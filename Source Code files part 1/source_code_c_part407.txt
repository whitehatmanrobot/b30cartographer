a
    );


DWORD
_CatDBMapJetError(
    JET_ERR         jerr);


BOOL
_CatDBJET_errFailure(
    JET_ERR         jerr);


BOOL
_CatDBInitJetDatabaseParams(
    JET_INSTANCE    *pJetInstance);


BOOL
_CatDBAttachAndOpenDatabase(
    JET_DB_STRUCT   *pJetDBStruct,
    BOOL            fReadOnly);


BOOL
_CatDBCloseDatabaseFile(
    PJET_DB_STRUCT  pJetDBStruct,
    BOOL            fDetach);

BOOL
_CatDBCatalogFileAlreadyInstalled(
    LPCWSTR pwszCatalogToBeAdded,
    LPCWSTR pwszExistingCatalog);

#define LOGEVENT_STRING_PARAMTYPE   1
#define LOGEVENT_INT_PARAMTYPE      2
#define LOGEVENT_NONE_PARAMTYPE     3


//
// VSS Writer prototypes
//
VOID
_SystemWriterInit(
    BOOL fUnInit);

//
// Use these for memory that is transferred across an LRPC call
//
extern "C"
{
extern void __RPC_FAR * __RPC_API midl_user_allocate(size_t len);
extern void __RPC_API midl_user_free(void __RPC_FAR * ptr);
extern void __RPC_FAR * __RPC_API midl_user_reallocate(void __RPC_FAR * ptr, size_t len);
}

//
// general allocation routines
//
void * _CatDBAlloc(size_t len)
{
    void *temp;

    temp = LocalAlloc(LMEM_ZEROINIT, len);

    if (temp == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    return(temp);
}

void * _CatDBReAlloc(void *p, size_t len)
{
    void *temp;

    temp = LocalReAlloc(p, len, LMEM_MOVEABLE | LMEM_ZEROINIT);

    if (temp == NULL)
    {
       SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    return(temp);
}

void _CatDBFree(void *p)
{
    if (p != NULL)
    {
        LocalFree(p);
    }
}


LPSTR
_CatDBGetCatrootDirA()
{
    LPSTR       pszTempPath = NULL;
    char        szDefaultSystemDir[MAX_PATH + 1];
    DWORD       dwLength;

    //
    // Get System default directory
    //
    szDefaultSystemDir[0] = NULL;
    if (0 == GetSystemDirectoryA(&szDefaultSystemDir[0], MAX_PATH))
    {
        CATDBSVC_LOGERR_LASTERR()
        return (NULL);
    }

    //
    // Calculate length
    //
    dwLength = strlen(szDefaultSystemDir) + strlen(SZ_DATABASE_FILE_BASE_DIRECTORY) + 3;

    //
    // Allocate space for the full path
    //
    if (NULL == (pszTempPath = (LPSTR) malloc(sizeof(char) * dwLength)))
    {
        CATDBSVC_SETERR_LOG_RETURN(ERROR_NOT_ENOUGH_MEMORY, ErrorMemory)
        return (NULL);
    }

    //
    // Make the path
    //
    strcpy(pszTempPath, szDefaultSystemDir);
    if ((pszTempPath[0]) &&
        (pszTempPath[strlen(&pszTempPath[0]) - 1] != '\\'))
    {
        strcat(pszTempPath, "\\");
    }

    strcat(pszTempPath, SZ_DATABASE_FILE_BASE_DIRECTORY);
    strcat(pszTempPath, "\\");

ErrorMemory:

    return (pszTempPath);
}


LPWSTR
_CatDBGetCatrootDirW(
    BOOL fCatroot2)
{
    LPWSTR      pwszTempPath = NULL;
    WCHAR       wszDefaultSystemDir[MAX_PATH + 1];
    DWORD       dwLength;

    //
    // Get System default directory
    //
    wszDefaultSystemDir[0] = NULL;
    if (0 == GetSystemDirectoryW(&wszDefaultSystemDir[0], MAX_PATH))
    {
        CATDBSVC_LOGERR_LASTERR()
        return (NULL);
    }

    //
    // Calculate length
    //
    dwLength = wcslen(wszDefaultSystemDir) + 3;
    if (fCatroot2)
    {
        dwLength += wcslen(WSZ_DATABASE_FILE_BASE_DIRECTORY);
    }
    else
    {
        dwLength += wcslen(WSZ_CATALOG_FILE_BASE_DIRECTORY);
    }

    //
    // Allocate space for the full path
    //
    if (NULL == (pwszTempPath = (LPWSTR) malloc(sizeof(WCHAR) * dwLength)))
    {
        CATDBSVC_SETERR_LOG_RETURN(ERROR_NOT_ENOUGH_MEMORY, ErrorMemory)
        return (NULL);
    }

    //
    // Make the path
    //
    wcscpy(pwszTempPath, wszDefaultSystemDir);
    if ((pwszTempPath[0]) &&
        (pwszTempPath[wcslen(&pwszTempPath[0]) - 1] != L'\\'))
    {
        wcscat(pwszTempPath, L"\\");
    }

    if (fCatroot2)
    {
        wcscat(pwszTempPath, WSZ_DATABASE_FILE_BASE_DIRECTORY);
    }
    else
    {
        wcscat(pwszTempPath, WSZ_CATALOG_FILE_BASE_DIRECTORY);
    }

    wcscat(pwszTempPath, L"\\");

ErrorMemory:

    return (pwszTempPath);
}


LPWSTR
_CatDBCreatePath(
    IN LPCWSTR   pwsz1,
    IN LPCWSTR   pwsz2)
{
    LPWSTR  pwszTemp    = NULL;
    int     nTotalLen   = 0;
    int     nLenStr1    = 0;

    //
    // Calculate the length of the resultant string as the sum of the length
    // of psz1, a '\', the length of psz2, and a NULL char
    //
    nLenStr1 = wcslen(pwsz1);
    nTotalLen = nLenStr1 + wcslen(pwsz2) + 2;

    //
    // Allocate the string and copy pwsz1 into the buffer
    //
    if (NULL == (pwszTemp = (LPWSTR) malloc(sizeof(WCHAR) * nTotalLen)))
    {
        CATDBSVC_SETERR_LOG_RETURN(ERROR_NOT_ENOUGH_MEMORY, ErrorReturn)
    }

    wcscpy(pwszTemp, pwsz1);

    //
    // Add the extra '\' if needed
    //
    if (pwsz1[nLenStr1 - 1] != L'\\')
    {
        wcscat(pwszTemp, L"\\");
    }

    //
    // Tack on psz2
    //
    wcscat(pwszTemp, pwsz2);

CommonReturn:

    return (pwszTemp);

ErrorReturn:

    goto CommonReturn;
}


BOOL
_CatDBDVerifyGUIDString(
    IN LPCWSTR pwszDatabaseGUID)
{
    LPCWSTR pszCompareString = L"{00000000-0000-0000-0000-000000000000}";
    DWORD i;

    if (wcslen(pwszDatabaseGUID) != wcslen(pszCompareString))
    {
        return (FALSE);
    }

    for (i=0; i<wcslen(pszCompareString); i++)
    {
        if (pszCompareString[i] == L'0')
        {
            if (!((pwszDatabaseGUID[i] >= '0') && (pwszDatabaseGUID[i] <= '9') ||
                  (pwszDatabaseGUID[i] >= 'a') && (pwszDatabaseGUID[i] <= 'f') ||
                  (pwszDatabaseGUID[i] >= 'A') && (pwszDatabaseGUID[i] <= 'F')))
            {
                return (FALSE);
            }
        }
        else
        {
            if (pszCompareString[i] != pwszDatabaseGUID[i])
            {
                return (FALSE);
            }
        }
    }

    return (TRUE);
}


BOOL
_CatDBFileNameOK(
    IN LPCWSTR pwszFileName)
{
    if (pwszFileName == NULL)
    {
        return (TRUE);
    }

    if (wcslen(pwszFileName) > 28)
    {
        return (FALSE);
    }

    return (TRUE);
}


BOOL
_CatDBDeleteFiles(
    IN LPCWSTR pwszPath,
    IN LPCWSTR pwszSearch)
{
    BOOL                fRet        = TRUE;
    HANDLE              hFindHandle = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW    FindData;
    DWORD               dwErr;
    LPWSTR              pwszDelete  = NULL;

    //
    // Do the initial find
    //
    hFindHandle = FindFirstFileW(pwszSearch, &FindData);
    if (hFindHandle == INVALID_HANDLE_VALUE)
    {
        //
        // See if a real error occurred, or just no files
        //
        dwErr = GetLastError();
        if ((dwErr == ERROR_NO_MORE_FILES)  ||
            (dwErr == ERROR_FILE_NOT_FOUND))
        {
            //
            // There are no files of this type to delete
            //
            return (TRUE);
        }
        else
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }
    }

    while (1)
    {
        //
        // Only care about files
        //
        if (!(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            pwszDelete = _CatDBCreatePath(pwszPath, FindData.cFileName);

            if (pwszDelete == NULL)
            {
                CATDBSVC_LOGERR_LASTERR()
                goto ErrorReturn;
            }

            if (!DeleteFileW(pwszDelete))
            {
                CATDBSVC_LOGERR_LASTERR()
                goto ErrorReturn;
            }

            free(pwszDelete);
            pwszDelete = NULL;
        }

        //
        // Get next file
        //
        if (!FindNextFileW(hFindHandle, &FindData))
        {
            if (GetLastError() == ERROR_NO_MORE_FILES)
            {
                break;
            }
            else
            {
                CATDBSVC_LOGERR_LASTERR()
                goto ErrorReturn;
            }
        }
    }

CommonReturn:

    if (pwszDelete != NULL)
    {
        free(pwszDelete);
    }

    return (fRet);

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;
}

BOOL
_CatDBDeleteJetFiles()
{
    BOOL                fRet         = TRUE;
    LPWSTR              pwszCatroot2 = NULL;
    LPWSTR              pwszDelete   = NULL;
    LPWSTR              pwszSearch   = NULL;
    LPWSTR              pwszPathName = NULL;
    HANDLE              hFindHandle  = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW    FindData;
    DWORD               dwErr;

    //
    // Get the directory where the jet files live
    //
    pwszCatroot2 = _CatDBGetCatrootDirW(TRUE);

    if (pwszCatroot2 == NULL)
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // build the search string for jet log files and delete them
    // (there are two forms of log files).
    //
    pwszDelete = _CatDBCreatePath(pwszCatroot2, L"edb*.log");

    if (pwszDelete == NULL)
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    if (!_CatDBDeleteFiles(pwszCatroot2, pwszDelete))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    free(pwszDelete);
    pwszDelete = NULL;

    pwszDelete = _CatDBCreatePath(pwszCatroot2, L"res*.log");

    if (pwszDelete == NULL)
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    if (!_CatDBDeleteFiles(pwszCatroot2, pwszDelete))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    free(pwszDelete);
    pwszDelete = NULL;

    //
    // Delete the "catdb" and "timestamp" files in each directory
    //

    //
    // Build a search string for catdb directories
    //
    pwszSearch = _CatDBCreatePath(pwszCatroot2, L"{????????????????????????????????????}");

    if (pwszSearch == NULL)
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Do the initial find
    //
    hFindHandle = FindFirstFileW(pwszSearch, &FindData);
    if (hFindHandle == INVALID_HANDLE_VALUE)
    {
        //
        // See if a real error occurred, or just no directories
        //
        dwErr = GetLastError();
        if ((dwErr == ERROR_NO_MORE_FILES)  ||
            (dwErr == ERROR_PATH_NOT_FOUND) ||
            (dwErr == ERROR_FILE_NOT_FOUND))
        {
            //
            // There are no directories of this form
            //
            goto CommonReturn;
        }
        else
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }
    }

    while (1)
    {
        //
        // Only care about directories
        //
        if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            pwszPathName = _CatDBCreatePath(pwszCatroot2, FindData.cFileName);

            if (pwszPathName == NULL)
            {
                CATDBSVC_LOGERR_LASTERR()
                goto ErrorReturn;
            }

            //
            // Delete the "catdb" file
            //
            pwszDelete = _CatDBCreatePath(pwszPathName, WSZ_DBFILE_NAME);

            if (pwszDelete == NULL)
            {
                CATDBSVC_LOGERR_LASTERR()
                goto ErrorReturn;
            }

            DeleteFileW(pwszDelete);

            free(pwszDelete);
            pwszDelete = NULL;

            //
            // Delete the "timestamp" file
            //
            pwszDelete = _CatDBCreatePath(pwszPathName, WSZ_TIME_STAMP_FILE);

            if (pwszDelete == NULL)
            {
                CATDBSVC_LOGERR_LASTERR()
                goto ErrorReturn;
            }

            DeleteFileW(pwszDelete);

            free(pwszDelete);
            pwszDelete = NULL;

            free(pwszPathName);
            pwszPathName = NULL;
        }

        //
        // Get next file
        //
        if (!FindNextFileW(hFindHandle, &FindData))
        {
            if (GetLastError() == ERROR_NO_MORE_FILES)
            {
                break;
            }
            else
            {
                CATDBSVC_LOGERR_LASTERR()
                goto ErrorReturn;
            }
        }
    }

CommonReturn:

    if (pwszCatroot2 != NULL)
    {
        free(pwszCatroot2);
    }

    if (pwszDelete != NULL)
    {
        free(pwszDelete);
    }

    if (pwszSearch != NULL)
    {
        free(pwszSearch);
    }

    if (pwszPathName != NULL)
    {
        free(pwszPathName);
    }

    return (fRet);

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;
}


BOOL
_CatDBRebuildDB(
    LPCWSTR pwszPathName,
    LPCWSTR pwszDatabaseGUID)
{
    BOOL                fRet                = TRUE;
    LPWSTR              pwszSearch          = NULL;
    LPWSTR              pwszCatalog         = NULL;
    HANDLE              hFindHandle         = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW    FindData;
    DWORD               dwErr;
    LPWSTR __RPC_FAR    pwszCatalogNameUsed = NULL;
    WCHAR               wszTempFile[MAX_PATH];
    JET_DB_STRUCT       *pJetDBStruct       = NULL;

    //
    // First, just make sure the database gets created by doing
    // an open and close
    //
    if (!_CatDBAcquireOpenDatabaseFromCache(
                &pJetDBStruct,
                pwszDatabaseGUID,
                FALSE,
                TRUE))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    _CatDBReleaseDatabaseToCache(pJetDBStruct);

    //
    // Find all catalogs in direcotry and add each one
    //

    //
    // Build a search string for catalog files
    //
    pwszSearch = _CatDBCreatePath(pwszPathName, L"*.cat");

    if (pwszSearch == NULL)
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Do the initial find
    //
    hFindHandle = FindFirstFileW(pwszSearch, &FindData);
    if (hFindHandle == INVALID_HANDLE_VALUE)
    {
        //
        // See if a real error occurred, or just no directories
        //
        dwErr = GetLastError();
        if ((dwErr == ERROR_NO_MORE_FILES)  ||
            (dwErr == ERROR_FILE_NOT_FOUND))
        {
            //
            // There are no files of this form
            //
            goto CommonReturn;
        }
        else
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }
    }

    //
    // Get a temporary file name which will be used to when adding each catalog
    //
    if (0 == GetTempFileNameW(
                    g_pwszCatalogFileBaseDirectory,
                    L"TMP",
                    0,
                    wszTempFile))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // GetTempFileName actually creates the file, so delete it
    //
    DeleteFileW(wszTempFile);

    while (1)
    {
        //
        // Only care about files
        //
        if (!(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            pwszCatalog = _CatDBCreatePath(pwszPathName, FindData.cFileName);

            if (pwszCatalog == NULL)
            {
                CATDBSVC_LOGERR_LASTERR()
                goto ErrorReturn;
            }

            //
            // Copy the catalog file to a temporary location and add it from there
            //
            if (!CopyFileW(pwszCatalog, wszTempFile, TRUE))
            {
                CATDBSVC_LOGERR_LASTERR()
                goto ErrorReturn;
            }

            _CatDBAddCatalog(
                    NULL,
                    0,
                    pwszDatabaseGUID,
                    wszTempFile,
                    FindData.cFileName,
                    TRUE,
                    &pwszCatalogNameUsed);

            DeleteFileW(wszTempFile);

            if (pwszCatalogNameUsed != NULL)
            {
                MIDL_user_free(pwszCatalogNameUsed);
                pwszCatalogNameUsed = NULL;
            }

            free(pwszCatalog);
            pwszCatalog = NULL;
        }

        //
        // Get next file
        //
        if (!FindNextFileW(hFindHandle, &FindData))
        {
            if (GetLastError() == ERROR_NO_MORE_FILES)
            {
                break;
            }
            else
            {
                CATDBSVC_LOGERR_LASTERR()
                goto ErrorReturn;
            }
        }
    }

CommonReturn:

    if (pwszSearch != NULL)
    {
        free(pwszSearch);
    }

    if (pwszCatalog != NULL)
    {
        free(pwszCatalog);
    }

    return (fRet);

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;
}


BOOL
_CatDBRebuildAllDBs()
{
    BOOL                fRet            = TRUE;
    LPWSTR              pwszCatroot     = NULL;
    LPWSTR              pwszSearch      = NULL;
    LPWSTR              pwszPathName    = NULL;
    HANDLE              hFindHandle     = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW    FindData;
    DWORD               dwErr;

    //
    // Get the directory where the catalog files live
    //
    pwszCatroot = _CatDBGetCatrootDirW(FALSE);

    if (pwszCatroot == NULL)
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Build a search string for the catalog directories
    //
    pwszSearch = _CatDBCreatePath(pwszCatroot, L"{????????????????????????????????????}");

    if (pwszSearch == NULL)
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Do the initial find
    //
    hFindHandle = FindFirstFileW(pwszSearch, &FindData);
    if (hFindHandle == INVALID_HANDLE_VALUE)
    {
        //
        // See if a real error occurred, or just no directories
        //
        dwErr = GetLastError();
        if ((dwErr == ERROR_NO_MORE_FILES)  ||
            (dwErr == ERROR_PATH_NOT_FOUND) ||
            (dwErr == ERROR_FILE_NOT_FOUND))
        {
            //
            // There are no directories of this form
            //
            goto CommonReturn;
        }
        else
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }
    }

    while (1)
    {
        //
        // Only care about directories
        //
        if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            pwszPathName = _CatDBCreatePath(pwszCatroot, FindData.cFileName);

            if (pwszPathName == NULL)
            {
                CATDBSVC_LOGERR_LASTERR()
                goto ErrorReturn;
            }

            if (!_CatDBRebuildDB(pwszPathName, FindData.cFileName))
            {
                CATDBSVC_LOGERR_LASTERR()
                goto ErrorReturn;
            }

            free(pwszPathName);
            pwszPathName = NULL;
        }

        //
        // Get next file
        //
        if (!FindNextFileW(hFindHandle, &FindData))
        {
            if (GetLastError() == ERROR_NO_MORE_FILES)
            {
                break;
            }
            else
            {
                CATDBSVC_LOGERR_LASTERR()
                goto ErrorReturn;
            }
        }
    }

CommonReturn:

    if (pwszCatroot != NULL)
    {
        free(pwszCatroot);
    }

    if (pwszSearch != NULL)
    {
        free(pwszSearch);
    }

    if (pwszPathName != NULL)
    {
        free(pwszPathName);
    }

    return (fRet);

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;
}


/////////////////////////////////////////////////////////////////////////////////////////
//
// LPC-exposed functions
//
// these functions return a DWORD equivalent to GetLastError().  The client side stub
// code will check if the return code is not ERROR_SUCCESS, and if this is the case,
// the client stub will return FALSE and SetLastError() to this DWORD.
//
/////////////////////////////////////////////////////////////////////////////////////////

DWORD _CatDBAddCatalog(
    handle_t h,
    DWORD dwFlags,
    LPCWSTR pwszSubSysGUID,
    LPCWSTR pwszCatalogFile,
    LPCWSTR pwszCatName,
    BOOL fInRecursiveCall,
    LPWSTR __RPC_FAR *ppwszCatalogNameUsed)
{
    DWORD           dwRet                               = ERROR_SUCCESS;
    RPC_STATUS      RpcStatus;
    LPWSTR          pwszCatalogFileDir                  = NULL;
    BOOL            fImpersonating                      = FALSE;
    JET_DB_STRUCT   *pJetDBStruct                       = NULL;
    BOOL            fCatalogDatabaseAcquiredFromCache   = FALSE;
    PCCTL_CONTEXT   pCTLContext                         = NULL;
    LPWSTR          pwszNewCatalogName                  = NULL;
    HANDLE          hMappedFile                         = NULL;
    BYTE            *pbMappedFile                       = NULL;
    BOOL            fTransactionBegun                   = FALSE;
    BOOL            fFileAlreadyExists                  = FALSE;
    WCHAR           wszTempFile[MAX_PATH];
    JET_ERR         jerr;
    BOOL            fTempFileCreated                    = FALSE;

    //
    // Initialize out param
    //
    *ppwszCatalogNameUsed = NULL;

    //
    // Only allow one add or delete at a time
    //
    EnterCriticalSection(&g_CatDBAddDeleteCS);

    //
    // Impersonate client if needed
    //
    if (h != NULL)
    {
        if (RPC_S_OK != (RpcStatus = RpcImpersonateClient(h)))
        {
            CATDBSVC_SETERR_LOG_RETURN(RpcStatus, ErrorImpersonateClient);
        }

        fImpersonating = TRUE;
    }

    //
    // Create the path to the catalog files
    //
    if (NULL == (pwszCatalogFileDir = _CATDBConstructWSTRPath(
                                            g_pwszCatalogFileBaseDirectory,
                                            pwszSubSysGUID)))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Get the fully qualified path name of the new catalog file
    //
    if (NULL == (pwszNewCatalogName = _CatDBCreateNewCatalogFileName(
                                            pwszCatalogFileDir,
                                            pwszCatName,
                                            &fFileAlreadyExists)))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    if (NULL == (*ppwszCatalogNameUsed = (LPWSTR)
                    midl_user_allocate((wcslen(pwszNewCatalogName) + 1) * sizeof(WCHAR))))
    {
        CATDBSVC_SETERR_LOG_RETURN(ERROR_NOT_ENOUGH_MEMORY, ErrorMemory)
    }
    wcscpy(*ppwszCatalogNameUsed, pwszNewCatalogName);

    //
    // Open a CTL context on the catalog being added
    //
    if (!CatUtil_CreateCTLContextFromFileName(
            pwszCatalogFile,
            &hMappedFile,
            &pbMappedFile,
            &pCTLContext,
            FALSE))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // If we are replacing an existing catalog, save a copy of the old one
    // in case the commit fails
    //
    if (fFileAlreadyExists)
    {
        if (0 == GetTempFileNameW(
                        g_pwszCatalogFileBaseDirectory,
                        L"TMP",
                        0,
                        wszTempFile))
        {
            //
            // If the entries couldn't be deleted because the user doesn't
            // have write rights, then do a check to see if the catalog
            // they are trying to add already exists, if it does, then
            // retrun ERROR_ALREADY_EXISTS instead of ACCESS_DENIED
            //
            if (GetLastError() == ERROR_ACCESS_DENIED)
            {
                if (_CatDBCatalogFileAlreadyInstalled(
                            pwszCatalogFile,
                            pwszNewCatalogName))
                {
                    SetLastError(ERROR_ALREADY_EXISTS);
                    goto ErrorReturn;
                }
            }
            else
            {
                CATDBSVC_LOGERR_LASTERR()
                goto ErrorGetTempFileName;
            }
        }

        //
        // Copy the old catalog file to a temporary location
        //
        if (!CopyFileW(pwszNewCatalogName, wszTempFile, FALSE))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorCopyFile;
        }
        fTempFileCreated = TRUE;
    }

    //
    // Open the database file
    //
    if (!_CatDBAcquireOpenDatabaseFromCache(
                &pJetDBStruct,
                pwszSubSysGUID,
                FALSE,
                fInRecursiveCall))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }
    fCatalogDatabaseAcquiredFromCache = TRUE;

    //
    // Start transaction
    //
    if (_CatDBJET_errFailure(jerr  =
            JetBeginTransaction(pJetDBStruct->JetSesID)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetBeginTransaction)
    }
    fTransactionBegun = TRUE;

    if (fFileAlreadyExists)
    {
        if (!_CatDBDeleteCatalogEntriesFromDatabase(
                pJetDBStruct,
                pwszNewCatalogName))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }
    }

    //
    // Add the new DB entries
    //
    if (!_CatDBAddCatalogEntriesToDatabase(
            pJetDBStruct,
            pCTLContext,
            pwszNewCatalogName))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Don't need the CTL context anymore
    //
    CertFreeCTLContext(pCTLContext);
    pCTLContext = NULL;
    UnmapViewOfFile(pbMappedFile);
    pbMappedFile = NULL;
    CloseHandle(hMappedFile);
    hMappedFile = NULL;

    //
    // Now, copy the new catalog file to its location
    //
    if (!CopyFileW(pwszCatalogFile, pwszNewCatalogName, FALSE))
    {
        if (!fFileAlreadyExists)
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorCopyFile;
        }

        //
        // Since that failed, try renaming the destination file, and then re-copy.
        // BTW, the above copy will fail if another client already has the
        // destination file memory mapped in their catalog cache.
        //
        if (!_CatDBMoveInUseFileToTempLocation(pwszNewCatalogName))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        //
        // Now, retry the copy... this better work!
        //
        if (!CopyFileW(pwszCatalogFile, pwszNewCatalogName, FALSE))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorCopyFile;
        }
    }
    SetFileAttributesW(pwszNewCatalogName, FILE_ATTRIBUTE_SYSTEM);

    //
    // At this stage do the commit.
    //
    if (_CatDBJET_errFailure(jerr  =
            JetCommitTransaction(
                pJetDBStruct->JetSesID,
                0)))
    {
        //
        // Since there was an error doing the commit, copy back the original
        // catalog file
        //
        if (0 == CopyFileW(wszTempFile, pwszNewCatalogName, FALSE))
        {
            // THE ABOVE COPY FAILED... THE DATABASE IS NOW INCONSISTENT!!!!!
            CATDBSVC_LOGERR_LASTERR()
        }
        else
        {
            SetFileAttributesW(pwszNewCatalogName, FILE_ATTRIBUTE_SYSTEM);
        }

        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetCommitTransaction)
    }
    fTransactionBegun = FALSE;

    _CatDBTouchTimeStampFile(pwszSubSysGUID);

    //
    // Release DB back to the cache
    //
    _CatDBReleaseDatabaseToCache(pJetDBStruct);

    //
    // Notify client of changes
    //
    _CatDBNotifyClients();

CommonReturn:

    if (fTempFileCreated)
    {
        DeleteFileW(wszTempFile);
    }

    if (pwszNewCatalogName != NULL)
    {
        _CatDBFree(pwszNewCatalogName);
    }

    if (pwszCatalogFileDir != NULL)
    {
        _CatDBFree(pwszCatalogFileDir);
    }

    if (pCTLContext != NULL)
    {
        CertFreeCTLContext(pCTLContext);
    }

    if (pbMappedFile != NULL)
    {
        UnmapViewOfFile(pbMappedFile);
    }

    if (hMappedFile != NULL)
    {
        CloseHandle(hMappedFile);
    }

    if (fImpersonating)
    {
        if (RPC_S_OK != (RpcStatus = RpcRevertToSelf()))
        {
            MyLogErrorMessage((DWORD) RpcStatus, MSG_KEYSVC_REVERT_TO_SELF_FAILED);
        }
    }

    LeaveCriticalSection(&g_CatDBAddDeleteCS);

    return dwRet;

ErrorReturn:

    dwRet = GetLastError();

    if (0 == dwRet)
    {
        dwRet = (DWORD) E_UNEXPECTED;
    }

    if (fTransactionBegun)
    {
        JetRollback(pJetDBStruct->JetSesID, 0);
    }

    if (fCatalogDatabaseAcquiredFromCache)
    {
        _CatDBReleaseDatabaseToCache(pJetDBStruct);
    }

    if (*ppwszCatalogNameUsed != NULL)
    {
        midl_user_free(*ppwszCatalogNameUsed);
        *ppwszCatalogNameUsed = NULL;
    }

    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorImpersonateClient)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetBeginTransaction)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetCommitTransaction)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorMemory)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorCopyFile)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorGetTempFileName)
}

DWORD s_SSCatDBAddCatalog(
    /* [in] */ handle_t h,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pwszSubSysGUID,
    /* [in] */ LPCWSTR pwszCatalogFile,
    /* [unique][in] */ LPCWSTR pwszCatName,
    /* [out] */ LPWSTR __RPC_FAR *ppwszCatalogNameUsed)
{
    DWORD   dwRet;

    if (!_CatDBClientEnter())
    {
        CATDBSVC_LOGERR_LASTERR()
        return (GetLastError());
    }

    //
    // Check input params
    //
    if ((h == NULL) ||
        (!_CatDBDVerifyGUIDString(pwszSubSysGUID)) ||
        (!_CatDBFileNameOK(pwszCatName)))
    {
        CATDBSVC_SETERR_LOG_RETURN(ERROR_BAD_ARGUMENTS, ErrorReturn)
    }

    dwRet = _CatDBAddCatalog(
                    h,
                    dwFlags,
                    pwszSubSysGUID,
                    pwszCatalogFile,
                    pwszCatName,
                    FALSE,
                    ppwszCatalogNameUsed);

    _CatDBClientExit();

CommonReturn:

    return (dwRet);

ErrorReturn:

    dwRet = GetLastError();
    goto CommonReturn;
}


DWORD s_SSCatDBDeleteCatalog(
    /* [in] */ handle_t h,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pwszSubSysGUID,
    /* [in] */ LPCWSTR pwszCatalogFile)
{
    DWORD           dwRet                               = 0;
    RPC_STATUS      RpcStatus;
    BOOL            fImpersonating                      = FALSE;
    JET_DB_STRUCT   *pJetDBStruct                       = NULL;
    BOOL            fCatalogDatabaseAcquiredFromCache   = FALSE;
    JET_ERR         jerr;
    LPWSTR          pwszCatalogFileFullPath             = NULL;
    BOOL            fTransactionBegun                   = FALSE;
    LPWSTR          pwszCatalogFileDir                  = NULL;

    if (!_CatDBClientEnter())
    {
        CATDBSVC_LOGERR_LASTERR()
        return (GetLastError());
    }

    //
    // Check input params
    //
    if ((h == NULL) ||
        (!_CatDBDVerifyGUIDString(pwszSubSysGUID)))
    {
        return (ERROR_BAD_ARGUMENTS);
    }

    //
    // Only allow one add or delete at a time
    //
    EnterCriticalSection(&g_CatDBAddDeleteCS);

    //
    // Impersonate client
    //
    if (RPC_S_OK != (RpcStatus = RpcImpersonateClient(h)))
    {
        CATDBSVC_SETERR_LOG_RETURN(RpcStatus, ErrorImpersonateClient)
    }
    fImpersonating = TRUE;

    //
    // Create the path to the catalog files
    //
    if (NULL == (pwszCatalogFileDir = _CATDBConstructWSTRPath(
                                            g_pwszCatalogFileBaseDirectory,
                                            pwszSubSysGUID)))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Construct full path to catalog being deleted
    //
    if (NULL == (pwszCatalogFileFullPath =
            _CATDBConstructWSTRPath(pwszCatalogFileDir, pwszCatalogFile)))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Open the database file
    //
    if (!_CatDBAcquireOpenDatabaseFromCache(
                &pJetDBStruct,
                pwszSubSysGUID,
                FALSE,
                FALSE))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }
    fCatalogDatabaseAcquiredFromCache = TRUE;

    //
    // Start transaction
    //
    if (_CatDBJET_errFailure(jerr  =
            JetBeginTransaction(pJetDBStruct->JetSesID)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetBeginTransaction)
    }
    fTransactionBegun = TRUE;

    //
    // Delete the entries of the catalog file from the DB
    //
    if (!_CatDBDeleteCatalogEntriesFromDatabase(
                pJetDBStruct,
                pwszCatalogFileFullPath))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // At this stage do the commit.
    //
    if (_CatDBJET_errFailure(jerr  =
            JetCommitTransaction(
                pJetDBStruct->JetSesID,
                0)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetCommitTransaction)
    }
    fTransactionBegun = FALSE;

    if (!DeleteFileW(pwszCatalogFileFullPath))
    {
        //
        // Maybe the delete failed since the file doesn't even exist
        //
        if (GetLastError() != ERROR_FILE_NOT_FOUND)
        {
            //
            // If the delete failed for a reason other than NOT_FOUND
            // then another client is probably already accessing the file,
            // so just copy it to a temp location and log it for deletion
            //
            if (!_CatDBMoveInUseFileToTempLocation(pwszCatalogFileFullPath))
            {
                CATDBSVC_LOGERR_LASTERR()

                //
                // Don't return an error, since this isn't fatal
                //
            }
        }
    }

    //
    // Release DB back to the cache
    //
    _CatDBReleaseDatabaseToCache(pJetDBStruct);

    //
    // Notify client of changes
    //
    _CatDBNotifyClients();

    _CatDBTouchTimeStampFile(pwszSubSysGUID);

CommonReturn:

    if (pwszCatalogFileFullPath != NULL)
    {
        _CatDBFree(pwszCatalogFileFullPath);
    }

    if (pwszCatalogFileDir != NULL)
    {
        _CatDBFree(pwszCatalogFileDir);
    }

    if(fImpersonating)
    {
        if (RPC_S_OK != (RpcStatus = RpcRevertToSelf()))
        {
            MyLogErrorMessage((DWORD) RpcStatus, MSG_KEYSVC_REVERT_TO_SELF_FAILED);
        }
    }

    LeaveCriticalSection(&g_CatDBAddDeleteCS);

    _CatDBClientExit();

    return dwRet;

ErrorReturn:

    dwRet = GetLastError();

    if (0 == dwRet)
    {
        dwRet = (DWORD) E_UNEXPECTED;
    }

    if (fTransactionBegun)
    {
        JetRollback(pJetDBStruct->JetSesID, 0);
    }

    if (fCatalogDatabaseAcquiredFromCache)
    {
        _CatDBReleaseDatabaseToCache(pJetDBStruct);
    }

    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorImpersonateClient)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetBeginTransaction)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetCommitTransaction)
}


DWORD s_SSCatDBEnumCatalogs(
    /* [in] */ handle_t h,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pwszSubSysGUID,
    /* [in] */ DWORD cbHash,
    /* [size_is][in] */ BYTE __RPC_FAR *pbHash,
    /* [out] */ DWORD __RPC_FAR *pdwNumCatalogNames,
    /* [size_is][size_is][out] */ LPWSTR __RPC_FAR *__RPC_FAR *pppwszCatalogNames)
{
    DWORD           dwRet                               = ERROR_SUCCESS;
    JET_DB_STRUCT   *pJetDBStruct;
    JET_ERR         jerr;
    BOOL            fCatalogDatabaseAcquiredFromCache   = FALSE;
    CRYPT_HASH_BLOB HashBlob;
    JET_RETINFO     JetRetInfo;
    WCHAR           wszCatalogName[CATDB_MAX_CATNAME_LENGTH];
    DWORD           dwLength;
    DWORD           i;

    if (!_CatDBClientEnter())
    {
        CATDBSVC_LOGERR_LASTERR()
        return (GetLastError());
    }

    if ((h == NULL) ||
        (!_CatDBDVerifyGUIDString(pwszSubSysGUID)))
    {
        CATDBSVC_SETERR_LOG_RETURN(ERROR_BAD_ARGUMENTS, ErrorInvalidArg)
    }

    //
    // Init out vars
    //
    *pdwNumCatalogNames = 0;
    *pppwszCatalogNames = NULL;

    //
    // Open the database file
    //
    if (!_CatDBAcquireOpenDatabaseFromCache(
                &pJetDBStruct,
                pwszSubSysGUID,
                TRUE,
                FALSE))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }
    fCatalogDatabaseAcquiredFromCache = TRUE;

    //
    // Try to find the hash
    //
    HashBlob.pbData = pbHash;
    HashBlob.cbData = cbHash;
    jerr = _CatDBSeekInHashCatNameTable(pJetDBStruct, &HashBlob);

    if (jerr == JET_errSuccess)
    {
        //
        // Add all names from the Hashes CatNameList, plus all the buddys
        // of those CatNames
        //
        // NOTE: the order in which the CatNames are added to the list results in
        // only the first CatName of the list being guaranteed to contain the
        // hash... all other CatNames may or may not contain the hash.  This
        // is OK because the client side code only assumes the first CatName
        // contains the hash, and then explicitly searches all others for the hash.
        //
        memset(&JetRetInfo, 0, sizeof(JetRetInfo));
        JetRetInfo.cbStruct = sizeof(JetRetInfo);
        JetRetInfo.itagSequence = 1;
        jerr = JetRetrieveColumn(
                    pJetDBStruct->JetSesID,
                    pJetDBStruct->JetHashCatNameTableID,
                    pJetDBStruct->JetHashCatNameTable_CatNameColumnID,
                    wszCatalogName,
                    CATDB_MAX_CATNAME_LENGTH,
                    &dwLength,
                    JET_bitRetrieveCopy,
                    &JetRetInfo);

        while (jerr == JET_errSuccess)
        {
            if (!_CatDBAddCatNameAndCatNamesBuddyListToReturnCatNames(
                        pJetDBStruct,
                        wszCatalogName,
                        pdwNumCatalogNames,
                        pppwszCatalogNames,
                        FALSE))
            {
                CATDBSVC_LOGERR_LASTERR()
                goto ErrorReturn;
            }

            //
            // Setup for next loop
            //
            JetRetInfo.itagSequence++;
            jerr = JetRetrieveColumn(
                        pJetDBStruct->JetSesID,
                        pJetDBStruct->JetHashCatNameTableID,
                        pJetDBStruct->JetHashCatNameTable_CatNameColumnID,
                        wszCatalogName,
                        CATDB_MAX_CATNAME_LENGTH,
                        &dwLength,
                        JET_bitRetrieveCopy,
                        &JetRetInfo);
        }

        //
        // Check to see if a real error occurred and not just a JET_wrnColumnNull
        //
        if (_CatDBJET_errFailure(jerr))
        {
            CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
        }
    }
    else if ((jerr != JET_errRecordNotFound) && _CatDBJET_errFailure(jerr))
    {
        //
        // Some real error occurred
        //
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

CommonReturn:

    if (fCatalogDatabaseAcquiredFromCache)
    {
        _CatDBReleaseDatabaseToCache(pJetDBStruct);
    }

    _CatDBClientExit();

    return dwRet;

ErrorReturn:

    dwRet = GetLastError();

    if (0 == dwRet)
    {
        dwRet = (DWORD) E_UNEXPECTED;
    }

    for (i=0; i<(*pdwNumCatalogNames); i++)
    {
        midl_user_free((*pppwszCatalogNames)[i]);
    }

    if ((*pppwszCatalogNames) != NULL)
    {
        midl_user_free(*pppwszCatalogNames);
        *pppwszCatalogNames = NULL;
    }
    *pdwNumCatalogNames = 0;

    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorInvalidArg)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetDatabase)
}


//---------------------------------------------------------------------------------------
//
//  _CatDBProcessExitCallback
//
//---------------------------------------------------------------------------------------
VOID CALLBACK
_CatDBProcessExitCallback(
    PVOID lpParameter,
    BOOLEAN TimerOrWaitFired)
{
    LONG    lNotificationID = PtrToLong(lpParameter);
    DWORD   i;

    EnterCriticalSection(&g_CatDBRegisterNotifyCS);

    //
    // Search through the array to make sure the handle wasn't already unregistered
    //
    i = 0;
    while ( (i < g_NumNotificationStructs) &&
            (g_rgNotificationStructs[i].lNotificationID != lNotificationID))
    {
        i++;
    }

    //
    // If it was found, then clean it up.
    //
    if (i < g_NumNotificationStructs)
    {
        g_rgNotificationStructs[i].ProcessID = 0;

        CloseHandle(g_rgNotificationStructs[i].hClientProcess);
        g_rgNotificationStructs[i].hClientProcess = NULL;

        UnregisterWait(g_rgNotificationStructs[i].hRegisterWaitFor);
        g_rgNotificationStructs[i].hRegisterWaitFor = NULL;

        g_rgNotificationStructs[i].hNotificationHandle = INVALID_HANDLE_VALUE;

        CloseHandle(g_rgNotificationStructs[i].hDuplicatedNotificationHandle);
        g_rgNotificationStructs[i].hDuplicatedNotificationHandle =
                INVALID_HANDLE_VALUE;

        g_rgNotificationStructs[i].lNotificationID = 0;
    }

    LeaveCriticalSection(&g_CatDBRegisterNotifyCS);
}


DWORD s_SSCatDBRegisterForChangeNotification(
    /* [in] */ handle_t h,
    /* [in] */ DWORD_PTR EventHandle,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pwszSubSysGUID,
    /* [in] */ BOOL fUnRegister)
{
    DWORD               dwRet                   = ERROR_SUCCESS;
    RPC_STATUS          RpcStatus;
    HANDLE              hDuplicate              = INVALID_HANDLE_VALUE;
    DWORD               i, j;
    HANDLE              hWaitForToUnregister    = NULL;
    HANDLE              hClientProcess          = NULL;
    LONG                lLocalNotificationID    = 0;
    BOOL                fCSEntered              = FALSE;
    DWORD               dwPID                   = 0;
    NOTIFICATION_STRUCT *rghTemp;

    if (!_CatDBClientEnter())
    {
        CATDBSVC_LOGERR_LASTERR()
        return (GetLastError());
    }

    if ((h == NULL) ||
        (!_CatDBDVerifyGUIDString(pwszSubSysGUID)))
    {
        return (ERROR_BAD_ARGUMENTS);
    }

    if (RPC_S_OK != (RpcStatus = I_RpcBindingInqLocalClientPID(h, &dwPID)))
    {
        CATDBSVC_LOGERR(RpcStatus)
        return (ERROR_BAD_ARGUMENTS);
    }

    //
    // NOTE: this is a implementation that just notifies
    // all clients when an add/delete catalog occurs... regardless
    // of what catalog sub-system has been modified and what sub-system
    // the client is operating in.  Because of this implementation
    // pwszCatalogDir is NOT USED.  If this changes, the client side code
    // will also need to change.  See the NOTE in the
    // _CatAdminRegisterForChangeNotification() function of catadnew.cpp
    //

    EnterCriticalSection(&g_CatDBRegisterNotifyCS);
    fCSEntered = TRUE;

    //
    // First check to see whether we are registering or unregestering
    //
    if (!fUnRegister)
    {
        //
        // Make sure we can get a slot to add the handle to
        //
        i = 0;
        while ( (i < g_NumNotificationStructs) &&
                (g_rgNotificationStructs[i].hClientProcess != NULL))
        {
            i++;
        }

        //
        // If no space, allocate more
        //
        if (i >= g_NumNotificationStructs)
        {
            if (g_NumNotificationStructs == 0)
            {
                //
                // None allocated yet, so allocate and initialize
                //
                if (NULL == (g_rgNotificationStructs = (NOTIFICATION_STRUCT *)
                                    _CatDBAlloc(sizeof(NOTIFICATION_STRUCT) *
                                                ALLOCATION_BLOCK_SIZE)))
                {
                    CATDBSVC_LOGERR_LASTERR()
                    goto ErrorMemory;
                }

                g_NumNotificationStructs = ALLOCATION_BLOCK_SIZE;

                for (j = 0; j < g_NumNotificationStructs; j++)
                {
                    g_rgNotificationStructs[j].ProcessID = 0;

                    g_rgNotificationStructs[j].hClientProcess = NULL;

                    g_rgNotificationStructs[j].hRegisterWaitFor = NULL;

                    g_rgNotificationStructs[j].hNotificationHandle =
                            INVALID_HANDLE_VALUE;

                    g_rgNotificationStructs[j].hDuplicatedNotificationHandle =
                            INVALID_HANDLE_VALUE;

                    g_rgNotificationStructs[j].lNotificationID = 0;
                }

                // set i so it can just be used as open slot
                i = 0;
            }
            else
            {
                rghTemp = g_rgNotificationStructs;

                if (NULL == (g_rgNotificationStructs = (NOTIFICATION_STRUCT *)
                                    _CatDBReAlloc(g_rgNotificationStructs,
                                                  sizeof(NOTIFICATION_STRUCT) *
                                                        (g_NumNotificationStructs +
                                                        ALLOCATION_BLOCK_SIZE))))
                {
                    g_rgNotificationStructs = rghTemp;
                    CATDBSVC_LOGERR_LASTERR()
                    goto ErrorMemory;
                }

                for (   j = g_NumNotificationStructs;
                        j < (g_NumNotificationStructs + ALLOCATION_BLOCK_SIZE);
                        j++)
                {
                    g_rgNotificationStructs[j].ProcessID = 0;

                    g_rgNotificationStructs[j].hClientProcess = NULL;

                    g_rgNotificationStructs[j].hRegisterWaitFor = NULL;

                    g_rgNotificationStructs[j].hNotificationHandle =
                            INVALID_HANDLE_VALUE;

                    g_rgNotificationStructs[j].hDuplicatedNotificationHandle =
                            INVALID_HANDLE_VALUE;

                    g_rgNotificationStructs[j].lNotificationID = 0;
                }

                // set i so it can just be used as open slot
                i = g_NumNotificationStructs;

                g_NumNotificationStructs += ALLOCATION_BLOCK_SIZE;
            }
        }

        //
        // Open the process' handle that is registering a notification since we need
        // the process handle to duplicate the event handle that they want signaled,
        // plus, we wait on it in case of process exit
        //
        if (NULL == (hClientProcess = OpenProcess(
                                        PROCESS_DUP_HANDLE | SYNCHRONIZE,
                                        FALSE,
                                        dwPID)))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorOpenProcess;
        }

        //
        // Duplicate the handle
        //
        if (0 == (DuplicateHandle(
                        hClientProcess,
                        (HANDLE) EventHandle,
                        GetCurrentProcess(),
                        &hDuplicate,
                        EVENT_MODIFY_STATE, //0,
                        FALSE,
                        0))) //DUPLICATE_SAME_ACCESS)))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorDuplicateHandle;
        }

        //
        // Register a callback in case the process exits without unregistering
        //
        lLocalNotificationID = InterlockedIncrement(&g_lNotificationID);

        if (!RegisterWaitForSingleObject(
                &(g_rgNotificationStructs[i].hRegisterWaitFor),
                hClientProcess,
                _CatDBProcessExitCallback,
                ULongToPtr(lLocalNotificationID),   // use ULongToPtr instead of LongToPtr because
                                                    // ULongToPtr zero extends instead of sign extends
                INFINITE,
                WT_EXECUTEDEFAULT | WT_EXECUTEONLYONCE))
        {

            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        g_rgNotificationStructs[i].ProcessID = dwPID;

        g_rgNotificationStructs[i].hClientProcess = hClientProcess;
        hClientProcess = NULL;

        g_rgNotificationStructs[i].hNotificationHandle = (HANDLE) EventHandle;

        g_rgNotificationStructs[i].hDuplicatedNotificationHandle = hDuplicate;
        hDuplicate = INVALID_HANDLE_VALUE;

        g_rgNotificationStructs[i].lNotificationID = lLocalNotificationID;
    }
    else
    {
        //
        // Search through the array to find the handle being unregisterd
        //
        i = 0;
        while (i < g_NumNotificationStructs)
        {
            //
            // Match client based on ProcessID And EventHandle which is a unique pair
            //
            if ((g_rgNotificationStructs[i].hNotificationHandle == (HANDLE) EventHandle) &&
                (g_rgNotificationStructs[i].ProcessID == dwPID))
            {
                break;
            }

            i++;
        }

        //
        // Make sure we found the handle
        //
        if (i < g_NumNotificationStructs)
        {
            g_rgNotificationStructs[i].ProcessID = 0;

            hWaitForToUnregister = g_rgNotificationStructs[i].hRegisterWaitFor;
            g_rgNotificationStructs[i].hRegisterWaitFor = NULL;

            hClientProcess = g_rgNotificationStructs[i].hClientProcess;
            g_rgNotificationStructs[i].hClientProcess = NULL;

            g_rgNotificationStructs[i].hNotificationHandle = INVALID_HANDLE_VALUE;

            CloseHandle(g_rgNotificationStructs[i].hDuplicatedNotificationHandle);
            g_rgNotificationStructs[i].hDuplicatedNotificationHandle =
                    INVALID_HANDLE_VALUE;

            g_rgNotificationStructs[i].lNotificationID = 0;

            //
            // Leave the RegisterNotitifyCS before calling UnregisterWait()
            //
            LeaveCriticalSection(&g_CatDBRegisterNotifyCS);
            fCSEntered = FALSE;

            UnregisterWaitEx(hWaitForToUnregister, INVALID_HANDLE_VALUE);
            CloseHandle(hClientProcess);
            hClientProcess = NULL;
        }
    }

CommonReturn:

    if (fCSEntered)
    {
        LeaveCriticalSection(&g_CatDBRegisterNotifyCS);
    }

    if (hClientProcess != NULL)
    {
        CloseHandle(hClientProcess);
    }

    if (hDuplicate != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hDuplicate);
    }

    _CatDBClientExit();

    return dwRet;

ErrorReturn:

    dwRet = GetLastError();

    if (0 == dwRet)
    {
        dwRet = (DWORD) E_UNEXPECTED;
    }

    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorMemory)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorOpenProcess)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorDuplicateHandle)
}


#define CATDB_RETRY_PAUSE_COUNT     10
#define CATDB_PAUSE_RETRY_INTERNVAL 1000

DWORD s_SSCatDBPauseResumeService(
    /* [in] */ handle_t h,
    /* [in] */ DWORD dwFlags,
    /* [in] */ BOOL fResume)
{
    return (ERROR_CALL_NOT_IMPLEMENTED);
}



/////////////////////////////////////////////////////////////////////////////////////////
//
// Supporting functions
//
/////////////////////////////////////////////////////////////////////////////////////////


//---------------------------------------------------------------------------------------
//
//  _CatDBServiceInit
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBServiceInit(BOOL fUnInit)
{
    BOOL                        fRet                                = TRUE;
    DWORD                       dwErr                               = 0;
    HKEY                        hKey;
    DWORD                       dwDisposition;
    WCHAR                       wszDefaultSystemDir[MAX_PATH + 1];
    DWORD                       dwType;
    DWORD                       dwValue                             = 0;
    DWORD                       cbSize;
    DWORD                       NumCritSecsInitialized              = 0;
    PVOID                       pvoid                               = NULL;

    if (fUnInit && g_fDBSvcInitialized)
    {
        EnterCriticalSection(&g_CatDirCashCS);
        g_fShuttingDown = TRUE;
        LeaveCriticalSection(&g_CatDirCashCS);

        //
        // Close down the VSS writer object
        //
        _SystemWriterInit(TRUE);

        _CatDBCleanupClientNotifications();

        //
        // Wait for the registered callback to be completed
        //
        pvoid = InterlockedExchangePointer(
                    &g_hRegisterWaitForServiceShutdown,
                    NULL);

        if (pvoid != NULL)
        {
            UnregisterWaitEx((HANDLE) pvoid, INVALID_HANDLE_VALUE);
        }

        CloseHandle(g_hCatalogCacheCallbackEvent);
        g_hCatalogCacheCallbackEvent = NULL;

        //
        // Cleanup the cached catalog dirs
        //
        if (!_CatDBCloseCachedDatabases(TRUE))
        {
            CATDBSVC_LOGERR_LASTERR()
            //
            // Nothing we can do but log an error
            //
        }

        _CatDBTermJet();

        CloseHandle(g_hNotFrozen);
        g_hNotFrozen = NULL;

        if (g_pwszCatalogFileBaseDirectory != NULL)
        {
            _CatDBFree(g_pwszCatalogFileBaseDirectory);
            g_pwszCatalogFileBaseDirectory = NULL;
        }

        if (g_pwszDatabaseFileBaseDirectory != NULL)
        {
            _CatDBFree(g_pwszDatabaseFileBaseDirectory);
            g_pwszDatabaseFileBaseDirectory = NULL;
        }

        DeleteCriticalSection(&g_CatDBAddDeleteCS);
        DeleteCriticalSection(&g_CatDBRegisterNotifyCS);
        DeleteCriticalSection(&g_CatDirCashCS);
        DeleteCriticalSection(&g_CatClientCountCS);
        DeleteCriticalSection(&g_InitializeJetCS);
        DeleteCriticalSection(&g_WaitOrTimerCallbackCS);

        g_fDBSvcInitialized = FALSE;
    }
    else if (!fUnInit)
    {
        g_fShuttingDown = FALSE;

        __try
        {
            InitializeCriticalSection(&g_CatDBAddDeleteCS);
            NumCritSecsInitialized++;
            InitializeCriticalSection(&g_CatDBRegisterNotifyCS);
            NumCritSecsInitialized++;
            InitializeCriticalSection(&g_CatDirCashCS);
            NumCritSecsInitialized++;
            InitializeCriticalSection(&g_CatClientCountCS);
            NumCritSecsInitialized++;
            InitializeCriticalSection(&g_InitializeJetCS);
            NumCritSecsInitialized++;
            InitializeCriticalSection(&g_WaitOrTimerCallbackCS);
            NumCritSecsInitialized++;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            SetLastError(GetExceptionCode());
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        //
        // Get System default directory
        //
        wszDefaultSystemDir[0] = NULL;
        if (0 == GetSystemDirectoryW(wszDefaultSystemDir, MAX_PATH))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        //
        // Create default dirs for catalog files and CatDB files
        //
        if (NULL == (g_pwszCatalogFileBaseDirectory =
                                _CATDBConstructWSTRPath(
                                        wszDefaultSystemDir,
                                        WSZ_CATALOG_FILE_BASE_DIRECTORY)))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        if (NULL == (g_pwszDatabaseFileBaseDirectory =
                                _CATDBConstructWSTRPath(
                                        wszDefaultSystemDir,
                                        WSZ_DATABASE_FILE_BASE_DIRECTORY)))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        //
        // Get values to be used for timer callback, and database cache timeout
        //
        if (RegCreateKeyExW(
                HKEY_LOCAL_MACHINE,
                WSZ_REG_CATALOGDB_VALUES,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_READ,
                NULL,
                &hKey,
                &dwDisposition) == ERROR_SUCCESS)
        {
            cbSize = sizeof(DWORD);

            if (RegQueryValueExW(
                    hKey,
                    WSZ_REG_DATABASE_TIMEOUT,
                    NULL,
                    &dwType,
                    (BYTE *) &dwValue,
                    &cbSize) == ERROR_SUCCESS)
            {
                g_dwCatalogDatabaseCacheTimeout = dwValue;
            }

            dwValue = 0;
            cbSize = sizeof(DWORD);

            if (RegQueryValueExW(
                    hKey,
                    WSZ_REG_CALLBACK_TIMER,
                    NULL,
                    &dwType,
                    (BYTE *) &dwValue,
                    &cbSize) == ERROR_SUCCESS)
            {
                g_dwCatalogDatabaseCacheCallbackTime = dwValue;
            }

            RegCloseKey(hKey);
        }

        //
        // Create the event to be used in the call to RegisterWaitForSingleObject
        //
        if (NULL == (g_hCatalogCacheCallbackEvent = CreateEvent(NULL, TRUE, FALSE, NULL)))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        //
        // Create the g_hNotFrozen event (initially set to indicate not frozen)
        //
        if (NULL == (g_hNotFrozen = CreateEvent(NULL, TRUE, TRUE, NULL)))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        LIST_Initialize(&g_CatalogDBCacheList);

        //
        // Startup the VSS writer object
        //
        // Note: This will spin off a thread to do the actual initialization of
        //       the vss writer object, which depends on services like COM+ and VSS.
        //
        _SystemWriterInit(FALSE);

        g_fDBSvcInitialized = TRUE;
    }

CommonReturn:

    return fRet;

ErrorReturn:

    dwErr = GetLastError();

    if (NumCritSecsInitialized >= 1)
    {
        DeleteCriticalSection(&g_CatDBAddDeleteCS);
    }

    if (NumCritSecsInitialized >= 2)
    {
        DeleteCriticalSection(&g_CatDBRegisterNotifyCS);
    }

    if (NumCritSecsInitialized >= 3)
    {
        DeleteCriticalSection(&g_CatDirCashCS);
    }
    if (NumCritSecsInitialized >= 4)
    {
        DeleteCriticalSection(&g_CatClientCountCS);
    }

    if (NumCritSecsInitialized >= 5)
    {
        DeleteCriticalSection(&g_InitializeJetCS);
    }

    if (NumCritSecsInitialized >= 6)
    {
        DeleteCriticalSection(&g_WaitOrTimerCallbackCS);
    }

    if (g_pwszCatalogFileBaseDirectory != NULL)
    {
        _CatDBFree(g_pwszCatalogFileBaseDirectory);
    }

    if (g_pwszDatabaseFileBaseDirectory != NULL)
    {
        _CatDBFree(g_pwszDatabaseFileBaseDirectory);
    }

    if (g_hCatalogCacheCallbackEvent != NULL)
    {
        CloseHandle(g_hCatalogCacheCallbackEvent);
        g_hCatalogCacheCallbackEvent = NULL;
    }

    if (g_hNotFrozen != NULL)
    {
        CloseHandle(g_hNotFrozen);
        g_hNotFrozen = NULL;
    }

    SetLastError(dwErr);

    fRet = FALSE;
    goto CommonReturn;
}


//---------------------------------------------------------------------------------------
//
//  _CatDBClientEnter
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBClientEnter(void)
{
    BOOL    fRet = TRUE;

    EnterCriticalSection(&g_CatClientCountCS);
    g_dwClientCount++;
    LeaveCriticalSection(&g_CatClientCountCS);

    return fRet;
}


//---------------------------------------------------------------------------------------
//
//  _CatDBClientExit
//
//---------------------------------------------------------------------------------------
void
_CatDBClientExit(void)
{
    EnterCriticalSection(&g_CatClientCountCS);
    g_dwClientCount--;
    LeaveCriticalSection(&g_CatClientCountCS);
}


//---------------------------------------------------------------------------------------
//
//  _CatDBTouchTimeStampFile
//
//---------------------------------------------------------------------------------------
void
_CatDBTouchTimeStampFile(
    LPCWSTR pwszSubSysGUID)
{
    LPWSTR  pwsz = NULL;

    if (NULL != (pwsz = _CATDBConstructWSTRPath(
                                g_pwszDatabaseFileBaseDirectory,
                                pwszSubSysGUID)))
    {
        TimeStampFile_Touch(pwsz);
        _CatDBFree(pwsz);
    }
    else
    {
        CATDBSVC_LOGERR_LASTERR()
    }
}


//---------------------------------------------------------------------------------------
//
//  _CatDBInitializeJet
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBInitializeJet(
    BOOL    fInRecursiveCall)
{
    BOOL    fRet        = TRUE;
    JET_ERR jerr;

    EnterCriticalSection(&g_InitializeJetCS);

    if (g_fJetInitialized)
    {
        goto CommonReturn;
    }

    //
    // Create a jet instance so multiple jet users can co-exist
    // in the same process
    //
    jerr = JetCreateInstance(&g_JetInstance, SZ_CATALOG_DATABASE);
    if (_CatDBJET_errFailure(jerr))
    {
        CATDBSVC_SETERR_LOG_RETURN(jerr, ErrorReturn)
    }

    //
    // Initialize Jets parameters
    //
    if (!_CatDBInitJetDatabaseParams(&g_JetInstance))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Jet will start up at this point
    //
    jerr = JetInit(&g_JetInstance);

    //
    // Check for specific JET errors, if we got one of those errors then
    // the DB is corrupt in some way and we need to try and cleanup the
    // catroot2 dir, and rebuild the DB.
    //
    // Of course we should only do this if we are not already recursing
    //
    if (!fInRecursiveCall &&
            ((jerr == JET_errMissingLogFile)    ||
             (jerr == JET_errLogFileCorrupt)    ||
             (jerr == JET_errReadVerifyFailure) ||
             (jerr == JET_errPageNotInitialized)))
    {
        CATDBSVC_LOGERR(jerr)

        assert(0);

        JetTerm(g_JetInstance);
        g_JetInstance = 0;

        //
        // Cleanup the catroot 2 directory and then rebuild the DB
        //
        if (_CatDBDeleteJetFiles() && _CatDBRebuildAllDBs())
        {
            jerr = JET_errSuccess;
        }
    }

    if (_CatDBJET_errFailure(jerr))
    {
        CATDBSVC_SETERR_LOG_RETURN(jerr, ErrorReturn)
    }

    g_fJetInitialized = TRUE;

CommonReturn:

    LeaveCriticalSection(&g_InitializeJetCS);

    return (fRet);

ErrorReturn:

    if (g_JetInstance != 0)
    {
        JetTerm(g_JetInstance);
        g_JetInstance = 0;
    }

    fRet = FALSE;
    goto CommonReturn;
}


//---------------------------------------------------------------------------------------
//
//  _CatDBTermJet
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBTermJet()
{
    BOOL    fRet        = TRUE;
    JET_ERR jerr;

    EnterCriticalSection(&g_InitializeJetCS);

    if (!g_fJetInitialized ||
        (g_lOpenedDBCount != 0))
    {
        goto CommonReturn;
    }

    //
    // Shut Jet down!!
    //
    jerr = JetTerm(g_JetInstance);
    g_JetInstance = 0;
    g_fJetInitialized = FALSE;

    if (_CatDBJET_errFailure(jerr))
    {
        SetLastError(jerr);
        CATDBSVC_LOGERR(jerr)
    }

CommonReturn:

    LeaveCriticalSection(&g_InitializeJetCS);

    return (fRet);
}


//---------------------------------------------------------------------------------------
//
//  _CatDBAcquireOpenDatabaseFromCache
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBAcquireOpenDatabaseFromCache(
    PJET_DB_STRUCT  *ppJetDBStruct,
    LPCWSTR         pwszSubSysGUID,
    BOOL            fReadOnly,
    BOOL            fInRecursiveCall)
{
    BOOL                        fRet                    = TRUE;
    JET_ERR                     jerr;
    LPSTR                       pszDatabaseFileDir      = NULL;
    LPSTR                       pszSubSysGUID           = NULL;
    LPSTR                       pszTemp                 = NULL;
    BOOL                        fJetSessionBegun        = FALSE;
    BOOL                        fJetDBFileOpen          = FALSE;
    BOOL                        fCSEntered              = FALSE;
    PJET_DB_STRUCT              pJetDBStruct            = NULL;
    LIST_NODE                   *pListNode              = NULL;
    CATALOG_DIR_CACHE_STRUCT    *pCatDirCacheStruct     = NULL;
    CATALOG_DIR_CACHE_STRUCT    *pNewCatDirCacheStruct  = NULL;
    DWORD                       dwErr                   = 0;
    PVOID                       pvoid                   = NULL;
    HANDLE                      hTemp                   = NULL;

    //
    // check to see if we are shutting down, if so, get out
    //
    EnterCriticalSection(&g_CatDirCashCS);
    fCSEntered = TRUE;
    if (g_fShuttingDown)
    {
        CATDBSVC_SETERR_LOG_RETURN(ERROR_CAN_NOT_COMPLETE, ErrorReturn)
    }
    LeaveCriticalSection(&g_CatDirCashCS);
    fCSEntered = FALSE;

    //
    // Wait here if we're currently frozen
    //
    WaitForSingleObject(g_hNotFrozen,INFINITE);

    //
    // Do this here to ensure that JetTerm isn't called after the
    // initialize below is called.  This reference will be removed
    // if an actuall cached DB is used.
    //
    InterlockedIncrement(&g_lOpenedDBCount);

    //
    // Make sure Jet is initialized
    //
    if (!_CatDBInitializeJet(fInRecursiveCall))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // First check to see if there is a cached session available
    //
    EnterCriticalSection(&g_CatDirCashCS);
    fCSEntered = TRUE;

    pListNode = LIST_GetFirst(&g_CatalogDBCacheList);

    while (pListNode != NULL)
    {
        pCatDirCacheStruct = (CATALOG_DIR_CACHE_STRUCT *) LIST_GetElement(pListNode);

        if ((WaitForSingleObject(pCatDirCacheStruct->hDBNotInUse, 0) == WAIT_OBJECT_0) &&
            (_wcsicmp(pCatDirCacheStruct->pwszSubSysGUID, pwszSubSysGUID) == 0)) /*&&
            (pCatDirCacheStruct->fReadOnly == fReadOnly))*/
        {
            break;
        }

        pListNode = LIST_GetNext(pListNode);
    }

    if (pListNode != NULL)
    {
        //
        // Using a cached DB, which already has a ref count, so get rid of the
        // one added at the beginning of the function
        //
        InterlockedDecrement(&g_lOpenedDBCount);

        ResetEvent(pCatDirCacheStruct->hDBNotInUse);
        pCatDirCacheStruct->dwTimeLastTouched = GetTickCount();
        *ppJetDBStruct = &(pCatDirCacheStruct->JetDBStruct);
        goto CommonReturn;
    }

    //
    // There are either no cached DBs for this dir, or they are already in use...
    // So open a new instance
    //
    if (NULL == (pNewCatDirCacheStruct = (CATALOG_DIR_CACHE_STRUCT *)
                    _CatDBAlloc(sizeof(CATALOG_DIR_CACHE_STRUCT))))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    memset(&(pNewCatDirCacheStruct->JetDBStruct), 0, sizeof(JET_DB_STRUCT));
    pNewCatDirCacheStruct->hDBNotInUse = NULL;
    pNewCatDirCacheStruct->pwszSubSysGUID = NULL;
    pNewCatDirCacheStruct->dwTimeLastTouched = GetTickCount();
    pNewCatDirCacheStruct->fReadOnly = fReadOnly;

    //
    // Create the DBNotInUse event for this new instance (initially clear to indicate in use)
    //
    pNewCatDirCacheStruct->hDBNotInUse = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (pNewCatDirCacheStruct->hDBNotInUse == NULL)
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Make a copy of the catalog database GUID
    //
    if (NULL == (pNewCatDirCacheStruct->pwszSubSysGUID = (LPWSTR)
                    _CatDBAlloc((wcslen(pwszSubSysGUID) + 1) * sizeof(WCHAR))))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }
    wcscpy(pNewCatDirCacheStruct->pwszSubSysGUID, pwszSubSysGUID);

    pJetDBStruct = &(pNewCatDirCacheStruct->JetDBStruct);

    //
    // Begin a session
    //
    if (_CatDBJET_errFailure(jerr =
            JetBeginSession(
                g_JetInstance,
                &(pJetDBStruct->JetSesID),
                NULL,
                NULL)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }
    fJetSessionBegun = TRUE;

    //
    // Get the fully qualified name of the database file
    //
    pszDatabaseFileDir = _CatDBConvertWszToSz(g_pwszDatabaseFileBaseDirectory);
    if (pszDatabaseFileDir == NULL)
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    pszSubSysGUID = _CatDBConvertWszToSz(pwszSubSysGUID);
    if (pszSubSysGUID == NULL)
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    if (NULL == (pszTemp = _CATDBConstructPath(pszDatabaseFileDir, pszSubSysGUID)))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    if (NULL == (pJetDBStruct->pszDBFileName =
                                    _CATDBConstructPath(pszTemp, SZ_DBFILE_NAME)))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Open the DB file... create it if it doesn't already exist
    //
    if (!_CatDBAttachAndOpenDatabase(pJetDBStruct, fReadOnly))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }
    fJetDBFileOpen = TRUE;

    //
    // Register the global close callback for cached DBs
    //
    if (!RegisterWaitForSingleObject(
            &hTemp,
            g_hCatalogCacheCallbackEvent,
            _CatDBWaitOrTimerCallback,
            NULL, // Context
            g_dwCatalogDatabaseCacheCallbackTime,
            WT_EXECUTEDEFAULT))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    pvoid = InterlockedExchangePointer(
            &g_hRegisterWaitForServiceShutdown,
            hTemp);

    //
    // Add the opened database to the cache list
    //
    if (!LIST_AddTail(&g_CatalogDBCacheList, pNewCatDirCacheStruct))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    *ppJetDBStruct = &(pNewCatDirCacheStruct->JetDBStruct);

CommonReturn:

    if (fCSEntered)
    {
        LeaveCriticalSection(&g_CatDirCashCS);
    }

    //
    // If there was already a callback registered, then unregister the one that was
    // previously registered
    //
    if (pvoid != NULL)
    {
        UnregisterWaitEx((HANDLE) pvoid, INVALID_HANDLE_VALUE);
    }

    if (pszDatabaseFileDir != NULL)
    {
        _CatDBFree(pszDatabaseFileDir);
    }

    if (pszSubSysGUID != NULL)
    {
        _CatDBFree(pszSubSysGUID);
    }

    if (pszTemp != NULL)
    {
        _CatDBFree(pszTemp);
    }

    return fRet;

ErrorReturn:

    dwErr = GetLastError();

    if (fJetDBFileOpen)
    {
        JetCloseDatabase(pJetDBStruct->JetSesID, pJetDBStruct->JetDBID, 0);
    }

    if (fJetSessionBegun)
    {
        JetEndSession(pJetDBStruct->JetSesID, 0);
    }

    if (pNewCatDirCacheStruct != NULL)
    {
        if (pNewCatDirCacheStruct->hDBNotInUse)
        {
            CloseHandle(pNewCatDirCacheStruct->hDBNotInUse);
        }

        if (pNewCatDirCacheStruct->JetDBStruct.pszDBFileName != NULL)
        {
            _CatDBFree(pNewCatDirCacheStruct->JetDBStruct.pszDBFileName);
        }

        if (pNewCatDirCacheStruct->pwszSubSysGUID != NULL)
        {
            _CatDBFree(pNewCatDirCacheStruct->pwszSubSysGUID);
        }

        _CatDBFree(pNewCatDirCacheStruct);
    }

    InterlockedDecrement(&g_lOpenedDBCount);

    SetLastError(dwErr);

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetDatabase)
}


//---------------------------------------------------------------------------------------
//
//  _CatDBReleaseDatabaseToCache
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBReleaseDatabaseToCache(
    PJET_DB_STRUCT  pJetDBStruct)
{
    //
    // This cast works because the JET_DB_STRUCT is the first member of the
    // CATALOG_DIR_CACHE_STRUCT
    //
    CATALOG_DIR_CACHE_STRUCT *pCatDirCacheStruct =
        (CATALOG_DIR_CACHE_STRUCT *) pJetDBStruct;

    pCatDirCacheStruct->dwTimeLastTouched = GetTickCount();
    SetEvent(pCatDirCacheStruct->hDBNotInUse);

    return TRUE;
}


//---------------------------------------------------------------------------------------
//
//  _CatDBInstanceCount
//
//---------------------------------------------------------------------------------------
DWORD
_CatDBInstanceCount(
    PWSTR pwszSubSysGUID)
{
    DWORD                       dwResult                = 0;
    LIST_NODE                   *pListNode              = NULL;
    CATALOG_DIR_CACHE_STRUCT    *pCatDirCacheStruct     = NULL;

    if (pwszSubSysGUID)
    {
        pListNode = LIST_GetFirst(&g_CatalogDBCacheList);

        while (pListNode != NULL)
        {
            pCatDirCacheStruct = (CATALOG_DIR_CACHE_STRUCT *) LIST_GetElement(pListNode);

            if (_wcsicmp(pCatDirCacheStruct->pwszSubSysGUID, pwszSubSysGUID) == 0)
            {
                ++dwResult;
            }

            pListNode = LIST_GetNext(pListNode);
        }
    }

    return dwResult;
}


//---------------------------------------------------------------------------------------
//
//  _CatDBCloseCachedDatabases
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBCloseCachedDatabases(
    BOOL fForceClose)
{
    BOOL                        fRet                        = TRUE;
    BOOL                        fDatabaseFoundThatIsInUse   = FALSE;
    BOOL                        fCloseFailed                = FALSE;
    LIST_NODE                   *pListNode                  = NULL;
    CATALOG_DIR_CACHE_STRUCT    *pCatDirCacheStruct         = NULL;
    PVOID                       pvoid                       = NULL;
    DWORD                       dwWaitResult;
    BOOL                        fDetach;

    EnterCriticalSection(&g_CatDirCashCS);

    //
    // Cycle through all open DBs and close them
    //
    pListNode = LIST_GetFirst(&g_CatalogDBCacheList);

    while (pListNode != NULL)
    {
        pCatDirCacheStruct = (CATALOG_DIR_CACHE_STRUCT *) LIST_GetElement(pListNode);

        //
        // Is the instance currently in use?
        // If a close is being forced, wait for the instance to be released
        //
        if (fForceClose)
        {
            dwWaitResult = WaitForSingleObject(pCatDirCacheStruct->hDBNotInUse, INFINITE);
        }
        else
        {
            dwWaitResult = WaitForSingleObject(pCatDirCacheStruct->hDBNotInUse, 0);
        }

        //
        // If the database is not in use AND
        // a DB close is being forced by caller OR the DB hasn't been used in a while
        // then close it
        //
        if ((dwWaitResult == WAIT_OBJECT_0) &&
            (fForceClose || ((GetTickCount() - pCatDirCacheStruct->dwTimeLastTouched) >
                              g_dwCatalogDatabaseCacheTimeout)))
        {
            //
            // Only detach if we are closing the last instance
            //
            fDetach = (_CatDBInstanceCount(pCatDirCacheStruct->pwszSubSysGUID) == 1);

            if (!_CatDBCloseDatabaseFile(&(pCatDirCacheStruct->JetDBStruct), fDetach))
            {
                fCloseFailed = TRUE;
                CATDBSVC_LOGERR_LASTERR()
            }
            else
            {
                //
                // Decrement the open DB count and check to see if there are anymore
                // DBs open, if that was the last one, then terminate Jet
                //
                if (0 == InterlockedDecrement(&g_lOpenedDBCount))
                {
                    _CatDBTermJet();
                }
            }

            CloseHandle(pCatDirCacheStruct->hDBNotInUse);

            _CatDBFree(pCatDirCacheStruct->JetDBStruct.pszDBFileName);
            _CatDBFree(pCatDirCacheStruct->pwszSubSysGUID);

            pListNode = LIST_GetNext(pListNode);
            LIST_RemoveElement(&g_CatalogDBCacheList, pCatDirCacheStruct);
            _CatDBFree(pCatDirCacheStruct);

        }
        else
        {
            fDatabaseFoundThatIsInUse = TRUE;
            pListNode = LIST_GetNext(pListNode);
        }
    }

    if (fDatabaseFoundThatIsInUse || fCloseFailed)
    {
        fRet = FALSE;
    }

    LeaveCriticalSection(&g_CatDirCashCS);

    return fRet;
}


//---------------------------------------------------------------------------------------
//
//  _CatDBWaitOrTimerCallback
//
//---------------------------------------------------------------------------------------
VOID CALLBACK
_CatDBWaitOrTimerCallback(
    PVOID lpParameter,
    BOOLEAN fTimedOut)
{
    BOOL    fClosed = FALSE;
    PVOID   pvoid   = NULL;

    //
    // Make sure only one thread executes the callback at a time
    //
    EnterCriticalSection(&g_WaitOrTimerCallbackCS);

    //
    // If we are being called because we timed out (the event wasn't set), that
    // means we should close the database if possible... otherwise, the event
    // was set because we are shutting down, so don't do anything and just let the
    // shutdown-cleanup code handle it.
    //
    if (fTimedOut)
    {
        //
        // If the close succeeds that means there are no DBs still in use, so we should
        // unregister the callback
        //
        fClosed = _CatDBCloseCachedDatabases(FALSE);

        //
        // Since we have a thread, try to clean up the temp files
        //
        _CatDBCleanupTempFiles();
    }

    //
    // if there does not need to be another callback then unregister
    //
    if (fClosed)
    {
        pvoid = InterlockedExchangePointer(
                &g_hRegisterWaitForServiceShutdown,
                NULL);
        if (pvoid != NULL)
        {
            UnregisterWait((HANDLE) pvoid);
        }
    }

    LeaveCriticalSection(&g_WaitOrTimerCallbackCS);
}


//---------------------------------------------------------------------------------------
//
//  _CatDBAddCatalogEntriesToDatabase
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBAddCatalogEntriesToDatabase(
    PJET_DB_STRUCT  pJetDBStruct,
    PCCTL_CONTEXT   pCTLContext,
    LPWSTR          pwszNewCatalogName)
{
    BOOL                        fRet                = TRUE;
    WCHAR                       *pwszCatBaseName;
    DWORD                       i;
    CRYPT_DATA_BLOB             CryptDataBlob;
    SPC_INDIRECT_DATA_CONTENT   *pIndirectData      = NULL;

    CryptDataBlob.pbData = NULL;

    //
    // Extract the base name from the full path name
    //
    if (NULL == (pwszCatBaseName = wcsrchr(pwszNewCatalogName, L'\\')))
    {
        pwszCatBaseName = wcsrchr(pwszNewCatalogName, L':');
    }

    if (pwszCatBaseName != NULL)
    {
        pwszCatBaseName++;
    }
    else
    {
        pwszCatBaseName = pwszNewCatalogName;
    }

    //
    // Loop for each hash in the catalog file
    //
    for (i=0; i<pCTLContext->pCtlInfo->cCTLEntry; i++)
    {
        if (!_CatDBFindAndDecodeHashInCatEntry(
                &(pCTLContext->pCtlInfo->rgCTLEntry[i]),
                &pIndirectData))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        if (!_CatDBAddHashCatNamePair(
                pJetDBStruct,
                &(pIndirectData->Digest),
                pwszCatBaseName))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        _CatDBFree(pIndirectData);
        pIndirectData = NULL;
    }

CommonReturn:

    return fRet;

ErrorReturn:

    if (pIndirectData != NULL)
    {
        _CatDBFree(pIndirectData);
    }

    fRet = FALSE;
    goto CommonReturn;
}


//---------------------------------------------------------------------------------------
//
//  _CatDBAddHashCatNamePair
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBAddHashCatNamePair(
    PJET_DB_STRUCT      pJetDBStruct,
    PCRYPT_DATA_BLOB    pHashBlob,
    LPWSTR              pwszCatBaseName)
{
    BOOL    fRet = TRUE;
    JET_ERR jerr;

    //
    // First, try to find the hash in the HashCatName table.
    //
    jerr = _CatDBSeekInHashCatNameTable(pJetDBStruct, pHashBlob);

    if (jerr == JET_errRecordNotFound)
    {
        //
        // not found
        //
        if (!_CatDBAddNewRowToHashCatNameTable(
                pJetDBStruct,
                pHashBlob,
                pwszCatBaseName))
        {
            goto ErrorReturn;
        }
    }
    else if (jerr == JET_errSuccess)
    {
        //
        // found
        //
        if (!_CatDBAddValueToExistingHashCatNameRow(
                pJetDBStruct,
                pHashBlob,
                pwszCatBaseName))
        {
            goto ErrorReturn;
        }
    }
    else if (_CatDBJET_errFailure(jerr))
    {
        //
        // error
        //
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }


CommonReturn:

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetDatabase)
}


//---------------------------------------------------------------------------------------
//
//  _CatDBAddNewRowToHashCatNameTable
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBAddNewRowToHashCatNameTable(
    PJET_DB_STRUCT      pJetDBStruct,
    PCRYPT_DATA_BLOB    pHashBlob,
    LPWSTR              pwszCatBaseName)
{
    BOOL        fRet = TRUE;
    JET_ERR     jerr;
    JET_SETINFO JetSetInfo;

    //
    // Create the new row, and insert the values
    //
    if (_CatDBJET_errFailure(jerr  =
            JetPrepareUpdate(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetHashCatNameTableID,
                JET_prepInsert)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    // hash
    if (_CatDBJET_errFailure(jerr  =
            JetSetColumn(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetHashCatNameTableID,
                pJetDBStruct->JetHashCatNameTable_HashColumnID,
                pHashBlob->pbData,
                pHashBlob->cbData,
                0,
                NULL)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    // catname
    memset(&JetSetInfo, 0, sizeof(JetSetInfo));
    JetSetInfo.cbStruct = sizeof(JetSetInfo);
    JetSetInfo.itagSequence = 1;
    if (_CatDBJET_errFailure(jerr  =
            JetSetColumn(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetHashCatNameTableID,
                pJetDBStruct->JetHashCatNameTable_CatNameColumnID,
                (BYTE const *) pwszCatBaseName,
                (wcslen(pwszCatBaseName) + 1) * sizeof(WCHAR),
                0,
                &JetSetInfo)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    if (_CatDBJET_errFailure(jerr  =
            JetUpdate(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetHashCatNameTableID,
                NULL,
                0,
                NULL)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

CommonReturn:

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetDatabase)
}


//---------------------------------------------------------------------------------------
//
//  _CatDBAddValueToExistingHashCatNameRow
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBAddValueToExistingHashCatNameRow(
    PJET_DB_STRUCT      pJetDBStruct,
    PCRYPT_DATA_BLOB    pHashBlob,
    LPWSTR              pwszCatBaseName)
{
    BOOL        fRet = TRUE;
    JET_ERR     jerr;
    JET_SETINFO JetSetInfo;
    WCHAR       wszCatalogName[CATDB_MAX_CATNAME_LENGTH];
    DWORD       dwLength;
    JET_RETINFO JetRetInfo;

    //
    // Make sure we are not here because a single hash is in the same catalog twice...
    //
    //
    if (_CatDBCatnameAlreadyInHashesListOfCats(
            pJetDBStruct,
            pHashBlob,
            pwszCatBaseName))
    {
        goto CommonReturn;
    }

    //
    // Create a row in the CatNameBuddy Table for the current catalog if it
    // doesn't already exist
    //
    if (!_CatDBAddNewRowToCatNameBuddyTableIfNotExists(
            pJetDBStruct,
            pwszCatBaseName))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Get each catalog name in the current hashes CatNameList and add it to the
    // current catalogs buddy list
    //
    memset(&JetRetInfo, 0, sizeof(JetRetInfo));
    JetRetInfo.cbStruct = sizeof(JetRetInfo);
    JetRetInfo.itagSequence = 1;
    jerr = JetRetrieveColumn(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetHashCatNameTableID,
                pJetDBStruct->JetHashCatNameTable_CatNameColumnID,
                wszCatalogName,
                CATDB_MAX_CATNAME_LENGTH,
                &dwLength,
                JET_bitRetrieveCopy,
                &JetRetInfo);

    while (jerr == JET_errSuccess)
    {
        if (!_CatDBAddNewRowToCatNameBuddyTableIfNotExists(
                pJetDBStruct,
                wszCatalogName))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        //
        // Add the buddy that was found to the current catalogs buddy list
        //
        if (!_CatDBAddNameToBuddyList(
                pJetDBStruct,
                wszCatalogName,
                pwszCatBaseName))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        //
        // Add the buddys of the buddy that was found, to current catalogs buddy list
        //
        if (!_CatDBAddWholeBuddyList(
                pJetDBStruct,
                pwszCatBaseName,
                wszCatalogName))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        //
        // Add the current catalog to the buddy list of the buddy that was found
        //
        if (!_CatDBAddNameToBuddyList(
                pJetDBStruct,
                pwszCatBaseName,
                wszCatalogName))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        //
        // Setup for next loop
        //
        JetRetInfo.itagSequence++;
        jerr = JetRetrieveColumn(
                    pJetDBStruct->JetSesID,
                    pJetDBStruct->JetHashCatNameTableID,
                    pJetDBStruct->JetHashCatNameTable_CatNameColumnID,
                    wszCatalogName,
                    CATDB_MAX_CATNAME_LENGTH,
                    &dwLength,
                    JET_bitRetrieveCopy,
                    &JetRetInfo);
    }

    //
    // Check to see if a real error occurred and not just a JET_wrnColumnNull
    //
    if (_CatDBJET_errFailure(jerr))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    //
    // Add the current catalog to the CatNameList of the current hash
    //
    if (_CatDBJET_errFailure(jerr  =
            JetPrepareUpdate(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetHashCatNameTableID,
                JET_prepReplace)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    memset(&JetSetInfo, 0, sizeof(JetSetInfo));
    JetSetInfo.cbStruct = sizeof(JetSetInfo);
    JetSetInfo.itagSequence = 0; // insert into next open position
    if (_CatDBJET_errFailure(jerr  =
            JetSetColumn(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetHashCatNameTableID,
                pJetDBStruct->JetHashCatNameTable_CatNameColumnID,
                (BYTE const *) pwszCatBaseName,
                (wcslen(pwszCatBaseName) + 1) * sizeof(WCHAR),
                0,
                &JetSetInfo)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    if (_CatDBJET_errFailure(jerr  =
            JetUpdate(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetHashCatNameTableID,
                NULL,
                0,
                NULL)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

CommonReturn:

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetDatabase)
}


//---------------------------------------------------------------------------------------
//
//  _CatDBCatnameAlreadyInHashesListOfCats
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBCatnameAlreadyInHashesListOfCats(
    PJET_DB_STRUCT      pJetDBStruct,
    PCRYPT_DATA_BLOB    pHashBlob,
    LPWSTR              pwszCatBaseName)
{
    JET_ERR     jerr;
    WCHAR       wszCatalogName[CATDB_MAX_CATNAME_LENGTH];
    DWORD       dwLength;
    JET_RETINFO JetRetInfo;

    //
    // Get each catalog name in the current hashes CatNameList see if it is the same
    // as pwszCatBaseName
    //
    memset(&JetRetInfo, 0, sizeof(JetRetInfo));
    JetRetInfo.cbStruct = sizeof(JetRetInfo);
    JetRetInfo.itagSequence = 1;
    jerr = JetRetrieveColumn(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetHashCatNameTableID,
                pJetDBStruct->JetHashCatNameTable_CatNameColumnID,
                wszCatalogName,
                CATDB_MAX_CATNAME_LENGTH,
                &dwLength,
                JET_bitRetrieveCopy,
                &JetRetInfo);

    while (jerr == JET_errSuccess)
    {
        if (_wcsicmp(wszCatalogName, pwszCatBaseName) == 0)
        {
            //
            // Duplicate found
            //
            return TRUE;
        }

        //
        // Setup for next loop
        //
        JetRetInfo.itagSequence++;
        jerr = JetRetrieveColumn(
                    pJetDBStruct->JetSesID,
                    pJetDBStruct->JetHashCatNameTableID,
                    pJetDBStruct->JetHashCatNameTable_CatNameColumnID,
                    wszCatalogName,
                    CATDB_MAX_CATNAME_LENGTH,
                    &dwLength,
                    JET_bitRetrieveCopy,
                    &JetRetInfo);
    }

    //
    // No duplicates were found
    //
    return FALSE;
}


//---------------------------------------------------------------------------------------
//
//  _CatDBAddNewRowToCatNameBuddyTableIfNotExists
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBAddNewRowToCatNameBuddyTableIfNotExists(
    PJET_DB_STRUCT      pJetDBStruct,
    LPWSTR              pwszCatBaseName)
{
    BOOL    fRet = TRUE;
    JET_ERR jerr;

    //
    // Try to find the CatName in the CatNameBuddy table.
    //
    jerr = _CatDBSeekInCatNameBuddyTable(pJetDBStruct, pwszCatBaseName);
    if (jerr == JET_errRecordNotFound)
    {
        //
        // not found, so add the row
        //
        if (!_CatDBAddNewRowToCatNameBuddyTable(pJetDBStruct, pwszCatBaseName))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }
    }
    else if (_CatDBJET_errFailure(jerr))
    {
        //
        // error
        //
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }
    // else, it was found, so just return successfully

CommonReturn:

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetDatabase)
}


//---------------------------------------------------------------------------------------
//
//  _CatDBAddNewRowToCatNameBuddyTable
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBAddNewRowToCatNameBuddyTable(
    PJET_DB_STRUCT      pJetDBStruct,
    LPWSTR              pwszCatBaseName)
{
    BOOL        fRet = TRUE;
    JET_ERR     jerr;
    JET_SETINFO JetSetInfo;

    //
    // Create the new row, and insert the values
    //
    if (_CatDBJET_errFailure(jerr  =
            JetPrepareUpdate(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetCatNameBuddyTableID,
                JET_prepInsert)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    // catname
    if (_CatDBJET_errFailure(jerr  =
            JetSetColumn(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetCatNameBuddyTableID,
                pJetDBStruct->JetCatNameBuddyTable_CatNameColumnID,
                (BYTE const *) pwszCatBaseName,
                (wcslen(pwszCatBaseName) + 1) * sizeof(WCHAR),
                0,
                NULL)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    if (_CatDBJET_errFailure(jerr  =
            JetUpdate(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetCatNameBuddyTableID,
                NULL,
                0,
                NULL)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

CommonReturn:

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetDatabase)
}


//---------------------------------------------------------------------------------------
//
//  _CatDBAddNameToBuddyList
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBAddNameToBuddyList(
    PJET_DB_STRUCT      pJetDBStruct,
    LPWSTR              pwszNameToAdd,
    LPWSTR              pwszListToAddTo)
{
    BOOL        fRet = TRUE;
    JET_ERR     jerr;
    JET_SETINFO JetSetInfo;
    JET_RETINFO JetRetInfo;
    WCHAR       wszCatalogName[CATDB_MAX_CATNAME_LENGTH];
    DWORD       dwLength;

    //
    // Don't add the same name to itself
    //
    if (_wcsicmp(pwszNameToAdd, pwszListToAddTo) == 0)
    {
        goto CommonReturn;
    }

    //
    // seek to the pwszListToAddTo row in the CatNameBuddy table
    //
    jerr = _CatDBSeekInCatNameBuddyTable(pJetDBStruct, pwszListToAddTo);
    if (jerr == JET_errRecordNotFound)
    {
        //
        // this bad, since we know the row should exist
        //
        CATDBSVC_SETERR_LOG_RETURN(JET_errRecordNotFound, ErrorJetDatabase)
    }
    else if (_CatDBJET_errFailure(jerr))
    {
        //
        // error
        //
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    //
    // Check to see if the buddy being added is already there.
    //
    memset(&JetRetInfo, 0, sizeof(JetRetInfo));
    JetRetInfo.cbStruct = sizeof(JetRetInfo);
    JetRetInfo.itagSequence = 1;
    jerr = JetRetrieveColumn(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetCatNameBuddyTableID,
                pJetDBStruct->JetCatNameBuddyTable_BuddyColumnID,
                wszCatalogName,
                CATDB_MAX_CATNAME_LENGTH,
                &dwLength,
                JET_bitRetrieveCopy,
                &JetRetInfo);

    while (jerr == JET_errSuccess)
    {
        //
        // Compare to see if this is the name we are supposed to add,
        // if so, we are done, so get out
        //
        if (_wcsicmp(pwszNameToAdd, wszCatalogName) == 0)
        {
            goto CommonReturn;
        }

        //
        // Setup for next loop
        //
        JetRetInfo.itagSequence++;
        jerr = JetRetrieveColumn(
                    pJetDBStruct->JetSesID,
                    pJetDBStruct->JetCatNameBuddyTableID,
                    pJetDBStruct->JetCatNameBuddyTable_BuddyColumnID,
                    wszCatalogName,
                    CATDB_MAX_CATNAME_LENGTH,
                    &dwLength,
                    JET_bitRetrieveCopy,
                    &JetRetInfo);
    }

    //
    // Check to see if a real error occurred and not just a JET_wrnColumnNull
    //
    if (_CatDBJET_errFailure(jerr))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    //
    // Prepare, then insert the new buddy name into the list
    //
    if (_CatDBJET_errFailure(jerr  =
            JetPrepareUpdate(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetCatNameBuddyTableID,
                JET_prepReplace)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    memset(&JetSetInfo, 0, sizeof(JetSetInfo));
    JetSetInfo.cbStruct = sizeof(JetSetInfo);
    JetSetInfo.itagSequence = 0; // insert in next open position
    if (_CatDBJET_errFailure(jerr  =
            JetSetColumn(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetCatNameBuddyTableID,
                pJetDBStruct->JetCatNameBuddyTable_BuddyColumnID,
                (BYTE const *) pwszNameToAdd,
                (wcslen(pwszNameToAdd) + 1) * sizeof(WCHAR),
                0,
                &JetSetInfo)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    if (_CatDBJET_errFailure(jerr  =
            JetUpdate(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetCatNameBuddyTableID,
                NULL,
                0,
                NULL)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

CommonReturn:

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetDatabase)
}


//---------------------------------------------------------------------------------------
//
//  _CatDBAddWholeBuddyList
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBAddWholeBuddyList(
    PJET_DB_STRUCT      pJetDBStruct,
    LPWSTR              pwszBuddyToAddTo,
    LPWSTR              pwszBuddyListName)
{
    BOOL        fRet = TRUE;
    JET_ERR     jerr;
    JET_RETINFO JetRetInfo;
    WCHAR       wszCatalogName[CATDB_MAX_CATNAME_LENGTH];
    DWORD       dwLength;

    //
    // seek to the pwszBuddyListName row in the CatNameBuddy table
    //
    jerr = _CatDBSeekInCatNameBuddyTable(pJetDBStruct, pwszBuddyListName);
    if (jerr == JET_errRecordNotFound)
    {
        //
        // this bad, since we know the row should exist
        //
        CATDBSVC_SETERR_LOG_RETURN(JET_errRecordNotFound, ErrorJetDatabase)
    }
    else if (_CatDBJET_errFailure(jerr))
    {
        //
        // error
        //
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    //
    // Get each buddy in the list and add it to pwszBuddyToAddTo's buddy list
    //
    memset(&JetRetInfo, 0, sizeof(JetRetInfo));
    JetRetInfo.cbStruct = sizeof(JetRetInfo);
    JetRetInfo.itagSequence = 1;
    jerr = JetRetrieveColumn(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetCatNameBuddyTableID,
                pJetDBStruct->JetCatNameBuddyTable_BuddyColumnID,
                wszCatalogName,
                CATDB_MAX_CATNAME_LENGTH,
                &dwLength,
                JET_bitRetrieveCopy,
                &JetRetInfo);

    while (jerr == JET_errSuccess)
    {
        //
        // Add the buddy that was found to the current catalogs buddy list
        //
        if (!_CatDBAddNameToBuddyList(
                pJetDBStruct,
                wszCatalogName,
                pwszBuddyToAddTo))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }


        //
        // setup for next loop
        //

        //
        // NOTE - we have to re-seek since the cursor was reset in
        //        the _CatDBAddNameToBuddyList call
        //
        jerr = _CatDBSeekInCatNameBuddyTable(pJetDBStruct, pwszBuddyListName);
        if (jerr == JET_errRecordNotFound)
        {
            //
            // this bad, since we know the row should exist
            //
            CATDBSVC_SETERR_LOG_RETURN(JET_errRecordNotFound, ErrorJetDatabase)
        }
        else if (jerr != JET_errSuccess)
        {
            //
            // error
            //
            CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
        }

        JetRetInfo.itagSequence++;
        jerr = JetRetrieveColumn(
                    pJetDBStruct->JetSesID,
                    pJetDBStruct->JetCatNameBuddyTableID,
                    pJetDBStruct->JetCatNameBuddyTable_BuddyColumnID,
                    wszCatalogName,
                    CATDB_MAX_CATNAME_LENGTH,
                    &dwLength,
                    JET_bitRetrieveCopy,
                    &JetRetInfo);
    }

    //
    // Check to see if a real error occurred and not just a JET_wrnColumnNull
    //
    if (_CatDBJET_errFailure(jerr))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

CommonReturn:

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetDatabase)
}


//---------------------------------------------------------------------------------------
//
//  _CatDBMoveInUseFileToTempLocation
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBMoveInUseFileToTempLocation(
    LPWSTR              pwszFile
    )
{
    BOOL            fRet                    = TRUE;
    WCHAR           wszTempFile[MAX_PATH];
    HKEY            hKey                    = NULL;
    HKEY            hKey2                   = NULL;
    DWORD           dwDisposition;
    DWORD           i;

    //
    // Get the temp file name that the file will be renamed to
    //
    if (0 == GetTempFileNameW(
                    g_pwszCatalogFileBaseDirectory,
                    L"TMP",
                    0,
                    wszTempFile))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorGetTempFileName;
    }

    //
    // Move the file to a temporary location
    //
    if (!MoveFileExW(pwszFile, wszTempFile, MOVEFILE_REPLACE_EXISTING))
    {
        DeleteFileW(wszTempFile);
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorMoveFile;
    }

    //
    // The moved copy is still being accessed, so log the name of the file
    // to make sure it gets cleaned up later.
    //
    if (RegCreateKeyExW(
            HKEY_LOCAL_MACHINE,
            WSZ_REG_TEMP_FILES_KEY,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,
            &hKey,
            &dwDisposition) == ERROR_SUCCESS)
    {
        //
        // convert all '\\' to '*'
        //
        for (i=0; i<wcslen(wszTempFile); i++)
        {
            if (wszTempFile[i] == L'\\')
            {
                wszTempFile[i] = L'*';
            }
        }

        if (RegCreateKeyW(
                hKey,
                wszTempFile,
                &hKey2) == ERROR_SUCCESS)
        {
            RegCloseKey(hKey2);
        }
    }

CommonReturn:

    if (hKey != NULL)
    {
        RegCloseKey(hKey);
    }

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorGetTempFileName)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorMoveFile)
}


//---------------------------------------------------------------------------------------
//
//  _CatDBCleanupTempFiles
//
//---------------------------------------------------------------------------------------
void
_CatDBCleanupTempFiles()
{
    HKEY    hKey    = NULL;
    HKEY    hKey2   = NULL;
    DWORD   dwIndex = 0;
    DWORD   dwRet   = 0;
    DWORD   dwDisposition;
    WCHAR   wszFileToDelete[MAX_PATH + 1];
    DWORD   i;

    //
    // Open the key that contains all the tempfile name keys
    //
    if (RegCreateKeyExW(
            HKEY_LOCAL_MACHINE,
            WSZ_REG_TEMP_FILES_KEY,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,
            &hKey,
            &dwDisposition) == ERROR_SUCCESS)
    {
        //
        // Query to see how many keys there are
        //
        if (RegQueryInfoKey(
                hKey,
                NULL,
                NULL,
                NULL,
                &dwIndex,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL) == ERROR_SUCCESS)
        {
            dwIndex--;

            //
            // Enumerate through all the keys and try to delete the
            // corresponding temp files
            //
            while (RegEnumKeyW(
                        hKey,
                        dwIndex,
                        wszFileToDelete,
                        MAX_PATH + 1) == ERROR_SUCCESS)
            {
                //
                // Delete the key first
                //
                RegDeleteKey(hKey, wszFileToDelete);

                //
                // convert all '*' back to '\\'
                //
                for (i=0; i<wcslen(wszFileToDelete); i++)
                {
                    if (wszFileToDelete[i] == L'*')
                    {
                        wszFileToDelete[i] = L'\\';
                    }
                }

                //
                // If the delete fails for any reason other than file not found
                // add the key back to try and delete it later.
                //
                if ((DeleteFileW(wszFileToDelete) == 0) &&
                    (GetLastError() != ERROR_FILE_NOT_FOUND))
                {
                    //
                    // convert all '\\' back to '*' and then add the reg key back
                    //
                    for (i=0; i<wcslen(wszFileToDelete); i++)
                    {
                        if (wszFileToDelete[i] == L'\\')
                        {
                            wszFileToDelete[i] = L'*';
                        }
                    }

                    if (RegCreateKeyW(
                            hKey,
                            wszFileToDelete,
                            &hKey2) == ERROR_SUCCESS)
                    {
                        RegCloseKey(hKey2);
                    }
                }

                dwIndex--;
            }
        }

        RegCloseKey(hKey);
    }
}



//---------------------------------------------------------------------------------------
//
//  _CatDBDeleteCatalogEntriesFromDatabase
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBDeleteCatalogEntriesFromDatabase(
    PJET_DB_STRUCT      pJetDBStruct,
    LPWSTR              pwszCatalogName)
{
    BOOL                        fRet                = TRUE;
    PCCTL_CONTEXT               pCTLContext         = NULL;
    HANDLE                      hMappedFile         = NULL;
    BYTE                        *pbMappedFile       = NULL;
    WCHAR                       *pwszCatBaseName;
    DWORD                       i;
    SPC_INDIRECT_DATA_CONTENT   *pIndirectData      = NULL;
    BOOL                        fDeleteUsingName    = TRUE;
    DWORD                       dwErr               = 0;

    //
    // Extract the base name from the full path name
    //
    if (NULL == (pwszCatBaseName = wcsrchr(pwszCatalogName, L'\\')))
    {
        pwszCatBaseName = wcsrchr(pwszCatalogName, L':');
    }

    if (pwszCatBaseName != NULL)
    {
        pwszCatBaseName++;
    }
    else
    {
        pwszCatBaseName = pwszCatalogName;
    }

    //
    // Open a CTL context on the catalog file whose entries are being deleted
    //
    if (CatUtil_CreateCTLContextFromFileName(
            pwszCatalogName,
            &hMappedFile,
            &pbMappedFile,
            &pCTLContext,
            FALSE))
    {
        //
        // Since we can create a CTL context on the catalog, first try to
        // delete without walking the whole HashCatnameTable, which we will
        // have to do if we delete using the catalog name only
        //
        fDeleteUsingName = FALSE;

        //
        // Loop for each hash in the catalog file
        //
        for (i=0; i<pCTLContext->pCtlInfo->cCTLEntry; i++)
        {
            if (!_CatDBFindAndDecodeHashInCatEntry(
                    &(pCTLContext->pCtlInfo->rgCTLEntry[i]),
                    &pIndirectData))
            {
                //
                // Since this failed, fallback and try to delete the catalog
                // from the DB using the catalogs name only
                //
                fDeleteUsingName = TRUE;
                break;
            }

            if (!_CatDBRemoveCatNameFromHashesListOfCatNames(
                    pJetDBStruct,
                    &(pIndirectData->Digest),
                    pwszCatBaseName))
            {
                //
                // Since this failed, fallback and try to delete the catalog
                // from the DB using the catalogs name only
                //
                fDeleteUsingName = TRUE;
                break;
            }

            _CatDBFree(pIndirectData);
            pIndirectData = NULL;
        }
    }

    if (fDeleteUsingName)
    {
        //
        // Since that failed, the catalog is most likely corrupt, so just use
        // the catalog name to delete its entries from the HashCatName table
        //
        if (!_CatDBRemoveCatNameFromCatNameTable(
                pJetDBStruct,
                pwszCatBaseName))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }
    }

    //
    // Delete all occurences of CatName from buddy table
    //
    if (!_CatDBRemoveCatNameFromBuddyTable(
            pJetDBStruct,
            pwszCatBaseName))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

CommonReturn:

    dwErr = GetLastError();

    if (pIndirectData != NULL)
    {
        _CatDBFree(pIndirectData);
    }

    if (pCTLContext != NULL)
    {
        CertFreeCTLContext(pCTLContext);
    }
    if (pbMappedFile != NULL)
    {
        UnmapViewOfFile(pbMappedFile);
    }

    if (hMappedFile != NULL)
    {
        CloseHandle(hMappedFile);
    }

    SetLastError(dwErr);

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;
}


//---------------------------------------------------------------------------------------
//
//  _CatDBRemoveCatNameFromHashesListOfCatNames
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBRemoveCatNameFromHashesListOfCatNames(
    PJET_DB_STRUCT      pJetDBStruct,
    PCRYPT_DATA_BLOB    pHashBlob,
    LPWSTR              pwszCatBaseName)
{
    BOOL    fRet = TRUE;
    JET_ERR jerr;

    //
    // First, try to find the hash in the HashCatName table.
    //
    jerr = _CatDBSeekInHashCatNameTable(pJetDBStruct, pHashBlob);

    if (jerr == JET_errRecordNotFound)
    {
        //
        // Not found, this is OK since a single catalog may contain the same hash
        // twice, in which case by the second time the hash is being looked for
        // the row may already be gone.
        //
        goto CommonReturn;
    }
    else if (jerr == JET_errSuccess)
    {
        //
        // found
        //
        if (!_CatDBRemoveCatNameFromMultiValuedColumn(
                pJetDBStruct,
                pJetDBStruct->JetHashCatNameTableID,
                pJetDBStruct->JetHashCatNameTable_CatNameColumnID,
                pwszCatBaseName))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }
    }
    else if (_CatDBJET_errFailure(jerr))
    {
        //
        // error
        //
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

CommonReturn:

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetDatabase)
}


//---------------------------------------------------------------------------------------
//
//  _CatDBRemoveCatNameFromMultiValuedColumn
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBRemoveCatNameFromMultiValuedColumn(
    PJET_DB_STRUCT      pJetDBStruct,
    JET_TABLEID         jetTableID,
    JET_COLUMNID        jetColumnID,
    LPWSTR              pwszCatBaseName)
{
    BOOL            fRet            = TRUE;
    JET_ERR         jerr;
    JET_SETINFO     JetSetInfo;
    WCHAR           wszCatalogName[CATDB_MAX_CATNAME_LENGTH];
    DWORD           dwLength;
    JET_RETINFO     JetRetInfo;
    BOOL            fDeleteRow      = FALSE;
    unsigned long   iValueToDelete  = 0;

    //
    // Search for the CatName in the current row
    //
    memset(&JetRetInfo, 0, sizeof(JetRetInfo));
    JetRetInfo.cbStruct = sizeof(JetRetInfo);
    JetRetInfo.itagSequence = 1;
    jerr = JetRetrieveColumn(
                pJetDBStruct->JetSesID,
                jetTableID,
                jetColumnID,
                wszCatalogName,
                CATDB_MAX_CATNAME_LENGTH,
                &dwLength,
                JET_bitRetrieveCopy,
                &JetRetInfo);

    while (jerr == JET_errSuccess)
    {
        //
        // See if this is the one
        //
        if (0 == _wcsicmp(pwszCatBaseName, wszCatalogName))
        {
            iValueToDelete = JetRetInfo.itagSequence;

            if (JetRetInfo.itagSequence == 1)
            {
                //
                // If this CatName is the only one in the row, then
                //  set a flag to just delete the row
                //
                JetRetInfo.itagSequence = 2;
                jerr = JetRetrieveColumn(
                            pJetDBStruct->JetSesID,
                            jetTableID,
                            jetColumnID,
                            wszCatalogName,
                            CATDB_MAX_CATNAME_LENGTH,
                            &dwLength,
                            JET_bitRetrieveCopy,
                            &JetRetInfo);

                if (jerr == JET_wrnColumnNull)
                {
                    jerr = JET_errSuccess;
                    fDeleteRow = TRUE;
                }
            }
            break;
        }

        //
        // Setup for next loop
        //
        JetRetInfo.itagSequence++;
        jerr = JetRetrieveColumn(
                    pJetDBStruct->JetSesID,
                    jetTableID,
                    jetColumnID,
                    wszCatalogName,
                    CATDB_MAX_CATNAME_LENGTH,
                    &dwLength,
                    JET_bitRetrieveCopy,
                    &JetRetInfo);
    }

    //
    // Make sure the CatName was found
    //
    if (jerr == JET_wrnColumnNull)
    {
        //
        // Not found, this is OK
        //
        goto CommonReturn;

    }
    else if (_CatDBJET_errFailure(jerr))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    //
    // If this CatName is the only one in the row, then just delete the row,
    // otherwise, remove it from the multi-valued column
    //
    if (fDeleteRow)
    {
        if (_CatDBJET_errFailure(jerr  =
                JetDelete(
                    pJetDBStruct->JetSesID,
                    jetTableID)))
        {
            CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
        }
    }
    else
    {
        //
        // Remove the CatName from the current row
        //
        if (_CatDBJET_errFailure(jerr  =
                JetPrepareUpdate(
                    pJetDBStruct->JetSesID,
                    jetTableID,
                    JET_prepReplace)))
        {
            CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
        }

        memset(&JetSetInfo, 0, sizeof(JetSetInfo));
        JetSetInfo.cbStruct = sizeof(JetSetInfo);
        JetSetInfo.itagSequence = iValueToDelete;
        if (_CatDBJET_errFailure(jerr  =
                JetSetColumn(
                    pJetDBStruct->JetSesID,
                    jetTableID,
                    jetColumnID,
                    NULL,
                    0,
                    0,
                    &JetSetInfo)))
        {
            CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
        }

        if (_CatDBJET_errFailure(jerr  =
                JetUpdate(
                    pJetDBStruct->JetSesID,
                    jetTableID,
                    NULL,
                    0,
                    NULL)))
        {
            CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
        }
    }

CommonReturn:

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetDatabase)
}


//---------------------------------------------------------------------------------------
//
//  _CatDBRemoveCatNameFromCatNameTable
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBRemoveCatNameFromCatNameTable(
    PJET_DB_STRUCT      pJetDBStruct,
    LPWSTR              pwszCatBaseName)
{
    BOOL    fRet = TRUE;
    JET_ERR jerr;

    //
    // Delete this CatName from every row that contains it
    //
    jerr = JetMove(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetHashCatNameTableID,
                JET_MoveFirst,
                0);

    while (jerr == JET_errSuccess)
    {
        if (!_CatDBRemoveCatNameFromMultiValuedColumn(
                pJetDBStruct,
                pJetDBStruct->JetHashCatNameTableID,
                pJetDBStruct->JetHashCatNameTable_CatNameColumnID,
                pwszCatBaseName))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        //
        // Setup for next loop
        //
        jerr = JetMove(
                    pJetDBStruct->JetSesID,
                    pJetDBStruct->JetHashCatNameTableID,
                    JET_MoveNext,
                    0);
    }

    //
    // See if this was a real error, or just no more records
    //
    if ((jerr != JET_errNoCurrentRecord) && _CatDBJET_errFailure(jerr))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

CommonReturn:

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetDatabase)
}


//---------------------------------------------------------------------------------------
//
//  _CatDBRemoveCatNameFromBuddyTable
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBRemoveCatNameFromBuddyTable(
    PJET_DB_STRUCT      pJetDBStruct,
    LPWSTR              pwszCatBaseName)
{
    BOOL    fRet = TRUE;
    JET_ERR jerr;

    //
    // First, delete this CatName's buddy list
    //
    jerr = _CatDBSeekInCatNameBuddyTable(pJetDBStruct, pwszCatBaseName);

    if (jerr == JET_errSuccess)
    {
        if (_CatDBJET_errFailure(jerr  =
                JetDelete(
                    pJetDBStruct->JetSesID,
                    pJetDBStruct->JetCatNameBuddyTableID)))
        {
            CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
        }
    }

    //
    // Second, delete this CatName from everyone elses buddy list
    //
    jerr = JetMove(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetCatNameBuddyTableID,
                JET_MoveFirst,
                0);

    while (jerr == JET_errSuccess)
    {
        if (!_CatDBRemoveCatNameFromMultiValuedColumn(
                pJetDBStruct,
                pJetDBStruct->JetCatNameBuddyTableID,
                pJetDBStruct->JetCatNameBuddyTable_BuddyColumnID,
                pwszCatBaseName))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        //
        // Setup for next loop
        //
        jerr = JetMove(
                    pJetDBStruct->JetSesID,
                    pJetDBStruct->JetCatNameBuddyTableID,
                    JET_MoveNext,
                    0);
    }

    //
    // See if this was a real error, or just no more records
    //
    if ((jerr != JET_errNoCurrentRecord) && _CatDBJET_errFailure(jerr))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

CommonReturn:

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetDatabase)
}


//---------------------------------------------------------------------------------------
//
//  _CatDBAddCatNameAndCatNamesBuddyListToReturnCatNames
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBAddCatNameAndCatNamesBuddyListToReturnCatNames(
    PJET_DB_STRUCT              pJetDBStruct,
    LPWSTR                      pwszCatName,
    DWORD __RPC_FAR             *pdwNumCatalogNames,
    LPWSTR __RPC_FAR *__RPC_FAR *pppwszCatalogNames,
    BOOL                        fRecursiveCall)
{
    BOOL        fRet = TRUE;
    JET_ERR     jerr;
    JET_RETINFO JetRetInfo;
    WCHAR       wszCatalogName[CATDB_MAX_CATNAME_LENGTH];
    DWORD       dwLength;

    //
    // First add the original catname
    //
    if (!_CatDBAddCatNameToReturnBuddyListIfNotExist(
            pwszCatName,
            pdwNumCatalogNames,
            pppwszCatalogNames))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Seek to the catname's buddy list
    //
    jerr = _CatDBSeekInCatNameBuddyTable(pJetDBStruct, pwszCatName);

    if (jerr == JET_errSuccess)
    {
        //
        // Add all the catname's buddies, and catname's buddies' buddies (only do one recursion)
        //
        memset(&JetRetInfo, 0, sizeof(JetRetInfo));
        JetRetInfo.cbStruct = sizeof(JetRetInfo);
        JetRetInfo.itagSequence = 1;
        jerr = JetRetrieveColumn(
                    pJetDBStruct->JetSesID,
                    pJetDBStruct->JetCatNameBuddyTableID,
                    pJetDBStruct->JetCatNameBuddyTable_BuddyColumnID,
                    wszCatalogName,
                    CATDB_MAX_CATNAME_LENGTH,
                    &dwLength,
                    JET_bitRetrieveCopy,
                    &JetRetInfo);

        while (jerr == JET_errSuccess)
        {
            if (fRecursiveCall)
            {
                if (!_CatDBAddCatNameToReturnBuddyListIfNotExist(
                        wszCatalogName,
                        pdwNumCatalogNames,
                        pppwszCatalogNames))
                {
                    CATDBSVC_LOGERR_LASTERR()
                    goto ErrorReturn;
                }
            }
            else
            {
                //
                // Recurse to get the buddies' buddies
                //
                if (!_CatDBAddCatNameAndCatNamesBuddyListToReturnCatNames(
                        pJetDBStruct,
                        wszCatalogName,
                        pdwNumCatalogNames,
                        pppwszCatalogNames,
                        TRUE))
                {
                    CATDBSVC_LOGERR_LASTERR()
                    goto ErrorReturn;
                }
            }

            //
            // Re-seek to the catname's buddy list, since it could have moved in the
            // recursive call to this function
            //
            jerr = _CatDBSeekInCatNameBuddyTable(pJetDBStruct, pwszCatName);
            if (_CatDBJET_errFailure(jerr))
            {
                CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
            }

            //
            // Setup for next loop
            //
            JetRetInfo.itagSequence++;
            jerr = JetRetrieveColumn(
                        pJetDBStruct->JetSesID,
                        pJetDBStruct->JetCatNameBuddyTableID,
                        pJetDBStruct->JetCatNameBuddyTable_BuddyColumnID,
                        wszCatalogName,
                        CATDB_MAX_CATNAME_LENGTH,
                        &dwLength,
                        JET_bitRetrieveCopy,
                        &JetRetInfo);
        }

        //
        // Check to see if a real error occurred and not just a JET_wrnColumnNull
        //
        if (_CatDBJET_errFailure(jerr))
        {
            CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
        }
    }

CommonReturn:

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetDatabase)
}


//---------------------------------------------------------------------------------------
//
//  _CatDBAddCatNameToReturnBuddyListIfNotExist
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBAddCatNameToReturnBuddyListIfNotExist(
    LPWSTR                      pwszBuddy,
    DWORD __RPC_FAR             *pdwNumCatalogNames,
    LPWSTR __RPC_FAR *__RPC_FAR *pppwszCatalogNames)
{
    BOOL        fRet            = TRUE;
    DWORD       i;
    BOOL        fAlreadyExists  = FALSE;
    LPWSTR      *rgTemp         = NULL;

    //
    // First, see if the name already exists in the list
    //
    for (i=0; i<(*pdwNumCatalogNames); i++)
    {
        if (_wcsicmp((*pppwszCatalogNames)[i], pwszBuddy) == 0)
        {
            fAlreadyExists = TRUE;
            break;
        }
    }

    //
    // Add it if it doesn't already exist
    //
    if (!fAlreadyExists)
    {
        //
        // Allocate a new slot in the array of buddy names
        //
        if ((*pdwNumCatalogNames) == 0)
        {
            *pppwszCatalogNames = (LPWSTR __RPC_FAR *)
                    midl_user_allocate(sizeof(LPWSTR));
        }
        else
        {
            rgTemp = *pppwszCatalogNames;
            *pppwszCatalogNames =   (LPWSTR __RPC_FAR *)
                                    midl_user_reallocate(
                                        *pppwszCatalogNames,
                                        ((*pdwNumCatalogNames) + 1) * sizeof(LPWSTR));
        }

        //
        // Make sure allocation worked
        //
        if ((*pppwszCatalogNames) == NULL)
        {
            *pppwszCatalogNames = rgTemp;
            CATDBSVC_SETERR_LOG_RETURN(ERROR_NOT_ENOUGH_MEMORY, ErrorMemory)
        }

        (*pppwszCatalogNames)[(*pdwNumCatalogNames)] = (LPWSTR)
                midl_user_allocate((wcslen(pwszBuddy) + 1) * sizeof(WCHAR));

        if ((*pppwszCatalogNames)[(*pdwNumCatalogNames)] == NULL)
        {
            CATDBSVC_SETERR_LOG_RETURN(ERROR_NOT_ENOUGH_MEMORY, ErrorMemory)
        }
        wcscpy((*pppwszCatalogNames)[(*pdwNumCatalogNames)], pwszBuddy);
        (*pdwNumCatalogNames)++;
    }

CommonReturn:

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorMemory)
}


//---------------------------------------------------------------------------------------
//
//  _CatDBSeekInCatNameBuddyTable
//
//---------------------------------------------------------------------------------------
JET_ERR
_CatDBSeekInCatNameBuddyTable(
    PJET_DB_STRUCT      pJetDBStruct,
    LPWSTR              pwszBuddyRow)
{
    JET_ERR jerr;

    if (_CatDBJET_errFailure(jerr  =
            JetMakeKey(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetCatNameBuddyTableID,
                (BYTE const *) pwszBuddyRow,
                (wcslen(pwszBuddyRow) + 1) * sizeof(WCHAR),
                JET_bitNewKey)))
    {
        return jerr;
    }

    jerr = JetSeek(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetCatNameBuddyTableID,
                JET_bitSeekEQ);

    return jerr;
}


//---------------------------------------------------------------------------------------
//
//  _CatDBSeekInHashCatNameTable
//
//---------------------------------------------------------------------------------------
JET_ERR
_CatDBSeekInHashCatNameTable(
    PJET_DB_STRUCT      pJetDBStruct,
    PCRYPT_DATA_BLOB    pHashBlob)
{
    JET_ERR jerr;

    if (_CatDBJET_errFailure(jerr  =
            JetMakeKey(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetHashCatNameTableID,
                pHashBlob->pbData,
                pHashBlob->cbData,
                JET_bitNewKey)))
    {
        return jerr;
    }

    jerr = JetSeek(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetHashCatNameTableID,
                JET_bitSeekEQ);

    return jerr;
}


//---------------------------------------------------------------------------------------
//
//  _CatDBNotifyClients
//
//---------------------------------------------------------------------------------------
void
_CatDBNotifyClients(void)
{
    DWORD i = 0;

    EnterCriticalSection(&g_CatDBRegisterNotifyCS);

    while (i < g_NumNotificationStructs)
    {
        if (g_rgNotificationStructs[i].hDuplicatedNotificationHandle !=
                INVALID_HANDLE_VALUE)
        {
            SetEvent(g_rgNotificationStructs[i].hDuplicatedNotificationHandle);
        }
        i++;
    }

    LeaveCriticalSection(&g_CatDBRegisterNotifyCS);
}


//---------------------------------------------------------------------------------------
//
//  _CatDBCleanupClientNotifications
//
//---------------------------------------------------------------------------------------
void
_CatDBCleanupClientNotifications(void)
{
    DWORD i = 0;
    HANDLE *rgUnregisterHandles = NULL;
    HANDLE *rgProcessHandles = NULL;
    int nHandleIndex = -1;

    EnterCriticalSection(&g_CatDBRegisterNotifyCS);

    rgUnregisterHandles = (HANDLE *) _CatDBAlloc(sizeof(HANDLE) * g_NumNotificationStructs);
    rgProcessHandles = (HANDLE *) _CatDBAlloc(sizeof(HANDLE) * g_NumNotificationStructs);
    if ((rgUnregisterHandles == NULL) || (rgProcessHandles == NULL))
    {
        goto Return;
    }

    for (i=0; i<g_NumNotificationStructs; i++)
    {
        if (g_rgNotificationStructs[i].hDuplicatedNotificationHandle != INVALID_HANDLE_VALUE)
        {
            nHandleIndex++;

            g_rgNotificationStructs[i].ProcessID = 0;

            rgUnregisterHandles[nHandleIndex] = g_rgNotificationStructs[i].hRegisterWaitFor;
            g_rgNotificationStructs[i].hRegisterWaitFor = NULL;

            rgProcessHandles[nHandleIndex] = g_rgNotificationStructs[i].hClientProcess;
            g_rgNotificationStructs[i].hClientProcess = NULL;

            g_rgNotificationStructs[i].hNotificationHandle = INVALID_HANDLE_VALUE;

            CloseHandle(g_rgNotificationStructs[i].hDuplicatedNotificationHandle);
            g_rgNotificationStructs[i].hDuplicatedNotificationHandle =
                    INVALID_HANDLE_VALUE;

            g_rgNotificationStructs[i].lNotificationID = 0;
        }
    }

Return:

    LeaveCriticalSection(&g_CatDBRegisterNotifyCS);

    while (nHandleIndex >= 0)
    {
        UnregisterWaitEx(rgUnregisterHandles[nHandleIndex], INVALID_HANDLE_VALUE);
        CloseHandle(rgProcessHandles[nHandleIndex]);

        nHandleIndex--;
    }

    if (rgUnregisterHandles != NULL)
    {
        _CatDBFree(rgUnregisterHandles);
    }

    if (rgProcessHandles != NULL)
    {
        _CatDBFree(rgProcessHandles);
    }
}


//---------------------------------------------------------------------------------------
//
//  _CatDBCreateNewCatalogFileName
//
//---------------------------------------------------------------------------------------
#define SZ_UNIQUE_CAT_FILENAME_FORMAT   L"%X.CAT"
#define MAX_UNIQUE_CAT_FILES            0xffffffff

LPWSTR
_CatDBCreateNewCatalogFileName(
    LPCWSTR pwszCatalogFileDir,
    LPCWSTR pwszCatName,
    BOOL    *pfFileAlreadyExists)
{
    LPWSTR  pwszFullyQualifiedCatName   = NULL;
    WCHAR   pwszTempBaseName[56];
    BOOL    fUniqueFileNameFound;
    DWORD   dw;
    HANDLE  hTestFile                   = INVALID_HANDLE_VALUE;
    DWORD   dwLastErr                   = 0;

    if (pwszCatName != NULL)
    {
        //
        // The caller specified the cat name to use, so just concatenate the
        // the path and the name
        //
        if (NULL == (pwszFullyQualifiedCatName = _CATDBConstructWSTRPath(
                                                        pwszCatalogFileDir,
                                                        pwszCatName)))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        //
        // See if this file already exists by trying to create the file
        //
        hTestFile = CreateFileW(
                        pwszFullyQualifiedCatName,
                        GENERIC_WRITE | GENERIC_READ,
                        0, // dwShareMode
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL); // hTemplateFile

        dwLastErr = GetLastError();

        if ((hTestFile == INVALID_HANDLE_VALUE) &&
            (   (dwLastErr == ERROR_FILE_NOT_FOUND) ||
                (dwLastErr == ERROR_PATH_NOT_FOUND) ||
                (dwLastErr == ERROR_BAD_NETPATH)))
        {
            *pfFileAlreadyExists = FALSE;
        }
        else if (hTestFile == INVALID_HANDLE_VALUE)
        {
            *pfFileAlreadyExists = TRUE;
        }
        else
        {
            *pfFileAlreadyExists = TRUE;
            CloseHandle(hTestFile);
        }
    }
    else
    {
        *pfFileAlreadyExists = FALSE;

        //
        // Create a unique name for the directory in question
        //
        fUniqueFileNameFound = FALSE;
        dw = 1;

        while ((!fUniqueFileNameFound) && (dw != 0))  // (dw == 0) after rollover.
        {
            wsprintfW(pwszTempBaseName, SZ_UNIQUE_CAT_FILENAME_FORMAT, dw);
            if (NULL == (pwszFullyQualifiedCatName = _CATDBConstructWSTRPath(
                                                            pwszCatalogFileDir,
                                                            pwszTempBaseName)))

            if (pwszFullyQualifiedCatName == NULL)
            {
                CATDBSVC_LOGERR_LASTERR()
                goto ErrorReturn;
            }

            //
            // See if this is a unique file name by trying to create the file
            //
            hTestFile = CreateFileW(
                            pwszFullyQualifiedCatName,
                            GENERIC_WRITE | GENERIC_READ,
                            0, // dwShareMode
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL); // hTemplateFile

            if (hTestFile == INVALID_HANDLE_VALUE)
            {
                fUniqueFileNameFound = TRUE;
            }
            else
            {
                CloseHandle(hTestFile);

                //
                // Setup for next iteration
                //
                _CatDBFree(pwszFullyQualifiedCatName);
                pwszFullyQualifiedCatName = NULL;
                dw++;
            }
        }
    }

CommonReturn:

    return pwszFullyQualifiedCatName;

ErrorReturn:

    if (pwszFullyQualifiedCatName != NULL)
    {
        _CatDBFree(pwszFullyQualifiedCatName);
    }
    pwszFullyQualifiedCatName = NULL;

    goto CommonReturn;
}


//---------------------------------------------------------------------------------------
//
//  _CatDBFindAndDecodeHashInCatEntry
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBFindAndDecodeHashInCatEntry(
    PCTL_ENTRY                  pctlEntry,
    SPC_INDIRECT_DATA_CONTENT   **ppIndirectData)
{
    BOOL    fRet            = TRUE;
    DWORD   i;
    DWORD   cbIndirectData  = 0;

    *ppIndirectData = NULL;

    //
    // Search for the hash in the attributes
    //
    for (i=0; i<pctlEntry->cAttribute; i++)
    {
        if (strcmp(pctlEntry->rgAttribute[i].pszObjId, SPC_INDIRECT_DATA_OBJID) == 0)
        {
            break;
        }
    }

    //
    // Make sure the hash was found
    //
    if (i >= pctlEntry->cAttribute)
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorInvalidCatalogFormat;
    }

    //
    // decode the indirect data
    //
    if (!CryptDecodeObject(
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                SPC_INDIRECT_DATA_CONTENT_STRUCT,
                pctlEntry->rgAttribute[i].rgValue[0].pbData,
                pctlEntry->rgAttribute[i].rgValue[0].cbData,
                0,
                NULL,
                &cbIndirectData))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorCryptDecodeObject;
    }

    if (NULL == (*ppIndirectData = (SPC_INDIRECT_DATA_CONTENT *)
                    _CatDBAlloc(cbIndirectData)))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorMemory;
    }

    if (!CryptDecodeObject(
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                SPC_INDIRECT_DATA_CONTENT_STRUCT,
                pctlEntry->rgAttribute[i].rgValue[0].pbData,
                pctlEntry->rgAttribute[i].rgValue[0].cbData,
                0,
                *ppIndirectData,
                &cbIndirectData))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorCryptDecodeObject;
    }

CommonReturn:

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorInvalidCatalogFormat)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorCryptDecodeObject)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorMemory)
}



#define SZ_HASH_CATNAME_TABLE               "HashCatNameTable"
#define SZ_HASH_CATNAME_TABLE_HASHCOL       "HashCatNameTable_HashCol"
#define SZ_HASH_CATNAME_TABLE_CATNAMECOL    "HashCatNameTable_CatNameCol"
#define SZ_HASH_CATNAME_TABLE_INDEX         "HashCatNameTable_Index"
#define SZ_HASH_CATNAME_TABLE_INDEX_DEF     "+HashCatNameTable_HashCol\0"

#define SZ_CATNAME_BUDDY_TABLE              "CatNameBuddyTable"
#define SZ_CATNAME_BUDDY_TABLE_CATNAMECOL   "CatNameBuddyTable_CatNameCol"
#define SZ_CATNAME_BUDDY_TABLE_BUDDYCOL     "CatNameBuddyTable_BuddyCol"
#define SZ_CATNAME_BUDDY_TABLE_INDEX        "CatNameBuddyTable_Index"
#define SZ_CATNAME_BUDDY_TABLE_INDEX_DEF    "+CatNameBuddyTable_CatNameCol\0"


//---------------------------------------------------------------------------------------
//
//  _CatDBInitJetDatabaseParams
//
//---------------------------------------------------------------------------------------
typedef struct _DBJETPARAM
{
    DWORD paramid;
    DWORD lParam;
    char *pszParam;
} DBJETPARAM;


DBJETPARAM g_rgJetParams[] = {

#define JP_LOGPATH  0
    { JET_paramLogFilePath,        0,               NULL},

#define JP_SYSTEMPATH   1
    { JET_paramSystemPath,         0,               NULL},

#define JP_TEMPPATH 2
    { JET_paramTempPath,           0,               NULL},

    { JET_paramEventSource,        0,               "Catalog Database"},

    { JET_paramMaxVerPages,          1024,          NULL},

#if !defined(_M_IA64) && !defined(_M_AXP64)
    //{ JET_paramEventLogCache,        32768,         NULL},
#endif

    { JET_paramCircularLog,         1,              NULL},

    { JET_paramNoInformationEvent,  1,              NULL},

    { JET_paramAccessDeniedRetryPeriod, 1000,        NULL}
};
#define CDBPARAM    (sizeof(g_rgJetParams)/sizeof(g_rgJetParams[0]))


BOOL
_CatDBInitJetDatabaseParams(
    JET_INSTANCE    *pJetInstance)
{
    BOOL        fRet        = TRUE;
    JET_ERR     jerr;
    LPSTR       pszTempPath = NULL;

    DBJETPARAM  const *pjp;

    //
    // Create a temp path for cat db
    //
    if (NULL == (pszTempPath = _CatDBGetCatrootDirA()))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorGetSystemDirectory;
    }

    //
    // Initialize the Jet Parameters
    //
    g_rgJetParams[JP_LOGPATH].pszParam = pszTempPath;
    g_rgJetParams[JP_SYSTEMPATH].pszParam = pszTempPath;
    g_rgJetParams[JP_TEMPPATH].pszParam = pszTempPath;

    for (pjp = g_rgJetParams; pjp < &g_rgJetParams[CDBPARAM]; pjp++)
    {
        if (_CatDBJET_errFailure(jerr  =
                JetSetSystemParameter(
                    pJetInstance,
                    0,
                    pjp->paramid,
                    pjp->lParam,
                    pjp->pszParam)))
        {
            CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
        }
    }

CommonReturn:

    if (pszTempPath != NULL)
    {
        free(pszTempPath);
    }

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetDatabase)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorGetSystemDirectory)
}


//---------------------------------------------------------------------------------------
//
//  _CatDBGetColumnIDs
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBGetColumnIDs(
    PJET_DB_STRUCT  pJetDBStruct)
{
    BOOL            fRet                    = TRUE;
    JET_ERR         jerr;
    JET_COLUMNDEF   JetColumnDef;
    BOOL            fHashCatNameTableOpen   = FALSE;
    BOOL            fCatNameBuddyTableOpen  = FALSE;
    DWORD           dwErr                   = 0;

    //
    // Hash-CatName table and columns
    //
    if (_CatDBJET_errFailure(jerr  =
            JetOpenTable(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetDBID,
                SZ_HASH_CATNAME_TABLE,
                NULL,
                0,
                0,
                &(pJetDBStruct->JetHashCatNameTableID))))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }
    fHashCatNameTableOpen = TRUE;

    if (_CatDBJET_errFailure(jerr  =
            JetGetColumnInfo(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetDBID,
                SZ_HASH_CATNAME_TABLE,
                SZ_HASH_CATNAME_TABLE_HASHCOL,
                &JetColumnDef,
                sizeof(JetColumnDef),
                JET_ColInfo)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }
    pJetDBStruct->JetHashCatNameTable_HashColumnID = JetColumnDef.columnid;

    if (_CatDBJET_errFailure(jerr  =
            JetGetColumnInfo(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetDBID,
                SZ_HASH_CATNAME_TABLE,
                SZ_HASH_CATNAME_TABLE_CATNAMECOL,
                &JetColumnDef,
                sizeof(JetColumnDef),
                JET_ColInfo)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }
    pJetDBStruct->JetHashCatNameTable_CatNameColumnID = JetColumnDef.columnid;

    //
    // CatNameBuddy table and columns
    //
    if (_CatDBJET_errFailure(jerr  =
            JetOpenTable(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetDBID,
                SZ_CATNAME_BUDDY_TABLE,
                NULL,
                0,
                0,
                &(pJetDBStruct->JetCatNameBuddyTableID))))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }
    fCatNameBuddyTableOpen = TRUE;

    if (_CatDBJET_errFailure(jerr  =
            JetGetColumnInfo(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetDBID,
                SZ_CATNAME_BUDDY_TABLE,
                SZ_CATNAME_BUDDY_TABLE_CATNAMECOL,
                &JetColumnDef,
                sizeof(JetColumnDef),
                JET_ColInfo)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }
    pJetDBStruct->JetCatNameBuddyTable_CatNameColumnID = JetColumnDef.columnid;

    if (_CatDBJET_errFailure(jerr  =
            JetGetColumnInfo(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetDBID,
                SZ_CATNAME_BUDDY_TABLE,
                SZ_CATNAME_BUDDY_TABLE_BUDDYCOL,
                &JetColumnDef,
                sizeof(JetColumnDef),
                JET_ColInfo)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }
    pJetDBStruct->JetCatNameBuddyTable_BuddyColumnID = JetColumnDef.columnid;


CommonReturn:

    return fRet;

ErrorReturn:

    dwErr = GetLastError();

    if (fHashCatNameTableOpen)
    {
        JetCloseTable(pJetDBStruct->JetSesID, pJetDBStruct->JetHashCatNameTableID);
    }

    if (fCatNameBuddyTableOpen)
    {
        JetCloseTable(pJetDBStruct->JetSesID, pJetDBStruct->JetCatNameBuddyTableID);
    }

    SetLastError(dwErr);

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetDatabase)
}


//---------------------------------------------------------------------------------------
//
//  _CatDBCreateDBFile
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBCreateDBFile(
    PJET_DB_STRUCT  pJetDBStruct,
    LPSTR           pszDBFileName)
{
    BOOL            fRet                                        = TRUE;
    JET_ERR         jerr;
    JET_COLUMNDEF   JetColumnDef;
    BOOL            fDBFileOpen                                 = FALSE;
    BOOL            fDBFileCreated                              = FALSE;
    BOOL            fTransactionBegun                           = FALSE;
    DWORD           dwErr                                       = 0;
    JET_DBID        LocalJetDBID                                = 0;
    JET_TABLEID     LocalJetHashCatNameTableID                  = 0;
    JET_COLUMNID    LocalJetHashCatNameTable_HashColumnID       = 0;
    JET_COLUMNID    LocalJetHashCatNameTable_CatNameColumnID    = 0;
    JET_TABLEID     LocalJetCatNameBuddyTableID                 = 0;
    JET_COLUMNID    LocalJetCatNameBuddyTable_CatNameColumnID   = 0;
    JET_COLUMNID    LocalJetCatNameBuddyTable_BuddyColumnID     = 0;

    //
    // Create the actual db file
    //
    if (_CatDBJET_errFailure(jerr  =
            JetCreateDatabase(
                pJetDBStruct->JetSesID,
                pszDBFileName,
                NULL,
                &(LocalJetDBID),
                0)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }
    fDBFileCreated = TRUE;
    fDBFileOpen = TRUE;

    if (_CatDBJET_errFailure(jerr  =
            JetCloseDatabase(
                pJetDBStruct->JetSesID,
                LocalJetDBID,
                0)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }
    fDBFileOpen = FALSE;

    if (_CatDBJET_errFailure(jerr  =
            JetOpenDatabase(
                pJetDBStruct->JetSesID,
                pszDBFileName,
                NULL,
                &(LocalJetDBID),
                0)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }
    fDBFileOpen = TRUE;

    //
    // Add the whole schema to the db file (tables, columns, indexes)
    //

    if (_CatDBJET_errFailure(jerr  =
            JetBeginTransaction(pJetDBStruct->JetSesID)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }
    fTransactionBegun = TRUE;

    //
    // Create the hash-catname table, columns, and indexes
    //
    if (_CatDBJET_errFailure(jerr  =
            JetCreateTable(
                pJetDBStruct->JetSesID,
                LocalJetDBID,
                SZ_HASH_CATNAME_TABLE,
                4,
                100,
                &(LocalJetHashCatNameTableID))))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    if (_CatDBJET_errFailure(jerr  =
            JetCloseTable(
                pJetDBStruct->JetSesID,
                LocalJetHashCatNameTableID)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    if (_CatDBJET_errFailure(jerr  =
            JetOpenTable(
                pJetDBStruct->JetSesID,
                LocalJetDBID,
                SZ_HASH_CATNAME_TABLE,
                NULL,
                0,
                0,
                &(LocalJetHashCatNameTableID))))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    // Hash column
    memset(&JetColumnDef, 0, sizeof(JetColumnDef));
    JetColumnDef.cbStruct = sizeof(JetColumnDef);
    JetColumnDef.langid = 0x409;
    JetColumnDef.wCountry = 1;
    JetColumnDef.coltyp = JET_coltypBinary;
    JetColumnDef.grbit = JET_bitColumnNotNULL;

    if (_CatDBJET_errFailure(jerr  =
            JetAddColumn(
                pJetDBStruct->JetSesID,
                LocalJetHashCatNameTableID,
                SZ_HASH_CATNAME_TABLE_HASHCOL,
                &JetColumnDef,
                NULL,
                0,
                &(LocalJetHashCatNameTable_HashColumnID))))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    // CatName column
    memset(&JetColumnDef, 0, sizeof(JetColumnDef));
    JetColumnDef.cbStruct = sizeof(JetColumnDef);
    JetColumnDef.cp = 1200; // unicode (1200) instead of Ascii (1252)
    JetColumnDef.langid = 0x409;
    JetColumnDef.wCountry = 1;
    JetColumnDef.coltyp = JET_coltypText;
    JetColumnDef.cbMax = 255;
    JetColumnDef.grbit = JET_bitColumnMultiValued | JET_bitColumnTagged;

    if (_CatDBJET_errFailure(jerr  =
            JetAddColumn(
                pJetDBStruct->JetSesID,
                LocalJetHashCatNameTableID,
                SZ_HASH_CATNAME_TABLE_CATNAMECOL,
                &JetColumnDef,
                NULL,
                0,
                &(LocalJetHashCatNameTable_CatNameColumnID))))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    // Hash-CatName table index
    if (_CatDBJET_errFailure(jerr  =
            JetCreateIndex(
                pJetDBStruct->JetSesID,
                LocalJetHashCatNameTableID,
                SZ_HASH_CATNAME_TABLE_INDEX,
                JET_bitIndexPrimary,
                SZ_HASH_CATNAME_TABLE_INDEX_DEF,
                strlen(SZ_HASH_CATNAME_TABLE_INDEX_DEF) + 2,
                80)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    //
    // Create the CatName-Buddy table, columns, and indexes
    //
    if (_CatDBJET_errFailure(jerr  =
            JetCreateTable(
                pJetDBStruct->JetSesID,
                LocalJetDBID,
                SZ_CATNAME_BUDDY_TABLE,
                4,
                100,
                &(LocalJetCatNameBuddyTableID))))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    if (_CatDBJET_errFailure(jerr  =
            JetCloseTable(
                pJetDBStruct->JetSesID,
                LocalJetCatNameBuddyTableID)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    if (_CatDBJET_errFailure(jerr  =
            JetOpenTable(
                pJetDBStruct->JetSesID,
                LocalJetDBID,
                SZ_CATNAME_BUDDY_TABLE,
                NULL,
                0,
                0,
                &(LocalJetCatNameBuddyTableID))))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    // CatName column
    memset(&JetColumnDef, 0, sizeof(JetColumnDef));
    JetColumnDef.cbStruct = sizeof(JetColumnDef);
    JetColumnDef.cp = 1200; // unicode (1200) instead of Ascii (1252)
    JetColumnDef.langid = 0x409;
    JetColumnDef.wCountry = 1;
    JetColumnDef.coltyp = JET_coltypText;
    JetColumnDef.cbMax = 255;
    JetColumnDef.grbit = JET_bitColumnNotNULL;

    if (_CatDBJET_errFailure(jerr  =
            JetAddColumn(
                pJetDBStruct->JetSesID,
                LocalJetCatNameBuddyTableID,
                SZ_CATNAME_BUDDY_TABLE_CATNAMECOL,
                &JetColumnDef,
                NULL,
                0,
                &(LocalJetCatNameBuddyTable_CatNameColumnID))))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    // Buddy column
    memset(&JetColumnDef, 0, sizeof(JetColumnDef));
    JetColumnDef.cbStruct = sizeof(JetColumnDef);
    JetColumnDef.cp = 1200; // unicode (1200) instead of Ascii (1252)
    JetColumnDef.langid = 0x409;
    JetColumnDef.wCountry = 1;
    JetColumnDef.coltyp = JET_coltypText;
    JetColumnDef.cbMax = 255;
    JetColumnDef.grbit = JET_bitColumnMultiValued | JET_bitColumnTagged;

    if (_CatDBJET_errFailure(jerr  =
            JetAddColumn(
                pJetDBStruct->JetSesID,
                LocalJetCatNameBuddyTableID,
                SZ_CATNAME_BUDDY_TABLE_BUDDYCOL,
                &JetColumnDef,
                NULL,
                0,
                &(LocalJetCatNameBuddyTable_BuddyColumnID))))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    // CatName-Buddy table index
    if (_CatDBJET_errFailure(jerr  =
            JetCreateIndex(
                pJetDBStruct->JetSesID,
                LocalJetCatNameBuddyTableID,
                SZ_CATNAME_BUDDY_TABLE_INDEX,
                JET_bitIndexPrimary,
                SZ_CATNAME_BUDDY_TABLE_INDEX_DEF,
                strlen(SZ_CATNAME_BUDDY_TABLE_INDEX_DEF) + 2,
                80)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    //
    // Now that all the schema has been successfully added, COMMIT
    //
    if (_CatDBJET_errFailure(jerr  =
            JetCommitTransaction(
                pJetDBStruct->JetSesID,
                0)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    if (_CatDBJET_errFailure(jerr  =
            JetCloseDatabase(
                pJetDBStruct->JetSesID,
                LocalJetDBID,
                0)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

CommonReturn:

    return fRet;

ErrorReturn:

    dwErr = GetLastError();

    if (fTransactionBegun)
    {
        JetRollback(pJetDBStruct->JetSesID, 0);
    }

    if (fDBFileOpen)
    {
        JetCloseDatabase(
                pJetDBStruct->JetSesID,
                LocalJetDBID,
                0);
    }

    if (fDBFileCreated)
    {
        DeleteFileA(pszDBFileName);
    }

    SetLastError(dwErr);

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetDatabase)
}


//---------------------------------------------------------------------------------------
//
//  _CatDBAttachAndOpenDatabase
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBAttachAndOpenDatabase(
    JET_DB_STRUCT   *pJetDBStruct,
    BOOL            fReadOnly)
{
    BOOL    fRet            = TRUE;
    JET_ERR jerr;
    BOOL    fJetDBFileOpen  = FALSE;
    DWORD   dwErr           = 0;

    //
    // Try to attach the existing database, if it doesn't already exist,
    // then create it
    //
    jerr = JetAttachDatabase(
                pJetDBStruct->JetSesID,
                pJetDBStruct->pszDBFileName,
                0); //fReadOnly ? JET_bitDbReadOnly : 0);

    if (jerr == JET_errFileNotFound)
    {
        //
        // The DB file doesn't exist yet, so create it
        //
        if (!_CatDBCreateDBFile(
                pJetDBStruct,
                pJetDBStruct->pszDBFileName))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }
    }
    else if (_CatDBJET_errFailure(jerr))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    if (_CatDBJET_errFailure(jerr =
            JetOpenDatabase(
                pJetDBStruct->JetSesID,
                pJetDBStruct->pszDBFileName,
                NULL,
                &(pJetDBStruct->JetDBID),
                0)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }
    fJetDBFileOpen = TRUE;

    if (!_CatDBGetColumnIDs(pJetDBStruct))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Set the current indexes for both tables so all seeks work
    //
    if (_CatDBJET_errFailure(jerr =
            JetSetCurrentIndex(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetHashCatNameTableID,
                NULL))) // NULL == primary index
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    if (_CatDBJET_errFailure(jerr =
            JetSetCurrentIndex(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetCatNameBuddyTableID,
                NULL))) // NULL == primary index
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }
CommonReturn:

    return fRet;

ErrorReturn:

    dwErr = GetLastError();

    if (fJetDBFileOpen)
    {
        JetCloseDatabase(pJetDBStruct->JetSesID, pJetDBStruct->JetDBID, 0);
    }

    SetLastError(dwErr);

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetDatabase)
}



//---------------------------------------------------------------------------------------
//
//  _CatDBCloseDatabaseFile
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBCloseDatabaseFile(
    PJET_DB_STRUCT  pJetDBStruct,
    BOOL            fDetach)
{
    BOOL            fRet            = TRUE;
    JET_ERR         jerr;


    if (_CatDBJET_errFailure(jerr =
            JetCloseTable(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetHashCatNameTableID)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    if (_CatDBJET_errFailure(jerr =
            JetCloseTable(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetCatNameBuddyTableID)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    if (_CatDBJET_errFailure(jerr =
            JetCloseDatabase(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetDBID,
                0)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    if (fDetach)
    {
        if (_CatDBJET_errFailure(jerr =
                JetDetachDatabase(
                    pJetDBStruct->JetSesID,
                    pJetDBStruct->pszDBFileName)))
        {
            CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
        }
    }

    if (_CatDBJET_errFailure(jerr =
            JetEndSession(
                pJetDBStruct->JetSesID,
                0)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

CommonReturn:

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetDatabase)
}


//---------------------------------------------------------------------------------------
//
//  _CatDBCatalogFileAlreadyInstalled
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBCatalogFileAlreadyInstalled(
    LPCWSTR pwszCatalogToBeAdded,
    LPCWSTR pwszExistingCatalog)
{
    BOOL    fRet            = TRUE;
    HANDLE  h1              = NULL;
    HANDLE  h2              = NULL;
    BYTE    rgbHash1[20];
    BYTE    rgbHash2[20];
    DWORD   cbHash1         = 20;
    DWORD   cbHash2         = 20;

    //
    // Open both files
    //

    h1 = CreateFileW(
                pwszCatalogToBeAdded,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL); // hTemplateFile

    if (h1 == NULL)
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    h2 = CreateFileW(
                pwszExistingCatalog,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL); // hTemplateFile

    if (h1 == NULL)
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Get the hash for each file
    //

    if (!CryptCATAdminCalcHashFromFileHandle(
                h1,
                &cbHash1,
                rgbHash1,
                0))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    if (!CryptCATAdminCalcHashFromFileHandle(
                h2,
                &cbHash2,
                rgbHash2,
                0))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Compare the hashes to see if they are the same
    //
    if (memcmp(rgbHash1, rgbHash2, 20) == 0)
    {
        fRet = TRUE;
    }

Return:

    if (h1 != NULL)
    {
        CloseHandle(h1);
    }

    if (h2 != NULL)
    {
        CloseHandle(h2);
    }

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  _CatDBFreeze
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBFreeze()
{
    //
    // Freeze all incomming requests
    //
    ResetEvent(g_hNotFrozen);

    //
    // Close all open instances of all databased (which also detaches automatically)
    //
    if (!_CatDBCloseCachedDatabases(TRUE))
    {
        CATDBSVC_LOGERR_LASTERR()
        return FALSE;
    }

    return TRUE;
}


//---------------------------------------------------------------------------------------
//
//  _CatDBThaw
//
//---------------------------------------------------------------------------------------
VOID
_CatDBThaw()
{
    //
    // Unfreeze all incomming requests
    //
    SetEvent(g_hNotFrozen);
}


//---------------------------------------------------------------------------------------
//
//  _CatDBJET_errFailure
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBJET_errFailure(
    JET_ERR             jerr)
{
    if (jerr == JET_errSuccess)
    {
        return FALSE;
    }
    else if (jerr & 0x80000000)
    {
        //
        // Jet errors are negative numbers, jet warnings are positive
        //
        return TRUE;
    }
    else
    {
        CATDBSVC_LOGWARN(_CatDBMapJetError(jerr))
        return FALSE;
    }
}


//---------------------------------------------------------------------------------------
//
//  _CatDBMapJetError
//
//---------------------------------------------------------------------------------------
DWORD
_CatDBMapJetError(JET_ERR jerr)
{
    // FIX FIX
    return jerr;//ERROR_DATABASE_FAILURE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\crypstub\dpapistb.cpp ===
/*++

Copyright (C) 2000  Microsoft Corporation

Module Name:

    dpapistb.cpp

Abstract:

    RPC Proxy Stub to handle downlevel requests to the services.exe 
    pipe

Author:

    petesk   3/1/00

Revisions:


--*/

#define _CRYPT32_   // use correct Dll Linkage

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wincrypt.h>


// midl generated files
#include "dpapiprv.h"
#include "keyrpc.h"





DWORD
s_BackuprKey(
    /* [in] */ handle_t h,
    /* [in] */ GUID __RPC_FAR *pguidActionAgent,
    /* [in] */ BYTE __RPC_FAR *pDataIn,
    /* [in] */ DWORD cbDataIn,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppDataOut,
    /* [out] */ DWORD __RPC_FAR *pcbDataOut,
    /* [in] */ DWORD dwParam
    )
{

    RPC_BINDING_HANDLE hProxy = NULL;
    WCHAR *pStringBinding = NULL;
    RPC_SECURITY_QOS RpcQos;

    RPC_STATUS RpcStatus = RPC_S_OK;


    RpcStatus = RpcImpersonateClient(h);

    if (RPC_S_OK != RpcStatus)
    {
        return RpcStatus;
    }

    RpcStatus = RpcStringBindingComposeW(
                          NULL,
                          DPAPI_LOCAL_PROT_SEQ,
                          NULL,
                          DPAPI_LOCAL_ENDPOINT,
                          NULL,
                          &pStringBinding);
    if (RPC_S_OK != RpcStatus)
    {
        goto error;
    }

    RpcStatus = RpcBindingFromStringBindingW(
                                pStringBinding,
                                &hProxy);
    if (NULL != pStringBinding)
    {
        RpcStringFreeW(&pStringBinding);
    }
    if (RPC_S_OK != RpcStatus)
    {
        goto error;
    }

    RpcStatus = RpcEpResolveBinding(
                        hProxy,
                        BackupKey_v1_0_c_ifspec);
    if (RPC_S_OK != RpcStatus)
    {
        goto error;

    }

    __try
    {

        RpcStatus = BackuprKey(
                        hProxy,
                        (GUID*)pguidActionAgent,
                        pDataIn,
                        cbDataIn,
                        ppDataOut,
                        pcbDataOut,
                        dwParam
                        );

    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        RpcStatus = _exception_code();
    }

error:

    if(hProxy)
    {
        RpcBindingFree(&hProxy);
    }

    RpcRevertToSelf();

    return RpcStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\cryptsvc\certprot.cpp ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    certprot.cpp

Abstract:

    This module contains routines associated with server side 
    I_CertProtectFunctions operations.

Author:

    Phil Hallin (philh)     19-Nov-97

--*/

#include <windows.h>
#include <wincrypt.h>

#include "cerrpc.h" // header file generated by MIDL compiler
#include "certprot.h"



///////////////////////////////////////////////////////////////////////
// LPC-exposed functions

//
// these functions return a DWORD equivalent to GetLastError().
// the client side stub code will check if the return code is not
// ERROR_SUCCESS, and if this is the case, the client stub will return
// FALSE and SetLastError() to this DWORD.
//

DWORD s_SSCertProtectFunction( 
    /* [in] */ handle_t h,
    /* [in] */ DWORD dwFuncId,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pwszIn,
    /* [size_is][in] */ BYTE __RPC_FAR *pbIn,
    /* [in] */ DWORD cbIn,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbOut,
    /* [out] */ DWORD __RPC_FAR *pcbOut)
{
    DWORD dwRet;

    __try {

        {
            HINSTANCE hCrypt32Dll;
            PFN_CERT_SRV_PROTECT_FUNCTION pfnCertSrvProtectFunction;

            *ppbOut = NULL;
            *pcbOut = 0;
            hCrypt32Dll = LoadLibraryW(L"crypt32.dll");
            if (hCrypt32Dll == NULL) {
                dwRet = GetLastError();
                goto Ret;
            }

            if (NULL == (pfnCertSrvProtectFunction =
                    (PFN_CERT_SRV_PROTECT_FUNCTION) GetProcAddress(
                        hCrypt32Dll, "I_CertSrvProtectFunction")))
                dwRet = ERROR_PROC_NOT_FOUND;
            else
                dwRet = pfnCertSrvProtectFunction(
                    h,
                    dwFuncId,
                    dwFlags,
                    pwszIn,
                    pbIn,
                    cbIn,
                    ppbOut,
                    pcbOut,
                    midl_user_allocate,
                    midl_user_free
                    );
            FreeLibrary(hCrypt32Dll);
            goto Ret;
        }

    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        dwRet = GetExceptionCode();
        // TODO: for NT, convert exception code to winerror.
        //       for 95, just override to access violation.
    }

Ret:
    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\crypstub\keysvr.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntsecapi.h>
#include <wincrypt.h>
#include <userenv.h>
#include <lmcons.h>
#include <certca.h>
#include "keysvc.h"
#include "cryptui.h"
#include "lenroll.h"
#include "keysvcc.h"

DWORD BindLocalKeyService(handle_t *hProxy);



// key service stub functions
ULONG       s_KeyrOpenKeyService(
/* [in]  */     handle_t                        hRPCBinding,
/* [in]  */     KEYSVC_TYPE                     OwnerType,
/* [in]  */     PKEYSVC_UNICODE_STRING          pOwnerName,
/* [in]  */     ULONG                           ulDesiredAccess,
/* [in]  */     PKEYSVC_BLOB                    pAuthentication,
/* [in, out] */ PKEYSVC_BLOB                    *ppReserved,
/* [out] */     KEYSVC_HANDLE                   *phKeySvc)
{
    RPC_BINDING_HANDLE hProxy = NULL;


    RPC_STATUS RpcStatus = RPC_S_OK;

    RpcStatus = RpcImpersonateClient(hRPCBinding);

    if (RPC_S_OK != RpcStatus)
    {
        return RpcStatus;
    }
    RpcStatus = BindLocalKeyService(&hProxy);
    if(RPC_S_OK != RpcStatus)
    {
        goto error;
    }

    __try
    {
        RpcStatus = s_KeyrOpenKeyService(
                                        hProxy,
                                        OwnerType,
                                        pOwnerName,
                                        ulDesiredAccess,
                                        pAuthentication,
                                        ppReserved,
                                        phKeySvc);

    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        RpcStatus = _exception_code();
    }
error:

    if(hProxy)
    {
        RpcBindingFree(&hProxy);
    }

    RpcRevertToSelf();

    return RpcStatus;

}

ULONG       s_KeyrEnumerateProviders(
/* [in] */      handle_t                        hRPCBinding,
/* [in] */      KEYSVC_HANDLE                   hKeySvc,
/* [in, out] */ PKEYSVC_BLOB                    *ppReserved,
/* [in, out] */ ULONG                           *pcProviderCount,
/* [in, out][size_is(,*pcProviderCount)] */
                PKEYSVC_PROVIDER_INFO           *ppProviders)
{
        RPC_BINDING_HANDLE hProxy = NULL;


    RPC_STATUS RpcStatus = RPC_S_OK;

    RpcStatus = RpcImpersonateClient(hRPCBinding);

    if (RPC_S_OK != RpcStatus)
    {
        return RpcStatus;
    }
    RpcStatus = BindLocalKeyService(&hProxy);
    if(RPC_S_OK != RpcStatus)
    {
        goto error;
    }

    __try
    {
        RpcStatus = s_KeyrEnumerateProviders(
                                                hProxy,
                                                hKeySvc,
                                                ppReserved,
                                                pcProviderCount,
                                                ppProviders);

    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        RpcStatus = _exception_code();
    }
error:

    if(hProxy)
    {
        RpcBindingFree(&hProxy);
    }

    RpcRevertToSelf();

    return RpcStatus;
}

ULONG       s_KeyrEnumerateProviderTypes(
/* [in] */      handle_t                        hRPCBinding,
/* [in] */      KEYSVC_HANDLE                   hKeySvc,
/* [in, out] */ PKEYSVC_BLOB                    *ppReserved,
/* [in, out] */ ULONG                           *pcProviderCount,
/* [in, out][size_is(,*pcProviderCount)] */
                PKEYSVC_PROVIDER_INFO           *ppProviders)
{
    return ERROR_CALL_NOT_IMPLEMENTED; 
}


ULONG       s_KeyrEnumerateProvContainers(
/* [in] */      handle_t                        hRPCBinding,
/* [in] */      KEYSVC_HANDLE                   hKeySvc,
/* [in] */      KEYSVC_PROVIDER_INFO            Provider,
/* [in, out] */ PKEYSVC_BLOB                    *ppReserved,
/* [in, out] */ ULONG                           *pcContainerCount,
/* [in, out][size_is(,*pcContainerCount)] */
                PKEYSVC_UNICODE_STRING          *ppContainers)
{
    return ERROR_CALL_NOT_IMPLEMENTED; 
}


ULONG       s_KeyrCloseKeyService(
/* [in] */      handle_t                        hRPCBinding,
/* [in] */      KEYSVC_HANDLE                   hKeySvc,
/* [in, out] */ PKEYSVC_BLOB                    *ppReserved)
{
        RPC_BINDING_HANDLE hProxy = NULL;


    RPC_STATUS RpcStatus = RPC_S_OK;

    RpcStatus = RpcImpersonateClient(hRPCBinding);

    if (RPC_S_OK != RpcStatus)
    {
        return RpcStatus;
    }
    RpcStatus = BindLocalKeyService(&hProxy);
    if(RPC_S_OK != RpcStatus)
    {
        goto error;
    }

    __try
    {
        RpcStatus = s_KeyrCloseKeyService(
                                            hProxy,
                                            hKeySvc,
                                            ppReserved);

    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        RpcStatus = _exception_code();
    }
error:

    if(hProxy)
    {
        RpcBindingFree(&hProxy);
    }

    RpcRevertToSelf();

    return RpcStatus;
}

ULONG       s_KeyrGetDefaultProvider(
/* [in] */      handle_t                        hRPCBinding,
/* [in] */      KEYSVC_HANDLE                   hKeySvc,
/* [in] */      ULONG                           ulProvType,
/* [in] */      ULONG                           ulFlags,
/* [in, out] */ PKEYSVC_BLOB                    *ppReserved,
/* [out] */     ULONG                           *pulDefType,
/* [out] */     PKEYSVC_PROVIDER_INFO           *ppProvider)
{
        RPC_BINDING_HANDLE hProxy = NULL;


    RPC_STATUS RpcStatus = RPC_S_OK;

    RpcStatus = RpcImpersonateClient(hRPCBinding);

    if (RPC_S_OK != RpcStatus)
    {
        return RpcStatus;
    }
    RpcStatus = BindLocalKeyService(&hProxy);
    if(RPC_S_OK != RpcStatus)
    {
        goto error;
    }

    __try
    {
        RpcStatus = s_KeyrGetDefaultProvider(
                                        hProxy,
                                        hKeySvc,
                                        ulProvType,
                                        ulFlags,
                                        ppReserved,
                                        pulDefType,
                                        ppProvider);

    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        RpcStatus = _exception_code();
    }
error:

    if(hProxy)
    {
        RpcBindingFree(&hProxy);
    }

    RpcRevertToSelf();

    return RpcStatus;
}

ULONG       s_KeyrSetDefaultProvider(
/* [in] */      handle_t                        hRPCBinding,
/* [in] */      KEYSVC_HANDLE                   hKeySvc,
/* [in] */      ULONG                           ulFlags,
/* [in, out] */ PKEYSVC_BLOB                    *ppReserved,
/* [in] */      KEYSVC_PROVIDER_INFO            Provider)
{
    return ERROR_CALL_NOT_IMPLEMENTED; 
}

ULONG s_KeyrEnroll(
/* [in] */      handle_t                        hRPCBinding,
/* [in] */      BOOL                            fKeyService,
/* [in] */      ULONG                           ulPurpose,
/* [in] */      PKEYSVC_UNICODE_STRING          pAcctName,
/* [in] */      PKEYSVC_UNICODE_STRING          pCALocation,
/* [in] */      PKEYSVC_UNICODE_STRING          pCAName,
/* [in] */      BOOL                            fNewKey,
/* [in] */      PKEYSVC_CERT_REQUEST_PVK_NEW    pKeyNew,
/* [in] */      PKEYSVC_BLOB __RPC_FAR          pCert,
/* [in] */      PKEYSVC_CERT_REQUEST_PVK_NEW    pRenewKey,
/* [in] */      PKEYSVC_UNICODE_STRING          pHashAlg,
/* [in] */      PKEYSVC_UNICODE_STRING          pDesStore,
/* [in] */      ULONG                           ulStoreFlags,
/* [in] */      PKEYSVC_CERT_ENROLL_INFO        pRequestInfo,
/* [in] */      ULONG                           ulFlags,
/* [out][in] */ PKEYSVC_BLOB __RPC_FAR          *ppReserved,
/* [out] */     PKEYSVC_BLOB __RPC_FAR          *ppPKCS7Blob,
/* [out] */     PKEYSVC_BLOB __RPC_FAR          *ppHashBlob,
/* [out] */     ULONG __RPC_FAR                 *pulStatus)
{
        RPC_BINDING_HANDLE hProxy = NULL;


    RPC_STATUS RpcStatus = RPC_S_OK;

    RpcStatus = RpcImpersonateClient(hRPCBinding);

    if (RPC_S_OK != RpcStatus)
    {
        return RpcStatus;
    }
    RpcStatus = BindLocalKeyService(&hProxy);
    if(RPC_S_OK != RpcStatus)
    {
        goto error;
    }

    __try
    {
        RpcStatus = s_KeyrEnroll(
                                hProxy,
                                fKeyService,
                                ulPurpose,
                                pAcctName,
                                pCALocation,
                                pCAName,
                                fNewKey,
                                pKeyNew,
                                pCert,
                                pRenewKey,
                                pHashAlg,
                                pDesStore,
                                ulStoreFlags,
                                pRequestInfo,
                                ulFlags,
                                ppReserved,
                                ppPKCS7Blob,
                                ppHashBlob,
                                pulStatus);

    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        RpcStatus = _exception_code();
    }
error:

    if(hProxy)
    {
        RpcBindingFree(&hProxy);
    }

    RpcRevertToSelf();

    return RpcStatus;
}


ULONG s_KeyrExportCert(
/* [in] */      handle_t hRPCBinding,
/* [in] */      KEYSVC_HANDLE hKeySvc,
/* [in] */      PKEYSVC_UNICODE_STRING pPassword,
/* [in] */      PKEYSVC_UNICODE_STRING pCertStore,
/* [in] */      ULONG cHashCount,
/* [size_is][in] */
                KEYSVC_CERT_HASH *pHashes,
/* [in] */      ULONG ulFlags,
/* [in, out] */ PKEYSVC_BLOB *ppReserved,
/* [out] */     PKEYSVC_BLOB *ppPFXBlob)
{
    return ERROR_CALL_NOT_IMPLEMENTED; 
}


ULONG       s_KeyrImportCert(
/* [in] */      handle_t                        hRPCBinding,
/* [in] */      KEYSVC_HANDLE                   hKeySvc,
/* [in] */      PKEYSVC_UNICODE_STRING          pPassword,
/* [in] */      KEYSVC_UNICODE_STRING           *pCertStore,
/* [in] */      PKEYSVC_BLOB                    pPFXBlob,
/* [in] */      ULONG                           ulFlags,
/* [in, out] */ PKEYSVC_BLOB                    *ppReserved)
{
    return ERROR_CALL_NOT_IMPLEMENTED; 
}

ULONG s_KeyrEnumerateAvailableCertTypes(

    /* [in] */      handle_t                        hRPCBinding,
    /* [in] */      KEYSVC_HANDLE                   hKeySvc,
    /* [in, out] */ PKEYSVC_BLOB                    *ppReserved,
    /* [out][in] */ ULONG *pcCertTypeCount,
    /* [in, out][size_is(,*pcCertTypeCount)] */
                     PKEYSVC_UNICODE_STRING *ppCertTypes)

{
        RPC_BINDING_HANDLE hProxy = NULL;


    RPC_STATUS RpcStatus = RPC_S_OK;

    RpcStatus = RpcImpersonateClient(hRPCBinding);

    if (RPC_S_OK != RpcStatus)
    {
        return RpcStatus;
    }
    RpcStatus = BindLocalKeyService(&hProxy);
    if(RPC_S_OK != RpcStatus)
    {
        goto error;
    }

    __try
    {
        RpcStatus = s_KeyrEnumerateAvailableCertTypes(
                                                        hProxy,
                                                        hKeySvc,
                                                        ppReserved,
                                                        pcCertTypeCount,
                                                        ppCertTypes);

    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        RpcStatus = _exception_code();
    }
error:

    if(hProxy)
    {
        RpcBindingFree(&hProxy);
    }

    RpcRevertToSelf();

    return RpcStatus;
}




ULONG s_KeyrEnumerateCAs(

    /* [in] */      handle_t                        hRPCBinding,
    /* [in] */      KEYSVC_HANDLE                   hKeySvc,
    /* [in, out] */ PKEYSVC_BLOB                    *ppReserved,
    /* [in] */      ULONG                           ulFlags,
    /* [out][in] */ ULONG                           *pcCACount,
    /* [in, out][size_is(,*pcCACount)] */
               PKEYSVC_UNICODE_STRING               *ppCAs)

{
        RPC_BINDING_HANDLE hProxy = NULL;


    RPC_STATUS RpcStatus = RPC_S_OK;

    RpcStatus = RpcImpersonateClient(hRPCBinding);

    if (RPC_S_OK != RpcStatus)
    {
        return RpcStatus;
    }
    RpcStatus = BindLocalKeyService(&hProxy);
    if(RPC_S_OK != RpcStatus)
    {
        goto error;
    }

    __try
    {
        RpcStatus = s_KeyrEnumerateCAs(
                                hProxy,
                                hKeySvc,
                                ppReserved,
                                ulFlags,
                                pcCACount,
                                ppCAs);

    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        RpcStatus = _exception_code();
    }
error:

    if(hProxy)
    {
        RpcBindingFree(&hProxy);
    }

    RpcRevertToSelf();

    return RpcStatus;
}


DWORD BindLocalKeyService(handle_t *hProxy)
{

    WCHAR *pStringBinding = NULL;
    *hProxy = NULL;

    RPC_STATUS RpcStatus = RPC_S_OK;

    RpcStatus = RpcStringBindingComposeW(
                          NULL,
                          KEYSVC_LOCAL_PROT_SEQ,
                          NULL,
                          KEYSVC_LOCAL_ENDPOINT,
                          NULL,
                          &pStringBinding);
    if (RPC_S_OK != RpcStatus)
    {
        goto error;
    }

    RpcStatus = RpcBindingFromStringBindingW(
                                pStringBinding,
                                hProxy);

    if (RPC_S_OK != RpcStatus)
    {
        goto error;
    }

    RpcStatus = RpcEpResolveBinding(
                        *hProxy,
                        IKeySvc_v1_0_c_ifspec);
    if (RPC_S_OK != RpcStatus)
    {
        if(*hProxy)
        {
            RpcBindingFree(hProxy);
            *hProxy = NULL;
        }
        goto error;

    }

error:
    if (NULL != pStringBinding)
    {
        RpcStringFreeW(&pStringBinding);
    }
    return RpcStatus;
}

ULONG s_KeyrEnroll_V2
 (/* [in] */      handle_t                        hRPCBinding,
 /* [in] */      BOOL                            fKeyService,
 /* [in] */      ULONG                           ulPurpose,
 /* [in] */      ULONG                           ulFlags,
 /* [in] */      PKEYSVC_UNICODE_STRING          pAcctName,
 /* [in] */      PKEYSVC_UNICODE_STRING          pCALocation,
 /* [in] */      PKEYSVC_UNICODE_STRING          pCAName,
 /* [in] */      BOOL                            fNewKey,
 /* [in] */      PKEYSVC_CERT_REQUEST_PVK_NEW_V2 pKeyNew,
 /* [in] */      PKEYSVC_BLOB __RPC_FAR          pCert,
 /* [in] */      PKEYSVC_CERT_REQUEST_PVK_NEW_V2 pRenewKey,
 /* [in] */      PKEYSVC_UNICODE_STRING          pHashAlg,
 /* [in] */      PKEYSVC_UNICODE_STRING          pDesStore,
 /* [in] */      ULONG                           ulStoreFlags,
 /* [in] */      PKEYSVC_CERT_ENROLL_INFO        pRequestInfo,
 /* [in] */      ULONG                           ulReservedFlags,
 /* [out][in] */ PKEYSVC_BLOB __RPC_FAR          *ppReserved,
 /* [out][in] */ PKEYSVC_BLOB __RPC_FAR          *ppRequest,
 /* [out] */     PKEYSVC_BLOB __RPC_FAR          *ppPKCS7Blob,
 /* [out] */     PKEYSVC_BLOB __RPC_FAR          *ppHashBlob,
 /* [out] */     ULONG __RPC_FAR                 *pulStatus)
 {
     RPC_BINDING_HANDLE hProxy = NULL;


     RPC_STATUS RpcStatus = RPC_S_OK;

     RpcStatus = RpcImpersonateClient(hRPCBinding);

     if (RPC_S_OK != RpcStatus)
     {
         return RpcStatus;
     }
     RpcStatus = BindLocalKeyService(&hProxy);
     if(RPC_S_OK != RpcStatus)
     {
         goto error;
     }

     __try
     {
         RpcStatus = s_KeyrEnroll_V2(
                                 hProxy,
                                 fKeyService,
                                 ulPurpose,
                                 ulFlags,
                                 pAcctName,
                                 pCALocation,
                                 pCAName,
                                 fNewKey,
                                 pKeyNew,
                                 pCert,
                                 pRenewKey,
                                 pHashAlg,
                                 pDesStore,
                                 ulStoreFlags,
                                 pRequestInfo,
                                 ulReservedFlags,
                                 ppReserved,
                                 ppRequest,
                                 ppPKCS7Blob,
                                 ppHashBlob,
                                 pulStatus);

     }
     __except ( EXCEPTION_EXECUTE_HANDLER )
     {
         RpcStatus = _exception_code();
     }
 error:

     if(hProxy)
     {
         RpcBindingFree(&hProxy);
     }

     RpcRevertToSelf();

     return RpcStatus;
 }

ULONG s_KeyrQueryRequestStatus
(/* [in] */        handle_t                         hRPCBinding, 
 /* [in] */        unsigned __int64                 u64Request, 
 /* [out, ref] */  KEYSVC_QUERY_CERT_REQUEST_INFO  *pQueryInfo)
{
    RPC_BINDING_HANDLE hProxy = NULL;


    RPC_STATUS RpcStatus = RPC_S_OK;

    RpcStatus = RpcImpersonateClient(hRPCBinding);

    if (RPC_S_OK != RpcStatus)
    {
        return RpcStatus;
    }
    RpcStatus = BindLocalKeyService(&hProxy);
    if(RPC_S_OK != RpcStatus)
    {
        goto error;
    }

    __try
    {
        RpcStatus = s_KeyrQueryRequestStatus(
                                hProxy,
                                u64Request, 
                                pQueryInfo); 
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        RpcStatus = _exception_code();
    }
error:

    if(hProxy)
    {
        RpcBindingFree(&hProxy);
    }

    RpcRevertToSelf();

    return RpcStatus;
}

ULONG s_RKeyrPFXInstall
(/* [in] */        handle_t                        hRPCBinding,
 /* [in] */        PKEYSVC_BLOB                    pPFX,
 /* [in] */        PKEYSVC_UNICODE_STRING          pPassword,
 /* [in] */        ULONG                           ulFlags)
 {
     RPC_BINDING_HANDLE hProxy = NULL;


     RPC_STATUS RpcStatus = RPC_S_OK;

     RpcStatus = RpcImpersonateClient(hRPCBinding);

     if (RPC_S_OK != RpcStatus)
     {
         return RpcStatus;
     }
     RpcStatus = BindLocalKeyService(&hProxy);
     if(RPC_S_OK != RpcStatus)
     {
         goto error;
     }

     __try
     {
         RpcStatus = s_RKeyrPFXInstall(
                                 hProxy,
                                 pPFX,
                                 pPassword,
                                 ulFlags);

     }
     __except ( EXCEPTION_EXECUTE_HANDLER )
     {
         RpcStatus = _exception_code();
     }
 error:

     if(hProxy)
     {
         RpcBindingFree(&hProxy);
     }

     RpcRevertToSelf();

     return RpcStatus;
 }


ULONG       s_RKeyrOpenKeyService(
/* [in]  */     handle_t                       hRPCBinding,
/* [in]  */     KEYSVC_TYPE                    OwnerType,
/* [in]  */     PKEYSVC_UNICODE_STRING         pOwnerName,
/* [in]  */     ULONG                          ulDesiredAccess,
/* [in]  */     PKEYSVC_BLOB                   pAuthentication,
/* [in, out] */ PKEYSVC_BLOB                  *ppReserved,
/* [out] */     KEYSVC_HANDLE                 *phKeySvc)
{
    return s_KeyrOpenKeyService
        (hRPCBinding,
         OwnerType,
         pOwnerName,
         ulDesiredAccess,
         pAuthentication,
         ppReserved,
         phKeySvc);
}

ULONG       s_RKeyrCloseKeyService(
/* [in] */      handle_t         hRPCBinding,
/* [in] */      KEYSVC_HANDLE    hKeySvc,
/* [in, out] */ PKEYSVC_BLOB    *ppReserved)
{
    return s_KeyrCloseKeyService
        (hRPCBinding,
         hKeySvc,
         ppReserved);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\cryptsvc\dbutils.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       dbutils.cpp
//
//  Contents:   utilities
//
//  History:    07-Feb-00    reidk    Created
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <dbgdef.h>

extern void * _CatDBAlloc(size_t len);
extern void * _CatDBReAlloc(void *p, size_t len);
extern void _CatDBFree(void *p);


LPSTR _CatDBConvertWszToSz(LPCWSTR pwsz)
{
    LPSTR   psz = NULL;
    LONG    cch = 0;

    cch = WideCharToMultiByte(
            GetACP(),
            0,          // dwFlags
            pwsz,
            -1,         // cchWideChar, -1 => null terminated
            NULL,
            0,
            NULL,
            NULL);

    if (cch == 0)
    {
        goto ErrorWideCharToMultiByte;
    }

    if (NULL == (psz = (CHAR *) _CatDBAlloc(cch + 1)))
    {
        goto ErrorMemory;
    }

    psz[cch] = '\0';

    if (0 == WideCharToMultiByte(
                GetACP(),
                0,          // dwFlags
                pwsz,
                -1,         // cchWideChar, -1 => null terminated
                psz,
                cch,
                NULL,
                NULL))
    {
        goto ErrorWideCharToMultiByte;
    }

CommonReturn:

    return (psz);

ErrorReturn:

    if (psz != NULL)
    {
        _CatDBFree(psz);
    }

    psz = NULL;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorWideCharToMultiByte)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorMemory)
}


LPWSTR _CATDBAllocAndCopyWSTR(LPCWSTR pwsz)
{
    LPWSTR  pwszTemp = NULL;

    if (NULL == (pwszTemp =
                 (LPWSTR) _CatDBAlloc(sizeof(WCHAR) * (wcslen(pwsz) + 1) )))
    {
        goto ErrorMemory;
    }

    wcscpy(pwszTemp, pwsz);

CommonReturn:

    return (pwszTemp);

ErrorReturn:

    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorMemory)
}


LPWSTR _CATDBAllocAndCopyWSTR2(LPCWSTR pwsz1, LPCWSTR pwsz2)
{
    LPWSTR  pwszTemp = NULL;

    if (NULL == (pwszTemp =
                 (LPWSTR) _CatDBAlloc(sizeof(WCHAR) * ( wcslen(pwsz1) +
                                                        wcslen(pwsz2) +
                                                        1))))
    {
        goto ErrorMemory;
    }

    wcscpy(pwszTemp, pwsz1);
    wcscat(pwszTemp, pwsz2);

CommonReturn:

    return (pwszTemp);

ErrorReturn:

    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorMemory)
}


BOOL _CATDBStrCatWSTR(LPWSTR *ppwszAddTo, LPCWSTR pwszAdd)
{
    BOOL    fRet = TRUE;
    LPWSTR  pwszTemp = NULL;

    if (NULL == (pwszTemp = (LPWSTR) _CatDBAlloc(sizeof(WCHAR) * (  wcslen(*ppwszAddTo) +
                                                                    wcslen(pwszAdd) +
                                                                    1))))
    {
        goto ErrorMemory;
    }

    wcscpy(pwszTemp, *ppwszAddTo);
    wcscat(pwszTemp, pwszAdd);

    _CatDBFree(*ppwszAddTo);
    *ppwszAddTo = pwszTemp;

CommonReturn:

    return (fRet);

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorMemory)
}


BOOL _CATDBStrCat(LPSTR *ppszAddTo, LPCSTR pszAdd)
{
    BOOL   fRet = TRUE;
    LPSTR  pszTemp = NULL;

    if (NULL == (pszTemp = (LPSTR) _CatDBAlloc(sizeof(char) * ( strlen(*ppszAddTo) +
                                                                strlen(pszAdd) +
                                                                1))))
    {
        goto ErrorMemory;
    }

    strcpy(pszTemp, *ppszAddTo);
    strcat(pszTemp, pszAdd);

    _CatDBFree(*ppszAddTo);
    *ppszAddTo = pszTemp;

CommonReturn:

    return (fRet);

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorMemory)
}

LPWSTR _CATDBConstructWSTRPath(LPCWSTR pwsz1, LPCWSTR pwsz2)
{
    LPWSTR  pwszTemp    = NULL;
    int     nTotalLen   = 0;
    int     nLenStr1    = 0;

    //
    // Calculate the length of the resultant string as the sum of the length
    // of pwsz1, length of pwsz2, a NULL char, and a possible extra '\' char
    //
    nLenStr1 = wcslen(pwsz1);
    nTotalLen = nLenStr1 + wcslen(pwsz2) + 2;

    //
    // Allocate the string and copy pwsz1 into the buffer
    //
    if (NULL == (pwszTemp = (LPWSTR) _CatDBAlloc(sizeof(WCHAR) * nTotalLen)))
    {
        goto ErrorMemory;
    }

    wcscpy(pwszTemp, pwsz1);

    //
    // Add the extra '\' if needed
    //
    if (pwsz1[nLenStr1 - 1] != L'\\')
    {
        pwszTemp[nLenStr1] = L'\\';
        pwszTemp[nLenStr1 + 1] = L'\0';
    }

    //
    // Tack on pwsz2
    //
    wcscat(pwszTemp, pwsz2);

CommonReturn:

    return (pwszTemp);

ErrorReturn:

    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorMemory)
}


LPSTR _CATDBConstructPath(LPCSTR psz1, LPCSTR psz2)
{
    LPSTR   pszTemp     = NULL;
    int     nTotalLen   = 0;
    int     nLenStr1    = 0;

    //
    // Calculate the length of the resultant string as the sum of the length
    // of psz1, length of psz2, a NULL char, and a possible extra '\' char
    //
    nLenStr1 = strlen(psz1);
    nTotalLen = nLenStr1 + strlen(psz2) + 2;

    //
    // Allocate the string and copy pwsz1 into the buffer
    //
    if (NULL == (pszTemp =
                 (LPSTR) _CatDBAlloc(sizeof(char) * nTotalLen)))
    {
        goto ErrorMemory;
    }

    strcpy(pszTemp, psz1);

    //
    // Add the extra '\' if needed
    //
    if (psz1[nLenStr1 - 1] != '\\')
    {
        pszTemp[nLenStr1] = '\\';
        pszTemp[nLenStr1 + 1] = '\0';
    }

    //
    // Tack on pwsz2
    //
    strcat(pszTemp, psz2);

CommonReturn:

    return (pszTemp);

ErrorReturn:

    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorMemory)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\crypstub\crypstub.cpp ===
/*++

Copyright (C) 2000  Microsoft Corporation

Module Name:

    crypstub.cpp

Abstract:

    RPC Proxy Stub to handle downlevel requests to the services.exe 
    pipe

Author:

    petesk   3/1/00

Revisions:


--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <svcs.h>       // SVCS_

#include "crypstub.h"
#include "keyrpc.h"
#include "keysvc.h"
//
// global module handle used to reference resources contained in this module.
//

HINSTANCE   g_hInst = NULL;


BOOL
WINAPI
DllMain(
    HMODULE hInst,
    DWORD dwReason,
    LPVOID lpReserved
    )
{

    if( dwReason == DLL_PROCESS_ATTACH ) {
        g_hInst = hInst;
        DisableThreadLibraryCalls(hInst);
    }

    return TRUE;
}


NTSTATUS
WINAPI
StartCryptServiceStubs( 
     PSVCS_START_RPC_SERVER RpcpStartRpcServer,
     LPTSTR SvcsRpcPipeName
    )
{
    NTSTATUS dwStatus = STATUS_SUCCESS;

    //
    // enable negotiate protocol, as, clients expect this to work against the
    // stub.
    //

    RpcServerRegisterAuthInfoW( NULL, RPC_C_AUTHN_GSS_NEGOTIATE, NULL, NULL );

    dwStatus = RpcpStartRpcServer(
                        SvcsRpcPipeName,
                        s_BackupKey_v1_0_s_ifspec
                        );

    if(NT_SUCCESS(dwStatus))
    {
        dwStatus = RpcpStartRpcServer(
                    SvcsRpcPipeName,
                    s_IKeySvc_v1_0_s_ifspec
                    );
    }

    return dwStatus;
}


NTSTATUS
WINAPI
StopCryptServiceStubs( 
    PSVCS_STOP_RPC_SERVER RpcpStopRpcServer
    )

{

    NTSTATUS dwStatus = STATUS_SUCCESS;

    RpcpStopRpcServer(
                        s_BackupKey_v1_0_s_ifspec
                        );

    dwStatus = RpcpStopRpcServer(
                        s_IKeySvc_v1_0_s_ifspec
                        );
    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\cryptsvc\dbutils.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       dbutils.h
//
//  Contents:   utilities header
//
//  History:    07-Feb-00    reidk    Created
//
//----------------------------------------------------------------------------

#if !defined(__CATDBUTILS_H__)
#define __CATDBUTILS_H__

LPSTR _CatDBConvertWszToSz(LPCWSTR pwsz);

LPWSTR _CATDBAllocAndCopyWSTR(LPCWSTR pwsz);

LPWSTR _CATDBAllocAndCopyWSTR2(LPCWSTR  pwsz1, LPCWSTR pwsz2);

BOOL _CATDBStrCatWSTR(LPWSTR *ppwszAddTo, LPCWSTR pwszAdd);

BOOL _CATDBStrCat(LPSTR *ppszAddTo, LPCSTR pszAdd);

LPWSTR _CATDBConstructWSTRPath(LPCWSTR pwsz1, LPCWSTR pwsz2);

LPSTR _CATDBConstructPath(LPCSTR psz1, LPCSTR psz2);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\cryptsvc\keysvr.h ===
#ifndef _KEYSVR_H_
#define _KEYSVR_H_


#ifdef __cplusplus
extern "C" {
#endif

typedef struct __KEYSVC_CONTEXT__ {
    DWORD       dwType;
    LONG        iRefCount;
    DWORD       dwAccess;
    HANDLE      hProfile;
    LPWSTR      pszServiceName;
    HANDLE      hLogonToken;
} KEYSVC_CONTEXT, *PKEYSVC_CONTEXT;


// provider information
typedef struct _TMP_LIST_INFO_ {
    void *pInfo;
    struct _TMP_LIST_INFO_ *pNext;
} TMP_LIST_INFO, *PTMP_LIST_INFO;



DWORD
StartKeyService(
    VOID
    );

DWORD
StopKeyService(
    VOID
    );

VOID 
MyLogErrorMessage(
    DWORD dwErr, 
    DWORD dwMsgId
    );


#ifdef __cplusplus
}
#endif

#endif // _KEYSVR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\cryptsvc\keysvr.cpp ===
//depot/Lab03_N/DS/security/cryptoapi/cryptsvc/keysvr.cpp#9 - edit change 6380 (text)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <svcs.h>       // SVCS_
#include <ntsecapi.h>
#include <wincrypt.h>
#include <wintrust.h>
#include <wintrustp.h>
#include <userenv.h>
#include <lmcons.h>
#include <certca.h>
#include "keysvc.h"
#include "keysvr.h"
#include "pfx.h"
#include "cryptui.h"
#include "lenroll.h"
#include "cryptmsg.h"

#include "unicode.h"
#include "unicode5.h"
#include <crypt.h>


#define KEYSVC_DEFAULT_ENDPOINT            TEXT("\\pipe\\keysvc")
#define KEYSVC_DEFAULT_PROT_SEQ            TEXT("ncacn_np")
#define MAXPROTSEQ    20

#define ARRAYSIZE(rg) (sizeof(rg) / sizeof((rg)[0]))

void *MyAlloc(size_t len)
{
    return LocalAlloc(LMEM_ZEROINIT, len);
}

void MyFree(void *p)
{
    LocalFree(p);
}

void MyRpcRevertToSelfEx(RPC_BINDING_HANDLE hRPCBinding) 
{
    RPC_STATUS rpcStatus; 
  
    rpcStatus = RpcRevertToSelfEx((RPC_BINDING_HANDLE)hRPCBinding); 
    if (RPC_S_OK != rpcStatus) { 
	MyLogErrorMessage(rpcStatus, MSG_KEYSVC_REVERT_TO_SELF_FAILED); 
    }
}

void MyRevertToSelf()
{
    if (!RevertToSelf()) { 
	MyLogErrorMessage(GetLastError(), MSG_KEYSVC_REVERT_TO_SELF_FAILED); 
    }
}


DWORD
StartKeyService(
		VOID
		)
{
    return ERROR_SUCCESS; }

DWORD
StopKeyService(
	       VOID
	       )
{
    return ERROR_SUCCESS;
}

DWORD AllocAndAssignString(
                           IN PKEYSVC_UNICODE_STRING pUnicodeString,
                           OUT LPWSTR *ppwsz
                           )
{
    DWORD   dwErr = 0;

    if ((NULL != pUnicodeString->Buffer) && (0 != pUnicodeString->Length))
	{
	    if ((pUnicodeString->Length > pUnicodeString->MaximumLength) ||
		(pUnicodeString->Length & 1) || (pUnicodeString->MaximumLength & 1))
		{
		    dwErr = ERROR_INVALID_PARAMETER;
		    goto Ret;
		}

	    if (NULL == (*ppwsz = (LPWSTR)MyAlloc(pUnicodeString->MaximumLength +
						  sizeof(WCHAR))))
		{
		    dwErr = ERROR_NOT_ENOUGH_MEMORY;
		    goto Ret;
		}
	    memcpy(*ppwsz, pUnicodeString->Buffer, pUnicodeString->Length);
	}
 Ret:
    return dwErr;
}

// key service functions
ULONG       s_KeyrOpenKeyService(
				 /* [in]  */     handle_t                        /*hRPCBinding*/,
				 /* [in]  */     KEYSVC_TYPE                     /*OwnerType*/,
				 /* [in]  */     PKEYSVC_UNICODE_STRING          /*pOwnerName*/,
				 /* [in]  */     ULONG                           /*ulDesiredAccess*/,
				 /* [in]  */     PKEYSVC_BLOB                    /*pAuthentication*/,
				 /* [in, out] */ PKEYSVC_BLOB *                  /*ppReserved*/,
				 /* [out] */     KEYSVC_HANDLE *                 /*phKeySvc*/)
{
    return ERROR_CALL_NOT_IMPLEMENTED; 
}

ULONG       s_KeyrEnumerateProviders(
				     /* [in] */      handle_t                        hRPCBinding,
				     /* [in] */      KEYSVC_HANDLE                   /*hKeySvc*/,
				     /* [in, out] */ PKEYSVC_BLOB *                  /*ppReserved*/,
				     /* [in, out] */ ULONG                           *pcProviderCount,
				     /* [in, out][size_is(,*pcProviderCount)] */
				     PKEYSVC_PROVIDER_INFO           *ppProviders)
{
    return ERROR_CALL_NOT_IMPLEMENTED; 
}


ULONG       s_KeyrCloseKeyService(
				  /* [in] */      handle_t                        /*hRPCBinding*/,
				  /* [in] */      KEYSVC_HANDLE                   /*hKeySvc*/,
				  /* [in, out] */ PKEYSVC_BLOB *                  /*ppReserved*/)
{
    return ERROR_CALL_NOT_IMPLEMENTED; 
}

ULONG       s_KeyrGetDefaultProvider(
				     /* [in] */      handle_t                        hRPCBinding,
				     /* [in] */      KEYSVC_HANDLE                   /*hKeySvc*/,
				     /* [in] */      ULONG                           ulProvType,
				     /* [in] */      ULONG                           /*ulFlags*/,
				     /* [in, out] */ PKEYSVC_BLOB *                  /*ppReserved*/,
				     /* [out] */     ULONG                           *pulDefType,
				     /* [out] */     PKEYSVC_PROVIDER_INFO           *ppProvider)
{
    return ERROR_CALL_NOT_IMPLEMENTED; 
}

ULONG s_KeyrEnroll(
		   /* [in] */      handle_t                        /*hRPCBinding*/,
		   /* [in] */      BOOL                            /*fKeyService*/,
		   /* [in] */      ULONG                           /*ulPurpose*/,
		   /* [in] */      PKEYSVC_UNICODE_STRING          /*pAcctName*/,
		   /* [in] */      PKEYSVC_UNICODE_STRING          /*pCALocation*/,
		   /* [in] */      PKEYSVC_UNICODE_STRING          /*pCAName*/,
		   /* [in] */      BOOL                            /*fNewKey*/,
		   /* [in] */      PKEYSVC_CERT_REQUEST_PVK_NEW    /*pKeyNew*/,
		   /* [in] */      PKEYSVC_BLOB __RPC_FAR          /*pCert*/,
		   /* [in] */      PKEYSVC_CERT_REQUEST_PVK_NEW    /*pRenewKey*/,
		   /* [in] */      PKEYSVC_UNICODE_STRING          /*pHashAlg*/,
		   /* [in] */      PKEYSVC_UNICODE_STRING          /*pDesStore*/,
		   /* [in] */      ULONG                           /*ulStoreFlags*/,
		   /* [in] */      PKEYSVC_CERT_ENROLL_INFO        /*pRequestInfo*/,
		   /* [in] */      ULONG                           /*ulFlags*/,
		   /* [out][in] */ PKEYSVC_BLOB __RPC_FAR *        /*ppReserved*/,
		   /* [out] */     PKEYSVC_BLOB __RPC_FAR *        /*ppPKCS7Blob*/,
		   /* [out] */     PKEYSVC_BLOB __RPC_FAR *        /*ppHashBlob*/,
		   /* [out] */     ULONG __RPC_FAR *               /*pulStatus*/)
{
    return ERROR_CALL_NOT_IMPLEMENTED; 
}


ULONG s_KeyrEnumerateAvailableCertTypes(

					/* [in] */      handle_t                        hRPCBinding,
					/* [in] */      KEYSVC_HANDLE                   /*hKeySvc*/,
					/* [in, out] */ PKEYSVC_BLOB *                  /*ppReserved*/,
					/* [out][in] */ ULONG *pcCertTypeCount,
					/* [in, out][size_is(,*pcCertTypeCount)] */
					PKEYSVC_UNICODE_STRING *ppCertTypes)

{
    DWORD                   dwErr = ERROR_INVALID_DATA;
    HCERTTYPE               hType = NULL;
    DWORD                   cTypes = 0;
    DWORD                   cTrustedTypes = 0;
    DWORD                   i;
    LPWSTR                  *awszTrustedTypes = NULL;
    DWORD                   cbTrustedTypes = 0;
    PKEYSVC_UNICODE_STRING  awszResult = NULL;
    LPWSTR                  wszCurrentName;

    __try
	{
	    *pcCertTypeCount = 0;
	    *ppCertTypes = NULL;

	    dwErr = CAEnumCertTypes(CT_FIND_LOCAL_SYSTEM | CT_ENUM_MACHINE_TYPES, &hType);
	    if(dwErr != S_OK)
		{
		    goto Ret;
		}
	    cTypes = CACountCertTypes(hType);

	    awszTrustedTypes = (LPWSTR *)MyAlloc(sizeof(LPWSTR)*cTypes);
	    if(awszTrustedTypes == NULL)
		{
		    dwErr = ERROR_NOT_ENOUGH_MEMORY;
		    goto Ret;
		}
	    while(hType)
		{
		    HCERTTYPE hNextType = NULL;
		    LPWSTR *awszTypeName = NULL;
		    dwErr = CAGetCertTypeProperty(hType, CERTTYPE_PROP_DN, &awszTypeName);
		    if((dwErr == S_OK) && (awszTypeName))
			{
			    if(awszTypeName[0])
				{
				    dwErr = CACertTypeAccessCheck(hType, NULL);
				    if(dwErr == S_OK)
					{
					    // SECURITY: can awszTypeName be very large (perhaps the hacker managed to get into the DS and muck with template names).  
					    // Should we disable allocs over a certain value?  
					    awszTrustedTypes[cTrustedTypes] = (LPWSTR)MyAlloc((wcslen(awszTypeName[0])+1)*sizeof(WCHAR));
					    if(awszTrustedTypes[cTrustedTypes])
						{
						    wcscpy(awszTrustedTypes[cTrustedTypes], awszTypeName[0]);
						    cbTrustedTypes += (wcslen(awszTypeName[0])+1)*sizeof(WCHAR);
						    cTrustedTypes++;
						}
					}

				}
			    CAFreeCertTypeProperty(hType, awszTypeName);
			}
		    dwErr = CAEnumNextCertType(hType, &hNextType);
		    if(dwErr != S_OK)
			{
			    break;
			}
		    CACloseCertType(hType);
		    hType = hNextType;
		}

	    cbTrustedTypes += sizeof(KEYSVC_UNICODE_STRING)*cTrustedTypes;
	    awszResult = (PKEYSVC_UNICODE_STRING)MyAlloc(cbTrustedTypes);
	    if(awszResult == NULL)
		{
		    dwErr = ERROR_NOT_ENOUGH_MEMORY;
		    goto Ret;
		}
        
	    wszCurrentName = (LPWSTR)(&awszResult[cTrustedTypes]);
	    for(i=0; i < cTrustedTypes; i++)
		{
		    wcscpy(wszCurrentName, awszTrustedTypes[i]);
		    // BUGBUG: we're truncating the template name here.  Might be better to filter this out?  Are there any security issues here?
		    awszResult[i].Length = (WORD)(((wcslen(awszTrustedTypes[i]) + 1)*sizeof(WCHAR)) & 0xFFFF); 
		    awszResult[i].MaximumLength = awszResult[i].Length;
		    awszResult[i].Buffer = wszCurrentName;
		    wszCurrentName += wcslen(awszTrustedTypes[i]) + 1;
		}

	    *pcCertTypeCount = cTrustedTypes;
	    *ppCertTypes = awszResult;
	    awszResult = NULL;
	    dwErr = ERROR_SUCCESS;

	}
    __except ( EXCEPTION_EXECUTE_HANDLER )
	{
	    dwErr    = _exception_code();
	}
 Ret:
    __try
	{
	    if(awszTrustedTypes)
		{
		    for(i=0; i < cTrustedTypes; i++)
			{
			    if(awszTrustedTypes[i])
				{
				    MyFree(awszTrustedTypes[i]);
				}
			}
		    MyFree(awszTrustedTypes);
		}
	    if(awszResult)
		{
		    MyFree(awszResult);
		}
	}
    __except ( EXCEPTION_EXECUTE_HANDLER )
	{
	    dwErr = ERROR_INVALID_PARAMETER;
	}
    return dwErr;
}




ULONG s_KeyrEnumerateCAs(

			 /* [in] */      handle_t                        hRPCBinding,
			 /* [in] */      KEYSVC_HANDLE                   /*hKeySvc*/,
			 /* [in, out] */ PKEYSVC_BLOB *                  /*ppReserved*/,
			 /* [in] */      ULONG                           ulFlags,
			 /* [out][in] */ ULONG                           *pcCACount,
			 /* [in, out][size_is(,*pcCACount)] */
			 PKEYSVC_UNICODE_STRING               *ppCAs)

{
    DWORD                   dwErr = ERROR_INVALID_DATA; 
    HCAINFO                 hCA = NULL;
    DWORD                   cCAs = 0;
    DWORD                   cTrustedCAs = 0;
    DWORD                   i;
    LPWSTR                  *awszTrustedCAs = NULL;
    DWORD                   cbTrustedCAs = 0;
    PKEYSVC_UNICODE_STRING  awszResult = NULL;
    LPWSTR                  wszCurrentName;

    __try
	{
	    *pcCACount = 0;
	    *ppCAs = NULL;

	    dwErr = CAEnumFirstCA(NULL, ulFlags, &hCA);

	    if(dwErr != S_OK)
		{
		    goto Ret;
		}
	    cCAs = CACountCAs(hCA);

	    awszTrustedCAs = (LPWSTR *)MyAlloc(sizeof(LPWSTR)*cCAs);
	    if(awszTrustedCAs == NULL)
		{
		    dwErr = ERROR_NOT_ENOUGH_MEMORY;
		    goto Ret;
		}
	    while(hCA)
		{
		    HCAINFO hNextCA = NULL;
		    LPWSTR *awszCAName = NULL;
		    dwErr = CAGetCAProperty(hCA, CA_PROP_NAME, &awszCAName);
		    if((dwErr == S_OK) && (awszCAName))
			{
			    if(awszCAName[0])
				{
				    dwErr = CAAccessCheck(hCA, NULL);
				    if(dwErr == S_OK)
					{
					    awszTrustedCAs[cTrustedCAs] = (LPWSTR)MyAlloc((wcslen(awszCAName[0])+1)*sizeof(WCHAR));
					    if(awszTrustedCAs[cTrustedCAs])
						{
						    wcscpy(awszTrustedCAs[cTrustedCAs], awszCAName[0]);
						    cbTrustedCAs += (wcslen(awszCAName[0])+1)*sizeof(WCHAR);
						    cTrustedCAs++;
						}
					}

				}
			    CAFreeCAProperty(hCA, awszCAName);
			}
		    dwErr = CAEnumNextCA(hCA, &hNextCA);
		    if(dwErr != S_OK)
			{
			    break;
			}
		    CACloseCA(hCA);
		    hCA = hNextCA;
		}

	    cbTrustedCAs += sizeof(KEYSVC_UNICODE_STRING)*cTrustedCAs;
	    awszResult = (PKEYSVC_UNICODE_STRING)MyAlloc(cbTrustedCAs);
	    if(awszResult == NULL)
		{
		    dwErr = ERROR_NOT_ENOUGH_MEMORY;
		    goto Ret;
		}
        
	    wszCurrentName = (LPWSTR)(&awszResult[cTrustedCAs]);
	    for(i=0; i < cTrustedCAs; i++)
		{
		    wcscpy(wszCurrentName, awszTrustedCAs[i]);
		    // BUGBUG: we're truncating the template name here.  Might be better to filter this out?  Are there any security issues here?
		    awszResult[i].Length = (WORD)(((wcslen(awszTrustedCAs[i]) + 1)*sizeof(WCHAR)) & 0xFFFF); 
		    awszResult[i].MaximumLength = awszResult[i].Length;
		    awszResult[i].Buffer = wszCurrentName;
		    wszCurrentName += wcslen(awszTrustedCAs[i]) + 1;
		}


	    *pcCACount = cTrustedCAs;
	    *ppCAs = awszResult;
	    awszResult = NULL;
	    dwErr = ERROR_SUCCESS;

	}
    __except ( EXCEPTION_EXECUTE_HANDLER )
	{
	    dwErr    = _exception_code();
	}
 Ret:
    __try
	{
	    if(awszTrustedCAs)
		{
		    for(i=0; i < cTrustedCAs; i++)
			{
			    if(awszTrustedCAs[i])
				{
				    MyFree(awszTrustedCAs[i]);
				}
			}
		    MyFree(awszTrustedCAs);
		}
	    if(awszResult)
		{
		    MyFree(awszResult);
		}
	}
    __except ( EXCEPTION_EXECUTE_HANDLER )
	{
	    dwErr = ERROR_INVALID_PARAMETER;
	}
    return dwErr;
}

ULONG s_KeyrEnroll_V2
(/* [in] */      handle_t                        hRPCBinding,
 /* [in] */      BOOL                            fKeyService,
 /* [in] */      ULONG                           ulPurpose,
 /* [in] */      ULONG                           ulFlags, 
 /* [in] */      PKEYSVC_UNICODE_STRING          pAcctName,
 /* [in] */      PKEYSVC_UNICODE_STRING          pCALocation,
 /* [in] */      PKEYSVC_UNICODE_STRING          pCAName,
 /* [in] */      BOOL                            fNewKey,
 /* [in] */      PKEYSVC_CERT_REQUEST_PVK_NEW_V2 pKeyNew,
 /* [in] */      PKEYSVC_BLOB __RPC_FAR          pCert,
 /* [in] */      PKEYSVC_CERT_REQUEST_PVK_NEW_V2 pRenewKey,
 /* [in] */      PKEYSVC_UNICODE_STRING          pHashAlg,
 /* [in] */      PKEYSVC_UNICODE_STRING          pDesStore,
 /* [in] */      ULONG                           ulStoreFlags,
 /* [in] */      PKEYSVC_CERT_ENROLL_INFO        pRequestInfo,
 /* [in] */      ULONG                           /*ulReservedFlags*/,
 /* [out][in] */ PKEYSVC_BLOB __RPC_FAR *        /*ppReserved*/,
 /* [out][in] */ PKEYSVC_BLOB __RPC_FAR          *ppRequest, 
 /* [out] */     PKEYSVC_BLOB __RPC_FAR          *ppPKCS7Blob,
 /* [out] */     PKEYSVC_BLOB __RPC_FAR          *ppHashBlob,
 /* [out] */     ULONG __RPC_FAR                 *pulStatus)
{
    CERT_REQUEST_PVK_NEW    KeyNew;
    CERT_REQUEST_PVK_NEW    RenewKey;
    DWORD                   cbExtensions; 
    PBYTE                   pbExtensions = NULL; 
    PCERT_REQUEST_PVK_NEW   pTmpRenewKey = NULL;
    PCERT_REQUEST_PVK_NEW   pTmpKeyNew = NULL;
    LPWSTR                  pwszProv = NULL;
    LPWSTR                  pwszCont = NULL;
    LPWSTR                  pwszRenewProv = NULL;
    LPWSTR                  pwszRenewCont = NULL;
    LPWSTR                  pwszDesStore = NULL;
    LPWSTR                  pwszAttributes = NULL;
    LPWSTR                  pwszFriendly = NULL;
    LPWSTR                  pwszDescription = NULL;
    LPWSTR                  pwszUsage = NULL;
    LPWSTR                  pwszCALocation = NULL;
    LPWSTR                  pwszCertDNName = NULL;
    LPWSTR                  pwszCAName = NULL;
    LPWSTR                  pwszHashAlg = NULL;
    CERT_BLOB               CertBlob;
    CERT_BLOB               *pCertBlob = NULL;
    CERT_BLOB               PKCS7Blob;
    CERT_BLOB               HashBlob;
    CERT_ENROLL_INFO        EnrollInfo;
    DWORD                   dwErr = 0;
    HANDLE                  hRequest = *ppRequest;
    KEYSVC_BLOB             ReservedBlob; 
    BOOL                    fCreateRequest   = 0 == (ulFlags & (CRYPTUI_WIZ_SUBMIT_ONLY | CRYPTUI_WIZ_FREE_ONLY)); 
    BOOL                    fFreeRequest     = 0 == (ulFlags & (CRYPTUI_WIZ_CREATE_ONLY | CRYPTUI_WIZ_SUBMIT_ONLY)); 
    BOOL                    fSubmitRequest   = 0 == (ulFlags & (CRYPTUI_WIZ_CREATE_ONLY | CRYPTUI_WIZ_FREE_ONLY)); 

    __try
	{
	    //////////////////////////////////////////////////////////////
	    // 
	    // INITIALIZATION:
	    //
	    //////////////////////////////////////////////////////////////

	    memset(&KeyNew, 0, sizeof(KeyNew));
	    memset(&RenewKey, 0, sizeof(RenewKey));
	    memset(&EnrollInfo, 0, sizeof(EnrollInfo));
	    memset(&PKCS7Blob, 0, sizeof(PKCS7Blob));
	    memset(&HashBlob, 0, sizeof(HashBlob));
	    memset(&CertBlob, 0, sizeof(CertBlob));
	    memset(&ReservedBlob, 0, sizeof(ReservedBlob)); 

	    *ppPKCS7Blob = NULL;
	    *ppHashBlob = NULL;

	    //////////////////////////////////////////////////////////////
	    //
	    // INPUT VALIDATION:
	    //
	    //////////////////////////////////////////////////////////////

	    BOOL fValidInput = TRUE; 

	    fValidInput &= fCreateRequest || fSubmitRequest || fFreeRequest; 

	    switch (ulFlags & (CRYPTUI_WIZ_CREATE_ONLY | CRYPTUI_WIZ_SUBMIT_ONLY | CRYPTUI_WIZ_FREE_ONLY))
		{
		case CRYPTUI_WIZ_CREATE_ONLY:  
		    fValidInput &= NULL == *ppRequest;  
		    break;

		case CRYPTUI_WIZ_SUBMIT_ONLY: 
		case CRYPTUI_WIZ_FREE_ONLY: 
		    fValidInput &= NULL != *ppRequest; 
		    break; 
            
		case 0:
		default:
		    ;
		}       

	    if (FALSE == fValidInput)
		{
		    dwErr = ERROR_INVALID_PARAMETER;
		    goto Ret; 
		}

	    //////////////////////////////////////////////////////////////
	    //
	    // PROCEDURE BODY:
	    //
	    //////////////////////////////////////////////////////////////

	    // if enrolling for a service account then need to logon and load profile
	    if (0 != pAcctName->Length)
		{
		    dwErr = ERROR_NOT_SUPPORTED; 
		    goto Ret; 
		}

	    // assign all the values in the passed in structure to the
	    // temporary structure
	    KeyNew.dwSize = sizeof(CERT_REQUEST_PVK_NEW);
	    KeyNew.dwProvType = pKeyNew->ulProvType;
	    if (0 != (dwErr = AllocAndAssignString(&pKeyNew->Provider,
						   &pwszProv)))
		goto Ret;
	    KeyNew.pwszProvider = pwszProv;
	    KeyNew.dwProviderFlags = pKeyNew->ulProviderFlags;
	    if (0 != (dwErr = AllocAndAssignString(&pKeyNew->KeyContainer,
						   &pwszCont)))
		goto Ret;
	    KeyNew.pwszKeyContainer = pwszCont;
	    KeyNew.dwKeySpec = pKeyNew->ulKeySpec;
	    KeyNew.dwGenKeyFlags = pKeyNew->ulGenKeyFlags;
	    KeyNew.dwEnrollmentFlags = pKeyNew->ulEnrollmentFlags; 
	    KeyNew.dwSubjectNameFlags = pKeyNew->ulSubjectNameFlags;
	    KeyNew.dwPrivateKeyFlags = pKeyNew->ulPrivateKeyFlags;
	    KeyNew.dwGeneralFlags = pKeyNew->ulGeneralFlags; 

	    pTmpKeyNew = &KeyNew;

	    if (pCert->cb)
		{
		    // if necessary assign the cert to be renewed values
		    // temporary structure
		    CertBlob.cbData = pCert->cb;
		    CertBlob.pbData = pCert->pb;

		    pCertBlob = &CertBlob;
		}

	    if (CRYPTUI_WIZ_CERT_RENEW == ulPurpose)
		{
		    // assign all the values in the passed in structure to the
		    // temporary structure
		    RenewKey.dwSize = sizeof(CERT_REQUEST_PVK_NEW);
		    RenewKey.dwProvType = pRenewKey->ulProvType;
		    if (0 != (dwErr = AllocAndAssignString(&pRenewKey->Provider,
							   &pwszRenewProv)))
			goto Ret;
		    RenewKey.pwszProvider = pwszRenewProv;
		    RenewKey.dwProviderFlags = pRenewKey->ulProviderFlags;
		    if (0 != (dwErr = AllocAndAssignString(&pRenewKey->KeyContainer,
							   &pwszRenewCont)))
			goto Ret;
		    RenewKey.pwszKeyContainer = pwszRenewCont;
		    RenewKey.dwKeySpec = pRenewKey->ulKeySpec;
		    RenewKey.dwGenKeyFlags = pRenewKey->ulGenKeyFlags;
		    RenewKey.dwEnrollmentFlags = pRenewKey->ulEnrollmentFlags;
		    RenewKey.dwSubjectNameFlags = pRenewKey->ulSubjectNameFlags;
		    RenewKey.dwPrivateKeyFlags = pRenewKey->ulPrivateKeyFlags;
		    RenewKey.dwGeneralFlags = pRenewKey->ulGeneralFlags;

		    pTmpRenewKey = &RenewKey;
		}

	    // For SUBMIT and FREE operations, hRequest is an IN parameter. 
	    if (0 != ((CRYPTUI_WIZ_SUBMIT_ONLY | CRYPTUI_WIZ_FREE_ONLY) & ulFlags))
		{
		    memcpy(&hRequest, (*ppRequest)->pb, sizeof(hRequest)); 
		}

	    // check if the destination cert store was passed in
	    if (0 != (dwErr = AllocAndAssignString(pDesStore, &pwszDesStore)))
		goto Ret;

	    // copy over the request info
	    EnrollInfo.dwSize = sizeof(EnrollInfo);
	    if (0 != (dwErr = AllocAndAssignString(&pRequestInfo->UsageOID,
						   &pwszUsage)))
		goto Ret;
	    EnrollInfo.pwszUsageOID = pwszUsage;

	    if (0 != (dwErr = AllocAndAssignString(&pRequestInfo->CertDNName,
						   &pwszCertDNName)))
		goto Ret;
	    EnrollInfo.pwszCertDNName = pwszCertDNName;

	    // cast the cert extensions
	    EnrollInfo.dwExtensions = pRequestInfo->cExtensions;
	    cbExtensions = (sizeof(CERT_EXTENSIONS)+sizeof(PCERT_EXTENSIONS)) * pRequestInfo->cExtensions; 
	    for (DWORD dwIndex = 0; dwIndex < pRequestInfo->cExtensions; dwIndex++)
		{
		    cbExtensions += sizeof(CERT_EXTENSION) * 
			pRequestInfo->prgExtensions[dwIndex]->cExtension;
		}

	    EnrollInfo.prgExtensions = (PCERT_EXTENSIONS *)MyAlloc(cbExtensions);
	    if (NULL == EnrollInfo.prgExtensions)
		{
		    dwErr = ERROR_NOT_ENOUGH_MEMORY; 
		    goto Ret; 
		}

	    pbExtensions = (PBYTE)(EnrollInfo.prgExtensions + EnrollInfo.dwExtensions);
	    for (DWORD dwIndex = 0; dwIndex < EnrollInfo.dwExtensions; dwIndex++)
		{
		    EnrollInfo.prgExtensions[dwIndex] = (PCERT_EXTENSIONS)pbExtensions; 
		    pbExtensions += sizeof(CERT_EXTENSIONS); 
		    EnrollInfo.prgExtensions[dwIndex]->cExtension = pRequestInfo->prgExtensions[dwIndex]->cExtension; 
		    EnrollInfo.prgExtensions[dwIndex]->rgExtension = (PCERT_EXTENSION)pbExtensions; 
		    pbExtensions += sizeof(CERT_EXTENSION) * EnrollInfo.prgExtensions[dwIndex]->cExtension; 
            
		    for (DWORD dwSubIndex = 0; dwSubIndex < EnrollInfo.prgExtensions[dwIndex]->cExtension; dwSubIndex++) 
			{
			    EnrollInfo.prgExtensions[dwIndex]->rgExtension[dwSubIndex].pszObjId = 
				pRequestInfo->prgExtensions[dwIndex]->rgExtension[dwSubIndex].pszObjId; 
                
			    EnrollInfo.prgExtensions[dwIndex]->rgExtension[dwSubIndex].fCritical =
				pRequestInfo->prgExtensions[dwIndex]->rgExtension[dwSubIndex].fCritical;

			    EnrollInfo.prgExtensions[dwIndex]->rgExtension[dwSubIndex].Value.cbData = 
				pRequestInfo->prgExtensions[dwIndex]->rgExtension[dwSubIndex].cbData; 

			    EnrollInfo.prgExtensions[dwIndex]->rgExtension[dwSubIndex].Value.pbData = 
				pRequestInfo->prgExtensions[dwIndex]->rgExtension[dwSubIndex].pbData; 
			}                
		}

	    EnrollInfo.dwPostOption = pRequestInfo->ulPostOption;
	    if (0 != (dwErr = AllocAndAssignString(&pRequestInfo->FriendlyName,
						   &pwszFriendly)))
		goto Ret;
	    EnrollInfo.pwszFriendlyName = pwszFriendly;
	    if (0 != (dwErr = AllocAndAssignString(&pRequestInfo->Description,
						   &pwszDescription)))
		goto Ret;
	    EnrollInfo.pwszDescription = pwszDescription;

	    if (0 != (dwErr = AllocAndAssignString(&pRequestInfo->Attributes,
						   &pwszAttributes)))
		goto Ret;

	    if (0 != (dwErr = AllocAndAssignString(pHashAlg,
						   &pwszHashAlg)))
		goto Ret;
	    if (0 != (dwErr = AllocAndAssignString(pCALocation,
						   &pwszCALocation)))
		goto Ret;
	    if (0 != (dwErr = AllocAndAssignString(pCAName,
						   &pwszCAName)))
		goto Ret;

	    // call the local enrollment API

	    __try {
		dwErr = LocalEnrollNoDS(ulFlags, pwszAttributes, NULL, fKeyService,
					ulPurpose, FALSE, 0, NULL, 0, pwszCALocation,
					pwszCAName, pCertBlob, pTmpRenewKey, fNewKey,
					pTmpKeyNew, pwszHashAlg, pwszDesStore, ulStoreFlags,
					&EnrollInfo, &PKCS7Blob, &HashBlob, pulStatus, &hRequest);
	    } __except( EXCEPTION_EXECUTE_HANDLER ) {
		// TODO: convert to Winerror
		dwErr = GetExceptionCode();
	    }

	    if( dwErr != 0 )
		goto Ret;

	    // Assign OUT parameters based on what kind of request we've just made.  
	    // Possible requests are:
	    // 
	    // 1)  CREATE only        // Assign "ppRequest" to contain a HANDLE to the cert request. 
	    // 2)  SUBMIT only        // Assign "ppPKCS7Blob" and "ppHashBlob" to the values returned from LocalEnrollNoDS()
	    // 3)  FREE   only        // No need to assign OUT params. 
	    // 4)  Complete (all 3).
	    switch (ulFlags & (CRYPTUI_WIZ_CREATE_ONLY | CRYPTUI_WIZ_SUBMIT_ONLY | CRYPTUI_WIZ_FREE_ONLY))
		{
		case CRYPTUI_WIZ_CREATE_ONLY:
		    // We've done the request creation portion of a 3-stage request, 
		    // assign the "request" out parameter now: 
		    if (NULL == (*ppRequest = (KEYSVC_BLOB*)MyAlloc(sizeof(KEYSVC_BLOB)+
								    sizeof(hRequest))))
			{
			    dwErr = ERROR_NOT_ENOUGH_MEMORY; 
			    goto Ret; 
			}
	    
		    (*ppRequest)->cb = sizeof(hRequest); 
		    (*ppRequest)->pb = (BYTE*)(*ppRequest) + sizeof(KEYSVC_BLOB); 
		    memcpy((*ppRequest)->pb, &hRequest, sizeof(hRequest)); 

		    break; 

		case CRYPTUI_WIZ_SUBMIT_ONLY:
		case 0:
		    // We've done the request submittal portion of a 3-stage request, 
		    // or we've done a 1-stage request.  Assign the "certificate" out parameters now:

		    // alloc and copy for the RPC out parameters
		    if (NULL == (*ppPKCS7Blob = (KEYSVC_BLOB*)MyAlloc(sizeof(KEYSVC_BLOB) +
								      PKCS7Blob.cbData)))
			{
			    dwErr = ERROR_NOT_ENOUGH_MEMORY;
			    goto Ret;
			}
		    (*ppPKCS7Blob)->cb = PKCS7Blob.cbData;
		    (*ppPKCS7Blob)->pb = (BYTE*)(*ppPKCS7Blob) + sizeof(KEYSVC_BLOB);
		    memcpy((*ppPKCS7Blob)->pb, PKCS7Blob.pbData, (*ppPKCS7Blob)->cb);
	    
		    if (NULL == (*ppHashBlob = (KEYSVC_BLOB*)MyAlloc(sizeof(KEYSVC_BLOB) +
								     HashBlob.cbData)))
			{
			    dwErr = ERROR_NOT_ENOUGH_MEMORY;
			    goto Ret;
			}
		    (*ppHashBlob)->cb = HashBlob.cbData;
		    (*ppHashBlob)->pb = (BYTE*)(*ppHashBlob) + sizeof(KEYSVC_BLOB);
		    memcpy((*ppHashBlob)->pb, HashBlob.pbData, (*ppHashBlob)->cb);

		    break;

		case CRYPTUI_WIZ_FREE_ONLY:
		default:
		    *ppRequest = NULL; 
		    break; 
		}
	}
    __except ( EXCEPTION_EXECUTE_HANDLER )
	{
	    dwErr = ERROR_INVALID_PARAMETER;
	    goto Ret;
	}
 Ret:
    __try
	{
	    if (pwszProv)
		MyFree(pwszProv);
	    if (pwszCont)
		MyFree(pwszCont);
	    if (pwszRenewProv)
		MyFree(pwszRenewProv);
	    if (pwszRenewCont)
		MyFree(pwszRenewCont);
	    if (pwszDesStore)
		MyFree(pwszDesStore);
	    if (pwszAttributes)
		MyFree(pwszAttributes);
	    if (pwszFriendly)
		MyFree(pwszFriendly);
	    if (pwszDescription)
		MyFree(pwszDescription);
	    if (pwszUsage)
		MyFree(pwszUsage);
	    if (pwszCertDNName)
		MyFree(pwszCertDNName);
	    if (pwszCAName)
		MyFree(pwszCAName);
	    if (pwszCALocation)
		MyFree(pwszCALocation);
	    if (pwszHashAlg)
		MyFree(pwszHashAlg);
	    if (PKCS7Blob.pbData)
		{
		    MyFree(PKCS7Blob.pbData);
		}
	    if (HashBlob.pbData)
		{
		    MyFree(HashBlob.pbData);
		}
	    if (EnrollInfo.prgExtensions)
		MyFree(EnrollInfo.prgExtensions);
	}
    __except ( EXCEPTION_EXECUTE_HANDLER )
	{
	    dwErr = ERROR_INVALID_PARAMETER;
	}
    return dwErr;
}

ULONG s_KeyrQueryRequestStatus
(/* [in] */        handle_t                         hRPCBinding, 
 /* [in] */        unsigned __int64                 u64Request, 
 /* [out, ref] */  KEYSVC_QUERY_CERT_REQUEST_INFO  *pQueryInfo)
                   
{
    CRYPTUI_WIZ_QUERY_CERT_REQUEST_INFO  QueryInfo; 
    DWORD                                dwErr      = 0; 
    HANDLE                               hRequest   = (HANDLE)u64Request; 

    __try 
	{ 
	    // We have the permission necessary to query the request.  Proceed. 
	    ZeroMemory(&QueryInfo, sizeof(QueryInfo)); 

	    // Query the request. 
	    dwErr = LocalEnrollNoDS(CRYPTUI_WIZ_QUERY_ONLY, NULL, &QueryInfo, FALSE, 0, FALSE, NULL, NULL,
				    0, NULL, NULL, NULL, NULL, FALSE, NULL, NULL, NULL,
				    0, NULL, NULL, NULL, NULL, &hRequest); 
	    if (ERROR_SUCCESS != dwErr)
		goto Ret; 
	}
    __except ( EXCEPTION_EXECUTE_HANDLER )
	{
	    dwErr = ERROR_INVALID_PARAMETER;
	    goto Ret;
	}
    
    pQueryInfo->ulSize    = QueryInfo.dwSize; 
    pQueryInfo->ulStatus  = QueryInfo.dwStatus; 
 Ret:
    return dwErr; 
}


ULONG s_RKeyrPFXInstall
(/* [in] */        handle_t                        hRPCBinding,
 /* [in] */        PKEYSVC_BLOB                    pPFX,
 /* [in] */        PKEYSVC_UNICODE_STRING          pPassword,
 /* [in] */        ULONG                           ulFlags)

{
    BOOL             fIsImpersonatingClient  = FALSE; 
    CRYPT_DATA_BLOB  PFXBlob; 
    DWORD            dwCertOpenStoreFlags;
    DWORD            dwData; 
    DWORD            dwResult; 
    HCERTSTORE       hSrcStore               = NULL; 
    HCERTSTORE       hCAStore                = NULL; 
    HCERTSTORE       hMyStore                = NULL; 
    HCERTSTORE       hRootStore              = NULL; 
    LPWSTR           pwszPassword            = NULL; 
    PCCERT_CONTEXT   pCertContext            = NULL; 
    

    struct Stores { 
	HANDLE  *phStore;
	LPCWSTR  pwszStoreName; 
    } rgStores[] = { 
	{ &hMyStore,   L"my" }, 
	{ &hCAStore,   L"ca" }, 
	{ &hRootStore, L"root" }
    }; 

    __try 
	{ 
	    // Initialize locals: 
	    PFXBlob.cbData = pPFX->cb; 
	    PFXBlob.pbData = pPFX->pb; 

	    switch (ulFlags & (CRYPT_MACHINE_KEYSET | CRYPT_USER_KEYSET)) 
		{ 
		case CRYPT_MACHINE_KEYSET: 
		    dwCertOpenStoreFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE; 
		    break; 

		case CRYPT_USER_KEYSET: // not supported
		default:
		    dwResult = ERROR_INVALID_PARAMETER; 
		    goto error; 
		}

	    dwResult = RpcImpersonateClient(hRPCBinding); 
	    if (RPC_S_OK != dwResult) 
		goto error; 
	    fIsImpersonatingClient = TRUE; 

	    if (ERROR_SUCCESS != (dwResult = AllocAndAssignString((PKEYSVC_UNICODE_STRING)pPassword, &pwszPassword)))
		goto error; 

	    // Get an in-memory store which contains all of the certs in the PFX
	    // blob.  
	    if (NULL == (hSrcStore = PFXImportCertStore(&PFXBlob, pwszPassword, ulFlags)))
		{
		    dwResult = GetLastError(); 
		    goto error; 
		}

	    // Open the stores we'll need: 
	    for (DWORD dwIndex = 0; dwIndex < ARRAYSIZE(rgStores); dwIndex++) 
		{
		    *(rgStores[dwIndex].phStore) = CertOpenStore
			(CERT_STORE_PROV_SYSTEM_W,                 // store provider type
			 PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,  // cert encoding type
			 NULL,                                     // hCryptProv
			 dwCertOpenStoreFlags,                     // open store flags
			 rgStores[dwIndex].pwszStoreName           // store name
			 ); 
		    if (NULL == *(rgStores[dwIndex].phStore))
			{
			    dwResult = GetLastError();
			    goto error; 
			}
		}

	    // Enumerate the certs in the in-memory store, and add them to the local machine's
	    // "my" store.  NOTE: CertEnumCertificatesInStore frees the previous cert context
	    // before returning the new context.  
	    while (NULL != (pCertContext = CertEnumCertificatesInStore(hSrcStore, pCertContext)))
		{ 
		    HCERTSTORE hCertStore; 

		    // check if the certificate has the property on it
		    // make sure the private key matches the certificate
		    // search for both machine key and user keys
		    if (CertGetCertificateContextProperty
			(pCertContext,
			 CERT_KEY_PROV_INFO_PROP_ID,
			 NULL,
			 &dwData) &&
			CryptFindCertificateKeyProvInfo
			(pCertContext,
			 0,
			 NULL))
			{
			    hCertStore = hMyStore; 
			}
		    else if (TrustIsCertificateSelfSigned
			     (pCertContext,
			      pCertContext->dwCertEncodingType,
			      0))
			{
			    hCertStore = hRootStore; 
			}
		    else
			{
			    hCertStore = hCAStore; 
			}
            
		    if (!CertAddCertificateContextToStore
			(hCertStore, 
			 pCertContext, 
			 CERT_STORE_ADD_NEW, 
			 NULL))
			{
			    dwResult = GetLastError(); 
			    goto error; 
			}
		}
	}
    __except (EXCEPTION_EXECUTE_HANDLER)
	{
	    dwResult = GetExceptionCode(); 
	    goto error;
	}

    // We're done!
    dwResult = ERROR_SUCCESS; 
 error:
    if (fIsImpersonatingClient) { MyRpcRevertToSelfEx(hRPCBinding); }
    if (NULL != hSrcStore)      { CertCloseStore(hSrcStore, 0); }  
    
    // Close all of the destination stores we've opened. 
    for (DWORD dwIndex = 0; dwIndex < ARRAYSIZE(rgStores); dwIndex++)
	if (NULL != *(rgStores[dwIndex].phStore))   
	    CertCloseStore(*(rgStores[dwIndex].phStore), 0); 

    if (NULL != pwszPassword)   { MyFree(pwszPassword); } 
    if (NULL != pCertContext)   { CertFreeCertificateContext(pCertContext); }
    return dwResult; 
}

ULONG       s_RKeyrOpenKeyService(
				  /* [in]  */     handle_t                       hRPCBinding,
				  /* [in]  */     KEYSVC_TYPE                    OwnerType,
				  /* [in]  */     PKEYSVC_UNICODE_STRING         pOwnerName,
				  /* [in]  */     ULONG                          ulDesiredAccess,
				  /* [in]  */     PKEYSVC_BLOB                   pAuthentication,
				  /* [in, out] */ PKEYSVC_BLOB                  *ppReserved,
				  /* [out] */     KEYSVC_HANDLE                 *phKeySvc)
{
    return s_KeyrOpenKeyService
	(hRPCBinding,
	 OwnerType,
	 pOwnerName,
	 ulDesiredAccess,
	 pAuthentication,
	 ppReserved,
	 phKeySvc);
}

ULONG       s_RKeyrCloseKeyService(
				   /* [in] */      handle_t         hRPCBinding,
				   /* [in] */      KEYSVC_HANDLE    hKeySvc,
				   /* [in, out] */ PKEYSVC_BLOB    *ppReserved)
{
    return s_KeyrCloseKeyService
	(hRPCBinding,
	 hKeySvc,
	 ppReserved);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\cryptsvc\service.cpp ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1993-1995  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:   service.c
//
//  PURPOSE:  Implements functions required by all services
//            and takes into account dumbed-down win95 services
//
//  FUNCTIONS:
//    main(int argc, char **argv);
//    service_ctrl(DWORD dwCtrlCode);
//    CryptServiceMain(DWORD dwArgc, LPWSTR *lpszArgv);
//    WinNTDebugService(int argc, char **argv);
//    ControlHandler ( DWORD dwCtrlType );
//
//  COMMENTS:
//
//  AUTHOR: Craig Link - Microsoft Developer Support
//  MODIFIED: Matt Thomlinson
//            Scott Field
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <svcs.h>       // SVCS_
#include <wincrypt.h>
#include <cryptui.h>
#include <stdio.h>
#include "keysvr.h"
#include "lenroll.h"
#include "keysvc.h"
#include "keysvcc.h"
#include "cerrpc.h"
#include "service.h"
#include "unicode.h"
#include "unicode5.h"
#include "catdb.h"
#include "cryptmsg.h"

#define CRYPTSVC_EVENT_STOP "CRYPTSVC_EVENT_STOP"


#define RTN_OK                  0   // no errors
#define RTN_USAGE               1   // usage error (invalid commandline)
#define RTN_ERROR_INIT          2   // error during service initialization
#define RTN_ERROR_INSTALL       13  // error during -install or -remove
#define RTN_ERROR_INSTALL_SIG   14  // error installing signature(s)
#define RTN_ERROR_INSTALL_START 15  // could not start service during install
#define RTN_ERROR_INSTALL_SHEXT 16  // error installing shell extension

//
// global module handle used to reference resources contained in this module.
//

HINSTANCE   g_hInst = NULL;


// internal variables
static SERVICE_STATUS   ssStatus;       // current status of the service
SERVICE_STATUS_HANDLE   sshStatusHandle;


// internal function prototypes
void WINAPI service_ctrl(DWORD dwCtrlCode);
void WINAPI CryptServiceMain(DWORD dwArgc, LPWSTR *lpszArgv);
BOOL IsAdministrator(VOID);

extern BOOL _CatDBServiceInit(BOOL fUnInit);

//
// forward declaration for security callbacks
//
RPC_IF_CALLBACK_FN CryptSvcSecurityCallback;

long __stdcall
CryptSvcSecurityCallback(void * Interface, void *Context)
{
    RPC_STATUS          Status;
    unsigned int        RpcClientLocalFlag;

    Status = I_RpcBindingIsClientLocal(NULL, &RpcClientLocalFlag);
    if (Status != RPC_S_OK)
    {
        return (RPC_S_ACCESS_DENIED);
    }

    if (RpcClientLocalFlag == 0)
    {
        return (RPC_S_ACCESS_DENIED);
    }

    return (RPC_S_OK);
}

//
// Returns RPC_S_OK if the binding represents a local administrator on this box,
// AND if the binding is local. 
//
long __stdcall
KeySvcSecurityCallback(void * Interface, void *Context)
{
    BOOL          fIsImpersonatingClient  = FALSE; 
    RPC_STATUS    rpcStatus;
    unsigned int  RpcClientLocalFlag;

    rpcStatus = I_RpcBindingIsClientLocal(NULL, &RpcClientLocalFlag);
    if (rpcStatus != RPC_S_OK)
	goto error; 

    if (!RpcClientLocalFlag) { 
	rpcStatus = RPC_S_ACCESS_DENIED; 
	goto error; 
    }

    rpcStatus = RpcImpersonateClient(NULL); 
    if (rpcStatus != RPC_S_OK)
	goto error; 
    fIsImpersonatingClient = TRUE; 

    if (!IsAdministrator()) { 
	rpcStatus = RPC_S_ACCESS_DENIED; 
	goto error; 
    }
    
    rpcStatus = RPC_S_OK; 
 error:
    if (fIsImpersonatingClient) { 
	RPC_STATUS rpcStatus2 = RpcRevertToSelfEx(NULL); 
	if (RPC_S_OK != rpcStatus2) { 
	    MyLogErrorMessage(rpcStatus2, MSG_KEYSVC_REVERT_TO_SELF_FAILED); 
	}
    }
    return rpcStatus; 
}

//
// Returns RPC_S_OK if the binding represents a local administrator on this box.
// Does not require that the binding be local. 
//
long __stdcall
RKeySvcSecurityCallback(void * Interface, void *Context)
{
    BOOL          fIsImpersonatingClient  = FALSE; 
    RPC_STATUS    rpcStatus;

    rpcStatus = RpcImpersonateClient(NULL); 
    if (rpcStatus != RPC_S_OK)
	goto error; 
    fIsImpersonatingClient = TRUE; 

    if (!IsAdministrator()) { 
	rpcStatus = RPC_S_ACCESS_DENIED; 
	goto error; 
    }
    
    rpcStatus = RPC_S_OK; 
 error:
    if (fIsImpersonatingClient) { 
	RPC_STATUS rpcStatus2 = RpcRevertToSelfEx(NULL); 
	if (RPC_S_OK != rpcStatus2) { 
	    MyLogErrorMessage(rpcStatus2, MSG_KEYSVC_REVERT_TO_SELF_FAILED); 
	}
    }
    return rpcStatus; 
}

BOOL
WINAPI
DllMain(
    HMODULE hInst,
    DWORD dwReason,
    LPVOID lpReserved
    )
{

    if( dwReason == DLL_PROCESS_ATTACH ) {
        g_hInst = hInst;
        DisableThreadLibraryCalls(hInst);
    }

    return TRUE;
}


DWORD
WINAPI
Start(
    LPVOID lpV
    )
{
    BOOL fIsNT = FIsWinNT();
    int iRet;


    //
    // surpress dialog boxes generated by missing files, etc.
    //

    SetErrorMode(SEM_NOOPENFILEERRORBOX);

    SERVICE_TABLE_ENTRYW dispatchTable[] =
    {
        { SZSERVICENAME, (LPSERVICE_MAIN_FUNCTIONW)CryptServiceMain },
        { NULL, NULL }
    };

#ifdef WIN95_LEGACY

    if (!fIsNT)
        goto dispatch95;

#endif  // WIN95_LEGACY

    // if it doesn't match any of the above parameters
    // the service control manager may be starting the service
    // so we must call StartServiceCtrlDispatcher

    if(!FIsWinNT5()) {
        if (!StartServiceCtrlDispatcherW(dispatchTable))
            AddToMessageLog(L"StartServiceCtrlDispatcher failed.");
    } else {
        CryptServiceMain( 0, NULL );
    }

    return RTN_OK;

#ifdef WIN95_LEGACY

dispatch95:


    //
    // Win95 doesn't support services, except as pseudo-.exe files
    //

    HMODULE hKernel = GetModuleHandleA("kernel32.dll");
    if (NULL == hKernel)
    {
        AddToMessageLog(L"RegisterServiceProcess module handle failed");
        return RTN_ERROR_INIT;
    }

    // inline typedef: COOL!
    typedef DWORD REGISTERSERVICEPROCESS(
        DWORD dwProcessId,
        DWORD dwServiceType);

    REGISTERSERVICEPROCESS* pfnRegSvcProc = NULL;

    // Make sure Win95 Logoff won't stop our .exe
    if (NULL == (pfnRegSvcProc = (REGISTERSERVICEPROCESS*)GetProcAddress(hKernel, "RegisterServiceProcess")))
    {
        AddToMessageLog(L"RegisterServiceProcess failed");
        return RTN_ERROR_INIT;
    }

    pfnRegSvcProc(GetCurrentProcessId(), TRUE);  // register this process ID as a service process

    //
    // call re-entry point and return with result of it.
    //

    iRet = ServiceStart(0, 0);

    if(iRet != ERROR_SUCCESS)
        AddToMessageLog(L"ServiceStart error!");

    return iRet;

#endif  // WIN95_LEGACY

}

//
//  FUNCTION: CryptServiceMain
//
//  PURPOSE: To perform actual initialization of the service
//
//  PARAMETERS:
//    dwArgc   - number of command line arguments
//    lpszArgv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    This routine performs the service initialization and then calls
//    the user defined ServiceStart() routine to perform majority
//    of the work.
//
void WINAPI CryptServiceMain(DWORD dwArgc, LPWSTR * /*lpszArgv*/)
{
    DWORD dwLastError = ERROR_SUCCESS;

    // register our service control handler:
    //
    sshStatusHandle = RegisterServiceCtrlHandlerW( SZSERVICENAME, service_ctrl);

    if (!sshStatusHandle)
        return;

    // SERVICE_STATUS members that don't change in example
    //
    ssStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    ssStatus.dwServiceSpecificExitCode = 0;


    // report the status to the service control manager.
    //

    if (!ReportStatusToSCMgr(
                    SERVICE_START_PENDING, // service state
                    NO_ERROR,              // exit code
                    3000                   // wait hint
                    )) return ;

    dwLastError = ServiceStart(0, 0);

    return;
}



//
//  FUNCTION: service_ctrl
//
//  PURPOSE: This function is called by the SCM whenever
//           ControlService() is called on this service.
//
//  PARAMETERS:
//    dwCtrlCode - type of control requested
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
VOID WINAPI service_ctrl(DWORD dwCtrlCode)
{
    // Handle the requested control code.
    //
    switch(dwCtrlCode)
    {
        // Stop the service.
        //
        case SERVICE_CONTROL_STOP:

            //
            // tell the SCM we are stopping before triggering StopService() code
            // to avoid potential race condition during STOP_PENDING -> STOPPED transition
            //

            ssStatus.dwCurrentState = SERVICE_STOP_PENDING;
            ReportStatusToSCMgr(ssStatus.dwCurrentState, NO_ERROR, 0);
            ServiceStop();
            return;

        case SERVICE_CONTROL_SHUTDOWN:
            ServiceStop();
            return;

        // Update the service status.
        //
        case SERVICE_CONTROL_INTERROGATE:
            break;

        // invalid control code
        //
        default:
            break;

    }

    ReportStatusToSCMgr(ssStatus.dwCurrentState, NO_ERROR, 0);
}



//
//  FUNCTION: ReportStatusToSCMgr()
//
//  PURPOSE: Sets the current status of the service and
//           reports it to the Service Control Manager
//
//  PARAMETERS:
//    dwCurrentState - the state of the service
//    dwWin32ExitCode - error code to report
//    dwWaitHint - worst case estimate to next checkpoint
//
//  RETURN VALUE:
//    TRUE  - success
//    FALSE - failure
//
//  COMMENTS:
//
BOOL ReportStatusToSCMgr(DWORD dwCurrentState,
                         DWORD dwWin32ExitCode,
                         DWORD dwWaitHint)
{
    static DWORD dwCheckPoint = 1;
    BOOL fResult = TRUE;


    if (dwCurrentState == SERVICE_START_PENDING)
        ssStatus.dwControlsAccepted = 0;
    else
        ssStatus.dwControlsAccepted =   SERVICE_ACCEPT_STOP |
                                        SERVICE_ACCEPT_SHUTDOWN;

    ssStatus.dwCurrentState = dwCurrentState;
    if(dwWin32ExitCode == 0) {
        ssStatus.dwWin32ExitCode = 0;
    } else {
        ssStatus.dwServiceSpecificExitCode = dwWin32ExitCode;
        ssStatus.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
    }

    ssStatus.dwWaitHint = dwWaitHint;

    if ( ( dwCurrentState == SERVICE_RUNNING ) ||
         ( dwCurrentState == SERVICE_STOPPED ) )
        ssStatus.dwCheckPoint = 0;
    else
        ssStatus.dwCheckPoint = dwCheckPoint++;


    // Report the status of the service to the service control manager.
    //
    if (!(fResult = SetServiceStatus( sshStatusHandle, &ssStatus))) {
        AddToMessageLog(L"SetServiceStatus");
    }

    return fResult;
}



//
//  FUNCTION: AddToMessageLog(LPWSTR lpszMsg)
//
//  PURPOSE: Allows any thread to log an error message
//
//  PARAMETERS:
//    lpszMsg - text for message
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
VOID AddToMessageLog(LPWSTR lpszMsg)
{
    DWORD dwLastError = GetLastError();

    if(FIsWinNT()) {

        //
        // WinNT: Use event logging to log the error.
        //

        WCHAR   szMsg[512];
        HANDLE  hEventSource;
        LPWSTR  lpszStrings[2];

        hEventSource = RegisterEventSourceW(NULL, SZSERVICENAME);

        if(hEventSource == NULL)
            return;

        wsprintfW(szMsg, L"%s error: %lu", SZSERVICENAME, dwLastError);
        lpszStrings[0] = szMsg;
        lpszStrings[1] = lpszMsg;

        ReportEventW(hEventSource, // handle of event source
            EVENTLOG_ERROR_TYPE,  // event type
            0,                    // event category
            0,                    // event ID
            NULL,                 // current user's SID
            2,                    // strings in lpszStrings
            0,                    // no bytes of raw data
            (LPCWSTR*)lpszStrings,          // array of error strings
            NULL);                // no raw data

        (VOID) DeregisterEventSource(hEventSource);

    }
#ifdef WIN95_LEGACY
    else {

        //
        // Win95: log error to file
        //

        HANDLE hFile;
        SYSTEMTIME st;
        CHAR szMsgOut[512];
        DWORD cchMsgOut;
        DWORD dwBytesWritten;

        hFile = CreateFileA(
            "pstore.log",
            GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,
            OPEN_ALWAYS,
            0,
            NULL
            );

        if(hFile == INVALID_HANDLE_VALUE)
            return;

        GetSystemTime( &st );

        cchMsgOut = wsprintfA(szMsgOut, "%.2u-%.2u-%.2u %.2u:%.2u:%.2u %ls (rc=%lu)\015\012",
            st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond,
            lpszMsg,
            dwLastError
            );

        //
        // seek to EOF
        //

        SetFilePointer(hFile, 0, NULL, FILE_END);

        WriteFile(hFile, szMsgOut, cchMsgOut, &dwBytesWritten, NULL);
        CloseHandle(hFile);
    }
#endif  // WIN95_LEGACY

}

//--------------------------------------------------------------------
VOID MyLogEvent(WORD wType, DWORD dwEventID, unsigned int nStrings, const WCHAR ** rgwszStrings) {
    HANDLE  hEventLog  = NULL;

    hEventLog = RegisterEventSource(NULL, L"cryptsvc");
    if (NULL == hEventLog) {
    goto error;
    }

    if (!ReportEvent(hEventLog, wType, 0/*category*/, dwEventID, NULL, (WORD)nStrings, 0, rgwszStrings, NULL)) {
        goto error;
    }

error:
    if (NULL != hEventLog) {
        DeregisterEventSource(hEventLog);
    }
}

//--------------------------------------------------------------------
VOID MyLogErrorMessage(DWORD dwErr, DWORD dwMsgId) {
    const WCHAR *rgwszStrings[2];
    WCHAR wszNumberBuf[20];
    WCHAR *pwszError = NULL;

    swprintf(wszNumberBuf, L"0x%08X", dwErr);
    rgwszStrings[0] = wszNumberBuf;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
              FORMAT_MESSAGE_FROM_SYSTEM |
              FORMAT_MESSAGE_IGNORE_INSERTS,
              NULL,
              dwErr,
              0,
              (LPWSTR) &pwszError,
              0,
              NULL)) {
    rgwszStrings[1] = pwszError;
    } else {
    rgwszStrings[1] = L"";
    }

    MyLogEvent(EVENTLOG_ERROR_TYPE, dwMsgId, 2, rgwszStrings);

    if (NULL != pwszError) {
    LocalFree(pwszError);
    }
}


BOOL IsAdministrator(
		 VOID
		 )
    /*++

    This function determines if the calling user is an Administrator.

    On Windows NT, the caller of this function must be impersonating
    the user which is to be queried.  If the caller is not impersonating,
    this function will always return FALSE.

--*/
{
    HANDLE hAccessToken;
    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
    PSID psidAdministrators = NULL;
    BOOL bSuccess;

    if(!OpenThreadToken(
			GetCurrentThread(),
			TOKEN_QUERY,
			TRUE,
			&hAccessToken
			)) return FALSE;

    bSuccess = AllocateAndInitializeSid(
					&siaNtAuthority,
					2,
					SECURITY_BUILTIN_DOMAIN_RID,
					DOMAIN_ALIAS_RID_ADMINS,
					0, 0, 0, 0, 0, 0,
					&psidAdministrators
					);

    if( bSuccess ) {
	BOOL fIsMember = FALSE;

	bSuccess = CheckTokenMembership( hAccessToken, psidAdministrators, &fIsMember );

	if( bSuccess && !fIsMember )
	    bSuccess = FALSE;

    }

    CloseHandle( hAccessToken );

    if(psidAdministrators)
	FreeSid(psidAdministrators);

    return bSuccess;
}

// this event is signalled when the
// service should end
//
HANDLE  hServerStopEvent = NULL;




extern DWORD GlobalSecurityMask;
extern BOOL g_bAudit;



//
// waitable thread pool handle.
//

HANDLE hRegisteredWait = NULL;


VOID
TeardownServer(
    DWORD dwLastError
    );

VOID
NTAPI
TerminationNotify(
    PVOID Context,
    BOOLEAN TimerOrWaitFired
    );



//
//  FUNCTION: ServiceStart
//
//  COMMENTS:
//    The service
//    stops when hServerStopEvent is signalled

DWORD
ServiceStart(
    HINSTANCE hInstance,
    int nCmdShow
    )
{

    DWORD dwLastError = ERROR_SUCCESS;
    BOOL fStartedKeyService = FALSE;
    BOOL bListConstruct = FALSE;

    LPWSTR pwszServerPrincipalName = NULL;

    // Only on Win95 do we use a named event, in order to support shutting
    // down the server cleanly on that platform, since Win95 does not support
    // real services.

    hServerStopEvent = CreateEventA(
            NULL,
            TRUE,           // manual reset event
            FALSE,          // not-signalled
            (FIsWinNT() ? NULL : CRYPTSVC_EVENT_STOP)    // WinNT: unnamed, Win95 named
            );

    //
    // if event already exists, terminate quietly so that only one instance
    // of the service is allowed.
    //

    if(hServerStopEvent && GetLastError() == ERROR_ALREADY_EXISTS) {
        CloseHandle(hServerStopEvent);
        hServerStopEvent = NULL;
    }

    if(hServerStopEvent == NULL) {
        dwLastError = GetLastError();
        goto cleanup;
    }

    //
    // report the status to the service control manager.
    // (service start still pending).
    //

    if (!ReportStatusToSCMgr(
            SERVICE_START_PENDING,  // service state
            NO_ERROR,               // exit code
            3000                    // wait hint
            )) {
        dwLastError = GetLastError();
        goto cleanup;
    }


    dwLastError = StartKeyService();
    if(ERROR_SUCCESS != dwLastError)
    {
        dwLastError = GetLastError();
        goto cleanup;
    }

    if (!_CatDBServiceInit(FALSE))
    {
        dwLastError = GetLastError();
        goto cleanup;
    }


    //
    // Initialize the RPC interfaces for
    // Key Service, ICertProt, etc.

    RPC_STATUS status;

    status = RpcServerUseProtseqEpW(KEYSVC_DEFAULT_PROT_SEQ,
                                    RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                    KEYSVC_DEFAULT_ENDPOINT,
                                    NULL);              //Security Descriptor

    if(RPC_S_DUPLICATE_ENDPOINT == status)
    {
        status = RPC_S_OK;
    }

    if (status)
    {
        dwLastError = status;
        goto cleanup;
    }

    status = RpcServerUseProtseqEpW(KEYSVC_LOCAL_PROT_SEQ,   //ncalrpc
                                    RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                    KEYSVC_LOCAL_ENDPOINT,   //keysvc
                                    NULL);              //Security Descriptor

    if(RPC_S_DUPLICATE_ENDPOINT == status)
    {
        status = RPC_S_OK;
    }

    if (status)
    {
        dwLastError = status;
        goto cleanup;
    }

    status = RpcServerRegisterIfEx(s_IKeySvc_v1_0_s_ifspec,
                                   NULL,
                                   NULL,
                                   RPC_IF_AUTOLISTEN | RPC_IF_ALLOW_SECURE_ONLY,
                                   RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                   KeySvcSecurityCallback); // require admin and LRPC
    if (status)
    {
        dwLastError = status;
        goto cleanup;
    }

    status = RpcServerRegisterIfEx(s_IKeySvcR_v1_0_s_ifspec,
                                   NULL,
                                   NULL,
                                   RPC_IF_AUTOLISTEN | RPC_IF_ALLOW_SECURE_ONLY,
                                   RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                   RKeySvcSecurityCallback); // require admin, LRPC not required
    if (status)
    {
        dwLastError = status;
        goto cleanup;
    }

    status = RpcServerRegisterIfEx(s_ICertProtectFunctions_v1_0_s_ifspec,
                                   NULL,
                                   NULL,
                                   RPC_IF_AUTOLISTEN,
                                   RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                   CryptSvcSecurityCallback);

    if (status)
    {
        dwLastError = status;
        goto cleanup;
    }

    status = RpcServerRegisterIfEx(s_ICatDBSvc_v1_0_s_ifspec,
                                   NULL,
                                   NULL,
                                   RPC_IF_AUTOLISTEN,
                                   RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                   CryptSvcSecurityCallback);
    if (status)
    {
        dwLastError = status;
        goto cleanup;
    }

    //
    // report the status to the service control manager.
    //

    if (!ReportStatusToSCMgr(
            SERVICE_RUNNING,       // service state
            NO_ERROR,              // exit code
            0                      // wait hint
            )) {
        dwLastError = GetLastError();
        goto cleanup;
    }


    // allow clients to make authenticated requests
    status = RpcServerInqDefaultPrincName(RPC_C_AUTHN_GSS_NEGOTIATE, &pwszServerPrincipalName);
    if (RPC_S_OK != status)
    {
	// Shouldn't prevent service from startin just because auth failed.
	// Just log an event here.
	MyLogErrorMessage(status, MSG_RKEYSVC_COULDNT_INIT_SECURITY);
    }
    else
    {
        status = RpcServerRegisterAuthInfo
            (pwszServerPrincipalName,
             RPC_C_AUTHN_GSS_NEGOTIATE,
             NULL,                       // Use default key acquisiting function
             NULL                        // Use default creds
             );
        if (RPC_S_OK != status)
        {
            // Shouldn't prevent service from startin just because auth failed.
	    // Just log an event here.
	    MyLogErrorMessage(status, MSG_RKEYSVC_COULDNT_INIT_SECURITY);
        }
    }

    //
    // on WinNT5, ask services.exe to notify us when the service is shutting
    // down, and return this thread to the work item queue.
    //

    if(!RegisterWaitForSingleObject(
                            &hRegisteredWait,
                            hServerStopEvent,   // wait handle
                            TerminationNotify,  // callback fcn
                            NULL,               // parameter
                            INFINITE,           // timeout
                            WT_EXECUTELONGFUNCTION | WT_EXECUTEONLYONCE
                            )) {

        hRegisteredWait = NULL;
        dwLastError = GetLastError();
    }

    if (NULL != pwszServerPrincipalName) { RpcStringFreeW(&pwszServerPrincipalName); }
    return dwLastError;



cleanup:

    TeardownServer( dwLastError );

    if (NULL != pwszServerPrincipalName) { RpcStringFreeW(&pwszServerPrincipalName); }
    return dwLastError;
}

VOID
NTAPI
TerminationNotify(
    PVOID Context,
    BOOLEAN TimerOrWaitFired
    )
/*++

Routine Description:

    This function gets called by a services worker thread when the
    termination event gets signaled.

Arguments:

Return Value:

--*/
{
    //
    // per JSchwart:
    // safe to unregister during callback.
    //

    if( hRegisteredWait ) {
        UnregisterWaitEx( hRegisteredWait, NULL );
        hRegisteredWait = NULL;
    }

    TeardownServer( ERROR_SUCCESS );
}

VOID
TeardownServer(
    DWORD dwLastError
    )
{
    RPC_STATUS  rpcStatus;
    DWORD       dwErrToReport = dwLastError;


    //
    // Unregister RPC Interfaces

    rpcStatus = RpcServerUnregisterIf(s_IKeySvc_v1_0_s_ifspec, 0, 0);
    if ((rpcStatus != RPC_S_OK) && (dwErrToReport == ERROR_SUCCESS))
    {
        dwErrToReport = rpcStatus;
    }

    rpcStatus = RpcServerUnregisterIf(s_IKeySvcR_v1_0_s_ifspec, 0, 0);
    if ((rpcStatus != RPC_S_OK) && (dwErrToReport == ERROR_SUCCESS))
    {
        dwErrToReport = rpcStatus;
    }

    rpcStatus = RpcServerUnregisterIf(s_ICertProtectFunctions_v1_0_s_ifspec, 0, 0);
    if ((rpcStatus != RPC_S_OK) && (dwErrToReport == ERROR_SUCCESS))
    {
        dwErrToReport = rpcStatus;
    }

    rpcStatus = RpcServerUnregisterIf(s_ICatDBSvc_v1_0_s_ifspec, 0, 0);
    if ((rpcStatus != RPC_S_OK) && (dwErrToReport == ERROR_SUCCESS))
    {
        dwErrToReport = rpcStatus;
    }

    //
    // stop backup key server
    // Note:  this function knows internally whether the backup key server
    // really started or not.
    //

    StopKeyService();


    _CatDBServiceInit(TRUE);


    if(hServerStopEvent) {
        SetEvent(hServerStopEvent); // make event signalled to release anyone waiting for termination
        CloseHandle(hServerStopEvent);
        hServerStopEvent = NULL;
    }

    ReportStatusToSCMgr(
                        SERVICE_STOPPED,
                        dwErrToReport,
                        0
                        );

}

//  FUNCTION: ServiceStop
//
//  PURPOSE: Stops the service
//
//  COMMENTS:
//    If a ServiceStop procedure is going to
//    take longer than 3 seconds to execute,
//    it should spawn a thread to execute the
//    stop code, and return.  Otherwise, the
//    ServiceControlManager will believe that
//    the service has stopped responding.
//
VOID ServiceStop()
{

    if(hServerStopEvent)
    {
        SetEvent(hServerStopEvent); // signal waiting threads and reset to non-signalled
    }
}


extern "C"
{


/*********************************************************************/
/*                 MIDL allocate and free                            */
/*********************************************************************/

void __RPC_FAR * __RPC_API midl_user_allocate(size_t len)
{
    return(LocalAlloc(LMEM_ZEROINIT, len));
}

void __RPC_API midl_user_free(void __RPC_FAR * ptr)
{
    //
    // sfield: zero memory before freeing it.
    // do this because RPC allocates alot on our behalf, and we want to
    // be as sanitary as possible with respect to not letting anything
    // sensitive go to pagefile.
    //

    ZeroMemory( ptr, LocalSize( ptr ) );
    LocalFree(ptr);
}

void __RPC_FAR * __RPC_API midl_user_reallocate(void __RPC_FAR * ptr, size_t len)
{
    return(LocalReAlloc(ptr, len, LMEM_MOVEABLE | LMEM_ZEROINIT));
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\forwardr\mscat32\mscat32.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       mscat32.cpp
//
//--------------------------------------------------------------------------

#ifdef _M_IX86

#include <windows.h>
#include <wincrypt.h>
#include <mscat.h>

STDAPI mscat32DllRegisterServer(void);
EXTERN_C
__declspec(naked)
HRESULT
STDAPICALLTYPE
DllRegisterServer()
{
    __asm {
        jmp mscat32DllRegisterServer
    }
}

STDAPI mscat32DllUnregisterServer(void);
EXTERN_C
__declspec(naked)
HRESULT
STDAPICALLTYPE
DllUnregisterServer()
{
    __asm {
        jmp mscat32DllUnregisterServer
    }
}


EXTERN_C
__declspec(naked)
HANDLE WINAPI ForwardrCryptCATOpen(IN          LPWSTR pwszFileName,
                                  IN          DWORD fdwOpenFlags,
                                  IN OPTIONAL HCRYPTPROV hProv,
                                  IN OPTIONAL DWORD dwPublicVersion,
                                  IN OPTIONAL DWORD dwEncodingType)
{
    __asm {
        jmp CryptCATOpen
    }
}

EXTERN_C
__declspec(naked)
BOOL WINAPI ForwardrCryptCATClose(IN HANDLE hCatalog)
{
    __asm {
        jmp CryptCATClose
    }
}

EXTERN_C
__declspec(naked)
CRYPTCATSTORE * WINAPI ForwardrCryptCATStoreFromHandle(IN HANDLE hCatalog)
{
    __asm {
        jmp CryptCATStoreFromHandle
    }
}

EXTERN_C
__declspec(naked)
HANDLE WINAPI ForwardrCryptCATHandleFromStore(IN CRYPTCATSTORE *pCatStore)
{
    __asm {
        jmp CryptCATHandleFromStore
    }
}

EXTERN_C
__declspec(naked)
BOOL WINAPI ForwardrCryptCATPersistStore(IN HANDLE hCatalog)
{
    __asm {
        jmp CryptCATPersistStore
    }
}


EXTERN_C
__declspec(naked)
CRYPTCATATTRIBUTE * WINAPI ForwardrCryptCATGetCatAttrInfo(IN HANDLE hCatalog,
                                                         IN LPWSTR pwszReferenceTag)
{
    __asm {
        jmp CryptCATGetCatAttrInfo
    }
}

EXTERN_C
__declspec(naked)
CRYPTCATATTRIBUTE * WINAPI ForwardrCryptCATPutCatAttrInfo(IN HANDLE hCatalog,
                                                         IN LPWSTR pwszReferenceTag,
                                                         IN DWORD dwAttrTypeAndAction,
                                                         IN DWORD cbData,
                                                         IN BYTE *pbData)
{
    __asm {
        jmp CryptCATPutCatAttrInfo
    }
}

EXTERN_C
__declspec(naked)
CRYPTCATATTRIBUTE * WINAPI ForwardrCryptCATEnumerateCatAttr(IN HANDLE hCatalog,
                                                           IN CRYPTCATATTRIBUTE *pPrevAttr)
{
    __asm {
        jmp CryptCATEnumerateCatAttr
    }
}


EXTERN_C
__declspec(naked)
CRYPTCATMEMBER * WINAPI ForwardrCryptCATGetMemberInfo(IN HANDLE hCatalog,
                                                     IN LPWSTR pwszReferenceTag)
{
    __asm {
        jmp CryptCATGetMemberInfo
    }
}

EXTERN_C
__declspec(naked)
CRYPTCATMEMBER * WINAPI ForwardrCryptCATPutMemberInfo(IN HANDLE hCatalog,
                                                     IN OPTIONAL LPWSTR pwszFileName,
                                                     IN          LPWSTR pwszReferenceTag,
                                                     IN          GUID *pgSubjectType,
                                                     IN          DWORD dwCertVersion,
                                                     IN          DWORD cbSIPIndirectData,
                                                     IN          BYTE *pbSIPIndirectData)
{
    __asm {
        jmp CryptCATPutMemberInfo
    }
}

EXTERN_C
__declspec(naked)
CRYPTCATMEMBER * WINAPI ForwardrCryptCATEnumerateMember(IN HANDLE hCatalog,
                                                       IN CRYPTCATMEMBER *pPrevMember)
{
    __asm {
        jmp CryptCATEnumerateMember
    }
}

EXTERN_C
__declspec(naked)
CRYPTCATATTRIBUTE * WINAPI ForwardrCryptCATGetAttrInfo(IN HANDLE hCatalog,
                                                      IN CRYPTCATMEMBER *pCatMember,
                                                      IN LPWSTR pwszReferenceTag)
{
    __asm {
        jmp CryptCATGetAttrInfo
    }
}

EXTERN_C
__declspec(naked)
CRYPTCATATTRIBUTE * WINAPI ForwardrCryptCATPutAttrInfo(IN HANDLE hCatalog,
                                                      IN CRYPTCATMEMBER *pCatMember,
                                                      IN LPWSTR pwszReferenceTag,
                                                      IN DWORD dwAttrTypeAndAction,
                                                      IN DWORD cbData,
                                                      IN BYTE *pbData)
{
    __asm {
        jmp CryptCATPutAttrInfo
    }
}

EXTERN_C
__declspec(naked)
CRYPTCATATTRIBUTE * WINAPI ForwardrCryptCATEnumerateAttr(IN HANDLE hCatalog,
                                                        IN CRYPTCATMEMBER *pCatMember,
                                                        IN CRYPTCATATTRIBUTE *pPrevAttr)
{
    __asm {
        jmp CryptCATEnumerateAttr
    }
}

EXTERN_C
__declspec(naked)
BOOL WINAPI ForwardrCryptCATAdminReleaseCatalogContext(IN HCATADMIN hCatAdmin,
                                                      IN HCATINFO hCatInfo,
                                                      IN DWORD dwFlags)
{
    __asm {
        jmp CryptCATAdminReleaseCatalogContext
    }
}

EXTERN_C
__declspec(naked)
CRYPTCATCDF * WINAPI ForwardrCryptCATCDFOpen(IN LPWSTR pwszFilePath,
                                            IN OPTIONAL PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError)
{
    __asm {
        jmp CryptCATCDFOpen
    }
}


EXTERN_C
__declspec(naked)
BOOL WINAPI ForwardrCryptCATCDFClose(IN CRYPTCATCDF *pCDF)
{
    __asm {
        jmp CryptCATCDFClose
    }
}

EXTERN_C
__declspec(naked)
CRYPTCATATTRIBUTE * WINAPI ForwardrCryptCATCDFEnumCatAttributes(CRYPTCATCDF *pCDF,
                                                               CRYPTCATATTRIBUTE *pPrevAttr,
                                                                PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError)
{
    __asm {
        jmp CryptCATCDFEnumCatAttributes
    }
}

EXTERN_C
__declspec(naked)
CRYPTCATMEMBER * WINAPI ForwardrCryptCATCDFEnumMembers(IN          CRYPTCATCDF *pCDF,
                                                      IN          CRYPTCATMEMBER *pPrevMember,
                                                      IN OPTIONAL PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError)
{
    __asm {
        jmp CryptCATCDFEnumMembers
    }
}

EXTERN_C
__declspec(naked)
CRYPTCATATTRIBUTE *WINAPI ForwardrCryptCATCDFEnumAttributes(IN          CRYPTCATCDF *pCDF,
                                                           IN          CRYPTCATMEMBER *pMember,
                                                           IN          CRYPTCATATTRIBUTE *pPrevAttr,
                                                           IN OPTIONAL PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError)
{
    __asm {
        jmp CryptCATCDFEnumAttributes
    }
}



EXTERN_C
__declspec(naked)
BOOL WINAPI      ForwardrCryptCATAdminAcquireContext(OUT HCATADMIN *phCatAdmin,
                                                    IN const GUID *pgSubsystem,
                                                    IN DWORD dwFlags)
{
    __asm {
        jmp CryptCATAdminAcquireContext
    }
}

EXTERN_C
__declspec(naked)
BOOL WINAPI      ForwardrCryptCATAdminReleaseContext(IN HCATADMIN hCatAdmin,
                                                    IN DWORD dwFlags)
{
    __asm {
        jmp CryptCATAdminReleaseContext
    }
}

EXTERN_C
__declspec(naked)
HCATINFO WINAPI ForwardrCryptCATAdminEnumCatalogFromHash(IN HCATADMIN hCatAdmin,
                                                        IN BYTE *pbHash,
                                                        IN DWORD cbHash,
                                                        IN DWORD dwFlags,
                                                        IN OUT HCATINFO *phPrevCatInfo)
{
    __asm {
        jmp CryptCATAdminEnumCatalogFromHash
    }
}

EXTERN_C
__declspec(naked)
BOOL WINAPI ForwardrCryptCATAdminCalcHashFromFileHandle(IN HANDLE hFile,
                                                       IN OUT DWORD *pcbHash,
                                                       OUT OPTIONAL BYTE *pbHash,
                                                       IN DWORD dwFlags)
{
    __asm {
        jmp CryptCATAdminCalcHashFromFileHandle
    }
}

EXTERN_C
__declspec(naked)
BOOL WINAPI ForwardrCryptCATCatalogInfoFromContext(IN HCATINFO hCatInfo,
                                                  IN OUT CATALOG_INFO *psCatInfo,
                                                  IN DWORD dwFlags)
{
    __asm {
        jmp CryptCATCatalogInfoFromContext
    }
}

EXTERN_C
__declspec(naked)
HCATINFO WINAPI ForwardrCryptCATAdminAddCatalog(IN HCATADMIN hCatAdmin,
                                               IN WCHAR *pwszCatalogFile,
                                               IN OPTIONAL WCHAR *pwszSelectBaseName,
                                               IN DWORD dwFlags)
{
    __asm {
        jmp CryptCATAdminAddCatalog
    }
}


EXTERN_C
__declspec(naked)
BOOL WINAPI      ForwardrIsCatalogFile(IN OPTIONAL HANDLE hFile,
                                      IN OPTIONAL WCHAR *pwszFileName)
{
    __asm {
        jmp IsCatalogFile
    }
}

EXTERN_C
BOOL WINAPI
CatalogCompactHashDatabase (
       IN LPCWSTR pwszDbLock,
       IN LPCWSTR pwszDbDirectory,
       IN LPCWSTR pwszDbName,
       IN OPTIONAL LPCWSTR pwszUnwantedCatalog
       );

EXTERN_C
__declspec(naked)
void
ForwardrCatalogCompactHashDatabase (
       IN LPCWSTR pwszDbLock,
       IN LPCWSTR pwszDbDirectory,
       IN LPCWSTR pwszDbName,
       IN OPTIONAL LPCWSTR pwszUnwantedCatalog
       )
{
    __asm {
        jmp CatalogCompactHashDatabase
    }
}



EXTERN_C
LPWSTR WINAPI CryptCATCDFEnumMembersByCDFTag(CRYPTCATCDF *pCDF, LPWSTR pwszPrevCDFTag,
                                       PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError,
                                       CRYPTCATMEMBER** ppMember);

EXTERN_C
__declspec(naked)
LPWSTR WINAPI ForwardrCryptCATCDFEnumMembersByCDFTag(CRYPTCATCDF *pCDF, LPWSTR pwszPrevCDFTag,
                                       PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError,
                                       CRYPTCATMEMBER** ppMember)
{
    __asm {
        jmp CryptCATCDFEnumMembersByCDFTag
    }
}

EXTERN_C
LPWSTR WINAPI CryptCATCDFEnumMembersByCDFTagEx(CRYPTCATCDF *pCDF, LPWSTR pwszPrevCDFTag,
                                       PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError,
                                       CRYPTCATMEMBER** ppMember, BOOL fContinueOnError,
                                       LPVOID pvReserved);

EXTERN_C
__declspec(naked)
LPWSTR WINAPI ForwardrCryptCATCDFEnumMembersByCDFTagEx(CRYPTCATCDF *pCDF, LPWSTR pwszPrevCDFTag,
                                       PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError,
                                       CRYPTCATMEMBER** ppMember, BOOL fContinueOnError,
                                       LPVOID pvReserved)
{
    __asm {
        jmp CryptCATCDFEnumMembersByCDFTagEx
    }
}

EXTERN_C
CRYPTCATATTRIBUTE * WINAPI CryptCATCDFEnumAttributesWithCDFTag(CRYPTCATCDF *pCDF, LPWSTR pwszMemberTag, CRYPTCATMEMBER *pMember,
                                             CRYPTCATATTRIBUTE *pPrevAttr,
                                             PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError);

EXTERN_C
__declspec(naked)
CRYPTCATATTRIBUTE * WINAPI ForwardrCryptCATCDFEnumAttributesWithCDFTag(CRYPTCATCDF *pCDF, LPWSTR pwszMemberTag, CRYPTCATMEMBER *pMember,
                                             CRYPTCATATTRIBUTE *pPrevAttr,
                                             PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError)
{
    __asm {
        jmp CryptCATCDFEnumAttributesWithCDFTag
    }
}


EXTERN_C
BOOL MsCatConstructHashTag (IN DWORD cbDigest, IN LPBYTE pbDigest, OUT LPWSTR* ppwszHashTag);

EXTERN_C
__declspec(naked)
BOOL ForwardrMsCatConstructHashTag (IN DWORD cbDigest, IN LPBYTE pbDigest, OUT LPWSTR* ppwszHashTag)
{
    __asm {
        jmp MsCatConstructHashTag
    }
}

EXTERN_C
VOID MsCatFreeHashTag (IN LPWSTR pwszHashTag);
EXTERN_C
__declspec(naked)
VOID ForwardrMsCatFreeHashTag (IN LPWSTR pwszHashTag)
{
    __asm {
        jmp MsCatFreeHashTag
    }
}


BOOL WINAPI CryptCATVerifyMember(HANDLE hCatalog,
                                 CRYPTCATMEMBER *pCatMember,
                                 HANDLE hFileOrMemory);

__declspec(naked)
BOOL WINAPI ForwardrCryptCATVerifyMember(HANDLE hCatalog,
                                 CRYPTCATMEMBER *pCatMember,
                                 HANDLE hFileOrMemory)
{
    __asm {
        jmp CryptCATVerifyMember
    }
}
#else

static void Dummy()
{
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\cryptsvc\service.h ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1993-1995  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE: service.h
//
//  AUTHOR: Craig Link
//
//
//  Comments:  The use of this header file and the accompanying service.c
//  file simplifies the process of writting a service.  You as a developer
//  simply need to follow the TODO's outlined in this header file, and 
//  implement the ServiceStart() and ServiceStop() functions.
//  
//  There is no need to modify the code in service.c.  Just add service.c
//  to your project and link with the following libraries...
//
//  libcmt.lib kernel32.lib advapi.lib shell32.lib
//
//  This code also supports unicode.  Be sure to compile both service.c and
//  and code #include "service.h" with the same Unicode setting.
//
//  Upon completion, your code will have the following command line interface
//
//  <service exe> -?                to display this list
//  <service exe> -install          to install the service
//  <service exe> -remove           to remove the service
//  <service exe> -debug <params>   to run as a console app for debugging
//
//  Note: This code also implements Ctrl+C and Ctrl+Break handlers
//        when using the debug option.  These console events cause
//        your ServiceStop routine to be called
//
//        Also, this code only handles the OWN_SERVICE service type
//        running in the LOCAL_SYSTEM security context.
//
//        To control your service ( start, stop, etc ) you may use the
//        Services control panel applet or the NET.EXE program.
//
//        To aid in writing/debugging service, the
//        SDK contains a utility (MSTOOLS\BIN\SC.EXE) that
//        can be used to control, configure, or obtain service status.
//        SC displays complete status for any service/driver
//        in the service database, and allows any of the configuration
//        parameters to be easily changed at the command line.
//        For more information on SC.EXE, type SC at the command line.
//

#ifndef _SERVICE_H
#define _SERVICE_H


#ifdef __cplusplus
extern "C" {
#endif


//////////////////////////////////////////////////////////////////////////////
//// todo: change to desired strings
////
// name of the executable
#define SZAPPNAME            L"cryptsvc"
// internal name of the service
#define SZSERVICENAME        L"CryptSvc"
// displayed name of the service
#define SZSERVICEDISPLAYNAME L"Cryptographic Services"
#define SZSERVICEDISPLAYNAMEA "Cryptographic Services"
// list of service dependencies - "dep1\0dep2\0\0"
// RPC must be running for us to work!
#define SZDEPENDENCIES       L"RpcSs\0" // doubly null terminated
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//// todo: ServiceStart()must be defined by in your code.
////       The service should use ReportStatusToSCMgr to indicate
////       progress.  This routine must also be used by StartService()
////       to report to the SCM when the service is running.
////
////       If a ServiceStop procedure is going to take longer than
////       3 seconds to execute, it should spawn a thread to
////       execute the stop code, and return.  Otherwise, the
////       ServiceControlManager will believe that the service has
////       stopped responding
////
DWORD ServiceStart (HINSTANCE hInstance, int nCmdShow);
VOID ServiceStop();
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//// The following are procedures which
//// may be useful to call within the above procedures,
//// but require no implementation by the user.
//// They are implemented in service.c

//
//  FUNCTION: ReportStatusToSCMgr()
//
//  PURPOSE: Sets the current status of the service and
//           reports it to the Service Control Manager
//
//  PARAMETERS:
//    dwCurrentState - the state of the service
//    dwWin32ExitCode - error code to report
//    dwWaitHint - worst case estimate to next checkpoint
//
//  RETURN VALUE:
//    TRUE  - success 
//    FALSE - failure
//
BOOL ReportStatusToSCMgr(DWORD dwCurrentState, DWORD dwWin32ExitCode, DWORD dwWaitHint);


//
//  FUNCTION: AddToMessageLog(LPWSTR lpszMsg)
//
//  PURPOSE: Allows any thread to log an error message
//
//  PARAMETERS:
//    lpszMsg - text for message
//
//  RETURN VALUE:
//    none
//
void AddToMessageLog(LPWSTR lpszMsg);
//////////////////////////////////////////////////////////////////////////////

void StopRPCServer();


// entry point to start the service from install stub.

DWORD WINAPI Start( LPVOID lpV );


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\forwardr\mssip32\mssip32.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       mssip32.cpp
//
//--------------------------------------------------------------------------

#ifdef _M_IX86

#include <windows.h>
#include <wincrypt.h>
#include <mssip.h>

STDAPI mssip32DllRegisterServer(void);
EXTERN_C
__declspec(naked)
HRESULT
STDAPICALLTYPE
DllRegisterServer()
{
    __asm {
        jmp mssip32DllRegisterServer
    }
}

STDAPI mssip32DllUnregisterServer(void);
EXTERN_C
__declspec(naked)
HRESULT
STDAPICALLTYPE
DllUnregisterServer()
{
    __asm {
        jmp mssip32DllUnregisterServer
    }
}


EXTERN_C
__declspec(naked)
BOOL WINAPI ForwardrCryptSIPGetSignedDataMsg(   
                                IN      SIP_SUBJECTINFO *pSubjectInfo,
                                OUT     DWORD           *pdwEncodingType,
                                IN      DWORD           dwIndex,
                                IN OUT  DWORD           *pcbSignedDataMsg,
                                OUT     BYTE            *pbSignedDataMsg)
{
    __asm {
        jmp CryptSIPGetSignedDataMsg
    }
}

EXTERN_C
__declspec(naked)
BOOL WINAPI ForwardrCryptSIPPutSignedDataMsg(   
                                IN      SIP_SUBJECTINFO *pSubjectInfo,
                                IN      DWORD           dwEncodingType,
                                OUT     DWORD           *pdwIndex,
                                IN      DWORD           cbSignedDataMsg,
                                IN      BYTE            *pbSignedDataMsg)
{
    __asm {
        jmp CryptSIPPutSignedDataMsg
    }
}

EXTERN_C
__declspec(naked)
BOOL WINAPI ForwardrCryptSIPRemoveSignedDataMsg(
                                IN      SIP_SUBJECTINFO     *pSubjectInfo,
                                IN      DWORD               dwIndex)
{
    __asm {
        jmp CryptSIPRemoveSignedDataMsg
    }
}

EXTERN_C
__declspec(naked)
BOOL WINAPI ForwardrCryptSIPVerifyIndirectData(
                                IN      SIP_SUBJECTINFO     *pSubjectInfo,
                                IN      SIP_INDIRECT_DATA   *pIndirectData)
{
    __asm {
        jmp CryptSIPVerifyIndirectData
    }
}

EXTERN_C
__declspec(naked)
BOOL WINAPI ForwardrCryptSIPCreateIndirectData(
                                IN      SIP_SUBJECTINFO     *pSubjectInfo,
                                IN OUT  DWORD               *pcbIndirectData,
                                OUT     SIP_INDIRECT_DATA   *pIndirectData)
{
    __asm {
        jmp CryptSIPCreateIndirectData
    }
}

void CryptSIPGetRegWorkingFlags(DWORD *pdwState);
__declspec(naked)
void ForwardrCryptSIPGetRegWorkingFlags(DWORD *pdwState) 
{
    __asm {
        jmp CryptSIPGetRegWorkingFlags
    }
}

//
//  support for Auth2 release
//
typedef struct _SIP_INFORMATION
{
    DWORD       cbSize;         // sizeof(SIP_INFORMATION)
    DWORD       cgSubjects;     // number of guids in array
    const GUID  *pgSubjects;    // array of supported guids/subjects
} SIP_INFORMATION, *PSIP_INFORMATION;

BOOL CryptSIPGetInfo(IN OUT SIP_INFORMATION    *pSIPInit);
__declspec(naked)
BOOL ForwardrCryptSIPGetInfo(IN OUT SIP_INFORMATION    *pSIPInit)
{
    __asm {
        jmp CryptSIPGetInfo
    }
}

#else

static void Dummy()
{
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\cryptsvc\writer.cpp ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    backup.cpp

Abstract:

    This module contains routines that handle the COM+ VSS writer object for
    backup and restore of the catalogs, the catalog databases, and for
    WFP-protected system files.

Author:

    Patrick Masse (patmasse)     04-02-2002

--*/

#include <windows.h>
#include <stdio.h>
#include <dbgdef.h>
#include <assert.h>
#include <sfc.h>

#include <vss.h>
#include <vswriter.h>
#include <vsbackup.h>

#include "service.h"
#include "errlog.h"
#include "cryptmsg.h"


//***************************************************************************************
//
//  _CatDB prototypes
//
//***************************************************************************************

LPWSTR
_CatDBGetCatrootDirW(
    BOOL fCatroot2);

LPWSTR
_CatDBCreatePath(
    IN LPCWSTR   pwsz1,
    IN LPCWSTR   pwsz2);

BOOL
_CatDBFreeze();

VOID
_CatDBThaw();


//***************************************************************************************
//
//  CSystemWriter object declaration
//
//***************************************************************************************

class CSystemWriter :
    public CVssWriter
{
private:
    static CSystemWriter *sm_pWriter;
    STDMETHODCALLTYPE CSystemWriter() {}

public:
    virtual STDMETHODCALLTYPE ~CSystemWriter() {}

    //  CSystemWriter object Startup and Shutdown functions
    
    static bool
    Startup();
    
    static void
    Shutdown();

    // CSystemWriter object exported VSS member functions
    
    virtual bool STDMETHODCALLTYPE
    OnIdentify(
        IN IVssCreateWriterMetadata *pMetadata);
    
    virtual bool STDMETHODCALLTYPE
    OnPrepareBackup(
        IN IVssWriterComponents *pWriterComponents);
    
    virtual bool STDMETHODCALLTYPE
    OnPrepareSnapshot();
    
    virtual bool STDMETHODCALLTYPE
    OnFreeze();
    
    virtual bool STDMETHODCALLTYPE
    OnThaw();
    
    virtual bool STDMETHODCALLTYPE
    OnAbort();

private:

    // CSystemWriter object VSS helper functions

    bool
    AddCatalogFiles(
        IN IVssCreateWriterMetadata *pMetadata,
        IN bool fCatroot2);
    
    bool
    AddSystemFiles(
        IN IVssCreateWriterMetadata *pMetadata);

    // CSystemWriter object private initialization functions

    static BOOL
    IsSystemSetupInProgress();
    
    static BOOL
    WaitForServiceRunning(
        IN PWSTR wszServiceName);
    
    static DWORD WINAPI
    InitializeThreadFunc(
        IN PVOID pvResult);
    
    bool STDMETHODCALLTYPE
    Initialize();
    
    bool STDMETHODCALLTYPE
    Uninitialize();

    // Error handling functions

    static HRESULT
    SqlErrorToWriterError(
        IN HRESULT hSqlError);
    
    static HRESULT
    WinErrorToWriterError(
        IN DWORD dwWinError);
    
    static void
    LogSystemErrorEvent(
        IN DWORD dwMsgId,
        IN PWSTR pwszDetails,
        IN DWORD dwSysErrCode);
};


//***************************************************************************************
//
//  Globals
//
//***************************************************************************************

//  The writer COM+ object guid
CONST GUID g_guidWriterId =
{
    0xe8132975, 0x6f93, 0x4464, { 0xa5, 0x3e, 0x10, 0x50, 0x25, 0x3a, 0xe2, 0x20 }
};

//  The writer display name
LPCWSTR g_wszWriterName    = L"System Writer";

//  The component name
LPCWSTR g_wszComponentName = L"System Files";

//  Handle to the initialization thread
HANDLE g_hInitializeThread = NULL;

//  Static class member variables
CSystemWriter *CSystemWriter::sm_pWriter = NULL;

// Global from catdbsvc.cpp
extern BOOL g_fShuttingDown;


//***************************************************************************************
//
//  CSystemWriter object Startup and Shutdown functions
//
//***************************************************************************************

//---------------------------------------------------------------------------------------
//
//  CSystemWriter::Startup()
//
//---------------------------------------------------------------------------------------
bool
CSystemWriter::Startup()
{
    bool        fRet = true;
    DWORD       dwThreadId;
    
    //
    // Writer object already created?
    //
    if (sm_pWriter != NULL)
    {
        goto CommonReturn;
    }

    //
    // Is a system setup currently in progress?
    // If so... don't initialize, but return ok.
    //
    // Notes:   Added because any attempt to initialize VSS during GUI-mode setup
    //          really screws things up.
    //
    if (IsSystemSetupInProgress())
    {
        goto CommonReturn;
    }

    //
    // Create the CSystemWriter object
    //
    sm_pWriter = new CSystemWriter;

    if (sm_pWriter == NULL)
    {
        LogSystemErrorEvent(MSG_SYSTEMWRITER_INIT_FAILURE, L"Allocation of CSystemWriter object failed.", ERROR_OUTOFMEMORY);
        goto ErrorReturn;
    }

    //
    // Spin up a thread to do the subscription in.
    //
    // Notes:   We must use a thread to do this, since the rest of this service is
    //          required early in the boot sequence, and this thread may take quite
    //          a while to initialize, since it will wait for needed services before
    //          attempting initialization.
    //
    g_hInitializeThread = ::CreateThread(
        NULL,
        0,
        InitializeThreadFunc,
        NULL,
        0,
        &dwThreadId);

    if (g_hInitializeThread == NULL)
    {
        LogSystemErrorEvent(MSG_SYSTEMWRITER_INIT_FAILURE, L"Creation of CSystemWriter initialization thread failed.", GetLastError());
        goto ErrorReturn;
    }

CommonReturn:

    return fRet;

ErrorReturn:

    fRet = false;

    if (sm_pWriter)
    {
        delete sm_pWriter;
        sm_pWriter = NULL;
    }

    goto CommonReturn;
}

//---------------------------------------------------------------------------------------
//
//  CSystemWriter::Shutdown()
//
//---------------------------------------------------------------------------------------
void
CSystemWriter::Shutdown()
{
    HANDLE hInitializeThread = InterlockedExchangePointer(&g_hInitializeThread, NULL);

    if (hInitializeThread != NULL)
    {
        WaitForSingleObject(hInitializeThread, INFINITE);
        CloseHandle(hInitializeThread);
    }
    
    if (sm_pWriter)
    {
        sm_pWriter->Uninitialize();

        delete sm_pWriter;
        sm_pWriter = NULL;
    }
}


//***************************************************************************************
//
//  CSystemWriter object exported VSS member functions
//
//***************************************************************************************

//---------------------------------------------------------------------------------------
//
//  CSystemWriter::OnIdentify()
//
//---------------------------------------------------------------------------------------
bool STDMETHODCALLTYPE
CSystemWriter::OnIdentify(
    IN IVssCreateWriterMetadata *pMetadata)
{
    bool fRet = true;
    HRESULT hResult;

    //
    // Set the restore method for the writer
    //
    hResult = pMetadata->SetRestoreMethod(
        VSS_RME_RESTORE_AT_REBOOT,
        NULL,
        NULL,
        VSS_WRE_NEVER,
        true);

    if (hResult != S_OK)
    {
        SetWriterFailure(SqlErrorToWriterError(hResult));
        goto ErrorReturn;
    }

    //
    // Add one file group component
    //
    hResult = pMetadata->AddComponent(
        VSS_CT_FILEGROUP,
        NULL,
        g_wszComponentName,
        g_wszComponentName,
        NULL,
        0,
        false,
        false,
        false);

    if (hResult != S_OK)
    {
        SetWriterFailure(SqlErrorToWriterError(hResult));
        goto ErrorReturn;
    }

    //
    // Add catalog files group to component
    //
    if (!AddCatalogFiles(pMetadata,false))
    {
        // Writer failure already set by AddCatalogFiles function
        goto ErrorReturn;
    }

    //
    // Add catalog database files to component
    //
    if (!AddCatalogFiles(pMetadata,true))
    {
        // Writer failure already set by AddCatalogFiles function
        goto ErrorReturn;
    }

    //
    // Add system files group to component
    //
    if (!AddSystemFiles(pMetadata))
    {
        // Writer failure already set by AddSystemFiles function
        goto ErrorReturn;
    }

CommonReturn:

    return fRet;

ErrorReturn:

    fRet = false;
    goto CommonReturn;
}

//---------------------------------------------------------------------------------------
//
//  CSystemWriter::OnPrepareBackup()
//
//---------------------------------------------------------------------------------------
bool STDMETHODCALLTYPE
CSystemWriter::OnPrepareBackup(
    IN IVssWriterComponents *pWriterComponents)
{
    //
    // Nothing...
    //
    // Notes:   But at a later time, we may want to make sure all of the files are
    //          in the snapshot here.
    //
    return true;
}

//---------------------------------------------------------------------------------------
//
//  CSystemWriter::OnPrepareSnapshot()
//
//---------------------------------------------------------------------------------------
bool STDMETHODCALLTYPE
CSystemWriter::OnPrepareSnapshot()
{
    //
    // Nothing...
    //
    return true;
}

//---------------------------------------------------------------------------------------
//
//  CSystemWriter::OnFreeze()
//
//---------------------------------------------------------------------------------------
bool STDMETHODCALLTYPE
CSystemWriter::OnFreeze()
{
    if(!_CatDBFreeze())
    {
        //
        // The backup should not continue!
        //
        SetWriterFailure(VSS_E_WRITERERROR_NONRETRYABLE);
        return false;
    }

    return true;
}

//---------------------------------------------------------------------------------------
//
//  CSystemWriter::OnThaw()
//
//---------------------------------------------------------------------------------------
bool STDMETHODCALLTYPE
CSystemWriter::OnThaw()
{
    _CatDBThaw();

    return true;
}

//---------------------------------------------------------------------------------------
//
//  CSystemWriter::OnAbort()
//
//---------------------------------------------------------------------------------------
bool STDMETHODCALLTYPE
CSystemWriter::OnAbort()
{
    _CatDBThaw();

    return true;
}


//***************************************************************************************
//
//  CSystemWriter object VSS helper functions
//
//***************************************************************************************

//---------------------------------------------------------------------------------------
//
//  CSystemWriter::AddCatalogFiles()
//
//---------------------------------------------------------------------------------------
bool
CSystemWriter::AddCatalogFiles(
    IN IVssCreateWriterMetadata *pMetadata,
    IN bool fCatroot2)
{
    bool                fRet            = true;
    LPWSTR              pwszCatroot     = NULL;
    LPWSTR              pwszSearch      = NULL;
    LPWSTR              pwszPathName    = NULL;
    HANDLE              hFindHandle     = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW    FindData;
    DWORD               dwErr;
    HRESULT             hResult;

    //
    // Get the directory where the catalog files live
    //
    pwszCatroot = _CatDBGetCatrootDirW(fCatroot2);

    if (pwszCatroot == NULL)
    {
        SetWriterFailure(WinErrorToWriterError(GetLastError()));
        goto ErrorReturn;
    }

    //
    // Build a search string for the catalog directories
    //
    pwszSearch = _CatDBCreatePath(pwszCatroot, L"{????????????????????????????????????}");

    if (pwszSearch == NULL)
    {
        SetWriterFailure(WinErrorToWriterError(GetLastError()));
        goto ErrorReturn;
    }

    //
    // Do the initial find
    //
    hFindHandle = FindFirstFileW(pwszSearch, &FindData);
    if (hFindHandle == INVALID_HANDLE_VALUE)
    {
        //
        // See if a real error occurred, or just no directories
        //
        dwErr = GetLastError();
        if ((dwErr == ERROR_NO_MORE_FILES)  ||
            (dwErr == ERROR_PATH_NOT_FOUND) ||
            (dwErr == ERROR_FILE_NOT_FOUND))
        {
            //
            // There are no directories of this form
            //
            goto CommonReturn;
        }
        else
        {
            SetWriterFailure(WinErrorToWriterError(GetLastError()));
            goto ErrorReturn;
        }
    }

    while (TRUE)
    {
        //
        // Only care about directories
        //
        if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            pwszPathName = _CatDBCreatePath(pwszCatroot, FindData.cFileName);

            if (pwszPathName == NULL)
            {
                SetWriterFailure(WinErrorToWriterError(GetLastError()));
                goto ErrorReturn;
            }

            //
            // Add this catalog directory to component files group
            //
            hResult = pMetadata->AddFilesToFileGroup(
                NULL,
                g_wszComponentName,
                pwszPathName,
                L"*",
                true,
                NULL);

            free(pwszPathName);
            pwszPathName = NULL;
            
            if (hResult != S_OK)
            {
                SetWriterFailure(SqlErrorToWriterError(hResult));
                goto ErrorReturn;
            }
        }

        //
        // Get next file
        //
        if (!FindNextFileW(hFindHandle, &FindData))
        {
            //
            // Check to make sure the enumeration loop terminated normally
            //
            if (GetLastError() == ERROR_NO_MORE_FILES)
            {
                break;
            }
            else
            {
                SetWriterFailure(WinErrorToWriterError(GetLastError()));
                goto ErrorReturn;
            }
        }
    }

CommonReturn:

    if (pwszCatroot != NULL)
    {
        free(pwszCatroot);
    }

    if (pwszSearch != NULL)
    {
        free(pwszSearch);
    }

    if (pwszPathName != NULL)
    {
        free(pwszPathName);
    }

    return (fRet);

ErrorReturn:

    fRet = false;
    goto CommonReturn;
}

//---------------------------------------------------------------------------------------
//
//  CSystemWriter::AddSystemFiles()
//
//---------------------------------------------------------------------------------------
bool
CSystemWriter::AddSystemFiles(
    IN IVssCreateWriterMetadata *pMetadata)
{
    bool fRet = true;
    PROTECTED_FILE_DATA FileData;
    DWORD dwAttributes;
    PWSTR pwszPathName;
    PWSTR pwszFileSpec;
    bool bRecursive;
    HRESULT hResult;

    FileData.FileNumber = 0;

    //
    // Enumerate all of the files and directories protected by WFP
    //
    while (SfcGetNextProtectedFile(NULL, &FileData))
    {
        //
        // Make sure this file or directory is currently on this system
        //
        dwAttributes = GetFileAttributes(FileData.FileName);
        if (dwAttributes != INVALID_FILE_ATTRIBUTES)
        {
            //
            // Is this a directory?
            //
            if (dwAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                pwszPathName = FileData.FileName;
                pwszFileSpec = L"*";

                bRecursive = true;
            }
            else
            {
                //
                // Extract path and filename
                //
                if (pwszFileSpec = wcsrchr(FileData.FileName, L'\\'))
                {
                    pwszPathName = FileData.FileName;
                    *(pwszFileSpec++) = 0;
                }
                else
                {
                    // Should never get here!
                    assert(FALSE);
                }

                bRecursive = false;
            }

            //
            // Add this file or directory to component files group
            //
            hResult = pMetadata->AddFilesToFileGroup(
                NULL,
                g_wszComponentName,
                pwszPathName,
                pwszFileSpec,
                bRecursive,
                NULL);

            if (hResult != S_OK)
            {
                SetWriterFailure(SqlErrorToWriterError(hResult));
                goto ErrorReturn;
            }
        }
    }

    //
    // Check to make sure the enumeration loop terminated normally
    //
    if (GetLastError() != ERROR_NO_MORE_FILES)
    {
        SetWriterFailure(WinErrorToWriterError(GetLastError()));
        goto ErrorReturn;
    }

//
// Kludge to add the WinSxS directory for backup and restore, since
// the SfcGetNextProtectedFile() API does not report files under this
// directory.
//
    WCHAR wszWindowsDir[MAX_PATH+1];

    //
    // Get Windows directory
    //
    if (!GetWindowsDirectory(wszWindowsDir, MAX_PATH+1))
    {
        SetWriterFailure(WinErrorToWriterError(GetLastError()));
        goto ErrorReturn;
    }

    //
    // Create %WINDIR%\WinSxs directory string
    //
    pwszPathName = _CatDBCreatePath(wszWindowsDir, L"WinSxS");
    if (pwszPathName == NULL)
    {
        SetWriterFailure(WinErrorToWriterError(GetLastError()));
        goto ErrorReturn;
    }

    //
    // Make sure the %WINDIR%\WinSxs directory exists
    // and that it is a directory
    //
    dwAttributes = GetFileAttributes(pwszPathName);
    if ((dwAttributes != INVALID_FILE_ATTRIBUTES) &&
        (dwAttributes & FILE_ATTRIBUTE_DIRECTORY))
    {
        //
        // Add this directory to component files group
        //
        hResult = pMetadata->AddFilesToFileGroup(
            NULL,
            g_wszComponentName,
            pwszPathName,
            L"*",
            true,
            NULL);

        free(pwszPathName);
        pwszPathName = NULL;

        if (hResult != S_OK)
        {
            SetWriterFailure(SqlErrorToWriterError(hResult));
            goto ErrorReturn;
        }
    }
    else
    {
        free(pwszPathName);
        pwszPathName = NULL;
    }
//
// End kludge
//

CommonReturn:

    return fRet;

ErrorReturn:

    fRet = false;
    goto CommonReturn;
}


//***************************************************************************************
//
// CSystemWriter object private initialization functions
//
//***************************************************************************************

//---------------------------------------------------------------------------------------
//
//  CSystemWriter::IsSystemSetupInProgress()
//
//  Queries the registry to determine if a system setup is in progress.
//
//---------------------------------------------------------------------------------------
BOOL
CSystemWriter::IsSystemSetupInProgress()
{
    HKEY hKey;
    LONG lResult;
    DWORD dwSystemSetupInProgress = FALSE;
    DWORD dwSize = sizeof(dwSystemSetupInProgress);

    //
    // Open the System Setup key
    //
    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"System\\Setup", 0, KEY_QUERY_VALUE, &hKey);

    if (lResult == ERROR_SUCCESS)
    {
        //
        // Query SystemSetupInProgress value (assume 0 if value doesn't exist)
        //
        RegQueryValueEx(hKey, L"SystemSetupInProgress", NULL, NULL, (LPBYTE)&dwSystemSetupInProgress, &dwSize);
    
        //
        // Close the System Setup key
        //
        RegCloseKey(hKey);
    }

    return (BOOL)dwSystemSetupInProgress;
}

//---------------------------------------------------------------------------------------
//
//  CSystemWriter::WaitForServiceRunning()
//
//  Blocks until the service specified by wszServiceName enters the SERVICE_RUNNING
//  state.
//
//  Notes:  Uses a QueryServiceStatusEx()/Sleep() loop bevause no sync-object
//          mechanism is currently available.  Should be changed to use sync-object
//          mechanism when available.
//
//  Returns:    TRUE        Service specified is in SERVICE_RUNNING state.
//              FALSE       An error has occured preventing us from determining the
//                          state of the service specified.
//
//---------------------------------------------------------------------------------------
BOOL
CSystemWriter::WaitForServiceRunning(
    IN PWSTR wszServiceName)
{
    BOOL                            fRet            = TRUE;
    SC_HANDLE                       hScm            = NULL;
    SC_HANDLE                       hService        = NULL;
    LPSERVICE_STATUS_PROCESS        pInfo           = NULL;
    DWORD                           cbInfo          = 0;
    DWORD                           cbNeeded        = 0;
    BOOL                            fReady          = FALSE;
    DWORD                           dwError;

    //
    // Open the service control manager
    //
    hScm = OpenSCManager( NULL, NULL, SC_MANAGER_CONNECT|SC_MANAGER_ENUMERATE_SERVICE);

    if (!hScm)
    {
        LogSystemErrorEvent(MSG_SYSTEMWRITER_INIT_FAILURE, L"Could not open the Service Control Manager.", GetLastError());
        goto ErrorReturn;
    }

    //
    // Open the service
    //
    // Notes:   This should fail only if the service is not installed.
    //
    hService = OpenService(hScm, wszServiceName, SERVICE_QUERY_STATUS);

    if (!hService)
    {
        LogSystemErrorEvent(MSG_SYSTEMWRITER_INIT_FAILURE, L"Could not open the EventSystem service for query.", GetLastError());
        goto ErrorReturn;
    }

    //
    // This query loop should only execute twixe.  First to determine the size of the data, and second to
    // retrieve the data.  Only if the data size changes in between the first and second loops, will the
    // loop execute a third time
    //
    while(!fReady)
    {
        if (QueryServiceStatusEx(
            hService,
            SC_STATUS_PROCESS_INFO,
            (LPBYTE)pInfo,
            cbInfo,
            &cbNeeded))
        {
            //
            // Check that the state of the service is SERVICE_RUNNING.
            //
            if (pInfo->dwCurrentState == SERVICE_RUNNING)
            {
                fReady = TRUE;
            }
            else
            {
                //
                // If not, sleep for awhile
                //
                Sleep(500);

                //
                // Check for service shutdown condition
                //
                if (g_fShuttingDown)
                {
                    goto ErrorReturn;
                }
            }
        }
        else
        {
            if ((dwError = GetLastError()) != ERROR_INSUFFICIENT_BUFFER)
            {
                //
                // For all other errors
                //
                LogSystemErrorEvent(MSG_SYSTEMWRITER_INIT_FAILURE, L"Could not query the status of the EventSystem service.", dwError);
                goto ErrorReturn;
            }

            //
            // Just in case we already allocated a buffer on a previous loop
            //
            if (pInfo)
            {
                LocalFree((HLOCAL)pInfo);
            }

            //
            // Allocate buffer for the status data
            //
            pInfo = (LPSERVICE_STATUS_PROCESS) LocalAlloc(LMEM_FIXED, cbNeeded);

            if (!pInfo)
            {
                LogSystemErrorEvent(MSG_SYSTEMWRITER_INIT_FAILURE, L"Could not query the status of the EventSystem service.", GetLastError());
                goto ErrorReturn;
            }

            // Update parameters passed to QueryServiceStatusEx for next loop
            cbInfo = cbNeeded;
            cbNeeded = 0;
        }
    }

CommonReturn:

    if (pInfo)
    {
        LocalFree((HLOCAL)pInfo);
    }

    if (hService)
    {
        CloseServiceHandle(hService);
    }

    if (hScm)
    {
        CloseServiceHandle(hScm);
    }

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;
}

//---------------------------------------------------------------------------------------
//
//  CSystemWriter::InitializeThreadFunc()
//
//  This thread initializes the VSS base class.  If an error during initialization,
//  it is responsible for cleaning-up the object before exiting.
//  
//  Notes:  Waits for the EventSystem, COM+, and VSS services to initialize before
//          intializing the VSS base class.
//
//---------------------------------------------------------------------------------------
DWORD
CSystemWriter::InitializeThreadFunc(
    IN PVOID pvDummy)
{
    UNREFERENCED_PARAMETER(pvDummy);

    HRESULT hResult;
    bool fCoInitialized = false;
    bool fInitialized = false;

    //
    // Wait for EventSystem service to initialize here...
    //
    // Notes:   The call to Initialize() below requires that the EventSystem be up
    //          and running or it will hang.  We can't add a service-level dependency
    //          on the EventSystem service, because the EventSystem service fails
    //          to initialize during GUI-mode system setup, and the rest of our
    //          service must absolutely be available to the setup process.
    //
    if (!WaitForServiceRunning(L"EventSystem"))
    {
        //
        // We either couldn't determine the state of the EventSystem service or this 
        // service is being shutdown, so we should just exit here and not initialize.
        //
        goto Done;
    }

    //
    // Intialize MTA thread
    //
    hResult = ::CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (hResult != S_OK)
    {
        LogSystemErrorEvent(MSG_SYSTEMWRITER_INIT_FAILURE, L"CoInitializeEx failed.", hResult);
        goto Done;
    }
    fCoInitialized = true;

    //
    // Note: CoInitializeSecurity() is called by the service host, so we don't have to do it here.
    //

    //
    // Initialize the base class and subscribe
    //
    // Notes:   This call will wait for the COM+ and VSS services to initialize!
    //
    fInitialized = sm_pWriter->Initialize();

Done:
    
    //
    // Detach this thread from COM+ now, since we're about to exit.
    //
    if (fCoInitialized)
    {
        CoUninitialize();
    }

    //
    // If something prevented us from initializing, cleanup the object
    //
    if (!fInitialized)
    {
        delete sm_pWriter;
        sm_pWriter = NULL;
    }

    //
    // NULL-out and close global handle to this thread.
    //
    HANDLE hInitializeThread = InterlockedExchangePointer(&g_hInitializeThread, NULL);

    if (hInitializeThread != NULL)
    {
        ::CloseHandle(hInitializeThread);
    }

    return 0;
}

//---------------------------------------------------------------------------------------
//
//  CSystemWriter::Initialize()
//
//  Initializes and subscribes to the VSS base class.
//
//---------------------------------------------------------------------------------------
bool STDMETHODCALLTYPE
CSystemWriter::Initialize()
{
    bool fRet = true;
    HRESULT hResult;

    //
    // Initialize the VSS base class
    //
    hResult = CVssWriter::Initialize(
            g_guidWriterId,
            g_wszWriterName,
            VSS_UT_BOOTABLESYSTEMSTATE,
            VSS_ST_OTHER,
            VSS_APP_SYSTEM,
            60000);

    if (hResult != S_OK)
    {
        LogSystemErrorEvent(MSG_SYSTEMWRITER_INIT_FAILURE, L"System Writer object failed to initialize VSS.", hResult);
        goto ErrorReturn;
    }

    //
    // Subscribe to the VSS base class
    //
    hResult = Subscribe();

    if (hResult != S_OK)
    {
        LogSystemErrorEvent(MSG_SYSTEMWRITER_INIT_FAILURE, L"System Writer object failed to subscribe to VSS.", hResult);
        goto ErrorReturn;
    }

CommonReturn:

    return fRet;

ErrorReturn:

    fRet = false;
    goto CommonReturn;
}

//---------------------------------------------------------------------------------------
//
//  CSystemWriter::Uninitialize()
//
//  Unsubscribes from the VSS base class.
//
//---------------------------------------------------------------------------------------
bool STDMETHODCALLTYPE
CSystemWriter::Uninitialize()
{
    //
    // Unsubscribe from the VSS base class
    //
    return (Unsubscribe() == S_OK);
}


//***************************************************************************************
//
//  Error handling helper functions
//
//***************************************************************************************

//---------------------------------------------------------------------------------------
//
//  CSystemWriter::SqlErrorToWriterError()
//
//  Translate a SQL writer error code into a VSS writer error.
//
//---------------------------------------------------------------------------------------
HRESULT
CSystemWriter::SqlErrorToWriterError(
    IN HRESULT hSqlError)
{
    switch(hSqlError)
    {
        case E_OUTOFMEMORY:
        case HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY):
        case HRESULT_FROM_WIN32(ERROR_DISK_FULL):
        case HRESULT_FROM_WIN32(ERROR_TOO_MANY_OPEN_FILES):
        case HRESULT_FROM_WIN32(ERROR_NO_MORE_USER_HANDLES):
            return VSS_E_WRITERERROR_OUTOFRESOURCES;
    }
    
    return VSS_E_WRITERERROR_NONRETRYABLE;
}

//---------------------------------------------------------------------------------------
//
//  CSystemWriter::WinErrorToWriterError()
//
//  Translate WinError to a writer error
//
//---------------------------------------------------------------------------------------
HRESULT
CSystemWriter::WinErrorToWriterError(
    IN DWORD dwWinError)
{
    switch(dwWinError)
    {
        case ERROR_OUTOFMEMORY:
        case ERROR_NOT_ENOUGH_MEMORY:
        case ERROR_DISK_FULL:
        case ERROR_TOO_MANY_OPEN_FILES:
        case ERROR_NO_MORE_USER_HANDLES:
            return VSS_E_WRITERERROR_OUTOFRESOURCES;
    }
    
    return VSS_E_WRITERERROR_NONRETRYABLE;
}

//---------------------------------------------------------------------------------------
//
//  CSystemWriter::LogSystemErrorEvent()
//
//  Logs a SYSTEM error event based on the dwMsgId and additional optional info.
//
//---------------------------------------------------------------------------------------
void
CSystemWriter::LogSystemErrorEvent(
    IN DWORD dwMsgId,
    IN PWSTR pwszDetails,
    IN DWORD dwSysErrCode)
{
    HANDLE  hEventLog           = NULL;
    LPWSTR  wszDetailsHdr       = L"\n\nDetails:\n";
    LPWSTR  wszErrorHdr         = L"\n\nSystem Error:\n";
    LPWSTR  pwszError           = NULL;
    LPWSTR  pwszExtra           = NULL;
    DWORD   dwExtraLength       = 0;
    LPCWSTR rgpwszStrings[1]    = {L""};

    if (pwszDetails)
    {
        dwExtraLength += wcslen(wszDetailsHdr);
        dwExtraLength += wcslen(pwszDetails);
    }

    if (dwSysErrCode)
    {
        dwExtraLength += wcslen(wszErrorHdr);

        //
        // Try to get error message from system
        //
        FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                  FORMAT_MESSAGE_FROM_SYSTEM |
                  FORMAT_MESSAGE_IGNORE_INSERTS,
                  NULL,
                  dwSysErrCode,
                  0,
                  (LPWSTR) &pwszError,
                  0,
                  NULL);

        //
        // If we couldn't get an error message from the system, we'll just
        // print out the error code.
        //
        if (!pwszError)
        {
            pwszError = (LPWSTR) LocalAlloc(LMEM_FIXED, 26*sizeof(WCHAR));

            if (pwszError)
            {
                swprintf(pwszError, L"0x%08X (unresolvable)", dwSysErrCode);
            }
        }

        if (pwszError)
        {
            dwExtraLength += wcslen(pwszError);
        }
    }

    if (dwExtraLength)
    {
        //
        // Allocate extra string
        //
        pwszExtra = (LPWSTR) LocalAlloc(LMEM_FIXED, (dwExtraLength+1)*sizeof(WCHAR));

        if (pwszExtra)
        {
            pwszExtra[0] = 0;

            if (pwszDetails)
            {
                wcscat(pwszExtra, wszDetailsHdr);
                wcscat(pwszExtra, pwszDetails);
            }

            if (pwszError)
            {
                wcscat(pwszExtra, wszErrorHdr);
                wcscat(pwszExtra, pwszError);
            }
        }
    }

    if (pwszExtra)
    {
        rgpwszStrings[0] = pwszExtra;
    }

    hEventLog = RegisterEventSourceW(NULL, SZSERVICENAME);
    if (hEventLog != NULL)
    {
        ReportEventW(
            hEventLog,
            EVENTLOG_ERROR_TYPE,
            0,
            dwMsgId,
            NULL,
            1,
            0,
            rgpwszStrings,
            NULL);

        DeregisterEventSource(hEventLog);
    }

    if (pwszError)
    {
        LocalFree((HLOCAL)pwszError);
    }

    if (pwszExtra)
    {
        LocalFree((HLOCAL)pwszExtra);
    }
}


//***************************************************************************************
//
// Exported wrapper for CSystemWriter object Startup/Shutdown
//
//***************************************************************************************

//---------------------------------------------------------------------------------------
//
//  _SystemWriterInit()
//
//---------------------------------------------------------------------------------------
VOID
_SystemWriterInit(
    BOOL fUnInit)
{
    if (!fUnInit)
    {
        CSystemWriter::Startup();
    }
    else
    {
        CSystemWriter::Shutdown();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\cryptsvc\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\forwardr\softpub\softpub.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       softpub.cpp
//
//--------------------------------------------------------------------------

#ifdef _M_IX86

#include <windows.h>
#include <wincrypt.h>
#include <wintrust.h>
#include <prsht.h>

STDAPI SoftpubDllRegisterServer(void);
EXTERN_C
__declspec(naked)
HRESULT
STDAPICALLTYPE
DllRegisterServer()
{
    __asm {
        jmp SoftpubDllRegisterServer
    }
}

STDAPI SoftpubDllUnregisterServer(void);
EXTERN_C
__declspec(naked)
HRESULT
STDAPICALLTYPE
DllUnregisterServer()
{
    __asm {
        jmp SoftpubDllUnregisterServer
    }
}

EXTERN_C
HRESULT WINAPI SoftpubAuthenticode(CRYPT_PROVIDER_DATA *pProvData);

EXTERN_C
__declspec(naked)
HRESULT WINAPI ForwardrSoftpubAuthenticode(CRYPT_PROVIDER_DATA *pProvData)
{
    __asm {
        jmp SoftpubAuthenticode
    }
}

EXTERN_C
HRESULT WINAPI SoftpubDumpStructure(CRYPT_PROVIDER_DATA *pProvData);

EXTERN_C
__declspec(naked)
HRESULT WINAPI ForwardrSoftpubDumpStructure(CRYPT_PROVIDER_DATA *pProvData)
{
    __asm {
        jmp SoftpubDumpStructure
    }
}


EXTERN_C
HRESULT WINAPI SoftpubInitialize(CRYPT_PROVIDER_DATA *pProvData);

EXTERN_C
__declspec(naked)
HRESULT WINAPI ForwardrSoftpubInitialize(CRYPT_PROVIDER_DATA *pProvData)
{
    __asm {
        jmp SoftpubInitialize
    }
}

EXTERN_C
HRESULT WINAPI SoftpubLoadMessage(CRYPT_PROVIDER_DATA *pProvData);

EXTERN_C
__declspec(naked)
HRESULT WINAPI ForwardrSoftpubLoadMessage(CRYPT_PROVIDER_DATA *pProvData)
{
    __asm {
        jmp SoftpubLoadMessage
    }
}

EXTERN_C
HRESULT SoftpubLoadSignature(CRYPT_PROVIDER_DATA *pProvData);

EXTERN_C
__declspec(naked)
HRESULT ForwardrSoftpubLoadSignature(CRYPT_PROVIDER_DATA *pProvData)
{
    __asm {
        jmp SoftpubLoadSignature
    }
}

EXTERN_C
BOOL WINAPI SoftpubCheckCert(CRYPT_PROVIDER_DATA *pProvData, DWORD idxSigner,
                             BOOL fCounterSignerChain, DWORD idxCounterSigner);

EXTERN_C
__declspec(naked)
BOOL WINAPI ForwardrSoftpubCheckCert(CRYPT_PROVIDER_DATA *pProvData, DWORD idxSigner,
                             BOOL fCounterSignerChain, DWORD idxCounterSigner)
{
    __asm {
        jmp SoftpubCheckCert
    }
}

EXTERN_C
HRESULT WINAPI SoftpubCleanup(CRYPT_PROVIDER_DATA *pProvData);

EXTERN_C
__declspec(naked)
HRESULT WINAPI ForwardrSoftpubCleanup(CRYPT_PROVIDER_DATA *pProvData)
{
    __asm {
        jmp SoftpubCleanup
    }
}


HRESULT WINAPI SoftpubDefCertInit(CRYPT_PROVIDER_DATA *pProvData);

__declspec(naked)
HRESULT WINAPI ForwardrSoftpubDefCertInit(CRYPT_PROVIDER_DATA *pProvData)
{
    __asm {
        jmp SoftpubDefCertInit
    }
}


HRESULT WINAPI HTTPSCertificateTrust(CRYPT_PROVIDER_DATA *pProvData);

__declspec(naked)
HRESULT WINAPI ForwardrHTTPSCertificateTrust(CRYPT_PROVIDER_DATA *pProvData)
{
    __asm {
        jmp HTTPSCertificateTrust
    }
}

EXTERN_C
HRESULT WINAPI HTTPSFinalProv(CRYPT_PROVIDER_DATA *pProvData);

EXTERN_C
__declspec(naked)
HRESULT WINAPI ForwardrHTTPSFinalProv(CRYPT_PROVIDER_DATA *pProvData)
{
    __asm {
        jmp HTTPSFinalProv
    }
}

EXTERN_C
HRESULT WINAPI OfficeInitializePolicy(CRYPT_PROVIDER_DATA *pProvData);

EXTERN_C
__declspec(naked)
HRESULT WINAPI ForwardrOfficeInitializePolicy(CRYPT_PROVIDER_DATA *pProvData)
{
    __asm {
        jmp OfficeInitializePolicy
    }
}

EXTERN_C
HRESULT WINAPI OfficeCleanupPolicy(CRYPT_PROVIDER_DATA *pProvData);

EXTERN_C
__declspec(naked)
HRESULT WINAPI ForwardrOfficeCleanupPolicy(CRYPT_PROVIDER_DATA *pProvData)
{
    __asm {
        jmp OfficeCleanupPolicy
    }
}


EXTERN_C
HRESULT WINAPI DriverInitializePolicy(CRYPT_PROVIDER_DATA *pProvData);

EXTERN_C
__declspec(naked)
HRESULT WINAPI ForwardrDriverInitializePolicy(CRYPT_PROVIDER_DATA *pProvData)
{
    __asm {
        jmp DriverInitializePolicy
    }
}

EXTERN_C
HRESULT WINAPI DriverFinalPolicy(CRYPT_PROVIDER_DATA *pProvData);

EXTERN_C
__declspec(naked)
HRESULT WINAPI ForwardrDriverFinalPolicy(CRYPT_PROVIDER_DATA *pProvData)
{
    __asm {
        jmp DriverFinalPolicy
    }
}

EXTERN_C
HRESULT WINAPI DriverCleanupPolicy(CRYPT_PROVIDER_DATA *pProvData);

EXTERN_C
__declspec(naked)
HRESULT WINAPI ForwardrDriverCleanupPolicy(CRYPT_PROVIDER_DATA *pProvData)
{
    __asm {
        jmp DriverCleanupPolicy
    }
}


EXTERN_C
BOOL WINAPI OpenPersonalTrustDBDialog(HWND hwndParent);

EXTERN_C
__declspec(naked)
BOOL WINAPI ForwardrOpenPersonalTrustDBDialog(HWND hwndParent)
{
    __asm {
        jmp OpenPersonalTrustDBDialog
    }
}

EXTERN_C
BOOL CALLBACK AddPersonalTrustDBPages(
    LPVOID lpv,
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM lParam
   );

EXTERN_C
__declspec(naked)
BOOL CALLBACK ForwardrAddPersonalTrustDBPages(
    LPVOID lpv,
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM lParam
   )
{
    __asm {
        jmp AddPersonalTrustDBPages
    }
}


EXTERN_C
__declspec(naked)
HRESULT
WINAPI
ForwardrFindCertsByIssuer(
    OUT PCERT_CHAIN pCertChains,
    IN OUT DWORD *pcbCertChains,
    OUT DWORD *pcCertChains,        // count of certificates chains returned
    IN BYTE* pbEncodedIssuerName,   // DER encoded issuer name
    IN DWORD cbEncodedIssuerName,   // count in bytes of encoded issuer name
    IN LPCWSTR pwszPurpose,         // "ClientAuth" or "CodeSigning"
    IN DWORD dwKeySpec              // only return signers supporting this
    // keyspec
    )
{
    __asm {
        jmp FindCertsByIssuer
    }
}

BOOL WINAPI SoftpubLoadDefUsageCallData(const char *pszUsageOID, CRYPT_PROVIDER_DEFUSAGE *psDefUsage);

__declspec(naked)
BOOL WINAPI ForwardrSoftpubLoadDefUsageCallData(const char *pszUsageOID, CRYPT_PROVIDER_DEFUSAGE *psDefUsage)
{
    __asm {
        jmp SoftpubLoadDefUsageCallData
    }
}

BOOL WINAPI SoftpubFreeDefUsageCallData(const char *pszUsageOID, CRYPT_PROVIDER_DEFUSAGE *psDefUsage);

__declspec(naked)
BOOL WINAPI ForwardrSoftpubFreeDefUsageCallData(const char *pszUsageOID, CRYPT_PROVIDER_DEFUSAGE *psDefUsage)
{
    __asm {
        jmp SoftpubFreeDefUsageCallData
    }
}

HRESULT
WINAPI
GenericChainCertificateTrust(
    IN OUT PCRYPT_PROVIDER_DATA pProvData
    );

__declspec(naked)
HRESULT
WINAPI
ForwardrGenericChainCertificateTrust(
    IN OUT PCRYPT_PROVIDER_DATA pProvData
    )
{
    __asm {
        jmp GenericChainCertificateTrust
    }
}


HRESULT
WINAPI
GenericChainFinalProv(
    IN OUT PCRYPT_PROVIDER_DATA pProvData
    );

__declspec(naked)
HRESULT
WINAPI
ForwardrGenericChainFinalProv(
    IN OUT PCRYPT_PROVIDER_DATA pProvData
    )
{
    __asm {
        jmp GenericChainFinalProv
    }
}

#else

static void Dummy()
{
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\mincrypt\dll\mincryptdll.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       mincryptdll.cpp
//
//  Functions:  DllMain
//
//  History:    26-Jan-01    philh    created
//
//--------------------------------------------------------------------------

#include "windows.h"

// unreferenced formal parameter
#pragma warning (disable: 4100)


//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL WINAPI DllMain(
                HMODULE hInstDLL,
                DWORD fdwReason,
                LPVOID lpvReserved
                )
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\mincrypt\inc\minasn1.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       minasn1.h
//
//  Contents:   Minimal ASN.1 Utility and Parsing API Prototypes
//              and Definitions
//
//              Contains functions to parse X.509 certificates, PKCS #7
//              Signed Data messages, Certificate Trusts Lists (CTLs),
//              hash catalogs, Authenticode Indirect Data and
//              RSA public keys.
//
//              These APIs are implemented to be self contained and to
//              allow for code obfuscation. These APIs will be included
//              in such applications as, DRM or licensing verification.
//
//              Additionally, since these APIs have been pared down
//              from their wincrypt.h and crypt32.dll counterparts they are
//              a good candidate for applications with minimal memory and CPU
//              resources.
//
//              These parsing functions don't depend on more heavy wait
//              ASN.1 runtimes, such as, msoss.dll or msasn1.dll.
//
//              These functions will only use stack memory. No heap
//              allocations. No calls to APIs in other DLLs.
//
//  APIs: 
//              MinAsn1DecodeLength
//              MinAsn1ExtractContent
//              MinAsn1ExtractValues
//
//              MinAsn1ParseCertificate
//              MinAsn1ParseAlgorithmIdentifier
//              MinAsn1ParsePublicKeyInfo
//              MinAsn1ParseRSAPublicKey
//              MinAsn1ParseExtensions
//              MinAsn1ParseSignedData
//              MinAsn1ParseSignedDataCertificates
//              MinAsn1ParseAttributes
//              MinAsn1ParseCTL
//              MinAsn1ParseCTLSubject
//              MinAsn1ParseIndirectData
//
//              MinAsn1FindExtension
//              MinAsn1FindAttribute
//              MinAsn1ExtractParsedCertificatesFromSignedData
//
//----------------------------------------------------------------------------

#ifndef __MINASN1_H__
#define __MINASN1_H__


#if defined (_MSC_VER)

#if ( _MSC_VER >= 800 )
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)    /* Nameless struct/union */
#endif

#if (_MSC_VER > 1020)
#pragma once
#endif

#endif


#include <wincrypt.h>

#ifdef __cplusplus
extern "C" {
#endif


//+-------------------------------------------------------------------------
//  ASN.1 Tag Defines
//--------------------------------------------------------------------------
#define MINASN1_TAG_NULL                    0x00
#define MINASN1_TAG_BOOLEAN                 0x01
#define MINASN1_TAG_INTEGER                 0x02
#define MINASN1_TAG_BITSTRING               0x03
#define MINASN1_TAG_OCTETSTRING             0x04
#define MINASN1_TAG_OID                     0x06
#define MINASN1_TAG_UTC_TIME                0x17
#define MINASN1_TAG_GENERALIZED_TIME        0x18
#define MINASN1_TAG_CONSTRUCTED             0x20
#define MINASN1_TAG_SEQ                     0x30
#define MINASN1_TAG_SET                     0x31
#define MINASN1_TAG_CONTEXT_0               0x80
#define MINASN1_TAG_CONTEXT_1               0x81
#define MINASN1_TAG_CONTEXT_2               0x82
#define MINASN1_TAG_CONTEXT_3               0x83

#define MINASN1_TAG_CONSTRUCTED_CONTEXT_0   \
                        (MINASN1_TAG_CONSTRUCTED | MINASN1_TAG_CONTEXT_0)
#define MINASN1_TAG_CONSTRUCTED_CONTEXT_1   \
                        (MINASN1_TAG_CONSTRUCTED | MINASN1_TAG_CONTEXT_1)
#define MINASN1_TAG_CONSTRUCTED_CONTEXT_3   \
                        (MINASN1_TAG_CONSTRUCTED | MINASN1_TAG_CONTEXT_3)

//+-------------------------------------------------------------------------
//  ASN.1 Length Defines for indefinite length encooding
//--------------------------------------------------------------------------
#define MINASN1_LENGTH_INDEFINITE               0x80
#define MINASN1_LENGTH_NULL                     0x00

#define MINASN1_LENGTH_TOO_LARGE                -1
#define MINASN1_INSUFFICIENT_DATA               -2
#define MINASN1_UNSUPPORTED_INDEFINITE_LENGTH   -3

//+-------------------------------------------------------------------------
//  Get the number of contents octets in a definite-length BER-encoding.
//
//  Parameters:
//          pcbContent - receives the number of contents octets
//          pbLength   - points to the first length octet
//          cbBER      - number of bytes remaining in the BER encoding
//
//  Returns:
//          success - the number of bytes in the length field, > 0
//          failure - < 0
//
//          One of the following failure values can be returned:
//              MINASN1_LENGTH_TOO_LARGE
//              MINASN1_INSUFFICIENT_DATA
//              MINASN1_UNSUPPORTED_INDEFINITE_LENGTH
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1DecodeLength(
    OUT DWORD *pcbContent,
    IN const BYTE *pbLength,
    IN  DWORD cbBER
    );

//+-------------------------------------------------------------------------
//  Point to the content octets in a definite-length BER-encoded blob.
//
//  Returns:
//          success - the number of bytes skipped, > 0
//          failure - < 0
//
//          One of the following failure values can be returned:
//              MINASN1_LENGTH_TOO_LARGE
//              MINASN1_INSUFFICIENT_DATA
//              MINASN1_UNSUPPORTED_INDEFINITE_LENGTH
//
// Assumption: pbData points to a definite-length BER-encoded blob.
//             If *pcbContent isn't within cbBER, MINASN1_INSUFFICIENT_DATA
//             is returned.
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ExtractContent(
    IN const BYTE *pbBER,
    IN DWORD cbBER,
    OUT DWORD *pcbContent,
    OUT const BYTE **ppbContent
    );


typedef struct _MINASN1_EXTRACT_VALUE_PARA {
    // See below for list of operations and optional return blobs.
    DWORD           dwFlags;

    // Index into rgValueBlob of the returned value. Ignored if none of
    // the ASN1_PARSE_RETURN_*_BLOB_FLAG's is set in the above dwFlags.
    DWORD           dwIndex;

    // The following 0 terminated array of tags is optional. If ommited, the
    // value may contain any tag.
    const BYTE      *rgbTag;
} MINASN1_EXTRACT_VALUE_PARA, *PMINASN1_EXTRACT_VALUE_PARA;

// The lower 8 bits of dwFlags is set to one of the following operations
#define MINASN1_MASK_VALUE_OP                   0xFF
#define MINASN1_STEP_OVER_VALUE_OP              1
#define MINASN1_OPTIONAL_STEP_OVER_VALUE_OP     2
#define MINASN1_STEP_INTO_VALUE_OP              3
#define MINASN1_OPTIONAL_STEP_INTO_VALUE_OP     4
#define MINASN1_STEP_OUT_VALUE_OP               5

#define MINASN1_RETURN_VALUE_BLOB_FLAG          0x80000000
#define MINASN1_RETURN_CONTENT_BLOB_FLAG        0x40000000


//+-------------------------------------------------------------------------
//  Extract one or more tagged values from the ASN.1 encoded byte array.
//
//  Either steps into the value's content octets (MINASN1_STEP_INTO_VALUE_OP or
//  MINASN1_OPTIONAL_STEP_INTO_VALUE_OP) or steps over the value's tag,
//  length and content octets (MINASN1_STEP_OVER_VALUE_OP or
//  MINASN1_OPTIONAL_STEP_OVER_VALUE_OP).
//
//  You can step out of a stepped into sequence via MINASN1_STEP_OUT_VALUE_OP.
//
//  For tag matching, only supports single byte tags.
//
//  Only definite-length ASN.1 is supported.
//
//  *pcValue is updated with the number of values successfully extracted.
//
//  Returns:
//      success - >= 0 => length of all bytes consumed through the last value
//                        extracted. For STEP_INTO, only the tag and length
//                        octets.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  A non-NULL rgValueBlob[] is updated with the pointer to and length of the
//  tagged value or its content octets. The rgValuePara[].dwIndex is used to
//  index into rgValueBlob[].  For OPTIONAL_STEP_OVER or
//  OPTIONAL_STEP_INTO, if no more bytes in the outer SEQUENCE or if the tag
//  isn't found, pbData and cbData are set to 0. Additioanlly, for
//  OPTIONAL_STEP_INTO, all subsequent values are skipped and their
//  rgValueBlob[] entries zeroed until a STEP_OUT is encountered.
//
//  If MINASN1_RETURN_VALUE_BLOB_FLAG is set, pbData points to
//  the tag. cbData includes the tag, length and content octets.
//
//  If MINASN1_RETURN_CONTENT_BLOB_FLAG is set, pbData points to the content
//  octets. cbData includes only the content octets.
//
//  If neither BLOB_FLAG is set, rgValueBlob[] isn't updated.
//
//  For MINASN1_RETURN_CONTENT_BLOB_FLAG of a BITSTRING, pbData is
//  advanced past the first contents octet containing the number of
//  unused bits and cbData has been decremented by 1. If cbData > 0, then,
//  *(pbData - 1) will contain the number of unused bits.
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ExtractValues(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN OUT DWORD *pcValuePara,
    IN const MINASN1_EXTRACT_VALUE_PARA *rgValuePara,
    IN DWORD cValueBlob,
    OUT OPTIONAL PCRYPT_DER_BLOB rgValueBlob
    );


//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseCertificate
//
//  Parses an ASN.1 encoded X.509 certificate.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded certificate
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgCertBlob[] is updated with pointer to and length of the following
//  fields in the encoded X.509 certificate.
//
//  All BITSTRING fields have been advanced past the unused count octet.
//--------------------------------------------------------------------------

// Encoded bytes including To Be Signed and Signature
#define MINASN1_CERT_ENCODED_IDX                1

// To Be Signed bytes
#define MINASN1_CERT_TO_BE_SIGNED_IDX           2

// Signature Algorithm value bytes (MinAsn1ParseAlgorithmIdentifier)
#define MINASN1_CERT_SIGN_ALGID_IDX             3

// Signature content bytes (BITSTRING)
#define MINASN1_CERT_SIGNATURE_IDX              4

// Version content bytes (OPTIONAL INTEGER)
#define MINASN1_CERT_VERSION_IDX                5

// Serial Number content bytes (INTEGER)
#define MINASN1_CERT_SERIAL_NUMBER_IDX          6

// Issuer Name value bytes (ANY)
#define MINASN1_CERT_ISSUER_IDX                 7

// Not Before value bytes (UTC_TIME or GENERALIZED_TIME)
#define MINASN1_CERT_NOT_BEFORE_IDX             8

// Not After value bytes (UTC_TIME or GENERALIZED_TIME)
#define MINASN1_CERT_NOT_AFTER_IDX              9

// Subject Name value bytes (ANY)
#define MINASN1_CERT_SUBJECT_IDX                10

// Public Key Info value bytes (MinAsn1ParsePublicKeyInfo)
#define MINASN1_CERT_PUBKEY_INFO_IDX            11

// Issuer Unique Id content bytes (OPTIONAL BITSTRING)
#define MINASN1_CERT_ISSUER_UNIQUE_ID_IDX       12

// Subject Unique Id content bytes (OPTIONAL BITSTRING)
#define MINASN1_CERT_SUBJECT_UNIQUE_ID_IDX      13

// Extensions value bytes skipping "[3] EXPLICIT" tag
// (OPTIONAL MinAsn1ParseExtensions)
#define MINASN1_CERT_EXTS_IDX                   14

#define MINASN1_CERT_BLOB_CNT                   15

LONG
WINAPI
MinAsn1ParseCertificate(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT CRYPT_DER_BLOB rgCertBlob[MINASN1_CERT_BLOB_CNT]
    );


//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseAlgorithmIdentifier
//
//  Parses an ASN.1 encoded Algorithm Identifier contained in numerous
//  other ASN.1 structures, such as, X.509 certificate and PKCS #7 Signed Data
//  message.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded algorithm
//                        identifier
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgAlgIdBlob[] is updated with pointer to and length of the following
//  fields in the encoded Algorithm Identifier
//--------------------------------------------------------------------------

// Encoded bytes including outer SEQUENCE tag and length octets
#define MINASN1_ALGID_ENCODED_IDX               1

// Object Identifier content bytes (OID)
#define MINASN1_ALGID_OID_IDX                   2

// Encoded parameters value bytes (OPTIONAL ANY)
#define MINASN1_ALGID_PARA_IDX                  3

#define MINASN1_ALGID_BLOB_CNT                  4


LONG
WINAPI
MinAsn1ParseAlgorithmIdentifier(
    IN PCRYPT_DER_BLOB pAlgIdValueBlob,
    OUT CRYPT_DER_BLOB rgAlgIdBlob[MINASN1_ALGID_BLOB_CNT]
    );



//+-------------------------------------------------------------------------
//  Function: MinAsn1ParsePublicKeyInfo
//
//  Parses an ASN.1 encoded Public Key Info structure contained in an
//  X.509 certificate
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded public key
//                        info
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgPubKeyInfoBlob[] is updated with pointer to and length of the
//  following fields in the encoded Public Key Info.
//
//  All BITSTRING fields have been advanced past the unused count octet.
//--------------------------------------------------------------------------

// Encoded bytes including outer SEQUENCE tag and length octets
#define MINASN1_PUBKEY_INFO_ENCODED_IDX         1

// Algorithm Identifier value bytes (MinAsn1ParseAlgorithmIdentifier)
#define MINASN1_PUBKEY_INFO_ALGID_IDX           2

// Public Key content bytes (BITSTRING, MinAsn1ParseRSAPublicKey)
#define MINASN1_PUBKEY_INFO_PUBKEY_IDX          3

#define MINASN1_PUBKEY_INFO_BLOB_CNT            4


LONG
WINAPI
MinAsn1ParsePublicKeyInfo(
    IN PCRYPT_DER_BLOB pPubKeyInfoValueBlob,
    CRYPT_DER_BLOB rgPubKeyInfoBlob[MINASN1_PUBKEY_INFO_BLOB_CNT]
    );


//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseRSAPublicKey
//
//  Parses an ASN.1 encoded RSA PKCS #1 Public Key contained in the contents of
//  Public Key BITSTRING in a X.509 certificate.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded RSA public key
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgRSAPubKeyBlob[] is updated with pointer to and length of the
//  following fields in the encoded RSA Public Key.
//--------------------------------------------------------------------------

// Encoded bytes including outer SEQUENCE tag and length octets
#define MINASN1_RSA_PUBKEY_ENCODED_IDX          1

// Modulus content bytes (INTEGER)
#define MINASN1_RSA_PUBKEY_MODULUS_IDX          2

// Exponent content bytes (INTEGER)
#define MINASN1_RSA_PUBKEY_EXPONENT_IDX         3

#define MINASN1_RSA_PUBKEY_BLOB_CNT             4

LONG
WINAPI
MinAsn1ParseRSAPublicKey(
    IN PCRYPT_DER_BLOB pPubKeyContentBlob,
    CRYPT_DER_BLOB rgRSAPubKeyBlob[MINASN1_RSA_PUBKEY_BLOB_CNT]
    );


//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseExtensions
//
//  Parses an ASN.1 encoded sequence of extensions contained in 
//  other ASN.1 structures, such as, X.509 certificate and CTL.
//
//  Upon input, *pcExt contains the maximum number of parsed extensions
//  that can be returned. Updated with the number of extensions processed.
//
//  Returns:
//      success - >= 0 => bytes skipped, length of the encoded extensions
//                        processed. If all extensions were processed,
//                        bytes skipped = pExtsValueBlob->cbData.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgrgExtBlob[][] is updated with pointer to and length of the
//  following fields in the encoded extension.
//--------------------------------------------------------------------------

// Encoded bytes including outer SEQUENCE tag and length octets
#define MINASN1_EXT_ENCODED_IDX                 1

// Object Identifier content bytes (OID)
#define MINASN1_EXT_OID_IDX                     2

// Critical content bytes (OPTIONAL BOOLEAN, DEFAULT FALSE)
#define MINASN1_EXT_CRITICAL_IDX                3

// Value content bytes (OCTETSTRING)
#define MINASN1_EXT_VALUE_IDX                   4

#define MINASN1_EXT_BLOB_CNT                    5

LONG
WINAPI
MinAsn1ParseExtensions(
    IN PCRYPT_DER_BLOB pExtsValueBlob,  // Extensions ::= SEQUENCE OF Extension
    IN OUT DWORD *pcExt,
    OUT CRYPT_DER_BLOB rgrgExtBlob[][MINASN1_EXT_BLOB_CNT]
    );



//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseSignedData
//
//  Parses an ASN.1 encoded PKCS #7 Signed Data Message. Assumes the
//  PKCS #7 message is definite length encoded. Assumes PKCS #7 version
//  1.5, ie, not the newer CMS version.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded message
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgSignedDataBlob[] is updated with pointer to and length of the
//  following fields in the encoded PKCS #7 message.
//--------------------------------------------------------------------------

// Encoded bytes including outer SEQUENCE tag and length octets
#define MINASN1_SIGNED_DATA_ENCODED_IDX                             1

// Outer Object Identfier content bytes (OID, should be "1.2.840.113549.1.7.2")
#define MINASN1_SIGNED_DATA_OUTER_OID_IDX                           2

// Version content bytes (INTEGER)
#define MINASN1_SIGNED_DATA_VERSION_IDX                             3

// Set of Digest Algorithms value bytes (SET OF)
#define MINASN1_SIGNED_DATA_DIGEST_ALGIDS_IDX                       4

// Inner Object Identifier content bytes (OID)
#define MINASN1_SIGNED_DATA_CONTENT_OID_IDX                         5

// Signed content data content bytes excluding "[0] EXPLICIT" tag
// (OPTIONAL ANY, MinAsn1ParseCTL, MinAsn1ParseIndirectData)
#define MINASN1_SIGNED_DATA_CONTENT_DATA_IDX                        6

// Certificates value bytes including "[1] IMPLICIT" tag
// (OPTIONAL, MinAsn1ParseSignedDataCertificates)
#define MINASN1_SIGNED_DATA_CERTS_IDX                               7

// CRL value bytes including "[2] IMPLICIT" tag (OPTIONAL)
#define MINASN1_SIGNED_DATA_CRLS_IDX                                8

// Encoded bytes including outer SET tag and length octets
#define MINASN1_SIGNED_DATA_SIGNER_INFOS_IDX                        9

// The following point to the first Signer Info fields (OPTIONAL)

// Encoded bytes including outer SEQUENCE tag and length octets
#define MINASN1_SIGNED_DATA_SIGNER_INFO_ENCODED_IDX                 10

// Version content bytes (INTEGER)
#define MINASN1_SIGNED_DATA_SIGNER_INFO_VERSION_IDX                 11

// Issuer Name value bytes (ANY)
#define MINASN1_SIGNED_DATA_SIGNER_INFO_ISSUER_IDX                  12

// Serial Number content bytes (INTEGER)
#define MINASN1_SIGNED_DATA_SIGNER_INFO_SERIAL_NUMBER_IDX           13

// Digest Algorithm value bytes (MinAsn1ParseAlgorithmIdentifier)
#define MINASN1_SIGNED_DATA_SIGNER_INFO_DIGEST_ALGID_IDX            14

// Authenticated attributes value bytes including "[0] IMPLICIT" tag
// (OPTIONAL, MinAsn1ParseAttributes)
#define MINASN1_SIGNED_DATA_SIGNER_INFO_AUTH_ATTRS_IDX              15

// Encrypted Digest Algorithm value bytes (MinAsn1ParseAlgorithmIdentifier)
#define MINASN1_SIGNED_DATA_SIGNER_INFO_ENCRYPT_DIGEST_ALGID_IDX    16

// Encrypted digest content bytes (OCTET STRING)
#define MINASN1_SIGNED_DATA_SIGNER_INFO_ENCYRPT_DIGEST_IDX          17

// Unauthenticated attributes value bytes including "[1] IMPLICIT" tag
// (OPTIONAL, MinAsn1ParseAttributes)
#define MINASN1_SIGNED_DATA_SIGNER_INFO_UNAUTH_ATTRS_IDX            18

#define MINASN1_SIGNED_DATA_BLOB_CNT                                19

LONG
WINAPI
MinAsn1ParseSignedData(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT CRYPT_DER_BLOB rgSignedDataBlob[MINASN1_SIGNED_DATA_BLOB_CNT]
    );



//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseSignedDataCertificates
//
//  Parses an ASN.1 encoded set of certificates contained in 
//  a Signed Data message.
//
//  Upon input, *pcCert contains the maximum number of parsed certificates
//  that can be returned. Updated with the number of certificates processed.
//
//  Returns:
//      success - >= 0 => bytes skipped, length of the encoded certificates
//                        processed. If all certificates were processed,
//                        bytes skipped = pCertsValueBlob->cbData.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgrgCertBlob[][] is updated with pointer to and length of the
//  fields in the encoded certificate. See MinAsn1ParseCertificate for the
//  field definitions.
//--------------------------------------------------------------------------

LONG
WINAPI
MinAsn1ParseSignedDataCertificates(
    IN PCRYPT_DER_BLOB pCertsValueBlob,
    IN OUT DWORD *pcCert,
    OUT CRYPT_DER_BLOB rgrgCertBlob[][MINASN1_CERT_BLOB_CNT]
    );


//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseAttributes
//
//  Parses an ASN.1 encoded sequence of attributes contained in 
//  other ASN.1 structures, such as, Signer Info authenticated or
//  unauthenticated attributes.
//
//  The outer tag is ignored. It can be a SET, [0] IMPLICIT, or [1] IMPLICIT.
//
//  Upon input, *pcAttr contains the maximum number of parsed attributes
//  that can be returned. Updated with the number of attributes processed.
//
//  Returns:
//      success - >= 0 => bytes skipped, length of the encoded attributes
//                        processed. If all attributes were processed,
//                        bytes skipped = pAttrsValueBlob->cbData.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgrgAttrBlob[][] is updated with pointer to and length of the
//  following fields in the encoded attribute.
//--------------------------------------------------------------------------

// Encoded bytes including outer SEQUENCE tag and length octets
#define MINASN1_ATTR_ENCODED_IDX                1

// Object Identifier content bytes (OID)
#define MINASN1_ATTR_OID_IDX                    2

// Values value bytes (SET OF)
#define MINASN1_ATTR_VALUES_IDX                 3

// First Value's value bytes (OPTIONAL ANY)
#define MINASN1_ATTR_VALUE_IDX                  4

#define MINASN1_ATTR_BLOB_CNT                   5

LONG
WINAPI
MinAsn1ParseAttributes(
    IN PCRYPT_DER_BLOB pAttrsValueBlob,
    IN OUT DWORD *pcAttr,
    OUT CRYPT_DER_BLOB rgrgAttrBlob[][MINASN1_ATTR_BLOB_CNT]
    );




//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseCTL
//
//  Parses an ASN.1 encoded Certificate Trust List (CTL). A CTL is always
//  contained as the inner content data in a PKCS #7 Signed Data. A CTL has
//  the following OID: "1.3.6.1.4.1.311.10.1".
//
//  A catalog file is formatted as a PKCS #7 Signed CTL.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded CTL
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgCTLBlob[] is updated with pointer to and length of the following
//  fields in the encoded CTL.
//
//--------------------------------------------------------------------------

// Encoded bytes including outer SEQUENCE tag and length octets
#define MINASN1_CTL_ENCODED_IDX                 1

// Version content bytes (OPTIONAL INTEGER)
#define MINASN1_CTL_VERSION_IDX                 2

// Subject usage value bytes (SEQUENCE OF OID)
#define MINASN1_CTL_SUBJECT_USAGE_IDX           3

// List Identifier content bytes (OPTIONAL OCTETSTRING)
#define MINASN1_CTL_LIST_ID_IDX                 4

// Sequence number content bytes (OPTIONAL INTEGER)
#define MINASN1_CTL_SEQUENCE_NUMBER_IDX         5

// This Update value bytes (UTC_TIME or GENERALIZED_TIME)
#define MINASN1_CTL_THIS_UPDATE_IDX             6

// Next Update value bytes (OPTIONAL UTC_TIME or GENERALIZED_TIME)
#define MINASN1_CTL_NEXT_UPDATE_IDX             7

// Subject Algorithm Identifier value bytes (MinAsn1ParseAlgorithmIdentifier)
#define MINASN1_CTL_SUBJECT_ALGID_IDX           8

// Subjects value bytes (OPTIONAL, iterative MinAsn1ParseCTLSubject)
#define MINASN1_CTL_SUBJECTS_IDX                9

// Extensions value bytes skipping "[0] EXPLICIT" tag
// (OPTIONAL, MinAsn1ParseExtensions)
#define MINASN1_CTL_EXTS_IDX                    10

#define MINASN1_CTL_BLOB_CNT                    11

LONG
WINAPI
MinAsn1ParseCTL(
    IN PCRYPT_DER_BLOB pEncodedContentBlob,
    OUT CRYPT_DER_BLOB rgCTLBlob[MINASN1_CTL_BLOB_CNT]
    );



//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseCTLSubject
//
//  Parses an ASN.1 encoded CTL Subject contained within a CTL's SEQUENCE OF
//  Subjects.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded subject.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgCTLSubjectBlob[][] is updated with pointer to and length of the
//  following fields in the encoded subject.
//--------------------------------------------------------------------------

// Encoded bytes including outer SEQUENCE tag and length octets
#define MINASN1_CTL_SUBJECT_ENCODED_IDX         1

// Subject Identifier content bytes (OCTETSTRING)
#define MINASN1_CTL_SUBJECT_ID_IDX              2

// Attributes value bytes (OPTIONAL, MinAsn1ParseAttributes)
#define MINASN1_CTL_SUBJECT_ATTRS_IDX           3

#define MINASN1_CTL_SUBJECT_BLOB_CNT            4

LONG
WINAPI
MinAsn1ParseCTLSubject(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT CRYPT_DER_BLOB rgCTLSubjectBlob[MINASN1_CTL_SUBJECT_BLOB_CNT]
    );



//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseIndirectData
//
//  Parses an ASN.1 encoded Indirect Data. Indirect Data is always
//  contained as the inner content data in a PKCS #7 Signed Data. It has
//  the following OID: "1.3.6.1.4.1.311.2.1.4"
//
//  An Authenticode signed file contains a PKCS #7 Signed Indirect Data.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded Indirect Data
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgIndirectDataBlob[] is updated with pointer to and length of the
//  following fields in the encoded Indirect Data.
//
//--------------------------------------------------------------------------

// Encoded bytes including outer SEQUENCE tag and length octets
#define MINASN1_INDIRECT_DATA_ENCODED_IDX       1

// Attribute Object Identifier content bytes (OID)
#define MINASN1_INDIRECT_DATA_ATTR_OID_IDX      2

// Attribute value bytes (OPTIONAL ANY)
#define MINASN1_INDIRECT_DATA_ATTR_VALUE_IDX    3

// Digest Algorithm Identifier (MinAsn1ParseAlgorithmIdentifier)
#define MINASN1_INDIRECT_DATA_DIGEST_ALGID_IDX  4

// Digest content bytes (OCTETSTRING)
#define MINASN1_INDIRECT_DATA_DIGEST_IDX        5

#define MINASN1_INDIRECT_DATA_BLOB_CNT          6

LONG
WINAPI
MinAsn1ParseIndirectData(
    IN PCRYPT_DER_BLOB pEncodedContentBlob,
    OUT CRYPT_DER_BLOB rgIndirectDataBlob[MINASN1_INDIRECT_DATA_BLOB_CNT]
    );




//+-------------------------------------------------------------------------
//  Find an extension identified by its Encoded Object Identifier.
//
//  Searches the list of parsed extensions returned by
//  MinAsn1ParseExtensions().
//
//  If found, returns pointer to the rgExtBlob[MINASN1_EXT_BLOB_CNT].
//  Otherwise, returns NULL.
//--------------------------------------------------------------------------
PCRYPT_DER_BLOB
WINAPI
MinAsn1FindExtension(
    IN PCRYPT_DER_BLOB pEncodedOIDBlob,
    IN DWORD cExt,
    IN CRYPT_DER_BLOB rgrgExtBlob[][MINASN1_EXT_BLOB_CNT]
    );


//+-------------------------------------------------------------------------
//  Find the first attribute identified by its Encoded Object Identifier.
//
//  Searches the list of parsed attributes returned by
//  MinAsn1ParseAttributes().
//
//  If found, returns pointer to the rgAttrBlob[MINASN1_ATTR_BLOB_CNT].
//  Otherwise, returns NULL.
//--------------------------------------------------------------------------
PCRYPT_DER_BLOB
WINAPI
MinAsn1FindAttribute(
    IN PCRYPT_DER_BLOB pEncodedOIDBlob,
    IN DWORD cAttr,
    IN CRYPT_DER_BLOB rgrgAttrBlob[][MINASN1_ATTR_BLOB_CNT]
    );

//+-------------------------------------------------------------------------
//  Parses an ASN.1 encoded PKCS #7 Signed Data Message to extract and
//  parse the X.509 certificates it contains.
//
//  Assumes the PKCS #7 message is definite length encoded.
//  Assumes PKCS #7 version 1.5, ie, not the newer CMS version.
//
//  Upon input, *pcCert contains the maximum number of parsed certificates
//  that can be returned. Updated with the number of certificates processed.
//
//  If the encoded message was successfully parsed, TRUE is returned
//  with *pcCert updated with the number of parsed certificates. Otherwise,
//  FALSE is returned for a parse error.
//  Returns:
//      success - >= 0 => bytes skipped, length of the encoded certificates
//                        processed.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//                        from beginning of message.
//
//  The rgrgCertBlob[][] is updated with pointer to and length of the
//  fields in the encoded certificate. See MinAsn1ParseCertificate for the
//  field definitions.
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ExtractParsedCertificatesFromSignedData(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN OUT DWORD *pcCert,
    OUT CRYPT_DER_BLOB rgrgCertBlob[][MINASN1_CERT_BLOB_CNT]
    );



#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#if defined (_MSC_VER)
#if ( _MSC_VER >= 800 )

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif

#endif
#endif

#endif // __MINASN1_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\mincrypt\lib\fileutil.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       fileutil.h
//
//  Contents:   File utility functions used by the minimal cryptographic
//              APIs.
//
//  APIs: 
//              I_MinCryptMapFile
//
//----------------------------------------------------------------------------

#ifndef __MINCRYPT_FILEUTIL_H__
#define __MINCRYPT_FILEUTIL_H__


#if defined (_MSC_VER)

#if ( _MSC_VER >= 800 )
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)    /* Nameless struct/union */
#endif

#if (_MSC_VER > 1020)
#pragma once
#endif

#endif


#include <wincrypt.h>
#include <mincrypt.h>

#ifdef __cplusplus
extern "C" {
#endif


//+-------------------------------------------------------------------------
//  Maps the file into memory.
//
//  According to dwFileType, pvFile can be a pwszFilename, hFile or pFileBlob.
//  Only READ access is required.
//
//  dwFileType:
//      MINCRYPT_FILE_NAME      : pvFile - LPCWSTR pwszFilename
//      MINCRYPT_FILE_HANDLE    : pvFile - HANDLE hFile
//      MINCRYPT_FILE_BLOB      : pvFile - PCRYPT_DATA_BLOB pFileBlob
//
//  *pFileBlob is updated with pointer to and length of the mapped file. For
//  MINCRYPT_FILE_NAME and MINCRYPT_FILE_HANDLE, UnmapViewOfFile() must
//  be called to free pFileBlob->pbData.
//
//  All accesses to this mapped memory must be within __try / __except's.
//--------------------------------------------------------------------------
LONG
WINAPI
I_MinCryptMapFile(
    IN DWORD dwFileType,
    IN const VOID *pvFile,
    OUT PCRYPT_DATA_BLOB pFileBlob
    );




#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#if defined (_MSC_VER)
#if ( _MSC_VER >= 800 )

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif

#endif
#endif

#endif // __MINCRYPT_FILEUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\mincrypt\lib\fileutil.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       fileutil.cpp
//
//  Contents:   File utility functions used by the minimal cryptographic
//              APIs.
//
//  Functions:  I_MinCryptMapFile
//
//  History:    21-Jan-01    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"

#ifdef _M_IX86

//+=========================================================================
//  The following is taken from the following file:
//      \nt\ds\security\cryptoapi\common\unicode\reg.cpp
//-=========================================================================

BOOL WINAPI I_FIsWinNT(void) {

    static BOOL fIKnow = FALSE;
    static BOOL fIsWinNT = FALSE;

    OSVERSIONINFO osVer;

    if(fIKnow)
        return(fIsWinNT);

    memset(&osVer, 0, sizeof(OSVERSIONINFO));
    osVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if( GetVersionEx(&osVer) )
        fIsWinNT = (osVer.dwPlatformId == VER_PLATFORM_WIN32_NT);

    // even on an error, this is as good as it gets
    fIKnow = TRUE;

   return(fIsWinNT);
}


// make MBCS from Unicode string
//
// Include parameters specifying the length of the input wide character
// string and return number of bytes converted. An input length of -1 indicates
// null terminated.
//
// This extended version was added to handle REG_MULTI_SZ which contains
// multiple null terminated strings.
BOOL WINAPI I_MkMBStrEx(PBYTE pbBuff, DWORD cbBuff, LPCWSTR wsz, int cchW,
    char ** pszMB, int *pcbConverted) {

    int   cbConverted;

    // sfield: don't bring in crt for assert.  you get free assert via
    // an exception if these are null
//    assert(pszMB != NULL);
    *pszMB = NULL;
//    assert(pcbConverted != NULL);
    *pcbConverted = 0;
    if(wsz == NULL)
        return(TRUE);

    // how long is the mb string
    cbConverted = WideCharToMultiByte(  0,
                                        0,
                                        wsz,
                                        cchW,
                                        NULL,
                                        0,
                                        NULL,
                                        NULL);
    if (cbConverted <= 0)
        return(FALSE);

    // get a buffer long enough
    if(pbBuff != NULL  &&  (DWORD) cbConverted <= cbBuff)
        *pszMB = (char *) pbBuff;
    else
        *pszMB = (char *) I_MemAlloc(cbConverted);

    if(*pszMB == NULL) {
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }

    // now convert to MB
    *pcbConverted = WideCharToMultiByte(0,
                        0,
                        wsz,
                        cchW,
                        *pszMB,
                        cbConverted,
                        NULL,
                        NULL);
    return(TRUE);
}

// make MBCS from Unicode string
BOOL WINAPI I_MkMBStr(PBYTE pbBuff, DWORD cbBuff, LPCWSTR wsz, char ** pszMB) {
    int cbConverted;
    return I_MkMBStrEx(pbBuff, cbBuff, wsz, -1, pszMB, &cbConverted);
}

void WINAPI I_FreeMBStr(PBYTE pbBuff, char * szMB) {

    if((szMB != NULL) &&  (pbBuff != (PBYTE)szMB))
        I_MemFree(szMB);
}


//+=========================================================================
//  The following was taken from the following file:
//      \nt\ds\security\cryptoapi\common\unicode\file.cpp
//-=========================================================================

HANDLE WINAPI I_CreateFileU (
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    ) {

    BYTE rgb[_MAX_PATH];
    char *  szFileName;
    HANDLE  hFile;

    if(I_FIsWinNT())
        return( CreateFileW (
            lpFileName,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDisposition,
            dwFlagsAndAttributes,
            hTemplateFile
            ));

    hFile = INVALID_HANDLE_VALUE;
    if(I_MkMBStr(rgb, _MAX_PATH, lpFileName, &szFileName))
        hFile = CreateFileA (
            szFileName,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDisposition,
            dwFlagsAndAttributes,
            hTemplateFile
            );

    I_FreeMBStr(rgb, szFileName);

    return(hFile);
}

#else

#define I_CreateFileU             CreateFileW

#endif // _M_IX86



//+-------------------------------------------------------------------------
//  Maps the file into memory.
//
//  According to dwFileType, pvFile can be a pwszFilename, hFile or pFileBlob.
//  Only READ access is required.
//
//  dwFileType:
//      MINCRYPT_FILE_NAME      : pvFile - LPCWSTR pwszFilename
//      MINCRYPT_FILE_HANDLE    : pvFile - HANDLE hFile
//      MINCRYPT_FILE_BLOB      : pvFile - PCRYPT_DATA_BLOB pFileBlob
//
//  *pFileBlob is updated with pointer to and length of the mapped file. For
//  MINCRYPT_FILE_NAME and MINCRYPT_FILE_HANDLE, UnmapViewOfFile() must
//  be called to free pFileBlob->pbData.
//
//  All accesses to this mapped memory must be within __try / __except's.
//--------------------------------------------------------------------------
LONG
WINAPI
I_MinCryptMapFile(
    IN DWORD dwFileType,
    IN const VOID *pvFile,
    OUT PCRYPT_DATA_BLOB pFileBlob
    )
{
    LONG lErr = ERROR_SUCCESS;

    switch (dwFileType) {
        case MINCRYPT_FILE_NAME:
            {
                LPCWSTR pwszInFilename = (LPCWSTR) pvFile;
                HANDLE hFile;

                hFile = I_CreateFileU(
                    pwszInFilename,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,                   // lpsa
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL                    // hTemplateFile
                    );
                if (INVALID_HANDLE_VALUE == hFile)
                    goto CreateFileError;

                lErr = I_MinCryptMapFile(
                    MINCRYPT_FILE_HANDLE,
                    (const VOID *) hFile,
                    pFileBlob
                    );
                CloseHandle(hFile);
            }
            break;

        case MINCRYPT_FILE_HANDLE:
            {
                HANDLE hInFile = (HANDLE) pvFile;
                HANDLE hMappedFile;
                DWORD cbHighSize = 0;;
                DWORD cbLowSize;

                cbLowSize = GetFileSize(hInFile, &cbHighSize);
                if (INVALID_FILE_SIZE == cbLowSize)
                    goto GetFileSizeError;
                if (0 != cbHighSize)
                    goto Exceeded32BitFileSize;

                hMappedFile = CreateFileMappingA(
                    hInFile,
                    NULL,           // lpFileMappingAttributes,
                    PAGE_READONLY,
                    0,              // dwMaximumSizeHigh
                    0,              // dwMaximumSizeLow
                    NULL            // lpName
                    );
                if (NULL == hMappedFile)
                    goto CreateFileMappingError;

                pFileBlob->pbData = (BYTE *) MapViewOfFile(
                    hMappedFile,
                    FILE_MAP_READ,
                    0,              // dwFileOffsetHigh
                    0,              // dwFileOffsetLow
                    0               // dwNumberOfBytesToMap, 0 => entire file
                    );
                CloseHandle(hMappedFile);
                if (NULL == pFileBlob->pbData)
                    goto MapViewOfFileError;

                pFileBlob->cbData = cbLowSize;
            }
            break;

        case MINCRYPT_FILE_BLOB:
            {
                PCRYPT_DATA_BLOB pInFileBlob = (PCRYPT_DATA_BLOB) pvFile;
                *pFileBlob = *pInFileBlob;
            }
            break;

        default:
            goto InvalidParameter;
    }

CommonReturn:
    return lErr;

ErrorReturn:
    assert(ERROR_SUCCESS != lErr);
    pFileBlob->pbData = NULL;
    pFileBlob->cbData = 0;
    goto CommonReturn;

InvalidParameter:
    lErr = ERROR_INVALID_PARAMETER;
    goto ErrorReturn;

Exceeded32BitFileSize:
    lErr = ERROR_FILE_INVALID;
    goto ErrorReturn;

CreateFileError:
GetFileSizeError:
CreateFileMappingError:
MapViewOfFileError:
    lErr = GetLastError();
    if (ERROR_SUCCESS == lErr)
        lErr = ERROR_OPEN_FAILED;
    goto ErrorReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\mincrypt\inc\mincrypt.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       mincrypt.h
//
//  Contents:   Minimal Cryptographic API Prototypes and Definitions
//
//              Contains cryptographic functions to verify PKCS #7 Signed Data
//              messages, X.509 certificate chains, Authenticode signed
//              files and file hashes in system catalogs.
//
//              These APIs rely on the APIs defined in minasn1.h for doing
//              the low level ASN.1 parsing.
//
//              These APIs are implemented to be self contained and to
//              allow for code obfuscation. These APIs will be included
//              in such applications as, DRM or licensing verification.
//
//              If the file name or file handle option is selected,
//              the following APIs will need to call the kernel32.dll APIs
//              to open, map and unmap files:
//                  MinCryptHashFile
//                  MinCryptVerifySignedFile
//              The following API will need to call kernel32.dll and
//              wintrust.dll APIs to find, open, map and unmap files:
//                  MinCryptVerifyHashInSystemCatalogs
//              Except for the calls in the above APIs,
//              no calls to APIs in other DLLs.
//
//              Additionally, since these APIs have been pared down
//              from their wincrypt.h and crypt32.dll counterparts they are
//              a good candidate for applications with minimal memory and CPU
//              resources.
//
//  APIs: 
//              MinCryptDecodeHashAlgorithmIdentifier
//              MinCryptHashMemory
//              MinCryptVerifySignedHash
//              MinCryptVerifyCertificate
//              MinCryptVerifySignedData
//              MinCryptHashFile
//              MinCryptVerifySignedFile
//              MinCryptVerifyHashInSystemCatalogs
//
//----------------------------------------------------------------------------

#ifndef __MINCRYPT_H__
#define __MINCRYPT_H__


#if defined (_MSC_VER)

#if ( _MSC_VER >= 800 )
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)    /* Nameless struct/union */
#endif

#if (_MSC_VER > 1020)
#pragma once
#endif

#endif


#include <wincrypt.h>
#include <minasn1.h>

#ifdef __cplusplus
extern "C" {
#endif



#define MINCRYPT_MAX_HASH_LEN               20
#define MINCRYPT_SHA1_HASH_LEN              20
#define MINCRYPT_MD5_HASH_LEN               16
#define MINCRYPT_MD2_HASH_LEN               16


//+-------------------------------------------------------------------------
//  Decodes an ASN.1 encoded Algorithm Identifier and converts to
//  a CAPI Hash AlgID, such as, CALG_SHA1 or CALG_MD5.
//
//  Returns 0 if there isn't a CAPI AlgId corresponding to the Algorithm
//  Identifier.
//
//  Only CALG_SHA1, CALG_MD5 and CALG_MD2 are supported.
//--------------------------------------------------------------------------
ALG_ID
WINAPI
MinCryptDecodeHashAlgorithmIdentifier(
    IN PCRYPT_DER_BLOB pAlgIdValueBlob
    );

//+-------------------------------------------------------------------------
//  Hashes one or more memory blobs according to the Hash ALG_ID.
//
//  rgbHash is updated with the resultant hash. *pcbHash is updated with
//  the length associated with the hash algorithm.
//
//  If the function succeeds, the return value is ERROR_SUCCESS. Otherwise,
//  a nonzero error code is returned.
//
//  Only CALG_SHA1, CALG_MD5 and CALG_MD2 are supported.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptHashMemory(
    IN ALG_ID HashAlgId,
    IN DWORD cBlob,
    IN PCRYPT_DER_BLOB rgBlob,
    OUT BYTE rgbHash[MINCRYPT_MAX_HASH_LEN],
    OUT DWORD *pcbHash
    );


//+-------------------------------------------------------------------------
//  Verifies a signed hash.
//
//  The ASN.1 encoded Public Key Info is parsed and used to decrypt the
//  signed hash. The decrypted signed hash is compared with the input
//  hash.
//
//  If the signed hash was successfully verified, ERROR_SUCCESS is returned.
//  Otherwise, a nonzero error code is returned.
//
//  Only RSA signatures are supported.
//
//  Only MD2, MD5 and SHA1 hashes are supported.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptVerifySignedHash(
    IN ALG_ID HashAlgId,
    IN BYTE *pbHash,
    IN DWORD cbHash,
    IN PCRYPT_DER_BLOB pSignedHashContentBlob,
    IN PCRYPT_DER_BLOB pPubKeyInfoValueBlob
    );



//+-------------------------------------------------------------------------
//  Verifies a previously parsed X.509 Certificate.
//
//  Assumes the ASN.1 encoded X.509 certificate was parsed via
//  MinAsn1ParseCertificate() and the set of potential issuer certificates
//  were parsed via one or more of:
//   - MinAsn1ParseCertificate()
//   - MinAsn1ParseSignedDataCertificates()
//   - MinAsn1ExtractParsedCertificatesFromSignedData()
//
//  Iteratively finds the issuer certificate via its encoded name. The
//  public key in the issuer certificate is used to verify the subject
//  certificate's signature. This is repeated until finding a self signed
//  certificate or a baked in root identified by its encoded name.
//  For a self signed certificate, compares against the baked in root
//  public keys.
//
//  If the certificate and its issuers were successfully verified to a
//  baked in root, ERROR_SUCCESS is returned.  Otherwise, a nonzero error
//  code is returned.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptVerifyCertificate(
    IN CRYPT_DER_BLOB rgSubjectCertBlob[MINASN1_CERT_BLOB_CNT],
    IN DWORD cIssuerCert,
    IN CRYPT_DER_BLOB rgrgIssuerCertBlob[][MINASN1_CERT_BLOB_CNT]
    );



//+-------------------------------------------------------------------------
//  Function: MinCryptVerifySignedData
//
//  Verifies an ASN.1 encoded PKCS #7 Signed Data Message.
//
//  Assumes the PKCS #7 message is definite length encoded.
//  Assumes PKCS #7 version 1.5, ie, not the newer CMS version.
//  We only look at the first signer.
//
//  The Signed Data message is parsed. Its signature is verified. Its
//  signer certificate chain is verified to a baked in root public key.
//
//  If the Signed Data was successfully verified, ERROR_SUCCESS is returned.
//  Otherwise, a nonzero error code is returned.
//
//  Here are some interesting errors that can be returned:
//      CRYPT_E_BAD_MSG     - unable to ASN1 parse as a signed data message
//      ERROR_NO_DATA       - the content is empty
//      CRYPT_E_NO_SIGNER   - not signed or unable to find signer cert
//      CRYPT_E_UNKNOWN_ALGO- unknown MD5 or SHA1 ASN.1 algorithm identifier
//      CERT_E_UNTRUSTEDROOT- the signer chain's root wasn't baked in
//      CERT_E_CHAINING     - unable to build signer chain to a root
//      CRYPT_E_AUTH_ATTR_MISSING - missing digest authenticated attribute
//      CRYPT_E_HASH_VALUE  - content hash != authenticated digest attribute
//      NTE_BAD_ALGID       - unsupported hash or public key algorithm
//      NTE_BAD_PUBLIC_KEY  - not a valid RSA public key
//      NTE_BAD_SIGNATURE   - bad PKCS #7 or signer chain signature 
//
//  The rgVerSignedDataBlob[] is updated with pointer to and length of the
//  following fields in the encoded PKCS #7 message.
//--------------------------------------------------------------------------

// Content Object Identifier content bytes (OID)
#define MINCRYPT_VER_SIGNED_DATA_CONTENT_OID_IDX                    0

// Content data content bytes excluding "[0] EXPLICIT" tag
// (OPTIONAL MinAsn1ParseCTL, MinAsn1ParseIndirectData)
#define MINCRYPT_VER_SIGNED_DATA_CONTENT_DATA_IDX                   1

// Signer certificate's encoded bytes (MinAsn1ParseCertificate)
#define MINCRYPT_VER_SIGNED_DATA_SIGNER_CERT_IDX                    2

// Authenticated attributes value bytes including "[0] IMPLICIT" tag
// (OPTIONAL, MinAsn1ParseAttributes)
#define MINCRYPT_VER_SIGNED_DATA_AUTH_ATTRS_IDX                     3

// Unauthenticated attributes value bytes including "[1] IMPLICIT" tag
// (OPTIONAL, MinAsn1ParseAttributes)
#define MINCRYPT_VER_SIGNED_DATA_UNAUTH_ATTRS_IDX                   4

#define MINCRYPT_VER_SIGNED_DATA_BLOB_CNT                           5

LONG
WINAPI
MinCryptVerifySignedData(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT CRYPT_DER_BLOB rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_BLOB_CNT]
    );



//+-------------------------------------------------------------------------
//  File Type Definitions
//
//  Specifies the type of the "const VOID *pvFile" parameter
//--------------------------------------------------------------------------

// pvFile - LPCWSTR pwszFilename
#define MINCRYPT_FILE_NAME          1

// pvFile - HANDLE hFile
#define MINCRYPT_FILE_HANDLE        2

// pvFile - PCRYPT_DATA_BLOB pFileBlob
#define MINCRYPT_FILE_BLOB          3


//+-------------------------------------------------------------------------
//  Hashes the file according to the Hash ALG_ID.
//
//  According to dwFileType, pvFile can be a pwszFilename, hFile or pFileBlob.
//  Only requires READ access.
//
//  dwFileType:
//      MINCRYPT_FILE_NAME      : pvFile - LPCWSTR pwszFilename
//      MINCRYPT_FILE_HANDLE    : pvFile - HANDLE hFile
//      MINCRYPT_FILE_BLOB      : pvFile - PCRYPT_DATA_BLOB pFileBlob
//
//  rgbHash is updated with the resultant hash. *pcbHash is updated with
//  the length associated with the hash algorithm.
//
//  If the function succeeds, the return value is ERROR_SUCCESS. Otherwise,
//  a nonzero error code is returned.
//
//  Only CALG_SHA1 and CALG_MD5 are supported.
//
//  If a NT PE 32 bit file format, hashed according to imagehlp rules, ie, skip
//  section containing potential signature, ... . Otherwise, the entire file
//  is hashed.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptHashFile(
    IN DWORD dwFileType,
    IN const VOID *pvFile,
    IN ALG_ID HashAlgId,
    OUT BYTE rgbHash[MINCRYPT_MAX_HASH_LEN],
    OUT DWORD *pcbHash
    );


//+-------------------------------------------------------------------------
//  Verifies a previously signed file.
//
//  According to dwFileType, pvFile can be a pwszFilename, hFile or pFileBlob.
//  Only requires READ access.
//
//  dwFileType:
//      MINCRYPT_FILE_NAME      : pvFile - LPCWSTR pwszFilename
//      MINCRYPT_FILE_HANDLE    : pvFile - HANDLE hFile
//      MINCRYPT_FILE_BLOB      : pvFile - PCRYPT_DATA_BLOB pFileBlob
//
//  Checks if the file has an embedded PKCS #7 Signed Data message containing
//  Indirect Data. The PKCS #7 is verified via MinCryptVerifySignedData().
//  The Indirect Data is parsed via MinAsn1ParseIndirectData() to get the
//  HashAlgId and the file hash.  MinCryptHashFile() is called to hash the
//  file. The returned hash is compared against the Indirect Data's hash.
//
//  The caller can request one or more signer authenticated attribute values
//  to be returned. The still encoded values are returned in the
//  caller allocated memory. The beginning of this returned memory will
//  be set to an array of attribute value blobs pointing to these
//  encoded values (CRYPT_DER_BLOB rgAttrBlob[cAttrOID]).
//  For performance reasons, the caller should make every attempt to allow
//  for a single pass call. The necessary memory size is:
//      (cAttrOID * sizeof(CRYPT_DER_BLOB)) +
//          total length of encoded attribute values.
//
//  *pcbAttr will be updated with the number of bytes required to contain
//  the attribute blobs and values. If the input memory is insufficient,
//  ERROR_INSUFFICIENT_BUFFER will be returned if no other error.
//
//  For a multi-valued attribute, only the first value is returned.
//
//  If the function succeeds, the return value is ERROR_SUCCESS. Otherwise,
//  a nonzero error code is returned.
//
//  Only NT, PE 32 bit file formats are supported.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptVerifySignedFile(
    IN DWORD dwFileType,
    IN const VOID *pvFile,

    IN OPTIONAL DWORD cAttrOID,
    IN OPTIONAL CRYPT_DER_BLOB rgAttrEncodedOIDBlob[],
    // CRYPT_DER_BLOB rgAttrBlob[cAttrOID] header is at beginning
    // with the bytes pointed to immediately following
    OUT OPTIONAL CRYPT_DER_BLOB *rgAttrValueBlob,
    IN OUT OPTIONAL DWORD *pcbAttr
    );

//+-------------------------------------------------------------------------
//  Verifies the hashes in the system catalogs.
//
//  Iterates through the hashes and attempts to find the system catalog
//  containing it. If found, the system catalog file is verified as a
//  PKCS #7 Signed Data message with its signer cert verified up to a baked
//  in root.
//
//  The following mscat32.dll APIs are called to find the system catalog file:
//      CryptCATAdminAcquireContext
//      CryptCATAdminReleaseContext
//      CryptCATAdminEnumCatalogFromHash
//      CryptCATAdminReleaseCatalogContext
//      CryptCATCatalogInfoFromContext
//
//  If the hash was successfully verified, rglErr[] is set to ERROR_SUCCESS.
//  Otherwise, rglErr[] is set to a nonzero error code.
//
//  The caller can request one or more catalog subject attribute,
//  extension or signer authenticated attribute values to be returned for
//  each hash.  The still encoded values are returned in the
//  caller allocated memory. The beginning of this returned memory will
//  be set to a 2 dimensional array of attribute value blobs pointing to these
//  encoded values (CRYPT_DER_BLOB rgrgAttrValueBlob[cHash][cAttrOID]).
//  For performance reasons, the caller should make every attempt to allow
//  for a single pass call. The necessary memory size is:
//      (cHash * cAttrOID * sizeof(CRYPT_DER_BLOB)) +
//          total length of encoded attribute values.
//
//  *pcbAttr will be updated with the number of bytes required to contain
//  the attribute blobs and values. If the input memory is insufficient,
//  ERROR_INSUFFICIENT_BUFFER will be returned if no other error.
//
//  For a multi-valued attribute, only the first value is returned.
//
//  If the function succeeds, the return value is ERROR_SUCCESS. This may
//  be returned for unsuccessful rglErr[] values. Otherwise,
//  a nonzero error code is returned.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptVerifyHashInSystemCatalogs(
    IN ALG_ID HashAlgId,
    IN DWORD cHash,
    IN CRYPT_HASH_BLOB rgHashBlob[],
    OUT LONG rglErr[],

    IN OPTIONAL DWORD cAttrOID,
    IN OPTIONAL CRYPT_DER_BLOB rgAttrEncodedOIDBlob[],
    // CRYPT_DER_BLOB rgrgAttrValueBlob[cHash][cAttrOID] header is at beginning
    // with the bytes pointed to immediately following
    OUT OPTIONAL CRYPT_DER_BLOB *rgrgAttrValueBlob,
    IN OUT OPTIONAL DWORD *pcbAttr
    );
    



#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#if defined (_MSC_VER)
#if ( _MSC_VER >= 800 )

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif

#endif
#endif

#endif // __MINCRYPT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\mincrypt\lib\asn1parse.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       asn1parse.cpp
//
//  Contents:   Minimal ASN.1 parse functions.
//
//  Functions:  MinAsn1ParseCertificate
//              MinAsn1ParseAlgorithmIdentifier
//              MinAsn1ParsePublicKeyInfo
//              MinAsn1ParseRSAPublicKey
//              MinAsn1ParseExtensions
//              MinAsn1ParseSignedData
//              MinAsn1ParseSignedDataCertificates
//              MinAsn1ParseAttributes
//              MinAsn1ParseCTL
//              MinAsn1ParseCTLSubject
//              MinAsn1ParseIndirectData
//
//  History:    15-Jan-01    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"

const BYTE rgbSeqTag[] = {MINASN1_TAG_SEQ, 0};
const BYTE rgbSetTag[] = {MINASN1_TAG_SET, 0};
const BYTE rgbOIDTag[] = {MINASN1_TAG_OID, 0};
const BYTE rgbIntegerTag[] = {MINASN1_TAG_INTEGER, 0};
const BYTE rgbBooleanTag[] = {MINASN1_TAG_BOOLEAN, 0};
const BYTE rgbBitStringTag[] = {MINASN1_TAG_BITSTRING, 0};
const BYTE rgbOctetStringTag[] = {MINASN1_TAG_OCTETSTRING, 0};
const BYTE rgbConstructedContext0Tag[] =
    {MINASN1_TAG_CONSTRUCTED_CONTEXT_0, 0};
const BYTE rgbConstructedContext1Tag[] =
    {MINASN1_TAG_CONSTRUCTED_CONTEXT_1, 0};
const BYTE rgbConstructedContext3Tag[] =
    {MINASN1_TAG_CONSTRUCTED_CONTEXT_3, 0};
const BYTE rgbContext1Tag[] = {MINASN1_TAG_CONTEXT_1, 0};
const BYTE rgbContext2Tag[] = {MINASN1_TAG_CONTEXT_2, 0};
const BYTE rgbChoiceOfTimeTag[] =
    {MINASN1_TAG_UTC_TIME, MINASN1_TAG_GENERALIZED_TIME, 0};


const MINASN1_EXTRACT_VALUE_PARA rgParseCertPara[] = {
    // 0 - SignedContent ::= SEQUENCE {
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_INTO_VALUE_OP, 
        MINASN1_CERT_ENCODED_IDX, rgbSeqTag,

    // 0.1 - toBeSigned ::== SEQUENCE {
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_INTO_VALUE_OP,
        MINASN1_CERT_TO_BE_SIGNED_IDX, rgbSeqTag,

    // 0.1.0 - version                 [0] EXPLICIT CertificateVersion DEFAULT v1,
    MINASN1_OPTIONAL_STEP_INTO_VALUE_OP, 0, rgbConstructedContext0Tag,

    // 0.1.0.0 - version number (INTEGER)
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_CERT_VERSION_IDX, rgbIntegerTag,
    // 0.1.0.1
    MINASN1_STEP_OUT_VALUE_OP, 0, NULL,

    // 0.1.1 - serialNumber            CertificateSerialNumber,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_CERT_SERIAL_NUMBER_IDX, rgbIntegerTag,
    // 0.1.2 - signature               AlgorithmIdentifier,
    MINASN1_STEP_OVER_VALUE_OP, 0, rgbSeqTag,
    // 0.1.3 - issuer                  NOCOPYANY, -- really Name
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_CERT_ISSUER_IDX, rgbSeqTag,
    // 0.1.4 - validity                Validity,
    MINASN1_STEP_INTO_VALUE_OP, 0, rgbSeqTag,

    // 0.1.4.0 - notBefore           ChoiceOfTime,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_CERT_NOT_BEFORE_IDX, rgbChoiceOfTimeTag,
    // 0.1.4.1 - notAfter            ChoiceOfTime,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_CERT_NOT_AFTER_IDX, rgbChoiceOfTimeTag,
    // 0.1.4.2
    MINASN1_STEP_OUT_VALUE_OP, 0, NULL,

    // 0.1.5 - subject                 NOCOPYANY, -- really Name
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_CERT_SUBJECT_IDX, rgbSeqTag,
    // 0.1.6 - subjectPublicKeyInfo    SubjectPublicKeyInfo,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_CERT_PUBKEY_INFO_IDX, rgbSeqTag,
    // 0.1.7 - issuerUniqueIdentifier  [1] IMPLICIT BITSTRING OPTIONAL,
    // Note, advanced past the unused bits octet
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_CERT_ISSUER_UNIQUE_ID_IDX, rgbContext1Tag,
    // 0.1.8 - subjectUniqueIdentifier [2] IMPLICIT BITSTRING OPTIONAL,
    // Note, advanced past the unused bits octet
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_CERT_SUBJECT_UNIQUE_ID_IDX, rgbContext2Tag,
    // 0.1.9 - extensions              [3] EXPLICIT Extensions OPTIONAL
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_CERT_EXTS_IDX, rgbConstructedContext3Tag,

    // 0.1.10
    MINASN1_STEP_OUT_VALUE_OP, 0, NULL,

    // 0.2 - signatureAlgorithm  AlgorithmIdentifier,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_CERT_SIGN_ALGID_IDX, rgbSeqTag,
    // 0.3 - signature           BITSTRING
    // Note, advanced past the unused bits octet
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_CERT_SIGNATURE_IDX, rgbBitStringTag,
};
#define PARSE_CERT_PARA_CNT         \
    (sizeof(rgParseCertPara) / sizeof(rgParseCertPara[0]))

//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseCertificate
//
//  Parses an ASN.1 encoded X.509 certificate.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded certificate
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  All BITSTRING fields have been advanced past the unused count octet.
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ParseCertificate(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT CRYPT_DER_BLOB rgCertBlob[MINASN1_CERT_BLOB_CNT]
    )
{

    LONG lSkipped;
    DWORD cValuePara = PARSE_CERT_PARA_CNT;

    lSkipped = MinAsn1ExtractValues(
        pbEncoded,
        cbEncoded,
        &cValuePara,
        rgParseCertPara,
        MINASN1_CERT_BLOB_CNT,
        rgCertBlob
        );

    if (0 < lSkipped) {
        lSkipped = rgCertBlob[MINASN1_CERT_ENCODED_IDX].cbData;

        // If present, fixup the ISSUER_UNIQUE_ID and SUBJECT_UNIQUE_ID bit
        // fields to advance past the first contents octet containing the
        // number of unused bits
        if (0 != rgCertBlob[MINASN1_CERT_ISSUER_UNIQUE_ID_IDX].cbData) {
            rgCertBlob[MINASN1_CERT_ISSUER_UNIQUE_ID_IDX].pbData += 1;
            rgCertBlob[MINASN1_CERT_ISSUER_UNIQUE_ID_IDX].cbData -= 1;
        }

        if (0 != rgCertBlob[MINASN1_CERT_SUBJECT_UNIQUE_ID_IDX].cbData) {
            rgCertBlob[MINASN1_CERT_SUBJECT_UNIQUE_ID_IDX].pbData += 1;
            rgCertBlob[MINASN1_CERT_SUBJECT_UNIQUE_ID_IDX].cbData -= 1;
        }
    }

    return lSkipped;
}

const MINASN1_EXTRACT_VALUE_PARA rgParseAlgIdPara[] = {
    // 0 - AlgorithmIdentifier    ::=    SEQUENCE {
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_INTO_VALUE_OP, 
        MINASN1_ALGID_ENCODED_IDX, rgbSeqTag,

    // 0.0 - algorithm  ObjectID,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_ALGID_OID_IDX, rgbOIDTag,
    // 0.1 parameters ANY OPTIONAL
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_ALGID_PARA_IDX, NULL,
};
#define PARSE_ALGID_PARA_CNT        \
    (sizeof(rgParseAlgIdPara) / sizeof(rgParseAlgIdPara[0]))

//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseAlgorithmIdentifier
//
//  Parses an ASN.1 encoded Algorithm Identifier contained in numerous
//  other ASN.1 structures, such as, X.509 certificate and PKCS #7 Signed Data
//  message.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded algorithm
//                        identifier
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ParseAlgorithmIdentifier(
    IN PCRYPT_DER_BLOB pAlgIdValueBlob,
    OUT CRYPT_DER_BLOB rgAlgIdBlob[MINASN1_ALGID_BLOB_CNT]
    )
{

    LONG lSkipped;
    DWORD cValuePara = PARSE_ALGID_PARA_CNT;

    lSkipped = MinAsn1ExtractValues(
        pAlgIdValueBlob->pbData,
        pAlgIdValueBlob->cbData,
        &cValuePara,
        rgParseAlgIdPara,
        MINASN1_ALGID_BLOB_CNT,
        rgAlgIdBlob
        );

    if (0 < lSkipped)
        lSkipped = rgAlgIdBlob[MINASN1_ALGID_ENCODED_IDX].cbData;

    return lSkipped;
}



const MINASN1_EXTRACT_VALUE_PARA rgParsePubKeyInfoPara[] = {
    // 0 - PublicKeyInfo ::= SEQUENCE {
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_INTO_VALUE_OP, 
        MINASN1_PUBKEY_INFO_ENCODED_IDX, rgbSeqTag,

    // 0.0 - algorithm  AlgorithmIdentifier,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_PUBKEY_INFO_ALGID_IDX, rgbSeqTag,

    // 0.1 - PublicKey  BITSTRING
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_PUBKEY_INFO_PUBKEY_IDX, rgbBitStringTag,
};
#define PARSE_PUBKEY_INFO_PARA_CNT      \
    (sizeof(rgParsePubKeyInfoPara) / sizeof(rgParsePubKeyInfoPara[0]))

//+-------------------------------------------------------------------------
//  Function: MinAsn1ParsePublicKeyInfo
//
//  Parses an ASN.1 encoded Public Key Info structure contained in an
//  X.509 certificate
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded public key
//                        info
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  All BITSTRING fields have been advanced past the unused count octet.
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ParsePublicKeyInfo(
    IN PCRYPT_DER_BLOB pPubKeyInfoValueBlob,
    CRYPT_DER_BLOB rgPubKeyInfoBlob[MINASN1_PUBKEY_INFO_BLOB_CNT]
    )
{

    LONG lSkipped;
    DWORD cValuePara = PARSE_PUBKEY_INFO_PARA_CNT;

    lSkipped = MinAsn1ExtractValues(
        pPubKeyInfoValueBlob->pbData,
        pPubKeyInfoValueBlob->cbData,
        &cValuePara,
        rgParsePubKeyInfoPara,
        MINASN1_PUBKEY_INFO_BLOB_CNT,
        rgPubKeyInfoBlob
        );

    if (0 < lSkipped)
        lSkipped = rgPubKeyInfoBlob[MINASN1_PUBKEY_INFO_ENCODED_IDX].cbData;

    return lSkipped;
}



const MINASN1_EXTRACT_VALUE_PARA rgParseRSAPubKeyPara[] = {
    // 0 - RSAPublicKey ::= SEQUENCE {
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_INTO_VALUE_OP, 
        MINASN1_RSA_PUBKEY_ENCODED_IDX, rgbSeqTag,

    // 0.0 - modulus         HUGEINTEGER,    -- n
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_RSA_PUBKEY_MODULUS_IDX, rgbIntegerTag,
    // 0.1 - publicExponent  INTEGER (0..4294967295)         -- e
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_RSA_PUBKEY_EXPONENT_IDX, rgbIntegerTag,
};
#define PARSE_RSA_PUBKEY_PARA_CNT       \
    (sizeof(rgParseRSAPubKeyPara) / sizeof(rgParseRSAPubKeyPara[0]))

//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseRSAPublicKey
//
//  Parses an ASN.1 encoded RSA PKCS #1 Public Key contained in the contents of
//  Public Key BITSTRING in a X.509 certificate.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded RSA public key
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ParseRSAPublicKey(
    IN PCRYPT_DER_BLOB pPubKeyContentBlob,
    CRYPT_DER_BLOB rgRSAPubKeyBlob[MINASN1_RSA_PUBKEY_BLOB_CNT]
    )
{

    LONG lSkipped;
    DWORD cValuePara = PARSE_RSA_PUBKEY_PARA_CNT;

    lSkipped = MinAsn1ExtractValues(
        pPubKeyContentBlob->pbData,
        pPubKeyContentBlob->cbData,
        &cValuePara,
        rgParseRSAPubKeyPara,
        MINASN1_RSA_PUBKEY_BLOB_CNT,
        rgRSAPubKeyBlob
        );

    if (0 < lSkipped)
        lSkipped = rgRSAPubKeyBlob[MINASN1_RSA_PUBKEY_ENCODED_IDX].cbData;

    return lSkipped;
}


const MINASN1_EXTRACT_VALUE_PARA rgParseExtPara[] = {
    // 0 - Extension ::= SEQUENCE {
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_INTO_VALUE_OP, 
        MINASN1_EXT_ENCODED_IDX, rgbSeqTag,

    // 0.0 - extnId              EncodedObjectID,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_EXT_OID_IDX, rgbOIDTag,
    // 0.1 - critical            BOOLEAN DEFAULT FALSE,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_EXT_CRITICAL_IDX, rgbBooleanTag,
    // 0.2 - extnValue           OCTETSTRING
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_EXT_VALUE_IDX, rgbOctetStringTag,
};

#define PARSE_EXT_PARA_CNT          \
    (sizeof(rgParseExtPara) / sizeof(rgParseExtPara[0]))

//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseExtensions
//
//  Parses an ASN.1 encoded sequence of extensions contained in 
//  other ASN.1 structures, such as, X.509 certificate and CTL.
//
//  Upon input, *pcExt contains the maximum number of parsed extensions
//  that can be returned. Updated with the number of extensions processed.
//
//  Returns:
//      success - >= 0 => bytes skipped, length of the encoded extensions
//                        processed. If all extensions were processed,
//                        bytes skipped = pExtsValueBlob->cbData.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ParseExtensions(
    IN PCRYPT_DER_BLOB pExtsValueBlob,  // Extensions ::= SEQUENCE OF Extension
    IN OUT DWORD *pcExt,
    OUT CRYPT_DER_BLOB rgrgExtBlob[][MINASN1_EXT_BLOB_CNT]
    )
{
    const BYTE *pbEncoded = (const BYTE *) pExtsValueBlob->pbData;
    DWORD cbEncoded = pExtsValueBlob->cbData;
    DWORD cExt = *pcExt;
    DWORD iExt = 0;
    LONG lAllExts = 0;

    const BYTE *pb;
    DWORD cb;

    if (0 == cbEncoded)
        // No extensions
        goto CommonReturn;

    // Step into the SEQUENCE
    if (0 >= MinAsn1ExtractContent(
            pbEncoded,
            cbEncoded,
            &cb,
            &pb
            )) {
        lAllExts = -1;
        goto CommonReturn;
    }

    for (iExt = 0; 0 < cb && iExt < cExt; iExt++) {
        LONG lExt;
        DWORD cbExt;
        DWORD cValuePara = PARSE_EXT_PARA_CNT;

        lExt = MinAsn1ExtractValues(
            pb,
            cb,
            &cValuePara,
            rgParseExtPara,
            MINASN1_EXT_BLOB_CNT,
            rgrgExtBlob[iExt]
            );

        if (0 >= lExt) {
            if (0 == lExt)
                lExt = -1;
            lAllExts = -((LONG)(pb - pbEncoded)) + lExt;
            goto CommonReturn;
        }

        cbExt = rgrgExtBlob[iExt][MINASN1_EXT_ENCODED_IDX].cbData;
        pb += cbExt;
        cb -= cbExt;
    }

    lAllExts = (LONG)(pb - pbEncoded);
    assert((DWORD) lAllExts <= cbEncoded);

CommonReturn:
    *pcExt = iExt;
    return lAllExts;
}


const MINASN1_EXTRACT_VALUE_PARA rgParseSignedDataPara[] = {
    // 0 - ContentInfo ::= SEQUENCE {
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_INTO_VALUE_OP, 
        MINASN1_SIGNED_DATA_ENCODED_IDX, rgbSeqTag,

    // 0.0 - contentType ContentType,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_OUTER_OID_IDX, rgbOIDTag,
    // 0.1 - content  [0] EXPLICIT ANY -- OPTIONAL
    MINASN1_STEP_INTO_VALUE_OP, 0, rgbConstructedContext0Tag,

    // 0.1.0 - SignedData ::= SEQUENCE {
    MINASN1_STEP_INTO_VALUE_OP, 0, rgbSeqTag,

    // 0.1.0.0 - version             INTEGER,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_VERSION_IDX, rgbIntegerTag,
    // 0.1.0.1 - digestAlgorithms    DigestAlgorithmIdentifiers,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_DIGEST_ALGIDS_IDX, rgbSetTag,
    // 0.1.0.2 - ContentInfo ::= SEQUENCE {
    MINASN1_STEP_INTO_VALUE_OP, 0, rgbSeqTag,

    // 0.1.0.2.0 - contentType ContentType,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_CONTENT_OID_IDX, rgbOIDTag,
    // 0.1.0.2.1 - content  [0] EXPLICIT ANY -- OPTIONAL
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_CONTENT_DATA_IDX, rgbConstructedContext0Tag,
    // 0.1.0.2.2
    MINASN1_STEP_OUT_VALUE_OP, 0, NULL,

    // 0.1.0.3 - certificates        [0] IMPLICIT Certificates OPTIONAL,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_CERTS_IDX, rgbConstructedContext0Tag,
    // 0.1.0.4 - crls                [1] IMPLICIT CertificateRevocationLists OPTIONAL,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_CRLS_IDX, rgbConstructedContext1Tag,
    // 0.1.0.5 - signerInfos :: = SET OF
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_INTO_VALUE_OP,
        MINASN1_SIGNED_DATA_SIGNER_INFOS_IDX, rgbSetTag,

    // 0.1.0.5.0 - SignerInfo ::= SEQUENCE {
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_OPTIONAL_STEP_INTO_VALUE_OP,
        MINASN1_SIGNED_DATA_SIGNER_INFO_ENCODED_IDX, rgbSeqTag,

    // 0.1.0.5.0.0 - version                     INTEGER,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_SIGNER_INFO_VERSION_IDX, rgbIntegerTag,
    // 0.1.0.5.0.1 - issuerAndSerialNumber       IssuerAndSerialNumber
    MINASN1_STEP_INTO_VALUE_OP, 0, rgbSeqTag,

    // 0.1.0.5.0.1.0 - issuer          ANY,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_SIGNER_INFO_ISSUER_IDX, rgbSeqTag,
    // 0.1.0.5.0.1.1 - serialNumber    INTEGER
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_SIGNER_INFO_SERIAL_NUMBER_IDX, rgbIntegerTag,
    // 0.1.0.5.0.1.2
    MINASN1_STEP_OUT_VALUE_OP, 0, NULL,

    // 0.1.0.5.0.2 - digestAlgorithm             DigestAlgorithmIdentifier,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_SIGNER_INFO_DIGEST_ALGID_IDX, rgbSeqTag,
    // 0.1.0.5.0.3 - authenticatedAttributes     [0] IMPLICIT Attributes OPTIONAL,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_SIGNER_INFO_AUTH_ATTRS_IDX, rgbConstructedContext0Tag,
    // 0.1.0.5.0.4 - digestEncryptionAlgorithm   DigestEncryptionAlgId,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_SIGNER_INFO_ENCRYPT_DIGEST_ALGID_IDX, rgbSeqTag,
    // 0.1.0.5.0.5 - encryptedDigest             EncryptedDigest,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_SIGNER_INFO_ENCYRPT_DIGEST_IDX, rgbOctetStringTag,
    // 0.1.0.5.0.6 - unauthenticatedAttributes   [1] IMPLICIT Attributes OPTIONAL
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_SIGNER_INFO_UNAUTH_ATTRS_IDX, rgbConstructedContext1Tag,
};
#define PARSE_SIGNED_DATA_PARA_CNT      \
    (sizeof(rgParseSignedDataPara) / sizeof(rgParseSignedDataPara[0]))


//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseSignedData
//
//  Parses an ASN.1 encoded PKCS #7 Signed Data Message. Assumes the
//  PKCS #7 message is definite length encoded. Assumes PKCS #7 version
//  1.5, ie, not the newer CMS version.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded message
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ParseSignedData(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT CRYPT_DER_BLOB rgSignedDataBlob[MINASN1_SIGNED_DATA_BLOB_CNT]
    )
{

    LONG lSkipped;
    DWORD cValuePara = PARSE_SIGNED_DATA_PARA_CNT;

    lSkipped = MinAsn1ExtractValues(
        pbEncoded,
        cbEncoded,
        &cValuePara,
        rgParseSignedDataPara,
        MINASN1_SIGNED_DATA_BLOB_CNT,
        rgSignedDataBlob
        );

    if (0 < lSkipped)
        lSkipped = rgSignedDataBlob[MINASN1_SIGNED_DATA_ENCODED_IDX].cbData;

    return lSkipped;
}


//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseSignedDataCertificates
//
//  Parses an ASN.1 encoded set of certificates contained in 
//  a Signed Data message.
//
//  Upon input, *pcCert contains the maximum number of parsed certificates
//  that can be returned. Updated with the number of certificates processed.
//
//  Returns:
//      success - >= 0 => bytes skipped, length of the encoded certificates
//                        processed. If all certificates were processed,
//                        bytes skipped = pCertsValueBlob->cbData.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgrgCertBlob[][] is updated with pointer to and length of the
//  fields in the encoded certificate. See MinAsn1ParseCertificate for the
//  field definitions.
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ParseSignedDataCertificates(
    IN PCRYPT_DER_BLOB pCertsValueBlob,
    IN OUT DWORD *pcCert,
    OUT CRYPT_DER_BLOB rgrgCertBlob[][MINASN1_CERT_BLOB_CNT]
    )
{
    const BYTE *pbEncoded = (const BYTE *) pCertsValueBlob->pbData;
    DWORD cbEncoded = pCertsValueBlob->cbData;
    DWORD cCert = *pcCert;
    DWORD iCert = 0;
    LONG lAllCerts = 0;

    const BYTE *pb;
    DWORD cb;

    if (0 == cbEncoded)
        // No certificates
        goto CommonReturn;

    // Skip outer tag and length
    if (0 >= MinAsn1ExtractContent(
            pbEncoded,
            cbEncoded,
            &cb,
            &pb
            )) {
        lAllCerts = -1;
        goto CommonReturn;
    }

    for (iCert = 0; 0 < cb && iCert < cCert; iCert++) {
        LONG lCert;

        lCert = MinAsn1ParseCertificate(
            pb,
            cb,
            rgrgCertBlob[iCert]
            );

        if (0 >= lCert) {
            if (0 == lCert)
                lCert = -1;
            lAllCerts = -((LONG)(pb - pbEncoded)) + lCert;
            goto CommonReturn;
        }

        pb += lCert;
        cb -= lCert;
    }

    lAllCerts = (LONG)(pb - pbEncoded);
    assert((DWORD) lAllCerts <= cbEncoded);

CommonReturn:
    *pcCert = iCert;
    return lAllCerts;
}


const MINASN1_EXTRACT_VALUE_PARA rgParseAttrPara[] = {
    // 0 - Attribute ::= SEQUENCE {
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_INTO_VALUE_OP, 
        MINASN1_ATTR_ENCODED_IDX, rgbSeqTag,

    // 0.0 - attributeType       ObjectID,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_ATTR_OID_IDX, rgbOIDTag,
    // 0.1 - attributeValue      SET OF
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_INTO_VALUE_OP,
        MINASN1_ATTR_VALUES_IDX, rgbSetTag,

    // 0.1.0 - Value        ANY -- OPTIONAL
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_ATTR_VALUE_IDX, NULL,
};
#define PARSE_ATTR_PARA_CNT         \
    (sizeof(rgParseAttrPara) / sizeof(rgParseAttrPara[0]))

//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseAttributes
//
//  Parses an ASN.1 encoded sequence of attributes contained in 
//  other ASN.1 structures, such as, Signer Info authenticated or
//  unauthenticated attributes.
//
//  The outer tag is ignored. It can be a SET, [0] IMPLICIT, or [1] IMPLICIT.
//
//  Upon input, *pcAttr contains the maximum number of parsed attributes
//  that can be returned. Updated with the number of attributes processed.
//
//  Returns:
//      success - >= 0 => bytes skipped, length of the encoded attributes
//                        processed. If all attributes were processed,
//                        bytes skipped = pAttrsValueBlob->cbData.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ParseAttributes(
    IN PCRYPT_DER_BLOB pAttrsValueBlob,
    IN OUT DWORD *pcAttr,
    OUT CRYPT_DER_BLOB rgrgAttrBlob[][MINASN1_ATTR_BLOB_CNT]
    )
{
    const BYTE *pbEncoded = (const BYTE *) pAttrsValueBlob->pbData;
    DWORD cbEncoded = pAttrsValueBlob->cbData;
    DWORD cAttr = *pcAttr;
    DWORD iAttr = 0;
    LONG lAllAttrs = 0;

    const BYTE *pb;
    DWORD cb;

    if (0 == cbEncoded)
        // No attributes
        goto CommonReturn;

    // Skip the outer tag and length
    if (0 >= MinAsn1ExtractContent(
            pbEncoded,
            cbEncoded,
            &cb,
            &pb
            )) {
        lAllAttrs = -1;
        goto CommonReturn;
    }

    for (iAttr = 0; 0 < cb && iAttr < cAttr; iAttr++) {
        LONG lAttr;
        DWORD cbAttr;
        DWORD cValuePara = PARSE_ATTR_PARA_CNT;

        lAttr = MinAsn1ExtractValues(
            pb,
            cb,
            &cValuePara,
            rgParseAttrPara,
            MINASN1_ATTR_BLOB_CNT,
            rgrgAttrBlob[iAttr]
            );

        if (0 >= lAttr) {
            if (0 == lAttr)
                lAttr = -1;
            lAllAttrs = -((LONG)(pb - pbEncoded)) + lAttr;
            goto CommonReturn;
        }

        cbAttr = rgrgAttrBlob[iAttr][MINASN1_ATTR_ENCODED_IDX].cbData;
        pb += cbAttr;
        cb -= cbAttr;
    }

    lAllAttrs = (LONG)(pb - pbEncoded);
    assert((DWORD) lAllAttrs <= cbEncoded);

CommonReturn:
    *pcAttr = iAttr;
    return lAllAttrs;
}



const MINASN1_EXTRACT_VALUE_PARA rgParseCTLPara[] = {
    // 0 - CertificateTrustList ::= SEQUENCE {
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_INTO_VALUE_OP, 
        MINASN1_CTL_ENCODED_IDX, rgbSeqTag,

    // 0.0 - version                 CTLVersion DEFAULT v1,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_CTL_VERSION_IDX, rgbIntegerTag,
    // 0.1 - subjectUsage            SubjectUsage,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_CTL_SUBJECT_USAGE_IDX, rgbSeqTag,
    // 0.2 - listIdentifier          ListIdentifier OPTIONAL,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_CTL_LIST_ID_IDX, rgbOctetStringTag,
    // 0.3 - sequenceNumber          HUGEINTEGER OPTIONAL,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_CTL_SEQUENCE_NUMBER_IDX, rgbIntegerTag,
    // 0.4 - ctlThisUpdate           ChoiceOfTime,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_CTL_THIS_UPDATE_IDX, rgbChoiceOfTimeTag,
    // 0.5 - ctlNextUpdate           ChoiceOfTime OPTIONAL,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_CTL_NEXT_UPDATE_IDX, rgbChoiceOfTimeTag,
    // 0.6 - subjectAlgorithm        AlgorithmIdentifier,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_CTL_SUBJECT_ALGID_IDX, rgbSeqTag,
    // 0.7 - trustedSubjects         TrustedSubjects OPTIONAL,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_CTL_SUBJECTS_IDX, rgbSeqTag,
    // 0.8 - ctlExtensions           [0] EXPLICIT Extensions OPTIONAL
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_CTL_EXTS_IDX, rgbConstructedContext0Tag,
};
#define PARSE_CTL_PARA_CNT          \
    (sizeof(rgParseCTLPara) / sizeof(rgParseCTLPara[0]))

//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseCTL
//
//  Parses an ASN.1 encoded Certificate Trust List (CTL). A CTL is always
//  contained as the inner content data in a PKCS #7 Signed Data. A CTL has
//  the following OID: "1.3.6.1.4.1.311.10.1".
//
//  A catalog file is formatted as a PKCS #7 Signed CTL.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded CTL
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ParseCTL(
    IN PCRYPT_DER_BLOB pEncodedContentBlob,
    OUT CRYPT_DER_BLOB rgCTLBlob[MINASN1_CTL_BLOB_CNT]
    )
{

    LONG lSkipped;
    DWORD cValuePara = PARSE_CTL_PARA_CNT;

    lSkipped = MinAsn1ExtractValues(
        pEncodedContentBlob->pbData,
        pEncodedContentBlob->cbData,
        &cValuePara,
        rgParseCTLPara,
        MINASN1_CTL_BLOB_CNT,
        rgCTLBlob
        );

    if (0 < lSkipped)
        lSkipped = rgCTLBlob[MINASN1_CTL_ENCODED_IDX].cbData;

    return lSkipped;
}


const MINASN1_EXTRACT_VALUE_PARA rgParseCTLSubjectPara[] = {
    // 0 - TrustedSubject ::= SEQUENCE {
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_INTO_VALUE_OP, 
        MINASN1_CTL_SUBJECT_ENCODED_IDX, rgbSeqTag,

    // 0.0 - subjectIdentifier       SubjectIdentifier,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_CTL_SUBJECT_ID_IDX, rgbOctetStringTag,
    // 0.1 - subjectAttributes	    Attributes OPTIONAL
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_CTL_SUBJECT_ATTRS_IDX, rgbSetTag,
};
#define PARSE_CTL_SUBJECT_PARA_CNT      \
    (sizeof(rgParseCTLSubjectPara) / sizeof(rgParseCTLSubjectPara[0]))

//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseCTLSubject
//
//  Parses an ASN.1 encoded CTL Subject contained within a CTL's SEQUENCE OF
//  Subjects.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded subject.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ParseCTLSubject(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT CRYPT_DER_BLOB rgCTLSubjectBlob[MINASN1_CTL_SUBJECT_BLOB_CNT]
    )
{

    LONG lSkipped;
    DWORD cValuePara = PARSE_CTL_SUBJECT_PARA_CNT;

    lSkipped = MinAsn1ExtractValues(
        pbEncoded,
        cbEncoded,
        &cValuePara,
        rgParseCTLSubjectPara,
        MINASN1_CTL_SUBJECT_BLOB_CNT,
        rgCTLSubjectBlob
        );

    if (0 < lSkipped)
        lSkipped = rgCTLSubjectBlob[MINASN1_CTL_SUBJECT_ENCODED_IDX].cbData;

    return lSkipped;
}



const MINASN1_EXTRACT_VALUE_PARA rgParseIndirectDataPara[] = {
    // 0 - SpcIndirectDataContent ::= SEQUENCE {
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_INTO_VALUE_OP, 
        MINASN1_INDIRECT_DATA_ENCODED_IDX, rgbSeqTag,

    // 0.0 - data                    SpcAttributeTypeAndOptionalValue,
    MINASN1_STEP_INTO_VALUE_OP, 0, rgbSeqTag,

    // 0.0.0 - type                    ObjectID,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_INDIRECT_DATA_ATTR_OID_IDX, rgbOIDTag,
    // 0.0.1 - value                   NOCOPYANY OPTIONAL
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_INDIRECT_DATA_ATTR_VALUE_IDX, NULL,
    // 0.0.2
    MINASN1_STEP_OUT_VALUE_OP, 0, NULL,

    // 0.1 - messageDigest           DigestInfo
    MINASN1_STEP_INTO_VALUE_OP, 0, rgbSeqTag,

    // 0.1.0 - digestAlgorithm     AlgorithmIdentifier,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_INDIRECT_DATA_DIGEST_ALGID_IDX, rgbSeqTag,
    // 0.1.1 - digest              OCTETSTRING
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_INDIRECT_DATA_DIGEST_IDX, rgbOctetStringTag,
};
#define PARSE_INDIRECT_DATA_PARA_CNT    \
    (sizeof(rgParseIndirectDataPara) / sizeof(rgParseIndirectDataPara[0]))

//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseIndirectData
//
//  Parses an ASN.1 encoded Indirect Data. Indirect Data is always
//  contained as the inner content data in a PKCS #7 Signed Data. It has
//  the following OID: "1.3.6.1.4.1.311.2.1.4"
//
//  An Authenticode signed file contains a PKCS #7 Signed Indirect Data.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded Indirect Data
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ParseIndirectData(
    IN PCRYPT_DER_BLOB pEncodedContentBlob,
    OUT CRYPT_DER_BLOB rgIndirectDataBlob[MINASN1_INDIRECT_DATA_BLOB_CNT]
    )
{

    LONG lSkipped;
    DWORD cValuePara = PARSE_INDIRECT_DATA_PARA_CNT;

    lSkipped = MinAsn1ExtractValues(
        pEncodedContentBlob->pbData,
        pEncodedContentBlob->cbData,
        &cValuePara,
        rgParseIndirectDataPara,
        MINASN1_INDIRECT_DATA_BLOB_CNT,
        rgIndirectDataBlob
        );

    if (0 < lSkipped)
        lSkipped = rgIndirectDataBlob[MINASN1_INDIRECT_DATA_ENCODED_IDX].cbData;

    return lSkipped;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\mincrypt\lib\asn1util.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       asn1util.cpp
//
//  Contents:   Minimal ASN.1 utility helper functions.
//
//  Functions:  MinAsn1DecodeLength
//              MinAsn1ExtractContent
//              MinAsn1ExtractValues
//
//              MinAsn1FindExtension
//              MinAsn1FindAttribute
//              MinAsn1ExtractParsedCertificatesFromSignedData
//
//  History:    15-Jan-01    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"

//+-------------------------------------------------------------------------
//  Get the number of contents octets in a definite-length BER-encoding.
//
//  Parameters:
//          pcbContent - receives the number of contents octets
//          pbLength   - points to the first length octet
//          cbBER      - number of bytes remaining in the BER encoding
//
//  Returns:
//          success - the number of bytes in the length field, > 0
//          failure - < 0
//
//          One of the following failure values can be returned:
//              MINASN1_LENGTH_TOO_LARGE
//              MINASN1_INSUFFICIENT_DATA
//              MINASN1_UNSUPPORTED_INDEFINITE_LENGTH
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1DecodeLength(
    OUT DWORD   *pcbContent,
    IN const BYTE *pbLength,
    IN  DWORD   cbBER)
{
    long        i;
    BYTE        cbLength;
    const BYTE  *pb;

    if (cbBER < 1)
        goto TooLittleData;

    if (0x80 == *pbLength)
        goto IndefiniteLength;

    // determine the number of length octets and contents octets
    if ((cbLength = *pbLength) & 0x80) {
        cbLength &= ~0x80;         // low 7 bits have number of bytes
        if (cbLength > 4)
            goto LengthTooLargeError;
        if (cbLength >= cbBER)
            goto TooLittleData;
        *pcbContent = 0;
        for (i=cbLength, pb=pbLength+1; i>0; i--, pb++)
            *pcbContent = (*pcbContent << 8) + (const DWORD)*pb;
        i = cbLength + 1;
    } else {
        *pcbContent = (DWORD)cbLength;
        i = 1;
    }

CommonReturn:
    return i;   // how many bytes there were in the length field

LengthTooLargeError:
    i = MINASN1_LENGTH_TOO_LARGE;
    goto CommonReturn;

IndefiniteLength:
    i = MINASN1_UNSUPPORTED_INDEFINITE_LENGTH;
    goto CommonReturn;

TooLittleData:
    i = MINASN1_INSUFFICIENT_DATA;
    goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  Point to the content octets in a definite-length BER-encoded blob.
//
//  Returns:
//          success - the number of bytes skipped, > 0
//          failure - < 0
//
//          One of the following failure values can be returned:
//              MINASN1_LENGTH_TOO_LARGE
//              MINASN1_INSUFFICIENT_DATA
//              MINASN1_UNSUPPORTED_INDEFINITE_LENGTH
//
// Assumption: pbData points to a definite-length BER-encoded blob.
//             If *pcbContent isn't within cbBER, MINASN1_INSUFFICIENT_DATA
//             is returned.
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ExtractContent(
    IN const BYTE *pbBER,
    IN DWORD cbBER,
    OUT DWORD *pcbContent,
    OUT const BYTE **ppbContent)
{
#define TAG_MASK 0x1f
    DWORD       cbIdentifier;
    DWORD       cbContent;
    LONG        cbLength;
    LONG        lHeader;
    const BYTE  *pb = pbBER;

    if (0 == cbBER--)
        goto TooLittleData;

    // Skip over the identifier octet(s)
    if (TAG_MASK == (*pb++ & TAG_MASK)) {
        // high-tag-number form
        cbIdentifier = 2;
        while (TRUE) {
            if (0 == cbBER--)
                goto TooLittleData;
            if (0 == (*pb++ & 0x80))
                break;
            cbIdentifier++;
        }
    } else {
        // low-tag-number form
        cbIdentifier = 1;
    }

    if (0 > (cbLength = MinAsn1DecodeLength( &cbContent, pb, cbBER))) {
        lHeader = cbLength;
        goto CommonReturn;
    }

    if (cbContent > (cbBER - cbLength))
        goto TooLittleData;

    pb += cbLength;

    *pcbContent = cbContent;
    *ppbContent = pb;

    lHeader = cbLength + cbIdentifier;
CommonReturn:
    return lHeader;

TooLittleData:
    lHeader = MINASN1_INSUFFICIENT_DATA;
    goto CommonReturn;
}


typedef struct _STEP_INTO_STACK_ENTRY {
    const BYTE      *pb;
    DWORD           cb;
    BOOL            fSkipIntoValues;
} STEP_INTO_STACK_ENTRY, *PSTEP_INTO_STACK_ENTRY;

#define MAX_STEP_INTO_DEPTH     8

//+-------------------------------------------------------------------------
//  Extract one or more tagged values from the ASN.1 encoded byte array.
//
//  Either steps into the value's content octets (MINASN1_STEP_INTO_VALUE_OP or
//  MINASN1_OPTIONAL_STEP_INTO_VALUE_OP) or steps over the value's tag,
//  length and content octets (MINASN1_STEP_OVER_VALUE_OP or
//  MINASN1_OPTIONAL_STEP_OVER_VALUE_OP).
//
//  You can step out of a stepped into sequence via MINASN1_STEP_OUT_VALUE_OP.
//
//  For tag matching, only supports single byte tags.
//
//  Only definite-length ASN.1 is supported.
//
//  *pcValue is updated with the number of values successfully extracted.
//
//  Returns:
//      success - >= 0 => length of all bytes consumed through the last value
//                        extracted. For STEP_INTO, only the tag and length
//                        octets.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  A non-NULL rgValueBlob[] is updated with the pointer to and length of the
//  tagged value or its content octets. The rgValuePara[].dwIndex is used to
//  index into rgValueBlob[].  For OPTIONAL_STEP_OVER or
//  OPTIONAL_STEP_INTO, if no more bytes in the outer SEQUENCE or if the tag
//  isn't found, pbData and cbData are set to 0. Additioanlly, for
//  OPTIONAL_STEP_INTO, all subsequent values are skipped and their
//  rgValueBlob[] entries zeroed until a STEP_OUT is encountered.
//
//  If MINASN1_RETURN_VALUE_BLOB_FLAG is set, pbData points to
//  the tag. cbData includes the tag, length and content octets.
//
//  If MINASN1_RETURN_CONTENT_BLOB_FLAG is set, pbData points to the content
//  octets. cbData includes only the content octets.
//
//  If neither BLOB_FLAG is set, rgValueBlob[] isn't updated.
//
//  For MINASN1_RETURN_CONTENT_BLOB_FLAG of a BITSTRING, pbData is
//  advanced past the first contents octet containing the number of
//  unused bits and cbData has been decremented by 1. If cbData > 0, then,
//  *(pbData - 1) will contain the number of unused bits.
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ExtractValues(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN OUT DWORD *pcValuePara,
    IN const MINASN1_EXTRACT_VALUE_PARA *rgValuePara,
    IN DWORD cValueBlob,
    OUT OPTIONAL PCRYPT_DER_BLOB rgValueBlob
    )
{
    DWORD cValue = *pcValuePara;
    const BYTE *pb = pbEncoded;
    DWORD cb = cbEncoded;
    BOOL fSkipIntoValues = FALSE;

    DWORD iValue;
    LONG lAllValues;

    STEP_INTO_STACK_ENTRY rgStepIntoStack[MAX_STEP_INTO_DEPTH];
    DWORD dwStepIntoDepth = 0;

    for (iValue = 0; iValue < cValue; iValue++) {
        DWORD dwParaFlags = rgValuePara[iValue].dwFlags;
        DWORD dwOp = dwParaFlags & MINASN1_MASK_VALUE_OP;
        const BYTE *pbParaTag = rgValuePara[iValue].rgbTag;
        DWORD dwIndex = rgValuePara[iValue].dwIndex;
        BOOL fValueBlob = (dwParaFlags & (MINASN1_RETURN_VALUE_BLOB_FLAG |
                MINASN1_RETURN_CONTENT_BLOB_FLAG)) && rgValueBlob &&
                (dwIndex < cValueBlob);
        BOOL fSkipValue = FALSE;

        LONG lTagLength;
        DWORD cbContent;
        const BYTE *pbContent;
        DWORD cbValue;

        if (MINASN1_STEP_OUT_VALUE_OP == dwOp) {
            // Unstack and advance past the last STEP_INTO

            if (0 == dwStepIntoDepth)
                goto InvalidStepOutOp;

            dwStepIntoDepth--;
            pb = rgStepIntoStack[dwStepIntoDepth].pb;
            cb = rgStepIntoStack[dwStepIntoDepth].cb;
            fSkipIntoValues = rgStepIntoStack[dwStepIntoDepth].fSkipIntoValues;

            continue;
        }

        if (fSkipIntoValues) {
            // For an omitted OPTIONAL_STEP_INTO, all of its included values
            // are also omitted.
            fSkipValue = TRUE;
        } else if (0 == cb) {
            if (!(MINASN1_OPTIONAL_STEP_INTO_VALUE_OP == dwOp ||
                    MINASN1_OPTIONAL_STEP_OVER_VALUE_OP == dwOp))
                goto TooLittleData;
            fSkipValue = TRUE;
        } else if (pbParaTag) {
            // Assumption: single byte tag for doing comparison

            // Check if the encoded tag matches one of the expected tags

            BYTE bEncodedTag;
            BYTE bParaTag;

            bEncodedTag = *pb;
            while ((bParaTag = *pbParaTag) && bParaTag != bEncodedTag)
                pbParaTag++;

            if (0 == bParaTag) {
                if (!(MINASN1_OPTIONAL_STEP_INTO_VALUE_OP == dwOp ||
                        MINASN1_OPTIONAL_STEP_OVER_VALUE_OP == dwOp))
                    goto InvalidTag;
                fSkipValue = TRUE;
            }
        }

        if (fSkipValue) {
            if (fValueBlob) {
                rgValueBlob[dwIndex].pbData = NULL;
                rgValueBlob[dwIndex].cbData = 0;
            }

            if (MINASN1_STEP_INTO_VALUE_OP == dwOp ||
                    MINASN1_OPTIONAL_STEP_INTO_VALUE_OP == dwOp) {
                // Stack this skipped STEP_INTO
                if (MAX_STEP_INTO_DEPTH <= dwStepIntoDepth)
                    goto ExceededStepIntoDepth;
                rgStepIntoStack[dwStepIntoDepth].pb = pb;
                rgStepIntoStack[dwStepIntoDepth].cb = cb;
                rgStepIntoStack[dwStepIntoDepth].fSkipIntoValues =
                    fSkipIntoValues;
                dwStepIntoDepth++;

                fSkipIntoValues = TRUE;
            }
            continue;
        }

        lTagLength = MinAsn1ExtractContent(
            pb,
            cb,
            &cbContent,
            &pbContent
            );
        if (0 >= lTagLength)
            goto InvalidTagOrLength;

        cbValue = cbContent + lTagLength;

        if (fValueBlob) {
            if (dwParaFlags & MINASN1_RETURN_CONTENT_BLOB_FLAG) {
                rgValueBlob[dwIndex].pbData = (BYTE *) pbContent;
                rgValueBlob[dwIndex].cbData = cbContent;

                if (MINASN1_TAG_BITSTRING == *pb) {
                    if (0 < cbContent) {
                        // Advance past the first contents octet containing
                        // the number of unused bits
                        rgValueBlob[dwIndex].pbData += 1;
                        rgValueBlob[dwIndex].cbData -= 1;
                    }
                }
            } else if (dwParaFlags & MINASN1_RETURN_VALUE_BLOB_FLAG) {
                rgValueBlob[dwIndex].pbData = (BYTE *) pb;
                rgValueBlob[dwIndex].cbData = cbValue;
            }
        }

        switch (dwOp) {
            case MINASN1_STEP_INTO_VALUE_OP:
            case MINASN1_OPTIONAL_STEP_INTO_VALUE_OP:
                // Stack this STEP_INTO
                if (MAX_STEP_INTO_DEPTH <= dwStepIntoDepth)
                    goto ExceededStepIntoDepth;
                rgStepIntoStack[dwStepIntoDepth].pb = pb + cbValue;
                rgStepIntoStack[dwStepIntoDepth].cb = cb - cbValue;
                assert(!fSkipIntoValues);
                rgStepIntoStack[dwStepIntoDepth].fSkipIntoValues = FALSE;
                dwStepIntoDepth++;
                pb = pbContent;
                cb = cbContent;
                break;
            case MINASN1_STEP_OVER_VALUE_OP:
            case MINASN1_OPTIONAL_STEP_OVER_VALUE_OP:
                pb += cbValue;
                cb -= cbValue;
                break;
            default:
                goto InvalidArg;
        }
    }

    lAllValues = (LONG)(pb - pbEncoded);
    assert((DWORD) lAllValues <= cbEncoded);

CommonReturn:
    *pcValuePara = iValue;
    return lAllValues;

InvalidStepOutOp:
TooLittleData:
InvalidTag:
ExceededStepIntoDepth:
InvalidTagOrLength:
InvalidArg:
    lAllValues = -((LONG)(pb - pbEncoded)) - 1;
    goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  Find an extension identified by its Encoded Object Identifier.
//
//  Searches the list of parsed extensions returned by
//  MinAsn1ParseExtensions().
//
//  If found, returns pointer to the rgExtBlob[MINASN1_EXT_BLOB_CNT].
//  Otherwise, returns NULL.
//--------------------------------------------------------------------------
PCRYPT_DER_BLOB
WINAPI
MinAsn1FindExtension(
    IN PCRYPT_DER_BLOB pEncodedOIDBlob,
    IN DWORD cExt,
    IN CRYPT_DER_BLOB rgrgExtBlob[][MINASN1_EXT_BLOB_CNT]
    )
{
    DWORD i;
    DWORD cbOID = pEncodedOIDBlob->cbData;
    const BYTE *pbOID = pEncodedOIDBlob->pbData;

    for (i = 0; i < cExt; i++) {
        if (cbOID == rgrgExtBlob[i][MINASN1_EXT_OID_IDX].cbData
                            &&
                0 == memcmp(pbOID, rgrgExtBlob[i][MINASN1_EXT_OID_IDX].pbData,
                                cbOID))
            return rgrgExtBlob[i];
    }

    return NULL;
}


//+-------------------------------------------------------------------------
//  Find the first attribute identified by its Encoded Object Identifier.
//
//  Searches the list of parsed attributes returned by
//  MinAsn1ParseAttributes().
//
//  If found, returns pointer to the rgAttrBlob[MINASN1_ATTR_BLOB_CNT].
//  Otherwise, returns NULL.
//--------------------------------------------------------------------------
PCRYPT_DER_BLOB
WINAPI
MinAsn1FindAttribute(
    IN PCRYPT_DER_BLOB pEncodedOIDBlob,
    IN DWORD cAttr,
    IN CRYPT_DER_BLOB rgrgAttrBlob[][MINASN1_ATTR_BLOB_CNT]
    )
{
    DWORD i;
    DWORD cbOID = pEncodedOIDBlob->cbData;
    const BYTE *pbOID = pEncodedOIDBlob->pbData;

    for (i = 0; i < cAttr; i++) {
        if (cbOID == rgrgAttrBlob[i][MINASN1_ATTR_OID_IDX].cbData
                            &&
                0 == memcmp(pbOID, rgrgAttrBlob[i][MINASN1_ATTR_OID_IDX].pbData,
                                cbOID))
            return rgrgAttrBlob[i];
    }

    return NULL;
}

//+-------------------------------------------------------------------------
//  Parses an ASN.1 encoded PKCS #7 Signed Data Message to extract and
//  parse the X.509 certificates it contains.
//
//  Assumes the PKCS #7 message is definite length encoded.
//  Assumes PKCS #7 version 1.5, ie, not the newer CMS version.
//
//  Upon input, *pcCert contains the maximum number of parsed certificates
//  that can be returned. Updated with the number of certificates processed.
//
//  If the encoded message was successfully parsed, TRUE is returned
//  with *pcCert updated with the number of parsed certificates. Otherwise,
//  FALSE is returned for a parse error.
//  Returns:
//      success - >= 0 => bytes skipped, length of the encoded certificates
//                        processed.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//                        from beginning of message.
//
//  The rgrgCertBlob[][] is updated with pointer to and length of the
//  fields in the encoded certificate. See MinAsn1ParseCertificate for the
//  field definitions.
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ExtractParsedCertificatesFromSignedData(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN OUT DWORD *pcCert,
    OUT CRYPT_DER_BLOB rgrgCertBlob[][MINASN1_CERT_BLOB_CNT]
    )
{
    LONG lSkipped;
    CRYPT_DER_BLOB rgSignedDataBlob[MINASN1_SIGNED_DATA_BLOB_CNT];

    lSkipped = MinAsn1ParseSignedData(
        pbEncoded,
        cbEncoded,
        rgSignedDataBlob
        );
    if (0 >= lSkipped)
        goto ParseError;

    lSkipped = MinAsn1ParseSignedDataCertificates(
            &rgSignedDataBlob[MINASN1_SIGNED_DATA_CERTS_IDX],
            pcCert,
            rgrgCertBlob
            );

    if (0 > lSkipped) {
        assert(rgSignedDataBlob[MINASN1_SIGNED_DATA_CERTS_IDX].pbData >
            pbEncoded);
        lSkipped -= (LONG)(rgSignedDataBlob[MINASN1_SIGNED_DATA_CERTS_IDX].pbData -
            pbEncoded);

        goto ParseError;
    }

CommonReturn:
    return lSkipped;

ParseError:
    *pcCert = 0;
    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\mincrypt\lib\imagehack.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       imagehack.cpp
//
//  Contents:   "Hacked" version of the imagehlp APIs
//
//              Contains a "stripped" down subset of the imagehlp functionality
//              necessary to hash a PE file and to extract the 
//              PKCS #7 Signed Data message.
//
//              Most of this file is derived from the following 2 files:
//                  \nt\ds\security\cryptoapi\pkitrust\mssip32\peimage2.cpp
//                  \nt\sdktools\debuggers\imagehlp\dice.cxx
//
//  Functions:  imagehack_ImageGetDigestStream
//              imagehack_ImageGetCertificateData
//
//  History:    20-Jan-01    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"

//+=========================================================================
//  The following was taken from the following file:
//      \nt\ds\security\cryptoapi\pkitrust\mssip32\peimage2.cpp
//-=========================================================================

__inline DWORD AlignIt (DWORD Value, DWORD Alignment) { return (Value + (Alignment - 1)) & ~(Alignment -1); }

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

BOOL
I_CalculateImagePtrs(
    PLOADED_IMAGE LoadedImage
    )
{
    PIMAGE_DOS_HEADER DosHeader;
    BOOL fRC = FALSE;

    // Everything is mapped. Now check the image and find nt image headers

    __try {
        DosHeader = (PIMAGE_DOS_HEADER)LoadedImage->MappedAddress;

        if ((DosHeader->e_magic != IMAGE_DOS_SIGNATURE) &&
            (DosHeader->e_magic != IMAGE_NT_SIGNATURE)) {
            __leave;
        }

        if (DosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
            if (DosHeader->e_lfanew == 0) {
                __leave;
            }
            LoadedImage->FileHeader = (PIMAGE_NT_HEADERS)((ULONG_PTR)DosHeader + DosHeader->e_lfanew);

            if (
                // If IMAGE_NT_HEADERS would extend past the end of file...
                (PBYTE)LoadedImage->FileHeader + sizeof(IMAGE_NT_HEADERS) >
                    (PBYTE)LoadedImage->MappedAddress + LoadedImage->SizeOfImage ||

                // ..or if it would begin in, or before the IMAGE_DOS_HEADER...
                (PBYTE)LoadedImage->FileHeader <
                    (PBYTE)LoadedImage->MappedAddress + sizeof(IMAGE_DOS_HEADER)  )
            {
                // ...then e_lfanew is not as expected.
                // (Several Win95 files are in this category.)
                __leave;
            }
        } else {

            // No DOS header indicates an image built w/o a dos stub

            LoadedImage->FileHeader = (PIMAGE_NT_HEADERS)DosHeader;
        }

        if ( LoadedImage->FileHeader->Signature != IMAGE_NT_SIGNATURE ) {
            __leave;
        } else {
            LoadedImage->fDOSImage = FALSE;
        }

        // No optional header indicates an object...

        if ( !LoadedImage->FileHeader->FileHeader.SizeOfOptionalHeader ) {
            __leave;
        }

        // Check for versions < 2.50

        if ( LoadedImage->FileHeader->OptionalHeader.MajorLinkerVersion < 3 &&
             LoadedImage->FileHeader->OptionalHeader.MinorLinkerVersion < 5 ) {
            __leave;
        }

        InitializeListHead( &LoadedImage->Links );
        LoadedImage->NumberOfSections = LoadedImage->FileHeader->FileHeader.NumberOfSections;
        LoadedImage->Sections = IMAGE_FIRST_SECTION(LoadedImage->FileHeader);
        fRC = TRUE;

    } __except ( EXCEPTION_EXECUTE_HANDLER ) { }

    return fRC;
}

BOOL
I_MapIt(
    PCRYPT_DATA_BLOB pFileBlob,
    PLOADED_IMAGE LoadedImage
    )
{

    LoadedImage->hFile = INVALID_HANDLE_VALUE;
    LoadedImage->MappedAddress = pFileBlob->pbData;
    LoadedImage->SizeOfImage = pFileBlob->cbData;

    if (!LoadedImage->MappedAddress) {
        return (FALSE);
    }

    if (!I_CalculateImagePtrs(LoadedImage)) {
        return(FALSE);
    }


    return(TRUE);
}

typedef struct _EXCLUDE_RANGE {
    PBYTE Offset;
    DWORD Size;
    struct _EXCLUDE_RANGE *Next;
} EXCLUDE_RANGE;

class EXCLUDE_LIST
{
    public:
        EXCLUDE_LIST() {
            m_Image = NULL;
            m_ExRange = (EXCLUDE_RANGE *)I_MemAlloc(sizeof(EXCLUDE_RANGE));

            if(m_ExRange)
                memset(m_ExRange, 0x00, sizeof(EXCLUDE_RANGE));
        }

        ~EXCLUDE_LIST() {
            EXCLUDE_RANGE *pTmp;
            pTmp = m_ExRange->Next;
            while (pTmp)
            {
                I_MemFree(m_ExRange);
                m_ExRange = pTmp;
                pTmp = m_ExRange->Next;
            }
            I_MemFree(m_ExRange);
        }

        void Init(LOADED_IMAGE * Image, DIGEST_FUNCTION pFunc, DIGEST_HANDLE dh) {
            m_Image = Image;
            m_ExRange->Offset = NULL;
            m_ExRange->Size = 0;
            m_pFunc = pFunc;
            m_dh = dh;
            return;
        }

        void Add(DWORD_PTR Offset, DWORD Size);

        BOOL Emit(PBYTE Offset, DWORD Size);

    private:
        LOADED_IMAGE  * m_Image;
        EXCLUDE_RANGE * m_ExRange;
        DIGEST_FUNCTION m_pFunc;
        DIGEST_HANDLE m_dh;
};

void
EXCLUDE_LIST::Add(
    DWORD_PTR Offset,
    DWORD Size
    )
{
    EXCLUDE_RANGE *pTmp, *pExRange;

    pExRange = m_ExRange;

    while (pExRange->Next && (pExRange->Next->Offset < (PBYTE)Offset)) {
        pExRange = pExRange->Next;
    }

    pTmp = (EXCLUDE_RANGE *) I_MemAlloc(sizeof(EXCLUDE_RANGE));

    if(pTmp)
    {
        pTmp->Next = pExRange->Next;
        pTmp->Offset = (PBYTE)Offset;
        pTmp->Size = Size;
        pExRange->Next = pTmp;
    }

    return;
}


BOOL
EXCLUDE_LIST::Emit(
    PBYTE Offset,
    DWORD Size
    )
{
    BOOL rc = FALSE;

    EXCLUDE_RANGE *pExRange;
    DWORD EmitSize, ExcludeSize;

    pExRange = m_ExRange->Next;

    while (pExRange && (Size > 0)) {
        if (pExRange->Offset >= Offset) {
            // Emit what's before the exclude list.
            EmitSize = min((DWORD)(pExRange->Offset - Offset), Size);
            if (EmitSize) {
                rc = (*m_pFunc)(m_dh, Offset, EmitSize);
                Size -= EmitSize;
                Offset += EmitSize;
            }
        }

        if (Size) {
            if (pExRange->Offset + pExRange->Size >= Offset) {
                // Skip over what's in the exclude list.
                ExcludeSize = min(Size, (DWORD)(pExRange->Offset + pExRange->Size - Offset));
                Size -= ExcludeSize;
                Offset += ExcludeSize;
            }
        }

        pExRange = pExRange->Next;
    }

    // Emit what's left.
    if (Size) {
        rc = (*m_pFunc)(m_dh, Offset, Size);
    }
    return rc;
}


#pragma warning (push)
// error C4509: nonstandard extension used: 'imagehack_ImageGetDigestStream'
//              uses SEH and 'ExList' has destructor
#pragma warning (disable: 4509)


BOOL
WINAPI
imagehack_ImageGetDigestStream(
    IN      PCRYPT_DATA_BLOB pFileBlob,
    IN      DWORD   DigestLevel,
    IN      DIGEST_FUNCTION DigestFunction,
    IN      DIGEST_HANDLE   DigestHandle
    )

/*++

Routine Description:
    Given an image, return the bytes necessary to construct a certificate.
    Only PE images are supported at this time.

Arguments:

    FileHandle  -   Handle to the file in question.  The file should be opened
                    with at least GENERIC_READ access.

    DigestLevel -   Indicates what data will be included in the returned buffer.
                    Valid values are:

                        CERT_PE_IMAGE_DIGEST_ALL_BUT_CERTS - Include data outside the PE image itself
                                                              (may include non-mapped debug symbolic)

    DigestFunction - User supplied routine that will process the data.

    DigestHandle -  User supplied handle to identify the digest.  Passed as the first
                    argument to the DigestFunction.

Return Value:

    TRUE         - Success.

    FALSE        - There was some error.  Call GetLastError for more information.  Possible
                   values are ERROR_INVALID_PARAMETER or ERROR_OPERATION_ABORTED.

--*/

{
    LOADED_IMAGE    LoadedImage;
    DWORD           ErrorCode;
    EXCLUDE_LIST    ExList;

    if (I_MapIt(pFileBlob, &LoadedImage) == FALSE) {
        // Unable to map the image or invalid digest level.
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    ErrorCode = ERROR_INVALID_PARAMETER;
    __try {
        PIMAGE_DATA_DIRECTORY CertDirectory;
        DWORD HeaderEndOffset = 0;

        if ((LoadedImage.FileHeader->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC) &&
            (LoadedImage.FileHeader->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC))
        {
            __leave;
        }

        ExList.Init(&LoadedImage, DigestFunction, DigestHandle);

        if (LoadedImage.FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            PIMAGE_NT_HEADERS32 NtHeader32 = (PIMAGE_NT_HEADERS32)(LoadedImage.FileHeader);
            // Exclude the checksum.
            ExList.Add(((DWORD_PTR) &NtHeader32->OptionalHeader.CheckSum),
                       sizeof(NtHeader32->OptionalHeader.CheckSum));

            CertDirectory = &NtHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];
            HeaderEndOffset = NtHeader32->OptionalHeader.SizeOfHeaders;
        } else {
            PIMAGE_NT_HEADERS64 NtHeader64 = (PIMAGE_NT_HEADERS64)(LoadedImage.FileHeader);
            // Exclude the checksum.
            ExList.Add(((DWORD_PTR) &NtHeader64->OptionalHeader.CheckSum),
                       sizeof(NtHeader64->OptionalHeader.CheckSum));

            CertDirectory = &NtHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];
            HeaderEndOffset = NtHeader64->OptionalHeader.SizeOfHeaders;
        }

        DWORD CertFileOffset = CertDirectory->VirtualAddress;
        DWORD CertFileSize = CertDirectory->Size;

        if (CertFileOffset && CertFileSize) {
            DWORD i;

            if (CertFileOffset > LoadedImage.SizeOfImage) {
                __leave;    // Start of certs is past end of image
            }
            if ((CertFileOffset + CertFileSize) != LoadedImage.SizeOfImage) {
                __leave;    // Certs not at end of image
            }
            if ((CertFileOffset + CertFileSize) < CertFileOffset) {
                __leave;    // cert end is before cert start (start + size wraps)
            }
            if (CertFileOffset < HeaderEndOffset) {
                __leave;    // Certs are in the header space
            }

            // See if the certs are in the section data
            for (i = 0; i < LoadedImage.NumberOfSections; i++) {
                DWORD SectionFileOffsetStart = LoadedImage.Sections[i].PointerToRawData;
                DWORD SectionFileOffsetEnd = SectionFileOffsetStart + LoadedImage.Sections[i].SizeOfRawData;

                if (SectionFileOffsetStart && (CertFileOffset < SectionFileOffsetEnd)) {
                    __leave;    // CertData starts before this section - not allowed
                }
            }
        }

        // Exclude the Security directory.
        ExList.Add((DWORD_PTR) CertDirectory, sizeof(IMAGE_DATA_DIRECTORY));

        // Exclude the certs.
        ExList.Add((DWORD_PTR)CertFileOffset + (DWORD_PTR)LoadedImage.MappedAddress, CertFileSize);

        ExList.Emit((PBYTE) (LoadedImage.MappedAddress), LoadedImage.SizeOfImage);
        ErrorCode = ERROR_SUCCESS;

    } __except(EXCEPTION_EXECUTE_HANDLER) { }


    SetLastError(ErrorCode);

    return(ErrorCode == ERROR_SUCCESS ? TRUE : FALSE);
}

#pragma warning (pop)


//+=========================================================================
//  The following was taken from the following file:
//      \nt\sdktools\debuggers\imagehlp\dice.cxx
//-=========================================================================


BOOL
I_FindCertificate(
    IN PLOADED_IMAGE    LoadedImage,
    IN DWORD            Index,
    OUT LPWIN_CERTIFICATE * Certificate
    )
{
    PIMAGE_DATA_DIRECTORY pDataDir;
    DWORD_PTR CurrentCert = NULL;
    BOOL rc;

    if (LoadedImage->fDOSImage) {
        // No way this could have a certificate;
        return(FALSE);
    }

    rc = FALSE;

    __try {
        if (LoadedImage->FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            pDataDir = &((PIMAGE_NT_HEADERS32)(LoadedImage->FileHeader))->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];
        } else if (LoadedImage->FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
            pDataDir = &((PIMAGE_NT_HEADERS64)(LoadedImage->FileHeader))->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];
        } else {
            __leave;     // Not an interesting file type.
        }

        // Check if the cert pointer is at least reasonable.
        if (!pDataDir->VirtualAddress ||
            !pDataDir->Size ||
            (pDataDir->VirtualAddress + pDataDir->Size > LoadedImage->SizeOfImage))
        {
            __leave;
        }

        // We're not looking at an empty security slot or an invalid (past the image boundary) value.
        // Let's see if we can find it.

        DWORD CurrentIdx = 0;
        DWORD_PTR LastCert;

        CurrentCert = (DWORD_PTR)(LoadedImage->MappedAddress) + pDataDir->VirtualAddress;
        LastCert = CurrentCert + pDataDir->Size;

        while (CurrentCert < LastCert ) {
            if (CurrentIdx == Index) {
                rc = TRUE;
                __leave;
            }
            CurrentIdx++;
            CurrentCert += ((LPWIN_CERTIFICATE)CurrentCert)->dwLength;
            CurrentCert = (CurrentCert + 7) & ~7;   // align it.
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) { }

    if (rc == TRUE) {
        *Certificate = (LPWIN_CERTIFICATE)CurrentCert;
    }

    return(rc);
}

BOOL
WINAPI
imagehack_ImageGetCertificateData(
    IN      PCRYPT_DATA_BLOB pFileBlob,
    IN      DWORD   CertificateIndex,
    OUT     LPWIN_CERTIFICATE * Certificate
    )

/*++

Routine Description:

    Given a specific certificate index, retrieve the certificate data.

Arguments:

    FileHandle          -   Handle to the file in question.  The file should be opened
                            with at least GENERIC_READ access.

    CertificateIndex    -   Index to retrieve

    Certificate         -   Output buffer where the certificate is to be stored.

    RequiredLength      -   Size of the certificate buffer (input).  On return, is
                            set to the actual certificate length.  NULL can be used
                            to determine the size of a certificate.

Return Value:

    TRUE    - Successful

    FALSE   - There was some error.  Call GetLastError() for more information.

--*/

{
    LOADED_IMAGE LoadedImage;
    DWORD   ErrorCode;

    LPWIN_CERTIFICATE ImageCert;

    *Certificate = NULL;

    // if (I_MapIt(FileHandle, &LoadedImage, MAP_READONLY) == FALSE) {
    if (I_MapIt(pFileBlob, &LoadedImage) == FALSE) {
        // Unable to map the image.
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    ErrorCode = ERROR_INVALID_PARAMETER;
    __try {
        if (I_FindCertificate(&LoadedImage, CertificateIndex, &ImageCert) == FALSE) {
            __leave;
        }
        
        *Certificate = ImageCert;
        ErrorCode = ERROR_SUCCESS;
    } __except(EXCEPTION_EXECUTE_HANDLER) { }

    // I_UnMapIt(&LoadedImage);

    SetLastError(ErrorCode);
    return(ErrorCode == ERROR_SUCCESS ? TRUE: FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\mincrypt\lib\imagehack.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       imagehack.h
//
//  Contents:   "Hacked" version of the imagehlp APIs
//
//              Contains a "stripped" down subset of the imagehlp functionality
//              necessary to hash a PE file and to extract the 
//              PKCS #7 Signed Data message.
//
//  APIs:       imagehack_ImageGetDigestStream
//              imagehack_ImageGetCertificateData
//
//----------------------------------------------------------------------------

#ifndef __IMAGEHACK_H__
#define __IMAGEHACK_H__


#if defined (_MSC_VER)

#if ( _MSC_VER >= 800 )
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)    /* Nameless struct/union */
#endif

#if (_MSC_VER > 1020)
#pragma once
#endif

#endif


#include <wincrypt.h>
#include <imagehlp.h>
#include <wintrust.h>

#ifdef __cplusplus
extern "C" {
#endif


BOOL
WINAPI
imagehack_ImageGetDigestStream(
    IN      PCRYPT_DATA_BLOB pFileBlob,
    IN      DWORD   DigestLevel,                    // ignored
    IN      DIGEST_FUNCTION DigestFunction,
    IN      DIGEST_HANDLE   DigestHandle
    );

BOOL
WINAPI
imagehack_ImageGetCertificateData(
    IN      PCRYPT_DATA_BLOB pFileBlob,
    IN      DWORD   CertificateIndex,               // should be 0
    OUT     LPWIN_CERTIFICATE * Certificate
    );



#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#if defined (_MSC_VER)
#if ( _MSC_VER >= 800 )

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif

#endif
#endif

#endif // __IMAGEHACK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\mincrypt\lib\vercat.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       vercat.cpp
//
//  Contents:   Minimal Cryptographic functions to verify hashes in the
//              system catalogs.
//
//  Functions:  MinCryptVerifyHashInSystemCatalogs
//
//  History:    23-Jan-01    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <softpub.h>
#include <mscat.h>

// #define szOID_CTL               "1.3.6.1.4.1.311.10.1"
const BYTE rgbOID_CTL[] =
    {0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x0A, 0x01};

// #define SPC_INDIRECT_DATA_OBJID "1.3.6.1.4.1.311.2.1.4"
static const BYTE rgbSPC_INDIRECT_DATA_OBJID[] =
    {0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x04};
const CRYPT_DER_BLOB IndirectDataEncodedOIDBlob = {
        sizeof(rgbSPC_INDIRECT_DATA_OBJID), 
        (BYTE *) rgbSPC_INDIRECT_DATA_OBJID
};

#define MAX_CAT_FILE_CNT            10
#define MAX_CAT_ATTR_CNT            10
#define MAX_CAT_EXT_CNT             10

typedef struct _MAP_CAT_INFO {
    LONG                lErr;
    CRYPT_DATA_BLOB     FileBlob;
    CRYPT_DER_BLOB      CTLSubjectsValueBlob;
    CRYPT_DER_BLOB      CTLExtsValueBlob;
    CRYPT_DER_BLOB      SignerAuthAttrsValueBlob;
} MAP_CAT_INFO, *PMAP_CAT_INFO;

#define MAP_CAT_IDX_MASK        0x0000FFFF
#define MAP_CAT_MULTIPLE_FLAG   0x00010000


LONG
WINAPI
I_GetAndMapSystemCatalogs(
    IN ALG_ID HashAlgId,
    IN DWORD cHash,
    IN CRYPT_HASH_BLOB rgHashBlob[],
    OUT LONG rglHashMapCatIdx[],
    OUT DWORD *pcMapCatInfo,
    OUT MAP_CAT_INFO rgMapCatInfo[MAX_CAT_FILE_CNT]
    )
{
    LONG lErr;
    HCATADMIN hCatAdmin = NULL;
    const GUID guidCatRoot = DRIVER_ACTION_VERIFY;
    DWORD cMapCatInfo = 0;
    DWORD cCatInfo = 0;
    CATALOG_INFO rgCatInfo[MAX_CAT_FILE_CNT];
    LONG rglMapCatIdx[MAX_CAT_FILE_CNT];
    DWORD iHash;

    if (!(CryptCATAdminAcquireContext(&hCatAdmin, &guidCatRoot, 0)))
        goto CryptCATAdminAcquireContextError;

    for (iHash = 0; iHash < cHash; iHash++) {
        HCATINFO hCatInfo = NULL;

        // Set index to indicate no catalog file
        rglHashMapCatIdx[iHash] = -1;

        while (hCatInfo = CryptCATAdminEnumCatalogFromHash(hCatAdmin,
                    rgHashBlob[iHash].pbData, rgHashBlob[iHash].cbData,
                    0, &hCatInfo)) {
            CATALOG_INFO CatInfo;
            LONG lMapCatIdx;
            DWORD iCatInfo;

            memset(&CatInfo, 0, sizeof(CATALOG_INFO));
            CatInfo.cbStruct = sizeof(CATALOG_INFO);

            if (!(CryptCATCatalogInfoFromContext(hCatInfo, &CatInfo, 0)))
                continue;

            // Ensure we have a NULL terminated string
            CatInfo.wszCatalogFile[
                sizeof(CatInfo.wszCatalogFile)/sizeof(WCHAR) - 1] = L'\0';

            // Check if we already encountered this catalog file
            for (iCatInfo = 0; iCatInfo < cCatInfo; iCatInfo++) {
                if (0 == _wcsicmp(CatInfo.wszCatalogFile,
                        rgCatInfo[iCatInfo].wszCatalogFile))
                    break;
            }

            if (iCatInfo >= cCatInfo) {
                // Attempt to map this new catalog file

                if (cCatInfo >= MAX_CAT_FILE_CNT)
                    continue;

                wcscpy(rgCatInfo[cCatInfo].wszCatalogFile,
                    CatInfo.wszCatalogFile);

                memset(&rgMapCatInfo[cMapCatInfo], 0, sizeof(MAP_CAT_INFO));

                if (ERROR_SUCCESS == I_MinCryptMapFile(
                        MINCRYPT_FILE_NAME,
                        (const VOID *) CatInfo.wszCatalogFile,
                        &rgMapCatInfo[cMapCatInfo].FileBlob
                        ))
                    rglMapCatIdx[cCatInfo] = cMapCatInfo++;
                else
                    rglMapCatIdx[cCatInfo] = -1;

                cCatInfo++;
                assert(iCatInfo < cCatInfo);
            }

            lMapCatIdx = rglMapCatIdx[iCatInfo];

            if (0 > rglHashMapCatIdx[iHash])
                rglHashMapCatIdx[iHash] = lMapCatIdx;
            else if (0 <= lMapCatIdx)
                rglHashMapCatIdx[iHash] |= MAP_CAT_MULTIPLE_FLAG;
        }
    }

    lErr = ERROR_SUCCESS;

CommonReturn:
    *pcMapCatInfo = cMapCatInfo;
    if (hCatAdmin)
        CryptCATAdminReleaseContext(hCatAdmin, 0);
    return lErr;

CryptCATAdminAcquireContextError:
    lErr = GetLastError();
    if (ERROR_SUCCESS == lErr)
        lErr = E_UNEXPECTED;
    goto CommonReturn;
}


VOID
WINAPI
I_VerifyMappedCatalog(
    IN OUT PMAP_CAT_INFO pMapCatInfo
    )
{
    LONG lErr;
    CRYPT_DER_BLOB rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_BLOB_CNT];
    CRYPT_DER_BLOB rgCTLBlob[MINASN1_CTL_BLOB_CNT];

    __try {
        lErr = MinCryptVerifySignedData(
            pMapCatInfo->FileBlob.pbData,
            pMapCatInfo->FileBlob.cbData,
            rgVerSignedDataBlob
            );
        if (ERROR_SUCCESS != lErr)
            goto ErrorReturn;

        // The data content should be a CTL
        if (sizeof(rgbOID_CTL) !=
                rgVerSignedDataBlob[
                    MINCRYPT_VER_SIGNED_DATA_CONTENT_OID_IDX].cbData
                        ||
                0 != memcmp(rgbOID_CTL,
                        rgVerSignedDataBlob[
                            MINCRYPT_VER_SIGNED_DATA_CONTENT_OID_IDX].pbData,
                        sizeof(rgbOID_CTL)))
            goto NotCTLOID;

        if (0 >= MinAsn1ParseCTL(
                &rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_CONTENT_DATA_IDX],
                rgCTLBlob
                ))
            goto ParseCTLError;

    
        pMapCatInfo->CTLSubjectsValueBlob =
            rgCTLBlob[MINASN1_CTL_SUBJECTS_IDX];
        pMapCatInfo->CTLExtsValueBlob =
            rgCTLBlob[MINASN1_CTL_EXTS_IDX];
        pMapCatInfo->SignerAuthAttrsValueBlob =
            rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_AUTH_ATTRS_IDX];

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        lErr = GetExceptionCode();
        if (ERROR_SUCCESS == lErr)
            lErr = E_UNEXPECTED;
        goto ErrorReturn;
    }

    lErr = ERROR_SUCCESS;

CommonReturn:
    pMapCatInfo->lErr = lErr;
    return;

ErrorReturn:
    goto CommonReturn;

NotCTLOID:
ParseCTLError:
    lErr = CRYPT_E_BAD_MSG;
    goto ErrorReturn;

}

VOID
WINAPI
I_VerifyMappedSystemCatalogs(
    IN DWORD cMapCatInfo,
    IN OUT MAP_CAT_INFO rgMapCatInfo[MAX_CAT_FILE_CNT]
    )
{
    DWORD i;

    for (i = 0; i < cMapCatInfo; i++)
        I_VerifyMappedCatalog(&rgMapCatInfo[i]);
}


LONG
WINAPI
I_FindHashInCTLSubjects(
    IN ALG_ID HashAlgId,
    IN PCRYPT_HASH_BLOB pHashBlob,
    IN PCRYPT_DER_BLOB pCTLSubjectsValueBlob,
    OUT PCRYPT_DER_BLOB pCTLSubjectAttrsValueBlob
    )
{
    DWORD cbEncoded;
    const BYTE *pbEncoded;

    // Advance past the outer tag and length
    if (0 >= MinAsn1ExtractContent(
            pCTLSubjectsValueBlob->pbData,
            pCTLSubjectsValueBlob->cbData,
            &cbEncoded,
            &pbEncoded
            ))
        goto NoOrInvalidSubjects;

    while (cbEncoded) {
        // Loop through the encoded subjects until we have a hash match
        // with the digest octets in the IndirectData attribute.

        LONG cbSubject;
        CRYPT_DER_BLOB rgCTLSubjectBlob[MINASN1_CTL_SUBJECT_BLOB_CNT];
        DWORD cAttr;
        CRYPT_DER_BLOB rgrgAttrBlob[MAX_CAT_ATTR_CNT][MINASN1_ATTR_BLOB_CNT];

        cbSubject = MinAsn1ParseCTLSubject(
            pbEncoded,
            cbEncoded,
            rgCTLSubjectBlob
            );
        if (0 >= cbSubject)
            goto InvalidSubject;
        
        cAttr = MAX_CAT_ATTR_CNT;
        if (0 < MinAsn1ParseAttributes(
                    &rgCTLSubjectBlob[MINASN1_CTL_SUBJECT_ATTRS_IDX],
                    &cAttr,
                    rgrgAttrBlob
                    )) {
            PCRYPT_DER_BLOB rgIndirectDataAttrBlob;
            CRYPT_DER_BLOB rgIndirectDataBlob[MINASN1_INDIRECT_DATA_BLOB_CNT];

            rgIndirectDataAttrBlob = MinAsn1FindAttribute(
                (PCRYPT_DER_BLOB) &IndirectDataEncodedOIDBlob,
                cAttr,
                rgrgAttrBlob
                );

            if (rgIndirectDataAttrBlob &&
                    0 < MinAsn1ParseIndirectData(
                            &rgIndirectDataAttrBlob[MINASN1_ATTR_VALUE_IDX],
                            rgIndirectDataBlob)) {
                if (pHashBlob->cbData ==
                        rgIndirectDataBlob[
                            MINASN1_INDIRECT_DATA_DIGEST_IDX].cbData
                                    &&
                        0 == memcmp(pHashBlob->pbData,
                                rgIndirectDataBlob[
                                    MINASN1_INDIRECT_DATA_DIGEST_IDX].pbData,
                                pHashBlob->cbData)) {

                    *pCTLSubjectAttrsValueBlob =
                        rgCTLSubjectBlob[MINASN1_CTL_SUBJECT_ATTRS_IDX];
                    return ERROR_SUCCESS;
                }
            }
        }

        pbEncoded += cbSubject;
        cbEncoded -= cbSubject;
    }

NoOrInvalidSubjects:
InvalidSubject:
    pCTLSubjectAttrsValueBlob->pbData = NULL;
    pCTLSubjectAttrsValueBlob->cbData = 0;

    return ERROR_FILE_NOT_FOUND;
}


LONG
WINAPI
I_FindHashInMappedSystemCatalogs(
    IN ALG_ID HashAlgId,
    IN PCRYPT_HASH_BLOB pHashBlob,
    IN DWORD cMapCatInfo,
    IN MAP_CAT_INFO rgMapCatInfo[MAX_CAT_FILE_CNT],
    IN OUT LONG *plMapCatIdx,
    OUT PCRYPT_DER_BLOB pCTLSubjectAttrsValueBlob
    )
{
    LONG lErr;
    LONG lMapCatIdx = *plMapCatIdx;
    BOOL fMultiple = FALSE;

    if (0 > lMapCatIdx)
        goto NotInCatalog;
    if (lMapCatIdx & MAP_CAT_MULTIPLE_FLAG)
        fMultiple = TRUE;
    else
        fMultiple = FALSE;
    lMapCatIdx &= MAP_CAT_IDX_MASK;

    assert((DWORD) lMapCatIdx < cMapCatInfo);

    if (ERROR_SUCCESS == rgMapCatInfo[lMapCatIdx].lErr
                        &&
        ERROR_SUCCESS == I_FindHashInCTLSubjects(
            HashAlgId,
            pHashBlob,
            &rgMapCatInfo[lMapCatIdx].CTLSubjectsValueBlob,
            pCTLSubjectAttrsValueBlob
            ))
        goto SuccessReturn;

    if (fMultiple) {
        DWORD i;
        for (i = 0; i < cMapCatInfo; i++) {
            if ((DWORD) lMapCatIdx == i)
                continue;

            if (ERROR_SUCCESS == rgMapCatInfo[i].lErr
                                &&
                ERROR_SUCCESS == I_FindHashInCTLSubjects(
                    HashAlgId,
                    pHashBlob,
                    &rgMapCatInfo[i].CTLSubjectsValueBlob,
                    pCTLSubjectAttrsValueBlob
                    )) {
                lMapCatIdx = i;
                goto SuccessReturn;
            }
        }
    }

NotInCatalog:
    lErr = ERROR_FILE_NOT_FOUND;
    lMapCatIdx = -1;
    pCTLSubjectAttrsValueBlob->pbData = NULL;
    pCTLSubjectAttrsValueBlob->cbData = 0;
    goto CommonReturn;

SuccessReturn:
    lErr = ERROR_SUCCESS;
CommonReturn:
    *plMapCatIdx = lMapCatIdx;
    return lErr;
}


VOID
WINAPI
I_GetHashAttributes(
    IN OPTIONAL DWORD cAttrOID,
    IN OPTIONAL CRYPT_DER_BLOB rgAttrEncodedOIDBlob[],

    IN PCRYPT_DER_BLOB pCTLSubjectAttrsValueBlob,
    IN PCRYPT_DER_BLOB pCTLExtsValueBlob,
    IN PCRYPT_DER_BLOB pSignerAuthAttrsValueBlob,

    IN OUT OPTIONAL CRYPT_DER_BLOB rgAttrValueBlob[],
    IN OUT LONG *plRemainExtra,
    IN OUT BYTE **ppbExtra
    )
{
    DWORD cSubjectAttr;
    CRYPT_DER_BLOB rgrgSubjectAttrBlob[MAX_CAT_ATTR_CNT][MINASN1_ATTR_BLOB_CNT];
    DWORD cExt;
    CRYPT_DER_BLOB rgrgExtBlob[MAX_CAT_EXT_CNT][MINASN1_EXT_BLOB_CNT];
    DWORD cSignerAttr;
    CRYPT_DER_BLOB rgrgSignerAttrBlob[MAX_CAT_ATTR_CNT][MINASN1_ATTR_BLOB_CNT];

    DWORD i;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;

    // Parse the attributes and extensions
    cSubjectAttr = MAX_CAT_ATTR_CNT;
    if (0 >= MinAsn1ParseAttributes(
            pCTLSubjectAttrsValueBlob,
            &cSubjectAttr,
            rgrgSubjectAttrBlob))
        cSubjectAttr = 0;

    cExt = MAX_CAT_EXT_CNT;
    if (0 >= MinAsn1ParseExtensions(
            pCTLExtsValueBlob,
            &cExt,
            rgrgExtBlob))
        cExt = 0;

    cSignerAttr = MAX_CAT_ATTR_CNT;
    if (0 >= MinAsn1ParseAttributes(
            pSignerAuthAttrsValueBlob,
            &cSignerAttr,
            rgrgSignerAttrBlob))
        cSignerAttr = 0;

    for (i = 0; i < cAttrOID; i++) {
        PCRYPT_DER_BLOB rgFindAttrBlob;
        PCRYPT_DER_BLOB rgFindExtBlob;
        PCRYPT_DER_BLOB pFindAttrValue; 

        if (rgFindAttrBlob = MinAsn1FindAttribute(
                &rgAttrEncodedOIDBlob[i],
                cSubjectAttr,
                rgrgSubjectAttrBlob
                ))
            pFindAttrValue = &rgFindAttrBlob[MINASN1_ATTR_VALUE_IDX];
        else if (rgFindExtBlob = MinAsn1FindExtension(
                &rgAttrEncodedOIDBlob[i],
                cExt,
                rgrgExtBlob
                ))
            pFindAttrValue = &rgFindExtBlob[MINASN1_EXT_VALUE_IDX];
        else if (rgFindAttrBlob = MinAsn1FindAttribute(
                &rgAttrEncodedOIDBlob[i],
                cSignerAttr,
                rgrgSignerAttrBlob
                ))
            pFindAttrValue = &rgFindAttrBlob[MINASN1_ATTR_VALUE_IDX];
        else
            pFindAttrValue = NULL;

        if (pFindAttrValue && 0 != pFindAttrValue->cbData) {
            const BYTE *pbFindValue = pFindAttrValue->pbData;
            DWORD cbFindValue = pFindAttrValue->cbData;

            lRemainExtra -= cbFindValue;
            if (0 <= lRemainExtra) {
                rgAttrValueBlob[i].pbData = pbExtra;
                rgAttrValueBlob[i].cbData = cbFindValue;

                memcpy(pbExtra, pbFindValue, cbFindValue);
                pbExtra += cbFindValue;
            }
        }
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}




//+-------------------------------------------------------------------------
//  Verifies the hashes in the system catalogs.
//
//  Iterates through the hashes and attempts to find the system catalog
//  containing it. If found, the system catalog file is verified as a
//  PKCS #7 Signed Data message with its signer cert verified up to a baked
//  in root.
//
//  The following mscat32.dll APIs are called to find the system catalog file:
//      CryptCATAdminAcquireContext
//      CryptCATAdminReleaseContext
//      CryptCATAdminEnumCatalogFromHash
//      CryptCATAdminReleaseCatalogContext
//      CryptCATCatalogInfoFromContext
//
//  If the hash was successfully verified, rglErr[] is set to ERROR_SUCCESS.
//  Otherwise, rglErr[] is set to a nonzero error code.
//
//  The caller can request one or more catalog subject attribute,
//  extension or signer authenticated attribute values to be returned for
//  each hash.  The still encoded values are returned in the
//  caller allocated memory. The beginning of this returned memory will
//  be set to a 2 dimensional array of attribute value blobs pointing to these
//  encoded values (CRYPT_DER_BLOB rgrgAttrValueBlob[cHash][cAttrOID]).
//  The caller should make every attempt to allow for a
//  single pass call. The necessary memory size is:
//      (cHash * cAttrOID * sizeof(CRYPT_DER_BLOB)) +
//          total length of encoded attribute values.
//
//  *pcbAttr will be updated with the number of bytes required to contain
//  the attribute blobs and values. If the input memory is insufficient,
//  ERROR_INSUFFICIENT_BUFFER will be returned if no other error.
//
//  For a multi-valued attribute, only the first value is returned.
//
//  If the function succeeds, the return value is ERROR_SUCCESS. This may
//  be returned for unsuccessful rglErr[] values. Otherwise,
//  a nonzero error code is returned.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptVerifyHashInSystemCatalogs(
    IN ALG_ID HashAlgId,
    IN DWORD cHash,
    IN CRYPT_HASH_BLOB rgHashBlob[],
    OUT LONG rglErr[],

    IN OPTIONAL DWORD cAttrOID,
    IN OPTIONAL CRYPT_DER_BLOB rgAttrEncodedOIDBlob[],
    // CRYPT_DER_BLOB rgrgAttrValueBlob[cHash][cAttrOID] header is at beginning
    // with the bytes pointed to immediately following
    OUT OPTIONAL CRYPT_DER_BLOB *rgrgAttrValueBlob,
    IN OUT OPTIONAL DWORD *pcbAttr
    )
{
    LONG lErr;
    DWORD cMapCatInfo = 0;
    MAP_CAT_INFO rgMapCatInfo[MAX_CAT_FILE_CNT];
    DWORD iMapCat;

    //**********************************************************************
    //  WARNING!!!!
    //
    //  The following function calls into other DLLs such as, kernel32.dll
    //  and wintrust.dll to find and map the system catalog files. The input
    //  array of hashes must be protected!!
    //
    //  After returning we won't be calling into other DLLs until
    //  UnmapViewOfFile is called in CommonReturn.
    //  
    //**********************************************************************

    // Note, rglErr[] is overloaded and also used to contain the indices
    // into rgMapCatInfo for each corresponding hash.
    lErr = I_GetAndMapSystemCatalogs(
            HashAlgId,
            cHash,
            rgHashBlob,
            rglErr,
            &cMapCatInfo,
            rgMapCatInfo
            );
    if (ERROR_SUCCESS != lErr)
        goto ErrorReturn;

    __try {
        DWORD cbAttr = 0;
        LONG lRemainExtra = 0;
        BYTE *pbExtra = NULL;
        DWORD iHash;

        if (0 != cAttrOID && 0 != cHash) {
            if (rgrgAttrValueBlob)
                cbAttr = *pcbAttr;

            lRemainExtra = cbAttr - sizeof(CRYPT_DER_BLOB) * cAttrOID * cHash;
            if (0 <= lRemainExtra) {
                memset(rgrgAttrValueBlob, 0,
                    sizeof(CRYPT_DER_BLOB) * cAttrOID * cHash);
                pbExtra = (BYTE *) &rgrgAttrValueBlob[cAttrOID * cHash];
            }
        }

        I_VerifyMappedSystemCatalogs(
            cMapCatInfo,
            rgMapCatInfo
            );

        for (iHash = 0; iHash < cHash; iHash++) {
            LONG lMapCatIdx = rglErr[iHash];
            CRYPT_DER_BLOB CTLSubjectAttrsValueBlob;

            rglErr[iHash] = I_FindHashInMappedSystemCatalogs(
                HashAlgId,
                &rgHashBlob[iHash],
                cMapCatInfo,
                rgMapCatInfo,
                &lMapCatIdx,
                &CTLSubjectAttrsValueBlob
                );

            if (0 != cAttrOID && ERROR_SUCCESS == rglErr[iHash]) {
                assert(0 <= lMapCatIdx && (DWORD) lMapCatIdx < cMapCatInfo);
                I_GetHashAttributes(
                    cAttrOID,
                    rgAttrEncodedOIDBlob,
                    &CTLSubjectAttrsValueBlob,
                    &rgMapCatInfo[lMapCatIdx].CTLExtsValueBlob,
                    &rgMapCatInfo[lMapCatIdx].SignerAuthAttrsValueBlob,
                    0 <= lRemainExtra ?
                        &rgrgAttrValueBlob[cAttrOID * iHash] : NULL,
                    &lRemainExtra,
                    &pbExtra
                    );
            }
        }

        if (0 != cAttrOID && 0 != cHash) {
            if (0 <= lRemainExtra)
                *pcbAttr = cbAttr - (DWORD) lRemainExtra;
            else {
                *pcbAttr = cbAttr + (DWORD) -lRemainExtra;
                goto InsufficientBuffer;
            }
        }

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        lErr = GetExceptionCode();
        if (ERROR_SUCCESS == lErr)
            lErr = E_UNEXPECTED;
        goto ErrorReturn;
    }
    lErr = ERROR_SUCCESS;

CommonReturn:
    //**********************************************************************
    //  WARNING!!!!
    //
    //  UnmapViewOfFile is in another DLL, kernel32.dll.
    //  lErr and the return error for each hash in rglErr[] must be protected.
    //  
    //**********************************************************************
    for (iMapCat = 0; iMapCat < cMapCatInfo; iMapCat++)
        UnmapViewOfFile(rgMapCatInfo[iMapCat].FileBlob.pbData);

    return lErr;

ErrorReturn:
    assert(ERROR_SUCCESS != lErr);
    if (ERROR_INSUFFICIENT_BUFFER == lErr)
        // This error can only be set when we determine that the attribute
        // buffer isn't big enough.
        lErr = E_UNEXPECTED;
    goto CommonReturn;

InsufficientBuffer:
    lErr = ERROR_INSUFFICIENT_BUFFER;
    // Don't goto ErrorReturn. It explicitly checks that noone else can
    // set this error
    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\mincrypt\lib\verfile.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       verfile.cpp
//
//  Contents:   Minimal Cryptographic functions to hash files and verify
//              Authenticode signed files.
//              message
//
//  Functions:  MinCryptHashFile
//              MinCryptVerifySignedFile
//
//  History:    21-Jan-01    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <md5.h>
#include <sha.h>

#define PE_EXE_HEADER_TAG       "MZ"
#define MIN_PE_FILE_LEN         4

#define MAX_SIGNED_FILE_AUTH_ATTR_CNT   10

typedef struct _DIGEST_DATA {
    ALG_ID      AlgId;
    void        *pvSHA1orMD5Ctx;
} DIGEST_DATA, *PDIGEST_DATA;

// #define SPC_INDIRECT_DATA_OBJID "1.3.6.1.4.1.311.2.1.4"
const BYTE rgbSPC_INDIRECT_DATA_OBJID[] =
    {0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x04};

BOOL
WINAPI
I_DigestFunction(
    DIGEST_HANDLE refdata,
    PBYTE pbData,
    DWORD cbData
    )
{
    PDIGEST_DATA pDigestData = (PDIGEST_DATA) refdata;

    switch (pDigestData->AlgId)
    {
        case CALG_MD5:
            MD5Update((MD5_CTX *)pDigestData->pvSHA1orMD5Ctx, pbData, cbData);
            return(TRUE);

        case CALG_SHA1:
            A_SHAUpdate((A_SHA_CTX *)pDigestData->pvSHA1orMD5Ctx, pbData,
                cbData);
            return(TRUE);
    }
    return FALSE;
}

BOOL
WINAPI
I_IsNtPe32File(
    IN PCRYPT_DATA_BLOB pFileBlob
    )
{
    const BYTE *pbFile = pFileBlob->pbData;
    DWORD cbFile = pFileBlob->cbData;

    if (MIN_PE_FILE_LEN > cbFile)
        return FALSE;

    if (0 != memcmp(&pbFile[0], PE_EXE_HEADER_TAG, strlen(PE_EXE_HEADER_TAG)))
        return FALSE;

    //  Make sure it is a 32 bit PE
    if (sizeof(IMAGE_DOS_HEADER) > cbFile)
        return FALSE;
    else {
        IMAGE_DOS_HEADER *pDosHead = (IMAGE_DOS_HEADER *) pbFile;

        if (pDosHead->e_magic != IMAGE_DOS_SIGNATURE)
            return FALSE;

        if (cbFile < (sizeof(IMAGE_DOS_HEADER) + pDosHead->e_lfanew))
            return FALSE;
        else {
            IMAGE_NT_HEADERS *pNTHead =
                (IMAGE_NT_HEADERS *)((ULONG_PTR)pDosHead + pDosHead->e_lfanew);

            if (pNTHead->Signature != IMAGE_NT_SIGNATURE)
                return FALSE;
        }
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//  Hashes the file according to the Hash ALG_ID.
//
//  According to dwFileType, pvFile can be a pwszFilename, hFile or pFileBlob.
//  Only requires READ access.
//
//  dwFileType:
//      MINCRYPT_FILE_NAME      : pvFile - LPCWSTR pwszFilename
//      MINCRYPT_FILE_HANDLE    : pvFile - HANDLE hFile
//      MINCRYPT_FILE_BLOB      : pvFile - PCRYPT_DATA_BLOB pFileBlob
//
//  rgbHash is updated with the resultant hash. *pcbHash is updated with
//  the length associated with the hash algorithm.
//
//  If the function succeeds, the return value is ERROR_SUCCESS. Otherwise,
//  a nonzero error code is returned.
//
//  Only CALG_SHA1 and CALG_MD5 are supported.
//
//  If a NT PE 32 bit file format, hashed according to imagehlp rules, ie, skip
//  section containing potential signature, ... . Otherwise, the entire file
//  is hashed.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptHashFile(
    IN DWORD dwFileType,
    IN const VOID *pvFile,
    IN ALG_ID HashAlgId,
    OUT BYTE rgbHash[MINCRYPT_MAX_HASH_LEN],
    OUT DWORD *pcbHash
    )
{
    LONG lErr;
    CRYPT_DATA_BLOB FileBlob = {0, NULL};
    DIGEST_DATA DigestData;
    A_SHA_CTX ShaCtx;
    MD5_CTX Md5Ctx;

    __try {
        lErr = I_MinCryptMapFile(
            dwFileType,
            pvFile,
            &FileBlob
            );
        if (ERROR_SUCCESS != lErr)
            goto ErrorReturn;

        if (!I_IsNtPe32File(&FileBlob)) {
            // Hash the entire file
            lErr = MinCryptHashMemory(
                HashAlgId,
                1,              // cBlob
                &FileBlob,
                rgbHash,
                pcbHash
                );
            goto CommonReturn;
        }

        DigestData.AlgId = HashAlgId;
        switch (HashAlgId) {
            case CALG_MD5:
                DigestData.pvSHA1orMD5Ctx = &Md5Ctx;
                MD5Init(&Md5Ctx);
                break;

            case CALG_SHA1:
                DigestData.pvSHA1orMD5Ctx = &ShaCtx;
                A_SHAInit(&ShaCtx);
                break;

            default:
                goto InvalidHashAlgId;
        }

        if (!imagehack_ImageGetDigestStream(
                &FileBlob,
                0,                  // DigestLevel, ignored
                I_DigestFunction,
                &DigestData
                ))
            goto DigestStreamError;
        else {
            DWORD dwPadBeforeCerts;

            dwPadBeforeCerts = (FileBlob.cbData + 7) & ~7;
            dwPadBeforeCerts -= FileBlob.cbData;

            if (0 < dwPadBeforeCerts) {
                BYTE rgb[8];
                // imagehlp put nulls before the signature!
                memset(rgb, 0x00, dwPadBeforeCerts);

                if (!I_DigestFunction(&DigestData, rgb, dwPadBeforeCerts))
                    goto DigestFunctionError;
            }
        }

        switch (HashAlgId) {
            case CALG_MD5:
                MD5Final(&Md5Ctx);
                memcpy(rgbHash, Md5Ctx.digest, MD5DIGESTLEN);
                *pcbHash = MINCRYPT_MD5_HASH_LEN;
                break;

            case CALG_SHA1:
                A_SHAFinal(&ShaCtx, rgbHash);
                *pcbHash = MINCRYPT_SHA1_HASH_LEN;
                break;

            default:
                goto InvalidHashAlgId;
        }

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        lErr = GetExceptionCode();
        if (ERROR_SUCCESS == lErr)
            lErr = E_UNEXPECTED;
        goto ErrorReturn;
    }

    lErr = ERROR_SUCCESS;

CommonReturn:
    //**********************************************************************
    //  WARNING!!!!
    //
    //  UnmapViewOfFile is in another DLL, kernel32.dll.
    //  lErr and the return hash in rgbHash[] must be protected.
    //  
    //**********************************************************************
    if (MINCRYPT_FILE_BLOB != dwFileType && NULL != FileBlob.pbData)
        UnmapViewOfFile(FileBlob.pbData);
    return lErr;

ErrorReturn:
    *pcbHash = 0;
    goto CommonReturn;

InvalidHashAlgId:
    lErr = NTE_BAD_ALGID;
    goto ErrorReturn;

DigestStreamError:
DigestFunctionError:
    lErr = NTE_BAD_HASH;
    goto ErrorReturn;
}


// Only called when cAttrOID != 0
LONG
WINAPI
I_GetAuthAttributes(
    IN PCRYPT_DER_BLOB pAttrsValueBlob,
    IN DWORD cAttrOID,
    IN CRYPT_DER_BLOB rgAttrEncodedOIDBlob[],
    // CRYPT_DER_BLOB rgAttrBlob[cAttrOID] header is at beginning
    // with the bytes pointed to immediately following
    OUT OPTIONAL CRYPT_DER_BLOB *rgAttrValueBlob,
    IN OUT DWORD *pcbAttr
    )
{
    LONG lErr;
    DWORD i;
    LONG lRemainExtra;
    BYTE *pbExtra;
    DWORD cbAttr;

    CRYPT_DER_BLOB rgrgAttrBlob[MAX_SIGNED_FILE_AUTH_ATTR_CNT][MINASN1_ATTR_BLOB_CNT];
    DWORD cAttr;

    assert(0 != cAttrOID);

    if (rgAttrValueBlob)
        cbAttr = *pcbAttr;
    else
        cbAttr = 0;

    lRemainExtra = cbAttr - sizeof(CRYPT_DER_BLOB) * cAttrOID;
    if (0 <= lRemainExtra) {
        memset(rgAttrValueBlob, 0, sizeof(CRYPT_DER_BLOB) * cAttrOID);
        pbExtra = (BYTE *) &rgAttrValueBlob[cAttrOID];
    } else
        pbExtra = NULL;

    // Parse the authenticated attributes
    cAttr = MAX_SIGNED_FILE_AUTH_ATTR_CNT;
    if (0 >= MinAsn1ParseAttributes(
            pAttrsValueBlob,
            &cAttr,
            rgrgAttrBlob))
        cAttr = 0;

    for (i = 0; i < cAttrOID; i++) {
        PCRYPT_DER_BLOB rgFindAttrBlob;

        rgFindAttrBlob = MinAsn1FindAttribute(
            &rgAttrEncodedOIDBlob[i],
            cAttr,
            rgrgAttrBlob
            );
        if (rgFindAttrBlob) {
            PCRYPT_DER_BLOB pFindAttrValue =
                &rgFindAttrBlob[MINASN1_ATTR_VALUE_IDX];
            const BYTE *pbFindValue = pFindAttrValue->pbData;
            DWORD cbFindValue = pFindAttrValue->cbData;

            if (0 < cbFindValue) {
                lRemainExtra -= cbFindValue;
                if (0 <= lRemainExtra) {
                    rgAttrValueBlob[i].pbData = pbExtra;
                    rgAttrValueBlob[i].cbData = cbFindValue;

                    memcpy(pbExtra, pbFindValue, cbFindValue);
                    pbExtra += cbFindValue;
                }
            }
        }
    }

    if (0 <= lRemainExtra) {
        *pcbAttr = cbAttr - (DWORD) lRemainExtra;
        lErr = ERROR_SUCCESS;
    } else {
        *pcbAttr = cbAttr + (DWORD) -lRemainExtra;
        lErr = ERROR_INSUFFICIENT_BUFFER;
    }

    return lErr;
}

//+-------------------------------------------------------------------------
//  Verifies a previously signed file.
//
//  According to dwFileType, pvFile can be a pwszFilename, hFile or pFileBlob.
//  Only requires READ access.
//
//  dwFileType:
//      MINCRYPT_FILE_NAME      : pvFile - LPCWSTR pwszFilename
//      MINCRYPT_FILE_HANDLE    : pvFile - HANDLE hFile
//      MINCRYPT_FILE_BLOB      : pvFile - PCRYPT_DATA_BLOB pFileBlob
//
//  Checks if the file has an embedded PKCS #7 Signed Data message containing
//  Indirect Data. The PKCS #7 is verified via MinCryptVerifySignedData().
//  The Indirect Data is parsed via MinAsn1ParseIndirectData() to get the
//  HashAlgId and the file hash.  MinCryptHashFile() is called to hash the
//  file. The returned hash is compared against the Indirect Data's hash.
//
//  The caller can request one or more signer authenticated attribute values
//  to be returned. The still encoded values are returned in the
//  caller allocated memory. The beginning of this returned memory will
//  be set to an array of attribute value blobs pointing to these
//  encoded values. The caller should make every attempt to allow for a
//  single pass call. The necessary memory size is:
//      (cAttrOID * sizeof(CRYPT_DER_BLOB)) +
//          total length of encoded attribute values.
//
//  *pcbAttr will be updated with the number of bytes required to contain
//  the attribute blobs and values. If the input memory is insufficient,
//  ERROR_INSUFFICIENT_BUFFER will be returned if no other error.
//
//  For the multi-valued attributes, only the first value is returned.
//
//  If the function succeeds, the return value is ERROR_SUCCESS. Otherwise,
//  a nonzero error code is returned.
//
//  Only NT, PE 32 bit file formats are supported.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptVerifySignedFile(
    IN DWORD dwFileType,
    IN const VOID *pvFile,

    IN OPTIONAL DWORD cAttrOID,
    IN OPTIONAL CRYPT_DER_BLOB rgAttrEncodedOIDBlob[],
    // CRYPT_DER_BLOB rgAttrBlob[cAttrOID] header is at beginning
    // with the bytes pointed to immediately following
    OUT OPTIONAL CRYPT_DER_BLOB *rgAttrValueBlob,
    IN OUT OPTIONAL DWORD *pcbAttr
    )
{
    LONG lErr;
    CRYPT_DATA_BLOB FileBlob = {0, NULL};

    __try {
        LPWIN_CERTIFICATE pCertHdr = NULL;
        const BYTE *pbEncodedSignedData;
        DWORD cbEncodedSignedData;
        CRYPT_DER_BLOB rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_BLOB_CNT];
        CRYPT_DER_BLOB rgIndirectDataBlob[MINASN1_INDIRECT_DATA_BLOB_CNT];
        ALG_ID HashAlgId;
        BYTE rgbHash[MINCRYPT_MAX_HASH_LEN];
        DWORD cbHash;

        lErr = I_MinCryptMapFile(
            dwFileType,
            pvFile,
            &FileBlob
            );
        if (ERROR_SUCCESS != lErr)
            goto ErrorReturn;

        if (!I_IsNtPe32File(&FileBlob))
            goto NotNtPe32File;

        if (!imagehack_ImageGetCertificateData(
                &FileBlob,
                0,              // CertificateIndex
                &pCertHdr
                ))
            goto NoSignature;

        if (WIN_CERT_REVISION_2_0 != pCertHdr->wRevision ||
                WIN_CERT_TYPE_PKCS_SIGNED_DATA != pCertHdr->wCertificateType)
            goto UnsupportedSignature;

        if (offsetof(WIN_CERTIFICATE, bCertificate) > pCertHdr->dwLength)
            goto InvalidSignature;

        cbEncodedSignedData = pCertHdr->dwLength -
            offsetof(WIN_CERTIFICATE, bCertificate);
        pbEncodedSignedData = pCertHdr->bCertificate;

        lErr = MinCryptVerifySignedData(
            pbEncodedSignedData,
            cbEncodedSignedData,
            rgVerSignedDataBlob
            );
        if (ERROR_SUCCESS != lErr)
            goto ErrorReturn;

        // The data content should be Indirect Data
        if (sizeof(rgbSPC_INDIRECT_DATA_OBJID) !=
                rgVerSignedDataBlob[
                    MINCRYPT_VER_SIGNED_DATA_CONTENT_OID_IDX].cbData
                        ||
                0 != memcmp(rgbSPC_INDIRECT_DATA_OBJID,
                        rgVerSignedDataBlob[
                            MINCRYPT_VER_SIGNED_DATA_CONTENT_OID_IDX].pbData,
                        sizeof(rgbSPC_INDIRECT_DATA_OBJID)))
            goto NotIndirectDataOID;

        if (0 >= MinAsn1ParseIndirectData(
                &rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_CONTENT_DATA_IDX],
                rgIndirectDataBlob
                ))
            goto ParseIndirectDataError;

        HashAlgId = MinCryptDecodeHashAlgorithmIdentifier(
            &rgIndirectDataBlob[MINASN1_INDIRECT_DATA_DIGEST_ALGID_IDX]
            );
        if (0 == HashAlgId)
            goto UnknownHashAlgId;

        lErr = MinCryptHashFile(
            MINCRYPT_FILE_BLOB,
            (const VOID *) &FileBlob,
            HashAlgId,
            rgbHash,
            &cbHash
            );
        if (ERROR_SUCCESS != lErr)
            goto ErrorReturn;

        // Check that the hash in the indirect data matches the file hash
        if (cbHash !=
                rgIndirectDataBlob[MINASN1_INDIRECT_DATA_DIGEST_IDX].cbData
                        ||
                0 != memcmp(rgbHash,
                    rgIndirectDataBlob[MINASN1_INDIRECT_DATA_DIGEST_IDX].pbData,
                    cbHash))
            goto InvalidFileHash;

        if (cAttrOID)
            lErr = I_GetAuthAttributes(
                &rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_AUTH_ATTRS_IDX],
                cAttrOID,
                rgAttrEncodedOIDBlob,
                rgAttrValueBlob,
                pcbAttr
                );
        else
            lErr = ERROR_SUCCESS;

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        lErr = GetExceptionCode();
        if (ERROR_SUCCESS == lErr)
            lErr = E_UNEXPECTED;
        goto ErrorReturn;
    }

CommonReturn:
    //**********************************************************************
    //  WARNING!!!!
    //
    //  UnmapViewOfFile is in another DLL, kernel32.dll.
    //  lErr must be protected.
    //  
    //**********************************************************************
    if (MINCRYPT_FILE_BLOB != dwFileType && NULL != FileBlob.pbData)
        UnmapViewOfFile(FileBlob.pbData);
    return lErr;

ErrorReturn:
    assert(ERROR_SUCCESS != lErr);
    if (ERROR_INSUFFICIENT_BUFFER == lErr)
        // This error can only be set when we determine that the attribute
        // buffer isn't big enough.
        lErr = E_UNEXPECTED;
    goto CommonReturn;

NotNtPe32File:
    lErr = ERROR_NOT_SUPPORTED;
    goto ErrorReturn;

NoSignature:
UnsupportedSignature:
InvalidSignature:
    lErr = TRUST_E_NOSIGNATURE;
    goto ErrorReturn;

NotIndirectDataOID:
ParseIndirectDataError:
    lErr = CRYPT_E_BAD_MSG;
    goto ErrorReturn;

UnknownHashAlgId:
    lErr = CRYPT_E_UNKNOWN_ALGO;
    goto ErrorReturn;

InvalidFileHash:
    lErr = CRYPT_E_HASH_VALUE;
    goto ErrorReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\mincrypt\test\tminver\licexample.cpp ===
//+-------------------------------------------------------------------------
//  File:       licexample.cpp
//
//  Contents:   An example calling the minasn1 and mincrypt APIs to parse
//              the certificates in a PKCS #7 Signed Data, find a certificate
//              having the license extension and validate this certificate
//              up to a baked in and trusted root. Returns a pointer
//              to the license data within the verified certificate.
//--------------------------------------------------------------------------

#include <windows.h>
#include "minasn1.h"
#include "mincrypt.h"

#define MAX_LICENSE_CERT_CNT    20
#define MAX_LICENSE_EXT_CNT     20

// #define szOID_ESL_LICENSE_EXT "1.3.6.1.4.1.311.41.3"
const BYTE rgbOID_ESL_LICENSE_EXT[] =
    {0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x29, 0x03};
const CRYPT_DER_BLOB ESL_LICENSE_EXTEncodedOIDBlob = {
    sizeof(rgbOID_ESL_LICENSE_EXT), 
    (BYTE *) rgbOID_ESL_LICENSE_EXT
};


// Returns ERROR_SUCCESS if able to find and successfully verify the
// certificate containing the license data. Returns pointer to the
// license data bytes in the encoded data.
LONG
GetAndVerifyLicenseDataFromPKCS7SignedData(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT const BYTE **ppbLicenseData,
    OUT DWORD *pcbLicenseData
    )
{
    LONG lErr;
    const BYTE *pbLicenseData;
    DWORD cbLicenseData;
    DWORD cCert;
    CRYPT_DER_BLOB rgrgCertBlob[MAX_LICENSE_CERT_CNT][MINASN1_CERT_BLOB_CNT];
    PCRYPT_DER_BLOB rgLicenseCertBlob;
    DWORD iCert;

    // Parse the PKCS #7 to get the bag of certs.
    cCert = MAX_LICENSE_CERT_CNT;
    if (0 >= MinAsn1ExtractParsedCertificatesFromSignedData(
            pbEncoded,
            cbEncoded,
            &cCert,
            rgrgCertBlob
            ))
        goto ParseError;

    // Loop through the certs. Parse the cert's extensions. Attempt to
    // find the license extension.
    rgLicenseCertBlob = NULL;
    for (iCert = 0; iCert < cCert; iCert++) {
        DWORD cExt;
        CRYPT_DER_BLOB rgrgExtBlob[MAX_LICENSE_EXT_CNT][MINASN1_EXT_BLOB_CNT];
        PCRYPT_DER_BLOB rgLicenseExtBlob;

        cExt = MAX_LICENSE_EXT_CNT;
        if (0 >= MinAsn1ParseExtensions(
                &rgrgCertBlob[iCert][MINASN1_CERT_EXTS_IDX],
                &cExt,
                rgrgExtBlob
                ))
            continue;

        rgLicenseExtBlob = MinAsn1FindExtension(
            (PCRYPT_DER_BLOB) &ESL_LICENSE_EXTEncodedOIDBlob,
            cExt,
            rgrgExtBlob
            );

        if (NULL != rgLicenseExtBlob) {
            pbLicenseData = rgLicenseExtBlob[MINASN1_EXT_VALUE_IDX].pbData;
            cbLicenseData = rgLicenseExtBlob[MINASN1_EXT_VALUE_IDX].cbData;
            rgLicenseCertBlob = rgrgCertBlob[iCert];

            break;
        }
    }

    if (NULL == rgLicenseCertBlob)
        goto NoLicenseCert;

    // Verify the License certificate chain to a baked in trusted root.
    lErr = MinCryptVerifyCertificate(
        rgLicenseCertBlob,
        cCert,
        rgrgCertBlob
        );

CommonReturn:
    *ppbLicenseData = pbLicenseData;
    *pcbLicenseData = cbLicenseData;
    return lErr;

ErrorReturn:
    pbLicenseData = NULL;
    cbLicenseData = 0;
    goto CommonReturn;

ParseError:
    lErr = CRYPT_E_BAD_MSG;
    goto ErrorReturn;

NoLicenseCert:
    lErr = ERROR_NOT_FOUND;
    goto ErrorReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\mincrypt\lib\vercert.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       vercert.cpp
//
//  Contents:   Minimal Cryptographic functions to verify ASN.1 encoded
//              X.509 certificates
//
//
//  Functions:  MinCryptVerifyCertificate
//
//  History:    17-Jan-01    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"

#define MAX_CHAIN_DEPTH             10

// #define USE_TEST_ROOTS_FOR_TESTING  1


//+=========================================================================
//  Microsoft Roots
//-=========================================================================

// Name:: <CN=Microsoft Authenticode(tm) Root Authority, O=MSFT, C=US>
const BYTE rgbMicrosoftRoot0_Name[] = {
    0x30, 0x50, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03,
    0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31,
    0x0D, 0x30, 0x0B, 0x06, 0x03, 0x55, 0x04, 0x0A,
    0x13, 0x04, 0x4D, 0x53, 0x46, 0x54, 0x31, 0x32,
    0x30, 0x30, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13,
    0x29, 0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F,
    0x66, 0x74, 0x20, 0x41, 0x75, 0x74, 0x68, 0x65,
    0x6E, 0x74, 0x69, 0x63, 0x6F, 0x64, 0x65, 0x28,
    0x74, 0x6D, 0x29, 0x20, 0x52, 0x6F, 0x6F, 0x74,
    0x20, 0x41, 0x75, 0x74, 0x68, 0x6F, 0x72, 0x69,
    0x74, 0x79
};
const BYTE rgbMicrosoftRoot0_PubKeyInfo[]= {
    0x30, 0x82, 0x01, 0x22, 0x30, 0x0D, 0x06, 0x09,
    0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01,
    0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0F, 0x00,
    0x30, 0x82, 0x01, 0x0A, 0x02, 0x82, 0x01, 0x01,
    0x00, 0xDF, 0x08, 0xBA, 0xE3, 0x3F, 0x6E, 0x64,
    0x9B, 0xF5, 0x89, 0xAF, 0x28, 0x96, 0x4A, 0x07,
    0x8F, 0x1B, 0x2E, 0x8B, 0x3E, 0x1D, 0xFC, 0xB8,
    0x80, 0x69, 0xA3, 0xA1, 0xCE, 0xDB, 0xDF, 0xB0,
    0x8E, 0x6C, 0x89, 0x76, 0x29, 0x4F, 0xCA, 0x60,
    0x35, 0x39, 0xAD, 0x72, 0x32, 0xE0, 0x0B, 0xAE,
    0x29, 0x3D, 0x4C, 0x16, 0xD9, 0x4B, 0x3C, 0x9D,
    0xDA, 0xC5, 0xD3, 0xD1, 0x09, 0xC9, 0x2C, 0x6F,
    0xA6, 0xC2, 0x60, 0x53, 0x45, 0xDD, 0x4B, 0xD1,
    0x55, 0xCD, 0x03, 0x1C, 0xD2, 0x59, 0x56, 0x24,
    0xF3, 0xE5, 0x78, 0xD8, 0x07, 0xCC, 0xD8, 0xB3,
    0x1F, 0x90, 0x3F, 0xC0, 0x1A, 0x71, 0x50, 0x1D,
    0x2D, 0xA7, 0x12, 0x08, 0x6D, 0x7C, 0xB0, 0x86,
    0x6C, 0xC7, 0xBA, 0x85, 0x32, 0x07, 0xE1, 0x61,
    0x6F, 0xAF, 0x03, 0xC5, 0x6D, 0xE5, 0xD6, 0xA1,
    0x8F, 0x36, 0xF6, 0xC1, 0x0B, 0xD1, 0x3E, 0x69,
    0x97, 0x48, 0x72, 0xC9, 0x7F, 0xA4, 0xC8, 0xC2,
    0x4A, 0x4C, 0x7E, 0xA1, 0xD1, 0x94, 0xA6, 0xD7,
    0xDC, 0xEB, 0x05, 0x46, 0x2E, 0xB8, 0x18, 0xB4,
    0x57, 0x1D, 0x86, 0x49, 0xDB, 0x69, 0x4A, 0x2C,
    0x21, 0xF5, 0x5E, 0x0F, 0x54, 0x2D, 0x5A, 0x43,
    0xA9, 0x7A, 0x7E, 0x6A, 0x8E, 0x50, 0x4D, 0x25,
    0x57, 0xA1, 0xBF, 0x1B, 0x15, 0x05, 0x43, 0x7B,
    0x2C, 0x05, 0x8D, 0xBD, 0x3D, 0x03, 0x8C, 0x93,
    0x22, 0x7D, 0x63, 0xEA, 0x0A, 0x57, 0x05, 0x06,
    0x0A, 0xDB, 0x61, 0x98, 0x65, 0x2D, 0x47, 0x49,
    0xA8, 0xE7, 0xE6, 0x56, 0x75, 0x5C, 0xB8, 0x64,
    0x08, 0x63, 0xA9, 0x30, 0x40, 0x66, 0xB2, 0xF9,
    0xB6, 0xE3, 0x34, 0xE8, 0x67, 0x30, 0xE1, 0x43,
    0x0B, 0x87, 0xFF, 0xC9, 0xBE, 0x72, 0x10, 0x5E,
    0x23, 0xF0, 0x9B, 0xA7, 0x48, 0x65, 0xBF, 0x09,
    0x88, 0x7B, 0xCD, 0x72, 0xBC, 0x2E, 0x79, 0x9B,
    0x7B, 0x02, 0x03, 0x01, 0x00, 0x01
};


// Name:: <CN=Microsoft Root Authority, OU=Microsoft Corporation,
//         OU=Copyright (c) 1997 Microsoft Corp.>
const BYTE rgbMicrosoftRoot1_Name[]= {
    0x30, 0x70, 0x31, 0x2B, 0x30, 0x29, 0x06, 0x03,
    0x55, 0x04, 0x0B, 0x13, 0x22, 0x43, 0x6F, 0x70,
    0x79, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x28,
    0x63, 0x29, 0x20, 0x31, 0x39, 0x39, 0x37, 0x20,
    0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F, 0x66,
    0x74, 0x20, 0x43, 0x6F, 0x72, 0x70, 0x2E, 0x31,
    0x1E, 0x30, 0x1C, 0x06, 0x03, 0x55, 0x04, 0x0B,
    0x13, 0x15, 0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73,
    0x6F, 0x66, 0x74, 0x20, 0x43, 0x6F, 0x72, 0x70,
    0x6F, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x31,
    0x21, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x04, 0x03,
    0x13, 0x18, 0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73,
    0x6F, 0x66, 0x74, 0x20, 0x52, 0x6F, 0x6F, 0x74,
    0x20, 0x41, 0x75, 0x74, 0x68, 0x6F, 0x72, 0x69,
    0x74, 0x79
};

const BYTE rgbMicrosoftRoot1_PubKeyInfo[]= {
    0x30, 0x82, 0x01, 0x22, 0x30, 0x0D, 0x06, 0x09,
    0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01,
    0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0F, 0x00,
    0x30, 0x82, 0x01, 0x0A, 0x02, 0x82, 0x01, 0x01,
    0x00, 0xA9, 0x02, 0xBD, 0xC1, 0x70, 0xE6, 0x3B,
    0xF2, 0x4E, 0x1B, 0x28, 0x9F, 0x97, 0x78, 0x5E,
    0x30, 0xEA, 0xA2, 0xA9, 0x8D, 0x25, 0x5F, 0xF8,
    0xFE, 0x95, 0x4C, 0xA3, 0xB7, 0xFE, 0x9D, 0xA2,
    0x20, 0x3E, 0x7C, 0x51, 0xA2, 0x9B, 0xA2, 0x8F,
    0x60, 0x32, 0x6B, 0xD1, 0x42, 0x64, 0x79, 0xEE,
    0xAC, 0x76, 0xC9, 0x54, 0xDA, 0xF2, 0xEB, 0x9C,
    0x86, 0x1C, 0x8F, 0x9F, 0x84, 0x66, 0xB3, 0xC5,
    0x6B, 0x7A, 0x62, 0x23, 0xD6, 0x1D, 0x3C, 0xDE,
    0x0F, 0x01, 0x92, 0xE8, 0x96, 0xC4, 0xBF, 0x2D,
    0x66, 0x9A, 0x9A, 0x68, 0x26, 0x99, 0xD0, 0x3A,
    0x2C, 0xBF, 0x0C, 0xB5, 0x58, 0x26, 0xC1, 0x46,
    0xE7, 0x0A, 0x3E, 0x38, 0x96, 0x2C, 0xA9, 0x28,
    0x39, 0xA8, 0xEC, 0x49, 0x83, 0x42, 0xE3, 0x84,
    0x0F, 0xBB, 0x9A, 0x6C, 0x55, 0x61, 0xAC, 0x82,
    0x7C, 0xA1, 0x60, 0x2D, 0x77, 0x4C, 0xE9, 0x99,
    0xB4, 0x64, 0x3B, 0x9A, 0x50, 0x1C, 0x31, 0x08,
    0x24, 0x14, 0x9F, 0xA9, 0xE7, 0x91, 0x2B, 0x18,
    0xE6, 0x3D, 0x98, 0x63, 0x14, 0x60, 0x58, 0x05,
    0x65, 0x9F, 0x1D, 0x37, 0x52, 0x87, 0xF7, 0xA7,
    0xEF, 0x94, 0x02, 0xC6, 0x1B, 0xD3, 0xBF, 0x55,
    0x45, 0xB3, 0x89, 0x80, 0xBF, 0x3A, 0xEC, 0x54,
    0x94, 0x4E, 0xAE, 0xFD, 0xA7, 0x7A, 0x6D, 0x74,
    0x4E, 0xAF, 0x18, 0xCC, 0x96, 0x09, 0x28, 0x21,
    0x00, 0x57, 0x90, 0x60, 0x69, 0x37, 0xBB, 0x4B,
    0x12, 0x07, 0x3C, 0x56, 0xFF, 0x5B, 0xFB, 0xA4,
    0x66, 0x0A, 0x08, 0xA6, 0xD2, 0x81, 0x56, 0x57,
    0xEF, 0xB6, 0x3B, 0x5E, 0x16, 0x81, 0x77, 0x04,
    0xDA, 0xF6, 0xBE, 0xAE, 0x80, 0x95, 0xFE, 0xB0,
    0xCD, 0x7F, 0xD6, 0xA7, 0x1A, 0x72, 0x5C, 0x3C,
    0xCA, 0xBC, 0xF0, 0x08, 0xA3, 0x22, 0x30, 0xB3,
    0x06, 0x85, 0xC9, 0xB3, 0x20, 0x77, 0x13, 0x85,
    0xDF, 0x02, 0x03, 0x01, 0x00, 0x01
};


// 4096 bit key generated in 2001
//
// Name:: <CN=Microsoft Root Certificate Authority, DC=microsoft, DC=com>
const BYTE rgbMicrosoftRoot2_Name[]= {
    0x30, 0x5F, 0x31, 0x13, 0x30, 0x11, 0x06, 0x0A,
    0x09, 0x92, 0x26, 0x89, 0x93, 0xF2, 0x2C, 0x64,
    0x01, 0x19, 0x16, 0x03, 0x63, 0x6F, 0x6D, 0x31,
    0x19, 0x30, 0x17, 0x06, 0x0A, 0x09, 0x92, 0x26,
    0x89, 0x93, 0xF2, 0x2C, 0x64, 0x01, 0x19, 0x16,
    0x09, 0x6D, 0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F,
    0x66, 0x74, 0x31, 0x2D, 0x30, 0x2B, 0x06, 0x03,
    0x55, 0x04, 0x03, 0x13, 0x24, 0x4D, 0x69, 0x63,
    0x72, 0x6F, 0x73, 0x6F, 0x66, 0x74, 0x20, 0x52,
    0x6F, 0x6F, 0x74, 0x20, 0x43, 0x65, 0x72, 0x74,
    0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20,
    0x41, 0x75, 0x74, 0x68, 0x6F, 0x72, 0x69, 0x74,
    0x79
};
const BYTE rgbMicrosoftRoot2_PubKeyInfo[]= {
    0x30, 0x82, 0x02, 0x22, 0x30, 0x0D, 0x06, 0x09,
    0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01,
    0x01, 0x05, 0x00, 0x03, 0x82, 0x02, 0x0F, 0x00,
    0x30, 0x82, 0x02, 0x0A, 0x02, 0x82, 0x02, 0x01,
    0x00, 0xF3, 0x5D, 0xFA, 0x80, 0x67, 0xD4, 0x5A,
    0xA7, 0xA9, 0x0C, 0x2C, 0x90, 0x20, 0xD0, 0x35,
    0x08, 0x3C, 0x75, 0x84, 0xCD, 0xB7, 0x07, 0x89,
    0x9C, 0x89, 0xDA, 0xDE, 0xCE, 0xC3, 0x60, 0xFA,
    0x91, 0x68, 0x5A, 0x9E, 0x94, 0x71, 0x29, 0x18,
    0x76, 0x7C, 0xC2, 0xE0, 0xC8, 0x25, 0x76, 0x94,
    0x0E, 0x58, 0xFA, 0x04, 0x34, 0x36, 0xE6, 0xDF,
    0xAF, 0xF7, 0x80, 0xBA, 0xE9, 0x58, 0x0B, 0x2B,
    0x93, 0xE5, 0x9D, 0x05, 0xE3, 0x77, 0x22, 0x91,
    0xF7, 0x34, 0x64, 0x3C, 0x22, 0x91, 0x1D, 0x5E,
    0xE1, 0x09, 0x90, 0xBC, 0x14, 0xFE, 0xFC, 0x75,
    0x58, 0x19, 0xE1, 0x79, 0xB7, 0x07, 0x92, 0xA3,
    0xAE, 0x88, 0x59, 0x08, 0xD8, 0x9F, 0x07, 0xCA,
    0x03, 0x58, 0xFC, 0x68, 0x29, 0x6D, 0x32, 0xD7,
    0xD2, 0xA8, 0xCB, 0x4B, 0xFC, 0xE1, 0x0B, 0x48,
    0x32, 0x4F, 0xE6, 0xEB, 0xB8, 0xAD, 0x4F, 0xE4,
    0x5C, 0x6F, 0x13, 0x94, 0x99, 0xDB, 0x95, 0xD5,
    0x75, 0xDB, 0xA8, 0x1A, 0xB7, 0x94, 0x91, 0xB4,
    0x77, 0x5B, 0xF5, 0x48, 0x0C, 0x8F, 0x6A, 0x79,
    0x7D, 0x14, 0x70, 0x04, 0x7D, 0x6D, 0xAF, 0x90,
    0xF5, 0xDA, 0x70, 0xD8, 0x47, 0xB7, 0xBF, 0x9B,
    0x2F, 0x6C, 0xE7, 0x05, 0xB7, 0xE1, 0x11, 0x60,
    0xAC, 0x79, 0x91, 0x14, 0x7C, 0xC5, 0xD6, 0xA6,
    0xE4, 0xE1, 0x7E, 0xD5, 0xC3, 0x7E, 0xE5, 0x92,
    0xD2, 0x3C, 0x00, 0xB5, 0x36, 0x82, 0xDE, 0x79,
    0xE1, 0x6D, 0xF3, 0xB5, 0x6E, 0xF8, 0x9F, 0x33,
    0xC9, 0xCB, 0x52, 0x7D, 0x73, 0x98, 0x36, 0xDB,
    0x8B, 0xA1, 0x6B, 0xA2, 0x95, 0x97, 0x9B, 0xA3,
    0xDE, 0xC2, 0x4D, 0x26, 0xFF, 0x06, 0x96, 0x67,
    0x25, 0x06, 0xC8, 0xE7, 0xAC, 0xE4, 0xEE, 0x12,
    0x33, 0x95, 0x31, 0x99, 0xC8, 0x35, 0x08, 0x4E,
    0x34, 0xCA, 0x79, 0x53, 0xD5, 0xB5, 0xBE, 0x63,
    0x32, 0x59, 0x40, 0x36, 0xC0, 0xA5, 0x4E, 0x04,
    0x4D, 0x3D, 0xDB, 0x5B, 0x07, 0x33, 0xE4, 0x58,
    0xBF, 0xEF, 0x3F, 0x53, 0x64, 0xD8, 0x42, 0x59,
    0x35, 0x57, 0xFD, 0x0F, 0x45, 0x7C, 0x24, 0x04,
    0x4D, 0x9E, 0xD6, 0x38, 0x74, 0x11, 0x97, 0x22,
    0x90, 0xCE, 0x68, 0x44, 0x74, 0x92, 0x6F, 0xD5,
    0x4B, 0x6F, 0xB0, 0x86, 0xE3, 0xC7, 0x36, 0x42,
    0xA0, 0xD0, 0xFC, 0xC1, 0xC0, 0x5A, 0xF9, 0xA3,
    0x61, 0xB9, 0x30, 0x47, 0x71, 0x96, 0x0A, 0x16,
    0xB0, 0x91, 0xC0, 0x42, 0x95, 0xEF, 0x10, 0x7F,
    0x28, 0x6A, 0xE3, 0x2A, 0x1F, 0xB1, 0xE4, 0xCD,
    0x03, 0x3F, 0x77, 0x71, 0x04, 0xC7, 0x20, 0xFC,
    0x49, 0x0F, 0x1D, 0x45, 0x88, 0xA4, 0xD7, 0xCB,
    0x7E, 0x88, 0xAD, 0x8E, 0x2D, 0xEC, 0x45, 0xDB,
    0xC4, 0x51, 0x04, 0xC9, 0x2A, 0xFC, 0xEC, 0x86,
    0x9E, 0x9A, 0x11, 0x97, 0x5B, 0xDE, 0xCE, 0x53,
    0x88, 0xE6, 0xE2, 0xB7, 0xFD, 0xAC, 0x95, 0xC2,
    0x28, 0x40, 0xDB, 0xEF, 0x04, 0x90, 0xDF, 0x81,
    0x33, 0x39, 0xD9, 0xB2, 0x45, 0xA5, 0x23, 0x87,
    0x06, 0xA5, 0x55, 0x89, 0x31, 0xBB, 0x06, 0x2D,
    0x60, 0x0E, 0x41, 0x18, 0x7D, 0x1F, 0x2E, 0xB5,
    0x97, 0xCB, 0x11, 0xEB, 0x15, 0xD5, 0x24, 0xA5,
    0x94, 0xEF, 0x15, 0x14, 0x89, 0xFD, 0x4B, 0x73,
    0xFA, 0x32, 0x5B, 0xFC, 0xD1, 0x33, 0x00, 0xF9,
    0x59, 0x62, 0x70, 0x07, 0x32, 0xEA, 0x2E, 0xAB,
    0x40, 0x2D, 0x7B, 0xCA, 0xDD, 0x21, 0x67, 0x1B,
    0x30, 0x99, 0x8F, 0x16, 0xAA, 0x23, 0xA8, 0x41,
    0xD1, 0xB0, 0x6E, 0x11, 0x9B, 0x36, 0xC4, 0xDE,
    0x40, 0x74, 0x9C, 0xE1, 0x58, 0x65, 0xC1, 0x60,
    0x1E, 0x7A, 0x5B, 0x38, 0xC8, 0x8F, 0xBB, 0x04,
    0x26, 0x7C, 0xD4, 0x16, 0x40, 0xE5, 0xB6, 0x6B,
    0x6C, 0xAA, 0x86, 0xFD, 0x00, 0xBF, 0xCE, 0xC1,
    0x35, 0x02, 0x03, 0x01, 0x00, 0x01
};



#ifdef USE_TEST_ROOTS_FOR_TESTING

//+=========================================================================
//  Test Roots
//-=========================================================================

// Name:: <CN=Microsoft Test Root Authority, OU=Microsoft Corporation, OU=Copyright (c) 1999 Microsoft Corp.>
const BYTE rgbTestRoot0_Name[] = {
    0x30, 0x75, 0x31, 0x2B, 0x30, 0x29, 0x06, 0x03,
    0x55, 0x04, 0x0B, 0x13, 0x22, 0x43, 0x6F, 0x70,
    0x79, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x28,
    0x63, 0x29, 0x20, 0x31, 0x39, 0x39, 0x39, 0x20,
    0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F, 0x66,
    0x74, 0x20, 0x43, 0x6F, 0x72, 0x70, 0x2E, 0x31,
    0x1E, 0x30, 0x1C, 0x06, 0x03, 0x55, 0x04, 0x0B,
    0x13, 0x15, 0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73,
    0x6F, 0x66, 0x74, 0x20, 0x43, 0x6F, 0x72, 0x70,
    0x6F, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x31,
    0x26, 0x30, 0x24, 0x06, 0x03, 0x55, 0x04, 0x03,
    0x13, 0x1D, 0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73,
    0x6F, 0x66, 0x74, 0x20, 0x54, 0x65, 0x73, 0x74,
    0x20, 0x52, 0x6F, 0x6F, 0x74, 0x20, 0x41, 0x75,
    0x74, 0x68, 0x6F, 0x72, 0x69, 0x74, 0x79
};

const BYTE rgbTestRoot0_PubKeyInfo[]= {
    0x30, 0x81, 0xDF, 0x30, 0x0D, 0x06, 0x09, 0x2A,
    0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01,
    0x05, 0x00, 0x03, 0x81, 0xCD, 0x00, 0x30, 0x81,
    0xC9, 0x02, 0x81, 0xC1, 0x00, 0xA9, 0xAA, 0x83,
    0x58, 0x6D, 0xB5, 0xD3, 0x0C, 0x4B, 0x5B, 0x80,
    0x90, 0xE5, 0xC3, 0x0F, 0x28, 0x0C, 0x7E, 0x3D,
    0x3C, 0x24, 0xC5, 0x29, 0x56, 0x63, 0x8C, 0xEE,
    0xC7, 0x83, 0x4A, 0xD8, 0x8C, 0x25, 0xD3, 0x0E,
    0xD3, 0x12, 0xB7, 0xE1, 0x86, 0x72, 0x74, 0xA7,
    0x8B, 0xFB, 0x0F, 0x05, 0xE9, 0x65, 0xC1, 0x9B,
    0xD8, 0x56, 0xC2, 0x93, 0xF0, 0xFB, 0xE9, 0x5A,
    0x48, 0x85, 0x7D, 0x95, 0xAA, 0xDF, 0x01, 0x86,
    0xB7, 0x33, 0x33, 0x46, 0x56, 0xCB, 0x5B, 0x7A,
    0xC4, 0xAF, 0xA0, 0x96, 0x53, 0x3A, 0xE9, 0xFB,
    0x3B, 0x78, 0xC1, 0x43, 0x0C, 0xC7, 0x6E, 0x1C,
    0x2F, 0xD1, 0x55, 0xF1, 0x19, 0xB2, 0x3F, 0xF8,
    0xD6, 0xA0, 0xC7, 0x24, 0x95, 0x3B, 0xC8, 0x45,
    0x25, 0x6F, 0x45, 0x3A, 0x46, 0x4F, 0xD2, 0x27,
    0x8B, 0xC7, 0x50, 0x75, 0xC6, 0x80, 0x5E, 0x0D,
    0x99, 0x78, 0x61, 0x77, 0x39, 0xC1, 0xB3, 0x0F,
    0x9D, 0x12, 0x9C, 0xC4, 0xBB, 0x32, 0x7B, 0xB2,
    0x4B, 0x26, 0xAA, 0x4E, 0xC0, 0x32, 0xB0, 0x2A,
    0x13, 0x21, 0xBE, 0xED, 0x24, 0xF4, 0x7D, 0x0D,
    0xEA, 0xAA, 0x8A, 0x7A, 0xD2, 0x8B, 0x4D, 0x97,
    0xB5, 0x4D, 0x64, 0xBA, 0xFB, 0x46, 0xDD, 0x69,
    0x6F, 0x9A, 0x0E, 0xCC, 0x53, 0x77, 0xAA, 0x6E,
    0xAE, 0x20, 0xD6, 0x21, 0x98, 0x69, 0xD9, 0x46,
    0xB9, 0x64, 0x32, 0xD4, 0x17, 0x02, 0x03, 0x01,
    0x00, 0x01
};

//+=========================================================================
//  VeriSign Roots
//-=========================================================================


// Name:: <OU=VeriSign Commercial Software Publishers CA, O="VeriSign, Inc.", L=Internet>
const BYTE rgbVeriSignRoot0_Name[] = {
    0x30, 0x61, 0x31, 0x11, 0x30, 0x0F, 0x06, 0x03,
    0x55, 0x04, 0x07, 0x13, 0x08, 0x49, 0x6E, 0x74,
    0x65, 0x72, 0x6E, 0x65, 0x74, 0x31, 0x17, 0x30,
    0x15, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x0E,
    0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E,
    0x2C, 0x20, 0x49, 0x6E, 0x63, 0x2E, 0x31, 0x33,
    0x30, 0x31, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13,
    0x2A, 0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67,
    0x6E, 0x20, 0x43, 0x6F, 0x6D, 0x6D, 0x65, 0x72,
    0x63, 0x69, 0x61, 0x6C, 0x20, 0x53, 0x6F, 0x66,
    0x74, 0x77, 0x61, 0x72, 0x65, 0x20, 0x50, 0x75,
    0x62, 0x6C, 0x69, 0x73, 0x68, 0x65, 0x72, 0x73,
    0x20, 0x43, 0x41
};

const BYTE rgbVeriSignRoot0_PubKeyInfo[]= {
    0x30, 0x81, 0x9F, 0x30, 0x0D, 0x06, 0x09, 0x2A,
    0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01,
    0x05, 0x00, 0x03, 0x81, 0x8D, 0x00, 0x30, 0x81,
    0x89, 0x02, 0x81, 0x81, 0x00, 0xC3, 0xD3, 0x69,
    0x65, 0x52, 0x01, 0x94, 0x54, 0xAB, 0x28, 0xC6,
    0x62, 0x18, 0xB3, 0x54, 0x55, 0xC5, 0x44, 0x87,
    0x45, 0x4A, 0x3B, 0xC2, 0x7E, 0xD8, 0xD3, 0xD7,
    0xC8, 0x80, 0x86, 0x8D, 0xD8, 0x0C, 0xF1, 0x16,
    0x9C, 0xCC, 0x6B, 0xA9, 0x29, 0xB2, 0x8F, 0x76,
    0x73, 0x92, 0xC8, 0xC5, 0x62, 0xA6, 0x3C, 0xED,
    0x1E, 0x05, 0x75, 0xF0, 0x13, 0x00, 0x6C, 0x14,
    0x4D, 0xD4, 0x98, 0x90, 0x07, 0xBE, 0x69, 0x73,
    0x81, 0xB8, 0x62, 0x4E, 0x31, 0x1E, 0xD1, 0xFC,
    0xC9, 0x0C, 0xEB, 0x7D, 0x90, 0xBF, 0xAE, 0xB4,
    0x47, 0x51, 0xEC, 0x6F, 0xCE, 0x64, 0x35, 0x02,
    0xD6, 0x7D, 0x67, 0x05, 0x77, 0xE2, 0x8F, 0xD9,
    0x51, 0xD7, 0xFB, 0x97, 0x19, 0xBC, 0x3E, 0xD7,
    0x77, 0x81, 0xC6, 0x43, 0xDD, 0xF2, 0xDD, 0xDF,
    0xCA, 0xA3, 0x83, 0x8B, 0xCB, 0x41, 0xC1, 0x3D,
    0x22, 0x48, 0x48, 0xA6, 0x19, 0x02, 0x03, 0x01,
    0x00, 0x01
};

#endif


typedef struct _ROOT_INFO {
    CRYPT_DER_BLOB  EncodedName;
    CRYPT_DER_BLOB  EncodedPubKeyInfo;
} ROOT_INFO, *PROOT_INFO;

const ROOT_INFO RootTable[] = {
    sizeof(rgbMicrosoftRoot0_Name), (BYTE *) rgbMicrosoftRoot0_Name,
    sizeof(rgbMicrosoftRoot0_PubKeyInfo), (BYTE *) rgbMicrosoftRoot0_PubKeyInfo,

    sizeof(rgbMicrosoftRoot1_Name), (BYTE *) rgbMicrosoftRoot1_Name,
    sizeof(rgbMicrosoftRoot1_PubKeyInfo), (BYTE *) rgbMicrosoftRoot1_PubKeyInfo,

    sizeof(rgbMicrosoftRoot2_Name), (BYTE *) rgbMicrosoftRoot2_Name,
    sizeof(rgbMicrosoftRoot2_PubKeyInfo), (BYTE *) rgbMicrosoftRoot2_PubKeyInfo,

#ifdef USE_TEST_ROOTS_FOR_TESTING
    sizeof(rgbTestRoot0_Name), (BYTE *) rgbTestRoot0_Name,
    sizeof(rgbTestRoot0_PubKeyInfo), (BYTE *) rgbTestRoot0_PubKeyInfo,

    sizeof(rgbVeriSignRoot0_Name), (BYTE *) rgbVeriSignRoot0_Name,
    sizeof(rgbVeriSignRoot0_PubKeyInfo), (BYTE *) rgbVeriSignRoot0_PubKeyInfo,
#endif
};
#define ROOT_CNT (sizeof(RootTable) / sizeof(RootTable[0]))



// If found, returns pointer to the PubKeyInfo blob. Otherwise, returns NULL.
PCRYPT_DER_BLOB
WINAPI
I_MinCryptFindRootByName(
    IN PCRYPT_DER_BLOB pIssuerNameValueBlob
    )
{
    DWORD i;
    
    for (i = 0; i < ROOT_CNT; i++) {
        if (pIssuerNameValueBlob->cbData == RootTable[i].EncodedName.cbData &&
                0 == memcmp(pIssuerNameValueBlob->pbData,
                        RootTable[i].EncodedName.pbData,
                        pIssuerNameValueBlob->cbData))
            return (PCRYPT_DER_BLOB) &RootTable[i].EncodedPubKeyInfo;
    }

    return NULL;
}

// If found, returns pointer to the PubKeyInfo blob. Otherwise, returns NULL.
PCRYPT_DER_BLOB
WINAPI
I_MinCryptFindRootByKey(
    IN PCRYPT_DER_BLOB pSubjectPubKeyInfoBlob
    )
{
    DWORD i;
    
    for (i = 0; i < ROOT_CNT; i++) {
        if (pSubjectPubKeyInfoBlob->cbData ==
                RootTable[i].EncodedPubKeyInfo.cbData
                                &&
                0 == memcmp(pSubjectPubKeyInfoBlob->pbData,
                        RootTable[i].EncodedPubKeyInfo.pbData,
                        pSubjectPubKeyInfoBlob->cbData))
            return (PCRYPT_DER_BLOB) &RootTable[i].EncodedPubKeyInfo;
    }

    return NULL;
}



// If found, returns pointer to rgCertBlob[MINASN1_CERT_BLOB_CNT].
// Otherwise, returns NULL.
PCRYPT_DER_BLOB
WINAPI
I_MinCryptFindIssuerCertificateByName(
    IN PCRYPT_DER_BLOB pIssuerNameValueBlob,
    IN DWORD cCert,
    IN CRYPT_DER_BLOB rgrgCertBlob[][MINASN1_CERT_BLOB_CNT]
    )
{
    DWORD i;
    DWORD cbName = pIssuerNameValueBlob->cbData;
    const BYTE *pbName = pIssuerNameValueBlob->pbData;

    if (0 == cbName)
        return NULL;
    
    for (i = 0; i < cCert; i++) {
        if (cbName == rgrgCertBlob[i][MINASN1_CERT_SUBJECT_IDX].cbData &&
                0 == memcmp(pbName,
                        rgrgCertBlob[i][MINASN1_CERT_SUBJECT_IDX].pbData,
                        cbName))
            return rgrgCertBlob[i];
    }

    return NULL;
}


//+-------------------------------------------------------------------------
//  Verifies a previously parsed X.509 Certificate.
//
//  Assumes the ASN.1 encoded X.509 certificate was parsed via
//  MinAsn1ParseCertificate() and the set of potential issuer certificates
//  were parsed via one or more of:
//   - MinAsn1ParseCertificate()
//   - MinAsn1ParseSignedDataCertificates()
//   - MinAsn1ExtractParsedCertificatesFromSignedData()
//
//  Iteratively finds the issuer certificate via its encoded name. The
//  public key in the issuer certificate is used to verify the subject
//  certificate's signature. This is repeated until finding a self signed
//  certificate or a baked in root identified by its encoded name.
//  For a self signed certificate, compares against the baked in root
//  public keys.
//
//  If the certificate and its issuers were successfully verified to a
//  baked in root, ERROR_SUCCESS is returned.  Otherwise, a nonzero error
//  code is returned.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptVerifyCertificate(
    IN CRYPT_DER_BLOB rgSubjectCertBlob[MINASN1_CERT_BLOB_CNT],
    IN DWORD cIssuerCert,
    IN CRYPT_DER_BLOB rgrgIssuerCertBlob[][MINASN1_CERT_BLOB_CNT]
    )
{
    LONG lErr;
    DWORD dwChainDepth = 0;
    PCRYPT_DER_BLOB rgSubject;
    BOOL fRoot = FALSE;

    rgSubject = rgSubjectCertBlob;
    while (!fRoot) {
        ALG_ID HashAlgId;
        BYTE rgbHash[MINCRYPT_MAX_HASH_LEN];
        DWORD cbHash;

        PCRYPT_DER_BLOB rgIssuer = NULL;
        PCRYPT_DER_BLOB pIssuerPubKeyInfo = NULL;

        // Hash the Subject's ToBeSigned bytes
        HashAlgId = MinCryptDecodeHashAlgorithmIdentifier(
            &rgSubject[MINASN1_CERT_SIGN_ALGID_IDX]);
        if (0 == HashAlgId)
            goto UnknownHashAlgId;
        lErr = MinCryptHashMemory(
            HashAlgId,
            1,                  // cBlob,
            &rgSubject[MINASN1_CERT_TO_BE_SIGNED_IDX],
            rgbHash,
            &cbHash
            );
        if (ERROR_SUCCESS != lErr)
            goto ErrorReturn;

        // Get the public key to decrypt the signature

        // Check if SelfSigned
        if (rgSubject[MINASN1_CERT_ISSUER_IDX].cbData ==
                rgSubject[MINASN1_CERT_SUBJECT_IDX].cbData
                                &&
                0 == memcmp(rgSubject[MINASN1_CERT_ISSUER_IDX].pbData,
                        rgSubject[MINASN1_CERT_SUBJECT_IDX].pbData,
                        rgSubject[MINASN1_CERT_ISSUER_IDX].cbData)) {
            pIssuerPubKeyInfo = I_MinCryptFindRootByKey(
                &rgSubject[MINASN1_CERT_PUBKEY_INFO_IDX]);
            if (NULL == pIssuerPubKeyInfo)
                goto UntrustedRoot;
            fRoot = TRUE;
        } else {
            // Check if the issuer is a root
            pIssuerPubKeyInfo = I_MinCryptFindRootByName(
                &rgSubject[MINASN1_CERT_ISSUER_IDX]);
            if (pIssuerPubKeyInfo)
                fRoot = TRUE;
            else {
                // Try to find the issuer from the input set of
                // certificates
                rgIssuer = I_MinCryptFindIssuerCertificateByName(
                    &rgSubject[MINASN1_CERT_ISSUER_IDX],
                    cIssuerCert,
                    rgrgIssuerCertBlob
                    );
                if (NULL == rgIssuer)
                    goto PartialChain;

                pIssuerPubKeyInfo = &rgIssuer[MINASN1_CERT_PUBKEY_INFO_IDX];
            }
        }

        // Use the issuer or root's public key to decrypt and verify
        // the signature.
        lErr = MinCryptVerifySignedHash(
            HashAlgId,
            rgbHash,
            cbHash,
            &rgSubject[MINASN1_CERT_SIGNATURE_IDX],
            pIssuerPubKeyInfo
            );
        if (ERROR_SUCCESS != lErr)
            goto ErrorReturn;

        if (!fRoot) {
            assert(rgIssuer);
            dwChainDepth++;
            if (MAX_CHAIN_DEPTH < dwChainDepth)
                goto CyclicChain;
            rgSubject = rgIssuer;
        }
    }


    lErr = ERROR_SUCCESS;

ErrorReturn:
CommonReturn:
    return lErr;

UnknownHashAlgId:
    lErr = CRYPT_E_UNKNOWN_ALGO;
    goto CommonReturn;
UntrustedRoot:
    lErr = CERT_E_UNTRUSTEDROOT;
    goto CommonReturn;
CyclicChain:
PartialChain:
    lErr = CERT_E_CHAINING;
    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\mincrypt\test\tminver\testutil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       testutil.cpp

//  Contents:   Test Utility API Prototypes and Definitions
//
//  History:    29-Jan-01   philh   created
//
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "testutil.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>
#include <stddef.h>

#define TESTUTIL_MAX_EXT_CNT    30
#define TESTUTIL_MAX_ATTR_CNT   30


//+-------------------------------------------------------------------------
//  Error output routines
//--------------------------------------------------------------------------
VOID
PrintErr(
    IN LPCSTR pszMsg,
    IN LONG lErr
    )
{
    printf("%s failed => 0x%x (%d) \n", pszMsg, lErr, lErr);
}

VOID
PrintLastError(
    IN LPCSTR pszMsg
    )
{
    DWORD dwErr = GetLastError();
    printf("%s failed => 0x%x (%d) \n", pszMsg, dwErr, dwErr);
}

//+-------------------------------------------------------------------------
//  Test allocation and free routines
//--------------------------------------------------------------------------
LPVOID
TestAlloc(
    IN size_t cbBytes
    )
{
    LPVOID pv;
    pv = malloc(cbBytes);
    if (pv == NULL)
        PrintErr("TestAlloc", (LONG) GetLastError());
    return pv;
}

VOID
TestFree(
    IN LPVOID pv
    )
{
    if (pv)
        free(pv);
}


CRYPT_DECODE_PARA TestDecodePara = {
    offsetof(CRYPT_DECODE_PARA, pfnFree) + sizeof(TestDecodePara.pfnFree),
    TestAlloc,
    TestFree
};

//+-------------------------------------------------------------------------
//  Allocate and convert a multi-byte string to a wide string. TestFree()
//  must be called to free the returned wide string.
//--------------------------------------------------------------------------
LPWSTR
AllocAndSzToWsz(
    IN LPCSTR psz
    )
{
    size_t  cb;
    LPWSTR  pwsz = NULL;

    if (-1 == (cb = mbstowcs( NULL, psz, strlen(psz))))
        goto bad_param;
    cb += 1;        // terminating NULL
    if (NULL == (pwsz = (LPWSTR)TestAlloc( cb * sizeof(WCHAR)))) {
        PrintLastError("AllocAndSzToWsz");
        goto failed;
    }
    if (-1 == mbstowcs( pwsz, psz, cb))
        goto bad_param;
    goto common_return;

bad_param:
    printf("failed => Bad AllocAndSzToWsz");
failed:
    if (pwsz) {
        TestFree(pwsz);
        pwsz = NULL;
    }
common_return:
    return pwsz;
}


//+-------------------------------------------------------------------------
//  Conversions functions between encoded OID and the dot string
//  representation
//--------------------------------------------------------------------------
#define MAX_OID_STRING_LEN          0x80
#define MAX_ENCODED_OID_LEN         0x80

//  Encoded Attribute
//
//  Attribute ::= SEQUENCE {
//      type       EncodedObjectID,
//      values     AttributeSetValue
//  } --#public--
//
//  AttributeSetValue ::= SET OF NOCOPYANY


BOOL
EncodedOIDToDot(
    IN PCRYPT_DER_BLOB pEncodedOIDBlob,
    OUT CHAR rgszOID[MAX_OID_STRING_LEN]
    )
{
    BOOL fResult;
    DWORD cbOID = pEncodedOIDBlob->cbData;
    const BYTE *pbOID = pEncodedOIDBlob->pbData;
    BYTE rgbEncodedAttr[MAX_ENCODED_OID_LEN];
    PCRYPT_ATTRIBUTE pAttr = NULL;
    DWORD cbAttr;

    // Convert the OID into an encoded Attribute that we can
    // decode to get the OID string.
    if (0 == cbOID || MAX_OID_STRING_LEN  - 6 < cbOID) {
        strcpy(rgszOID, "Invalid OID length");
        return FALSE;
    }

    rgbEncodedAttr[0] = MINASN1_TAG_SEQ;
    rgbEncodedAttr[1] = (BYTE) (2 + cbOID + 2);
    rgbEncodedAttr[2] = MINASN1_TAG_OID;
    rgbEncodedAttr[3] = (BYTE) cbOID;
    memcpy(&rgbEncodedAttr[4], pbOID, cbOID);
    rgbEncodedAttr[4 + cbOID + 0] = MINASN1_TAG_SET;
    rgbEncodedAttr[4 + cbOID + 1] = 0;

    if (!CryptDecodeObjectEx(
            X509_ASN_ENCODING,
            PKCS_ATTRIBUTE,
            rgbEncodedAttr,
            2 + 2 + cbOID + 2,
            CRYPT_DECODE_NOCOPY_FLAG | CRYPT_DECODE_ALLOC_FLAG,
            &TestDecodePara,
            (void *) &pAttr,
            &cbAttr
            )) {
        strcpy(rgszOID, "Decode OID failed");
        return FALSE;
    }

    if (strlen(pAttr->pszObjId) >= MAX_OID_STRING_LEN) {
        strcpy(rgszOID, "Invalid OID length");
        fResult = FALSE;
    } else {
        strcpy(rgszOID, pAttr->pszObjId);
        fResult = TRUE;
    }

    TestFree(pAttr);
    return fResult;
}

const BYTE rgbSeqTag[] = {MINASN1_TAG_SEQ, 0};
const BYTE rgbOIDTag[] = {MINASN1_TAG_OID, 0};

const MINASN1_EXTRACT_VALUE_PARA rgExtractAttrPara[] = {
    // 0 - Attribute ::= SEQUENCE {
    MINASN1_STEP_INTO_VALUE_OP, 0, rgbSeqTag,
    //   1 - type EncodedObjectID,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        0, rgbOIDTag,
};

#define ATTR_VALUE_COUNT            \
    (sizeof(rgExtractAttrPara) / sizeof(rgExtractAttrPara[0]))

BOOL
DotToEncodedOID(
    IN LPCSTR pszOID,
    OUT BYTE rgbEncodedOID[MAX_ENCODED_OID_LEN],
    OUT DWORD *pcbEncodedOID
    )
{
    BOOL fResult;
    CRYPT_ATTRIBUTE Attr;
    BYTE rgbEncoded[512];
    DWORD cbEncoded;
    CRYPT_DER_BLOB rgValueBlob[1];
    DWORD cValue;
    DWORD i;
    BYTE *pb;
    DWORD cb;

    // Encode an Attribute that only has the OID.
    Attr.pszObjId = (LPSTR) pszOID;
    Attr.cValue = 0;
    Attr.rgValue = NULL;

    cbEncoded = sizeof(rgbEncoded);
    if (!CryptEncodeObject(
            X509_ASN_ENCODING,
            PKCS_ATTRIBUTE,
            &Attr,
            rgbEncoded,
            &cbEncoded
            )) {
        printf("\n");
        printf("Asn1Encode(%s)", pszOID);
        PrintLastError("");
        goto ErrorReturn;
    }

    cValue = ATTR_VALUE_COUNT;
    if (0 >= MinAsn1ExtractValues(
            rgbEncoded,
            cbEncoded,
            &cValue,
            rgExtractAttrPara,
            1,
            rgValueBlob
            )) {
        printf("Unable to encode OID: %s\n", pszOID);
        goto ErrorReturn;
    }

    pb = rgValueBlob[0].pbData;
    cb = rgValueBlob[0].cbData;

    if (0 == cb || MAX_ENCODED_OID_LEN < cb) {
        printf("Invalid length for OID: %s\n", pszOID);
        goto ErrorReturn;
    }
    memcpy(rgbEncodedOID, pb, cb);
    *pcbEncodedOID = cb;

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    *pcbEncodedOID = 0;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  Functions to print bytes
//--------------------------------------------------------------------------
VOID
PrintBytes(
    IN PCRYPT_DER_BLOB pBlob
    )
{
    DWORD cb = pBlob->cbData;
    BYTE *pb = pBlob->pbData;

    if (0 == cb) {
        printf(" No Bytes\n");
        return;
    }

    for (; 0 < cb; cb--, pb++)
        printf(" %02X", *pb);

    printf("\n");
}


#define CROW 16
VOID
PrintMultiLineBytes(
    IN LPCSTR pszHdr,
    IN PCRYPT_DER_BLOB pBlob
    )
{
    DWORD cbSize = pBlob->cbData;
    BYTE *pb = pBlob->pbData;
    DWORD cb, i;

    if (cbSize == 0) {
        printf("%s No Bytes\n", pszHdr);
        return;
    }

    while (cbSize > 0)
    {
        printf("%s", pszHdr);
        cb = min(CROW, cbSize);
        cbSize -= cb;
        for (i = 0; i<cb; i++)
            printf(" %02X", pb[i]);
        for (i = cb; i<CROW; i++)
            printf("   ");
        printf("    '");
        for (i = 0; i<cb; i++)
            if (pb[i] >= 0x20 && pb[i] <= 0x7f)
                printf("%c", pb[i]);
            else
                printf(".");
        pb += cb;
        printf("'\n");
    }
}

//+-------------------------------------------------------------------------
//  Allocate and read an encoded DER blob from a file
//--------------------------------------------------------------------------
BOOL
ReadDERFromFile(
    IN LPCSTR  pszFileName,
    OUT PBYTE   *ppbDER,
    OUT PDWORD  pcbDER
    )
{
    BOOL        fRet;
    HANDLE      hFile = 0;
    PBYTE       pbDER = NULL;
    DWORD       cbDER;
    DWORD       cbRead;

    if( INVALID_HANDLE_VALUE == (hFile = CreateFile( pszFileName, GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL, OPEN_EXISTING, 0, NULL))) {
        printf( "can't open %s\n", pszFileName);
        goto ErrorReturn;
    }

    cbDER = GetFileSize( hFile, NULL);
    if (cbDER == 0) {
        printf( "empty file %s\n", pszFileName);
        goto ErrorReturn;
    }
    if (NULL == (pbDER = (PBYTE)TestAlloc(cbDER))) {
        printf( "can't alloc %d bytes\n", cbDER);
        goto ErrorReturn;
    }
    if (!ReadFile( hFile, pbDER, cbDER, &cbRead, NULL) ||
            (cbRead != cbDER)) {
        printf( "can't read %s\n", pszFileName);
        goto ErrorReturn;
    }

    *ppbDER = pbDER;
    *pcbDER = cbDER;
    fRet = TRUE;
CommonReturn:
    if (hFile)
        CloseHandle(hFile);
    return fRet;
ErrorReturn:
    if (pbDER)
        TestFree(pbDER);
    *ppbDER = NULL;
    *pcbDER = 0;
    fRet = FALSE;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  Write an encoded DER blob to a file
//--------------------------------------------------------------------------
BOOL
WriteDERToFile(
    IN LPCSTR  pszFileName,
    IN PBYTE   pbDER,
    IN DWORD   cbDER
    )
{
    BOOL fResult;

    // Write the Encoded Blob to the file
    HANDLE hFile;
    hFile = CreateFile(pszFileName,
                GENERIC_WRITE,
                0,                  // fdwShareMode
                NULL,               // lpsa
                CREATE_ALWAYS,
                0,                  // fdwAttrsAndFlags
                0);                 // TemplateFile
    if (INVALID_HANDLE_VALUE == hFile) {
        fResult = FALSE;
        PrintLastError("WriteDERToFile::CreateFile");
    } else {
        DWORD dwBytesWritten;
        if (!(fResult = WriteFile(
                hFile,
                pbDER,
                cbDER,
                &dwBytesWritten,
                NULL            // lpOverlapped
                )))
            PrintLastError("WriteDERToFile::WriteFile");
        CloseHandle(hFile);
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  Display functions
//--------------------------------------------------------------------------


VOID
DisplayCert(
    IN CRYPT_DER_BLOB rgCertBlob[MINASN1_CERT_BLOB_CNT],
    IN BOOL fVerbose
    )
{
    if (0 != rgCertBlob[MINASN1_CERT_VERSION_IDX].cbData) {
        printf("Version:");
        PrintBytes(&rgCertBlob[MINASN1_CERT_VERSION_IDX]);
    }

    printf("Subject:");
    DisplayName(&rgCertBlob[MINASN1_CERT_SUBJECT_IDX]);

    printf("Issuer:");
    DisplayName(&rgCertBlob[MINASN1_CERT_ISSUER_IDX]);
    printf("SerialNumber:");
    PrintBytes(&rgCertBlob[MINASN1_CERT_SERIAL_NUMBER_IDX]);


    printf("NotBefore:\n");
    PrintMultiLineBytes("    ", &rgCertBlob[MINASN1_CERT_NOT_BEFORE_IDX]);
    printf("NotAfter:\n");
    PrintMultiLineBytes("    ", &rgCertBlob[MINASN1_CERT_NOT_AFTER_IDX]);


    if (0 != rgCertBlob[MINASN1_CERT_ISSUER_UNIQUE_ID_IDX].cbData) {
        printf("IssuerUniqueId:\n");
        PrintMultiLineBytes("    ",
            &rgCertBlob[MINASN1_CERT_ISSUER_UNIQUE_ID_IDX]);
    }

    if (0 != rgCertBlob[MINASN1_CERT_SUBJECT_UNIQUE_ID_IDX].cbData) {
        printf("SubjectUniqueId:\n");
        PrintMultiLineBytes("    ",
            &rgCertBlob[MINASN1_CERT_SUBJECT_UNIQUE_ID_IDX]);
    }

    if (fVerbose) {
        CRYPT_DER_BLOB rgPubKeyInfoBlob[MINASN1_PUBKEY_INFO_BLOB_CNT];
        CRYPT_DER_BLOB rgPubKeyAlgIdBlob[MINASN1_ALGID_BLOB_CNT];
        CRYPT_DER_BLOB rgSignAlgIdBlob[MINASN1_ALGID_BLOB_CNT];


        if (0 >= MinAsn1ParsePublicKeyInfo(
                    &rgCertBlob[MINASN1_CERT_PUBKEY_INFO_IDX],
                    rgPubKeyInfoBlob
                    ) ||
            0 >= MinAsn1ParseAlgorithmIdentifier(
                    &rgPubKeyInfoBlob[MINASN1_PUBKEY_INFO_ALGID_IDX],
                    rgPubKeyAlgIdBlob
                    ))
            printf("PublicKeyInfo: parse failed\n");
        else {
            CHAR rgszOID[MAX_OID_STRING_LEN];
            CRYPT_DER_BLOB rgRSAPubKeyBlob[MINASN1_RSA_PUBKEY_BLOB_CNT];

            EncodedOIDToDot(&rgPubKeyAlgIdBlob[MINASN1_ALGID_OID_IDX],
                rgszOID);

            printf("PublicKeyInfo.Algorithm: %s\n", rgszOID);

            if (0 != rgPubKeyAlgIdBlob[MINASN1_ALGID_PARA_IDX].cbData) {
                printf("PublicKeyInfo.Algorithm.Parameters:\n");
                PrintMultiLineBytes("    ",
                    &rgPubKeyAlgIdBlob[MINASN1_ALGID_PARA_IDX]);
            }

            if (0 >= MinAsn1ParseRSAPublicKey(
                    &rgPubKeyInfoBlob[MINASN1_PUBKEY_INFO_PUBKEY_IDX],
                    rgRSAPubKeyBlob
                    )) {
                printf("PublicKeyInfo.PublicKey:\n");
                PrintMultiLineBytes("    ",
                    &rgPubKeyInfoBlob[MINASN1_PUBKEY_INFO_PUBKEY_IDX]);
            } else {
                DWORD dwByteLen;

                dwByteLen =
                    rgRSAPubKeyBlob[MINASN1_RSA_PUBKEY_MODULUS_IDX].cbData;
                if (0 < dwByteLen && 0 == rgRSAPubKeyBlob[
                            MINASN1_RSA_PUBKEY_MODULUS_IDX].pbData[0])
                    dwByteLen--;
                printf("PublicKeyInfo.RSAPublicKey.BitLength: %d\n",
                    dwByteLen * 8);

                printf("PublicKeyInfo.RSAPublicKey.Modulus:\n");
                PrintMultiLineBytes("    ",
                    &rgRSAPubKeyBlob[MINASN1_RSA_PUBKEY_MODULUS_IDX]);
                printf("PublicKeyInfo.RSAPublicKey.Exponent:");
                PrintBytes(&rgRSAPubKeyBlob[MINASN1_RSA_PUBKEY_EXPONENT_IDX]);
            }
        }

        if ( 0 >= MinAsn1ParseAlgorithmIdentifier(
                    &rgCertBlob[MINASN1_CERT_SIGN_ALGID_IDX],
                    rgSignAlgIdBlob
                    ))
            printf("SignatureAlgorithm: parse failed\n");
        else {
            CHAR rgszOID[MAX_OID_STRING_LEN];
            EncodedOIDToDot(&rgSignAlgIdBlob[MINASN1_ALGID_OID_IDX],
                rgszOID);

            printf("Signature.Algorithm: %s\n", rgszOID);
            if (0 != rgSignAlgIdBlob[MINASN1_ALGID_PARA_IDX].cbData) {
                printf("Signature.Algorithm.Parameters:\n");
                PrintMultiLineBytes("    ",
                    &rgSignAlgIdBlob[MINASN1_ALGID_PARA_IDX]);
            }
        }

        printf("Signature.Content\n");
        PrintMultiLineBytes("    ", &rgCertBlob[MINASN1_CERT_SIGNATURE_IDX]);

        DisplayExts(&rgCertBlob[MINASN1_CERT_EXTS_IDX]);
    }
}

VOID
DisplayName(
    IN PCRYPT_DER_BLOB pNameValueBlob
    )
{
    WCHAR wszName[512];

    CertNameToStrW(
        X509_ASN_ENCODING,
        pNameValueBlob,
        CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
        wszName,
        512
        );

    printf(" <%S>\n", wszName);
}

VOID
DisplayExts(
    IN PCRYPT_DER_BLOB pExtsValueBlob
    )
{
    DWORD cExt;
    DWORD i;
    CRYPT_DER_BLOB rgrgExtBlob[TESTUTIL_MAX_EXT_CNT][MINASN1_EXT_BLOB_CNT];

    if (0 == pExtsValueBlob->cbData)
        return;

    cExt = TESTUTIL_MAX_EXT_CNT;
    if (0 >= MinAsn1ParseExtensions(
            pExtsValueBlob,
            &cExt,
            rgrgExtBlob
            )) {
        printf("Extensions: parse failed\n");
        return;
    }

    for (i = 0; i < cExt; i++) {
        CHAR rgszOID[MAX_OID_STRING_LEN];

        EncodedOIDToDot(&rgrgExtBlob[i][MINASN1_EXT_OID_IDX], rgszOID);
        printf("Extension[%d] %s  Critical: ", i, rgszOID);
        if (0 != rgrgExtBlob[i][MINASN1_EXT_CRITICAL_IDX].cbData &&
                0 != rgrgExtBlob[i][MINASN1_EXT_CRITICAL_IDX].pbData[0])
            printf("TRUE\n");
        else
            printf("FALSE\n");

        PrintMultiLineBytes("    ", &rgrgExtBlob[i][MINASN1_EXT_VALUE_IDX]);
    }
}

VOID
DisplayCTL(
    IN PCRYPT_DER_BLOB pEncodedContentBlob,
    IN BOOL fVerbose
    )
{
    CRYPT_DER_BLOB rgCTLBlob[MINASN1_CTL_BLOB_CNT];

    if (0 >= MinAsn1ParseCTL(
            pEncodedContentBlob,
            rgCTLBlob
            )) {
        printf("CTL: parse failed\n");
        return;
    }

    if (0 != rgCTLBlob[MINASN1_CTL_VERSION_IDX].cbData) {
        printf("Version:");
        PrintBytes(&rgCTLBlob[MINASN1_CTL_VERSION_IDX]);
    }

    printf("SubjectUsage:\n");
    PrintMultiLineBytes("    ", &rgCTLBlob[MINASN1_CTL_SUBJECT_USAGE_IDX]);

    if (0 != rgCTLBlob[MINASN1_CTL_LIST_ID_IDX].cbData) {
        printf("ListIdentifier:\n");
        PrintMultiLineBytes("    ", &rgCTLBlob[MINASN1_CTL_LIST_ID_IDX]);
    }

    if (0 != rgCTLBlob[MINASN1_CTL_SEQUENCE_NUMBER_IDX].cbData) {
        printf("SequenceNumber:");
        PrintBytes(&rgCTLBlob[MINASN1_CTL_SEQUENCE_NUMBER_IDX]);
    }

    printf("ThisUpdate:\n");
    PrintMultiLineBytes("    ", &rgCTLBlob[MINASN1_CTL_THIS_UPDATE_IDX]);
    if (0 != rgCTLBlob[MINASN1_CTL_NEXT_UPDATE_IDX].cbData) {
        printf("NextUpdate:\n");
        PrintMultiLineBytes("    ", &rgCTLBlob[MINASN1_CTL_NEXT_UPDATE_IDX]);
    }

    printf("SubjectAlgorithmIdentifier:\n");
    PrintMultiLineBytes("    ", &rgCTLBlob[MINASN1_CTL_SUBJECT_ALGID_IDX]);

    if (fVerbose)
        DisplayExts(&rgCTLBlob[MINASN1_CTL_EXTS_IDX]);

    if (0 != rgCTLBlob[MINASN1_CTL_SUBJECTS_IDX].cbData) {
        DWORD cbEncoded;
        const BYTE *pbEncoded;
        DWORD i;

        printf("\n");

        // Advance past the Subjects' outer tag and length
        if (0 >= MinAsn1ExtractContent(
                rgCTLBlob[MINASN1_CTL_SUBJECTS_IDX].pbData,
                rgCTLBlob[MINASN1_CTL_SUBJECTS_IDX].cbData,
                &cbEncoded,
                &pbEncoded
                )) {
            printf("Subjects: parse failed\n");
            return;
        }



        // Loop through the encoded subjects
        for (i = 0; 0 != cbEncoded; i++) {
            LONG cbSubject;
            CRYPT_DER_BLOB rgCTLSubjectBlob[MINASN1_CTL_SUBJECT_BLOB_CNT];

            printf("----  Subject[%d]  ----\n", i);

            cbSubject = MinAsn1ParseCTLSubject(
                pbEncoded,
                cbEncoded,
                rgCTLSubjectBlob
                );
            if (0 >= cbSubject) {
                printf("Subject: parse failed\n");
                return;
            }

            printf("Identifier:\n");
            PrintMultiLineBytes("    ",
                &rgCTLSubjectBlob[MINASN1_CTL_SUBJECT_ID_IDX]);

            if (fVerbose) {
                DisplayAttrs("",
                    &rgCTLSubjectBlob[MINASN1_CTL_SUBJECT_ATTRS_IDX]);
                printf("\n");
            }

            pbEncoded += cbSubject;
            cbEncoded -= cbSubject;
        }
    }
}

VOID
DisplayAttrs(
    IN LPCSTR pszHdr,
    IN PCRYPT_DER_BLOB pAttrsValueBlob
    )
{
    DWORD cAttr;
    DWORD i;
    CRYPT_DER_BLOB rgrgAttrBlob[TESTUTIL_MAX_ATTR_CNT][MINASN1_ATTR_BLOB_CNT];

    if (0 == pAttrsValueBlob->cbData)
        return;

    cAttr = TESTUTIL_MAX_ATTR_CNT;
    if (0 >= MinAsn1ParseAttributes(
            pAttrsValueBlob,
            &cAttr,
            rgrgAttrBlob
            )) {
        printf("%sAttributes: parse failed\n", pszHdr);
        return;
    }

    for (i = 0; i < cAttr; i++) {
        CHAR rgszOID[MAX_OID_STRING_LEN];

        EncodedOIDToDot(&rgrgAttrBlob[i][MINASN1_ATTR_OID_IDX], rgszOID);
        printf("%sAttribute[%d] %s:\n", pszHdr, i, rgszOID);
        PrintMultiLineBytes("    ", &rgrgAttrBlob[i][MINASN1_ATTR_VALUE_IDX]);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\mincrypt\lib\verdata.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       verdata.cpp
//
//  Contents:   Minimal Cryptographic functions to verify PKCS #7 Signed Data
//              message
//
//
//  Functions:  MinCryptVerifySignedData
//
//  History:    19-Jan-01    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"

#define MAX_SIGNED_DATA_CERT_CNT        10
#define MAX_SIGNED_DATA_AUTH_ATTR_CNT   10

// #define szOID_RSA_signedData    "1.2.840.113549.1.7.2"
const BYTE rgbOID_RSA_signedData[] =
    {0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x02};

// #define szOID_RSA_messageDigest "1.2.840.113549.1.9.4"
const BYTE rgbOID_RSA_messageDigest[] =
    {0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x04};
const CRYPT_DER_BLOB RSA_messageDigestEncodedOIDBlob = {
        sizeof(rgbOID_RSA_messageDigest), 
        (BYTE *) rgbOID_RSA_messageDigest
};

PCRYPT_DER_BLOB
WINAPI
I_MinCryptFindSignerCertificateByIssuerAndSerialNumber(
    IN PCRYPT_DER_BLOB pIssuerNameValueBlob,
    IN PCRYPT_DER_BLOB pIssuerSerialNumberContentBlob,
    IN DWORD cCert,
    IN CRYPT_DER_BLOB rgrgCertBlob[][MINASN1_CERT_BLOB_CNT]
    )
{
    DWORD i;
    const BYTE *pbName = pIssuerNameValueBlob->pbData;
    DWORD cbName = pIssuerNameValueBlob->cbData;
    const BYTE *pbSerial = pIssuerSerialNumberContentBlob->pbData;
    DWORD cbSerial = pIssuerSerialNumberContentBlob->cbData;
    
    if (0 == cbName || 0 == cbSerial)
        return NULL;

    for (i = 0; i < cCert; i++) {
        PCRYPT_DER_BLOB rgCert = rgrgCertBlob[i];

        if (cbName == rgCert[MINASN1_CERT_ISSUER_IDX].cbData &&
                cbSerial == rgCert[MINASN1_CERT_SERIAL_NUMBER_IDX].cbData
                        &&
                0 == memcmp(pbSerial,
                        rgCert[MINASN1_CERT_SERIAL_NUMBER_IDX].pbData,
                        cbSerial)
                        &&
                0 == memcmp(pbName,
                        rgCert[MINASN1_CERT_ISSUER_IDX].pbData,
                        cbName))
            return rgCert;
    }

    return NULL;
}

//  Verifies that the input hash matches the
//  szOID_RSA_messageDigest ("1.2.840.113549.1.9.4") authenticated attribute.
//
//  Replaces the input hash with a hash of the authenticated attributes.
LONG
WINAPI
I_MinCryptVerifySignerAuthenticatedAttributes(
    IN ALG_ID HashAlgId,
    IN OUT BYTE rgbHash[MINCRYPT_MAX_HASH_LEN],
    IN OUT DWORD *pcbHash,
    IN PCRYPT_DER_BLOB pAttrsValueBlob
    )
{
    LONG lErr;
    DWORD cAttr;
    CRYPT_DER_BLOB rgrgAttrBlob[MAX_SIGNED_DATA_AUTH_ATTR_CNT][MINASN1_ATTR_BLOB_CNT];
    PCRYPT_DER_BLOB rgDigestAuthAttr;

    const BYTE *pbDigestAuthValue;
    DWORD cbDigestAuthValue;

    CRYPT_DER_BLOB rgAuthHashBlob[2];
    const BYTE bTagSet = MINASN1_TAG_SET;

    // Parse the authenticated attributes
    cAttr = MAX_SIGNED_DATA_AUTH_ATTR_CNT;
    if (0 >= MinAsn1ParseAttributes(
            pAttrsValueBlob,
            &cAttr,
            rgrgAttrBlob) || 0 == cAttr)
        goto MissingAuthAttrs;

    // Find the szOID_RSA_messageDigest ("1.2.840.113549.1.9.4")
    // attribute value
    rgDigestAuthAttr = MinAsn1FindAttribute(
        (PCRYPT_DER_BLOB) &RSA_messageDigestEncodedOIDBlob,
        cAttr,
        rgrgAttrBlob
        );
    if (NULL == rgDigestAuthAttr)
        goto MissingDigestAuthAttr;

    // Skip past the digest's outer OCTET tag and length octets
    if (0 >= MinAsn1ExtractContent(
            rgDigestAuthAttr[MINASN1_ATTR_VALUE_IDX].pbData,
            rgDigestAuthAttr[MINASN1_ATTR_VALUE_IDX].cbData,
            &cbDigestAuthValue,
            &pbDigestAuthValue
            ))
        goto InvalidDigestAuthAttr;

    // Check that the authenticated digest bytes match the input
    // content hash.
    if (*pcbHash != cbDigestAuthValue ||
            0 != memcmp(rgbHash, pbDigestAuthValue, cbDigestAuthValue))
        goto InvalidContentHash;

    // Hash the authenticated attributes. This hash will be compared against
    // the decrypted signature.

    // Note, the authenticated attributes "[0] Implicit" tag needs to be changed
    // to a "SET OF" tag before doing the hash.
    rgAuthHashBlob[0].pbData = (BYTE *) &bTagSet;
    rgAuthHashBlob[0].cbData = 1;
    assert(0 < pAttrsValueBlob->cbData);
    rgAuthHashBlob[1].pbData = pAttrsValueBlob->pbData + 1;
    rgAuthHashBlob[1].cbData = pAttrsValueBlob->cbData - 1;
    
    lErr = MinCryptHashMemory(
        HashAlgId,
        2,                      // cBlob
        rgAuthHashBlob,
        rgbHash,
        pcbHash
        );

CommonReturn:
    return lErr;

MissingAuthAttrs:
MissingDigestAuthAttr:
InvalidDigestAuthAttr:
    lErr = CRYPT_E_AUTH_ATTR_MISSING;
    goto CommonReturn;

InvalidContentHash:
    lErr = CRYPT_E_HASH_VALUE;
    goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  Function: MinCryptVerifySignedData
//
//  Verifies an ASN.1 encoded PKCS #7 Signed Data Message.
//
//  Assumes the PKCS #7 message is definite length encoded.
//  Assumes PKCS #7 version 1.5, ie, not the newer CMS version.
//  We only look at the first signer.
//
//  The Signed Data message is parsed. Its signature is verified. Its
//  signer certificate chain is verified to a baked in root public key.
//
//  If the Signed Data was successfully verified, ERROR_SUCCESS is returned.
//  Otherwise, a nonzero error code is returned.
//
//  Here are some interesting errors that can be returned:
//      CRYPT_E_BAD_MSG     - unable to ASN1 parse as a signed data message
//      ERROR_NO_DATA       - the content is empty
//      CRYPT_E_NO_SIGNER   - not signed or unable to find signer cert
//      CRYPT_E_UNKNOWN_ALGO- unknown MD5 or SHA1 ASN.1 algorithm identifier
//      CERT_E_UNTRUSTEDROOT- the signer chain's root wasn't baked in
//      CERT_E_CHAINING     - unable to build signer chain to a root
//      CRYPT_E_AUTH_ATTR_MISSING - missing digest authenticated attribute
//      CRYPT_E_HASH_VALUE  - content hash != authenticated digest attribute
//      NTE_BAD_ALGID       - unsupported hash or public key algorithm
//      NTE_BAD_PUBLIC_KEY  - not a valid RSA public key
//      NTE_BAD_SIGNATURE   - bad PKCS #7 or signer chain signature 
//
//  The rgVerSignedDataBlob[] is updated with pointer to and length of the
//  following fields in the encoded PKCS #7 message.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptVerifySignedData(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT CRYPT_DER_BLOB rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_BLOB_CNT]
    )
{
    LONG lErr;
    CRYPT_DER_BLOB rgParseSignedDataBlob[MINASN1_SIGNED_DATA_BLOB_CNT];
    DWORD cCert;
    CRYPT_DER_BLOB rgrgCertBlob[MAX_SIGNED_DATA_CERT_CNT][MINASN1_CERT_BLOB_CNT];
    PCRYPT_DER_BLOB rgSignerCert;
    ALG_ID HashAlgId;
    BYTE rgbHash[MINCRYPT_MAX_HASH_LEN];
    DWORD cbHash;
    CRYPT_DER_BLOB ContentBlob;

    memset(rgVerSignedDataBlob, 0,
        sizeof(CRYPT_DER_BLOB) * MINCRYPT_VER_SIGNED_DATA_BLOB_CNT);

    // Parse the message and verify that it's ASN.1 PKCS #7 SignedData
    if (0 >= MinAsn1ParseSignedData(
            pbEncoded,
            cbEncoded,
            rgParseSignedDataBlob
            ))
        goto ParseSignedDataError;

    // Only support szOID_RSA_signedData - "1.2.840.113549.1.7.2"
    if (sizeof(rgbOID_RSA_signedData) !=
            rgParseSignedDataBlob[MINASN1_SIGNED_DATA_OUTER_OID_IDX].cbData
                        ||
            0 != memcmp(rgbOID_RSA_signedData,
                    rgParseSignedDataBlob[MINASN1_SIGNED_DATA_OUTER_OID_IDX].pbData,
                    sizeof(rgbOID_RSA_signedData)))
        goto NotSignedDataOID;

    // Verify this isn't an empty SignedData message
    if (0 == rgParseSignedDataBlob[MINASN1_SIGNED_DATA_CONTENT_OID_IDX].cbData
                        ||
            0 == rgParseSignedDataBlob[MINASN1_SIGNED_DATA_CONTENT_DATA_IDX].cbData)
        goto NoContent;

    rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_CONTENT_OID_IDX] =
        rgParseSignedDataBlob[MINASN1_SIGNED_DATA_CONTENT_OID_IDX];
    rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_CONTENT_DATA_IDX] =
        rgParseSignedDataBlob[MINASN1_SIGNED_DATA_CONTENT_DATA_IDX];

    // Check that the message has a signer
    if (0 == rgParseSignedDataBlob[MINASN1_SIGNED_DATA_SIGNER_INFO_ENCODED_IDX].cbData)
        goto NoSigner;

    // Get the message's bag of certs
    cCert = MAX_SIGNED_DATA_CERT_CNT;
    if (0 >= MinAsn1ParseSignedDataCertificates(
            &rgParseSignedDataBlob[MINASN1_SIGNED_DATA_CERTS_IDX],
            &cCert,
            rgrgCertBlob
            ) || 0 == cCert)
        goto NoCerts;

    // Get the signer certificate
    rgSignerCert = I_MinCryptFindSignerCertificateByIssuerAndSerialNumber(
        &rgParseSignedDataBlob[MINASN1_SIGNED_DATA_SIGNER_INFO_ISSUER_IDX],
        &rgParseSignedDataBlob[MINASN1_SIGNED_DATA_SIGNER_INFO_SERIAL_NUMBER_IDX],
        cCert,
        rgrgCertBlob
        );
    if (NULL == rgSignerCert)
        goto NoSignerCert;

    rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_SIGNER_CERT_IDX] =
        rgSignerCert[MINASN1_CERT_ENCODED_IDX];
    rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_AUTH_ATTRS_IDX] =
        rgParseSignedDataBlob[MINASN1_SIGNED_DATA_SIGNER_INFO_AUTH_ATTRS_IDX];
    rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_UNAUTH_ATTRS_IDX] =
        rgParseSignedDataBlob[MINASN1_SIGNED_DATA_SIGNER_INFO_UNAUTH_ATTRS_IDX];


    // Verify the signer certificate up to a baked in, trusted root
    lErr = MinCryptVerifyCertificate(
        rgSignerCert,
        cCert,
        rgrgCertBlob
        );
    if (ERROR_SUCCESS != lErr)
        goto ErrorReturn;


    // Hash the message's content octets according to the signer's hash
    // algorithm
    HashAlgId = MinCryptDecodeHashAlgorithmIdentifier(
        &rgParseSignedDataBlob[MINASN1_SIGNED_DATA_SIGNER_INFO_DIGEST_ALGID_IDX]
        );
    if (0 == HashAlgId)
        goto UnknownHashAlgId;

    // Note, the content's tag and length octets aren't included in the hash
    if (0 >= MinAsn1ExtractContent(
            rgParseSignedDataBlob[MINASN1_SIGNED_DATA_CONTENT_DATA_IDX].pbData,
            rgParseSignedDataBlob[MINASN1_SIGNED_DATA_CONTENT_DATA_IDX].cbData,
            &ContentBlob.cbData,
            (const BYTE **) &ContentBlob.pbData
            ))
        goto InvalidContent;

    lErr = MinCryptHashMemory(
        HashAlgId,
        1,                      // cBlob
        &ContentBlob,
        rgbHash,
        &cbHash
        );
    if (ERROR_SUCCESS != lErr)
        goto ErrorReturn;

    // If we have authenticated attributes, then, need to compare the
    // above hash with the szOID_RSA_messageDigest ("1.2.840.113549.1.9.4")
    // attribute value. After a successful comparison, the above hash
    // is replaced with a hash of the authenticated attributes.
    if (0 != rgParseSignedDataBlob[
            MINASN1_SIGNED_DATA_SIGNER_INFO_AUTH_ATTRS_IDX].cbData) {
        lErr = I_MinCryptVerifySignerAuthenticatedAttributes(
            HashAlgId,
            rgbHash,
            &cbHash,
            &rgParseSignedDataBlob[MINASN1_SIGNED_DATA_SIGNER_INFO_AUTH_ATTRS_IDX]
            );
        if (ERROR_SUCCESS != lErr)
            goto ErrorReturn;
    }

    // Verify the signature using either the authenticated attributes hash
    // or the content hash
    lErr = MinCryptVerifySignedHash(
        HashAlgId,
        rgbHash,
        cbHash,
        &rgParseSignedDataBlob[MINASN1_SIGNED_DATA_SIGNER_INFO_ENCYRPT_DIGEST_IDX],
        &rgSignerCert[MINASN1_CERT_PUBKEY_INFO_IDX]
        );


ErrorReturn:
CommonReturn:
    return lErr;

ParseSignedDataError:
NotSignedDataOID:
InvalidContent:
    lErr = CRYPT_E_BAD_MSG;
    goto CommonReturn;

NoContent:
    lErr = ERROR_NO_DATA;
    goto CommonReturn;

NoSigner:
NoCerts:
NoSignerCert:
    lErr = CRYPT_E_NO_SIGNER;
    goto CommonReturn;

UnknownHashAlgId:
    lErr = CRYPT_E_UNKNOWN_ALGO;
    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\mincrypt\lib\verhash.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       verhash.cpp
//
//  Contents:   Minimal Cryptographic functions to verify ASN.1 encoded
//              signed hashes. Signed hashes are used in X.509 certificates
//              and PKCS #7 signed data.
//
//              Also contains md5 or sha1 memory hash function.
//              
//
//  Functions:  MinCryptDecodeHashAlgorithmIdentifier
//              MinCryptHashMemory
//              MinCryptVerifySignedHash
//
//  History:    17-Jan-01    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <md5.h>
#include <md2.h>
#include <sha.h>
#include <rsa.h>

#define MAX_RSA_PUB_KEY_BIT_LEN             4096
#define MAX_RSA_PUB_KEY_BYTE_LEN            (MAX_RSA_PUB_KEY_BIT_LEN / 8 )
#define MAX_BSAFE_PUB_KEY_MODULUS_BYTE_LEN  \
    (MAX_RSA_PUB_KEY_BYTE_LEN +  sizeof(DWORD) * 4)

typedef struct _BSAFE_PUB_KEY_CONTENT {
    BSAFE_PUB_KEY   Header;
    BYTE            rgbModulus[MAX_BSAFE_PUB_KEY_MODULUS_BYTE_LEN];
} BSAFE_PUB_KEY_CONTENT, *PBSAFE_PUB_KEY_CONTENT;


#ifndef RSA1
#define RSA1 ((DWORD)'R'+((DWORD)'S'<<8)+((DWORD)'A'<<16)+((DWORD)'1'<<24))
#endif

// from \nt\ds\win32\ntcrypto\scp\nt_sign.c

//
// Reverse ASN.1 Encodings of possible hash identifiers.  The leading byte is
// the length of the remaining byte string.
//

static const BYTE
    *md2Encodings[]
//                        1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18
    = { (CONST BYTE *)"\x12\x10\x04\x00\x05\x02\x02\x0d\xf7\x86\x48\x86\x2a\x08\x06\x0c\x30\x20\x30",
        (CONST BYTE *)"\x10\x10\x04\x02\x02\x0d\xf7\x86\x48\x86\x2a\x08\x06\x0a\x30\x1e\x30",
        (CONST BYTE *)"\x00" },

    *md5Encodings[]
    = { (CONST BYTE *)"\x12\x10\x04\x00\x05\x05\x02\x0d\xf7\x86\x48\x86\x2a\x08\x06\x0c\x30\x20\x30",
        (CONST BYTE *)"\x10\x10\x04\x05\x02\x0d\xf7\x86\x48\x86\x2a\x08\x06\x0a\x30\x1e\x30",
        (CONST BYTE *)"\x00" },

    *shaEncodings[]
    = { (CONST BYTE *)"\x0f\x14\x04\x00\x05\x1a\x02\x03\x0e\x2b\x05\x06\x09\x30\x21\x30",
        (CONST BYTE *)"\x0d\x14\x04\x1a\x02\x03\x0e\x2b\x05\x06\x07\x30\x1f\x30",
        (CONST BYTE *)"\x00"};



typedef struct _ENCODED_OID_INFO {
    DWORD           cbEncodedOID;
    const BYTE      *pbEncodedOID;
    ALG_ID          AlgId;
} ENCODED_OID_INFO, *PENCODED_OID_INFO;

//
// SHA1/MD5/MD2 HASH OIDS
//

// #define szOID_OIWSEC_sha1       "1.3.14.3.2.26"
const BYTE rgbOIWSEC_sha1[] =
    {0x2B, 0x0E, 0x03, 0x02, 0x1A};

// #define szOID_OIWSEC_sha        "1.3.14.3.2.18"
const BYTE rgbOID_OIWSEC_sha[] =
    {0x2B, 0x0E, 0x03, 0x02, 0x12};

// #define szOID_RSA_MD5           "1.2.840.113549.2.5"
const BYTE rgbOID_RSA_MD5[] =
    {0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x02, 0x05};

// #define szOID_RSA_MD2           "1.2.840.113549.2.2"
const BYTE rgbOID_RSA_MD2[] =
    {0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x02, 0x02};

//
// RSA SHA1/MD5/MD2 SIGNATURE OIDS
//

// #define szOID_RSA_SHA1RSA       "1.2.840.113549.1.1.5"
const BYTE rgbOID_RSA_SHA1RSA[] =
    {0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05};

// #define szOID_RSA_MD5RSA        "1.2.840.113549.1.1.4"
const BYTE rgbOID_RSA_MD5RSA[] =
    {0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x04};

// #define szOID_OIWSEC_sha1RSASign "1.3.14.3.2.29"
const BYTE rgbOID_OIWSEC_sha1RSASign[] =
    {0x2B, 0x0E, 0x03, 0x02, 0x1D};

// #define szOID_OIWSEC_shaRSA     "1.3.14.3.2.15"
const BYTE rgbOID_OIWSEC_shaRSA[] =
    {0x2B, 0x0E, 0x03, 0x02, 0x0F};

// #define szOID_OIWSEC_md5RSA     "1.3.14.3.2.3"
const BYTE rgbOID_OIWSEC_md5RSA[] =
    {0x2B, 0x0E, 0x03, 0x02, 0x03};

// #define szOID_RSA_MD2RSA        "1.2.840.113549.1.1.2"
const BYTE rgbOID_RSA_MD2RSA[] =
   {0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x02}; 

// #define szOID_OIWDIR_md2RSA     "1.3.14.7.2.3.1"
const BYTE rgbOID_OIWDIR_md2RSA[] =
    {0x2B, 0x0E, 0x07, 0x02, 0x03, 0x01};


const ENCODED_OID_INFO HashAlgTable[] = {
    // Hash OIDs
    sizeof(rgbOIWSEC_sha1), rgbOIWSEC_sha1, CALG_SHA1,
    sizeof(rgbOID_OIWSEC_sha), rgbOID_OIWSEC_sha, CALG_SHA1,
    sizeof(rgbOID_RSA_MD5), rgbOID_RSA_MD5, CALG_MD5,
    sizeof(rgbOID_RSA_MD2), rgbOID_RSA_MD2, CALG_MD2,

    // Signature OIDs
    sizeof(rgbOID_RSA_SHA1RSA), rgbOID_RSA_SHA1RSA, CALG_SHA1,
    sizeof(rgbOID_RSA_MD5RSA), rgbOID_RSA_MD5RSA, CALG_MD5,
    sizeof(rgbOID_OIWSEC_sha1RSASign), rgbOID_OIWSEC_sha1RSASign, CALG_SHA1,
    sizeof(rgbOID_OIWSEC_shaRSA), rgbOID_OIWSEC_shaRSA, CALG_SHA1,
    sizeof(rgbOID_OIWSEC_md5RSA), rgbOID_OIWSEC_md5RSA, CALG_MD5,
    sizeof(rgbOID_RSA_MD2RSA), rgbOID_RSA_MD2RSA, CALG_MD2,
    sizeof(rgbOID_OIWDIR_md2RSA), rgbOID_OIWDIR_md2RSA, CALG_MD2,
};
#define HASH_ALG_CNT (sizeof(HashAlgTable) / sizeof(HashAlgTable[0]))



//+-------------------------------------------------------------------------
//  Decodes an ASN.1 encoded Algorithm Identifier and converts to
//  a CAPI Hash AlgID, such as, CALG_SHA1 or CALG_MD5.
//
//  Returns 0 if there isn't a CAPI AlgId corresponding to the Algorithm
//  Identifier.
//
//  Only CALG_SHA1, CALG_MD5 and CALG_MD2 are supported.
//--------------------------------------------------------------------------
ALG_ID
WINAPI
MinCryptDecodeHashAlgorithmIdentifier(
    IN PCRYPT_DER_BLOB pAlgIdValueBlob
    )
{
    ALG_ID HashAlgId = 0;
    LONG lSkipped;
    CRYPT_DER_BLOB rgAlgIdBlob[MINASN1_ALGID_BLOB_CNT];
    DWORD cbEncodedOID;
    const BYTE *pbEncodedOID;
    DWORD i;

    lSkipped = MinAsn1ParseAlgorithmIdentifier(
        pAlgIdValueBlob,
        rgAlgIdBlob
        );
    if (0 >= lSkipped)
        goto CommonReturn;

    cbEncodedOID = rgAlgIdBlob[MINASN1_ALGID_OID_IDX].cbData;
    pbEncodedOID = rgAlgIdBlob[MINASN1_ALGID_OID_IDX].pbData;

    for (i = 0; i < HASH_ALG_CNT; i++) {
        if (cbEncodedOID == HashAlgTable[i].cbEncodedOID &&
                0 == memcmp(pbEncodedOID, HashAlgTable[i].pbEncodedOID,
                                cbEncodedOID)) {
            HashAlgId = HashAlgTable[i].AlgId;
            break;
        }
    }

CommonReturn:
    return HashAlgId;
}


#pragma warning (push)
// local variable 'Md5Ctx' may be used without having been initialized
#pragma warning (disable: 4701)

//+-------------------------------------------------------------------------
//  Hashes one or more memory blobs according to the Hash ALG_ID.
//
//  rgbHash is updated with the resultant hash. *pcbHash is updated with
//  the length associated with the hash algorithm.
//
//  If the function succeeds, the return value is ERROR_SUCCESS. Otherwise,
//  a nonzero error code is returned.
//
//  Only CALG_SHA1, CALG_MD5 and CALG_MD2 are supported.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptHashMemory(
    IN ALG_ID HashAlgId,
    IN DWORD cBlob,
    IN PCRYPT_DER_BLOB rgBlob,
    OUT BYTE rgbHash[MINCRYPT_MAX_HASH_LEN],
    OUT DWORD *pcbHash
    )
{
    A_SHA_CTX ShaCtx;
    MD5_CTX Md5Ctx;
    MD2_CTX Md2Ctx;
    DWORD iBlob;

    switch (HashAlgId) {
        case CALG_MD2:
            memset(&Md2Ctx, 0, sizeof(Md2Ctx));
            *pcbHash = MINCRYPT_MD2_HASH_LEN;
            break;

        case CALG_MD5:
            MD5Init(&Md5Ctx);
            *pcbHash = MINCRYPT_MD5_HASH_LEN;
            break;

        case CALG_SHA1:
            A_SHAInit(&ShaCtx);
            *pcbHash = MINCRYPT_SHA1_HASH_LEN;
            break;

        default:
            *pcbHash = 0;
            return NTE_BAD_ALGID;
    }

    for (iBlob = 0; iBlob < cBlob; iBlob++) {
        BYTE *pb = rgBlob[iBlob].pbData;
        DWORD cb = rgBlob[iBlob].cbData;

        if (0 == cb)
            continue;

        switch (HashAlgId) {
            case CALG_MD2:
                MD2Update(&Md2Ctx, pb, cb);
                break;

            case CALG_MD5:
                MD5Update(&Md5Ctx, pb, cb);
                break;

            case CALG_SHA1:
                A_SHAUpdate(&ShaCtx, pb, cb);
                break;
        }

    }

    switch (HashAlgId) {
        case CALG_MD2:
            MD2Final(&Md2Ctx);
            memcpy(rgbHash, Md2Ctx.state, MINCRYPT_MD2_HASH_LEN);
            break;

        case CALG_MD5:
            MD5Final(&Md5Ctx);
            assert(MD5DIGESTLEN == MINCRYPT_MD5_HASH_LEN);
            memcpy(rgbHash, Md5Ctx.digest, MD5DIGESTLEN);
            break;

        case CALG_SHA1:
            A_SHAFinal(&ShaCtx, rgbHash);
            break;
    }

    return ERROR_SUCCESS;

}

#pragma warning (pop)

//+=========================================================================
//  MinCryptVerifySignedHash Support Functions
//-=========================================================================

VOID
WINAPI
I_ReverseAndCopyBytes(
    OUT BYTE *pbDst,
    IN const BYTE *pbSrc,
    IN DWORD cb
    )
{
    if (0 == cb)
        return;
    for (pbDst += cb - 1; cb > 0; cb--)
        *pbDst-- = *pbSrc++;
}



//  The basis for much of the code in this function can be found in
//  \nt\ds\win32\ntcrypto\scp\nt_key.c
LONG
WINAPI
I_ConvertParsedRSAPubKeyToBSafePubKey(
    IN CRYPT_DER_BLOB rgRSAPubKeyBlob[MINASN1_RSA_PUBKEY_BLOB_CNT],
    OUT PBSAFE_PUB_KEY_CONTENT pBSafePubKeyContent
    )
{
    LONG lErr;
    DWORD cbModulus;
    const BYTE *pbAsn1Modulus;
    DWORD cbExp;
    const BYTE *pbAsn1Exp;
    DWORD cbTmpLen;
    LPBSAFE_PUB_KEY pBSafePubKey;

    // Get the ASN.1 public key modulus (BIG ENDIAN). The modulus length
    // is the public key byte length.
    cbModulus = rgRSAPubKeyBlob[MINASN1_RSA_PUBKEY_MODULUS_IDX].cbData;
    pbAsn1Modulus = rgRSAPubKeyBlob[MINASN1_RSA_PUBKEY_MODULUS_IDX].pbData;
    // Strip off a leading 0 byte. Its there in the decoded ASN
    // integer for an unsigned integer with the leading bit set.
    if (cbModulus > 1 && *pbAsn1Modulus == 0) {
        pbAsn1Modulus++;
        cbModulus--;
    }
    if (MAX_RSA_PUB_KEY_BYTE_LEN < cbModulus)
        goto ExceededMaxPubKeyModulusLen;

    // Get the ASN.1 public exponent (BIG ENDIAN).
    cbExp = rgRSAPubKeyBlob[MINASN1_RSA_PUBKEY_EXPONENT_IDX].cbData;
    pbAsn1Exp = rgRSAPubKeyBlob[MINASN1_RSA_PUBKEY_EXPONENT_IDX].pbData;
    // Strip off a leading 0 byte. Its there in the decoded ASN
    // integer for an unsigned integer with the leading bit set.
    if (cbExp > 1 && *pbAsn1Exp == 0) {
        pbAsn1Exp++;
        cbExp--;
    }
    if (sizeof(DWORD) < cbExp)
        goto ExceededMaxPubKeyExpLen;

    if (0 == cbModulus || 0 == cbExp)
        goto InvalidPubKey;

    // Update the BSAFE data structure from the parsed and length validated
    // ASN.1 public key modulus and exponent components.

    cbTmpLen = (sizeof(DWORD) * 2) - (cbModulus % (sizeof(DWORD) * 2));
    if ((sizeof(DWORD) * 2) != cbTmpLen)
        cbTmpLen += sizeof(DWORD) * 2;

    memset(pBSafePubKeyContent, 0, sizeof(*pBSafePubKeyContent));
    pBSafePubKey = &pBSafePubKeyContent->Header;
    pBSafePubKey->magic = RSA1;
    pBSafePubKey->keylen = cbModulus + cbTmpLen;
    pBSafePubKey->bitlen = cbModulus * 8;
    pBSafePubKey->datalen = cbModulus - 1;

    I_ReverseAndCopyBytes((BYTE *) &pBSafePubKey->pubexp, pbAsn1Exp, cbExp);
    I_ReverseAndCopyBytes(pBSafePubKeyContent->rgbModulus, pbAsn1Modulus,
        cbModulus);

    lErr = ERROR_SUCCESS;
CommonReturn:
    return lErr;

ExceededMaxPubKeyModulusLen:
ExceededMaxPubKeyExpLen:
InvalidPubKey:
    lErr = NTE_BAD_PUBLIC_KEY;
    goto CommonReturn;
}


//  The basis for much of the code in this function can be found in
//  \nt\ds\win32\ntcrypto\scp\nt_sign.c
LONG
WINAPI
I_VerifyPKCS1SigningFormat(
    IN BSAFE_PUB_KEY *pKey,
    IN ALG_ID HashAlgId,
    IN BYTE *pbHash,
    IN DWORD cbHash,
    IN BYTE *pbPKCS1Format
    )
{
    LONG lErr = ERROR_INTERNAL_ERROR;
    const BYTE **rgEncOptions;
    BYTE rgbTmpHash[MINCRYPT_MAX_HASH_LEN];
    DWORD i;
    DWORD cb;
    BYTE *pbStart;
    DWORD cbTmp;

    switch (HashAlgId)
    {
    case CALG_MD2:
        rgEncOptions = md2Encodings;
        break;

    case CALG_MD5:
        rgEncOptions = md5Encodings;
        break;

    case CALG_SHA:
        rgEncOptions = shaEncodings;
        break;

    default:
        goto UnsupportedHash;
    }

    // Reverse the hash to match the signature.
    for (i = 0; i < cbHash; i++)
        rgbTmpHash[i] = pbHash[cbHash - (i + 1)];

    // See if it matches.
    if (0 != memcmp(rgbTmpHash, pbPKCS1Format, cbHash))
    {
        goto BadSignature;
    }

    cb = cbHash;
    for (i = 0; 0 != *rgEncOptions[i]; i += 1)
    {
        pbStart = (LPBYTE)rgEncOptions[i];
        cbTmp = *pbStart++;
        if (0 == memcmp(&pbPKCS1Format[cb], pbStart, cbTmp))
        {
            cb += cbTmp;   // Adjust the end of the hash data.
            break;
        }
    }

    // check to make sure the rest of the PKCS #1 padding is correct
    if ((0x00 != pbPKCS1Format[cb])
        || (0x00 != pbPKCS1Format[pKey->datalen])
        || (0x1 != pbPKCS1Format[pKey->datalen - 1]))
    {
        goto BadSignature;
    }

    for (i = cb + 1; i < pKey->datalen - 1; i++)
    {
        if (0xff != pbPKCS1Format[i])
        {
            goto BadSignature;
        }
    }

    lErr = ERROR_SUCCESS;

CommonReturn:
    return lErr;

UnsupportedHash:
    lErr = NTE_BAD_ALGID;
    goto CommonReturn;

BadSignature:
    lErr = NTE_BAD_SIGNATURE;
    goto CommonReturn;
}
    

//+-------------------------------------------------------------------------
//  Verifies a signed hash.
//
//  The ASN.1 encoded Public Key Info is parsed and used to decrypt the
//  signed hash. The decrypted signed hash is compared with the input
//  hash.
//
//  If the signed hash was successfully verified, ERROR_SUCCESS is returned.
//  Otherwise, a nonzero error code is returned.
//
//  Only RSA signed hashes are supported.
//
//  Only MD2, MD5 and SHA1 hashes are supported.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptVerifySignedHash(
    IN ALG_ID HashAlgId,
    IN BYTE *pbHash,
    IN DWORD cbHash,
    IN PCRYPT_DER_BLOB pSignedHashContentBlob,
    IN PCRYPT_DER_BLOB pPubKeyInfoValueBlob
    )
{
    LONG lErr;
    LONG lSkipped;
    
    CRYPT_DER_BLOB rgPubKeyInfoBlob[MINASN1_PUBKEY_INFO_BLOB_CNT];
    CRYPT_DER_BLOB rgRSAPubKeyBlob[MINASN1_RSA_PUBKEY_BLOB_CNT];
    BSAFE_PUB_KEY_CONTENT BSafePubKeyContent;
    LPBSAFE_PUB_KEY pBSafePubKey;

    DWORD cbSignature;
    const BYTE *pbAsn1Signature;

    BYTE rgbBSafeIn[MAX_BSAFE_PUB_KEY_MODULUS_BYTE_LEN];
    BYTE rgbBSafeOut[MAX_BSAFE_PUB_KEY_MODULUS_BYTE_LEN];


    // Attempt to parse and convert the ASN.1 encoded public key into
    // an RSA BSAFE formatted key.
    lSkipped = MinAsn1ParsePublicKeyInfo(
        pPubKeyInfoValueBlob,
        rgPubKeyInfoBlob
        );
    if (0 >= lSkipped)
        goto ParsePubKeyInfoError;

    lSkipped = MinAsn1ParseRSAPublicKey(
        &rgPubKeyInfoBlob[MINASN1_PUBKEY_INFO_PUBKEY_IDX],
        rgRSAPubKeyBlob
        );
    if (0 >= lSkipped)
        goto ParseRSAPubKeyError;

    lErr = I_ConvertParsedRSAPubKeyToBSafePubKey(
        rgRSAPubKeyBlob,
        &BSafePubKeyContent
        );
    if (ERROR_SUCCESS != lErr)
        goto CommonReturn;

    pBSafePubKey = &BSafePubKeyContent.Header;
    
    // Get the ASN.1 signature (BIG ENDIAN).
    //
    // It must be the same length as the public key
    cbSignature = pSignedHashContentBlob->cbData;
    pbAsn1Signature = pSignedHashContentBlob->pbData;
    if (cbSignature != pBSafePubKey->bitlen / 8)
        goto InvalidSignatureLen;

    // Decrypt the signature (LITTLE ENDIAN)
    assert(sizeof(rgbBSafeIn) >= cbSignature);
    I_ReverseAndCopyBytes(rgbBSafeIn, pbAsn1Signature, cbSignature);
    memset(&rgbBSafeIn[cbSignature], 0, sizeof(rgbBSafeIn) - cbSignature);
    memset(rgbBSafeOut, 0, sizeof(rgbBSafeOut));

    if (!BSafeEncPublic(pBSafePubKey, rgbBSafeIn, rgbBSafeOut))
        goto BSafeEncPublicError;


    lErr = I_VerifyPKCS1SigningFormat(
        pBSafePubKey,
        HashAlgId,
        pbHash,
        cbHash,
        rgbBSafeOut
        );

CommonReturn:
    return lErr;

ParsePubKeyInfoError:
ParseRSAPubKeyError:
    lErr = NTE_BAD_PUBLIC_KEY;
    goto CommonReturn;

InvalidSignatureLen:
BSafeEncPublicError:
    lErr = NTE_BAD_SIGNATURE;
    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\mincrypt\test\tminver\testutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       testutil.h
//
//  Contents:   Test Utility API Prototypes and Definitions
//
//  History:    29-Jan-01   philh   created
//--------------------------------------------------------------------------

#ifndef __TEST_UTIL_H__
#define __TEST_UTIL_H__

#ifdef __cplusplus
extern "C" {
#endif

#include "wincrypt.h"
#include "minasn1.h"
#include "mincrypt.h"

//+-------------------------------------------------------------------------
//  Error output routines
//--------------------------------------------------------------------------
VOID
PrintErr(
    IN LPCSTR pszMsg,
    IN LONG lErr
    );

//+-------------------------------------------------------------------------
//  Test allocation and free routines
//--------------------------------------------------------------------------
LPVOID
TestAlloc(
    IN size_t cbBytes
    );

VOID
TestFree(
    IN LPVOID pv
    );

//+-------------------------------------------------------------------------
//  Allocate and convert a multi-byte string to a wide string. TestFree()
//  must be called to free the returned wide string.
//--------------------------------------------------------------------------
LPWSTR
AllocAndSzToWsz(
    IN LPCSTR psz
    );


//+-------------------------------------------------------------------------
//  Conversions functions between encoded OID and the dot string
//  representation
//--------------------------------------------------------------------------
#define MAX_OID_STRING_LEN          0x80
#define MAX_ENCODED_OID_LEN         0x80

BOOL
EncodedOIDToDot(
    IN PCRYPT_DER_BLOB pEncodedOIDBlob,
    OUT CHAR rgszOID[MAX_OID_STRING_LEN]
    );

BOOL
DotToEncodedOID(
    IN LPCSTR pszOID,
    OUT BYTE rgbEncodedOID[MAX_ENCODED_OID_LEN],
    OUT DWORD *pcbEncodedOID
    );

//+-------------------------------------------------------------------------
//  Functions to print bytes
//--------------------------------------------------------------------------
VOID
PrintBytes(
    IN PCRYPT_DER_BLOB pBlob
    );

VOID
PrintMultiLineBytes(
    IN LPCSTR pszHdr,
    IN PCRYPT_DER_BLOB pBlob
    );

//+-------------------------------------------------------------------------
//  Allocate and read an encoded DER blob from a file
//--------------------------------------------------------------------------
BOOL
ReadDERFromFile(
    IN LPCSTR  pszFileName,
    OUT PBYTE   *ppbDER,
    OUT PDWORD  pcbDER
    );

//+-------------------------------------------------------------------------
//  Write an encoded DER blob to a file
//--------------------------------------------------------------------------
BOOL
WriteDERToFile(
    IN LPCSTR  pszFileName,
    IN PBYTE   pbDER,
    IN DWORD   cbDER
    );

//+-------------------------------------------------------------------------
//  Display functions
//--------------------------------------------------------------------------


VOID
DisplayCert(
    IN CRYPT_DER_BLOB rgCertBlob[MINASN1_CERT_BLOB_CNT],
    IN BOOL fVerbose = FALSE
    );

VOID
DisplayName(
    IN PCRYPT_DER_BLOB pNameValueBlob
    );

VOID
DisplayExts(
    IN PCRYPT_DER_BLOB pExtsValueBlob
    );

VOID
DisplayCTL(
    IN PCRYPT_DER_BLOB pEncodedContentBlob,
    IN BOOL fVerbose = FALSE
    );

VOID
DisplayAttrs(
    IN LPCSTR pszHdr,
    IN PCRYPT_DER_BLOB pAttrsValueBlob
    );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\mincrypt\test\tminver\tminver.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1997
//
//  File:       tminver.cpp
//
//  Contents:   Minimal ASN.1 Parsing and Cryptographic API Tests
//
//              See Usage() for a list of test options.
//
//
//  Functions:  main
//
//  History:    29-Jan-01   philh   created
//--------------------------------------------------------------------------

#include <windows.h>
#include <assert.h>
#include "testutil.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

#define MAX_FILENAME_CNT    100
#define DEFAULT_ATTR_LEN    1000
#define MAX_ATTR_CNT        20

//+-------------------------------------------------------------------------
// Global Test Parameters
//--------------------------------------------------------------------------
BOOL fVerbose = FALSE;
BOOL fContent = FALSE;
BOOL fQuiet = FALSE;
LONG lQuietErr = 0;
DWORD cbFirstAttrLen = DEFAULT_ATTR_LEN;
ALG_ID HashAlgId = CALG_SHA1;



static void Usage(void)
{
    printf("Usage: ttrust [options] <TestName> <Filename>\n");
    printf("TestNames are:\n");
    printf("  Data                  - PKCS #7 SignedData\n");
    printf("  Cert                  - X.509 encoded certifcate\n");
    printf("  Certs                 - Certs in PKCS #7 SignedData\n");
    printf("  File                  - Authenticode Signed File\n");
    printf("  Cat                   - File(s) in System Catalogs\n");
    printf("\n");
    printf("Options are:\n");
    printf("  -Content              - Display content\n");
    printf("  -MD5                  - MD5 File hash default of SHA1\n");
    printf("\n");
    printf("  -h                    - This message\n");
    printf("  -v                    - Verbose\n");
    printf("  -q[<Number>]          - Quiet, expected error\n");
    printf("  -a<OID String>        - Attribute OID string\n");
    printf("  -A<Number>            - Attribute length, default of %d\n",
                                            DEFAULT_ATTR_LEN);
    printf("\n");
}

BOOL
TestData(
    IN LPCSTR pszFilename
    )
{
    BOOL fResult;
    LONG lErr;
    DWORD cbEncoded;
    PBYTE pbEncoded = NULL;
    CRYPT_DER_BLOB rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_BLOB_CNT];
    BOOL fCTL = FALSE;

    if (!ReadDERFromFile(pszFilename, &pbEncoded, &cbEncoded))
        goto ErrorReturn;

    lErr = MinCryptVerifySignedData(
        pbEncoded,
        cbEncoded,
        rgVerSignedDataBlob
        );

    if (fQuiet) {
        if (lErr != lQuietErr) {
            printf("Expected => 0x%x, ", lQuietErr);
            PrintErr("MinCryptVerifySignedData", lErr);
            goto ErrorReturn;
        } else
            goto SuccessReturn;
    }

    if (ERROR_SUCCESS != lErr)
        PrintErr("MinCryptVerifySignedData", lErr);

    if (0 == rgVerSignedDataBlob[
            MINCRYPT_VER_SIGNED_DATA_SIGNER_CERT_IDX].cbData)
        printf("No Signer\n");
    else {
        LONG lSkipped;
        CRYPT_DER_BLOB rgCertBlob[MINASN1_CERT_BLOB_CNT];

        printf("====  Signer  ====\n");

        lSkipped = MinAsn1ParseCertificate(
            rgVerSignedDataBlob[
                MINCRYPT_VER_SIGNED_DATA_SIGNER_CERT_IDX].pbData,
            rgVerSignedDataBlob[
                MINCRYPT_VER_SIGNED_DATA_SIGNER_CERT_IDX].cbData,
            rgCertBlob
            );

        if (0 > lSkipped)
            printf("MinAsn1ParseCertificate failed at offset: %d\n",
                -lSkipped - 1);
        else
            DisplayCert(rgCertBlob, fVerbose);

        if (fVerbose) {
            DisplayAttrs("Authenticated",
                &rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_AUTH_ATTRS_IDX]);
            DisplayAttrs("Unauthenticated",
                &rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_UNAUTH_ATTRS_IDX]);
        }

        printf("\n");
    }

    if (0 == rgVerSignedDataBlob[
            MINCRYPT_VER_SIGNED_DATA_CONTENT_OID_IDX].cbData)
        printf("No Content OID\n");
    else {
        CHAR rgszOID[MAX_OID_STRING_LEN];

        EncodedOIDToDot(&rgVerSignedDataBlob[
                MINCRYPT_VER_SIGNED_DATA_CONTENT_OID_IDX],
            rgszOID
            );

        if (0 == strcmp(rgszOID, szOID_CTL))
            fCTL = TRUE;

        printf("Content OID:: %s\n", rgszOID);
    }

    if (0 == rgVerSignedDataBlob[
            MINCRYPT_VER_SIGNED_DATA_CONTENT_DATA_IDX].cbData)
        printf("No Content Data\n");
    else {
        if (fCTL)
            printf("CTL ");
        printf("Content Data:: %d bytes\n",
            rgVerSignedDataBlob[
                MINCRYPT_VER_SIGNED_DATA_CONTENT_DATA_IDX].cbData);

        if (fContent) {
            if (fCTL) {
                printf("\n====  CTL  ====\n");
                DisplayCTL(&rgVerSignedDataBlob[
                    MINCRYPT_VER_SIGNED_DATA_CONTENT_DATA_IDX], fVerbose);
            } else
                PrintMultiLineBytes("    ", &rgVerSignedDataBlob[
                    MINCRYPT_VER_SIGNED_DATA_CONTENT_DATA_IDX]);
        }
    }

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    TestFree(pbEncoded);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

BOOL
TestCert(
    IN LPCSTR pszFilename
    )
{
    BOOL fResult;
    DWORD cbEncoded;
    PBYTE pbEncoded = NULL;
    LONG lSkipped;
    CRYPT_DER_BLOB rgCertBlob[MINASN1_CERT_BLOB_CNT];

    if (!ReadDERFromFile(pszFilename, &pbEncoded, &cbEncoded))
        goto ErrorReturn;

    printf("====  Cert  ====\n");

    lSkipped = MinAsn1ParseCertificate(
        pbEncoded,
        cbEncoded,
        rgCertBlob
        );

    if (0 > lSkipped) {
        printf("MinAsn1ParseCertificate failed at offset: %d\n",
            -lSkipped - 1);
        fResult = FALSE;
    } else {
        DisplayCert(rgCertBlob, fVerbose);
        fResult = TRUE;
    }

    printf("\n");

    fResult = TRUE;
CommonReturn:
    TestFree(pbEncoded);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

#define MAX_CERTS_CNT   256

BOOL
TestCerts(
    IN LPCSTR pszFilename
    )
{
    BOOL fResult;
    LONG lSkipped;
    DWORD cbEncoded;
    PBYTE pbEncoded = NULL;
    CRYPT_DER_BLOB rgrgCertBlob[MAX_CERTS_CNT][MINASN1_CERT_BLOB_CNT];
    DWORD cCert = MAX_CERTS_CNT;

    if (!ReadDERFromFile(pszFilename, &pbEncoded, &cbEncoded))
        goto ErrorReturn;

    lSkipped = MinAsn1ExtractParsedCertificatesFromSignedData(
        pbEncoded,
        cbEncoded,
        &cCert,
        rgrgCertBlob
        );
    if (0 > lSkipped) {
        printf("MinAsn1ExtractParsedCertificatesFromSignedData failed at offset: %d\n",
            -lSkipped - 1);
        goto ErrorReturn;
    }

    if (0 == cCert)
        printf("No Certs\n");
    else {
        DWORD i;
        LONG lErr;

        for (i = 0; i < cCert; i++) {
            printf("====  Cert[%d]  ====\n", i);
            lErr = MinCryptVerifyCertificate(
                rgrgCertBlob[i],
                cCert,
                rgrgCertBlob
                );
            
            printf("Verify: ");
            if (ERROR_SUCCESS == lErr)
                printf("Success\n");
            else
                printf("0x%x (%d) \n", lErr, lErr);

            DisplayCert(rgrgCertBlob[i], fVerbose);

            printf("\n");
        }
    }

    fResult = TRUE;
CommonReturn:
    TestFree(pbEncoded);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

BOOL
TestFile(
    IN LPCSTR pszFilename,
    IN OPTIONAL DWORD cAttrOID,
    IN OPTIONAL LPCSTR rgpszAttrOID[MAX_ATTR_CNT],
    IN OPTIONAL CRYPT_DER_BLOB rgAttrEncodedOIDBlob[MAX_ATTR_CNT]
    )
{
    BOOL fResult;
    LONG lErr;
    DWORD cbAttr = 0;
    LPWSTR pwszFilename = NULL;
    PCRYPT_DER_BLOB pAttrValueBlob = NULL;

    pwszFilename = AllocAndSzToWsz(pszFilename);

    if (0 != cAttrOID && 0 != cbFirstAttrLen) {
        if (NULL == (pAttrValueBlob =
                (PCRYPT_DER_BLOB) TestAlloc(cbFirstAttrLen)))
            goto ErrorReturn;
        cbAttr = cbFirstAttrLen;
    }

    lErr = MinCryptVerifySignedFile(
        MINCRYPT_FILE_NAME,
        (const VOID *) pwszFilename,
        cAttrOID,
        rgAttrEncodedOIDBlob,
        pAttrValueBlob,
        &cbAttr
        );

    if (fQuiet) {
        if (lErr != lQuietErr) {
            printf("Expected => 0x%x, ", lQuietErr);
            PrintErr("MinCryptVerifySignedFile", lErr);
            goto ErrorReturn;
        } else
            goto SuccessReturn;
    }

    if (ERROR_INSUFFICIENT_BUFFER == lErr) {
        printf("Insufficient Buffer, require: %d input: %d\n",
            cbAttr, cbFirstAttrLen);

        TestFree(pAttrValueBlob);

        if (NULL == (pAttrValueBlob =
                (PCRYPT_DER_BLOB) TestAlloc(cbAttr)))
            goto ErrorReturn;

        lErr = MinCryptVerifySignedFile(
            MINCRYPT_FILE_NAME,
            (const VOID *) pwszFilename,
            cAttrOID,
            rgAttrEncodedOIDBlob,
            pAttrValueBlob,
            &cbAttr
            );
    }

    if (ERROR_SUCCESS != lErr)
        PrintErr("MinVerifySignedFile", lErr);
    else {
        DWORD i;

        printf("MinVerifySignedFile succeeded\n");

        for (i = 0; i < cAttrOID; i++) {
            printf("====  Attr[%d]  ====\n", i);
            printf("OID: %s ", rgpszAttrOID[i]);
            PrintBytes(&rgAttrEncodedOIDBlob[i]);
            printf("Value:\n");
            PrintMultiLineBytes("    ", &pAttrValueBlob[i]);
        }
    }

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    TestFree(pwszFilename);
    TestFree(pAttrValueBlob);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

BOOL
TestCat(
    IN DWORD cFilename,
    IN LPCSTR rgpszFilename[MAX_FILENAME_CNT],
    IN OPTIONAL DWORD cAttrOID,
    IN OPTIONAL LPCSTR rgpszAttrOID[MAX_ATTR_CNT],
    IN OPTIONAL CRYPT_DER_BLOB rgAttrEncodedOIDBlob[MAX_ATTR_CNT]
    )
{
    BOOL fResult;
    LONG lErr;
    DWORD cbAttr = 0;
    LPWSTR rgpwszFilename[MAX_FILENAME_CNT];
    CRYPT_HASH_BLOB rgHashBlob[MAX_FILENAME_CNT];
    BYTE rgrgbHash[MAX_FILENAME_CNT][MINCRYPT_MAX_HASH_LEN];
    LONG rglErr[MAX_FILENAME_CNT];
    PCRYPT_DER_BLOB pAttrValueBlob = NULL;
    DWORD i;


    for (i = 0; i < cFilename; i++)
        rgpwszFilename[i] = AllocAndSzToWsz(rgpszFilename[i]);

    fResult = TRUE;
    for (i = 0; i < cFilename; i++) {
        rgHashBlob[i].pbData = rgrgbHash[i];
        rgHashBlob[i].cbData = 0;
        lErr = MinCryptHashFile(
            MINCRYPT_FILE_NAME,
            (const VOID *) rgpwszFilename[i],
            HashAlgId,
            rgHashBlob[i].pbData,
            &rgHashBlob[i].cbData
            );

        if (ERROR_SUCCESS != lErr) {
            printf("<%S> ", rgpwszFilename[i]);
            PrintErr("MinCryptHashFile", lErr);
            fResult = FALSE;
        }
    }

    if (!fResult)
        goto ErrorReturn;

    if (0 != cAttrOID && 0 != cbFirstAttrLen) {
        if (NULL == (pAttrValueBlob =
                (PCRYPT_DER_BLOB) TestAlloc(cbFirstAttrLen)))
            goto ErrorReturn;
        cbAttr = cbFirstAttrLen;
    }

    lErr = MinCryptVerifyHashInSystemCatalogs(
        HashAlgId,
        cFilename,
        rgHashBlob,
        rglErr,
        cAttrOID,
        rgAttrEncodedOIDBlob,
        pAttrValueBlob,
        &cbAttr
        );


    if (ERROR_INSUFFICIENT_BUFFER == lErr) {
        printf("Insufficient Buffer, require: %d input: %d\n",
            cbAttr, cbFirstAttrLen);

        TestFree(pAttrValueBlob);

        if (NULL == (pAttrValueBlob =
                (PCRYPT_DER_BLOB) TestAlloc(cbAttr)))
            goto ErrorReturn;

        lErr = MinCryptVerifyHashInSystemCatalogs(
            HashAlgId,
            cFilename,
            rgHashBlob,
            rglErr,
            cAttrOID,
            rgAttrEncodedOIDBlob,
            pAttrValueBlob,
            &cbAttr
            );
    }

    if (ERROR_SUCCESS != lErr) {
        PrintErr("MinCryptVerifyHashInSystemCatalogs", lErr);
        goto ErrorReturn;
    }

    if (fQuiet) {
        fResult = TRUE;

        for (i = 0; i < cFilename; i++) {
            if (rglErr[i] != lQuietErr) {
                printf("<%S> ", rgpwszFilename[i]);
                printf("Expected => 0x%x, ", lQuietErr);
                PrintErr("MinCryptVerifyHashInSystemCatalogs", rglErr[i]);
                fResult = FALSE;
            }
        }

        if (fResult)
            goto SuccessReturn;
        else
            goto ErrorReturn;
    }


    printf("MinCryptVerifyHashInSystemCatalogs succeeded\n");
    for (i = 0; i < cFilename; i++) {
        DWORD j;

        printf("#####  [%d] <%S>  #####\n", i, rgpwszFilename[i]);
        if (ERROR_SUCCESS == rglErr[i])
            printf("Verify: SUCCESS\n");
        else {
            printf("%S ",  rgpwszFilename[i]);
            PrintErr("Verify", rglErr[i]);
        }

        printf("Hash:");
        PrintBytes(&rgHashBlob[i]);

        for (j = 0; j < cAttrOID; j++) {
            printf("====  Attr[%d]  ====\n", j);
            printf("OID: %s ", rgpszAttrOID[j]);
            PrintBytes(&rgAttrEncodedOIDBlob[j]);
            printf("Value:\n");
            PrintMultiLineBytes("    ", &pAttrValueBlob[i*cAttrOID + j]);
        }

        printf("\n");
    }

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    for (i = 0; i < cFilename; i++)
        TestFree(rgpwszFilename[i]);
    TestFree(pAttrValueBlob);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}


int _cdecl main(int argc, char * argv[]) 
{
    BOOL fResult;
    DWORD cFilename = 0;
    LPCSTR rgpszFilename[MAX_FILENAME_CNT];
    LPCSTR pszTestName = NULL;
    DWORD cAttrOID = 0;
    LPCSTR rgpszAttrOID[MAX_ATTR_CNT];
    CRYPT_DER_BLOB rgAttrEncodedOIDBlob[MAX_ATTR_CNT];
    BYTE rgbEncodedOID[MAX_ATTR_CNT][MAX_ENCODED_OID_LEN];


    int iStatus = 0;


    while (--argc>0) {
        if (**++argv == '-')
        {
            if (0 == _stricmp(argv[0]+1, "Content")) {
                fContent = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "MD5")) {
                HashAlgId = CALG_MD5;
            } else {
                switch(argv[0][1])
                {
                case 'v':
                    fVerbose = TRUE;
                    break;
                case 'q':
                    fQuiet = TRUE;
                    if (argv[0][2])
                        lQuietErr = (LONG) strtoul(argv[0]+2, NULL, 0);
                    break;
                case 'a':
                    if (MAX_ATTR_CNT <= cAttrOID) {
                        printf("Too many Attribute OIDs\n");
                        goto BadUsage;
                    }
                    rgpszAttrOID[cAttrOID] = argv[0]+2;
                    rgAttrEncodedOIDBlob[cAttrOID].cbData = MAX_ENCODED_OID_LEN;
                    rgAttrEncodedOIDBlob[cAttrOID].pbData =
                        rgbEncodedOID[cAttrOID];
                    if (!DotToEncodedOID(
                            rgpszAttrOID[cAttrOID],
                            rgAttrEncodedOIDBlob[cAttrOID].pbData,
                            &rgAttrEncodedOIDBlob[cAttrOID].cbData
                            )) {
                        printf("Invalid OID: %s\n", rgpszAttrOID[cAttrOID]);
                        goto BadUsage;
                    }

                    cAttrOID++;
                    break;
                case 'A':
                    cbFirstAttrLen = strtoul(argv[0]+2, NULL, 0);
                    break;
                case 'h':
                default:
                    goto BadUsage;
                }
            }
        } else {
            if (pszTestName == NULL)
                pszTestName = argv[0];
            else if (cFilename < MAX_FILENAME_CNT)
                rgpszFilename[cFilename++] = argv[0];
            else {
                printf("Too many Filenames\n");
                goto BadUsage;
            }
        }
    }

    if (NULL == pszTestName) {
        printf("Missing TestName\n");
        goto BadUsage;
    }

    if (0 == cFilename) {
        printf("Missing Filename\n");
        goto BadUsage;
    }

    printf("command line: %s\n", GetCommandLine());

    if (0 == _stricmp(pszTestName, "Data"))
        fResult = TestData(rgpszFilename[0]);
    else if (0 == _stricmp(pszTestName, "Cert"))
        fResult = TestCert(rgpszFilename[0]);
    else if (0 == _stricmp(pszTestName, "Certs"))
        fResult = TestCerts(rgpszFilename[0]);
    else if (0 == _stricmp(pszTestName, "File"))
        fResult = TestFile(
            rgpszFilename[0],
            cAttrOID,
            rgpszAttrOID,
            rgAttrEncodedOIDBlob
            );
            
    else if (0 == _stricmp(pszTestName, "Cat"))
        fResult = TestCat(
            cFilename,
            rgpszFilename,
            cAttrOID,
            rgpszAttrOID,
            rgAttrEncodedOIDBlob
            );
    else {
        printf("Invalid TestName\n");
        goto BadUsage;
    }

    if (!fResult)
        goto ErrorReturn;

    printf("Passed\n");
    iStatus = 0;

CommonReturn:
    return iStatus;

ErrorReturn:
    iStatus = -1;
    printf("Failed\n");
    goto CommonReturn;

BadUsage:
    Usage();
    goto ErrorReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\algorithm.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Algorithm.h

  Content: Declaration of the CAlgorithm.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/
    
#ifndef __ALGORITHM_H_
#define __ALGORITHM_H_

#include "Resource.h"
#include "Lock.h"
#include "Error.h"
#include "Debug.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateAlgorithmObject

  Synopsis : Create an IAlgorithm object.

  Parameter: BOOL bReadOnly - TRUE if read-only, else FASLE.
  
             BOOL bAESAllowed - TRUE if AES algorithm is allowed.
  
             IAlgorithm ** ppIAlgorithm - Pointer to pointer to IAlgorithm 
                                          to receive the interface pointer.
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateAlgorithmObject (BOOL bReadOnly, 
                               BOOL bAESAllowed, 
                               IAlgorithm ** ppIAlgorithm);

////////////////////////////////////////////////////////////////////////////////
//
// CAlgorithm
//

class ATL_NO_VTABLE CAlgorithm : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CAlgorithm, &CLSID_Algorithm>,
    public ICAPICOMError<CAlgorithm, &IID_IAlgorithm>,
    public IDispatchImpl<IAlgorithm, &IID_IAlgorithm, &LIBID_CAPICOM,
                         CAPICOM_MAJOR_VERSION, CAPICOM_MINOR_VERSION>
{
public:
    CAlgorithm()
    {
    }

DECLARE_NO_REGISTRY()

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAlgorithm)
    COM_INTERFACE_ENTRY(IAlgorithm)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CAlgorithm)
END_CATEGORY_MAP()

    HRESULT FinalConstruct()
    {
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for Algorithm object.\n", hr);
            return hr;
        }

        m_bReadOnly = FALSE;
        m_bAESAllowed = FALSE;
        m_Name = CAPICOM_ENCRYPTION_ALGORITHM_RC2;
        m_KeyLength = CAPICOM_ENCRYPTION_KEY_LENGTH_MAXIMUM;

        return S_OK;
    }

//
// IAlgorithm
//
public:
    STDMETHOD(get_KeyLength)
        (/*[out, retval]*/ CAPICOM_ENCRYPTION_KEY_LENGTH * pVal);

    STDMETHOD(put_KeyLength)
        (/*[in]*/ CAPICOM_ENCRYPTION_KEY_LENGTH newVal);

    STDMETHOD(get_Name)
        (/*[out, retval]*/ CAPICOM_ENCRYPTION_ALGORITHM * pVal);

    STDMETHOD(put_Name)
        (/*[in]*/ CAPICOM_ENCRYPTION_ALGORITHM newVal);

    //
    // C++ member function needed to initialize the object.
    //
    STDMETHOD(Init)
        (BOOL bReadOnly,
         BOOL bAESAllowed);

private:
    CLock                         m_Lock;
    BOOL                          m_bReadOnly;
    BOOL                          m_bAESAllowed;
    CAPICOM_ENCRYPTION_ALGORITHM  m_Name;
    CAPICOM_ENCRYPTION_KEY_LENGTH m_KeyLength;
};

#endif //__ALGORITHM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\algorithm.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Algorithm.cpp

  Content: Implementation of CAlgorithm.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "Algorithm.h"
#include "Common.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateAlgorithmObject

  Synopsis : Create an IAlgorithm object.

  Parameter: BOOL bReadOnly - TRUE if read-only, else FASLE.
  
             BOOL bAESAllowed - TRUE if AES algorithm is allowed.
  
             IAlgorithm ** ppIAlgorithm - Pointer to pointer to IAlgorithm 
                                          to receive the interface pointer.
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateAlgorithmObject (BOOL bReadOnly, BOOL bAESAllowed, IAlgorithm ** ppIAlgorithm)
{
    HRESULT hr = S_OK;
    CComObject<CAlgorithm> * pCAlgorithm = NULL;

    DebugTrace("Entering CreateAlgorithmObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(ppIAlgorithm);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CAlgorithm>::CreateInstance(&pCAlgorithm)))
        {
            DebugTrace("Error [%#x]: CComObject<CAlgorithm>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize object.
        //
        if (FAILED(hr = pCAlgorithm->Init(bReadOnly, bAESAllowed)))
        {
            DebugTrace("Error [%#x]: pCAlgorithm->Init() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return interface pointer to caller.
        //
        if (FAILED(hr = pCAlgorithm->QueryInterface(ppIAlgorithm)))
        {
            DebugTrace("Error [%#x]: pCAlgorithm->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreateAlgorithmObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (pCAlgorithm)
    {
        delete pCAlgorithm;
    }

    goto CommonExit;
}


///////////////////////////////////////////////////////////////////////////////
//
// CAlgorithm
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CAlgorithm::get_Name

  Synopsis : Return the enum name of the algorithm.

  Parameter: CAPICOM_ENCRYPTION_ALGORITHM * pVal - Pointer to 
                                                   CAPICOM_ENCRYPTION_ALGORITHM 
                                                   to receive result.
  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CAlgorithm::get_Name (CAPICOM_ENCRYPTION_ALGORITHM * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CAlgorithm::get_Name().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
        *pVal = m_Name;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CAlgorithm:get_Name().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CAlgorithm::put_Name

  Synopsis : Set algorithm enum name.

  Parameter: CAPICOM_ENCRYPTION_ALGORITHM newVal - Algorithm enum name.
  
  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CAlgorithm::put_Name (CAPICOM_ENCRYPTION_ALGORITHM newVal)
{
    HRESULT    hr = S_OK;
    HCRYPTPROV hCryptProv = NULL;

    DebugTrace("Entering CAlgorithm::put_Name().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure it is not read only.
        //
        if (m_bReadOnly)
        {
            hr = CAPICOM_E_NOT_ALLOWED;

            DebugTrace("Error [%#x]: Writing to read-only Algorithm object is not allowed.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure algo is valid.
        //
        switch (newVal)
        {
            case CAPICOM_ENCRYPTION_ALGORITHM_RC2:
            case CAPICOM_ENCRYPTION_ALGORITHM_RC4:
            case CAPICOM_ENCRYPTION_ALGORITHM_DES:
            case CAPICOM_ENCRYPTION_ALGORITHM_3DES:
            {
                break;
            }

            case CAPICOM_ENCRYPTION_ALGORITHM_AES:
            {
                //
                // Make sure AES is allowed.
                //
                if (!m_bAESAllowed)
                {
                    hr = CAPICOM_E_NOT_ALLOWED;

                    DebugTrace("Error [%#x]: AES encryption is specifically not allowed.\n", hr);
                    goto ErrorExit;
                }

                break;
            }

            default:
            {
                hr = CAPICOM_E_INVALID_ALGORITHM;

                DebugTrace("Error [%#x]: Unknown algorithm enum name (%#x).\n", hr, newVal);
                goto ErrorExit;
            }
        }

        //
        // Store name.
        //
        m_Name = newVal;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resources.
    //
    if (hCryptProv)
    {
        ::ReleaseContext(hCryptProv);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CAlgorithm::put_Name().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CAlgorithm::get_KeyLength

  Synopsis : Return the enum name of the key length.

  Parameter: CAPICOM_ENCRYPTION_KEY_LENGTH * pVal - Pointer to 
                                                    CAPICOM_ENCRYPTION_KEY_LENGTH 
                                                    to receive result.
  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CAlgorithm::get_KeyLength (CAPICOM_ENCRYPTION_KEY_LENGTH * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CAlgorithm::get_KeyLength().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
        *pVal = m_KeyLength;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CAlgorithm:get_KeyLength().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CAlgorithm::put_KeyLength

  Synopsis : Set key length enum name.

  Parameter: CAPICOM_ENCRYPTION_KEY_LENGTH newVal - Key length enum name.
  
  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CAlgorithm::put_KeyLength (CAPICOM_ENCRYPTION_KEY_LENGTH newVal)
{
    HRESULT hr = S_OK;
    HCRYPTPROV hCryptProv = NULL;

    DebugTrace("Entering CAlgorithm::put_KeyLength().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        //
        // Make sure it is not read only.
        //
        if (m_bReadOnly)
        {
            hr = CAPICOM_E_NOT_ALLOWED;

            DebugTrace("Error [%#x]: Writing to read-only Algorithm object is not allowed.\n", hr);
            goto ErrorExit;
        }

        // Determine key length requested.
        //
        switch (newVal)
        {
            case CAPICOM_ENCRYPTION_KEY_LENGTH_MAXIMUM:
            case CAPICOM_ENCRYPTION_KEY_LENGTH_40_BITS:
            case CAPICOM_ENCRYPTION_KEY_LENGTH_56_BITS:
            case CAPICOM_ENCRYPTION_KEY_LENGTH_128_BITS:
            case CAPICOM_ENCRYPTION_KEY_LENGTH_192_BITS:
            case CAPICOM_ENCRYPTION_KEY_LENGTH_256_BITS:
            {
                break;
            }

            default:
            {
                hr = CAPICOM_E_INVALID_KEY_LENGTH;

                DebugTrace("Error [%#x]: Unknown key length enum name (%#x).\n", hr, newVal);
                goto ErrorExit;
            }
        }

        //
        // Store name.
        //
        m_KeyLength = newVal;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resources.
    //
    if (hCryptProv)
    {
        ::ReleaseContext(hCryptProv);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CAlgorithm::put_KeyLength().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// Private methods.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CAlgorithm::Init

  Synopsis : Initialize the object.

  Parameter: BOOL bReadOnly - TRUE for Read only, else FALSE.

             BOOL bAESAllowed - TRUE if AES algorithm is allowed.

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CAlgorithm::Init (BOOL bReadOnly, BOOL bAESAllowed)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CAlgorithm::Init().\n");

    m_bReadOnly = bReadOnly;
    m_bAESAllowed = bAESAllowed;

    DebugTrace("Leaving CAlgorithm::Init().\n");

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\adhelpers.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    ADHelpers.h

  Content: Declaration AdHelper.cpp.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#ifndef __ADHELPERS_H_
#define __ADHELPERS_H_

#include "Debug.h"
#include <ActiveDs.h>

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : LoadFromDirectory

  Synopsis : Load all certificates from the userCertificate attribute of users
             specified through the filter.

  Parameter: HCERTSTORE hCertStore - Certificate store handle of store to 
                                     receive all the certificates.
                                     
             BSTR bstrFilter - Filter (See Store::Open() for more info).

  Remark   : 

------------------------------------------------------------------------------*/

HRESULT LoadFromDirectory (HCERTSTORE hCertStore, 
                           BSTR       bstrFilter);

#endif // __ADHELPERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\attribute.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Attribute.cpp

  Content: Implementation of CAttribute.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "Attribute.h"
#include "Common.h"
#include "Convert.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateAttributebject

  Synopsis : Create an IAttribute object and initialize the object with data
             from the specified attribute.

  Parameter: CRYPT_ATTRIBUTE * pAttribute - Pointer to CRYPT_ATTRIBUTE.
 
             IAttribute ** ppIAttribute - Pointer to pointer IAttribute object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateAttributeObject (CRYPT_ATTRIBUTE * pAttribute,
                               IAttribute     ** ppIAttribute)
{
    HRESULT hr = S_OK;
    CAPICOM_ATTRIBUTE AttrName;
    CComVariant varValue;
    CComObject<CAttribute> * pCAttribute = NULL;

    DebugTrace("Entering CreateAttributeObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pAttribute);
    ATLASSERT(ppIAttribute);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CAttribute>::CreateInstance(&pCAttribute)))
        {
            DebugTrace("Error [%#x]: CComObject<CAttribute>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Determine OID value.
        //
        if (0 == ::strcmp(pAttribute->pszObjId, szOID_RSA_signingTime))
        {
            DATE       SigningTime;
            SYSTEMTIME st;
            CRYPT_DATA_BLOB FileTimeBlob = {0, NULL};
       
            if (FAILED(hr = ::DecodeObject(szOID_RSA_signingTime,
                                           pAttribute->rgValue->pbData,
                                           pAttribute->rgValue->cbData,
                                           &FileTimeBlob)))
            {
                DebugTrace("Error [%#x]: DecodeObject() failed.\n", hr);
                goto ErrorExit;
            }

            if (!::FileTimeToSystemTime((FILETIME *) FileTimeBlob.pbData, &st) ||
                !::SystemTimeToVariantTime(&st, &SigningTime))
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());

                ::CoTaskMemFree(FileTimeBlob.pbData);

                DebugTrace("Error [%#x]: unable to convert FILETIME to DATE.\n", hr);
                goto ErrorExit;
            }

            ::CoTaskMemFree(FileTimeBlob.pbData);

            AttrName = CAPICOM_AUTHENTICATED_ATTRIBUTE_SIGNING_TIME;
            varValue = SigningTime;
            varValue.ChangeType(VT_DATE, NULL);
        }
        else if (0 == ::strcmp(pAttribute->pszObjId, szOID_CAPICOM_DOCUMENT_NAME))
        {
            CComBSTR bstrName;
            CRYPT_DATA_BLOB NameBlob = {0, NULL};

            if (FAILED(hr = ::DecodeObject(X509_OCTET_STRING,
                                           pAttribute->rgValue->pbData,
                                           pAttribute->rgValue->cbData,
                                           &NameBlob)))
            {
                DebugTrace("Error [%#x]: DecodeObject() failed.\n", hr);
                goto ErrorExit;
            }

            if (FAILED(hr = ::BlobToBstr((DATA_BLOB *) NameBlob.pbData, &bstrName)))
            {
                ::CoTaskMemFree(NameBlob.pbData);

                DebugTrace("Error [%#x]: BlobToBstr() failed.\n", hr);
                goto ErrorExit;
            }

            ::CoTaskMemFree(NameBlob.pbData);

            AttrName = CAPICOM_AUTHENTICATED_ATTRIBUTE_DOCUMENT_NAME;
            varValue = bstrName;
        }
        else if (0 == ::strcmp(pAttribute->pszObjId, szOID_CAPICOM_DOCUMENT_DESCRIPTION))
        {
            CComBSTR bstrDesc;
            CRYPT_DATA_BLOB DescBlob = {0, NULL};

            if (FAILED(hr = ::DecodeObject(X509_OCTET_STRING,
                                           pAttribute->rgValue->pbData,
                                           pAttribute->rgValue->cbData,
                                           &DescBlob)))
            {
                DebugTrace("Error [%#x]: DecodeObject() failed.\n", hr);
                goto ErrorExit;
            }

            if (FAILED(hr = ::BlobToBstr((DATA_BLOB *) DescBlob.pbData, &bstrDesc)))
            {
                ::CoTaskMemFree(DescBlob.pbData);

                DebugTrace("Error [%#x]: BlobToBstr() failed.\n", hr);
                goto ErrorExit;
            }

            ::CoTaskMemFree(DescBlob.pbData);

            AttrName = CAPICOM_AUTHENTICATED_ATTRIBUTE_DOCUMENT_DESCRIPTION;
            varValue = bstrDesc;
        }
        else
        {
            hr = CAPICOM_E_ATTRIBUTE_INVALID_NAME;

            DebugTrace("Error [%#x]: Unknown attribute OID (%#s).\n", hr, pAttribute->pszObjId);
            goto ErrorExit;
        }

        //
        // Initialize object.
        //
        if (FAILED(hr = pCAttribute->Init(AttrName, pAttribute->pszObjId, varValue)))
        {
            DebugTrace("Error [%#x]: pCAttribute->Init() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return interface pointer to caller.
        //
        if (FAILED(hr = pCAttribute->QueryInterface(ppIAttribute)))
        {
            DebugTrace("Error [%#x]: pCAttribute->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreateAttributeObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    if (pCAttribute)
    {
        delete pCAttribute;
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AttributePairIsValid

  Synopsis : Check to see if an attribute name and value pair is valid.

  Parameter: CAPICOM_ATTRIBUTE AttrName - Attribute name.

             VARIANT varValue - Attribute value.

  Remark   :

------------------------------------------------------------------------------*/

HRESULT AttributePairIsValid (CAPICOM_ATTRIBUTE AttrName, 
                              VARIANT           varValue)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering AttributePairIsValid()");

    //
    // Check attribute name and value pair validity.
    //
    switch (AttrName)
    {
        case CAPICOM_AUTHENTICATED_ATTRIBUTE_SIGNING_TIME:
        {
            if (VT_DATE != varValue.vt)
            {
                hr = CAPICOM_E_ATTRIBUTE_INVALID_VALUE;

                DebugTrace("Error [%#x]: attribute name and value type does not match.\n", hr);
            }

            break;
        }

        case CAPICOM_AUTHENTICATED_ATTRIBUTE_DOCUMENT_NAME:
        case CAPICOM_AUTHENTICATED_ATTRIBUTE_DOCUMENT_DESCRIPTION:
        {
            if (VT_BSTR != varValue.vt)
            {
                hr = CAPICOM_E_ATTRIBUTE_INVALID_VALUE;

                DebugTrace("Error [%#x]: attribute data type does not match attribute name type, expecting a BSTR variant.\n", hr);
            }
        
            break;
        }

        default:
        {
            hr = CAPICOM_E_ATTRIBUTE_INVALID_NAME;

            DebugTrace("Error [%#x]: unknown attribute name (%#x).\n", hr, AttrName);
            break;
        }
    }

    DebugTrace("Leaving AttributePairIsValid().\n");

    return hr;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AttributeIsValid

  Synopsis : Check to see if an attribute is valid.

  Parameter: IAttribute * pVal - Attribute to be checked.

  Remark   :

------------------------------------------------------------------------------*/

HRESULT AttributeIsValid (IAttribute * pAttribute)
{
    HRESULT hr = S_OK;

    CAPICOM_ATTRIBUTE AttrName;
    CComVariant       varValue;

    DebugTrace("Entering AttributeIsValid()");

    //
    // Sanity check.
    //
    ATLASSERT(pAttribute);

    //
    // Get attribute name.
    //
    if (FAILED(hr = pAttribute->get_Name(&AttrName)))
    {
        DebugTrace("Error [%#x]: pVal->get_Name() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Get attribute value.
    //
    if (FAILED(hr = pAttribute->get_Value(&varValue)))
    {
        DebugTrace("Error [%#x]: pVal->get_Value() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Check attribute name and value pair validity.
    //
    if (FAILED(hr = AttributePairIsValid(AttrName, varValue)))
    {
        DebugTrace("Error [%#x]: AttributePairIsValid() failed.\n", hr);
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving AttributeIsValid().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AttributeIsSupported

  Synopsis : Check to see if an attribute is supported.

  Parameter: LPSTR pszObjId - Pointer to attribute OID.

  Remark   :

------------------------------------------------------------------------------*/

BOOL AttributeIsSupported (LPSTR pszObjId)
{
    //
    // Sanity check.
    //
    ATLASSERT(pszObjId);

    return (0 == ::strcmp(pszObjId, szOID_RSA_signingTime) ||
            0 == ::strcmp(pszObjId, szOID_CAPICOM_DOCUMENT_NAME) ||
            0 == ::strcmp(pszObjId, szOID_CAPICOM_DOCUMENT_DESCRIPTION));
}

///////////////////////////////////////////////////////////////////////////////
//
// CAttribute
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CAttribute::get_Name

  Synopsis : Return the name of the attribute.

  Parameter: CAPICOM_ATTRIBUTE * pVal - Pointer to CAPICOM_ATTRIBUTE to receive 
                                        result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CAttribute::get_Name (CAPICOM_ATTRIBUTE * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CAttribute::get_Name().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure it is initialized.
        //
        if (!m_bInitialized)
        {
            hr = CAPICOM_E_ATTRIBUTE_NAME_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: attribute name has not been initialized.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
        *pVal = m_AttrName;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CAttribute::get_Name().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CAttribute::put_Name

  Synopsis : Set attribute enum name.

  Parameter: CAPICOM_ATTRIBUTE newVal - attribute enum name.
  
  Remark   : 

------------------------------------------------------------------------------*/

STDMETHODIMP CAttribute::put_Name (CAPICOM_ATTRIBUTE newVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CAttribute::put_Name().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    //
    // Reset value based on EKU name.
    //
    switch (newVal)
    {
        case CAPICOM_AUTHENTICATED_ATTRIBUTE_SIGNING_TIME:
        {
            if (!(m_bstrOID = szOID_RSA_signingTime))
            {
                hr = E_OUTOFMEMORY;

                DebugTrace("Error [%#x]: m_bstrOID = szOID_RSA_signingTime failed.\n", hr);
                goto ErrorExit;
            }
            break;
        }

        case CAPICOM_AUTHENTICATED_ATTRIBUTE_DOCUMENT_NAME:
        {
            if (!(m_bstrOID = szOID_CAPICOM_DOCUMENT_NAME))
            {
                hr = E_OUTOFMEMORY;

                DebugTrace("Error [%#x]: m_bstrOID = szOID_CAPICOM_DOCUMENT_NAME failed.\n", hr);
                goto ErrorExit;
            }
            break;
        }

        case CAPICOM_AUTHENTICATED_ATTRIBUTE_DOCUMENT_DESCRIPTION:
        {
            if (!(m_bstrOID = szOID_CAPICOM_DOCUMENT_DESCRIPTION))
            {
                hr = E_OUTOFMEMORY;

                DebugTrace("Error [%#x]: m_bstrOID = szOID_CAPICOM_DOCUMENT_DESCRIPTION failed.\n", hr);
                goto ErrorExit;
            }
            break;
        }

        default:
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Unknown attribute name (%#x).\n", hr, newVal);
            goto ErrorExit;
        }
    }

    //
    // Store name.
    //
    m_AttrName = newVal;
    m_varValue.Clear();
    m_bInitialized = TRUE;

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CAttribute::put_Name().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CAttribute::get_Value

  Synopsis : Return the actual value of the attribute.

  Parameter: VARIANT * pVal - Pointer to VARIANT to receive value.

  Remark   : Note: value type varies depending on the attribute type. For
             example, szOID_RSA_SigningTime would have a DATE value.

------------------------------------------------------------------------------*/

STDMETHODIMP CAttribute::get_Value (VARIANT * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CAttribute::get_Value().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure it was set.
        //
        if (VT_EMPTY == m_varValue.vt)
        {
            hr = CAPICOM_E_ATTRIBUTE_VALUE_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: attribute value has not been initialized.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
        if (FAILED(hr = ::VariantCopy(pVal, &m_varValue)))
        {
            DebugTrace("Error [%#x]: VariantCopy() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CAttribute::get_Value().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;

    return S_OK;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CAttribute::put_Value

  Synopsis : Set attribute value.

  Parameter: VARIANT newVal - attribute value.

  Remark   : Note: value type varies depending on the attribute type. For
             example, szOID_RSA_SigningTime would have a DATE value.

------------------------------------------------------------------------------*/

STDMETHODIMP CAttribute::put_Value (VARIANT newVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CAttribute::put_Value().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure it is initialized.
        //
        if (!m_bInitialized)
        {
            hr = CAPICOM_E_ATTRIBUTE_NAME_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: attribute name has not been initialized.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure data type matches attribute type.
        //
        if (FAILED(hr = AttributePairIsValid(m_AttrName, newVal)))
        {

            DebugTrace("Error [%#x]: AttributePairIsValid() failed.\n", hr);
            goto ErrorExit;
       }

        //
        // Store value.
        //
        m_varValue = newVal;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CAttribute::put_Value().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// Private methods.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CAttribute::Init

  Synopsis : Initialize the object.

  Parameter: DWORD AttrName - Enum name of Attribute.

             LPSTR lpszOID - Attribute OID string.

             VARIANT varValue - Value of attribute (data type depends on
                                the type of attribute).

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us with CERT_CONTEXT.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CAttribute::Init (CAPICOM_ATTRIBUTE AttrName, 
                               LPSTR             lpszOID, 
                               VARIANT           varValue)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CAttribute::Init().\n");

    //
    // Sanity check.
    //
    ATLASSERT(lpszOID);

    //
    // Init private members.
    //
    if (!(m_bstrOID = lpszOID))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Error [%#x]: m_bstrOID = lpszOID failed.\n", hr);
        goto ErrorExit;
    }

    m_bInitialized = TRUE;
    m_AttrName     = AttrName;
    m_varValue     = varValue;

CommonExit:

    DebugTrace("Leaving CAttribute::Init().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resources.
    //
    m_bstrOID.Empty();

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\adhelpers.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    ADHelpers.cpp

  Content: Implementation of helper routines for accessing Active Directory.
           Functions in this module require DSClient installed for down level
           clients.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "AdHelpers.h"
#include "Settings.h"

////////////////////
//
// Local typedefs
//

typedef HRESULT (WINAPI * PADSOPENOBJECT)(LPWSTR lpszPathName, 
                                          LPWSTR lpszUserName, 
                                          LPWSTR lpszPassword, 
                                          DWORD dwReserved, 
                                          REFIID riid, 
                                          VOID FAR * FAR *ppObject);

typedef HRESULT (WINAPI * PADSBUILDENUMERATOR)(IADsContainer * pADsContainer, 
                                               IEnumVARIANT ** ppEnumVariant);

typedef HRESULT (WINAPI * PADSENUMERATENEXT)(IEnumVARIANT * pEnumVariant, 
                                             ULONG          cElements, 
                                             VARIANT FAR  * pvar, 
                                             ULONG FAR    * pcElementsFetched);

typedef HRESULT (WINAPI * PADSFREEENUMERATOR)(IEnumVARIANT * pEnumVariant);


////////////////////////////////////////////////////////////////////////////////
//
// Local functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : IsUserCertificateInGC

  Synopsis : Determine if the userCertificate attribute is replicated in the GC.

  Parameter: HMODULE hDLL - ActiveDS.DLL handle.
  
             BOOL * pbResult - Pointer to BOOL to receive result.

  Remark   : 

------------------------------------------------------------------------------*/

static HRESULT IsUserCertificateInGC (HMODULE hDLL, 
                                      BOOL  * pbResult)
{
    HRESULT             hr          = S_OK;
    IADs              * pIADs       = NULL;
    IDirectorySearch  * pISchema    = NULL;  
    LPOLESTR            pszList[]   = {L"lDAPDisplayName", L"isMemberOfPartialAttributeSet"};
    LPOLESTR            pszFilter   = L"(&(objectCategory=attributeSchema)(lDAPDisplayName=userCertificate))";
    ADS_SEARCH_HANDLE   hSearch     = NULL;
    DWORD               dwNumPrefs  = 1;
    CComBSTR            bstrPath;
    CComBSTR            bstrSchema;
    ADS_SEARCHPREF_INFO SearchPrefs;
    CComVariant         var;
    PADSOPENOBJECT      pADsOpenObject;

    static BOOL bResult  = FALSE;
    static BOOL bChecked = FALSE;

    DebugTrace("Entering IsUserCertificateInGC().\n");

    //
    // Sanity check.
    //
    ATLASSERT(hDLL);
    ATLASSERT(pbResult);

    //
    // If we had already checked once, use the cached result.
    //
    if (bChecked)
    {
        *pbResult = bResult;
        goto CommonExit;
    }

    //
    // Initialize.
    //
    if (!(bstrPath = L"LDAP://") || !(bstrSchema = L"schemaNamingContext"))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Error [%#x]: bstrPath = L\"LDAP://\") || (bstrSchema  = L\"schemaNamingContext\" failed.", hr);
        goto ErrorExit;
    }

    //
    // Get ADsOpenObject address pointer.
    //
    if (!(pADsOpenObject = (PADSOPENOBJECT) ::GetProcAddress(hDLL, "ADsOpenObject")))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: GetProcAddress() failed to load ADsOpenObject().\n", hr);
        goto ErrorExit;
    }

    //
    // Bind to rootDSE to get the schemaNamingContext property.
    //
    if (FAILED(hr = pADsOpenObject(L"LDAP://rootDSE",
                                   NULL,
                                   NULL,
                                   ADS_SECURE_AUTHENTICATION,
                                   IID_IADs,
                                   (void **) &pIADs)))
    {
        DebugTrace("Error [%#x]: ADsOpenObject() failed for IID_IADs.\n", hr);
        goto ErrorExit;
    }

    //
    // Get schema container path.
    //
    if (FAILED(hr = pIADs->Get(bstrSchema, &var)))
    {
        DebugTrace("Error [%#x]: pIADs->Get() failed.\n", hr);
        goto ErrorExit;
    }
    //
    // Build path to the schema container.
    //
    if (FAILED(hr = bstrPath.AppendBSTR(var.bstrVal)))
    {
        DebugTrace("Error [%#x]: bstrPath.AppendBSTR() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Bind to the actual schema container.
    //
    if (FAILED(hr = pADsOpenObject(bstrPath, 
                                   NULL,
                                   NULL,
                                   ADS_SECURE_AUTHENTICATION,
                                   IID_IDirectorySearch, 
                                   (void **) &pISchema)))
    {
        DebugTrace("Error [%#x]: ADsOpenObject() failed for IID_IDirectorySearch.\n", hr);
        goto ErrorExit;
    }

    //
    // Attributes are one-level deep in the Schema container so only 
    // need to search one level.
    //
    SearchPrefs.dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    SearchPrefs.vValue.dwType = ADSTYPE_INTEGER;
    SearchPrefs.vValue.Integer = ADS_SCOPE_ONELEVEL;

    //
    // Set the search preference.
    //
    if (FAILED(hr = pISchema->SetSearchPreference(&SearchPrefs, dwNumPrefs)))
    {
        DebugTrace("Error [%#x]: pISchema->SetSearchPreference() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Execute search.
    //
    if (FAILED(hr = pISchema->ExecuteSearch(pszFilter,
                                            pszList,
                                            sizeof(pszList) / sizeof(LPOLESTR),
                                            &hSearch)))
    {
        DebugTrace("Error [%#x]: pISchema->ExecuteSearch() failed.\n", hr);
        goto ErrorExit;
    }
                                            
    //
    // Retrieve first row of data.
    //
    if (FAILED(hr = pISchema->GetFirstRow(hSearch)))
    {
        DebugTrace("Error [%#x]: pISchema->GetFirstRow() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Loop until no more row.
    //
    while (S_ADS_NOMORE_ROWS != hr)
    {
        ADS_SEARCH_COLUMN Column;

        //
        // Get the lDAPDisplayName column.
        //
        if (FAILED(hr = pISchema->GetColumn(hSearch, 
                                            L"lDAPDisplayName", 
                                            &Column)))
        {

            DebugTrace("Error [%#x]: pISchema->GetColumn() failed.\n", hr);
            goto ErrorExit;
        }

        DebugTrace("Info: %ls = %ls\n", Column.pszAttrName, Column.pADsValues->CaseIgnoreString);

        //
        // Is this attributeSchema for userCertificate?
        //
        if (0 == ::wcscmp(L"userCertificate", Column.pADsValues->CaseIgnoreString))
        {
            pISchema->FreeColumn(&Column);

            //
            // Get the isMemberOfPartialAttributeSet column.
            //
            if (FAILED(hr = pISchema->GetColumn(hSearch, 
                                                L"isMemberOfPartialAttributeSet", 
                                                &Column)))
            {

                DebugTrace("Error [%#x]: pISchema->GetColumn() failed.\n", hr);
                goto ErrorExit;
            }

             bResult = Column.pADsValues->Boolean;

            //
            // Should only have one row, so we don't really have to
            // break here, but is a little more effiecit to break,
            // since we don't need to ask for the next row to terminate
            // the loop.
            //
            pISchema->FreeColumn(&Column);

            break;
        }

        pISchema->FreeColumn(&Column);

        //
        // Get next row.
        //
        hr = pISchema->GetNextRow(hSearch);
    }

    //
    // Reset hr.
    //
    hr = S_OK;

    //
    // Return result to caller.
    //
    *pbResult = bResult;

CommonExit:
    //
    // Free resource.
    //
    if (hSearch)
    {
        pISchema->CloseSearchHandle(hSearch);
    }

    if (pISchema)
    {
        pISchema->Release();
    }
    if (pIADs)
    {
        pIADs->Release();
    }

    DebugTrace("Leaving IsUserCertificateInGC().\n");
    
    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : BuildRootDSESearch

  Synopsis : Build a search container of the rootDSE.

  Parameter: HMODULE hDLL - ActiveDS.DLL handle.
  
             IDirectorySearch ** ppISearch - To receive container to search.

  Remark   : 

------------------------------------------------------------------------------*/

static HRESULT BuildRootDSESearch (HMODULE             hDLL, 
                                   IDirectorySearch ** ppISearch)
{
    HRESULT  hr    = S_OK;
    IADs   * pIADs = NULL;
    CComBSTR       bstrPath;
    CComBSTR       bstrDefault;
    PADSOPENOBJECT pADsOpenObject;
    CComVariant    var;

    DebugTrace("Entering BuildRootDSESearch().\n");

    //
    // Sanity check.
    //
    ATLASSERT(hDLL);
    ATLASSERT(ppISearch);

    //
    // Initialize.
    //
    if (!(bstrPath = L"LDAP://") || !(bstrDefault = L"defaultNamingContext"))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Error [%#x]: bstrPath = L\"LDAP://\" || bstrDefault = L\"defaultNamingContext\" failed.", hr);
        goto ErrorExit;
    }

    //
    // Get ADsOpenObject address pointer.
    //
    if (!(pADsOpenObject = (PADSOPENOBJECT) ::GetProcAddress(hDLL, "ADsOpenObject")))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: GetProcAddress() failed to load ADsOpenObject().\n", hr);
        goto ErrorExit;
    }

    //
    // Get rootDSE.
    //
    if (FAILED(hr = pADsOpenObject(L"LDAP://rootDSE",
                                   NULL,
                                   NULL,
                                   ADS_SECURE_AUTHENTICATION,
                                   IID_IADs,
                                   (void **) &pIADs)))
    {
        DebugTrace("Error [%#x]: ADsOpenObject() failed for IID_IADs.\n", hr);
        goto ErrorExit;
    }

    //
    // Get current user's domain container DN.
    //
    if (FAILED(hr = pIADs->Get(bstrDefault, &var)))
    {
        DebugTrace("Error [%#x]: pIADs->Get() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Build path to the domain container.
    //
    if (FAILED(hr = bstrPath.AppendBSTR(var.bstrVal)))
    {
        DebugTrace("Error [%#x]: bstrPath.AppendBSTR(var.bstrVal) failed.", hr);
        goto ErrorExit;
    }

    //
    // Get IDerictorySearch interface pointer.
    //
    if (FAILED(hr = pADsOpenObject(bstrPath,
                                   NULL,
                                   NULL,
                                   ADS_SECURE_AUTHENTICATION,
                                   IID_IDirectorySearch,
                                   (void **) ppISearch)))
    {
        DebugTrace("Error [%#x]: ADsOpenObject() failed for IID_IDirectorySearch.\n", hr);
        goto ErrorExit;
    }

CommonExit:
    //
    // Free resource.
    //
    if (pIADs)
    {
        pIADs->Release();
    }

    DebugTrace("Leaving BuildRootDSESearch().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : BuildGlobalCatalogSearch

  Synopsis : Build a search container of the GC.

  Parameter: HMODULE hDLL - ActiveDS.DLL handle.
  
             IDirectorySearch ** ppISearch - To receive container to search.

  Remark   : 

------------------------------------------------------------------------------*/

static HRESULT BuildGlobalCatalogSearch (HMODULE             hDLL, 
                                         IDirectorySearch ** ppISearch)
{
    HRESULT         hr          = S_OK;
    IEnumVARIANT  * pIEnum      = NULL;
    IADsContainer * pIContainer = NULL;
    IDispatch     * pIDispatch  = NULL;
    ULONG           lFetched    = 0;

    PADSOPENOBJECT      pADsOpenObject      = NULL;
    PADSBUILDENUMERATOR pADsBuildEnumerator = NULL;
    PADSENUMERATENEXT   pADsEnumerateNext   = NULL;
    PADSFREEENUMERATOR  pADsFreeEnumerator  = NULL;
    CComVariant         var;

    DebugTrace("Entering BuildGlobalCatalogSearch().\n");

    //
    // Sanity check.
    //
    ATLASSERT(hDLL);
    ATLASSERT(ppISearch);

    //
    // Initialize.
    //
    *ppISearch = NULL;

    //
    // Get ADs function address pointers.
    //
    if (!(pADsOpenObject = (PADSOPENOBJECT) ::GetProcAddress(hDLL, "ADsOpenObject")))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: GetProcAddress() failed to load ADsOpenObject().\n", hr);
        goto ErrorExit;
    }
    if (!(pADsBuildEnumerator = (PADSBUILDENUMERATOR) ::GetProcAddress(hDLL, "ADsBuildEnumerator")))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: GetProcAddress() failed to load ADsBuildEnumerator().\n", hr);
        goto ErrorExit;
    }
    if (!(pADsEnumerateNext = (PADSENUMERATENEXT) ::GetProcAddress(hDLL, "ADsEnumerateNext")))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: GetProcAddress() failed to load ADsEnumerateNext().\n", hr);
        goto ErrorExit;
    }
    if (!(pADsFreeEnumerator = (PADSFREEENUMERATOR) ::GetProcAddress(hDLL, "ADsFreeEnumerator")))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: GetProcAddress() failed to load ADsFreeEnumerator().\n", hr);
        goto ErrorExit;
    }

    //
    // First, bind to the GC: namespace container object. The "real" GC DN 
    // is a single immediate child of the GC: namespace, which must be
    // obtained using enumeration.
    //
    if (FAILED(hr = pADsOpenObject(L"GC:",
                                   NULL,
                                   NULL,
                                   ADS_SECURE_AUTHENTICATION,
                                   IID_IADsContainer,
                                   (void **) &pIContainer)))
    {
        DebugTrace("Error [%#x]: ADsOpenObject() failed for IID_IADsContainer.\n", hr);
        goto ErrorExit;
    } 

    //
    // Fetch an enumeration interface for the GC container. 
    //
    if (FAILED(hr = pADsBuildEnumerator(pIContainer, &pIEnum)))
    {
        DebugTrace("Error [%#x]: ADsBuildEnumerator() failed.\n", hr);
        goto ErrorExit;
    } 

    //
    // Now enumerate.
    //
    if (FAILED(hr = pADsEnumerateNext(pIEnum, 1, &var, &lFetched)))
    {
        DebugTrace("Error [%#x]: ADsEnumerateNext() failed.\n", hr);
        goto ErrorExit;
    } 

    //
    // There should only be one child in the GC object.
    //
    if (1 != lFetched)
    {
        hr = E_UNEXPECTED;

        DebugTrace("Error [%#x]: ADsEnumerateNext() returns lFetched = %d, which is not 1.\n", hr, lFetched);
        goto ErrorExit;
    }

    //
    // Obtain the IDispatch pointer.
    //
    pIDispatch = V_DISPATCH(&var);

    //
    // Return IDirectorySearch interface pointer to caller.
    //
    if (FAILED(hr = pIDispatch->QueryInterface(IID_IDirectorySearch, 
                                               (void **) ppISearch)))
    {
        DebugTrace("Error [%#x]: pIDispatch->QueryInterface() failed for IID_IDirectorySearch.\n", hr);
        goto ErrorExit;
    }

CommonExit:
    //
    // Free resource.
    //
    if (pIEnum)
    {
        pADsFreeEnumerator(pIEnum);
    }
    if (pIContainer)
    {
        pIContainer->Release();
    }
    
    DebugTrace("Leaving BuildGlobalCatalogSearch().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : BuildADSearch

  Synopsis : Build a search container. We will first check to see if the
             userCertificate attribute is replicated in the global catalog.
             If so, we will bind the search to the GC, otherwise, will bind
             to default domain.

  Parameter: IDirectorySearch ** ppISearch - To receive container to search.

  Remark   : 

------------------------------------------------------------------------------*/

static HRESULT BuildADSearch (IDirectorySearch ** ppISearch)
{
    HRESULT hr      = S_OK;
    BOOL    bResult = FALSE;
    HMODULE hDLL    = NULL;
    CAPICOM_ACTIVE_DIRECTORY_SEARCH_LOCATION SearchLocation = ActiveDirectorySearchLocation();

    DebugTrace("Entering BuildADSearch().\n");

    //
    // Sanity check.
    //
    ATLASSERT(ppISearch);

    //
    // Initialize.
    //
    *ppISearch = NULL;

    //
    // Load ActiveDS.DLL.
    //
    if (!(hDLL = ::LoadLibrary("ActiveDS.DLL")))
    {
        hr = CAPICOM_E_NOT_SUPPORTED;

        DebugTrace("Error: DSClient not installed.\n");
        goto ErrorExit;
    }

    //
    // Did user specify a search location?
    //
    if (CAPICOM_SEARCH_ANY == SearchLocation)
    {
        //
        // No, so determine if userCerticate is replicated in the GC.
        //
        if (FAILED(hr = ::IsUserCertificateInGC(hDLL, &bResult)))
        {
            DebugTrace("Error [%#x]: IsUserCertificateInGC() failed.\n", hr);
            goto ErrorExit;
        } 

        //
        // Search GC or default domain.
        //
        SearchLocation = bResult ? CAPICOM_SEARCH_GLOBAL_CATALOG : CAPICOM_SEARCH_DEFAULT_DOMAIN;
    }

    //
    // Check to see where to search.
    //
    if (CAPICOM_SEARCH_GLOBAL_CATALOG == SearchLocation)
    {
        //
        // GC.
        //
        hr = ::BuildGlobalCatalogSearch(hDLL, ppISearch);
    } 
    else
    {
        //
        // rootDSE (default domain).
        //
        hr = ::BuildRootDSESearch(hDLL, ppISearch);
    }

CommonExit:
    //
    // Free resource.
    //
    if (hDLL)
    {
        ::FreeLibrary(hDLL);
    }

    DebugTrace("Leaving BuildADSearch().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : LoadUserCertificates

  Synopsis : Load all certificates from the userCertificate attribute of the
             specified search container for users specified through the filter.

  Parameter: HCERTSTORE hCertStore - Certificate store handle of store to 
                                     receive all the certificates.

             IDirectorySearch * pIContainer - Container to search.

             BSTR bstrFilter - Filter (See Store::Open() for more info).

  Remark   : 

------------------------------------------------------------------------------*/

static HRESULT LoadUserCertificates (HCERTSTORE         hCertStore,
                                     IDirectorySearch * pIContainer, 
                                     LPOLESTR           pszFilter)
{
    HRESULT           hr               = S_OK;
    ADS_SEARCH_HANDLE hSearch          = NULL;
    LPOLESTR          pszSearchList[]  = {L"userCertificate"};
    CComBSTR          bstrSearchFilter;
    ADS_SEARCHPREF_INFO SearchPrefs;

    DebugTrace("Entering LoadUserCertificates().\n");

    //
    // Sanity check.
    //
    ATLASSERT(hCertStore);
    ATLASSERT(pIContainer);
    ATLASSERT(pszFilter);

    try
    {
        //
        // Initialize.
        //
        if (!(bstrSearchFilter = L"(&(objectClass=user)(objectCategory=person)"))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error [%#x]: bstrSearchFilter = L\"(&(objectClass=user)(objectCategory=person)\" failed.\n", hr);
            goto ErrorExit;
        }
        if (!(bstrSearchFilter += pszFilter))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error [%#x]: bstrSearchFilter += pszFilter failed.\n", hr);
            goto ErrorExit;
        }
        if (!(bstrSearchFilter += L")"))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error [%#x]: bstrSearchFilter += L\")\" failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Specify subtree search.
        //
        SearchPrefs.dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
        SearchPrefs.vValue.dwType = ADSTYPE_INTEGER;
        SearchPrefs.vValue.Integer = ADS_SCOPE_SUBTREE;
 
        //
        // Set the search preference.
        //
        if (FAILED(hr = pIContainer->SetSearchPreference(&SearchPrefs, 1)))
        {
            DebugTrace("Error [%#x]: pIContainer->SetSearchPreference() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Execute the search.
        //
        if (FAILED(hr = pIContainer->ExecuteSearch(bstrSearchFilter,
                                                   pszSearchList,
                                                   sizeof(pszSearchList)/sizeof(LPOLESTR),
                                                   &hSearch)))
        {
            DebugTrace("Error [%#x]: pIContainer->ExecuteSearch() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Retrieve first row of data.
        //
        if (FAILED(hr = pIContainer->GetFirstRow(hSearch)))
        {
            DebugTrace("Error [%#x]: pIContainer->GetFirstRow() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Loop until no more row.
        //
        while (S_ADS_NOMORE_ROWS != hr)
        {
            DWORD dwValue;
            ADS_SEARCH_COLUMN Column;

            //
            // Try to get the userCertificate attribute.
            //
            if (FAILED(hr = pIContainer->GetColumn(hSearch, L"userCertificate", &Column)))
            {
                if (E_ADS_COLUMN_NOT_SET == hr)
                {
                    //
                    // Get next row.
                    //
                    hr = pIContainer->GetNextRow(hSearch);
                    continue;
                }

                DebugTrace("Error [%#x]: pIContainer->GetColumn() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Import all the certificate values.
            //
            for (dwValue = 0; dwValue < Column.dwNumValues; dwValue++)
            {
                if (!::CertAddEncodedCertificateToStore(hCertStore, 
                                                        CAPICOM_ASN_ENCODING, 
                                                        (const PBYTE) Column.pADsValues[dwValue].OctetString.lpValue, 
                                                        Column.pADsValues[dwValue].OctetString.dwLength, 
                                                        CERT_STORE_ADD_USE_EXISTING, 
                                                        NULL))
                {
                    hr = HRESULT_FROM_WIN32(::GetLastError());

                    pIContainer->FreeColumn(&Column);

                    DebugTrace("Error [%#x]: CertAddEncodedCertificateToStore() failed.\n", hr);
                    goto ErrorExit;
                }
            }

            pIContainer->FreeColumn(&Column);

            //
            // Get next row.
            //
            hr = pIContainer->GetNextRow(hSearch);
        }

        //
        // Reset return code.
        //
        hr = S_OK;
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:
    //
    // Free resource.
    //
    if (hSearch)
    {
        pIContainer->CloseSearchHandle(hSearch);
    }

    DebugTrace("Leaving LoadUserCertificates().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : LoadFromDirectory

  Synopsis : Load all certificates from the userCertificate attribute of users
             specified through the filter.

  Parameter: HCERTSTORE hCertStore - Certificate store handle of store to 
                                     receive all the certificates.
                                     
             BSTR bstrFilter - Filter (See Store::Open() for more info).

  Remark   : 

------------------------------------------------------------------------------*/

HRESULT LoadFromDirectory (HCERTSTORE hCertStore, 
                           BSTR       bstrFilter)
{
    HRESULT hr   = S_OK;
    IDirectorySearch * pIContainerToSearch = NULL;

    DebugTrace("Entering LoadFromDirectory().\n");
    
    //
    // Sanity check.
    //
    ATLASSERT(bstrFilter);
    ATLASSERT(hCertStore);

    //
    // Build the AD search container.
    //   
    if (FAILED(hr = ::BuildADSearch(&pIContainerToSearch)))
    {
        DebugTrace("Error [%#x]: BuildADSearch() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Load all userCertificate of the specified filter.
    //
    if (FAILED(hr = ::LoadUserCertificates(hCertStore,
                                           pIContainerToSearch,
                                           bstrFilter)))
    {
        DebugTrace("Error [%#x]: LoadUserCertificates() failed.\n", hr);
        goto ErrorExit;
    }

CommonExit:
    //
    // Free resource.
    //
    if (pIContainerToSearch)
    {
        pIContainerToSearch->Release();
    }

    DebugTrace("Leaving LoadFromDirectory().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\attributes.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000.

  File:    Attributes.cpp

  Content: Implementation of CAttributes.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "Attributes.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateAttributesObject

  Synopsis : Create and initialize an IAttributes collection object.

  Parameter: CRYPT_ATTRIBUTES * pAttrbibutes - Pointer to attributes to be 
                                               added to the collection object.
  
             IAttributes ** ppIAttributes - Pointer to pointer to IAttributes 
                                            to receive the interface pointer.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateAttributesObject (CRYPT_ATTRIBUTES * pAttributes,
                                IAttributes     ** ppIAttributes)
{
    HRESULT hr = S_OK;
    CComObject<CAttributes> * pCAttributes = NULL;

    DebugTrace("Entering CreateAttributesObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pAttributes);
    ATLASSERT(ppIAttributes);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CAttributes>::CreateInstance(&pCAttributes)))
        {
            DebugTrace("Error [%#x]: CComObject<CAttributes>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize object.
        //
        if (FAILED(hr = pCAttributes->Init(pAttributes)))
        {
            DebugTrace("Error [%#x]: pCAttributes->Init() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return IAttributes pointer to caller.
        //
        if (FAILED(hr = pCAttributes->QueryInterface(ppIAttributes)))
        {
            DebugTrace("Error [%#x]: pCAttributes->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreateAttributesObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (pCAttributes)
    {
        delete pCAttributes;
    }

    goto CommonExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// CAttributes
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CAttributes::Add

  Synopsis : Add an Attribute to the collection.

  Parameter: IAttribute * pVal - Attribute to be added.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CAttributes::Add (IAttribute * pVal)
{
    HRESULT  hr = S_OK;
    char     szIndex[33];
    CComBSTR bstrIndex;

    DebugTrace("Entering CAttributes::Add().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure we have a valid attribute object.
        //
        if (FAILED(hr = ::AttributeIsValid(pVal)))
        {
            DebugTrace("Error [%#x]: AttributeIsValid() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure we still have room to add.
        //
        if ((m_dwNextIndex + 1) > m_coll.max_size())
        {
            hr = CAPICOM_E_OUT_OF_RESOURCE;

            DebugTrace("Error [%#x]: Maximum entries (%#x) reached for Attributes collection.\n", 
                        hr, m_coll.size() + 1);
            goto ErrorExit;
        }

        //
        // BSTR index of numeric value.
        //
        wsprintfA(szIndex, "%#08x", ++m_dwNextIndex);

        if (!(bstrIndex = szIndex))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error [%#x]: bstrIndex = szIndex failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Now add object to collection map.
        //
        // Note that the overloaded = operator for CComPtr will
        // automatically AddRef to the object. Also, when the CComPtr
        // is deleted (happens when the Remove or map destructor is called), 
        // the CComPtr destructor will automatically Release the object.
        //
        m_coll[bstrIndex] = pVal;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CAttributes::Add().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CAttributes::Remove

  Synopsis : Remove a Attribute from the collection.

  Parameter: long Index - Attribute index (1-based).

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CAttributes::Remove (long Index)
{
    HRESULT  hr = S_OK;
    AttributeMap::iterator iter;

    DebugTrace("Entering CAttributes::Remove().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure parameter is valid.
        //
        if (Index < 1 || (DWORD) Index > m_coll.size())
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Index %d is out of range.\n", hr, Index);
            goto ErrorExit;
        }

        //
        // Find object in map.
        //
        Index--;
        iter = m_coll.begin(); 
        
        while (iter != m_coll.end() && Index > 0)
        {
             iter++; 
             Index--;
        }

        //
        // This should not happen.
        //
        if (iter == m_coll.end())
        {
            hr = CAPICOM_E_INTERNAL;

            DebugTrace("Error [%#x]: iterator went pass end of map.\n", hr);
            goto ErrorExit;
        }

        //
        // Now remove object in map.
        //
        m_coll.erase(iter);
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CAttributes::Remove().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CAttributes::Clear

  Synopsis : Remove all attributes from the collection.

  Parameter: None.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CAttributes::Clear (void)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CAttributes::Clear().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    //
    // Clear it.
    //
    m_coll.clear();
    
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CAttributes::Clear().\n");

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// Non COM functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CAttributes::Init

  Synopsis : Initialize the attributes collection object by adding all 
             individual attribute object to the collection.

  Parameter: CRYPT_ATTRIBUTES * pAttributes - Attribute to be added.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CAttributes::Init (CRYPT_ATTRIBUTES * pAttributes)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CAttributes::Init().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pAttributes);

    //
    // Initialize.
    //
    m_dwNextIndex = 0;

    //
    // Create the IAttribute object for each of the supported attribute. 
    //
    for (DWORD cAttr= 0; cAttr < pAttributes->cAttr; cAttr++)
    {
        CComPtr<IAttribute> pIAttribute = NULL;

        //
        // Add only supported attribute.
        //
        if (::AttributeIsSupported(pAttributes->rgAttr[cAttr].pszObjId))
        {
            if (FAILED(hr = ::CreateAttributeObject(&pAttributes->rgAttr[cAttr], &pIAttribute)))
            {
                DebugTrace("Error [%#x]: CreateAttributeObject() failed.\n", hr);
                goto ErrorExit;
            }

            if (FAILED(hr = Add(pIAttribute)))
            {
                DebugTrace("Error [%#x]: CAttributes::Add() failed.\n", hr);
                goto ErrorExit;
            }
        }
    }

CommonExit:

    DebugTrace("Leaving CAttributes::Init().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    m_coll.clear();

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\attribute.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows

  Copyright (C) Microsoft Corporation, 1995 - 1999.

  File:    Attribute.h

  Content: Declaration of CAttribute.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#ifndef __ATTRIBUTE_H_
#define __ATTRIBUTE_H_

#include "Resource.h"
#include "Lock.h"
#include "Error.h"
#include "Debug.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateAttributebject

  Synopsis : Create an IAttribute object and initialize the object with data
             from the specified attribute.

  Parameter: CRYPT_ATTRIBUTE * pAttribute - Pointer to CRYPT_ATTRIBUTE.
 
             IAttribute ** ppIAttribute - Pointer to pointer IAttribute object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateAttributeObject (CRYPT_ATTRIBUTE * pAttribute,
                               IAttribute     ** ppIAttribute);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AttributeIsValid

  Synopsis : Check to see if an attribute is valid.

  Parameter: IAttribute * pVal - Attribute to be checked.

  Remark   :

------------------------------------------------------------------------------*/

HRESULT AttributeIsValid (IAttribute * pAttribute);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AttributeIsSupported

  Synopsis : Check to see if an attribute is supported.

  Parameter: LPSTR pszObjID - Pointer to attribute OID.

  Remark   :

------------------------------------------------------------------------------*/

BOOL AttributeIsSupported (LPSTR pszObjId);


///////////////////////////////////////////////////////////////////////////////
//
// CAttribute
//
class ATL_NO_VTABLE CAttribute : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CAttribute, &CLSID_Attribute>,
    public ICAPICOMError<CAttribute, &IID_IAttribute>,
    public IDispatchImpl<IAttribute, &IID_IAttribute, &LIBID_CAPICOM,
                         CAPICOM_MAJOR_VERSION, CAPICOM_MINOR_VERSION>,
    public IObjectSafetyImpl<CAttribute, INTERFACESAFE_FOR_UNTRUSTED_CALLER | 
                                         INTERFACESAFE_FOR_UNTRUSTED_DATA>
{
public:
    CAttribute()
    {
    }

DECLARE_REGISTRY_RESOURCEID(IDR_ATTRIBUTE)

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAttribute)
    COM_INTERFACE_ENTRY(IAttribute)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CAttribute)
    IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
    IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
END_CATEGORY_MAP()

    HRESULT FinalConstruct()
    {
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for Attribute object.\n", hr);
            return hr;
        }

        m_bInitialized = FALSE;

        return S_OK;
    }

//
// IAttribute
//
public:
    STDMETHOD(get_Value)
        (/*[out, retval]*/ VARIANT *pVal);

    STDMETHOD(put_Value)
        (/*[in]*/ VARIANT newVal);

    STDMETHOD(get_Name)
        (/*[out, retval]*/ CAPICOM_ATTRIBUTE *pVal);

    STDMETHOD(put_Name)
        (/*[in]*/ CAPICOM_ATTRIBUTE newVal);

    //
    // C++ member function needed to initialize the object.
    //
    STDMETHOD(Init)
        (CAPICOM_ATTRIBUTE AttributeName, 
         LPSTR             lpszOID, 
         VARIANT           varValue);

private:
    CLock               m_Lock;
    BOOL                m_bInitialized;
    CAPICOM_ATTRIBUTE   m_AttrName;
    CComBSTR            m_bstrOID;
    CComVariant         m_varValue;
};

#endif //__ATTRIBUTE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\capicom.cpp ===
// CAPICOM.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f CAPICOMps.mk in the project directory.

//
// Turn off:
//
// - Unreferenced formal parameter warning.
// - Assignment within conditional expression warning.
//
#pragma warning (disable: 4100)
#pragma warning (disable: 4706)

#include "StdAfx.h"
#include "Resource.h"
#include <initguid.h>
#include "CAPICOM.h"
#include "CAPICOM_i.c"

#include "Algorithm.h"
#include "Attribute.h"
#include "Attributes.h"
#include "BasicConstraints.h"
#include "Certificate.h"
#include "Certificates.h"
#include "CertificatePolicies.h"
#include "CertificateStatus.h"
#include "Chain.h"
#include "EKU.h"
#include "EKUs.h"
#include "EncodedData.h"
#include "EncryptedData.h"
#include "EnvelopedData.h"
#include "ExtendedKeyUsage.h"
#include "ExtendedProperties.h"
#include "ExtendedProperty.h"
#include "Extension.h"
#include "Extensions.h"
#include "HashedData.h"
#include "KeyUsage.h"
#include "NoticeNumbers.h"
#include "OID.h"
#include "PolicyInformation.h"
#include "PrivateKey.h"
#include "PublicKey.h"
#include "Qualifier.h"
#include "Qualifiers.h"
#include "Recipients.h"
#include "Settings.h"
#include "SignedCode.h"
#include "SignedData.h"
#include "Signer2.h"
#include "Signers.h"
#include "Store.h"
#include "Template.h"
#include "Utilities.h"
#include "OIDs.h"

CComModule _Module;

/////////////////////////////////////////////////////////////////////////////
//
// Objec map
//

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY_NON_CREATEABLE(CEKU)
OBJECT_ENTRY_NON_CREATEABLE(CEKUs)
OBJECT_ENTRY_NON_CREATEABLE(CKeyUsage)
OBJECT_ENTRY_NON_CREATEABLE(CExtendedKeyUsage)
OBJECT_ENTRY_NON_CREATEABLE(CBasicConstraints)
OBJECT_ENTRY_NON_CREATEABLE(CCertificateStatus)
OBJECT_ENTRY_NON_CREATEABLE(CAttributes)
OBJECT_ENTRY_NON_CREATEABLE(CSigners)
OBJECT_ENTRY_NON_CREATEABLE(CAlgorithm)
OBJECT_ENTRY_NON_CREATEABLE(CRecipients)
OBJECT_ENTRY(CLSID_Settings, CSettings)
OBJECT_ENTRY(CLSID_Certificate, CCertificate)
OBJECT_ENTRY(CLSID_Certificates, CCertificates)
OBJECT_ENTRY(CLSID_Store, CStore)
OBJECT_ENTRY(CLSID_Chain, CChain)
OBJECT_ENTRY(CLSID_Attribute, CAttribute)
OBJECT_ENTRY(CLSID_Signer, CSigner)
OBJECT_ENTRY(CLSID_SignedData, CSignedData)
OBJECT_ENTRY(CLSID_EnvelopedData, CEnvelopedData)
OBJECT_ENTRY(CLSID_EncryptedData, CEncryptedData)

//
// CAPICOM v2.0
//
OBJECT_ENTRY(CLSID_OID, COID)
OBJECT_ENTRY_NON_CREATEABLE(COIDs)
OBJECT_ENTRY_NON_CREATEABLE(CNoticeNumbers)
OBJECT_ENTRY_NON_CREATEABLE(CQualifier)
OBJECT_ENTRY_NON_CREATEABLE(CQualifiers)
OBJECT_ENTRY_NON_CREATEABLE(CPolicyInformation)
OBJECT_ENTRY_NON_CREATEABLE(CCertificatePolicies)
OBJECT_ENTRY_NON_CREATEABLE(CEncodedData)
OBJECT_ENTRY_NON_CREATEABLE(CTemplate)
OBJECT_ENTRY_NON_CREATEABLE(CPublicKey)
OBJECT_ENTRY(CLSID_PrivateKey, CPrivateKey)
OBJECT_ENTRY_NON_CREATEABLE(CExtension)
OBJECT_ENTRY_NON_CREATEABLE(CExtensions)
OBJECT_ENTRY(CLSID_ExtendedProperty, CExtendedProperty)
OBJECT_ENTRY_NON_CREATEABLE(CExtendedProperties)
OBJECT_ENTRY(CLSID_SignedCode, CSignedCode)
OBJECT_ENTRY(CLSID_HashedData, CHashedData)
OBJECT_ENTRY(CLSID_Utilities, CUtilities)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
//
// DLL Entry Point
//

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_CAPICOM);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\base64.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows

  Copyright (C) Microsoft Corporation, 1995 - 1999.

  File:       Base64.cpp

  Contents:   Implementation of Base64 routines.

  Functions:  Encode
              Decode

  History:    11-15-99    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "Base64.h"

#include "Convert.h"

#if (0) //DSIE: 10/29/2001
#ifdef CAPICOM_BASE64_STRICT
#define BASE64_STRICT        // enforce syntax check on input data
#else
#undef BASE64_STRICT        // enforce syntax check on input data
#endif

// The following table translates an ascii subset to 6 bit values as follows
// (see RFC 1421 and/or RFC 1521):
//
//  input    hex (decimal)
//  'A' --> 0x00 (0)
//  'B' --> 0x01 (1)
//  ...
//  'Z' --> 0x19 (25)
//  'a' --> 0x1a (26)
//  'b' --> 0x1b (27)
//  ...
//  'z' --> 0x33 (51)
//  '0' --> 0x34 (52)
//  ...
//  '9' --> 0x3d (61)
//  '+' --> 0x3e (62)
//  '/' --> 0x3f (63)
//
// Encoded lines must be no longer than 76 characters.
// The final "quantum" is handled as follows:  The translation output shall
// always consist of 4 characters.  'x', below, means a translated character,
// and '=' means an equal sign.  0, 1 or 2 equal signs padding out a four byte
// translation quantum means decoding the four bytes would result in 3, 2 or 1
// unencoded bytes, respectively.
//
//  unencoded size    encoded data
//  --------------    ------------
//     1 byte        "xx=="
//     2 bytes        "xxx="
//     3 bytes        "xxxx"

#define CB_BASE64LINEMAX    64    // others use 64 -- could be up to 76

// Any other (invalid) input character value translates to 0x40 (64)

const BYTE abDecode[256] =
{
    /* 00: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 10: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 20: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 62, 64, 64, 64, 63,
    /* 30: */ 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 64, 64, 64, 64, 64, 64,
    /* 40: */ 64,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
    /* 50: */ 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 64, 64, 64, 64, 64,
    /* 60: */ 64, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
    /* 70: */ 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 64, 64, 64, 64, 64,
    /* 80: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 90: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* a0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* b0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* c0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* d0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* e0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* f0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
};

const UCHAR abEncode[] =
    /*  0 thru 25: */ "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    /* 26 thru 51: */ "abcdefghijklmnopqrstuvwxyz"
    /* 52 thru 61: */ "0123456789"
    /* 62 and 63: */  "+/";

#define MOD4(x) ((x) & 3)

__inline BOOL _IsBase64WhiteSpace(IN TCHAR const ch)
{
    return(ch == TEXT(' ') ||
           ch == TEXT('\t') ||
           ch == TEXT('\r') ||
           ch == TEXT('\n'));
}

DWORD Base64DecodeA(IN TCHAR const    * pchIn,
                    IN DWORD            cchIn,
                    OPTIONAL OUT BYTE * pbOut,
                    IN OUT DWORD      * pcbOut)
{
    DWORD dwErr;
    DWORD cchInDecode, cbOutDecode;
    TCHAR const *pchInEnd;
    TCHAR const *pchInT;
    BYTE *pbOutT;

    //
    // Count the translatable characters, skipping whitespace & CR-LF chars.
    //
    cchInDecode = 0;
    pchInEnd = &pchIn[cchIn];
    dwErr = ERROR_INVALID_DATA;
    for (pchInT = pchIn; pchInT < pchInEnd; pchInT++)
    {
        if (sizeof(abDecode) < (unsigned) *pchInT || abDecode[*pchInT] > 63)
        {
            //
            // Found a non-base64 character.  Decide what to do.
            //
            DWORD cch;

            if (_IsBase64WhiteSpace(*pchInT))
            {
                continue;        // skip all whitespace
            }

            // The length calculation may stop in the middle of the last
            // translation quantum, because the equal sign padding characters
            // are treated as invalid input.  If the last translation quantum
            // is not 4 bytes long, there must be 3, 2 or 1 equal sign(s).

            if (0 != cchInDecode)
            {
                cch = MOD4(cchInDecode);
                if (0 != cch)
                {
                    cch = 4 - cch;
                    while (0 != cch && pchInT < pchInEnd && '=' == *pchInT)
                    {
                        pchInT++;
                        cch--;
                    }
                }

                if (0 == cch)
                {
                    break;
                }
            }

            DebugTrace("Error: %c is an invlaid base64 data.\n", *pchInT);
            
            goto ErrorExit;
        }
        
        cchInDecode++;            // only count valid base64 chars
    }

    ATLASSERT(pchInT <= pchInEnd);

#ifdef BASE64_STRICT
    if (pchInT < pchInEnd)
    {
        TCHAR const *pch;
        DWORD cchEqual = 0;

        for (pch = pchInT; pch < pchInEnd; pch++)
        {
            if (!_IsBase64WhiteSpace(*pch))
            {
                // Allow up to 3 extra trailing equal signs.
                if (TEXT('=') == *pch && 3 > cchEqual)
                {
                    cchEqual++;
                    continue;
                }
    
                DebugTrace("Error: %c is an invalid trailing base64 data.\n", pch);

                goto ErrorExit;
            }
        }

#if _DEBUG
        if (0 != cchEqual)
        {
            DebugTrace("Info: Ignoring trailing base64 data ===.\n");
        }
#endif // _DEBUG
    }
#endif // BASE64_STRICT

    pchInEnd = pchInT;        // don't process any trailing stuff again

    // We know how many translatable characters are in the input buffer, so now
    // set the output buffer size to three bytes for every four (or fraction of
    // four) input bytes.  Compensate for a fractional translation quantum.

    cbOutDecode = ((cchInDecode + 3) >> 2) * 3;
    switch (cchInDecode % 4)
    {
        case 1:
        case 2:
            cbOutDecode -= 2;
            break;

        case 3:
            cbOutDecode--;
            break;
    }

    pbOutT = pbOut;

    if (NULL == pbOut)
    {
        pbOutT += cbOutDecode;
    }
    else
    {
        // Decode one quantum at a time: 4 bytes ==> 3 bytes
        if (cbOutDecode > *pcbOut)
        {
            *pcbOut = cbOutDecode;
            dwErr = ERROR_MORE_DATA;
            goto ErrorExit;
        }

        pchInT = pchIn;
        while (cchInDecode > 0)
        {
            DWORD i;
            BYTE ab4[4];

            ZeroMemory(ab4, sizeof(ab4));
            for (i = 0; i < min(sizeof(ab4)/sizeof(ab4[0]), cchInDecode); i++)
            {
                while (sizeof(abDecode) > (unsigned) *pchInT && 
                       63 < abDecode[*pchInT])
                {
                    pchInT++;
                }
                
                ATLASSERT(pchInT < pchInEnd);
                ab4[i] = (BYTE) *pchInT++;
            }

            // Translate 4 input characters into 6 bits each, and deposit the
            // resulting 24 bits into 3 output bytes by shifting as appropriate.

            // out[0] = in[0]:in[1] 6:2
            // out[1] = in[1]:in[2] 4:4
            // out[2] = in[2]:in[3] 2:6

            *pbOutT++ = (BYTE) ((abDecode[ab4[0]] << 2) | (abDecode[ab4[1]] >> 4));

            if (i > 2)
            {
                *pbOutT++ = (BYTE) ((abDecode[ab4[1]] << 4) | (abDecode[ab4[2]] >> 2));
            }
            if (i > 3)
            {
                *pbOutT++ = (BYTE) ((abDecode[ab4[2]] << 6) | abDecode[ab4[3]]);
            }
            cchInDecode -= i;
        }

        ATLASSERT((DWORD) (pbOutT - pbOut) <= cbOutDecode);
    }

    *pcbOut = SAFE_SUBTRACT_POINTERS(pbOutT, pbOut);

    dwErr = ERROR_SUCCESS;

CommonExit:
    return dwErr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(ERROR_SUCCESS != dwErr);

    goto CommonExit;
}

// Encode a BYTE array into a Base64 text string.
// Use CR-LF pairs for line breaks, unless CRYPT_STRING_NOCR is set.
// Do not '\0' terminate the text string -- that's handled by the caller.
// Do not add -----BEGIN/END headers -- that's also handled by the caller.

DWORD Base64EncodeA(IN BYTE const      * pbIn,
                    IN DWORD             cbIn,
                    IN DWORD             Flags,
                    OPTIONAL OUT TCHAR * pchOut,
                    IN OUT DWORD       * pcchOut)
{
    DWORD dwErr;
    TCHAR *pchOutT;
    DWORD cchOutEncode;
    BOOL fNoCR = 0 != (CRYPT_STRING_NOCR & Flags);

    // Allocate enough memory for full final translation quantum.
    cchOutEncode = ((cbIn + 2) / 3) * 4;

    // and enough for CR-LF pairs for every CB_BASE64LINEMAX character line.
    cchOutEncode +=    (fNoCR? 1 : 2) * ((cchOutEncode + CB_BASE64LINEMAX - 1) / CB_BASE64LINEMAX);

    pchOutT = pchOut;
    if (NULL == pchOut)
    {
        pchOutT += cchOutEncode;
    }
    else
    {
        DWORD cCol;

        if (cchOutEncode > *pcchOut)
        {
            *pcchOut = cchOutEncode;
            dwErr = ERROR_MORE_DATA;
            goto ErrorExit;
        }

        cCol = 0;
        while ((long) cbIn > 0)    // signed comparison -- cbIn can wrap
        {
            BYTE ab3[3];

            if (cCol == CB_BASE64LINEMAX/4)
            {
                cCol = 0;
            
                if (!fNoCR)
                {
                    *pchOutT++ = '\r';
                }
                *pchOutT++ = '\n';
            }

            cCol++;
            ZeroMemory(ab3, sizeof(ab3));

            ab3[0] = *pbIn++;
            if (cbIn > 1)
            {
                ab3[1] = *pbIn++;
                if (cbIn > 2)
                {
                    ab3[2] = *pbIn++;
                }
            }

            *pchOutT++ = abEncode[ab3[0] >> 2];
            *pchOutT++ = abEncode[((ab3[0] << 4) | (ab3[1] >> 4)) & 0x3f];
            *pchOutT++ = (cbIn > 1)? abEncode[((ab3[1] << 2) | (ab3[2] >> 6)) & 0x3f] : '=';
            *pchOutT++ = (cbIn > 2)? abEncode[ab3[2] & 0x3f] : '=';

            cbIn -= 3;
        }

        // Append CR-LF only if there was input data

        if (pchOutT != pchOut)
        {
            if (!fNoCR)
            {
                *pchOutT++ = '\r';
            }
            *pchOutT++ = '\n';
        }

        ATLASSERT((DWORD) (pchOutT - pchOut) == cchOutEncode);
    }
    *pcchOut = SAFE_SUBTRACT_POINTERS(pchOutT, pchOut);

    dwErr = ERROR_SUCCESS;

CommonExit:
    return dwErr;

ErrorExit:
    ATLASSERT(ERROR_SUCCESS != dwErr);

    goto CommonExit;
}

DWORD Base64EncodeW(IN BYTE const * pbIn,
                    IN DWORD        cbIn,
                    IN DWORD        Flags,
                    OUT WCHAR     * wszOut,
                    OUT DWORD     * pcchOut)
{

    DWORD   cchOut;
    CHAR   *pch = NULL;
    DWORD   cch;
    DWORD   dwErr;

    ATLASSERT(pcchOut != NULL);

    // only want to know how much to allocate
    // we know all base64 char map 1-1 with unicode
    if (wszOut == NULL)
    {
        // get the number of characters
        *pcchOut = 0;
        dwErr = Base64EncodeA(pbIn, cbIn, Flags, NULL, pcchOut);
    }
    else // otherwise we have an output buffer
    {
        // char count is the same be it ascii or unicode,
        cchOut = *pcchOut;
        cch = 0;
        dwErr = ERROR_OUTOFMEMORY;
        pch = (CHAR *) malloc(cchOut);
        if (NULL != pch)
        {
            dwErr = Base64EncodeA(pbIn, cbIn, Flags, pch, &cchOut);
            if (ERROR_SUCCESS == dwErr)
            {
                // should not fail!
                cch = MultiByteToWideChar(0, 0, pch, cchOut, wszOut, *pcchOut);

                // check to make sure we did not fail
                ATLASSERT(*pcchOut == 0 || cch != 0);
            }
        }
    }

    if(pch != NULL)
    {
        free(pch);
    }

    return(dwErr);
}

DWORD Base64DecodeW(IN const WCHAR * wszIn,
                    IN DWORD         cch,
                    OUT BYTE       * pbOut,
                    OUT DWORD      * pcbOut)
{
    CHAR *pch;
    DWORD dwErr = ERROR_SUCCESS;

    // in all cases we need to convert to an ascii string
    // we know the ascii string is less
    if ((pch = (CHAR *) malloc(cch)) == NULL)
    {
        dwErr = ERROR_OUTOFMEMORY;
    }
    // we know no base64 wide char map to more than 1 ascii char
    else if (WideCharToMultiByte(0, 0, wszIn, cch, pch, cch, NULL, NULL) == 0)
    {
        dwErr = ERROR_NO_DATA;
    }
    // get the length of the buffer
    else if (pbOut == NULL)
    {
        *pcbOut = 0;
        dwErr = Base64DecodeA(pch, cch, NULL, pcbOut);
    }
    // otherwise fill in the buffer
    else 
    {
        dwErr = Base64DecodeA(pch, cch, pbOut, pcbOut);
    }

    if(pch != NULL)
    {
        free(pch);
    }

    return(dwErr);
}
#endif

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : Base64Encode

  Synopsis : Base64 encode the blob.

  Parameter: DATA_BLOB DataBlob  - DATA_BLOB to be base64 encoded.

             BSTR * pbstrEncoded - Pointer to BSTR to receive the base64 
                                   encoded blob.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT Base64Encode (DATA_BLOB DataBlob, 
                      BSTR    * pbstrEncoded)
{
    HRESULT hr            = S_OK;
    DWORD   dwEncodedSize = 0;
    BSTR    bstrEncoded   = NULL;

    DebugTrace("Entering Base64Encode()\n");

    //
    // Sanity check.
    //
    ATLASSERT(pbstrEncoded);

    try
    {
        //
        // Make sure parameters are valid.
        //
        if (!DataBlob.cbData || !DataBlob.pbData)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error: base64 encoding of empty data not allowed.\n");
            goto ErrorExit;
        }

        //
        // Convert to base64.
        //
        if (FAILED(hr = ::BinaryToString(DataBlob.pbData, 
                                         DataBlob.cbData,
                                         CRYPT_STRING_BASE64,
                                         &bstrEncoded,
                                         &dwEncodedSize)))
        {
            DebugTrace("Error [%#x]: BinaryToString() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return base64 encoded BSTR to caller.
        //
        *pbstrEncoded = bstrEncoded;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving Base64Encode()\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (bstrEncoded)
    {
        ::SysFreeString(bstrEncoded);
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : Base64Decode

  Synopsis : Decode the base64 encoded blob.

  Parameter: BSTR bstrEncoded      - BSTR of base64 encoded blob to decode.

             DATA_BLOB * pDataBlob - Pointer to DATA_BLOB to receive decoded 
                                     data blob.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT Base64Decode (BSTR        bstrEncoded, 
                      DATA_BLOB * pDataBlob)
{
    HRESULT   hr            = S_OK;
    DWORD     dwEncodedSize = 0;
    DATA_BLOB DataBlob      = {0, NULL};

    DebugTrace("Entering Base64Decode()\n");

    //
    // Sanity check.
    //
    ATLASSERT(bstrEncoded);
    ATLASSERT(pDataBlob);

    try
    {
        //
        // Make sure parameters are valid.
        //
        if (0 == (dwEncodedSize = ::SysStringLen(bstrEncoded)))
        {
            hr = E_INVALIDARG;

            DebugTrace("Error: invalid parameter, empty base64 encoded data not allowed.\n");
            goto ErrorExit;
        }

        //
        // Base64 decode.
        //
        if (FAILED(hr = ::StringToBinary(bstrEncoded,
                                         dwEncodedSize,
                                         CRYPT_STRING_BASE64_ANY,
                                         &DataBlob.pbData,
                                         &DataBlob.cbData)))
        {
            DebugTrace("Error [%#x]: StringToBinary() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return base64 decoded blob to caller.
        //
        *pDataBlob = DataBlob;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving Base64Decode()\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (DataBlob.pbData)
    {
        ::CoTaskMemFree(DataBlob.pbData);
    }

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\attributes.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows

  Copyright (C) Microsoft Corporation, 1995 - 1999.

  File:    Attributes.h

  Content: Declaration of CAttributes.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#ifndef __ATTRIBUTES_H_
#define __ATTRIBUTES_H_

#include "Resource.h"
#include "Lock.h"
#include "Debug.h"
#include "CopyItem.h"
#include "Attribute.h"

//
// typdefs to make life easier.
//
typedef std::map<CComBSTR, CComPtr<IAttribute> > AttributeMap;
typedef CComEnumOnSTL<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _CopyMapItem<IAttribute>, AttributeMap> AttributeEnum;
typedef ICollectionOnSTLImpl<IAttributes, AttributeMap, VARIANT, _CopyMapItem<IAttribute>, AttributeEnum> IAttributesCollection;


////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateAttributesObject

  Synopsis : Create and initialize an IAttributes collection object.

  Parameter: CRYPT_ATTRIBUTES * pAttrbibutes - Pointer to attributes to be 
                                               added to the collection object.
  
             IAttributes ** ppIAttributes - Pointer to pointer to IAttributes 
                                            to receive the interface pointer.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateAttributesObject (CRYPT_ATTRIBUTES * pAttributes,
                                IAttributes     ** ppIAttributes);


////////////////////////////////////////////////////////////////////////////////
//
// CAttributes
//

class ATL_NO_VTABLE CAttributes : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CAttributes, &CLSID_Attributes>,
    public ICAPICOMError<CAttributes, &IID_IAttributes>,
    public IDispatchImpl<IAttributesCollection, &IID_IAttributes, &LIBID_CAPICOM,
                         CAPICOM_MAJOR_VERSION, CAPICOM_MINOR_VERSION>
{
public:
    CAttributes()
    {
    }

DECLARE_NO_REGISTRY()

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAttributes)
    COM_INTERFACE_ENTRY(IAttributes)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CAttributes)
END_CATEGORY_MAP()

    HRESULT FinalConstruct()
    {
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for Attributes object.\n", hr);
            return hr;
        }

        m_dwNextIndex = 0;

        return S_OK;
    }

//
// IAttributes
//
public:
    //
    // These are the only ones that we need to implemented, others will be
    // handled by ATL ICollectionOnSTLImpl.
    //
    STDMETHOD(Clear)
        (void);

    STDMETHOD(Remove)
        (/*[in]*/ long Index);

    STDMETHOD(Add)
        (/*[in]*/ IAttribute * pVal);

    //
    // None COM functions.
    //
    STDMETHOD(Init)
        (CRYPT_ATTRIBUTES * pAttributes);

private:
    CLock   m_Lock;
    DWORD   m_dwNextIndex;
};
#endif //__ATTRIBUTES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\basicconstraints.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows

  Copyright (C) Microsoft Corporation, 1995 - 1999.

  File:    BasicConstraints.h.

  Content: Declaration of the CBasicConstraints.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#ifndef __BASICCONSTRAINTS_H_
#define __BASICCONSTRAINTS_H_

#include "Resource.h"
#include "Error.h"
#include "Lock.h"
#include "Debug.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateBasicConstraintsObject

  Synopsis : Create a IBasicConstraints object and populate the porperties with
             data from the key usage extension of the specified certificate.

  Parameter: PCCERT_CONTEXT pCertContext            - Pointer to CERT_CONTEXT.

             IBasicConstraints ** ppIBasicConstraints - Pointer to pointer 
                                                        IBasicConstraints 
                                                        object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateBasicConstraintsObject (PCCERT_CONTEXT       pCertContext,
                                      IBasicConstraints ** ppIBasicConstraints);


////////////////////////////////////////////////////////////////////////////////
//
// CBasicConstraints
//
class ATL_NO_VTABLE CBasicConstraints : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CBasicConstraints, &CLSID_BasicConstraints>,
    public ICAPICOMError<CBasicConstraints, &IID_IBasicConstraints>,
    public IDispatchImpl<IBasicConstraints, &IID_IBasicConstraints, &LIBID_CAPICOM, 
                         CAPICOM_MAJOR_VERSION, CAPICOM_MINOR_VERSION>
{
public:
    CBasicConstraints()
    {
    }

DECLARE_NO_REGISTRY()

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CBasicConstraints)
    COM_INTERFACE_ENTRY(IBasicConstraints)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CBasicConstraints)
END_CATEGORY_MAP()

    HRESULT FinalConstruct()
    {
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for BasicConstraints object.\n", hr);
            return hr;
        }

        m_bIsPresent  = VARIANT_FALSE;
        m_bIsCritical = VARIANT_FALSE;
        m_bIsCertificateAuthority = VARIANT_FALSE;
        m_bIsPathLenConstraintPresent = VARIANT_FALSE;
        m_lPathLenConstraint = 0;

        return S_OK;
    }

//
// IBasicConstraints
//
public:
    STDMETHOD(get_IsPathLenConstraintPresent)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

    STDMETHOD(get_PathLenConstraint)
        (/*[out, retval]*/ long * pVal);

    STDMETHOD(get_IsCertificateAuthority)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

    STDMETHOD(get_IsCritical)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

    STDMETHOD(get_IsPresent)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

    //
    // Non COM functions.
    //
    STDMETHOD(Init)
        (PCCERT_CONTEXT pCertContext);

private:
    CLock        m_Lock;
    VARIANT_BOOL m_bIsPresent;
    VARIANT_BOOL m_bIsCritical;
    VARIANT_BOOL m_bIsCertificateAuthority;
    VARIANT_BOOL m_bIsPathLenConstraintPresent;
    long         m_lPathLenConstraint;
};

#endif //__BASICCONSTRAINTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\basicconstraints.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    BasicConstraints.cpp

  Content: Implementation of CBasicConstraints.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "BasicConstraints.h"

#include "Common.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateBasicConstraintsObject

  Synopsis : Create a IBasicConstraints object and populate the porperties with
             data from the key usage extension of the specified certificate.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT.

             IBasicConstraints ** ppIBasicConstraints - Pointer to pointer 
                                                        IBasicConstraints 
                                                        object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateBasicConstraintsObject (PCCERT_CONTEXT       pCertContext,
                                      IBasicConstraints ** ppIBasicConstraints)
{
    HRESULT hr = S_OK;
    CComObject<CBasicConstraints> * pCBasicConstraints = NULL;

    DebugTrace("Entering CreateBasicConstraintsObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(ppIBasicConstraints);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CBasicConstraints>::CreateInstance(&pCBasicConstraints)))
        {
            DebugTrace("Error [%#x]: CComObject<CBasicConstraints>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize object.
        //
        if (FAILED(hr = pCBasicConstraints->Init(pCertContext)))
        {
            DebugTrace("Error [%#x]: pCBasicConstraints::Init() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return interface pointer to caller.
        //
        if (FAILED(hr = pCBasicConstraints->QueryInterface(ppIBasicConstraints)))
        {
            DebugTrace("Error [%#x]: pCBasicConstraints->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Entering CreateBasicConstraintsObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (pCBasicConstraints)
    {
        delete pCBasicConstraints;
    }

    goto CommonExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// CBasicConstraints
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CBasicConstraints::get_IsPresent

  Synopsis : Check to see if the basic constraints extension is present.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CBasicConstraints::get_IsPresent (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CBasicConstraints::get_IsPresent().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
        *pVal = m_bIsPresent;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CBasicConstraints::get_IsPresent().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CBasicConstraints::get_IsCritical

  Synopsis : Check to see if the basic constraints extension is marked critical.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CBasicConstraints::get_IsCritical (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CBasicConstraints::get_IsCritical().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
        *pVal = m_bIsCritical;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CBasicConstraints::get_IsCritical().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CBasicConstraints::get_IsCertificateAuthority

  Synopsis : Check to see if the basic constraints extension contains the CA
             value.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CBasicConstraints::get_IsCertificateAuthority (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CBasicConstraints::get_IsCertificateAuthority().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
        *pVal = m_bIsCertificateAuthority;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CBasicConstraints::get_IsCertificateAuthority().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CBasicConstraints::get_IsPathLenConstraintPresent

  Synopsis : Check to see if the basic constraints extension contains path
             length constraints.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CBasicConstraints::get_IsPathLenConstraintPresent (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CBasicConstraints::get_IsPathLenConstraintPresent().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
        *pVal = m_bIsPathLenConstraintPresent;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CBasicConstraints::get_IsPathLenConstraintPresent().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CBasicConstraints::get_PathLenConstraint

  Synopsis : Return the path length constraints value.

  Parameter: long * pVal - Pointer to long to receive value.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CBasicConstraints::get_PathLenConstraint (long * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CBasicConstraints::get_PathLenConstraint().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
        *pVal = m_lPathLenConstraint;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CBasicConstraints::get_PathLenConstraint().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// Private methods.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CBasicConstraints::Init

  Synopsis : Initialize the object.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT.

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us with CERT_CONTEXT.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CBasicConstraints::Init (PCCERT_CONTEXT pCertContext)
{
    HRESULT hr = S_OK;
    CRYPT_DATA_BLOB DataBlob = {0, NULL};
    PCERT_BASIC_CONSTRAINTS2_INFO pInfo = NULL;
    PCERT_EXTENSION pBasicConstraints   = NULL;
    
    DebugTrace("Entering CBasicConstraints::Init().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);

    //
    // Find the basic constraints extension.
    //
    if (pBasicConstraints = ::CertFindExtension(szOID_BASIC_CONSTRAINTS2,
                                                pCertContext->pCertInfo->cExtension,
                                                pCertContext->pCertInfo->rgExtension))
    {
        //
        // Decode the basic constraints extension.
        //
        if (FAILED(hr = ::DecodeObject(X509_BASIC_CONSTRAINTS2,
                                       pBasicConstraints->Value.pbData,
                                       pBasicConstraints->Value.cbData,
                                       &DataBlob)))
        {
            DebugTrace("Error [%#x]: DecodeObject() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Point to CERT_BASIC_CONSTRAINTS2_INFO.
        //
        pInfo = (PCERT_BASIC_CONSTRAINTS2_INFO) DataBlob.pbData;

        //
        // Set values.
        //
        m_bIsPresent = VARIANT_TRUE;

        if (pBasicConstraints->fCritical)
        {
            m_bIsCritical = VARIANT_TRUE;
        }

        if (pInfo->fCA)
        {
            m_bIsCertificateAuthority = VARIANT_TRUE;
        }

        if (pInfo->fPathLenConstraint)
        {
            m_bIsPathLenConstraintPresent = VARIANT_TRUE;
            m_lPathLenConstraint = (long) pInfo->dwPathLenConstraint;
        }
    }

CommonExit:
    //
    // Free resources.
    //
    if (DataBlob.pbData)
    {
        ::CoTaskMemFree((LPVOID) DataBlob.pbData);
    }

    DebugTrace("Leaving CBasicConstraints::Init().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\base64.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows

  Copyright (C) Microsoft Corporation, 1995 - 1999.

  File:       Base64.h

  Content:    Declaration of Base64 routines.

  History:    11-15-99    dsie     created

------------------------------------------------------------------------------*/

#ifndef __BASE64_H_
#define __BASE64_H_

#include "Debug.h"

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : Base64Encode

  Synopsis : Base64 encode the blob.

  Parameter: DATA_BLOB DataBlob  - DATA_BLOB to be base64 encoded.

             BSTR * pbstrEncoded - Pointer to BSTR to receive the base64 
                                   encoded blob.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT Base64Encode (DATA_BLOB DataBlob, 
                      BSTR    * pbstrEncoded);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : Base64Decode

  Synopsis : Decode the base64 encoded blob.

  Parameter: BSTR bstrEncoded      - BSTR of base64 encoded blob to decode.

             DATA_BLOB * pDataBlob - Pointer to DATA_BLOB to receive decoded 
                                     data blob.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT Base64Decode (BSTR        bstrEncoded, 
                      DATA_BLOB * pDataBlob);

#if (0)
///////////////////////////////////////////////////////////////////////////////
//
// Copied from \NT\ds\security\cryptoapi\common\pkifmt\pkifmt.h.
//

#ifdef __cplusplus
extern "C" {
#endif

DWORD __stdcall            // ERROR_*
Base64DecodeA(
    IN CHAR const *pchIn,
    IN DWORD cchIn,
    OUT BYTE *pbOut,
    OUT DWORD *pcbOut);

DWORD __stdcall            // ERROR_*
Base64DecodeW(
    IN WCHAR const *pchIn,
    IN DWORD cchIn,
    OUT BYTE *pbOut,
    OUT DWORD *pcbOut);

DWORD __stdcall        // ERROR_*
Base64EncodeA(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT CHAR *pchOut,
    OUT DWORD *pcchOut);

DWORD __stdcall            // ERROR_*
Base64EncodeW(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT WCHAR *pchOut,
    OUT DWORD *pcchOut);
    
#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif // #if (0)

#endif //__BASE64_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\certhlpr.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000 - 2001.

  File:    CertHlpr.h

  Content: Declaration of the certificate helper functions.

  History: 09-07-2001    dsie     created

------------------------------------------------------------------------------*/

#ifndef __CERTHLPR_H_
#define __CERTHLPR_H_

#include "Debug.h"
#include "SignHlpr.h"

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : GetEnhancedKeyUsage

  Synopsis : Retrieve the EKU from the cert.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT.

         DWORD dwFlags - 0, or
                             CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG, or
                             CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG.

             PCERT_ENHKEY_USAGE * ppUsage - Pointer to PCERT_ENHKEY_USAGE
                                            to receive the usages.

  Remark   : If EKU extension is found with no EKU, then return HRESULT
             is CERT_E_WRONG_USAGE.
             
------------------------------------------------------------------------------*/

HRESULT GetEnhancedKeyUsage (PCCERT_CONTEXT       pCertContext,
                             DWORD                dwFlags,
                             PCERT_ENHKEY_USAGE * ppUsage);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : BuildChain

  Synopsis : Build a chain using the specified policy.

  Parameter: PCCERT_CONTEXT pCertContext - CERT_CONTEXT of cert to verify.

             HCERTSTORE hCertStore - Additional store (can be NULL).

             LPCSTR pszPolicy - Policy used to verify the cert (i.e.
                                CERT_CHAIN_POLICY_BASE).

             PCCERT_CHAIN_CONTEXT * ppChainContext - Pointer to 
                                                     PCCERT_CHAIN_CONTEXT.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT BuildChain (PCCERT_CONTEXT         pCertContext,
                    HCERTSTORE             hCertStore, 
                    LPCSTR                 pszPolicy,
                    PCCERT_CHAIN_CONTEXT * ppChainContext);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : VerifyCertificate

  Synopsis : Verify if the certificate is valid.

  Parameter: PCCERT_CONTEXT pCertContext - CERT_CONTEXT of cert to verify.

             HCERTSTORE hCertStore - Additional store (can be NULL).

             LPCSTR pszPolicy - Policy used to verify the cert (i.e.
                                CERT_CHAIN_POLICY_BASE).
  Remark   :

------------------------------------------------------------------------------*/

HRESULT VerifyCertificate (PCCERT_CONTEXT pCertContext,
                           HCERTSTORE     hCertStore, 
                           LPCSTR         pszPolicy);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : SelectCertificateContext

  Synopsis : Pop UI to prompt user to select a certificate from an opened store.

  Parameter: HCERTSTORE hCertStore - Source cert store.

             HWND hWndParent - Parent window handle.

             LPWCSTR pwszTitle - Dialog title string.

             LPWCSTR - pwszDisplayString - Dialog display string.

             BOOL bMultiSelect - TRUE to enable multi-select.

             PFNCFILTERPROC pfnFilterCallback - Pointer to filter callback
                                                function.
  
             HCERTSTORE hSelectedCertStore - HCERTSTORE to receive the 
                                             selected certs for multi-select 
                                             mode.

             PCCERT_CONTEXT * ppCertContext - Pointer to PCCERT_CONTEXT
                                              receive the certificate context
                                              for single selection mode.

  Remark   : typedef struct tagCRYPTUI_SELECTCERTIFICATE_STRUCTW {
                DWORD               dwSize;
                HWND                hwndParent;         // OPTIONAL
                DWORD               dwFlags;            // OPTIONAL
                LPCWSTR             szTitle;            // OPTIONAL
                DWORD               dwDontUseColumn;    // OPTIONAL
                LPCWSTR             szDisplayString;    // OPTIONAL
                PFNCFILTERPROC      pFilterCallback;    // OPTIONAL
                PFNCCERTDISPLAYPROC pDisplayCallback;   // OPTIONAL
                void *              pvCallbackData;     // OPTIONAL
                DWORD               cDisplayStores;
                HCERTSTORE *        rghDisplayStores;
                DWORD               cStores;            // OPTIONAL
                HCERTSTORE *        rghStores;          // OPTIONAL
                DWORD               cPropSheetPages;    // OPTIONAL
                LPCPROPSHEETPAGEW   rgPropSheetPages;   // OPTIONAL
                HCERTSTORE          hSelectedCertStore; // OPTIONAL
            } CRYPTUI_SELECTCERTIFICATE_STRUCTW
            
------------------------------------------------------------------------------*/

HRESULT SelectCertificateContext (HCERTSTORE       hCertStore,
                                  LPCWSTR          pwszTitle,
                                  LPCWSTR          pwszDisplayString,
                                  BOOL             bMultiSelect,
                                  PFNCFILTERPROC   pfnFilterCallback,
                                  HCERTSTORE       hSelectedCertStore,
                                  PCCERT_CONTEXT * ppCertContext);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : SelectCertificate

  Synopsis : Select a certificate from the sepcified store. If only 1 cert is
             found after the filter, then that cert is returned. If more than
             1 cert is found, then UI is popped to prompt user to select a 
             certificate from the specified store.

  Parameter: CAPICOM_STORE_INFO StoreInfo - Store to select from.

             PFNCFILTERPROC pfnFilterCallback - Pointer to filter callback
                                                function.
  
             ICertificate2 ** ppICertificate - Pointer to pointer to 
                                               ICertificate to receive interface
                                               pointer.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT SelectCertificate (CAPICOM_STORE_INFO StoreInfo,
                           PFNCFILTERPROC     pfnFilterCallback,
                           ICertificate2   ** ppICertificate);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : ExportCertificatesToStore

  Synopsis : Copy all certs from the collections to the specified store.

  Parameter: ICertificates2 * pICertificate - Pointer to collection.

             HCERTSTORE hCertStore - Store to copy to.

  Remark   :
------------------------------------------------------------------------------*/

HRESULT ExportCertificatesToStore(ICertificates2 * pICertificate,
                                  HCERTSTORE       hCertStore);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateMemoryStoreFromCertificates

  Synopsis : Create a memory cert store and copy all certs from the collections 
             to the store.

  Parameter: ICertificates2 * pICertificates - Pointer to collection.

             HCERTSTORE * phCertStore - Pointer to receive store handle.

  Remark   : If pICertificate is NULL, then the returned store is still valid 
             nut empty. Also, caller must close the returned store.

------------------------------------------------------------------------------*/

HRESULT CreateMemoryStoreFromCertificates(ICertificates2 * pICertificates, 
                                          HCERTSTORE     * phCertStore);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CompareCertAndContainerPublicKey

  Synopsis : Compare public key in cert matches the container's key.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT to be used 
                                           to initialize the IPrivateKey object.

             BSTR ContainerName - Container name.
         
             BSTR ProviderName - Provider name.

             DWORD dwProvType - Provider type.

             DWORD dwKeySpec - Key spec.

             DWORD dwFlags - Provider flags.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CompareCertAndContainerPublicKey (PCCERT_CONTEXT pCertContext,
                                          LPWSTR         pwszContainerName,
                                          LPWSTR         pwszProvName,
                                          DWORD          dwProvType, 
                                          DWORD          dwKeySpec,
                                          DWORD          dwFlags);
#endif // __CERTHLPR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\certhlpr.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000 - 2001.

  File:    CertHlpr.cpp

  Content: Helper functions for cert.

  History: 09-10-2001    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "CertHlpr.h"
#include "Settings.h"
#include "Certificate.h"
#include "Common.h"

typedef PCCERT_CONTEXT (WINAPI * PCRYPTUIDLGSELECTCERTIFICATEW) 
                       (IN PCCRYPTUI_SELECTCERTIFICATE_STRUCTW pcsc);

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : GetEnhancedKeyUsage

  Synopsis : Retrieve the EKU from the cert.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT.

             DWORD dwFlags - 0, or
                             CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG, or
                             CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG.

             PCERT_ENHKEY_USAGE * ppUsage - Pointer to PCERT_ENHKEY_USAGE
                                            to receive the usages.

  Remark   : If EKU extension is found with no EKU, then return HRESULT
             is CERT_E_WRONG_USAGE.
             
------------------------------------------------------------------------------*/

HRESULT GetEnhancedKeyUsage (PCCERT_CONTEXT       pCertContext,
                             DWORD                dwFlags,
                             PCERT_ENHKEY_USAGE * ppUsage)
{
    HRESULT            hr          = S_OK;
    DWORD              dwWinError  = 0;
    DWORD              cbUsage     = 0;
    PCERT_ENHKEY_USAGE pUsage      = NULL;

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(ppUsage);

    //
    // Initialize.
    //
    *ppUsage = NULL;

    //
    // Determine extended key usage data length.
    //
    if (!::CertGetEnhancedKeyUsage(pCertContext,
                                   dwFlags,
                                   NULL,
                                   &cbUsage))
    {
        //
        // Older version of Crypt32.dll would return FALSE for
        // empty EKU. In this case, we want to treat it as success,
        //
        if (CRYPT_E_NOT_FOUND == (dwWinError = ::GetLastError()))
        {
            //
            // and also set the cbUsage.
            //
            cbUsage = sizeof(CERT_ENHKEY_USAGE);

            DebugTrace("Info: CertGetEnhancedKeyUsage() found no EKU, so valid for all uses.\n");
        }
        else
        {
            hr = HRESULT_FROM_WIN32(dwWinError);

            DebugTrace("Error [%#x]: CertGetEnhancedKeyUsage() failed to get size.\n", hr);
            goto ErrorExit;
        }
    }

    //
    // Allocate memory.
    //
    if (!(pUsage = (PCERT_ENHKEY_USAGE) ::CoTaskMemAlloc((ULONG) cbUsage)))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Error: out of memory.\n");
        goto ErrorExit;
    }

    //
    // Get extended key usage data.
    //
    if (!::CertGetEnhancedKeyUsage(pCertContext,
                                   dwFlags,
                                   pUsage,
                                   &cbUsage))
    {
        //
        // Older version of Crypt32.dll would return FALSE for
        // empty EKU. In this case, we want to treat it as success.
        //
        if (CRYPT_E_NOT_FOUND == (dwWinError  = ::GetLastError()))
        {
            //
            // Structure pointed to by pUsage is not initialized by older
            // version of Cryp32 for empty EKU.
            //
            ::ZeroMemory(pUsage, sizeof(CERT_ENHKEY_USAGE));
        }
        else
        {
            hr = HRESULT_FROM_WIN32(dwWinError);

            DebugTrace("Error [%#x]: CertGetEnhancedKeyUsage() failed to get data.\n", hr);
            goto ErrorExit;
        }
    }

    //
    // See if we have any EKU?
    //
    if (0 == pUsage->cUsageIdentifier && CRYPT_E_NOT_FOUND != ::GetLastError())
    {
        //
        // This is not valid for any usage.
        //
        hr = CERT_E_WRONG_USAGE;
        goto ErrorExit;
    }

    //
    // Return usages to caller.
    //
    *ppUsage = pUsage;

CommonExit:

    DebugTrace("Leaving GetEnhancedKeyUsage().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (pUsage)
    {
        ::CoTaskMemFree(pUsage);
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : BuildChain

  Synopsis : Build a chain using the specified policy.

  Parameter: PCCERT_CONTEXT pCertContext - CERT_CONTEXT of cert to verify.

             HCERTSTORE hCertStore - Additional store (can be NULL).

             LPCSTR pszPolicy - Policy used to verify the cert (i.e.
                                CERT_CHAIN_POLICY_BASE).

             PCCERT_CHAIN_CONTEXT * ppChainContext - Pointer to 
                                                     PCCERT_CHAIN_CONTEXT.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT BuildChain (PCCERT_CONTEXT         pCertContext,
                    HCERTSTORE             hCertStore, 
                    LPCSTR                 pszPolicy,
                    PCCERT_CHAIN_CONTEXT * ppChainContext)
{
    HRESULT         hr        = S_OK;
    CERT_CHAIN_PARA ChainPara = {0};;
    LPSTR rgpszUsageIdentifier[1] = {NULL};

    DebugTrace("Entering BuildChain().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(pszPolicy);
    ATLASSERT(ppChainContext);

    //
    // Initialize.
    //
    ChainPara.cbSize = sizeof(ChainPara);

    //
    // Check policy.
    //
    if (CERT_CHAIN_POLICY_BASE == pszPolicy)
    {
        //
        // No EKU for base policy.
        //
    }
    else if (CERT_CHAIN_POLICY_AUTHENTICODE == pszPolicy)
    {
        //
        // Setup EKU for Authenticode policy.
        //
        rgpszUsageIdentifier[0] = szOID_PKIX_KP_CODE_SIGNING;
        ChainPara.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
        ChainPara.RequestedUsage.Usage.cUsageIdentifier = 1;
        ChainPara.RequestedUsage.Usage.rgpszUsageIdentifier = rgpszUsageIdentifier;
    }
    else
    {
        //
        // We don't support any other policy, yet.
        //
        hr = CERT_E_INVALID_POLICY;

        DebugTrace("Internal error [%#x]: unexpected policy (%#x).\n", hr, pszPolicy);
        goto ErrorExit;
    }

    //
    // Build the chain.
    //
    if (!::CertGetCertificateChain(NULL,            // in optional 
                                   pCertContext,    // in 
                                   NULL,            // in optional
                                   hCertStore,      // in optional 
                                   &ChainPara,      // in 
                                   0,               // in 
                                   NULL,            // in 
                                   ppChainContext)) // out 
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CertGetCertificateChain() failed.\n", hr);
        goto ErrorExit;
    }
   
CommonExit:

    DebugTrace("Leaving BuildChain().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : VerifyCertificate

  Synopsis : Verify if the certificate is valid.

  Parameter: PCCERT_CONTEXT pCertContext - CERT_CONTEXT of cert to verify.

             HCERTSTORE hCertStore - Additional store (can be NULL).

             LPCSTR pszPolicy - Policy used to verify the cert (i.e.
                                CERT_CHAIN_POLICY_BASE).
  Remark   :

------------------------------------------------------------------------------*/

HRESULT VerifyCertificate (PCCERT_CONTEXT pCertContext,
                           HCERTSTORE     hCertStore, 
                           LPCSTR         pszPolicy)
{
    HRESULT                  hr            = S_OK;
    PCCERT_CHAIN_CONTEXT     pChainContext = NULL;
    CERT_CHAIN_POLICY_PARA   PolicyPara    = {0};
    CERT_CHAIN_POLICY_STATUS PolicyStatus  = {0};

    DebugTrace("Entering VerifyCertificate().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(pszPolicy);

    //
    // Initialize.
    //
    PolicyPara.cbSize = sizeof(PolicyPara);
    PolicyStatus.cbSize = sizeof(PolicyStatus);

    //
    // Build the chain.
    //
    if (FAILED(hr = ::BuildChain(pCertContext,
                                 hCertStore,
                                 pszPolicy,
                                 &pChainContext)))
    {
        DebugTrace("Error [%#x]: BuildChain() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Verify the chain using the specified policy.
    //
    if (::CertVerifyCertificateChainPolicy(pszPolicy,
                                           pChainContext,
                                           &PolicyPara,
                                           &PolicyStatus))
    {
        if (PolicyStatus.dwError)
        {
            hr = HRESULT_FROM_WIN32(PolicyStatus.dwError);

            DebugTrace("Error [%#x]: invalid policy.\n", hr);
            goto ErrorExit;
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(CERT_E_INVALID_POLICY);

        DebugTrace("Error [%#x]: CertVerifyCertificateChainPolicy() failed.\n", hr);
        goto ErrorExit;
    }
    
CommonExit:
    //
    // Free resource.
    //
    if (pChainContext)
    {
        ::CertFreeCertificateChain(pChainContext);
    }

    DebugTrace("Leaving VerifyCertificate().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : SelectCertificateContext

  Synopsis : Pop UI to prompt user to select a certificate from an opened store.

  Parameter: HCERTSTORE hCertStore - Source cert store.

             LPWCSTR pwszTitle - Dialog title string.

             LPWCSTR - pwszDisplayString - Dialog display string.

             BOOL bMultiSelect - TRUE to enable multi-select.

             PFNCFILTERPROC pfnFilterCallback - Pointer to filter callback
                                                function.
  
             HCERTSTORE hSelectedCertStore - HCERTSTORE to receive the 
                                             selected certs for multi-select 
                                             mode.

             PCCERT_CONTEXT * ppCertContext - Pointer to PCCERT_CONTEXT
                                              receive the certificate context
                                              for single selection mode.

  Remark   : typedef struct tagCRYPTUI_SELECTCERTIFICATE_STRUCTW {
                DWORD               dwSize;
                HWND                hwndParent;         // OPTIONAL
                DWORD               dwFlags;            // OPTIONAL
                LPCWSTR             szTitle;            // OPTIONAL
                DWORD               dwDontUseColumn;    // OPTIONAL
                LPCWSTR             szDisplayString;    // OPTIONAL
                PFNCFILTERPROC      pFilterCallback;    // OPTIONAL
                PFNCCERTDISPLAYPROC pDisplayCallback;   // OPTIONAL
                void *              pvCallbackData;     // OPTIONAL
                DWORD               cDisplayStores;
                HCERTSTORE *        rghDisplayStores;
                DWORD               cStores;            // OPTIONAL
                HCERTSTORE *        rghStores;          // OPTIONAL
                DWORD               cPropSheetPages;    // OPTIONAL
                LPCPROPSHEETPAGEW   rgPropSheetPages;   // OPTIONAL
                HCERTSTORE          hSelectedCertStore; // OPTIONAL
            } CRYPTUI_SELECTCERTIFICATE_STRUCTW
            
------------------------------------------------------------------------------*/

HRESULT SelectCertificateContext (HCERTSTORE       hCertStore,
                                  LPCWSTR          pwszTitle,
                                  LPCWSTR          pwszDisplayString,
                                  BOOL             bMultiSelect,
                                  PFNCFILTERPROC   pfnFilterCallback,
                                  HCERTSTORE       hSelectedCertStore,
                                  PCCERT_CONTEXT * ppCertContext)
{
    HRESULT        hr           = S_OK;
    HINSTANCE      hDLL         = NULL;
    PCCERT_CONTEXT pCertContext = NULL;

    PCRYPTUIDLGSELECTCERTIFICATEW pCryptUIDlgSelectCertificateW = NULL;
    CRYPTUI_SELECTCERTIFICATE_STRUCTW csc;

    DebugTrace("Entering SelectCertificateContext().\n");

    //
    // Sanity check.
    //
    ATLASSERT(hCertStore);

    //
    // Initialize.
    //
    if (ppCertContext)
    {
        *ppCertContext = NULL;
    }

    //
    // Make sure we are allowed to pop UI.
    //
    if (!PromptForCertificateEnabled())
    {
        hr = CAPICOM_E_UI_DISABLED;

        DebugTrace("Error [%#x]: Certificate selection UI is disabled.\n", hr);
        goto ErrorExit;
    }

    //
    // Get pointer to CryptUIDlgSelectCertificateW().
    //
    if (hDLL = ::LoadLibrary("CryptUI.dll"))
    {
        pCryptUIDlgSelectCertificateW = (PCRYPTUIDLGSELECTCERTIFICATEW) 
            ::GetProcAddress(hDLL, "CryptUIDlgSelectCertificateW");
    }

    //
    // Is CryptUIDlgSelectCertificateW() available?
    //
    if (!pCryptUIDlgSelectCertificateW)
    {
        hr = CAPICOM_E_NOT_SUPPORTED;

        DebugTrace("Error [%#x]: CryptUIDlgSelectCertificateW() API not available.\n", hr);
        goto ErrorExit;
    }

    //
    // Pop UI to prompt user to select cert.
    // 
    ::ZeroMemory(&csc, sizeof(csc));
#if (0) //DSIE: Bug in older version of CRYPTUI does not check size correctly,
        //      so always force it to the oldest version of structure.
    csc.dwSize = sizeof(csc);
#else
    csc.dwSize = offsetof(CRYPTUI_SELECTCERTIFICATE_STRUCTW, hSelectedCertStore);
#endif
    csc.dwFlags = bMultiSelect ? CRYPTUI_SELECTCERT_MULTISELECT : 0;
    csc.szTitle = pwszTitle;
    csc.szDisplayString = pwszDisplayString;
    csc.cDisplayStores = 1;
    csc.rghDisplayStores = &hCertStore;
    csc.pFilterCallback = pfnFilterCallback;
    csc.hSelectedCertStore = bMultiSelect ? hSelectedCertStore : NULL;

    //
    // Display the selection dialog.
    //
    if (pCertContext = (PCERT_CONTEXT) pCryptUIDlgSelectCertificateW(&csc))
    {
        //
        // Return CERT_CONTEXT to caller.
        //
        if (!(*ppCertContext = ::CertDuplicateCertificateContext(pCertContext)))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertDuplicateCertificateContext() failed.\n", hr);
            goto ErrorExit;
        }
    }
    else
    {
        //
        // Is this multi-select?
        //
        if (bMultiSelect)
        {
            //
            // See if we have any cert in the store?
            //
            if (!(pCertContext = ::CertEnumCertificatesInStore(hSelectedCertStore, pCertContext)))
            {
                hr = CAPICOM_E_CANCELLED;
    
                DebugTrace("Error [%#x]: user cancelled cert selection dialog box.\n", hr);
                goto ErrorExit;
            }
        }
        else
        {
            hr = CAPICOM_E_CANCELLED;
    
            DebugTrace("Error [%#x]: user cancelled cert selection dialog box.\n", hr);
            goto ErrorExit;
        }
    }
 
CommonExit:
    //
    // Release resources.
    //
    if (pCertContext)
    {
        ::CertFreeCertificateContext(pCertContext);
    }
    if (hDLL)
    {
        ::FreeLibrary(hDLL);
    }

    DebugTrace("Leaving SelectCertificateContext().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : SelectCertificate

  Synopsis : Select a certificate from the sepcified store. If only 1 cert is
             found after the filter, then that cert is returned. If more than
             1 cert is found, then UI is popped to prompt user to select a 
             certificate from the specified store.

  Parameter: CAPICOM_STORE_INFO StoreInfo - Store to select from.

             PFNCFILTERPROC pfnFilterCallback - Pointer to filter callback
                                                function.
  
             ICertificate2 ** ppICertificate - Pointer to pointer to 
                                               ICertificate2 to receive
                                               interface pointer.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT SelectCertificate (CAPICOM_STORE_INFO StoreInfo,
                           PFNCFILTERPROC     pfnFilterCallback,
                           ICertificate2   ** ppICertificate)
{
    HRESULT        hr           = S_OK;
    HCERTSTORE     hCertStore   = NULL;
    PCCERT_CONTEXT pCertContext = NULL;
    PCCERT_CONTEXT pEnumContext = NULL;
    DWORD          dwValidCerts = 0;

    DebugTrace("Entering SelectCertificate().\n");

    //
    // Sanity check.
    //
    ATLASSERT(ppICertificate);

    //
    // Open the store for cert selection if necessary.
    //
    switch (StoreInfo.dwChoice)
    {
        case CAPICOM_STORE_INFO_STORENAME:
        {
            if (!(hCertStore = ::CertOpenStore((LPCSTR) CERT_STORE_PROV_SYSTEM,
                                               CAPICOM_ASN_ENCODING,
                                               NULL,
                                               CERT_STORE_READONLY_FLAG | CERT_SYSTEM_STORE_CURRENT_USER,
                                               (void *) StoreInfo.pwszStoreName)))
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());

                DebugTrace("Error [%#x]: CertOpenStore() failed.\n", hr);
                goto ErrorExit; 
            }

            break;
        }

        case CAPICOM_STORE_INFO_HCERTSTORE:
        {
            if (!(hCertStore = ::CertDuplicateStore(StoreInfo.hCertStore)))
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());
            
                DebugTrace("Error [%#x]: CertDuplicateStore() failed.\n", hr);
                goto ErrorExit; 
            }

            break;
        }

        default:
        {
            hr = CAPICOM_E_INTERNAL;

            DebugTrace("Internal error [%#x]: unknow store info deChoice (%d).\n", hr, StoreInfo.dwChoice);
            goto ErrorExit;
        }
    }

 
    //
    // Count number of certs in store.
    //
    while (pEnumContext = ::CertEnumCertificatesInStore(hCertStore, pEnumContext))
    {
        //
        // Count only if it will not be filtered out.
        //
        if (pfnFilterCallback && !pfnFilterCallback(pEnumContext, NULL, NULL))
        {
            continue;
        }

        if (pCertContext)
        {
            ::CertFreeCertificateContext(pCertContext);
        }

        if (!(pCertContext = ::CertDuplicateCertificateContext(pEnumContext)))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertDuplicateCertificateContext() failed.\n", hr);
            goto ErrorExit;
        }

        dwValidCerts++;
    }

    //
    // Above loop can exit either because there is no more certificate in
    // the store or an error. Need to check last error to be certain.
    //
    if (CRYPT_E_NOT_FOUND != ::GetLastError())
    {
       hr = HRESULT_FROM_WIN32(::GetLastError());
       
       DebugTrace("Error [%#x]: CertEnumCertificatesInStore() failed.\n", hr);
       goto ErrorExit;
    }

    //
    // If only 1 cert available, don't pop UI (just use it).
    //
    if (0 == dwValidCerts)
    {
        hr = CAPICOM_E_STORE_EMPTY;

        DebugTrace("Error [%#x]: no certificate found.\n", hr);
        goto ErrorExit;
    }
    else if (1 < dwValidCerts)
    {
        //
        // First free the CERT_CONTEXT we duplicated above.
        //
        ::CertFreeCertificateContext(pCertContext), pCertContext = NULL;

        //
        // Pop UI to prompt user to select the signer cert.
        //
        if (FAILED(hr = ::SelectCertificateContext(hCertStore,
                                                   NULL,
                                                   NULL,
                                                   FALSE,
                                                   pfnFilterCallback, 
                                                   NULL,
                                                   &pCertContext)))
        {
            DebugTrace("Error [%#x]: SelectCertificateContext() failed.\n", hr);
            goto ErrorExit;
        }
    }

    //
    // Create an ICertificate object from the CERT_CONTEXT.
    //
    if (FAILED(hr = ::CreateCertificateObject(pCertContext, 0, ppICertificate)))
    {
        DebugTrace("Error [%#x]: CreateCertificateObject() failed.\n", hr);
        goto ErrorExit;
    }
  
CommonExit:
    //
    // Release resources.
    //
    if (pEnumContext)
    {
        ::CertFreeCertificateContext(pEnumContext);
    }
    if (pCertContext)
    {
        ::CertFreeCertificateContext(pCertContext);
    }
    if (hCertStore)
    {
        ::CertCloseStore(hCertStore, 0);
    }

    DebugTrace("Leaving SelectCertificate().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : ExportCertificatesToStore

  Synopsis : Copy all certs from the collections to the specified store.

  Parameter: ICertificates2 * pICertificate - Pointer to collection.

             HCERTSTORE hCertStore - Store to copy to.

  Remark   :
------------------------------------------------------------------------------*/

HRESULT ExportCertificatesToStore(ICertificates2 * pICertificates, 
                                  HCERTSTORE       hCertStore)
{
    HRESULT hr = S_OK;
    CComPtr<ICCertificates> pICCertificates = NULL;

    DebugTrace("Entering ExportCertificatesToStore().\n");

    //
    // Sanity check.
    //
    ATLASSERT(hCertStore);

    //
    // Make sure we have something to load.
    //
    if (pICertificates)
    {
        //
        // Get ICCertificate interface pointer.
        //
        if (FAILED(hr = pICertificates->QueryInterface(IID_ICCertificates, (void **) &pICCertificates)))
        {
            DebugTrace("Error [%#x]: pICertificates->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Get the CERT_CONTEXT.
        //
        if (FAILED(hr = pICCertificates->_ExportToStore(hCertStore)))
        {
            DebugTrace("Error [%#x]: pICCertificates->_ExportToStore() failed.\n", hr);
            goto ErrorExit;
        }
    }

CommonExit:

    DebugTrace("Leaving ExportCertificatesToStore().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateMemoryStoreFromCertificates

  Synopsis : Create a memory cert store and copy all certs from the collections 
             to the store.

  Parameter: ICertificates2 * pICertificates - Pointer to collection.

             HCERTSTORE * phCertStore - Pointer to receive store handle.

  Remark   : If pICertificate is NULL, then the returned store is still valid 
             nut empty. Also, caller must close the returned store.

------------------------------------------------------------------------------*/

HRESULT CreateMemoryStoreFromCertificates(ICertificates2 * pICertificates, 
                                          HCERTSTORE     * phCertStore)
{
    HRESULT hr = S_OK;
    HCERTSTORE hCertStore = NULL;

    DebugTrace("Entering CreateMemoryStoreFromCertificates().\n");

    //
    // Sanity check.
    //
    ATLASSERT(phCertStore);

    //
    // Initialize.
    //
    *phCertStore = hCertStore;

    //
    // Create the memory store.
    //
    if (!(hCertStore = ::CertOpenStore(CERT_STORE_PROV_MEMORY, 
                                       CAPICOM_ASN_ENCODING,
                                       NULL,
                                       CERT_STORE_CREATE_NEW_FLAG,
                                       NULL)))
    {
        DebugTrace("Error [%#x]: CertOpenStore() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Now load the collection into the store.
    //
    if (FAILED(hr = ::ExportCertificatesToStore(pICertificates, hCertStore)))
    {
        DebugTrace("Error [%#x]: ExportCertificatesToStore() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Return store handle to caller.
    //
    *phCertStore = hCertStore;

CommonExit:

    DebugTrace("Leaving CreateMemoryStoreFromCertificates().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (hCertStore)
    {
        ::CertCloseStore(hCertStore, 0);
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CompareCertAndContainerPublicKey

  Synopsis : Compare public key in cert matches the container's key.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT to be used 
                                           to initialize the IPrivateKey object.

             BSTR ContainerName - Container name.
         
             BSTR ProviderName - Provider name.

             DWORD dwProvType - Provider type.

             DWORD dwKeySpec - Key spec.

             DWORD dwFlags - Provider flags.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CompareCertAndContainerPublicKey (PCCERT_CONTEXT pCertContext,
                                          LPWSTR         pwszContainerName,
                                          LPWSTR         pwszProvName,
                                          DWORD          dwProvType, 
                                          DWORD          dwKeySpec,
                                          DWORD          dwFlags)
{
    HRESULT               hr               = S_OK;
    HCRYPTPROV            hCryptProv       = NULL;
    DWORD                 cbProvPubKeyInfo = 0;
    PCERT_PUBLIC_KEY_INFO pProvPubKeyInfo  = NULL;

    DebugTrace("Entering CompareCertAndContainerPublicKey().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(pwszContainerName);
    ATLASSERT(pwszProvName);

    //
    // Acquire provider with key access.
    //
    if (FAILED(hr = ::AcquireContext(pwszProvName,
                                     pwszContainerName,
                                     dwProvType,
                                     dwFlags,
                                     TRUE,
                                     &hCryptProv)))
    {
        DebugTrace("Error [%#x]: AcquireContext() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Get provider's public key.
    //
    if (!::CryptExportPublicKeyInfo(hCryptProv,
                                    dwKeySpec,
                                    pCertContext->dwCertEncodingType,
                                    NULL,
                                    &cbProvPubKeyInfo))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptExportPublicKeyInfo() failed.\n", hr);
        goto ErrorExit;
    }
    if (!(pProvPubKeyInfo = (PCERT_PUBLIC_KEY_INFO) ::CoTaskMemAlloc(cbProvPubKeyInfo)))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Error: out of memory.\n");
        goto ErrorExit;
    }
    if (!::CryptExportPublicKeyInfo(hCryptProv,
                                    dwKeySpec,
                                    pCertContext->dwCertEncodingType,
                                    pProvPubKeyInfo,
                                    &cbProvPubKeyInfo))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptExportPublicKeyInfo() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Compare the keys.
    //
    if (!::CertComparePublicKeyInfo(pCertContext->dwCertEncodingType,
                                    &pCertContext->pCertInfo->SubjectPublicKeyInfo,
                                    pProvPubKeyInfo))
    {
        hr = HRESULT_FROM_WIN32(NTE_BAD_PUBLIC_KEY);

        DebugTrace("Error [%#x]: CertComparePublicKeyInfo() failed.\n", hr);
        goto ErrorExit;
    }

CommonExit:
    //
    // Free resources.
    //
    if (pProvPubKeyInfo)
    {
        ::CoTaskMemFree(pProvPubKeyInfo);
    }

    if (hCryptProv)
    {
        ::CryptReleaseContext(hCryptProv, 0);
    }

    DebugTrace("Leaving CompareCertAndContainerPublicKey().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));
    
    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\certificatepolicies.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    CCertificatePolicies.cpp

  Content: Implementation of CCertificatePolicies.

  History: 11-17-2001    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "CertificatePolicies.h"
#include "Common.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateCertificatePoliciesObject

  Synopsis : Create a CertificatePolicies collection object and populate the 
             collection with policy information from the specified certificate 
             policies.

  Parameter: LPSTR pszOid - OID string.
  
             CRYPT_DATA_BLOB * pEncodedBlob - Pointer to encoded data blob.

             IDispatch ** ppICertificatePolicies - Pointer to pointer 
                                                   IDispatch to recieve the 
                                                   interface pointer.
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateCertificatePoliciesObject (LPSTR             pszOid,
                                         CRYPT_DATA_BLOB * pEncodedBlob,
                                         IDispatch      ** ppICertificatePolicies)
{
    HRESULT hr = S_OK;
    CComObject<CCertificatePolicies> * pCCertificatePolicies = NULL;

    DebugTrace("Entering CreateCCertificatePoliciesObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pszOid);
    ATLASSERT(pEncodedBlob);
    ATLASSERT(ppICertificatePolicies);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CCertificatePolicies>::CreateInstance(&pCCertificatePolicies)))
        {
            DebugTrace("Error [%#x]: CComObject<CCertificatePolicies>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize object.
        //
        if (FAILED(hr = pCCertificatePolicies->Init(pszOid, pEncodedBlob)))
        {
            DebugTrace("Error [%#x]: pCCertificatePolicies->Init() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return interface pointer to caller.
        //
        if (FAILED(hr = pCCertificatePolicies->QueryInterface(IID_IDispatch, 
                                                              (void **) ppICertificatePolicies)))
        {
            DebugTrace("Unexpected error [%#x]:  pCCertificatePolicies->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreateCCertificatePoliciesObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    if (pCCertificatePolicies)
    {
        delete pCCertificatePolicies;
    }

    goto CommonExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// CCertificatePolicies
//

////////////////////////////////////////////////////////////////////////////////
//
// Non COM functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificatePolicies::Init

  Synopsis : Initialize the CCertificatePolicies collection object by adding all 
             individual qualifier object to the collection.

  Parameter: LPSTR pszOid - OID string.
  
             CRYPT_DATA_BLOB * pEncodedBlob - Pointer to encoded data blob.

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CCertificatePolicies::Init (LPSTR             pszOid, 
                                         CRYPT_DATA_BLOB * pEncodedBlob)
{
    HRESULT             hr                = S_OK;
    DATA_BLOB           DataBlob          = {0, NULL};
    PCERT_POLICIES_INFO pCertPoliciesInfo = NULL;
    
    DWORD i;

    DebugTrace("Entering CCertificatePolicies::Init().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pszOid);
    ATLASSERT(pEncodedBlob);
    ATLASSERT(pEncodedBlob->cbData);
    ATLASSERT(pEncodedBlob->pbData);

    try
    {
        //
        // Decode the extension.
        //
        if (FAILED(hr = ::DecodeObject(szOID_CERT_POLICIES,
                                       pEncodedBlob->pbData,
                                       pEncodedBlob->cbData,
                                       &DataBlob)))
        {
            DebugTrace("Error [%#x]: DecodeObject() failed.\n", hr);
            goto ErrorExit;
        }

        pCertPoliciesInfo = (PCERT_POLICIES_INFO) DataBlob.pbData;

        //
        // Add all CCertificatePolicies to the map.
        //
        for (i = 0; i < pCertPoliciesInfo->cPolicyInfo; i++)
        {
            CComBSTR bstrIndex;
            CComPtr<IPolicyInformation> pIPolicyInformation = NULL;

            //
            // Create the qualifier object.
            //
            if (FAILED(hr = ::CreatePolicyInformationObject(&pCertPoliciesInfo->rgPolicyInfo[i], 
                                                            &pIPolicyInformation)))
            {
                DebugTrace("Error [%#x]: CreatePolicyInformationObject() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // BSTR index of OID.
            //
            if (!(bstrIndex = pCertPoliciesInfo->rgPolicyInfo[i].pszPolicyIdentifier))
            {
                hr = E_OUTOFMEMORY;

                DebugTrace("Error [%#x]: bstrIndex = pCertPoliciesInfo->rgPolicyInfo[i].pszPolicyIdentifier failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Now add object to collection map.
            //
            // Note that the overloaded = operator for CComPtr will
            // automatically AddRef to the object. Also, when the CComPtr
            // is deleted (happens when the Remove or map destructor is called), 
            // the CComPtr destructor will automatically Release the object.
            //
            m_coll[bstrIndex] = pIPolicyInformation;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:
    //
    // Free resources.
    //
    if (DataBlob.pbData)
    {
        ::CoTaskMemFree(DataBlob.pbData);
    }

    DebugTrace("Leaving CCertificatePolicies::Init().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    m_coll.clear();

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\certificate.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Certificate.h

  Content: Declaration of CCertificate.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#ifndef __CERTIFICATE_H_
#define __CERTIFICATE_H_

#include "Resource.h"
#include "Error.h"
#include "Lock.h"
#include "Debug.h"
#include "KeyUsage.h"
#include "ExtendedKeyUsage.h"
#include "BasicConstraints.h"
#include "Template.h"
#include "CertificateStatus.h"
#include "PublicKey.h"
#include "PrivateKey.h"
#include "Extensions.h"
#include "ExtendedProperties.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateCertificateObject

  Synopsis : Create an ICertificate object.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT to be used
                                           to initialize the ICertificate 
                                           object.

             DWORD dwCurrentSafety  - Current safety setting.

             ICertificate2 ** ppICertificate  - Pointer to pointer ICertificate
                                               object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateCertificateObject (PCCERT_CONTEXT   pCertContext,
                                 DWORD            dwCurrentSafety,
                                 ICertificate2 ** ppICertificate);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : GetCertContext

  Synopsis : Return the certificate's PCERT_CONTEXT.

  Parameter: ICertificate * pICertificate - Pointer to ICertificate for which
                                            the PCERT_CONTEXT is to be returned.
  
             PCCERT_CONTEXT * ppCertContext - Pointer to PCERT_CONTEXT.

  Remark   :
 
------------------------------------------------------------------------------*/

HRESULT GetCertContext (ICertificate    * pICertificate, 
                        PCCERT_CONTEXT  * ppCertContext);


////////////////////////////////////////////////////////////////////////////////
//
// CCertificate
//

class ATL_NO_VTABLE CCertificate : 
    public ICertContext,
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CCertificate, &CLSID_Certificate>,
    public ICAPICOMError<CCertificate, &IID_ICertificate2>,
    public IDispatchImpl<ICertificate2, &IID_ICertificate2, &LIBID_CAPICOM,
                         CAPICOM_MAJOR_VERSION, CAPICOM_MINOR_VERSION>,
    public IObjectSafetyImpl<CCertificate, INTERFACESAFE_FOR_UNTRUSTED_CALLER | 
                                           INTERFACESAFE_FOR_UNTRUSTED_DATA>
{
public:

    CCertificate()
    {
    }

DECLARE_REGISTRY_RESOURCEID(IDR_CERTIFICATE)

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CCertificate)
    COM_INTERFACE_ENTRY(ICertificate)
    COM_INTERFACE_ENTRY(ICertificate2)
    COM_INTERFACE_ENTRY(ICertContext)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CCertificate)
    IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
    IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
END_CATEGORY_MAP()

    HRESULT FinalConstruct()
    {
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for Certificate object.\n", hr);
            return hr;
        }

        m_pCertContext        = NULL;
        m_pIKeyUsage          = NULL;
        m_pIExtendedKeyUsage  = NULL;
        m_pIBasicConstraints  = NULL;
        m_pICertificateStatus = NULL;
        m_pITemplate          = NULL;
        m_pIPublicKey         = NULL;
        m_pIExtensions        = NULL;

        return S_OK;
    }

    void FinalRelease()
    {
        m_pIKeyUsage.Release();
        m_pIExtendedKeyUsage.Release();
        m_pIBasicConstraints.Release();
        m_pICertificateStatus.Release();
        m_pITemplate.Release();
        m_pIPublicKey.Release();
        m_pIExtensions.Release();

        if (m_pCertContext)
        {
            ::CertFreeCertificateContext(m_pCertContext);
        }
    }

//
// ICertificate
//
public:
    //
    // CAPICOM v1.0
    //
    STDMETHOD(Display)();

    STDMETHOD(Import)
        (/*[in]*/ BSTR EncodedCertificate);

    STDMETHOD(Export)
        (/*[in, defaultvalue(CAPICOM_ENCODE_BASE64)]*/ CAPICOM_ENCODING_TYPE EncodingType,
         /*[out, retval]*/ BSTR * pVal);

    STDMETHOD(BasicConstraints)
        (/*[out, retval]*/ IBasicConstraints ** pVal);

    STDMETHOD(ExtendedKeyUsage)
        (/*[out, retval]*/ IExtendedKeyUsage ** pVal);

    STDMETHOD(KeyUsage)
        (/*[out, retval]*/ IKeyUsage ** pVal);

    STDMETHOD(IsValid)
        (/*[out, retval]*/ ICertificateStatus ** pVal);

    STDMETHOD(GetInfo)
        (/*[in]*/ CAPICOM_CERT_INFO_TYPE InfoType, 
         /*[out, retval]*/ BSTR * pVal);

    STDMETHOD(HasPrivateKey)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

    STDMETHOD(get_Thumbprint)
        (/*[out, retval]*/ BSTR * pVal);

    STDMETHOD(get_ValidToDate)
        (/*[out, retval]*/ DATE * pVal);

    STDMETHOD(get_ValidFromDate)
        (/*[out, retval]*/ DATE * pVal);

    STDMETHOD(get_IssuerName)
        (/*[out, retval]*/ BSTR * pVal);

    STDMETHOD(get_SubjectName)
        (/*[out, retval]*/ BSTR * pVal);

    STDMETHOD(get_SerialNumber)
        (/*[out, retval]*/ BSTR * pVal);

    STDMETHOD(get_Version)
        (/*[out, retval]*/ long * pVal);

    //
    // CAPICOM v2.0
    //
    STDMETHOD(get_Archived)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

    STDMETHOD(put_Archived)
        (/*[in]*/ VARIANT_BOOL newVal);

    STDMETHOD(Template)
        (/*[out, retval]*/ ITemplate ** pVal);

    STDMETHOD(PublicKey)
        (/*[out, retval]*/ IPublicKey ** pVal);

    STDMETHOD(get_PrivateKey)
        (/*[out, retval]*/ IPrivateKey ** pVal);

    STDMETHOD(put_PrivateKey)
        (/*[in]*/ IPrivateKey * newVal);

    STDMETHOD(Extensions)
        (/*[out, retval]*/ IExtensions ** pVal);

    STDMETHOD(ExtendedProperties)
        (/*[out, retval]*/ IExtendedProperties ** pVal);

    STDMETHOD(Load)
        (/*[in]*/ BSTR FileName, 
         /*[in, defaultvalue("")]*/ BSTR Password,
         /*[in, defaultvalue(CAPICOM_KEY_STORAGE_DEFAULT)]*/ CAPICOM_KEY_STORAGE_FLAG KeyStorageFlag,
         /*[in, defaultvalue(CAPICOM_CURRENT_USER_KEY)]*/ CAPICOM_KEY_LOCATION KeyLocation);


    STDMETHOD(Save)
        (/*[in]*/ BSTR FileName, 
         /*[in, defaultvalue("")]*/ BSTR Password,
         /*[in, defaultvalue(CAPICOM_CERTIFICATE_SAVE_AS_CER)]*/ CAPICOM_CERTIFICATE_SAVE_AS_TYPE SaveAs,
         /*[in, defaultvalue(CAPICOM_CERTIFICATE_INCLUDE_END_ENTITY_ONLY)]*/ CAPICOM_CERTIFICATE_INCLUDE_OPTION IncludeOption);

    //
    // ICertContext custom interface.
    //
    STDMETHOD(get_CertContext)
        (/*[out, retval]*/ long * ppCertContext);

    STDMETHOD(put_CertContext)
        (/*[in]*/ long pCertContext);

    STDMETHOD(FreeContext)
        (/*[in]*/ long pCertContext);

    //
    // C++ member function needed to initialize the object.
    //
    STDMETHOD(ImportBlob)
        (DATA_BLOB              * pCertBlob,
         BOOL                     bAllowPfx,
         CAPICOM_KEY_LOCATION     KeyLocation,
         BSTR                     pwszPassword,
         CAPICOM_KEY_STORAGE_FLAG KeyStorageFlag);

    STDMETHOD(GetContext)
        (PCCERT_CONTEXT * ppCertContext);

    STDMETHOD(PutContext)
        (PCCERT_CONTEXT pCertContext, DWORD dwCurrentSafety);

private:
    CLock                        m_Lock;
    PCCERT_CONTEXT               m_pCertContext;
    CComPtr<IKeyUsage>           m_pIKeyUsage;
    CComPtr<IExtendedKeyUsage>   m_pIExtendedKeyUsage;
    CComPtr<IBasicConstraints>   m_pIBasicConstraints;
    CComPtr<ITemplate>           m_pITemplate;
    CComPtr<ICertificateStatus>  m_pICertificateStatus;
    CComPtr<IPublicKey>          m_pIPublicKey;
    CComPtr<IExtensions>         m_pIExtensions;
};

#endif //__CERTIFICATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\certificatepolicies.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows

  Copyright (C) Microsoft Corporation, 1995 - 1999.

  File:    CertificatePolicies.h

  Content: Declaration of CCertificatePolicies.

  History: 11-17-2001    dsie     created

------------------------------------------------------------------------------*/

#ifndef __CERTIFICATEPOLICIES_H_
#define __CERTIFICATEPOLICIES_H_

#include "Resource.h"
#include "Debug.h"
#include "CopyItem.h"
#include "CertificatePolicies.h"

#include "PolicyInformation.h"

//
// typdefs to make life easier.
//
typedef std::map<CComBSTR, CComPtr<IPolicyInformation> > PolicyInformationMap;
typedef CComEnumOnSTL<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _CopyMapItem<IPolicyInformation>, PolicyInformationMap> PolicyInformationEnum;
typedef ICollectionOnSTLImpl<ICertificatePolicies, PolicyInformationMap, VARIANT, _CopyMapItem<IPolicyInformation>, PolicyInformationEnum> ICertificatePoliciesCollection;


////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateCertificatePoliciesObject

  Synopsis : Create a CertificatePolicies collection object and populate the 
             collection with policy information from the specified certificate 
             policies.

  Parameter: LPSTR pszOid - OID string.
  
             CRYPT_DATA_BLOB * pEncodedBlob - Pointer to encoded data blob.

             IDispatch ** ppICertificatePolicies - Pointer to pointer 
                                                   IDispatch to recieve the 
                                                   interface pointer.
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateCertificatePoliciesObject (LPSTR             pszOid,
                                         CRYPT_DATA_BLOB * pEncodedBlob,
                                         IDispatch      ** ppICertificatePolicies);

////////////////////////////////////////////////////////////////////////////////
//
// CCertificatePolicies
//

class ATL_NO_VTABLE CCertificatePolicies : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CCertificatePolicies, &CLSID_CertificatePolicies>,
    public ICAPICOMError<CCertificatePolicies, &IID_ICertificatePolicies>,
    public IDispatchImpl<ICertificatePoliciesCollection, &IID_ICertificatePolicies, &LIBID_CAPICOM,
                         CAPICOM_MAJOR_VERSION, CAPICOM_MINOR_VERSION>
{
public:
    CCertificatePolicies()
    {
    }

DECLARE_NO_REGISTRY()

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CCertificatePolicies)
    COM_INTERFACE_ENTRY(ICertificatePolicies)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CCertificatePolicies)
END_CATEGORY_MAP()

//
// ICertificatePolicies
//
public:
    //
    // These are the only ones that we need to implemented, others will be
    // handled by ATL ICollectionOnSTLImpl.
    //

    //
    // None COM functions.
    //
    STDMETHOD(Init) 
        (LPSTR pszOid, CRYPT_DATA_BLOB * pEncodedBlob);
};

#endif //__CERTIFICATEPOLICIES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\certificate.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Certificate.cpp

  Content: Implementation of CCertificate.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "Certificate.h"
#include "CertHlpr.h"
#include "Convert.h"
#include "Common.h"
#include "PFXHlpr.h"
#include "PrivateKey.h"
#include "Settings.h"

////////////////////////////////////////////////////////////////////////////////
//
// typedefs.
//

typedef BOOL (WINAPI * PCRYPTUIDLGVIEWCERTIFICATEW) 
             (IN  PCCRYPTUI_VIEWCERTIFICATE_STRUCTW  pCertViewInfo,
              OUT BOOL                              *pfPropertiesChanged);


////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateCertificateObject

  Synopsis : Create an ICertificate object.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT to be used
                                           to initialize the ICertificate 
                                           object.

             DWORD dwCurrentSafety  - Current safety setting.

             ICertificate2 ** ppICertificate  - Pointer to pointer ICertificate
                                               object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateCertificateObject (PCCERT_CONTEXT   pCertContext,
                                 DWORD            dwCurrentSafety,
                                 ICertificate2 ** ppICertificate)
{
    HRESULT hr = S_OK;
    CComObject<CCertificate> * pCCertificate = NULL;

    DebugTrace("Entering CreateCertificateObject().\n", hr);

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(ppICertificate);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CCertificate>::CreateInstance(&pCCertificate)))
        {
            DebugTrace("Error [%#x]: CComObject<CCertificate>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize object.
        //
        if (FAILED(hr = pCCertificate->PutContext(pCertContext, dwCurrentSafety)))
        {
            DebugTrace("Error [%#x]: pCCertificate->PutContext() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return interface pointer to caller.
        //
        if (FAILED(hr = pCCertificate->QueryInterface(ppICertificate)))
        {
            DebugTrace("Error [%#x]: pCCertificate->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }
    
    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreateCertificateObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    if (pCCertificate)
    {
        delete pCCertificate;
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : GetCertContext

  Synopsis : Return the certificate's PCERT_CONTEXT.

  Parameter: ICertificate * pICertificate - Pointer to ICertificate for which
                                            the PCERT_CONTEXT is to be returned.
  
             PCCERT_CONTEXT * ppCertContext - Pointer to PCERT_CONTEXT.

  Remark   :
 
------------------------------------------------------------------------------*/

HRESULT GetCertContext (ICertificate   * pICertificate, 
                        PCCERT_CONTEXT * ppCertContext)
{
    HRESULT               hr            = S_OK;
    CComPtr<ICertContext> pICertContext = NULL;

    DebugTrace("Entering GetCertContext().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pICertificate);
    ATLASSERT(ppCertContext);

    //
    // Get ICCertificate interface pointer.
    //
    if (FAILED(hr = pICertificate->QueryInterface(IID_ICertContext, (void **) &pICertContext)))
    {
        DebugTrace("Error [%#x]: pICertificate->QueryInterface() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Get the CERT_CONTEXT.
    //
    if (FAILED(hr = pICertContext->get_CertContext((long *) ppCertContext)))
    {
        DebugTrace("Error [%#x]: pICertContext->get_CertContext() failed.\n", hr);
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving GetCertContext().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// Local functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : GetCertNameInfo

  Synopsis : Return the name for the subject or issuer field.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT.

             DWORD dwNameType    - 0 for subject name or CERT_NAME_ISSUER_FLAG
                                   for issuer name.

             DWORD dwDisplayType - Display type.

             BSTR * pbstrName    - Pointer to BSTR to receive resulting name
                                   string.

  Remark   : It is the caller's responsibility to free the BSTR.
             No checking of any of the flags is done, so be sure to call
             with the right flags.

------------------------------------------------------------------------------*/

static HRESULT GetCertNameInfo (PCCERT_CONTEXT pCertContext, 
                                DWORD          dwNameType, 
                                DWORD          dwDisplayType, 
                                BSTR         * pbstrName)
{
    HRESULT hr        = S_OK;
    DWORD   cbNameLen = 0;
    LPWSTR  pwszName  = NULL;
    DWORD   dwStrType = CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG;

    DebugTrace("Entering GetCertNameInfo().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(pbstrName);

    //
    // Get the length needed.
    //
    if (!(cbNameLen = ::CertGetNameStringW(pCertContext,   
                                           dwDisplayType,
                                           dwNameType,
                                           dwDisplayType == CERT_NAME_RDN_TYPE ? (LPVOID) &dwStrType : NULL,
                                           NULL,   
                                           0)))
    {
        hr = HRESULT_FROM_WIN32(CRYPT_E_NOT_FOUND);

        DebugTrace("Error [%#x]: CertGetNameStringW() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Create returned BSTR.
    //
    if (!(pwszName = (LPWSTR) ::CoTaskMemAlloc(cbNameLen * sizeof(WCHAR))))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Error: out of memory.\n");
        goto ErrorExit;
    }

    //
    // Now actually get the name string.
    //
    if (!::CertGetNameStringW(pCertContext,
                              dwDisplayType,
                              dwNameType,
                              dwDisplayType == CERT_NAME_RDN_TYPE ? (LPVOID) &dwStrType : NULL,
                              (LPWSTR) pwszName,
                              cbNameLen))
    {
        hr = HRESULT_FROM_WIN32(CRYPT_E_NOT_FOUND);

        DebugTrace("Error [%#x]: CertGetNameStringW() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Return BSTR to caller.
    //
    if (!(*pbstrName = ::SysAllocString(pwszName)))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Error: out of memory.\n");
        goto ErrorExit;
    }

CommonExit:
    //
    // Free resource.
    //
    if (pwszName)
    {
        ::CoTaskMemFree(pwszName);
    }

    DebugTrace("Leaving GetCertNameInfo().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CertToStore

  Synopsis : Add the cert, optionally with the chain, to the store.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT.

             CAPICOM_CERTIFICATE_INCLUDE_OPTION IncludeOption - Include option.

             HCERTSTORE hCertStore - Store to add to.

  Remark   :

------------------------------------------------------------------------------*/

static HRESULT CertToStore(PCCERT_CONTEXT                     pCertContext,
                           CAPICOM_CERTIFICATE_INCLUDE_OPTION IncludeOption,
                           HCERTSTORE                         hCertStore)
{
    HRESULT              hr            = S_OK;
    PCCERT_CHAIN_CONTEXT pChainContext = NULL;

    DebugTrace("Entering CertToStore().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(hCertStore);

    //
    // No need to build chain if only including end cert.
    //
    if (CAPICOM_CERTIFICATE_INCLUDE_END_ENTITY_ONLY == IncludeOption)
    {
        //
        // Add the only cert to store.
        //
        if (!::CertAddCertificateContextToStore(hCertStore, 
                                                pCertContext, 
                                                CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES, 
                                                NULL))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertAddCertificateContextToStore() failed.\n", hr);
            goto ErrorExit;
        }
    }
    else
    {
        DWORD           i;
        BOOL            bAddRoot;
        CERT_CHAIN_PARA ChainPara = {0};

        //
        // Initialize.
        //
        ChainPara.cbSize = sizeof(ChainPara);
        
        switch (IncludeOption)
        {
            case CAPICOM_CERTIFICATE_INCLUDE_WHOLE_CHAIN:
            {
                bAddRoot = TRUE;
                break;
            }

            case CAPICOM_CERTIFICATE_INCLUDE_CHAIN_EXCEPT_ROOT:
                //
                // Fall thru to default.
                //
            default:
            {
                bAddRoot = FALSE;
                break;
            }
        }

        //
        // Build the chain.
        //
        if (!::CertGetCertificateChain(NULL,
                                       pCertContext,
                                       NULL,
                                       NULL,
                                       &ChainPara,
                                       0,
                                       NULL,
                                       &pChainContext))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertGetCertificateChain() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(pChainContext->cChain);

        //
        // Now add the chain to store and skip root cert if requested. 
        //
        for (i = 0; i < pChainContext->rgpChain[0]->cElement; i++)
        {
            //
            // Skip the root cert, if requested.
            //
            if (!bAddRoot &&
                (pChainContext->rgpChain[0]->rgpElement[i]->TrustStatus.dwInfoStatus & CERT_TRUST_IS_SELF_SIGNED))
            {
                continue;
            }

            //
            // Add to store.
            //
            if (!::CertAddCertificateContextToStore(hCertStore,
                                                    pChainContext->rgpChain[0]->rgpElement[i]->pCertContext,
                                                    CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES,
                                                    NULL))
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());

                DebugTrace("Error [%#x]: CertAddCertificateContextToStore() failed.\n", hr);
                goto ErrorExit;
            }
        }
    }

CommonExit:
    //
    // Free resource.
    //
    if (pChainContext)
    {
        ::CertFreeCertificateChain(pChainContext);
    }

    DebugTrace("Leaving CertToStore().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// CCertificate
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::get_Version

  Synopsis : Return the cert version number.

  Parameter: long * pVersion - Pointer to long to receive version number.

  Remark   : The returned value is 1 for V1, 2 for V2, 3 for V3, and so on.

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::get_Version (long * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CCertificate::get_Version().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure cert is already initialized.
        //
        if (!m_pCertContext)
        {
            hr = CAPICOM_E_CERTIFICATE_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: Certificate object has not been initalized.\n", hr);
            goto ErrorExit;
        }

        *pVal = (long) m_pCertContext->pCertInfo->dwVersion + 1;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::get_Version().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::get_SerialNumber

  Synopsis : Return the Serial Number field as HEX string in BSTR.

  Parameter: BSTR * pVal - Pointer to BSTR to receive the serial number.

  Remark   : Upper case 'A' - 'F' is used for the returned HEX string with 
             no embeded space (i.e. 46A2FC01).

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::get_SerialNumber (BSTR * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CCertificate::get_SerialNumber().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure cert is already initialized.
        //
        if (!m_pCertContext)
        {
            hr = CAPICOM_E_CERTIFICATE_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: object does not represent an initialized certificate.\n", hr);
            goto ErrorExit;
        }

        //
        // Convert integer blob to BSTR.
        //
        if (FAILED(hr = ::IntBlobToHexString(&m_pCertContext->pCertInfo->SerialNumber, pVal)))
        {
            DebugTrace("Error [%#x]: IntBlobToHexString() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::get_SerialNumber().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::get_SubjectName

  Synopsis : Return the Subject field.

  Parameter: BSTR * pVal - Pointer to BSTR to receive the subject's name.

  Remark   : This method returns the full DN in the SubjectName field in the 
             form of "CN = Daniel Sie OU = Outlook O = Microsoft L = Redmond 
             S = WA C = US"

             The returned name has the same format as specifying 
             CERT_NAME_RDN_TYPE for the CertGetNameString() API..

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::get_SubjectName (BSTR * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CCertificate::get_SubjectName().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure cert is already initialized.
        //
        if (!m_pCertContext)
        {
            hr = CAPICOM_E_CERTIFICATE_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: object does not represent an initialized certificate.\n", hr);
            goto ErrorExit;
        }

        //
        // Return requested name string.
        //
        if (FAILED(hr = ::GetCertNameInfo(m_pCertContext, 
                                          0, 
                                          CERT_NAME_RDN_TYPE, 
                                          pVal)))
        {
            DebugTrace("Error [%#x]: GetCertNameInfo() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::get_SubjectName().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::get_IssuerName

  Synopsis : Return the Issuer field.

  Parameter: BSTR * pVal - Pointer to BSTR to receive the issuer's name.

  Remark   : This method returns the full DN in the IssuerName field in the 
             form of "CN = Daniel Sie OU = Outlook O = Microsoft L = Redmond 
             S = WA C = US"

             The returned name has the same format as specifying 
             CERT_NAME_RDN_TYPE for the CertGetNameString() API.

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::get_IssuerName (BSTR * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CCertificate::get_IssuerName().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure cert is already initialized.
        //
        if (!m_pCertContext)
        {
            hr = CAPICOM_E_CERTIFICATE_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: object does not represent an initialized certificate.\n", hr);
            goto ErrorExit;
        }

        //
        // Return requested name string.
        //
        if (FAILED(hr = ::GetCertNameInfo(m_pCertContext, 
                                          CERT_NAME_ISSUER_FLAG, 
                                          CERT_NAME_RDN_TYPE, 
                                          pVal)))
        {
            DebugTrace("Error [%#x]: GetCertNameInfo() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::get_IssuerName().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::get_ValidFromDate

  Synopsis : Return the NotBefore field.

  Parameter: DATE * pDate - Pointer to DATE to receive the valid from date.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::get_ValidFromDate (DATE * pVal)
{
    HRESULT hr = S_OK;
    FILETIME   ftLocal;
    SYSTEMTIME stLocal;

    DebugTrace("Entering CCertificate::get_ValidFromDate().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure cert is already initialized.
        //
        if (!m_pCertContext)
        {
            hr = CAPICOM_E_CERTIFICATE_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: object does not represent an initialized certificate.\n", hr);
            goto ErrorExit;
        }

        //
        // Convert to local time.
        //
        if (!(::FileTimeToLocalFileTime(&m_pCertContext->pCertInfo->NotBefore, &ftLocal) && 
              ::FileTimeToSystemTime(&ftLocal, &stLocal) &&
              ::SystemTimeToVariantTime(&stLocal, pVal)))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: unable to convert FILETIME to DATE.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::get_ValidFromDate().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::get_ValidToDate

  Synopsis : Return the NotAfter field.

  Parameter: DATE * pDate - Pointer to DATE to receive valid to date.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::get_ValidToDate (DATE * pVal)
{
    HRESULT hr = S_OK;
    FILETIME   ftLocal;
    SYSTEMTIME stLocal;

    DebugTrace("Entering CCertificate::get_ValidToDate().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure cert is already initialized.
        //
        if (!m_pCertContext)
        {
            hr = CAPICOM_E_CERTIFICATE_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: object does not represent an initialized certificate.\n", hr);
            goto ErrorExit;
        }

        //
        // Convert to local time.
        //
        if (!(::FileTimeToLocalFileTime(&m_pCertContext->pCertInfo->NotAfter, &ftLocal) && 
              ::FileTimeToSystemTime(&ftLocal, &stLocal) &&
              ::SystemTimeToVariantTime(&stLocal, pVal)))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: unable to convert FILETIME to DATE.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::get_ValidToDate().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::get_Thumbprint

  Synopsis : Return the SHA1 hash as HEX string.

  Parameter: BSTR * pVal - Pointer to BSTR to receive hash.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::get_Thumbprint (BSTR * pVal)
{
    HRESULT hr     = S_OK;
    BYTE *  pbHash = NULL;
    DWORD   cbHash = 0;

    DebugTrace("Entering CCertificate::get_Thumbprint().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure cert is already initialized.
        //
        if (!m_pCertContext)
        {
            hr = CAPICOM_E_CERTIFICATE_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: object does not represent an initialized certificate.\n", hr);
            goto ErrorExit;
        }

        //
        // Calculate length needed.
        //
        if (!::CertGetCertificateContextProperty(m_pCertContext,
                                                 CERT_SHA1_HASH_PROP_ID,
                                                 NULL,
                                                 &cbHash))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertGetCertificateContextProperty() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Allocate memory.
        //
        if (!(pbHash = (BYTE *) ::CoTaskMemAlloc(cbHash)))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error: out of memory.\n");
            goto ErrorExit;
        }

        //
        // Now get the hash.
        //
        if (!::CertGetCertificateContextProperty(m_pCertContext,
                                                 CERT_SHA1_HASH_PROP_ID,
                                                 (LPVOID) pbHash,
                                                 &cbHash))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            DebugTrace("Error [%#x]: CertGetCertificateContextProperty() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Conver to HEX BSTR.
        //
        if (FAILED(hr = ::BinaryToHexString(pbHash, cbHash, pVal)))
        {
            DebugTrace("Error [%#x]: BinaryToHexString() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resource.
    //
    if (pbHash)
    {
        ::CoTaskMemFree((LPVOID) pbHash);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::get_Thumbprint().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::HasPrivateKey

  Synopsis : Check to see if the cert has the associated private key.

  Parameter: VARIANT_BOOL * pVal - Pointer to BOOL to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::HasPrivateKey (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;
    DWORD   cb = 0;

    DebugTrace("Entering CCertificate::HasPrivateKey().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure cert is already initialized.
        //
        if (!m_pCertContext)
        {
            hr = CAPICOM_E_CERTIFICATE_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: object does not represent an initialized certificate.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
        *pVal = ::CertGetCertificateContextProperty(m_pCertContext, 
                                                    CERT_KEY_PROV_INFO_PROP_ID, 
                                                    NULL, 
                                                    &cb) ? VARIANT_TRUE : VARIANT_FALSE;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::HasPrivateKey().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::GetInfo

  Synopsis : Get other simple info from the certificate.

             
  Parameter: CAPICOM_CERT_INFO_TYPE InfoType - Info type

             BSTR * pVal - Pointer to BSTR to receive the result.

  Remark   : Note that an empty string "" is returned if the requested info is
             not available in the certificate.

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::GetInfo (CAPICOM_CERT_INFO_TYPE InfoType, 
                                    BSTR                 * pVal)
{
    HRESULT hr = S_OK;
    DWORD   dwFlags = 0;
    DWORD   dwDisplayType = 0;

    DebugTrace("Entering CCertificate::GetInfo().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure cert is already initialized.
        //
        if (!m_pCertContext)
        {
            hr = CAPICOM_E_CERTIFICATE_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: object does not represent an initialized certificate.\n", hr);
            goto ErrorExit;
        }

        //
        // Process request.
        //
        switch (InfoType)
        {
            case CAPICOM_CERT_INFO_ISSUER_SIMPLE_NAME:
            {
                dwFlags = CERT_NAME_ISSUER_FLAG;

                //
                // Warning: dropping thru.
                //
            }

            case CAPICOM_CERT_INFO_SUBJECT_SIMPLE_NAME:
            {
                //
                // Get requested simple name string.
                //
                dwDisplayType = CERT_NAME_SIMPLE_DISPLAY_TYPE;

                break;
            }

            case CAPICOM_CERT_INFO_ISSUER_EMAIL_NAME:
            {
                dwFlags = CERT_NAME_ISSUER_FLAG;

                //
                // Warning: dropping thru.
                //
            }

            case CAPICOM_CERT_INFO_SUBJECT_EMAIL_NAME:
            {
                //
                // Get requested email name string.
                //
                dwDisplayType = CERT_NAME_EMAIL_TYPE;

                break;
            }

            case CAPICOM_CERT_INFO_ISSUER_UPN:
            {
                dwFlags = CERT_NAME_ISSUER_FLAG;

                //
                // Warning: dropping thru.
                //
            }

            case CAPICOM_CERT_INFO_SUBJECT_UPN:
            {
                //
                // Get requested UPN name string.
                //
                dwDisplayType = CERT_NAME_UPN_TYPE;

                break;
            }

            case CAPICOM_CERT_INFO_ISSUER_DNS_NAME:
            {
                dwFlags = CERT_NAME_ISSUER_FLAG;

                //
                // Warning: dropping thru.
                //
            }

            case CAPICOM_CERT_INFO_SUBJECT_DNS_NAME:
            {
                //
                // Get requested DNS name string.
                //
                dwDisplayType = CERT_NAME_DNS_TYPE;

                break;
            }

            default:
            {
                hr = E_INVALIDARG;

                DebugTrace("Error [%#x]: Unknown cert info type (%#x).\n", hr, InfoType);
                goto ErrorExit;
            }
        }
        
        if (FAILED(hr = ::GetCertNameInfo(m_pCertContext, 
                                          dwFlags, 
                                          dwDisplayType, 
                                          pVal)))
        {
            DebugTrace("Error [%#x]: GetCertNameInfo() failed for display type = %d.\n", hr, dwDisplayType);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::GetInfo().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::IsValid

  Synopsis : Return an ICertificateStatus object for certificate validity check.

  Parameter: ICertificateStatus ** pVal - Pointer to pointer to 
                                          ICertificateStatus object to receive
                                          the interface pointer.
  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::IsValid (ICertificateStatus ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CCertificate::IsValid().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure cert is already initialized.
        //
        if (!m_pCertContext)
        {
            hr = CAPICOM_E_CERTIFICATE_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: object does not represent an initialized certificate.\n", hr);
            goto ErrorExit;
        }

        //
        // Create the embeded ICertificateStatus object, if not already done so.
        //
        if (!m_pICertificateStatus)
        {
            if (FAILED(hr = ::CreateCertificateStatusObject(m_pCertContext, &m_pICertificateStatus)))
            {
                DebugTrace("Error [%#x]: CreateCertificateStatusObject() failed.\n", hr);
                goto ErrorExit;
            }
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_pICertificateStatus);

        //
        // Return interface pointer to user.
        //
        if (FAILED(hr = m_pICertificateStatus->QueryInterface(pVal)))
        {
            DebugTrace("Error [%#x]: m_pICertificateStatus->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::IsValid().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::KeyUsage

  Synopsis : Return the Key Usage extension as an IKeyUsage object.

  Parameter: IKeyUsage ** pVal - Pointer to pointer to IKeyUsage to receive the 
                                 interface pointer.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::KeyUsage (IKeyUsage ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CCertificate::KeyUsage().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure cert is already initialized.
        //
        if (!m_pCertContext)
        {
            hr = CAPICOM_E_CERTIFICATE_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: object does not represent an initialized certificate.\n", hr);
            goto ErrorExit;
        }

        //
        // Create the embeded IKeyUsage object, if not already done so.
        //
        if (!m_pIKeyUsage)
        {
            if (FAILED(hr = ::CreateKeyUsageObject(m_pCertContext, &m_pIKeyUsage)))
            {
                DebugTrace("Error [%#x]: CreateKeyUsageObject() failed.\n", hr);
                goto ErrorExit;
            }
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_pIKeyUsage);

        //
        // Return interface pointer to user.
        //
        if (FAILED(hr = m_pIKeyUsage->QueryInterface(pVal)))
        {
            DebugTrace("Error [%#x]: m_pIKeyUsage->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::KeyUsage().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::ExtendedKeyUsage

  Synopsis : Return the EKU extension as an IExtendedKeyUsage object.

  Parameter: IExtendedKeyUsage ** pVal - Pointer to pointer to IExtendedKeyUsage
                                         to receive the interface pointer.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::ExtendedKeyUsage (IExtendedKeyUsage ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CCertificate::ExtendedKeyUsage().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure cert is already initialized.
        //
        if (!m_pCertContext)
        {
            hr = CAPICOM_E_CERTIFICATE_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: object does not represent an initialized certificate.\n", hr);
            goto ErrorExit;
        }

        //
        // Create the embeded IExtendedKeyUsage object, if not already done so.
        //
        if (!m_pIExtendedKeyUsage)
        {
            if (FAILED(hr = ::CreateExtendedKeyUsageObject(m_pCertContext, &m_pIExtendedKeyUsage)))
            {
                DebugTrace("Error [%#x]: CreateExtendedKeyUsageObject() failed.\n", hr);
                goto ErrorExit;
            }
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_pIExtendedKeyUsage);

        //
        // Return interface pointer to user.
        //
        if (FAILED(hr = m_pIExtendedKeyUsage->QueryInterface(pVal)))
        {
            DebugTrace("Error [%#x]: m_pIExtendedKeyUsage->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::ExtendedKeyUsage().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::BasicConstraints

  Synopsis : Return the BasicConstraints extension as an IBasicConstraints
             object.

  Parameter: IBasicConstraints ** pVal - Pointer to pointer to IBasicConstraints
                                         to receive the interface pointer.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::BasicConstraints (IBasicConstraints ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CCertificate::BasicConstraints().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure cert is already initialized.
        //
        if (!m_pCertContext)
        {
            hr = CAPICOM_E_CERTIFICATE_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: object does not represent an initialized certificate.\n", hr);
            goto ErrorExit;
        }

        //
        // Create the embeded IBasicConstraints object, if not already done so.
        //
        if (!m_pIBasicConstraints)
        {
            if (FAILED(hr = ::CreateBasicConstraintsObject(m_pCertContext, &m_pIBasicConstraints)))
            {
                DebugTrace("Error [%#x]: CreateBasicConstraintsObject() failed.\n", hr);
                goto ErrorExit;
            }
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_pIBasicConstraints);

        //
        // Return interface pointer to user.
        //
        if (FAILED(hr = m_pIBasicConstraints->QueryInterface(pVal)))
        {
            DebugTrace("Error [%#x]: m_pIBasicConstraints->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::BasicConstraints().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::Export

  Synopsis : Export the certificate.

  Parameter: CAPICOM_ENCODING_TYPE EncodingType - Encoding type.
  
             BSTR * pVal - Pointer to BSTR to receive the certificate blob.
  Remark   : 

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::Export (CAPICOM_ENCODING_TYPE EncodingType, 
                                   BSTR                * pVal)
{
    HRESULT   hr       = S_OK;
    DATA_BLOB CertBlob = {0, NULL};

    DebugTrace("Entering CCertificate::Export().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure cert is already initialized.
        //
        if (!m_pCertContext)
        {
            hr = CAPICOM_E_CERTIFICATE_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: object does not represent an initialized certificate.\n", hr);
            goto ErrorExit;
        }

        //
        // Determine encoding type.
        //
        CertBlob.cbData = m_pCertContext->cbCertEncoded;
        CertBlob.pbData = m_pCertContext->pbCertEncoded;

        //
        // Export certificate.
        //
        if (FAILED(hr = ::ExportData(CertBlob, EncodingType, pVal)))
        {
            DebugTrace("Error [%#x]: ExportData() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }


UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::Export().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::Import

  Synopsis : Imoprt a certificate.

  Parameter: BSTR EncodedCertificate - BSTR containing the encoded certificate
                                       blob.
  
  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::Import (BSTR EncodedCertificate)
{
    HRESULT   hr       = S_OK;
    DATA_BLOB CertBlob = {0, NULL};

    DebugTrace("Entering CCertificate::Import().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure parameter is valid.
        //
        if ((NULL == (CertBlob.pbData = (LPBYTE) EncodedCertificate)) ||
            (0 == (CertBlob.cbData = ::SysStringByteLen(EncodedCertificate))))
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: EncodedCertificate = %#x, SysStringByteLen(EncodedCertificate) = %d.\n", 
                        hr, EncodedCertificate, EncodedCertificate);
            goto ErrorExit;
        }

        //
        // Now import the blob.
        //
        if (FAILED(hr = ImportBlob(&CertBlob, 
                                   FALSE, 
                                   (CAPICOM_KEY_LOCATION) 0, 
                                   NULL, 
                                   (CAPICOM_KEY_STORAGE_FLAG) 0)))
        {
            DebugTrace("Error [%#x]: CCertificate::ImportBlob() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Entering CCertificate::Import().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::Display

  Synopsis : Display the certificate using CryptUIDlgViewCertificateW() API.

  Parameter: None

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::Display()
{
    HRESULT   hr    = S_OK;
    HINSTANCE hDLL  = NULL;

    PCRYPTUIDLGVIEWCERTIFICATEW     pCryptUIDlgViewCertificateW = NULL;
    CRYPTUI_VIEWCERTIFICATE_STRUCTW ViewInfo;

    DebugTrace("Entering CCertificate::Display().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    //
    // Make sure cert is already initialized.
    //
    if (!m_pCertContext)
    {
        hr = CAPICOM_E_CERTIFICATE_NOT_INITIALIZED;

        DebugTrace("Error [%#x]: object does not represent an initialized certificate.\n", hr);
        goto ErrorExit;
    }

    //
    // Get pointer to CryptUIDlgViewCertificateW().
    //
    if (hDLL = ::LoadLibrary("CryptUI.dll"))
    {
        pCryptUIDlgViewCertificateW = (PCRYPTUIDLGVIEWCERTIFICATEW) ::GetProcAddress(hDLL, "CryptUIDlgViewCertificateW");
    }

    //
    // Is CryptUIDlgViewCertificateW() available?
    //
    if (!pCryptUIDlgViewCertificateW)
    {
        hr = CAPICOM_E_NOT_SUPPORTED;

        DebugTrace("Error: CryptUIDlgViewCertificateW() API not available.\n");
        goto ErrorExit;
    }

    //
    // Initialize view structure.
    //
    ::ZeroMemory((void *) &ViewInfo, sizeof(ViewInfo));
    ViewInfo.dwSize = sizeof(ViewInfo);
    ViewInfo.pCertContext = m_pCertContext;

    //
    // View it.
    //
    if (!pCryptUIDlgViewCertificateW(&ViewInfo, 0))
    {
        //
        // CryptUIDlgViewCertificateW() returns ERROR_CANCELLED if user closed
        // the window through the x button!!!
        //
        DWORD dwWinError = ::GetLastError();
        if (ERROR_CANCELLED != dwWinError)
        {
            hr = HRESULT_FROM_WIN32(dwWinError);

            DebugTrace("Error [%#x]: CryptUIDlgViewCertificateW() failed.\n", hr);
            goto ErrorExit;
        }
    }

UnlockExit:
    //
    // Release resources.
    //
    if (hDLL)
    {
        ::FreeLibrary(hDLL);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::Display().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// Certificate2
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::get_Archived

  Synopsis : Return the archived status.

  Parameter: VARIANT_BOOL * pVal - Pointer to BOOL to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::get_Archived (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;
    DWORD   cb = 0;

    DebugTrace("Entering CCertificate::get_Archived().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure cert is already initialized.
        //
        if (!m_pCertContext)
        {
            hr = CAPICOM_E_CERTIFICATE_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: object does not represent an initialized certificate.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
        *pVal = ::CertGetCertificateContextProperty(m_pCertContext, 
                                                    CERT_ARCHIVED_PROP_ID, 
                                                    NULL, 
                                                    &cb) ? VARIANT_TRUE : VARIANT_FALSE;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::get_Archived().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::put_Archived

  Synopsis : Set the archived status.

  Parameter: VARIANT_BOOL newVal - Pointer to BOOL to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::put_Archived (VARIANT_BOOL newVal)
{
    HRESULT   hr       = S_OK;
    LPVOID    pvData   = NULL;
    DATA_BLOB DataBlob = {0, NULL};

    DebugTrace("Entering CCertificate::put_Archived().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure cert is already initialized.
        //
        if (!m_pCertContext)
        {
            hr = CAPICOM_E_CERTIFICATE_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: object does not represent an initialized certificate.\n", hr);
            goto ErrorExit;
        }

        //
        // Not allowed if called from WEB script.
        //
        if (m_dwCurrentSafety)
        {
            hr = CAPICOM_E_NOT_ALLOWED;

            DebugTrace("Error [%#x]: Changing archived bit from within WEB script is not allowed.\n", hr);
            goto ErrorExit;
        }


        //
        // Set/Reset archive property.
        //
        if (newVal)
        {
            pvData = (LPVOID) &DataBlob;
        }

        if (!::CertSetCertificateContextProperty(m_pCertContext, 
                                                 CERT_ARCHIVED_PROP_ID,
                                                 0,
                                                 pvData))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());


            DebugTrace("Error [%#x]: CertSetCertificateContextProperty() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::put_Archived().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::Template

  Synopsis : Return the ITemplate object.

  Parameter: ITemplate ** pVal - Pointer to pointer to ITemplate
                                 to receive the interface pointer.
  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::Template (ITemplate ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CCertificate::Template().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure cert is already initialized.
        //
        if (!m_pCertContext)
        {
            hr = CAPICOM_E_CERTIFICATE_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: object does not represent an initialized certificate.\n", hr);
            goto ErrorExit;
        }

        //
        // Create the embeded ITemplate object, if not already done so.
        //
        if (!m_pITemplate)
        {
            if (FAILED(hr = ::CreateTemplateObject(m_pCertContext, &m_pITemplate)))
            {
                DebugTrace("Error [%#x]: CreateTemplateObject() failed.\n", hr);
                goto ErrorExit;
            }
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_pITemplate);

        //
        // Return interface pointer to user.
        //
        if (FAILED(hr = m_pITemplate->QueryInterface(pVal)))
        {
            DebugTrace("Error [%#x]: m_pITemplate->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }

        ATLASSERT(*pVal);

        DebugTrace("Info: ITemplate vtable value = %#x\n", (PVOID) *pVal);
     }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::Template().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::PublicKey

  Synopsis : Return the IPublicKey object.

  Parameter: IPublicKey ** pVal - Pointer to pointer to IPublicKey
                                  to receive the interface pointer.
  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::PublicKey (IPublicKey ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CCertificate::PublicKey().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure cert is already initialized.
        //
        if (!m_pCertContext)
        {
            hr = CAPICOM_E_CERTIFICATE_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: object does not represent an initialized certificate.\n", hr);
            goto ErrorExit;
        }

        //
        // Create the embeded IPublicKey object, if not already done so.
        //
        if (!m_pIPublicKey)
        {
            if (FAILED(hr = ::CreatePublicKeyObject(m_pCertContext, &m_pIPublicKey)))
            {
                DebugTrace("Error [%#x]: CreatePublicKeybject() failed.\n", hr);
                goto ErrorExit;
            }
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_pIPublicKey);

        //
        // Return interface pointer to user.
        //
        if (FAILED(hr = m_pIPublicKey->QueryInterface(pVal)))
        {
            DebugTrace("Error [%#x]: m_pIPublicKey->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }

        ATLASSERT(*pVal);

        DebugTrace("Info: IPublicKey vtable value = %#x\n", (PVOID) *pVal);
     }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::PublicKey().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::get_PrivateKey

  Synopsis : Return the IPrivateKey object.

  Parameter: IPrivateKey ** pVal - Pointer to pointer to IPrivateKey
                                   to receive the interface pointer.
  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::get_PrivateKey (IPrivateKey ** pVal)
{
    HRESULT hr = S_OK;
    CComPtr<IPrivateKey> pIPrivateKey = NULL;

    DebugTrace("Entering CCertificate::get_PrivateKey().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure cert is already initialized.
        //
        if (!m_pCertContext)
        {
            hr = CAPICOM_E_CERTIFICATE_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: object does not represent an initialized certificate.\n", hr);
            goto ErrorExit;
        }

        //
        // Create the object on the fly (read-only if called from WEB script).
        //
        if (FAILED(hr = ::CreatePrivateKeyObject(m_pCertContext, m_dwCurrentSafety ? TRUE : FALSE, &pIPrivateKey)))
        {
            DebugTrace("Error [%#x]: CreatePrivateKeybject() failed.\n", hr);
            goto ErrorExit;
        }
        
        //
        // Return interface pointer to user.
        //
        if (FAILED(hr = pIPrivateKey->QueryInterface(pVal)))
        {
            DebugTrace("Error [%#x]: pIPrivateKey->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
     }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::get_PrivateKey().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::put_PrivateKey

  Synopsis : Set the IPrivateKey object.

  Parameter: IPrivateKey * newVal - Pointer to IPrivateKey.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::put_PrivateKey (IPrivateKey * newVal)
{
    HRESULT              hr           = S_OK;
    PCRYPT_KEY_PROV_INFO pKeyProvInfo = NULL;

    DebugTrace("Entering CCertificate::put_PrivateKey().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Not allowed if called from WEB script.
        //
        if (m_dwCurrentSafety)
        {
            hr = CAPICOM_E_NOT_ALLOWED;

            DebugTrace("Error [%#x]: Changing PrivateKey from within WEB script is not allowed.\n", hr);
            goto ErrorExit;
        }

        //
        // Check parameters.
        //
        if (NULL == newVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter newVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure cert is already initialized.
        //
        if (!m_pCertContext)
        {
            hr = CAPICOM_E_CERTIFICATE_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: object does not represent an initialized certificate.\n", hr);
            goto ErrorExit;
        }

        //
        // NULL to disassociate.
        //
        if (newVal)
        {
            //
            // Get copy of key prov info.
            //
            if (FAILED(hr = ::GetKeyProvInfo(newVal, &pKeyProvInfo)))
            {
                DebugTrace("Error [%#x]: GetKeyProvInfo() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Make sure public keys match.
            //
            if (FAILED(hr = ::CompareCertAndContainerPublicKey(m_pCertContext, 
                                                               pKeyProvInfo->pwszContainerName,
                                                               pKeyProvInfo->pwszProvName,
                                                               pKeyProvInfo->dwProvType,
                                                               pKeyProvInfo->dwKeySpec,
                                                               pKeyProvInfo->dwFlags & CRYPT_MACHINE_KEYSET)))
            {
                DebugTrace("Error [%#x]: CompareCertAndContainerPublicKey() failed.\n", hr);
                goto ErrorExit;
            }
        }

        //
        // Set the association.
        //
        if (!::CertSetCertificateContextProperty(m_pCertContext, 
                                                 CERT_KEY_PROV_INFO_PROP_ID,
                                                 0,
                                                 pKeyProvInfo))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertSetCertificateContextProperty() failed.\n", hr);
            goto ErrorExit;
        }
     }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resources.
    //
    if (pKeyProvInfo)
    {
        ::CoTaskMemFree(pKeyProvInfo);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::put_PrivateKey().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::Extensions

  Synopsis : Return the IExtensions collection object.

  Parameter: IExtensions ** pVal - Pointer to pointer to IExtensions
                                   to receive the interface pointer.
  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::Extensions (IExtensions ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CCertificate::Extensions().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure cert is already initialized.
        //
        if (!m_pCertContext)
        {
            hr = CAPICOM_E_CERTIFICATE_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: object does not represent an initialized certificate.\n", hr);
            goto ErrorExit;
        }

        //
        // Create the embeded IExtensions object, if not already done so.
        //
        if (!m_pIExtensions)
        {
            if (FAILED(hr = ::CreateExtensionsObject(m_pCertContext, &m_pIExtensions)))
            {
                DebugTrace("Error [%#x]: CreateExtensionsObject() failed.\n", hr);
                goto ErrorExit;
            }
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_pIExtensions);

        //
        // Return interface pointer to user.
        //
        if (FAILED(hr = m_pIExtensions->QueryInterface(pVal)))
        {
            DebugTrace("Error [%#x]: m_pIExtensions->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
     }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::Extensions().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::ExtendedProperties

  Synopsis : Return the IExtendedProperties collection object.

  Parameter: IExtendedProperties ** pVal - Pointer to pointer to 
                                           IExtendedProperties to receive the 
                                           interface pointer.
  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::ExtendedProperties (IExtendedProperties ** pVal)
{
    HRESULT   hr    = S_OK;

    DebugTrace("Entering CCertificate::ExtendedProperties().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure cert is already initialized.
        //
        if (!m_pCertContext)
        {
            hr = CAPICOM_E_CERTIFICATE_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: object does not represent an initialized certificate.\n", hr);
            goto ErrorExit;
        }

        //
        // Create the dynamic IExtendedProperties object.
        //
        if (FAILED(hr = ::CreateExtendedPropertiesObject(m_pCertContext, 
                                                         m_dwCurrentSafety ? TRUE : FALSE,
                                                         pVal)))
        {
            DebugTrace("Error [%#x]: CreateExtendedPropertiesObject() failed.\n", hr);
            goto ErrorExit;
        }
     }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::ExtendedProperties().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::Load

  Synopsis : Method to load certificate(s) from a file.

  Parameter: BSTR FileName - File name.

             BSTR Password - Password (required for PFX file.)

             CAPICOM_KEY_STORAGE_FLAG KeyStorageFlag - Key storage flag.

             CAPICOM_KEY_LOCATION KeyLocation - Key location.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::Load (BSTR                     FileName,
                                 BSTR                     Password,
                                 CAPICOM_KEY_STORAGE_FLAG KeyStorageFlag,
                                 CAPICOM_KEY_LOCATION     KeyLocation)
{
    HRESULT   hr       = S_OK;
    DATA_BLOB CertBlob = {0, NULL};

    DebugTrace("Entering CCertificate::Load().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Not allowed if called from WEB script.
        //
        if (m_dwCurrentSafety)
        {
            hr = CAPICOM_E_NOT_ALLOWED;

            DebugTrace("Error [%#x]: Loading cert file from WEB script is not allowed.\n", hr);
            goto ErrorExit;
        }

        //
        // Check parameters.
        //
        if (0 == ::SysStringLen(FileName))
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter FileName is NULL or empty.\n", hr);
            goto ErrorExit;
        }

        //
        // Work around MIDL problem.
        //
        if (0 == ::SysStringLen(Password))
        {
            Password = NULL;
        }

        //
        // Read entire file in.
        //
        if (FAILED(hr = ::ReadFileContent((LPWSTR) FileName, &CertBlob)))
        {
            DebugTrace("Error [%#x]: ReadFileContent() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Now import the blob.
        //
        if (FAILED(hr = ImportBlob(&CertBlob, TRUE, KeyLocation, Password, KeyStorageFlag)))
        {
            DebugTrace("Error [%#x]: CCertificate::ImportBlob() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resource.
    //
    if (CertBlob.pbData)
    {
        ::UnmapViewOfFile(CertBlob.pbData);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::Load().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::Save

  Synopsis : Method to save certificate(s) to a file.

  Parameter: BSTR FileName - File name.

             BSTR Password - Password (required for PFX file.)

             CAPICOM_CERTIFICATE_SAVE_AS_TYPE FileType - SaveAs type.

             CAPICOM_CERTIFICATE_INCLUDE_OPTION IncludeOption - Include option.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::Save (BSTR                               FileName,
                                 BSTR                               Password,
                                 CAPICOM_CERTIFICATE_SAVE_AS_TYPE   SaveAs,
                                 CAPICOM_CERTIFICATE_INCLUDE_OPTION IncludeOption)
{
    HRESULT    hr         = S_OK;
    HCERTSTORE hCertStore = NULL;

    DebugTrace("Entering CCertificate::Save().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Not allowed if called from WEB script.
        //
        if (m_dwCurrentSafety)
        {
            hr = CAPICOM_E_NOT_ALLOWED;

            DebugTrace("Error [%#x]: Saving cert file from WEB script is not allowed.\n", hr);
            goto ErrorExit;
        }

        //
        // Check parameters.
        //
        if (0 == ::SysStringLen(FileName))
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter FileName is NULL or empty.\n", hr);
            goto ErrorExit;
        }

        //
        // Work around MIDL problem.
        //
        if (0 == ::SysStringLen(Password))
        {
            Password = NULL;
        }

        //
        // Make sure cert is already initialized.
        //
        if (!m_pCertContext)
        {
            hr = CAPICOM_E_CERTIFICATE_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: object does not represent an initialized certificate.\n", hr);
            goto ErrorExit;
        }

        //
        // Check file type.
        //
        switch (SaveAs)
        {
            case CAPICOM_CERTIFICATE_SAVE_AS_CER:
            {
                DATA_BLOB DataBlob;
                
                //
                // Simply write the encoded cert blob to file.
                //
                DataBlob.cbData = m_pCertContext->cbCertEncoded;
                DataBlob.pbData = m_pCertContext->pbCertEncoded;

                if (FAILED(hr = ::WriteFileContent(FileName, DataBlob)))
                {
                    DebugTrace("Error [%#x]: WriteFileContent() failed.\n", hr);
                    goto ErrorExit;
                }

                break;
            }

            case CAPICOM_CERTIFICATE_SAVE_AS_PFX:
            {
                //
                // Create a memory store.
                //
                if (!(hCertStore = ::CertOpenStore(CERT_STORE_PROV_MEMORY, 
                                                   CAPICOM_ASN_ENCODING,
                                                   0, 
                                                   0,
                                                   NULL)))
                {
                    hr = HRESULT_FROM_WIN32(::GetLastError());
       
                    DebugTrace("Error [%#x]: CertOpenStore() failed.\n", hr);
                    goto ErrorExit;
                }

                //
                // Add all requested certs to the store.
                //
                if (FAILED(hr = ::CertToStore(m_pCertContext, IncludeOption, hCertStore)))
                {
                    DebugTrace("Error [%#x]: CertToStore() failed.\n", hr);
                    goto ErrorExit;
                }

                //
                // Save as PFX file.
                //
                if (FAILED(hr = ::PFXSaveStore(hCertStore, 
                                               FileName, 
                                               Password, 
                                               EXPORT_PRIVATE_KEYS | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY)))
                {
                    DebugTrace("Error [%#x]: PFXSaveStore() failed.\n", hr);
                    goto ErrorExit;
                }

                break;
            }

            default:
            {
                hr = E_INVALIDARG;

                DebugTrace("Error: invalid parameter, unknown save as type.\n");
                goto ErrorExit;
            }
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resources.
    //
    if (hCertStore)
    {
        ::CertCloseStore(hCertStore, 0);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::Save().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// Custom interfaces.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::get_CertContext

  Synopsis : Return the certificate's PCCERT_CONTEXT.

  Parameter: long * ppCertContext - Pointer to PCCERT_CONTEXT disguished in a
                                    long.

  Remark   : We need to use long instead of PCCERT_CONTEXT because VB can't 
             handle double indirection (i.e. vb would bark on this 
             PCCERT_CONTEXT * ppCertContext).
 
------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::get_CertContext (long * ppCertContext)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CCertificate::get_CertContext().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Return cert context to caller.
        //
        if (FAILED(hr = GetContext((PCCERT_CONTEXT *) ppCertContext)))
        {
            DebugTrace("Error [%#x]: CCertificate::GetContext() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::get_CertContext().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::put_CertContext

  Synopsis : Initialize the object with a CERT_CONTEXT.

  Parameter: long pCertContext - Poiner to CERT_CONTEXT, disguised in a long,
                                 used to initialize this object.

  Remark   : Note that this is NOT 64-bit compatiable. Plese see remark of
             get_CertContext for more detail.

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::put_CertContext (long pCertContext)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CCertificate::put_CertContext().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Reset the object with this context.
        //
        if (FAILED(hr = PutContext((PCCERT_CONTEXT) pCertContext, m_dwCurrentSafety)))
        {
            DebugTrace("Error [%#x]: CCertificate::PutContext() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::put_CertContext().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::FreeContext

  Synopsis : Free a CERT_CONTEXT.

  Parameter: long pCertContext - Poiner to CERT_CONTEXT, disguised in a long,
                                 to be freed.

  Remark   : Note that this is NOT 64-bit compatiable. Plese see remark of
             get_CertContext for more detail.

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::FreeContext (long pCertContext)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CCertificate::FreeContext().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Free the context.
        //
        if (!::CertFreeCertificateContext((PCCERT_CONTEXT) pCertContext))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertFreeCertificateContext() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificate::FreeContext().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// Private methods.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::ImportBlob

  Synopsis : Private function to load a certificate from blob.

  Parameter: DATA_BLOB * pCertBlob

             BOOL bAllowPfx

             CAPICOM_KEY_LOCATION KeyLocation - Key location.

             BSTR pwszPassword - Password (required for PFX file.)

             CAPICOM_KEY_STORAGE_FLAG KeyStorageFlag - Key storage flag.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::ImportBlob (DATA_BLOB              * pCertBlob,
                                       BOOL                     bAllowPfx,
                                       CAPICOM_KEY_LOCATION     KeyLocation,
                                       BSTR                     pwszPassword,
                                       CAPICOM_KEY_STORAGE_FLAG KeyStorageFlag)
{
    HRESULT        hr             = S_OK;
    HCERTSTORE     hCertStore     = NULL;
    PCCERT_CONTEXT pEnumContext   = NULL;
    PCCERT_CONTEXT pCertContext   = NULL;
    DWORD          dwContentType  = 0;
    DWORD          cb             = 0;
    DWORD          dwFlags        = 0;
    DWORD          dwExpectedType = CERT_QUERY_CONTENT_FLAG_CERT |
                                    CERT_QUERY_CONTENT_FLAG_SERIALIZED_CERT;

    DebugTrace("Entering CCertificate::ImportBlob().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertBlob);
    
    //
    // Set PFX flag, if allowed.
    //
    if (bAllowPfx)
    {
        dwExpectedType |= CERT_QUERY_CONTENT_FLAG_PFX;
    }

    //
    // Crack the blob.
    //
    if (!::CryptQueryObject(CERT_QUERY_OBJECT_BLOB,
                            (LPCVOID) pCertBlob,
                            dwExpectedType,
                            CERT_QUERY_FORMAT_FLAG_ALL, 
                            0,
                            NULL,
                            &dwContentType,
                            NULL,
                            &hCertStore,
                            NULL,
                            NULL))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptQueryObject() failed.\n", hr);
        goto ErrorExit;
    }

    DebugTrace("Info: CryptQueryObject() returns dwContentType = %#x.\n", dwContentType);

    //
    // Need to import it ourselves for PFX file.
    //
    if (CERT_QUERY_CONTENT_PFX == dwContentType)
    {
        //
        // Make sure PFX is allowed.
        //
        if (!bAllowPfx)
        {
            hr = CAPICOM_E_NOT_SUPPORTED;

            DebugTrace("Error [%#x]: Importing PFX where not supported.\n", hr);
            goto ErrorExit;
        }

        // 
        // Setup import flags.
        //
        if (CAPICOM_LOCAL_MACHINE_KEY == KeyLocation)
        {
            dwFlags |= CRYPT_MACHINE_KEYSET;
        }
        else if (IsWin2KAndAbove())
        {
            dwFlags |= CRYPT_USER_KEYSET;
        }

        if (KeyStorageFlag & CAPICOM_KEY_STORAGE_EXPORTABLE)
        {
            dwFlags |= CRYPT_EXPORTABLE;
        }

        if (KeyStorageFlag & CAPICOM_KEY_STORAGE_USER_PROTECTED)
        {
            dwFlags |= CRYPT_USER_PROTECTED;
        }

        DebugTrace("Info: dwFlags = %#x.", dwFlags);

        //
        // Now import the blob to store.
        //
        if (!(hCertStore = ::PFXImportCertStore((CRYPT_DATA_BLOB *) pCertBlob,
                                                pwszPassword,
                                                dwFlags)))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: PFXImportCertStore() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(hCertStore);

        //
        // Find the first cert with private key, if none, then simply take
        // the very first cert.
        //
        while (pEnumContext = ::CertEnumCertificatesInStore(hCertStore, pEnumContext))
        {
            //
            // Does this cert has a private key?
            //
            if (::CertGetCertificateContextProperty(pEnumContext, 
                                                    CERT_KEY_PROV_INFO_PROP_ID, 
                                                    NULL, 
                                                    &cb))
            {
                //
                // Yes, so free the one without private key, had we found one previously.
                //
                if (pCertContext)
                {
                    if (!::CertFreeCertificateContext(pCertContext))
                    {
                        hr = HRESULT_FROM_WIN32(::GetLastError());

                        DebugTrace("Error [%#x]: CertFreeCertificateContext() failed.\n", hr);
                        goto ErrorExit;
                    }
                }

                if (!(pCertContext = ::CertDuplicateCertificateContext(pEnumContext)))
                {
                    hr = HRESULT_FROM_WIN32(::GetLastError());

                    DebugTrace("Error [%#x]: CertDuplicateCertificateContext() failed.\n", hr);
                    goto ErrorExit;
                }

                //
                // Set last error before we break out of loop.
                //
                ::SetLastError((DWORD) CRYPT_E_NOT_FOUND);

                break;
            }
            else
            {
                //
                // Keep the first one.
                //
                if (!pCertContext)
                {
                    if (!(pCertContext = ::CertDuplicateCertificateContext(pEnumContext)))
                    {
                        hr = HRESULT_FROM_WIN32(::GetLastError());

                        DebugTrace("Error [%#x]: CertDuplicateCertificateContext() failed.\n", hr);
                        goto ErrorExit;
                    }
                }
            }
        }

        //
        // Above loop can exit either because there is no more certificate in
        // the store or an error. Need to check last error to be certain.
        //
        if (CRYPT_E_NOT_FOUND != ::GetLastError())
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
    
            DebugTrace("Error [%#x]: CertEnumCertificatesInStore() failed.\n", hr);
            goto ErrorExit;
        }
    }
    else
    {
        //
        // It is a CER file, so it must have only 1 cert.
        //
        if (!(pCertContext = ::CertEnumCertificatesInStore(hCertStore, NULL)))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
    
            DebugTrace("Error [%#x]: CertEnumCertificatesInStore() failed.\n", hr);
            goto ErrorExit;
        }
    }

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);

    //
    // Now initialize the object with the found cert.
    //
    if (FAILED(hr = PutContext(pCertContext, m_dwCurrentSafety)))
    {
        DebugTrace("Error [%#x]: CCertificate::PutContext() failed.\n", hr);
        goto ErrorExit;
    }   

CommonExit:
    //
    // Free resource.
    //
    if (pCertContext)
    {
        ::CertFreeCertificateContext(pCertContext);
    }

    if (pEnumContext)
    {
        ::CertFreeCertificateContext(pEnumContext);
    }

    if (hCertStore)
    {
        ::CertCloseStore(hCertStore, 0);
    }

    DebugTrace("Leaving CCertificate::ImportBlob().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::GetContext

  Synopsis : Return the certificate's PCCERT_CONTEXT.

  Parameter: PCCERT_CONTEXT * ppCertContext - Pointer to PCCERT_CONTEXT.

  Remark   : This method is designed for internal use only, and therefore,
             should not be exposed to user.

             Note that this is a custom interface, not a dispinterface.

             Note that the cert context ref count is incremented by
             CertDuplicateCertificateContext(), so it is the caller's
             responsibility to free the context.
 
------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::GetContext (PCCERT_CONTEXT * ppCertContext)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CCertificate::GetContext().\n");

    //
    // Make sure cert is already initialized.
    //
    if (!m_pCertContext)
    {
        hr = CAPICOM_E_CERTIFICATE_NOT_INITIALIZED;

        DebugTrace("Error [%#x]: object does not represent an initialized certificate.\n", hr);
        goto ErrorExit;
    }

    //
    // Sanity check.
    //
    ATLASSERT(ppCertContext);

    //
    // Duplicate the cert context.
    //
    if (!(*ppCertContext = ::CertDuplicateCertificateContext(m_pCertContext)))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CertDuplicateCertificateContext() failed.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CCertificate::GetContext().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::PutContext

  Synopsis : Initialize the object with a CERT_CONTEXT.

  Parameter: PCERT_CONTEXT pCertContext - Poiner to CERT_CONTEXT used to 
                                          initialize this object.

             DWORD dwCurrentSafety  - Current safety setting.

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CCertificate::PutContext (PCCERT_CONTEXT pCertContext,
                                       DWORD          dwCurrentSafety)
{
    HRESULT        hr            = S_OK;
    PCCERT_CONTEXT pCertContext2 = NULL;

    DebugTrace("Entering CCertificate::PutContext().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);

    //
    // Duplicate the cert context.
    //
    if (!(pCertContext2 = ::CertDuplicateCertificateContext(pCertContext)))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CertDupliacteCertificateContext() failed.\n");
        goto ErrorExit;
    }

    //
    // Free previous context, if any.
    //
    if (m_pCertContext)
    {
        if (!::CertFreeCertificateContext(m_pCertContext))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertFreeCertificateContext() failed.\n");
            goto ErrorExit;
        }
    }

    //
    // Reset.
    //
    m_pCertContext = pCertContext2;
    m_pIKeyUsage.Release();
    m_pIExtendedKeyUsage.Release();
    m_pIBasicConstraints.Release();
    m_pICertificateStatus.Release();
    m_pITemplate.Release();
    m_pIPublicKey.Release();
    m_pIExtensions.Release();
    m_dwCurrentSafety = dwCurrentSafety;

CommonExit:

    DebugTrace("Leaving CCertificate::PutContext().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resources.
    //
    if (pCertContext2)
    {
        ::CertFreeCertificateContext(pCertContext2);
    }

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\certificates.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:     Certificates.cpp

  Contents: Implementation of CCertificates class for collection of 
            ICertificate objects.

  Remarks:  This object is not creatable by user directly. It can only be
            created via property/method of other CAPICOM objects.

            The collection container is implemented usign STL::map of 
            STL::pair of BSTR and ICertificate..

            See Chapter 9 of "BEGINNING ATL 3 COM Programming" for algorithm
            adopted in here.

  History:  11-15-99    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "Certificates.h"
#include "Common.h"
#include "Convert.h"
#include "CertHlpr.h"
#include "MsgHlpr.h"
#include "PFXHlpr.h"
#include "Policy.h"
#include "Settings.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateCertificatesObject

  Synopsis : Create an ICertificates collection object, and load the object with 
             certificates from the specified source.

  Parameter: CAPICOM_CERTIFICATES_SOURCE ccs - Source where to get the 
                                               certificates.

             DWORD dwCurrentSafety - Current safety setting.

             BOOL bIndexedByThumbprint - TRUE to index by thumbprint.

             ICertificates2 ** ppICertificates - Pointer to pointer to 
                                                 ICertificates to receive the
                                                 interface pointer.
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateCertificatesObject (CAPICOM_CERTIFICATES_SOURCE ccs,
                                  DWORD                       dwCurrentSafety,
                                  BOOL                        bIndexedByThumbprint,
                                  ICertificates2           ** ppICertificates)
{
    HRESULT hr = S_OK;
    CComObject<CCertificates> * pCCertificates = NULL;

    DebugTrace("Entering CreateCertificatesObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(ppICertificates);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CCertificates>::CreateInstance(&pCCertificates)))
        {
            DebugTrace("Error [%#x]: CComObject<CCertificates>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize object.
        //
        if (FAILED(hr = pCCertificates->Init(ccs, dwCurrentSafety, bIndexedByThumbprint)))
        {
            DebugTrace("Error [%#x]: pCCertificates->Init() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return interface pointer to caller.
        //
        if (FAILED(hr = pCCertificates->QueryInterface(ppICertificates)))
        {
            DebugTrace("Error [%#x]: pCCertificates->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreateCertificatesObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (pCCertificates)
    {
        delete pCCertificates;
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : FindTimeValidCallback

  Synopsis : Callback for find-time-valid.

  Parameter: See CryptUI.h.


  Remark   : 

------------------------------------------------------------------------------*/

static BOOL WINAPI FindTimeValidCallback (PCCERT_CONTEXT pCertContext,
                                          BOOL         * pfInitialSelectedCert,
                                          LPVOID         pvCallbackData)
{
    LONG lResult  = 0;
    BOOL bInclude = TRUE;

    DebugTrace("Entering FindTimeValidCallback().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(pvCallbackData);

    //
    // Skip it if not yet valid or expired.
    //
    if (0 != (lResult = ::CertVerifyTimeValidity((LPFILETIME) pvCallbackData,
                                                 pCertContext->pCertInfo)))
    {
        bInclude = FALSE;

        DebugTrace("Info: Time is not valid (lResult = %d)\n", lResult);
        DebugTrace("      Time (High = %#x, Low = %#x).\n",
                   ((LPFILETIME) pvCallbackData)->dwHighDateTime,
                   ((LPFILETIME) pvCallbackData)->dwLowDateTime);
        DebugTrace("      NotBefore (High = %#x, Low = %#x).\n", 
                   pCertContext->pCertInfo->NotBefore.dwHighDateTime,
                   pCertContext->pCertInfo->NotBefore.dwLowDateTime);
        DebugTrace("      NotAfter (High = %#x, Low = %#x).\n", 
                   pCertContext->pCertInfo->NotAfter.dwHighDateTime,
                   pCertContext->pCertInfo->NotAfter.dwLowDateTime);
    }

    DebugTrace("Leaving FindTimeValidCallback().\n");

    return bInclude;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : FindNotBeforeCallback

  Synopsis : Callback for find-by-not-before.

  Parameter: See CryptUI.h.


  Remark   : 

------------------------------------------------------------------------------*/

static BOOL WINAPI FindNotBeforeCallback (PCCERT_CONTEXT pCertContext,
                                          BOOL         * pfInitialSelectedCert,
                                          LPVOID         pvCallbackData)
{
    BOOL bInclude = TRUE;

    DebugTrace("Entering FindNotBeforeCallback().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(pvCallbackData);

    //
    // Skip it if time valid or expired.
    //
    if (!(-1 == ::CertVerifyTimeValidity((LPFILETIME) pvCallbackData,
                                         pCertContext->pCertInfo)))
    {
        bInclude = FALSE;

        DebugTrace("Info: time (High = %#x, Low = %#x) is either valid or expired.\n", 
                   ((LPFILETIME) pvCallbackData)->dwHighDateTime,
                   ((LPFILETIME) pvCallbackData)->dwLowDateTime);
    }

    DebugTrace("Leaving FindNotBeforeCallback().\n");

    return bInclude;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : FindNotAfterCallback

  Synopsis : Callback for find-by-not-after.

  Parameter: See CryptUI.h.


  Remark   : 

------------------------------------------------------------------------------*/

static BOOL WINAPI FindNotAfterCallback (PCCERT_CONTEXT pCertContext,
                                         BOOL         * pfInitialSelectedCert,
                                         LPVOID         pvCallbackData)
{
    BOOL bInclude = TRUE;

    DebugTrace("Entering FindNotAfterCallback().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(pvCallbackData);

    //
    // Skip it if not expired.
    //
    if (!(1 == ::CertVerifyTimeValidity((LPFILETIME) pvCallbackData,
                                        pCertContext->pCertInfo)))
    {
        bInclude = FALSE;

        DebugTrace("Info: time (High = %#x, Low = %#x) is not expired.\n", 
                   ((LPFILETIME) pvCallbackData)->dwHighDateTime,
                   ((LPFILETIME) pvCallbackData)->dwLowDateTime);
    }

    DebugTrace("Leaving FindNotAfterCallback().\n");

    return bInclude;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : FindTemplateCallback

  Synopsis : Callback for find-by-template.

  Parameter: See CryptUI.h.

  Remark   : 

------------------------------------------------------------------------------*/

static BOOL WINAPI FindTemplateCallback (PCCERT_CONTEXT pCertContext,
                                         BOOL         * pfInitialSelectedCert,
                                         LPVOID         pvCallbackData)
{
    HRESULT         hr           = S_OK;
    BOOL            bInclude     = FALSE;
    DATA_BLOB       CertTypeBlob = {0, NULL};
    DATA_BLOB       TemplateBlob = {0, NULL};
    PCERT_EXTENSION pCertType    = NULL;
    PCERT_EXTENSION pCertTemp    = NULL;

    DebugTrace("Entering FindTemplateCallback().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(pvCallbackData);

    //
    // Skip it if we don't have either szOID_ENROLL_CERTTYPE_EXTENSION or
    // szOID_CERTIFICATE_TEMPLATE extension.
    //
    if (!(pCertType = ::CertFindExtension(szOID_ENROLL_CERTTYPE_EXTENSION,
                                          pCertContext->pCertInfo->cExtension,
                                          pCertContext->pCertInfo->rgExtension)) && 
        !(pCertTemp = ::CertFindExtension(szOID_CERTIFICATE_TEMPLATE,
                                          pCertContext->pCertInfo->cExtension,
                                          pCertContext->pCertInfo->rgExtension)))
    {
        DebugTrace("Info: could not find both szOID_ENROLL_CERTTYPE_EXTENSION and szOID_CERTIFICATE_TEMPLATE.\n");
        goto CommonExit;
    }

    //
    // Check cert type template name if found.
    //
    if (pCertType)
    {
        PCERT_NAME_VALUE pNameValue = NULL;

        //
        // Decode the extension.
        //
        if (FAILED(hr = ::DecodeObject(X509_UNICODE_ANY_STRING, 
                                       pCertType->Value.pbData, 
                                       pCertType->Value.cbData,
                                       &CertTypeBlob)))
        {
            DebugTrace("Info [%#x]: DecodeObject() failed.\n", hr);
            goto CommonExit;
        }

        pNameValue = (PCERT_NAME_VALUE) CertTypeBlob.pbData;

        if (0 == ::_wcsicmp((LPWSTR) pNameValue->Value.pbData, (LPWSTR) pvCallbackData))
        {
            bInclude = TRUE;
        }
    }

    //
    // Look into cert template extension, if necessary.
    //
    if (!bInclude && pCertTemp)
    {
        PCCRYPT_OID_INFO   pOidInfo  = NULL;
        PCERT_TEMPLATE_EXT pTemplate = NULL;

        //
        // Decode the extension.
        //
        if (FAILED(hr = ::DecodeObject(szOID_CERTIFICATE_TEMPLATE, 
                                       pCertTemp->Value.pbData, 
                                       pCertTemp->Value.cbData,
                                       &TemplateBlob)))
        {
            DebugTrace("Info [%#x]: DecodeObject() failed.\n", hr);
            goto CommonExit;
        }

        pTemplate = (PCERT_TEMPLATE_EXT) TemplateBlob.pbData;

        //
        // Convert to OID if user passed in friendly name.
        //
        if (pOidInfo = ::CryptFindOIDInfo(CRYPT_OID_INFO_NAME_KEY,
                                          pvCallbackData,
                                          CRYPT_TEMPLATE_OID_GROUP_ID))
        {
            if (0 == ::strcmp(pTemplate->pszObjId, pOidInfo->pszOID))
            {
                bInclude = TRUE;
            }
        }
        else
        {
            CComBSTR bstrOID;

            if (!(bstrOID = pTemplate->pszObjId))
            {
                DebugTrace("Info: bstrOID = pTemplate->pszObjId failed.\n", hr);
                goto CommonExit;
            }

            if (0 == ::wcscmp(bstrOID, (LPWSTR) pvCallbackData))
            {
                bInclude = TRUE;
            }
        }
    }

CommonExit:
    //
    // Free resources.
    //
    if (TemplateBlob.pbData)
    {
        ::CoTaskMemFree((LPVOID) TemplateBlob.pbData);
    }
    if (CertTypeBlob.pbData)
    {
        ::CoTaskMemFree((LPVOID) CertTypeBlob.pbData);
    }

    DebugTrace("Leaving FindTemplateCallback().\n");

    return bInclude;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : FindExtensionCallback

  Synopsis : Callback for find-by-extension.

  Parameter: See CryptUI.h.


  Remark   : 

------------------------------------------------------------------------------*/

static BOOL WINAPI FindExtensionCallback (PCCERT_CONTEXT pCertContext,
                                          BOOL         * pfInitialSelectedCert,
                                          LPVOID         pvCallbackData)
{
    BOOL             bInclude   = TRUE;
    PCERT_EXTENSION  pExtension = NULL;

    DebugTrace("Entering FindExtensionCallback().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(pvCallbackData);

    //
    // Skip it if we can't find the specified extension.
    //
    if (!(pExtension = ::CertFindExtension((LPSTR) pvCallbackData,
                                           pCertContext->pCertInfo->cExtension,
                                           pCertContext->pCertInfo->rgExtension)))
    {
        bInclude = FALSE;

        DebugTrace("Info: extension (%s) could not be found.\n", pvCallbackData);
    }

    DebugTrace("Leaving FindExtensionCallback().\n");

    return bInclude;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : FindRootNameCallback

  Synopsis : Callback for find-by-rootname.

  Parameter: See CryptUI.h.

  Remark   : 

------------------------------------------------------------------------------*/

static BOOL WINAPI FindRootNameCallback (PCCERT_CHAIN_CONTEXT pChainContext,
                                         BOOL               * pfInitialSelectedChain,
                                         LPVOID               pvCallbackData)
{
    BOOL               bInclude     = FALSE;
    HCERTSTORE         hCertStore   = NULL;
    PCCERT_CONTEXT     pRootContext = NULL;
    PCERT_SIMPLE_CHAIN pSimpleChain;

    DebugTrace("Entering FindRootNameCallback().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pChainContext);
    ATLASSERT(pvCallbackData);

    //
    // Skip if we don't have a complete chain (we don't have a root cert).
    //
    if (CERT_TRUST_IS_PARTIAL_CHAIN & pChainContext->TrustStatus.dwErrorStatus)
    {
        DebugTrace("Info: certificate has only partial chain.\n");
        goto CommonExit;
    }

    //
    // Open a new temporary memory store.
    //
    if (!(hCertStore = ::CertOpenStore(CERT_STORE_PROV_MEMORY,
                                       CAPICOM_ASN_ENCODING,
                                       NULL,
                                       CERT_STORE_CREATE_NEW_FLAG,
                                       NULL)))
    {
        DebugTrace("Info [%#x]: CertOpenStore() failed.\n", 
                    HRESULT_FROM_WIN32(::GetLastError()));
        goto CommonExit;
    }

    //
    // Copy the root cert of simple chain to memory store.
    //
    pSimpleChain = pChainContext->rgpChain[0];
    if (!::CertAddCertificateContextToStore(hCertStore, 
                                            pSimpleChain->rgpElement[pSimpleChain->cElement - 1]->pCertContext, 
                                            CERT_STORE_ADD_ALWAYS, 
                                            NULL))
    {
        DebugTrace("Info [%#x]: CertAddCertificateContextToStore() failed.\n", 
                   HRESULT_FROM_WIN32(::GetLastError()));
        goto CommonExit;
    }

    //
    // Does it match?
    //
    if (!(pRootContext = ::CertFindCertificateInStore(hCertStore,
                                                      CAPICOM_ASN_ENCODING,
                                                      0,
                                                      CERT_FIND_SUBJECT_STR,
                                                      pvCallbackData,
                                                      pRootContext)))
    {
        DebugTrace("Info [%#x]: CertFindCertificateInStore() failed.\n", 
                   HRESULT_FROM_WIN32(::GetLastError()));
        goto CommonExit;
    }

    //
    // We have a match.
    //
    bInclude = TRUE;

CommonExit:
    //
    // Free resources.
    //
    if (pRootContext)
    {
        ::CertFreeCertificateContext(pRootContext);
    }
    if (hCertStore)
    {
        ::CertCloseStore(hCertStore, 0);
    }

    DebugTrace("Leaving FindRootNameCallback().\n");

    return bInclude;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : FindApplicationPolicyCallback

  Synopsis : Callback for find-by-application-policy.

  Parameter: See CryptUI.h.

  Remark   : 

------------------------------------------------------------------------------*/

static BOOL WINAPI FindApplicationPolicyCallback (PCCERT_CONTEXT pCertContext,
                                                  BOOL         * pfInitialSelectedChain,
                                                  LPVOID         pvCallbackData)
{
    BOOL    bInclude = FALSE;
    int     cNumOIDs = 0;
    DWORD   cbOIDs   = 0;
    LPSTR * rghOIDs  = NULL;

    DebugTrace("Entering FindApplicationPolicyCallback().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(pvCallbackData);

    //
    // Get all the valid application usages.
    //
    if (!::CertGetValidUsages(1, &pCertContext, &cNumOIDs, NULL, &cbOIDs))
    {
        DebugTrace("Info [%#x]: CertGetValidUsages() failed.\n", 
                   HRESULT_FROM_WIN32(::GetLastError()));
        goto CommonExit;
    }

    if (!(rghOIDs = (LPSTR *) ::CoTaskMemAlloc(cbOIDs)))
    {
        DebugTrace("Info: out of memory..\n");
        goto CommonExit;
    }

    if (!::CertGetValidUsages(1, &pCertContext, &cNumOIDs, rghOIDs, &cbOIDs))
    {
        DebugTrace("Info [%#x]: CertGetValidUsages() failed.\n", 
                   HRESULT_FROM_WIN32(::GetLastError()));
        goto CommonExit;
    }

    //
    // No EKU is consider good for all.
    //
    if (-1 == cNumOIDs)
    {
        bInclude = TRUE;
    }
    else
    {
        //
        // See if we can find it in the array.
        //
        while (cNumOIDs--)
        {
            if (0 == ::strcmp((LPSTR) pvCallbackData, rghOIDs[cNumOIDs]))
            {
                bInclude = TRUE;
                break;
            }
        }
    }

CommonExit:
    //
    // Free resources.
    //
    if (rghOIDs)
    {
        ::CoTaskMemFree((LPVOID) rghOIDs);
    }

    DebugTrace("Leaving FindApplicationPolicyCallback().\n");

    return bInclude;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : FindCertificatePolicyCallback

  Synopsis : Callback for find-by-certificate-policy.

  Parameter: See CryptUI.h.

  Remark   : 

------------------------------------------------------------------------------*/

static BOOL WINAPI FindCertificatePolicyCallback (PCCERT_CONTEXT pCertContext,
                                                  BOOL         * pfInitialSelectedChain,
                                                  LPVOID         pvCallbackData)
{
    HRESULT             hr         = S_OK;
    BOOL                bInclude   = FALSE;
    DWORD               dwIndex    = 0;
    DATA_BLOB           DataBlob   = {0, NULL};
    PCERT_EXTENSION     pExtension = NULL;
    PCERT_POLICIES_INFO pInfo      = NULL;

    DebugTrace("Entering FindCertificatePolicyCallback().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(pvCallbackData);

    //
    // Find the szOID_CERT_POLICIES extension.
    //
    if (!(pExtension = ::CertFindExtension(szOID_CERT_POLICIES,
                                           pCertContext->pCertInfo->cExtension,
                                           pCertContext->pCertInfo->rgExtension)))
    {
        DebugTrace("Info [%#x]: CertFindExtension() failed.\n", 
                   HRESULT_FROM_WIN32(::GetLastError()));
        goto CommonExit;
    }

    //
    // Decode the extension.
    //
    if (FAILED(hr = ::DecodeObject(szOID_CERT_POLICIES, 
                                   pExtension->Value.pbData,
                                   pExtension->Value.cbData, 
                                   &DataBlob)))
    {
        DebugTrace("Info [%#x]: DecodeObject() failed.\n", hr);
        goto CommonExit;
    }

    pInfo = (PCERT_POLICIES_INFO) DataBlob.pbData;
    dwIndex = pInfo->cPolicyInfo;

    //
    // Try to find a match.
    //
    while (dwIndex--)
    {
        if (0 == ::strcmp(pInfo->rgPolicyInfo[dwIndex].pszPolicyIdentifier, (LPSTR) pvCallbackData))
        {
            bInclude = TRUE;
            break;
        }
    }

CommonExit:
    //
    // Free resources.
    //
    if (DataBlob.pbData)
    {
        ::CoTaskMemFree((LPVOID) DataBlob.pbData);
    }

    DebugTrace("Leaving FindCertificatePolicyCallback().\n");

    return bInclude;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : FindKeyUsageCallback

  Synopsis : Callback for find-by-key-usage.

  Parameter: See CryptUI.h.

  Remark   : 

------------------------------------------------------------------------------*/

static BOOL WINAPI FindKeyUsageCallback (PCCERT_CONTEXT pCertContext,
                                         BOOL         * pfInitialSelectedChain,
                                         LPVOID         pvCallbackData)
{
    HRESULT hr             = S_OK;
    BOOL    bInclude       = FALSE;
    DWORD   dwActualUsages = 0;
    DWORD   dwCheckUsages  = 0;

    DebugTrace("Entering FindKeyUsageCallback().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(pvCallbackData);

    //
    // Check the key usage.
    //
    if (!::CertGetIntendedKeyUsage(CAPICOM_ASN_ENCODING,
                                   pCertContext->pCertInfo,
                                   (BYTE *) &dwActualUsages,
                                   sizeof(dwActualUsages))) 
    {
        //
        // Could be extension not present or an error.
        //
        if (FAILED(hr = HRESULT_FROM_WIN32(::GetLastError())))
        {
            DebugTrace("Error [%#x]: CertGetIntendedKeyUsage() failed.\n", hr);
            goto CommonExit;
        }
    }

    //
    // Check the bit mask.
    //
    dwCheckUsages = *(LPDWORD) pvCallbackData;

    if ((dwActualUsages & dwCheckUsages) == dwCheckUsages)
    {
        bInclude = TRUE;
    }

CommonExit:

    DebugTrace("Leaving FindKeyUsageCallback().\n");

    return bInclude;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : FindByChain

  Synopsis : Find certificate(s) in store based on chain's criteria and filter 
             with a callback.

  Parameter: HCERTSTORE hCertStore - Store to find certificate(s).
                                
             DWORD dwFindType - Find type.

             LPCVOID pvFindPara - Content to be found.

             VARIANT_BOOL bFindValidOnly - True to find valid certs only.

             PFNCHAINFILTERPROC pfnFilterCallback - Callback filter.

             LPVOID pvCallbackData - Callback data.

             DWORD dwCurrentSafety - Current safety setting.

             ICertificates2 ** ppICertificates - Pointer to pointer
                                                 ICertificates2 object.
  Remark   : 

------------------------------------------------------------------------------*/

static HRESULT FindByChain (HCERTSTORE         hCertStore,
                            DWORD              dwFindType,
                            LPCVOID            pvFindPara,
                            VARIANT_BOOL       bFindValidOnly,
                            PFNCHAINFILTERPROC pfnFilterCallback,
                            LPVOID             pvCallbackData,
                            DWORD              dwCurrentSafety,
                            ICertificates2   * pICertificates)
{
    HRESULT              hr            = S_OK;
    DWORD                dwWin32Error  = 0;
    PCCERT_CHAIN_CONTEXT pChainContext = NULL;

    DebugTrace("Entering FindByChain().\n");

    //
    // Sanity check.
    //
    ATLASSERT(hCertStore);
    ATLASSERT(pICertificates);

    //
    // Find all chains in the store, matching the find criteria.
    //
    while (pChainContext = ::CertFindChainInStore(hCertStore,
                                                  CAPICOM_ASN_ENCODING,
                                                  0,
                                                  dwFindType,
                                                  pvFindPara,
                                                  pChainContext))
    {
        CComPtr<ICertificate2> pICertificate = NULL;

        //
        // Apply filter if available.
        //
        if (pfnFilterCallback && !pfnFilterCallback(pChainContext, NULL, pvCallbackData))
        {
            continue;
        }

        //
        // Skip it if check is required and the cert is not valid.
        //
        if (bFindValidOnly && (CERT_TRUST_NO_ERROR != pChainContext->TrustStatus.dwErrorStatus))
        {
            continue;
        }

        //
        // Sanity check.
        //
        ATLASSERT(pChainContext->cChain);
        ATLASSERT(pChainContext->rgpChain);
        ATLASSERT(pChainContext->rgpChain[0]);
        ATLASSERT(pChainContext->rgpChain[0]->cElement);
        ATLASSERT(pChainContext->rgpChain[0]->rgpElement);
        ATLASSERT(pChainContext->rgpChain[0]->rgpElement[0]);
        ATLASSERT(pChainContext->rgpChain[0]->rgpElement[0]->pCertContext);

        //
        // Create a ICertificate object for the found certificate.
        //
        if (FAILED (hr = ::CreateCertificateObject(
                                pChainContext->rgpChain[0]->rgpElement[0]->pCertContext,
                                dwCurrentSafety,
                                &pICertificate)))
        {
            DebugTrace("Error [%#x]: CreateCertificateObject() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Add to collection.
        //
        if (FAILED(hr = pICertificates->Add(pICertificate)))
        {
            DebugTrace("Error [%#x]: pICertificates->Add() failed.\n", hr);
            goto ErrorExit;
        }
    }

    //
    // Above loop can exit with normal or error condition.
    //
    if (CRYPT_E_NOT_FOUND != (dwWin32Error = ::GetLastError()))
    {
        hr = HRESULT_FROM_WIN32(dwWin32Error);

        DebugTrace("Error [%#x]: CertFindChainInStore() failed.\n", hr);
        goto ErrorExit;
    }

CommonExit:
    //
    // Free resources.
    //
    if (pChainContext)
    {
        ::CertFreeCertificateChain(pChainContext);
    }

    DebugTrace("Leaving FindByChain().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : FindByCert

  Synopsis : Find certificate(s) in store and filter with a callback.

  Parameter: HCERTSTORE hCertStore - Store to find certificate(s).
                                
             DWORD dwFindType - Find type.

             LPCVOID pvFindPara - Content to be found.

             VARIANT_BOOL bFindValidOnly - True to find valid certs only.

             PFNCERTFILTERPROC pfnFilterCallback - Callback filter.

             LPVOID pvCallbackData - Callback data.

             DWORD dwCurrentSafety - Current safety setting.

             ICertificates2 ** ppICertificates - Pointer to pointer
                                                 ICertificates2 object.
  Remark   : 

------------------------------------------------------------------------------*/

static HRESULT FindByCert (HCERTSTORE       hCertStore,
                           DWORD            dwFindType,
                           LPCVOID          pvFindPara,
                           VARIANT_BOOL     bFindValidOnly,
                           PFNCFILTERPROC   pfnFilterCallback,
                           LPVOID           pvCallbackData,
                           DWORD            dwCurrentSafety,
                           ICertificates2 * pICertificates)
{
    HRESULT        hr           = S_OK;
    DWORD          dwWin32Error = 0;
    PCCERT_CONTEXT pCertContext = NULL;

    DebugTrace("Entering FindByCert().\n");

    //
    // Sanity check.
    //
    ATLASSERT(hCertStore);
    ATLASSERT(pICertificates);

    //
    // Find all certificates in the store, matching the find criteria.
    //
    while (pCertContext = ::CertFindCertificateInStore(hCertStore,
                                                       CAPICOM_ASN_ENCODING,
                                                       0,
                                                       dwFindType,
                                                       pvFindPara,
                                                       pCertContext))
    {
        CComPtr<ICertificate2> pICertificate = NULL;

        //
        // Apply filter if available.
        //
        if (pfnFilterCallback && !pfnFilterCallback(pCertContext, NULL, pvCallbackData))
        {
            continue;
        }

        //
        // Skip it if check is required and the cert is not valid.
        //
        if (bFindValidOnly)
        {
            if (FAILED(::VerifyCertificate(pCertContext, NULL, CERT_CHAIN_POLICY_BASE)))
            {
                continue;
            }
        }

        //
        // Create a ICertificate2 object for the found certificate.
        //
        if (FAILED (hr = ::CreateCertificateObject(pCertContext, 
                                                   dwCurrentSafety, 
                                                   &pICertificate)))
        {
            DebugTrace("Error [%#x]: CreateCertificateObject() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Add to collection.
        //
        if (FAILED(hr = pICertificates->Add(pICertificate)))
        {
            DebugTrace("Error [%#x]: pICertificates->Add() failed.\n", hr);
            goto ErrorExit;
        }
    }

    //
    // Above loop can exit with normal or error condition.
    //
    if (CRYPT_E_NOT_FOUND != (dwWin32Error = ::GetLastError()))
    {
        hr = HRESULT_FROM_WIN32(dwWin32Error);

        DebugTrace("Error [%#x]: CertFindCertificateInStore() failed.\n", hr);
        goto ErrorExit;
    }

CommonExit:
    //
    // Free resources.
    //
    if (pCertContext)
    {
        ::CertFreeCertificateContext(pCertContext);
    }

    DebugTrace("Leaving FindByCert().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// CCertificates
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificates::Find

  Synopsis : Find certificates in the collection that match the find criteria.

  Parameter: CAPICOM_CERTIFICATE_FIND_TYPE FindType - Find type (see CAPICOM.H 
                                                      for all possible values.)
  
             VARIANT varCriteria - Data type depends on FindType.

             VARIANT_BOOL bFindValidOnly - True to find valid certs only.

             ICertificates2 ** pVal - Pointer to pointer to ICertificates
                                      to receive the found certificate
                                      collection.                                    

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificates::Find (CAPICOM_CERTIFICATE_FIND_TYPE FindType, 
                                  VARIANT                       varCriteria, 
                                  VARIANT_BOOL                  bFindValidOnly,
                                  ICertificates2             ** pVal)
{
    USES_CONVERSION;

    HRESULT                 hr               = S_OK;
    VARIANT               * pvarCriteria     = NULL;
    BOOL                    bFindByChain     = FALSE;
    HCERTSTORE              hCertStore       = NULL;
    DWORD                   dwFindType       = CERT_FIND_ANY;
    LPVOID                  pvFindPara       = NULL;
    LPVOID                  pvCallbackData   = NULL;
    LPSTR                   pszOid           = NULL;
    SYSTEMTIME              st               = {0};
    FILETIME                ftLocal          = {0};
    FILETIME                ftUTC            = {0};
    CRYPT_HASH_BLOB         HashBlob         = {0, NULL};
    PCCRYPT_OID_INFO        pOidInfo         = NULL;
    PFNCFILTERPROC          pfnCertCallback  = NULL;
    PFNCHAINFILTERPROC      pfnChainCallback = NULL;
    CComPtr<ICertificates2> pICertificates   = NULL;
    CAPICOM_CERTIFICATES_SOURCE ccs = {CAPICOM_CERTIFICATES_LOAD_FROM_STORE, 0};
    CERT_CHAIN_FIND_BY_ISSUER_PARA ChainFindPara;

    DebugTrace("Entering CCertificates::Find().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure parameters are valid.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Skip over BYREF.
        //
        for (pvarCriteria = &varCriteria; 
             pvarCriteria && ((VT_VARIANT | VT_BYREF) == V_VT(pvarCriteria));
             pvarCriteria = V_VARIANTREF(pvarCriteria));

        //
        // Open a new memory store.
        //
        if (NULL == (hCertStore = ::CertOpenStore(CERT_STORE_PROV_MEMORY,
                                                  CAPICOM_ASN_ENCODING,
                                                  NULL,
                                                  CERT_STORE_CREATE_NEW_FLAG | CERT_STORE_ENUM_ARCHIVED_FLAG,
                                                  NULL)))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertOpenStore() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Create a new collection.
        //
        ccs.hCertStore = hCertStore;

        if (FAILED(hr = ::CreateCertificatesObject(ccs, m_dwCurrentSafety, TRUE, &pICertificates)))
        {
            DebugTrace("Error [%#x]: CreateCertificatesObject() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Export current collection to the new memory store so that we can
        // use it with CAPI's find APIs.
        //
        if (FAILED(hr = _ExportToStore(hCertStore)))
        {
            DebugTrace("Error [%#x]: CCertificates::ExportToStore() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Setup find parameters.
        //
        switch (FindType)
        {
            //
            // Find by SHA1 hash.
            //
            case CAPICOM_CERTIFICATE_FIND_SHA1_HASH:
            {
                //
                // Make sure data type is OK.
                //
                if (VT_BSTR != pvarCriteria->vt)
                {
                    if (FAILED(hr = ::VariantChangeType(pvarCriteria, pvarCriteria, 0, VT_BSTR)))
                    {
                        DebugTrace("Error [%#x]: invalid data type %d, expect %d.\n", hr, pvarCriteria->vt, VT_BSTR);
                        goto ErrorExit;
                    }
                }

                //
                // Convert hash to binary.
                //
                if (FAILED(hr = ::StringToBinary(pvarCriteria->bstrVal, 
                                                 ::SysStringLen(pvarCriteria->bstrVal),
                                                 CRYPT_STRING_HEX,
                                                 (PBYTE *) &HashBlob.pbData,
                                                 &HashBlob.cbData)))
                {
                    DebugTrace("Error [%#x]: StringToBinary() failed.\n", hr);
                    goto ErrorExit;
                }

                dwFindType = CERT_FIND_HASH;
                pvFindPara = (LPVOID) &HashBlob;

                break;
            }

            //
            // Find by subject name substring-in-string.
            //
            case CAPICOM_CERTIFICATE_FIND_SUBJECT_NAME:
            {
                //
                // Make sure data type is OK.
                //
                if (VT_BSTR != pvarCriteria->vt)
                {
                    if (FAILED(hr = ::VariantChangeType(pvarCriteria, pvarCriteria, 0, VT_BSTR)))
                    {
                        DebugTrace("Error [%#x]: invalid data type %d, expect %d.\n", hr, pvarCriteria->vt, VT_BSTR);
                        goto ErrorExit;
                    }
                }

                dwFindType = CERT_FIND_SUBJECT_STR;
                pvFindPara = (LPVOID) pvarCriteria->bstrVal;

                break;
            }

            //
            // Find by issuer name substring-in-string.
            //
            case CAPICOM_CERTIFICATE_FIND_ISSUER_NAME:
            {
                //
                // Make sure data type is OK.
                //
                if (VT_BSTR != pvarCriteria->vt)
                {
                    if (FAILED(hr = ::VariantChangeType(pvarCriteria, pvarCriteria, 0, VT_BSTR)))
                    {
                        DebugTrace("Error [%#x]: invalid data type %d, expect %d.\n", hr, pvarCriteria->vt, VT_BSTR);
                        goto ErrorExit;
                    }
                }

                dwFindType = CERT_FIND_ISSUER_STR;
                pvFindPara = (LPVOID) pvarCriteria->bstrVal;

                break;
            }

            //
            // Find by issuer name of root cert subtring-in-string.
            //
            case CAPICOM_CERTIFICATE_FIND_ROOT_NAME:
            {
                //
                // Make sure data type is OK.
                //
                if (VT_BSTR != pvarCriteria->vt)
                {
                    if (FAILED(hr = ::VariantChangeType(pvarCriteria, pvarCriteria, 0, VT_BSTR)))
                    {
                        DebugTrace("Error [%#x]: invalid data type %d, expect %d.\n", hr, pvarCriteria->vt, VT_BSTR);
                        goto ErrorExit;
                    }
                }

                ::ZeroMemory(&ChainFindPara, sizeof(ChainFindPara));
                ChainFindPara.cbSize = sizeof(ChainFindPara);

                dwFindType = CERT_CHAIN_FIND_BY_ISSUER;
                pvFindPara = (LPVOID) &ChainFindPara;
                pfnChainCallback = FindRootNameCallback;
                pvCallbackData = (LPVOID) pvarCriteria->bstrVal;

                bFindByChain = TRUE;

                break;
            }

            //
            // Find by template name or OID.
            //
            case CAPICOM_CERTIFICATE_FIND_TEMPLATE_NAME:
            {
                //
                // Make sure data type is OK.
                //
                if (VT_BSTR != pvarCriteria->vt)
                {
                    if (FAILED(hr = ::VariantChangeType(pvarCriteria, pvarCriteria, 0, VT_BSTR)))
                    {
                        DebugTrace("Error [%#x]: invalid data type %d, expect %d.\n", hr, pvarCriteria->vt, VT_BSTR);
                        goto ErrorExit;
                    }
                }

                pfnCertCallback = FindTemplateCallback;
                pvCallbackData = (LPVOID) pvarCriteria->bstrVal;

                break;
            }

            //
            // Find by extension.
            //
            case CAPICOM_CERTIFICATE_FIND_EXTENSION:
            {
                //
                // Make sure data type is OK.
                //
                if (VT_BSTR != pvarCriteria->vt)
                {
                    if (FAILED(hr = ::VariantChangeType(pvarCriteria, pvarCriteria, 0, VT_BSTR)))
                    {
                        DebugTrace("Error [%#x]: invalid data type %d, expect %d.\n", hr, pvarCriteria->vt, VT_BSTR);
                        goto ErrorExit;
                    }
                }

                //
                // Convert to OID if user passed in friendly name.
                //
                if (pOidInfo = ::CryptFindOIDInfo(CRYPT_OID_INFO_NAME_KEY,
                                                  (LPWSTR) pvarCriteria->bstrVal,
                                                  CRYPT_EXT_OR_ATTR_OID_GROUP_ID))
                {
                    pszOid = (LPSTR) pOidInfo->pszOID;
                }
                else
                {
                    //
                    // Convert to ASCII.
                    //
                    if (!(pszOid = W2A(pvarCriteria->bstrVal)))
                    {
                        hr = E_OUTOFMEMORY;

                        DebugTrace("Error [%%#x]: pszOid = W2A(pvarCriteria->bstrVal) failed.\n", hr);
                        goto ErrorExit;
                    }
                }

                pfnCertCallback = FindExtensionCallback;
                pvCallbackData = (LPVOID) pszOid;

                break;
            }

            //
            // Find by property ID.
            //
            case CAPICOM_CERTIFICATE_FIND_EXTENDED_PROPERTY:
            {
                //
                // Make sure data type is OK.
                //
                if (VT_I4 != pvarCriteria->vt)
                {
                    if (FAILED(hr = ::VariantChangeType(pvarCriteria, pvarCriteria, 0, VT_I4)))
                    {
                        DebugTrace("Error [%#x]: invalid data type %d, expect %d.\n", hr, pvarCriteria->vt, VT_I4);
                        goto ErrorExit;
                    }
                }

                dwFindType = CERT_FIND_PROPERTY;
                pvFindPara = (LPVOID) &pvarCriteria->lVal;

                break;
            }

            //
            // Find by application policy (EKU).
            //
            case CAPICOM_CERTIFICATE_FIND_APPLICATION_POLICY:
            {
                //
                // Make sure data type is OK.
                //
                if (VT_BSTR != pvarCriteria->vt)
                {
                    if (FAILED(hr = ::VariantChangeType(pvarCriteria, pvarCriteria, 0, VT_BSTR)))
                    {
                        DebugTrace("Error [%#x]: invalid data type %d, expect %d.\n", hr, pvarCriteria->vt, VT_BSTR);
                        goto ErrorExit;
                    }
                }

                //
                // Try to convert to OID if user passed in friendly name.
                //
                if (pOidInfo = ::CryptFindOIDInfo(CRYPT_OID_INFO_NAME_KEY,
                                                  (LPWSTR) pvarCriteria->bstrVal,
                                                  CRYPT_ENHKEY_USAGE_OID_GROUP_ID))
                {
                    pszOid = (LPSTR) pOidInfo->pszOID;
                }
                else
                {
                    //
                    // Convert to ASCII.
                    //
                    if (!(pszOid = W2A(pvarCriteria->bstrVal)))
                    {
                        hr = E_OUTOFMEMORY;

                        DebugTrace("Error [%#X]: pszOid = W2A(pvarCriteria->bstrVal) failed.\n", hr);
                        goto ErrorExit;
                    }
                }

                pfnCertCallback = FindApplicationPolicyCallback;
                pvCallbackData = (LPVOID) pszOid;

                break;
            }

            //
            // Find by certificate policy.
            //
            case CAPICOM_CERTIFICATE_FIND_CERTIFICATE_POLICY:
            {
                //
                // Make sure data type is OK.
                //
                if (VT_BSTR != pvarCriteria->vt)
                {
                    if (FAILED(hr = ::VariantChangeType(pvarCriteria, pvarCriteria, 0, VT_BSTR)))
                    {
                        DebugTrace("Error [%#x]: invalid data type %d, expect %d.\n", hr, pvarCriteria->vt, VT_BSTR);
                        goto ErrorExit;
                    }
                }

                //
                // Convert to OID if user passed in friendly name.
                //
                if (pOidInfo = ::CryptFindOIDInfo(CRYPT_OID_INFO_NAME_KEY,
                                                  (LPWSTR) pvarCriteria->bstrVal,
                                                  CRYPT_POLICY_OID_GROUP_ID))
                {
                    pszOid = (LPSTR) pOidInfo->pszOID;
                }
                else
                {
                    //
                    // Convert to ASCII.
                    //
                    if (!(pszOid = W2A(pvarCriteria->bstrVal)))
                    {
                        hr = E_OUTOFMEMORY;

                        DebugTrace("Error [%#x]: pszOid = W2A(pvarCriteria->bstrVal) failed.\n", hr);
                        goto ErrorExit;
                    }
                }

                pfnCertCallback = FindCertificatePolicyCallback;
                pvCallbackData = (LPVOID) pszOid;

                break;
            }

            //
            // Find by time valid.
            //
            case CAPICOM_CERTIFICATE_FIND_TIME_VALID:
            {
                //
                // !!! Warning, falling thru. !!!
                //
            }

            //
            // Find by notBefore time validity.
            //
            case CAPICOM_CERTIFICATE_FIND_TIME_NOT_YET_VALID:
            {
                //
                // !!! Warning, falling thru. !!!
                //
            }

            // Find by notAfter time validity.
            //
            case CAPICOM_CERTIFICATE_FIND_TIME_EXPIRED:
            {
                //
                // Make sure data type is OK.
                //
                if (VT_DATE != pvarCriteria->vt)
                {
                    if (FAILED(hr = ::VariantChangeType(pvarCriteria, pvarCriteria, 0, VT_DATE)))
                    {
                        DebugTrace("Error [%#x]: invalid data type %d, expect %d.\n", hr, pvarCriteria->vt, VT_DATE);
                        goto ErrorExit;
                    }
                }

                //
                // Convert to SYSTEMTIME format.
                //
                if (0 == pvarCriteria->date)
                {
                    ::GetLocalTime(&st);
                }
                else if (!::VariantTimeToSystemTime(pvarCriteria->date, &st))
                {
                    hr = E_INVALIDARG;

                    DebugTrace("Error [%#x]: VariantTimeToSystemTime() failed.\n", hr);
                    goto ErrorExit;
                }

                //
                // Convert to FILETIME format.
                //
                if (!::SystemTimeToFileTime(&st, &ftLocal))
                {
                    hr = HRESULT_FROM_WIN32(::GetLastError());

                    DebugTrace("Error [%#x]: SystemTimeToFileTime() failed.\n", hr);
                    goto ErrorExit;
                }

                //
                // Convert to UTC FILETIME.
                //
                if (!::LocalFileTimeToFileTime(&ftLocal, &ftUTC))
                {
                    hr = HRESULT_FROM_WIN32(::GetLastError());

                    DebugTrace("Error [%#x]: LocalFileTimeToFileTime() failed.\n", hr);
                    goto ErrorExit;
                }

                if (CAPICOM_CERTIFICATE_FIND_TIME_VALID == FindType)
                {
                    pfnCertCallback = FindTimeValidCallback;
                }
                else if (CAPICOM_CERTIFICATE_FIND_TIME_NOT_YET_VALID == FindType)
                {
                    pfnCertCallback = FindNotBeforeCallback;
                }
                else
                {
                    pfnCertCallback = FindNotAfterCallback;
                }
                pvCallbackData = (LPVOID) &ftUTC;

                break;
            }

            //
            // Find by key usage.
            //
            case CAPICOM_CERTIFICATE_FIND_KEY_USAGE:
            {
                //
                // By Key Usage bit flag?
                //
                if (VT_I4 != pvarCriteria->vt)
                {
                    //
                    // By key usage friendly's name?
                    //
                    if (VT_BSTR == pvarCriteria->vt)
                    {
                        typedef struct _KeyUsagesStruct
                        {
                            LPWSTR pwszKeyUsage;
                            DWORD  dwKeyUsageBit;
                        } KEY_USAGE_STRUCT;

                        KEY_USAGE_STRUCT KeyUsages[] = 
                            { {L"DigitalSignature",  CERT_DIGITAL_SIGNATURE_KEY_USAGE}, 
                              {L"NonRepudiation",    CERT_NON_REPUDIATION_KEY_USAGE},
                              {L"KeyEncipherment",   CERT_KEY_ENCIPHERMENT_KEY_USAGE},
                              {L"DataEncipherment",  CERT_DATA_ENCIPHERMENT_KEY_USAGE},
                              {L"KeyAgreement",      CERT_KEY_AGREEMENT_KEY_USAGE},
                              {L"KeyCertSign",       CERT_KEY_CERT_SIGN_KEY_USAGE},
                              {L"CRLSign",           CERT_CRL_SIGN_KEY_USAGE},
                              {L"EncipherOnly",      CERT_ENCIPHER_ONLY_KEY_USAGE},
                              {L"DecipherOnly",      CERT_DECIPHER_ONLY_KEY_USAGE}
                            };

                        //
                        // Find the name.
                        //
                        for (DWORD i = 0; i < ARRAYSIZE(KeyUsages); i++)
                        {
                            if (0 == _wcsicmp(KeyUsages[i].pwszKeyUsage, (LPWSTR) pvarCriteria->bstrVal))
                            {
                                break;
                            }
                        }

                        if (i == ARRAYSIZE(KeyUsages))
                        {
                            hr = E_INVALIDARG;

                            DebugTrace("Error [%#x]: Unknown key usage (%ls).\n", hr, (LPWSTR) pvarCriteria->bstrVal);
                            goto ErrorExit;
                        }

                        //
                        // Convert to bit flag.
                        //
                        ::VariantClear(pvarCriteria);
                        pvarCriteria->vt = VT_I4;
                        pvarCriteria->lVal = KeyUsages[i].dwKeyUsageBit;
                    }
                    else 
                    {
                        if (FAILED(hr = ::VariantChangeType(pvarCriteria, pvarCriteria, 0, VT_I4)))
                        {
                            DebugTrace("Error [%#x]: invalid data type %d, expect %d.\n", hr, pvarCriteria->vt, VT_I4);
                            goto ErrorExit;
                        }
                    }
                }

                pfnCertCallback = FindKeyUsageCallback;
                pvCallbackData = (LPVOID) &pvarCriteria->lVal;

                break;
            }

            default:
            {
                hr = CAPICOM_E_FIND_INVALID_TYPE;

                DebugTrace("Error [%#x]: invalid CAPICOM_CERTIFICATE_FIND_TYPE (%d).\n", hr, FindType);
                goto ErrorExit;
            }
        }

        //
        // Now find the certs.
        //
        if (bFindByChain)
        {
            if (FAILED(hr = ::FindByChain(hCertStore,
                                          dwFindType,
                                          pvFindPara,
                                          bFindValidOnly,
                                          pfnChainCallback,
                                          pvCallbackData,
                                          m_dwCurrentSafety,
                                          pICertificates)))
            {
                DebugTrace("Error [%#x]: FindByChain() failed.\n", hr);
                goto ErrorExit;
            }
        }
        else
        {
            if (FAILED(hr = ::FindByCert(hCertStore,
                                         dwFindType,
                                         pvFindPara,
                                         bFindValidOnly,
                                         pfnCertCallback,
                                         pvCallbackData,
                                         m_dwCurrentSafety,
                                         pICertificates)))
            {
                DebugTrace("Error [%#x]: FindByCert() failed.\n", hr);
                goto ErrorExit;
            }
        }

        //
        // Return collection to caller.
        //
        if (FAILED(hr = pICertificates->QueryInterface(pVal)))
        {
            DebugTrace("Unexpected error [%#x]: pICertificates->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free reources.
    //
    if (HashBlob.pbData)
    {
        ::CoTaskMemFree((LPVOID) HashBlob.pbData);
    }
    if (hCertStore)
    {
        ::CertCloseStore(hCertStore, 0);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificates::Find().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificates::Select

  Synopsis : Display the certificate selection dialog box.

  Parameter: BSTR Title - Dialog box title.

             BSTR DisplayString - Display string.

             VARIANT_BOOL bMultiSelect - True for multi-select.

             ICertificates2 ** pVal - Pointer to pointer to ICertificates
                                      to receive the select certificate
                                      collection.                                    

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificates::Select (BSTR              Title,
                                    BSTR              DisplayString,
                                    VARIANT_BOOL      bMultiSelect,
                                    ICertificates2 ** pVal)
{
    HRESULT                 hr             = S_OK;
    HCERTSTORE              hSrcStore      = NULL;
    HCERTSTORE              hDstStore      = NULL;
    PCCERT_CONTEXT          pCertContext   = NULL;
    CComPtr<ICertificates2> pICertificates = NULL;

    CAPICOM_CERTIFICATES_SOURCE ccs = {0, NULL};

    DebugTrace("Entering CCertificates::Select().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure parameters are valid.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure we are allowed to pop UI.
        //
        if (!PromptForCertificateEnabled())
        {
            hr = CAPICOM_E_UI_DISABLED;

            DebugTrace("Error [%#x]: UI is disabled.\n", hr);
            goto ErrorExit;
        }

        //
        // Work aroung MIDL default BSTR problem.
        //
        if (0 == ::SysStringLen(Title))
        {
            Title = NULL;
        }
        if (0 == ::SysStringLen(DisplayString))
        {
            DisplayString = NULL;
        }

        //
        // Open a new memory source store.
        //
        if (NULL == (hSrcStore = ::CertOpenStore(CERT_STORE_PROV_MEMORY,
                                                 CAPICOM_ASN_ENCODING,
                                                 NULL,
                                                 CERT_STORE_CREATE_NEW_FLAG,
                                                 NULL)))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertOpenStore() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Export collections to the new memory source store.
        //
        if (FAILED(hr = _ExportToStore(hSrcStore)))
        {
            DebugTrace("Error [%#x]: CCertificates::_ExportToStore() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Open a new memory destination store for multi-select.
        //
        if (bMultiSelect)
        {
            if (!(hDstStore = ::CertOpenStore(CERT_STORE_PROV_MEMORY,
                                              CAPICOM_ASN_ENCODING,
                                              NULL,
                                              CERT_STORE_CREATE_NEW_FLAG,
                                              NULL)))
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());

                DebugTrace("Error [%#x]: CertOpenStore() failed.\n", hr);
                goto ErrorExit;
            }
        }

        //
        // Display the cert selection dialog box.
        //
        if (FAILED(hr = ::SelectCertificateContext(hSrcStore,
                                                   Title,
                                                   DisplayString,
                                                   (BOOL) bMultiSelect,
                                                   NULL,
                                                   hDstStore,
                                                   &pCertContext)))
        {
            DebugTrace("Error [%#x]: SelectCertificateContext() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Create the collection object.
        //
        if (bMultiSelect)
        {
            //
            // Create a new collection from the destination store.
            //
            ccs.dwSource = CAPICOM_CERTIFICATES_LOAD_FROM_STORE;
            ccs.hCertStore = hDstStore;
        }
        else
        {
            //
            // Create a new collection from the cert context.
            //
            ccs.dwSource = CAPICOM_CERTIFICATES_LOAD_FROM_CERT;
            ccs.pCertContext = pCertContext;
        }

        if (FAILED(hr = ::CreateCertificatesObject(ccs, m_dwCurrentSafety, TRUE, &pICertificates)))
        {
            DebugTrace("Error [%#x]: CreateCertificatesObject() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return collection to caller.
        //
        if (FAILED(hr = pICertificates->QueryInterface(pVal)))
        {
            DebugTrace("Unexpected error [%#x]: pICertificates->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free reources.
    //
    if (pCertContext)
    {
        ::CertFreeCertificateContext(pCertContext);
    }
    if (hDstStore)
    {
        ::CertCloseStore(hDstStore, 0);
    }
    if (hSrcStore)
    {
        ::CertCloseStore(hSrcStore, 0);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificates::Select().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificates::Add

  Synopsis : Add a Certificate2 to the collection.

  Parameter: ICertificate2 * pVal - Certificate2 to be added.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificates::Add (ICertificate2 * pVal)
{
    HRESULT  hr = S_OK;
    char     szIndex[33];
    CComBSTR bstrIndex;

    DebugTrace("Entering CCertificates::Add().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure parameters are valid.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: pVal is NULL.\n", hr);
            goto ErrorExit;
        }

#if (0)
        CComPtr<ICertificate2> pICertificate = NULL;

        //
        // Make sure we have a valid Certificate.
        //
        if (FAILED(hr = pVal->QueryInterface(__uuidof(ICertificate2), (void **) &pICertificate.p)))
        {
            hr = E_NOINTERFACE;

            DebugTrace("Error [%#x]: pVal is not an Certificate object.\n", hr);
            goto ErrorExit;
        }
#endif

        DebugTrace("Info: m_dwNextIndex = %#x, m_coll.max_size() = %#x.\n", 
                    m_dwNextIndex, m_coll.max_size());

        //
        // If index by number, and the index exceeds our max, then we will
        // force it to be indexed by thumbprint.
        //
        if ((m_bIndexedByThumbprint) || ((m_dwNextIndex + 1) > m_coll.max_size()))
        {
            if (FAILED(hr = pVal->get_Thumbprint(&bstrIndex)))
            {
                DebugTrace("Error [%#x]: pVal->get_Thumbprint() failed.\n", hr);
                goto ErrorExit;
            }

            m_bIndexedByThumbprint = TRUE;
        }
        else
        {
            //
            // BSTR index of numeric value.
            //
            wsprintfA(szIndex, "%#08x", ++m_dwNextIndex);

            if (!(bstrIndex = szIndex))
            {
                hr = E_OUTOFMEMORY;

                DebugTrace("Error [%#x]: bstrIndex = szIndex failed.\n", hr);
                goto ErrorExit;
            }
        }

        //
        // Now add object to collection map.
        //
        // Note that the overloaded = operator for CComPtr will
        // automatically AddRef to the object. Also, when the CComPtr
        // is deleted (happens when the Remove or map destructor is called), 
        // the CComPtr destructor will automatically Release the object.
        //
        m_coll[bstrIndex] = pVal;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificates::Add().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificates::Remove

  Synopsis : Remove a Certificate2 from the collection.

  Parameter: VARIANT Index - Can be numeric index (1-based), SHA1 string, or 
                             Certificate object.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificates::Remove (VARIANT Index)
{
    HRESULT   hr        = S_OK;
    VARIANT * pvarIndex = NULL;
    CComBSTR  bstrIndex;
    CertificateMap::iterator iter;
    CComPtr<ICertificate2> pICertificate;

    DebugTrace("Entering CCertificates::Remove().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Skip over BYREF.
        //
        for (pvarIndex = &Index; 
             pvarIndex && ((VT_VARIANT | VT_BYREF) == V_VT(pvarIndex));
             pvarIndex = V_VARIANTREF(pvarIndex));

        //
        // Which form of index?
        //
        switch (pvarIndex->vt)
        {
            case VT_DISPATCH:
            {
                //
                // Get the thumbprint;
                //
                if (FAILED(hr = pvarIndex->pdispVal->QueryInterface(IID_ICertificate2, (void **) &pICertificate)))
                {
                    DebugTrace("Error [%#x]: pvarIndex->pdispVal->QueryInterface() failed.\n", hr);
                    goto ErrorExit;
                }

                if (FAILED(hr = pICertificate->get_Thumbprint(&bstrIndex)))
                {
                    DebugTrace("Error [%#x]: pICertificate->get_Thumbprint() failed.\n", hr);
                    goto ErrorExit;
                }

                //
                // !!! WARNING. Falling thru !!!
                //
            }

            case VT_BSTR:
            {
                //
                // Because we could have felt thru, so need to check again.
                //
                if (VT_BSTR == pvarIndex->vt)
                {
                    bstrIndex = pvarIndex->bstrVal;
                }

                //
                // Find the cert matching this thumbprint.
                //
                for (iter = m_coll.begin(); iter != m_coll.end(); iter++)
                {
                    CComBSTR bstrThumbprint;

                    //
                    // Point to the object.
                    //
                    pICertificate = (*iter).second;

                    //
                    // Get the thumbprint;
                    //
                    if (FAILED(hr = pICertificate->get_Thumbprint(&bstrThumbprint)))
                    {
                        DebugTrace("Error [%#x]: pICertificate->get_Thumbprint() failed.\n", hr);
                        goto ErrorExit;
                    }

                    //
                    // Same thumbprint?
                    //
                    if (0 == ::_wcsicmp(bstrThumbprint, bstrIndex))
                    {
                        break;
                    }
                }

                //
                // Did we find in the map?
                //
                if (iter == m_coll.end())
                {
                    hr = E_INVALIDARG;

                    DebugTrace("Error [%#x]: Requested certificate (sha1 = %ls) is not found in the collection.\n", 
                                hr, bstrIndex);
                    goto ErrorExit;
                }

                //
                // Now remove from map.
                //
                m_coll.erase(iter);

                break;
            }

            default:
            {
                DWORD dwIndex;

                //
                // Assume numeric index.
                //
                if (VT_I4 != pvarIndex->vt &&
                    FAILED(hr = ::VariantChangeType(pvarIndex, pvarIndex, 0, VT_I4)))
                {
                    DebugTrace("Error [%#x]: VariantChangeType() failed.\n", hr);
                    goto ErrorExit;
                }

                //
                // Make sure index is valid.
                //
                dwIndex = (DWORD) pvarIndex->lVal;

                if (dwIndex < 1 || dwIndex > m_coll.size())
                {
                    hr = E_INVALIDARG;

                    DebugTrace("Error [%#x]: Index %d is out of range.\n", hr, dwIndex);
                    goto ErrorExit;
                }

                //
                // Find object in map.
                //
                dwIndex--;
                iter = m_coll.begin(); 
        
                while (iter != m_coll.end() && dwIndex > 0)
                {
                     iter++; 
                     dwIndex--;
                }

                //
                // Did we find in the map?
                //
                if (iter == m_coll.end())
                {
                    hr = E_INVALIDARG;

                    DebugTrace("Error [%#x]: Requested certificate (Index = %d) is not found in the collection.\n", 
                                hr, dwIndex);
                    goto ErrorExit;
                }

                //
                // Now remove from map.
                //
                m_coll.erase(iter);

                break;
            }
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificates::Remove().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificates::Clear

  Synopsis : Remove all Certificate2 from the collection.

  Parameter: None.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificates::Clear (void)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CCertificates::Clear().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Clear it.
        //
        m_coll.clear();

        //
        // Sanity check.
        //
        ATLASSERT(0 == m_coll.size());
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificates::Clear().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificates::Save

  Synopsis : Method to save certificate collection to a file.

  Parameter: BSTR FileName - File name.

             BSTR Password - Password (required for PFX file.).

             CAPICOM_CERTIFICATES_SAVE_AS_TYPE SaveAs - SaveAs type.

             CAPICOM_EXPORT_FLAG ExportFlag - Export flags.


  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificates::Save (BSTR                              FileName,
                                  BSTR                              Password,
                                  CAPICOM_CERTIFICATES_SAVE_AS_TYPE SaveAs,
                                  CAPICOM_EXPORT_FLAG               ExportFlag)
{
    HRESULT     hr         = S_OK;
    HCERTSTORE  hCertStore = NULL;

    DebugTrace("Entering CCertificates::Save().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Not allowed if called from WEB script.
        //
        if (m_dwCurrentSafety)
        {
            hr = CAPICOM_E_NOT_ALLOWED;

            DebugTrace("Error [%#x]: Saving cert file from WEB script is not allowed.\n", hr);
            goto ErrorExit;
        }

        //
        // Check parameters.
        //
        if (0 == ::SysStringLen(FileName))
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter FileName is NULL or empty.\n", hr);
            goto ErrorExit;
        }

        //
        // Work around MIDL problem.
        //
        if (0 == ::SysStringLen(Password))
        {
            Password = NULL;
        }

        //
        // Open a new memory store.
        //
        if (NULL == (hCertStore = ::CertOpenStore(CERT_STORE_PROV_MEMORY,
                                                  CAPICOM_ASN_ENCODING,
                                                  NULL,
                                                  CERT_STORE_CREATE_NEW_FLAG | CERT_STORE_ENUM_ARCHIVED_FLAG,
                                                  NULL)))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertOpenStore() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Export current collection to the new memory store so that we can
        // use it with CAPI's store save APIs.
        //
        if (FAILED(hr = _ExportToStore(hCertStore)))
        {
            DebugTrace("Error [%#x]: CCertificates::ExportToStore() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Check file type.
        //
        switch (SaveAs)
        {
            case CAPICOM_CERTIFICATES_SAVE_AS_PFX:
            {
                //
                // Save as PFX file.
                //
                if (FAILED(hr = ::PFXSaveStore(hCertStore, 
                                               FileName, 
                                               Password, 
                                               EXPORT_PRIVATE_KEYS | 
                                               (ExportFlag & CAPICOM_EXPORT_IGNORE_PRIVATE_KEY_NOT_EXPORTABLE_ERROR ? 0 : REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY))))
                {
                    DebugTrace("Error [%#x]: PFXSaveStore() failed.\n", hr);
                    goto ErrorExit;
                }

                break;
            }

            case CAPICOM_CERTIFICATES_SAVE_AS_SERIALIZED:
            {
                //
                // Save as serialized store file.
                //
                if (!::CertSaveStore(hCertStore,
                                     0,
                                     CERT_STORE_SAVE_AS_STORE,
                                     CERT_STORE_SAVE_TO_FILENAME_W,
                                     (void *) FileName,
                                     0))
                {
                    hr = HRESULT_FROM_WIN32(::GetLastError());

                    DebugTrace("Error [%#x]: CertSaveStore() failed.\n", hr);
                    goto ErrorExit;
                }
  
                break;
            }

            case CAPICOM_CERTIFICATES_SAVE_AS_PKCS7:
            {
                //
                // Save as PKCS 7 file.
                //
                if (!::CertSaveStore(hCertStore,
                                     CAPICOM_ASN_ENCODING,
                                     CERT_STORE_SAVE_AS_PKCS7,
                                     CERT_STORE_SAVE_TO_FILENAME_W,
                                     (void *) FileName,
                                     0))
                {
                    hr = HRESULT_FROM_WIN32(::GetLastError());

                    DebugTrace("Error [%#x]: CertSaveStore() failed.\n", hr);
                    goto ErrorExit;
                }
  
                break;
            }

            default:
            {
                hr = E_INVALIDARG;

                DebugTrace("Error [%#x]: Unknown save as type (%#x).\n", hr, SaveAs);
                goto ErrorExit;
            }
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resources.
    //
    if (hCertStore)
    {
        ::CertCloseStore(hCertStore, 0);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificates::Save().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// Non COM functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificates::AddContext

  Synopsis : Add a cert to the collection.

  Parameter: PCCERT_CONTEXT pCertContext - Cert to be added.

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CCertificates::AddContext (PCCERT_CONTEXT pCertContext)
{
    HRESULT  hr = S_OK;
    CComPtr<ICertificate2> pICertificate = NULL;

    DebugTrace("Entering CCertificates::AddContext().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);

    try
    {
        //
        // Create the ICertificate object from CERT_CONTEXT.
        //
        if (FAILED(hr = ::CreateCertificateObject(pCertContext, 
                                                  m_dwCurrentSafety,
                                                  &pICertificate)))
        {
            DebugTrace("Error [%#x]: CreateCertificateObject() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Add to collection.
        //
        if (FAILED(hr = Add(pICertificate)))
        {
            DebugTrace("Error [%#x]: CCertificates::Add() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CCertificates::AddContext().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::LoadFromCert

  Synopsis : Load from the single certificate context.

  Parameter: PCCERT_CONTEXT pContext - Pointer to a cert context.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificates::LoadFromCert (PCCERT_CONTEXT pCertContext)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CCertificates::LoadFromCert().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);

    //
    // Add the cert.
    //
    if (FAILED(hr = AddContext(pCertContext)))
    {
        DebugTrace("Error [%#x]: CCertificates::AddContext() failed.\n", hr);
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CCertificates::LoadFromCert().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    m_coll.clear();

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificate::LoadFromChain

  Synopsis : Load all certificates from a chain.

  Parameter: PCCERT_CHAIN_CONTEXT pChainContext - Pointer to a chain context.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificates::LoadFromChain (PCCERT_CHAIN_CONTEXT pChainContext)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CCertificates::LoadFromChain().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pChainContext);

    //
    // Process only the simple chain.
    //
    PCERT_SIMPLE_CHAIN pSimpleChain = *pChainContext->rgpChain;

    //
    // Now loop through all certs in the chain.
    //
    for (DWORD i = 0; i < pSimpleChain->cElement; i++)
    {
        //
        // Add the cert.
        //
        if (FAILED(hr = AddContext(pSimpleChain->rgpElement[i]->pCertContext)))
        {
            DebugTrace("Error [%#x]: CCertificates::AddContext() failed.\n", hr);
            goto ErrorExit;
        }
    }

CommonExit:

    DebugTrace("Leaving CCertificates::LoadFromChain().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    m_coll.clear();

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificates::LoadFromStore

  Synopsis : Load all certificates from a store.

  Parameter: HCERTSTORE hCertStore - Store where all certificates are to be
                                     loaded from.

  Remark   :
  
------------------------------------------------------------------------------*/

STDMETHODIMP CCertificates::LoadFromStore (HCERTSTORE hCertStore)
{
    HRESULT hr = S_OK;
    PCCERT_CONTEXT pCertContext = NULL;

    DebugTrace("Entering CCertificates::LoadFromStore().\n");

    //
    // Sanity check.
    //
    ATLASSERT(hCertStore);

    //
    // Now transfer all certificates from the store to the collection map.
    //
    while (pCertContext = ::CertEnumCertificatesInStore(hCertStore, pCertContext))
    {
        //
        // Add the cert.
        //
        if (FAILED(hr = AddContext(pCertContext)))
        {
            DebugTrace("Error [%#x]: CCertificates::AddContext() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Don'f free cert context here, as CertEnumCertificatesInStore()
        // will do that automatically!!!
        //
    }

    //
    // Above loop can exit either because there is no more certificate in
    // the store or an error. Need to check last error to be certain.
    //
    if (CRYPT_E_NOT_FOUND != ::GetLastError())
    {
       hr = HRESULT_FROM_WIN32(::GetLastError());
       
       DebugTrace("Error [%#x]: CertEnumCertificatesInStore() failed.\n", hr);
       goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CCertificates::LoadFromStore().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (pCertContext)
    {
        ::CertFreeCertificateContext(pCertContext);
    }

    if (FAILED(hr))
    {
       m_coll.clear();
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificates::LoadFromMessage

  Synopsis : Load all certificates from a message.

  Parameter: HCRYPTMSG hMsg - Message handle.

  Remark   :
  
------------------------------------------------------------------------------*/

STDMETHODIMP CCertificates::LoadFromMessage (HCRYPTMSG hMsg)
{
    HRESULT hr          = S_OK;
    DWORD   dwCertCount = 0;
    DWORD   cbCertCount = sizeof(dwCertCount);

    DebugTrace("Entering CCertificates::LoadFromMessage().\n");

    //
    // Sanity check.
    //
    ATLASSERT(hMsg);

    //
    // Get number of certs in message.
    //
    if (!::CryptMsgGetParam(hMsg, 
                            CMSG_CERT_COUNT_PARAM,
                            0,
                            (void **) &dwCertCount,
                            &cbCertCount))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptMsgGetParam() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Loop thru all certs in the message.
    //
    while (dwCertCount--)
    {
        PCCERT_CONTEXT pCertContext = NULL;
        CRYPT_DATA_BLOB EncodedCertBlob = {0, NULL};

        //
        // Get a cert from the bag of certs.
        //
        if (FAILED(hr = ::GetMsgParam(hMsg, 
                                      CMSG_CERT_PARAM,
                                      dwCertCount,
                                      (void **) &EncodedCertBlob.pbData,
                                      &EncodedCertBlob.cbData)))
        {
            DebugTrace("Error [%#x]: GetMsgParam() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Create a context for the cert.
        //
        pCertContext = ::CertCreateCertificateContext(CAPICOM_ASN_ENCODING,
                                                      (const PBYTE) EncodedCertBlob.pbData,
                                                      EncodedCertBlob.cbData);

        //
        // Free encoded cert blob memory before checking result.
        //
        ::CoTaskMemFree((LPVOID) EncodedCertBlob.pbData);
 
        if (!pCertContext)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertCreateCertificateContext() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Add the cert.
        //
        hr = AddContext(pCertContext);

        //
        // Free cert context before checking result.
        //
        ::CertFreeCertificateContext(pCertContext);

        if (FAILED(hr))
        {
            DebugTrace("Error [%#x]: CCertificates::AddContext() failed.\n", hr);
            goto ErrorExit;
        }
    }

CommonExit:

    DebugTrace("Leaving CCertificates::LoadFromMessage().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    m_coll.clear();

    goto CommonExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// Custom interfaces.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificates::_ExportToStore

  Synopsis : Export all certificates in the collection to a specified store.

  Parameter: HCERTSTORE hCertStore - HCERSTORE to copy to.

  Remark   :
  
------------------------------------------------------------------------------*/

STDMETHODIMP CCertificates::_ExportToStore (HCERTSTORE hCertStore)
{
    HRESULT hr = S_OK;
    CertificateMap::iterator iter;

    DebugTrace("Entering CCertificates::_ExportToStore().\n");

    //
    // Sanity check.
    //
    ATLASSERT(hCertStore);
    
    //
    // Now, transfer all the certs in the collection to the store.
    //
    for (iter = m_coll.begin(); iter != m_coll.end(); iter++)
    {
        PCCERT_CONTEXT pCertContext = NULL;
        CComPtr<ICertificate> pICertificate = NULL;

        //
        // Get to the stored interface pointer.
        //
        if (!(pICertificate = (*iter).second))
        {
            hr = CAPICOM_E_INTERNAL;

            DebugTrace("Error [%#x]: iterator returns NULL pICertificate pointer.\n", hr);
            goto ErrorExit;
        }

        //
        // Get the CERT_CONTEXT.
        //
        if (FAILED(hr = ::GetCertContext(pICertificate, &pCertContext)))
        {
            DebugTrace("Error [%#x]: pICertificate->GetContext() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Add the link to store.
        //
        BOOL bResult = ::CertAddCertificateContextToStore(hCertStore, 
                                                          pCertContext, 
                                                          CERT_STORE_ADD_ALWAYS, 
                                                          NULL);
        //
        // First free cert context.
        //
        ::CertFreeCertificateContext(pCertContext);

        //
        // then check result.
        //
        if (!bResult)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertAddCertificateContextToStore() failed.\n", hr);
            goto ErrorExit;
        }
    }

CommonExit:

    DebugTrace("Leaving CCertificates::_ExportToStore().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificates::Init

  Synopsis : Initialize the object.

  Parameter: CAPICOM_CERTIFICATES_SOURCE ccs - Source where to get the 
                                               certificates.

             DWORD dwCurrentSafety - Current safety setting.
  
             BOOL bIndexedByThumbprint - TRUE to index by thumbprint.

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CCertificates::Init (CAPICOM_CERTIFICATES_SOURCE ccs, 
                                  DWORD                       dwCurrentSafety,
                                  BOOL                        bIndexedByThumbprint)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CCertificates::Init().\n");

    //
    // Set safety setting.
    //
    m_dwCurrentSafety = dwCurrentSafety;
    m_dwNextIndex = 0;
#if (1) // DSIE: Can turn on index by thumbprint if desired.
    m_bIndexedByThumbprint = FALSE;
#else
    m_bIndexedByThumbprint = bIndexedByThumbprint;
#endif

    //
    // Initialize object.
    //
    switch (ccs.dwSource)
    {
        case CAPICOM_CERTIFICATES_LOAD_FROM_CERT:
        {
            //
            // Sanity check.
            //
            ATLASSERT(ccs.pCertContext);

            if (FAILED(hr = LoadFromCert(ccs.pCertContext)))
            {
                DebugTrace("Error [%#x]: CCertificates::LoadFromCert() failed.\n", hr);
                goto ErrorExit;
            }
            break;
        }

        case CAPICOM_CERTIFICATES_LOAD_FROM_CHAIN:
        {
            //
            // Sanity check.
            //
            ATLASSERT(ccs.pChainContext);

            if (FAILED(hr = LoadFromChain(ccs.pChainContext)))
            {
                DebugTrace("Error [%#x]: CCertificates::LoadFromChain() failed.\n", hr);
                goto ErrorExit;
            }
            break;
        }

        case CAPICOM_CERTIFICATES_LOAD_FROM_STORE:
        {
            //
            // Sanity check.
            //
            ATLASSERT(ccs.hCertStore);

            if (FAILED(hr = LoadFromStore(ccs.hCertStore)))
            {
                DebugTrace("Error [%#x]: CCertificates::LoadFromStore() failed.\n", hr);
                goto ErrorExit;
            }
            break;
        }

        case CAPICOM_CERTIFICATES_LOAD_FROM_MESSAGE:
        {
            //
            // Sanity check.
            //
            ATLASSERT(ccs.hCryptMsg);

            if (FAILED(hr = LoadFromMessage(ccs.hCryptMsg)))
            {
                DebugTrace("Error [%#x]: CCertificates::LoadFromMessage() failed.\n", hr);
                goto ErrorExit;
            }
            break;
        }

        default:
        {
            //
            // We have a bug.
            //
            ATLASSERT(FALSE);

            hr = CAPICOM_E_INTERNAL;

            DebugTrace("Error [%#x]: Unknown store source (ccs.dwSource = %d).\n", hr, ccs.dwSource);
            goto ErrorExit;
        }
    }

CommonExit:

    DebugTrace("Leaving CCertificates::Init().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\certificates.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Certificates.h

  Content: Declaration of CCertificates.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#ifndef __CERTIFICATES_H_
#define __CERTIFICATES_H_

#include "Resource.h"
#include "Error.h"
#include "Lock.h"
#include "Debug.h"
#include "CopyItem.h"
#include "Certificate.h"

////////////////////
//
// Locals
//

//
// typdefs to make life easier.
//
typedef std::map<CComBSTR, CComPtr<ICertificate2> > CertificateMap;
typedef CComEnumOnSTL<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _CopyMapItem<ICertificate2>, CertificateMap> CertificateEnum;
typedef ICollectionOnSTLImpl<ICertificates2, CertificateMap, VARIANT, _CopyMapItem<ICertificate2>, CertificateEnum> ICertificatesCollection;


////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

typedef struct _CapicomCertificatesSource
{
    DWORD dwSource;
    union
    {
        PCCERT_CONTEXT       pCertContext;
        PCCERT_CHAIN_CONTEXT pChainContext;
        HCERTSTORE           hCertStore;
        HCRYPTMSG            hCryptMsg;
    };
} CAPICOM_CERTIFICATES_SOURCE, * PCAPICOM_CERTIFICATES_SOURCE;

// Values for dwSource of CAPICOM_LOAD_LOCATION
#define CAPICOM_CERTIFICATES_LOAD_FROM_CERT       0
#define CAPICOM_CERTIFICATES_LOAD_FROM_CHAIN      1
#define CAPICOM_CERTIFICATES_LOAD_FROM_STORE      2
#define CAPICOM_CERTIFICATES_LOAD_FROM_MESSAGE    3

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateCertificatesObject

  Synopsis : Create an ICertificates collection object, and load the object with 
             certificates from the specified source.

  Parameter: CAPICOM_CERTIFICATES_SOURCE ccs - Source where to get the 
                                               certificates.

             DWORD dwCurrentSafety - Current safety setting.

             BOOL bIndexedByThumbprint - TRUE to index by thumbprint.

             ICertificates2 ** ppICertificates - Pointer to pointer to 
                                                 ICertificates to receive the
                                                 interface pointer.
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateCertificatesObject (CAPICOM_CERTIFICATES_SOURCE ccs,
                                  DWORD                       dwCurrentSafety,
                                  BOOL                        bIndexedByThumbprint,
                                  ICertificates2           ** ppICertificates);
                                
////////////////////////////////////////////////////////////////////////////////
//
// CCertificates
//
class ATL_NO_VTABLE CCertificates : 
    public ICCertificates,
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CCertificates, &CLSID_Certificates>,
    public ICAPICOMError<CCertificates, &IID_ICertificates2>,
    public IDispatchImpl<ICertificatesCollection, &IID_ICertificates2, &LIBID_CAPICOM,
                         CAPICOM_MAJOR_VERSION, CAPICOM_MINOR_VERSION>,
    public IObjectSafetyImpl<CCertificates, INTERFACESAFE_FOR_UNTRUSTED_CALLER | 
                                            INTERFACESAFE_FOR_UNTRUSTED_DATA>
{
public:
    CCertificates()
    {
    }

    HRESULT FinalConstruct()
    {
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for Certificates object.\n", hr);
            return hr;
        }

        m_dwNextIndex = 0;
        m_bIndexedByThumbprint = FALSE;

        return S_OK;
    }

DECLARE_REGISTRY_RESOURCEID(IDR_CERTIFICATES)

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CCertificates)
    COM_INTERFACE_ENTRY(ICertificates)
    COM_INTERFACE_ENTRY(ICertificates2)
    COM_INTERFACE_ENTRY(ICCertificates)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CCertificates)
    IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
    IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
END_CATEGORY_MAP()

//
// ICertificates
//
public:
    //
    // These are the only ones that we need to implemented, others will be
    // handled by ATL ICollectionOnSTLImpl.
    //
    STDMETHOD(Find)
        (/*[in]*/ CAPICOM_CERTIFICATE_FIND_TYPE FindType, 
         /*[in]*/ VARIANT varCriteria,
         /*[in]*/ VARIANT_BOOL bFindValidOnly,
         /*[out, retval]*/ ICertificates2 ** pVal);

    STDMETHOD(Select)
        (/*[in, defaultvalue("")]*/ BSTR Title,
         /*[in, defaultvalue("")]*/ BSTR DisplayString,
         /*[in, defaultvalue(VARIANT_FALSE)]*/ VARIANT_BOOL bMultiSelect,
         /*[out, retval]*/ ICertificates2 ** pVal);

    STDMETHOD(Add)
        (/*[in]*/ ICertificate2 * pVal);

    STDMETHOD(Remove)
        (/*[in]*/ VARIANT Index);

    STDMETHOD(Clear)
        (void);

    STDMETHOD(Save)
        (/*[in]*/ BSTR FileName, 
         /*[in, defaultvalue("")]*/ BSTR Password,
         /*[in, defaultvalue(CAPICOM_STORE_SAVE_AS_PFX)]*/ CAPICOM_CERTIFICATES_SAVE_AS_TYPE SaveAs,
         /*[in, defaultvalue(0)]*/ CAPICOM_EXPORT_FLAG ExportFlag);

    //
    // ICCertficates custom interface.
    //
    STDMETHOD(_ExportToStore)
        (/*[in]*/ HCERTSTORE hCertStore);

    //
    // None COM functions.
    //
    STDMETHOD(AddContext)
        (PCCERT_CONTEXT pCertContext);

    STDMETHOD(LoadFromCert)
        (PCCERT_CONTEXT pCertContext);

    STDMETHOD(LoadFromChain)
        (PCCERT_CHAIN_CONTEXT pChainContext);

    STDMETHOD(LoadFromStore)
        (HCERTSTORE hCertStore);

    STDMETHOD(LoadFromMessage)
        (HCRYPTMSG hMsg);

    STDMETHOD(Init)
        (CAPICOM_CERTIFICATES_SOURCE ccs, 
         DWORD dwCurrentSafety,
         BOOL bIndexedByThumbprint);

private:
    CLock m_Lock;
    DWORD m_dwNextIndex;
    BOOL  m_bIndexedByThumbprint;
};

#endif //__CERTIFICATES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\certificatestatus.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:      CertificateStatus.cpp

  Contents:  Implementation of CCertificateStatus

  Remarks:   This object is not creatable by user directly. It can only be
             created via property/method of other CAPICOM objects.

  History:   11-15-99    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "CertificateStatus.h"

#include "Chain.h"
#include "OIDs.h"

///////////////
//
// Local
//

#define DEFAULT_CHECK_FLAGS ((CAPICOM_CHECK_FLAG) (CAPICOM_CHECK_SIGNATURE_VALIDITY | \
                                                   CAPICOM_CHECK_TIME_VALIDITY | \
                                                   CAPICOM_CHECK_TRUSTED_ROOT))


////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateCertificateStatusObject

  Synopsis : Create an ICertificateStatus object.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT.
  
             ICertificateStatus ** ppICertificateStatus - Pointer to pointer 
                                                          ICertificateStatus
                                                          object.        
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateCertificateStatusObject (PCCERT_CONTEXT        pCertContext,
                                       ICertificateStatus ** ppICertificateStatus)
{
    HRESULT hr = S_OK;
    CComObject<CCertificateStatus> * pCCertificateStatus = NULL;

    DebugTrace("Entering CreateCertificateStatusObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(ppICertificateStatus);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CCertificateStatus>::CreateInstance(&pCCertificateStatus)))
        {
            DebugTrace("Error [%#x]: CComObject<CCertificateStatus>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize the object.
        //
        if (FAILED(hr = pCCertificateStatus->Init(pCertContext)))
        {
            DebugTrace("Error [%#x]: pCCertificateStatus->Init() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return ICertificateStatus pointer to caller.
        //
        if (FAILED(hr = pCCertificateStatus->QueryInterface(ppICertificateStatus)))
        {
            DebugTrace("Error [%#x]: pCCertificateStatus->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreateCertificateStatusObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (pCCertificateStatus)
    {
        delete pCCertificateStatus;
    }

    goto CommonExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// CCertificateStatus
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificateStatus::get_Result

  Synopsis : Return the overall validity result of the cert, based on the
             currently set check flags and EKU.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive result.

  Remark   :
             
------------------------------------------------------------------------------*/

STDMETHODIMP CCertificateStatus::get_Result (VARIANT_BOOL * pVal)
{
    HRESULT         hr      = S_OK;
    CComPtr<IChain> pIChain = NULL;

    DebugTrace("Entering CCertificateStatus::get_Result().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_pCertContext);

        //
        // Build the chain and return the result.
        //
        if (FAILED(hr = ::CreateChainObject(m_pCertContext, this, NULL, pVal, &pIChain)))
        {
            DebugTrace("Error [%#x]: CreateChainObject() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificateStatus::get_Result().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificateStatus::get_CheckFlag

  Synopsis : Return the currently set validity check flag.

  Parameter: CAPICOM_CHECK_FLAG * pVal - Pointer to CAPICOM_CHECK_FLAG to 
                                         receive check flag.

  Remark   :
             
------------------------------------------------------------------------------*/

STDMETHODIMP CCertificateStatus::get_CheckFlag (CAPICOM_CHECK_FLAG * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CCertificateStatus::get_CheckFlag().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Return flag to user.
        //
        *pVal = m_CheckFlag;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificateStatus::get_CheckFlag().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificateStatus::put_CheckFlag

  Synopsis : Set validity check flag.

  Parameter: CAPICOM_CHECK_FLAG newVal - Check flag.

  Remark   : Note that CHECK_ONLINE_REVOCATION_STATUS and 
             CHECK_OFFLINE_REVOCATION_STATUS is mutually exclusive.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CCertificateStatus::put_CheckFlag (CAPICOM_CHECK_FLAG newVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CCertificateStatus::put_CheckFlag().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    //
    // Make sure flag is valid (maximum is CAPICOM_CHECK_OFFLINE_ALL).
    //
    if ((newVal & CAPICOM_CHECK_FLAG_LO_MASK) > CAPICOM_CHECK_OFFLINE_ALL)
    {
        hr = E_INVALIDARG;

        DebugTrace("Error [%#x]: invalid check flag (%#x).\n", hr, newVal);
        goto ErrorExit;
    }
    
    //
    // Store check flag.
    //
    m_CheckFlag = newVal;

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificateStatus::put_CheckFlag().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificateStatus::EKU

  Synopsis : Return the EKU object.

  Parameter: IEKU ** pVal - Pointer to pointer to IEKU to receive the
                            interface pointer.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificateStatus::EKU (IEKU ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CCertificateStatus::EKU().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_pIEKU);

        //
        // Return interface pointer to user.
        //
          if (FAILED(hr = m_pIEKU->QueryInterface(pVal)))
        {
            DebugTrace("Error [%#x]: m_pIEKU->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificateStatus::EKU().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificateStatus::get_VerificationTime

  Synopsis : Return the verification time.

  Parameter: DATE * pVal - Pointer to DATE to receive the value.

  Remark   : 

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificateStatus::get_VerificationTime (DATE * pVal)
{
    HRESULT    hr = S_OK;
    SYSTEMTIME st = {0};

    DebugTrace("Entering CCertificateStatus::get_VerificationTime().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure paremeters are valid.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Paremeter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // If the time was never explicit set by user, return the current time.
        //
        if ((DATE) 0 == m_VerificationTime)
        {
            ::GetLocalTime(&st);

            //
            // Convert to DATE.
            //
            if (0 == ::SystemTimeToVariantTime(&st, pVal))
            {
                hr = E_INVALIDARG;

                DebugTrace("Error [%#x]: SystemTimeToVariantTime() failed.\n", hr);
                goto ErrorExit;
            }
        }
        else
        {
            //
            // Return previously set verification time to caller.
            //
            *pVal = m_VerificationTime;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificateStatus::get_VerificationTime().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificateStatus::put_VerificationTime

  Synopsis : Set the verification time.

  Parameter: DATE newVal - New DATE value.

  Remark   : 

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificateStatus::put_VerificationTime (DATE newVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CCertificateStatus::put_VerificationTime().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Update verification time.
        //
        m_VerificationTime = newVal;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificateStatus::put_VerificationTime().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificateStatus::get_UrlRetrievalTimeout

  Synopsis : Get the URL retrieval timeout value in seconds.

  Parameter: long * pVal - Pointer to long to receive the value.

  Remark   : 

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificateStatus::get_UrlRetrievalTimeout (long * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CCertificateStatus::get_UrlRetrievalTimeout().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure paremeters are valid.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Paremeter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Return previously set URL retrieval timeout to caller.
        //
        *pVal = m_dwUrlRetrievalTimeout;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificateStatus::get_UrlRetrievalTimeout().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}
    

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificateStatus::put_UrlRetrievalTimeout

  Synopsis : Set the URL retrieval timeout value in seconds.

  Parameter: long newVal - New URL retrieval timeout value..

  Remark   : 

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificateStatus::put_UrlRetrievalTimeout (long newVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CCertificateStatus::put_UrlRetrievalTimeout().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure paremeters are valid.
        //
        if (CAPICOM_MAX_URL_RETRIEVAL_TIMEOUT < (DWORD) newVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: newVal (%#x) is greater than max retrieval timeout allowed.\n", 
                        hr, newVal);
            goto ErrorExit;
        }

        //
        // Update URL retrieval timeout.
        //
        m_dwUrlRetrievalTimeout = newVal;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificateStatus::put_UrlRetrievalTimeout().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificateStatus::CertificatePolicies

  Synopsis : Return the certificate policies OIDs collection for which this
             chain is valid.

  Parameter: IOID ** pVal - Pointer to pointer to IOIDs to receive the
                            interface pointer.

  Remark   : 

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificateStatus::CertificatePolicies (IOIDs ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CCertificateStatus::CertificatePolicies().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_pICertificatePolicies);

        //
        // Return interface pointer to user.
        //
          if (FAILED(hr = m_pICertificatePolicies->QueryInterface(pVal)))
        {
            DebugTrace("Error [%#x]: m_pICertificatePolicies->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificateStatus::CertificatePolicies().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificateStatus::ApplicationPolicies

  Synopsis : Return the application policies OIDs collection for which this
             chain is valid.

  Parameter: IOID ** pVal - Pointer to pointer to IOIDs to receive the
                            interface pointer.

  Remark   : 

------------------------------------------------------------------------------*/

STDMETHODIMP CCertificateStatus::ApplicationPolicies (IOIDs ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CCertificateStatus::ApplicationPolicies().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_pIApplicationPolicies);

        //
        // Return interface pointer to user.
        //
          if (FAILED(hr = m_pIApplicationPolicies->QueryInterface(pVal)))
        {
            DebugTrace("Error [%#x]: m_pIApplicationPolicies->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CCertificateStatus::ApplicationPolicies().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// Private methods.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CCertificateStatus::Init

  Synopsis : Initialize the object.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT.

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us with CERT_CONTEXT.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CCertificateStatus::Init (PCCERT_CONTEXT pCertContext)
{
    HRESULT hr = S_OK;
    CERT_ENHKEY_USAGE eku = {0, NULL};

    DebugTrace("Entering CCertificateStatus::Init().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);

    //
    // Set default check flags.
    //
    m_CheckFlag = DEFAULT_CHECK_FLAGS;

    //
    // Create the EKU object (default no EKU check).
    //
    if (FAILED(hr = ::CreateEKUObject(NULL, &m_pIEKU)))
    {
        DebugTrace("Error [%#x]: CreateEKUObject() failed.\n", hr);
        goto CommonExit;
    }

    //
    // Create the OIDs collection for certificate policies.
    //
    if (FAILED(hr = ::CreateOIDsObject(&eku, TRUE, &m_pICertificatePolicies)))
    {
        DebugTrace("Error [%#x]: CreateOIDsObject() failed.\n", hr);
        goto CommonExit;
    }

    //
    // Create the OIDs collection for application policies.
    //
    if (FAILED(hr = ::CreateOIDsObject(&eku, FALSE, &m_pIApplicationPolicies)))
    {
        DebugTrace("Error [%#x]: CreateOIDsObject() failed.\n", hr);
        goto CommonExit;
    }

    //
    // Save cert context.
    //
    if (!(m_pCertContext = ::CertDuplicateCertificateContext(pCertContext)))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        DebugTrace("Error [%#x]: CertDuplicateCertificateContext() failed.\n", hr);
    }

    m_VerificationTime = (DATE) 0;
    m_dwUrlRetrievalTimeout = 0;

CommonExit:

    DebugTrace("Leaving CCertificateStatus::Init().\n");

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\certificatestatus.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    CertificateStatus.h

  Content: Declaration of CCertificateStatus.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/
    
#ifndef __CERTIFICATESTATUS_H_
#define __CERTIFICATESTATUS_H_

#include "Resource.h"
#include "Error.h"
#include "Lock.h"
#include "Debug.h"
#include "EKU.h"

#define CAPICOM_DEFAULT_URL_RETRIEVAL_TIMEOUT   (15)    // Default is 15 seconds.
#define CAPICOM_MAX_URL_RETRIEVAL_TIMEOUT       (120)   // Maximum 2 minutes.

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateCertificateStatusObject

  Synopsis : Create an ICertificateStatus object.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT.
  
             ICertificateStatus ** ppICertificateStatus - Pointer to pointer 
                                                          ICertificateStatus
                                                          object.        
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateCertificateStatusObject (PCCERT_CONTEXT        pCertContext,
                                       ICertificateStatus ** ppICertificateStatus);


////////////////////////////////////////////////////////////////////////////////
//
// CCertificateStatus
//

class ATL_NO_VTABLE CCertificateStatus :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CCertificateStatus, &CLSID_CertificateStatus>,
    public ICAPICOMError<CCertificateStatus, &IID_ICertificateStatus2>,
    public IDispatchImpl<ICertificateStatus2, &IID_ICertificateStatus2, &LIBID_CAPICOM,
                         CAPICOM_MAJOR_VERSION, CAPICOM_MINOR_VERSION>
{
public:
    CCertificateStatus()
    {
    }

DECLARE_NO_REGISTRY()

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CCertificateStatus)
    COM_INTERFACE_ENTRY(ICertificateStatus)
    COM_INTERFACE_ENTRY(ICertificateStatus2)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CCertificateStatus)
END_CATEGORY_MAP()

    HRESULT FinalConstruct()
    {
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for CertificateStatus object.\n", hr);
            return hr;
        }

        m_pIEKU = NULL;
        m_pICertificatePolicies = NULL;
        m_pIApplicationPolicies = NULL;
        m_CheckFlag = CAPICOM_CHECK_NONE;
        m_pCertContext = NULL;
        m_VerificationTime = (DATE) 0;
        m_dwUrlRetrievalTimeout = 0;

        return S_OK;
    }

    void FinalRelease()
    {
        m_pIEKU.Release();
        m_pICertificatePolicies.Release();
        m_pIApplicationPolicies.Release();
        if (m_pCertContext)
        {
            ::CertFreeCertificateContext(m_pCertContext);
        }
    }

//
// ICertificateStatus
//
public:
    STDMETHOD(EKU)
        (/*[out, retval]*/ IEKU ** pVal);

    STDMETHOD(get_CheckFlag)
        (/*[out, retval]*/ CAPICOM_CHECK_FLAG * pVal);

    STDMETHOD(put_CheckFlag)
        (/*[in]*/ CAPICOM_CHECK_FLAG newVal);

    STDMETHOD(get_Result)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

    STDMETHOD(get_VerificationTime)
        (/*[out, retval]*/ DATE * pVal);

    STDMETHOD(put_VerificationTime)
        (/*[in]*/ DATE newVal);

    STDMETHOD(get_UrlRetrievalTimeout)
        (/*[out, retval]*/ long * pVal);

    STDMETHOD(put_UrlRetrievalTimeout)
        (/*[in]*/ long newVal);

    STDMETHOD(CertificatePolicies)
        (/*[out, retval]*/ IOIDs ** pVal);

    STDMETHOD(ApplicationPolicies)
        (/*[out, retval]*/ IOIDs ** pVal);

    //
    // None COM functions.
    //
    STDMETHOD(Init)(PCCERT_CONTEXT pCertContext);

private:
    CLock               m_Lock;
    DATE                m_VerificationTime;
    DWORD               m_dwUrlRetrievalTimeout;
    CComPtr<IEKU>       m_pIEKU;
    CComPtr<IOIDs>      m_pICertificatePolicies;
    CComPtr<IOIDs>      m_pIApplicationPolicies;
    PCCERT_CONTEXT      m_pCertContext;
    CAPICOM_CHECK_FLAG  m_CheckFlag;
};

#endif //__CERTIFICATESTATUS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\common.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Common.cpp

  Content: Common routines.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "Common.h"

#include "Convert.h"

LPSTR g_rgpszOSNames[] =
{
    "Unknown OS platform",
    "Win32s",
    "Win9x",
    "WinMe",
    "WinNT 3.5",
    "WinNT 4.0",
    "Win2K",
    "WinXP",
    "Above WinXP"
};

typedef struct _CSP_PROVIDERS
{
    DWORD   dwProvType;
    LPSTR   pszProvider;
} CSP_PROVIDERS;

static CSP_PROVIDERS g_rgpProviders[] = 
{ 
    PROV_RSA_FULL,  NULL,                   // Default RSA Full provider.
    PROV_RSA_FULL,  MS_ENHANCED_PROV_A,     // Microsoft Enhanced RSA provider.
    PROV_RSA_FULL,  MS_STRONG_PROV_A,       // Microsoft Strong RSA provider.
    PROV_RSA_FULL,  MS_DEF_PROV_A,          // Microsoft Base RSA provider.
    PROV_RSA_AES,   NULL,                   // Default RSA AES Full provider.
    PROV_RSA_AES,   MS_ENH_RSA_AES_PROV_A   // Microsoft RSA AES Full provider.
};

#define g_dwNumRSAProviders (4)
#define g_dwNumProviders    (ARRAYSIZE(g_rgpProviders))

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : GetOSVersion

  Synopsis : Get the current OS platform/version.

  Parameter: None.

  Remark   :

------------------------------------------------------------------------------*/

OSVERSION GetOSVersion ()
{
    HRESULT    hr        = S_OK;
    OSVERSION  osVersion = OS_WIN_UNKNOWN;
    OSVERSIONINFO OSVersionInfo;

    DebugTrace("Entering GetOSVersion().\n");

    //
    // Initialize OSVERSIONINFO struct.
    //
    OSVersionInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO); 

    //
    // GetVersionEx() will fail on Windows 3.x or below NT 3.5 systems.
    //
    if (!::GetVersionEx(&OSVersionInfo))
    {
        DebugTrace("Error [%#x]: GetVersionEx() failed.\n", hr);
        goto CommonExit;
    }

    //
    // Check platform ID.
    //
    switch (OSVersionInfo.dwPlatformId)
    {
        case VER_PLATFORM_WIN32s:
        {
            //
            // Win32s.
            //
            osVersion = OS_WIN_32s;
            break;
        }
        
        case VER_PLATFORM_WIN32_WINDOWS:
        {
            if (4 == OSVersionInfo.dwMajorVersion && 90 == OSVersionInfo.dwMinorVersion)
            {
                //
                // WinMe.
                //
                osVersion = OS_WIN_ME;
            }
            else
            {
                //
                // Win9x.
                //
                osVersion = OS_WIN_9X;
            }

            break;
        }

        case VER_PLATFORM_WIN32_NT:
        {
            switch (OSVersionInfo.dwMajorVersion)
            {
                case 4:
                {
                    //
                    // NT 4.
                    //
                    osVersion = OS_WIN_NT4;
                    break;
                }

                case 5:
                {
                    if (0 == OSVersionInfo.dwMinorVersion)
                    {
                        //
                        // Win2K.
                        //
                        osVersion = OS_WIN_2K;
                    }
                    else if (1 == OSVersionInfo.dwMinorVersion)
                    {
                        //
                        // WinXP.
                        //
                        osVersion = OS_WIN_XP;
                    }
                    else
                    {
                        //
                        // Above WinXP.
                        //
                        osVersion = OS_WIN_ABOVE_XP;
                    }

                    break;
                }

                default:
                {
                    //
                    // Must be NT 3.5.
                    //
                    osVersion = OS_WIN_NT3_5;
                    break;
                }
            }

            break;
        }

        default:
        {
            DebugTrace("Info: unsupported OS (Platform = %d, Major = %d, Minor = %d).\n", 
                        OSVersionInfo.dwPlatformId, OSVersionInfo.dwMajorVersion, OSVersionInfo.dwMinorVersion);
            break;
        }
    }

CommonExit:

    DebugTrace("Leaving GetOSVersion().\n");

    return osVersion;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : EncodeObject

  Synopsis : Allocate memory and encode an ASN.1 object using CAPI
             CryptEncodeObject() API.

  Parameter: LPCSRT pszStructType           - see MSDN document for possible 
                                              types.
             LPVOID pbData                  - Pointer to data to be encoded 
                                              (data type must match 
                                              pszStrucType).
             CRYPT_DATA_BLOB * pEncodedBlob - Pointer to CRYPT_DATA_BLOB to 
                                              receive the encoded length and 
                                              data.

  Remark   : No parameter check is done.

------------------------------------------------------------------------------*/

HRESULT EncodeObject (LPCSTR            pszStructType, 
                      LPVOID            pbData, 
                      CRYPT_DATA_BLOB * pEncodedBlob)
{
    HRESULT hr = S_OK;
    DWORD cbEncoded = 0;
    BYTE * pbEncoded = NULL;

    DebugTrace("Entering EncodeObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(NULL != pszStructType);
    ATLASSERT(NULL != pbData);
    ATLASSERT(NULL != pEncodedBlob);

    //
    // Intialize return value.
    //
    pEncodedBlob->cbData = 0;
    pEncodedBlob->pbData = NULL;

    //
    // Determine encoded length required.
    //
    if (!::CryptEncodeObject(CAPICOM_ASN_ENCODING,
                             pszStructType,
                             (const void *) pbData,
                             NULL,
                             &cbEncoded))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Unable to determine object encoded length [0x%x]: CryptEncodeObject() failed.\n", hr);
        goto CommonExit;
    }

    //
    // Allocate memory for encoded blob.
    //
    if (!(pbEncoded = (BYTE *) ::CoTaskMemAlloc(cbEncoded)))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Out of memory: CoTaskMemAlloc(cbEncoded) failed.\n");
        goto CommonExit;
    }

    //
    // Encode.
    //
    if (!::CryptEncodeObject(CAPICOM_ASN_ENCODING,
                             pszStructType,
                             (const void *) pbData,
                             pbEncoded,
                             &cbEncoded))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Unable to encode object [0x%x]: CryptEncodeObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Return value.
    //
    pEncodedBlob->cbData = cbEncoded;
    pEncodedBlob->pbData = pbEncoded;

CommonExit:

    DebugTrace("Leaving EncodeObject().\n");
    
    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resources.
    //
    if (pbEncoded)
    {
        ::CoTaskMemFree((LPVOID) pbEncoded);
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : DecodeObject

  Synopsis : Allocate memory and decode an ASN.1 object using CAPI
             CryptDecodeObject() API.

  Parameter: LPCSRT pszStructType           - see MSDN document for possible
                                              types.
             BYTE * pbEncoded               - Pointer to data to be decoded 
                                              (data type must match 
                                              pszStructType).
             DWORD cbEncoded                - Size of encoded data.
             CRYPT_DATA_BLOB * pDecodedBlob - Pointer to CRYPT_DATA_BLOB to 
                                              receive the decoded length and 
                                              data.
  Remark   : No parameter check is done.

------------------------------------------------------------------------------*/

HRESULT DecodeObject (LPCSTR            pszStructType, 
                      BYTE            * pbEncoded,
                      DWORD             cbEncoded,
                      CRYPT_DATA_BLOB * pDecodedBlob)
{
    HRESULT hr = S_OK;
    DWORD   cbDecoded = 0;
    BYTE *  pbDecoded = NULL;

    DebugTrace("Entering DecodeObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pszStructType);
    ATLASSERT(pbEncoded);
    ATLASSERT(pDecodedBlob);

    //
    // Intialize return value.
    //
    pDecodedBlob->cbData = 0;
    pDecodedBlob->pbData = NULL;

    //
    // Determine encoded length required.
    //
    if (!::CryptDecodeObject(CAPICOM_ASN_ENCODING,
                             pszStructType,
                             (const BYTE *) pbEncoded,
                             cbEncoded,
                             0,
                             NULL,
                             &cbDecoded))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptDecodeObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Allocate memory for decoded blob.
    //
    if (!(pbDecoded = (BYTE *) ::CoTaskMemAlloc(cbDecoded)))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Error: out of memory.\n");
        goto ErrorExit;
    }

    //
    // Decode.
    //
    if (!::CryptDecodeObject(CAPICOM_ASN_ENCODING,
                             pszStructType,
                             (const BYTE *) pbEncoded,
                             cbEncoded,
                             0,
                             pbDecoded,
                             &cbDecoded))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptDecodeObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Return value.
    //
    pDecodedBlob->cbData = cbDecoded;
    pDecodedBlob->pbData = pbDecoded;

CommonExit:

    DebugTrace("Leaving DecodeObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resources.
    //
    if (pbDecoded)
    {
        ::CoTaskMemFree((LPVOID) pbDecoded);
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : GetKeyParam

  Synopsis : Allocate memory and retrieve requested key parameter using 
             CryptGetKeyParam() API.

  Parameter: HCRYPTKEY hKey  - Key handler.
             DWORD dwParam   - Key parameter query.
             BYTE ** ppbData - Pointer to receive buffer.
             DWORD * pcbData - Size of buffer.

  Remark   :

------------------------------------------------------------------------------*/

HRESULT GetKeyParam (HCRYPTKEY hKey,
                     DWORD     dwParam,
                     BYTE   ** ppbData,
                     DWORD   * pcbData)
{
    HRESULT hr     = S_OK;
    DWORD   cbData = 0;
    BYTE  * pbData = NULL;

    DebugTrace("Entering GetKeyParam().\n");

    //
    // Sanity check.
    //
    ATLASSERT(ppbData);
    ATLASSERT(pcbData);
    
    //
    // Determine data buffer size.
    //
    if (!::CryptGetKeyParam(hKey,
                            dwParam,
                            NULL,
                            &cbData,
                            0))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptGetKeyParam() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Allocate memory for buffer.
    //
    if (!(pbData = (BYTE *) ::CoTaskMemAlloc(cbData)))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Error: out of memory.\n");
        goto ErrorExit;
    }

    //
    // Now get the data.
    //
    if (!::CryptGetKeyParam(hKey,
                            dwParam,
                            pbData,
                            &cbData,
                            0))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptGetKeyParam() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Return key param to caller.
    //
    *ppbData = pbData;
    *pcbData = cbData;

CommonExit:

    DebugTrace("Leaving GetKeyParam().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resources.
    //
    if (pbData)
    {
        ::CoTaskMemFree(pbData);
    }
    
    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : IsAlgSupported

  Synopsis : Check to see if the algo is supported by the CSP.

  Parameter: HCRYPTPROV hCryptProv - CSP handle.

             ALG_ID AlgId - Algorithm ID.

             PROV_ENUMALGS_EX * pPeex - Pointer to PROV_ENUMALGS_EX to receive
                                        the found structure.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT IsAlgSupported (HCRYPTPROV         hCryptProv, 
                        ALG_ID             AlgId, 
                        PROV_ENUMALGS_EX * pPeex)
{
    DWORD EnumFlag = CRYPT_FIRST;
    DWORD cbPeex   = sizeof(PROV_ENUMALGS_EX);
    
    //
    // Sanity check.
    //
    ATLASSERT(hCryptProv);
    ATLASSERT(pPeex);

    //
    // Initialize.
    //
    ::ZeroMemory(pPeex, sizeof(PROV_ENUMALGS_EX));

    //
    // Get algorithm capability from CSP.
    //
    while (::CryptGetProvParam(hCryptProv, PP_ENUMALGS_EX, (BYTE *) pPeex,
                               &cbPeex, EnumFlag))
    {
        EnumFlag = 0;

        if (pPeex->aiAlgid == AlgId)
        {
            return S_OK;
        }
    }

    return CAPICOM_E_NOT_SUPPORTED;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : IsAlgKeyLengthSupported

  Synopsis : Check to see if the algo and key length is supported by the CSP.

  Parameter: HCRYPTPROV hCryptProv - CSP handle.

             ALG_ID AlgID - Algorithm ID.

             DWORD dwKeyLength - Key length

  Remark   :

------------------------------------------------------------------------------*/

HRESULT IsAlgKeyLengthSupported (HCRYPTPROV hCryptProv, 
                                 ALG_ID     AlgID,
                                 DWORD      dwKeyLength)
{
    HRESULT hr;
    PROV_ENUMALGS_EX peex;

    //
    // Sanity check.
    //
    ATLASSERT(hCryptProv);

    //
    // Make sure AlgID is supported.
    //
    if (FAILED(hr = ::IsAlgSupported(hCryptProv, AlgID, &peex)))
    {
        DebugTrace("Info: AlgID = %d is not supported by this CSP.\n", AlgID);
        return hr;
    }

    //
    // Make sure key length is supported for RC2 and RC4.
    //
    if (AlgID == CALG_RC2 || AlgID == CALG_RC4)
    {
        if (dwKeyLength < peex.dwMinLen || dwKeyLength > peex.dwMaxLen)
        {
            DebugTrace("Info: Key length = %d is not supported by this CSP.\n", dwKeyLength);
            return CAPICOM_E_NOT_SUPPORTED;
        }
    }

    return S_OK;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AcquireContext

  Synopsis : Acquire context for the specified CSP and keyset container.
  
  Parameter: LPSTR pszProvider - CSP provider name or NULL.
  
             LPSTR pszContainer - Keyset container name or NULL.

             DWORD dwProvType - Provider type.

             DWORD dwFlags - Same as dwFlags of CryptAcquireConext.

             BOOL bNewKeyset - TRUE to create new keyset container, else FALSE.
  
             HCRYPTPROV * phCryptProv - Pointer to HCRYPTPROV to recevice
                                        CSP context.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT AcquireContext(LPSTR        pszProvider, 
                       LPSTR        pszContainer,
                       DWORD        dwProvType,
                       DWORD        dwFlags,
                       BOOL         bNewKeyset,
                       HCRYPTPROV * phCryptProv)
{
    HRESULT    hr         = S_OK;
    HCRYPTPROV hCryptProv = NULL;

    DebugTrace("Entering AcquireContext().\n");

    //
    // Sanity check.
    //
    ATLASSERT(phCryptProv);

    //
    // Get handle to the specified provider.
    //
    if(!::CryptAcquireContextA(&hCryptProv, 
                               pszContainer, 
                               pszProvider, 
                               dwProvType, 
                               dwFlags)) 
    {
        DWORD dwWinError = ::GetLastError();

        if (NTE_BAD_KEYSET != dwWinError || NTE_KEYSET_NOT_DEF == dwWinError || !bNewKeyset)
        {
            hr = HRESULT_FROM_WIN32(dwWinError);

            DebugTrace("Error [%#x]: CryptAcquireContextA() failed.\n", hr);
            goto CommonExit;
        }

        //
        // Keyset container not found, so create it.
        //
        if(!::CryptAcquireContextA(&hCryptProv, 
                                   pszContainer, 
                                   pszProvider, 
                                   dwProvType, 
                                   CRYPT_NEWKEYSET | dwFlags)) 
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptAcquireContextA() failed.\n", hr);
            goto CommonExit;
        }
    }

    //
    // Return handle to caller.
    //
    *phCryptProv = hCryptProv;

CommonExit:

    DebugTrace("Leaving AcquireContext().\n");

    return hr;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AcquireContext

  Synopsis : Acquire context for the specified CSP and keyset container.
  
  Parameter: LPWSTR pwszProvider - CSP provider name or NULL.
  
             LPWSTR pwszContainer - Keyset container name or NULL.

             DWORD dwProvType - Provider type.

             DWORD dwFlags - Same as dwFlags of CryptAcquireConext.
  
             BOOL bNewKeyset - TRUE to create new keyset container, else FALSE.
  
             HCRYPTPROV * phCryptProv - Pointer to HCRYPTPROV to recevice
                                        CSP context.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT AcquireContext(LPWSTR       pwszProvider, 
                       LPWSTR       pwszContainer,
                       DWORD        dwProvType,
                       DWORD        dwFlags,
                       BOOL         bNewKeyset,
                       HCRYPTPROV * phCryptProv)
{
    HRESULT hr           = S_OK;
    LPSTR   pszProvider  = NULL;
    LPSTR   pszContainer = NULL;

    DebugTrace("Entering AcquireContext().\n");

    //
    // Sanity check.
    //
    ATLASSERT(phCryptProv);

    //
    // Call W directly if available.
    //
    if (IsWinNTAndAbove())
    {
        //
        // Get handle to the specified provider.
        //
        if(!::CryptAcquireContextW(phCryptProv, 
                                   pwszContainer, 
                                   pwszProvider, 
                                   dwProvType, 
                                   dwFlags)) 
        {
            DWORD dwWinError = ::GetLastError();

            if (NTE_BAD_KEYSET != dwWinError || NTE_KEYSET_NOT_DEF == dwWinError || !bNewKeyset)
            {
                hr = HRESULT_FROM_WIN32(dwWinError);

                DebugTrace("Error [%#x]: CryptAcquireContextW() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Keyset container not found, so create it.
            //
            if(!::CryptAcquireContextW(phCryptProv, 
                                       pwszContainer, 
                                       pwszProvider, 
                                       dwProvType, 
                                       CRYPT_NEWKEYSET | dwFlags)) 
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());

                DebugTrace("Error [%#x]: CryptAcquireContextW() failed.\n", hr);
                goto ErrorExit;
            }
        }
    }
    else
    {
        //
        // Convert to ANSI.
        //
        if (pwszProvider &&
            FAILED(hr = ::UnicodeToAnsi(pwszProvider, -1, &pszProvider, NULL)))
        {
            DebugTrace("Error [%#x]: UnicodeToAnsi() failed.\n", hr);
            goto ErrorExit;
        }

        if (pwszContainer &&
            FAILED(hr = ::UnicodeToAnsi(pwszContainer, -1, &pszContainer, NULL)))
        {
            DebugTrace("Error [%#x]: UnicodeToAnsi() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Call ANSI version.
        //
        hr = ::AcquireContext(pszProvider, pszContainer, dwProvType, dwFlags, bNewKeyset, phCryptProv);
    }

CommonExit:
    //
    // Free resources.
    //
    if (pszProvider)
    {
        ::CoTaskMemFree((LPVOID) pszProvider);
    }
    if (pszContainer)
    {
        ::CoTaskMemFree((LPVOID) pszContainer);
    }

    DebugTrace("Leaving AcquireContext().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AcquireContext

  Synopsis : Acquire context of a CSP using the default container for a
             specified hash algorithm.
  
  Parameter: ALG_ID AlgOID - Algorithm ID.

             HCRYPTPROV * phCryptProv - Pointer to HCRYPTPROV to recevice
                                        CSP context.

  Remark   : Note that KeyLength will be ignored for DES and 3DES.
  
------------------------------------------------------------------------------*/

HRESULT AcquireContext(ALG_ID       AlgID,
                       HCRYPTPROV * phCryptProv)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering AcquireContext().\n");

    //
    // Sanity check.
    //
    ATLASSERT(phCryptProv);

    //
    // Find the first provider that support the specified algorithm.
    //
    for (DWORD i = 0; i < g_dwNumProviders; i++)
    {
        PROV_ENUMALGS_EX peex;
        HCRYPTPROV hCryptProv = NULL;

        //
        // Acquire CSP handle.
        //
        if (FAILED(::AcquireContext(g_rgpProviders[i].pszProvider,
                                    NULL,
                                    g_rgpProviders[i].dwProvType,
                                    CRYPT_VERIFYCONTEXT,
                                    TRUE,
                                    &hCryptProv)))
        {
            DebugTrace("Info: AcquireContext() failed for %s provider of type %#x.\n", 
                       g_rgpProviders[i].pszProvider ? g_rgpProviders[i].pszProvider : "default",
                       g_rgpProviders[i].dwProvType);
            continue;
        }

        //
        // Make sure algo is supported by this CSP.
        //
        if (FAILED(::IsAlgSupported(hCryptProv, AlgID, &peex)))
        {
            ::CryptReleaseContext(hCryptProv, 0);

            DebugTrace("Info: %s provider does not support AlgID = %d.\n", 
                       g_rgpProviders[i].pszProvider ? g_rgpProviders[i].pszProvider : "Default", 
                       AlgID);
        }
        else
        {
            //
            // Found the CSP.
            //
            *phCryptProv = hCryptProv;
            break;
        }
    }

    //
    // Did we find the CSP.
    //
    if (i == g_dwNumProviders)
    {
        *phCryptProv = NULL;

        hr = CAPICOM_E_NOT_SUPPORTED;

        DebugTrace("Error [%#x]: could not find a CSP that support AlgID = %d.\n", 
                    hr, AlgID);
    }

    DebugTrace("Leaving AcquireContext().\n");

    return hr;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AcquireContext

  Synopsis : Acquire context of a CSP using the default container for a
             specified encryption algorithm and desired key length.
  
  Parameter: ALG_ID AlgOID - Algorithm ID.

             DWORD dwKeyLength - Key length.

             HCRYPTPROV * phCryptProv - Pointer to HCRYPTPROV to recevice
                                        CSP context.

  Remark   : Note that KeyLength will be ignored for DES and 3DES.
  
------------------------------------------------------------------------------*/

HRESULT AcquireContext(ALG_ID       AlgID,
                       DWORD        dwKeyLength,
                       HCRYPTPROV * phCryptProv)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering AcquireContext().\n");

    //
    // Sanity check.
    //
    ATLASSERT(phCryptProv);

    //
    // Find the first provider that support the specified 
    // algorithm and key length.
    //
    for (DWORD i = 0; i < g_dwNumProviders; i++)
    {
        HCRYPTPROV hCryptProv = NULL;

        //
        // Acquire CSP handle.
        //
        if (FAILED(::AcquireContext(g_rgpProviders[i].pszProvider,
                                    NULL,
                                    g_rgpProviders[i].dwProvType,
                                    CRYPT_VERIFYCONTEXT, 
                                    TRUE,
                                    &hCryptProv)))
        {
            DebugTrace("Info: AcquireContext() failed for %s provider of type %#x.\n", 
                       g_rgpProviders[i].pszProvider ? g_rgpProviders[i].pszProvider : "default",
                       g_rgpProviders[i].dwProvType);
            continue;
        }

        //
        // Make sure algo and key length are supported by this CSP.
        //
        if (FAILED(::IsAlgKeyLengthSupported(hCryptProv, AlgID, dwKeyLength)))
        {
            ::CryptReleaseContext(hCryptProv, 0);

            DebugTrace("Info: %s provider does not support AlgID = %d and/or key length = %d.\n", 
                       g_rgpProviders[i].pszProvider ? g_rgpProviders[i].pszProvider : "Default", 
                       AlgID, dwKeyLength);
        }
        else
        {
            //
            // Found the CSP.
            //
            DebugTrace("Info: Found CSP = %s.\n", g_rgpProviders[i].pszProvider);

            *phCryptProv = hCryptProv;
            break;
        }
    }

    //
    // Did we find the CSP.
    //
    if (i == g_dwNumProviders)
    {
        *phCryptProv = NULL;

        hr = CAPICOM_E_NOT_SUPPORTED;

        DebugTrace("Error [%#x]: could not find a CSP that support AlgID = %d and/or key length = %d.\n", 
                    hr, AlgID, dwKeyLength);
    }

    DebugTrace("Leaving AcquireContext().\n");

    return hr;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AcquireContext

  Synopsis : Acquire context of a CSP using the default container for a
             specified algorithm and desired key length.
  
  Parameter: CAPICOM_ENCRYPTION_ALGORITHM AlgoName - Algorithm name.

             CAPICOM_ENCRYPTION_KEY_LENGTH KeyLength - Key length.

             HCRYPTPROV * phCryptProv - Pointer to HCRYPTPROV to recevice
                                        CSP context.

  Remark   : Note that KeyLength will be ignored for DES and 3DES.

             Note also the the returned handle cannot be used to access private 
             key, and should NOT be used to store assymetric key, as it refers 
             to the default container, which can be easily destroy any existing 
             assymetric key pair.

------------------------------------------------------------------------------*/

HRESULT AcquireContext (CAPICOM_ENCRYPTION_ALGORITHM  AlgoName,
                        CAPICOM_ENCRYPTION_KEY_LENGTH KeyLength,
                        HCRYPTPROV                  * phCryptProv)
{
    HRESULT hr          = S_OK;
    ALG_ID  AlgID       = 0;
    DWORD   dwKeyLength = 0;

    DebugTrace("Entering AcquireContext().\n");

    //
    // Sanity check.
    //
    ATLASSERT(phCryptProv);

    //
    // Convert enum name to ALG_ID.
    //
    if (FAILED(hr = ::EnumNameToAlgID(AlgoName, KeyLength, &AlgID)))
    {
        DebugTrace("Error [%#x]: EnumNameToAlgID() failed.\n");
        goto CommonExit;
    }

    //
    // Convert enum name to key length.
    //
    if (FAILED(hr = ::EnumNameToKeyLength(KeyLength, AlgID, &dwKeyLength)))
    {
        DebugTrace("Error [%#x]: EnumNameToKeyLength() failed.\n");
        goto CommonExit;
    }

    //
    // Pass on to overloaded version.
    //
    hr = ::AcquireContext(AlgID, dwKeyLength, phCryptProv);

CommonExit:

    DebugTrace("Leaving AcquireContext().\n");
    
    return hr;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AcquireContext

  Synopsis : Acquire the proper CSP and access to the private key for 
             the specified cert.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT of cert.

             HCRYPTPROV * phCryptProv    - Pointer to HCRYPTPROV to recevice
                                           CSP context.

             DWORD * pdwKeySpec          - Pointer to DWORD to receive key
                                           spec, AT_KEYEXCHANGE or AT_SIGNATURE.

             BOOL * pbReleaseContext     - Upon successful and if this is set
                                           to TRUE, then the caller must
                                           free the CSP context by calling
                                           CryptReleaseContext(), otherwise
                                           the caller must not free the CSP
                                           context.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT AcquireContext (PCCERT_CONTEXT pCertContext, 
                        HCRYPTPROV   * phCryptProv, 
                        DWORD        * pdwKeySpec, 
                        BOOL         * pbReleaseContext)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering AcquireContext().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(phCryptProv);
    ATLASSERT(pdwKeySpec);
    ATLASSERT(pbReleaseContext);

    //
    // Acquire CSP context and access to the private key associated 
    // with this cert.
    //
    if (!::CryptAcquireCertificatePrivateKey(pCertContext,
                                             CRYPT_ACQUIRE_USE_PROV_INFO_FLAG |
                                             CRYPT_ACQUIRE_COMPARE_KEY_FLAG,
                                             NULL,
                                             phCryptProv,
                                             pdwKeySpec,
                                             pbReleaseContext))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptAcquireCertificatePrivateKey() failed.\n", hr);
    }

    DebugTrace("Leaving AcquireContext().\n");

    return hr;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : ReleaseContext

  Synopsis : Release CSP context.
  
  Parameter: HCRYPTPROV hProv - CSP handle.

  Remark   :

------------------------------------------------------------------------------*/

HRESULT ReleaseContext (HCRYPTPROV hProv)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering ReleaseContext().\n");

    //
    // Sanity check.
    //
    ATLASSERT(hProv);

    //
    // Release the context.
    //
    if (!::CryptReleaseContext(hProv, 0))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptReleaseContext() failed.\n", hr);
    }

    DebugTrace("Leaving ReleaseContext().\n");

    return hr;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : OIDToAlgID

  Synopsis : Convert algorithm OID to the corresponding ALG_ID value.

  Parameter: LPSTR pszAlgoOID - Algorithm OID string.
  
             ALG_ID * pAlgID - Pointer to ALG_ID to receive the value.

  Remark   :

------------------------------------------------------------------------------*/

HRESULT OIDToAlgID (LPSTR    pszAlgoOID, 
                    ALG_ID * pAlgID)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering OIDToAlgID().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pszAlgoOID);
    ATLASSERT(pAlgID);

    //
    // Determine ALG_ID.
    //
    if (0 == ::strcmp(szOID_RSA_RC2CBC, pszAlgoOID))
    {
        *pAlgID = CALG_RC2;
    }
    else if (0 == ::strcmp(szOID_RSA_RC4, pszAlgoOID))
    {
        *pAlgID = CALG_RC4;
    }
    else if (0 == ::strcmp(szOID_OIWSEC_desCBC, pszAlgoOID))
    {
        *pAlgID = CALG_DES;
    }
    else if (0 == ::strcmp(szOID_RSA_DES_EDE3_CBC, pszAlgoOID))
    {
        *pAlgID = CALG_3DES;
    }
    else
    {
        hr = CAPICOM_E_INVALID_ALGORITHM;
        DebugTrace("Error: invalid parameter, unknown algorithm OID.\n");
    }

    DebugTrace("Leaving OIDToAlgID().\n");

    return hr;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AlgIDToOID

  Synopsis : Convert ALG_ID value to the corresponding algorithm OID.

  Parameter: ALG_ID AlgID - ALG_ID to be converted.

             LPSTR * ppszAlgoOID - Pointer to LPSTR to receive the OID string.

  Remark   :

------------------------------------------------------------------------------*/

HRESULT AlgIDToOID (ALG_ID  AlgID, 
                    LPSTR * ppszAlgoOID)
{
    HRESULT hr = S_OK;
    LPSTR   pszAlgoOID = NULL;

    DebugTrace("Entering AlgIDToOID().\n");

    //
    // Sanity check.
    //
    ATLASSERT(ppszAlgoOID);

    //
    // Determine ALG_ID.
    //
    switch (AlgID)
    {
        case CALG_RC2:
        {
            pszAlgoOID = szOID_RSA_RC2CBC;
            break;
        }

        case CALG_RC4:
        {
            pszAlgoOID = szOID_RSA_RC4;
            break;
        }

        case CALG_DES:
        {
            pszAlgoOID = szOID_OIWSEC_desCBC;
            break;
        }

        case CALG_3DES:
        {
            pszAlgoOID = szOID_RSA_DES_EDE3_CBC;
            break;
        }

        default:
        {
            hr = CAPICOM_E_INVALID_ALGORITHM;

            DebugTrace("Error [%#x]: Unknown ALG_ID (%#x).\n", hr, AlgID);
            goto CommonExit;
        }
    }

    //
    // Allocate memory.
    //
    if (!(*ppszAlgoOID = (LPSTR) ::CoTaskMemAlloc(::strlen(pszAlgoOID) + 1)))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Error [%#x]: CoTaskMemAlloc() failed.\n", hr);
        goto CommonExit;
    }

    //
    // Copy OID string to caller.
    //
    ::strcpy(*ppszAlgoOID, pszAlgoOID);

CommonExit:

    DebugTrace("Leaving AlgIDToOID().\n");

    return hr;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AlgIDToEnumName

  Synopsis : Convert ALG_ID value to the corresponding algorithm enum name.

  Parameter: ALG_ID AlgID - ALG_ID to be converted.
  
             CAPICOM_ENCRYPTION_ALGORITHM * pAlgoName - Receive algo enum name.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT AlgIDToEnumName (ALG_ID                         AlgID, 
                         CAPICOM_ENCRYPTION_ALGORITHM * pAlgoName)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering AlgIDToEnumName().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pAlgoName);

    switch (AlgID)
    {
        case CALG_RC2:
        {
            *pAlgoName = CAPICOM_ENCRYPTION_ALGORITHM_RC2;
            break;
        }

        case CALG_RC4:
        {
            *pAlgoName = CAPICOM_ENCRYPTION_ALGORITHM_RC4;
            break;
        }

        case CALG_DES:
        {
            *pAlgoName = CAPICOM_ENCRYPTION_ALGORITHM_DES;
            break;
        }

        case CALG_3DES:
        {
            *pAlgoName = CAPICOM_ENCRYPTION_ALGORITHM_3DES;
            break;
        }

        case CALG_AES_128:
        case CALG_AES_192:
        case CALG_AES_256:
        {
            *pAlgoName = CAPICOM_ENCRYPTION_ALGORITHM_AES;
            break;
        }

        default:
        {
            hr = CAPICOM_E_INVALID_ALGORITHM;
            DebugTrace("Error: invalid parameter, unknown ALG_ID.\n");
        }
    }

    DebugTrace("Leaving AlgIDToEnumName().\n");

    return hr;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : EnumNameToAlgID

  Synopsis : Convert algorithm enum name to the corresponding ALG_ID value.

  Parameter: CAPICOM_ENCRYPTION_ALGORITHM AlgoName - Algo enum name.

             CAPICOM_ENCRYPTION_KEY_LENGTH KeyLength - Key length.
  
             ALG_ID * pAlgID - Pointer to ALG_ID to receive the value.  

  Remark   :

------------------------------------------------------------------------------*/

HRESULT EnumNameToAlgID (CAPICOM_ENCRYPTION_ALGORITHM  AlgoName,
                         CAPICOM_ENCRYPTION_KEY_LENGTH KeyLength,
                         ALG_ID                      * pAlgID)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering EnumNameToAlgID().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pAlgID);

    switch (AlgoName)
    {
        case CAPICOM_ENCRYPTION_ALGORITHM_RC2:
        {
            *pAlgID = CALG_RC2;
            break;
        }

        case CAPICOM_ENCRYPTION_ALGORITHM_RC4:
        {
            *pAlgID = CALG_RC4;
            break;
        }

        case CAPICOM_ENCRYPTION_ALGORITHM_DES:
        {
            *pAlgID = CALG_DES;
            break;
        }

        case CAPICOM_ENCRYPTION_ALGORITHM_3DES:
        {
            *pAlgID = CALG_3DES;
            break;
        }

        case CAPICOM_ENCRYPTION_ALGORITHM_AES:
        {
            //
            // CAPI uses a different scheme for AES (key length is tied to ALG_ID).
            //
            if (CAPICOM_ENCRYPTION_KEY_LENGTH_MAXIMUM == KeyLength || 
                CAPICOM_ENCRYPTION_KEY_LENGTH_256_BITS == KeyLength)
            {
                *pAlgID = CALG_AES_256;
            }
            else if (CAPICOM_ENCRYPTION_KEY_LENGTH_192_BITS == KeyLength)
            {
                *pAlgID = CALG_AES_192;
            }
            else if (CAPICOM_ENCRYPTION_KEY_LENGTH_128_BITS == KeyLength)
            {
                *pAlgID = CALG_AES_128;
            }
            else
            {
                hr = CAPICOM_E_INVALID_KEY_LENGTH;

                DebugTrace("Error [%#x]: Invalid key length (%d) specified for AES.\n", hr, KeyLength);
                goto ErrorExit;
            }

            break;
        }

        default:
        {
            hr = CAPICOM_E_INVALID_ALGORITHM;

            DebugTrace("Error [%#x]: Unknown CAPICOM_ENCRYPTION_ALGORITHM (%#x).\n", hr, AlgoName);
        }
    }

CommonExit:

    DebugTrace("Leaving EnumNameToAlgID().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : KeyLengthToEnumName

  Synopsis : Convert actual key length value to the corresponding key length
             enum name.

  Parameter: DWORD dwKeyLength - Key length.

             ALG_ID AlgId - Algo ID.
  
             CAPICOM_ENCRYPTION_KEY_LENGTH * pKeyLengthName - Receive key length
                                                           enum name.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT KeyLengthToEnumName (DWORD                           dwKeyLength,
                             ALG_ID                          AlgId,
                             CAPICOM_ENCRYPTION_KEY_LENGTH * pKeyLengthName)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering KeyLengthToEnumName().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pKeyLengthName);

    switch (AlgId)
    {
        case CALG_AES_256:
        {
            *pKeyLengthName = CAPICOM_ENCRYPTION_KEY_LENGTH_256_BITS;
            break;
        }

        case CALG_AES_192:
        {
            *pKeyLengthName = CAPICOM_ENCRYPTION_KEY_LENGTH_192_BITS;
            break;
        }

        case CALG_AES_128:
        {
            *pKeyLengthName = CAPICOM_ENCRYPTION_KEY_LENGTH_128_BITS;
            break;
        }

        default:
        {
            switch (dwKeyLength)
            {
                case 40:
                {
                    *pKeyLengthName = CAPICOM_ENCRYPTION_KEY_LENGTH_40_BITS;
                    break;
                }
    
                case 56:
                {
                    *pKeyLengthName = CAPICOM_ENCRYPTION_KEY_LENGTH_56_BITS;
                    break;
                }

                case 128:
                {
                    *pKeyLengthName = CAPICOM_ENCRYPTION_KEY_LENGTH_128_BITS;
                    break;
                }

                default:
                {
                    hr = CAPICOM_E_INVALID_KEY_LENGTH;

                    DebugTrace("Error [%#x]: Unknown key length (%#x).\n", hr, dwKeyLength);
                }
            }
        }
    }
 
    DebugTrace("Leaving KeyLengthToEnumName().\n");

    return hr;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : EnumNameToKeyLength

  Synopsis : Convert key length enum name to the corresponding actual key length 
             value .

  Parameter: CAPICOM_ENCRYPTION_KEY_LENGTH KeyLengthName - Key length enum name.

             ALG_ID AlgId - Algorithm ID.

             DWORD * pdwKeyLength - Pointer to DWORD to receive value.
             
  Remark   :

------------------------------------------------------------------------------*/

HRESULT EnumNameToKeyLength (CAPICOM_ENCRYPTION_KEY_LENGTH KeyLengthName,
                             ALG_ID                        AlgId,
                             DWORD                       * pdwKeyLength)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering EnumNameToKeyLength().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pdwKeyLength);

    *pdwKeyLength = 0;

    switch (KeyLengthName)
    {
        case CAPICOM_ENCRYPTION_KEY_LENGTH_40_BITS:
        {
            *pdwKeyLength = 40;
            break;
        }
    
        case CAPICOM_ENCRYPTION_KEY_LENGTH_56_BITS:
        {
            *pdwKeyLength = 56;
            break;
        }

        case CAPICOM_ENCRYPTION_KEY_LENGTH_128_BITS:
        {
            *pdwKeyLength = 128;
            break;
        }

        case CAPICOM_ENCRYPTION_KEY_LENGTH_192_BITS:
        {
            *pdwKeyLength = 192;
            break;
        }

        case CAPICOM_ENCRYPTION_KEY_LENGTH_256_BITS:
        {
            *pdwKeyLength = 256;
            break;
        }

        case CAPICOM_ENCRYPTION_KEY_LENGTH_MAXIMUM:
        {
            switch (AlgId)
            {
                case CALG_AES_128:
                {
                    *pdwKeyLength = 128;
                    break;
                }

                case CALG_AES_192:
                {
                    *pdwKeyLength = 192;
                    break;
                }

                case CALG_AES_256:
                {
                    *pdwKeyLength = 256;
                    break;
                }

                default:
                {
                    DWORD dwFlags = 0;

                    //
                    // No need to access assymetric key.
                    //
                    if (IsWin2KAndAbove())
                    {
                        dwFlags = CRYPT_VERIFYCONTEXT;
                    }

                    //
                    // Find the first RSA provider that supports the specified algorithm.
                    //
                    for (DWORD i = 0; i < g_dwNumRSAProviders; i++)
                    {
                        PROV_ENUMALGS_EX peex;
                        HCRYPTPROV hCryptProv = NULL;

                        //
                        // Acquire CSP handle.
                        //
                        if (FAILED(::AcquireContext(g_rgpProviders[i].pszProvider,
                                                    NULL,
                                                    g_rgpProviders[i].dwProvType,
                                                    dwFlags, 
                                                    TRUE,
                                                    &hCryptProv)))
                        {
                            DebugTrace("Info: AcquireContext() failed for %s provider of type %#x.\n", 
                                       g_rgpProviders[i].pszProvider ? g_rgpProviders[i].pszProvider : "default",
                                       g_rgpProviders[i].dwProvType);
                            continue;
                        }

                        //
                        // Is this algorithm supported?
                        //
                        if (FAILED(::IsAlgSupported(hCryptProv, AlgId, &peex)))
                        {
                            ::CryptReleaseContext(hCryptProv, 0);

                            DebugTrace("Info: %s provider does not support AlgID = %d.\n", 
                                       g_rgpProviders[i].pszProvider ? g_rgpProviders[i].pszProvider : "default", 
                                       AlgId);
                            continue;
                        }

                        //
                        // Set key length
                        //
                        if (CALG_DES == AlgId)
                        {
                            *pdwKeyLength = 56;
                            break;
                        }
                        else if (CALG_3DES == AlgId)
                        {
                            *pdwKeyLength = 168;
                            break;
                        }
                        else if (peex.dwMaxLen >= 128)
                        {
                            *pdwKeyLength = 128;
                            break;
                        }
                        else if (peex.dwMaxLen >= 56)
                        {
                            *pdwKeyLength = 56;
                            break;
                        }
                        else if (peex.dwMaxLen >= 40)
                        {
                            *pdwKeyLength = 40;
                            break;
                        }
                    }

                    //
                    // Did wet find the CSP?
                    //
                    if (i == g_dwNumRSAProviders)
                    {
                        hr = CAPICOM_E_NOT_SUPPORTED;

                        DebugTrace("Error [%#x]: could not find a CSP that supports AlgID = %d and/or key length = 40.\n", 
                                   hr, AlgId);
                    }

                    break;
                }
            }

            break;
        }

        default:
        {
            hr = CAPICOM_E_INVALID_KEY_LENGTH;

            DebugTrace("Error [%#x]: Unknown CAPICOM_ENCRYPTION_KEY_LENGTH (%#x).\n", hr, KeyLengthName);

            break;
        }
    }

    DebugTrace("Leaving EnumNameToKeyLength().\n");

    return hr;
}

//-----------------------------------------------------------------------------
//
//  ExpandString
//
//-----------------------------------------------------------------------------

static LPWSTR ExpandString (LPCWSTR pwszString)
{
    DWORD  dwExpanded   = 0;
    LPWSTR pwszExpanded = NULL;

    //
    // Sanity check.
    //
    ATLASSERT(pwszString);

    dwExpanded = ::ExpandEnvironmentStringsU(pwszString, NULL, 0);
    
    if (!(pwszExpanded = (LPWSTR) ::CoTaskMemAlloc(dwExpanded * sizeof(WCHAR))))
    {
        SetLastError((DWORD) E_OUTOFMEMORY);
        return (NULL);
    }

    if (0 == ExpandEnvironmentStringsU(pwszString, pwszExpanded, dwExpanded))
    {
        ::CoTaskMemFree(pwszExpanded);
        return (NULL);
    }

    return (pwszExpanded);
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : IsDiskFile

  Synopsis : Check if a the file name represents a disk file.

  Parameter: LPWSTR pwszFileName - File name.
  
  Remark   :

------------------------------------------------------------------------------*/

HRESULT IsDiskFile (LPWSTR pwszFileName)
{
    HRESULT hr                   = S_OK;
    HANDLE  hFile                = INVALID_HANDLE_VALUE;
    LPWSTR  pwszExpandedFileName = NULL;
    DWORD   dwFileType           = FILE_TYPE_UNKNOWN;

    DebugTrace("Entering IsDiskFile().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pwszFileName);

    //
    // Expand filename string.
    //
    if (!(pwszExpandedFileName = ::ExpandString(pwszFileName)))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: ExpandString() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Open for generic read.
    //
    if (INVALID_HANDLE_VALUE == (hFile = ::CreateFileU(pwszExpandedFileName,
                                                       GENERIC_READ,
                                                       FILE_SHARE_READ,
                                                       NULL,
                                                       OPEN_EXISTING,
                                                       FILE_ATTRIBUTE_NORMAL,
                                                       NULL)))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CreateFileU() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Make sure it is a disk file.
    //
    if (FILE_TYPE_DISK != (dwFileType = ::GetFileType(hFile)))
    {
        hr = E_INVALIDARG;

        DebugTrace("Error [%#x]: Not a disk file (%#x).\n", hr, dwFileType);
        goto ErrorExit;
    }

CommonExit:
    //
    // Free resources.
    //
    if (hFile && hFile != INVALID_HANDLE_VALUE)
    {
        ::CloseHandle(hFile);
    }
    if (pwszExpandedFileName)
    {
        ::CoTaskMemFree((LPVOID) pwszExpandedFileName);
    }

    DebugTrace("Leaving IsDiskFile().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : ReadFileContent

  Synopsis : Read all bytes from the specified file.

  Parameter: LPWSTR pwszFileName - File name.
  
             DATA_BLOB * pDataBlob - Pointer to DATA_BLOB to receive the
                                     file content.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT ReadFileContent (LPWSTR      pwszFileName,
                         DATA_BLOB * pDataBlob)
{
    HRESULT hr                   = S_OK;
    DWORD   cbData               = 0;
    DWORD   cbHighSize           = 0;
    HANDLE  hFile                = INVALID_HANDLE_VALUE;
    HANDLE  hFileMapping         = NULL;
    LPWSTR  pwszExpandedFileName = NULL;
    LPBYTE  pbData               = NULL;
    DWORD   dwFileType           = FILE_TYPE_UNKNOWN;

    DebugTrace("Entering ReadFileContent().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pwszFileName);
    ATLASSERT(pDataBlob);

    //
    // Expand filename string.
    //
    if (!(pwszExpandedFileName = ::ExpandString(pwszFileName)))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: ExpandString() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Open for generic read.
    //
    if (INVALID_HANDLE_VALUE == (hFile = ::CreateFileU(pwszExpandedFileName,
                                                       GENERIC_READ,
                                                       FILE_SHARE_READ,
                                                       NULL,
                                                       OPEN_EXISTING,
                                                       FILE_ATTRIBUTE_NORMAL,
                                                       NULL)))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CreateFileU() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Make sure it is a disk file.
    //
    if (FILE_TYPE_DISK != (dwFileType = ::GetFileType(hFile)))
    {
        hr = E_INVALIDARG;

        DebugTrace("Error [%#x]: Not a disk file (%#x).\n", hr, dwFileType);
        goto ErrorExit;
    }

    //
    // Get file size.
    //
    if ((cbData = ::GetFileSize(hFile, &cbHighSize)) == 0xffffffff)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: GetFileSize() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // We do not handle file more than 4G bytes.
    //
    if (cbHighSize != 0)
    {
        hr = E_FAIL;

        DebugTrace("Error [%#x]: File size greater 4G bytes.\n", hr);
        goto ErrorExit;
    }

    //
    // Create a file mapping object.
    //
    if (NULL == (hFileMapping = ::CreateFileMapping(hFile,
                                                    NULL,
                                                    PAGE_READONLY,
                                                    0,
                                                    0,
                                                    NULL)))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CreateFileMapping() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Now create a view of the file.
    //
    if (NULL == (pbData = (BYTE *) ::MapViewOfFile(hFileMapping,
                                                   FILE_MAP_READ,
                                                   0,
                                                   0,
                                                   cbData)))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: MapViewOfFile() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Return data to caller.
    //
    pDataBlob->cbData = cbData;
    pDataBlob->pbData = pbData;

CommonExit:
    //
    // Free resources.
    //
    if (hFile && hFile != INVALID_HANDLE_VALUE)
    {
        ::CloseHandle(hFile);
    }
    if (hFileMapping)
    {
        ::CloseHandle(hFileMapping);
    }
    if (pwszExpandedFileName)
    {
        ::CoTaskMemFree((LPVOID) pwszExpandedFileName);
    }

    DebugTrace("Leaving ReadFileContent().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : WriteFileContent

  Synopsis : Write all bytes of blob to the specified file.

  Parameter: LPWSTR pwszFileName - File name.
  
             DATA_BLOB DataBlob - Blob to be written.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT WriteFileContent(LPCWSTR   pwszFileName,
                         DATA_BLOB DataBlob)
{
    HRESULT hr                   = S_OK;
    HANDLE  hFile                = NULL;
    DWORD   dwBytesWritten       = 0;
    LPWSTR  pwszExpandedFileName = NULL;
    DWORD   dwFileType           = FILE_TYPE_UNKNOWN;

    DebugTrace("Entering WriteFileContent().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pwszFileName);
    ATLASSERT(DataBlob.cbData);
    ATLASSERT(DataBlob.pbData);

    //
    // Expand filename string.
    //
    if (!(pwszExpandedFileName = ::ExpandString(pwszFileName)))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: ExpandString() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Open for generic write.
    //
    if (INVALID_HANDLE_VALUE == (hFile = ::CreateFileU(pwszExpandedFileName,
                                                       GENERIC_WRITE,
                                                       0,
                                                       NULL,
                                                       CREATE_ALWAYS,
                                                       FILE_ATTRIBUTE_NORMAL,
                                                       NULL)))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CreateFileU() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Make sure it is a disk file.
    //
    if (FILE_TYPE_DISK != (dwFileType = ::GetFileType(hFile)))
    {
        hr = E_INVALIDARG;

        DebugTrace("Error [%#x]: Invalid file type (%#x).\n", hr, dwFileType);
        goto ErrorExit;
    }

    //
    // Now write it out.
    //
    if (!::WriteFile(hFile, DataBlob.pbData, DataBlob.cbData, &dwBytesWritten, NULL))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CreateFileU() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Make sure we wrote everything out.
    //
    if (dwBytesWritten != DataBlob.cbData)
    {
        hr = E_FAIL;

        DebugTrace("Error [%#x]: Not able to write all data (only partial).\n", hr);
        goto ErrorExit;
    }

CommonExit:
    //
    // Free resources.
    //
    if (hFile && hFile != INVALID_HANDLE_VALUE)
    {
        ::CloseHandle(hFile);
    }
    if (pwszExpandedFileName)
    {
        ::CoTaskMemFree((LPVOID) pwszExpandedFileName);
    }

    DebugTrace("Leaving WriteFileContent().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\convert.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows

  Copyright (C) Microsoft Corporation, 1995 - 1999.

  File:       Convert.cpp

  Contents:   Implementation of encoding conversion routines.

  History:    11-15-99    dsie     created

------------------------------------------------------------------------------*/

#define _CRYPT32_  // This is required to statically link in pkifmt.lib.

#include "StdAfx.h"
#include "CAPICOM.h"
#include "Convert.h"
#include "Base64.h"

#include <ctype.h>

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : UnicodeToAnsi

  Synopsis : Convert an array of unicode character to ANSI.

  Parameter: LPWSTR pwszUnicodeString - Pointer to Unicode string to be
                                        converted to ANSI string.

             int cchWideChar - Number of characters, or -1 if 
                               pwszUnicodeString is NULL terminated.

             LPSTR * ppszAnsiString - Pointer to LPSTR to received the
                                      converted ANSI string.

             int * pcchAnsiChar (Optional) - Pointer to int to receive 
                                             the number of characters 
                                             translated.
  
  Remark   : Caller must call CoTaskMemFree to free the returned ANSI string.

------------------------------------------------------------------------------*/

HRESULT UnicodeToAnsi (LPWSTR  pwszUnicodeString, 
                       int     cchWideChar,
                       LPSTR * ppszAnsiString,
                       int   * pcchAnsiChar)
{
    HRESULT hr            = S_OK;
    int     cchAnsiChar   = 0;
    LPSTR   pszAnsiString = NULL;

    DebugTrace("Entering UnicodeToAnsi().\n");

    //
    // Make sure parameter is valid.
    //
    if (NULL == pwszUnicodeString || NULL == ppszAnsiString)
    {
        hr = E_INVALIDARG;

        DebugTrace("Error [%#x]: pwszUnicodeString = %#x, ppszAnsiString = %#x.\n", 
                    hr, pwszUnicodeString, ppszAnsiString);
        goto ErrorExit;
    }

    //
    // Determine ANSI length.
    //
    cchAnsiChar = ::WideCharToMultiByte(CP_ACP,            // code page
                                        0,                 // performance and mapping flags
                                        pwszUnicodeString, // wide-character string
                                        cchWideChar,       // number of chars in string
                                        NULL,              // buffer for new string
                                        0,                 // size of buffer
                                        NULL,              // default for unmappable chars
                                        NULL);             // set when default char used
    if (0 == cchAnsiChar)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: WideCharToMultiByte() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Allocate memory for ANSI string.
    //
    if (!(pszAnsiString = (LPSTR) ::CoTaskMemAlloc(cchAnsiChar)))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Error [%#x]: CoTaskMemAlloc() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Conver to ANSI.
    //
    cchAnsiChar = ::WideCharToMultiByte(CP_ACP,
                                        0,
                                        pwszUnicodeString,
                                        cchWideChar,
                                        pszAnsiString,
                                        cchAnsiChar,
                                        NULL,
                                        NULL);
    if (0 == cchAnsiChar)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: WideCharToMultiByte() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Return values to caller.
    //
    if (pcchAnsiChar)
    {
        *pcchAnsiChar = cchAnsiChar;
    }

    *ppszAnsiString = pszAnsiString;

CommonExit:

    DebugTrace("Leaving UnicodeToAnsi().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resources.
    //
    if (pszAnsiString)
    {
        ::CoTaskMemFree(pszAnsiString);
    }

    goto CommonExit;
}

#if (0)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AnsiToUnicode

  Synopsis : Convert a array of ANSI character to Unicode.

  Parameter: LPSTR pszAnsiString - Pointer to ANSI string to be converted to 
                                   ANSI string.

             DWORD cchAnsiChar - Number of characters, or -1 if pszAnsiString 
                                 is NULL terminated.

             LPWSTR * ppwszUnicodeString - Pointer to LPWSTR to received the
                                           converted Unicode string.

             DWORD * pcchUnicodeChar (Optional) - Pointer to DWORD to receive 
                                                  the number of characters 
                                                  translated.
  
  Remark   : Caller must call CoTaskMemFree to free the returned Unicode string.

------------------------------------------------------------------------------*/

HRESULT AnsiToUnicode (LPSTR    pszAnsiString, 
                       DWORD    cchAnsiChar,
                       LPWSTR * ppwszUnicodeString,
                       DWORD  * pcchUnicodeChar)
{
    HRESULT hr                = S_OK;
    DWORD   cchUnicodeChar    = 0;
    LPWSTR  pwszUnicodeString = NULL;

    DebugTrace("Entering AnsiToUnicode().\n");

    //
    // Make sure parameter is valid.
    //
    if (NULL == pszAnsiString || NULL == ppwszUnicodeString)
    {
        hr = E_INVALIDARG;

        DebugTrace("Error [%#x]: pszAnsiString = %#x, ppwszUnicodeString = %#x.\n", 
                    hr, pszAnsiString, ppwszUnicodeString);
        goto ErrorExit;
    }

    //
    // Determine Unicode length.
    //
    cchUnicodeChar = ::MultiByteToWideChar(CP_ACP,                // code page
                                           0,                     // performance and mapping flags
                                           pszAnsiString,         // ANSI string
                                           cchAnsiChar,           // number of chars in string
                                           NULL,                  // buffer for new Unicode string
                                           0);                    // size of buffer
    if (0 == cchUnicodeChar)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: MultiByteToWideChar() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Allocate memory for Unicode string.
    //
    if (!(pwszUnicodeString = (LPWSTR) ::CoTaskMemAlloc(cchUnicodeChar * sizeof(WCHAR))))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Error [%#x]: CoTaskMemAlloc() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Conver to ANSI.
    //
    cchUnicodeChar = ::MultiByteToWideChar(CP_ACP,
                                           0,
                                           pszAnsiString,
                                           cchAnsiChar,
                                           pwszUnicodeString,
                                           cchUnicodeChar);
    if (0 == cchUnicodeChar)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: MultiByteToWideChar() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Return values to caller.
    //
    if (pcchUnicodeChar)
    {
        *pcchUnicodeChar = cchUnicodeChar;
    }

    *ppwszUnicodeString = pwszUnicodeString;

CommonExit:

    DebugTrace("Leaving AnsiToUnicode().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resources.
    //
    if (pwszUnicodeString)
    {
        ::CoTaskMemFree(pwszUnicodeString);
    }

    goto CommonExit;
}
#endif

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : ByteToHex

  Synopsis : Convert a byte to hex character.

  Parameter: BYTE byte - Byte to be converted.
  
  Remark   : Data must be valid, i.e. 0 through 15.

------------------------------------------------------------------------------*/

static inline WCHAR ByteToHex (BYTE byte)
{
    ATLASSERT(byte < 16);

    if(byte < 10)
    {
        return (WCHAR) (byte + L'0');
    }
    else
    {
        return (WCHAR) ((byte - 10) + L'A');
    }
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : HexToByte

  Synopsis : Convert a hex character to byte.

  Parameter: WCHAR wc - Hex character to be converted.
  
  Remark   : 0xff is returned if wc is not a hex character.

------------------------------------------------------------------------------*/

static inline BYTE HexToByte (WCHAR wc)
{
    BYTE b;

    if (!iswxdigit(wc))
    {
        return (BYTE) 0xff;
    }

    if (iswdigit(wc))
    {
        b = (BYTE) (wc - L'0');
    }
    else if (iswupper(wc))
    {
        b = (BYTE) (wc - L'A' + 10);
    }
    else
    {
        b = (BYTE) (wc - L'a' + 10);
    }

    return (b);
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : IntBlobToHexString

  Synopsis : Convert an interger blob to hex string.

  Parameter: BYTE byte - Byte to be converted.
  
  Remark   :

------------------------------------------------------------------------------*/

HRESULT IntBlobToHexString (CRYPT_INTEGER_BLOB * pBlob, BSTR * pbstrHex)
{
    HRESULT hr       = S_OK;
    LPWSTR  pwszStr  = NULL;
    LPWSTR  pwszTemp = NULL;
    DWORD   cbData   = 0;

    DebugTrace("Entering IntBlobToHexString().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pBlob);
    ATLASSERT(pbstrHex);

    try
    {
        //
        // Make sure parameters are valid.
        //
        if (!pBlob->cbData || !pBlob->pbData)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error: invalid parameter, empty integer blob.\n");
            goto ErrorExit;
        }

        //
        // Allocate memory (Need 2 wchars for each byte, plus a NULL character).
        //
        if (NULL == (pwszStr = (LPWSTR) ::CoTaskMemAlloc((pBlob->cbData * 2 + 1) * sizeof(WCHAR))))
        {
            hr = E_OUTOFMEMORY;
            
            DebugTrace("Error: out of memory.\n");
            goto ErrorExit;
        }

        //
        // Now convert it to hex string (Remember data is stored in little-endian).
        //
        pwszTemp = pwszStr;
        cbData = pBlob->cbData;

        while (cbData--)
        {
            //
            // Get the byte.
            //
            BYTE byte = pBlob->pbData[cbData];
    
            //
            // Convert upper nibble.
            //
            *pwszTemp++ = ::ByteToHex((BYTE) ((byte & 0xf0) >> 4));

            //
            // Conver lower nibble.
            //
            *pwszTemp++ = ::ByteToHex((BYTE) (byte & 0x0f));
        }

        //
        // NULL terminate it.
        //
        *pwszTemp = L'\0';

        //
        // Return BSTR to caller.
        //
        if (NULL == (*pbstrHex = ::SysAllocString(pwszStr)))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error: out of memory.\n");
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:
    //
    // Free resources.
    //
    if (pwszStr)
    {
        ::CoTaskMemFree(pwszStr);
    }

    DebugTrace("Leaving IntBlobToHexString().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : BinaryToHexString

  Synopsis : Convert binary data to hex string.

  Parameter: BYTE * pbBytes - Bytes to be converted.

             DWORD cBytes - Number of bytes to be converted.

             BSTR * pbstrHex - Pointer to BSTR to received converted hex string.
  
  Remark   :

------------------------------------------------------------------------------*/

HRESULT BinaryToHexString (BYTE * pbBytes, DWORD cBytes, BSTR * pbstrHex)
{
    HRESULT hr = S_OK;
    LPWSTR  pwszTemp  = NULL;
    LPWSTR  pwszStr   = NULL;

    DebugTrace("Entering BinaryToHexString().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pbBytes);
    ATLASSERT(pbstrHex);

    //
    // Allocate memory. (Need 2 wchars for each byte, plus a NULL character).
    //
    if (NULL == (pwszStr = (LPWSTR) ::CoTaskMemAlloc((cBytes * 2 + 1) * sizeof(WCHAR))))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Error: out of memory.\n");
        goto ErrorExit;
    }

    //
    // Now convert it to hex string.
    //
    pwszTemp = pwszStr;

    while (cBytes--)
    {
        //
        // Get the byte.
        //
        BYTE byte = *pbBytes++;
    
        //
        // Convert upper nibble.
        //
        *pwszTemp++ = ::ByteToHex((BYTE) ((byte & 0xf0) >> 4));

        //
        // Conver lower nibble.
        //
        *pwszTemp++ = ::ByteToHex((BYTE) (byte & 0x0f));
    }

    //
    // NULL terminate it.
    //
    *pwszTemp = L'\0';

    //
    // Return BSTR to caller.
    //
    if (NULL == (*pbstrHex = ::SysAllocString(pwszStr)))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Error [%#x]: SysAllocString() failed.\n", hr);
        goto ErrorExit;
    }

CommonExit:
    //
    // Free resources.
    //
    if (pwszStr)
    {
        ::CoTaskMemFree(pwszStr);
    }

    DebugTrace("Leaving BinaryToHexString().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : HexToBinaryString

  Synopsis : Convert hex string to binary data.

  Parameter: BSTR bstrHex - Hex string to be converted.

             BSTR * pbstrBinary - Pointer to BSTR to received converted string.
  
  Remark   :

------------------------------------------------------------------------------*/

HRESULT HexToBinaryString (BSTR bstrHex, BSTR * pbstrBinary)
{
    HRESULT hr       = S_OK;
    LPWSTR  pwszHex  = NULL;
    LPSTR   pbBinary = NULL;

    DebugTrace("Entering HexToBinaryString().\n");

    //
    // Sanity check.
    //
    ATLASSERT(bstrHex);
    ATLASSERT(pbstrBinary);

    DWORD i;
    DWORD cchHex = ::SysStringLen(bstrHex);

    //
    // Make sure even number of hex chars.
    //
    if (cchHex & 0x00000001)
    {
        hr = E_INVALIDARG;

        DebugTrace("Error [%#x]: bstrHex does not contain even number of characters.\n", hr);
        goto ErrorExit;
    }

    //
    // Allocate memory. (Need 1 byte for two hex chars).
    //
    cchHex /= 2;
    if (NULL == (pbBinary = (LPSTR) ::CoTaskMemAlloc(cchHex)))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Error [%#x]: CoTaskMemAlloc() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Now convert it to binary.
    //
    pwszHex = bstrHex;
    for (i = 0; i < cchHex; i++)
    {
        //
        // Convert upper and lower nibbles.
        //
#if (0) // DSIE - Work around compiler's bug.
        pbBinary[i] = (BYTE) ((::HexToByte(*pwszHex++) << 4) | ::HexToByte(*pwszHex++));
#else
        pbBinary[i] = (BYTE) ((::HexToByte(*pwszHex) << 4) | ::HexToByte(*(pwszHex + 1)));
        pwszHex += 2;
#endif
    }

    //
    // Return BSTR to caller.
    //
    if (NULL == (*pbstrBinary = ::SysAllocStringByteLen(pbBinary, cchHex)))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Error [%#x]: SysAllocStringByteLen() failed.\n", hr);
        goto ErrorExit;
    }

CommonExit:
    //
    // Free resources.
    //
    if (pbBinary)
    {
        ::CoTaskMemFree(pbBinary);
    }

    DebugTrace("Leaving HexToBinaryString().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : StringToBinary

  Synopsis : Convert a formatted string to binary value.

  Parameter: LPCWSTR pwszString - Pointer to string to be converted.

             DWORD  cchString - Number of characters in pwszString.

             DWORD dwFormat - Conversion format (See WinCrypt.h).

             PBYTE * ppbBinary - Pointer to pointer to buffer to hold binary
                                 data.

             DWORD * pdwBinary - Number of bytes in the binary buffer.

  Remark   : Caller free the buffer by calling CoTaskMemFree().

------------------------------------------------------------------------------*/

HRESULT StringToBinary (LPCWSTR pwszString, 
                        DWORD   cchString,
                        DWORD   dwFormat,
                        PBYTE * ppbBinary,
                        DWORD * pdwBinary)
{
    HRESULT hr       = S_OK;
    PBYTE   pbBinary = NULL;
    DWORD   dwBinary = 0;

    DebugTrace("Entering StringToBinary().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pwszString);

    if (!::CryptStringToBinaryW(pwszString, 
                                cchString, 
                                dwFormat, 
                                NULL, 
                                &dwBinary, 
                                NULL, 
                                NULL))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptStringToBinaryW() failed.\n", hr);
        goto ErrorExit;
    }

    if (pdwBinary)
    {
        *pdwBinary = dwBinary;
    }

    if (ppbBinary)
    {
        if (NULL == (pbBinary = (PBYTE) ::CoTaskMemAlloc(dwBinary)))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error [%#x]: CoTaskMemAlloc() failed.\n", hr);
            goto ErrorExit;
        }

        if (!::CryptStringToBinaryW(pwszString, 
                                    cchString, 
                                    dwFormat, 
                                    pbBinary, 
                                    &dwBinary, 
                                    NULL, 
                                    NULL))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptStringToBinaryW() failed.\n", hr);
            goto ErrorExit;
        }
    
        *ppbBinary = pbBinary;
    }

CommonExit:

    DebugTrace("Leaving StringToBinary().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resources.
    //
    if (pbBinary)
    {
        ::CoTaskMemFree(pbBinary);
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : BinaryToString

  Synopsis : Convert a binary value to formatted string.

  Parameter: PBYTE pbBinary - Pointer to buffer of binary data.

             DWORD cbBinary - Number of bytes in the binary buffer.

             DWORD dwFormat - Conversion format (See WinCrypt.h).

             BSTR * pbstrString - Pointer to BSTR to receive converted
                                  string.

             DWORD * pcchString - Number of characters in *pbstrString.
             
  Remark   : Caller free the string by calling SysFreeString().

------------------------------------------------------------------------------*/

HRESULT BinaryToString (PBYTE   pbBinary,
                        DWORD   cbBinary,
                        DWORD   dwFormat,
                        BSTR  * pbstrString, 
                        DWORD * pcchString)
{
    HRESULT hr         = S_OK;
    DWORD   cchString  = 0;
    PWSTR   pwszString = NULL;

    DebugTrace("Entering BinaryToString().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pbBinary);

    if (!::CryptBinaryToStringW(pbBinary,
                                cbBinary,
                                dwFormat, 
                                NULL, 
                                &cchString))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptBinaryToStringW() failed.\n", hr);
        goto ErrorExit;
    }

    if (pbstrString)
    {
        //
        // Sanity check.
        //
        ATLASSERT(cchString);

        //
        // Allocate memory.
        //
        if (NULL == (pwszString = (LPWSTR) ::CoTaskMemAlloc(cchString * sizeof(WCHAR))))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error [%#x]: CoTaskMemAlloc() failed.\n", hr);
            goto ErrorExit;
        }

        if (!::CryptBinaryToStringW(pbBinary,
                                    cbBinary,
                                    dwFormat, 
                                    pwszString, 
                                    &cchString))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptBinaryToStringW() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return base64 encoded string to caller.
        //
        if (NULL == (*pbstrString = ::SysAllocString(pwszString)))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error [%#x]: SysAllocString() failed.\n", hr);
            goto ErrorExit;
        }
    }

    if (pcchString)
    {
        *pcchString = cchString;
    }

CommonExit:
    //
    // Free resources.
    //
    if (pwszString)
    {
        ::CoTaskMemFree((LPVOID) pwszString);
    }

    DebugTrace("Leaving BinaryToString().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : BlobToBstr

  Synopsis : Convert a blob to BSTR.

  Parameter: DATA_BLOB * pDataBlob - Pointer to blob to be converted to BSTR.

             BSTR * lpBstr - Pointer to BSTR to receive the converted BSTR.

  Remark   : Caller free allocated memory for the returned BSTR.

------------------------------------------------------------------------------*/

HRESULT BlobToBstr (DATA_BLOB * pDataBlob, 
                    BSTR      * lpBstr)
{
    //
    // Return NULL if requested.
    //
    if (!lpBstr)
    {
        DebugTrace("Error: invalid parameter, lpBstr is NULL.\n");
        return E_INVALIDARG;
    }

    //
    // Make sure parameter is valid.
    //
    if (!pDataBlob->cbData || !pDataBlob->pbData)
    {
        *lpBstr = NULL;
        return S_OK;
    }

    //
    // Convert to BSTR without code page conversion.
    //
    if (!(*lpBstr = ::SysAllocStringByteLen((LPCSTR) pDataBlob->pbData, pDataBlob->cbData)))
    {
        DebugTrace("Error: out of memory.\n");
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : BstrToBlob

  Synopsis : Convert a BSTR to blob.

  Parameter: BSTR bstr - BSTR to be converted to blob.
  
             DATA_BLOB * lpBlob - Pointer to DATA_BLOB to receive converted blob.

  Remark   : Caller free allocated memory for the returned BLOB.

------------------------------------------------------------------------------*/

HRESULT BstrToBlob (BSTR        bstr, 
                    DATA_BLOB * lpBlob)
{
    //
    // Sanity check.
    //
    ATLASSERT(lpBlob);

    //
    // Return NULL if requested.
    //
    if (0 == ::SysStringByteLen(bstr))
    {
        lpBlob->cbData = 0;
        lpBlob->pbData = NULL;
        return S_OK;
    }

    //
    // Allocate memory.
    //
    lpBlob->cbData = ::SysStringByteLen(bstr);
    if (!(lpBlob->pbData = (LPBYTE) ::CoTaskMemAlloc(lpBlob->cbData)))
    {
        DebugTrace("Error: out of memory.\n");
        return E_OUTOFMEMORY;
    }

    //
    // Convert to blob without code page conversion.
    //
    ::CopyMemory(lpBlob->pbData, (LPBYTE) bstr, lpBlob->cbData);

    return S_OK;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : ExportData

  Synopsis : Export binary data to a BSTR with specified encoding type.

  Parameter: DATA_BLOB DataBlob - Binary data blob.
    
             CAPICOM_ENCODING_TYPE EncodingType - Encoding type.

             BSTR * pbstrEncoded - Pointer to BSTR to receive the encoded data.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT ExportData (DATA_BLOB             DataBlob, 
                    CAPICOM_ENCODING_TYPE EncodingType, 
                    BSTR *                pbstrEncoded)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering ExportData().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pbstrEncoded);
    
    //
    // Intialize.
    //
    *pbstrEncoded = NULL;

    //
    // Make sure there is something to convert.
    //
    if (DataBlob.cbData)
    {
        //
        // Sanity check.
        //
        ATLASSERT(DataBlob.pbData);

        //
        // Determine encoding type.
        //
        switch (EncodingType)
        {
            case CAPICOM_ENCODE_ANY:
            {
                //
                // Fall through to base64.
                //
            }

            case CAPICOM_ENCODE_BASE64:
            {
                //
                // Base64 encode.
                //
                if (FAILED(hr = ::Base64Encode(DataBlob, pbstrEncoded)))
                {
                    DebugTrace("Error [%#x]: Base64Encode() failed.\n", hr);
                    goto ErrorExit;
                }

                break;
            }

            case CAPICOM_ENCODE_BINARY:
            {
                //
                // No encoding needed, simply convert blob to bstr.
                //
                if (FAILED(hr = ::BlobToBstr(&DataBlob, pbstrEncoded)))
                {
                    DebugTrace("Error [%#x]: BlobToBstr() failed.\n", hr);
                    goto ErrorExit;
                }

                break;
            }

            default:
            {
                hr = CAPICOM_E_ENCODE_INVALID_TYPE;

                DebugTrace("Error [%#x]: invalid CAPICOM_ENCODING_TYPE.\n", hr);
                goto ErrorExit;
            }
        }
    }

CommonExit:

    DebugTrace("Leaving ExportData().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : ImportData

  Synopsis : Import encoded data.

  Parameter: BSTR bstrEncoded - BSTR containing the data to be imported.

             CAPICOM_ENCODING_TYPE EncodingType - Encoding type.
             
             DATA_BLOB * pDataBlob - Pointer to DATA_BLOB to receive the
                                     decoded data.
  
  Remark   : There is no need for encoding type parameter, as the encoding type
             will be determined automatically by this routine.

------------------------------------------------------------------------------*/

HRESULT ImportData (BSTR                  bstrEncoded,
                    CAPICOM_ENCODING_TYPE EncodingType,
                    DATA_BLOB           * pDataBlob)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering ImportData().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pDataBlob);
    ATLASSERT(bstrEncoded);

    //
    // Initialize.
    //
    ::ZeroMemory((void *) pDataBlob, sizeof(DATA_BLOB));

    //
    // Which encoding type?
    //
    switch (EncodingType)
    {
        case CAPICOM_ENCODE_BASE64:
        {
            //
            // Decode data.
            //
            if (FAILED(hr = ::Base64Decode(bstrEncoded, pDataBlob)))
            {
                DebugTrace("Error [%#x]: Base64Decode() failed.\n", hr);
                goto ErrorExit;
            }

            break;
        }

        case CAPICOM_ENCODE_BINARY:
        {
            //
            // Decode data.
            //
            if (FAILED(hr = ::BstrToBlob(bstrEncoded, pDataBlob)))
            {
                DebugTrace("Error [%#x]: BstrToBlob() failed.\n", hr);
                goto ErrorExit;
            }

            break;
        }

        case CAPICOM_ENCODE_ANY:
        {
            //
            // Try base64 first.
            //
            if (FAILED(hr = ::Base64Decode(bstrEncoded, pDataBlob)))
            {
                //
                // Try HEX.
                //
                hr = S_OK;
                DebugTrace("Info [%#x]: Base64Decode() failed, try HEX.\n", hr);

                if (FAILED(hr = ::StringToBinary(bstrEncoded,
                                                 ::SysStringLen(bstrEncoded),
                                                 CRYPT_STRING_HEX,
                                                 &pDataBlob->pbData,
                                                 &pDataBlob->cbData)))
                {
                    //
                    // Try binary.
                    //
                    hr = S_OK;
                    DebugTrace("Info [%#x]: All known decoding failed, so assume binary.\n", hr);

                    if (FAILED(hr = ::BstrToBlob(bstrEncoded, pDataBlob)))
                    {
                        DebugTrace("Error [%#x]: BstrToBlob() failed.\n", hr);
                        goto ErrorExit;
                    }
                }
            }

            break;
        }

        default:
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: invalid encoding type (%d).\n", hr, EncodingType);
            goto ErrorExit;
        }
    }

CommonExit:

    DebugTrace("Leaving ImportData().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\convert.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows

  Copyright (C) Microsoft Corporation, 1995 - 1999.

  File:       Convert.h

  Content:    Declaration of convertion routines.

  History:    11-15-99    dsie     created

------------------------------------------------------------------------------*/

#ifndef __CONVERT_H_
#define __CONVERT_H_

#include "Debug.h"

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : UnicodeToAnsi

  Synopsis : Convert an array of unicode character to ANSI.

  Parameter: LPWSTR pwszUnicodeString - Pointer to Unicode string to be
                                        converted to ANSI string.

             int cchWideChar - Number of characters, or -1 if 
                               pwszUnicodeString is NULL terminated.

             LPSTR * ppszAnsiString - Pointer to LPSTR to received the
                                      converted ANSI string.

             int * pcchAnsiChar (Optional) - Pointer to int to receive 
                                             the number of characters 
                                             translated.
  
  Remark   : Caller must call CoTaskMemFree to free the returned ANSI string.

------------------------------------------------------------------------------*/

HRESULT UnicodeToAnsi (LPWSTR  pwszUnicodeString, 
                       int     cchWideChar,
                       LPSTR * ppszAnsiString,
                       int   * pcchAnsiChar);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AnsiToUnicode

  Synopsis : Convert a array of ANSI character to Unicode.

  Parameter: LPSTR pszAnsiString - Pointer to ANSI string to be converted to 
                                   ANSI string.

             DWORD cchAnsiChar - Number of characters, or -1 if pszAnsiString 
                                 is NULL terminated.

             LPWSTR * ppwszUnicodeString - Pointer to LPWSTR to received the
                                           converted Unicode string.

             DWORD * pcchUnicodeChar (Optional) - Pointer to DWORD to receive 
                                                  the number of characters 
                                                  translated.
  
  Remark   : Caller must call CoTaskMemFree to free the returned Unicode string.

------------------------------------------------------------------------------*/

HRESULT AnsiToUnicode (LPSTR    pszAnsiString, 
                       DWORD    cchAnsiChar,
                       LPWSTR * ppwszUnicodeString,
                       DWORD  * pcchUnicodeChar);
                       
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : IntBlobToHexString

  Synopsis : Convert an interger blob to hex string.

  Parameter: BYTE byte - Byte to be converted.
  
  Remark   :

------------------------------------------------------------------------------*/

HRESULT IntBlobToHexString (CRYPT_INTEGER_BLOB * pBlob, BSTR * pbstrHex);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : BinaryToHexString

  Synopsis : Convert binary data to hex string.

  Parameter: BYTE * pbBytes - Bytes to be converted.

             DWORD cBytes - Number of bytes to be converted.

             BSTR * pbstrHex - Pointer to BSTR to received converted hex string.
  
  Remark   :

------------------------------------------------------------------------------*/

HRESULT BinaryToHexString (BYTE * pbBytes, DWORD cBytes, BSTR * pbstrHex);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : HexToBinaryString

  Synopsis : Convert hex string to binary data.

  Parameter: BSTR bstrHex - Hex string to be converted.

             BSTR * pbstrBinary - Pointer to BSTR to received converted string.
  
  Remark   :

------------------------------------------------------------------------------*/

HRESULT HexToBinaryString (BSTR bstrHex, BSTR * pbstrBinary);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : StringToBinary

  Synopsis : Convert a formatted string to binary value.

  Parameter: LPCWSTR pwszString - Pointer to string to be converted.

             DWORD  cchString - Number of characters in pwszString.

             DWORD dwFormat - Conversion format (See WinCrypt.h).

             PBYTE * ppbBinary - Pointer to pointer to buffer to hold binary
                                 data.

             DWORD * pdwBinary - Number of bytes in the binary buffer.

  Remark   : Caller free the buffer by calling CoTaskMemFree().

------------------------------------------------------------------------------*/

HRESULT StringToBinary (LPCWSTR pwszString, 
                        DWORD   cchString,
                        DWORD   dwFormat,
                        PBYTE * ppbBinary,
                        DWORD * pdwBinary);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : BinaryToString

  Synopsis : Convert a binary value to formatted string.

  Parameter: PBYTE pbBinary - Pointer to buffer of binary data.

             DWORD cbBinary - Number of bytes in the binary buffer.

             DWORD dwFormat - Conversion format (See WinCrypt.h).

             BSTR * pbstrString - Pointer to BSTR to receive converted
                                  string.

             DWORD * pcchString - Number of characters in *pbstrString.
             
  Remark   : Caller free the string by calling SysFreeString().

------------------------------------------------------------------------------*/

HRESULT BinaryToString (PBYTE   pbBinary,
                        DWORD   cbBinary,
                        DWORD   dwFormat,
                        BSTR  * pbstrString, 
                        DWORD * pcchString);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : BlobToBstr

  Synopsis : Convert a blob to BSTR.

  Parameter: DATA_BLOB * pDataBlob - Pointer to blob to be converted to BSTR.

             BSTR * lpBstr - Pointer to BSTR to receive the converted BSTR.

  Remark   : Caller free allocated memory for the returned BSTR.

------------------------------------------------------------------------------*/

HRESULT BlobToBstr (DATA_BLOB * pDataBlob, 
                    BSTR      * lpBstr);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : BstrToBlob

  Synopsis : Convert a BSTR to blob.

  Parameter: BSTR bstr - BSTR to be converted to blob.
  
             DATA_BLOB * lpBlob - Pointer to DATA_BLOB to receive converted blob.

  Remark   : Caller free allocated memory for the returned BLOB.

------------------------------------------------------------------------------*/

HRESULT BstrToBlob (BSTR        bstr, 
                    DATA_BLOB * lpBlob);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : ExportData

  Synopsis : Export binary data to a BSTR with specified encoding type.

  Parameter: DATA_BLOB DataBlob - Binary data blob.
    
             CAPICOM_ENCODING_TYPE EncodingType - Encoding type.

             BSTR * pbstrEncoded - Pointer to BSTR to receive the encoded data.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT ExportData (DATA_BLOB             DataBlob, 
                    CAPICOM_ENCODING_TYPE EncodingType, 
                    BSTR *                pbstrEncoded);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : ImportData

  Synopsis : Import encoded data.

  Parameter: BSTR bstrEncoded - BSTR containing the data to be imported.

             CAPICOM_ENCODING_TYPE EncodingType - Encoding type.
             
             DATA_BLOB * pDataBlob - Pointer to DATA_BLOB to receive the
                                     decoded data.
  
  Remark   : There is no need for encoding type parameter, as the encoding type
             will be determined automatically by this routine.

------------------------------------------------------------------------------*/

HRESULT ImportData (BSTR                  bstrEncoded,
                    CAPICOM_ENCODING_TYPE EncodingType,
                    DATA_BLOB           * pDataBlob);

#endif //__CONVERT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\common.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Common.h

  Content: Declaration of Common.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/


#ifndef __COMMON_H_
#define __COMMON_H_

#include "Debug.h"

////////////////////
//
// typedefs
//

typedef enum osVersion
{
    OS_WIN_UNKNOWN      = 0,
    OS_WIN_32s          = 1,
    OS_WIN_9X           = 2,
    OS_WIN_ME           = 3,
    OS_WIN_NT3_5        = 4,
    OS_WIN_NT4          = 5,
    OS_WIN_2K           = 6,
    OS_WIN_XP           = 7,
    OS_WIN_ABOVE_XP     = 8,
} OSVERSION, * POSVERSION;

extern LPSTR g_rgpszOSNames[];

////////////////////
//
// macros
//

#define IsWinNTAndAbove()          (GetOSVersion() >= OS_WIN_NT4)
#define IsWin2KAndAbove()          (GetOSVersion() >= OS_WIN_2K)
#define IsWinXPAndAbove()          (GetOSVersion() >= OS_WIN_XP)
#define OSName()                   (g_rgpszOSNames[GetOSVersion()])

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : GetOSVersion

  Synopsis : Get the current OS platform/version.

  Parameter: None.

  Remark   :

------------------------------------------------------------------------------*/

OSVERSION GetOSVersion ();

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : EncodeObject

  Synopsis : Allocate memory and encode an ASN.1 object using CAPI
             CryptEncodeObject() API.

  Parameter: LPCSRT pszStructType           - see MSDN document for possible 
                                              types.
             LPVOID pbData                  - Pointer to data to be encoded 
                                              (data type must match 
                                              pszStrucType).
             CRYPT_DATA_BLOB * pEncodedBlob - Pointer to CRYPT_DATA_BLOB to 
                                              receive the encoded length and 
                                              data.

  Remark   : No parameter check is done.

------------------------------------------------------------------------------*/

HRESULT EncodeObject (LPCSTR            pszStructType, 
                      LPVOID            pbData, 
                      CRYPT_DATA_BLOB * pEncodedBlob);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : DecodeObject

  Synopsis : Allocate memory and decode an ASN.1 object using CAPI
             CryptDecodeObject() API.

  Parameter: LPCSRT pszStructType           - see MSDN document for possible
                                              types.
             BYTE * pbEncoded               - Pointer to data to be decoded 
                                              (data type must match 
                                              pszStructType).
             DWORD cbEncoded                - Size of encoded data.
             CRYPT_DATA_BLOB * pDecodedBlob - Pointer to CRYPT_DATA_BLOB to 
                                              receive the decoded length and 
                                              data.
  Remark   : No parameter check is done.

------------------------------------------------------------------------------*/

HRESULT DecodeObject (LPCSTR            pszStructType, 
                      BYTE            * pbEncoded,
                      DWORD             cbEncoded,
                      CRYPT_DATA_BLOB * pDecodedBlob);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : GetKeyParam

  Synopsis : Allocate memory and retrieve requested key parameter using 
             CryptGetKeyParam() API.

  Parameter: HCRYPTKEY hKey  - Key handler.
             DWORD dwParam   - Key parameter query.
             BYTE ** ppbData - Pointer to receive buffer.
             DWORD * pcbData - Size of buffer.

  Remark   :

------------------------------------------------------------------------------*/

HRESULT GetKeyParam (HCRYPTKEY hKey,
                     DWORD     dwParam,
                     BYTE   ** ppbData,
                     DWORD   * pcbData);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : IsAlgSupported

  Synopsis : Check to see if the algo is supported by the CSP.

  Parameter: HCRYPTPROV hCryptProv - CSP handle.

             ALG_ID AlgId - Algorithm ID.

             PROV_ENUMALGS_EX * pPeex - Pointer to PROV_ENUMALGS_EX to receive
                                        the found structure.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT IsAlgSupported (HCRYPTPROV         hCryptProv, 
                        ALG_ID             AlgId, 
                        PROV_ENUMALGS_EX * pPeex);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : IsAlgKeyLengthSupported

  Synopsis : Check to see if the algo and key length is supported by the CSP.

  Parameter: HCRYPTPROV hCryptProv - CSP handle.

             ALG_ID AlgID - Algorithm ID.

             DWORD dwKeyLength - Key length

  Remark   :

------------------------------------------------------------------------------*/

HRESULT IsAlgKeyLengthSupported (HCRYPTPROV hCryptProv, 
                                 ALG_ID     AlgID,
                                 DWORD      dwKeyLength);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AcquireContext

  Synopsis : Acquire context for the specified CSP and keyset container.
  
  Parameter: LPSTR pszProvider - CSP provider name or NULL.
  
             LPSTR pszContainer - Keyset container name or NULL.

             DWORD dwProvType - Provider type.

             DWORD dwFlags - Same as dwFlags of CryptAcquireConext.
  
             BOOL bNewKeyset - TRUE to create new keyset container, else FALSE.

             HCRYPTPROV * phCryptProv - Pointer to HCRYPTPROV to recevice
                                        CSP context.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT AcquireContext(LPSTR        pszProvider, 
                       LPSTR        pszContainer,
                       DWORD        dwProvType,
                       DWORD        dwFlags,
                       BOOL         bNewKeyset,
                       HCRYPTPROV * phCryptProv);
                      
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AcquireContext

  Synopsis : Acquire context for the specified CSP and keyset container.
  
  Parameter: LPWSTR pwszProvider - CSP provider name or NULL.
  
             LPWSTR pwszContainer - Keyset container name or NULL.

             DWORD dwProvType - Provider type.

             DWORD dwFlags - Same as dwFlags of CryptAcquireConext.
  
             BOOL bNewKeyset - TRUE to create new keyset container, else FALSE.

             HCRYPTPROV * phCryptProv - Pointer to HCRYPTPROV to recevice
                                        CSP context.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT AcquireContext(LPWSTR       pwszProvider, 
                       LPWSTR       pwszContainer,
                       DWORD        dwProvType,
                       DWORD        dwFlags,
                       BOOL         bNewKeyset,
                       HCRYPTPROV * phCryptProv);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AcquireContext

  Synopsis : Acquire context of a CSP using the default container for a
             specified hash algorithm.
  
  Parameter: ALG_ID AlgOID - Algorithm ID.

             HCRYPTPROV * phCryptProv - Pointer to HCRYPTPROV to recevice
                                        CSP context.

  Remark   : Note that KeyLength will be ignored for DES and 3DES.
  
------------------------------------------------------------------------------*/

HRESULT AcquireContext(ALG_ID       AlgID,
                       HCRYPTPROV * phCryptProv);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AcquireContext

  Synopsis : Acquire context of a CSP using the default container for a
             specified algorithm and desired key length.
  
  Parameter: ALG_ID AlgOID - Algorithm ID.

             DWORD dwKeyLength - Key length.

             HCRYPTPROV * phCryptProv - Pointer to HCRYPTPROV to recevice
                                        CSP context.

  Remark   : Note that KeyLength will be ignored for DES and 3DES.
  
------------------------------------------------------------------------------*/

HRESULT AcquireContext (ALG_ID       AlgID,
                        DWORD        dwKeyLength,
                        HCRYPTPROV * phCryptProv);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AcquireContext

  Synopsis : Acquire context of a CSP using the default container for a
             specified algorithm and desired key length.
  
  Parameter: CAPICOM_ENCRYPTION_ALGORITHM AlgoName - Algorithm name.

             CAPICOM_ENCRYPTION_KEY_LENGTH KeyLength - Key length.

             HCRYPTPROV * phCryptProv - Pointer to HCRYPTPROV to recevice
                                        CSP context.

  Remark   : Note that KeyLength will be ignored for DES and 3DES.

             Note also the the returned handle cannot be used to access private 
             key, and should NOT be used to store assymetric key, as it refers 
             to the default container, which can be easily destroy any existing 
             assymetric key pair.

------------------------------------------------------------------------------*/

HRESULT AcquireContext (CAPICOM_ENCRYPTION_ALGORITHM  AlgoName,
                        CAPICOM_ENCRYPTION_KEY_LENGTH KeyLength,
                        HCRYPTPROV                  * phCryptProv);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AcquireContext

  Synopsis : Acquire the proper CSP and access to the private key for 
             the specified cert.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT of cert.

             HCRYPTPROV * phCryptProv    - Pointer to HCRYPTPROV to recevice
                                           CSP context.

             DWORD * pdwKeySpec          - Pointer to DWORD to receive key
                                           spec, AT_KEYEXCHANGE or AT_SIGNATURE.

             BOOL * pbReleaseContext     - Upon successful and if this is set
                                           to TRUE, then the caller must
                                           free the CSP context by calling
                                           CryptReleaseContext(), otherwise
                                           the caller must not free the CSP
                                           context.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT AcquireContext (PCCERT_CONTEXT pCertContext, 
                        HCRYPTPROV   * phCryptProv, 
                        DWORD        * pdwKeySpec, 
                        BOOL         * pbReleaseContext);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : ReleaseContext

  Synopsis : Release CSP context.
  
  Parameter: HCRYPTPROV hProv - CSP handle.

  Remark   :

------------------------------------------------------------------------------*/

HRESULT ReleaseContext (HCRYPTPROV hProv);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : OIDToAlgID

  Synopsis : Convert algorithm OID to the corresponding ALG_ID value.

  Parameter: LPSTR pszAlgoOID - Algorithm OID string.
  
             ALG_ID * pAlgID - Pointer to ALG_ID to receive the value.

  Remark   :

------------------------------------------------------------------------------*/

HRESULT OIDToAlgID (LPSTR    pszAlgoOID, 
                    ALG_ID * pAlgID);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AlgIDToOID

  Synopsis : Convert ALG_ID value to the corresponding algorithm OID.

  Parameter: ALG_ID AlgID - ALG_ID to be converted.

             LPSTR * ppszAlgoOID - Pointer to LPSTR to receive the OID string.

  Remark   :

------------------------------------------------------------------------------*/

HRESULT AlgIDToOID (ALG_ID  AlgID, 
                    LPSTR * ppszAlgoOID);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AlgIDToEnumName

  Synopsis : Convert ALG_ID value to the corresponding algorithm enum name.

  Parameter: ALG_ID AlgID - ALG_ID to be converted.
  
             CAPICOM_ENCRYPTION_ALGORITHM * pAlgoName - Receive algo enum name.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT AlgIDToEnumName (ALG_ID                         AlgID, 
                         CAPICOM_ENCRYPTION_ALGORITHM * pAlgoName);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : EnumNameToAlgID

  Synopsis : Convert algorithm enum name to the corresponding ALG_ID value.

  Parameter: CAPICOM_ENCRYPTION_ALGORITHM AlgoName - Algo enum name.

             CAPICOM_ENCRYPTION_KEY_LENGTH KeyLength - Key length.
  
             ALG_ID * pAlgID - Pointer to ALG_ID to receive the value.  

  Remark   :

------------------------------------------------------------------------------*/

HRESULT EnumNameToAlgID (CAPICOM_ENCRYPTION_ALGORITHM  AlgoName,
                         CAPICOM_ENCRYPTION_KEY_LENGTH KeyLength,
                         ALG_ID                      * pAlgID);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : KeyLengthToEnumName

  Synopsis : Convert actual key length value to the corresponding key length
             enum name.

  Parameter: DWORD dwKeyLength - Key length.

             ALG_ID AlgId - Algo ID.
  
             CAPICOM_ENCRYPTION_KEY_LENGTH * pKeyLengthName - Receive key length
                                                           enum name.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT KeyLengthToEnumName (DWORD                           dwKeyLength,
                             ALG_ID                          AlgId,
                             CAPICOM_ENCRYPTION_KEY_LENGTH * pKeyLengthName);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : EnumNameToKeyLength

  Synopsis : Convert key length enum name to the corresponding actual key length 
             value .

  Parameter: CAPICOM_ENCRYPTION_KEY_LENGTH KeyLengthName - Key length enum name.

             ALG_ID AlgId - Algorithm ID.

             DWORD * pdwKeyLength - Pointer to DWORD to receive value.
             
  Remark   :

------------------------------------------------------------------------------*/

HRESULT EnumNameToKeyLength (CAPICOM_ENCRYPTION_KEY_LENGTH KeyLengthName,
                             ALG_ID                        AlgId,
                             DWORD                       * pdwKeyLength);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : IsDiskFile

  Synopsis : Check if a the file name represents a disk file.

  Parameter: LPWSTR pwszFileName - File name.
  
  Remark   :

------------------------------------------------------------------------------*/

HRESULT IsDiskFile (LPWSTR pwszFileName);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : ReadFileContent

  Synopsis : Read all bytes from the specified file.

  Parameter: LPWSTR  pwszFileName
                                                          
             DATA_BLOB * pDataBlob
  Remark   :

------------------------------------------------------------------------------*/

HRESULT ReadFileContent (LPWSTR      pwszFileName,
                         DATA_BLOB * pDataBlob);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : WriteFileContent

  Synopsis : Write all bytes of blob to the specified file.

  Parameter: LPWSTR pwszFileName - File name.
  
             DATA_BLOB DataBlob - Blob to be written.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT WriteFileContent(LPCWSTR    pwszFileName,
                         DATA_BLOB DataBlob);

#endif //__COMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\chain.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows

  Copyright (C) Microsoft Corporation, 1995 - 1999.

  File:       Chain.h

  Content:    Declaration of CChain.

  History:    11-15-99    dsie     created

------------------------------------------------------------------------------*/

#ifndef __CHAIN_H_
#define __CHAIN_H_

#include "Resource.h"
#include "Error.h"
#include "Lock.h"
#include "Debug.h"

//
// Chain policy error status.
//
typedef enum CAPICOM_CHAIN_STATUS
{
    CAPICOM_CHAIN_STATUS_OK                                 = 0x00000000,
    CAPICOM_CHAIN_STATUS_REVOKED                            = 0x80092010,
    CAPICOM_CHAIN_STATUS_REVOCATION_NO_CHECK                = 0x80092012,
    CAPICOM_CHAIN_STATUS_REVOCATION_OFFLINE                 = 0x80092013,
    CAPICOM_CHAIN_STATUS_INVALID_BASIC_CONSTRAINTS          = 0x80096019,
    CAPICOM_CHAIN_STATUS_INVALID_SIGNATURE                  = 0x80096004,
    CAPICOM_CHAIN_STATUS_EXPIRED                            = 0x800B0101,
    CAPICOM_CHAIN_STATUS_NESTED_VALIDITY_PERIOD             = 0x800B0102,
    CAPICOM_CHAIN_STATUS_UNTRUSTEDROOT                      = 0x800B0109,
    CAPICOM_CHAIN_STATUS_PARTIAL_CHAINING                   = 0x800B010A,
    CAPICOM_CHAIN_STATUS_INVALID_USAGE                      = 0x800B0110,
    CAPICOM_CHAIN_STATUS_INVALID_POLICY                     = 0x800B0113,
    CAPICOM_CHAIN_STATUS_INVALID_NAME                       = 0x800B0114,
} CAPICOM_CHAIN_STATUS;

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateChainObject

  Synopsis : Create and initialize an IChain object by building the chain
             of a specified certificate and policy.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT.
  
             ICertificateStatus * pIStatus - Pointer to ICertificateStatus
                                             object.

             HCERTSTORE hAdditionalStore - Additional store handle.

             VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive chain
                                   overall validity result.

             IChain ** ppIChain - Pointer to pointer to IChain object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateChainObject (PCCERT_CONTEXT       pCertContext, 
                           ICertificateStatus * pIStatus,
                           HCERTSTORE           hAdditionalStore,
                           VARIANT_BOOL       * pbResult,
                           IChain            ** ppIChain);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateChainObject

  Synopsis : Create and initialize an IChain object by building the chain
             of a specified certificate and policy.

  Parameter: ICertificate * pICertificate - Poitner to ICertificate.

             HCERTSTORE hAdditionalStore - Additional store handle.
  
             VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive chain
                                   overall validity result.

             IChain ** ppIChain - Pointer to pointer to IChain object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateChainObject (ICertificate * pICertificate,
                           HCERTSTORE     hAdditionalStore,
                           VARIANT_BOOL * pbResult,
                           IChain      ** ppIChain);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateChainObject

  Synopsis : Create and initialize an IChain object from a built chain.

  Parameter: PCCERT_CHAIN_CONTEXT pChainContext - Chain context.

             IChain ** ppIChain - Pointer to pointer to IChain object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateChainObject (PCCERT_CHAIN_CONTEXT pChainContext,
                           IChain            ** ppIChain);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : GetChainContext

  Synopsis : Return an array of PCCERT_CONTEXT from the chain.

  Parameter: IChain * pIChain - Pointer to IChain.
  
             CRYPT_DATA_BLOB * pChainBlob - Pointer to blob to recevie the
                                            size and array of PCERT_CONTEXT
                                            for the chain.
  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP GetChainContext (IChain          * pIChain, 
                              CRYPT_DATA_BLOB * pChainBlob);


////////////////////////////////////////////////////////////////////////////////
//
// CChain
//

class ATL_NO_VTABLE CChain : 
    public IChainContext,
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CChain, &CLSID_Chain>,
    public ICAPICOMError<CChain, &IID_IChain2>,
    public IDispatchImpl<IChain2, &IID_IChain2, &LIBID_CAPICOM,
                         CAPICOM_MAJOR_VERSION, CAPICOM_MINOR_VERSION>,
    public IObjectSafetyImpl<CChain, INTERFACESAFE_FOR_UNTRUSTED_CALLER | 
                                     INTERFACESAFE_FOR_UNTRUSTED_DATA>
{
public:
    CChain()
    {
        m_pUnkMarshaler = NULL;
    }

DECLARE_REGISTRY_RESOURCEID(IDR_CHAIN)

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CChain)
    COM_INTERFACE_ENTRY(IChain)
    COM_INTERFACE_ENTRY(IChain2)
    COM_INTERFACE_ENTRY(IChainContext)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CChain)
    IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
    IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
END_CATEGORY_MAP()

    HRESULT FinalConstruct()
    {
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for Chain object.\n", hr);
            return hr;
        }

        m_dwStatus      = 0;
        m_pChainContext = NULL;

        return CoCreateFreeThreadedMarshaler(
            GetControllingUnknown(), &m_pUnkMarshaler.p);
    }

    void FinalRelease()
    {
        if (m_pChainContext)
        {
            ::CertFreeCertificateChain(m_pChainContext);
        }

        m_pUnkMarshaler.Release();
    }

    CComPtr<IUnknown> m_pUnkMarshaler;

//
// IChain
//
public:
    STDMETHOD(get_Certificates)
        (/*[out, retval]*/ ICertificates ** pVal);

    STDMETHOD(get_Status)
        (/*[in, defaultvalue(0)]*/ long Index, 
         /*[out,retval]*/ long * pVal);

    STDMETHOD(Build)
        (/*[in]*/ ICertificate * pICertificate, 
         /*[out, retval]*/ VARIANT_BOOL * pVal);

    STDMETHOD(CertificatePolicies)
        (/*[out, retval]*/ IOIDs ** pVal);

    STDMETHOD(ApplicationPolicies)
        (/*[out, retval]*/ IOIDs ** pVal);

    STDMETHOD(ExtendedErrorInfo)
        (/*[in, defaultvalue(1)]*/ long Index, 
         /*[out, retval]*/ BSTR * pVal);

    //
    // Custom interfaces. 
    //
    STDMETHOD(get_ChainContext)
        (/*[out, retval]*/ long * pChainContext);

    STDMETHOD(put_ChainContext)
        (/*[in]*/ long pChainContext);

    STDMETHOD(FreeContext)
        (/*[in]*/ long pChainContext);


    //
    // Non COM functions.
    //
    STDMETHOD(Init)
        (PCCERT_CONTEXT       pCertContext, 
         ICertificateStatus * pIStatus,
         HCERTSTORE           hAdditionalStore,
         VARIANT_BOOL       * pbResult);

    STDMETHOD(Verify)
        (CAPICOM_CHECK_FLAG CheckFlag,
         CAPICOM_CHAIN_STATUS * pVal);

    STDMETHOD(GetContext)
        (PCCERT_CHAIN_CONTEXT * ppChainContext);

    STDMETHOD(PutContext)
        (PCCERT_CHAIN_CONTEXT pChainContext);

private:
    CLock                m_Lock;
    DWORD                m_dwStatus;
    PCCERT_CHAIN_CONTEXT m_pChainContext;
};

#endif //__CHAIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\chain.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Chain.cpp

  Content: Implementation of CChain.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "Chain.h"

#include "Convert.h"
#include "Common.h"
#include "OIDs.h"
#include "Certificates.h"
#include "CertificateStatus.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateChainObject

  Synopsis : Create and initialize an IChain object by building the chain
             of a specified certificate and policy.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT.
  
             ICertificateStatus * pIStatus - Pointer to ICertificateStatus
                                             object.

             HCERTSTORE hAdditionalStore - Additional store handle.

             VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive chain
                                   overall validity result.

             IChain ** ppIChain - Pointer to pointer to IChain object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateChainObject (PCCERT_CONTEXT       pCertContext, 
                           ICertificateStatus * pIStatus,
                           HCERTSTORE           hAdditionalStore,
                           VARIANT_BOOL       * pbResult,
                           IChain            ** ppIChain)
{
    HRESULT hr = S_OK;
    CComObject<CChain> * pCChain = NULL;

    DebugTrace("Entering CreateChainObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(pIStatus);
    ATLASSERT(pbResult);
    ATLASSERT(ppIChain);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CChain>::CreateInstance(&pCChain)))
        {
            DebugTrace("Error [%#x]: CComObject<CChain>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize object.
        //
        if (FAILED(hr = pCChain->Init(pCertContext, 
                                      pIStatus, 
                                      hAdditionalStore, 
                                      pbResult)))
        {
            DebugTrace("Error [%#x]: pCChain->Init() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return IChain pointer to caller.
        //
        if (FAILED(hr = pCChain->QueryInterface(ppIChain)))
        {
            DebugTrace("Error [%#x]: pCChain->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreateChainObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (pCChain)
    {
        delete pCChain;
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateChainObject

  Synopsis : Create and initialize an IChain object by building the chain
             of a specified certificate and policy.

  Parameter: ICertificate * pICertificate - Poitner to ICertificate.

             HCERTSTORE hAdditionalStore - Additional store handle.
  
             VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive chain
                                   overall validity result.

             IChain ** ppIChain - Pointer to pointer to IChain object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateChainObject (ICertificate * pICertificate,
                           HCERTSTORE     hAdditionalStore,
                           VARIANT_BOOL * pbResult,
                           IChain      ** ppIChain)
{
    HRESULT                     hr = S_OK;
    PCCERT_CONTEXT              pCertContext = NULL;
    CComPtr<ICertificateStatus> pIStatus     = NULL;

    DebugTrace("Entering CreateChainObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pICertificate);
    ATLASSERT(pbResult);
    ATLASSERT(ppIChain);

    try
    {

        //
        // Get CERT_CONTEXT.
        //
        if (FAILED(hr = ::GetCertContext(pICertificate, &pCertContext)))
        {
            DebugTrace("Error [%#x]: GetCertContext() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Get status check object.
        //
        if (FAILED(hr = pICertificate->IsValid(&pIStatus)))
        {
            DebugTrace("Error [%#x]: pICertificate->IsValid() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Create the object.
        //
        if (FAILED(hr = ::CreateChainObject(pCertContext, 
                                            pIStatus, 
                                            hAdditionalStore, 
                                            pbResult, 
                                            ppIChain)))
        {
            DebugTrace("Error [%#x]: CreateChainObject() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:
    //
    // Free resource.
    //
    if (pCertContext)
    {
        ::CertFreeCertificateContext(pCertContext);
    }

    DebugTrace("Leaving CreateChainObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateChainObject

  Synopsis : Create and initialize an IChain object from a built chain.

  Parameter: PCCERT_CHAIN_CONTEXT pChainContext - Chain context.

             IChain ** ppIChain - Pointer to pointer to IChain object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateChainObject (PCCERT_CHAIN_CONTEXT pChainContext,
                           IChain            ** ppIChain)
{
    HRESULT hr = S_OK;
    CComObject<CChain> * pCChain = NULL;

    DebugTrace("Entering CreateChainObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pChainContext);
    ATLASSERT(ppIChain);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CChain>::CreateInstance(&pCChain)))
        {
            DebugTrace("Error [%#x]: CComObject<CChain>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize object.
        //
        if (FAILED(hr = pCChain->PutContext(pChainContext)))
        {
            DebugTrace("Error [%#x]: pCChain->Init() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return IChain pointer to caller.
        //
        if (FAILED(hr = pCChain->QueryInterface(ppIChain)))
        {
            DebugTrace("Error [%#x]: pCChain->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }
    
    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreateChainObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (pCChain)
    {
        delete pCChain;
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : GetChainContext

  Synopsis : Return an array of PCCERT_CONTEXT from the chain.

  Parameter: IChain * pIChain - Pointer to IChain.
  
             CRYPT_DATA_BLOB * pChainBlob - Pointer to blob to recevie the
                                            size and array of PCERT_CONTEXT
                                            for the chain.
  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP GetChainContext (IChain          * pIChain, 
                              CRYPT_DATA_BLOB * pChainBlob)
{
    HRESULT                hr             = S_OK;
    DWORD                  dwCerts        = 0;
    PCCERT_CHAIN_CONTEXT   pChainContext  = NULL;
    PCERT_SIMPLE_CHAIN     pSimpleChain   = NULL;
    PCCERT_CONTEXT       * rgCertContext  = NULL;
    CComPtr<IChainContext> pIChainContext = NULL;
    
    DebugTrace("Entering GetChainContext().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pIChain);
    ATLASSERT(pChainBlob);

    //
    // Get ICCertificate interface pointer.
    //
    if (FAILED(hr = pIChain->QueryInterface(IID_IChainContext, (void **) &pIChainContext)))
    {
        DebugTrace("Error [%#x]: pIChainContext->QueryInterface() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Get the CHAIN_CONTEXT.
    //
    if (FAILED(hr = pIChainContext->get_ChainContext((long *) &pChainContext)))
    {
        DebugTrace("Error [%#x]: pIChainContext->get_ChainContext() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Process only the simple chain.
    //
    pSimpleChain = *pChainContext->rgpChain;

    //
    // Should have at least one cert in the chain.
    //
    ATLASSERT(pSimpleChain->cElement);

    //
    // Allocate memory for array of PCERT_CONTEXT to return.
    //
    if (!(rgCertContext = (PCCERT_CONTEXT *) ::CoTaskMemAlloc(pSimpleChain->cElement * sizeof(PCCERT_CONTEXT))))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Error: out of memory.\n");
        goto ErrorExit;
    }

    //
    // Now loop through all certs in the chain.
    //
    for (dwCerts = 0; dwCerts < pSimpleChain->cElement; dwCerts++)
    {
        //
        // Add the cert.
        //
        if (!(rgCertContext[dwCerts] = ::CertDuplicateCertificateContext(pSimpleChain->rgpElement[dwCerts]->pCertContext)))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertDuplicateCertificateContext() failed.\n", hr);
            goto ErrorExit;
        }
    }

    //
    // Return PCCERT_CONTEXT array.
    //
    pChainBlob->cbData = dwCerts;
    pChainBlob->pbData = (BYTE *) rgCertContext;

CommonExit:
    //
    // Free resource.
    //
    if (pChainContext)
    {
        ::CertFreeCertificateChain(pChainContext);
    }

    DebugTrace("Leaving GetChainContext().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (rgCertContext)
    {
        while (dwCerts--)
        {
            if (rgCertContext[dwCerts])
            {
                ::CertFreeCertificateContext(rgCertContext[dwCerts]);
            }
        }

        ::CoTaskMemFree((LPVOID) rgCertContext);
    }

    goto CommonExit;
}

///////////////////////////////////////////////////////////////////////////////
//
// CChain
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CChain::get_Certificates

  Synopsis : Return the certificate chain in the form of ICertificates 
             collection object.

  Parameter: ICertificates ** pVal - Pointer to pointer to ICertificates 
                                     collection object.

  Remark   : This collection is ordered with index 1 being the end certificate 
             and Certificates.Count() being the root certificate.

------------------------------------------------------------------------------*/

STDMETHODIMP CChain::get_Certificates (ICertificates ** pVal)
{
    HRESULT hr = S_OK;
    CComPtr<ICertificates2> pICertificates2 = NULL;
    CAPICOM_CERTIFICATES_SOURCE ccs = {CAPICOM_CERTIFICATES_LOAD_FROM_CHAIN, 0};

    DebugTrace("Entering CChain::get_Certificates().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure chain has been built.
        //
        if (NULL == m_pChainContext)
        {
            hr = CAPICOM_E_CHAIN_NOT_BUILT;

            DebugTrace("Error [%#x]: chain object was not initialized.\n", hr);
            goto ErrorExit;
        }

        ccs.pChainContext = m_pChainContext;

        //
        // Create a ICertificates2 object.
        //
        if (FAILED(hr = ::CreateCertificatesObject(ccs, m_dwCurrentSafety, FALSE, &pICertificates2)))
        {
            DebugTrace("Error [%#x]: CreateCertificatesObject() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return ICertificates to calller.
        //
        if (FAILED(hr = pICertificates2->QueryInterface(__uuidof(ICertificates), (void **) pVal)))
        {
            DebugTrace("Error [%#x]: pICertificates2->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CChain::get_Certificates().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CChain::get_Status

  Synopsis : Return validity status for the chain or a specific certificate in
             the chain.

  Parameter: long Index  - 0 to specify chain status, 1 for the end cert 
                           status, or Certificates.Count() for the root cert 
                           status.

             long * pVal - Pointer to a long integer to receive the status,
                           which can be ORed with the following flags:

                    //
                    // These can be applied to certificates and chains.
                    //
                    CAPICOM_TRUST_IS_NOT_TIME_VALID                 = 0x00000001
                    CAPICOM_TRUST_IS_NOT_TIME_NESTED                = 0x00000002
                    CAPICOM_TRUST_IS_REVOKED                        = 0x00000004
                    CAPICOM_TRUST_IS_NOT_SIGNATURE_VALID            = 0x00000008
                    CAPICOM_TRUST_IS_NOT_VALID_FOR_USAGE            = 0x00000010
                    CAPICOM_TRUST_IS_UNTRUSTED_ROOT                 = 0x00000020
                    CAPICOM_TRUST_REVOCATION_STATUS_UNKNOWN         = 0x00000040
                    CAPICOM_TRUST_IS_CYCLIC                         = 0x00000080

                    CAPICOM_TRUST_INVALID_EXTENSION                 = 0x00000100
                    CAPICOM_TRUST_INVALID_POLICY_CONSTRAINTS        = 0x00000200
                    CAPICOM_TRUST_INVALID_BASIC_CONSTRAINTS         = 0x00000400
                    CAPICOM_TRUST_INVALID_NAME_CONSTRAINTS          = 0x00000800
                    CAPICOM_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT = 0x00001000
                    CAPICOM_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT   = 0x00002000
                    CAPICOM_TRUST_HAS_NOT_PERMITTED_NAME_CONSTRAINT = 0x00004000
                    CAPICOM_TRUST_HAS_EXCLUDED_NAME_CONSTRAINT      = 0x00008000

                    CAPICOM_TRUST_IS_OFFLINE_REVOCATION             = 0x01000000
                    CAPICOM_TRUST_NO_ISSUANCE_CHAIN_POLICY          = 0x02000000

                    //
                    // These can be applied to chains only.
                    //
                    CAPICOM_TRUST_IS_PARTIAL_CHAIN                  = 0x00010000
                    CAPICOM_TRUST_CTL_IS_NOT_TIME_VALID             = 0x00020000
                    CAPICOM_TRUST_CTL_IS_NOT_SIGNATURE_VALID        = 0x00040000
                    CAPICOM_TRUST_CTL_IS_NOT_VALID_FOR_USAGE        = 0x00080000

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CChain::get_Status (long   Index, 
                                 long * pVal)
{
    HRESULT hr      = S_OK;
    DWORD   dwIndex = (DWORD) Index;

    DebugTrace("Entering CChain::get_Status().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure chain has been built.
        //
        if (NULL == m_pChainContext)
        {
            hr = CAPICOM_E_CHAIN_NOT_BUILT;

            DebugTrace("Error [%#x]: chain object was not initialized.\n", hr);
            goto ErrorExit;
        }

        //
        // Return requested status.
        //
        if (0 == dwIndex)
        {
            *pVal = (long) m_dwStatus;
        }
        else
        {
            //
            // We only look at the first simple chain.
            //
            PCERT_SIMPLE_CHAIN pChain = m_pChainContext->rgpChain[0];

            //
            // Make sure index is not out of range.
            //
            if (dwIndex > pChain->cElement)
            {
                hr = E_INVALIDARG;

                DebugTrace("Error [%#x]: certificate index (%#x) out of range.\n", hr, dwIndex);
                goto ErrorExit;
            }

            *pVal = (long) pChain->rgpElement[dwIndex - 1]->TrustStatus.dwErrorStatus;
        }
    }
    
    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();
    
    DebugTrace("Leaving CChain::get_Status().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CChain::Build

  Synopsis : Build the chain.

  Parameter: ICertificate * pICertificate - Pointer to certificate for which
                                            the chain is to build.
  
             VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive chain
                                   overall validity result.
  Remark   : 

------------------------------------------------------------------------------*/

STDMETHODIMP CChain::Build (ICertificate * pICertificate, 
                            VARIANT_BOOL * pVal)
{
    HRESULT                     hr           = S_OK;
    PCCERT_CONTEXT              pCertContext = NULL;
    CComPtr<ICertificateStatus> pIStatus     = NULL;

    DebugTrace("Entering CChain::Build().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pICertificate)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pICertificate is NULL.\n", hr);
            goto ErrorExit;
        }
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Get CERT_CONTEXT.
        //
        if (FAILED(hr = ::GetCertContext(pICertificate, &pCertContext)))
        {
            DebugTrace("Error [%#x]: GetCertContext() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Get status check object.
        //
        if (FAILED(hr = pICertificate->IsValid(&pIStatus)))
        {
            DebugTrace("Error [%#x]: pICertificate->IsValid() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Build the chain.
        //
        if (FAILED(hr = Init(pCertContext, pIStatus, NULL, pVal)))
        {
            DebugTrace("Error [%#x]: CChain::Init() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resource.
    //
    if (pCertContext)
    {
        ::CertFreeCertificateContext(pCertContext);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CChain::Build().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CChain::CertificatePolicies

  Synopsis : Return the certificate policies OIDs collection for which this
             chain is valid.

  Parameter: IOID ** pVal - Pointer to pointer to IOIDs to receive the
                            interface pointer.

  Remark   : 

------------------------------------------------------------------------------*/

STDMETHODIMP CChain::CertificatePolicies (IOIDs ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CChain::CertificatePolicies().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();
        
        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure chain has been built.
        //
        if (NULL == m_pChainContext)
        {
            hr = CAPICOM_E_CHAIN_NOT_BUILT;

            DebugTrace("Error [%#x]: chain object was not initialized.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure OS is XP and above.
        //
        if (IsWinXPAndAbove())
        {
            //
            // Make sure rgbElement is present.
            //
            if (1 > m_pChainContext->cChain)
            {
                hr = CAPICOM_E_UNKNOWN;

                DebugTrace("Error [%#x]: m_pChainContext->cChain = %d.\n", 
                           hr, m_pChainContext->cChain);
                goto ErrorExit;
            }

            if  (1 > m_pChainContext->rgpChain[0]->cElement)
            {
                hr = CAPICOM_E_UNKNOWN;

                DebugTrace("Error [%#x]: m_pChainContext->rgpChain[0]->cElement = %d.\n", 
                           hr, m_pChainContext->rgpChain[0]->cElement);
                goto ErrorExit;
            }

            //
            // Create the OIDs collection for the simple chain.
            //
            if (FAILED(hr = ::CreateOIDsObject(m_pChainContext->rgpChain[0]->rgpElement[0]->pIssuanceUsage, 
                                               TRUE, pVal)))
            {
                DebugTrace("Error [%#x]: CreateOIDsObject() failed.\n", hr);
                goto ErrorExit;
            }
        }
        else
        {
            CERT_ENHKEY_USAGE PolicyUsages = {0, NULL};

            //
            // Create the OIDs collection for the simple chain.
            //
            if (FAILED(hr = ::CreateOIDsObject(&PolicyUsages, TRUE, pVal)))
            {
                DebugTrace("Error [%#x]: CreateOIDsObject() failed.\n", hr);
                goto ErrorExit;
            }
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CChain::CertificatePolicies().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CChain::ApplicationPolicies

  Synopsis : Return the application policies OIDs collection for which this
             chain is valid.

  Parameter: IOID ** pVal - Pointer to pointer to IOIDs to receive the
                            interface pointer.

  Remark   : 

------------------------------------------------------------------------------*/

STDMETHODIMP CChain::ApplicationPolicies (IOIDs ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CChain::ApplicationPolicies().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure chain has been built.
        //
        if (NULL == m_pChainContext)
        {
            hr = CAPICOM_E_CHAIN_NOT_BUILT;

            DebugTrace("Error [%#x]: chain object was not initialized.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure OS is XP and above.
        //
        if (IsWinXPAndAbove())
        {
            //
            // Make sure rgbElement is present.
            //
            if (1 > m_pChainContext->cChain)
            {
                hr = CAPICOM_E_UNKNOWN;

                DebugTrace("Error [%#x]: m_pChainContext->cChain = %d.\n", 
                           hr, m_pChainContext->cChain);
                goto ErrorExit;
            }

            if  (1 > m_pChainContext->rgpChain[0]->cElement)
            {
                hr = CAPICOM_E_UNKNOWN;

                DebugTrace("Error [%#x]: m_pChainContext->rgpChain[0]->cElement = %d.\n", 
                           hr, m_pChainContext->rgpChain[0]->cElement);
                goto ErrorExit;
            }

            //
            // Create the OIDs collection for the simple chain.
            //
            if (FAILED(hr = ::CreateOIDsObject(m_pChainContext->rgpChain[0]->rgpElement[0]->pApplicationUsage, 
                                               FALSE, pVal)))
            {
                DebugTrace("Error [%#x]: CreateOIDsObject() failed.\n", hr);
                goto ErrorExit;
            }
        }
        else
        {
            //
            // $BUGBUG: Not supported (should we return CAPICOM_E_NOT_SUPPORTED?)
            //
            *pVal = NULL;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CChain::ApplicationPolicies().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CChain::ExtendedErrorInfo

  Synopsis : Return the extended error information description string.

  Parameter: long Index - Index of the chain (one based).

             BSTR * pVal - Pointer to BSTR to receive the string.

  Remark   : 

------------------------------------------------------------------------------*/

STDMETHODIMP CChain::ExtendedErrorInfo (long Index, BSTR * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CChain::ExtendedErrorInfo().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure chain has been built.
        //
        if (NULL == m_pChainContext)
        {
            hr = CAPICOM_E_CHAIN_NOT_BUILT;

            DebugTrace("Error [%#x]: chain object was not initialized.\n", hr);
            goto ErrorExit;
        }

        DebugTrace("m_pChainContext = %#x.\n", m_pChainContext);

        //
        // Make sure OS is XP and above.
        //
        if (IsWinXPAndAbove())
        {
            CComBSTR bstrErrorInfo;

            //
            // Make sure rgbElement is present.
            //
            if (1 > m_pChainContext->cChain)
            {
                hr = CAPICOM_E_UNKNOWN;

                DebugTrace("Error [%#x]: m_pChainContext->cChain = %d.\n", 
                           hr, m_pChainContext->cChain);
                goto ErrorExit;
            }

            if  (Index < 1 || (DWORD) Index > m_pChainContext->rgpChain[0]->cElement)
            {
                hr = E_INVALIDARG;

                DebugTrace("Error [%#x]: Index out of range, Index = %d, m_pChainContext->rgpChain[0]->cElement = %u.\n", 
                           hr, Index, m_pChainContext->rgpChain[0]->cElement);
                goto ErrorExit;
            }

            //
            // Convert string to BSTR.
            //
            if (m_pChainContext->rgpChain[0]->rgpElement[Index - 1]->pwszExtendedErrorInfo &&
                !(bstrErrorInfo = m_pChainContext->rgpChain[0]->rgpElement[Index - 1]->pwszExtendedErrorInfo))
            {
                hr = E_OUTOFMEMORY;

                DebugTrace("Error [%#x]: bstrErrorInfo = pwszExtendedErrorInfo failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Return string to caller.
            //
            *pVal = bstrErrorInfo.Detach();
        }
        else
        {
            //
            // $BUGBUG: Not supported (should we return CAPICOM_E_NOT_SUPPORTED?)
            //
            *pVal = NULL;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CChain::ExtendedErrorInfo().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// Custom interfaces.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CChain::get_ChainContext

  Synopsis : Return the chains's PCCERT_CHAIN_CONTEXT.

  Parameter: long * ppChainContext - Pointer to PCCERT_CHAIN_CONTEXT disguished
                                     in a long.

  Remark   : We need to use long instead of PCCERT_CHAIN_CONTEXT because VB 
             can't handle double indirection (i.e. vb would bark on this 
             PCCERT_CHAIN_CONTEXT * ppChainContext).
 
------------------------------------------------------------------------------*/

STDMETHODIMP CChain::get_ChainContext (long * ppChainContext)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CChain::get_ChainContext().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == ppChainContext)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter ppChainContext is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Return chain context to caller.
        //
        if (FAILED(hr = GetContext((PCCERT_CHAIN_CONTEXT *) ppChainContext)))
        {
            DebugTrace("Error [%#x]: CChain::GetContext() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CChain::get_ChainContext().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CChain::put_ChainContext

  Synopsis : Initialize the object with a CERT_CHAIN_CONTEXT.

  Parameter: long pChainContext - Poiner to CERT_CHAIN_CONTEXT, disguised in a 
                                  long, used to initialize this object.

  Remark   : Note that this is NOT 64-bit compatiable. Plese see remark of
             get_ChainContext for more detail.

------------------------------------------------------------------------------*/

STDMETHODIMP CChain::put_ChainContext (long pChainContext)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CChain::put_ChainContext().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pChainContext)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pChainContext is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Reset the object with this context.
        //
        if (FAILED(hr = PutContext((PCCERT_CHAIN_CONTEXT) pChainContext)))
        {
            DebugTrace("Error [%#x]: CChain::PutContext() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CChain::put_CertContext().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CChain::FreeContext

  Synopsis : Free a CERT_CHAIN_CONTEXT.

  Parameter: long pChainContext - Poiner to CERT_CHAIN_CONTEXT, disguised in a 
                                  long, to be freed.

  Remark   : Note that this is NOT 64-bit compatiable. Plese see remark of
             get_ChainContext for more detail.

------------------------------------------------------------------------------*/

STDMETHODIMP CChain::FreeContext (long pChainContext)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CChain::FreeContext().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pChainContext)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pChainContext is NULL.\n", hr);
            goto ErrorExit;
        }

         //
        // Free the context.
        //
        ::CertFreeCertificateChain((PCCERT_CHAIN_CONTEXT) pChainContext);
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CChain::FreeContext().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// Private methods.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CChain::Init

  Synopsis : Initialize the object.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT.

             ICertificateStatus * pIStatus - Pointer to ICertificateStus object
                                             used to build the chain.

             HCERTSTORE hAdditionalStore - Additional store handle.

             VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive chain
                                   overall validity result.
             
  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us with CERT_CONTEXT.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CChain::Init (PCCERT_CONTEXT       pCertContext, 
                           ICertificateStatus * pIStatus,
                           HCERTSTORE           hAdditionalStore,
                           VARIANT_BOOL       * pbResult)
{
    HRESULT                      hr                    = S_OK;
    VARIANT_BOOL                 bResult               = VARIANT_FALSE;
    long                         lIndex                = 0;
    long                         cEkuOid               = 0;
    long                         cIssuanceOid          = 0;
    DWORD                        dwCheckFlags          = 0;
    CAPICOM_CHECK_FLAG           UserFlags             = CAPICOM_CHECK_NONE;
    CComPtr<IEKU>                pIEku                 = NULL;
    LPSTR                      * rgpEkuOid             = NULL;
    LPSTR                      * rgpIssuanceOid        = NULL;
    PCCERT_CHAIN_CONTEXT         pChainContext         = NULL;
    CComPtr<ICertificateStatus2> pICertificateStatus2  = NULL;
    CComPtr<IOIDs>               pIApplicationPolicies = NULL;
    CComPtr<IOIDs>               pICertificatePolicies = NULL;
    DATE                         dtVerificationTime    = {0};
    SYSTEMTIME                   stVerificationTime    = {0};
    FILETIME                     ftVerificationTime    = {0};
    FILETIME                     ftUTCVerificationTime = {0};
    LPFILETIME                   pftVerificationTime   = NULL;
    DWORD                        dwUrlRetrievalTimeout = 0;
    CAPICOM_CHAIN_STATUS         PolicyStatus          = CAPICOM_CHAIN_STATUS_OK;
    CERT_CHAIN_PARA              ChainPara             = {0};
    CComBSTR                     bstrEkuOid;

    DebugTrace("Entering CChain::Init().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(pIStatus);
    ATLASSERT(pbResult);

    //
    // Is this v2?
    //
    if (FAILED(hr = pIStatus->QueryInterface(IID_ICertificateStatus2, 
                                            (void **) &pICertificateStatus2)))
    {
        DebugTrace("Info [%#x]: pIStatus->QueryInterface(IID_ICertificateStatus2) failed.\n", hr);
        hr = S_OK;
    }

    //
    // Get the user's requested check flag.
    //
    if (FAILED(hr = pIStatus->get_CheckFlag(&UserFlags)))
    {
        DebugTrace("Error [%#x]: pIStatus->CheckFlag() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Set revocation flags.
    //
    if ((CAPICOM_CHECK_ONLINE_REVOCATION_STATUS & UserFlags) || 
        (CAPICOM_CHECK_OFFLINE_REVOCATION_STATUS & UserFlags))
    {
        if (UserFlags & CAPICOM_CHECK_REVOCATION_END_CERT_ONLY)
        {
            dwCheckFlags |= CERT_CHAIN_REVOCATION_CHECK_END_CERT;
        }
        else if (UserFlags & CAPICOM_CHECK_REVOCATION_ENTIRE_CHAIN)
        {
            dwCheckFlags |= CERT_CHAIN_REVOCATION_CHECK_CHAIN;
        }
        else // default is chain minus root.
        {
            dwCheckFlags |= CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT;
        }

        if (CAPICOM_CHECK_OFFLINE_REVOCATION_STATUS & UserFlags)
        {
            dwCheckFlags |= CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY;
        }
    }

    //
    // Is this v2?
    //
    if (pICertificateStatus2)
    {
        //
        // Get verification time.
        //
        if (FAILED(hr = pICertificateStatus2->get_VerificationTime(&dtVerificationTime)))
        {
            DebugTrace("Error [%#x]: pICertificateStatus2->get_VerificationTime() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Get URL retrieval timeout.
        //
        if (FAILED(hr = pICertificateStatus2->get_UrlRetrievalTimeout((long *) &dwUrlRetrievalTimeout)))
        {
            DebugTrace("Error [%#x]: pICertificateStatus2->get_UrlRetrievalTimeout() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Try application policies.
        //
        if (FAILED(hr = pICertificateStatus2->ApplicationPolicies(&pIApplicationPolicies)))
        {
            DebugTrace("Error [%#x]: pICertificateStatus2->ApplicationPolicies() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Get count of OIDs.
        //
        if (FAILED(hr = pIApplicationPolicies->get_Count(&cEkuOid)))
        {
            DebugTrace("Error [%#x]: pIApplicationPolicies->get_Count() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Do we have any application usage?
        //
        if (0 < cEkuOid)
        {
            //
            // Allocate memory for usage array.
            //
            if (!(rgpEkuOid = (LPTSTR *) ::CoTaskMemAlloc(sizeof(LPSTR) * cEkuOid)))
            {
                hr = E_OUTOFMEMORY;

                DebugTrace("Error [%#x]: CoTaskMemAlloc() failed.\n", hr);
                goto ErrorExit;
            }
            ::ZeroMemory(rgpEkuOid, sizeof(LPSTR) * cEkuOid); 

            //
            // Setup usage array.
            //
            for (lIndex = 0; lIndex < cEkuOid; lIndex++)
            {
                CComBSTR      bstrOid;
                CComPtr<IOID> pIOID    = NULL;
                CComVariant   varOid   = NULL;
                CComVariant   varIndex = lIndex + 1;

                if (FAILED(hr = pIApplicationPolicies->get_Item(varIndex, &varOid)))
                {
                    DebugTrace("Error [%#x]: pIApplicationPolicies->get_Item() failed.\n", hr);
                    goto ErrorExit;
                }

                if (FAILED(hr = varOid.pdispVal->QueryInterface(IID_IOID, (void **) &pIOID)))
                {
                    DebugTrace("Error [%#x]: varOid.pdispVal->QueryInterface() failed.\n", hr);
                    goto ErrorExit;
                }

                if (FAILED(hr = pIOID->get_Value(&bstrOid)))
                {
                    DebugTrace("Error [%#x]: pIOID->get_Value() failed.\n", hr);
                    goto ErrorExit;
                }

                if (FAILED(hr = ::UnicodeToAnsi((LPWSTR) bstrOid,
                                                -1,
                                                &rgpEkuOid[lIndex],
                                                NULL)))
                {
                    DebugTrace("Error [%#x]:UnicodeToAnsi() failed.\n", hr);
                    goto ErrorExit;
                }
            }
        }

        //
        // OK, try issuance policies.
        //
        if (FAILED(hr = pICertificateStatus2->CertificatePolicies(&pICertificatePolicies)))
        {
            DebugTrace("Error [%#x]: pICertificateStatus2->CertificatePolicies() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Get count of OIDs.
        //
        if (FAILED(hr = pICertificatePolicies->get_Count(&cIssuanceOid)))
        {
            DebugTrace("Error [%#x]: pICertificatePolicies->get_Count() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Do we have any usage?
        //
        if (0 < cIssuanceOid)
        {
            //
            // Make sure we have WinXP and above.
            //
            if (!IsWinXPAndAbove())
            {
                hr = CAPICOM_E_NOT_SUPPORTED;

                DebugTrace("Error [%#x]: building chain with issuance policy is not support.\n", hr);
                goto ErrorExit;
            }

            //
            // Allocate memory for usage array.
            //
            if (!(rgpIssuanceOid = (LPTSTR *) ::CoTaskMemAlloc(sizeof(LPSTR) * cIssuanceOid)))
            {
                hr = E_OUTOFMEMORY;

                DebugTrace("Error [%#x]: CoTaskMemAlloc() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Setup usage array.
            //
            for (lIndex = 0; lIndex < cIssuanceOid; lIndex++)
            {
                CComBSTR      bstrOid;
                CComPtr<IOID> pIOID    = NULL;
                CComVariant   varOid   = NULL;
                CComVariant   varIndex = lIndex + 1;

                if (FAILED(hr = pICertificatePolicies->get_Item(varIndex, &varOid)))
                {
                    DebugTrace("Error [%#x]: pICertificatePolicies->get_Item() failed.\n", hr);
                    goto ErrorExit;
                }

                if (FAILED(hr = varOid.pdispVal->QueryInterface(IID_IOID, (void **) &pIOID)))
                {
                    DebugTrace("Error [%#x]: varOid.pdispVal->QueryInterface() failed.\n", hr);
                    goto ErrorExit;
                }

                if (FAILED(hr = pIOID->get_Value(&bstrOid)))
                {
                    DebugTrace("Error [%#x]: pIOID->get_Value() failed.\n", hr);
                    goto ErrorExit;
                }

                if (FAILED(hr = ::UnicodeToAnsi((LPWSTR) bstrOid,
                                                -1,
                                                &rgpIssuanceOid[lIndex],
                                                NULL)))
                {
                    DebugTrace("Error [%#x]:UnicodeToAnsi() failed.\n", hr);
                    goto ErrorExit;
                }
            }
        }
    }
    
    //
    // If we didn't find any application usage, then try the old EKU object.
    //
    if (0 == cEkuOid)
    {
        //
        // Get EKU object.
        //
        if (FAILED(hr = pIStatus->EKU(&pIEku)))
        {
            DebugTrace("Error [%#x]: pIStatus->EKU() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Get EKU OID value.
        //
        if (FAILED(hr = pIEku->get_OID(&bstrEkuOid)))
        {
            DebugTrace("Error [%#x]: pIEku->get_OID() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // If not empty EKU, then set it.
        //
        if (bstrEkuOid.Length() > 0)
        {
            //
            // Allocate memory for EKU usage array.
            //
            cEkuOid = 1;

            if (!(rgpEkuOid = (LPTSTR *) ::CoTaskMemAlloc(sizeof(LPSTR))))
            {
                hr = E_OUTOFMEMORY;

                DebugTrace("Error [%#x]: CoTaskMemAlloc() failed.\n", hr);
                goto ErrorExit;
            }
            ::ZeroMemory(rgpEkuOid, sizeof(LPSTR) * cEkuOid); 

            if (FAILED(hr = ::UnicodeToAnsi((LPWSTR) bstrEkuOid,
                                            -1,
                                            &rgpEkuOid[0],
                                            NULL)))
            {
                DebugTrace("Error [%#x]:UnicodeToAnsi() failed.\n", hr);
                goto ErrorExit;
            }
        }
    }

    //
    // If we found any usage, then force the appropriate policy check flags.
    //
    if (0 < cEkuOid)
    {
        UserFlags = (CAPICOM_CHECK_FLAG) ((DWORD) UserFlags | CAPICOM_CHECK_APPLICATION_USAGE);
    }
    if (0 < cIssuanceOid)
    {
        UserFlags = (CAPICOM_CHECK_FLAG) ((DWORD) UserFlags | CAPICOM_CHECK_CERTIFICATE_POLICY);
    }

    //
    // Initialize.
    //
    ChainPara.cbSize = sizeof(ChainPara);
    ChainPara.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
    ChainPara.RequestedUsage.Usage.cUsageIdentifier = cEkuOid;
    ChainPara.RequestedUsage.Usage.rgpszUsageIdentifier = rgpEkuOid;
    ChainPara.RequestedIssuancePolicy.dwType = USAGE_MATCH_TYPE_AND;
    ChainPara.RequestedIssuancePolicy.Usage.cUsageIdentifier = cIssuanceOid;
    ChainPara.RequestedIssuancePolicy.Usage.rgpszUsageIdentifier = rgpIssuanceOid;

    //
    // Set verification time, if specified.
    //
    if ((DATE) 0 != dtVerificationTime)
    {
        //
        // Convert to SYSTEMTIME format.
        //
        if (!::VariantTimeToSystemTime(dtVerificationTime, &stVerificationTime))
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: VariantTimeToSystemTime() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Convert to FILETIME format.
        //
        if (!::SystemTimeToFileTime(&stVerificationTime, &ftVerificationTime))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: SystemTimeToFileTime() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Convert to UTC FILETIME.
        //
        if (!::LocalFileTimeToFileTime(&ftVerificationTime, &ftUTCVerificationTime))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: LocalFileTimeToFileTime() failed.\n", hr);
            goto ErrorExit;
        }

        pftVerificationTime = &ftUTCVerificationTime;
    }

    //
    // Set URL retrieval timeout, if avaliable.
    //
    // Note: Ignored by CAPI by pre Win2K platforms.
    //
    if (0 != dwUrlRetrievalTimeout)
    {
        ChainPara.dwUrlRetrievalTimeout = dwUrlRetrievalTimeout * 1000;
    }

    //
    // Build the chain.
    //
    if (!::CertGetCertificateChain(NULL,                // in optional 
                                   pCertContext,        // in 
                                   pftVerificationTime, // in optional
                                   hAdditionalStore,    // in optional 
                                   &ChainPara,          // in 
                                   dwCheckFlags,        // in 
                                   NULL,                // in 
                                   &pChainContext))     // out 
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CertGetCertificateChain() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Chain was successfully built, so update states.
    //
    if (m_pChainContext)
    {
        ::CertFreeCertificateChain(m_pChainContext);
    }

    m_pChainContext = pChainContext;
    m_dwStatus = pChainContext->TrustStatus.dwErrorStatus;

    //
    // Verify the chain using base policy.
    //
    if (FAILED(hr = Verify(UserFlags, &PolicyStatus)))
    {
        DebugTrace("Error [%#x]: Chain::Verify() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Ignore errors that user specifically requested not to check.
    //
    if (CAPICOM_CHAIN_STATUS_REVOCATION_OFFLINE == PolicyStatus)
    {
        if (CAPICOM_CHECK_OFFLINE_REVOCATION_STATUS & UserFlags)
        {
            bResult = VARIANT_TRUE;
        
            DebugTrace("Info: offline revocation when performing offline revocation checking.\n");
            goto CommonExit;
        }
        else if (CAPICOM_CHECK_ONLINE_REVOCATION_STATUS & UserFlags)
        {
            DebugTrace("Info: offline revocation when performing online revocation checking.\n");
            goto CommonExit;
        }
    }

    if ((CAPICOM_CHECK_TRUSTED_ROOT & UserFlags) &&
        (CAPICOM_CHAIN_STATUS_UNTRUSTEDROOT == PolicyStatus))
    {
        DebugTrace("Info: chain does not verify because of untrusted root.\n");
        goto CommonExit;
    }

    if ((CAPICOM_CHECK_TIME_VALIDITY & UserFlags) &&
        (CAPICOM_CHAIN_STATUS_EXPIRED == PolicyStatus))
    {
        DebugTrace("Info: chain does not verify because of certificate expiration.\n");
        goto CommonExit;
    }

    if ((CAPICOM_CHECK_SIGNATURE_VALIDITY & UserFlags) &&
        (CAPICOM_CHAIN_STATUS_INVALID_SIGNATURE == PolicyStatus))
    {
        DebugTrace("Info: chain does not verify because of invalid certificate signature.\n");
        goto CommonExit;
    }

    if (((CAPICOM_CHECK_ONLINE_REVOCATION_STATUS | CAPICOM_CHECK_OFFLINE_REVOCATION_STATUS) & UserFlags) &&
        (CAPICOM_CHAIN_STATUS_REVOKED == PolicyStatus || CAPICOM_CHAIN_STATUS_REVOCATION_NO_CHECK == PolicyStatus))
    {
        DebugTrace("Info: chain does not verify because a certificate in the chain was revoked or could not be checked most likely due to no CDP in certificate.\n");
        goto CommonExit;
    }

    if ((CAPICOM_CHECK_COMPLETE_CHAIN & UserFlags) &&
        (CAPICOM_CHAIN_STATUS_PARTIAL_CHAINING == PolicyStatus))
    {
        DebugTrace("Info: chain does not verify because of partial chain.\n");
        goto CommonExit;
    }

    if (((CAPICOM_CHECK_APPLICATION_USAGE & UserFlags) || 
         (CAPICOM_CHECK_CERTIFICATE_POLICY & UserFlags)) &&
        (CAPICOM_CHAIN_STATUS_INVALID_USAGE == PolicyStatus))
    {
        DebugTrace("Info: chain does not verify because of invalid usage.\n");
        goto CommonExit;
    }

    if ((CAPICOM_CHECK_NAME_CONSTRAINTS & UserFlags) &&
        (CAPICOM_CHAIN_STATUS_INVALID_NAME == PolicyStatus))
    {
        DebugTrace("Info: chain does not verify because of invalid name constraints.\n");
        goto CommonExit;
    }

    if ((CAPICOM_CHECK_BASIC_CONSTRAINTS & UserFlags) &&
        (CAPICOM_CHAIN_STATUS_INVALID_BASIC_CONSTRAINTS == PolicyStatus))
    {
        DebugTrace("Info: chain does not verify because of invalid basic constraints.\n");
        goto CommonExit;
    }

    if ((CAPICOM_CHECK_NESTED_VALIDITY_PERIOD & UserFlags) &&
        (CAPICOM_CHAIN_STATUS_NESTED_VALIDITY_PERIOD == PolicyStatus))
    {
        DebugTrace("Info: chain does not verify because of invalid nested validity period.\n");
        goto CommonExit;
    }

    //
    // Everything is check out OK.
    //
    bResult = VARIANT_TRUE;

CommonExit:
    //
    // Free resources.
    //
    if (rgpEkuOid)
    {
        for (lIndex = 0; lIndex < cEkuOid; lIndex++)
        {
            if (rgpEkuOid[lIndex])
            {
                ::CoTaskMemFree(rgpEkuOid[lIndex]);
            }
        }

        ::CoTaskMemFree((LPVOID) rgpEkuOid);
    }
    if (rgpIssuanceOid)
    {
        for (lIndex = 0; lIndex < cIssuanceOid; lIndex++)
        {
            if (rgpIssuanceOid[lIndex])
            {
                ::CoTaskMemFree(rgpIssuanceOid[lIndex]);
            }
        }

        ::CoTaskMemFree((LPVOID) rgpIssuanceOid);
    }

    //
    // Return result.
    //
    *pbResult = bResult;

    DebugTrace("Leaving CChain::Init().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resouce.
    //
    if (pChainContext)
    {
        ::CertFreeCertificateChain(pChainContext);
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CChain::Verify

  Synopsis : Verify the chain using base policy.

  Parameter: CAPICOM_CHECK_FLAG CheckFlag - Check flag.

             CAPICOM_CHAIN_STATUS * pVal - Pointer to CAPICOM_CHAIN_STATUS to 
                                           receive the chain validity status.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CChain::Verify (CAPICOM_CHECK_FLAG     CheckFlag,
                             CAPICOM_CHAIN_STATUS * pVal)
{
    HRESULT                  hr           = S_OK;
    LPCSTR                   pszPolicy    = CERT_CHAIN_POLICY_BASE;
    CERT_CHAIN_POLICY_PARA   PolicyPara   = {0};
    CERT_CHAIN_POLICY_STATUS PolicyStatus = {0};

    DebugTrace("Entering CChain::Verify().\n");

    //
    // Check parameters.
    //
    if (NULL == pVal)
    {
        hr = E_INVALIDARG;

        DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
        goto ErrorExit;
    }

    //
    // Make sure chain has been built.
    //
    if (NULL == m_pChainContext)
    {
        hr = CAPICOM_E_CHAIN_NOT_BUILT;

        DebugTrace("Error [%#x]: chain object was not initialized.\n", hr);
        goto ErrorExit;
    }

    //
    // Initialize.
    //
    PolicyStatus.cbSize = sizeof(PolicyStatus);
    PolicyPara.cbSize = sizeof(PolicyPara);

    //
    // Setup policy structures.
    //
    if (0 == (CheckFlag & CAPICOM_CHECK_TIME_VALIDITY))
    {
        PolicyPara.dwFlags |= CERT_CHAIN_POLICY_IGNORE_ALL_NOT_TIME_VALID_FLAGS;
    }

    if (0 == (CheckFlag & CAPICOM_CHECK_APPLICATION_USAGE) &&
        0 == (CheckFlag & CAPICOM_CHECK_CERTIFICATE_POLICY))
    {
        PolicyPara.dwFlags |= CERT_CHAIN_POLICY_IGNORE_WRONG_USAGE_FLAG;
    }

    if (0 == (CheckFlag & CAPICOM_CHECK_NAME_CONSTRAINTS))
    {
        PolicyPara.dwFlags |= CERT_CHAIN_POLICY_IGNORE_INVALID_NAME_FLAG;
    }

    if (0 == (CheckFlag & CAPICOM_CHECK_BASIC_CONSTRAINTS))
    {
        PolicyPara.dwFlags |= CERT_CHAIN_POLICY_IGNORE_INVALID_BASIC_CONSTRAINTS_FLAG;
    }

    if (0 == (CheckFlag & CAPICOM_CHECK_NESTED_VALIDITY_PERIOD))
    {
        PolicyPara.dwFlags |= CERT_CHAIN_POLICY_IGNORE_NOT_TIME_NESTED_FLAG;
    }

    //
    // Verify the chain policy.
    //
    if (!::CertVerifyCertificateChainPolicy(pszPolicy,
                                            m_pChainContext,
                                            &PolicyPara,
                                            &PolicyStatus))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CertVerifyCertificateChainPolicy() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Return policy status to caller.
    //
    *pVal = (CAPICOM_CHAIN_STATUS) PolicyStatus.dwError;

CommonExit:

    DebugTrace("Leaving CChain::Verify().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CChain::GetContext

  Synopsis : Return the PCCERT_CHAIN_CONTEXT.

  Parameter: PCCERT_CHAIN_CONTEXT * ppChainContext - Pointer to 
                                                     PCCERT_CHAIN_CONTEXT.

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us with CERT_CONTEXT.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.

------------------------------------------------------------------------------*/

STDMETHODIMP CChain::GetContext (PCCERT_CHAIN_CONTEXT * ppChainContext)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CChain::GetContext().\n");

    //
    // Sanity check.
    //
    ATLASSERT(ppChainContext);

    //
    // Make sure chain has been built.
    //
    if (!m_pChainContext)
    {
        hr = CAPICOM_E_CHAIN_NOT_BUILT;

        DebugTrace("Error: chain object was not initialized.\n");
        goto ErrorExit;
    }

    //
    // Duplicate the chain context.
    //
    if (!(*ppChainContext = ::CertDuplicateCertificateChain(m_pChainContext)))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CertDuplicateCertificateChain() failed.\n");
        goto ErrorExit;
    }
 

CommonExit:

    DebugTrace("Leaving CChain::GetContext().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CChain::PutContext

  Synopsis : Initialize the object.

  Parameter: PCCERT_CHAIN_CONTEXT pChainContext - Chain context.
             
  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us with CERT_CONTEXT.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CChain::PutContext (PCCERT_CHAIN_CONTEXT pChainContext)
{
    HRESULT              hr             = S_OK;
    PCCERT_CHAIN_CONTEXT pChainContext2 = NULL;

    DebugTrace("Entering CChain::PutContext().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pChainContext);

    //
    // Dupliacte the context.
    //
    if (!(pChainContext2 = ::CertDuplicateCertificateChain(pChainContext)))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CertDuplicateCertificateChain() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Free ay previous chain context.
    //
    if (m_pChainContext)
    {
        ::CertFreeCertificateChain(m_pChainContext);
    }

    //
    // Update state.
    //
    m_pChainContext = pChainContext2;
    m_dwStatus = pChainContext->TrustStatus.dwErrorStatus;

CommonExit:

    DebugTrace("Leaving CChain::PutContext().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\debug.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Debug.cpp

  Content: Implementation of debugging facilities.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "Debug.h"

#ifdef _DEBUG

#define CAPICOM_DUMP_DIR_ENV_VAR   "CAPICOM_DUMP_DIR"

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : DumpToFile

  Synopsis : Dump data to file for debug analysis.

  Parameter: char * szFileName - File name (just the file name without any
                                 directory path).
  
             BYTE * pbData - Pointer to data.
             
             DWORD cbData - Size of data.

  Remark   : No action is taken if the environment variable, CAPICOM_DUMP_DIR,
             is not defined. If defined, the value should be the directory
             where the file would be created (i.e. C:\Test).

------------------------------------------------------------------------------*/

void DumpToFile (char * szFileName, BYTE * pbData, DWORD cbData)
{ 
    DWORD  dwSize = 0;
    char * szPath = NULL;
    HANDLE hFile  = NULL;

    //
    // No dump, if CAPICOM_DUMP_DIR environment is not found.
    //
    if (0 == (dwSize = ::GetEnvironmentVariableA(CAPICOM_DUMP_DIR_ENV_VAR, NULL, 0)))
    {
        goto CommonExit;
    }

    //
    // Allocate memory for the entire path (dir + filename).
    //
    if (!(szPath = (char *) ::CoTaskMemAlloc(dwSize + ::strlen(szFileName) + 1)))
    {
        goto CommonExit;
    }

    //
    // Get the dir.
    //
    if (dwSize != ::GetEnvironmentVariableA(CAPICOM_DUMP_DIR_ENV_VAR, szPath, dwSize) + 1)
    {
        goto CommonExit;
    }

    //
    // Append \ if not the last char.
    //
    if (szPath[dwSize - 1] != '\\')
    {
        ::strcat(szPath, "\\");
    }

    //
    // Form full path.
    //
    ::strcat(szPath, szFileName);

    //
    // Open the file.
    //
    if (hFile = ::CreateFileA(szPath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL))
    {
        DWORD cbWritten = 0;

        ::WriteFile(hFile,        // handle to file
                    pbData,       // data buffer
                    cbData,       // number of bytes to write
                    &cbWritten,   // number of bytes written
                    NULL);        // overlapped buffer

        ATLASSERT(cbData == cbWritten);
    }

CommonExit:
    //
    // Free resource.
    //
    if (hFile)
    {
        ::CloseHandle(hFile);
    }
    if (szPath)
    {
        ::CoTaskMemFree(szPath);
    }

    return;
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\copyitem.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows

  Copyright (C) Microsoft Corporation, 1995 - 1999

  File:    CopyItem.h

  Content: Declaration of _CopyXXXItem template class.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#ifndef __CopyItem_H_
#define __CopyItem_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <map>
#pragma warning(disable:4786) // Disable symbol names > 256 character warning.

//
// _CopyMapItem class. 
//
template <class T>
class _CopyMapItem
{
public:
    //
    // copy method.
    //
    static HRESULT copy(VARIANT * p1, std::pair<const CComBSTR, CComPtr<T> > * p2)
    {
        CComPtr<T> p = p2->second;
        CComVariant var = p;
        return VariantCopy(p1, &var);
    }

    //
    // init method.
    //
    static void init(VARIANT * p)
    {
        p->vt = VT_EMPTY;
    }

    //
    // destroy method.
    //
    static void destroy(VARIANT * p)
    {
        VariantClear(p);
    }
};

//
// _CopyBstrMap class. 
//
class _CopyClsIdMap
{
public:
    //
    // copy method.
    //
    static HRESULT copy(VARIANT * p1, std::pair<const CComBSTR, const CLSID *> * p2)
    {
        HRESULT hr;
        CComPtr<IDispatch> p;

        //
        // Create the decoder object.
        //
        if (S_OK == (hr = ::CoCreateInstance((REFCLSID) p2->second,
                                             NULL,
                                             CLSCTX_INPROC_SERVER,
                                             IID_IDispatch,
                                             (LPVOID *) &p)))
        {
            //
            // Copy.
            //
            p1->vt = VT_DISPATCH;
            hr = p->QueryInterface((IDispatch **) &(p1->pdispVal));
        }

        return hr;
    }

    //
    // init method.
    //
    static void init(VARIANT * p)
    {
        p->vt = VT_EMPTY;
    }

    //
    // destroy method.
    //
    static void destroy(VARIANT * p)
    {
        VariantClear(p);
    }
};

template <class T>
class _CopyVariant
{
public:
    //
    // init method.
    //
    static void init(VARIANT * p)
    {
        p->vt = VT_EMPTY;
    }

    //
    // copy method.
    //
    static HRESULT copy(VARIANT * p1, T * p2)
    {
        CComVariant var = *p2;
        return VariantCopy(p1, &var);
    }

    //
    // destroy method.
    //
    static void destroy(VARIANT * p)
    {
        VariantClear(p);
    }
};

#if (0) //DSIE
template <class DestinationType, class SourceType = DestinationType>
class GenericCopy
{
public :
    typedef DestinationType    destination_type;
    typedef SourceType        source_type;

    static void init(destination_type* p)
    {
        _Copy<destination_type>::init(p);
    }
    static void destroy(destination_type* p)
    {
        _Copy<destination_type>::destroy(p);
    }
    static HRESULT copy(destination_type* pTo, const source_type* pFrom)
    {
        return _Copy<destination_type>::copy(pTo, const_cast<source_type*>(pFrom));
    }

}; // class GenericCopy

template <>
class GenericCopy<VARIANT, std::string>
{
public :
    typedef VARIANT        destination_type;
    typedef std::string    source_type;

    static void init(destination_type* p)
    {
        GenericCopy<destination_type>::init(p);
    }
    static void destroy(destination_type* p)
    {
        GenericCopy<destination_type>::destroy(p);
    }
    static HRESULT copy(destination_type* pTo, const source_type* pFrom)
    {
        return CComVariant(pFrom->c_str()).Detach(pTo);
    }

}; // class GenericCopy<VARIANT, std::string>

template <>
class GenericCopy<BSTR, std::string>
{
public :
    typedef BSTR        destination_type;
    typedef std::string    source_type;

    static void init(destination_type* p)
    {
        GenericCopy<destination_type>::init(p);
    }
    static void destroy(destination_type* p)
    {
        GenericCopy<destination_type>::destroy(p);
    }
    static HRESULT copy(destination_type* pTo, const source_type* pFrom)
    {
        *pTo = CComBSTR(pFrom->c_str()).Detach();
        if (*pTo)
            return S_OK;
        else
            return E_OUTOFMEMORY;
    }

}; // class GenericCopy<BSTR, std::string>
#endif //DSIE

#endif // __CopyItem_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\decoder.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:      Decoder.cpp

  Contents:  Implementation of decoder routines.

  Remarks:

  History:   11-15-2001    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "Decoder.h"

#include "CertificatePolicies.h"

typedef HRESULT (* PFNDECODERFACTORY) (LPSTR             pszObjId,
                                       CRYPT_DATA_BLOB * pEncodedBlob,
                                       IDispatch      ** ppIDispatch);

typedef struct _tagDecoderEntry
{
    LPCSTR              pszObjId;
    PFNDECODERFACTORY   pfnDecoderFactory;
} DECODER_ENTRY;

static DECODER_ENTRY g_DecoderEntries[] =
{
    {szOID_CERT_POLICIES, CreateCertificatePoliciesObject},
};

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateDecoderObject

  Synopsis : Create a known decoder object and return the IDispatch.

  Parameter: LPSTR pszOid - OID string.
  
             CRYPT_DATA_BLOB * pEncodedBlob - Pointer to encoded data blob.

             IDispatch ** ppIDecoder - Pointer to pointer IDispatch
                                       to recieve the interface pointer.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateDecoderObject (LPSTR             pszOid,
                             CRYPT_DATA_BLOB * pEncodedBlob,
                             IDispatch      ** ppIDecoder)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CreateDecoderObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pszOid);
    ATLASSERT(pEncodedBlob);
    ATLASSERT(ppIDecoder);

    try
    {
        //
        // Initialize.
        // 
        *ppIDecoder = NULL;

        //
        // Find the decoder, if available.
        //
        for (DWORD i = 0; i < ARRAYSIZE(g_DecoderEntries); i++)
        {
            if (0 == ::strcmp(pszOid, g_DecoderEntries[i].pszObjId))
            {
                DebugTrace("Info: found a decoder for OID = %s.\n", pszOid);

                //
                // Call the corresponding decoder factory to create the decoder object.
                //
                if (FAILED(hr = g_DecoderEntries[i].pfnDecoderFactory(pszOid, pEncodedBlob, ppIDecoder)))
                {
                    DebugTrace("Error [%#x]: g_DecoderEntries[i].pfnDecoderFactory() failed.\n", hr);
                    goto ErrorExit;
                }

                break;
            }
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreateDecoderObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\decoder.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Decoder.h

  Content: Declaration of Decoder routines.

  History: 11-15-2001    dsie     created

------------------------------------------------------------------------------*/

#ifndef __DECODER_H_
#define __DECODER_H_

#include "Debug.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateDecoderObject

  Synopsis : Create a known decoder object and return the IDispatch.

  Parameter: LPSTR pszOid - OID string.
  
             CRYPT_DATA_BLOB * pEncodedBlob - Pointer to encoded data blob.

             IDispatch ** ppIDecoder - Pointer to pointer IDispatch
                                       to recieve the interface pointer.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateDecoderObject (LPSTR             pszOid,
                             CRYPT_DATA_BLOB * pEncodedBlob,
                             IDispatch      ** ppIDecoder);

#endif //__DECODER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\debug.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Debug.h

  Content: Global debug facilities.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/


#ifndef _INCLUDE_DEBUG_H
#define _INCLUDE_DEBUG_H

#ifdef CAPICOM_USE_PRINTF_FOR_DEBUG_TRACE
#define DebugTrace  printf
#else
#define DebugTrace  ATLTRACE
#endif


#ifdef _DEBUG
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : DumpToFile

  Synopsis : Dump data to file for debug analysis.

  Parameter: char * szFileName - File name (just the file name without any
                                 directory path).
  
             BYTE * pbData - Pointer to data.
             
             DWORD cbData - Size of data.

  Remark   : No action is taken if the environment variable, "CAPICOM_DUMP_DIR"
             is not defined. If defined, the value should be the directory
             where the file would be created (i.e. C:\Test).

------------------------------------------------------------------------------*/

void DumpToFile (char * szFileName, 
                 BYTE * pbData, 
                 DWORD  cbData);

#else

#define DumpToFile(f,p,c)

#endif // _DEBUG

#endif // __INCLUDE_DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\dialogui.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    DialogUI.h

  Content: Declaration of DialogUI.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#ifndef __DIALOGUI_H_
#define __DIALOGUI_H_

#include "Resource.h"

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : UserApprovedOperation

  Synopsis : Pop UI to prompt user to approve an operation.

  Parameter: DWORD iddDialog - ID of dialog to display.

             LPWSTR pwszDomain - DNS name.

  Remark   :

------------------------------------------------------------------------------*/

HRESULT UserApprovedOperation (DWORD iddDialog, LPWSTR pwszDomain);

//
// IPromptUser
//

template <class T>
class ATL_NO_VTABLE IPromptUser : public IObjectWithSiteImpl<T>
{
public:

    STDMETHODIMP OperationApproved(DWORD iddDialog)
    {
        HRESULT hr = S_OK;
        CComBSTR bstrUrl;
        CComBSTR bstrDomain;
        INTERNET_SCHEME nScheme;

        DebugTrace("Entering IPromptUser::OperationApproved().\n");

        if (FAILED(hr = GetCurrentUrl(&bstrUrl)))
        {
           DebugTrace("Error [%#x]: IPromptUser::GetCurrentUrl() failed.\n", hr);
           goto CommonExit;
        }

        DebugTrace("Info: Site URL = %ls.\n", bstrUrl);

        if (FAILED(hr = GetDomainAndScheme(bstrUrl, &bstrDomain, &nScheme)))
        {
           DebugTrace("Error [%#x]: IPromptUser::GetDomainAndScheme() failed.\n", hr);
           goto CommonExit;
        }

        DebugTrace("Info: DNS = %ls, Scheme = %#x.\n", bstrDomain, nScheme);

        if (INTERNET_SCHEME_HTTP == nScheme || INTERNET_SCHEME_HTTPS == nScheme)
        {
            if (FAILED(hr = ::UserApprovedOperation(iddDialog, bstrDomain)))
            {
               DebugTrace("Error [%#x]: UserApprovedOperation() failed.\n", hr);
               goto CommonExit;
            }
        }

    CommonExit:

        DebugTrace("Leaving IPromptUser::OperationApproved().\n");

        return hr;
    }

private:

    STDMETHODIMP GetDomainAndScheme (LPWSTR wszUrl, BSTR * pbstrDomain, INTERNET_SCHEME * pScheme)
    {
        HRESULT hr = S_OK;
        OLECHAR wszDomain[INTERNET_MAX_HOST_NAME_LENGTH];
        OLECHAR wszDecodedUrl[INTERNET_MAX_URL_LENGTH];

        URL_COMPONENTSW uc  = {0};
        DWORD cchDomain     = ARRAYSIZE(wszDomain);
        DWORD cchDecodedUrl = ARRAYSIZE(wszDecodedUrl);

        //
        // CanonicalizeUrl will change "/foo/../bar" into "/bar".
        //
        if (!::InternetCanonicalizeUrlW(wszUrl, wszDecodedUrl, &cchDecodedUrl, ICU_DECODE))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: InternetCanonicalizeUrlW() failed.\n", hr);
            return hr;
        }

        //
        // Crack will break it down into components.
        //
        uc.dwStructSize = sizeof(uc);
        uc.lpszHostName = wszDomain;
        uc.dwHostNameLength = cchDomain;

        if (!InternetCrackUrlW(wszDecodedUrl, cchDecodedUrl, ICU_DECODE, &uc))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: InternetCrackUrlW() failed.\n", hr);
            return hr;
        }

        //
        // Return domain name.
        //
        if (NULL == (*pbstrDomain = ::SysAllocString(wszDomain)))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error {%#x]: SysAllocString() failed.\n", hr);
            return hr;
        }

        *pScheme = uc.nScheme;

        return hr;
    }

    STDMETHODIMP GetCurrentUrl (BSTR * pbstrUrl)
    {
        HRESULT hr = S_OK;
        CComBSTR                  bstrUrl;
        CComPtr<IServiceProvider> spSrvProv;
        CComPtr<IWebBrowser2>     spWebBrowser;

        ATLASSERT(pbstrUrl);

        *pbstrUrl = NULL;

        if (FAILED(hr = GetSite(IID_IServiceProvider, (void **) &spSrvProv)))
        {
            DebugTrace("Error [%#x]: IPromptUser::GetSite() failed.\n", hr);
            return hr;
        }

        if (FAILED(hr = spSrvProv->QueryService(SID_SWebBrowserApp,
                                                IID_IWebBrowser2,
                                                (void**) &spWebBrowser)))
        {
            DebugTrace("Error [%#x]: spSrvProv->QueryService() failed.\n", hr);
            return hr;
        }

        if (FAILED(hr = spWebBrowser->get_LocationURL(&bstrUrl)))
        {
            DebugTrace("Error [%#x]: spWebBrowser->get_LocationURL() failed.\n", hr);
            return hr;
        }

        *pbstrUrl = bstrUrl.Detach();

        return hr;
    };
};

#endif //__DIALOGUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\eku.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    EKU.cpp

  Content: Implementation of CEKU.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "EKU.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateEKUObject

  Synopsis : Create an IEKU object and initialize the object with data
             from the specified OID.

  Parameter: LPTSTR * pszOID - Pointer to EKU OID string.
  
             IEKU ** ppIEKU - Pointer to pointer IEKU object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateEKUObject (LPSTR pszOID, IEKU ** ppIEKU)
{
    HRESULT            hr    = S_OK;
    CComObject<CEKU> * pCEKU = NULL;
    CAPICOM_EKU        EkuName;
    CComBSTR           bstrValue;

    DebugTrace("Entering CreateEKUObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(ppIEKU);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CEKU>::CreateInstance(&pCEKU)))
        {
            DebugTrace("Error [%#x]: CComObject<CEKU>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Determine EKU enum name.
        //
        if (NULL == pszOID)
        {
            EkuName = CAPICOM_EKU_OTHER;
        }
        else if (0 == ::strcmp(CAPICOM_OID_SERVER_AUTH, pszOID))
        {
            EkuName = CAPICOM_EKU_SERVER_AUTH;
        }
        else if (0 == ::strcmp(CAPICOM_OID_CLIENT_AUTH, pszOID))
        {
            EkuName = CAPICOM_EKU_CLIENT_AUTH;
        }
        else if (0 == ::strcmp(CAPICOM_OID_CODE_SIGNING, pszOID))
        {
            EkuName = CAPICOM_EKU_CODE_SIGNING;
        }
        else if (0 == ::strcmp(CAPICOM_OID_EMAIL_PROTECTION, pszOID))
        {
            EkuName = CAPICOM_EKU_EMAIL_PROTECTION;
        }
        else if (0 == ::strcmp(CAPICOM_OID_SMART_CARD_LOGON, pszOID))
        {
            EkuName = CAPICOM_EKU_SMARTCARD_LOGON;
        }
        else if (0 == ::strcmp(CAPICOM_OID_ENCRYPTING_FILE_SYSTEM, pszOID))
        {
            EkuName = CAPICOM_EKU_ENCRYPTING_FILE_SYSTEM;
        }
        else
        {
            EkuName = CAPICOM_EKU_OTHER;
        }

        //
        // Initialize object.
        //
        if (FAILED(hr = pCEKU->Init(EkuName, pszOID)))
        {
            DebugTrace("Error [%#x]: pCEKU->Init() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return interface pointer to caller.
        //
        if (FAILED(hr = pCEKU->QueryInterface(ppIEKU)))
        {
            DebugTrace("Error [%#x]: pCEKU->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreateEKUObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    if (pCEKU)
    {
        delete pCEKU;
    }

    goto CommonExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// CEKU
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEKU::get_Name

  Synopsis : Return the enum name of the EKU.

  Parameter: CAPICOM_EKU * pVal - Pointer to CAPICOM_EKU to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CEKU::get_Name (CAPICOM_EKU * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CEKU::get_Name().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
          *pVal = m_Name;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CEKU::get_Name().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEKU::put_Name

  Synopsis : Set EKU enum name.

  Parameter: CAPICOM_EKU newVal - EKU enum name.
  
  Remark   : The corresponding EKU value will be set for all except EKU_OTHER,
             in which case the user must make another explicit call to 
             put_Value to set it.

------------------------------------------------------------------------------*/

STDMETHODIMP CEKU::put_Name (CAPICOM_EKU newVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CEKU::put_Name().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    //
    // Reset value based on EKU name.
    //
    switch (newVal)
    {
        case CAPICOM_EKU_OTHER:
        {
            m_bstrOID.Empty();
            break;
        }

        case CAPICOM_EKU_SERVER_AUTH:
        {
            if (!(m_bstrOID = CAPICOM_OID_SERVER_AUTH))
            {
                hr = E_OUTOFMEMORY;

                DebugTrace("Error [%#x]: m_bstrOID = CAPICOM_OID_SERVER_AUTH failed.\n", hr);
                goto ErrorExit;
            }
            break;
        }

        case CAPICOM_EKU_CLIENT_AUTH:
        {
            if (!(m_bstrOID = CAPICOM_OID_CLIENT_AUTH))
            {
                hr = E_OUTOFMEMORY;

                DebugTrace("Error [%#x]: m_bstrOID = CAPICOM_OID_CLIENT_AUTH failed.\n", hr);
                goto ErrorExit;
            }
            break;
        }

        case CAPICOM_EKU_CODE_SIGNING:
        {
            if (!(m_bstrOID = CAPICOM_OID_CODE_SIGNING))
            {
                hr = E_OUTOFMEMORY;

                DebugTrace("Error [%#x]: m_bstrOID = CAPICOM_OID_CODE_SIGNING failed.\n", hr);
                goto ErrorExit;
            }
            break;
        }

        case CAPICOM_EKU_EMAIL_PROTECTION:
        {
            if (!(m_bstrOID = CAPICOM_OID_EMAIL_PROTECTION))
            {
                hr = E_OUTOFMEMORY;

                DebugTrace("Error [%#x]: m_bstrOID = CAPICOM_OID_EMAIL_PROTECTION failed.\n", hr);
                goto ErrorExit;
            }
            break;
        }

        case CAPICOM_EKU_SMARTCARD_LOGON:
        {
            if (!(m_bstrOID = CAPICOM_OID_SMART_CARD_LOGON))
            {
                hr = E_OUTOFMEMORY;

                DebugTrace("Error [%#x]: m_bstrOID = CAPICOM_OID_SMART_CARD_LOGON failed.\n", hr);
                goto ErrorExit;
            }
            break;
        }

        case CAPICOM_EKU_ENCRYPTING_FILE_SYSTEM:
        {
            if (!(m_bstrOID = CAPICOM_OID_ENCRYPTING_FILE_SYSTEM))
            {
                hr = E_OUTOFMEMORY;

                DebugTrace("Error [%#x]: m_bstrOID = CAPICOM_OID_ENCRYPTING_FILE_SYSTEM failed.\n", hr);
                goto ErrorExit;
            }
            break;
        }

        default:
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Unknown EKU name (%#x).\n", hr, newVal);
            goto ErrorExit;
        }
    }

    //
    // Store name.
    //
    m_Name = newVal;

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CEKU::put_Name().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEKU::get_OID

  Synopsis : Return the actual OID string of the EKU.

  Parameter: BSTR * pVal - Pointer to BSTR to receive value.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CEKU::get_OID (BSTR * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CEKU::get_OID().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
        if (FAILED(hr = m_bstrOID.CopyTo(pVal)))
        {
            DebugTrace("Error [%#x]: m_bstrOID.CopyTo() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CEKU::get_OID().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEKU::put_OID

  Synopsis : Set EKU actual OID string value.

  Parameter: BSTR newVal - EKU OID string.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CEKU::put_OID (BSTR newVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CEKU::put_OID().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure Name property is CAPICOM_EKU_OTHER.
        //
        if (CAPICOM_EKU_OTHER != m_Name)
        {
            hr = CAPICOM_E_EKU_INVALID_OID;

            DebugTrace("Error [%#x]: attemp to set EKU OID, when EKU name is not CAPICOM_EKU_OTHER.\n", hr);
            goto ErrorExit;
        }

        //
        // Store value.
        //
        if (NULL == newVal)
        {
            m_bstrOID.Empty();
        }
        else if (!(m_bstrOID = newVal))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error [%#x]: m_bstrOID = newVal failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CEKU::put_OID().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// Private methods.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEKU::Init

  Synopsis : Initialize the object.

  Parameter: CAPICOM_EKU EkuName - Enum name of EKU.

             LPSTR lpszOID - EKU OID string.

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us with CERT_CONTEXT.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CEKU::Init (CAPICOM_EKU EkuName, 
                         LPSTR       lpszOID)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CEKU::Init().\n");

    //
    // Explicitly empty the BSTR to work around ATL's bug where it calls 
    // SysAllocStringLen() with -1 when the right-hand value is NULL, and 
    // caused OLEAUT32.DLL to assert in checked build. 
    //
    // Note: ATL fixed this problem in VC 7.
    //
    if (NULL == lpszOID)
    {
        m_bstrOID.Empty();
    }
    else if (!(m_bstrOID = lpszOID))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Error [%#x]: m_bstrOID = lpszOID failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Init private members.
    //
    m_Name = EkuName;

CommonExit:

    DebugTrace("Leaving CEKU::Init().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\dialogui.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    DialogUI.CPP

  Content: UI dialogs.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"

#include "Certificate.h"
#include "Settings.h"

////////////////////////////////////////////////////////////////////////////////
//
// typedefs.
//

typedef struct _CAPICOM_DIALOG_DATA
{
    DWORD   dwDlgId;
    WCHAR   wszDomainName[INTERNET_MAX_URL_LENGTH];
    BOOL    bWasApproved;
    BOOL    bDoNotShowWasChecked;
} CAPICOM_DIALOG_DATA, * PCAPICOM_DIALOG_DATA;

static CAPICOM_DIALOG_DATA g_DialogData[] =
{
    {IDD_STORE_OPEN_SECURITY_ALERT_DLG,     '\0',   FALSE,   FALSE},
    {IDD_STORE_ADD_SECURITY_ALERT_DLG,      '\0',   FALSE,   FALSE},
    {IDD_STORE_REMOVE_SECURITY_ALERT_DLG,   '\0',   FALSE,   FALSE},
    {IDD_SIGN_SECURITY_ALERT_DLG,           '\0',   FALSE,   FALSE},
    {IDD_DECRYPT_SECURITY_ALERT_DLG,        '\0',   FALSE,   FALSE},
};

#define g_NumDialogs    (ARRAYSIZE(g_DialogData))

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CenterWindow 

  Synopsis : Certer the window to the screen.

  Parameter: HWND hwnd - Window handle.

  Remark   :

------------------------------------------------------------------------------*/

static void CenterWindow (HWND hwnd)
{
    RECT  rect;

    //
    // Sanity check.
    //
    ATLASSERT(hwnd);

    //
    // Get dimension of window.
    //
    if (::GetWindowRect(hwnd, &rect))
    {
        //
        // Calculate center point.
        //
        int wx = (::GetSystemMetrics(SM_CXSCREEN) - (rect.right - rect.left)) / 2;
        int wy = (::GetSystemMetrics(SM_CYSCREEN) - (rect.bottom - rect.top)) / 2;
        
        //
        // Position it.
        //
        if (wx > 0 && wy > 0)
        {
            ::SetWindowPos(hwnd, NULL, wx, wy, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
        }
    }

    return;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : UserApprovedOperationDlgProc

  Synopsis : UserApprovedOperation dialog proc.

  Remark   :

------------------------------------------------------------------------------*/

INT_PTR CALLBACK UserApprovedOperationDlgProc (HWND hDlg,     // Handle to dialog box
                                               UINT uMsg,     // Message
                                               WPARAM wParam, // First message parameter
                                               LPARAM lParam) // Second message parameter
{
    PCAPICOM_DIALOG_DATA pDialogData = NULL;

    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            if (lParam)
            {
                ::SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR) lParam);
            }

            CenterWindow(hDlg);

            SetFocus(GetDlgItem(hDlg, IDNO));

            return TRUE;
        }
      
        case WM_COMMAND:
        {
            if (BN_CLICKED == HIWORD(wParam)) 
            {
                switch(LOWORD(wParam)) 
                {
                    case IDYES:
                    case IDNO:
                    case IDCANCEL:
                    {
                        EndDialog(hDlg, LOWORD(wParam));
                        return TRUE;
                    }

                    case IDC_DLG_NO_SHOW_AGAIN:
                    {
                        if (pDialogData = (PCAPICOM_DIALOG_DATA) ::GetWindowLongPtr(hDlg, GWLP_USERDATA))
                        {
                            if (BST_CHECKED == ::IsDlgButtonChecked(hDlg, IDC_DLG_NO_SHOW_AGAIN))
                            {
                                pDialogData->bDoNotShowWasChecked = TRUE;
                            }
                            else
                            {
                                pDialogData->bDoNotShowWasChecked = FALSE;
                            }

                        }

                        return TRUE;
                    }
                }
            }

            break;
        }

        case WM_CLOSE:
        {
            EndDialog(hDlg, IDNO);
            return 0;
        }
    }

    return FALSE;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : UserApprovedOperation

  Synopsis : Pop UI to prompt user to approve an operation.

  Parameter: DWORD iddDialog - Dialog ID.

             LPWSTR pwszDomain - DNS name.

  Remark   :

------------------------------------------------------------------------------*/

HRESULT UserApprovedOperation (DWORD iddDialog, LPWSTR pwszDomain)
{
    HRESULT              hr          = S_OK;
    INT_PTR              iDlgRet     = 0;
    PCAPICOM_DIALOG_DATA pDialogData = NULL;

    DebugTrace("Entering UserApprovedOperation().\n");

    //
    // Sanity check.
    //
    ATLASSERT(iddDialog);
    ATLASSERT(pwszDomain);

    //
    // Determine dialog box.
    //
    for (DWORD i = 0; i < g_NumDialogs; i++)
    {
        if (iddDialog == g_DialogData[i].dwDlgId)
        {
            break;
        }
    }
    if (i == g_NumDialogs)
    {
        hr = CAPICOM_E_INTERNAL;

        DebugTrace("Error [%#x]: Unknown dialog ID (iddDialog = %#x).\n", hr, iddDialog);
        goto ErrorExit;
    }

    //
    // Point to the dialog data.
    //
    pDialogData = &g_DialogData[i];

    //
    // Had the domain changed?
    //
    if (0 != _wcsicmp(pDialogData->wszDomainName, pwszDomain))
    {
        //
        // Reset stickiness.
        //
        pDialogData->bWasApproved = FALSE;
        pDialogData->bDoNotShowWasChecked = FALSE;
        wcsncpy(pDialogData->wszDomainName, pwszDomain, INTERNET_MAX_URL_LENGTH);
        pDialogData->wszDomainName[INTERNET_MAX_URL_LENGTH - 1] = '\0';
    }

    //
    // Pop if necessary.
    //
    if (pDialogData->bDoNotShowWasChecked)
    {
        //
        // The "Do not show..." had been previously checked, so we will
        // only allow the operation if it was previously allowed.
        //
        if (!pDialogData->bWasApproved)
        {
            hr = CAPICOM_E_CANCELLED;

            DebugTrace("Info: operation presumed cancelled since \"Do not show...\" was checked and the last response wasn't YES.\n");
        }
    }
    else
    {
        //
        // The "Do not show..." had not been checked previously, so pop.
        //
        if (-1 == (iDlgRet = ::DialogBoxParamA(_Module.GetResourceInstance(),
                                               (LPSTR) MAKEINTRESOURCE(iddDialog),
                                               NULL,
                                               UserApprovedOperationDlgProc,
                                               (LPARAM) pDialogData)))
                         
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: DialogBoxParam() failed.\n");
            goto ErrorExit;
        }

        //
        // Check result.
        //
        if (IDYES == iDlgRet)
        {
            //
            // For Store.Open dialog, we always force the "Do not show..." condition.
            //
            if (IDD_STORE_OPEN_SECURITY_ALERT_DLG == iddDialog)
            {
                pDialogData->bDoNotShowWasChecked = TRUE;
            }

            pDialogData->bWasApproved = TRUE;
        }
        else
        {
            pDialogData->bWasApproved = FALSE;

            hr = CAPICOM_E_CANCELLED;
            DebugTrace("Info: operation has been cancelled by user.\n");
        }
    }

CommonExit:

    DebugTrace("Leaving UserApprovedOperation().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\ekus.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    EKUs.cpp

  Content: Implementation of CEKUs.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "EKUs.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateEKUsObject

  Synopsis : Create a IEKUs collection object and populate the collection with
             EKUs from the specified certificate.

  Parameter: PCERT_ENHKEY_USAGE pUsage - Pointer to CERT_ENHKEY_USAGE.

             IEKUs ** ppIEKUs - Pointer to pointer IEKUs object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateEKUsObject (PCERT_ENHKEY_USAGE pUsage,
                          IEKUs           ** ppIEKUs)
{
    HRESULT hr = S_OK;
    CComObject<CEKUs> * pCEKUs = NULL;

    DebugTrace("Entering CreateEKUsObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(ppIEKUs);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CEKUs>::CreateInstance(&pCEKUs)))
        {
            DebugTrace("Error [%#x]: CComObject<CEKUs>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize object.
        //
        if (FAILED(hr = pCEKUs->Init(pUsage)))
        {
            DebugTrace("Error [%#x]: pCEKUs->Init() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return interface pointer to caller.
        //
        if (FAILED(hr = pCEKUs->QueryInterface(ppIEKUs)))
        {
            DebugTrace("Unexpected error [%#x]:  pCEKUs->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreateEKUsObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    if (pCEKUs)
    {
        delete pCEKUs;
    }

    goto CommonExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// CEKUs
//

////////////////////////////////////////////////////////////////////////////////
//
// Non COM functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEKUs::Init

  Synopsis : Initialize the EKUs collection object by adding all individual
             EKU object to the collection.

  Parameter: PCERT_ENHKEY_USAGE pUsage - Pointer to CERT_ENHKEY_USAGE.

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CEKUs::Init (PCERT_ENHKEY_USAGE pUsage)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CEKUs::Init().\n");

    try
    {
        //
        // Add all EKU OIDs to the map.
        //
        if (pUsage)
        {
            //
            // Debug Log.
            //
            DebugTrace("Creating %d EKU object(s) for the EKUs collection.\n", pUsage->cUsageIdentifier);

            //
            // Make sure we have room to add.
            //
            if ((m_coll.size() + pUsage->cUsageIdentifier) > m_coll.max_size())
            {
                hr = CAPICOM_E_OUT_OF_RESOURCE;

                DebugTrace("Error [%#x]: Maximum entries (%#x) reached for EKUs collection.\n", 
                            hr, pUsage->cUsageIdentifier);
                goto ErrorExit;
            }

            for (DWORD i = 0; i < pUsage->cUsageIdentifier; i++)
            {
                //
                // Create the IEKU object for each of the EKU found in the certificate.
                //
                char szIndex[33];
                CComBSTR bstrIndex;
                CComPtr<IEKU> pIEKU;

                if (FAILED(hr = ::CreateEKUObject(pUsage->rgpszUsageIdentifier[i], &pIEKU)))
                {
                    DebugTrace("Error [%#x]: CreateEKUObject() failed.\n", hr);
                    goto ErrorExit;
                }

                //
                // BSTR index of numeric value.
                //
                wsprintfA(szIndex, "%#08x", m_coll.size() + 1);

                if (!(bstrIndex = szIndex))
                {
                    hr = E_OUTOFMEMORY;

                    DebugTrace("Error [%#x]: bstrIndex = szIndex failed.\n", hr);
                    goto ErrorExit;
                }

                //
                // Now add object to collection map.
                //
                // Note that the overloaded = operator for CComPtr will
                // automatically AddRef to the object. Also, when the CComPtr
                // is deleted (happens when the Remove or map destructor is called), 
                // the CComPtr destructor will automatically Release the object.
                //
                m_coll[bstrIndex] = pIEKU;
            }
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CEKUs::Init().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    m_coll.clear();

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\eku.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows

  Copyright (C) Microsoft Corporation, 1995 - 1999.

  File:    EKU.h

  Content: Declaration of CEKU.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#ifndef __EKU_H_
#define __EKU_H_

#include "Resource.h"
#include "Error.h"
#include "Lock.h"
#include "Debug.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateEKUObject

  Synopsis : Create an IEKU object and initialize the object with data
             from the specified OID.

  Parameter: LPTSTR * pszOID - Pointer to EKU OID string.
  
             IEKU ** ppIEKU - Pointer to pointer IEKU object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateEKUObject (LPSTR pszOID, IEKU ** ppIEKU);


////////////////////////////////////////////////////////////////////////////////
//
// CEKU
//

class ATL_NO_VTABLE CEKU : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CEKU, &CLSID_EKU>,
    public ICAPICOMError<CEKU, &IID_IEKU>,
    public IDispatchImpl<IEKU, &IID_IEKU, &LIBID_CAPICOM,
                         CAPICOM_MAJOR_VERSION, CAPICOM_MINOR_VERSION>
{
public:
    CEKU()
    {
    }

DECLARE_NO_REGISTRY()

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CEKU)
    COM_INTERFACE_ENTRY(IEKU)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CEKU)
END_CATEGORY_MAP()

    HRESULT FinalConstruct()
    {
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for EKU object.\n", hr);
            return hr;
        }

        m_Name = CAPICOM_EKU_OTHER;

        return S_OK;
    }

//
// IEKU
//
public:
    STDMETHOD(get_OID)
        (/*[out, retval]*/ BSTR * pVal);

    STDMETHOD(put_OID)
        (/*[out, retval]*/ BSTR newVal);

    STDMETHOD(get_Name)
        (/*[out, retval]*/ CAPICOM_EKU * pVal);

    STDMETHOD(put_Name)
        (/*[out, retval]*/ CAPICOM_EKU newVal);
    
    //
    // C++ member function needed to initialize the object.
    //
    STDMETHOD(Init)
        (CAPICOM_EKU EkuName, LPSTR pszOID);

private:
    CLock       m_Lock;
    CAPICOM_EKU m_Name;
    CComBSTR    m_bstrOID;
};

#endif //__EKU_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\ekus.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows

  Copyright (C) Microsoft Corporation, 1995 - 1999.

  File:    EKUs.h

  Content: Declaration of CEKUs.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#ifndef __EKUs_H_
#define __EKUs_H_

#include "Resource.h"
#include "Debug.h"
#include "CopyItem.h"
#include "EKU.h"

//
// typdefs to make life easier.
//
typedef std::map<CComBSTR, CComPtr<IEKU> > EKUMap;
typedef CComEnumOnSTL<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _CopyMapItem<IEKU>, EKUMap> EKUEnum;
typedef ICollectionOnSTLImpl<IEKUs, EKUMap, VARIANT, _CopyMapItem<IEKU>, EKUEnum> IEKUsCollection;


////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateEKUsObject

  Synopsis : Create a IEKUs collection object and populate the collection with
             EKUs from the specified certificate.

  Parameter: PCERT_ENHKEY_USAGE pUsage - Pointer to CERT_ENHKEY_USAGE.

             IEKUs ** ppIEKUs - Pointer to pointer IEKUs object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateEKUsObject (PCERT_ENHKEY_USAGE    pUsage,
                          IEKUs              ** ppIEKUs);


////////////////////////////////////////////////////////////////////////////////
//
// CEKUs
//

class ATL_NO_VTABLE CEKUs : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CEKUs, &CLSID_EKUs>,
    public ICAPICOMError<CEKUs, &IID_IEKUs>,
    public IDispatchImpl<IEKUsCollection, &IID_IEKUs, &LIBID_CAPICOM,
                         CAPICOM_MAJOR_VERSION, CAPICOM_MINOR_VERSION>
{
public:
    CEKUs()
    {
    }

DECLARE_NO_REGISTRY()

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CEKUs)
    COM_INTERFACE_ENTRY(IEKUs)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CEKUs)
END_CATEGORY_MAP()

//
// IEKUs
//
public:
    //
    // These are the only ones that we need to implemented, others will be
    // handled by ATL ICollectionOnSTLImpl.
    //

    //
    // None COM functions.
    //
    STDMETHOD(Init) 
        (PCERT_ENHKEY_USAGE pUsage);
};

#endif //__EKUs_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\encodeddata.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows

  Copyright (C) Microsoft Corporation, 1995 - 1999.

  File:    EncodedData.h

  Content: Declaration of CEncodedData.

  History: 06-15-2001    dsie     created

------------------------------------------------------------------------------*/

#ifndef __ENCODEDDATA_H_
#define __ENCODEDDATA_H_

#include "Resource.h"
#include "Error.h"
#include "Lock.h"
#include "Debug.h"

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateEncodedDataObject

  Synopsis : Create and initialize an CEncodedData object.

  Parameter: LPSTR pszOid - Pointer to OID string.
  
             CRYPT_DATA_BLOB * pEncodedBlob - Pointer to encoded data blob.
  
             IEncodedData ** ppIEncodedData - Pointer to pointer IEncodedData
                                              object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateEncodedDataObject (LPSTR             pszOid,
                                 CRYPT_DATA_BLOB * pEncodedBlob, 
                                 IEncodedData   ** ppIEncodedData);

////////////////////////////////////////////////////////////////////////////////
//
// CEncodedData
//
class ATL_NO_VTABLE CEncodedData : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CEncodedData, &CLSID_EncodedData>,
    public ICAPICOMError<CEncodedData, &IID_IEncodedData>,
    public IDispatchImpl<IEncodedData, &IID_IEncodedData, &LIBID_CAPICOM,
                         CAPICOM_MAJOR_VERSION, CAPICOM_MINOR_VERSION>
{
public:
    CEncodedData()
    {
    }

DECLARE_NO_REGISTRY()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CEncodedData)
    COM_INTERFACE_ENTRY(IEncodedData)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CEncodedData)
END_CATEGORY_MAP()

    HRESULT FinalConstruct()
    {
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for Certificate object.\n", hr);
            return hr;
        }

        m_pszOid = NULL;
        m_pIDecoder = NULL;
        m_EncodedBlob.cbData = 0;
        m_EncodedBlob.pbData = NULL;

        return S_OK;
    }

    void FinalRelease()
    {
        m_pIDecoder.Release();
        if (m_pszOid)
        {
            ::CoTaskMemFree(m_pszOid);
        }
        if (m_EncodedBlob.pbData)
        {
            ::CoTaskMemFree(m_EncodedBlob.pbData);
        }
    }

//
// IEncodedData
//
public:

    STDMETHOD(get_Value)
        (/*[in, defaultvalue(CAPICOM_ENCODE_BASE64)]*/ CAPICOM_ENCODING_TYPE EncodingType, 
         /*[out, retval]*/ BSTR * pVal);

    STDMETHOD(Format)
        (/*[in, defaultvalue(VARIANT_FALSE)]*/ VARIANT_BOOL bMultiLines,
         /*[out, retval]*/ BSTR * pVal);

    STDMETHOD(Decoder)
        (/*[out, retval]*/ IDispatch ** pVal);

    //
    // C++ member function needed to initialize the object.
    //
    STDMETHOD(Init)
        (LPSTR             pszOid,
         CRYPT_DATA_BLOB * pEncodedBlob);

private:
    CLock               m_Lock;
    LPSTR               m_pszOid;
    CComPtr<IDispatch>  m_pIDecoder;
    CRYPT_DATA_BLOB     m_EncodedBlob;
};

#endif //__ENCODEDDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\encodeddata.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    EncodedData.cpp

  Content: Implementation of CEncodedData.

  History: 06-15-2001    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "EncodedData.h"
#include "Convert.h"
#include "Decoder.h"
#include "OID.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateEncodedDataObject

  Synopsis : Create and initialize an CEncodedData object.

  Parameter: LPSTR pszOid - Pointer to OID string.
  
             CRYPT_DATA_BLOB * pEncodedBlob - Pointer to encoded data blob.
  
             IEncodedData ** ppIEncodedData - Pointer to pointer IEncodedData
                                              object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateEncodedDataObject (LPSTR             pszOid,
                                 CRYPT_DATA_BLOB * pEncodedBlob, 
                                 IEncodedData   ** ppIEncodedData)
{
    HRESULT hr = S_OK;
    CComObject<CEncodedData> * pCEncodedData = NULL;

    DebugTrace("Entering CreateEncodedDataObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pszOid);
    ATLASSERT(pEncodedBlob);
    ATLASSERT(ppIEncodedData);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CEncodedData>::CreateInstance(&pCEncodedData)))
        {
            DebugTrace("Error [%#x]: CComObject<CEncodedData>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize object.
        //
        if (FAILED(hr = pCEncodedData->Init(pszOid, pEncodedBlob)))
        {
            DebugTrace("Error [%#x]: pCEncodedData->Init() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return interface pointer to caller.
        //
        if (FAILED(hr = pCEncodedData->QueryInterface(ppIEncodedData)))
        {
            DebugTrace("Error [%#x]: pCEncodedData->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreateEncodedDataObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    if (pCEncodedData)
    {
        delete pCEncodedData;
    }

    goto CommonExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// CEncodedData
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEncodedData::get_Value

  Synopsis : Return the encoded data.

  Parameter: CAPICOM_ENCODING_TYPE EncodingType - Encoding type.
  
             BSTR * pVal - Pointer to BSTR to receive the EncodedData blob.
  Remark   : 

  NOTE     : The OID is not exported, so it is up to the caller to corelate
             the blob to the proper OID it represents.

------------------------------------------------------------------------------*/

STDMETHODIMP CEncodedData::get_Value (CAPICOM_ENCODING_TYPE EncodingType, 
                                      BSTR                * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CEncodedData::get_Value().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_pszOid);
        ATLASSERT(m_EncodedBlob.cbData);
        ATLASSERT(m_EncodedBlob.pbData);

        //
        // Export EncodedData.
        //
        if (FAILED(hr = ::ExportData(m_EncodedBlob, EncodingType, pVal)))
        {
            DebugTrace("Error [%#x]: ExportData() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }


UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CEncodedData::get_Value().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEncodedData::Format

  Synopsis : Format the encoded data.

  Parameter: VARIANT_BOOL bMultiLines - True for multi-lines format.

             BSTR * pVal - Pointer to BSTR to receive formatted output.
  
  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CEncodedData::Format (VARIANT_BOOL bMultiLines,
                                   BSTR       * pVal)
{
    HRESULT  hr         = S_OK;
    DWORD    cbFormat   = 0;
    LPWSTR   pwszFormat = NULL;

    DebugTrace("Entering CEncodedData::Format().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_pszOid);
        ATLASSERT(m_EncodedBlob.cbData);
        ATLASSERT(m_EncodedBlob.pbData);

        //
        // Format.
        //
        if (!::CryptFormatObject(X509_ASN_ENCODING,
                                 0,
                                 bMultiLines ? CRYPT_FORMAT_STR_MULTI_LINE : 0,
                                 NULL,
                                 m_pszOid,
                                 m_EncodedBlob.pbData,
                                 m_EncodedBlob.cbData,
                                 NULL,
                                 &cbFormat))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Info [%#x]: CryptFormatObject() failed to get size, so converting to hex.\n", hr);

            //
            // Most likely CryptFormatObject() does not understand the OID (downlevel platforms),
            // so try to convert it to hex ourselves.
            //
            if (FAILED(hr = ::BinaryToString(m_EncodedBlob.pbData,
                                             m_EncodedBlob.cbData,
                                             CRYPT_STRING_HEX,
                                             &*pVal,
                                             NULL)))
            {
                DebugTrace("Error [%#x]: BinaryToString() failed.\n", hr);
                goto ErrorExit;
            }

            goto UnlockExit;
        }

        if (!(pwszFormat = (LPWSTR) ::CoTaskMemAlloc(cbFormat)))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error: out of memory.\n");
            goto ErrorExit;
        }

        if (!::CryptFormatObject(X509_ASN_ENCODING,
                                 0,
                                 bMultiLines ? CRYPT_FORMAT_STR_MULTI_LINE : 0,
                                 NULL,
                                 m_pszOid,
                                 m_EncodedBlob.pbData,
                                 m_EncodedBlob.cbData,
                                 (LPVOID) pwszFormat,
                                 &cbFormat))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptFormatObject() failed to get data.\n", hr);
            goto ErrorExit;
        }

        //
        // Return formatted string to caller.
        //
        if (!(*pVal = ::SysAllocString(pwszFormat)))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error: out of memory.\n");
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }


UnlockExit:
    //
    // Free resources.
    //
    if (pwszFormat)
    {
        ::CoTaskMemFree((LPVOID) pwszFormat);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CEncodedData::Format().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEncodedData::Decoder

  Synopsis : Return the decoder object.

  Parameter: IDispatch ** pVal - Pointer to pointer to IDispatch to receive
                                 the decoder object.
  
  Remark   : Not all EncodedData has an associated decoder. CAPICOM only 
             provides certain decoders.

------------------------------------------------------------------------------*/

STDMETHODIMP CEncodedData::Decoder (IDispatch ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CEncodedData::Decoder().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

#if (0) // DSIE: is only created by us, so it is always initialized.
        //
        // Make sure object is already initialized.
        //
        if (!m_pszOid)
        {
            hr = CAPICOM_E_ENCODE_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: encode object has not been initialized.\n", hr);
            goto ErrorExit;
        }
#endif
        //
        // Sanity check.
        //
        ATLASSERT(m_pszOid);
        ATLASSERT(m_EncodedBlob.cbData);
        ATLASSERT(m_EncodedBlob.pbData);

        //
        // Do we have a decoder?
        //
        if (!m_pIDecoder)
        {
            //
            // Attempt to create one.
            //
            if (FAILED(hr = ::CreateDecoderObject(m_pszOid, &m_EncodedBlob, &m_pIDecoder)))
            {
                DebugTrace("Error [%#x]: CreateDecoderObject() failed for OID = %s.\n", hr, m_pszOid);
                goto ErrorExit;
            }

            //
            // Did we get a decoder?
            if (!m_pIDecoder)
            {
                DebugTrace("Info: no decoder found for OID = %s.\n", hr, m_pszOid);
                goto UnlockExit;
            }
        }

        //
        // Return result.
        //
        if (FAILED(hr = m_pIDecoder->QueryInterface(pVal)))
        {
            DebugTrace("Error [%#x]: m_pIDecoder->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CEncodedData::Decoder().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// Private methods.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEncodedData::Init

  Synopsis : Initialize the object.

  Parameter: LPSTR pszOid - Pointer to OID string.
  
             CRYPT_DATA_BLOB * pEncodedBlob - Pointer to encoded data blob.

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CEncodedData::Init (LPSTR             pszOid,
                                 CRYPT_DATA_BLOB * pEncodedBlob)
{
    HRESULT hr            = S_OK;
    LPSTR   pszOid2       = NULL;
    PBYTE   pbEncodedData = NULL;

    DebugTrace("Entering CEncodedData::Init().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pszOid);
    ATLASSERT(pEncodedBlob);
    ATLASSERT(pEncodedBlob->cbData);
    ATLASSERT(pEncodedBlob->pbData);

    //
    // Allocate memory for OID.
    //
    if (NULL == (pszOid2 = (LPSTR) ::CoTaskMemAlloc(::strlen(pszOid) + 1)))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Error [%#x]: CoTaskMemAlloc() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Copy.
    //
    ::strcpy(pszOid2, pszOid);

    //
    // Allocate memory for encoded blob.
    //
    if (NULL == (pbEncodedData = (PBYTE) ::CoTaskMemAlloc(pEncodedBlob->cbData)))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Error [%#x]: CoTaskMemAlloc() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Copy.
    //
    ::CopyMemory(pbEncodedData, pEncodedBlob->pbData, pEncodedBlob->cbData);

    //
    // Update states.
    //
    m_pszOid = pszOid2;
    m_pIDecoder = NULL;
    m_EncodedBlob.cbData = pEncodedBlob->cbData;
    m_EncodedBlob.pbData = pbEncodedData;

CommonExit:

    DebugTrace("Leaving CEncodedData::Init().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resources.
    //
    if (pszOid2)
    {
        ::CoTaskMemFree(pszOid2);
    }
    if (pbEncodedData)
    {
        ::CoTaskMemFree(pbEncodedData);
    }

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\encrypteddata.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    EncryptedData.h

  Content: Declaration of the CEncryptedData.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/
    
#ifndef __ENCRYPTEDDATA_H_
#define __ENCRYPTEDDATA_H_

#include "Resource.h"
#include "Lock.h"
#include "Error.h"
#include "Debug.h"
#include "Algorithm.h"

////////////////////
//
// Local defines.
//
typedef struct _EncryptedDataInfo
{
    DATA_BLOB VersionBlob;
    DATA_BLOB AlgIDBlob;
    DATA_BLOB KeyLengthBlob;
    DATA_BLOB IVBlob;
    DATA_BLOB SaltBlob;
    DATA_BLOB CipherBlob;
} CAPICOM_ENCTYPTED_DATA_INFO, * PCAPICOM_ENCRYPTED_DATA_INFO;


////////////////////////////////////////////////////////////////////////////////
//
// CEncryptedData
//

class ATL_NO_VTABLE CEncryptedData : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CEncryptedData, &CLSID_EncryptedData>,
    public ICAPICOMError<CEncryptedData, &IID_IEncryptedData>,
    public IDispatchImpl<IEncryptedData, &IID_IEncryptedData, &LIBID_CAPICOM,
                         CAPICOM_MAJOR_VERSION, CAPICOM_MINOR_VERSION>,
    public IObjectSafetyImpl<CEncryptedData, INTERFACESAFE_FOR_UNTRUSTED_CALLER | 
                                             INTERFACESAFE_FOR_UNTRUSTED_DATA>
{
public:
    CEncryptedData()
    {
    }

DECLARE_REGISTRY_RESOURCEID(IDR_ENCRYPTEDDATA)

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CEncryptedData)
    COM_INTERFACE_ENTRY(IEncryptedData)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CEncryptedData)
    IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
    IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
END_CATEGORY_MAP()

    HRESULT FinalConstruct()
    {
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for EncryptedData object.\n", hr);
            return hr;
        }

        //
        // Create embeded IAlgorithm.
        //
        if (FAILED(hr = ::CreateAlgorithmObject(FALSE, TRUE, &m_pIAlgorithm)))
        {
            DebugTrace("Error [%#x]: CreateAlgorithmObject() failed inside CEncryptedData::FinalConstruct().\n", hr);
            return hr;
        }

        //
        // Update member variables.
        //
        m_ContentBlob.cbData = 0;
        m_ContentBlob.pbData = NULL;

        return S_OK;
    }

    void FinalRelease()
    {
        if (m_ContentBlob.pbData)
        {
            ::CoTaskMemFree(m_ContentBlob.pbData);
        }

        for (DWORD i = 0; i < m_bstrSecret.Length(); i++)
        {
            m_bstrSecret.m_str[i] = (WCHAR) 0x0aa0;
            m_bstrSecret.m_str[i] = (WCHAR) 0xa00a;
        }

        m_bstrSecret.Empty();
        m_pIAlgorithm.Release();
    }

//
// IEncryptedData
//
public:
    STDMETHOD(Decrypt)
        (/*[in]*/ BSTR EncryptedMessage);

    STDMETHOD(Encrypt)
        (/*[in, defaultvalue(CAPICOM_BASE64_ENCODE)]*/ CAPICOM_ENCODING_TYPE EncodingType,
         /*[out, retval]*/ BSTR * pVal);
    
    STDMETHOD(SetSecret)
        (/*[in]*/ BSTR newVal,
         /*[in, defaultvalue(SECRET_PASSWORD)]*/ CAPICOM_SECRET_TYPE SecretType);

    STDMETHOD(get_Algorithm)
        (/*[out, retval]*/ IAlgorithm ** pVal);

    STDMETHOD(get_Content)
        (/*[out, retval]*/ BSTR * pVal);

    STDMETHOD(put_Content)
        (/*[in]*/ BSTR newVal);

private:
    CLock               m_Lock;
    DATA_BLOB           m_ContentBlob;
    CComBSTR            m_bstrSecret;
    CAPICOM_SECRET_TYPE m_SecretType;
    CComPtr<IAlgorithm> m_pIAlgorithm;

    STDMETHOD(OpenToEncode)
        (DATA_BLOB * pSaltBlob,
         HCRYPTPROV * phCryptProv,
         HCRYPTKEY * phKey);

    STDMETHOD(OpenToDecode)
        (BSTR EncryptedMessage,
         HCRYPTPROV * phCryptProv,
         HCRYPTKEY * phKey,
         CAPICOM_ENCTYPTED_DATA_INFO * pEncryptedDataInfo);

    STDMETHOD(GenerateKey)
        (HCRYPTPROV hCryptProv,
         CAPICOM_ENCRYPTION_ALGORITHM AlgoName,
         CAPICOM_ENCRYPTION_KEY_LENGTH KeyLength,
         DATA_BLOB SaltBlob,
         HCRYPTKEY * phKey);
};

#endif //__ENCRYPTEDDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\encrypteddata.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    EncryptedData.cpp

  Content: Implementation of CEncryptedData.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "EncryptedData.h"
#include "Common.h"
#include "Convert.h"

///////////////////////////////////////////////////////////////////////////////
//
// Local functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : DeriveKey

  Synopsis : Derive a session key.

  Parameter: HCRYPTPROV hCryptProv - CSP handler.

             ALG_ID AlgID - Encryption algorithm ID.

             DWORD dwKeyLength - Key length.

             DATA_BLOB SecretBlob - Secret blob.

             DATA_BLOB SaltBlob - Salt blob.

             BOOL dwEffectiveKeyLength - Effective key length.

             HCRYPTKEY * phKey - Pointer to HCRYPTKEY to receive session key.

  Remark   : 

------------------------------------------------------------------------------*/

static HRESULT DeriveKey (HCRYPTPROV  hCryptProv,
                          ALG_ID      AlgID,
                          DWORD       dwKeyLength,
                          DATA_BLOB   SecretBlob,
                          DATA_BLOB   SaltBlob,
                          DWORD       dwEffectiveKeyLength,
                          HCRYPTKEY * phKey)
{
    HRESULT    hr    = S_OK;
    HCRYPTHASH hHash = NULL;
    HCRYPTKEY  hKey  = NULL;
    DWORD      dwFlags = CRYPT_EXPORTABLE | CRYPT_NO_SALT;

    DebugTrace("Entering DeriveKey().\n");

    //
    // Sanity check.
    //
    ATLASSERT(hCryptProv);
    ATLASSERT(AlgID);
    ATLASSERT(SecretBlob.cbData);
    ATLASSERT(SecretBlob.pbData);
    ATLASSERT(SaltBlob.cbData);
    ATLASSERT(SaltBlob.pbData);
    ATLASSERT(phKey);

    //
    // Create a hash object.
    //
    if (!::CryptCreateHash(hCryptProv, CALG_SHA1, 0, 0, &hHash))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptCreateHash() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Hash in the password data.
    //
    if(!::CryptHashData(hHash, 
                        SecretBlob.pbData,
                        SecretBlob.cbData, 
                        0)) 
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptHashData() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Hash in the salt.
    //
    if(!::CryptHashData(hHash, 
                        SaltBlob.pbData,
                        SaltBlob.cbData, 
                        0)) 
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptHashData() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Dump salt value.
    //
#ifdef _DEBUG
    {
       HRESULT hr2;
       CComBSTR bstrSaltValue;

       if (FAILED(hr2 = ::BinaryToHexString(SaltBlob.pbData, SaltBlob.cbData, &bstrSaltValue)))
       {
           DebugTrace("Info [%#x]: BinaryToHexString() failed.\n", hr2);
       }
       else
       {
           DebugTrace("Info: Session salt value = %ls.\n", bstrSaltValue);
       }
    }
#endif

    //
    // Set key length.
    //
    if (CALG_RC2 == AlgID || CALG_RC4 == AlgID)
    {
        dwFlags |= dwKeyLength << 16;
    }

    //
    // Derive a session key from the hash object.
    //
    if (!::CryptDeriveKey(hCryptProv, 
                          AlgID, 
                          hHash, 
                          dwFlags, 
                          &hKey)) 
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptDeriveKey() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Dump key value.
    //
#ifdef _DEBUG
    {
        BYTE pbKeyValue[256] = {0};
        DWORD cbKeyValue = ARRAYSIZE(pbKeyValue);

        if (!::CryptExportKey(hKey, NULL, PLAINTEXTKEYBLOB, 0, pbKeyValue, &cbKeyValue))
        {
            DebugTrace("Info [%#x]: CryptExportKey() failed.\n", HRESULT_FROM_WIN32(::GetLastError()));
        }
        else
        {
            HRESULT hr3;
            CComBSTR bstrKeyValue;

            if (FAILED(hr3 = ::BinaryToHexString(pbKeyValue, cbKeyValue, &bstrKeyValue)))
            {
                DebugTrace("Info [%#x]: BinaryToHexString() failed.\n", hr3);
            }
            else
            {
                DebugTrace("Info: Session key value = %ls.\n", bstrKeyValue);
            }
        }
    }
#endif

    //
    // Set effective key length for RC2.
    //
    if (CALG_RC2 == AlgID)
    {
        DebugTrace("Info: DeriveKey() is setting RC2 effective key length to %d.\n", dwEffectiveKeyLength);

        if (!::CryptSetKeyParam(hKey, KP_EFFECTIVE_KEYLEN, (PBYTE) &dwEffectiveKeyLength, 0))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptSetKeyParam() failed.\n", hr);
            goto ErrorExit;
        }
    }

    //
    // Return session key to caller.
    //
    *phKey = hKey;

CommonExit:
    //
    // Free resource.
    //
    if (hHash)
    {
        ::CryptDestroyHash(hHash);
    }

    DebugTrace("Leaving DeriveKey().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (hKey)
    {
        ::CryptDestroyKey(hKey);
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : EncodeEncryptedData

  Synopsis : ASN.1 encode the cipher blob.

  Parameter: HCRYPTKEY hKey - Session key used to encrypt the data.

             DATA_BLOB SaltBlob - Salt blob.

             DATA_BLOB CipherBlob - Cipher blob.

             DATA_BLOB * pEncodedBlob - Pointer to DATA_BLOB to receive the
                                        ASN.1 encoded blob.

  Remark   : The format is proprietory, and should not be documented. It is  
             right now encoded as a PKCS_CONTENT_INFO_SEQUENCE_OF_ANY with
             proprietory OID.

------------------------------------------------------------------------------*/

static HRESULT EncodeEncryptedData (HCRYPTKEY   hKey, 
                                    DATA_BLOB   SaltBlob,
                                    DATA_BLOB   CipherBlob, 
                                    DATA_BLOB * pEncodedBlob)
{
    HRESULT   hr = S_OK;
    DWORD     dwCAPICOMVersion = CAPICOM_VERSION;
    DATA_BLOB KeyParamBlob[3]  = {{0, NULL}, {0, NULL}, {0, NULL}};

    DWORD i;
    CAPICOM_ENCTYPTED_DATA_INFO        EncryptedDataInfo;
    CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY EncryptedDataFormat;
    CRYPT_CONTENT_INFO                 ContentInfo;
    CRYPT_DER_BLOB                     ContentBlob = {0, NULL};

    DebugTrace("Entering EncodeEncryptedData().\n");

    //
    // Sanity check.
    //
    ATLASSERT(hKey);
    ATLASSERT(pEncodedBlob);

    //
    // Initialize.
    //
    ::ZeroMemory(pEncodedBlob, sizeof(DATA_BLOB));
    ::ZeroMemory(&ContentInfo, sizeof(ContentInfo));
    ::ZeroMemory(&EncryptedDataInfo, sizeof(EncryptedDataInfo));
    ::ZeroMemory(&EncryptedDataFormat, sizeof(EncryptedDataFormat));

    //
    // Encode the version number.
    //
    if (FAILED(hr = ::EncodeObject(X509_INTEGER, 
                                   &dwCAPICOMVersion, 
                                   &EncryptedDataInfo.VersionBlob)))
    {
        DebugTrace("Error [%#x]: EncodeObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Encode ALG_ID.
    //
    if (FAILED(hr = ::GetKeyParam(hKey, 
                                  KP_ALGID, 
                                  &KeyParamBlob[0].pbData, 
                                  &KeyParamBlob[0].cbData)))
    {
        DebugTrace("Error [%#x]: GetKeyParam() failed for KP_ALGID.\n", hr);
        goto ErrorExit;
    }

    if (FAILED(hr = ::EncodeObject(X509_INTEGER, 
                                   KeyParamBlob[0].pbData, 
                                   &EncryptedDataInfo.AlgIDBlob)))
    {
        DebugTrace("Error [%#x]: EncodeObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Encode key length.
    //
    if (FAILED(hr = ::GetKeyParam(hKey, 
                                  KP_KEYLEN, 
                                  &KeyParamBlob[1].pbData, 
                                  &KeyParamBlob[1].cbData)))
    {
        DebugTrace("Error [%#x]: GetKeyParam() failed for KP_KEYLEN.\n", hr);
        goto ErrorExit;
    }

    if (FAILED(hr = ::EncodeObject(X509_INTEGER, 
                                   KeyParamBlob[1].pbData, 
                                   &EncryptedDataInfo.KeyLengthBlob)))
    {
        DebugTrace("Error [%#x]: EncodeObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Encode IV value.
    //
    if (FAILED(hr = ::GetKeyParam(hKey, 
                                  KP_IV, 
                                  &KeyParamBlob[2].pbData, 
                                  &KeyParamBlob[2].cbData)))
    {
        DebugTrace("Error [%#x]: GetKeyParam() failed for KP_IV.\n", hr);
        goto ErrorExit;
    }

    if (FAILED(hr = ::EncodeObject(X509_OCTET_STRING, 
                                   &KeyParamBlob[2], 
                                   &EncryptedDataInfo.IVBlob)))
    {
        DebugTrace("Error [%#x]: EncodeObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Encode salt value.
    //
    if (FAILED(hr = ::EncodeObject(X509_OCTET_STRING, 
                                   &SaltBlob, 
                                   &EncryptedDataInfo.SaltBlob)))
    {
        DebugTrace("Error [%#x]: EncodeObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Encode the cipher text.
    //
    if (FAILED(hr = ::EncodeObject(X509_OCTET_STRING, 
                                   &CipherBlob, 
                                   &EncryptedDataInfo.CipherBlob)))
    {
        DebugTrace("Error [%#x]: EncodeObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Encode the entire content as PKCS_CONTENT_INFO_SEQUENCE_OF_ANY.
    //
    EncryptedDataFormat.pszObjId = szOID_CAPICOM_ENCRYPTED_CONTENT;
    EncryptedDataFormat.cValue = 6;
    EncryptedDataFormat.rgValue = (DATA_BLOB *) &EncryptedDataInfo;
    
    if (FAILED(hr = ::EncodeObject(PKCS_CONTENT_INFO_SEQUENCE_OF_ANY,
                                   &EncryptedDataFormat,
                                   &ContentBlob)))
    {
        DebugTrace("Error [%#x]: EncodeObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Finally, wrap the entire encrypted content in CONTENT_INFO.
    //
    ContentInfo.pszObjId = szOID_CAPICOM_ENCRYPTED_DATA;
    ContentInfo.Content = ContentBlob;

    if (FAILED(hr = ::EncodeObject(PKCS_CONTENT_INFO,
                                   &ContentInfo,
                                   pEncodedBlob)))
    {
        DebugTrace("Error [%#x]: EncodeObject() failed.\n", hr);
        goto ErrorExit;
    }

CommonExit:
    //
    // Free resource.
    //
    for (i = 0; i < 3; i++)
    {
        if (KeyParamBlob[i].pbData)
        {
            ::CoTaskMemFree(KeyParamBlob[i].pbData);
        }
    }
    if (EncryptedDataInfo.VersionBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.VersionBlob.pbData);
    }
    if (EncryptedDataInfo.AlgIDBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.AlgIDBlob.pbData);
    }
    if (EncryptedDataInfo.KeyLengthBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.KeyLengthBlob.pbData);
    }
    if (EncryptedDataInfo.IVBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.IVBlob.pbData);
    }
    if (EncryptedDataInfo.SaltBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.SaltBlob.pbData);
    }
    if (EncryptedDataInfo.CipherBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.CipherBlob.pbData);
    }
    if (ContentBlob.pbData)
    {
        ::CoTaskMemFree(ContentBlob.pbData);
    }

    DebugTrace("Leaving EncodeEncryptedData().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : DecodeEncryptedData

  Synopsis : ASN.1 decode the cipher text blob.

  Parameter: DATA_BLOB EncodedBlob - Encoded cipher blob.

             CAPICOM_ENCTYPTED_DATA_INFO * pEncryptedDataInfo - Pointer to 
                                                                structure to
                                                                receive decoded
                                                                structure.
  Remark   :

------------------------------------------------------------------------------*/

static HRESULT DecodeEncryptedData (DATA_BLOB                     EncodedBlob, 
                                    CAPICOM_ENCTYPTED_DATA_INFO * pEncryptedDataInfo)
{
    HRESULT   hr              = S_OK;
    DATA_BLOB ContentInfoBlob = {0, NULL};
    DATA_BLOB EncryptedBlob   = {0, NULL};

    CRYPT_CONTENT_INFO                   ContentInfo;
    CAPICOM_ENCTYPTED_DATA_INFO          EncryptedDataInfo;
    CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY * pEncryptedDataFormat = NULL;

    DebugTrace("Entering DecodeEncryptedData().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pEncryptedDataInfo);

    //
    // Initialize.
    //
    ::ZeroMemory(&ContentInfo, sizeof(ContentInfo));
    ::ZeroMemory(&EncryptedDataInfo, sizeof(EncryptedDataInfo));

    //
    // Decode the CONTENT_INFO.
    //
    if (FAILED(hr = ::DecodeObject(PKCS_CONTENT_INFO,
                                   EncodedBlob.pbData,
                                   EncodedBlob.cbData,
                                   &ContentInfoBlob)))
    {
        DebugTrace("Error [%#x]: DecodeObject() failed.\n", hr);
        goto ErrorExit;
    }
    ContentInfo = * ((CRYPT_CONTENT_INFO *) ContentInfoBlob.pbData);

    //
    // Make sure this is our CONTENT_INFO.
    //
    if (0 != ::strcmp(szOID_CAPICOM_ENCRYPTED_DATA, ContentInfo.pszObjId))
    {
        hr = CAPICOM_E_ENCRYPT_INVALID_TYPE;

        DebugTrace("Error [%#x]: Not a CAPICOM encrypted data.\n", hr);
        goto ErrorExit;
    }

    //
    // Decode the content blob.
    //
    if (FAILED(hr = ::DecodeObject(PKCS_CONTENT_INFO_SEQUENCE_OF_ANY,
                                   ContentInfo.Content.pbData,
                                   ContentInfo.Content.cbData,
                                   &EncryptedBlob)))
    {
        DebugTrace("Error [%#x]: DecodeObject() failed.\n", hr);
        goto ErrorExit;
    }
    pEncryptedDataFormat = (CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY *) EncryptedBlob.pbData;

    //
    // Make sure it is the right format.
    //
    if (0 != ::strcmp(szOID_CAPICOM_ENCRYPTED_CONTENT, pEncryptedDataFormat->pszObjId))
    {
        hr = CAPICOM_E_ENCRYPT_INVALID_TYPE;

        DebugTrace("Error [%#x]: Not a CAPICOM encrypted content.\n", hr);
        goto ErrorExit;
    }

    //
    // Sanity check.
    //
    ATLASSERT(6 == pEncryptedDataFormat->cValue);

    //
    // Decode version.
    //
    if (FAILED(hr = ::DecodeObject(X509_INTEGER,
                                   pEncryptedDataFormat->rgValue[0].pbData,
                                   pEncryptedDataFormat->rgValue[0].cbData,
                                   &EncryptedDataInfo.VersionBlob)))
    {
        DebugTrace("Error [%#x]: DecodeObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Decode ALG_ID.
    //
    if (FAILED(hr = ::DecodeObject(X509_INTEGER,
                                   pEncryptedDataFormat->rgValue[1].pbData,
                                   pEncryptedDataFormat->rgValue[1].cbData,
                                   &EncryptedDataInfo.AlgIDBlob)))
    {
        DebugTrace("Error [%#x]: DecodeObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Decode key length.
    //
    if (FAILED(hr = ::DecodeObject(X509_INTEGER,
                                   pEncryptedDataFormat->rgValue[2].pbData,
                                   pEncryptedDataFormat->rgValue[2].cbData,
                                   &EncryptedDataInfo.KeyLengthBlob)))
    {
        DebugTrace("Error [%#x]: DecodeObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Decode IV value.
    //
    if (FAILED(hr = ::DecodeObject(X509_OCTET_STRING,
                                   pEncryptedDataFormat->rgValue[3].pbData,
                                   pEncryptedDataFormat->rgValue[3].cbData,
                                   &EncryptedDataInfo.IVBlob)))
    {
        DebugTrace("Error [%#x]: DecodeObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Decode salt value.
    //
    if (FAILED(hr = ::DecodeObject(X509_OCTET_STRING,
                                   pEncryptedDataFormat->rgValue[4].pbData,
                                   pEncryptedDataFormat->rgValue[4].cbData,
                                   &EncryptedDataInfo.SaltBlob)))
    {
        DebugTrace("Error [%#x]: DecodeObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Decode cipher text.
    //
    if (FAILED(hr = ::DecodeObject(X509_OCTET_STRING,
                                   pEncryptedDataFormat->rgValue[5].pbData,
                                   pEncryptedDataFormat->rgValue[5].cbData,
                                   &EncryptedDataInfo.CipherBlob)))
    {
        DebugTrace("Error [%#x]: DecodeObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Return decoded encrypted data to caller.
    //
    *pEncryptedDataInfo = EncryptedDataInfo;

CommonExit:
    //
    // Free resource.
    //
    if (EncryptedBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedBlob.pbData);
    }
    if (ContentInfoBlob.pbData)
    {
        ::CoTaskMemFree(ContentInfoBlob.pbData);
    }

    DebugTrace("Leaving DecodeEncryptedData().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (EncryptedDataInfo.VersionBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.VersionBlob.pbData);
    }
    if (EncryptedDataInfo.AlgIDBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.AlgIDBlob.pbData);
    }
    if (EncryptedDataInfo.KeyLengthBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.KeyLengthBlob.pbData);
    }
    if (EncryptedDataInfo.IVBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.IVBlob.pbData);
    }
    if (EncryptedDataInfo.SaltBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.SaltBlob.pbData);
    }
    if (EncryptedDataInfo.CipherBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.CipherBlob.pbData);
    }

    goto CommonExit;
}


///////////////////////////////////////////////////////////////////////////////
//
// CEncryptedData
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEncryptedData::get_Content

  Synopsis : Return the content.

  Parameter: BSTR * pVal - Pointer to BSTR to receive the content.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CEncryptedData::get_Content (BSTR * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CEncryptedData::get_Content().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure content is already initialized.
        //
        if (0 == m_ContentBlob.cbData)
        {
            hr = CAPICOM_E_ENCRYPT_NOT_INITIALIZED;

            DebugTrace("Error: encrypt object has not been initialized.\n");
            goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_ContentBlob.pbData);

        //
        // Return content.
        //
        if (FAILED(hr = ::BlobToBstr(&m_ContentBlob, pVal)))
        {
            DebugTrace("Error [%#x]: BlobToBstr() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CEncryptedData::get_Content().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEncryptedData::put_Content

  Synopsis : Initialize the object with content to be encrypted.

  Parameter: BSTR newVal - BSTR containing the content to be encrypted.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CEncryptedData::put_Content (BSTR newVal)
{
    HRESULT hr = S_OK;
    DATA_BLOB ContentBlob = {0, NULL};

    DebugTrace("Entering CEncryptedData::put_Content().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (0 == ::SysStringByteLen(newVal))
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter newVal is NULL or empty.\n", hr);
            goto ErrorExit;
        }

        //
        // Covert BSTR to blob.
        //
        if (FAILED(hr = ::BstrToBlob(newVal, &ContentBlob)))
        {
            DebugTrace("Error [%#x]: BstrToBlob() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Update content.
        //
        if (m_ContentBlob.pbData)
        {
            ::CoTaskMemFree(m_ContentBlob.pbData);
        }
        m_ContentBlob = ContentBlob;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CEncryptedData::put_Content().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    //
    // Free resources.
    //
    if (ContentBlob.pbData)
    {
        ::CoTaskMemFree((LPVOID) ContentBlob.pbData);
    }

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEncryptedData::get_Algorithm

  Synopsis : Property to return the algorithm object.

  Parameter: IAlgorithm ** pVal - Pointer to pointer to IAlgorithm to receive 
                                  the interfcae pointer.
  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CEncryptedData::get_Algorithm (IAlgorithm ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CEncryptedData::get_Algorithm().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_pIAlgorithm);

        //
        // Return interface pointer to caller.
        //
        if (FAILED(hr = m_pIAlgorithm->QueryInterface(pVal)))
        {
            DebugTrace("Unexpected error [%#x]: m_pIAlgorithm->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CEncryptedData::get_Algorithm().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEncryptedData::SetSecret

  Synopsis : Set the encryption secret used to generated the session key.

  Parameter: BSTR newVal - The secret.

             CAPICOM_SECRET_TYPE SecretType - Secret type, which can be:

                    SECRET_PASSWORD = 0

  Remark   : For v1.0, we only support password secret. But, we really need
             to consider plain text session key (See Q228786), as this is one
             of the frequently asked question on the public list server.

------------------------------------------------------------------------------*/

STDMETHODIMP CEncryptedData::SetSecret (BSTR                newVal, 
                                        CAPICOM_SECRET_TYPE SecretType)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CEncryptedData::SetSecret().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (0 == ::SysStringLen(newVal) || 256 < ::SysStringLen(newVal))
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter newVal is either empty or greater than 256 characters.\n", hr);
            goto ErrorExit;
        }

        //
        // Determine secret type.
        //
        switch (SecretType)
        {
            case CAPICOM_SECRET_PASSWORD:
            {
                m_SecretType = SecretType;
                break;
            }

            default:
            {
                hr = E_INVALIDARG;

                DebugTrace("Error [%#x]: Unknown secret type (%#x).\n", hr, SecretType);
                goto ErrorExit;
            }
        }

        //
        // Initialize secret.
        //
        if (NULL == newVal)
        {
            m_bstrSecret.Empty();
        }
        else if (!(m_bstrSecret = newVal))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error [%#x]: m_bstrSecret = newVal failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CEncryptedData::SetSecret().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEncryptedData::Encrypt

  Synopsis : Encrypt the content.

  Parameter: CAPICOM_ENCODING_TYPE EncodingType - Encoding type.

             BSTR * pVal - Pointer to BSTR to receive the encrypted message.

  Remark   : Note that since CAPI still does not support PKCS 7 EncryptedData
             type, therefore, the format of the encrypted data used here is 
             propriety, and should not be documented. 

------------------------------------------------------------------------------*/

STDMETHODIMP CEncryptedData::Encrypt (CAPICOM_ENCODING_TYPE EncodingType, 
                                      BSTR                * pVal)
{
    HRESULT    hr          = S_OK;
    HCRYPTPROV hCryptProv  = NULL;
    HCRYPTKEY  hSessionKey = NULL;
    DWORD      dwBufLength = 0;
    DATA_BLOB  SaltBlob    = {0, NULL};
    DATA_BLOB  CipherBlob  = {0, NULL};
    DATA_BLOB  MessageBlob = {0, NULL};

    DebugTrace("Entering CEncryptedData::Encrypt().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure we do have content to encrypt.
        //
        if (0 == m_ContentBlob.cbData)
        {
            hr = CAPICOM_E_ENCRYPT_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: encrypt object has not been initialized.\n", hr);
            goto ErrorExit;
        }
        if (0 == m_bstrSecret.Length())
        {
            hr = CAPICOM_E_ENCRYPT_NO_SECRET;

            DebugTrace("Error [%#x]: secret is emtpty or not been set.\n", hr);
            goto ErrorExit;
        }

        //
        // Open a new message to encode.
        //
        if (FAILED(hr = OpenToEncode(&SaltBlob, &hCryptProv, &hSessionKey)))
        {
            DebugTrace("Error [%#x]: CEncryptedData::OpenToEncode() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Determine buffer length.
        //
        dwBufLength = m_ContentBlob.cbData;
        if (!::CryptEncrypt(hSessionKey,
                            NULL,
                            TRUE,
                            0,
                            NULL,
                            &dwBufLength,
                            0))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptEncrypt() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_ContentBlob.cbData <= dwBufLength);

        //
        // Copy clear text to another buffer.
        //
        if (!(CipherBlob.pbData = (PBYTE) ::CoTaskMemAlloc(dwBufLength)))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error: out of memory.\n");
            goto ErrorExit;
        }

        CipherBlob.cbData = dwBufLength;

        ::CopyMemory(CipherBlob.pbData, 
                     m_ContentBlob.pbData, 
                     m_ContentBlob.cbData);

        //
        // Encrypt.
        //
        dwBufLength = m_ContentBlob.cbData;

        if (!::CryptEncrypt(hSessionKey,
                            NULL,
                            TRUE,
                            0,
                            CipherBlob.pbData,
                            &dwBufLength,
                            CipherBlob.cbData))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptEncrypt() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Encode the cipher text.
        //
        if (FAILED(hr = ::EncodeEncryptedData(hSessionKey, 
                                              SaltBlob,
                                              CipherBlob, 
                                              &MessageBlob)))
        {
            DebugTrace("Error [%#x]: Encode() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Now export the encoded message.
        //
        if (FAILED(hr = ::ExportData(MessageBlob, EncodingType, pVal)))
        {
            DebugTrace("Error [%#x]: ExportData() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Write encoded blob to file, so we can use offline tool such as
        // ASN parser to analyze message. 
        //
        // The following line will resolve to void for non debug build, and
        // thus can be safely removed if desired.
        //
        DumpToFile("Encrypted.asn", MessageBlob.pbData, MessageBlob.cbData);
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resource.
    //
    if (MessageBlob.pbData)
    {
        ::CoTaskMemFree(MessageBlob.pbData);
    }
    if (CipherBlob.pbData)
    {
        ::CoTaskMemFree(CipherBlob.pbData);
    }
    if (hSessionKey)
    {
        ::CryptDestroyKey(hSessionKey);
    }
    if (hCryptProv)
    {
        ::ReleaseContext(hCryptProv);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CEncryptedData::Encrypt().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEncryptedData::Decrypt

  Synopsis : Decrypt the encrypted content.

  Parameter: BSTR EncryptedMessage - BSTR containing the encrypted message.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CEncryptedData::Decrypt (BSTR EncryptedMessage)
{
    HRESULT    hr           = S_OK;
    HCRYPTPROV hCryptProv   = NULL;
    HCRYPTKEY  hSessionKey  = NULL;
    DATA_BLOB  ContentBlob  = {0, NULL};
    DWORD      dwVersion    = 0;
    ALG_ID     AlgId        = 0;
    DWORD      dwKeyLength  = 0;

    CAPICOM_ENCTYPTED_DATA_INFO    EncryptedDataInfo = {0};
    CAPICOM_ENCRYPTION_ALGORITHM   AlgoName;
    CAPICOM_ENCRYPTION_KEY_LENGTH  KeyLength;

    DebugTrace("Entering CEncryptedData::Decrypt().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (0 == ::SysStringByteLen(EncryptedMessage))
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter EncryptedMessage is NULL or empty.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure secret is set.
        //
        if (0 == m_bstrSecret.Length())
        {
            hr = CAPICOM_E_ENCRYPT_NO_SECRET;

            DebugTrace("Error [%#x]: secret is empty or not been set.\n", hr);
            goto ErrorExit;
        }

        //
        // Open a new message to decode.
        //
        if (FAILED(hr = OpenToDecode(EncryptedMessage, 
                                     &hCryptProv, 
                                     &hSessionKey,
                                     &EncryptedDataInfo)))
        {
            DebugTrace("Error [%#x]: CEncryptedData::OpenToDecode() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Get version, AlgId and key length.
        //
        dwVersion = *((DWORD *) EncryptedDataInfo.VersionBlob.pbData);
        AlgId = *((ALG_ID *) EncryptedDataInfo.AlgIDBlob.pbData);
        dwKeyLength = *((DWORD *) EncryptedDataInfo.KeyLengthBlob.pbData);

        DebugTrace("Info: CAPICOM EncryptedData version = %#x.\n", dwVersion);
        DebugTrace("Info:         AlgId                 = %#x.\n", AlgId);
        DebugTrace("Info:         dwKeyLength           = %#x.\n", dwKeyLength);
            
        //
        // Copy cipher blob.
        //
        ContentBlob.cbData = ((DATA_BLOB *) EncryptedDataInfo.CipherBlob.pbData)->cbData;
        
        if (!(ContentBlob.pbData = (LPBYTE) ::CoTaskMemAlloc(ContentBlob.cbData)))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error [%#x]: CoTaskMemAlloc(ContentBlob.cbData) failed.\n", hr);
            goto ErrorExit;
        }

        ::CopyMemory(ContentBlob.pbData, 
                     ((DATA_BLOB *) EncryptedDataInfo.CipherBlob.pbData)->pbData, 
                     ContentBlob.cbData);

        //
        // Decrypt.
        //
        if (!::CryptDecrypt(hSessionKey,
                            NULL,
                            TRUE,
                            0,
                            ContentBlob.pbData,
                            &ContentBlob.cbData))
        {
            //
            // Try again for v1.0 EncryptedData with 40 bits RC2.
            //
            if (NTE_BAD_DATA == (hr = HRESULT_FROM_WIN32(::GetLastError())))
            {
                DATA_BLOB SecretBlob = {m_bstrSecret.Length() * sizeof(WCHAR), 
                                        (BYTE *) m_bstrSecret.m_str};
                DATA_BLOB SaltBlob = *((DATA_BLOB *) EncryptedDataInfo.SaltBlob.pbData);
                DATA_BLOB IVBlob = *((DATA_BLOB *)  EncryptedDataInfo.IVBlob.pbData);;

                //
                // For RC2, if encrypted with v1.0, then force 40-bits per bug 572627.
                //
                if (0x00010000 != dwVersion || CALG_RC2 != AlgId)
                {
                    hr = HRESULT_FROM_WIN32(::GetLastError());

                    DebugTrace("Error [%#x]: CryptDecrypt() failed.\n", hr);
                    goto ErrorExit;
                }

                //
                // This is most likely the case data was encrypted with
                // CAPICOM v1.0 on .Net Server or later. So, try again with 
                // effective key length set to the same as key length.
                //
                DebugTrace("Info: Data most likely encrypted by CAPICOM v.10 RC2 on .Net Server or later, so forcing effective key length.\n");

                //
                // Derive the key again.
                //
                ::CryptDestroyKey(hSessionKey), hSessionKey = NULL;

                if (FAILED(hr = ::DeriveKey(hCryptProv, 
                                            AlgId,
                                            dwKeyLength,
                                            SecretBlob,
                                            SaltBlob,
                                            dwKeyLength,
                                            &hSessionKey)))
                {
                    DebugTrace("Error [%#x]: DeriveKey() failed.\n", hr);
                    goto ErrorExit;
                }

                //
                // Set IV.
                //
                if(IVBlob.cbData && !::CryptSetKeyParam(hSessionKey, KP_IV, IVBlob.pbData, 0))
                {
                    hr = HRESULT_FROM_WIN32(::GetLastError());

                    DebugTrace("Error [%#x]: CryptSetKeyParam() failed for KP_IV.\n", hr);
                    goto ErrorExit;
                }

                //
                // Copy cipher blob again, since previous copy is destroyed by
                // CryptDecrypt because of in-place decryption.
                //
                ContentBlob.cbData = ((DATA_BLOB *) EncryptedDataInfo.CipherBlob.pbData)->cbData;
                ::CopyMemory(ContentBlob.pbData, 
                             ((DATA_BLOB *) EncryptedDataInfo.CipherBlob.pbData)->pbData, 
                             ContentBlob.cbData);

                //
                // If this still fails, then there is nothing we can do further.
                //
                if (!::CryptDecrypt(hSessionKey,
                                    NULL,
                                    TRUE,
                                    0,
                                    ContentBlob.pbData,
                                    &ContentBlob.cbData))
                {
                    hr = HRESULT_FROM_WIN32(::GetLastError());

                    DebugTrace("Error [%#x]: CryptDecrypt() failed.\n", hr);
                    goto ErrorExit;
                }
            }
        }

        //
        // Convert ALG_ID to CAPICOM_ENCRYPTION_ALGORITHM.
        //
        if (FAILED(::AlgIDToEnumName(AlgId, &AlgoName)))
        {
            //
            // Default to RC2.
            //
            AlgoName = CAPICOM_ENCRYPTION_ALGORITHM_RC2;
        }

        //
        // Convert key length value to CAPICOM_ENCRYPTION_KEY_LENGTH.
        //
        if (FAILED(::KeyLengthToEnumName(dwKeyLength, AlgId, &KeyLength)))
        {
            //
            // Default to maximum.
            //
            KeyLength = CAPICOM_ENCRYPTION_KEY_LENGTH_MAXIMUM;
        }

        //
        // Reset member variables.
        //
        if (m_ContentBlob.pbData)
        {
            ::CoTaskMemFree((LPVOID) m_ContentBlob.pbData);
        }

        //
        // Update member variables.
        //
        m_ContentBlob = ContentBlob;
        m_pIAlgorithm->put_Name(AlgoName);
        m_pIAlgorithm->put_KeyLength(KeyLength);
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resource.
    //
    if (hSessionKey)
    {
        ::CryptDestroyKey(hSessionKey);
    }
    if (hCryptProv)
    {
        ::ReleaseContext(hCryptProv);
    }
    if (EncryptedDataInfo.VersionBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.VersionBlob.pbData);
    }
    if (EncryptedDataInfo.AlgIDBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.AlgIDBlob.pbData);
    }
    if (EncryptedDataInfo.KeyLengthBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.KeyLengthBlob.pbData);
    }
    if (EncryptedDataInfo.SaltBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.SaltBlob.pbData);
    }
    if (EncryptedDataInfo.IVBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.IVBlob.pbData);
    }
    if (EncryptedDataInfo.CipherBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.CipherBlob.pbData);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CEncryptedData::Decrypt().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resources.
    //
    if (ContentBlob.pbData)
    {
        ::CoTaskMemFree((LPVOID) ContentBlob.pbData);
    }

    ReportError(hr);

    goto UnlockExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// Private member functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEncryptedData::OpenToEncode

  Synopsis : Create and initialize an encrypt message for encoding.

  Parameter: DATA_BLOB * pSaltBlob - Pointer to DATA_BLOB to receive the
                                     salt value blob.
  
             HCRYPTPROV * phCryptProv - Pointer to HCRYPTPROV to receive CSP
                                        handler.

             HCRYPTKEY * phKey - Pointer to HCRYPTKEY to receive session key.

  Remark   : 

------------------------------------------------------------------------------*/

STDMETHODIMP CEncryptedData::OpenToEncode(DATA_BLOB  * pSaltBlob,
                                          HCRYPTPROV * phCryptProv,
                                          HCRYPTKEY  * phKey)
{
    HRESULT    hr         = S_OK;
    HCRYPTPROV hCryptProv = NULL;
    HCRYPTKEY  hKey       = NULL;
    DATA_BLOB  SaltBlob   = {16, NULL};

    CAPICOM_ENCRYPTION_ALGORITHM  AlgoName;
    CAPICOM_ENCRYPTION_KEY_LENGTH KeyLength;

    DebugTrace("Entering CEncryptedData::OpenToEncode().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pSaltBlob);
    ATLASSERT(phCryptProv);
    ATLASSERT(phKey);
    ATLASSERT(m_ContentBlob.cbData && m_ContentBlob.pbData);
    ATLASSERT(m_bstrSecret);
    ATLASSERT(m_bstrSecret.Length());

    //
    // Get algorithm enum name.
    //
    if (FAILED(hr = m_pIAlgorithm->get_Name(&AlgoName)))
    {
        DebugTrace("Error [%#x]: m_pIAlgorithm->get_Name() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Get key length enum name.
    //
    if (FAILED(hr = m_pIAlgorithm->get_KeyLength(&KeyLength)))
    {
        DebugTrace("Error [%#x]: m_pIAlgorithm->get_KeyLength() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Get CSP context.
    //
    if (FAILED(hr = ::AcquireContext(AlgoName, 
                                     KeyLength, 
                                     &hCryptProv)))
    {
        DebugTrace("Error [%#x]: AcquireContext() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Generate random salt.
    //
    if (!(SaltBlob.pbData = (BYTE *) ::CoTaskMemAlloc(SaltBlob.cbData)))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Error: out of memory.\n");
        goto ErrorExit;
    }

    if (!::CryptGenRandom(hCryptProv, SaltBlob.cbData, SaltBlob.pbData))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptGenRandom() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Generate the session key.
    //
    if (FAILED(hr = GenerateKey(hCryptProv, 
                                AlgoName, 
                                KeyLength,
                                SaltBlob,
                                &hKey)))
    {
        DebugTrace("Error [%#x]: GenerateKey() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Set CMSG_ENCRYPTED_ENCODE_INFO.
    //
    *pSaltBlob = SaltBlob;
    *phCryptProv = hCryptProv;
    *phKey = hKey;

CommonExit:

    DebugTrace("Leaving CEncryptedData::OpenToEncode().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (hKey)
    {
        ::CryptDestroyKey(hKey);
    }
    if (hCryptProv)
    {
        ::ReleaseContext(hCryptProv);
    }
    if (SaltBlob.pbData)
    {
        ::CoTaskMemFree(SaltBlob.pbData);
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEncryptedData::OpenToDecode

  Synopsis : Open an encrypt message for decoding.

  Parameter: BSTR EncryptedMessage - BSTR containing the encrypted message.
  
             HCRYPTPROV * phCryptProv - Pointer to HCRYPTPROV to receive CSP
                                        handler.

             HCRYPTKEY * phKey - Pointer to HCRYPTKEY to receive session key.

             CAPICOM_ENCTYPTED_DATA_INFO * pEncryptedDataInfo;

  Remark   : 

------------------------------------------------------------------------------*/

STDMETHODIMP CEncryptedData::OpenToDecode (
        BSTR                          EncryptedMessage,
        HCRYPTPROV                  * phCryptProv,
        HCRYPTKEY                   * phKey,
        CAPICOM_ENCTYPTED_DATA_INFO * pEncryptedDataInfo)
{
    HRESULT    hr          = S_OK;
    HCRYPTPROV hCryptProv  = NULL;
    HCRYPTKEY  hKey        = NULL;
    DWORD      dwVersion   = 0;
    ALG_ID     AlgID       = 0;
    DWORD      dwKeyLength = 0;
    DATA_BLOB  MessageBlob = {0, NULL};
    DATA_BLOB  SecretBlob  = {m_bstrSecret.Length() * sizeof(WCHAR), 
                              (BYTE *) m_bstrSecret.m_str};
    DATA_BLOB SaltBlob;
    DATA_BLOB IVBlob;
    CAPICOM_ENCTYPTED_DATA_INFO EncryptedDataInfo = {0};

    DebugTrace("Entering CEncryptedData::OpenToDecode().\n");

    //
    // Sanity check.
    //
    ATLASSERT(EncryptedMessage);
    ATLASSERT(phCryptProv);
    ATLASSERT(phKey);
    ATLASSERT(pEncryptedDataInfo);
    ATLASSERT(m_bstrSecret);
    ATLASSERT(m_bstrSecret.Length());

    try
    {
        //
        // Import the message.
        //
        if (FAILED(hr = ::ImportData(EncryptedMessage, CAPICOM_ENCODE_ANY, &MessageBlob)))
        {
            DebugTrace("Error [%#x]: ImportData() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Decode the blob.
        //
        if (FAILED(hr = ::DecodeEncryptedData(MessageBlob,
                                              &EncryptedDataInfo)))
        {
            DebugTrace("Error [%#x]: DecodeEncryptedData() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Retrieve values.
        //
        dwVersion = *((DWORD *) EncryptedDataInfo.VersionBlob.pbData);
        AlgID = *((ALG_ID *) EncryptedDataInfo.AlgIDBlob.pbData);
        dwKeyLength = *((DWORD *) EncryptedDataInfo.KeyLengthBlob.pbData);
        SaltBlob = *((DATA_BLOB *) EncryptedDataInfo.SaltBlob.pbData);
        IVBlob = *((DATA_BLOB *)  EncryptedDataInfo.IVBlob.pbData);

        //
        // Get CSP context.
        //
        if (FAILED(hr = ::AcquireContext(AlgID,
                                         dwKeyLength, 
                                         &hCryptProv)))
        {
            DebugTrace("Error [%#x]: AcquireContext() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Derive the key. For RC2, if encrypted with v1.0, then force 
        // 40-bits per bug 572627.
        //
        if (FAILED(hr = ::DeriveKey(hCryptProv, 
                                    AlgID,
                                    dwKeyLength,
                                    SecretBlob,
                                    SaltBlob,
                                    dwVersion == 0x00010000 ? 40 : dwKeyLength,
                                    &hKey)))
        {
            DebugTrace("Error [%#x]: DeriveKey() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Set IV, if required.
        //
        if ((CALG_RC2 == AlgID) || (CALG_DES == AlgID) || (CALG_3DES == AlgID))
        {
            //
            // Set IV.
            //
            if(IVBlob.cbData && !::CryptSetKeyParam(hKey, KP_IV, IVBlob.pbData, 0))
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());

                DebugTrace("Error [%#x]: CryptSetKeyParam() failed for KP_IV.\n", hr);
                goto ErrorExit;
            }

            //
            // Dump IV value.
            //
#ifdef _DEBUG
            {
               HRESULT hr2;
               CComBSTR bstrIVValue;

               if (FAILED(hr2 = ::BinaryToHexString(IVBlob.pbData, IVBlob.cbData, &bstrIVValue)))
               {
                   DebugTrace("Info [%#x]: BinaryToHexString() failed.\n", hr2);
               }
               else
               {
                   DebugTrace("Info: Session IV value = %ls.\n", bstrIVValue);
               }
            }
#endif
        }

        //
        // Return results to caller.
        //
        *phCryptProv = hCryptProv;
        *phKey = hKey;
        *pEncryptedDataInfo = EncryptedDataInfo;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:
    //
    // Free resource.
    //
    if (MessageBlob.pbData)
    {
        ::CoTaskMemFree(MessageBlob.pbData);
    }

    DebugTrace("Leaving CEncryptedData::OpenToDecode().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (hKey)
    {
        ::CryptDestroyKey(hKey);
    }
    if (hCryptProv)
    {
        ::ReleaseContext(hCryptProv);
    }
    if (EncryptedDataInfo.VersionBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.VersionBlob.pbData);
    }
    if (EncryptedDataInfo.AlgIDBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.AlgIDBlob.pbData);
    }
    if (EncryptedDataInfo.KeyLengthBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.KeyLengthBlob.pbData);
    }
    if (EncryptedDataInfo.SaltBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.SaltBlob.pbData);
    }
    if (EncryptedDataInfo.IVBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.IVBlob.pbData);
    }
    if (EncryptedDataInfo.CipherBlob.pbData)
    {
        ::CoTaskMemFree(EncryptedDataInfo.CipherBlob.pbData);
    }

    goto CommonExit;
}
    
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEncryptedData::GenerateKey

  Synopsis : Generate the session key.

  Parameter: HCRYPTPROV hCryptProv - CSP handler.

             CAPICOM_ENCRYPTION_ALGORITHM AlogName - Algo enum name.

             CAPICOM_ENCRYPTION_KEY_LENGTH KeyLength - Key length enum name.

             DATA_BLOB SaltBlob - Salt blob.

             HCRYPTKEY * phKey - Pointer to HCRYPTKEY to receive session key.

  Remark   : 

------------------------------------------------------------------------------*/

STDMETHODIMP CEncryptedData::GenerateKey (
        HCRYPTPROV                    hCryptProv,
        CAPICOM_ENCRYPTION_ALGORITHM  AlgoName,
        CAPICOM_ENCRYPTION_KEY_LENGTH KeyLength,
        DATA_BLOB                     SaltBlob,
        HCRYPTKEY                   * phKey)
{
    HRESULT    hr          = S_OK;
    HCRYPTKEY  hKey        = NULL;
    ALG_ID     AlgId       = 0;
    DWORD      dwKeyLength = 0;
    DATA_BLOB  SecretBlob  = {m_bstrSecret.Length() * sizeof(WCHAR), 
                              (BYTE *) m_bstrSecret.m_str};
    DWORD      dwBlockLen  = 0;
    DWORD      cbBlockLen  = sizeof(dwBlockLen);
    DATA_BLOB  IVBlob      = {0, NULL};

    DebugTrace("Entering CEncryptedData::GenerateKey().\n");

    //
    // Sanity check.
    //
    ATLASSERT(hCryptProv);
    ATLASSERT(phKey);
    ATLASSERT(SaltBlob.cbData);
    ATLASSERT(SaltBlob.pbData);

    //
    // Conver to ALG_ID.
    //
    if (FAILED(hr = ::EnumNameToAlgID(AlgoName, KeyLength, &AlgId)))
    {
        DebugTrace("Error [%#x]: EnumNameToAlgID() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Set key length for RC2 and RC4.
    //
    if ((CALG_RC2 == AlgId || CALG_RC4 == AlgId) &&
        FAILED(hr = ::EnumNameToKeyLength(KeyLength, AlgId, &dwKeyLength)))
    {
        DebugTrace("Error [%#x]: EnumNameToKeyLength() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Derive a session key from the secret.
    //
    if (FAILED(hr = DeriveKey(hCryptProv, 
                              AlgId, 
                              dwKeyLength, 
                              SecretBlob,
                              SaltBlob,
                              dwKeyLength,
                              &hKey)) )
    {
        DebugTrace("Error [%#x]: DeriveKey() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Generate random IV, if required.
    //
    if ((CALG_RC2 == AlgId) || (CALG_DES == AlgId) || (CALG_3DES == AlgId))
    {
        //
        // Get block size.
        //
        if (!::CryptGetKeyParam(hKey, KP_BLOCKLEN, (BYTE *) &dwBlockLen, &cbBlockLen, 0))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptGetKeyParam() failed for KP_BLOCKLEN.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure block length is valid.
        //
        if (IVBlob.cbData = dwBlockLen / 8)
        {
            //
            // Allocate memory.
            //
            if (!(IVBlob.pbData = (BYTE *) ::CoTaskMemAlloc(IVBlob.cbData)))
            {
                hr = E_OUTOFMEMORY;

                DebugTrace("Error: out of memory.\n");
                goto ErrorExit;
            }

            //
            // Generate random IV.
            //
            if(!::CryptGenRandom(hCryptProv, IVBlob.cbData, IVBlob.pbData)) 
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());

                DebugTrace("Error [%#x]: CryptGenRandom() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Set IV.
            //
            if(IVBlob.cbData && !::CryptSetKeyParam(hKey, KP_IV, IVBlob.pbData, 0))
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());

                DebugTrace("Error [%#x]: CryptSetKeyParam() failed for KP_IV.\n", hr);
                goto ErrorExit;
            }

            //
            // Dump IV value.
            //
#ifdef _DEBUG
            {
               HRESULT hr2;
               CComBSTR bstrIVValue;

               if (FAILED(hr2 = ::BinaryToHexString(IVBlob.pbData, IVBlob.cbData, &bstrIVValue)))
               {
                   DebugTrace("Info [%#x]: BinaryToHexString() failed.\n", hr2);
               }
               else
               {
                   DebugTrace("Info: Session IV value = %ls.\n", bstrIVValue);
               }
            }
#endif
        }
    }

    //
    // Return session key to caller.
    //
    *phKey = hKey;

CommonExit:
    //
    // Free resource.
    //
    if (IVBlob.pbData)
    {
        ::CoTaskMemFree(IVBlob.pbData);
    }

    DebugTrace("Leaving EncryptedData::GenerateKey().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (hKey)
    {
        ::CryptDestroyKey(hKey);
    }

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\envelopeddata.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    EnvelopedData.h

  Content: Declaration of the CEnvelopedData.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#ifndef __ENVELOPEDDATA_H_
#define __ENVELOPEDDATA_H_

#include "Resource.h"
#include "Lock.h"
#include "Error.h"
#include "Debug.h"
#include "Certificate.h"
#include "Recipients.h"
#include "Algorithm.h"
#include "DialogUI.h"

///////////////////////////////////////////////////////////////////////////////
//
// CEnvelopedData
//

class ATL_NO_VTABLE CEnvelopedData : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CEnvelopedData, &CLSID_EnvelopedData>,
    public ICAPICOMError<CEnvelopedData, &IID_IEnvelopedData>,
    public IPromptUser<CEnvelopedData>,
    public IDispatchImpl<IEnvelopedData, &IID_IEnvelopedData, &LIBID_CAPICOM,
                         CAPICOM_MAJOR_VERSION, CAPICOM_MINOR_VERSION>,
    public IObjectSafetyImpl<CEnvelopedData, INTERFACESAFE_FOR_UNTRUSTED_CALLER | 
                                             INTERFACESAFE_FOR_UNTRUSTED_DATA>
{
public:
    CEnvelopedData()
    {
    }

DECLARE_REGISTRY_RESOURCEID(IDR_ENVELOPEDDATA)

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CEnvelopedData)
    COM_INTERFACE_ENTRY(IEnvelopedData)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(IObjectWithSite)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CEnvelopedData)
    IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
    IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
END_CATEGORY_MAP()

    HRESULT FinalConstruct()
    {
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for EnvelopedData object.\n", hr);
            return hr;
        }

        if (FAILED(hr = Init()))
        {
            DebugTrace("Error [%#x]: CEnvelopedData::Init() failed inside CEnvelopedData::FinalConstruct().\n", hr);
            return hr;
        }

        return S_OK;
    }

    void FinalRelease()
    {
        if (m_ContentBlob.pbData)
        {
            ::CoTaskMemFree(m_ContentBlob.pbData);
        }

        m_pIAlgorithm.Release();
        m_pIRecipients.Release();
    }

//
// IEnvelopedData
//
public:
    STDMETHOD(Decrypt)
        (/*[in]*/ BSTR EnvelopedMessage);

    STDMETHOD(Encrypt)
        (/*[in, defaultvalue(CAPICOM_BASE64_ENCODE)]*/ CAPICOM_ENCODING_TYPE EncodingType, 
         /*[out, retval]*/ BSTR * pVal);

    STDMETHOD(get_Recipients)
        (/*[out, retval]*/ IRecipients ** pVal);

    STDMETHOD(get_Algorithm)
        (/*[out, retval]*/ IAlgorithm ** pVal);

    STDMETHOD(get_Content)
        (/*[out, retval]*/ BSTR * pVal);

    STDMETHOD(put_Content)
        (/*[in]*/ BSTR newVal);

private:
    CLock                m_Lock;
    BOOL                 m_bEnveloped;
    DATA_BLOB            m_ContentBlob;
    CComPtr<IAlgorithm>  m_pIAlgorithm;
    CComPtr<IRecipients> m_pIRecipients;

    STDMETHOD(Init)();

    STDMETHOD(OpenToEncode)
        (HCRYPTMSG * phMsg, 
         HCRYPTPROV * hCryptProv);

    STDMETHOD(OpenToDecode)
        (HCRYPTPROV hCryptProv,
         BSTR EnvelopedMessage,
         HCRYPTMSG * phMsg);
};

#endif //__ENVELOPEDDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\envelopeddata.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    EnvelopedData.cpp

  Content: Implementation of CEnvelopedData.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "EnvelopedData.h"

#include "Common.h"
#include "Convert.h"
#include "CertHlpr.h"
#include "MsgHlpr.h"
#include "SignHlpr.h"
#include "Settings.h"

////////////////////////////////////////////////////////////////////////////////
//
// Local functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : SelectRecipientCertCallback 

  Synopsis : Callback routine for CryptUIDlgSelectCertificateW() API for
             recipient's cert selection.

  Parameter: See CryptUI.h for defination.

  Remark   : Filter out any cert that is not time valid.

------------------------------------------------------------------------------*/

static BOOL WINAPI SelectRecipientCertCallback (PCCERT_CONTEXT pCertContext,
                                                BOOL *         pfInitialSelectedCert,
                                                void *         pvCallbackData)
{
    int nValidity = 0;

    //
    // Check cert time validity.
    //
    if (0 != (nValidity = ::CertVerifyTimeValidity(NULL, pCertContext->pCertInfo)))
    {
        DebugTrace("Info: SelectRecipientCertCallback() - invalid time (%s).\n", 
                    nValidity < 0 ? "not yet valid" : "expired");
        return FALSE;
    }

    return TRUE;
}


////////////////////////////////////////////////////////////////////////////////
//
// CEnvelopedData
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : SetKeyLength

  Synopsis : Setup the symetric encryption key length.

  Parameter: HCRYPTPROV hCryptProv - CSP handle.
  
             CRYPT_ALGORITHM_IDENTIFIER EncryptAlgorithm - Encryption algorithm.

             CAPICOM_ENCRYPTION_KEY_LENGTH KeyLength - Key length.

             void ** pAuxInfo - Receive NULL or allocated and initialized
                                aux info structure.
  Remark   :

------------------------------------------------------------------------------*/

static HRESULT SetKeyLength (
        HCRYPTPROV                    hCryptProv,
        CRYPT_ALGORITHM_IDENTIFIER    EncryptAlgorithm,
        CAPICOM_ENCRYPTION_KEY_LENGTH KeyLength,
        void                       ** ppAuxInfo)
{
    HRESULT hr    = S_OK;
    ALG_ID  AlgID = 0;
    PROV_ENUMALGS_EX  peex;
    CMSG_RC2_AUX_INFO * pRC2AuxInfo = NULL;
    CMSG_RC4_AUX_INFO * pRC4AuxInfo = NULL;

    DebugTrace("Entering SetKeyLength().\n");

    //
    // Sanity check.
    //
    ATLASSERT(hCryptProv);
    ATLASSERT(ppAuxInfo);

    //
    // Initialize.
    //
    *ppAuxInfo = (void *) NULL;

    //
    // Get ALG_ID.
    //
    if (FAILED(hr = ::OIDToAlgID(EncryptAlgorithm.pszObjId, &AlgID)))
    {
        DebugTrace("Error [%#x]: OIDToAlgID() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Get algorithm capability from CSP.
    //
    if (FAILED(::IsAlgSupported(hCryptProv, AlgID, &peex)))
    {
        hr = CAPICOM_E_NOT_SUPPORTED;

        DebugTrace("Error: requested encryption algorithm is not available.\n");
        goto ErrorExit;
    }

    //
    // Setup AuxInfo for RC2.
    //
    if (CALG_RC2 == AlgID)
    {
        //
        // Allocate and intialize memory for RC2 AuxInfo structure.
        //
        if (!(pRC2AuxInfo = (CMSG_RC2_AUX_INFO *) ::CoTaskMemAlloc(sizeof(CMSG_RC2_AUX_INFO))))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error: out of memory.\n");
            goto ErrorExit;
        }

        ::ZeroMemory(pRC2AuxInfo, sizeof(CMSG_RC2_AUX_INFO));
        pRC2AuxInfo->cbSize = sizeof(CMSG_RC2_AUX_INFO);

        //
        // Determine key length requested.
        //
        if (CAPICOM_ENCRYPTION_KEY_LENGTH_MAXIMUM == KeyLength)
        {
            pRC2AuxInfo->dwBitLen = peex.dwMaxLen;
        }
        else if (CAPICOM_ENCRYPTION_KEY_LENGTH_40_BITS == KeyLength)
        {
            if (peex.dwMinLen <= 40 && 40 <= peex.dwMaxLen)
            {
                pRC2AuxInfo->dwBitLen = 40;
            }
            else
            {
                hr = CAPICOM_E_NOT_SUPPORTED;

                DebugTrace("Error [%#x]: 40-bits encryption is not available.\n", hr);
                goto ErrorExit;
            }
        }
        else if (CAPICOM_ENCRYPTION_KEY_LENGTH_56_BITS == KeyLength)
        {
            if (peex.dwMinLen <= 56 && 56 <= peex.dwMaxLen)
            {
                pRC2AuxInfo->dwBitLen = 56;
            }
            else
            {
                hr = CAPICOM_E_NOT_SUPPORTED;

                DebugTrace("Error [%#x]: 56-bits encryption is not available.\n", hr);
                goto ErrorExit;
            }
        }
        else if (CAPICOM_ENCRYPTION_KEY_LENGTH_128_BITS == KeyLength)
        {
            if (peex.dwMinLen <= 128 && 128 <= peex.dwMaxLen)
            {
                pRC2AuxInfo->dwBitLen = 128;
            }
            else
            {
                hr = CAPICOM_E_NOT_SUPPORTED;

                DebugTrace("Error [%#x]: 128-bits encryption is not available.\n", hr);
                goto ErrorExit;
            }
        }
        else
        {
            //
            // Should never get to here.
            //
            hr = CAPICOM_E_INTERNAL;

            DebugTrace("Error [%#x]: Unknown key length (%d).\n", hr, KeyLength);
            goto ErrorExit;
        }

        //
        // Return RC2 AuxInfo pointer to caller.
        //
        *ppAuxInfo = (void *) pRC2AuxInfo;
    }
    else if (CALG_RC4 == AlgID)
    {
        //
        // Allocate and intialize memory for RC4 AuxInfo structure.
        //
        if (!(pRC4AuxInfo = (CMSG_RC4_AUX_INFO *) ::CoTaskMemAlloc(sizeof(CMSG_RC4_AUX_INFO))))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error: out of memory.\n");
                goto ErrorExit;
        }

        ::ZeroMemory(pRC4AuxInfo, sizeof(CMSG_RC4_AUX_INFO));
        pRC4AuxInfo->cbSize = sizeof(CMSG_RC4_AUX_INFO);

        //
        // Determine key length requested.
        //
        if (CAPICOM_ENCRYPTION_KEY_LENGTH_MAXIMUM == KeyLength)
        {
            pRC4AuxInfo->dwBitLen = peex.dwMaxLen;
        }
        else if (CAPICOM_ENCRYPTION_KEY_LENGTH_40_BITS == KeyLength)
        {
            if (peex.dwMinLen <= 40 && 40 <= peex.dwMaxLen)
            {
                pRC4AuxInfo->dwBitLen = 40;
            }
            else
            {
                hr = CAPICOM_E_NOT_SUPPORTED;

                DebugTrace("Error [%#x]: 40-bits encryption is not available.\n", hr);
                goto ErrorExit;
            }
        }
        else if (CAPICOM_ENCRYPTION_KEY_LENGTH_56_BITS == KeyLength)
        {
            if (peex.dwMinLen <= 56 && 56 <= peex.dwMaxLen)
            {
                pRC4AuxInfo->dwBitLen = 56;
            }
            else
            {
                hr = CAPICOM_E_NOT_SUPPORTED;

                DebugTrace("Error [%#x]: 56-bits encryption is not available.\n", hr);
                goto ErrorExit;
            }
        }
        else if (CAPICOM_ENCRYPTION_KEY_LENGTH_128_BITS == KeyLength)
        {
            if (peex.dwMinLen <= 128 && 128 <= peex.dwMaxLen)
            {
                pRC4AuxInfo->dwBitLen = 128;
            }
            else
            {
                hr = CAPICOM_E_NOT_SUPPORTED;

                DebugTrace("Error [%#x]: 128-bits encryption is not available.\n", hr);
                goto ErrorExit;
            }
        }
        else
        {
            //
            // Should never get to here.
            //
            hr = CAPICOM_E_INTERNAL;

            DebugTrace("Error [%#x]: Unknown key length (%d).\n", hr, KeyLength);
            goto ErrorExit;
        }

        //
        // Return RC4 AuxInfo pointer to caller.
        //
        *ppAuxInfo = (void *) pRC4AuxInfo;
    }

CommonExit:

    DebugTrace("Leaving SetKeyLength().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (pRC2AuxInfo)
    {
        ::CoTaskMemFree(pRC2AuxInfo);
    }
    if (pRC4AuxInfo)
    {
        ::CoTaskMemFree(pRC4AuxInfo);
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : SetEncryptionAlgorithm

  Synopsis : Setup the encryption algorithm structure.

  Parameter: CAPICOM_ENCRYPTION_ALGORITHM AlgoName - Algorithm ID enum name.

             CAPICOM_ENCRYPTION_KEY_LENGTH KeyLength - Key length enum name.

             CRYPT_ALGORITHM_IDENTIFIER * pEncryptAlgorithm - Pointer to the
                                                              structure.

  Remark   :

------------------------------------------------------------------------------*/

static HRESULT SetEncryptionAlgorithm (CAPICOM_ENCRYPTION_ALGORITHM  AlgoName,
                                       CAPICOM_ENCRYPTION_KEY_LENGTH KeyLength,
                                       CRYPT_ALGORITHM_IDENTIFIER  * pEncryptAlgorithm)
{
    HRESULT hr    = S_OK;
    ALG_ID  AlgID = 0;

    DebugTrace("Entering SetEncryptionAlgorithm().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pEncryptAlgorithm);

    //
    // Initialize structure.
    //
    ::ZeroMemory(pEncryptAlgorithm, sizeof(CRYPT_ALGORITHM_IDENTIFIER));

    //
    // Convert to LPSTR.
    //
    if (FAILED(hr = ::EnumNameToAlgID(AlgoName, KeyLength, &AlgID)))
    {
        DebugTrace("Error: EnumNameToAlgID() failed.\n");
        goto ErrorExit;
    }
    
    if (FAILED(hr = ::AlgIDToOID(AlgID, &pEncryptAlgorithm->pszObjId)))
    {
        DebugTrace("Error: AlgIDToOID() failed.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving SetEncryptionAlgorithm().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (pEncryptAlgorithm->pszObjId)
    {
        ::CoTaskMemFree(pEncryptAlgorithm->pszObjId);
    }
    goto CommonExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// CEnvelopedData
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEnvelopedData::get_Content

  Synopsis : Return the content.

  Parameter: BSTR * pVal - Pointer to BSTR to receive the content.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CEnvelopedData::get_Content (BSTR * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CEnvelopedData::get_Content().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure content is already initialized.
        //
        if (0 == m_ContentBlob.cbData)
        {
            hr = CAPICOM_E_ENVELOP_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: Enveloped object has not been initialized.\n", hr);
            goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_ContentBlob.pbData);

        //
        // Return content.
        //
        if (FAILED(hr = ::BlobToBstr(&m_ContentBlob, pVal)))
        {
            DebugTrace("Error [%#x]: BlobToBstr() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CEnvelopedData::get_Content().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEnvelopedData::put_Content

  Synopsis : Initialize the object with content to be enveloped.

  Parameter: BSTR newVal - BSTR containing the content to be enveloped.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CEnvelopedData::put_Content (BSTR newVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CEnvelopedData::put_Content().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Make sure parameters are valid.
        //
        if (0 == ::SysStringByteLen(newVal))
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter newVal is NULL or empty.\n", hr);
            goto ErrorExit;
        }

        //
        // Update content.
        //
        if (FAILED(hr = ::BstrToBlob(newVal, &m_ContentBlob)))
        {
            DebugTrace("Error [%#x]: BstrToBlob() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CEnvelopedData::put_Content().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEnvelopedData::get_Algorithm

  Synopsis : Property to return the algorithm object.

  Parameter: IAlgorithm ** pVal - Pointer to pointer to IAlgorithm to receive 
                                  the interfcae pointer.
  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CEnvelopedData::get_Algorithm (IAlgorithm ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CEnvelopedData::get_Algorithm().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_pIAlgorithm);

        //
        // Return interface pointer to caller.
        //
        if (FAILED(hr = m_pIAlgorithm->QueryInterface(pVal)))
        {
            DebugTrace("Unexpected error [%#x]: m_pIAlgorithm->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CEnvelopedData::get_Algorithm().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEnvelopedData::get_Recipients

  Synopsis : Property to return the IRecipients collection object.

  Parameter: IRecipients ** pVal - Pointer to pointer to IRecipietns to receive
                                   the interface pointer.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CEnvelopedData::get_Recipients (IRecipients ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CEnvelopedData::get_Recipients().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_pIRecipients);

        //
        // Return interface pointer to caller.
        //
        if (FAILED(hr = m_pIRecipients->QueryInterface(pVal)))
        {
            DebugTrace("Unexpected error [%#x]: m_pIRecipients->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CEnvelopedData::get_Recipients().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEnvelopedData::Encrypt

  Synopsis : Envelop the content.

  Parameter: CAPICOM_ENCODING_TYPE EncodingType - Encoding type.
                                                       
             BSTR * pVal - Pointer to BSTR to receive the enveloped message.
  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CEnvelopedData::Encrypt (CAPICOM_ENCODING_TYPE EncodingType,
                                      BSTR                * pVal)
{
    HRESULT    hr               = S_OK;
    HCRYPTMSG  hMsg             = NULL;
    HCRYPTPROV hCryptProv       = NULL;
    CRYPT_DATA_BLOB MessageBlob = {0, NULL};

    DebugTrace("Entering CEnvelopedData::Encrypt().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure we do have content to envelop.
        //
        if (0 == m_ContentBlob.cbData)
        {
            hr = CAPICOM_E_ENVELOP_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: envelop object has not been initialized.\n", hr);
            goto ErrorExit;
        }

        //
        // Open a new message to encode.
        //
        if (FAILED(hr = OpenToEncode(&hMsg, &hCryptProv)))
        {
            DebugTrace("Error [%#x]: CEnvelopedData::OpenToEncode() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Update envelop content.
        //
        if(!::CryptMsgUpdate(hMsg,
                             m_ContentBlob.pbData,
                             m_ContentBlob.cbData,
                             TRUE))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptMsgUpdate() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Retrieve enveloped message.
        //
        if (FAILED(hr = ::GetMsgParam(hMsg,
                                      CMSG_CONTENT_PARAM,
                                      0,
                                      (void **) &MessageBlob.pbData,
                                      &MessageBlob.cbData)))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: GetMsgParam() failed to get message content.\n", hr);
            goto ErrorExit;
        }

        //
        // Now export the enveloped message.
        //
        if (FAILED(hr = ::ExportData(MessageBlob, EncodingType, pVal)))
        {
            DebugTrace("Error [%#x]: ExportData() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Write encoded blob to file, so we can use offline tool such as
        // ASN parser to analyze message. 
        //
        // The following line will resolve to void for non debug build, and
        // thus can be safely removed if desired.
        //
        DumpToFile("Enveloped.asn", MessageBlob.pbData, MessageBlob.cbData);
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resource.
    //
    if (MessageBlob.pbData)
    {
        ::CoTaskMemFree(MessageBlob.pbData);
    }
    if (hCryptProv)
    {
        ::ReleaseContext(hCryptProv);
    }
    if (hMsg)
    {
        ::CryptMsgClose(hMsg);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CEnvelopedData::Encrypt().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEnvelopedData::Decrypt

  Synopsis : Decrypt the enveloped message.

  Parameter: BSTR EnvelopedMessage - BSTR containing the enveloped message.

  Remark   : If called from web environment, UI will be displayed, if has 
             not been prevously disabled, to warn the user of accessing the 
             private key for decrypting.

------------------------------------------------------------------------------*/

STDMETHODIMP CEnvelopedData::Decrypt (BSTR EnvelopedMessage)
{
    HRESULT         hr              = S_OK;
    HRESULT         hr2             = S_OK;
    HCERTSTORE      hCertStores[2]  = {NULL, NULL};
    HCRYPTMSG       hMsg            = NULL;
    PCCERT_CONTEXT  pCertContext    = NULL;
    HCRYPTPROV      hCryptProv      = NULL;
    DWORD           dwKeySpec       = 0;
    BOOL            bReleaseContext = FALSE;
    BOOL            bUserPrompted   = FALSE;
    DWORD           dwNumRecipients = 0;
    DWORD           cbNumRecipients = sizeof(dwNumRecipients);
    CRYPT_DATA_BLOB ContentBlob     = {0, NULL};

    DWORD dwIndex;
    CComBSTR bstrContent;

    DebugTrace("Entering CEnvelopedData::Decrypt().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Reset member variables.
        //
        if (FAILED(hr = m_pIRecipients->Clear()))
        {
            DebugTrace("Error [%#x]: m_pIRecipients->Clear() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure parameters are valid.
        //
        if (0 == ::SysStringByteLen(EnvelopedMessage))
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter EnvelopedMessage is NULL or empty.\n", hr);
            goto ErrorExit;
        }

        //
        // Open current user and local machine MY stores.
        //
        hCertStores[0] = ::CertOpenStore(CERT_STORE_PROV_SYSTEM,
                                         CAPICOM_ASN_ENCODING,
                                         NULL,
                                         CERT_SYSTEM_STORE_CURRENT_USER | CERT_STORE_OPEN_EXISTING_FLAG,
                                         L"My");
        hCertStores[1] = ::CertOpenStore(CERT_STORE_PROV_SYSTEM,
                                         CAPICOM_ASN_ENCODING,
                                         NULL,
                                         CERT_SYSTEM_STORE_LOCAL_MACHINE | CERT_STORE_OPEN_EXISTING_FLAG,
                                         L"My");
        //
        // Did we manage to open any of the MY store?
        //
        if (NULL == hCertStores[0] && NULL == hCertStores[1])
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertOpenStore() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Open the message for decode.
        //
        if (FAILED(hr = OpenToDecode(NULL, EnvelopedMessage, &hMsg)))
        {
            DebugTrace("Error [%#x]: CEnvelopedData::OpenToDecode() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Determine number of recipients.
        //
        if (!::CryptMsgGetParam(hMsg,
                                CMSG_RECIPIENT_COUNT_PARAM,
                                0,
                                (void *) &dwNumRecipients,
                                &cbNumRecipients))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptMsgGetParam() failed for CMSG_RECIPIENT_COUNT_PARAM.\n", hr);
            goto ErrorExit;
        }

        //
        // Find recipient.
        //
        for (dwIndex = 0; dwIndex < dwNumRecipients; dwIndex++)
        {
            BOOL bFound = FALSE;
            DATA_BLOB CertInfoBlob = {0, NULL};

            //
            // Get RecipientInfo.
            //
            if (FAILED(hr = ::GetMsgParam(hMsg,
                                          CMSG_RECIPIENT_INFO_PARAM,
                                          dwIndex,
                                          (void **) &CertInfoBlob.pbData,
                                          &CertInfoBlob.cbData)))
            {
                DebugTrace("Error [%#x]: GetMsgParam() failed for CMSG_RECIPIENT_INFO_PARAM.\n", hr);
                goto ErrorExit;
            }

            //
            // Find recipient's cert in store.
            //
            if ((hCertStores[0] && (pCertContext = ::CertGetSubjectCertificateFromStore(hCertStores[0],
                                                                                        CAPICOM_ASN_ENCODING,
                                                                                        (CERT_INFO *) CertInfoBlob.pbData))) ||
                (hCertStores[1] && (pCertContext = ::CertGetSubjectCertificateFromStore(hCertStores[1],
                                                                                        CAPICOM_ASN_ENCODING,
                                                                                        (CERT_INFO *) CertInfoBlob.pbData))))
            {
                bFound = TRUE;
            }

            //
            // Free memory.
            //
            ::CoTaskMemFree(CertInfoBlob.pbData);

            //
            // Did we find the recipient?
            //
            if (bFound)
            {
                CMSG_CTRL_DECRYPT_PARA DecryptPara;

                //
                // If we are called from a web page, we need to pop up UI 
                // to get user permission to perform decrypt operation.
                //
                if (!bUserPrompted)
                {
                    if (m_dwCurrentSafety && 
                        FAILED(hr = OperationApproved(IDD_DECRYPT_SECURITY_ALERT_DLG)))
                    {
                        DebugTrace("Error [%#x]: OperationApproved() failed.\n", hr);
                        goto ErrorExit;
                    }

                    bUserPrompted = TRUE;
                }

                //
                // Acquire CSP context.
                //
                if (S_OK == ::AcquireContext(pCertContext, &hCryptProv, &dwKeySpec, &bReleaseContext))
                {
                    //
                    // Decypt the message.
                    //
                    ::ZeroMemory(&DecryptPara, sizeof(DecryptPara));
                    DecryptPara.cbSize = sizeof(DecryptPara);
                    DecryptPara.hCryptProv = hCryptProv;
                    DecryptPara.dwKeySpec = dwKeySpec;
                    DecryptPara.dwRecipientIndex = dwIndex; 

                    if(::CryptMsgControl(hMsg,
                                          0,
                                          CMSG_CTRL_DECRYPT,
                                          &DecryptPara))
                    {
                        //
                        // Get decrypted content.
                        //
                        if (FAILED(hr = ::GetMsgParam(hMsg,
                                                      CMSG_CONTENT_PARAM,
                                                      0,
                                                      (void **) &ContentBlob.pbData,
                                                      &ContentBlob.cbData)))
                        {
                            DebugTrace("Error [%#x]: GetMsgParam() failed to get CMSG_CONTENT_PARAM.\n", hr);
                            goto ErrorExit;
                        }
    
                        //
                        // Update member variables.
                        //
                        m_ContentBlob = ContentBlob;

                        //
                        // We are all done, so break out of loop.
                        //
                        break;
                    }
                    else
                    {
                        //
                        // Keep copy of error code.
                        //
                        hr2 = HRESULT_FROM_WIN32(::GetLastError());

                        DebugTrace("Info [%#x]: CryptMsgControl() failed to decrypt.\n", hr2);
                    }

                    if (bReleaseContext)
                    {
                        ::ReleaseContext(hCryptProv), hCryptProv = NULL;
                    }
                }

                ::CertFreeCertificateContext(pCertContext), pCertContext = NULL;
            }
        }

        //
        // Did we find the recipient?
        //
        if (dwIndex == dwNumRecipients)
        {
            //
            // Retrieve previous error if any.
            //
            if (FAILED(hr2))
            {
                hr = hr2;

                DebugTrace("Error [%#x]: CryptMsgControl() failed to decrypt.\n", hr);
            }
            else
            {
                hr = CAPICOM_E_ENVELOP_RECIPIENT_NOT_FOUND;

                DebugTrace("Error [%#x]: recipient not found.\n", hr);
            }

            goto ErrorExit;
        }
    }
   
    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resource.
    //
    if (hCryptProv && bReleaseContext)
    {
        ::ReleaseContext(hCryptProv);
    }
    if (pCertContext)
    {
        ::CertFreeCertificateContext(pCertContext);
    }
    if(hMsg)
    {
        ::CryptMsgClose(hMsg);
    }
    if (hCertStores[0])
    {
        ::CertCloseStore(hCertStores[0], 0);
    }
    if (hCertStores[1])
    {
        ::CertCloseStore(hCertStores[1], 0);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CEnvelopedData::Decrypt().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resources.
    //
    if (ContentBlob.pbData)
    {
        ::CoTaskMemFree(ContentBlob.pbData);
    }

    ReportError(hr);

    goto UnlockExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// Private member functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEnvelopedData::Init

  Synopsis : Initialize the object.

  Parameter: None.

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CEnvelopedData::Init ()
{
    HRESULT hr = S_OK;
    CComPtr<IAlgorithm>  pIAlgorithm  = NULL;
    CComPtr<IRecipients> pIRecipients = NULL;

    DebugTrace("Entering CEnvelopedData::Init().\n");

    //
    // Create embeded IAlgorithm.
    //
    if (FAILED(hr = ::CreateAlgorithmObject(FALSE, FALSE, &pIAlgorithm)))
    {
        DebugTrace("Error [%#x]: CreateAlgorithmObject() failed.\n", hr);
        goto CommonExit;
    }

    //
    // Create embeded IRecipients.
    //
    if (FAILED(hr = ::CreateRecipientsObject(&pIRecipients)))
    {
        DebugTrace("Error [%#x]: CreateRecipientsObject() failed.\n", hr);
        goto CommonExit;
    }

    //
    // Update member variables.
    //
    m_bEnveloped = FALSE;
    m_ContentBlob.cbData = 0;
    m_ContentBlob.pbData = NULL;
    m_pIAlgorithm = pIAlgorithm;
    m_pIRecipients = pIRecipients;

CommonExit:

    DebugTrace("Leaving CEnvelopedData::Init().\n");

    return hr;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEnvelopedData::OpenToEncode

  Synopsis : Create and initialize an envelop message for encoding.

  Parameter: HCRYPTMSG * phMsg - Pointer to HCRYPTMSG to receive message 
                                 handler.

             HCRYPTPROV * phCryptProv - Pointer to HCRYPTPROV to receive CSP
                                        handler.
  Remark   : 

------------------------------------------------------------------------------*/

STDMETHODIMP CEnvelopedData::OpenToEncode (HCRYPTMSG  * phMsg, 
                                           HCRYPTPROV * phCryptProv)
{
    HRESULT                hr                 = S_OK;
    DWORD                  dwNumRecipients    = 0;
    PCCERT_CONTEXT       * pCertContexts      = NULL;
    PCERT_INFO           * pCertInfos         = NULL;
    HCRYPTPROV             hCryptProv         = NULL;
    void *                 pEncryptionAuxInfo = NULL;
    CAPICOM_STORE_INFO     StoreInfo          = {0, L"AddressBook"};
    CComPtr<ICertificate>  pIRecipient        = NULL;
    CComPtr<ICertificate2> pICertificate2     = NULL;


    DWORD                      dwIndex;
    CAPICOM_ENCRYPTION_ALGORITHM  AlgoName;
    CAPICOM_ENCRYPTION_KEY_LENGTH KeyLength;
    CMSG_ENVELOPED_ENCODE_INFO EnvelopInfo;
    CRYPT_ALGORITHM_IDENTIFIER EncryptionAlgorithm;

    DebugTrace("Entering CEnvelopedData::OpenToEncode().\n");

    //
    // Sanity check.
    //
    ATLASSERT(phMsg);
    ATLASSERT(phCryptProv);
    ATLASSERT(m_ContentBlob.cbData && m_ContentBlob.pbData);
    ATLASSERT(m_pIRecipients);

    //
    // Initialize.
    //
    ::ZeroMemory(&EnvelopInfo, sizeof(EnvelopInfo));
    ::ZeroMemory(&EncryptionAlgorithm, sizeof(EncryptionAlgorithm));

    //
    // Make sure we do have at least 1 recipient.
    //
    if (FAILED(hr = m_pIRecipients->get_Count((long *) &dwNumRecipients)))
    {
        DebugTrace("Error [%#x]: m_pIRecipients->get_Count() failed.\n", hr);
        goto ErrorExit;
    }
    if (0 == dwNumRecipients)
    {
        //
        // Prompt user to add a recipient.
        //
        if (FAILED(hr = ::SelectCertificate(StoreInfo, 
                                            SelectRecipientCertCallback,
                                            &pICertificate2)))
        {
            if (hr == CAPICOM_E_STORE_EMPTY)
            {
                hr = CAPICOM_E_ENVELOP_NO_RECIPIENT;
            }

            DebugTrace("Error [%#x]: SelectCertificate() failed.\n", hr);
            goto ErrorExit;
        }

        if (FAILED(hr = pICertificate2->QueryInterface(__uuidof(ICertificate), (void **) &pIRecipient)))
        {
            DebugTrace("Unexpected error [%#x]: pICertificate2->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Add to collection.
        //
        if (FAILED (hr = m_pIRecipients->Add(pIRecipient)))
        {
            DebugTrace("Error [%#x]: m_pIRecipients->Add() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure count is 1.
        //
        if (FAILED(hr = m_pIRecipients->get_Count((long *) &dwNumRecipients)))
        {
            DebugTrace("Error [%#x]: m_pIRecipients->get_Count() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(1 == dwNumRecipients);
    }

    //
    // Allocate memory for CERT_CONTEXT array.
    //
    if (!(pCertContexts = (PCCERT_CONTEXT *) ::CoTaskMemAlloc(sizeof(PCCERT_CONTEXT) * dwNumRecipients)))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Error: out of memory.\n");
        goto ErrorExit;
    }
    ::ZeroMemory(pCertContexts, sizeof(PCCERT_CONTEXT) * dwNumRecipients);

    //
    // Allocate memory for CERT_INFO array.
    //
    if (!(pCertInfos = (PCERT_INFO *) ::CoTaskMemAlloc(sizeof(PCERT_INFO) * dwNumRecipients)))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Error: out of memory.\n");
        goto ErrorExit;
    }
    ::ZeroMemory(pCertInfos, sizeof(PCERT_INFO) * dwNumRecipients);

    //
    // Set CERT_INFO array.
    //
    for (dwIndex = 0; dwIndex < dwNumRecipients; dwIndex++)
    {
        CComVariant varRecipient;
        CComPtr<ICertificate> pIRecipient2 = NULL;

        //
        // Get next recipient.
        //
        if (FAILED(hr = m_pIRecipients->get_Item((long) (dwIndex + 1), 
                                                 &varRecipient)))
        {
            DebugTrace("Error [%#x]: m_pIRecipients->get_Item() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Get custom interface.
        //
        if (FAILED(hr = varRecipient.pdispVal->QueryInterface(IID_ICertificate, 
                                                              (void **) &pIRecipient2)))
        {
            DebugTrace("Error [%#x]: varRecipient.pdispVal->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Get CERT_CONTEXT.
        //
        if (FAILED(hr = ::GetCertContext(pIRecipient2, &pCertContexts[dwIndex])))
        {
            DebugTrace("Error [%#x]: GetCertContext() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Set CERT_INFO.
        //
        pCertInfos[dwIndex] = pCertContexts[dwIndex]->pCertInfo;
    }

    //
    // Get algorithm ID enum name.
    //
    if (FAILED(hr = m_pIAlgorithm->get_Name(&AlgoName)))
    {
        DebugTrace("Error [%#x]: m_pIAlgorithm->get_Name() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Get key length enum name.
    //
    if (FAILED(hr = m_pIAlgorithm->get_KeyLength(&KeyLength)))
    {
        DebugTrace("Error [%#x]: m_pIAlgorithm->get_KeyLength() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Get CSP context.
    //
    if (FAILED(hr = ::AcquireContext(AlgoName, 
                                     KeyLength, 
                                     &hCryptProv)))
    {
        DebugTrace("Error [%#x]: AcquireContext() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Set algorithm.
    //
    if (FAILED(hr = ::SetEncryptionAlgorithm(AlgoName,
                                             KeyLength,
                                             &EncryptionAlgorithm)))
    {
        DebugTrace("Error [%#x]: SetEncryptionAlgorithm() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Set key length.
    //
    if (FAILED(hr = ::SetKeyLength(hCryptProv, 
                                   EncryptionAlgorithm,
                                   KeyLength, 
                                   &pEncryptionAuxInfo)))
    {
        DebugTrace("Error [%#x]: SetKeyLength() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Set CMSG_ENVELOPED_ENCODE_INFO.
    //
    EnvelopInfo.cbSize = sizeof(EnvelopInfo);
    EnvelopInfo.ContentEncryptionAlgorithm = EncryptionAlgorithm;
    EnvelopInfo.hCryptProv = hCryptProv;
    EnvelopInfo.cRecipients = dwNumRecipients;
    EnvelopInfo.rgpRecipients = pCertInfos;
    EnvelopInfo.pvEncryptionAuxInfo = pEncryptionAuxInfo;

    //
    // Open the message for encoding.
    //
    if(!(*phMsg = ::CryptMsgOpenToEncode(CAPICOM_ASN_ENCODING,    // ASN encoding type
                                         0,                       // Flags
                                         CMSG_ENVELOPED,          // Message type
                                         &EnvelopInfo,            // Pointer to structure
                                         NULL,                    // Inner content OID
                                         NULL)))                  // Stream information (not used)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptMsgOpenToEncode() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Return HCRYPTPROV to caller.
    //
    *phCryptProv = hCryptProv;

CommonExit:
    //
    // Free resource.
    //
    if (pEncryptionAuxInfo)
    {
        ::CoTaskMemFree(pEncryptionAuxInfo);
    }
    if (EncryptionAlgorithm.pszObjId)
    {
        ::CoTaskMemFree(EncryptionAlgorithm.pszObjId);
    }
    if (EncryptionAlgorithm.Parameters.pbData)
    {
        ::CoTaskMemFree(EncryptionAlgorithm.Parameters.pbData);
    }
    if (pCertInfos)
    {
        ::CoTaskMemFree(pCertInfos);
    }
    if (pCertContexts)
    {
        for (dwIndex = 0; dwIndex < dwNumRecipients; dwIndex++)
        {
            if (pCertContexts[dwIndex])
            {
                ::CertFreeCertificateContext(pCertContexts[dwIndex]);
            }
        }

        ::CoTaskMemFree(pCertContexts);
    }

    DebugTrace("Leaving CEnvelopedData::OpenToEncode().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (hCryptProv)
    {
        ::ReleaseContext(hCryptProv);
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CEnvelopedData::OpenToDeccode

  Synopsis : Open an enveloped message for decoding.

  Parameter: HCRYPTPROV hCryptProv - CSP handle.

             BSTR EnvelopMessage - Enveloped message.
  
             HCRYPTMSG * phMsg - Pointer to HCRYPTMSG.

  Remark   : 

------------------------------------------------------------------------------*/

STDMETHODIMP CEnvelopedData::OpenToDecode (HCRYPTPROV  hCryptProv,
                                           BSTR        EnvelopedMessage,
                                           HCRYPTMSG * phMsg)
{
    HRESULT   hr             = S_OK;
    HCRYPTMSG hMsg           = NULL;
    DWORD     dwMsgType      = 0;
    DWORD     cbMsgType      = sizeof(dwMsgType);
    DATA_BLOB MessageBlob    = {0, NULL};
    DATA_BLOB AlgorithmBlob  = {0, NULL};
    DATA_BLOB ParametersBlob = {0, NULL};

    DebugTrace("Leaving CEnvelopedData::OpenToDecode().\n");

    // Sanity check.
    //
    ATLASSERT(phMsg);
    ATLASSERT(EnvelopedMessage);

    try
    {
        //
        // Open the message for decoding.
        //
        if (!(hMsg = ::CryptMsgOpenToDecode(CAPICOM_ASN_ENCODING,
                                            0,
                                            0,
                                            hCryptProv,
                                            NULL,
                                            NULL)))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptMsgOpenToDecode() failed.\n", hr);
            goto CommonExit;
        }

        //
        // Import the message.
        //
        if (FAILED(hr = ::ImportData(EnvelopedMessage, CAPICOM_ENCODE_ANY, &MessageBlob)))
        {
            DebugTrace("Error [%#x]: ImportData() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Update message with enveloped content.
        //
        if (!::CryptMsgUpdate(hMsg,
                              MessageBlob.pbData,
                              MessageBlob.cbData,
                              TRUE))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptMsgUpdate() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Check message type.
        //
        if (!::CryptMsgGetParam(hMsg,
                                CMSG_TYPE_PARAM,
                                0,
                                (void *) &dwMsgType,
                                &cbMsgType))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptMsgGetParam() failed for CMSG_TYPE_PARAM.\n", hr);
            goto ErrorExit;
        }

        if (CMSG_ENVELOPED != dwMsgType)
        {
            hr = CAPICOM_E_ENVELOP_INVALID_TYPE;

            DebugTrace("Error [%#x]: Enveloped message's dwMsgType (%#x) is not CMSG_ENVELOPED.\n", hr, dwMsgType);
            goto ErrorExit;
        }

        //
        // Get algorithm ID.
        //
        if (FAILED(hr = ::GetMsgParam(hMsg,
                                      CMSG_ENVELOPE_ALGORITHM_PARAM,
                                      0,
                                      (void **) &AlgorithmBlob.pbData,
                                      &AlgorithmBlob.cbData)))
        {
            DebugTrace("Error [%#x]: GetMsgParam() failed for CMSG_ENVELOPE_ALGORITHM_PARAM.\n", hr);
            goto ErrorExit;
        }

        //
        // Restore encryption algorithm state, as much as we can.
        //
        if (0 == lstrcmpA(szOID_RSA_RC2CBC, ((CRYPT_ALGORITHM_IDENTIFIER *) AlgorithmBlob.pbData)->pszObjId))
        {
            CAPICOM_ENCRYPTION_KEY_LENGTH KeyLength;

            DebugTrace("INFO: Envelop encryption algorithm was RC2.\n");

            //
            // Set encryption algorithm name.
            //
            if (FAILED(hr = m_pIAlgorithm->put_Name(CAPICOM_ENCRYPTION_ALGORITHM_RC2)))
            {
                DebugTrace("Error [%#x]: m_pIAlgorithm->put_Name() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Determine encryption key length.
            //
            if (((CRYPT_ALGORITHM_IDENTIFIER *) AlgorithmBlob.pbData)->Parameters.cbData)
            {
                if (FAILED(hr = ::DecodeObject(PKCS_RC2_CBC_PARAMETERS,
                                               ((CRYPT_ALGORITHM_IDENTIFIER *) AlgorithmBlob.pbData)->Parameters.pbData,
                                               ((CRYPT_ALGORITHM_IDENTIFIER *) AlgorithmBlob.pbData)->Parameters.cbData,
                                               &ParametersBlob)))
                {
                    DebugTrace("Error [%#x]: DecodeObject() failed for PKCS_RC2_CBC_PARAMETERS.\n", hr);
                    goto ErrorExit;
                }
            }

            //
            // Set encryption key length.
            //
            switch (((CRYPT_RC2_CBC_PARAMETERS *) ParametersBlob.pbData)->dwVersion)
            {
                case CRYPT_RC2_40BIT_VERSION:
                {
                    KeyLength = CAPICOM_ENCRYPTION_KEY_LENGTH_40_BITS;

                    DebugTrace("INFO: Envelop encryption key length was 40-bits.\n");
                    break;
                }

                case CRYPT_RC2_56BIT_VERSION:
                {
                    KeyLength = CAPICOM_ENCRYPTION_KEY_LENGTH_56_BITS;

                    DebugTrace("INFO: Envelop encryption key length was 56-bits.\n");
                    break;
                }

                case CRYPT_RC2_128BIT_VERSION:
                {
                    KeyLength = CAPICOM_ENCRYPTION_KEY_LENGTH_128_BITS;

                    DebugTrace("INFO: Envelop encryption key length was 128-bits.\n");
                    break;
                }

                default:
                {
                    //
                    // Unknown key length, so arbitrary choose one.
                    //
                    KeyLength = CAPICOM_ENCRYPTION_KEY_LENGTH_MAXIMUM;

                    DebugTrace("INFO: Unknown envelop encryption key length.\n");
                    break;
                }
            }

            //
            // Set key length.
            //
            if (FAILED(hr = m_pIAlgorithm->put_KeyLength(KeyLength)))
            {
                DebugTrace("Error [%#x]: m_pIAlgorithm->put_KeyLength() failed.\n", hr);
                goto ErrorExit;
            }
        }
        else if (0 == lstrcmpA(szOID_RSA_RC4, ((CRYPT_ALGORITHM_IDENTIFIER *) AlgorithmBlob.pbData)->pszObjId))
        {
            DebugTrace("INFO: Envelop encryption algorithm was RC4.\n");

            //
            // Set encryption algorithm name.
            //
            if (FAILED(hr = m_pIAlgorithm->put_Name(CAPICOM_ENCRYPTION_ALGORITHM_RC4)))
            {
                DebugTrace("Error [%#x]: m_pIAlgorithm->put_Name() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // For RC4, CAPI simply does not provide a way to retrieve the
            // encryption key length, so we will have to leave it alone!!!
            //
        }
        else if (0 == lstrcmpA(szOID_OIWSEC_desCBC, ((CRYPT_ALGORITHM_IDENTIFIER *) AlgorithmBlob.pbData)->pszObjId))
        {
            DebugTrace("INFO: Envelop encryption algorithm was DES.\n");

            //
            // Set encryption algorithm name.
            //
            if (FAILED(hr = m_pIAlgorithm->put_Name(CAPICOM_ENCRYPTION_ALGORITHM_DES)))
            {
                DebugTrace("Error [%#x]: m_pIAlgorithm->put_Name() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // For DES, key length is fixed at 56, and should be ignored.
            //
        }
        else if (0 == lstrcmpA(szOID_RSA_DES_EDE3_CBC, ((CRYPT_ALGORITHM_IDENTIFIER *) AlgorithmBlob.pbData)->pszObjId))
        {
            DebugTrace("INFO: Envelop encryption algorithm was 3DES.\n");

            //
            // Set encryption algorithm name.
            //
            if (FAILED(hr = m_pIAlgorithm->put_Name(CAPICOM_ENCRYPTION_ALGORITHM_3DES)))
            {
                DebugTrace("Error [%#x]: m_pIAlgorithm->put_Name() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // For 3DES, key length is fixed at 168, and should be ignored.
            //
        }
        else
        {
            DebugTrace("INFO: Unknown envelop encryption algorithm.\n");
        }

        //
        // Return msg handler to caller.
        //
        *phMsg = hMsg;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:
    //
    // Free resource.
    //
    if (ParametersBlob.pbData)
    {
        ::CoTaskMemFree(ParametersBlob.pbData);
    }
    if (AlgorithmBlob.pbData)
    {
        ::CoTaskMemFree(AlgorithmBlob.pbData);
    }
    if (MessageBlob.pbData)
    {
        ::CoTaskMemFree(MessageBlob.pbData);
    }

    DebugTrace("Leaving CEnvelopedData::OpenToDecode().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    if (hMsg)
    {
        ::CryptMsgClose(hMsg);
    }

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\extendedproperties.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000.

  File:    ExtendedProperties.cpp

  Content: Implementation of CExtendedProperties.

  History: 06-15-2001    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "ExtendedProperties.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateExtendedPropertiesObject

  Synopsis : Create and initialize an IExtendedProperties collection object.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT.
  
             BOOL bReadOnly - TRUE if read only instance, else FALSE.

             IExtendedProperties ** ppIExtendedProperties - Pointer to pointer 
                                                            to IExtendedProperties 
                                                            to receive the 
                                                            interface pointer.
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateExtendedPropertiesObject (PCCERT_CONTEXT         pCertContext,
                                        BOOL                   bReadOnly,
                                        IExtendedProperties ** ppIExtendedProperties)
{
    HRESULT hr = S_OK;
    CComObject<CExtendedProperties> * pCExtendedProperties = NULL;

    DebugTrace("Entering CreateExtendedPropertiesObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(ppIExtendedProperties);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CExtendedProperties>::CreateInstance(&pCExtendedProperties)))
        {
            DebugTrace("Error [%#x]: CComObject<CExtendedProperties>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        if (FAILED(hr = pCExtendedProperties->Init(pCertContext, bReadOnly)))
        {
            DebugTrace("Error [%#x]: pCExtendedProperties->Init() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return IExtendedProperties pointer to caller.
        //
        if (FAILED(hr = pCExtendedProperties->QueryInterface(ppIExtendedProperties)))
        {
            DebugTrace("Error [%#x]: pCExtendedProperties->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreateExtendedPropertiesObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (pCExtendedProperties)
    {
        delete pCExtendedProperties;
    }

    goto CommonExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// CExtendedProperties
//

#if (0)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CExtendedProperties::get_Item

  Synopsis : Return item in the collection.

  Parameter: long Index - Numeric index.
   
             VARIANT * pVal - Pointer to VARIANT to receive the IDispatch.

  Remark   :
             
------------------------------------------------------------------------------*/

STDMETHODIMP CExtendedProperties::get_Item (long Index, VARIANT * pVal)
{
    HRESULT  hr = S_OK;
    char     szIndex[33];
    CComBSTR bstrIndex;
    CComPtr<IExtendedProperty> pIExtendedProperty = NULL;

    DebugTrace("Entering CExtendedProperties::get_Item().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Intialize.
        //
        ::VariantInit(pVal);

        //
        // BSTR index of prop ID.
        //
        wsprintfA(szIndex, "%#08x", Index);

        if (!(bstrIndex = szIndex))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error [%#x]: bstrIndex = szIndex failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Index by PropID string.
        //
        ExtendedPropertyMap::iterator it;

        //
        // Find the item with this PropID.
        //
        it = m_coll.find(bstrIndex);

        if (it == m_coll.end())
        {
            DebugTrace("Info: PropID (%d) not found in the collection.\n", Index);
            goto CommonExit;
        }

        //
        // Point to found item.
        //
        pIExtendedProperty = (*it).second;

        //
        // Return to caller.
        //
        pVal->vt = VT_DISPATCH;
        if (FAILED(hr = pIExtendedProperty->QueryInterface(IID_IDispatch, (void **) &(pVal->pdispVal))))
        {
            DebugTrace("Error [%#x]: pIExtendedProperty->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = CAPICOM_E_INTERNAL;

        DebugTrace("Exception: internal error.\n");
        goto ErrorExit;
    }

CommonExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CExtendedProperties::get_Item().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto CommonExit;
}
#endif

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CExtendedProperties::Add

  Synopsis : Add a ExtendedProperty to the collection.

  Parameter: IExtendedProperty * pVal - ExtendedProperty to be added.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CExtendedProperties::Add (IExtendedProperty * pVal)
{
    HRESULT                    hr = S_OK;
    char                       szIndex[33];
    CComBSTR                   bstrIndex;
    CComBSTR                   bstrProperty;
    CAPICOM_PROPID             PropId;
    CComPtr<IExtendedProperty> pIExtendedProperty  = NULL;

    DebugTrace("Entering CExtendedProperties::Add().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Do not allowed if called from WEB script.
        //
        if (m_bReadOnly)
        {
            hr = CAPICOM_E_NOT_ALLOWED;

            DebugTrace("Error [%#x]: Adding extended property from WEB script is not allowed.\n", hr);
            goto ErrorExit;
        }

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_pCertContext);
           
        //
        // Create a new object for this property.
        //
        if (FAILED(hr = pVal->get_PropID(&PropId)))
        {
            DebugTrace("Error [%#x]: pVal->get_PropID() failed.\n", hr);
            goto ErrorExit;
        }

        if (FAILED(hr = ::CreateExtendedPropertyObject(m_pCertContext, 
                                                       (DWORD) PropId, 
                                                       FALSE, 
                                                       &pIExtendedProperty)))
        {
            DebugTrace("Error [%#x]: CreateExtendedPropertyObject() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Put value (will write thru).
        //
        if (FAILED(hr = pVal->get_Value(CAPICOM_ENCODE_BINARY, &bstrProperty)))
        {
            DebugTrace("Error [%#x]: pVal->get_Value() failed.\n", hr);
            goto ErrorExit;
        }

        if (FAILED(hr = pIExtendedProperty->put_Value(CAPICOM_ENCODE_BINARY, bstrProperty)))
        {
            DebugTrace("Error [%#x]: pIExtendedProperty->put_Value() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // BSTR index of prop ID.
        //
        wsprintfA(szIndex, "%#08x", PropId);

        if (!(bstrIndex = szIndex))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error [%#x]: bstrIndex = szIndex failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Now add object to collection map.
        //
        // Note that the overloaded = operator for CComPtr will
        // automatically AddRef to the object. Also, when the CComPtr
        // is deleted (happens when the Remove or map destructor is called), 
        // the CComPtr destructor will automatically Release the object.
        //
        m_coll[bstrIndex] = pIExtendedProperty;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CExtendedProperties::Add().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CExtendedProperties::Remove

  Synopsis : Remove a ExtendedProperty from the collection.

  Parameter: CAPICOM_PROPID PropId - Property ID.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CExtendedProperties::Remove (CAPICOM_PROPID PropId)
{
    HRESULT                       hr = S_OK;
    char                          szIndex[33];
    CComBSTR                      bstrIndex;
    CComPtr<IExtendedProperty>    pIExtendedProperty = NULL;
    ExtendedPropertyMap::iterator iter;

    DebugTrace("Entering CExtendedProperties::Remove().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Do not allowed if called from WEB script.
        //
        if (m_bReadOnly)
        {
            hr = CAPICOM_E_NOT_ALLOWED;

            DebugTrace("Error [%#x]: Removing extended property from WEB script is not allowed.\n", hr);
            goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_pCertContext);

        //
        // BSTR index of prop ID.
        //
        wsprintfA(szIndex, "%#08x", PropId);

        if (!(bstrIndex = szIndex))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error [%#x]: bstrIndex = szIndex failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Find the item in the map.
        //
        if (m_coll.end() == (iter = m_coll.find(bstrIndex)))
        {
            hr = HRESULT_FROM_WIN32(CRYPT_E_NOT_FOUND);

            DebugTrace("Error [%#x]: Prod ID (%u) does not exist.\n", hr, PropId);
            goto ErrorExit;
        }

        //
        // Remove from the cert.
        //
        if (!::CertSetCertificateContextProperty(m_pCertContext, 
                                                 (DWORD) PropId, 
                                                 0, 
                                                 NULL))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertSetCertificateContextProperty() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Now remove object in map.
        //
        m_coll.erase(iter);
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CExtendedProperties::Remove().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// Non COM functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CExtendedProperties::Init

  Synopsis : Initialize the collection object by adding all individual
             ExtendedProperty object to the collection.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT.

             BOOL bReadOnly - TRUE if read only instance, else FALSE.

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CExtendedProperties::Init (PCCERT_CONTEXT pCertContext,
                                         BOOL          bReadOnly)
{
    HRESULT   hr       = S_OK;
    DWORD     dwPropId = 0;

    DebugTrace("Entering CExtendedProperties::Init().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);

    try
    {
        //
        // Duplicate the handle.
        //
        if (!(m_pCertContext = ::CertDuplicateCertificateContext(pCertContext)))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertDuplicateCertificateContext() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Add all proerties to the map.
        //
        while (dwPropId = ::CertEnumCertificateContextProperties(pCertContext, dwPropId))
        {
            char                       szIndex[33];
            CComBSTR                   bstrIndex;
            CComPtr<IExtendedProperty> pIExtendedProperty = NULL;

            if (FAILED(hr = ::CreateExtendedPropertyObject(pCertContext, 
                                                           dwPropId,
                                                           bReadOnly,
                                                           &pIExtendedProperty)))
            {
                DebugTrace("Error [%#x]: CreateExtendedPropertyObject() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // BSTR index of prop ID.
            //
            wsprintfA(szIndex, "%#08x", dwPropId);

            if (!(bstrIndex = szIndex))
            {
                hr = E_OUTOFMEMORY;

                DebugTrace("Error [%#x]: bstrIndex = szIndex failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Now add object to collection map.
            //
            // Note that the overloaded = operator for CComPtr will
            // automatically AddRef to the object. Also, when the CComPtr
            // is deleted (happens when the Remove or map destructor is called), 
            // the CComPtr destructor will automatically Release the object.
            //
            m_coll[bstrIndex] = pIExtendedProperty;
        }

        m_bReadOnly = bReadOnly;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CExtendedProperties::Init().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    m_coll.clear();

    if (m_pCertContext)
    {
        ::CertFreeCertificateContext(m_pCertContext);
        m_pCertContext = NULL;
    }

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\extendedkeyusage.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows

  Copyright (C) Microsoft Corporation, 1995 - 1999.

  File:    ExtendedKeyUsage.h

  Content: Declaration of the CExtendedKeyUsage.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#ifndef __EXTENDEDKEYUSAGE_H_
#define __EXTENDEDKEYUSAGE_H_

#include "Resource.h"
#include "Error.h"
#include "Lock.h"
#include "Debug.h"
#include "EKUs.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateExtendedKeyUsageObject

  Synopsis : Create an IExtendedKeyUsage object and populate the object
             with EKU data from the certificate.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT.

             IExtendedKeyUsage ** ppIExtendedKeyUsage - Pointer to pointer to
                                                        IExtendedKeyUsage 
                                                        object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateExtendedKeyUsageObject (PCCERT_CONTEXT pCertContext,
                                      IExtendedKeyUsage ** ppIExtendedKeyUsage);


///////////////////////////////////////////////////////////////////////////////
//
// CExtendedKeyUsage
//

class ATL_NO_VTABLE CExtendedKeyUsage : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CExtendedKeyUsage, &CLSID_ExtendedKeyUsage>,
    public ICAPICOMError<CExtendedKeyUsage, &IID_IExtendedKeyUsage>,
    public IDispatchImpl<IExtendedKeyUsage, &IID_IExtendedKeyUsage, &LIBID_CAPICOM,
                         CAPICOM_MAJOR_VERSION, CAPICOM_MINOR_VERSION>
{
public:
    CExtendedKeyUsage()
    {
    }

DECLARE_NO_REGISTRY()

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CExtendedKeyUsage)
    COM_INTERFACE_ENTRY(IExtendedKeyUsage)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CExtendedKeyUsage)
END_CATEGORY_MAP()

    HRESULT FinalConstruct()
    {
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for ExtendedKeyUsage object.\n", hr);
            return hr;
        }

        m_pIEKUs      = NULL;
        m_bIsPresent  = VARIANT_FALSE;
        m_bIsCritical = VARIANT_FALSE;

        return S_OK;
    }

    void FinalRelease()
    {
        m_pIEKUs.Release();
    }

//
// IExtendedKeyUsage
//
public:
    STDMETHOD(get_IsPresent)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

    STDMETHOD(get_IsCritical)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

    STDMETHOD(get_EKUs)
        (/*[out, retval]*/ IEKUs ** pVal);

    //
    // None COM functions.
    //
    STDMETHOD(Init)
        (PCCERT_CONTEXT pCertContext);

private:
    CLock          m_Lock;
    CComPtr<IEKUs> m_pIEKUs;
    VARIANT_BOOL   m_bIsPresent;
    VARIANT_BOOL   m_bIsCritical;
};

#endif //__EXTENDEDKEYUSAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\error.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Error.h

  Content: Global error reporting facilities.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/


#ifndef _INCLUDE_ERROR_H
#define _INCLUDE_ERROR_H

#include "CAPICOM.h"
#include "Resource.h"
#include "Debug.h"

////////////////////
//
// typedefs
//

typedef struct capicom_error_map
{
    CAPICOM_ERROR_CODE ErrorCode;
    DWORD              ErrorStringId;
} CAPICOM_ERROR_MAP;

#ifndef ARRAYSIZE
#define ARRAYSIZE(x)                    (sizeof(x) / sizeof(x[0]))
#endif

//
// Error code to error string ID map.
//
static CAPICOM_ERROR_MAP CapicomErrorMap[] = 
{
    {CAPICOM_E_ENCODE_INVALID_TYPE,                     IDS_CAPICOM_E_ENCODE_INVALID_TYPE},
    {CAPICOM_E_EKU_INVALID_OID,                         IDS_CAPICOM_E_EKU_INVALID_OID},
    {CAPICOM_E_EKU_OID_NOT_INITIALIZED,                 IDS_CAPICOM_E_EKU_OID_NOT_INITIALIZED},
    {CAPICOM_E_CERTIFICATE_NOT_INITIALIZED,             IDS_CAPICOM_E_CERTIFICATE_NOT_INITIALIZED},
    {CAPICOM_E_CERTIFICATE_NO_PRIVATE_KEY,              IDS_CAPICOM_E_CERTIFICATE_NO_PRIVATE_KEY},
    {CAPICOM_E_CHAIN_NOT_BUILT,                         IDS_CAPICOM_E_CHAIN_NOT_BUILT},
    {CAPICOM_E_STORE_NOT_OPENED,                        IDS_CAPICOM_E_STORE_NOT_OPENED},
    {CAPICOM_E_STORE_EMPTY,                             IDS_CAPICOM_E_STORE_EMPTY},
    {CAPICOM_E_STORE_INVALID_OPEN_MODE,                 IDS_CAPICOM_E_STORE_INVALID_OPEN_MODE},
    {CAPICOM_E_STORE_INVALID_SAVE_AS_TYPE,              IDS_CAPICOM_E_STORE_INVALID_SAVE_AS_TYPE},
    {CAPICOM_E_ATTRIBUTE_NAME_NOT_INITIALIZED,          IDS_CAPICOM_E_ATTRIBUTE_NAME_NOT_INITIALIZED},
    {CAPICOM_E_ATTRIBUTE_VALUE_NOT_INITIALIZED,         IDS_CAPICOM_E_ATTRIBUTE_VALUE_NOT_INITIALIZED},
    {CAPICOM_E_ATTRIBUTE_INVALID_NAME,                  IDS_CAPICOM_E_ATTRIBUTE_INVALID_NAME},
    {CAPICOM_E_ATTRIBUTE_INVALID_VALUE,                 IDS_CAPICOM_E_ATTRIBUTE_INVALID_VALUE},
    {CAPICOM_E_SIGNER_NOT_INITIALIZED,                  IDS_CAPICOM_E_SIGNER_NOT_INITIALIZED},
    {CAPICOM_E_SIGNER_NOT_FOUND,                        IDS_CAPICOM_E_SIGNER_NOT_FOUND},
    {CAPICOM_E_SIGNER_NO_CHAIN,                         IDS_CAPICOM_E_SIGNER_NO_CHAIN}, // v2.0
    {CAPICOM_E_SIGNER_INVALID_USAGE,                    IDS_CAPICOM_E_SIGNER_INVALID_USAGE}, // v2.0
    {CAPICOM_E_SIGN_NOT_INITIALIZED,                    IDS_CAPICOM_E_SIGN_NOT_INITIALIZED},
    {CAPICOM_E_SIGN_INVALID_TYPE,                       IDS_CAPICOM_E_SIGN_INVALID_TYPE},
    {CAPICOM_E_SIGN_NOT_SIGNED,                         IDS_CAPICOM_E_SIGN_NOT_SIGNED},
    {CAPICOM_E_INVALID_ALGORITHM,                       IDS_CAPICOM_E_INVALID_ALGORITHM},
    {CAPICOM_E_INVALID_KEY_LENGTH,                      IDS_CAPICOM_E_INVALID_KEY_LENGTH},
    {CAPICOM_E_ENVELOP_NOT_INITIALIZED,                 IDS_CAPICOM_E_ENVELOP_NOT_INITIALIZED},
    {CAPICOM_E_ENVELOP_INVALID_TYPE,                    IDS_CAPICOM_E_ENVELOP_INVALID_TYPE},
    {CAPICOM_E_ENVELOP_NO_RECIPIENT,                    IDS_CAPICOM_E_ENVELOP_NO_RECIPIENT},
    {CAPICOM_E_ENVELOP_RECIPIENT_NOT_FOUND,             IDS_CAPICOM_E_ENVELOP_RECIPIENT_NOT_FOUND},
    {CAPICOM_E_ENCRYPT_NOT_INITIALIZED,                 IDS_CAPICOM_E_ENCRYPT_NOT_INITIALIZED},
    {CAPICOM_E_ENCRYPT_INVALID_TYPE,                    IDS_CAPICOM_E_ENCRYPT_INVALID_TYPE},
    {CAPICOM_E_ENCRYPT_NO_SECRET,                       IDS_CAPICOM_E_ENCRYPT_NO_SECRET},
    {CAPICOM_E_NOT_SUPPORTED,                           IDS_CAPICOM_E_NOT_SUPPORTED},
    {CAPICOM_E_UI_DISABLED,                             IDS_CAPICOM_E_UI_DISABLED},
    {CAPICOM_E_CANCELLED,                               IDS_CAPICOM_E_CANCELLED},
    {CAPICOM_E_NOT_ALLOWED,                             IDS_CAPICOM_E_NOT_ALLOWED}, // v2.0
    {CAPICOM_E_OUT_OF_RESOURCE,                         IDS_CAPICOM_E_OUT_OF_RESOURCE}, // v2.0
    {CAPICOM_E_INTERNAL,                                IDS_CAPICOM_E_INTERNAL},
    {CAPICOM_E_UNKNOWN,                                 IDS_CAPICOM_E_UNKNOWN},
                                                        
    //                                                  
    // CAPICOM v2.0                                     
    //
    {CAPICOM_E_PRIVATE_KEY_NOT_INITIALIZED,             IDS_CAPICOM_E_PRIVATE_KEY_NOT_INITIALIZED},
    {CAPICOM_E_PRIVATE_KEY_NOT_EXPORTABLE,              IDS_CAPICOM_E_PRIVATE_KEY_NOT_EXPORTABLE},
    {CAPICOM_E_ENCODE_NOT_INITIALIZED,                  IDS_CAPICOM_E_ENCODE_NOT_INITIALIZED},
    {CAPICOM_E_EXTENSION_NOT_INITIALIZED,               IDS_CAPICOM_E_EXTENSION_NOT_INITIALIZED},
    {CAPICOM_E_PROPERTY_NOT_INITIALIZED,                IDS_CAPICOM_E_PROPERTY_NOT_INITIALIZED},
    {CAPICOM_E_FIND_INVALID_TYPE,                       IDS_CAPICOM_E_FIND_INVALID_TYPE},
    {CAPICOM_E_FIND_INVALID_PREDEFINED_POLICY,          IDS_CAPICOM_E_FIND_INVALID_PREDEFINED_POLICY},
    {CAPICOM_E_CODE_NOT_INITIALIZED,                    IDS_CAPICOM_E_CODE_NOT_INITIALIZED},
    {CAPICOM_E_CODE_NOT_SIGNED,                         IDS_CAPICOM_E_CODE_NOT_SIGNED},
    {CAPICOM_E_CODE_DESCRIPTION_NOT_INITIALIZED,        IDS_CAPICOM_E_CODE_DESCRIPTION_NOT_INITIALIZED},
    {CAPICOM_E_CODE_DESCRIPTION_URL_NOT_INITIALIZED,    IDS_CAPICOM_E_CODE_DESCRIPTION_URL_NOT_INITIALIZED},
    {CAPICOM_E_CODE_INVALID_TIMESTAMP_URL,              IDS_CAPICOM_E_CODE_INVALID_TIMESTAMP_URL},
    {CAPICOM_E_HASH_NO_DATA,                            IDS_CAPICOM_E_HASH_NO_DATA},
    {CAPICOM_E_INVALID_CONVERT_TYPE,                    IDS_CAPICOM_E_INVALID_CONVERT_TYPE},
};

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  ICAPICOMError:

  This is a template class that implements the ISupportErrorInfo interface. In
  addition, it also contains member functions that facilitate error reporting.
  
  To use it, simply derive your class from this class, and add ISupportErrorInfo
  entry into your COM map.

  ie.

  class ATL_NO_VTABLE CMyClass : 
    ...
    public ICAPICOMError<CMyClass, &IID_IMyClass>,
    ...
  {
    ...

    BEGIN_COM_MAP(CMyClass)
        ...
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        ...
    END_COM_MAP()
    
    ...
  };

------------------------------------------------------------------------------*/

template <class T, const IID * piid>
class ATL_NO_VTABLE ICAPICOMError: public ISupportErrorInfo
{
public:
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid)
    {
        return (IsEqualGUID(riid, *piid)) ? S_OK : S_FALSE;
    }

    HRESULT ReportError(HRESULT hr)
    {
        HLOCAL pMsgBuf = NULL;

        DebugTrace("Entering ReportError(HRESULT).\n");

        //
        // If there's a system message associated with this error, report that.
        //
        if (::FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                             NULL,
                             (DWORD) hr,
                             MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                             (LPSTR) &pMsgBuf,
                             0,
                             NULL))
        {
            //
            // Sanity check.
            //
            ATLASSERT(NULL != pMsgBuf);

            //
            // Report error and free the buffer.
            //
            if (pMsgBuf)
            {
                CComCoClass<T>::Error((LPSTR) pMsgBuf, *piid, hr);

                ::LocalFree(pMsgBuf);
            }
        }
        else
        {
            //
            // No, so try CAPICOM error.
            //
            ReportError((CAPICOM_ERROR_CODE) hr); 
        }

        DebugTrace("Leaving ReportError(HRESULT).\n");

        return hr;
    }

    HRESULT ReportError(CAPICOM_ERROR_CODE CAPICOMError)
    {
        HRESULT hr      = (HRESULT) CAPICOMError;
        DWORD   ids     = IDS_CAPICOM_E_UNKNOWN;
        DWORD   cbMsg   = 0;
        HLOCAL  pMsgBuf = NULL;
        char    szFormat[512] = {'\0'};

        DebugTrace("Entering ReportError(CAPICOM_ERROR_CODE).\n");

        //
        // Map to error string id.
        //
        for (DWORD i = 0; i < ARRAYSIZE(CapicomErrorMap); i++)
        {
            if (CapicomErrorMap[i].ErrorCode == CAPICOMError)
            {
                ids = CapicomErrorMap[i].ErrorStringId;
                break;
            }
        }

        //
        // Load error format string from resource.
        //
        if (::LoadStringA(_Module.GetModuleInstance(), 
                          ids, 
                          szFormat,
                          ARRAYSIZE(szFormat)))
        {
            //
            // Format message into buffer.
            //
            if ('\0' != szFormat[0])
            {
                cbMsg = ::FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                         szFormat,
                                         0,
                                         MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                         (LPSTR) &pMsgBuf,
                                         0,
                                         NULL);
            }
        }
        else
        {
            //
            // well, try a general error string.
            //
            if (::LoadStringA(_Module.GetModuleInstance(),
                              hr = CAPICOM_E_UNKNOWN,
                              szFormat,
                              ARRAYSIZE(szFormat)))
            {
                cbMsg = ::FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                         szFormat,
                                         0,
                                         MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                         (LPSTR) &pMsgBuf,
                                         0,
                                         NULL);
            }
        }

        //
        // If we are still unable to get a formatted error string, then
        // fablicate one ourselves (very unlikely).
        //
        if (0 == cbMsg)
        {
            pMsgBuf = (HLOCAL) ::LocalAlloc(LPTR, sizeof(szFormat));
            if (NULL != pMsgBuf)
            {
                ::lstrcpyA((LPSTR) pMsgBuf, "Unknown error.\n");
            }
        }

        //
        // Report error and free the buffer.
        //
        if (pMsgBuf)
        {
            CComCoClass<T>::Error((LPSTR) pMsgBuf, *piid, hr);

            ::LocalFree(pMsgBuf);
        }

        DebugTrace("Leaving ReportError(CAPICOM_ERROR_CODE).\n");

        return hr;
    }
};
#endif // __INCLUDE_ERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\extendedkeyusage.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    ExtendedKeyUsage.cpp

  Content: Implementation of CExtendedKeyUsage.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "ExtendedKeyUsage.h"
#include "CertHlpr.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateExtendedKeyUsageObject

  Synopsis : Create an IExtendedKeyUsage object and populate the object
             with EKU data from the certificate.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT.

             IExtendedKeyUsage ** ppIExtendedKeyUsage - Pointer to pointer to 
                                                        IExtendedKeyUsage 
                                                        object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateExtendedKeyUsageObject (PCCERT_CONTEXT       pCertContext,
                                      IExtendedKeyUsage ** ppIExtendedKeyUsage)
{
    HRESULT hr = S_OK;
    CComObject<CExtendedKeyUsage> * pCExtendedKeyUsage = NULL;

    DebugTrace("Entering CreateExtendedKeyUsageObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(ppIExtendedKeyUsage);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CExtendedKeyUsage>::CreateInstance(&pCExtendedKeyUsage)))
        {
            DebugTrace("Error [%#x]: CComObject<CExtendedKeyUsage>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize object.
        //
        if (FAILED(hr = pCExtendedKeyUsage->Init(pCertContext)))
        {
            DebugTrace("Error [%#x]: pCExtendedKeyUsage->Init() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return interface pointer to caller.
        //
        if (FAILED(hr = pCExtendedKeyUsage->QueryInterface(ppIExtendedKeyUsage)))
        {
            DebugTrace("Error [%#x]: pCExtendedKeyUsage->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreateExtendedKeyUsageObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    if (pCExtendedKeyUsage)
    {
        delete pCExtendedKeyUsage;
    }

    goto CommonExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// CExtendedKeyUsage
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CExtendedKeyUsage::get_IsPresent

  Synopsis : Check to see if the EKU extension is present.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive result.

  Remark   : Note that this function may return VARIANT_TRUE even if there is 
             no EKU extension found in the certificate, because CAPI will
             take intersection of EKU with EKU extended property (i.e. no 
             EKU extension, but there is EKU extended property.)
             
------------------------------------------------------------------------------*/

STDMETHODIMP CExtendedKeyUsage::get_IsPresent (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CExtendedKeyUsage::get_IsPresent().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
        *pVal = m_bIsPresent;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CExtendedKeyUsage::get_IsPresent().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CExtendedKeyUsage::get_IsCritical

  Synopsis : Check to see if the EKU extension is marked critical.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CExtendedKeyUsage::get_IsCritical (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CExtendedKeyUsage::get_IsCritical().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
        *pVal = m_bIsCritical;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CExtendedKeyUsage::get_IsCritical().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CExtendedKeyUsage::get_EKUs

  Synopsis : Return an EKUs collection object representing all EKUs in the
             certificate.

  Parameter: IEKUs ** pVal - Pointer to pointer to IEKUs to receive the
                             interface pointer.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CExtendedKeyUsage::get_EKUs (IEKUs ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CExtendedKeyUsage::get_EKUs().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_pIEKUs);

        //
        // Return interface pointer to user.
        //
          if (FAILED(hr = m_pIEKUs->QueryInterface(pVal)))
        {
            DebugTrace("Error [%#x]: m_pIEKUs->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CExtendedKeyUsage::get_EKUs().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// Private methods.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CExtendedKeyUsage::Init

  Synopsis : Initialize the object.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT.

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us with CERT_CONTEXT.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CExtendedKeyUsage::Init (PCCERT_CONTEXT pCertContext)
{
    HRESULT            hr          = S_OK;
    PCERT_ENHKEY_USAGE pUsage      = NULL;
    VARIANT_BOOL       bIsPresent  = VARIANT_FALSE;
    VARIANT_BOOL       bIsCritical = VARIANT_FALSE;

    CERT_EXTENSION * pCertExtension;

    DebugTrace("Entering CExtendedKeyUsage::Init().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);

    //
    // Get EKU usages (extension and property).
    //
    hr = ::GetEnhancedKeyUsage(pCertContext, 0, &pUsage);

    switch (hr)
    {
        case S_OK:
        {
            //
            // See if EKU present or not, if so, we mark it as PRESENT,
            // otherwise, we mark it as NOT PRESENT (which means
            // is valid for all usages).
            //
            if (0 != pUsage->cUsageIdentifier)
            {
                //
                // Mark as present.
                //
                bIsPresent = VARIANT_TRUE;
            }
            break;
        }

        case CERT_E_WRONG_USAGE:
        {
            //
            // No valid usage. So marked as PRESENT.
            //
            hr = S_OK;
            bIsPresent = VARIANT_TRUE;
            break;
        }

        default:
        {
            DebugTrace("Error [%#x]: GetEnhancedKeyUsage() failed.\n", hr);
            goto ErrorExit;
            break;
        }
    }

    //
    // Find the extension to see if mark critical.
    //
    if (pCertExtension = ::CertFindExtension(szOID_ENHANCED_KEY_USAGE ,
                                             pCertContext->pCertInfo->cExtension,
                                             pCertContext->pCertInfo->rgExtension))
    {
        //
        // Need to do this since CAPI takes the intersection of EKU with
        // EKU extended property, which means we may not have a EKU extension
        // in the cert at all.
        //
        if (pCertExtension->fCritical)
        {
            bIsCritical = VARIANT_TRUE;
        }
    }

    //
    // Create the EKUs collection object.
    //
    if (FAILED(hr = ::CreateEKUsObject(pUsage, &m_pIEKUs)))
    {
        DebugTrace("Error [%#x]: CreateEKUsObject() failed.\n", hr);
        goto CommonExit;
    }

    //
    // Update member variables.
    //
    m_bIsPresent = bIsPresent;
    m_bIsCritical = bIsCritical;

CommonExit:
    //
    // Free resource.
    //
    if (pUsage)
    {
        ::CoTaskMemFree(pUsage);
    }

    DebugTrace("Leaving CExtendedKeyUsage::Init().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\extendedproperties.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows

  Copyright (C) Microsoft Corporation, 1995 - 1999.

  File:    ExtendedProperties.h

  Content: Declaration of CExtendedProperties.

  History: 06-15-2001    dsie     created

------------------------------------------------------------------------------*/

#ifndef __EXTENDEDPROPERTIES_H_
#define __EXTENDEDPROPERTIES_H_

#include "Resource.h"
#include "Lock.h"
#include "Debug.h"
#include "Error.h"
#include "CopyItem.h"
#include "ExtendedProperty.h"

//
// typdefs to make life easier.
//
typedef std::map<CComBSTR, CComPtr<IExtendedProperty> > ExtendedPropertyMap;
typedef CComEnumOnSTL<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _CopyMapItem<IExtendedProperty>, ExtendedPropertyMap> ExtendedPropertyEnum;
typedef ICollectionOnSTLImpl<IExtendedProperties, ExtendedPropertyMap, VARIANT, _CopyMapItem<IExtendedProperty>, ExtendedPropertyEnum> IExtendedPropertiesCollection;

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateExtendedPropertiesObject

  Synopsis : Create and initialize an IExtendedProperties collection object.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT.
  
             BOOL bReadOnly - TRUE if read only instance, else FALSE.

             IExtendedProperties ** ppIExtendedProperties - Pointer to pointer 
                                                            to IExtendedProperties 
                                                            to receive the 
                                                            interface pointer.
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateExtendedPropertiesObject (PCCERT_CONTEXT         pCertContext,
                                        BOOL                   bReadOnly,
                                        IExtendedProperties ** ppIExtendedProperties);

////////////////////////////////////////////////////////////////////////////////
//
// CExtendedProperties
//
class ATL_NO_VTABLE CExtendedProperties : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CExtendedProperties, &CLSID_ExtendedProperties>,
    public ICAPICOMError<CExtendedProperties, &IID_IExtendedProperties>,
    public IDispatchImpl<IExtendedPropertiesCollection, &IID_IExtendedProperties, &LIBID_CAPICOM,
                         CAPICOM_MAJOR_VERSION, CAPICOM_MINOR_VERSION>
{
public:
    CExtendedProperties()
    {
    }

DECLARE_NO_REGISTRY()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CExtendedProperties)
    COM_INTERFACE_ENTRY(IExtendedProperties)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

    HRESULT FinalConstruct()
    {
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for ExtendedProperties object.\n", hr);
            return hr;
        }

        m_pCertContext = NULL;
        m_bReadOnly = FALSE;

        return S_OK;
    }

    void FinalRelease()
    {
        if (m_pCertContext)
        {
            ::CertFreeCertificateContext(m_pCertContext);
        }
    }

//
// IExtendedProperties
//
public:
    //
    // These are the only ones that we need to implemented, others will be
    // handled by ATL ICollectionOnSTLImpl.
#if (0)
    STDMETHOD(get_Item)
        (/*[in]*/ long Index, 
         /*[out, retval]*/ VARIANT * pVal);
#endif

    STDMETHOD(Add)
        (/*[in]*/ IExtendedProperty * pVal);

    STDMETHOD(Remove)
        (/*[in]*/ CAPICOM_PROPID PropId);

    //
    // None COM functions.
    //
    STDMETHOD(Init) 
        (PCCERT_CONTEXT pCertContext, 
         BOOL           bReadOnly);

private:
    CLock          m_Lock;
    PCCERT_CONTEXT m_pCertContext;
    BOOL           m_bReadOnly;
};

#endif //__EXTENDEDPROPERTIES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\extendedproperty.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    ExtendedProperty.cpp

  Content: Implementation of CExtendedProperty.

  History: 06-15-2001    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "ExtendedProperty.h"
#include "Convert.h"
#include "Settings.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateExtendedPropertyObject

  Synopsis : Create an IExtendedProperty object.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT to be used 
                                           to initialize the IExtendedProperty
                                           object.

             DWORD dwPropId - Property ID.

             BOOL bReadOnly - TRUE for read-only, else FALSE.
             
             IExtendedProperty ** ppIExtendedProperty - Pointer to pointer 
                                                        IExtendedProperty 
                                                        object.
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateExtendedPropertyObject (PCCERT_CONTEXT       pCertContext,
                                      DWORD                dwPropId,
                                      BOOL                 bReadOnly,
                                      IExtendedProperty ** ppIExtendedProperty)
{
    HRESULT hr = S_OK;
    CComObject<CExtendedProperty> * pCExtendedProperty = NULL;

    DebugTrace("Entering CreateExtendedPropertyObject().\n", hr);

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(ppIExtendedProperty);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CExtendedProperty>::CreateInstance(&pCExtendedProperty)))
        {
            DebugTrace("Error [%#x]: CComObject<CExtendedProperty>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize object.
        //
        if (FAILED(hr = pCExtendedProperty->Init(pCertContext, dwPropId, bReadOnly)))
        {
            DebugTrace("Error [%#x]: pCExtendedProperty->Init() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return interface pointer to caller.
        //
        if (FAILED(hr = pCExtendedProperty->QueryInterface(ppIExtendedProperty)))
        {
            DebugTrace("Error [%#x]: pCExtendedProperty->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreateExtendedPropertyObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    if (pCExtendedProperty)
    {
        delete pCExtendedProperty;
    }

    goto CommonExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// CExtendedProperty
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CExtendedProperty::get_PropID

  Synopsis : Return the prop ID.

  Parameter: CAPICOM_PROPID * pVal - Pointer to CAPICOM_PROPID to receive ID.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CExtendedProperty:: get_PropID (CAPICOM_PROPID * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CExtendedProperty::get_PropID().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
        *pVal = (CAPICOM_PROPID) m_dwPropId;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CExtendedProperty::get_PropID().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CExtendedProperty::put_PropID

  Synopsis : Set prop ID.

  Parameter: CAPICOM_PROPID newVal - new prop ID.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CExtendedProperty::put_PropID (CAPICOM_PROPID newVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CExtendedProperty::put_PropID().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure it is not read-only.
        //
        if (m_bReadOnly)
        {
            hr = CAPICOM_E_NOT_ALLOWED;

            DebugTrace("Error [%#x]: Writing read-only PropID property is not allowed.\n", hr);
            goto ErrorExit;
        }

        //
        // Don't allow ID change if this is part of a cert. User need to delete
        // and then add to the ExtendedProperties collection.
        //
        if (m_pCertContext)
        {
            hr = CAPICOM_E_NOT_ALLOWED;

            DebugTrace("Error [%#x]: not allowed to change prop ID when the property is attached to a cert.\n", hr);
            goto ErrorExit;
        }

        //
        // Free previous blob if available.
        //
        if (m_DataBlob.pbData)
        {
            ::CoTaskMemFree((LPVOID) m_DataBlob.pbData);
        }

        //
        // Store value.
        //
        m_dwPropId = newVal;
        m_DataBlob.cbData = 0;
        m_DataBlob.pbData = NULL;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CExtendedProperty::put_PropID().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CExtendedProperty::get_Value

  Synopsis : Return the ExtendedProperty data.

  Parameter: CAPICOM_ENCODING_TYPE EncodingType - Encoding type.
             
             BSTR * pVal - Pointer to BSTR to receive the data.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CExtendedProperty::get_Value (CAPICOM_ENCODING_TYPE EncodingType, 
                                           BSTR                * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CExtendedProperty::get_Value().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure Prop ID is valid.
        //
        if (CAPICOM_PROPID_UNKNOWN == m_dwPropId)
        {
            hr = CAPICOM_E_PROPERTY_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: m_dwPropId member is not initialized.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
        if (FAILED(hr = ::ExportData(m_DataBlob, EncodingType, pVal)))
        {
            DebugTrace("Error [%#x]: ExportData() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CExtendedProperty::get_Value().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CExtendedProperty::put_Value

  Synopsis : Set the ExtendedProperty data.

  Parameter: CAPICOM_ENCODING_TYPE EncodingType - Encoding type.
             
             BSTR newVal - BSTR containing the encoded property.
  
  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CExtendedProperty::put_Value (CAPICOM_ENCODING_TYPE EncodingType, 
                                           BSTR                  newVal)
{
    HRESULT   hr       = S_OK;
    DATA_BLOB DataBlob = {0, NULL};

    DebugTrace("Entering CExtendedProperty::put_Value().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure Prop ID is valid.
        //
        if (CAPICOM_PROPID_UNKNOWN == m_dwPropId)
        {
            hr = CAPICOM_E_PROPERTY_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: m_dwPropId member is not initialized.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure it is not read-only.
        //
        if (m_bReadOnly)
        {
            hr = CAPICOM_E_NOT_ALLOWED;

            DebugTrace("Error [%#x]: Writing read-only PropID property is not allowed.\n", hr);
            goto ErrorExit;
        }

        //
        // Import non-NULL data.
        //
        if (0 < ::SysStringByteLen(newVal))
        {
            if (FAILED(hr = ::ImportData(newVal, EncodingType, &DataBlob)))
            {
                DebugTrace("Error [%#x]: ImportData() failed.\n", hr);
                goto ErrorExit;
            }
        }

        //
        // Write through to cert, if attached.
        //
        if (m_pCertContext)
        {
            LPVOID pvData;

            //
            // Some properties point to the data directly.
            //
            if (m_dwPropId == CAPICOM_PROPID_KEY_CONTEXT ||
                m_dwPropId == CAPICOM_PROPID_KEY_PROV_HANDLE ||
                m_dwPropId == CAPICOM_PROPID_KEY_PROV_INFO ||
                m_dwPropId == CAPICOM_PROPID_KEY_SPEC ||
                m_dwPropId == CAPICOM_PROPID_DATE_STAMP)
            {
                pvData = DataBlob.pbData;
            }
            else if ((m_dwPropId == CAPICOM_PROPID_FRIENDLY_NAME) &&
                     (L'\0' != newVal[::SysStringLen(newVal) - 1]))
            {
                LPBYTE pbNewVal = NULL;

                if (NULL == (pbNewVal = (LPBYTE) ::CoTaskMemAlloc(DataBlob.cbData + sizeof(WCHAR))))
                {
                    hr = E_OUTOFMEMORY;

                    DebugTrace("Error [%#x]: CoTaskMemAlloc() failed.\n", hr);
                    goto ErrorExit;
                }

                ::ZeroMemory(pbNewVal, DataBlob.cbData + sizeof(WCHAR));
                ::CopyMemory(pbNewVal, DataBlob.pbData, DataBlob.cbData);
                
                ::CoTaskMemFree(DataBlob.pbData);
                DataBlob.cbData += sizeof(WCHAR);
                DataBlob.pbData = pbNewVal;

                pvData = &DataBlob;
            }
            else
            {
                pvData = &DataBlob;
            }

            if (!::CertSetCertificateContextProperty(m_pCertContext, 
                                                     m_dwPropId, 
                                                     0,
                                                     pvData))
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());
    
                DebugTrace("Error [%#x]: CertSetCertificateContextProperty() failed.\n", hr);
                goto ErrorExit;
            }
        }

        //
        // Set it.
        //
        if (m_DataBlob.pbData)
        {
            ::CoTaskMemFree(m_DataBlob.pbData);
        }

        m_DataBlob = DataBlob;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CExtendedProperty::put_Value().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resources.
    //
    if (DataBlob.pbData)
    {
        ::CoTaskMemFree(DataBlob.pbData);
    }

    ReportError(hr);

    goto UnlockExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// Private methods.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CExtendedProperty::Init

  Synopsis : Initialize the object.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT to be used 
                                           to initialize the IExtendedProperty
                                           object.

             DWORD dwPropId - Property ID.
             
             BOOL bReadOnly - TRUE for read-only, else FALSE.

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us with CERT_ExtendedProperty.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CExtendedProperty::Init (PCCERT_CONTEXT pCertContext,
                                      DWORD          dwPropId,
                                      BOOL           bReadOnly)
{
    HRESULT        hr            = S_OK;
    DATA_BLOB      DataBlob      = {0, NULL};
    PCCERT_CONTEXT pCertContext2 = NULL;

    DebugTrace("Entering CExtendedProperty::Init().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(CAPICOM_PROPID_UNKNOWN != dwPropId);

    //
    // Duplicate the handle.
    //
    if (!(pCertContext2 = ::CertDuplicateCertificateContext(pCertContext)))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CertDuplicateCertificateContext() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Get content of property.
    //
    if (::CertGetCertificateContextProperty(pCertContext,
                                            dwPropId,
                                            NULL,
                                            &DataBlob.cbData))
    {
        if (NULL == (DataBlob.pbData = (LPBYTE) ::CoTaskMemAlloc(DataBlob.cbData)))
        {
            hr = E_OUTOFMEMORY;
    
            DebugTrace("Error: out of memory.\n", hr);
            goto ErrorExit;
        }
    
        if (!::CertGetCertificateContextProperty(pCertContext,
                                                 dwPropId,
                                                 DataBlob.pbData,
                                                 &DataBlob.cbData))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
    
            DebugTrace("Error [%#x]: CertGetCertificateContextProperty() failed.\n", hr);
            goto ErrorExit;
        }
    }

    //
    // Set states.
    //
    m_dwPropId = dwPropId;
    m_bReadOnly = bReadOnly;
    m_DataBlob = DataBlob;
    m_pCertContext = pCertContext2;

CommonExit:

    DebugTrace("Leaving CExtendedProperty::Init().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resources.
    //
    if (pCertContext2)
    {
        ::CertFreeCertificateContext(pCertContext2);
    }
    if (DataBlob.pbData)
    {
        ::CoTaskMemFree((LPVOID) DataBlob.pbData);
    }

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\extendedproperty.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    ExtendedProperty.h

  Content: Declaration of the CExtendedProperty.

  History: 06-15-2001    dsie     created

------------------------------------------------------------------------------*/

#ifndef __EXTENDEDPROPERTY_H_
#define __EXTENDEDPROPERTY_H_

#include "Resource.h"
#include "Lock.h"
#include "Error.h"
#include "Debug.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateExtendedPropertyObject

  Synopsis : Create an IExtendedProperty object.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT to be used 
                                           to initialize the IExtendedProperty
                                           object.

             DWORD dwPropId - Property ID.

             BOOL bReadOnly - TRUE for read-only, else FALSE.
             
             IExtendedProperty ** ppIExtendedProperty - Pointer to pointer 
                                                        IExtendedProperty 
                                                        object.
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateExtendedPropertyObject (PCCERT_CONTEXT       pCertContext,
                                      DWORD                dwPropId,
                                      BOOL                 bReadOnly,
                                      IExtendedProperty ** ppIExtendedProperty);

////////////////////////////////////////////////////////////////////////////////
//
// CExtendedProperty
//
class ATL_NO_VTABLE CExtendedProperty :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CExtendedProperty, &CLSID_ExtendedProperty>,
    public ICAPICOMError<CExtendedProperty, &IID_IExtendedProperty>,
    public IDispatchImpl<IExtendedProperty, &IID_IExtendedProperty, &LIBID_CAPICOM,
                         CAPICOM_MAJOR_VERSION, CAPICOM_MINOR_VERSION>
{
public:
    CExtendedProperty()
    {
    }

    HRESULT FinalConstruct()
    {
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for ExtendedProperty object.\n", hr);
            return hr;
        }

        m_dwPropId = CAPICOM_PROPID_UNKNOWN;
        m_bReadOnly = FALSE;
        m_DataBlob.cbData = 0;
        m_DataBlob.pbData = NULL;
        m_pCertContext = NULL;

        return S_OK;
    }

    void FinalRelease()
    {
        if (m_DataBlob.pbData) 
        {
            ::CoTaskMemFree((LPVOID) m_DataBlob.pbData);
        }
        if (m_pCertContext)
        {
            ::CertFreeCertificateContext(m_pCertContext);
        }
    }

DECLARE_REGISTRY_RESOURCEID(IDR_EXTENDEDPROPERTY)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CExtendedProperty)
    COM_INTERFACE_ENTRY(IExtendedProperty)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//
// IExtendedProperty
//
public:
    STDMETHOD(get_PropID)
        (/*[out, retval]*/ /*[in]*/ CAPICOM_PROPID * pVal);

    STDMETHOD(put_PropID)
        (/*[in]*/ CAPICOM_PROPID newVal);

    STDMETHOD(get_Value)
        (/*[in, defaultvalue(CAPICOM_ENCODE_BASE64)]*/ CAPICOM_ENCODING_TYPE EncodingType, 
         /*[out, retval]*/ BSTR * pVal);

    STDMETHOD(put_Value)
        (/*[in, defaultvalue(CAPICOM_ENCODE_BASE64)]*/ CAPICOM_ENCODING_TYPE EncodingType, 
         /*[in]*/ BSTR newVal);

    //
    // None COM functions.
    //
    STDMETHOD(Init)
        (PCCERT_CONTEXT pCertContext, DWORD dwPropId, BOOL bReadOnly);

private:
    CLock          m_Lock;
    DWORD          m_dwPropId;
    BOOL           m_bReadOnly;
    DATA_BLOB      m_DataBlob;
    PCCERT_CONTEXT m_pCertContext;
};

#endif //__EXTENDEDPROPERTY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\extensions.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:     Extensions.cpp

  Contents: Implementation of CExtensions class for collection of 
            IExtension objects.

  Remarks:  This object is not creatable by user directly. It can only be
            created via property/method of other CAPICOM objects.

            The collection container is implemented usign STL::map of 
            STL::pair of BSTR and IExtension..

            See Chapter 9 of "BEGINNING ATL 3 COM Programming" for algorithm
            adopted in here.

  History:  06-15-2001    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "Extensions.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateExtensionsObject

  Synopsis : Create an IExtensions collection object, and load the object with 
             Extensions from the specified location.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT to be used
                                           to initialize the IExtensions object.

             IExtensions ** ppIExtensions - Pointer to pointer IExtensions
                                            to recieve the interface pointer.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateExtensionsObject (PCCERT_CONTEXT  pCertContext,
                                IExtensions  ** ppIExtensions)
{
    HRESULT hr = S_OK;
    CComObject<CExtensions> * pCExtensions = NULL;

    DebugTrace("Entering CreateExtensionsObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(ppIExtensions);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CExtensions>::CreateInstance(&pCExtensions)))
        {
            DebugTrace("Error [%#x]: CComObject<CExtensions>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Init object with extensions.
        //
        if (FAILED(hr = pCExtensions->Init(pCertContext->pCertInfo->cExtension,
                                           pCertContext->pCertInfo->rgExtension)))
        {
            DebugTrace("Error [%#x]: pCExtensions->Init() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return interface pointer to caller.
        //
        if (FAILED(hr = pCExtensions->QueryInterface(ppIExtensions)))
        {
            DebugTrace("Error [%#x]: pCExtensions->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreateExtensionsObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (pCExtensions)
    {
        delete pCExtensions;
    }

    goto CommonExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// CExtensions
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CExtensions::get_Item

  Synopsis : Return item in the collection.

  Parameter: VARIANT Index - Numeric index or string OID.
   
             VARIANT * pVal - Pointer to VARIANT to receive the IDispatch.

  Remark   :
             
------------------------------------------------------------------------------*/

STDMETHODIMP CExtensions::get_Item (VARIANT Index, VARIANT * pVal)
{
    HRESULT  hr = S_OK;
    CComBSTR bstrIndex;
    CComPtr<IExtension> pIExtension = NULL;

    DebugTrace("Entering CExtensions::get_Item().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Intialize.
        //
        ::VariantInit(pVal);

        //
        // Numeric or string?
        //
        if (VT_BSTR == Index.vt)
        {
            //
            // Index by OID string.
            //
            ExtensionMap::iterator it;

            //
            // Find the item with this OID.
            //
            it = m_coll.find(Index.bstrVal);

            if (it == m_coll.end())
            {
                DebugTrace("Info: Extension (%ls) not found in the collection.\n", Index.bstrVal);
                goto CommonExit;
            }

            //
            // Point to found item.
            //
            pIExtension = (*it).second;

            //
            // Return to caller.
            //
            pVal->vt = VT_DISPATCH;
            if (FAILED(hr = pIExtension->QueryInterface(IID_IDispatch, (void **) &(pVal->pdispVal))))
            {
                DebugTrace("Error [%#x]: pIExtension->QueryInterface() failed.\n", hr);
                goto ErrorExit;
            }
        }
        else
        {
            //
            // Coerce to integer.
            //
            if (FAILED(hr = ::VariantChangeType(&Index, &Index, 0, VT_I4)))
            {
                DebugTrace("Error [%#x]: VariantChangeType() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Use the base class implemented by ATL.
            //
            if (FAILED(hr = IExtensionsCollection::get_Item(Index.lVal, pVal)))
            {
                DebugTrace("Error [%#x]: IExtensionsCollection::get_Item() failed.\n", hr);
                goto ErrorExit;
            }
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CExtensions::get_Item().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto CommonExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// Non COM functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CExtensions::Init

  Synopsis : Load all extensions into the collection.

  Parameter: DWORD cExtensions - Number of extensions.
  
             PCERT_EXTENSION * rgExtensions - Array of extensions.

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CExtensions::Init (DWORD           cExtensions,
                                PCERT_EXTENSION rgExtensions)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CExtensions::Init().\n");

    try
    {
        //
        // Add all to the collection.
        //
        for (DWORD i = 0; i < cExtensions; i++)
        {
            CComBSTR bstrIndex;
            CComPtr<IExtension> pIExtension = NULL;

            //
            // Create the IExtension object.
            //
            if (FAILED(hr = ::CreateExtensionObject(&rgExtensions[i], &pIExtension.p)))
            {
                DebugTrace("Error [%#x]: CreateExtensionObject() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // BSTR index of OID string.
            //
            if (!(bstrIndex = rgExtensions[i].pszObjId))
            {
                hr = E_OUTOFMEMORY;

                DebugTrace("Error [%#x]: bstrIndex = rgExtensions[i].pszObjId failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Now add object to collection map.
            //
            // Note that the overloaded = operator for CComPtr will
            // automatically AddRef to the object. Also, when the CComPtr
            // is deleted (happens when the Remove or map destructor is called), 
            // the CComPtr destructor will automatically Release the object.
            //
            m_coll[bstrIndex] = pIExtension;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CExtensions::Init().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\extension.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Extension.cpp

  Content: Implementation of CExtension.

  History: 06-15-2001    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "Extension.h"
#include "OID.h"
#include "EncodedData.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateExtensionObject

  Synopsis : Create an IExtension object.

  Parameter: PCERT_EXTENSION pCertExtension - Pointer to CERT_EXTENSION to be 
                                              used to initialize the IExtension
                                              object.

             IExtension ** ppIExtension - Pointer to pointer IExtension object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateExtensionObject (PCERT_EXTENSION    pCertExtension, 
                               IExtension      ** ppIExtension)
{
    HRESULT hr = S_OK;
    CComObject<CExtension> * pCExtension = NULL;

    DebugTrace("Entering CreateExtensionObject().\n", hr);

    //
    // Sanity check.
    //
    ATLASSERT(pCertExtension);
    ATLASSERT(ppIExtension);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CExtension>::CreateInstance(&pCExtension)))
        {
            DebugTrace("Error [%#x]: CComObject<CExtension>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize object.
        //
        if (FAILED(hr = pCExtension->Init(pCertExtension)))
        {
            DebugTrace("Error [%#x]: pCExtension->Init() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return interface pointer to caller.
        //
        if (FAILED(hr = pCExtension->QueryInterface(ppIExtension)))
        {
            DebugTrace("Error [%#x]: pCExtension->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreateExtensionObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    if (pCExtension)
    {
        delete pCExtension;
    }

    goto CommonExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// CExtension
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CExtension::get_OID

  Synopsis :Return the OID object.

  Parameter: IOID ** pVal - Pointer to pointer to IOID to receive the interface
                            pointer.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CExtension:: get_OID (IOID ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CExtension::get_OID().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_pIOID);

        //
        // Return result.
        //
        if (FAILED(hr = m_pIOID->QueryInterface(pVal)))
        {
            DebugTrace("Error [%#x]: m_pIOID->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CExtension::get_OID().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CExtension::get_IsCritical

  Synopsis : Check to see if the extension is marked critical.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CExtension::get_IsCritical (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CExtension::get_IsCritical().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
        *pVal = m_bIsCritical;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CExtension::get_IsCritical().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CExtension::get_EncodedData

  Synopsis : Return the encoded data object.

  Parameter: IEncodedData ** pVal - Pointer to pointer to IEncodedData to 
                                    receive the interface pointer.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CExtension::get_EncodedData (IEncodedData ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CExtension::get_EncodedData().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_pIEncodedData);

        //
        // Return result.
        //
        if (FAILED(hr = m_pIEncodedData->QueryInterface(pVal)))
        {
            DebugTrace("Error [%#x]: m_pIEncodedData->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CExtension::get_EncodedData().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// Private methods.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CExtension::Init

  Synopsis : Initialize the object.

  Parameter: PCERT_EXTENSION pCertExtension - Pointer to CERT_EXTENSION.

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us with CERT_EXTENSION.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CExtension::Init (PCERT_EXTENSION pCertExtension)
{
    HRESULT               hr            = S_OK;
    CComPtr<IOID>         pIOID         = NULL;
    CComPtr<IEncodedData> pIEncodedData = NULL;

    DebugTrace("Entering CExtension::Init().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertExtension);

    //
    // Create the embeded OID object.
    //
    if (FAILED(hr = ::CreateOIDObject(pCertExtension->pszObjId,
                                      TRUE,
                                      &pIOID.p)))
    {
        DebugTrace("Error [%#x]: CreateOIDObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Create the embeded EncodedData object.
    //
    if (FAILED(hr = ::CreateEncodedDataObject(pCertExtension->pszObjId,
                                              &pCertExtension->Value,
                                              &pIEncodedData)))
    {
        DebugTrace("Error [%#x]: CreateEncodedDataObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Reset.
    //
    m_bIsCritical = pCertExtension->fCritical ? VARIANT_TRUE : VARIANT_FALSE;
    m_pIOID = pIOID;
    m_pIEncodedData = pIEncodedData;

CommonExit:

    DebugTrace("Leaving CExtension::Init().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\hasheddata.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    HashedData.cpp

  Content: Implementation of CHashedData.

  History: 11-12-2001    dsie     created

------------------------------------------------------------------------------*/

#include "stdafx.h"
#include "CAPICOM.h"
#include "HashedData.h"

#include "Common.h"
#include "Convert.h"

typedef struct _tagHashAlgoTable
{
    CAPICOM_HASH_ALGORITHM CapicomHashAlg;
    ALG_ID                 AlgId;
} HASH_ALGO_TABLE;

static HASH_ALGO_TABLE HashAlgoTable[] = {
    {CAPICOM_HASH_ALGORITHM_SHA1,       CALG_SHA1},
    {CAPICOM_HASH_ALGORITHM_MD2,        CALG_MD2},
    {CAPICOM_HASH_ALGORITHM_MD4,        CALG_MD4},
    {CAPICOM_HASH_ALGORITHM_MD5,        CALG_MD5},
    // {CAPICOM_HASH_ALGORITHM_SHA_256,    CALG_SHA_256},
    // {CAPICOM_HASH_ALGORITHM_SHA_384,    CALG_SHA_384},
    // {CAPICOM_HASH_ALGORITHM_SHA_512,    CALG_SHA_512}
};

////////////////////////////////////////////////////////////////////////////////
//
// CHashedData
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CHashedData::get_Value

  Synopsis : Return the hash value.

  Parameter: BSTR * pVal - Pointer to BSTR to receive the hashed value blob.

  Remark   : 

------------------------------------------------------------------------------*/

STDMETHODIMP CHashedData::get_Value (BSTR * pVal)
{
    HRESULT         hr        = S_OK;
    DWORD           dwDataLen = sizeof(DWORD);
    CRYPT_DATA_BLOB HashData  = {0, NULL};

    DebugTrace("Entering CHashedData::get_Value().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure we have hash data.
        //
        if (!m_hCryptHash)
        {
            hr = CAPICOM_E_HASH_NO_DATA;

            DebugTrace("Error [%#x]: no value for HashedData.\n", hr);
            goto ErrorExit;
        }

        //
        // Get size of hashed value.
        //
        if (!::CryptGetHashParam(m_hCryptHash, 
                                 HP_HASHSIZE, 
                                 (LPBYTE) &HashData.cbData, 
                                 &dwDataLen, 
                                 0))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptGetHashParam() failed to get size.\n", hr);
            goto ErrorExit;
        }

        //
        // Allocate memory.
        //
        if (!(HashData.pbData = (LPBYTE) ::CoTaskMemAlloc(HashData.cbData)))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error [%#x]: CoTaskMemAlloc() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Now get the hashed value.
        //
        if (!::CryptGetHashParam(m_hCryptHash, HP_HASHVAL, HashData.pbData, &HashData.cbData, 0))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptGetHashParam() failed to get data.\n", hr);
            goto ErrorExit;
        }

        //
        // Export HashedData.
        //
        if (FAILED(hr = ::BinaryToHexString(HashData.pbData, HashData.cbData, pVal)))
        {
            DebugTrace("Error [%#x]: BinaryToHexString() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Reset state.
        //
        m_HashState = CAPICOM_HASH_INIT_STATE;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resources.
    //
    if (HashData.pbData)
    {
        ::CoTaskMemFree((LPVOID) HashData.pbData);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CHashedData::get_Value().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CHashedData::get_Algorithm

  Synopsis : Return the agorithm.

  Parameter: CAPICOM_HASH_ALGORITHM * pVal - Pointer to CAPICOM_HASH_ALGORITHM
                                             to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CHashedData::get_Algorithm (CAPICOM_HASH_ALGORITHM * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CHashedData::get_Algorithm().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
        *pVal = m_Algorithm;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CHashedData::get_Algorithm().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CHashedData::put_Algorithm

  Synopsis : Set algorithm.

  Parameter: CAPICOM_HASH_ALGORITHM newVal - Algorithm enum name.
  
  Remark   : The object state is reset..

------------------------------------------------------------------------------*/

STDMETHODIMP CHashedData::put_Algorithm (CAPICOM_HASH_ALGORITHM newVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CHashedData::put_Algorithm().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure algo is supported.
        //
        switch (newVal)
        {
            case CAPICOM_HASH_ALGORITHM_SHA1:
            case CAPICOM_HASH_ALGORITHM_MD2:
            case CAPICOM_HASH_ALGORITHM_MD4:
            case CAPICOM_HASH_ALGORITHM_MD5:
            // case CAPICOM_HASH_ALGORITHM_SHA_256:
            // case CAPICOM_HASH_ALGORITHM_SHA_384:
            // case CAPICOM_HASH_ALGORITHM_SHA_512:

            {
                break;
            }

            default:
            {
                hr = CAPICOM_E_INVALID_ALGORITHM;

                DebugTrace("Error [%#x]: Unknown hash algorithm (%u).\n", hr, newVal);
                goto ErrorExit;
            }
        }

        m_Algorithm = newVal;
   }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CHashedData::put_Algorithm().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CHashedData::Hash

  Synopsis : Hash data.

  Parameter: BSTR newVal - BSTR of value to hash.

  Remark   :
             
------------------------------------------------------------------------------*/

STDMETHODIMP CHashedData::Hash (BSTR newVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CHashedData::Hash().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == newVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter newVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Check our state.
        //
        switch (m_HashState)
        {
            case CAPICOM_HASH_INIT_STATE:
            {
                DWORD  Index = 0;
                ALG_ID AlgId = 0;

                //
                // Map algorithm to ALG_ID.
                //
                for (Index = 0; Index < ARRAYSIZE(HashAlgoTable); Index++)
                {
                    if (HashAlgoTable[Index].CapicomHashAlg == m_Algorithm)
                    {
                        AlgId = HashAlgoTable[Index].AlgId;
                        break;
                    }
                }

                //
                // Get the provider, if needed.
                //
                if (!m_hCryptProv)
                {
                    if (FAILED(hr = ::AcquireContext(AlgId, &m_hCryptProv)))
                    {
                        DebugTrace("Error [%#x]: AcquireContext() failed.\n", hr);
                        goto ErrorExit;
                    }
                }

                //
                // Sanity check.
                //
                ATLASSERT(Index < ARRAYSIZE(HashAlgoTable));

                //
                // Free handles if still available.
                //
                if (m_hCryptHash)
                {
                    if (!::CryptDestroyHash(m_hCryptHash))
                    {
                        hr = HRESULT_FROM_WIN32(::GetLastError());

                        DebugTrace("Error [%#x]: CryptDestroyHash() failed.\n", hr);
                        goto ErrorExit;
                    }

                    m_hCryptHash = NULL;
                }

                //
                // Create a new hash handle.
                //
                if (!::CryptCreateHash(m_hCryptProv, AlgId, NULL, 0, &m_hCryptHash))
                {
                    hr = HRESULT_FROM_WIN32(::GetLastError());

                    DebugTrace("Error [%#x]: CryptCreateHash() failed.\n", hr);
                    goto ErrorExit;
                }


                //
                // Update hash handle and state.
                //
                m_HashState  = CAPICOM_HASH_DATA_STATE;

                //
                // Fall thru to hash data.
                //
            }

            case CAPICOM_HASH_DATA_STATE:
            {
                //
                // Sanity check.
                //
                ATLASSERT(m_hCryptProv);
                ATLASSERT(m_hCryptHash);

                //
                // Hash the data.
                //
                if (!::CryptHashData(m_hCryptHash, 
                                     (PBYTE) newVal, 
                                     ::SysStringByteLen(newVal), 
                                     0))
                {
                    hr = HRESULT_FROM_WIN32(::GetLastError());

                    DebugTrace("Error [%#x]: CryptHashData() failed.\n", hr);
                    goto ErrorExit;
                }
 
                break;
            }

            default:
            {
                hr = CAPICOM_E_INTERNAL;

                DebugTrace("Error [%#x]: Unknown hash state (%d).\n", hr, m_HashState);
                goto ErrorExit;
            }
        }
     }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CHashedData::Hash().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\hasheddata.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    HashedData.h

  Content: Declaration of CHashedData.

  History: 11-12-2001   dsie     created

------------------------------------------------------------------------------*/

#ifndef __HASHEDDATA_H_
#define __HASHEDDATA_H_

#include "Resource.h"
#include "Error.h"
#include "Lock.h"
#include "Debug.h"

typedef enum
{
    CAPICOM_HASH_INIT_STATE     = 0,
    CAPICOM_HASH_DATA_STATE     = 1,
} CAPICOM_HASH_STATE;

////////////////////////////////////////////////////////////////////////////////
//
// CHashedData
//
class ATL_NO_VTABLE CHashedData : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CHashedData, &CLSID_HashedData>,
    public ICAPICOMError<CHashedData, &IID_IHashedData>,
    public IDispatchImpl<IHashedData, &IID_IHashedData, &LIBID_CAPICOM,
                         CAPICOM_MAJOR_VERSION, CAPICOM_MINOR_VERSION>,
    public IObjectSafetyImpl<CHashedData, INTERFACESAFE_FOR_UNTRUSTED_CALLER | 
                                          INTERFACESAFE_FOR_UNTRUSTED_DATA>
{
public:
    CHashedData()
    {
    }

DECLARE_REGISTRY_RESOURCEID(IDR_HASHEDDATA)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CHashedData)
    COM_INTERFACE_ENTRY(IHashedData)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CHashedData)
    IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
    IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
END_CATEGORY_MAP()

    HRESULT FinalConstruct()
    {
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for Certificate object.\n", hr);
            return hr;
        }

        m_hCryptProv = NULL;
        m_hCryptHash = NULL;
        m_Algorithm  = CAPICOM_HASH_ALGORITHM_SHA1;
        m_HashState  = CAPICOM_HASH_INIT_STATE;

        return S_OK;
    }

    void FinalRelease()
    {
        if (m_hCryptHash)
        {
            ::CryptDestroyHash(m_hCryptHash);
        }
        if (m_hCryptProv)
        {
            ::CryptReleaseContext(m_hCryptProv, 0);
        }
    }

//
// IHashedData
//
public:
    STDMETHOD(get_Value)
        (/*[out, retval]*/ BSTR * pVal);

    STDMETHOD(get_Algorithm)
        (/*[out, retval]*/ CAPICOM_HASH_ALGORITHM * pVal);

    STDMETHOD(put_Algorithm)
        (/*[in]*/ CAPICOM_HASH_ALGORITHM newVal);

    STDMETHOD(Hash)
        (/*[in]*/ BSTR newVal);

private:
    CLock                   m_Lock;
    HCRYPTPROV              m_hCryptProv;
    HCRYPTHASH              m_hCryptHash;
    CAPICOM_HASH_ALGORITHM  m_Algorithm;
    CAPICOM_HASH_STATE      m_HashState;
};

#endif //__HASHEDDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\extensions.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Extensions.h

  Content: Declaration of CExtensions.

  History: 06-15-2001    dsie     created

------------------------------------------------------------------------------*/

#ifndef __EXTENSIONS_H_
#define __EXTENSIONS_H_

#include "Resource.h"
#include "Lock.h"
#include "Debug.h"
#include "Error.h"
#include "CopyItem.h"
#include "Extension.h"

//
// typdefs to make life easier.
//
typedef std::map<CComBSTR, CComPtr<IExtension> > ExtensionMap;
typedef CComEnumOnSTL<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _CopyMapItem<IExtension>, ExtensionMap> ExtensionEnum;
typedef ICollectionOnSTLImpl<IExtensions, ExtensionMap, VARIANT, _CopyMapItem<IExtension>, ExtensionEnum> IExtensionsCollection;


////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateExtensionsObject

  Synopsis : Create an IExtensions collection object, and load the object with 
             Extensions from the specified location.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT to be used
                                           to initialize the IExtensions object.

             IExtensions ** ppIExtensions - Pointer to pointer IExtensions
                                            to recieve the interface pointer.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateExtensionsObject (PCCERT_CONTEXT pCertContext,
                                IExtensions  ** ppIExtensions);

                                
////////////////////////////////////////////////////////////////////////////////
//
// CExtensions
//
class ATL_NO_VTABLE CExtensions : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CExtensions, &CLSID_Extensions>,
    public ICAPICOMError<CExtensions, &IID_IExtensions>,
    public IDispatchImpl<IExtensionsCollection, &IID_IExtensions, &LIBID_CAPICOM,
                         CAPICOM_MAJOR_VERSION, CAPICOM_MINOR_VERSION>
{
public:
    CExtensions()
    {
    }

    HRESULT FinalConstruct()
    {
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for Extensions object.\n", hr);
            return hr;
        }

        return S_OK;
    }

DECLARE_NO_REGISTRY()

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CExtensions)
    COM_INTERFACE_ENTRY(IExtensions)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CExtensions)
END_CATEGORY_MAP()

//
// IExtensions
//
public:
    //
    // These are the only ones that we need to implemented, others will be
    // handled by ATL ICollectionOnSTLImpl.
    //
    STDMETHOD(get_Item)
        (/*[in] */ VARIANT Index, 
         /*[out, retval]*/ VARIANT * pVal);
    //
    // None COM functions.
    //
    STDMETHOD(Init)
        (DWORD cExtensions,
         PCERT_EXTENSION rgExtensions);

private:
    CLock m_Lock;
};

#endif //__EXTENSIONS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\extension.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Extension.h

  Content: Declaration of the CExtension.

  History: 06-15-2001    dsie     created

------------------------------------------------------------------------------*/

#ifndef __EXTENSION_H_
#define __EXTENSION_H_

#include "Resource.h"
#include "Lock.h"
#include "Error.h"
#include "Debug.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateExtensionObject

  Synopsis : Create an IExtension object.

  Parameter: PCERT_EXTENSION pCertExtension - Pointer to CERT_EXTENSION to be 
                                              used to initialize the IExtension
                                              object.

             IExtension ** ppIExtension - Pointer to pointer IExtension object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateExtensionObject (PCERT_EXTENSION    pCertExtension, 
                               IExtension      ** ppIExtension);

                               
////////////////////////////////////////////////////////////////////////////////
//
// CExtension
//
class ATL_NO_VTABLE CExtension : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CExtension, &CLSID_Extension>,
    public ICAPICOMError<CExtension, &IID_IExtension>,
    public IDispatchImpl<IExtension, &IID_IExtension, &LIBID_CAPICOM,
                         CAPICOM_MAJOR_VERSION, CAPICOM_MINOR_VERSION>
{
public:
    CExtension()
    {
    }

    HRESULT FinalConstruct()
    {
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for Extension object.\n", hr);
            return hr;
        }

        m_pIOID = NULL;
        m_pIEncodedData = NULL;
        m_bIsCritical = VARIANT_FALSE;

        return S_OK;
    }

    void FinalRelease()
    {
        m_pIOID.Release();
        m_pIEncodedData.Release();
    }

DECLARE_NO_REGISTRY()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CExtension)
    COM_INTERFACE_ENTRY(IExtension)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CExtension)
END_CATEGORY_MAP()

//
// IExtension
//
public:
    STDMETHOD(get_OID)
        (/*[out, retval]*/ IOID ** pVal);

    STDMETHOD(get_IsCritical)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

    STDMETHOD(get_EncodedData)
        (/*[out, retval]*/ IEncodedData ** pVal);

    //
    // None COM functions.
    //
    STDMETHOD(Init)
        (PCERT_EXTENSION pCertExtension);

private:
    CLock                   m_Lock;
    VARIANT_BOOL            m_bIsCritical;
    CComPtr<IOID>           m_pIOID;
    CComPtr<IEncodedData>   m_pIEncodedData;
};

#endif //__EXTENSION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\keyusage.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows

  Copyright (C) Microsoft Corporation, 1995 - 1999.

  File:    KeyUsage.h

  Content: Declaration of the CKeyUsage.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#ifndef __KEYUSAGE_H_
#define __KEYUSAGE_H_

#include "Resource.h"
#include "Lock.h"
#include "Error.h"
#include "Debug.h"

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateKeyUsageObject

  Synopsis : Create a IKeyUsage object and populate the porperties with
             data from the key usage extension of the specified certificate.

  Parameter: PCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT to be used
                                          to initialize the IKeyUsage object.

             IKeyUsage ** ppIKeyUsage   - Pointer to pointer IKeyUsage object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateKeyUsageObject (PCCERT_CONTEXT pCertContext, IKeyUsage ** ppIKeyUsage);


////////////////////////////////////////////////////////////////////////////////
//
// CKeyUsage
//

class ATL_NO_VTABLE CKeyUsage : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CKeyUsage, &CLSID_KeyUsage>,
    public ICAPICOMError<CKeyUsage, &IID_IKeyUsage>,
    public IDispatchImpl<IKeyUsage, &IID_IKeyUsage, &LIBID_CAPICOM,
                         CAPICOM_MAJOR_VERSION, CAPICOM_MINOR_VERSION>
{
public:
    CKeyUsage()
    {
    }

DECLARE_NO_REGISTRY()

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CKeyUsage)
    COM_INTERFACE_ENTRY(IKeyUsage)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CKeyUsage)
END_CATEGORY_MAP()

    HRESULT FinalConstruct()
    {
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for KeyUsage object.\n", hr);
            return hr;
        }

        m_dwKeyUsages = 0;
        m_bIsPresent  = VARIANT_FALSE;
        m_bIsCritical = VARIANT_FALSE;

        return S_OK;
    }

//
// IKeyUsage
//
public:
    STDMETHOD(get_IsDecipherOnlyEnabled)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

    STDMETHOD(get_IsEncipherOnlyEnabled)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

    STDMETHOD(get_IsCRLSignEnabled)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

    STDMETHOD(get_IsKeyCertSignEnabled)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

    STDMETHOD(get_IsKeyAgreementEnabled)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

    STDMETHOD(get_IsDataEnciphermentEnabled)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

    STDMETHOD(get_IsKeyEnciphermentEnabled)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

    STDMETHOD(get_IsNonRepudiationEnabled)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

    STDMETHOD(get_IsDigitalSignatureEnabled)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

    STDMETHOD(get_IsCritical)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

    STDMETHOD(get_IsPresent)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

    //
    // None COM functions.
    //
    STDMETHOD(Init)
        (PCCERT_CONTEXT pCertContext);

private:
    CLock          m_Lock;
    DWORD          m_dwKeyUsages;
    VARIANT_BOOL   m_bIsPresent;
    VARIANT_BOOL   m_bIsCritical;
};
#endif //__KEYUSAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\keyusage.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    KeyUsage.cpp

  Content: Implementation of CKeyUsage.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "KeyUsage.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateKeyUsageObject

  Synopsis : Create a IKeyUsage object and populate the porperties with
             data from the key usage extension of the specified certificate.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT to be used
                                           to initialize the IKeyUsage object.

             IKeyUsage ** ppIKeyUsage    - Pointer to pointer IKeyUsage object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateKeyUsageObject (PCCERT_CONTEXT pCertContext, 
                              IKeyUsage   ** ppIKeyUsage)
{
    HRESULT hr = S_OK;
    CComObject<CKeyUsage> * pCKeyUsage = NULL;

    DebugTrace("Entering CreateKeyUsageObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(ppIKeyUsage);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CKeyUsage>::CreateInstance(&pCKeyUsage)))
        {
            DebugTrace("Error [%#x]: CComObject<CKeyUsage>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Init the object.
        //
        if (FAILED(hr = pCKeyUsage->Init(pCertContext)))
        {
            DebugTrace("Error [%#x]: pCKeyUsage->Init() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return IKeyUsage pointer to caller.
        //
        if (FAILED(hr = pCKeyUsage->QueryInterface(ppIKeyUsage)))
        {
            DebugTrace("Error [%#x]: pCKeyUsage->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }
    
CommonExit:

    DebugTrace("Leaving CreateKeyUsageObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    if (pCKeyUsage)
    {
        delete pCKeyUsage;
    }

    goto CommonExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// CKeyUsage
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CKeyUsage::get_IsPresent

  Synopsis : Check to see if the KeyUsage extension is present.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive result.

  Remark   :
  
------------------------------------------------------------------------------*/

STDMETHODIMP CKeyUsage::get_IsPresent (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CKeyUsage::get_IsPresent().\n");

    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
        *pVal = m_bIsPresent;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CKeyUsage::get_IsPresent().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CKeyUsage::get_IsCritical

  Synopsis : Check to see if the KeyUsage extension is marked critical.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CKeyUsage::get_IsCritical (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CKeyUsage::get_IsCritical().\n");

    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
        *pVal = m_bIsCritical;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CKeyUsage::get_IsCritical().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CKeyUsage::get_IsDigitalSignatureEnabled

  Synopsis : Check to see if Digital Signature bit is set in KeyUsage extension.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CKeyUsage::get_IsDigitalSignatureEnabled (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CKeyUsage::get_IsDigitalSignatureEnabled().\n");

    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
        *pVal = m_dwKeyUsages & CERT_DIGITAL_SIGNATURE_KEY_USAGE ? VARIANT_TRUE : VARIANT_FALSE;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CKeyUsage::get_IsDigitalSignatureEnabled().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CKeyUsage::get_IsNonRepudiationEnabled

  Synopsis : Check to see if Non Repudiation bit is set in KeyUsage extension.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CKeyUsage::get_IsNonRepudiationEnabled (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CKeyUsage::get_IsNonRepudiationEnabled().\n");

    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
        *pVal = m_dwKeyUsages & CERT_NON_REPUDIATION_KEY_USAGE ? VARIANT_TRUE : VARIANT_FALSE;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CKeyUsage::get_IsNonRepudiationEnabled().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CKeyUsage::get_IsKeyEnciphermentEnabled

  Synopsis : Check to see if Key Encipherment bit is set in KeyUsage extension.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CKeyUsage::get_IsKeyEnciphermentEnabled (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CKeyUsage::get_IsKeyEnciphermentEnabled().\n");

    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
        *pVal = m_dwKeyUsages & CERT_KEY_ENCIPHERMENT_KEY_USAGE ? VARIANT_TRUE : VARIANT_FALSE;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CKeyUsage::get_IsKeyEnciphermentEnabled().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CKeyUsage::get_IsDataEnciphermentEnabled

  Synopsis : Check to see if Data Encipherment bit is set in KeyUsage extension.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CKeyUsage::get_IsDataEnciphermentEnabled (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CKeyUsage::get_IsDataEnciphermentEnabled().\n");

    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
        *pVal = m_dwKeyUsages & CERT_DATA_ENCIPHERMENT_KEY_USAGE ? VARIANT_TRUE : VARIANT_FALSE;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CKeyUsage::get_IsDataEnciphermentEnabled().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CKeyUsage::get_IsKeyAgreementEnabled

  Synopsis : Check to see if Key Agreement bit is set in KeyUsage extension.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CKeyUsage::get_IsKeyAgreementEnabled (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CKeyUsage::get_IsKeyAgreementEnabled().\n");

    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
        *pVal = m_dwKeyUsages & CERT_KEY_AGREEMENT_KEY_USAGE ? VARIANT_TRUE : VARIANT_FALSE;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CKeyUsage::get_IsKeyAgreementEnabled().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CKeyUsage::get_IsKeyCertSignEnabled

  Synopsis : Check to see if Key Cert Sign bit is set in KeyUsage extension.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CKeyUsage::get_IsKeyCertSignEnabled (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CKeyUsage::get_IsKeyCertSignEnabled().\n");

    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
        *pVal = m_dwKeyUsages & CERT_KEY_CERT_SIGN_KEY_USAGE ? VARIANT_TRUE : VARIANT_FALSE;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CKeyUsage::get_IsKeyCertSignEnabled().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CKeyUsage::get_IsCRLSignEnabled

  Synopsis : Check to see if CRL Sign bit is set in KeyUsage extension.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CKeyUsage::get_IsCRLSignEnabled (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CKeyUsage::get_IsCRLSignEnabled().\n");

    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
        *pVal = m_dwKeyUsages & CERT_CRL_SIGN_KEY_USAGE ? VARIANT_TRUE : VARIANT_FALSE;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CKeyUsage::get_IsCRLSignEnabled().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CKeyUsage::get_IsEncipherOnlyEnabled

  Synopsis : Check to see if Encipher Only bit is set in KeyUsage extension.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CKeyUsage::get_IsEncipherOnlyEnabled (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CKeyUsage::get_IsEncipherOnlyEnabled().\n");

    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
        *pVal = m_dwKeyUsages & CERT_ENCIPHER_ONLY_KEY_USAGE ? VARIANT_TRUE : VARIANT_FALSE;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CKeyUsage::get_IsEncipherOnlyEnabled().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CKeyUsage::get_IsDecipherOnlyEnabled

  Synopsis : Check to see if Decipher Only bit is set in KeyUsage extension.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CKeyUsage::get_IsDecipherOnlyEnabled (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CKeyUsage::get_IsDecipherOnlyEnabled().\n");

    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
        *pVal = m_dwKeyUsages & CERT_DECIPHER_ONLY_KEY_USAGE ? VARIANT_TRUE : VARIANT_FALSE;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CKeyUsage::get_IsDecipherOnlyEnabled().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// Private methods.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CKeyUsage::Init

  Synopsis : Initialize the object.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT.

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us with CERT_CONTEXT.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CKeyUsage::Init (PCCERT_CONTEXT pCertContext)
{
    HRESULT            hr          = S_OK;
    DWORD              dwKeyUsages = 0;
    VARIANT_BOOL       bIsPresent  = VARIANT_FALSE;
    VARIANT_BOOL       bIsCritical = VARIANT_FALSE;

    DebugTrace("Entering CKeyUsage::Init().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);

    //
    // Check the key usage.
    //
    if (::CertGetIntendedKeyUsage(CAPICOM_ASN_ENCODING,
                                  pCertContext->pCertInfo,
                                  (BYTE *) &dwKeyUsages,
                                  sizeof(dwKeyUsages))) 
    {
        CERT_EXTENSION * pCertExtension;
        
        bIsPresent = VARIANT_TRUE;

        //
        // Find the extension to see if mark critical.
        //
        pCertExtension = ::CertFindExtension(szOID_KEY_USAGE ,
                                             pCertContext->pCertInfo->cExtension,
                                             pCertContext->pCertInfo->rgExtension);
        if (NULL != pCertExtension)
        {
            if (pCertExtension->fCritical)
            {
                bIsCritical = VARIANT_TRUE;
            }
        }
    }
    else
    {
        //
        // Could be extension not present or an error.
        //
        DWORD dwWinError = ::GetLastError();
        if (dwWinError)
        {
            hr = HRESULT_FROM_WIN32(dwWinError);

            DebugTrace("Error [%#x]: CertGetIntendedKeyUsage() failed.\n", hr);
            goto CommonExit;
        }
    }

    //
    // Update member variables.
    //
    m_bIsPresent = bIsPresent;
    m_bIsCritical = bIsCritical;
    m_dwKeyUsages = dwKeyUsages;

CommonExit:

    DebugTrace("Leaving CKeyUsage::Init().\n");

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\msghlpr.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000 - 2001.

  File:    MsgHlpr.h

  Content: Declaration of the messaging helper functions.

  History: 09-07-2001    dsie     created

------------------------------------------------------------------------------*/

#ifndef __MSGHLPR_H_
#define __MSGHLPR_H_

#include "Debug.h"

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : GetMsgParam

  Synopsis : Allocate memory and retrieve requested message parameter using 
             CryptGetMsgParam() API.

  Parameter: HCRYPTMSG hMsg  - Message handler.
             DWORD dwMsgType - Message param type to retrieve.
             DWORD dwIndex   - Index (should be 0 most of the time).
             void ** ppvData - Pointer to receive buffer.
             DWORD * pcbData - Size of buffer.

  Remark   :

------------------------------------------------------------------------------*/

HRESULT GetMsgParam (HCRYPTMSG hMsg,
                     DWORD     dwMsgType,
                     DWORD     dwIndex,
                     void   ** ppvData,
                     DWORD   * pcbData);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : FindSignerCertInMessage

  Synopsis : Find the signer's cert in the bag of certs of the message for the
             specified signer.

  Parameter: HCRYPTMSG hMsg                          - Message handle.
             CERT_NAME_BLOB * pIssuerNameBlob        - Pointer to issuer' name
                                                       blob of signer's cert.
             CRYPT_INTEGERT_BLOB * pSerialNumberBlob - Pointer to serial number
                                                       blob of signer's cert.
             PCERT_CONTEXT * ppCertContext           - Pointer to PCERT_CONTEXT
                                                       to receive the found 
                                                       cert, or NULL to only
                                                       know the result.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT FindSignerCertInMessage (HCRYPTMSG            hMsg, 
                                 CERT_NAME_BLOB     * pIssuerNameBlob,
                                 CRYPT_INTEGER_BLOB * pSerialNumberBlob,
                                 PCERT_CONTEXT      * ppCertContext);

#endif //__MSGHLPR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\lock.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File   : Lock.h

  Content: Implementation of CLock class.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#ifndef __LOCK_H_
#define __LOCK_H_

class CLock
{
public:
    CLock()
    {
        __try
        {
            ::InitializeCriticalSection(&m_CriticalSection);
            m_Initialized = S_OK;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            m_Initialized = HRESULT_FROM_WIN32(::GetExceptionCode());
        }
    }

    ~CLock()
    {
        if (SUCCEEDED(m_Initialized))
        {
            ::DeleteCriticalSection(&m_CriticalSection);
        }
    }

    HRESULT Initialized()
    {
        return m_Initialized;
    }

    void Lock()
    {
        if (SUCCEEDED(m_Initialized))
        {
            ::EnterCriticalSection(&m_CriticalSection);
        }
    }

    void Unlock()
    {
        if (SUCCEEDED(m_Initialized))
        {
            ::LeaveCriticalSection(&m_CriticalSection);
        }
    }

private:
    HRESULT          m_Initialized;
    CRITICAL_SECTION m_CriticalSection;
};

#endif //__LOCK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\noticenumbers.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:      NoticeNumbers.cpp

  Contents:  Implementation of CNoticeNumbers class for collection of 
             IExtension objects.

  Remarks:   This object is not creatable by user directly. It can only be
             created via property/method of other CAPICOM objects.

             The collection container is implemented usign STL::map of 
             STL::pair of BSTR and IExtension..

             See Chapter 9 of "BEGINNING ATL 3 COM Programming" for algorithm
             adopted in here.

  History:   06-15-2001    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "NoticeNumbers.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateNoticeNumbersObject

  Synopsis : Create an INoticeNumbers collection object, and load the object 
             with NoticeNumbers.

  Parameter: PCERT_POLICY_QUALIFIER_NOTICE_REFERENCE pNoticeReference

             INoticeNumbers ** ppINoticeNumbers - Pointer to pointer 
                                                  INoticeNumbers to recieve the 
                                                  interface pointer.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateNoticeNumbersObject (PCERT_POLICY_QUALIFIER_NOTICE_REFERENCE pNoticeReference,
                                   INoticeNumbers  ** ppINoticeNumbers)
{
    HRESULT hr = S_OK;
    CComObject<CNoticeNumbers> * pCNoticeNumbers = NULL;

    DebugTrace("Entering CreateNoticeNumbersObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pNoticeReference);
    ATLASSERT(ppINoticeNumbers);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CNoticeNumbers>::CreateInstance(&pCNoticeNumbers)))
        {
            DebugTrace("Error [%#x]: CComObject<CNoticeNumbers>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Init object with notice numbers.
        //
        if (FAILED(hr = pCNoticeNumbers->Init(pNoticeReference->cNoticeNumbers,
                                              pNoticeReference->rgNoticeNumbers)))
        {
            DebugTrace("Error [%#x]: pCNoticeNumbers->Init() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return interface pointer to caller.
        //
        if (FAILED(hr = pCNoticeNumbers->QueryInterface(ppINoticeNumbers)))
        {
            DebugTrace("Error [%#x]: pCNoticeNumbers->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreateNoticeNumbersObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (pCNoticeNumbers)
    {
        delete pCNoticeNumbers;
    }

    goto CommonExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// CNoticeNumbers
//

////////////////////////////////////////////////////////////////////////////////
//
// Non COM functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CNoticeNumbers::Init

  Synopsis : Load all extensions into the collection.

  Parameter: DWORD cNoticeNumbers - Number of extensions.
  
             int * rgNoticeNumbers - Array of extensions.

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CNoticeNumbers::Init (DWORD cNoticeNumbers,
                                   int * rgNoticeNumbers)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CNoticeNumbers::Init().\n");

    //
    // Add all to the collection.
    //
    for (DWORD i = 0; i < cNoticeNumbers; i++)
    {
        //
        // Now add object to collection vector.
        //
        // Note that the overloaded = operator for CComPtr will
        // automatically AddRef to the object. Also, when the CComPtr
        // is deleted (happens when the Remove or map destructor is called), 
        // the CComPtr destructor will automatically Release the object.
        //
        m_coll.push_back((long) rgNoticeNumbers[i]);
    }

    DebugTrace("Leaving CNoticeNumbers::Init().\n");

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\noticenumbers.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    NoticeNumbers.h

  Content: Declaration of CNoticeNumbers.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#ifndef __NOTICENUMBERS_H_
#define __NOTICENUMBERS_H_

#include "Resource.h"
#include "Error.h"
#include "Lock.h"
#include "Debug.h"
#include "CopyItem.h"

////////////////////
//
// Locals
//

//
// typdefs to make life easier.
//
typedef std::vector<long> NoticeNumbersContainer;
typedef CComEnumOnSTL<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _CopyVariant<long>, NoticeNumbersContainer> NoticeNumberEnum;
typedef ICollectionOnSTLImpl<INoticeNumbers, NoticeNumbersContainer, VARIANT, _CopyVariant<long>, NoticeNumberEnum> INoticeNumbersCollection;


////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateNoticeNumbersObject

  Synopsis : Create an INoticeNumbers collection object, and load the object with 
             NoticeNumbers from the specified location.

  Parameter: PCERT_POLICY_QUALIFIER_NOTICE_REFERENCE pNoticeReference

             INoticeNumbers ** ppINoticeNumbers - Pointer to pointer INoticeNumbers
                                            to recieve the interface pointer.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateNoticeNumbersObject (PCERT_POLICY_QUALIFIER_NOTICE_REFERENCE pNoticeReference,
                                   INoticeNumbers  ** ppINoticeNumbers);
                                
////////////////////////////////////////////////////////////////////////////////
//
// CNoticeNumbers
//
class ATL_NO_VTABLE CNoticeNumbers :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CNoticeNumbers, &CLSID_NoticeNumbers>,
    public ICAPICOMError<CNoticeNumbers, &IID_INoticeNumbers>,
    public IDispatchImpl<INoticeNumbersCollection, &IID_INoticeNumbers, &LIBID_CAPICOM,
                         CAPICOM_MAJOR_VERSION, CAPICOM_MINOR_VERSION>
{
public:
    CNoticeNumbers()
    {
    }

    HRESULT FinalConstruct()
    {
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for NoticeNumbers object.\n", hr);
            return hr;
        }

        return S_OK;
    }

DECLARE_NO_REGISTRY()

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CNoticeNumbers)
    COM_INTERFACE_ENTRY(INoticeNumbers)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CNoticeNumbers)
END_CATEGORY_MAP()

//
// INoticeNumbers
//
public:
    //
    // These are the only ones that we need to implemented, others will be
    // handled by ATL ICollectionOnSTLImpl.
    //

    //
    // None COM functions.
    //
    STDMETHOD(Init)
        (DWORD cNoticeNumbers,
         int * rgNoticeNumbers);

private:
    CLock m_Lock;
};

#endif //__NOTICENUMBERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\msghlpr.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000 - 2001.

  File:    MsgHlpr.cpp

  Content: Helper functions for messaging.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "MsgHlpr.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : GetMsgParam

  Synopsis : Allocate memory and retrieve requested message parameter using 
             CryptGetMsgParam() API.

  Parameter: HCRYPTMSG hMsg  - Message handler.
             DWORD dwMsgType - Message param type to retrieve.
             DWORD dwIndex   - Index (should be 0 most of the time).
             void ** ppvData - Pointer to receive buffer.
             DWORD * pcbData - Size of buffer.

  Remark   :

------------------------------------------------------------------------------*/

HRESULT GetMsgParam (HCRYPTMSG hMsg,
                     DWORD     dwMsgType,
                     DWORD     dwIndex,
                     void   ** ppvData,
                     DWORD   * pcbData)
{
    HRESULT hr     = S_OK;
    DWORD   cbData = 0;
    void *  pvData = NULL;

    DebugTrace("Entering GetMsgParam().\n");

    //
    // Sanity check.
    //
    ATLASSERT(ppvData);
    ATLASSERT(pcbData);
    
    //
    // Determine data buffer size.
    //
    if (!::CryptMsgGetParam(hMsg,
                            dwMsgType,
                            dwIndex,
                            NULL,
                            &cbData))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptMsgGetParam() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Allocate memory for buffer.
    //
    if (!(pvData = (void *) ::CoTaskMemAlloc(cbData)))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Error: out of memory.\n");
        goto ErrorExit;
    }

    //
    // Now get the data.
    //
    if (!::CryptMsgGetParam(hMsg,
                            dwMsgType,
                            dwIndex,
                            pvData,
                            &cbData))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptMsgGetParam() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Return msg param to caller.
    //
    *ppvData = pvData;
    *pcbData = cbData;

CommonExit:

    DebugTrace("Leaving GetMsgParam().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resources.
    //
    if (pvData)
    {
        ::CoTaskMemFree(pvData);
    }
    
    goto CommonExit;
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : FindSignerCertInMessage

  Synopsis : Find the signer's cert in the bag of certs of the message for the
             specified signer.

  Parameter: HCRYPTMSG hMsg                          - Message handle.
             CERT_NAME_BLOB * pIssuerNameBlob        - Pointer to issuer' name
                                                       blob of signer's cert.
             CRYPT_INTEGERT_BLOB * pSerialNumberBlob - Pointer to serial number
                                                       blob of signer's cert.
             PCERT_CONTEXT * ppCertContext           - Pointer to PCERT_CONTEXT
                                                       to receive the found 
                                                       cert, or NULL to only
                                                       know the result.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT FindSignerCertInMessage (HCRYPTMSG            hMsg, 
                                 CERT_NAME_BLOB     * pIssuerNameBlob,
                                 CRYPT_INTEGER_BLOB * pSerialNumberBlob,
                                 PCERT_CONTEXT      * ppCertContext)
{
    HRESULT hr = S_OK;
    DWORD dwCertCount = 0;
    DWORD cbCertCount = sizeof(dwCertCount);

    DebugTrace("Entering FindSignerCertInMessage().\n");

    //
    // Sanity check.
    //
    ATLASSERT(NULL != hMsg);
    ATLASSERT(NULL != pIssuerNameBlob);
    ATLASSERT(NULL != pSerialNumberBlob);
    ATLASSERT(0 < pIssuerNameBlob->cbData);
    ATLASSERT(NULL != pIssuerNameBlob->pbData);
    ATLASSERT(0 < pSerialNumberBlob->cbData);
    ATLASSERT(NULL != pSerialNumberBlob->pbData);

    //
    // Get count of certs in message.
    //
    if (!::CryptMsgGetParam(hMsg,
                            CMSG_CERT_COUNT_PARAM,
                            0,
                            &dwCertCount,
                            &cbCertCount))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptMsgGetParam() failed.\n", hr);
        return hr;
    }

    //
    // See if the signer's cert is in the bag of certs.
    //
    while (dwCertCount--)
    {
        PCCERT_CONTEXT pCertContext = NULL;
        CRYPT_DATA_BLOB EncodedCertBlob = {0, NULL};

        //
        // Get a cert from the bag of certs.
        //
        hr = ::GetMsgParam(hMsg, 
                           CMSG_CERT_PARAM,
                           dwCertCount,
                           (void **) &EncodedCertBlob.pbData,
                           &EncodedCertBlob.cbData);
        if (FAILED(hr))
        {
            DebugTrace("Error [%#x]: GetMsgParam() failed.\n", hr);
            return hr;
        }

        //
        // Create a context for the cert.
        //
        pCertContext = ::CertCreateCertificateContext(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                                      (const BYTE *) EncodedCertBlob.pbData,
                                                      EncodedCertBlob.cbData);

        //
        // Free encoded cert blob memory before checking result.
        //
        ::CoTaskMemFree((LPVOID) EncodedCertBlob.pbData);
 
        if (NULL == pCertContext)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertCreateCertificateContext() failed.\n", hr);
            return hr;
        }

        //
        // Compare.
        //
        if (::CertCompareCertificateName(CAPICOM_ASN_ENCODING,
                                         pIssuerNameBlob,
                                         &pCertContext->pCertInfo->Issuer) &&
            ::CertCompareIntegerBlob(pSerialNumberBlob,
                                     &pCertContext->pCertInfo->SerialNumber))
        {
            if (NULL != ppCertContext)
            {
                *ppCertContext = (PCERT_CONTEXT) pCertContext;
            }
            else
            {
                ::CertFreeCertificateContext(pCertContext);
            }
        
            return S_OK;
        }
        else
        {
            //
            // No, keep looking.
            //
            ::CertFreeCertificateContext(pCertContext);
        }
    }

    //
    // If we get here, that means we never found the cert.
    //
    return CAPICOM_E_SIGNER_NOT_FOUND;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\oid.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows

  Copyright (C) Microsoft Corporation, 1995 - 1999.

  File:    OID.h

  Content: Declaration of COID.

  History: 06-15-2001    dsie     created

------------------------------------------------------------------------------*/

#ifndef __OID_H_
#define __OID_H_

#include "Resource.h"
#include "Error.h"
#include "Lock.h"
#include "Debug.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateOIDObject

  Synopsis : Create and initialize an COID object.

  Parameter: LPTSTR * pszOID - Pointer to OID string.

             BOOL bReadOnly - TRUE for Read only, else FALSE.
  
             IOID ** ppIOID - Pointer to pointer IOID object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateOIDObject (LPSTR pszOID, BOOL bReadOnly, IOID ** ppIOID);


////////////////////////////////////////////////////////////////////////////////
//
// COID
//
class ATL_NO_VTABLE COID : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<COID, &CLSID_OID>,
    public ICAPICOMError<COID, &IID_IOID>,
    public IDispatchImpl<IOID, &IID_IOID, &LIBID_CAPICOM,
                         CAPICOM_MAJOR_VERSION, CAPICOM_MINOR_VERSION>,
    public IObjectSafetyImpl<COID, INTERFACESAFE_FOR_UNTRUSTED_CALLER | 
                                   INTERFACESAFE_FOR_UNTRUSTED_DATA>
{
public:
    COID()
    {
    }

DECLARE_REGISTRY_RESOURCEID(IDR_OID)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(COID)
    COM_INTERFACE_ENTRY(IOID)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_CATEGORY_MAP(COID)
    IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
    IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
END_CATEGORY_MAP()

    HRESULT FinalConstruct()
    {
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for OID object.\n", hr);
            return hr;
        }

        m_Name = CAPICOM_OID_OTHER;
        m_bReadOnly = FALSE;
        m_bstrFriendlyName.Empty();
        m_bstrOID.Empty();
        return S_OK;
    }

//
// IOID
//
public:

    STDMETHOD(get_Name)
        (/*[out, retval]*/ CAPICOM_OID * pVal);

    STDMETHOD(put_Name)
        (/*[out, retval]*/ CAPICOM_OID newVal);
    
    STDMETHOD(get_FriendlyName)
        (/*[out, retval]*/ BSTR * pVal);

    STDMETHOD(put_FriendlyName)
        (/*[out, retval]*/ BSTR newVal);
    
    STDMETHOD(get_Value)
        (/*[out, retval]*/ BSTR * pVal);

    STDMETHOD(put_Value)
        (/*[out, retval]*/ BSTR newVal);

    //
    // C++ member function needed to initialize the object.
    //
    STDMETHOD(Init)
        (LPSTR pszOID, BOOL bReadOnly);

private:
    CLock       m_Lock;
    BOOL        m_bReadOnly;
    CAPICOM_OID m_Name;
    CComBSTR    m_bstrFriendlyName;
    CComBSTR    m_bstrOID;
};

#endif //__OID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\oids.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000.

  File:    OIDs.cpp

  Content: Implementation of COIDs.

  History: 06-15-2001    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "OIDs.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateOIDsObject

  Synopsis : Create and initialize an IOIDs collection object.

  Parameter: PCERT_ENHKEY_USAGE pUsages - Pointer to CERT_ENHKEY_USAGE used to
                                          initialize the OIDs collection.
  
             BOOL bCertPolicies - TRUE for certificate policies, else
                                  application policies is assumed.

             IOIDs ** ppIOIDs - Pointer to pointer to IOIDs to receive the 
                                interface pointer.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateOIDsObject (PCERT_ENHKEY_USAGE pUsages, 
                          BOOL bCertPolicies,
                          IOIDs ** ppIOIDs)
{
    HRESULT hr = S_OK;
    CComObject<COIDs> * pCOIDs = NULL;

    DebugTrace("Entering CreateOIDsObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(ppIOIDs);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<COIDs>::CreateInstance(&pCOIDs)))
        {
            DebugTrace("Error [%#x]: CComObject<COIDs>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize object.
        //
        if (FAILED(hr = pCOIDs->Init(pUsages, bCertPolicies)))
        {
            DebugTrace("Error [%#x]: pCOIDs->Init() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return IOIDs pointer to caller.
        //
        if (FAILED(hr = pCOIDs->QueryInterface(ppIOIDs)))
        {
            DebugTrace("Error [%#x]: pCOIDs->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreateOIDsObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (pCOIDs)
    {
        delete pCOIDs;
    }

    goto CommonExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// COIDs
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : COIDs::get_Item

  Synopsis : Return item in the collection.

  Parameter: VARIANT Index - Numeric index or string OID.
   
             VARIANT * pVal - Pointer to VARIANT to receive the IDispatch.

  Remark   :
             
------------------------------------------------------------------------------*/

STDMETHODIMP COIDs::get_Item (VARIANT Index, VARIANT * pVal)
{
    HRESULT  hr = S_OK;
    CComPtr<IOID> pIOID = NULL;

    DebugTrace("Entering COIDs::get_Item().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Intialize.
        //
        ::VariantInit(pVal);

        //
        // Numeric or string?
        //
        if (VT_BSTR == V_VT(&Index))
        {
            //
            // Index by OID string.
            //
            OIDMap::iterator it;

            //
            // Find the item with this OID.
            //
            it = m_coll.find(Index.bstrVal);

            if (it == m_coll.end())
            {
                DebugTrace("Info: OID (%ls) not found in the collection.\n", Index.bstrVal);
                goto CommonExit;
            }

            //
            // Point to found item.
            //
            pIOID = (*it).second;

            //
            // Return to caller.
            //
            pVal->vt = VT_DISPATCH;
            if (FAILED(hr = pIOID->QueryInterface(IID_IDispatch, (void **) &(pVal->pdispVal))))
            {
                DebugTrace("Error [%#x]: pIOID->QueryInterface() failed.\n", hr);
                goto ErrorExit;
            }
        }
        else
        {
            //
            // Coerce to integer.
            //
            if (FAILED(hr = ::VariantChangeType(&Index, &Index, 0, VT_I4)))
            {
                DebugTrace("Error [%#x]: VariantChangeType() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Use the base class implemented by ATL.
            //
            if (FAILED(hr = IOIDsCollection::get_Item(Index.lVal, pVal)))
            {
                DebugTrace("Error [%#x]: IOIDsCollection::get_Item() failed.\n", hr);
                goto ErrorExit;
            }
        }
    }

    catch(...)
    {
        hr = CAPICOM_E_INTERNAL;

        DebugTrace("Exception: internal error.\n");
        goto ErrorExit;
    }

CommonExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving COIDs::get_Item().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : COIDs::Add

  Synopsis : Add an OID to the collection.

  Parameter: IOID * pVal - OID to be added.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP COIDs::Add (IOID * pVal)
{
    HRESULT  hr = S_OK;
    CComBSTR bstrIndex;
    CComPtr<IOID> pIOID = NULL;

    DebugTrace("Entering COIDs::Add().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure we have a valid OID.
        //
        if (FAILED(hr = pVal->QueryInterface(__uuidof(IOID), (void **) &pIOID.p)))
        {
            hr = E_NOINTERFACE;

            DebugTrace("Error [%#x]: pVal is not an OID object.\n", hr);
            goto ErrorExit;
        }

        //
        // Get OID string.
        //
        if (FAILED(hr = pIOID->get_Value(&bstrIndex.m_str)))
        {
            DebugTrace("Error [%#x]: pIOID->get_Value() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Now add object to collection map.
        //
        // Note that the overloaded = operator for CComPtr will
        // automatically AddRef to the object. Also, when the CComPtr
        // is deleted (happens when the Remove or map destructor is called), 
        // the CComPtr destructor will automatically Release the object.
        //
        m_coll[bstrIndex] = pIOID;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving COIDs::Add().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : COIDs::Remove

  Synopsis : Remove a OID from the collection.

  Parameter: VARIANT Index - OID string or index (1-based).

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP COIDs::Remove (VARIANT Index)
{
    HRESULT hr = S_OK;
    OIDMap::iterator it;

    DebugTrace("Entering COIDs::Remove().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Numeric or string?
        //
        if (VT_BSTR == V_VT(&Index))
        {
            //
            // Find the item with this OID.
            //
            it = m_coll.find(Index.bstrVal);

            if (it == m_coll.end())
            {
                //
                // Not found.
                //
                hr = E_INVALIDARG;

                DebugTrace("Error [%#x]: OID (%ls) not found in the collection.\n", hr, Index.bstrVal);
                goto ErrorExit;
            }
        }
        else
        {
            DWORD iIndex = 0;

            //
            // Coerce to integer.
            //
            if (FAILED(hr = ::VariantChangeType(&Index, &Index, 0, VT_I4)))
            {
                DebugTrace("Error [%#x]: VariantChangeType() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Force to 1 based.
            //
            iIndex = V_I4(&Index) < 0 ? 1 : (DWORD) V_I4(&Index);

            //
            // Make sure parameter is valid.
            //
            if (iIndex > m_coll.size())
            {
                hr = E_INVALIDARG;

                DebugTrace("Error [%#x]: Index %d is out of range.\n", hr, iIndex);
                goto ErrorExit;
            }

            //
            // Find object in map.
            //
            iIndex--;
            it = m_coll.begin(); 
        
            while (it != m_coll.end() && iIndex > 0)
            {
                it++; 
                iIndex--;
            }
        }

        //
        // This should not happen.
        //
        if (it == m_coll.end())
        {
            hr = CAPICOM_E_INTERNAL;

            DebugTrace("Unexpected internal error [%#x]: iterator went pass end of map.\n", hr);
            goto ErrorExit;
        }

        //
        // Now remove object in map.
        //
        m_coll.erase(it);
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving COIDs::Remove().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : COIDs::Clear

  Synopsis : Remove all OIDs from the collection.

  Parameter: None.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP COIDs::Clear (void)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering COIDs::Clear().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Clear it.
        //
        m_coll.clear();
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving COIDs::Clear().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// Private methods.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : COIDs::Init

  Synopsis : Initialize the object.

  Parameter: PCERT_ENHKEY_USAGE pUsages - Pointer to CERT_ENHKEY_USAGE used to
                                          initialize the OIDs collection.

             BOOL bCertPolicies - TRUE for certificate policies, else
                                  application policies is assumed.

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP COIDs::Init (PCERT_ENHKEY_USAGE pUsages, BOOL bCertPolicies)
{
    HRESULT  hr = S_OK;
    CComBSTR bstrOid;

    DebugTrace("Entering COIDs::Init().\n");

    try
    {
        //
        // pUsages can be NULL.
        //
        if (pUsages)
        {
            //
            // Make sure we have room to add.
            //
            if ((m_coll.size() + pUsages->cUsageIdentifier) > m_coll.max_size())
            {
                hr = CAPICOM_E_OUT_OF_RESOURCE;

                DebugTrace("Error [%#x]: Maximum entries (%#x) reached for OIDs collection.\n", 
                            hr, pUsages->cUsageIdentifier);
                goto ErrorExit;
            }

            //
            // Add all OIDs to collection.
            //
            for (DWORD i = 0; i < pUsages->cUsageIdentifier; i++)
            {
                CComPtr<IOID> pIOID = NULL;

                //
                // Create the OID object.
                //
                if (FAILED(hr = ::CreateOIDObject(pUsages->rgpszUsageIdentifier[i], TRUE, &pIOID)))
                {
                    DebugTrace("Error [%#x]: CreateOIDObject() failed.\n", hr);
                    goto ErrorExit;
                }

                //
                // BSTR index of OID.
                //
                if (!(bstrOid = pUsages->rgpszUsageIdentifier[i]))
                {
                    hr = E_OUTOFMEMORY;

                    DebugTrace("Error [%#x]: bstrOid = pUsages->rgpszUsageIdentifier[i] failed.\n", hr);
                    goto ErrorExit;
                }

                //
                // Now add object to collection map.
                //
                // Note that the overloaded = operator for CComPtr will
                // automatically AddRef to the object. Also, when the CComPtr
                // is deleted (happens when the Remove or map destructor is called), 
                // the CComPtr destructor will automatically Release the object.
                //
                m_coll[bstrOid] = pIOID;
             }
        }
        else
        {
            //
            // No usage, meaning good for all.
            //
            CComPtr<IOID> pIOID  = NULL;
            LPSTR         pszOid = bCertPolicies ? szOID_ANY_CERT_POLICY : szOID_ANY_APPLICATION_POLICY;

            if (FAILED(hr = ::CreateOIDObject(pszOid, TRUE, &pIOID)))
            {
                DebugTrace("Error [%#x]: CreateOIDObject() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // BSTR index of OID.
            //
            if (!(bstrOid = pszOid))
            {
                hr = E_OUTOFMEMORY;

                DebugTrace("Error [%#x]: bstrOid = pszOid failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Now add object to collection map.
            //
            // Note that the overloaded = operator for CComPtr will
            // automatically AddRef to the object. Also, when the CComPtr
            // is deleted (happens when the Remove or map destructor is called), 
            // the CComPtr destructor will automatically Release the object.
            //
            m_coll[bstrOid] = pIOID;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving COIDs::Init().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\oid.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    OID.cpp

  Content: Implementation of COID.

  History: 06-15-2001    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "OID.h"

// 
// OID name mapping structure/array.
//
typedef struct _tagOIDMapping
{
    CAPICOM_OID     oidName;
    LPSTR           pszObjectId;
} OID_MAPPING, POID_MAPPING;

static OID_MAPPING g_OidMappingArray[] =
{
    // id-ce (Certificate/CRL Extensions)
    {CAPICOM_OID_AUTHORITY_KEY_IDENTIFIER_EXTENSION,        szOID_AUTHORITY_KEY_IDENTIFIER},
    {CAPICOM_OID_KEY_ATTRIBUTES_EXTENSION,                  szOID_KEY_ATTRIBUTES},
    {CAPICOM_OID_CERT_POLICIES_95_EXTENSION,                szOID_CERT_POLICIES_95},
    {CAPICOM_OID_KEY_USAGE_RESTRICTION_EXTENSION,           szOID_KEY_USAGE_RESTRICTION},
    {CAPICOM_OID_LEGACY_POLICY_MAPPINGS_EXTENSION,          szOID_LEGACY_POLICY_MAPPINGS},
    {CAPICOM_OID_SUBJECT_ALT_NAME_EXTENSION,                szOID_SUBJECT_ALT_NAME},
    {CAPICOM_OID_ISSUER_ALT_NAME_EXTENSION,                 szOID_ISSUER_ALT_NAME},
    {CAPICOM_OID_BASIC_CONSTRAINTS_EXTENSION,               szOID_BASIC_CONSTRAINTS},
    {CAPICOM_OID_SUBJECT_KEY_IDENTIFIER_EXTENSION,          szOID_SUBJECT_KEY_IDENTIFIER},
    {CAPICOM_OID_KEY_USAGE_EXTENSION,                       szOID_KEY_USAGE},
    {CAPICOM_OID_PRIVATEKEY_USAGE_PERIOD_EXTENSION,         szOID_PRIVATEKEY_USAGE_PERIOD},
    {CAPICOM_OID_SUBJECT_ALT_NAME2_EXTENSION,               szOID_SUBJECT_ALT_NAME2},
    {CAPICOM_OID_ISSUER_ALT_NAME2_EXTENSION,                szOID_ISSUER_ALT_NAME2},
    {CAPICOM_OID_BASIC_CONSTRAINTS2_EXTENSION,              szOID_BASIC_CONSTRAINTS2},
    {CAPICOM_OID_NAME_CONSTRAINTS_EXTENSION,                szOID_NAME_CONSTRAINTS},
    {CAPICOM_OID_CRL_DIST_POINTS_EXTENSION,                 szOID_CRL_DIST_POINTS},
    {CAPICOM_OID_CERT_POLICIES_EXTENSION,                   szOID_CERT_POLICIES},
    {CAPICOM_OID_POLICY_MAPPINGS_EXTENSION,                 szOID_POLICY_MAPPINGS},
    {CAPICOM_OID_AUTHORITY_KEY_IDENTIFIER2_EXTENSION,       szOID_AUTHORITY_KEY_IDENTIFIER2},
    {CAPICOM_OID_POLICY_CONSTRAINTS_EXTENSION,              szOID_POLICY_CONSTRAINTS},
    {CAPICOM_OID_ENHANCED_KEY_USAGE_EXTENSION,              szOID_ENHANCED_KEY_USAGE},
    {CAPICOM_OID_CERTIFICATE_TEMPLATE_EXTENSION,            szOID_CERTIFICATE_TEMPLATE},
    {CAPICOM_OID_APPLICATION_CERT_POLICIES_EXTENSION,       szOID_APPLICATION_CERT_POLICIES},
    {CAPICOM_OID_APPLICATION_POLICY_MAPPINGS_EXTENSION,     szOID_APPLICATION_POLICY_MAPPINGS},
    {CAPICOM_OID_APPLICATION_POLICY_CONSTRAINTS_EXTENSION,  szOID_APPLICATION_POLICY_CONSTRAINTS},

    // id-pe
    {CAPICOM_OID_AUTHORITY_INFO_ACCESS_EXTENSION,           szOID_AUTHORITY_INFO_ACCESS},
 
    // Application Policy (eku)
    {CAPICOM_OID_SERVER_AUTH_EKU,                           szOID_PKIX_KP_SERVER_AUTH},
    {CAPICOM_OID_CLIENT_AUTH_EKU,                           szOID_PKIX_KP_CLIENT_AUTH},
    {CAPICOM_OID_CODE_SIGNING_EKU,                          szOID_PKIX_KP_CODE_SIGNING},
    {CAPICOM_OID_EMAIL_PROTECTION_EKU,                      szOID_PKIX_KP_EMAIL_PROTECTION},
    {CAPICOM_OID_IPSEC_END_SYSTEM_EKU,                      szOID_PKIX_KP_IPSEC_END_SYSTEM},
    {CAPICOM_OID_IPSEC_TUNNEL_EKU,                          szOID_PKIX_KP_IPSEC_TUNNEL},
    {CAPICOM_OID_IPSEC_USER_EKU,                            szOID_PKIX_KP_IPSEC_USER},
    {CAPICOM_OID_TIME_STAMPING_EKU,                         szOID_PKIX_KP_TIMESTAMP_SIGNING},
    {CAPICOM_OID_CTL_USAGE_SIGNING_EKU,                     szOID_KP_CTL_USAGE_SIGNING},
    {CAPICOM_OID_TIME_STAMP_SIGNING_EKU,                    szOID_KP_TIME_STAMP_SIGNING},
    {CAPICOM_OID_SERVER_GATED_CRYPTO_EKU,                   szOID_SERVER_GATED_CRYPTO},
    {CAPICOM_OID_ENCRYPTING_FILE_SYSTEM_EKU,                szOID_KP_EFS},
    {CAPICOM_OID_EFS_RECOVERY_EKU,                          szOID_EFS_RECOVERY},
    {CAPICOM_OID_WHQL_CRYPTO_EKU,                           szOID_WHQL_CRYPTO},
    {CAPICOM_OID_NT5_CRYPTO_EKU,                            szOID_NT5_CRYPTO},
    {CAPICOM_OID_OEM_WHQL_CRYPTO_EKU,                       szOID_OEM_WHQL_CRYPTO},
    {CAPICOM_OID_EMBEDED_NT_CRYPTO_EKU,                     szOID_EMBEDDED_NT_CRYPTO},
    {CAPICOM_OID_ROOT_LIST_SIGNER_EKU,                      szOID_ROOT_LIST_SIGNER},
    {CAPICOM_OID_QUALIFIED_SUBORDINATION_EKU,               szOID_KP_QUALIFIED_SUBORDINATION},
    {CAPICOM_OID_KEY_RECOVERY_EKU,                          szOID_KP_KEY_RECOVERY},
    {CAPICOM_OID_DIGITAL_RIGHTS_EKU,                        szOID_DRM},
    {CAPICOM_OID_LICENSES_EKU,                              szOID_LICENSES},
    {CAPICOM_OID_LICENSE_SERVER_EKU,                        szOID_LICENSE_SERVER},
    {CAPICOM_OID_SMART_CARD_LOGON_EKU,                      szOID_KP_SMARTCARD_LOGON},
                                                            
    // Policy Qualifier                                     
    {CAPICOM_OID_PKIX_POLICY_QUALIFIER_CPS,                 szOID_PKIX_POLICY_QUALIFIER_CPS},
    {CAPICOM_OID_PKIX_POLICY_QUALIFIER_USERNOTICE,          szOID_PKIX_POLICY_QUALIFIER_USERNOTICE},
};

#define g_dwOidMappingEntries  ((DWORD) (ARRAYSIZE(g_OidMappingArray)))


////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateOIDObject

  Synopsis : Create and initialize an COID object.

  Parameter: LPTSTR * pszOID - Pointer to OID string.

             BOOL bReadOnly - TRUE for Read only, else FALSE.
  
             IOID ** ppIOID - Pointer to pointer IOID object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateOIDObject (LPSTR pszOID, BOOL bReadOnly, IOID ** ppIOID)
{
    HRESULT            hr    = S_OK;
    CComObject<COID> * pCOID = NULL;

    DebugTrace("Entering CreateOIDObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(ppIOID);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<COID>::CreateInstance(&pCOID)))
        {
            DebugTrace("Error [%#x]: CComObject<COID>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize object.
        //
        if (FAILED(hr = pCOID->Init(pszOID, bReadOnly)))
        {
            DebugTrace("Error [%#x]: pCOID->Init() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return interface pointer to caller.
        //
        if (FAILED(hr = pCOID->QueryInterface(ppIOID)))
        {
            DebugTrace("Error [%#x]: pCOID->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreateOIDObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    if (pCOID)
    {
        delete pCOID;
    }

    goto CommonExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// COID
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : COID::get_Name

  Synopsis : Return the enum name of the OID.

  Parameter: CAPICOM_OID * pVal - Pointer to CAPICOM_OID to receive result.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP COID::get_Name (CAPICOM_OID * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering COID::get_Name().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
        *pVal = m_Name;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving COID::get_Name().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : COID::put_Name

  Synopsis : Set OID enum name.

  Parameter: CAPICOM_OID newVal - OID enum name.
  
  Remark   : The corresponding OID value will be set for all except OID_OTHER,
             in which case the user must make another explicit call to 
             put_Value to set it.

------------------------------------------------------------------------------*/

STDMETHODIMP COID::put_Name (CAPICOM_OID newVal)
{
    HRESULT hr     = S_OK;
    LPSTR   pszOID = NULL;

    DebugTrace("Entering COID::put_Name().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure it is not read only.
        //
        if (m_bReadOnly)
        {
            hr = CAPICOM_E_NOT_ALLOWED;

            DebugTrace("Error [%#x]: Writing read-only OID object is not allowed.\n", hr);
            goto ErrorExit;
        }

        //
        // Find OID string value.
        //
        for (DWORD i = 0; i < g_dwOidMappingEntries; i++)
        {
            if (g_OidMappingArray[i].oidName == newVal)
            {
                pszOID = g_OidMappingArray[i].pszObjectId;
                break;
            }
        }

        //
        // Reset.
        //
        if (FAILED(hr = Init(pszOID, FALSE)))
        {
            DebugTrace("Error [%#x]: COID::init() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving COID::put_Name().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : COID::get_FriendlyName

  Synopsis : Return the freindly name of the OID.

  Parameter: BSTR * pVal - Pointer to BSTR to receive value.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP COID::get_FriendlyName (BSTR * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering COID::get_FriendlyName().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
        if (FAILED(hr = m_bstrFriendlyName.CopyTo(pVal)))
        {
            DebugTrace("Error [%#x]: m_bstrFriendlyName.CopyTo() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving COID::get_FriendlyName().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : COID::put_FriendlyName

  Synopsis : Set friendly name.

  Parameter: BSTR newVal - OID string.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP COID::put_FriendlyName (BSTR newVal)
{
    HRESULT          hr       = S_OK;
    PCCRYPT_OID_INFO pOidInfo = NULL;

    DebugTrace("Entering COID::put_FriendlyName().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure it is not read only.
        //
        if (m_bReadOnly)
        {
            hr = CAPICOM_E_NOT_ALLOWED;

            DebugTrace("Error [%#x]: Write read-only OID object is not allowed.\n", hr);
            goto ErrorExit;
        }

        //
        // Find OID and reset, if possible.
        //
        if (newVal)
        {
            if (pOidInfo = ::CryptFindOIDInfo(CRYPT_OID_INFO_NAME_KEY,
                                              (LPWSTR) newVal,
                                              0))
            {
                //
                // Reset.
                //
                if (FAILED(hr = Init((LPSTR) pOidInfo->pszOID, FALSE)))
                {
                    DebugTrace("Error [%#x]: COID::init() failed.\n", hr);
                    goto ErrorExit;
                }
            }
            else if (!(m_bstrFriendlyName = newVal))
            {
                hr = E_OUTOFMEMORY;

                DebugTrace("Error [%#x]: m_bstrFriendlyName = newVal failed.\n", hr);
                goto ErrorExit;
            }
        }
        else
        {
            m_bstrFriendlyName.Empty();
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving COID::put_FriendlyName().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : COID::get_Value

  Synopsis : Return the actual string of the OID.

  Parameter: BSTR * pVal - Pointer to BSTR to receive value.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP COID::get_Value (BSTR * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering COID::get_Value().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
        if (FAILED(hr = m_bstrOID.CopyTo(pVal)))
        {
            DebugTrace("Error [%#x]: m_bstrOID.CopyTo() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving COID::get_Value().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : COID::put_Value

  Synopsis : Set OID actual OID string value.

  Parameter: BSTR newVal - OID string.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP COID::put_Value (BSTR newVal)
{
    USES_CONVERSION;

    HRESULT hr = S_OK;
    LPSTR   pszOid = NULL;

    DebugTrace("Entering COID::put_Value().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure it is not read only.
        //
        if (m_bReadOnly)
        {
            hr = CAPICOM_E_NOT_ALLOWED;

            DebugTrace("Error [%#x]: Writing read-only OID object is not allowed.\n", hr);
            goto ErrorExit;
        }

        //
        // Check parameters.
        //
        if (NULL == newVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter newVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Convert to multibytes.
        //
        if (NULL == (pszOid = W2A(newVal)))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error: out of memory.\n");
            goto ErrorExit;
        }

        //
        // Reset.
        //
        if (FAILED(hr = Init(pszOid, FALSE)))
        {
            DebugTrace("Error [%#x]: COID::init() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving COID::put_Value().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// Private methods.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : COID::Init

  Synopsis : Initialize the object.

  Parameter: LPSTR pszOID - OID string.

             BOOL bReadOnly - TRUE for Read only, else FALSE.

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP COID::Init (LPSTR pszOID, BOOL bReadOnly)
{
    HRESULT          hr       = S_OK;
    CAPICOM_OID      oidName  = CAPICOM_OID_OTHER;
    PCCRYPT_OID_INFO pOidInfo = NULL;

    DebugTrace("Entering COID::Init().\n");

    if (pszOID)
    {
        //
        // Find enum name.
        //
        for (DWORD i = 0; i < g_dwOidMappingEntries; i++)
        {
            if (0 == ::strcmp(pszOID, g_OidMappingArray[i].pszObjectId))
            {
                oidName = g_OidMappingArray[i].oidName;
                break;
            }
        }

        if (!(m_bstrOID = pszOID))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error [%#x]: m_bstrOID = pszOID failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Set OID friendly name.
        //
        if (pOidInfo = ::CryptFindOIDInfo(CRYPT_OID_INFO_OID_KEY, pszOID, 0))
        {
            m_bstrFriendlyName = pOidInfo->pwszName;

            DebugTrace("Info: OID = %ls (%s).\n", pOidInfo->pwszName, pszOID);
        }
        else
        {
            DebugTrace("Info: Can't find friendly name for OID (%s).\n", pszOID);
        }
    }

    m_Name = oidName;
    m_bReadOnly = bReadOnly;

CommonExit:

    DebugTrace("Leaving COID::Init().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resources.
    //
    m_bstrOID.Empty();
    m_bstrFriendlyName.Empty();

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\pfxhlpr.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    PFXHlpr.cpp

  Content: PFX helper routines.

  History: 09-15-2001    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "PFXHlpr.h"
#include "Common.h"

////////////////////////////////////////////////////////////////////////////////
//
// Local functions.
//
       
////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : PFXExportStore

  Synopsis : Export cert store to PFX blob.

  Parameter: HCERTSTORE hCertStore - Store handle.
                                                            
             LPWSTR pwszPassword - Password to encrypt the PFX file.

             DWPRD dwFlags - PFX export flags.

             DATA_BLOB * pPFXBlob - Pointer to DATA_BLOB to receive PFX blob.

  Remark   :

------------------------------------------------------------------------------*/

HRESULT PFXExportStore (HCERTSTORE  hCertStore,
                        LPWSTR      pwszPassword,
                        DWORD       dwFlags,
                        DATA_BLOB * pPFXBlob)
{
    HRESULT   hr       = S_OK;
    DATA_BLOB DataBlob = {0, NULL};

    DebugTrace("Entering PFXExportStore().\n");

    //
    // Sanity check.
    //
    ATLASSERT(hCertStore);
    ATLASSERT(pPFXBlob);

    //
    // Export to blob.
    //
    if (!::PFXExportCertStoreEx(hCertStore,
                                &DataBlob,
                                pwszPassword,
                                NULL,
                                dwFlags))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: PFXExportCertStoreEx() failed.\n", hr);
        goto ErrorExit;
    }

    if (!(DataBlob.pbData = (LPBYTE) ::CoTaskMemAlloc(DataBlob.cbData)))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Error: out of memory.\n");
        goto ErrorExit;
    }

    if (!::PFXExportCertStoreEx(hCertStore,
                                &DataBlob,
                                pwszPassword,
                                NULL,
                                dwFlags))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: PFXExportCertStoreEx() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Return the blob to caller.
    //
    *pPFXBlob = DataBlob;

CommonExit:

    DebugTrace("Leaving PFXExportStore().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Remap private key not exportable errors to a common error code.
    //
    if (HRESULT_FROM_WIN32(NTE_BAD_KEY) == hr || 
        HRESULT_FROM_WIN32(NTE_BAD_KEY_STATE) == hr ||
        HRESULT_FROM_WIN32(NTE_BAD_TYPE) == hr)
    {
        DebugTrace("Info: Win32 error %#x is remapped to %#x.\n", 
                    hr, CAPICOM_E_PRIVATE_KEY_NOT_EXPORTABLE);

        hr = CAPICOM_E_PRIVATE_KEY_NOT_EXPORTABLE;

    }

    //
    // Free resources.
    //
    if (DataBlob.pbData)
    {
        ::CoTaskMemFree((LPVOID) DataBlob.pbData);
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : PFXSaveStore

  Synopsis : Save a PFX file and return all the certs in a HCERTSTORE.

  Parameter: HCERTSTORE hCertStore - Store handle.
  
             LPWSTR pwszFileName - PFX filename.
                                                          
             LPWSTR pwszPassword - Password to encrypt the PFX file.

             DWPRD dwFlags - PFX export flags.

  Remark   :

------------------------------------------------------------------------------*/

HRESULT PFXSaveStore (HCERTSTORE hCertStore,
                      LPWSTR     pwszFileName,
                      LPWSTR     pwszPassword,
                      DWORD      dwFlags)
{
    HRESULT      hr       = S_OK;
    DATA_BLOB DataBlob = {0, NULL};

    DebugTrace("Entering PFXSaveStore().\n");

    //
    // Sanity check.
    //
    ATLASSERT(hCertStore);
    ATLASSERT(pwszFileName);

    //
    // Export to blob.
    //
    if (FAILED(hr = ::PFXExportStore(hCertStore,
                                     pwszPassword,
                                     dwFlags,
                                     &DataBlob)))
    {
        DebugTrace("Error [%#x]: PFXExportStore() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Now write to file.
    //
    if (FAILED(hr = ::WriteFileContent(pwszFileName, DataBlob)))
    {
        DebugTrace("Error [%#x]: WriteFileContent() failed.\n", hr);
        goto ErrorExit;
    }

CommonExit:
    //
    // Free resources.
    //
    if (DataBlob.pbData)
    {
        ::CoTaskMemFree(DataBlob.pbData);
    }

    DebugTrace("Leaving PFXSaveStore().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : PFXLoadStore

  Synopsis : Load a PFX file and return all the certs in a HCERTSTORE.

  Parameter: LPWSTR pwszFileName - PFX filename.
                                                          
             LPWSTR pwszPassword - Password to decrypt the PFX file.

             DWPRD dwFlags - PFX import flags.

             HCERTSTORE * phCertStore - Pointer to HCERSTORE to receive the
                                        handle.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT PFXLoadStore (LPWSTR       pwszFileName,
                      LPWSTR       pwszPassword,
                      DWORD        dwFlags,
                      HCERTSTORE * phCertStore)
{
    HRESULT     hr         = S_OK;
    DATA_BLOB   DataBlob   = {0, NULL};
    HCERTSTORE  hCertStore = NULL;

    DebugTrace("Entering PFXLoadStore().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pwszFileName);
    ATLASSERT(phCertStore);

    //
    // Read content into memory.
    //
    if (FAILED(hr = ::ReadFileContent(pwszFileName, &DataBlob)))
    {
        DebugTrace("Error [%#x]: ReadFileContent() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Now import the blob to store.
    //
    if (!(hCertStore = ::PFXImportCertStore((CRYPT_DATA_BLOB *) &DataBlob,
                                            pwszPassword,
                                            dwFlags)))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: PFXImportCertStore() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Return HCERSTORE to caller.
    //
    *phCertStore = hCertStore;

CommonExit:
    //
    // Free resources.
    //
    if (DataBlob.pbData)
    {
        ::UnmapViewOfFile(DataBlob.pbData);
    }

    DebugTrace("Leaving PFXLoadStore().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resources.
    //
    if (hCertStore)
    {
        ::CertCloseStore(hCertStore, 0);
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : PFXFreeStore

  Synopsis : Free resources by deleting key containers loaded by PFXLoadStore,
             and then close the store.

  Parameter: HCERTSTORE hCertStore - Store handle returned by PFXLoadStore.
                                                         
  Remark   : hCertStore is always closed even if error occurred.

------------------------------------------------------------------------------*/

HRESULT PFXFreeStore (HCERTSTORE hCertStore)
{
    HRESULT              hr           = S_OK;
    HCRYPTPROV           hCryptProv   = NULL;
    PCCERT_CONTEXT       pCertContext = NULL;
    PCRYPT_KEY_PROV_INFO pKeyProvInfo = NULL;

    DebugTrace("Entering PFXFreeStore().\n");

    //
    // Sanity check.
    //
    ATLASSERT(hCertStore);

    //
    // Now delete all key containers.
    //
    while (pCertContext = ::CertEnumCertificatesInStore(hCertStore, pCertContext))
    {
        DWORD cbData = 0;

        //
        // Retrieve key container info.
        //
        if (!::CertGetCertificateContextProperty(pCertContext,
                                                 CERT_KEY_PROV_INFO_PROP_ID,
                                                 NULL,
                                                 &cbData))
        {
            continue;
        }

        if (!(pKeyProvInfo = (CRYPT_KEY_PROV_INFO *) ::CoTaskMemAlloc(cbData)))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error: out of memory.\n");
            goto ErrorExit;
        }

        if (!::CertGetCertificateContextProperty(pCertContext,
                                                 CERT_KEY_PROV_INFO_PROP_ID,
                                                 pKeyProvInfo,
                                                 &cbData))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertGetCertificateContextProperty() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // First disassociate the key from the cert.
        //
        if (!::CertSetCertificateContextProperty(pCertContext, 
                                                 CERT_KEY_PROV_INFO_PROP_ID,
                                                 0,
                                                 NULL))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertSetCertificateContextProperty() failed to disassociate key container.\n", hr);
            goto ErrorExit;
        }

        //
        // Then delete the key container.
        //
        if (FAILED (hr = ::AcquireContext(pKeyProvInfo->pwszProvName,
                                          pKeyProvInfo->pwszContainerName,
                                          pKeyProvInfo->dwProvType,
                                          CRYPT_DELETEKEYSET | (pKeyProvInfo->dwFlags & CRYPT_MACHINE_KEYSET),
                                          FALSE,
                                          &hCryptProv)))
        {
            DebugTrace("Error [%#x]: AcquireContext(CRYPT_DELETEKEYSET) failed .\n", hr);
            goto ErrorExit;
        }

        ::CoTaskMemFree((LPVOID) pKeyProvInfo), pKeyProvInfo = NULL;

        //
        // Don'f free cert context here, as CertEnumCertificatesInStore()
        // will do that automatically!!!
        //
    }

    //
    // Above loop can exit either because there is no more certificate in
    // the store or an error. Need to check last error to be certain.
    //
    if (CRYPT_E_NOT_FOUND != ::GetLastError())
    {
       hr = HRESULT_FROM_WIN32(::GetLastError());
       
       DebugTrace("Error [%#x]: CertEnumCertificatesInStore() failed.\n", hr);
       goto ErrorExit;
    }

CommonExit:
    //
    // Free resources.
    //
    if (pKeyProvInfo)
    {
        ::CoTaskMemFree((LPVOID) pKeyProvInfo);
    }
    if (pCertContext)
    {
        ::CertFreeCertificateContext(pCertContext);
    }
    if (hCertStore)
    {
        ::CertCloseStore(hCertStore, 0);
    }

    DebugTrace("Leaving PFXFreeStore().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\pfxhlpr.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    PFXHlpr.h

  Content: Declaration of PFXHlpr.

  History: 09-15-2001    dsie     created

------------------------------------------------------------------------------*/

#ifndef __PFXHLPR_H_
#define __PFXHLPR_H_

#include "Debug.h"

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : PFXExportStore

  Synopsis : Export cert store to PFX blob.

  Parameter: HCERTSTORE hCertStore - Store handle.
                                                            
             LPWSTR pwszPassword - Password to encrypt the PFX file.

             DWPRD dwFlags - PFX export flags.

             DATA_BLOB * pPFXBlob - Pointer to DATA_BLOB to receive PFX blob.

  Remark   :

------------------------------------------------------------------------------*/

HRESULT PFXExportStore (HCERTSTORE  hCertStore,
                        LPWSTR      pwszPassword,
                        DWORD       dwFlags,
                        DATA_BLOB * pPFXBlob);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : PFXSaveStore

  Synopsis : Save a PFX file and return all the certs in a HCERTSTORE.

  Parameter: HCERTSTORE hCertStore - Store handle.
  
             LPWSTR pwszFileName - PFX filename.
                                                          
             LPWSTR pwszPassword - Password to encrypt the PFX file.

             DWPRD dwFlags - PFX export flags.

  Remark   :

------------------------------------------------------------------------------*/

HRESULT PFXSaveStore (HCERTSTORE hCertStore,
                      LPWSTR     pwszFileName,
                      LPWSTR     pwszPassword,
                      DWORD      dwFlags);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : PFXLoadStore

  Synopsis : Load a PFX file and return all the certs in a HCERTSTORE.

  Parameter: LPWSTR pwszFileName - PFX filename.
                                                          
             LPWSTR pwszPassword - Password to decrypt the PFX file.

             DWPRD dwFlags - PFX import flags.

             HCERTSTORE * phCertStore - Pointer to HCERSTORE to receive the
                                        handle.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT PFXLoadStore (LPWSTR       pwszFileName,
                      LPWSTR       pwszPassword,
                      DWORD        dwFlags,
                      HCERTSTORE * phCertStore);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : PFXFreeStore

  Synopsis : Free resources by deleting key containers loaded by PFXLoadStore,
             and then close the store.

  Parameter: HCERTSTORE hCertStore - Store handle returned by PFXLoadStore.
                                                          
  Remark   : hCertStore is always closed even if error occurred.

------------------------------------------------------------------------------*/

HRESULT PFXFreeStore (HCERTSTORE hCertStore);

#endif //__PFXHLPR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\oids.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows

  Copyright (C) Microsoft Corporation, 1995 - 1999.

  File:    OIDs.h

  Content: Declaration of COIDs.

  History: 06-15-2001    dsie     created

------------------------------------------------------------------------------*/

#ifndef __OIDs_H_
#define __OIDs_H_

#include "Resource.h"
#include "Lock.h"
#include "Debug.h"
#include "CopyItem.h"
#include "OID.h"

//
// typdefs to make life easier.
//
typedef std::map<CComBSTR, CComPtr<IOID> > OIDMap;
typedef CComEnumOnSTL<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _CopyMapItem<IOID>, OIDMap> OIDEnum;
typedef ICollectionOnSTLImpl<IOIDs, OIDMap, VARIANT, _CopyMapItem<IOID>, OIDEnum> IOIDsCollection;

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateOIDsObject

  Synopsis : Create and initialize an IOIDs collection object.

  Parameter: PCERT_ENHKEY_USAGE pUsages - Pointer to CERT_ENHKEY_USAGE used to
                                          initialize the OIDs collection.
  
             BOOL bCertPolicies - TRUE for certificate policies, else
                                  application policies is assumed.

             IOIDs ** ppIOIDs - Pointer to pointer to IOIDs to receive the 
                                interface pointer.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateOIDsObject (PCERT_ENHKEY_USAGE pUsages, 
                          BOOL bCertPolicies,
                          IOIDs ** ppIOIDs);

////////////////////////////////////////////////////////////////////////////////
//
// COIDs
//
class ATL_NO_VTABLE COIDs : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<COIDs, &CLSID_OIDs>,
    public ICAPICOMError<COIDs, &IID_IOIDs>,
    public IDispatchImpl<IOIDsCollection, &IID_IOIDs, &LIBID_CAPICOM,
                         CAPICOM_MAJOR_VERSION, CAPICOM_MINOR_VERSION>
{
public:
    COIDs()
    {
    }

DECLARE_NO_REGISTRY()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(COIDs)
    COM_INTERFACE_ENTRY(IOIDs)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_CATEGORY_MAP(COIDs)
END_CATEGORY_MAP()

    HRESULT FinalConstruct()
    {
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for OIDs object.\n", hr);
            return hr;
        }

        return S_OK;
    }

//
// IOIDs
//
public:
    //
    // These are the only ones that we need to implemented, others will be
    // handled by ATL ICollectionOnSTLImpl.
    //
    STDMETHOD(get_Item)
        (VARIANT Index, VARIANT * pVal);

    STDMETHOD(Add)
        (/*[in]*/ IOID * pVal);

    STDMETHOD(Remove)
        (/*[in]*/ VARIANT Index);

    STDMETHOD(Clear)
        (void);

    //
    // C++ member function needed to initialize the object.
    //
    STDMETHOD(Init)
        (PCERT_ENHKEY_USAGE pUsages, BOOL bCertPolicies);
private:
    CLock   m_Lock;
};
#endif //__OIDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\policyinformation.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    PolicyInformation.cpp

  Content: Implementation of CPolicyInformation.

  History: 11-17-2001    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "PolicyInformation.h"

#include "OID.h"
#include "Qualifiers.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreatePolicyInformationObject

  Synopsis : Create a policy information object.

  Parameter: PCERT_POLICY_INFO pCertPolicyInfo - Pointer to CERT_POLICY_INFO.

             IPolicyInformation ** ppIPolicyInformation - Pointer to pointer 
                                                          IPolicyInformation 
                                                          object.             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreatePolicyInformationObject (PCERT_POLICY_INFO     pCertPolicyInfo,
                                       IPolicyInformation ** ppIPolicyInformation)
{
    HRESULT hr = S_OK;
    CComObject<CPolicyInformation> * pCPolicyInformation = NULL;

    DebugTrace("Entering CreatePolicyInformationObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertPolicyInfo);
    ATLASSERT(ppIPolicyInformation);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CPolicyInformation>::CreateInstance(&pCPolicyInformation)))
        {
            DebugTrace("Error [%#x]: CComObject<CPolicyInformation>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize object.
        //
        if (FAILED(hr = pCPolicyInformation->Init(pCertPolicyInfo)))
        {
            DebugTrace("Error [%#x]: pCPolicyInformation->Init() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return interface pointer to caller.
        //
        if (FAILED(hr = pCPolicyInformation->QueryInterface(ppIPolicyInformation)))
        {
            DebugTrace("Unexpected error [%#x]:  pCPolicyInformation->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreatePolicyInformationObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    if (pCPolicyInformation)
    {
        delete pCPolicyInformation;
    }

    goto CommonExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// CPolicyInformation
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CPolicyInformation::get_OID

  Synopsis :Return the OID object.

  Parameter: IOID ** pVal - Pointer to pointer to IOID to receive the interface
                            pointer.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CPolicyInformation:: get_OID (IOID ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CPolicyInformation::get_OID().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_pIOID);

        //
        // Return result.
        //
        if (FAILED(hr = m_pIOID->QueryInterface(pVal)))
        {
            DebugTrace("Error [%#x]: m_pIOID->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CPolicyInformation::get_OID().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CPolicyInformation::get_Qualifiers

  Synopsis :Return the Qualifiers object.

  Parameter: IQualifiers ** pVal - Pointer to pointer to IQualifiers to receive
                                   the interface pointer.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CPolicyInformation:: get_Qualifiers (IQualifiers ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CPolicyInformation::get_Qualifiers().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_pIQualifiers);

        //
        // Return result.
        //
        if (FAILED(hr = m_pIQualifiers->QueryInterface(pVal)))
        {
            DebugTrace("Error [%#x]: m_pIQualifiers->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CPolicyInformation::get_Qualifiers().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// Non COM functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CPolicyInformation::Init

  Synopsis : Initialize the PolicyInformation object.

  Parameter: PCERT_POLICY_INFO pCertPolicyInfo - Pointer to CERT_POLICY_INFO.

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CPolicyInformation::Init (PCERT_POLICY_INFO pCertPolicyInfo)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CPolicyInformation::Init().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertPolicyInfo);

    try
    {
        //
        // Create the embeded OID object.
        //
        if (FAILED(hr = ::CreateOIDObject(pCertPolicyInfo->pszPolicyIdentifier, TRUE, &m_pIOID)))
        {
            DebugTrace("Error [%#x]: CreateOIDObject() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Create the qualifiers object.
        //
        if (FAILED(hr = ::CreateQualifiersObject(pCertPolicyInfo, &m_pIQualifiers)))
        {
            DebugTrace("Error [%#x]: CreateQualifiersObject() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = CAPICOM_E_INTERNAL;

        DebugTrace("Exception: internal error.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CPolicyInformation::Init().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (m_pIOID)
    {
        m_pIOID.Release();
    }
    if (m_pIQualifiers)
    {
        m_pIQualifiers.Release();
    }

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\policy.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Policy.cpp

  Content: Implementation of various policy callbacks.

  History: 10-28-2001    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "Policy.h"

#include "CertHlpr.h"
#include "Common.h"

////////////////////////////////////////////////////////////////////////////////
//
// Local functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : HasSigningCapability()

  Synopsis : Check to see if the cert has basic signing capability.
             certs.

  Parameter: PCCERT_CONTEXT pCertContext - cert context.

  Remark   :

------------------------------------------------------------------------------*/

static BOOL HasSigningCapability (PCCERT_CONTEXT pCertContext)
{
    DWORD cb        = 0;
    int   nValidity = 0;

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);

    //
    // Check availability of private key.
    //
    if (!::CertGetCertificateContextProperty(pCertContext, 
                                             CERT_KEY_PROV_INFO_PROP_ID, 
                                             NULL, 
                                             &cb))
    {
        DebugTrace("Info: HasSigningCapability() - private key not found.\n");
        return FALSE;
    }

    //
    // Check cert time validity.
    //
    if (0 != (nValidity = ::CertVerifyTimeValidity(NULL, pCertContext->pCertInfo)))
    {
        DebugTrace("Info: HasSigningCapability() - invalid time (%s).\n", 
                    nValidity < 0 ? "not yet valid" : "expired");
        return FALSE;
    }

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////
//
// Export functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : FindDataSigningCertCallback 

  Synopsis : Callback routine for data signing certs filtering.

  Parameter: See CryptUI.h for defination.

  Remark   : Filter out any cert that is not time valid or has no associated 
             private key. In the future we should also consider filtering out 
             certs that do not have signing capability.

             Also, note that we are not building chain here, since chain
             building is costly, and thus present poor user's experience.

------------------------------------------------------------------------------*/

BOOL WINAPI FindDataSigningCertCallback (PCCERT_CONTEXT pCertContext,
                                         BOOL *         pfInitialSelectedCert,
                                         void *         pvCallbackData)
{
    BOOL bInclude = FALSE;

    DebugTrace("Entering FindDataSigningCertCallback().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);

    //
    // First make sure it has basic signing capability.
    //
    if (!::HasSigningCapability(pCertContext))
    {
        DebugTrace("Info: FindDataSigningCertCallback() - no basic signing capability..\n");
        goto CommonExit;
    }

    bInclude = TRUE;

CommonExit:

    DebugTrace("Leaving FindDataSigningCertCallback().\n");

    return bInclude;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : FindAuthenticodeCertCallback 

  Synopsis : Callback routine for Authenticode certs filtering.

  Parameter: See CryptUI.h for defination.

  Remark   : Filter out any cert that is not time valid, has no associated 
             private key, or code signing OID.

             Also, note that we are not building chain here, since chain
             building is costly, and thus present poor user's experience.

             Instead, we will build the chain and check validity of the cert
             selected (see GetSignerCert function).

------------------------------------------------------------------------------*/

BOOL WINAPI FindAuthenticodeCertCallback (PCCERT_CONTEXT pCertContext,
                                          BOOL *         pfInitialSelectedCert,
                                          void *         pvCallbackData)
{
    HRESULT            hr       = S_OK;
    BOOL               bInclude = FALSE;
    CRYPT_DATA_BLOB    DataBlob = {0, NULL};
    PCERT_ENHKEY_USAGE pUsage   = NULL;

    DebugTrace("Entering FindAuthenticodeCertCallback().\n");

    //
    // First make sure it has basic signing capability.
    //
    if (!::HasSigningCapability(pCertContext))
    {
        DebugTrace("Info: FindAuthenticodeCertCallback() - no basic signing capability..\n");
        goto CommonExit;
    }

    //
    // Get EKU (extension and property).
    //
    if (FAILED(hr = ::GetEnhancedKeyUsage(pCertContext, 0, &pUsage)))
    {
        DebugTrace("Info: FindAuthenticodeCertCallback() - GetEnhancedKeyUsage() failed.\n", hr);
        goto CommonExit;
    }

    //
    // Any usage?
    //
    if (!pUsage)
    {
        DebugTrace("Info: FindAuthenticodeCertCallback() - not valid for any usage.\n");
        goto CommonExit;
    }

    //
    // OK, if good for all usage or code signing OID is explicitly found.
    //
    if (0 == pUsage->cUsageIdentifier)
    {
        bInclude = TRUE;

        DebugTrace("Info: FindAuthenticodeCertCallback() - valid for all usages.\n");
    }
    else
    {
        PCERT_EXTENSION pExtension = NULL;

        //
        // Look for code signing OID.
        //
        for (DWORD cUsage = 0; cUsage < pUsage->cUsageIdentifier; cUsage++)
        {
            if (0 == ::strcmp(szOID_PKIX_KP_CODE_SIGNING, pUsage->rgpszUsageIdentifier[cUsage]))
            {
                bInclude = TRUE;

                DebugTrace("Info: FindAuthenticodeCertCallback() - code signing EKU found.\n");
                goto CommonExit;
            }
        }

        //
        // We didn't find code signing OID, so look for legacy VeriSign OID.
        //
        DebugTrace("Info: FindAuthenticodeCertCallback() - no code signing EKU found.\n");

        //
        // Decode the extension if found.
        //
        if ((0 == pCertContext->pCertInfo->cExtension) ||
            (!(pExtension = ::CertFindExtension(szOID_KEY_USAGE_RESTRICTION,
                                                pCertContext->pCertInfo->cExtension,
                                                pCertContext->pCertInfo->rgExtension))))
        {
            DebugTrace("Info: FindAuthenticodeCertCallback() - no legacy VeriSign OID found either.\n");
            goto CommonExit;
        }

        if (FAILED(hr = ::DecodeObject(X509_KEY_USAGE_RESTRICTION,
                                       pExtension->Value.pbData,
                                       pExtension->Value.cbData,
                                       &DataBlob)))
        {
            DebugTrace("Info [%#x]: DecodeObject() failed.\n", hr);
            goto CommonExit;
        }

        //
        // Now find either of the OIDs.
        //
        PCERT_KEY_USAGE_RESTRICTION_INFO pInfo = (PCERT_KEY_USAGE_RESTRICTION_INFO) DataBlob.pbData;
        DWORD cPolicyId = pInfo->cCertPolicyId; 

        while (cPolicyId--) 
        {
            DWORD cElementId = pInfo->rgCertPolicyId[cPolicyId].cCertPolicyElementId; 

            while (cElementId--) 
            {
                if (0 == ::strcmp(pInfo->rgCertPolicyId[cPolicyId].rgpszCertPolicyElementId[cElementId], 
                                  SPC_COMMERCIAL_SP_KEY_PURPOSE_OBJID) ||
                    0 == ::strcmp(pInfo->rgCertPolicyId[cPolicyId].rgpszCertPolicyElementId[cElementId], 
                                  SPC_INDIVIDUAL_SP_KEY_PURPOSE_OBJID))
                {
                    bInclude = TRUE;

                    DebugTrace("Info: FindAuthenticodeCertCallback() - legacy VeriSign code signing OID found.\n");
                    goto CommonExit;
                }
            }
        }    
    }

CommonExit:
    //
    // Free resources.
    //
    if (DataBlob.pbData)
    {
        ::CoTaskMemFree(DataBlob.pbData);
    }
    if (pUsage)
    {
        ::CoTaskMemFree(pUsage);
    }

    DebugTrace("Entering FindAuthenticodeCertCallback().\n");

    return bInclude;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\policy.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000 - 2001.

  File:    Policy.h

  Content: Declaration of the policy callback functions.

  History: 09-07-2001    dsie     created

------------------------------------------------------------------------------*/

#ifndef __POLICY_H_
#define __POLICY_H_

#include "Debug.h"

////////////////////
//
// typedefs
//

typedef BOOL (WINAPI * PFNCHAINFILTERPROC) 
                (PCCERT_CHAIN_CONTEXT pChainContext,
                 BOOL *               pfInitialSelectedChain,
                 LPVOID               pvCallbackData);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : FindDataSigningCertCallback 

  Synopsis : Callback routine for data signing certs filtering.

  Parameter: See CryptUI.h for defination.

  Remark   : Filter out any cert that is not time valid or has no associated 
             private key. In the future we should also consider filtering out 
             certs that do not have signing capability.

             Also, note that we are not building chain here, since chain
             building is costly, and thus present poor user's experience.

------------------------------------------------------------------------------*/

BOOL WINAPI FindDataSigningCertCallback (PCCERT_CONTEXT pCertContext,
                                         BOOL *         pfInitialSelectedCert,
                                         void *         pvCallbackData);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : FindAuthenticodeCertCallback 

  Synopsis : Callback routine for Authenticode certs filtering.

  Parameter: See CryptUI.h for defination.

  Remark   : Filter out any cert that is not time valid, has no associated 
             private key, or code signing OID.

             Also, note that we are not building chain here, since chain
             building is costly, and thus present poor user's experience.

             Instead, we will build the chain and check validity of the cert
             selected (see GetSignerCert function).

------------------------------------------------------------------------------*/

BOOL WINAPI FindAuthenticodeCertCallback (PCCERT_CONTEXT pCertContext,
                                          BOOL *         pfInitialSelectedCert,
                                          void *         pvCallbackData);

#endif //__POLICY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\policyinformation.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    PolicyInformation.h

  Content: Declaration of the CPolicyInformation.

  History: 06-15-2001    dsie     created

------------------------------------------------------------------------------*/

#ifndef __POLICYINFORMATION_H_
#define __POLICYINFORMATION_H_

#include "Resource.h"
#include "Lock.h"
#include "Error.h"
#include "Debug.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreatePolicyInformationObject

  Synopsis : Create a policy information object.

  Parameter: PCERT_POLICY_INFO pCertPolicyInfo - Pointer to CERT_POLICY_INFO.

             IPolicyInformation ** ppIPolicyInformation - Pointer to pointer 
                                                          IPolicyInformation 
                                                          object.             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreatePolicyInformationObject (PCERT_POLICY_INFO     pCertPolicyInfo,
                                       IPolicyInformation ** ppIPolicyInformation);
                               
////////////////////////////////////////////////////////////////////////////////
//
// CPolicyInformation
//
class ATL_NO_VTABLE CPolicyInformation : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CPolicyInformation, &CLSID_PolicyInformation>,
    public ICAPICOMError<CPolicyInformation, &IID_IPolicyInformation>,
    public IDispatchImpl<IPolicyInformation, &IID_IPolicyInformation, &LIBID_CAPICOM,
                         CAPICOM_MAJOR_VERSION, CAPICOM_MINOR_VERSION>
{
public:
    CPolicyInformation()
    {
    }

    HRESULT FinalConstruct()
    {
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for PolicyInformation object.\n", hr);
            return hr;
        }

        m_pIOID = NULL;
        m_pIQualifiers = NULL;

        return S_OK;
    }

    void FinalRelease()
    {
        m_pIOID.Release();
        m_pIQualifiers.Release();
    }

DECLARE_NO_REGISTRY()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CPolicyInformation)
    COM_INTERFACE_ENTRY(IPolicyInformation)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CPolicyInformation)
END_CATEGORY_MAP()

//
// IPolicyInformation
//
public:
    STDMETHOD(get_OID)
        (/*[out, retval]*/ IOID ** pVal);

    STDMETHOD(get_Qualifiers)
        (/*[out, retval]*/ IQualifiers ** pVal);

    //
    // None COM functions.
    //
    STDMETHOD(Init)
        (PCERT_POLICY_INFO pCertPolicyInfo);

private:
    CLock                m_Lock;
    CComPtr<IOID>        m_pIOID;
    CComPtr<IQualifiers> m_pIQualifiers;
};

#endif //__POLICYINFORMATION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\privatekey.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    PrivateKey.cpp

  Content: Implementation of CPrivateKey.

  History: 06-15-2001    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "PrivateKey.h"

#include "Common.h"
#include "CertHlpr.h"
#include "Settings.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreatePrivateKeyObject

  Synopsis : Create and initialize an CPrivateKey object.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT to be used 
                                           to initialize the IPrivateKey object.

             BOOL bReadOnly - TRUE if read-only, else FALSE.

             IPrivateKey ** ppIPrivateKey - Pointer to receive IPrivateKey.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreatePrivateKeyObject (PCCERT_CONTEXT  pCertContext,
                                BOOL            bReadOnly,
                                IPrivateKey  ** ppIPrivateKey)
{
    HRESULT hr = S_OK;
    CComObject<CPrivateKey> * pCPrivateKey = NULL;

    DebugTrace("Entering CreatePrivateKeyObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(ppIPrivateKey);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CPrivateKey>::CreateInstance(&pCPrivateKey)))
        {
            DebugTrace("Error [%#x]: CComObject<CPrivateKey>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize object.
        //
        if (FAILED(hr = pCPrivateKey->Init(pCertContext, bReadOnly)))
        {
            DebugTrace("Error [%#x]: pCPrivateKey->Init() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return interface pointer to caller.
        //
        if (FAILED(hr = pCPrivateKey->QueryInterface(ppIPrivateKey)))
        {
            DebugTrace("Error [%#x]: pCPrivateKey->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreatePrivateKeyObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    if (pCPrivateKey)
    {
        delete pCPrivateKey;
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : GetKeyProvInfo

  Synopsis : Return pointer to key prov info of a private key object.

  Parameter: IPrivateKey * pIPrivateKey - Pointer to private key object.
  
             PCRYPT_KEY_PROV_INFO * ppKeyProvInfo - Pointer to 
                                                    PCRYPT_KEY_PROV_INFO.

  Remark   : Caller must NOT free the structure.
 
------------------------------------------------------------------------------*/

HRESULT GetKeyProvInfo (IPrivateKey          * pIPrivateKey,
                        PCRYPT_KEY_PROV_INFO * ppKeyProvInfo)
{
    HRESULT               hr            = S_OK;
    PCRYPT_KEY_PROV_INFO  pKeyProvInfo  = NULL;
    CComPtr<ICPrivateKey> pICPrivateKey = NULL;

    DebugTrace("Entering GetKeyProvInfo().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pIPrivateKey);
    ATLASSERT(ppKeyProvInfo);

    //
    // Get ICPrivateKey interface pointer.
    //
    if (FAILED(hr = pIPrivateKey->QueryInterface(IID_ICPrivateKey, (void **) &pICPrivateKey)))
    {
        DebugTrace("Error [%#x]: pIPrivateKey->QueryInterface() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Get the PCRYPT_KEY_PROV_INFO.
    //
    if (FAILED(hr = pICPrivateKey->_GetKeyProvInfo(&pKeyProvInfo)))
    {
        DebugTrace("Error [%#x]: pICPrivateKey->_GetKeyProvInfo() failed.\n", hr);
        goto ErrorExit;
    }

    *ppKeyProvInfo = pKeyProvInfo;

CommonExit:

    DebugTrace("Leaving GetKeyProvInfo().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// CPrivateKey
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CPrivateKey::get_ContainerName

  Synopsis : Return the key container name.

  Parameter: BSTR * pVal - Pointer to BSTR to receive the value.

  Remark   :
             
------------------------------------------------------------------------------*/

STDMETHODIMP CPrivateKey::get_ContainerName (BSTR * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CPrivateKey::get_ContainerName().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure we do have private key.
        //
        if (!m_pKeyProvInfo)
        {
            hr = CAPICOM_E_PRIVATE_KEY_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: private key object has not been initialized.\n", hr);
            goto ErrorExit;
        }

        //
        // Return data to caller.
        //
        if (!(*pVal = ::SysAllocString(m_pKeyProvInfo->pwszContainerName)))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error [%#x]: SysAllocString() failed.\n", hr);
            goto ErrorExit;
        }
     }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CPrivateKey::get_ContainerName().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CPrivateKey::get_UniqueContainerName

  Synopsis : Return the unique key container name.

  Parameter: BSTR * pVal - Pointer to BSTR to receive the value.

  Remark   :
             
------------------------------------------------------------------------------*/

STDMETHODIMP CPrivateKey::get_UniqueContainerName (BSTR * pVal)
{
    HRESULT    hr         = S_OK;
    DWORD      dwFlags    = 0;
    DWORD      cbData     = 0;
    LPBYTE     pbData     = NULL;
    HCRYPTPROV hCryptProv = NULL;
    CComBSTR   bstrName;

    DebugTrace("Entering CPrivateKey::get_UniqueContainerName().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure we do have private key.
        //
        if (!m_pKeyProvInfo)
        {
            hr = CAPICOM_E_PRIVATE_KEY_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: private key object has not been initialized.\n", hr);
            goto ErrorExit;
        }

        //
        // Set dwFlags for machine keyset.
        //
        dwFlags = m_pKeyProvInfo->dwFlags & CRYPT_MACHINE_KEYSET;

        //
        // Get the provider context.
        //
        if (FAILED(hr = ::AcquireContext(m_pKeyProvInfo->pwszProvName,
                                         m_pKeyProvInfo->pwszContainerName,
                                         m_pKeyProvInfo->dwProvType,
                                         dwFlags,
                                         FALSE,
                                         &hCryptProv)))
        {
            DebugTrace("Error [%#x]: AcquireContext() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Get the unique container name.
        //
        if (!::CryptGetProvParam(hCryptProv,
                                 PP_UNIQUE_CONTAINER, 
                                 NULL,
                                 &cbData,
                                 0))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptGetProvParam() failed.\n", hr);
            goto ErrorExit;
        }

        if (NULL == (pbData = (LPBYTE) ::CoTaskMemAlloc(cbData)))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error [%#x]: CoTaskMemAlloc() failed.\n", hr);
            goto ErrorExit;
        }

        if (!::CryptGetProvParam(hCryptProv,
                                 PP_UNIQUE_CONTAINER, 
                                 pbData,
                                 &cbData,
                                 0))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptGetProvParam() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return data to caller.
        //
        if (!(bstrName = (LPSTR) pbData))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error [%#x]: bstrName = pbData failed.\n", hr);
            goto ErrorExit;
        }

        *pVal = bstrName.Detach();
     }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    //
    // Free resources.
    //
    if (hCryptProv)
    {
        ::CryptReleaseContext(hCryptProv, 0);
    }

    DebugTrace("Leaving CPrivateKey::get_UniqueContainerName().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CPrivateKey::get_ProviderName

  Synopsis : Return the provider name.

  Parameter: BSTR * pVal - Pointer to BSTR to receive the value.

  Remark   :
             
------------------------------------------------------------------------------*/

STDMETHODIMP CPrivateKey::get_ProviderName (BSTR * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CPrivateKey::get_ProviderName().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure we do have private key.
        //
        if (!m_pKeyProvInfo)
        {
            hr = CAPICOM_E_PRIVATE_KEY_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: private key object has not been initialized.\n", hr);
            goto ErrorExit;
        }

        //
        // Return data to caller.
        //
        if (!(*pVal = ::SysAllocString(m_pKeyProvInfo->pwszProvName)))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error [%#x]: SysAllocString() failed.\n", hr);
            goto ErrorExit;
        }
     }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CPrivateKey::get_ProviderName().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CPrivateKey::get_ProviderType

  Synopsis : Return the provider type.

  Parameter: CAPICOM_PROV_TYPE * pVal - Pointer to CAPICOM_PROV_TYPE to receive
                                        the value.
  Remark   :
             
------------------------------------------------------------------------------*/

STDMETHODIMP CPrivateKey::get_ProviderType (CAPICOM_PROV_TYPE * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CPrivateKey::get_ProviderType().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure we do have private key.
        //
        if (!m_pKeyProvInfo)
        {
            hr = CAPICOM_E_PRIVATE_KEY_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: private key object has not been initialized.\n", hr);
            goto ErrorExit;
        }

        //
        // Return data to caller.
        //
        *pVal = (CAPICOM_PROV_TYPE) m_pKeyProvInfo->dwProvType;
     }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CPrivateKey::get_ProviderType().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CPrivateKey::get_KeySpec

  Synopsis : Return the Key spec.

  Parameter: CAPICOM_KEY_SPEC * pVal - Pointer to CAPICOM_KEY_SPEC to receive
                                       the value.
  Remark   :
             
------------------------------------------------------------------------------*/

STDMETHODIMP CPrivateKey::get_KeySpec (CAPICOM_KEY_SPEC * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CPrivateKey::get_KeySpec().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure we do have private key.
        //
        if (!m_pKeyProvInfo)
        {
            hr = CAPICOM_E_PRIVATE_KEY_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: private key object has not been initialized.\n", hr);
            goto ErrorExit;
        }

        //
        // Return data to caller.
        //
        *pVal = (CAPICOM_KEY_SPEC) m_pKeyProvInfo->dwKeySpec;
     }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CPrivateKey::get_KeySpec().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
} 

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CPrivateKey::IsAccessible

  Synopsis : Check to see if the private key is accessible.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive the result.

         
  Remark   : This may cause UI to be displayed.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CPrivateKey::IsAccessible (VARIANT_BOOL * pVal)
{
    HRESULT    hr                  = S_OK;
    DWORD      dwFlags             = 0;
    DWORD      dwVerifyContextFlag = 0;
    DWORD      cbData              = 0;
    DWORD      dwImpType           = 0;
    HCRYPTPROV hCryptProv          = NULL;

    DebugTrace("Entering CPrivateKey::IsAccessible().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize.
        //
        *pVal = VARIANT_FALSE;

        //
        // Make sure we do have private key.
        //
        if (!m_pKeyProvInfo)
        {
            hr = CAPICOM_E_PRIVATE_KEY_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: private key object has not been initialized.\n", hr);
            goto ErrorExit;
        }

        //
        // Set dwFlags for machine keyset.
        //
        dwFlags = m_pKeyProvInfo->dwFlags & CRYPT_MACHINE_KEYSET;

        //
        // If Win2K and above, use CRYPT_VERIFYCONTEXT flag.
        //
        if (IsWin2KAndAbove())
        {
            dwVerifyContextFlag = CRYPT_VERIFYCONTEXT;
        }

        //
        // Get the provider context with no key access.
        //
        if (FAILED(hr = ::AcquireContext(m_pKeyProvInfo->pwszProvName,
                                         NULL,
                                         m_pKeyProvInfo->dwProvType,
                                         dwVerifyContextFlag | dwFlags,
                                         FALSE,
                                         &hCryptProv)))
        {
            DebugTrace("Error [%#x]: AcquireContext(CRYPT_VERIFYCONTEXT) failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Get provider param.
        //
        cbData = sizeof(dwImpType);

        if (!::CryptGetProvParam(hCryptProv, PP_IMPTYPE, (PBYTE) &dwImpType, &cbData, 0))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptGetProvParam(PP_IMPTYPE) failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Release verify context.
        //
        ::ReleaseContext(hCryptProv), hCryptProv = NULL;

        //
        // Check implementation type.
        //
        if (dwImpType & CRYPT_IMPL_HARDWARE)
        {
            //
            // We do not support this for hardware key in down level platforms,
            // because CRYPT_SILENT flag is not available.
            //
            if (!IsWin2KAndAbove())
            {
                hr = CAPICOM_E_NOT_SUPPORTED;

                DebugTrace("Error [%#x]: IsAccessible() for hardware key is not supported.\n", hr);
                goto ErrorExit;
            }

            //
            // Reacquire context with silent flag.
            //
            if (FAILED(hr = ::AcquireContext(m_pKeyProvInfo->pwszProvName,
                                             m_pKeyProvInfo->pwszContainerName,
                                             m_pKeyProvInfo->dwProvType,
                                             CRYPT_SILENT | dwFlags,
                                             FALSE,
                                             &hCryptProv)))
            {
                DebugTrace("Info [%#x]: AcquireContext(CRYPT_SILENT) failed, probably smart card not inserted.\n", hr);
                hr = S_OK;
                goto UnlockExit;
            }
        }
        else
        {
            //
            // Reacquire context with private key access.
            //
            if (FAILED(hr = ::AcquireContext(m_pKeyProvInfo->pwszProvName,
                                             m_pKeyProvInfo->pwszContainerName,
                                             m_pKeyProvInfo->dwProvType,
                                             dwFlags,
                                             FALSE,
                                             &hCryptProv)))
            {
                DebugTrace("Info [%#x]: AcquireContext() failed, probably access denied.\n", hr);
                hr = S_OK;
                goto UnlockExit;
            }
        }

        //
        // Return result to caller.
        //
        *pVal = VARIANT_TRUE;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    //
    // Free resources.
    //
    if (hCryptProv)
    {
        ::ReleaseContext(hCryptProv);
    }

    DebugTrace("Leaving CPrivateKey::IsAccessible().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
} 

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CPrivateKey::IsProtected

  Synopsis : Check to see if the private key is user protected.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive the result.

  Remark   :
             
------------------------------------------------------------------------------*/

STDMETHODIMP CPrivateKey::IsProtected (VARIANT_BOOL * pVal)
{
    HRESULT    hr                  = S_OK;
    DWORD      dwFlags             = 0;
    DWORD      dwVerifyContextFlag = 0;
    DWORD      cbData              = 0;
    DWORD      dwImpType           = 0;
    HCRYPTPROV hCryptProv          = NULL;

    DebugTrace("Entering CPrivateKey::IsProtected().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize.
        //
        *pVal = VARIANT_FALSE;

        //
        // Make sure we do have private key.
        //
        if (!m_pKeyProvInfo)
        {
            hr = CAPICOM_E_PRIVATE_KEY_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: private key object has not been initialized.\n", hr);
            goto ErrorExit;
        }

        //
        // Set dwFlags for machine keyset.
        //
        dwFlags = m_pKeyProvInfo->dwFlags & CRYPT_MACHINE_KEYSET;

        //
        // If Win2K and above, use CRYPT_VERIFYCONTEXT flag.
        //
        if (IsWin2KAndAbove())
        {
            dwVerifyContextFlag = CRYPT_VERIFYCONTEXT;
        }

        //
        // Get the provider context with no key access.
        //
        if (FAILED(hr = ::AcquireContext(m_pKeyProvInfo->pwszProvName,
                                         NULL,
                                         m_pKeyProvInfo->dwProvType,
                                         dwVerifyContextFlag | dwFlags,
                                         FALSE,
                                         &hCryptProv)))
        {
            DebugTrace("Error [%#x]: AcquireContext(CRYPT_VERIFYCONTEXT) failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Get provider param.
        //
        cbData = sizeof(dwImpType);

        if (!::CryptGetProvParam(hCryptProv, PP_IMPTYPE, (PBYTE) &dwImpType, &cbData, 0))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptGetProvParam(PP_IMPTYPE) failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Assume hardware key is protected.
        //
        if (dwImpType & CRYPT_IMPL_HARDWARE)
        {
            //
            // Return result to caller.
            //
            *pVal = VARIANT_TRUE;
        }
        else
        {
            //
            // We do not support this for software key in down level platforms,
            // because CRYPT_SILENT flag is not available.
            //
            if (!IsWin2KAndAbove())
            {
                hr = CAPICOM_E_NOT_SUPPORTED;

                DebugTrace("Error [%#x]: IsProtected() for software key is not supported.\n", hr);
                goto ErrorExit;
            }

            //
            // Reacquire context with key access (to make sure key exists).
            //
            ::ReleaseContext(hCryptProv), hCryptProv = NULL;

            if (FAILED(hr = ::AcquireContext(m_pKeyProvInfo->pwszProvName,
                                             m_pKeyProvInfo->pwszContainerName,
                                             m_pKeyProvInfo->dwProvType,
                                             dwFlags,
                                             FALSE,
                                             &hCryptProv)))
            {
                DebugTrace("Error [%#x]: AcquireContext() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Reacquire context with silent flag.
            //
            ::ReleaseContext(hCryptProv), hCryptProv = NULL;

            if (FAILED(hr = ::AcquireContext(m_pKeyProvInfo->pwszProvName,
                                             m_pKeyProvInfo->pwszContainerName,
                                             m_pKeyProvInfo->dwProvType,
                                             CRYPT_SILENT | dwFlags,
                                             FALSE,
                                             &hCryptProv)))
            {
                //
                // CSP refuses to open the container, so can assume it is user protected.
                //
                *pVal = VARIANT_TRUE;

                DebugTrace("Info [%#x]: AcquireContext(CRYPT_SILENT) failed, assume user protected.\n", hr);

                //
                // Successful.
                //
                hr = S_OK;
            }
        }
    }


    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    //
    // Free resources.
    //
    if (hCryptProv)
    {
        ::ReleaseContext(hCryptProv);
    }

    DebugTrace("Leaving CPrivateKey::IsProtected().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
} 

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CPrivateKey::IsExportable

  Synopsis : Check to see if the private key is exportable.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive the result.

  Remark   :
             
------------------------------------------------------------------------------*/

STDMETHODIMP CPrivateKey::IsExportable (VARIANT_BOOL * pVal)
{
    HRESULT    hr                  = S_OK;
    DWORD      dwFlags             = 0;
    DWORD      dwVerifyContextFlag = 0;
    DWORD      cbData              = 0;
    DWORD      dwImpType           = 0;
    DWORD      dwPermissions       = 0;
    HCRYPTPROV hCryptProv          = NULL;
    HCRYPTKEY  hCryptKey           = NULL;

    DebugTrace("Entering CPrivateKey::IsExportable().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize.
        //
        *pVal = VARIANT_FALSE;

        //
        // Make sure we do have private key.
        //
        if (!m_pKeyProvInfo)
        {
            hr = CAPICOM_E_PRIVATE_KEY_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: private key object has not been initialized.\n", hr);
            goto ErrorExit;
        }

        //
        // Set dwFlags for machine keyset.
        //
        dwFlags = m_pKeyProvInfo->dwFlags & CRYPT_MACHINE_KEYSET;

        //
        // If Win2K and above, use CRYPT_VERIFYCONTEXT flag.
        //
        if (IsWin2KAndAbove())
        {
            dwVerifyContextFlag = CRYPT_VERIFYCONTEXT;
        }

        //
        // Get the provider context with no key access.
        //
        if (FAILED(hr = ::AcquireContext(m_pKeyProvInfo->pwszProvName,
                                         NULL,
                                         m_pKeyProvInfo->dwProvType,
                                         dwVerifyContextFlag | dwFlags,
                                         FALSE,
                                         &hCryptProv)))
        {
            DebugTrace("Error [%#x]: AcquireContext(CRYPT_VERIFYCONTEXT) failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Get provider param.
        //
        cbData = sizeof(dwImpType);

        if (!::CryptGetProvParam(hCryptProv, PP_IMPTYPE, (PBYTE) &dwImpType, &cbData, 0))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptGetProvParam(PP_IMPTYPE) failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Assume hardware key is not exportable.
        //
        if (!(dwImpType & CRYPT_IMPL_HARDWARE))
        {
            //
            // We do not support this for software key in down level platforms,
            // because KP_PERMISSIONS flag is not available.
            //
            if (!IsWin2KAndAbove())
            {
                hr = CAPICOM_E_NOT_SUPPORTED;

                DebugTrace("Error [%#x]: IsExportabled() for software key is not supported.\n", hr);
                goto ErrorExit;
            }

            //
            // Reacquire context with private key access.
            //
            ::ReleaseContext(hCryptProv), hCryptProv = NULL;

            if (FAILED(hr = ::AcquireContext(m_pKeyProvInfo->pwszProvName,
                                             m_pKeyProvInfo->pwszContainerName,
                                             m_pKeyProvInfo->dwProvType,
                                             dwFlags,
                                             FALSE,
                                             &hCryptProv)))
            {
                DebugTrace("Error [%#x]: AcquireContext() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Get key handle.
            //
            if (!::CryptGetUserKey(hCryptProv, m_pKeyProvInfo->dwKeySpec, &hCryptKey))
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());

                DebugTrace("Error [%#x]: CryptGetUserKey() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Get key param.
            //
            cbData = sizeof(dwPermissions);

            if (!::CryptGetKeyParam(hCryptKey, KP_PERMISSIONS, (PBYTE) &dwPermissions, &cbData, 0))
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());

                DebugTrace("Error [%#x]: CryptGetKeyParam(KP_PERMISSIONS) failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Return result to caller.
            //
            if (dwPermissions & CRYPT_EXPORT)
            {
                *pVal = VARIANT_TRUE;
            }
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    //
    // Free resources.
    //
    if (hCryptKey)
    {
        ::CryptDestroyKey(hCryptKey);
    }
    if (hCryptProv)
    {
        ::ReleaseContext(hCryptProv);
    }

    DebugTrace("Leaving CPrivateKey::IsExportable().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
} 

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CPrivateKey::IsRemovable

  Synopsis : Check to see if the private key is stored in removable device.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive the result.

  Remark   :
             
------------------------------------------------------------------------------*/

STDMETHODIMP CPrivateKey::IsRemovable (VARIANT_BOOL * pVal)
{
    HRESULT    hr                  = S_OK;
    DWORD      dwFlags             = 0;
    DWORD      dwVerifyContextFlag = 0;
    DWORD      cbData              = 0;
    DWORD      dwImpType           = 0;
    HCRYPTPROV hCryptProv          = NULL;

    DebugTrace("Entering CPrivateKey::IsRemovable().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize.
        //
        *pVal = VARIANT_FALSE;

        //
        // Make sure we do have private key.
        //
        if (!m_pKeyProvInfo)
        {
            hr = CAPICOM_E_PRIVATE_KEY_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: private key object has not been initialized.\n", hr);
            goto ErrorExit;
        }

        //
        // Set dwFlags for machine keyset.
        //
        dwFlags = m_pKeyProvInfo->dwFlags & CRYPT_MACHINE_KEYSET;

        //
        // If Win2K and above, use CRYPT_VERIFYCONTEXT flag.
        //
        if (IsWin2KAndAbove())
        {
            dwVerifyContextFlag = CRYPT_VERIFYCONTEXT;
        }

        //
        // Get the provider context with no key access.
        //
        if (FAILED(hr = ::AcquireContext(m_pKeyProvInfo->pwszProvName,
                                         NULL,
                                         m_pKeyProvInfo->dwProvType,
                                         dwVerifyContextFlag | dwFlags,
                                         FALSE,
                                         &hCryptProv)))
        {
            DebugTrace("Error [%#x]: AcquireContext(CRYPT_VERIFYCONTEXT) failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Get provider param.
        //
        cbData = sizeof(dwImpType);

        if (!::CryptGetProvParam(hCryptProv, PP_IMPTYPE, (PBYTE) &dwImpType, &cbData, 0))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptGetProvParam(PP_IMPTYPE) failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result to caller.
        //
        if (dwImpType & CRYPT_IMPL_REMOVABLE)
        {
            *pVal = VARIANT_TRUE;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    //
    // Free resources.
    //
    if (hCryptProv)
    {
        ::ReleaseContext(hCryptProv);
    }


    DebugTrace("Leaving CPrivateKey::IsRemovable().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
} 

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CPrivateKey::IsMachineKeyset

  Synopsis : Check to see if the private key is stored in machine key container.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive the result.

  Remark   :
             
------------------------------------------------------------------------------*/

STDMETHODIMP CPrivateKey::IsMachineKeyset (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CPrivateKey::IsMachineKeyset().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize.
        //
        *pVal = VARIANT_FALSE;

        //
        // Make sure we do have private key.
        //
        if (!m_pKeyProvInfo)
        {
            hr = CAPICOM_E_PRIVATE_KEY_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: private key object has not been initialized.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result to caller.
        //
        if (m_pKeyProvInfo->dwFlags & CRYPT_MACHINE_KEYSET)
        {
            *pVal = VARIANT_TRUE;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CPrivateKey::IsMachineKeyset().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
} 

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CPrivateKey::IsHardwareDevice

  Synopsis : Check to see if the private key is stored in hardware device.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive the result.

  Remark   :
             
------------------------------------------------------------------------------*/

STDMETHODIMP CPrivateKey::IsHardwareDevice (VARIANT_BOOL * pVal)
{
    HRESULT    hr                  = S_OK;
    DWORD      dwFlags             = 0;
    DWORD      dwVerifyContextFlag = 0;
    DWORD      cbData              = 0;
    DWORD      dwImpType           = 0;
    HCRYPTPROV hCryptProv          = NULL;

    DebugTrace("Entering CPrivateKey::IsHardwareDevice().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize.
        //
        *pVal = VARIANT_FALSE;

        //
        // Make sure we do have private key.
        //
        if (!m_pKeyProvInfo)
        {
            hr = CAPICOM_E_PRIVATE_KEY_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: private key object has not been initialized.\n", hr);
            goto ErrorExit;
        }

        //
        // Set dwFlags for machine keyset.
        //
        dwFlags = m_pKeyProvInfo->dwFlags & CRYPT_MACHINE_KEYSET;

        //
        // If Win2K and above, use CRYPT_VERIFYCONTEXT flag.
        //
        if (IsWin2KAndAbove())
        {
            dwVerifyContextFlag = CRYPT_VERIFYCONTEXT;
        }

        //
        // Get the provider context with no key access.
        //
        if (FAILED(hr = ::AcquireContext(m_pKeyProvInfo->pwszProvName,
                                         NULL,
                                         m_pKeyProvInfo->dwProvType,
                                         dwVerifyContextFlag | dwFlags,
                                         FALSE,
                                         &hCryptProv)))
        {
            DebugTrace("Error [%#x]: AcquireContext(CRYPT_VERIFYCONTEXT) failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Get provider param.
        //
        cbData = sizeof(dwImpType);

        if (!::CryptGetProvParam(hCryptProv, PP_IMPTYPE, (PBYTE) &dwImpType, &cbData, 0))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptGetProvParam(PP_IMPTYPE) failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result to caller.
        //
        if (dwImpType & CRYPT_IMPL_HARDWARE)
        {
            *pVal = VARIANT_TRUE;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    //
    // Free resources.
    //
    if (hCryptProv)
    {
        ::ReleaseContext(hCryptProv);
    }

    DebugTrace("Leaving CPrivateKey::IsHardwareDevice().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
} 

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CPrivateKey::Open

  Synopsis : Open an existing key container.

  Parameter: BSTR ContainerName - Container name.
         
             BSTR ProviderName - Provider name.

             CAPICOM_PROV_TYPE ProviderType - Provider type.

             CAPICOM_KEY_SPEC KeySpec - Key spec.

             CAPICOM_STORE_LOCATION StoreLocation - Machine or user.

             VARIANT_BOOL bCheckExistence - True to check if the specified
                                            container and key actually exists.

  Remark   :
             
------------------------------------------------------------------------------*/

STDMETHODIMP CPrivateKey::Open (BSTR                   ContainerName,
                                BSTR                   ProviderName,
                                CAPICOM_PROV_TYPE      ProviderType,
                                CAPICOM_KEY_SPEC       KeySpec,
                                CAPICOM_STORE_LOCATION StoreLocation,
                                VARIANT_BOOL           bCheckExistence)
{
    HRESULT              hr                 = S_OK;
    DWORD                dwFlags            = 0;
    DWORD                dwSerializedLength = 0;
    HCRYPTPROV           hCryptProv         = NULL;
    HCRYPTKEY            hCryptKey          = NULL;
    PCRYPT_KEY_PROV_INFO pKeyProvInfo       = NULL;;

    DebugTrace("Entering CPrivateKey::Open().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Not allowed if read-only.
        //
        if (m_bReadOnly)
        {
            hr = CAPICOM_E_NOT_ALLOWED;

            DebugTrace("Error [%#x]: Opening private key from WEB script is not allowed.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure paremeters are valid.
        //
        switch (StoreLocation)
        {
            case CAPICOM_LOCAL_MACHINE_STORE:
            {
                dwFlags = CRYPT_MACHINE_KEYSET;
                break;
            }

            case CAPICOM_CURRENT_USER_STORE:
            {
                break;
            }

            default:
            {
                hr = E_INVALIDARG;

                DebugTrace("Error: invalid store location (%#x).\n", StoreLocation);
                goto ErrorExit;
            }
        }
        if (KeySpec != CAPICOM_KEY_SPEC_KEYEXCHANGE && KeySpec != CAPICOM_KEY_SPEC_SIGNATURE)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: invalid key spec (%#x).\n", hr, KeySpec);
            goto ErrorExit;
        }
        
        //
        // Make sure the container and key exists, if requested.
        //
        if (bCheckExistence)
        {
            if (FAILED(hr = ::AcquireContext((LPWSTR) ProviderName,
                                             (LPWSTR) ContainerName,
                                             ProviderType,
                                             dwFlags,
                                             FALSE,
                                             &hCryptProv)))
            {
                DebugTrace("Error [%#x]: AcquireContext() failed.\n", hr);
                goto ErrorExit;
            }

            if (!::CryptGetUserKey(hCryptProv, KeySpec, &hCryptKey))
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());

                DebugTrace("Error [%#x]: CryptGetUserKey() failed.\n", hr);
                goto ErrorExit;
            }
        }

        // 
        // Allocate memory to serialize the structure.
        //
        dwSerializedLength = sizeof(CRYPT_KEY_PROV_INFO) +
                             ((::SysStringLen(ContainerName) + 1) * sizeof(WCHAR)) + 
                             ((::SysStringLen(ProviderName) + 1) * sizeof(WCHAR));

        if (!(pKeyProvInfo = (PCRYPT_KEY_PROV_INFO) ::CoTaskMemAlloc(dwSerializedLength)))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error [%#x]: CoTaskMemAlloc() failed.\n", hr);
            goto ErrorExit;
        }

        // 
        // Now serialize it.
        //
        ::ZeroMemory((LPVOID) pKeyProvInfo, dwSerializedLength);
        pKeyProvInfo->pwszContainerName = (LPWSTR) ((LPBYTE) pKeyProvInfo + sizeof(CRYPT_KEY_PROV_INFO));
        pKeyProvInfo->pwszProvName = (LPWSTR) ((LPBYTE) pKeyProvInfo->pwszContainerName + 
                                               ((::SysStringLen(ContainerName) + 1) * sizeof(WCHAR)));
        pKeyProvInfo->dwProvType = ProviderType;
        pKeyProvInfo->dwKeySpec = KeySpec;
        pKeyProvInfo->dwFlags = dwFlags;

        ::wcscpy(pKeyProvInfo->pwszContainerName, ContainerName);
        ::wcscpy(pKeyProvInfo->pwszProvName, ProviderName);

        //
        // Update states.
        //
        if (m_pKeyProvInfo)
        {
            ::CoTaskMemFree((LPVOID) m_pKeyProvInfo);
        }
        m_cbKeyProvInfo = dwSerializedLength;
        m_pKeyProvInfo  = pKeyProvInfo;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resources.
    //
    if (hCryptKey)
    {
        ::CryptDestroyKey(hCryptKey);
    }
    if (hCryptProv)
    {
        ::ReleaseContext(hCryptProv);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CPrivateKey::Open().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resources.
    //
    if (pKeyProvInfo)
    {
        ::CoTaskMemFree(pKeyProvInfo);
    }

    ReportError(hr);

    goto UnlockExit;
} 

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CPrivateKey::Delete

  Synopsis : Delete the existing key container.

  Parameter: None.

  Remark   :
             
------------------------------------------------------------------------------*/

STDMETHODIMP CPrivateKey::Delete ()
{
    HRESULT    hr         = S_OK;
    HCRYPTPROV hCryptProv = NULL;

    DebugTrace("Entering CPrivateKey::Delete().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Not allowed if read-only.
        //
        if (m_bReadOnly)
        {
            hr = CAPICOM_E_NOT_ALLOWED;

            DebugTrace("Error [%#x]: Deleting private key from WEB script is not allowed.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure we do have private key.
        //
        if (!m_pKeyProvInfo)
        {
            hr = CAPICOM_E_PRIVATE_KEY_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: private key object has not been initialized.\n", hr);
            goto ErrorExit;
        }

        //
        // Delete it!
        //
        if (FAILED(hr = ::AcquireContext(m_pKeyProvInfo->pwszProvName,
                                         m_pKeyProvInfo->pwszContainerName,
                                         m_pKeyProvInfo->dwProvType,
                                         CRYPT_DELETEKEYSET | (m_pKeyProvInfo->dwFlags & CRYPT_MACHINE_KEYSET),
                                         FALSE,
                                         &hCryptProv)))
        {
            DebugTrace("Error [%#x]: AcquireContext(CRYPT_DELETEKEYSET) failed.\n", hr);
            goto ErrorExit;
        }
        
        //
        // Update states.
        //
        ::CoTaskMemFree((LPVOID) m_pKeyProvInfo);

        m_cbKeyProvInfo = 0;
        m_pKeyProvInfo  = NULL;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CPrivateKey::Delete().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
} 

////////////////////////////////////////////////////////////////////////////////
//
// Custom interfaces.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CPrivateKey::_GetKeyProvInfo

  Synopsis : Return pointer to key prov info of a private key object.

  Parameter: PCRYPT_KEY_PROV_INFO * ppKeyProvInfo - Pointer to 
                                                    PCRYPT_KEY_PROV_INFO.

  Remark   : Caller must free the structure with CoTaskMemFree().
 
------------------------------------------------------------------------------*/

STDMETHODIMP CPrivateKey::_GetKeyProvInfo (PCRYPT_KEY_PROV_INFO * ppKeyProvInfo)
{
    HRESULT              hr           = S_OK;
    PCRYPT_KEY_PROV_INFO pKeyProvInfo = NULL;

    DebugTrace("Entering CPrivateKey::_GetKeyProvInfo().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure we do have private key.
        //
        if (!m_pKeyProvInfo)
        {
            hr = CAPICOM_E_PRIVATE_KEY_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: private key object has not been initialized.\n", hr);
            goto ErrorExit;
        }

        //
        // Allocate memory.
        //
        if (!(pKeyProvInfo = (PCRYPT_KEY_PROV_INFO) ::CoTaskMemAlloc(m_cbKeyProvInfo)))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error [%#x]: CoTaskMemAlloc() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // copy structure over.
        //
        ::CopyMemory((LPVOID) pKeyProvInfo, (LPVOID) m_pKeyProvInfo, (SIZE_T) m_cbKeyProvInfo);

        //
        // and return the structure to caller.
        //
        *ppKeyProvInfo = pKeyProvInfo;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CPrivateKey::_GetKeyProvInfo().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resources.
    //
    if (pKeyProvInfo)
    {
        ::CoTaskMemFree((LPVOID) pKeyProvInfo);
    }

    ReportError(hr);

    goto UnlockExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// Private methods.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CPrivateKey::Init

  Synopsis : Initialize the object.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to PCCERT_CONTEXT to be used 
                                           to initialize the object.

             BOOL bReadOnly - TRUE if read-only, else FALSE.
  
  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CPrivateKey::Init (PCCERT_CONTEXT pCertContext, BOOL bReadOnly)
{
    HRESULT              hr           = S_OK;
    DWORD                cbData       = 0;
    PCRYPT_KEY_PROV_INFO pKeyProvInfo = NULL;

    DebugTrace("Entering CPrivateKey::Init().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);

    //
    // Get key provider info property.
    //
    if (!::CertGetCertificateContextProperty(pCertContext,
                                             CERT_KEY_PROV_INFO_PROP_ID,
                                             NULL,
                                             &cbData))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Info [%#x]: CertGetCertificateContextProperty() failed.\n", hr);
        goto ErrorExit;
    }

    if (!(pKeyProvInfo = (PCRYPT_KEY_PROV_INFO) ::CoTaskMemAlloc(cbData)))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Error [%#x]: CoTaskMemAlloc() failed.\n", hr);
        goto ErrorExit;
    }

    if (!::CertGetCertificateContextProperty(pCertContext,
                                             CERT_KEY_PROV_INFO_PROP_ID,
                                             pKeyProvInfo,
                                             &cbData))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Info [%#x]: CertGetCertificateContextProperty() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Update states.
    //
    if (m_pKeyProvInfo)
    {
        ::CoTaskMemFree((LPVOID) m_pKeyProvInfo);
    }
    m_bReadOnly = bReadOnly;
    m_cbKeyProvInfo = cbData;
    m_pKeyProvInfo  = pKeyProvInfo;

CommonExit:

    DebugTrace("Leaving CPrivateKey::Init().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resources.
    //
    if (pKeyProvInfo)
    {
        ::CoTaskMemFree((LPVOID) pKeyProvInfo);
    }

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\publickey.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    PublicKey.cpp

  Content: Implementation of CPublicKey.

  History: 06-15-2001    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "PublicKey.h"
#include "Common.h"
#include "Convert.h"
#include "OID.h"
#include "EncodedData.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreatePublicKeyObject

  Synopsis : Create and initialize an CPublicKey object.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT to be used 
                                           to initialize the IPublicKey object.

             IPublicKey ** ppIPublicKey - Pointer to pointer IPublicKey object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreatePublicKeyObject (PCCERT_CONTEXT pCertContext,
                               IPublicKey  ** ppIPublicKey)
{
    HRESULT hr = S_OK;
    CComObject<CPublicKey> * pCPublicKey = NULL;

    DebugTrace("Entering CreatePublicKeyObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(ppIPublicKey);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CPublicKey>::CreateInstance(&pCPublicKey)))
        {
            DebugTrace("Error [%#x]: CComObject<CPublicKey>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize object.
        //
        if (FAILED(hr = pCPublicKey->Init(pCertContext)))
        {
            DebugTrace("Error [%#x]: pCPublicKey->Init() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return interface pointer to caller.
        //
        if (FAILED(hr = pCPublicKey->QueryInterface(ppIPublicKey)))
        {
            DebugTrace("Error [%#x]: pCPublicKey->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreatePublicKeyObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    if (pCPublicKey)
    {
        delete pCPublicKey;
    }

    goto CommonExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// CPublicKey
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CPublicKey::get_Algorithm

  Synopsis : Return the algorithm OID object.

  Parameter: IOID ** pVal - Pointer to pointer IOID to receive the interface 
                            pointer.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CPublicKey::get_Algorithm(IOID ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CPublicKey::get_Algorithm().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_pIOID);

        //
        // Return interface pointer to user.
        //
        if (FAILED(hr = m_pIOID->QueryInterface(pVal)))
        {
            DebugTrace("Error [%#x]: m_pIOID->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
     }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CPublicKey::get_Algorithm().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CPublicKey::get_Length

  Synopsis : Return the public key length.

  Parameter: long * pVal - Pointer to long to receive the value.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CPublicKey::get_Length(long * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CPublicKey::get_Length().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        *pVal = (long) m_dwKeyLength;
     }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CPublicKey::get_Length().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

#if (0)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CPublicKey::get_Exponent

  Synopsis : Return the public key exponent.

  Parameter: long * pVal - Pointer to long to receive the value.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CPublicKey::get_Exponent(long * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CPublicKey::get_Exponent().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Sanity check.
        //
        ATLASSERT(m_pPublicKeyValues);


        *pVal = (long) m_pPublicKeyValues->rsapubkey.pubexp;
     }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CPublicKey::get_Exponent().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CPublicKey::get_Modulus

  Synopsis : Return the public key modulus.

  Parameter: CAPICOM_ENCODING_TYPE EncodingType - ENcoding type.
  
             BSTR * pVal - Pointer to BSTR to receive the value.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CPublicKey::get_Modulus(CAPICOM_ENCODING_TYPE EncodingType,
                                     BSTR                * pVal)
{
    HRESULT         hr          = S_OK;
    CRYPT_DATA_BLOB ModulusBlob = {0, NULL};

    DebugTrace("Entering CPublicKey::get_Modulus().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Sanity check.
        //
        ATLASSERT(m_pPublicKeyValues);

        //
        // Initialize the blob.
        //
        ModulusBlob.cbData = m_pPublicKeyValues->rsapubkey.bitlen / 8;
        ModulusBlob.pbData = m_pPublicKeyValues->modulus;

        //
        // Return data to caller.
        //
        if (FAILED(hr = ::ExportData(ModulusBlob, EncodingType, pVal)))
        {
            DebugTrace("Error [%#x]: ExportData() failed.\n", hr);
            goto ErrorExit;
        }
     }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CPublicKey::get_Modulus().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}
#endif

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CPublicKey::get_EncodedKey

  Synopsis : Return the encoded public key key object.

  Parameter: IEncodedData ** pVal - Pointer to pointer IEncodedData to receive 
                                    the interface pointer.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CPublicKey::get_EncodedKey(IEncodedData ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CPublicKey::get_EncodedKey().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_pIEncodedKey);

        //
        // Return interface pointer to user.
        //
        if (FAILED(hr = m_pIEncodedKey->QueryInterface(pVal)))
        {
            DebugTrace("Error [%#x]: m_pIEncodedKey->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
     }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CPublicKey::get_EncodedKey().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CPublicKey::get_EncodedParameters

  Synopsis : Return the encoded algorithm parameters key object.

  Parameter: IEncodedData ** pVal - Pointer to pointer IEncodedData to receive 
                                    the interface pointer.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CPublicKey::get_EncodedParameters(IEncodedData ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CPublicKey::get_EncodedParameters().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_pIEncodedParams);

        //
        // Return interface pointer to user.
        //
        if (FAILED(hr = m_pIEncodedParams->QueryInterface(pVal)))
        {
            DebugTrace("Error [%#x]: m_pIEncodedParams->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
     }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CPublicKey::get_EncodedParameters().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// Private methods.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CPublicKey::Init

  Synopsis : Initialize the object.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT to be used 
                                           to initialize the object.

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us with CERT_ExtendedProperty.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CPublicKey::Init (PCCERT_CONTEXT pCertContext)
{
    HRESULT   hr = S_OK;
    DWORD                 dwKeyLength     = 0;
    CComPtr<IOID>         pIOID           = NULL;
    CComPtr<IEncodedData> pIEncodedKey    = NULL;
    CComPtr<IEncodedData> pIEncodedParams = NULL;
    PCERT_PUBLIC_KEY_INFO pKeyInfo;


    DebugTrace("Entering CPublicKey::Init().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);

    //
    // Access the public key info structure.
    //
    pKeyInfo = &pCertContext->pCertInfo->SubjectPublicKeyInfo;

#if (0)
    //
    // Decode the public key.
    //
    LPSTR                 pszStructType    = NULL;
    CRYPT_DATA_BLOB       PublicKeyBlob    = {0, NULL};
    PUBLIC_KEY_VALUES   * pPublicKeyValues = NULL;

    if (0 == ::strcmp(szOID_RSA_RSA, pKeyInfo->Algorithm.pszObjId))
    {
        pszStructType = (LPSTR) RSA_CSP_PUBLICKEYBLOB;
    }
    else if (0 == ::strcmp(szOID_X957_DSA, pKeyInfo->Algorithm.pszObjId))
    {
        pszStructType = (LPSTR) X509_DSS_PUBLICKEY;
    }
    else
    {
        hr = CAPICOM_E_NOT_SUPPORTED;

        DebugTrace("Error [%#x]: Public Key algorithm (%s) not supported.\n", hr, pKeyInfo->Algorithm.pszObjId);
        goto ErrorExit;
    }

    if (FAILED(hr = ::DecodeObject((LPCSTR) pszStructType, 
                                   pKeyInfo->PublicKey.pbData, 
                                   pKeyInfo->PublicKey.cbData, 
                                   &PublicKeyBlob)))
    {
        DebugTrace("Error [%#x]: DecodeObject() failed.\n", hr);
        goto ErrorExit;
    }

    pPublicKeyValues = (PUBLIC_KEY_VALUES *) PublicKeyBlob.pbData;
#endif

    //
    // Create the embeded IOID object for algorithm.
    //
    if (FAILED(hr = ::CreateOIDObject(pKeyInfo->Algorithm.pszObjId, TRUE, &pIOID)))
    {
        DebugTrace("Error [%#x]: CreateOIDObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Create the embeded IEncodeData object for the public key value.
    //
    if (FAILED(hr = ::CreateEncodedDataObject(pKeyInfo->Algorithm.pszObjId,
                                              (DATA_BLOB *) &pKeyInfo->PublicKey,
                                              &pIEncodedKey)))
    {
        DebugTrace("Error [%#x]: CreateEncodedDataObject() failed for public key.\n", hr);
        goto ErrorExit;
    }

    //
    // Create the embeded IEncodeData object for the algorithm parameters.
    //
    if (FAILED(hr = ::CreateEncodedDataObject(pKeyInfo->Algorithm.pszObjId,
                                              &pKeyInfo->Algorithm.Parameters,
                                              &pIEncodedParams)))
    {
        DebugTrace("Error [%#x]: CreateEncodedDataObject() failed for algorithm parameters.\n", hr);
        goto ErrorExit;
    }

    //
    // Get key length.
    //
    if (0 == (dwKeyLength = ::CertGetPublicKeyLength(CAPICOM_ASN_ENCODING, pKeyInfo)))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CertGetPublicKeyLength() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Reset.
    //
    m_pIOID = pIOID;
    m_dwKeyLength = dwKeyLength;
    m_pIEncodedKey = pIEncodedKey;
    m_pIEncodedParams = pIEncodedParams;

CommonExit:

    DebugTrace("Leaving CPublicKey::Init().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\publickey.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows

  Copyright (C) Microsoft Corporation, 1995 - 1999.

  File:    PublicKey.h

  Content: Declaration of CPublicKey.

  History: 06-15-2001    dsie     created

------------------------------------------------------------------------------*/

#ifndef __PUBLICKEY_H_
#define __PUBLICKEY_H_

#include "Resource.h"
#include "Error.h"
#include "Lock.h"
#include "Debug.h"

#if (0)
typedef struct PublicKeyValues
{
    PUBLICKEYSTRUC pks;
    RSAPUBKEY      rsapubkey;
    BYTE           modulus[1];
} PUBLIC_KEY_VALUES, * PPUBLIC_KEY_VALUES;
#endif

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreatePublicKeyObject

  Synopsis : Create and initialize an CPublicKey object.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT to be used 
                                           to initialize the IPublicKey object.

             IPublicKey ** ppIPublicKey - Pointer to pointer IPublicKey object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreatePublicKeyObject (PCCERT_CONTEXT pCertContext,
                               IPublicKey  ** ppIPublicKey);

                               
////////////////////////////////////////////////////////////////////////////////
//
// CPublicKey
//
class ATL_NO_VTABLE CPublicKey : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CPublicKey, &CLSID_PublicKey>,
    public ICAPICOMError<CPublicKey, &IID_IPublicKey>,
    public IDispatchImpl<IPublicKey, &IID_IPublicKey, &LIBID_CAPICOM,
                         CAPICOM_MAJOR_VERSION, CAPICOM_MINOR_VERSION>
{
public:
    CPublicKey()
    {
    }

DECLARE_NO_REGISTRY()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CPublicKey)
    COM_INTERFACE_ENTRY(IPublicKey)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CPublicKey)
END_CATEGORY_MAP()

    HRESULT FinalConstruct()
    {
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for PublicKey object.\n", hr);
            return hr;
        }

        m_dwKeyLength      = 0;
        // m_pPublicKeyValues = NULL;
        m_pIOID            = NULL;
        m_pIEncodedKey     = NULL;
        m_pIEncodedParams  = NULL;

        return S_OK;
    }

    void FinalRelease()
    {
#if (0)
        if (m_pPublicKeyValues)
        {
            ::CoTaskMemFree((LPVOID) m_pPublicKeyValues);
        }
#endif
        m_pIOID.Release();
        m_pIEncodedKey.Release();
        m_pIEncodedParams.Release();
    }

//
// IPublicKey
//
public:
    STDMETHOD(get_Algorithm)
        (/*[out, retval]*/ IOID ** pVal);

    STDMETHOD(get_Length)
        (/*[out, retval]*/ long * pVal);

#if (0)
    STDMETHOD(get_Exponent)
        (/*[out, retval]*/ long * pVal);

    STDMETHOD(get_Modulus)
        (/*[in, defaultvalue(CAPICOM_ENCODE_BASE64)]*/ CAPICOM_ENCODING_TYPE EncodingType, 
         /*[out, retval]*/ BSTR * pVal);
#endif

    STDMETHOD(get_EncodedKey)
        (/*[out, retval]*/ IEncodedData ** pVal);

    STDMETHOD(get_EncodedParameters)
        (/*[out, retval]*/ IEncodedData ** pVal);

    //
    // None COM functions.
    //
    STDMETHOD(Init)
        (PCCERT_CONTEXT pCertContext);

private:
    CLock                   m_Lock;
    DWORD                   m_dwKeyLength;
    // PPUBLIC_KEY_VALUES      m_pPublicKeyValues;
    CComPtr<IOID>           m_pIOID;
    CComPtr<IEncodedData>   m_pIEncodedKey;
    CComPtr<IEncodedData>   m_pIEncodedParams;
};

#endif //__PUBLICKEY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\qualifiers.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows

  Copyright (C) Microsoft Corporation, 1995 - 1999.

  File:    Qualifiers.h

  Content: Declaration of CQualifiers.

  History: 11-17-2001    dsie     created

------------------------------------------------------------------------------*/

#ifndef __QUALIFIERS_H_
#define __QUALIFIERS_H_

#include "Resource.h"
#include "Debug.h"
#include "Error.h"
#include "CopyItem.h"
#include "Qualifier.h"

//
// typdefs to make life easier.
//
typedef std::map<CComBSTR, CComPtr<IQualifier> > QualifierMap;
typedef CComEnumOnSTL<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _CopyMapItem<IQualifier>, QualifierMap> QualifierEnum;
typedef ICollectionOnSTLImpl<IQualifiers, QualifierMap, VARIANT, _CopyMapItem<IQualifier>, QualifierEnum> IQualifiersCollection;


////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateQualifiersObject

  Synopsis : Create a qualifiers collection object and populate the collection 
             with qualifiers from the specified certificate policies.

  Parameter: PCERT_POLICY_INFO pCertPolicyInfo - Pointer to CERT_POLICY_INFO.

             IQualifiers ** ppIQualifiers - Pointer to pointer IQualifiers 
                                            object.             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateQualifiersObject (PCERT_POLICY_INFO pCertPolicyInfo,
                                IQualifiers    ** ppIQualifiers);

////////////////////////////////////////////////////////////////////////////////
//
// CQualifiers
//

class ATL_NO_VTABLE CQualifiers : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CQualifiers, &CLSID_Qualifiers>,
    public ICAPICOMError<CQualifiers, &IID_IQualifiers>,
    public IDispatchImpl<IQualifiersCollection, &IID_IQualifiers, &LIBID_CAPICOM,
                         CAPICOM_MAJOR_VERSION, CAPICOM_MINOR_VERSION>
{
public:
    CQualifiers()
    {
    }

DECLARE_NO_REGISTRY()

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CQualifiers)
    COM_INTERFACE_ENTRY(IQualifiers)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CQualifiers)
END_CATEGORY_MAP()

//
// IQualifiers
//
public:
    //
    // These are the only ones that we need to implemented, others will be
    // handled by ATL ICollectionOnSTLImpl.
    //

    //
    // None COM functions.
    //
    STDMETHOD(Init) 
        (PCERT_POLICY_INFO pCertPolicyInfo);
};

#endif //__QUALIFIERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\privatekey.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows

  Copyright (C) Microsoft Corporation, 1995 - 1999.

  File:    PrivateKey.h

  Content: Declaration of CPrivateKey.

  History: 06-15-2001    dsie     created

------------------------------------------------------------------------------*/

#ifndef __PRIVATEKEY_H_
#define __PRIVATEKEY_H_

#include "Resource.h"
#include "Error.h"
#include "Lock.h"
#include "Debug.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreatePrivateKeyObject

  Synopsis : Create and initialize an CPrivateKey object.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT to be used 
                                           to initialize the IPrivateKey object.

             BOOL bReadOnly - TRUE if read-only, else FALSE.

             IPrivateKey ** ppIPrivateKey - Pointer to receive IPrivateKey.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreatePrivateKeyObject (PCCERT_CONTEXT  pCertContext,
                                BOOL            bReadOnly,
                                IPrivateKey  ** ppIPrivateKey);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : GetKeyProvInfo

  Synopsis : Return pointer to key prov info of a private key object.

  Parameter: IPrivateKey * pIPrivateKey - Pointer to private key object.
  
             PCRYPT_KEY_PROV_INFO * ppKeyProvInfo - Pointer to 
                                                    PCRYPT_KEY_PROV_INFO.

  Remark   : Caller must NOT free the structure.
 
------------------------------------------------------------------------------*/

HRESULT GetKeyProvInfo (IPrivateKey          * pIPrivateKey,
                        PCRYPT_KEY_PROV_INFO * ppKeyProvInfo);

////////////////////////////////////////////////////////////////////////////////
//
// CPrivateKey
//
class ATL_NO_VTABLE CPrivateKey : ICPrivateKey, 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CPrivateKey, &CLSID_PrivateKey>,
    public ICAPICOMError<CPrivateKey, &IID_IPrivateKey>,
    public IDispatchImpl<IPrivateKey, &IID_IPrivateKey, &LIBID_CAPICOM,
                         CAPICOM_MAJOR_VERSION, CAPICOM_MINOR_VERSION>
{
public:
    CPrivateKey()
    {
    }

DECLARE_REGISTRY_RESOURCEID(IDR_PRIVATEKEY)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CPrivateKey)
    COM_INTERFACE_ENTRY(IPrivateKey)
    COM_INTERFACE_ENTRY(ICPrivateKey)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

    HRESULT FinalConstruct()
    {
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for PrivateKey object.\n", hr);
            return hr;
        }
        
        m_bReadOnly = FALSE;
        m_cbKeyProvInfo = 0;
        m_pKeyProvInfo  = NULL;

        return S_OK;
    }

    void FinalRelease()
    {
        if (m_pKeyProvInfo)
        {
            ::CoTaskMemFree((LPVOID) m_pKeyProvInfo);
        }
    }

//
// IPrivateKey
//
public:
    STDMETHOD(get_ContainerName)
        (/*[out, retval]*/ BSTR * pVal);

    STDMETHOD(get_UniqueContainerName)
        (/*[out, retval]*/ BSTR * pVal);

    STDMETHOD(get_ProviderName)
        (/*[out, retval]*/ BSTR * pVal);

    STDMETHOD(get_ProviderType)
        (/*[out, retval]*/ CAPICOM_PROV_TYPE * pVal);

    STDMETHOD(get_KeySpec)
        (/*[out, retval]*/ CAPICOM_KEY_SPEC * pVal);

    STDMETHOD(IsAccessible)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

    STDMETHOD(IsProtected)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

    STDMETHOD(IsExportable)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

    STDMETHOD(IsRemovable)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

    STDMETHOD(IsMachineKeyset)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

    STDMETHOD(IsHardwareDevice)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

    STDMETHOD(Open)
        (/*[in]*/ BSTR ContainerName,
         /*[in, defaultvalue(CAPICOM_PROV_MS_ENHANCED_PROV]*/ BSTR ProviderName,
         /*[in, defaultvalue(CAPICOM_PROV_RSA_FULL)]*/ CAPICOM_PROV_TYPE ProviderType,
         /*[in, defaultvalue(CAPICOM_KEY_SPEC_SIGNATURE)]*/ CAPICOM_KEY_SPEC KeySpec,
         /*[in, defaultvalue(CAPICOM_CURRENT_USER_STORE)]*/ CAPICOM_STORE_LOCATION StoreLocation,
         /*[in, defaultvalue(0)]*/ VARIANT_BOOL bCheckExistence);

    STDMETHOD(Delete)();

    //
    // Custom inferfaces.
    //
    STDMETHOD(_GetKeyProvInfo)
        (PCRYPT_KEY_PROV_INFO * ppKeyProvInfo);

    //
    // None COM functions.
    //
    STDMETHOD(Init)
        (PCCERT_CONTEXT pCertContext,
         BOOL bReadOnly);

private:
    CLock                m_Lock;
    BOOL                 m_bReadOnly;
    DWORD                m_cbKeyProvInfo;
    PCRYPT_KEY_PROV_INFO m_pKeyProvInfo;
};

#endif //__PRIVATEKEY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\qualifiers.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Qualifiers.cpp

  Content: Implementation of CQualifiers.

  History: 11-17-2001    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "Qualifiers.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateQualifiersObject

  Synopsis : Create a qualifiers collection object and populate the collection 
             with qualifiers from the specified certificate policies.

  Parameter: PCERT_POLICY_INFO pCertPolicyInfo - Pointer to CERT_POLICY_INFO.

             IQualifiers ** ppIQualifiers - Pointer to pointer IQualifiers 
             object.             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateQualifiersObject (PCERT_POLICY_INFO pCertPolicyInfo,
                                IQualifiers    ** ppIQualifiers)
{
    HRESULT hr = S_OK;
    CComObject<CQualifiers> * pCQualifiers = NULL;

    DebugTrace("Entering CreateQualifiersObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertPolicyInfo);
    ATLASSERT(ppIQualifiers);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CQualifiers>::CreateInstance(&pCQualifiers)))
        {
            DebugTrace("Error [%#x]: CComObject<CQualifiers>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize object.
        //
        if (FAILED(hr = pCQualifiers->Init(pCertPolicyInfo)))
        {
            DebugTrace("Error [%#x]: pCQualifiers->Init() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return interface pointer to caller.
        //
        if (FAILED(hr = pCQualifiers->QueryInterface(ppIQualifiers)))
        {
            DebugTrace("Unexpected error [%#x]:  pCQualifiers->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreateQualifiersObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    if (pCQualifiers)
    {
        delete pCQualifiers;
    }

    goto CommonExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// CQualifiers
//

////////////////////////////////////////////////////////////////////////////////
//
// Non COM functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CQualifiers::Init

  Synopsis : Initialize the qualifiers collection object by adding all 
             individual qualifier object to the collection.

  Parameter: PCERT_POLICY_INFO pCertPolicyInfo - Pointer to CERT_POLICY_INFO.

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CQualifiers::Init (PCERT_POLICY_INFO pCertPolicyInfo)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CQualifiers::Init().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertPolicyInfo);

    try
    {
        //
        // Make sure we have room to add.
        //
        if ((m_coll.size() + pCertPolicyInfo->cPolicyQualifier) > m_coll.max_size())
        {
            hr = CAPICOM_E_OUT_OF_RESOURCE;

            DebugTrace("Error [%#x]: Maximum entries (%#x) reached for Qualifierss collection.\n", 
                        hr, pCertPolicyInfo->cPolicyQualifier);
            goto ErrorExit;
        }

        //
        // Add all qualifiers to the map.
        //
        for (DWORD i = 0; i < pCertPolicyInfo->cPolicyQualifier; i++)
        {
            CComBSTR bstrIndex;
            CComPtr<IQualifier> pIQualifier = NULL;

            //
            // Create the qualifier object.
            //
            if (FAILED(hr = ::CreateQualifierObject(&pCertPolicyInfo->rgPolicyQualifier[i], 
                                                    &pIQualifier)))
            {
                DebugTrace("Error [%#x]: CreateQualifierObject() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // BSTR index of OID.
            //
            if (!(bstrIndex = pCertPolicyInfo->rgPolicyQualifier[i].pszPolicyQualifierId))
            {
                hr = E_OUTOFMEMORY;

                DebugTrace("Error [%#x]: bstrIndex = pCertPolicyInfo->rgPolicyQualifier[i].pszPolicyQualifierId failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Now add object to collection map.
            //
            // Note that the overloaded = operator for CComPtr will
            // automatically AddRef to the object. Also, when the CComPtr
            // is deleted (happens when the Remove or map destructor is called), 
            // the CComPtr destructor will automatically Release the object.
            //
            m_coll[bstrIndex] = pIQualifier;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CQualifiers::Init().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    m_coll.clear();

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\qualifier.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Qualifier.cpp

  Content: Implementation of CQualifier.

  History: 06-15-2001    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "Qualifier.h"
#include "Common.h"
#include "Convert.h"
#include "NoticeNumbers.h"
#include "OID.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateQualifierObject

  Synopsis : Create and initialize an CQualifier object.

  Parameter: PCERT_POLICY_QUALIFIER_INFO pQualifier - Pointer to qualifier.
  
             IQualifier ** ppIQualifier - Pointer to pointer IQualifier object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateQualifierObject (PCERT_POLICY_QUALIFIER_INFO pQualifier, 
                               IQualifier               ** ppIQualifier)
{
    HRESULT hr = S_OK;
    CComObject<CQualifier> * pCQualifier = NULL;

    DebugTrace("Entering CreateQualifierObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pQualifier);
    ATLASSERT(ppIQualifier);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CQualifier>::CreateInstance(&pCQualifier)))
        {
            DebugTrace("Error [%#x]: CComObject<CQualifier>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize object.
        //
        if (FAILED(hr = pCQualifier->Init(pQualifier)))
        {
            DebugTrace("Error [%#x]: pCQualifier->Init() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return interface pointer to caller.
        //
        if (FAILED(hr = pCQualifier->QueryInterface(ppIQualifier)))
        {
            DebugTrace("Error [%#x]: pCQualifier->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreateQualifierObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    if (pCQualifier)
    {
        delete pCQualifier;
    }

    goto CommonExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// CQualifier
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CQualifier::get_OID

  Synopsis :Return the OID object.

  Parameter: IOID ** pVal - Pointer to pointer to IOID to receive the interface
                            pointer.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CQualifier:: get_OID (IOID ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CQualifier::get_OID().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_pIOID);

        //
        // Return result.
        //
        if (FAILED(hr = m_pIOID->QueryInterface(pVal)))
        {
            DebugTrace("Error [%#x]: m_pIOID->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CQualifier::get_OID().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CQualifier::get_CPSPointer

  Synopsis : Return the URI of the CPS.

  Parameter: BSTR * pVal - Pointer to BSTR to receive the value.

  Remark   :
             
------------------------------------------------------------------------------*/

STDMETHODIMP CQualifier::get_CPSPointer (BSTR * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CQualifier::get_CPSPointer().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
        if (FAILED(hr = m_bstrCPSPointer.CopyTo(pVal)))
        {
            DebugTrace("Error [%#x]: m_bstrCPSPointer.CopyTo() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CQualifier::get_CPSPointer().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CQualifier::get_OrganizationName

  Synopsis : Return the organization name.

  Parameter: BSTR * pVal - Pointer to BSTR to receive the value.

  Remark   :
             
------------------------------------------------------------------------------*/

STDMETHODIMP CQualifier::get_OrganizationName (BSTR * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CQualifier::get_OrganizationName().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
        if (FAILED(hr = m_bstrOrganizationName.CopyTo(pVal)))
        {
            DebugTrace("Error [%#x]: m_bstrOrganizationName.CopyTo() failed.\n", hr);
            goto ErrorExit;
        }
     }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CQualifier::get_OrganizationName().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CQualifier::get_NoticeNumbers

  Synopsis : Return the notice number collection object.

  Parameter: INoticeNumbers ** pVal - Pointer to pointer to INoticeNumbers to
             to receive the interfcae pointer.

  Remark   :
             
------------------------------------------------------------------------------*/

STDMETHODIMP CQualifier::get_NoticeNumbers (INoticeNumbers ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CQualifier::get_NoticeNumbers().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
        if (m_pINoticeNumbers)
        {
              if (FAILED(hr = m_pINoticeNumbers->QueryInterface(pVal)))
            {
                DebugTrace("Error [%#x]: m_pINoticeNumbers->QueryInterface() failed.\n", hr);
                goto ErrorExit;
            }
        }
        else
        {
            *pVal = (INoticeNumbers *) NULL;
        }
     }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CQualifier::get_NoticeNumbers().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CQualifier::get_ExplicitText

  Synopsis : Return the explicit text.

  Parameter: BSTR * pVal - Pointer to BSTR to receive the value.

  Remark   :
             
------------------------------------------------------------------------------*/

STDMETHODIMP CQualifier::get_ExplicitText (BSTR * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CQualifier::get_ExplicitText().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
        if (FAILED(hr = m_bstrExplicitText.CopyTo(pVal)))
        {
            DebugTrace("Error [%#x]: m_bstrExplicitText.CopyTo() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CQualifier::get_ExplicitText().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// Private methods.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CQualifier::Init

  Synopsis : Initialize the object.

  Parameter: PCERT_POLICY_QUALIFIER_INFO pQualifier - Pointer to qualifier.

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CQualifier::Init (PCERT_POLICY_QUALIFIER_INFO pQualifier)
{
    HRESULT   hr       = S_OK;
    DATA_BLOB DataBlob = {0, NULL};

    DebugTrace("Entering CQualifier::Init().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pQualifier);

    //
    // Create the embeded OID object.
    //
    if (FAILED(hr = ::CreateOIDObject(pQualifier->pszPolicyQualifierId, TRUE, &m_pIOID)))
    {
        DebugTrace("Error [%#x]: CreateOIDObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // What type of qualifier?
    //
    if (0 == ::strcmp(szOID_PKIX_POLICY_QUALIFIER_CPS, 
                      pQualifier->pszPolicyQualifierId))
    {
        PCERT_NAME_VALUE pCertNameValue;

        //
        // CPS string.
        //
        if (FAILED(hr = ::DecodeObject(X509_UNICODE_ANY_STRING, 
                                       pQualifier->Qualifier.pbData,
                                       pQualifier->Qualifier.cbData,
                                       &DataBlob)))
        {
            DebugTrace("Error [%#x]: DecodeObject() failed.\n", hr);
            goto ErrorExit;
        }

        pCertNameValue = (PCERT_NAME_VALUE) DataBlob.pbData;

        if (!(m_bstrCPSPointer = (LPWSTR) pCertNameValue->Value.pbData))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error [%#x]: m_bstrCPSPointer = (LPWSTR) pCertNameValue->Value.pbData failed.\n", hr);
            goto ErrorExit;
        }
    }
    else if (0 == ::strcmp(szOID_PKIX_POLICY_QUALIFIER_USERNOTICE, 
                           pQualifier->pszPolicyQualifierId))
    {
        PCERT_POLICY_QUALIFIER_USER_NOTICE pUserNotice;

        //
        // User Notice.
        //
        if (FAILED(hr = ::DecodeObject(szOID_PKIX_POLICY_QUALIFIER_USERNOTICE, 
                                       pQualifier->Qualifier.pbData,
                                       pQualifier->Qualifier.cbData,
                                       &DataBlob)))
        {
            DebugTrace("Error [%#x]: DecodeObject() failed.\n", hr);
            goto ErrorExit;
        }

        pUserNotice = (PCERT_POLICY_QUALIFIER_USER_NOTICE) DataBlob.pbData;

        //
        // Do we have notice reference?
        //
        if (pUserNotice->pNoticeReference)
        {
            //
            // Any organization name?
            //
            if (pUserNotice->pNoticeReference->pszOrganization)
            {
                if (!(m_bstrOrganizationName = pUserNotice->pNoticeReference->pszOrganization))
                {
                    hr = E_OUTOFMEMORY;

                    DebugTrace("Error [%#x]: m_bstrOrganizationName = pUserNotice->pNoticeReference->pszOrganization failed.\n", hr);
                    goto ErrorExit;
                }
            }

            //
            // Any notice number?
            //
            if (pUserNotice->pNoticeReference->cNoticeNumbers)
            {
                if (FAILED(hr = ::CreateNoticeNumbersObject(pUserNotice->pNoticeReference,
                                                            &m_pINoticeNumbers)))
                {
                    DebugTrace("Error [%#x]: CreateNoticeNumbersObject() failed.\n", hr);
                    goto ErrorExit;
                }
            }
        }

        //
        // Do we have explicit display text?
        //
        if (pUserNotice->pszDisplayText)
        {
            if (!(m_bstrExplicitText = pUserNotice->pszDisplayText))
            {
                hr = E_OUTOFMEMORY;

                DebugTrace("Error [%#x]: m_bstrExplicitText = pUserNotice->pszDisplayText failed.\n", hr);
                goto ErrorExit;
            }
        }
    }
    else
    {
        DebugTrace("Info: Policy Qualifier (%s) is not recognized.\n", pQualifier->pszPolicyQualifierId);
    }

CommonExit:
    //
    // Free resources.
    //
    if (DataBlob.pbData)
    {
        ::CoTaskMemFree(DataBlob.pbData);
    }

    DebugTrace("Leaving CQualifier::Init().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resources.
    //
    if (m_pIOID)
    {
        m_pIOID.Release();
    }
    if (m_pINoticeNumbers)
    {
        m_pINoticeNumbers.Release();
    }
    m_bstrCPSPointer.Empty();
    m_bstrOrganizationName.Empty();
    m_bstrExplicitText.Empty();

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\recipients.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000.

  File:    Recipients.cpp

  Content: Implementation of CRecipients.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "Recipients.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateRecipientsObject

  Synopsis : Create and initialize an IRecipients collection object.

  Parameter: IRecipients ** ppIRecipients - Pointer to pointer to IRecipients 
                                            to receive the interface pointer.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateRecipientsObject (IRecipients ** ppIRecipients)
{
    HRESULT hr = S_OK;
    CComObject<CRecipients> * pCRecipients = NULL;

    DebugTrace("Entering CreateRecipientsObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(NULL != ppIRecipients);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CRecipients>::CreateInstance(&pCRecipients)))
        {
            DebugTrace("Error [%#x]: CComObject<CRecipients>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return IRecipients pointer to caller.
        //
        if (FAILED(hr = pCRecipients->QueryInterface(ppIRecipients)))
        {
            DebugTrace("Error [%#x]: pCRecipients->QueryInterface().\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreateRecipientsObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (pCRecipients)
    {
        delete pCRecipients;
    }

    goto CommonExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// CRecipients
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CRecipients::Add

  Synopsis : Add a recipient to the collection.

  Parameter: ICertificate * pVal - Recipient to be added.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CRecipients::Add (ICertificate * pVal)
{
    HRESULT  hr = S_OK;
    char     szIndex[33];
    CComBSTR bstrIndex;
    PCCERT_CONTEXT pCertContext = NULL;

    DebugTrace("Entering CRecipients::Add().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure we have a valid cert by getting the CERT_CONTEXT.
        //
        if (FAILED(hr = ::GetCertContext(pVal, &pCertContext)))
        {
            DebugTrace("Error [%#x]: GetCertContext() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Free the CERT_CONTEXT.
        //
        if (!::CertFreeCertificateContext(pCertContext))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertFreeCertificateContext() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // If we don't have room to use numeric index, force to use thumbprint.
        //
        if ((m_dwNextIndex + 1) > m_coll.max_size())
        {
            if (FAILED(hr = pVal->get_Thumbprint(&bstrIndex)))
            {
                DebugTrace("Error [%#x]: pVal->get_Thumbprint() failed.\n", hr);
                goto ErrorExit;
            }
        }
        else
        {
            //
            // BSTR index of numeric value.
            //
            wsprintfA(szIndex, "%#08x", ++m_dwNextIndex);

            if (!(bstrIndex = szIndex))
            {
                hr = E_OUTOFMEMORY;

                DebugTrace("Error [%#x]: bstrIndex = szIndex failed.\n", hr);
                goto ErrorExit;
            }
        }

        //
        // Now add object to collection map.
        //
        // Note that the overloaded = operator for CComPtr will
        // automatically AddRef to the object. Also, when the CComPtr
        // is deleted (happens when the Remove or map destructor is called), 
        // the CComPtr destructor will automatically Release the object.
        //
        m_coll[bstrIndex] = pVal;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CRecipients::Add().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CRecipients::Remove

  Synopsis : Remove a recipient from the collection.

  Parameter: long Index - Recipient index (1-based).

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CRecipients::Remove (long Index)
{
    HRESULT  hr = S_OK;
    RecipientMap::iterator iter;

    DebugTrace("Entering CRecipients::Remove().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure parameter is valid.
        //
        if (Index < 1 || (DWORD) Index > m_coll.size())
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter Index (%#d) is out of range.\n", hr, Index);
            goto ErrorExit;
        }

        //
        // Find object in map.
        //
        Index--;
        iter = m_coll.begin(); 
        
        while (iter != m_coll.end() && Index > 0)
        {
             iter++; 
             Index--;
        }

        //
        // This should not happen.
        //
        if (iter == m_coll.end())
        {
            hr = CAPICOM_E_INTERNAL;

            DebugTrace("Unexpected internal error [%#x]: iterator went pass end of map.\n", hr);
            goto ErrorExit;
        }

        //
        // Now remove object in map.
        //
        m_coll.erase(iter);
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CRecipients::Remove().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CRecipients::Clear

  Synopsis : Remove all recipients from the collection.

  Parameter: None.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CRecipients::Clear (void)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CRecipients::Clear().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Clear it.
        //
        m_coll.clear();
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CRecipients::Clear().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\qualifier.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Qualifier.h

  Content: Declaration of the CQualifier.

  History: 11-15-2001    dsie     created

------------------------------------------------------------------------------*/

#ifndef __QUALIFIER_H_
#define __QUALIFIER_H_

#include "Resource.h"
#include "Lock.h"
#include "Error.h"
#include "Debug.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateQualifierObject

  Synopsis : Create and initialize an CQualifier object.

  Parameter: PCERT_POLICY_QUALIFIER_INFO pQualifier - Pointer to qualifier.
  
             IQualifier ** ppIQualifier - Pointer to pointer IQualifier object.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateQualifierObject (PCERT_POLICY_QUALIFIER_INFO pQualifier, 
                               IQualifier               ** ppIQualifier);

////////////////////////////////////////////////////////////////////////////////
//
// CQualifier
//
class ATL_NO_VTABLE CQualifier : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CQualifier, &CLSID_Qualifier>,
    public ICAPICOMError<CQualifier, &IID_IQualifier>,
    public IDispatchImpl<IQualifier, &IID_IQualifier, &LIBID_CAPICOM,
                         CAPICOM_MAJOR_VERSION, CAPICOM_MINOR_VERSION>
{
public:
    CQualifier()
    {
    }

DECLARE_NO_REGISTRY()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CQualifier)
    COM_INTERFACE_ENTRY(IQualifier)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CQualifier)
END_CATEGORY_MAP()

    HRESULT FinalConstruct()
    {
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for Qualifier object.\n", hr);
            return hr;
        }

        m_pIOID = NULL;
        m_pINoticeNumbers = NULL;
        m_bstrCPSPointer.Empty();
        m_bstrOrganizationName.Empty();
        m_bstrExplicitText.Empty();

        return S_OK;
    }

    void FinalRelease()
    {
        m_pIOID.Release();
        m_pINoticeNumbers.Release();
    }

//
// IQualifier
//
public:
    STDMETHOD(get_OID)
        (/*[out, retval]*/ IOID ** pVal);

    STDMETHOD(get_CPSPointer)
        (/*[out, retval]*/ BSTR * pVal);

    STDMETHOD(get_OrganizationName)
        (/*[out, retval]*/ BSTR * pVal);

    STDMETHOD(get_NoticeNumbers)
        (/*[out, retval]*/ INoticeNumbers ** pVal);

    STDMETHOD(get_ExplicitText)
        (/*[out, retval]*/ BSTR * pVal);

    //
    // None COM functions.
    //
    STDMETHOD(Init)
        (PCERT_POLICY_QUALIFIER_INFO pQualifier);

private:
    CLock                   m_Lock;
    CComPtr<IOID>           m_pIOID;
    CComPtr<INoticeNumbers> m_pINoticeNumbers;
    CComBSTR                m_bstrCPSPointer;
    CComBSTR                m_bstrOrganizationName;
    CComBSTR                m_bstrExplicitText;
};

#endif //__QUALIFIER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CAPICOM.rc
//
#define IDS_PROJNAME                                            100
#define IDR_ALGORITHM                                           1000
#define IDR_ATTRIBUTE                                           1010
#define IDR_ATTRIBUTES                                          1020
#define IDR_BASICCONSTRAINTS                                    1030
#define IDR_CERTIFICATE                                         1040
#define IDR_CERTIFICATES                                        1050
#define IDR_CERTIFICATESTATUS                                   1060
#define IDR_CHAIN                                               1070
#define IDR_EKU                                                 1080
#define IDR_EKUS                                                1090
#define IDR_NOTICENUMBERS                                       1100
#define IDR_QUALIFIER                                           1110
#define IDR_QUALIFIERS                                          1120
#define IDR_POLICYINFORMATION                                   1130
#define IDR_CERTIFICATEPOLICIES                                 1140
#define IDR_ENCODEDDATA                                         1150
#define IDR_ENCRYPTEDDATA                                       1160
#define IDR_ENVELOPEDDATA                                       1170
#define IDR_EXTENDEDKEYUSAGE                                    1180
#define IDR_EXTENDEDPROPERTY                                    1190
#define IDR_EXTENDEDPROPERTIES                                  1200
#define IDR_EXTENSION                                           1210
#define IDR_EXTENSIONS                                          1220
#define IDR_KEYUSAGE                                            1230
#define IDR_OID                                                 1240
#define IDR_PRIVATEKEY                                          1250
#define IDR_PUBLICKEY                                           1260
#define IDR_RECIPIENTS                                          1270
#define IDR_SETTINGS                                            1280
#define IDR_SIGNEDDATA                                          1290
#define IDR_SIGNEDCODE                                          1300
#define IDR_SIGNER                                              1310
#define IDR_SIGNERS                                             1320
#define IDR_STORE                                               1330
#define IDR_TEMPLATE                                            1340
#define IDR_HASHEDDATA                                          1350
#define IDR_UTILITIES                                           1360
#define IDR_OIDS                                                1370
#define IDC_SEPARATORLINE                                       2000
#define IDC_DLG_NO_SHOW_AGAIN                                   2010
#define IDD_STORE_OPEN_SECURITY_ALERT_DLG                       4000
#define IDD_STORE_ADD_SECURITY_ALERT_DLG                        4010
#define IDD_STORE_REMOVE_SECURITY_ALERT_DLG                     4020
#define IDD_SIGN_SECURITY_ALERT_DLG                             4030
#define IDD_DECRYPT_SECURITY_ALERT_DLG                          4040
#define IDS_STORE_OPEN_PROMPT_STRING                            5000
#define IDS_STORE_ADD_PROMPT_STRING                             5010
#define IDS_STORE_REMOVE_PROMPT_STRING                          5020
#define IDS_SIGN_PROMPT_STRING                                  5030
#define IDS_DECRYPT_PROMPT_STRING                               5040
#define IDS_CAPICOM_E_ENCODE_INVALID_TYPE                       5100
#define IDS_CAPICOM_E_EKU_INVALID_OID                           5200
#define IDS_CAPICOM_E_EKU_OID_NOT_INITIALIZED                   5201
#define IDS_CAPICOM_E_CERTIFICATE_NOT_INITIALIZED               5210
#define IDS_CAPICOM_E_CERTIFICATE_NO_PRIVATE_KEY                5211
#define IDS_CAPICOM_E_CHAIN_NOT_BUILT                           5220
#define IDS_CAPICOM_E_STORE_NOT_OPENED                          5230
#define IDS_CAPICOM_E_STORE_EMPTY                               5231
#define IDS_CAPICOM_E_STORE_INVALID_OPEN_MODE                   5232
#define IDS_CAPICOM_E_STORE_INVALID_SAVE_AS_TYPE                5233
#define IDS_CAPICOM_E_ATTRIBUTE_NAME_NOT_INITIALIZED            5240
#define IDS_CAPICOM_E_ATTRIBUTE_VALUE_NOT_INITIALIZED           5241
#define IDS_CAPICOM_E_ATTRIBUTE_INVALID_NAME                    5242
#define IDS_CAPICOM_E_ATTRIBUTE_INVALID_VALUE                   5243
#define IDS_CAPICOM_E_SIGNER_NOT_INITIALIZED                    5250
#define IDS_CAPICOM_E_SIGNER_NOT_FOUND                          5251
#define IDS_CAPICOM_E_SIGNER_NO_CHAIN                           5252
#define IDS_CAPICOM_E_SIGNER_INVALID_USAGE                      5253
#define IDS_CAPICOM_E_SIGN_NOT_INITIALIZED                      5260
#define IDS_CAPICOM_E_SIGN_INVALID_TYPE                         5261
#define IDS_CAPICOM_E_SIGN_NOT_SIGNED                           5262
#define IDS_CAPICOM_E_INVALID_ALGORITHM                         5270
#define IDS_CAPICOM_E_INVALID_KEY_LENGTH                        5271
#define IDS_CAPICOM_E_ENVELOP_NOT_INITIALIZED                   5280
#define IDS_CAPICOM_E_ENVELOP_INVALID_TYPE                      5281
#define IDS_CAPICOM_E_ENVELOP_NO_RECIPIENT                      5282
#define IDS_CAPICOM_E_ENVELOP_RECIPIENT_NOT_FOUND               5283
#define IDS_CAPICOM_E_ENCRYPT_NOT_INITIALIZED                   5290
#define IDS_CAPICOM_E_ENCRYPT_INVALID_TYPE                      5291
#define IDS_CAPICOM_E_ENCRYPT_NO_SECRET                         5292
#define IDS_CAPICOM_E_PRIVATE_KEY_NOT_INITIALIZED               5300
#define IDS_CAPICOM_E_PRIVATE_KEY_NOT_EXPORTABLE                5301
#define IDS_CAPICOM_E_ENCODE_NOT_INITIALIZED                    5320
#define IDS_CAPICOM_E_EXTENSION_NOT_INITIALIZED                 5330
#define IDS_CAPICOM_E_PROPERTY_NOT_INITIALIZED                  5340
#define IDS_CAPICOM_E_FIND_INVALID_TYPE                         5350
#define IDS_CAPICOM_E_FIND_INVALID_PREDEFINED_POLICY            5351
#define IDS_CAPICOM_E_CODE_NOT_INITIALIZED                      5360
#define IDS_CAPICOM_E_CODE_NOT_SIGNED                           5361
#define IDS_CAPICOM_E_CODE_DESCRIPTION_NOT_INITIALIZED          5362
#define IDS_CAPICOM_E_CODE_DESCRIPTION_URL_NOT_INITIALIZED      5363
#define IDS_CAPICOM_E_CODE_INVALID_TIMESTAMP_URL                5364
#define IDS_CAPICOM_E_HASH_NO_DATA                              5370
#define IDS_CAPICOM_E_INVALID_CONVERT_TYPE                      5380
#define IDS_CAPICOM_E_NOT_SUPPORTED                             5900
#define IDS_CAPICOM_E_UI_DISABLED                               5901
#define IDS_CAPICOM_E_CANCELLED                                 5902
#define IDS_CAPICOM_E_NOT_ALLOWED                               5903
#define IDS_CAPICOM_E_OUT_OF_RESOURCE                           5904
#define IDS_CAPICOM_E_INTERNAL                                  5911
#define IDS_CAPICOM_E_UNKNOWN                                   5999
#define IDC_EDIT1                                               8000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        7000
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         8001
#define _APS_NEXT_SYMED_VALUE           9000
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\recipients.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Recipients.h

  Content: Declaration of CRecipients.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/
    
#ifndef __RECIPIENTS_H_
#define __RECIPIENTS_H_

#include "Resource.h"
#include "Lock.h"
#include "Error.h"
#include "Debug.h"
#include "Certificate.h"

////////////////////
//
// Locals
//

//
// typdefs to make life easier.
//
typedef std::map<CComBSTR, CComPtr<ICertificate> > RecipientMap;
typedef CComEnumOnSTL<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _CopyMapItem<ICertificate>, RecipientMap> RecipientEnum;
typedef ICollectionOnSTLImpl<IRecipients, RecipientMap, VARIANT, _CopyMapItem<ICertificate>, RecipientEnum> IRecipientsCollection;


////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateRecipientsObject

  Synopsis : Create and initialize an IRecipients collection object.

  Parameter: IRecipients ** ppIRecipients - Pointer to pointer to IRecipients 
                                            to receive the interface pointer.
             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateRecipientsObject (IRecipients ** ppIRecipients);


////////////////////////////////////////////////////////////////////////////////
//
// CRecipients
//

class ATL_NO_VTABLE CRecipients : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CRecipients, &CLSID_Recipients>,
    public ICAPICOMError<CRecipients, &IID_IRecipients>,
    public IDispatchImpl<IRecipientsCollection, &IID_IRecipients, &LIBID_CAPICOM,
                         CAPICOM_MAJOR_VERSION, CAPICOM_MINOR_VERSION>
{
public:
    CRecipients()
    {
    }

DECLARE_NO_REGISTRY()

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CRecipients)
    COM_INTERFACE_ENTRY(IRecipients)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CRecipients)
END_CATEGORY_MAP()

    HRESULT FinalConstruct()
    {
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for Recipients object.\n", hr);
            return hr;
        }

        m_dwNextIndex = 0;

        return S_OK;
    }

//
// IRecipients
//
public:
    //
    // These are the only ones that we need to implemented, others will be
    // handled by ATL ICollectionOnSTLImpl.
    //
    STDMETHOD(Clear)
        (void);

    STDMETHOD(Remove)
        (/*[in]*/ long Index);

    STDMETHOD(Add)
        (/*[in]*/ ICertificate * pVal);

private:
    CLock   m_Lock;
    DWORD   m_dwNextIndex;
};

#endif //__RECIPIENTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\settings.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Settings.h

  Content: Declaration of CSettings class.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#ifndef __SETTINGS_H_
#define __SETTINGS_H_

#include "Resource.h"
#include "Error.h"
#include "Lock.h"
#include "Debug.h"

///////////////
//
// Global
//

#define PromptForCertificateEnabled()               (g_bPromptCertificateUI)
#define ActiveDirectorySearchLocation()             (g_ADSearchLocation)

extern VARIANT_BOOL                                 g_bPromptCertificateUI;
extern CAPICOM_ACTIVE_DIRECTORY_SEARCH_LOCATION     g_ADSearchLocation;

////////////////////////////////////////////////////////////////////////////////
//
// CSettings
//

class ATL_NO_VTABLE CSettings : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSettings, &CLSID_Settings>,
    public ICAPICOMError<CSettings, &IID_ISettings>,
    public IDispatchImpl<ISettings, &IID_ISettings, &LIBID_CAPICOM,
                         CAPICOM_MAJOR_VERSION, CAPICOM_MINOR_VERSION>,
    public IObjectSafetyImpl<CSettings, INTERFACESAFE_FOR_UNTRUSTED_CALLER | 
                                        INTERFACESAFE_FOR_UNTRUSTED_DATA>
{
public:
    CSettings()
    {
    }

DECLARE_REGISTRY_RESOURCEID(IDR_SETTINGS)

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSettings)
    COM_INTERFACE_ENTRY(ISettings)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CSettings)
    IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
    IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
END_CATEGORY_MAP()

    HRESULT FinalConstruct()
    {
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for Settings object.\n", hr);
            return hr;
        }

        return S_OK;
    }

    void FinalRelease()
    {
    }

//
// ISettings
//
public:
    STDMETHOD(get_EnablePromptForCertificateUI)
        (/*[out, retval]*/ VARIANT_BOOL * pVal);

    STDMETHOD(put_EnablePromptForCertificateUI)
        (/*[in, defaultvalue(0)]*/ VARIANT_BOOL newVal);

    STDMETHOD(get_ActiveDirectorySearchLocation)
        (/*[out, retval]*/ CAPICOM_ACTIVE_DIRECTORY_SEARCH_LOCATION * pVal);

    STDMETHOD(put_ActiveDirectorySearchLocation)
        (/*[in, defaultvalue(SEARCH_LOCATION_UNSPECIFIED)]*/ CAPICOM_ACTIVE_DIRECTORY_SEARCH_LOCATION Val);

private:
    CLock m_Lock;
};

#endif //__SETTINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\settings.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:      Settings.cpp

  Contents:  Implementation of CSettings class.

  Remarks:

  History:   11-15-99    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "Settings.h"

///////////////
//
// Global
//

VARIANT_BOOL g_bPromptCertificateUI                         = VARIANT_TRUE;
CAPICOM_ACTIVE_DIRECTORY_SEARCH_LOCATION g_ADSearchLocation = CAPICOM_SEARCH_ANY;

////////////////////////////////////////////////////////////////////////////////
//
// CSettings
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSettings::get_EnablePromptForCertificateUI

  Synopsis : Get current EnablePromptForCertificateUI setting.

  Parameter: VARIANT_BOOL * pVal - Pointer to VARIANT_BOOL to receive result.

  Remark   :
  
------------------------------------------------------------------------------*/

STDMETHODIMP CSettings::get_EnablePromptForCertificateUI (VARIANT_BOOL * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CSettings::get_EnablePromptForCertificateUI().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Return it.
        //
        *pVal = g_bPromptCertificateUI;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CSettings::get_EnablePromptForCertificateUI().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSettings::put_EnablePromptForCertificateUI

  Synopsis : Set EnablePromptForCertificateUI setting.

  Parameter: VARIANT_BOOL newVal - VARIANT_TRUE to enable UI or VARAINT_FALSE
                                   to disable.

  Remark   :
  
------------------------------------------------------------------------------*/

STDMETHODIMP CSettings::put_EnablePromptForCertificateUI (VARIANT_BOOL newVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CSettings::put_EnablePromptForCertificateUI().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    //
    // Set it.
    //
    g_bPromptCertificateUI = newVal ? VARIANT_TRUE : VARIANT_FALSE;

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CSettings::put_EnablePromptForCertificateUI().\n");

    return hr;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSettings::get_ActiveDirectorySearchLocation

  Synopsis : Get current ActiveDirectorySearchLocation setting.

  Parameter: CAPICOM_ACTIVE_DIRECTORY_SEARCH_LOCATION * pVal - Pointer to variable
                                                               to receive result.

  Remark   :
  
------------------------------------------------------------------------------*/

STDMETHODIMP CSettings::get_ActiveDirectorySearchLocation (
        CAPICOM_ACTIVE_DIRECTORY_SEARCH_LOCATION * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CSettings::get_ActiveDirectorySearchLocation().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Return it.
        //
        *pVal = g_ADSearchLocation;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CSettings::get_ActiveDirectorySearchLocation().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSettings::put_ActiveDirectorySearchLocation

  Synopsis : Set ActiveDirectorySearchLocation setting.

  Parameter: CAPICOM_ACTIVE_DIRECTORY_SEARCH_LOCATION newVal - AD search location.

  Remark   :
  
------------------------------------------------------------------------------*/

STDMETHODIMP CSettings::put_ActiveDirectorySearchLocation (
        CAPICOM_ACTIVE_DIRECTORY_SEARCH_LOCATION newVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CSettings::put_ActiveDirectorySearchLocation().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    //
    // Make sure parameter is valid.
    //
    switch (newVal)
    {
        case CAPICOM_SEARCH_ANY:

        case CAPICOM_SEARCH_GLOBAL_CATALOG:

        case CAPICOM_SEARCH_DEFAULT_DOMAIN:
        {
            break;
        }

        default:
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Unknown search location (%#x).\n", hr, newVal);
            goto ErrorExit;
        }
    }

    //
    // Set it.
    //
    g_ADSearchLocation = newVal;

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CSettings::put_ActiveDirectorySearchLocation().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\signedcode.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000 - 2001.

  File:    SignedCode.h

  Content: Declaration of the CSignedCode.

  History: 09-07-2001    dsie     created

------------------------------------------------------------------------------*/

#ifndef __SIGNEDCODE_H_
#define __SIGNEDCODE_H_

#include "Resource.h"
#include "Error.h"
#include "Lock.h"
#include "Debug.h"

////////////////////////////////////////////////////////////////////////////////
//
// CSignedCode
//
class ATL_NO_VTABLE CSignedCode : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSignedCode, &CLSID_SignedCode>,
    public ICAPICOMError<CSignedCode, &IID_ISignedCode>,
    public IDispatchImpl<ISignedCode, &IID_ISignedCode, &LIBID_CAPICOM,
                         CAPICOM_MAJOR_VERSION, CAPICOM_MINOR_VERSION>
{
public:
    CSignedCode()
    {
    }

    HRESULT FinalConstruct()
    {
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for SignedCode object.\n", hr);
            return hr;
        }

        m_bHasWTD = FALSE;
        ::ZeroMemory(&m_WinTrustData, sizeof(WINTRUST_DATA));

        return S_OK;
    }

    void FinalRelease()
    {
        if (m_bHasWTD)
        {
            WVTClose();
        }
    }

DECLARE_REGISTRY_RESOURCEID(IDR_SIGNEDCODE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSignedCode)
    COM_INTERFACE_ENTRY(ISignedCode)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//
// ISignedCode
//
public:
    STDMETHOD(get_FileName)
        (/*[out, retval]*/ BSTR * pVal);

    STDMETHOD(put_FileName)
        (/*[in]*/ BSTR newVal);

    STDMETHOD(get_Description)
        (/*[out, retval]*/ BSTR * pVal);

    STDMETHOD(put_Description)
        (/*[in]*/ BSTR newVal);

    STDMETHOD(get_DescriptionURL)
        (/*[out, retval]*/ BSTR * pVal);

    STDMETHOD(put_DescriptionURL)
        (/*[in]*/ BSTR newVal);

    STDMETHOD(get_Signer)
        (/*[out, retval]*/ ISigner2 ** pVal);

    STDMETHOD(get_TimeStamper)
        (/*[out, retval]*/ ISigner2 ** pVal);

    STDMETHOD(get_Certificates)
        (/*[out, retval]*/ ICertificates2 ** pVal);

    STDMETHOD(Sign)
        (/*[in]*/ ISigner2 * pSigner2);

    STDMETHOD(Timestamp)
        (/*[in]*/ BSTR URL);

    STDMETHOD(Verify)
        (/*[in, defaultvalue(0)]*/ VARIANT_BOOL bUIAllowed);

private:
    CLock           m_Lock;
    BOOL            m_bHasWTD;
    WINTRUST_DATA   m_WinTrustData;
    CComBSTR        m_bstrFileName;
    CComBSTR        m_bstrDescription;
    CComBSTR        m_bstrDescriptionURL;

    STDMETHOD(WVTVerify)
        (DWORD dwUIChoice,
         DWORD dwProvFlags);

    STDMETHOD(WVTOpen)
        (PCRYPT_PROVIDER_DATA * ppProvData);

    STDMETHOD(WVTClose)
        (void);
};

#endif //__SIGNEDCODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\signedcode.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000 - 2001.

  File:    SignedCode.cpp

  Content: Implementation of CSignedCode

  History: 09-07-2001    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "SignedCode.h"

#include "Attributes.h"
#include "CertHlpr.h"
#include "Certificates.h"
#include "Chain.h"
#include "Common.h"
#include "Policy.h"
#include "Settings.h"
#include "SignHlpr.h"
#include "Signer2.h"

////////////////////////////////////////////////////////////////////////////////
//
// typedefs.
//

typedef BOOL (WINAPI * PCRYPTUIWIZDIGITALSIGN)(
     IN                 DWORD                               dwFlags,
     IN     OPTIONAL    HWND                                hwndParent,
     IN     OPTIONAL    LPCWSTR                             pwszWizardTitle,
     IN                 PCCRYPTUI_WIZ_DIGITAL_SIGN_INFO     pDigitalSignInfo,
     OUT    OPTIONAL    PCCRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT  *ppSignContext);

////////////////////////////////////////////////////////////////////////////////
//
// Local functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : FreeSignerSignInfo

  Synopsis : Free all memory allocated for the CRYPTUI_WIZ_DIGITAL_SIGN_INFO 
             structure, including any memory allocated for members of the
             structure.

  Parameter: CRYPTUI_WIZ_DIGITAL_SIGN_INFO * pSignInfo

  Remark   :

------------------------------------------------------------------------------*/

static void FreeSignerSignInfo (CRYPTUI_WIZ_DIGITAL_SIGN_INFO * pSignInfo)
{
    DebugTrace("Entering FreeSignerSignInfo().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pSignInfo);

    //
    // First free the authenticated attributes array, if present.
    // 
    if (pSignInfo->pSignExtInfo)
    {
        if (pSignInfo->pSignExtInfo->psAuthenticated)
        {
            ::FreeAttributes(pSignInfo->pSignExtInfo->psAuthenticated);

            ::CoTaskMemFree((PVOID) pSignInfo->pSignExtInfo->psAuthenticated);
        }

        ::CoTaskMemFree((PVOID) pSignInfo->pSignExtInfo);

        if (pSignInfo->pSignExtInfo->hAdditionalCertStore)
        {
            ::CertCloseStore(pSignInfo->pSignExtInfo->hAdditionalCertStore, 0);
        }
    }

    ::ZeroMemory(pSignInfo, sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_INFO));

    DebugTrace("Leaving FreeSignerSignInfo().\n");

    return;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : InitSignerSignInfo

  Synopsis : Initialize the signer info for code signing.

  Parameter: ISigner2 * pISigner2

             ICertificate * pICertificate
  
             PCCERT_CONTEXT pCertContext
  
             LPWSTR pwszFileName

             LPWSTR pwszDescription

             LPWSTR pwszDescriptionURL

             CRYPTUI_WIZ_DIGITAL_SIGN_INFO * pSignInfo

  Remark   :

------------------------------------------------------------------------------*/

static HRESULT InitSignerSignInfo(ISigner2                      * pISigner2,
                                  ICertificate                  * pICertificate,
                                  PCCERT_CONTEXT                  pCertContext,
                                  LPWSTR                          pwszFileName,
                                  LPWSTR                          pwszDescription,
                                  LPWSTR                          pwszDescriptionURL,
                                  CRYPTUI_WIZ_DIGITAL_SIGN_INFO * pSignInfo)
{
    HRESULT           hr                   = S_OK;
    PCRYPT_ATTRIBUTES pAuthAttr            = NULL;
    CComPtr<ISigner>  pISigner             = NULL;
    HCERTSTORE        hAdditionalCertStore = NULL;
    CRYPT_DATA_BLOB   ChainBlob            = {0, NULL};
    PCCERT_CONTEXT  * rgCertContext        = NULL;
    CComPtr<IChain>   pIChain              = NULL;
    CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO * pSignExtendedInfo = NULL;
    CAPICOM_CERTIFICATE_INCLUDE_OPTION IncludeOption = CAPICOM_CERTIFICATE_INCLUDE_CHAIN_EXCEPT_ROOT;

    DWORD i;

    DebugTrace("Entering InitSignerSignInfo().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pISigner2);
    ATLASSERT(pCertContext);
    ATLASSERT(pwszFileName);
    ATLASSERT(pSignInfo);

    //
    // Intialize.
    //
    ::ZeroMemory(pSignInfo, sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_INFO));

    //
    // QI for ISigner.
    //
    if (FAILED(hr = pISigner2->QueryInterface(__uuidof(ISigner), (void **) &pISigner)))
    {
        DebugTrace("Error [%#x]: pISigner2->QueryInterface() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Get authenticated attributes.
    //
    if (!(pAuthAttr = (PCRYPT_ATTRIBUTES) ::CoTaskMemAlloc(sizeof(CRYPT_ATTRIBUTES))))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Error: out of memory.\n");
        goto ErrorExit;
    }

    ::ZeroMemory(pAuthAttr, sizeof(CRYPT_ATTRIBUTES));

    if (FAILED(hr = ::GetAuthenticatedAttributes(pISigner, pAuthAttr)))
    {
        DebugTrace("Error [%#x]: GetAuthenticatedAttributes() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Get signer option flag.
    //
    if (FAILED(hr = pISigner2->get_Options(&IncludeOption)))
    {
        DebugTrace("Error [%#x]: pISigner2->get_Options() failed.\n", hr);
        goto ErrorExit;
    }

#if (1)
    //
    // If we need more than just the end cert, then build the chain
    // utilizing the additional store.
    //
    if (CAPICOM_CERTIFICATE_INCLUDE_END_ENTITY_ONLY != IncludeOption)
    {
        //
        // Get signer's additional store.
        //
        if (FAILED(hr = ::GetSignerAdditionalStore(pISigner2, &hAdditionalCertStore)))
        {
            DebugTrace("Error [%#x]: GetSignerAdditionalStore() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // If we were given additional store, then filter out any certs that
        // would not be included based on the include options.
        //
        if (NULL != hAdditionalCertStore)
        {
            DWORD cCertContext;
            VARIANT_BOOL bResult;

            //
            // Create a chain object.
            //
            if (FAILED(hr = ::CreateChainObject(pICertificate,
                                                hAdditionalCertStore,
                                                &bResult,
                                                &pIChain)))
            {
                DebugTrace("Error [%#x]: CreateChainObject() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Get the chain of certs.
            //
            if (FAILED(hr = ::GetChainContext(pIChain, &ChainBlob)))
            {
                DebugTrace("Error [%#x]: GetChainContext() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Rebuild additional store.
            //
            ::CertCloseStore(hAdditionalCertStore, 0);

            if (!(hAdditionalCertStore = ::CertOpenStore(CERT_STORE_PROV_MEMORY,
                                                         CAPICOM_ASN_ENCODING,
                                                         NULL,
                                                         CERT_STORE_CREATE_NEW_FLAG,
                                                         NULL)))
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());

                DebugTrace("Error [%#x]: CertOpenStore() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Determine number of cert(s) to include in the bag.
            //
            cCertContext = ChainBlob.cbData;

            if ((CAPICOM_CERTIFICATE_INCLUDE_CHAIN_EXCEPT_ROOT == IncludeOption) &&
                (1 < cCertContext))
            {
                cCertContext--;
            }

            for (i = 0, rgCertContext = (PCCERT_CONTEXT *) ChainBlob.pbData; i < cCertContext; i++)
            {
                if (!::CertAddCertificateContextToStore(hAdditionalCertStore, 
                                                        rgCertContext[i], 
                                                        CERT_STORE_ADD_USE_EXISTING, 
                                                        NULL))
                {
                    hr = HRESULT_FROM_WIN32(::GetLastError());

                    DebugTrace("Error [%#x]: CertOpenStore() failed.\n", hr);
                    goto ErrorExit;
                }
            }
        }
    }
#endif

    //
    // Setup CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO structure.
    //
    if (NULL == (pSignExtendedInfo = (CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO *) 
                                     ::CoTaskMemAlloc(sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO))))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Error: out of memory.\n");
        goto ErrorExit;
    }

    ::ZeroMemory(pSignExtendedInfo, sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO));
    pSignExtendedInfo->dwSize = sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO);
    pSignExtendedInfo->pwszDescription = pwszDescription;
    pSignExtendedInfo->pwszMoreInfoLocation = pwszDescriptionURL;
    pSignExtendedInfo->psAuthenticated = pAuthAttr->cAttr ? pAuthAttr : NULL;
    pSignExtendedInfo->hAdditionalCertStore = hAdditionalCertStore;

    //
    // Setup CRYPTUI_WIZ_DIGITAL_SIGN_INFO structure.
    //
    pSignInfo->dwSize = sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_INFO);
    pSignInfo->dwSubjectChoice = CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_FILE;
    pSignInfo->pwszFileName = pwszFileName;
    pSignInfo->dwSigningCertChoice = CRYPTUI_WIZ_DIGITAL_SIGN_CERT;
    pSignInfo->pSigningCertContext = pCertContext;
    switch (IncludeOption)
    {
        case CAPICOM_CERTIFICATE_INCLUDE_END_ENTITY_ONLY:
        {
            pSignInfo->dwAdditionalCertChoice = 0;
            break;
        }
        
        case CAPICOM_CERTIFICATE_INCLUDE_WHOLE_CHAIN:
        {
            pSignInfo->dwAdditionalCertChoice = CRYPTUI_WIZ_DIGITAL_SIGN_ADD_CHAIN;
            break;
        }

        case CAPICOM_CERTIFICATE_INCLUDE_CHAIN_EXCEPT_ROOT:
            //
            // Fall thru to default.
            //
        default:
        {
            pSignInfo->dwAdditionalCertChoice = CRYPTUI_WIZ_DIGITAL_SIGN_ADD_CHAIN_NO_ROOT ;
            break;
        }
    }

    pSignInfo->pSignExtInfo = pSignExtendedInfo;

CommonExit:
    //
    // Free resources.
    //
    if (ChainBlob.cbData && ChainBlob.pbData)
    {
        for (i = 0, rgCertContext = (PCCERT_CONTEXT *) ChainBlob.pbData; i < ChainBlob.cbData; i++)
        {
            ATLASSERT(rgCertContext[i]);

            ::CertFreeCertificateContext(rgCertContext[i]);
        }

        ::CoTaskMemFree((LPVOID) ChainBlob.pbData);
    }

    DebugTrace("Leaving InitSignerSignInfo().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resources.
    //
    if (pSignExtendedInfo)
    {
        ::CoTaskMemFree(pSignExtendedInfo);
    }

    if (pAuthAttr)
    {
       ::FreeAttributes(pAuthAttr);

        ::CoTaskMemFree(pAuthAttr);
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : FreeSignerSubjectInfo

  Synopsis : Free all memory allocated for the SIGNER_SUBJECT_INFO
             structure, including any memory allocated for members of the
             structure.

  Parameter: SIGNER_SUBJECT_INFO * pSubjectInfo

  Remark   :

------------------------------------------------------------------------------*/

static void FreeSignerSubjectInfo (SIGNER_SUBJECT_INFO * pSubjectInfo)
{
    DebugTrace("Entering FreeSignerSubjectInfo().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pSubjectInfo);

    //
    // First free the file info structure.
    // 
    if (pSubjectInfo->pSignerFileInfo)
    {
       ::CoTaskMemFree((PVOID) pSubjectInfo->pSignerFileInfo);
    }

    ::ZeroMemory(pSubjectInfo, sizeof(SIGNER_SUBJECT_INFO));

    DebugTrace("Leaving FreeSignerSubjectInfo().\n");

    return;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : InitSignerSubjectInfo

  Synopsis : Initialize the subject info for timestamping.

  Parameter: LPWSTR pwszFileName

             SIGNER_SUBJECT_INFO * pSubjectInfo

  Remark   :

------------------------------------------------------------------------------*/

static HRESULT InitSignerSubjectInfo (LPWSTR                pwszFileName,
                                      SIGNER_SUBJECT_INFO * pSubjectInfo)
{
    HRESULT hr = S_OK;
    static DWORD dwSignerIndex = 0;
    SIGNER_FILE_INFO * pFileInfo = NULL;

    DebugTrace("Entering InitSignerSubjectInfo().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pwszFileName);
    ATLASSERT(pSubjectInfo);

    //
    // Allocate memory for SIGNER_FILE_INFO.
    //
    if (!(pFileInfo = (SIGNER_FILE_INFO *) ::CoTaskMemAlloc(sizeof(SIGNER_FILE_INFO))))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Error: out of memory.\n");
        goto ErrorExit;
    }

    //
    // Initialize.
    //
    ::ZeroMemory(pFileInfo, sizeof(SIGNER_FILE_INFO));
    pFileInfo->cbSize = sizeof(SIGNER_FILE_INFO);
    pFileInfo->pwszFileName = pwszFileName;

    ::ZeroMemory(pSubjectInfo, sizeof(SIGNER_SUBJECT_INFO));
    pSubjectInfo->cbSize = sizeof(SIGNER_SUBJECT_INFO);
    pSubjectInfo->pdwIndex = &dwSignerIndex;
    pSubjectInfo->dwSubjectChoice = SIGNER_SUBJECT_FILE;
    pSubjectInfo->pSignerFileInfo = pFileInfo;   

CommonExit:

    DebugTrace("Leaving InitSignerSubjectInfo().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resources.
    //
    if (pFileInfo)
    {
        ::CoTaskMemFree((LPVOID) pFileInfo);
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : GetOpusInfo

  Synopsis : Get the OPUS info structure.

  Parameter: PCRYPT_PROVIDER_DATA pProvData - Pointer to CRYPT_PROV_DATA.

             PSPC_SP_OPUS_INFO * ppOpusInfo - Pointer to receive PSPC_SP_OPUS_INFO.

  Remark   : Caller must call CoTaskMemFree() for PSPC_SP_OPUS_INFO.

------------------------------------------------------------------------------*/

static HRESULT GetOpusInfo (CRYPT_PROVIDER_DATA * pProvData,
                            PSPC_SP_OPUS_INFO   * ppOpusInfo)
{
    HRESULT              hr       = S_OK;
    PCRYPT_PROVIDER_SGNR pSigner  = NULL;
    PCRYPT_ATTRIBUTE     pAttr    = NULL;
    CRYPT_DATA_BLOB      DataBlob = {0, NULL};

    DebugTrace("Entering GetOpusInfo().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pProvData);

    //
    // Get signer.
    //
    pSigner = WTHelperGetProvSignerFromChain((PCRYPT_PROVIDER_DATA) pProvData, 0, FALSE, 0);
    if (!pSigner || !pSigner->psSigner)
    {
        hr = CAPICOM_E_CODE_NOT_SIGNED;

        DebugTrace("Error [%#x]: code has not been signed.\n", hr);
        goto ErrorExit;
    }

    //
    // Find the OPUS INFO attribute.
    //
    if ((0 == pSigner->psSigner->AuthAttrs.cAttr) ||
        (NULL == (pAttr = ::CertFindAttribute(SPC_SP_OPUS_INFO_OBJID,
                                              pSigner->psSigner->AuthAttrs.cAttr,
                                              pSigner->psSigner->AuthAttrs.rgAttr))) ||
        (NULL == pAttr->rgValue))
    {
        hr = HRESULT_FROM_WIN32(CRYPT_E_NOT_FOUND);

        DebugTrace("Error [%#x]: OPUS attribute not found.\n", hr);
        goto ErrorExit;
    }

    //
    // Now decode the OPUS attribute.
    //
    if (FAILED(hr = ::DecodeObject(SPC_SP_OPUS_INFO_STRUCT,
                                   pAttr->rgValue->pbData,
                                   pAttr->rgValue->cbData,
                                   &DataBlob)))
    {
        DebugTrace("Error [%#x]: DecodeObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Finally return OPUS structure to valler.
    //
    *ppOpusInfo = (PSPC_SP_OPUS_INFO) DataBlob.pbData;

CommonExit:

    DebugTrace("Leaving GetOpusInfo().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resources.
    //
    if (DataBlob.pbData)
    {
        ::CoTaskMemFree(DataBlob.pbData);
    }

    goto CommonExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// CSignedCode
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSignedCode::get_FileName

  Synopsis : Return the filename.

  Parameter: BSTR * pVal - Pointer to BSTR to receive the filename.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CSignedCode::get_FileName(BSTR * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CSignedCode::get_FileName().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Return result.
        //
        if (FAILED(hr = m_bstrFileName.CopyTo(pVal)))
        {
            DebugTrace("Error [%#x]: m_bstrFileName.CopyTo() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CSignedCode::get_FileName().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSignedCode::put_FileName

  Synopsis : Initialize the object with filename of code to be signed.

  Parameter: BSTR newVal - BSTR containing the filename.

  Remark   : Note that this property should not be changed once a signature
             is created, as it will re-initialize the object even in error
             condition, unless that's your intention.

------------------------------------------------------------------------------*/

STDMETHODIMP CSignedCode::put_FileName (BSTR newVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CSignedCode::put_FileName().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Reset object.
        //
        if (NULL == newVal)
        {
            m_bstrFileName.Empty();
        }
        else if (!(m_bstrFileName = newVal))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error [%#x]: m_bstrFileName = newVal failed.\n", hr);
            goto ErrorExit;
        }
        m_bstrDescription.Empty();
        m_bstrDescriptionURL.Empty();
        WVTClose();
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CSignedCode::put_FileName().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSignedCode::get_Description

  Synopsis : Return the Description.

  Parameter: BSTR * pVal - Pointer to BSTR to receive the Description.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CSignedCode::get_Description(BSTR * pVal)
{
    HRESULT              hr        = S_OK;
    PCRYPT_PROVIDER_DATA pProvData = NULL;
    PSPC_SP_OPUS_INFO    pOpusInfo = NULL;

    DebugTrace("Entering CSignedCode::get_Description().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure filename was already set.
        //
        if (0 == m_bstrFileName.Length())
        {
            hr = CAPICOM_E_CODE_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: SignedCode object has not been initialized.\n", hr);
            goto ErrorExit;
        }

        //
        // If not set already, then see if we can get from the file.
        //
        if (0 == m_bstrDescription.Length())
        {
            if (FAILED(hr = WVTOpen(&pProvData)))
            {
                DebugTrace("Error [%#x]: CSignedCode::WVTOpen() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Get the OPUS info.
            //
            if (FAILED(hr = ::GetOpusInfo(pProvData, &pOpusInfo)))
            {
                DebugTrace("Error [%#x]: GetOpusInfo() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Make sure we have the value.
            //
            if (pOpusInfo->pwszProgramName)
            {
                //
                // Update state.
                //
                if (!(m_bstrDescription = pOpusInfo->pwszProgramName))
                {
                    hr = E_OUTOFMEMORY;

                    DebugTrace("Error [%#x]: m_bstrDescription = pOpusInfo->pwszProgramName failed.\n", hr);
                    goto ErrorExit;
                }
            }
        }

        //
        // Return result.
        //
        if (FAILED(hr = m_bstrDescription.CopyTo(pVal)))
        {
            DebugTrace("Error [%#x]: m_bstrDescription.CopyTo() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resources.
    //
    if (pOpusInfo)
    {
        ::CoTaskMemFree((LPVOID) pOpusInfo);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CSignedCode::get_Description().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSignedCode::put_Description

  Synopsis : Initialize the object with Description of code to be signed.

  Parameter: BSTR newVal - BSTR containing the Description.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CSignedCode::put_Description (BSTR newVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CSignedCode::put_Description().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure filename was already set.
        //
        if (0 == m_bstrFileName.Length())
        {
            hr = CAPICOM_E_CODE_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: SignedCode object has not been initialized.\n", hr);
            goto ErrorExit;
        }

        //
        // Save value.
        //
        if (NULL == newVal)
        {
            m_bstrDescription.Empty();
        }
        else if (!(m_bstrDescription = newVal))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error [%#x]: m_bstrDescription = newVal failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CSignedCode::put_Description().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSignedCode::get_DescriptionURL

  Synopsis : Return the DescriptionURL.

  Parameter: BSTR * pVal - Pointer to BSTR to receive the DescriptionURL.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CSignedCode::get_DescriptionURL(BSTR * pVal)
{
    HRESULT              hr        = S_OK;
    PCRYPT_PROVIDER_DATA pProvData = NULL;
    PSPC_SP_OPUS_INFO    pOpusInfo = NULL;

    DebugTrace("Entering CSignedCode::get_DescriptionURL().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure filename was already set.
        //
        if (0 == m_bstrFileName.Length())
        {
            hr = CAPICOM_E_CODE_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: SignedCode object has not been initialized.\n", hr);
            goto ErrorExit;
        }

        //
        // If not set already, then see if we can get from the file.
        //
        if (0 == m_bstrDescriptionURL.Length())
        {
            if (FAILED(hr = WVTOpen(&pProvData)))
            {
                DebugTrace("Error [%#x]: CSignedCode::WVTOpen() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Get the OPUS info.
            //
            if (FAILED(hr = ::GetOpusInfo(pProvData, &pOpusInfo)))
            {
                DebugTrace("Error [%#x]: GetOpusInfo() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Make sure we have the value.
            //
            if (pOpusInfo->pMoreInfo && SPC_URL_LINK_CHOICE == pOpusInfo->pMoreInfo->dwLinkChoice)
            {
                //
                // Update state.
                //
                if (!(m_bstrDescriptionURL = pOpusInfo->pMoreInfo->pwszUrl))
                {
                    hr = E_OUTOFMEMORY;

                    DebugTrace("Error [%#x]: m_bstrDescriptionURL = pOpusInfo->pMoreInfo->pwszUrl failed.\n", hr);
                    goto ErrorExit;
                }
            }
        }

        //
        // Return result.
        //
        if (FAILED(hr = m_bstrDescriptionURL.CopyTo(pVal)))
        {
            DebugTrace("Error [%#x]: m_bstrDescriptionURL.CopyTo() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resources.
    //
    if (pOpusInfo)
    {
        ::CoTaskMemFree((LPVOID) pOpusInfo);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CSignedCode::get_DescriptionURL().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSignedCode::put_DescriptionURL

  Synopsis : Initialize the object with DescriptionURL of code to be signed.

  Parameter: BSTR newVal - BSTR containing the DescriptionURL.

  Remark   : Note that this property should not be changed once a signature
             is created, as it will re-initialize the object even in error
             condition, unless that's your intention.

------------------------------------------------------------------------------*/

STDMETHODIMP CSignedCode::put_DescriptionURL (BSTR newVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CSignedCode::put_DescriptionURL().\n");

    //
    // Lock access to this object.
    //
    m_Lock.Lock();

    try
    {
        //
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure filename was set.
        //
        if (0 == m_bstrFileName.Length())
        {
            hr = CAPICOM_E_CODE_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: SignedCode object has not been initialized.\n", hr);
            goto ErrorExit;
        }

        //
        // Save value.
        //
        if (NULL == newVal)
        {
            m_bstrDescriptionURL.Empty();
        }
        else if (!(m_bstrDescriptionURL = newVal))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error [%#x]: m_bstrDescriptionURL = newVal failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CSignedCode::put_DescriptionURL().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSignedCode::get_Signer

  Synopsis : Return the code signer.

  Parameter: ISigner2 * pVal - Pointer to pointer to ISigner2 to receive
                               interface pointer.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CSignedCode::get_Signer (ISigner2 ** pVal)
{
    HRESULT              hr          = S_OK;
    PCRYPT_PROVIDER_DATA pProvData   = NULL;
    PCRYPT_PROVIDER_SGNR pProvSigner = NULL;
    PCRYPT_PROVIDER_CERT pProvCert   = NULL;
    CComPtr<ISigner2>    pISigner2   = NULL;


    DebugTrace("Entering CSignedCode::get_Signer().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure content is already initialized.
        //
        if (0 == m_bstrFileName.Length())
        {
            hr = CAPICOM_E_CODE_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: SignedCode object has not been initialized.\n", hr);
            goto ErrorExit;
        }

        //
        // Get authenticode data.
        //
        if (FAILED(hr = WVTOpen(&pProvData)))
        {
            DebugTrace("Error [%#x]: CSignedCode::WVTOpen() failed.\n", hr);
            goto ErrorExit;
        }      

        //
        // Get provider signer data.
        //
        if (!(pProvSigner = WTHelperGetProvSignerFromChain(pProvData, 0, FALSE, 0)))
        {
            hr = CAPICOM_E_INTERNAL;

            DebugTrace("Error [%#x]: WTHelperGetProvSignerFromChain() failed.\n", hr);
            goto ErrorExit;
        }

        if (!(pProvCert = WTHelperGetProvCertFromChain(pProvSigner, 0)))
        {
            hr = CAPICOM_E_INTERNAL;

            DebugTrace("Error [%#x]: WTHelperGetProvCertFromChain() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Create an ISigner object.
        //
        if (FAILED(hr = ::CreateSignerObject(pProvCert->pCert, 
                                             &pProvSigner->psSigner->AuthAttrs,
                                             pProvSigner->pChainContext,
                                             0,
                                             pVal)))
        {
            DebugTrace("Error [%#x]: CreateSignerObject() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CSignedCode::get_Signer().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSignedCode::get_TimeStamper

  Synopsis : Return the code timestamper.

  Parameter: ISigner2 * pVal - Pointer to pointer to ISigner2 to receive
                               interface pointer.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CSignedCode::get_TimeStamper (ISigner2 ** pVal)
{
    HRESULT              hr          = S_OK;
    PCRYPT_PROVIDER_DATA pProvData   = NULL;
    PCRYPT_PROVIDER_SGNR pProvSigner = NULL;
    PCRYPT_PROVIDER_CERT pProvCert   = NULL;
    CComPtr<ISigner2>    pISigner2   = NULL;


    DebugTrace("Entering CSignedCode::get_TimeStamper().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize.
        //
        *pVal = NULL;

        //
        // Make sure content is already initialized.
        //
        if (0 == m_bstrFileName.Length())
        {
            hr = CAPICOM_E_CODE_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: SignedCode object has not been initialized.\n", hr);
            goto ErrorExit;
        }

        //
        // Get authenticode data.
        //
        if (FAILED(hr = WVTOpen(&pProvData)))
        {
            DebugTrace("Error [%#x]: CSignedCode::WVTOpen() failed.\n", hr);
            goto ErrorExit;
        }      

        //
        // Get provider signer data.
        //
        if (!(pProvSigner = WTHelperGetProvSignerFromChain(pProvData, 0, FALSE, 0)))
        {
            hr = CAPICOM_E_INTERNAL;

            DebugTrace("Internal error [%#x]: WTHelperGetProvSignerFromChain() failed.\n", hr);
            goto ErrorExit;
        }

        if (!(pProvCert = WTHelperGetProvCertFromChain(pProvSigner, 0)))
        {
            hr = CAPICOM_E_INTERNAL;

            DebugTrace("Internal error [%#x]: WTHelperGetProvCertFromChain() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Get timestamper if available.
        //
        // Note: Authenticode only supports one counter signer (the timestamper).
        //
        if (pProvSigner->csCounterSigners)
        {
            //
            // Sanity check.
            //
            ATLASSERT(1 == pProvSigner->csCounterSigners);

            if (!(pProvCert = WTHelperGetProvCertFromChain(pProvSigner->pasCounterSigners, 0)))
            {
                hr = CAPICOM_E_INTERNAL;

                DebugTrace("Internal error [%#x]: WTHelperGetProvCertFromChain() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Create an ISigner object.
            //
            if (FAILED(hr = ::CreateSignerObject(pProvCert->pCert, 
                                                 &pProvSigner->pasCounterSigners->psSigner->AuthAttrs,
                                                 pProvSigner->pasCounterSigners->pChainContext,
                                                 0,
                                                 pVal)))
            {
                DebugTrace("Error [%#x]: CreateSignerObject() failed.\n", hr);
                goto ErrorExit;
            }
        }
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CSignedCode::get_TimeStamper().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSignedCode::get_Certificates

  Synopsis : Return all certificates found in the message as an non-ordered
             ICertificates collection object.

  Parameter: ICertificates2 ** pVal - Pointer to pointer to ICertificates 
                                      to receive the interface pointer.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CSignedCode::get_Certificates (ICertificates2 ** pVal)
{
    HRESULT              hr        = S_OK;
    PCRYPT_PROVIDER_DATA pProvData = NULL;
    CAPICOM_CERTIFICATES_SOURCE ccs = {CAPICOM_CERTIFICATES_LOAD_FROM_MESSAGE, 0};

    DebugTrace("Entering CSignedCode::get_Certificates().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure content is already initialized.
        //
        if (0 == m_bstrFileName.Length())
        {
            hr = CAPICOM_E_CODE_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: SignedCode object has not been initialized.\n", hr);
            goto ErrorExit;
        }

        //
        // Get WVT data.
        //
        if (FAILED(hr = WVTOpen(&pProvData)))
        {
            DebugTrace("Error [%#x]: CSignedCode::WVTOpen() failed.\n", hr);
            goto ErrorExit;
        }      

        //
        // Create the ICertificates2 collection object.
        //
        ccs.hCryptMsg = pProvData->hMsg;

        if (FAILED(hr = ::CreateCertificatesObject(ccs, 1, TRUE, pVal)))
        {
            DebugTrace("Error [%#x]: CreateCertificatesObject() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();
    
    DebugTrace("Leaving CSignedCode::get_Certificates().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSignedCode::Sign

  Synopsis : Sign the executable file.

  Parameter: ISigner2 * pSigner2 - Pointer to ISigner2 (Can be NULL).

  Remark   : The certificate selection dialog will be launched 
             (CryptUIDlgSelectCertificate API) to display a list of certificates
             from the Current User\My store for selecting a signer's certificate, 
             for the following conditions:

             1) A signer is not specified (pISigner is NULL) or the ICertificate
                property of the ISigner is not set
             
             2) There is more than 1 cert in the store that can be used for
                code signing, and
             
             3) The Settings::EnablePromptForIdentityUI property is not disabled.

             Also if called from web environment, UI will be displayed, if has 
             not been prevously disabled, to warn the user of accessing the 
             private key for signing.

------------------------------------------------------------------------------*/

STDMETHODIMP CSignedCode::Sign (ISigner2 * pISigner2)
{
    HRESULT                       hr                     = S_OK;
    HMODULE                       hDll                   = NULL;
    CComPtr<ISigner2>             pISelectedSigner2      = NULL;
    CComPtr<ICertificate>         pICertificate          = NULL;
    PCCERT_CONTEXT                pSelectedCertContext   = NULL;
    CAPICOM_STORE_INFO            StoreInfo              = {CAPICOM_STORE_INFO_STORENAME, L"My"};
    PCRYPTUIWIZDIGITALSIGN        pCryptUIWizDigitalSign = NULL;
    CRYPTUI_WIZ_DIGITAL_SIGN_INFO SignInfo               = {0};

    DebugTrace("Entering CSignedCode::Sign().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure content is already initialized.
        //
        if (0 == m_bstrFileName.Length())
        {
            hr = CAPICOM_E_CODE_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: SignedCode object has not been initialized.\n", hr);
            goto ErrorExit;
        }

        //
        // Get pointer to CryptUIWizDgitalSign().
        //
        if (hDll = ::LoadLibrary("CryptUI.dll"))
        {
            pCryptUIWizDigitalSign = (PCRYPTUIWIZDIGITALSIGN) ::GetProcAddress(hDll, "CryptUIWizDigitalSign");
        }

        //
        // Is CryptUIWizDigitalSign() available?
        //
        if (!pCryptUIWizDigitalSign)
        {
            hr = CAPICOM_E_NOT_SUPPORTED;

            DebugTrace("Error: CryptUIWizDigitalSign() API not available.\n");
            goto ErrorExit;
        }

        //
        // Close WVT data (ignore error)
        //
        WVTClose();

        //
        // Get the signer's cert (may prompt user to select signer's cert).
        //
        if (FAILED(hr = ::GetSignerCert(pISigner2,
                                        CERT_CHAIN_POLICY_AUTHENTICODE,
                                        StoreInfo,
                                        FindAuthenticodeCertCallback,
                                        &pISelectedSigner2,
                                        &pICertificate,
                                        &pSelectedCertContext)))
        {
            DebugTrace("Error [%#x]: GetSignerCert() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Setup signer info.
        //
        if (FAILED(hr = InitSignerSignInfo(pISelectedSigner2,
                                           pICertificate,
                                           pSelectedCertContext,
                                           m_bstrFileName,
                                           m_bstrDescription,
                                           m_bstrDescriptionURL,
                                           &SignInfo)))
        {
            DebugTrace("Error [%#x]: InitSignerSignInfo() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Now sign it.
        //
        if (!pCryptUIWizDigitalSign(CRYPTUI_WIZ_NO_UI,
                                    NULL,
                                    NULL,
                                    &SignInfo,
                                    NULL))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptUIWizDigitalSign() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resources.
    //
    ::FreeSignerSignInfo(&SignInfo);

    if (hDll)
    {
        ::FreeLibrary(hDll);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();
    
    DebugTrace("Leaving CSignedCode::Sign().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSignedCode::Timestamp

  Synopsis : Timestamp a signed executable file.

  Parameter: BSTR URL - URL of timestamp server.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CSignedCode::Timestamp (BSTR bstrURL)
{
    HRESULT hr = S_OK;
    SIGNER_SUBJECT_INFO SubjectInfo = {0};
 
    DebugTrace("Entering CSignedCode::Timestamp().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check paremeters.
        //
        if (0 == ::SysStringLen(bstrURL))
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter bstrURL is NULL or empty.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure filename is already initialized.
        //
        if (0 == m_bstrFileName.Length())
        {
            hr = CAPICOM_E_CODE_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: SignedCode object has not been initialized.\n", hr);
            goto ErrorExit;
        }

        //
        // Close WVT data (ignore error)
        //
        WVTClose();

        //
        // Init SIGNER_SUBJECT_INFO structure.
        //
        if (FAILED(hr = ::InitSignerSubjectInfo(m_bstrFileName, &SubjectInfo)))
        {
            DebugTrace("Error[%#x]: InitSignerSubjectInfo() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Now timestamp it.
        //
        if (S_OK != (hr = ::SignerTimeStamp(&SubjectInfo, bstrURL, NULL, NULL)))
        {
            //
            // Remap error.
            //
            if (HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION) == hr)
            {
                hr = CAPICOM_E_CODE_INVALID_TIMESTAMP_URL;
            }
            else if (HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) == hr)
            {
                hr = CAPICOM_E_CODE_NOT_SIGNED;
            }

            DebugTrace("Error[%#x]: SignerTimeStamp() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resources.
    //
    ::FreeSignerSubjectInfo(&SubjectInfo);

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();
    
    DebugTrace("Leaving CSignedCode::Timestamp().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSignedCode::Verify

  Synopsis : Verify the signed executable file.

  Parameter: VARIANT_BOOL bUIAllowed - True to allow UI.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CSignedCode::Verify (VARIANT_BOOL bUIAllowed)
{
    HRESULT hr = S_OK;
 
    DebugTrace("Entering CSignedCode::Verify().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure content is already initialized.
        //
        if (0 == m_bstrFileName.Length())
        {
            hr = CAPICOM_E_CODE_NOT_INITIALIZED;

            DebugTrace("Error: SignedCode object has not been initialized.\n");
            goto ErrorExit;
        }

        //
        // Verify.
        //
        if (FAILED(hr = WVTVerify(bUIAllowed ? WTD_UI_ALL : WTD_UI_NONE, 0)))
        {
            DebugTrace("Error [%#x]: WVTVerify() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Reset states.
        //
        m_bstrDescription.Empty();
        m_bstrDescriptionURL.Empty();
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();
    
    DebugTrace("Leaving CSignedCode::Verify().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// Private member functions.
//


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : WVTVerify

  Synopsis : Call WinVerifyTrust to verify the signed executable file.

  Parameter: DWORD dwUIChoice - WTD_NO_UI or WTD_ALL_UI.

             DWORD dwProvFlags - Provider flags (See WinTrust.h).

  Remark   : Caller must call WVTClose().

------------------------------------------------------------------------------*/

STDMETHODIMP CSignedCode::WVTVerify(DWORD dwUIChoice,
                                    DWORD dwProvFlags)
{
    HRESULT              hr                = S_OK;
    GUID                 wvtProvGuid       = WINTRUST_ACTION_GENERIC_VERIFY_V2;
    WINTRUST_FILE_INFO * pWinTrustFileInfo = NULL;
    PCRYPT_PROVIDER_DATA pProvData         = NULL;

    DebugTrace("Entering CSignedCode::WVTVerify().\n");

    //
    // Sanity check.
    //
    ATLASSERT(m_bstrFileName);

    //
    // Close WVT data (ignore error).
    //
    WVTClose();

    //
    // Allocate memory for WVT structures.
    //
    if (!(pWinTrustFileInfo = (WINTRUST_FILE_INFO *) ::CoTaskMemAlloc(sizeof(WINTRUST_FILE_INFO))))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Error: out of memory.\n");
        goto ErrorExit;
    }
    ::ZeroMemory(pWinTrustFileInfo, sizeof(WINTRUST_FILE_INFO));

    //
    // Setup structure to call WVT.
    //
    pWinTrustFileInfo->cbStruct      = sizeof(WINTRUST_FILE_INFO);
    pWinTrustFileInfo->pcwszFilePath = (LPWSTR) m_bstrFileName;

    m_WinTrustData.cbStruct          = sizeof(WINTRUST_DATA);
    m_WinTrustData.dwUIChoice        = dwUIChoice;
    m_WinTrustData.dwUnionChoice     = WTD_CHOICE_FILE;
    m_WinTrustData.dwStateAction     = WTD_STATEACTION_VERIFY;
    m_WinTrustData.pFile             = pWinTrustFileInfo;
    m_WinTrustData.dwProvFlags       = dwProvFlags;

    //
    // Now call WVT to verify.
    //
    if (S_OK != (hr = ::WinVerifyTrust(NULL, &wvtProvGuid, &m_WinTrustData)))
    {
        //
        // Handle error later.
        //
        hr = HRESULT_FROM_WIN32(hr);
        DebugTrace("Info [%#x]: CSignedCode::WVTVerify() failed.\n", hr);
    }

    //
    // Do we have the data?
    //
    if (!(pProvData = WTHelperProvDataFromStateData(m_WinTrustData.hWVTStateData)))
    {
        DebugTrace("Error [%#x]: WTHelperProvDataFromStateData() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Now we have the WVT data.
    //
    m_bHasWTD = TRUE;

    //
    // Be good boy to always go thru error exit.
    //
    if (FAILED(hr))
    {
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CSignedCode::WVTVerify().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Remap no signature error.
    //
    if (TRUST_E_NOSIGNATURE == hr)
    {
        hr = CAPICOM_E_CODE_NOT_SIGNED;
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : WVTOpen

  Synopsis : Open the signed code file to extract authenticode data.

  Parameter: PCRYPT_PROVIDER_DATA * pProvData - Pointer to receive PCRYPT_PROV_DATA.

  Remark   : Caller must call WVTClose().

------------------------------------------------------------------------------*/

STDMETHODIMP CSignedCode::WVTOpen (PCRYPT_PROVIDER_DATA * ppProvData)
{
    HRESULT              hr        = S_OK;
    PCRYPT_PROVIDER_DATA pProvData = NULL;

    DebugTrace("Entering CSignedCode::WVTOpen().\n");

    //
    // Sanity check.
    //
    ATLASSERT(ppProvData);

    //
    // Get the WVT data if we still don't have it.
    //
    if (!m_bHasWTD)
    {
        //
        // Get WINTRUST_DATA.
        //
        if (FAILED(hr = WVTVerify(WTD_UI_NONE, WTD_REVOCATION_CHECK_NONE)))
        {
            //
            // Ignore all errors. We are only interested in gettting the data.
            //
            DebugTrace("Info [%#x]: CSignedCode::WVTVerify() failed.\n", hr);
        }      

        //
        // Do we have the data?
        //
        if (!m_bHasWTD)
        {
            //
            // Must be something along the line of NO SIGNER.
            //
            DebugTrace("Error [%#x]: cannot get WINTRUST_DATA.\n", hr);
            goto ErrorExit;
        }

        //
        // We should be OK at this point.
        //
        hr = S_OK;
    }

    //
    // Do we have the data?
    //
    if (!(pProvData = WTHelperProvDataFromStateData(m_WinTrustData.hWVTStateData)))
    {
        hr = CAPICOM_E_UNKNOWN;

        DebugTrace("Unknown error [%#x]: WTHelperProvDataFromStateData() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Return CRYPT_PROVIDER_DATA, if requested.
    //
    if (ppProvData)
    {
        *ppProvData = pProvData;
    }

CommonExit:

    DebugTrace("Leaving CSignedCode::WVTOpen().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}
 
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : WVTClose

  Synopsis : Call WinVerifyTrust to release resources allocated.

  Parameter: None.

  Remark   : It is a no-op if the WVT data was not obtained earlier either
             thru WVTOpen or WVTVerify.

------------------------------------------------------------------------------*/

STDMETHODIMP CSignedCode::WVTClose (void)
{
    HRESULT hr          = S_OK;
    GUID    wvtProvGuid = WINTRUST_ACTION_GENERIC_VERIFY_V2;

    DebugTrace("Entering CSignedCode::WVTClose().\n");

    //
    // Release WVT data if opened.
    //
    if (m_bHasWTD)
    {
        //
        // Set state to close.
        //
        m_WinTrustData.dwStateAction = WTD_STATEACTION_CLOSE;

        //
        // Now call WVT to close state data.
        //
        if (S_OK != (hr = ::WinVerifyTrust(NULL, &wvtProvGuid, &m_WinTrustData)))
        {
            hr = HRESULT_FROM_WIN32(hr);

            DebugTrace("Error [%#x]: WinVerifyTrust() failed .\n", hr);
            goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_WinTrustData.pFile);

        //
        // Free resources.
        //
        ::CoTaskMemFree((LPVOID) m_WinTrustData.pFile);

        //
        // Now it is closed.
        //
        m_bHasWTD = FALSE;
    }

    //
    // Reset.
    //
    ::ZeroMemory(&m_WinTrustData, sizeof(WINTRUST_DATA));

CommonExit:

    DebugTrace("Leaving CSignedCode::WVTClose().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\signeddata.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    SignedData.cpp

  Content: Implementation of CSignedData.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "SignedData.h"

#include "Certificates.h"
#include "Chain.h"
#include "Common.h"
#include "Convert.h"
#include "CertHlpr.h"
#include "MsgHlpr.h"
#include "Policy.h"
#include "Settings.h"
#include "Signer2.h"
#include "Signers.h"
#include "SignHlpr.h"

////////////////////////////////////////////////////////////////////////////////
//
// Local functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : FreeCertificateChain

  Synopsis : Free resources allocated for the chain built with 
             InitCertificateChain.

  Parameter: CRYPT_DATA_BLOB * pChainBlob - Pointer to chain blob.

  Remark   :

------------------------------------------------------------------------------*/

static void FreeCertificateChain (CRYPT_DATA_BLOB * pChainBlob)
{
    DWORD i;
    PCCERT_CONTEXT * rgCertContext;

    DebugTrace("Entering FreeCertificateChain().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pChainBlob);

    //
    // Free all allocated memory for the chain.
    //
    ;
    for (i = 0, rgCertContext = (PCCERT_CONTEXT *) pChainBlob->pbData; i < pChainBlob->cbData; i++)
    {
        ATLASSERT(rgCertContext[i]);

        ::CertFreeCertificateContext(rgCertContext[i]);
    }

    ::CoTaskMemFree((LPVOID) pChainBlob->pbData);

    return;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : AddCertificateChain

  Synopsis : Add the chain of certificates to the bag of certs.

  Parameter: HCRYPTMSG hMsg - Message handle.

             DATA_BLOB * pChainBlob - Pointer chain blob of PCCERT_CONTEXT.

             CAPICOM_CERTIFICATE_INCLUDE_OPTION IncludeOption - Include option.

  Remark   :

------------------------------------------------------------------------------*/

static HRESULT AddCertificateChain (HCRYPTMSG                          hMsg, 
                                    DATA_BLOB                        * pChainBlob,
                                    CAPICOM_CERTIFICATE_INCLUDE_OPTION IncludeOption)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering AddCertificateChain().\n");

    //
    // Sanity check.
    //
    ATLASSERT(hMsg);
    ATLASSERT(pChainBlob);
    ATLASSERT(pChainBlob->cbData);
    ATLASSERT(pChainBlob->pbData);

    DWORD cCertContext = pChainBlob->cbData;
    PCERT_CONTEXT * rgCertContext = (PCERT_CONTEXT *) pChainBlob->pbData;

    //
    // Determine number of cert(s) to include in the bag.
    //
    switch (IncludeOption)
    {
        case CAPICOM_CERTIFICATE_INCLUDE_END_ENTITY_ONLY:
        {
            cCertContext = 1;
            break;
        }

        case CAPICOM_CERTIFICATE_INCLUDE_WHOLE_CHAIN:
        {
            break;
        }

        case CAPICOM_CERTIFICATE_INCLUDE_CHAIN_EXCEPT_ROOT:
        {
            //
            // <<< Falling thru to default >>>
            //
        }

        default:
        {
            if (1 < cCertContext)
            {
                cCertContext--;
            }
            break;
        }
    }

    //
    // Add all certs from the chain to message.
    //
    for (DWORD i = 0; i < cCertContext; i++)
    {
        //
        // Is this cert already in the bag of certs?
        //
        if (FAILED(hr =::FindSignerCertInMessage(hMsg, 
                                                 &rgCertContext[i]->pCertInfo->Issuer,
                                                 &rgCertContext[i]->pCertInfo->SerialNumber,
                                                 NULL)))
        {
            //
            // No, so add to bag of certs.
            //
            DATA_BLOB CertBlob = {rgCertContext[i]->cbCertEncoded, 
                                  rgCertContext[i]->pbCertEncoded};

            if (!::CryptMsgControl(hMsg,
                                   0,
                                   CMSG_CTRL_ADD_CERT,
                                   &CertBlob))
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());

                DebugTrace("Error [%#x]: CryptMsgControl() failed for CMSG_CTRL_ADD_CERT.\n", hr);
                break;
            }

            hr = S_OK;
        }
    }

    DebugTrace("Leaving AddCertificateChain().\n");

    return hr;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : InitCertificateChain

  Synopsis : Allocate and initialize a certificate chain for the specified 
             certificate, and return the chain in an array of PCERT_CONTEXT.

  Parameter: ICertificate * pICertificate - Pointer to ICertificate for which
                                            the chain will be built.

             HCERTSTORE hAdditionalStore  - Additional store handle.

             CRYPT_DATA_BLOB * pChainBlob - Pointer to blob to recevie the
                                            size and array of PCERT_CONTEXT
                                            for the chain.
  Remark   :

------------------------------------------------------------------------------*/

static HRESULT InitCertificateChain (ICertificate    * pICertificate, 
                                     HCERTSTORE        hAdditionalStore,
                                     CRYPT_DATA_BLOB * pChainBlob)
{
    HRESULT         hr      = S_OK;
    CComPtr<IChain> pIChain = NULL;
    VARIANT_BOOL    bResult = VARIANT_FALSE;

    DebugTrace("Entering InitCertificateChain().\n");

    //
    // Sanity checks.
    //
    ATLASSERT(pICertificate);
    ATLASSERT(pChainBlob);

    //
    // Create a chain object.
    //
    if (FAILED(hr = ::CreateChainObject(pICertificate,
                                        hAdditionalStore,
                                        &bResult,
                                        &pIChain)))
    {
        DebugTrace("Error [%#x]: CreateChainObject() failed.\n", hr);
        goto CommonExit;
    }

    //
    // Get the chain of certs.
    //
    if (FAILED(hr = ::GetChainContext(pIChain, pChainBlob)))
    {
        DebugTrace("Error [%#x]: GetChainContext() failed.\n", hr);
    }

CommonExit:

    DebugTrace("Leaving InitCertificateChain().\n");

    return hr;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : FreeSignerEncodeInfo

  Synopsis : Free all memory allocated for the CMSG_SIGNER_ENCODE_INFO 
             structure, including any memory allocated for members of the
             structure.

  Parameter: CMSG_SIGNER_ENCODE_INFO * pSignerEncodeInfo - Pointer to the
                                                           structure.

  Remark   :

------------------------------------------------------------------------------*/

static void FreeSignerEncodeInfo (CMSG_SIGNER_ENCODE_INFO * pSignerEncodeInfo)
{
    DebugTrace("Entering FreeSignerEncodeInfo().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pSignerEncodeInfo);

    //
    // First free the authenticated attributes array, if present.
    // 
    if (pSignerEncodeInfo->rgAuthAttr)
    {
        ::FreeAttributes(pSignerEncodeInfo->cAuthAttr, pSignerEncodeInfo->rgAuthAttr);

        ::CoTaskMemFree(pSignerEncodeInfo->rgAuthAttr);
    }

    ::ZeroMemory(pSignerEncodeInfo, sizeof(CMSG_SIGNER_ENCODE_INFO));

    DebugTrace("Leaving FreeSignerEncodeInfo().\n");

    return;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : InitSignerEncodeInfo

  Synopsis : Allocate a CMSG_SIGNER_ENCODE_INFO structure, and initialize it
             with values passed in through parameters.

  Parameter: ISigner * pISigner - Pointer to ISigner.
  
             PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT of cert.

             HCRYPTPROV phCryptProv - CSP handle.

             DWORD dwKeySpec - Key spec, AT_KEYEXCHANGE or AT_SIGNATURE.

             CMSG_SIGNER_ENCODE_INFO * pSignerEncodeInfo - Structure to be 
                                                           initialized.

  Return   : Pointer to an initialized CMSG_SIGNER_ENCODE_INFO structure if
             success, otherwise NULL (out of memory).

  Remark   : Must call FreeSignerEncodeInfo to free resources allocated.

------------------------------------------------------------------------------*/

static HRESULT InitSignerEncodeInfo (ISigner                 * pISigner,
                                     PCCERT_CONTEXT            pCertContext, 
                                     HCRYPTPROV                hCryptProv,
                                     DWORD                     dwKeySpec,
                                     CMSG_SIGNER_ENCODE_INFO * pSignerEncodeInfo)
{
    HRESULT hr = S_OK;
    CRYPT_ATTRIBUTES AuthAttr;

    DebugTrace("Entering InitSignerEncodeInfo().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pISigner);
    ATLASSERT(pCertContext);
    ATLASSERT(hCryptProv);
    ATLASSERT(pSignerEncodeInfo);

    //
    // Initialize.
    //
    ::ZeroMemory(&AuthAttr, sizeof(AuthAttr));

    //
    // Get authenticated attributes.
    //
    if (FAILED(hr = ::GetAuthenticatedAttributes(pISigner, &AuthAttr)))
    {
        DebugTrace("Error [%#x]: GetAuthenticatedAttributes() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Setup CMSG_SIGNER_ENCODE_INFO structure.
    //
    ::ZeroMemory(pSignerEncodeInfo, sizeof(CMSG_SIGNER_ENCODE_INFO));
    pSignerEncodeInfo->cbSize = sizeof(CMSG_SIGNER_ENCODE_INFO);
    pSignerEncodeInfo->pCertInfo = pCertContext->pCertInfo;
    pSignerEncodeInfo->hCryptProv = hCryptProv;
    pSignerEncodeInfo->dwKeySpec = dwKeySpec;
    pSignerEncodeInfo->HashAlgorithm.pszObjId = szOID_OIWSEC_sha1;
    pSignerEncodeInfo->cAuthAttr = AuthAttr.cAttr;
    pSignerEncodeInfo->rgAuthAttr = AuthAttr.rgAttr;

CommonExit:

    DebugTrace("Leaving InitSignerEncodeInfo().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resources.
    //
    ::FreeAttributes(&AuthAttr);

    goto CommonExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// CSignedData
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSignedData::get_Content

  Synopsis : Return the content.

  Parameter: BSTR * pVal - Pointer to BSTR to receive the content.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CSignedData::get_Content (BSTR * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CSignedData::get_Content().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure parameter is valid.
        //
        if (NULL == pVal)
        {
            hr = E_POINTER;

            DebugTrace("Error: invalid parameter, pVal is NULL.\n");
            goto ErrorExit;
        }

        //
        // Make sure content is already initialized.
        //
        if (0 == m_ContentBlob.cbData)
        {
            hr = CAPICOM_E_SIGN_NOT_INITIALIZED;

            DebugTrace("Error: SignedData object has not been initialized.\n");
            goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_ContentBlob.pbData);

        //
        // Return content.
        //
        if (FAILED(hr = ::BlobToBstr(&m_ContentBlob, pVal)))
        {
            DebugTrace("Error [%#x]: BlobToBstr() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CSignedData::get_Content().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSignedData::put_Content

  Synopsis : Initialize the object with content to be signed.

  Parameter: BSTR newVal - BSTR containing the content to be signed.

  Remark   : Note that this property should not be changed once a signature
             is created, as it will re-initialize the object even in error
             condition, unless that's your intention.

------------------------------------------------------------------------------*/

STDMETHODIMP CSignedData::put_Content (BSTR newVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CSignedData::put_Content().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Reset member variables.
        //
        if (m_ContentBlob.pbData)
        {
            ::CoTaskMemFree(m_ContentBlob.pbData);
        }
        if (m_MessageBlob.pbData)
        {
            ::CoTaskMemFree(m_MessageBlob.pbData);
        }

        m_bSigned = FALSE;
        m_bDetached = VARIANT_FALSE;
        m_ContentBlob.cbData = 0;
        m_ContentBlob.pbData = NULL;
        m_MessageBlob.cbData = 0;
        m_MessageBlob.pbData = NULL;

        //
        // Make sure parameters are valid.
        //
        if (NULL == newVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter newVal is NULL.\n", hr);
            goto ErrorExit;
        }
        if (0 == ::SysStringByteLen(newVal))
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter newVal is empty.\n", hr);
            goto ErrorExit;
        }

        //
        // Update content.
        //
        if (FAILED(hr = ::BstrToBlob(newVal, &m_ContentBlob)))
        {
            DebugTrace("Error [%#x]: BstrToBlob() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CSignedData::put_Content().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSignedData::get_Signers

  Synopsis : Return all the content signers as an ISigners collection object.

  Parameter: ISigner * pVal - Pointer to pointer to ISigners to receive
                              interface pointer.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CSignedData::get_Signers (ISigners ** pVal)
{
    HRESULT    hr     = S_OK;
    HCRYPTMSG  hMsg   = NULL;
    HCERTSTORE hStore = NULL;

    DebugTrace("Entering CSignedData::get_Signers().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure the messages is already signed.
        //
        if (!m_bSigned)
        {
            hr = CAPICOM_E_SIGN_NOT_SIGNED;

            DebugTrace("Error: content was not signed.\n");
            goto ErrorExit;
        }

        //
        // Open the encoded message for decode.
        //
        if (FAILED(hr = OpenToDecode(NULL,
                                     &hMsg)))
        {
            DebugTrace("Error [%#x]: OpenToDecode() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Open the PKCS7 store.
        //
        if (!(hStore = ::CertOpenStore(CERT_STORE_PROV_PKCS7,
                                       CAPICOM_ASN_ENCODING,
                                       NULL,
                                       CERT_STORE_OPEN_EXISTING_FLAG,
                                       &m_MessageBlob)))
        {
            DebugTrace("Error [%#x]: CertOpenStore() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Create the ISigners collection object.
        //
        if (FAILED(hr = ::CreateSignersObject(hMsg, 1, hStore, m_dwCurrentSafety, pVal)))
        {
            DebugTrace("Error [%#x]: CreateSignersObject() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resource.
    //
    if (hMsg)
    {
        ::CryptMsgClose(hMsg);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CSignedData::get_Signers().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSignedData::get_Certificates

  Synopsis : Return all certificates found in the message as an non-ordered
             ICertificates collection object.

  Parameter: ICertificates ** pVal - Pointer to pointer to ICertificates 
                                     to receive the interface pointer.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CSignedData::get_Certificates (ICertificates ** pVal)
{
    HRESULT hr = S_OK;
    CComPtr<ICertificates2> pICertificates = NULL;
    CAPICOM_CERTIFICATES_SOURCE ccs = {CAPICOM_CERTIFICATES_LOAD_FROM_MESSAGE, 0};

    DebugTrace("Entering CSignedData::get_Certificates().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure the messages is already signed.
        //
        if (!m_bSigned)
        {
            hr = CAPICOM_E_SIGN_NOT_SIGNED;

            DebugTrace("Error: content was not signed.\n");
            goto ErrorExit;
        }

        //
        // Open the encoded message for decode.
        //
        if (FAILED(hr = OpenToDecode(NULL, &ccs.hCryptMsg)))
        {
            DebugTrace("Error [%#x]: OpenToDecode() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Create the ICertificates2 collection object.
        //
        if (FAILED(hr = ::CreateCertificatesObject(ccs, m_dwCurrentSafety, TRUE, &pICertificates)))
        {
            DebugTrace("Error [%#x]: CreateCertificatesObject() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return ICertificates collection object to user.
        //
        if (FAILED(hr = pICertificates->QueryInterface(__uuidof(ICertificates), (void **) pVal)))
        {
            DebugTrace("Error [%#x]: pICertificates->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resource.
    //
    if (ccs.hCryptMsg)
    {
        ::CryptMsgClose(ccs.hCryptMsg);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();
    
    DebugTrace("Leaving CSignedData::get_Certificates().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSignedData::Sign

  Synopsis : Sign the content and produce a signed message.

  Parameter: ISigner * pSigner - Pointer to ISigner.

             VARIANT_BOOL bDetached - TRUE if content is to be detached, else
                                      FALSE.

             CAPICOM_ENCODING_TYPE EncodingType - Encoding type.

             BSTR * pVal - Pointer to BSTR to receive the signed message.

  Remark   : The certificate selection dialog will be launched 
             (CryptUIDlgSelectCertificate API) to display a list of certificates
             from the Current User\My store for selecting a signer's certificate, 
             for the following conditions:

             1) A signer is not specified (pVal is NULL) or the ICertificate
                property of the ISigner is not set
             
             2) There is more than 1 cert in the store, and
             
             3) The Settings::EnablePromptForIdentityUI property is not disabled.

             Also if called from web environment, UI will be displayed, if has 
             not been prevously disabled, to warn the user of accessing the 
             private key for signing.

------------------------------------------------------------------------------*/

STDMETHODIMP CSignedData::Sign (ISigner             * pISigner,
                                VARIANT_BOOL          bDetached, 
                                CAPICOM_ENCODING_TYPE EncodingType,
                                BSTR                * pVal)
{
    HRESULT               hr                    = S_OK;
    CComPtr<ISigner2>     pISigner2             = NULL;
    CComPtr<ISigner2>     pISelectedSigner2     = NULL;
    CComPtr<ICertificate> pISelectedCertificate = NULL;
    PCCERT_CONTEXT        pSelectedCertContext  = NULL;
    HCRYPTPROV            hCryptProv            = NULL;
    HCERTSTORE            hAdditionalStore      = NULL;
    DWORD                 dwKeySpec             = 0;
    BOOL                  bReleaseContext       = FALSE;
    DATA_BLOB             ChainBlob             = {0, NULL};
    CAPICOM_STORE_INFO    StoreInfo             = {CAPICOM_STORE_INFO_STORENAME, L"My"};
    CMSG_SIGNER_ENCODE_INFO SignerEncodeInfo    = {0};

    DebugTrace("Entering CSignedData::Sign().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure parameter is valid.
        //
        if (NULL == pVal)
        {
            hr = E_POINTER;

            DebugTrace("Error: invalid parameter, pVal is NULL.\n");
            goto ErrorExit;
        }

        //
        // Make sure content is already initialized.
        //
        if (0 == m_ContentBlob.cbData)
        {
            hr = CAPICOM_E_SIGN_NOT_INITIALIZED;

            DebugTrace("Error: SignedData object has not been initialized.\n");
            goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_ContentBlob.pbData);

        //
        // QI for ISigner2 if user passed in an ISigner.
        //
        if (pISigner)
        {
            if (FAILED(hr = pISigner->QueryInterface(__uuidof(ISigner2), (void **) &pISigner2)))
            {
                DebugTrace("Internal error [%#x]: pISigner->QueryInterface() failed.\n", hr);
                goto ErrorExit;
            }
        }

        //
        // Get the signer's cert (may prompt user to select signer's cert).
        //
        if (FAILED(hr = ::GetSignerCert(pISigner2,
                                        CERT_CHAIN_POLICY_BASE,
                                        StoreInfo,
                                        FindDataSigningCertCallback,
                                        &pISelectedSigner2, 
                                        &pISelectedCertificate, 
                                        &pSelectedCertContext)))
        {
            DebugTrace("Error [%#x]: GetSignerCert() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // If we are called from a web page, we need to pop up UI 
        // to get user permission to perform signing operation.
        //
        if (m_dwCurrentSafety && 
            FAILED(hr = OperationApproved(IDD_SIGN_SECURITY_ALERT_DLG)))
        {
            DebugTrace("Error [%#x]: OperationApproved() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Acquire CSP context and access to private key.
        //
        if (FAILED(hr = ::AcquireContext(pSelectedCertContext, 
                                         &hCryptProv, 
                                         &dwKeySpec, 
                                         &bReleaseContext)))
        {
            DebugTrace("Error [%#x]: AcquireContext() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Get additional store handle.
        //
        if (FAILED(hr = ::GetSignerAdditionalStore(pISelectedSigner2, &hAdditionalStore)))
        {
            DebugTrace("Error [%#x]: GetSignerAdditionalStore() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Build the bag of certs to be included into the message.
        //
        if (FAILED(hr = InitCertificateChain(pISelectedCertificate,
                                             hAdditionalStore,
                                             &ChainBlob)))
        {
            DebugTrace("Error [%#x]: InitCertificateChain() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Allocate and initialize a CMSG_SIGNER_ENCODE_INFO structure.
        //
        if (FAILED(hr = ::InitSignerEncodeInfo(pISelectedSigner2,
                                               pSelectedCertContext,
                                               hCryptProv,
                                               dwKeySpec,
                                               &SignerEncodeInfo)))
        {
            DebugTrace("Error [%#x]: InitSignerEncodeInfo() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Now sign the content.
        //
        if (FAILED(hr = SignContent(pISelectedSigner2,
                                    &SignerEncodeInfo,
                                    &ChainBlob,
                                    bDetached,
                                    EncodingType,
                                    pVal)))
        {
            DebugTrace("Error [%#x]: CSignedData::SignContent() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resources.
    //
    ::FreeSignerEncodeInfo(&SignerEncodeInfo);

    if (ChainBlob.pbData)
    {
        ::FreeCertificateChain(&ChainBlob);
    }
    if (hCryptProv && bReleaseContext)
    {
        ::CryptReleaseContext(hCryptProv, 0);
    }
    if (pSelectedCertContext)
    {
        ::CertFreeCertificateContext(pSelectedCertContext);
    }
    if (hAdditionalStore)
    {
        ::CertCloseStore(hAdditionalStore, 0);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();
    
    DebugTrace("Leaving CSignedData::Sign().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSignedData::CoSign

  Synopsis : CoSign the content and produce a signed message. This method will
             behaves the same as the Sign method as a non-detached message if 
             the messge currently does not already have a signature.

  Parameter: ISigner * pSigner - Pointer to ISigner.

             CAPICOM_ENCODING_TYPE EncodingType - Encoding type.

             BSTR * pVal - Pointer to BSTR to receive the signed message.

  Remark   : The certificate selection dialog will be launched 
             (CryptUIDlgSelectCertificate API) to display a list of certificates
             from the Current User\My store for selecting a signer's certificate, 
             for the following conditions:

             1) A signer is not specified (pVal is NULL) or the ICertificate
                property of the ISigner is not set
             
             2) There is more than 1 cert in the store, and
             
             3) The Settings::EnablePromptForIdentityUI property is not disabled.

             Also if called from web environment, UI will be displayed, if has 
             not been prevously disabled, to warn the user of accessing the 
             private key for signing.

------------------------------------------------------------------------------*/

STDMETHODIMP CSignedData::CoSign (ISigner             * pISigner,
                                  CAPICOM_ENCODING_TYPE EncodingType, 
                                  BSTR                * pVal)
{
    HRESULT               hr                    = S_OK;
    CComPtr<ISigner2>     pISigner2             = NULL;
    CComPtr<ISigner2>     pISelectedSigner2     = NULL;
    CComPtr<ICertificate> pISelectedCertificate = NULL;
    PCCERT_CONTEXT        pSelectedCertContext  = NULL;
    HCRYPTPROV            hCryptProv            = NULL;
    HCERTSTORE            hAdditionalStore      = NULL;
    DWORD                 dwKeySpec             = 0;
    BOOL                  bReleaseContext       = FALSE;
    DATA_BLOB             ChainBlob             = {0, NULL};
    CAPICOM_STORE_INFO    StoreInfo             = {CAPICOM_STORE_INFO_STORENAME, L"My"};
    CMSG_SIGNER_ENCODE_INFO SignerEncodeInfo;

    DebugTrace("Entering CSignedData::CoSign().\n");

    //
    // Initialize.
    //
    ::ZeroMemory(&SignerEncodeInfo, sizeof(SignerEncodeInfo));

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        if (NULL == pVal)
        {
            hr = E_POINTER;

            DebugTrace("Error: invalid parameter, pVal is NULL.\n");
            goto ErrorExit;
        }

        //
        // Make sure message has been signed?
        //
        if (!m_bSigned)
        {
            hr = CAPICOM_E_SIGN_NOT_SIGNED;

            DebugTrace("Error: cannot cosign an unsigned message.\n");
            goto ErrorExit;
        }

        //
        // Make sure content is already initialized.
        //
        if (0 == m_ContentBlob.cbData)
        {
            hr = CAPICOM_E_SIGN_NOT_INITIALIZED;

            DebugTrace("Error: SignedData object has not been initialized.\n");
            goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(m_ContentBlob.pbData);
        ATLASSERT(m_MessageBlob.cbData);
        ATLASSERT(m_MessageBlob.pbData);

        //
        // QI for ISigner2 if user passed in an ISigner.
        //
        if (pISigner)
        {
            if (FAILED(hr = pISigner->QueryInterface(__uuidof(ISigner2), (void **) &pISigner2)))
            {
                DebugTrace("Internal error [%#x]: pISigner->QueryInterface() failed.\n", hr);
                goto ErrorExit;
            }
        }

        //
        // Get the signer's cert (may prompt user to select signer's cert).
        //
        if (FAILED(hr = ::GetSignerCert(pISigner2,
                                        CERT_CHAIN_POLICY_BASE,
                                        StoreInfo,
                                        FindDataSigningCertCallback,
                                        &pISelectedSigner2, 
                                        &pISelectedCertificate, 
                                        &pSelectedCertContext)))
        {
            DebugTrace("Error [%#x]: GetSignerCert() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // If we are called from a web page, we need to pop up UI 
        // to get user permission to perform signing operation.
        //
        if (m_dwCurrentSafety && 
            FAILED(hr = OperationApproved(IDD_SIGN_SECURITY_ALERT_DLG)))
        {
            DebugTrace("Error [%#x]: OperationApproved() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Acquire CSP context and access to private key.
        //
        if (FAILED(hr = ::AcquireContext(pSelectedCertContext, 
                                         &hCryptProv, 
                                         &dwKeySpec, 
                                         &bReleaseContext)))
        {
            DebugTrace("Error [%#x]: AcquireContext() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Get additional store handle.
        //
        if (FAILED(hr = ::GetSignerAdditionalStore(pISelectedSigner2, &hAdditionalStore)))
        {
            DebugTrace("Error [%#x]: GetSignerAdditionalStore() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Build the bag of certs to be included into the message.
        //
        if (FAILED(hr = InitCertificateChain(pISelectedCertificate, 
                                             hAdditionalStore,
                                             &ChainBlob)))
        {
            DebugTrace("Error [%#x]: InitCertificateChain() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Allocate and initialize a CMSG_SIGNER_ENCODE_INFO structure.
        //
        if (FAILED(hr = ::InitSignerEncodeInfo(pISelectedSigner2,
                                               pSelectedCertContext, 
                                               hCryptProv,
                                               dwKeySpec,
                                               &SignerEncodeInfo)))
        {
            DebugTrace("Error [%#x]: InitSignerEncodeInfo() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // CoSign the content.
        //
        if (FAILED(hr = CoSignContent(pISelectedSigner2,
                                      &SignerEncodeInfo,
                                      &ChainBlob,
                                      EncodingType,
                                      pVal)))
        {
            DebugTrace("Error [%#x]: CSignedData::CoSignContent() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resources.
    //
    ::FreeSignerEncodeInfo(&SignerEncodeInfo);

    if (ChainBlob.pbData)
    {
        ::FreeCertificateChain(&ChainBlob);
    }
    if (hCryptProv && bReleaseContext)
    {
        ::CryptReleaseContext(hCryptProv, 0);
    }
    if (pSelectedCertContext)
    {
        ::CertFreeCertificateContext(pSelectedCertContext);
    }
    if (hAdditionalStore)
    {
        ::CertCloseStore(hAdditionalStore, 0);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();
    
    DebugTrace("Leaving CSignedData::CoSign().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSignedData::Verify

  Synopsis : Verify a signed message.

  Parameter: BSTR SignedMessage - BSTR containing the signed message to be
                                  verified.

             VARIANT_BOOL bDetached - TRUE if content was detached, else
                                      FALSE.

             CAPICOM_SIGNED_DATA_VERIFY_FLAG VerifyFlag - Verify flag.

  Remark   : Note that for non-detached message, this method will always try 
             to set the Content property using the signed message, even if the 
             signed message does not verify.

------------------------------------------------------------------------------*/

STDMETHODIMP CSignedData::Verify (BSTR                            SignedMessage, 
                                  VARIANT_BOOL                    bDetached,
                                  CAPICOM_SIGNED_DATA_VERIFY_FLAG VerifyFlag)
{ 
    HRESULT    hr           = S_OK;
    HCRYPTMSG  hMsg         = NULL;
    HCERTSTORE hPKCS7Store  = NULL;
    DWORD      dwNumSigners = 0;
    DWORD      cbSigners    = sizeof(dwNumSigners);
    DWORD      dwSigner     = 0;

    DebugTrace("Entering CSignedData::Verify().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Initialize member variables.
        //
        if (!bDetached)
        {
            if (m_ContentBlob.pbData)
            {
                ::CoTaskMemFree(m_ContentBlob.pbData);
            }

            m_ContentBlob.cbData = 0;
            m_ContentBlob.pbData = NULL;

        }
        if (m_MessageBlob.pbData)
        {
            ::CoTaskMemFree(m_MessageBlob.pbData);
        }

        m_bSigned = FALSE;
        m_bDetached = bDetached;
        m_MessageBlob.cbData = 0;
        m_MessageBlob.pbData = NULL;

        //
        // Make sure parameters are valid.
        //
        if (0 == ::SysStringByteLen(SignedMessage))
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter SignedMessage is NULL or empty.\n", hr);
            goto ErrorExit;
        }

        //
        // If detached, make sure content is already initialized.
        //
        if (m_bDetached)
        {
            if (0 == m_ContentBlob.cbData)
            {
                hr = CAPICOM_E_SIGN_NOT_INITIALIZED;

                DebugTrace("Error: content was not initialized for detached decoding.\n");
                goto ErrorExit;
            }

            //
            // Sanity check.
            //
            ATLASSERT(m_ContentBlob.pbData);
        }

        //
        // Import the message.
        //
        if (FAILED(hr = ::ImportData(SignedMessage, CAPICOM_ENCODE_ANY, &m_MessageBlob)))
        {
            DebugTrace("Error [%#x]: ImportData() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Write encoded blob to file, so we can use offline tool such as
        // ASN parser to analyze message. 
        //
        // The following line will resolve to void for non debug build, and
        // thus can be safely removed if desired.
        //
        DumpToFile("ImportedSigned.asn", m_MessageBlob.pbData, m_MessageBlob.cbData);

        //
        // Open the message to decode.
        //
        if (FAILED(hr = OpenToDecode(NULL, &hMsg)))
        {
            DebugTrace("Error [%#x]: OpenToDecode() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Verify cert as well?
        //
        if (CAPICOM_VERIFY_SIGNATURE_AND_CERTIFICATE == VerifyFlag)
        {
            //
            // Yes, so open the PKCS7 store.
            //
            if (!(hPKCS7Store = ::CertOpenStore(CERT_STORE_PROV_PKCS7,
                                                CAPICOM_ASN_ENCODING,
                                                NULL,
                                                CERT_STORE_OPEN_EXISTING_FLAG,
                                                &m_MessageBlob)))
            {
                DebugTrace("Error [%#x]: CertOpenStore() failed.\n", hr);
                goto ErrorExit;
            }
        }

        //
        // Get number of content signers (first level signers).
        //
        if (!::CryptMsgGetParam(hMsg, 
                                CMSG_SIGNER_COUNT_PARAM,
                                0,
                                (void **) &dwNumSigners,
                                &cbSigners))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptMsgGetParam() failed to get CMSG_SIGNER_COUNT_PARAM.\n", hr);
            goto ErrorExit;
        }

        //
        // Verify all signatures.
        //
        for (dwSigner = 0; dwSigner < dwNumSigners; dwSigner++)
        {
            PCERT_CONTEXT      pCertContext   = NULL;
            CMSG_SIGNER_INFO * pSignerInfo    = NULL;
            CRYPT_DATA_BLOB    SignerInfoBlob = {0, NULL};
        
            //
            // Get signer info.
            //
            if (FAILED(hr = ::GetMsgParam(hMsg,
                                          CMSG_SIGNER_INFO_PARAM,
                                          dwSigner,
                                          (void**) &SignerInfoBlob.pbData,
                                          &SignerInfoBlob.cbData)))
            {
                DebugTrace("Error [%#x]: GetMsgParam() failed to get CMSG_SIGNER_INFO_PARAM for signer #%d.\n", hr, dwSigner);
                goto ErrorExit;
            }

            pSignerInfo = (CMSG_SIGNER_INFO *) SignerInfoBlob.pbData;

            //
            // Find the cert in the message.
            //
            hr = ::FindSignerCertInMessage(hMsg,
                                           &pSignerInfo->Issuer,
                                           &pSignerInfo->SerialNumber,
                                           &pCertContext);
            //
            // First free memory.
            //
            ::CoTaskMemFree(SignerInfoBlob.pbData);

            //
            // Check result.
            //
            if (FAILED(hr))
            {
                DebugTrace("Error [%#x]: FindSignerCertInMessage() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Verify the cert regardless if the user had requested. This
            // is done so that the chain will always be built first before
            // we later verify the signature, which is required by DSS.
            //
            if (FAILED(hr = ::VerifyCertificate(pCertContext, hPKCS7Store, CERT_CHAIN_POLICY_BASE)))
            {
                //
                // Verify cert as well?
                //
                if (CAPICOM_VERIFY_SIGNATURE_AND_CERTIFICATE == VerifyFlag)
                {
                    //
                    // Free CERT_CONTEXT.
                    //
                    ::CertFreeCertificateContext(pCertContext);

                    DebugTrace("Error [%#x]: VerifyCertificate() failed.\n", hr);
                    goto ErrorExit;
                }

                //
                // Reset hr.
                //
                hr = S_OK;
            }

            //
            // Verify signature.
            //
            if (!::CryptMsgControl(hMsg,
                                   0,
                                   CMSG_CTRL_VERIFY_SIGNATURE,
                                   pCertContext->pCertInfo))
            {
                //
                // Invalid signature.
                //
                hr = HRESULT_FROM_WIN32(::GetLastError());

                //
                // Free CERT_CONTEXT.
                //
                ::CertFreeCertificateContext(pCertContext);

                DebugTrace("Error [%#x]: CryptMsgControl(CMSG_CTRL_VERIFY_SIGNATURE) failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Free CERT_CONTEXT.
            //
            ::CertFreeCertificateContext(pCertContext);
        }

        //
        // Update member variables.
        //
        m_bSigned = TRUE;
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resouce.
    //
    if(hMsg)
    {
        ::CryptMsgClose(hMsg);
    }
    if (hPKCS7Store)
    {
        ::CertCloseStore(hPKCS7Store, 0);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();
    
    DebugTrace("Leaving CSignedData::Verify().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Reset member variables.
    //
    m_bSigned   = FALSE;
    m_bDetached = VARIANT_FALSE;
#if (0)
    if (m_ContentBlob.pbData)
    {
        ::CoTaskMemFree(m_ContentBlob.pbData);
    }
    m_ContentBlob.cbData = 0;
    m_ContentBlob.pbData = NULL;
#endif
    if (m_MessageBlob.pbData)
    {
        ::CoTaskMemFree(m_MessageBlob.pbData);
    }
    m_MessageBlob.cbData = 0;
    m_MessageBlob.pbData = NULL;

    ReportError(hr);

    goto UnlockExit;
}


////////////////////////////////////////////////////////////////////////////////
//
// Private member functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSignData::OpenToEncode

  Synopsis : Open a message for encoding.

  Parameter: CMSG_SIGNER_ENCODE_INFO * pSignerEncodeInfo - Pointer to signer's
                                                           CMSG_SIGNER_ENCODE_INFO
                                                           structure.

             DATA_BLOB * pChainBlob                      - Pointer chain blob
                                                           of PCCERT_CONTEXT.

             CAPICOM_CERTIFICATE_INCLUDE_OPTION IncludeOption - Include option.

             HCRYPTMSG * phMsg                           - Pointer to HCRYPTMSG
                                                           to receive handle.
  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CSignedData::OpenToEncode(CMSG_SIGNER_ENCODE_INFO * pSignerEncodeInfo,
                                       DATA_BLOB               * pChainBlob,
                                       CAPICOM_CERTIFICATE_INCLUDE_OPTION IncludeOption,
                                       HCRYPTMSG               * phMsg)
{
    HRESULT     hr      = S_OK;
    HCRYPTMSG   hMsg    = NULL;
    DWORD       dwFlags = 0;
    CERT_BLOB * rgEncodedCertBlob = NULL;

    DWORD       i;
    CMSG_SIGNED_ENCODE_INFO SignedEncodeInfo;

    DebugTrace("Entering CSignedData::OpenToEncode().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pSignerEncodeInfo);
    ATLASSERT(pChainBlob);
    ATLASSERT(phMsg);

    //
    // Initialize.
    //
    ::ZeroMemory(&SignedEncodeInfo, sizeof(SignedEncodeInfo));

    DWORD cCertContext = pChainBlob->cbData;
    PCERT_CONTEXT * rgCertContext = (PCERT_CONTEXT *) pChainBlob->pbData;

    //
    // Determine number of cert(s) to include in the bag.
    //
    switch (IncludeOption)
    {
        case CAPICOM_CERTIFICATE_INCLUDE_END_ENTITY_ONLY:
        {
            cCertContext = 1;
            break;
        }

        case CAPICOM_CERTIFICATE_INCLUDE_WHOLE_CHAIN:
        {
            break;
        }

        case CAPICOM_CERTIFICATE_INCLUDE_CHAIN_EXCEPT_ROOT:
        {
            //
            // <<< Falling thru to default >>>
            //
        }

        default:
        {
            if (1 < cCertContext)
            {
                cCertContext--;
            }
            break;
        }
    }

    //
    // Allocate memory for the array.
    //
    if (!(rgEncodedCertBlob = (CERT_BLOB *) ::CoTaskMemAlloc(cCertContext * sizeof(CERT_BLOB))))
    {
        hr = E_OUTOFMEMORY;

        DebugTrace("Error: out of memory.\n");
        goto ErrorExit;
    }

    ::ZeroMemory(rgEncodedCertBlob, cCertContext * sizeof(CERT_BLOB));

    //
    // Build encoded certs array.
    //
    for (i = 0; i < cCertContext; i++)
    {
        rgEncodedCertBlob[i].cbData = rgCertContext[i]->cbCertEncoded;
        rgEncodedCertBlob[i].pbData = rgCertContext[i]->pbCertEncoded;
    }

    //
    // Setup up CMSG_SIGNED_ENCODE_INFO structure.
    //
    SignedEncodeInfo.cbSize = sizeof(CMSG_SIGNED_ENCODE_INFO);
    SignedEncodeInfo.cSigners = 1;
    SignedEncodeInfo.rgSigners = pSignerEncodeInfo;
    SignedEncodeInfo.cCertEncoded = cCertContext;
    SignedEncodeInfo.rgCertEncoded = rgEncodedCertBlob;

    //
    // Detached flag.
    //
    if (m_bDetached)
    {
        dwFlags = CMSG_DETACHED_FLAG;
    }

    //
    // Open a message to encode.
    //
    if (!(hMsg = ::CryptMsgOpenToEncode(CAPICOM_ASN_ENCODING,
                                        dwFlags,
                                        CMSG_SIGNED,
                                        &SignedEncodeInfo,
                                        NULL,
                                        NULL)))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptMsgOpenToEncode() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Returned message handle to caller.
    //
    *phMsg = hMsg;

CommonExit:
    //
    // Free resources.
    //
    if (rgEncodedCertBlob)
    {
        ::CoTaskMemFree(rgEncodedCertBlob);
    }

    DebugTrace("Leaving CSignedData::OpenToEncode().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (hMsg)
    {
        ::CryptMsgClose(hMsg);
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSignedData::OpenToDecode

  Synopsis : Open a signed message for decoding.

  Parameter: HCRYPTPROV hCryptProv - CSP handle or NULL for default CSP.

             HCRYPTMSG * phMsg - Pointer to HCRYPTMSG to receive handle.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CSignedData::OpenToDecode (HCRYPTPROV  hCryptProv,
                                        HCRYPTMSG * phMsg)
{
    HRESULT   hr        = S_OK;
    HCRYPTMSG hMsg      = NULL;
    DWORD     dwFlags   = 0;
    DWORD     dwMsgType = 0;
    DWORD     cbMsgType = sizeof(dwMsgType);

    DebugTrace("Entering CSignedData::OpenToDecode().\n");

    //
    // Sanity check.
    //
    ATLASSERT(phMsg);

    //
    // Detached flag.
    //
    if (m_bDetached)
    {
        dwFlags = CMSG_DETACHED_FLAG;
    }

    //
    // Open a message for decode.
    //
    if (!(hMsg = ::CryptMsgOpenToDecode(CAPICOM_ASN_ENCODING,   // ANS encoding type
                                        dwFlags,                // Flags
                                        0,                      // Message type (get from message)
                                        hCryptProv,             // Cryptographic provider
                                        NULL,                   // Inner content OID
                                        NULL)))                 // Stream information (not used)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptMsgOpenToDecode() failed.\n");
        goto ErrorExit;
    }

    //
    // Update message with signed content.
    //
    if (!::CryptMsgUpdate(hMsg,
                          m_MessageBlob.pbData,
                          m_MessageBlob.cbData,
                          TRUE))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        
        DebugTrace("Error [%#x]: CryptMsgUpdate() failed.\n",hr);
        goto ErrorExit;
    }

    //
    // Check message type.
    //
    if (!::CryptMsgGetParam(hMsg,
                            CMSG_TYPE_PARAM,
                            0,
                            (void *) &dwMsgType,
                            &cbMsgType))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptMsgGetParam() failed for CMSG_TYPE_PARAM.\n", hr);
        goto ErrorExit;
    }

    if (CMSG_SIGNED != dwMsgType)
    {
        hr = CAPICOM_E_SIGN_INVALID_TYPE;

        DebugTrace("Error: not an singed message.\n");
        goto ErrorExit;
    }

    //
    // If detached message, update content.
    //
    if (m_bDetached)
    {
        if (!::CryptMsgUpdate(hMsg,
                              m_ContentBlob.pbData,
                              m_ContentBlob.cbData,
                              TRUE))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
        
            DebugTrace("Error [%#x]: CryptMsgUpdate() failed.\n",hr);
            goto ErrorExit;
        }
    }
    else
    {
        //
        // Retrieve content.
        //
        if (FAILED(hr = ::GetMsgParam(hMsg, 
                                      CMSG_CONTENT_PARAM, 
                                      0, 
                                      (void **) &m_ContentBlob.pbData, 
                                      &m_ContentBlob.cbData)))
        {
            DebugTrace("Error [%#x]: GetMsgParam() failed to get CMSG_CONTENT_PARAM.\n", hr);
            goto ErrorExit;
        }
    }

    //
    // Returned message handle to caller.
    //
    *phMsg = hMsg;

CommonExit:

    DebugTrace("Leaving SignedData::OpenToDecode().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (hMsg)
    {
        ::CryptMsgClose(hMsg);
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSignedData::SignContent

  Synopsis : Sign the content by adding the very first signature to the message.

  Parameter: ISigner2 * pISigner2 - Poitner to ISigner2 object of signer.
  
             CMSG_SIGNER_ENCODE_INFO * pSignerEncodeInfo - Pointer to signer's
                                                           CMSG_SIGNER_ENCODE_INFO
                                                           structure.

             DATA_BLOB * pChainBlob - Pointer chain blob of PCCERT_CONTEXT.

             VARIANT_BOOL bDetached - Detached flag.

             CAPICOM_ENCODING_TYPE EncodingType - Encoding type.

             BSTR * pVal - Pointer to BSTR to receive the signed message.
  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CSignedData::SignContent (ISigner2                * pISigner2,
                                       CMSG_SIGNER_ENCODE_INFO * pSignerEncodeInfo,
                                       DATA_BLOB               * pChainBlob,
                                       VARIANT_BOOL              bDetached,
                                       CAPICOM_ENCODING_TYPE     EncodingType,
                                       BSTR                    * pVal)
{
    HRESULT   hr   = S_OK;
    HCRYPTMSG hMsg = NULL;
    DATA_BLOB MessageBlob = {0, NULL};
    CAPICOM_CERTIFICATE_INCLUDE_OPTION IncludeOption = CAPICOM_CERTIFICATE_INCLUDE_CHAIN_EXCEPT_ROOT;

    DebugTrace("Entering CSignedData::SignContent().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pISigner2);
    ATLASSERT(pSignerEncodeInfo);
    ATLASSERT(pChainBlob);
    ATLASSERT(pChainBlob->cbData);
    ATLASSERT(pChainBlob->pbData);
    ATLASSERT(pVal);

    ATLASSERT(m_ContentBlob.cbData);
    ATLASSERT(m_ContentBlob.pbData);

    try
    {
        //
        // Initialize member variables.
        //
        if (m_MessageBlob.pbData)
        {
            ::CoTaskMemFree(m_MessageBlob.pbData);
        }
        m_bSigned = FALSE;
        m_bDetached = bDetached;
        m_MessageBlob.cbData = 0;
        m_MessageBlob.pbData = NULL;

        //
        // Get signer option flag.
        //
        if (FAILED(hr = pISigner2->get_Options(&IncludeOption)))
        {
            DebugTrace("Error [%#x]: pISigner2->get_Options() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Open message to encode.
        //
        if (FAILED(hr = OpenToEncode(pSignerEncodeInfo,
                                     pChainBlob,
                                     IncludeOption,
                                     &hMsg)))
        {
            DebugTrace("Error [%#x]: OpenToEncode() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Update the message with data.
        //
        if (!::CryptMsgUpdate(hMsg,                     // Handle to the message
                              m_ContentBlob.pbData,     // Pointer to the content
                              m_ContentBlob.cbData,     // Size of the content
                              TRUE))                    // Last call
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
        
            DebugTrace("Error [%#x]: CryptMsgUpdate() failed.\n",hr);
            goto ErrorExit;
        }

        //
        // Retrieve the resulting message.
        //
        if (FAILED(hr = ::GetMsgParam(hMsg, 
                                      CMSG_CONTENT_PARAM, 
                                      0, 
                                      (void **) &MessageBlob.pbData, 
                                      &MessageBlob.cbData)))
        {
            DebugTrace("Error [%#x]: GetMsgParam() failed to get CMSG_CONTENT_PARAM.\n", hr);
            goto ErrorExit;
        }

        //
        // Now export the signed message.
        //
        if (FAILED(hr = ::ExportData(MessageBlob, EncodingType, pVal)))
        {
            DebugTrace("Error [%#x]: ExportData() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Write encoded blob to file, so we can use offline tool such as
        // ASN parser to analyze message. 
        //
        // The following line will resolve to void for non debug build, and
        // thus can be safely removed if desired.
        //
        DumpToFile("ExportedSigned.asn", MessageBlob.pbData, MessageBlob.cbData);

        //
        // Update member variables.
        //
        //
        if (m_MessageBlob.pbData)
        {
            ::CoTaskMemFree(m_MessageBlob.pbData);
        }

        m_bSigned = TRUE;
        m_bDetached = bDetached;
        m_MessageBlob = MessageBlob;
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }
CommonExit:
    //
    // Free resource.
    //
    if (hMsg)
    {
        ::CryptMsgClose(hMsg);
    }

    DebugTrace("Leaving CSignedData::SignContent().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (MessageBlob.pbData)
    {
        ::CoTaskMemFree(MessageBlob.pbData);
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSign::CoSignContent

  Synopsis : CoSign the content by adding another signature to the message.

  Parameter: ISigner2 * pISigner2 - Poitner to ISigner2 object of signer.
  
             CMSG_SIGNER_ENCODE_INFO * pSignerEncodeInfo - Pointer to signer's
                                                           CMSG_SIGNER_ENCODE_INFO
                                                           structure.

             DATA_BLOB * pChainBlob - Pointer chain blob of PCCERT_CONTEXT.

             CAPICOM_ENCODING_TYPE EncodingType - Encoding type.

             BSTR * pVal - Pointer to BSTR to receive the co-signed message.
  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CSignedData::CoSignContent (ISigner2                * pISigner2,
                                         CMSG_SIGNER_ENCODE_INFO * pSignerEncodeInfo,
                                         DATA_BLOB               * pChainBlob,
                                         CAPICOM_ENCODING_TYPE     EncodingType,
                                         BSTR                    * pVal)
{
    HRESULT   hr   = S_OK;
    HCRYPTMSG hMsg = NULL;
    DATA_BLOB MessageBlob = {0, NULL};
    CAPICOM_CERTIFICATE_INCLUDE_OPTION IncludeOption = CAPICOM_CERTIFICATE_INCLUDE_CHAIN_EXCEPT_ROOT;

    DebugTrace("Entering CSignedData::CoSignContent().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pISigner2);
    ATLASSERT(pSignerEncodeInfo);
    ATLASSERT(pChainBlob);
    ATLASSERT(pChainBlob->cbData);
    ATLASSERT(pChainBlob->pbData);
    ATLASSERT(pVal);

    ATLASSERT(m_bSigned);
    ATLASSERT(m_ContentBlob.cbData);
    ATLASSERT(m_ContentBlob.pbData);
    ATLASSERT(m_MessageBlob.cbData);
    ATLASSERT(m_MessageBlob.pbData);

    try
    {
        //
        // Get signer option flag.
        //
        if (FAILED(hr = pISigner2->get_Options(&IncludeOption)))
        {
            DebugTrace("Error [%#x]: pISigner2->get_Options() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Open the encoded message for decode.
        //
        if (FAILED(hr = OpenToDecode(pSignerEncodeInfo->hCryptProv, &hMsg)))
        {
            DebugTrace("Error [%#x]: OpenToDecode() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Add the co-signature to the message.
        //
        if (!::CryptMsgControl(hMsg,
                               0,
                               CMSG_CTRL_ADD_SIGNER,
                               (const void *) pSignerEncodeInfo))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
        
            DebugTrace("Error [%#x]: CryptMsgControl() failed for CMSG_CTRL_ADD_SIGNER.\n",hr);
            goto ErrorExit;
        }

        //
        // Add chain to message.
        //
        if (FAILED(hr = ::AddCertificateChain(hMsg, pChainBlob, IncludeOption)))
        {
            DebugTrace("Error [%#x]: AddCertificateChain() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Retrieve the resulting message.
        //
        if (FAILED(hr = ::GetMsgParam(hMsg, 
                                      CMSG_ENCODED_MESSAGE, 
                                      0, 
                                      (void **) &MessageBlob.pbData, 
                                      &MessageBlob.cbData)))
        {
            DebugTrace("Error [%#x]: GetMsgParam() failed to get CMSG_ENCODED_MESSAGE.\n",hr);
            goto ErrorExit;
        }

        //
        // Now export the signed message.
        //
        if (FAILED(hr = ::ExportData(MessageBlob, EncodingType, pVal)))
        {
            DebugTrace("Error [%#x]: ExportData() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Write encoded blob to file, so we can use offline tool such as
        // ASN parser to analyze message. 
        //
        // The following line will resolve to void for non debug build, and
        // thus can be safely removed if desired.
        //
        DumpToFile("ExportedCoSigned.asn", MessageBlob.pbData, MessageBlob.cbData);

        //
        // Update member variables.
        //
        //
        if (m_MessageBlob.pbData)
        {
            ::CoTaskMemFree(m_MessageBlob.pbData);
        }

        m_bSigned = TRUE;
        m_MessageBlob = MessageBlob;
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:
    //
    // Free resource.
    //
    if (hMsg)
    {
        ::CryptMsgClose(hMsg);
    }
 
    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (MessageBlob.pbData)
    {
        ::CoTaskMemFree(MessageBlob.pbData);
    }

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\signer.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Signer.cpp

  Content: Implementation of CSigner.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "Signer2.h"

#include "CertHlpr.h"
#include "Certificate.h"
#include "Chain.h"
#include "PFXHlpr.h"
#include "SignHlpr.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateSignerObject

  Synopsis : Create a ISigner object and initialize the object with the 
             specified certificate.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT.
  
             CRYPT_ATTRIBUTES * pAuthAttrs - Pointer to CRYPT_ATTRIBUTES
                                             of authenticated attributes.

             PCCERT_CHAIN_CONTEXT pChainContext - Chain context.

             DWORD dwCurrentSafety - Current safety setting.

             ISigner2 ** ppISigner2 - Pointer to pointer to ISigner object to
                                      receive the interface pointer.         
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateSignerObject (PCCERT_CONTEXT       pCertContext,
                            CRYPT_ATTRIBUTES   * pAuthAttrs,
                            PCCERT_CHAIN_CONTEXT pChainContext,
                            DWORD                dwCurrentSafety,
                            ISigner2 **          ppISigner2)
{
    HRESULT hr = S_OK;
    CComObject<CSigner> * pCSigner = NULL;

    DebugTrace("Entering CreateSignerObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(pAuthAttrs);
    ATLASSERT(ppISigner2);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CSigner>::CreateInstance(&pCSigner)))
        {
            DebugTrace("Error [%#x]: CComObject<CSigner>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize object.
        //
        if (FAILED(hr = pCSigner->Init(pCertContext, 
                                       pAuthAttrs, 
                                       pChainContext,
                                       dwCurrentSafety)))
        {
            DebugTrace("Error [%#x]: pCSigner->Init() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return interface pointer to caller.
        //
        if (FAILED(hr = pCSigner->QueryInterface(ppISigner2)))
        {
            DebugTrace("Error [%#x]: pCSigner->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreateSignerObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (pCSigner)
    {
        delete pCSigner;
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : GetSignerAdditionalStore

  Synopsis : Return the additional store, if any.

  Parameter: ISigner2 * pISigner - Pointer to signer object.
  
             HCERTSTORE * phCertStore - Pointer to HCERTSOTRE.

  Remark   : Caller must call CertCloseStore() for the handle returned.
 
------------------------------------------------------------------------------*/

HRESULT GetSignerAdditionalStore (ISigner2   * pISigner,
                                  HCERTSTORE * phCertStore)
{
    HRESULT           hr        = S_OK;
    CComPtr<ICSigner> pICSigner = NULL;

    DebugTrace("Entering GetSignerAdditionalStore().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pISigner);
    ATLASSERT(phCertStore);

    //
    // Get ICSigner interface pointer.
    //
    if (FAILED(hr = pISigner->QueryInterface(IID_ICSigner, (void **) &pICSigner)))
    {
        DebugTrace("Error [%#x]: pISigner->QueryInterface() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Get the HCERTSTORE.
    //
    if (FAILED(hr = pICSigner->get_AdditionalStore((long *) phCertStore)))
    {
        DebugTrace("Error [%#x]: pICSigner->get_AdditionalStore() failed.\n", hr);
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving GetSignerAdditionalStore().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : PutSignerAdditionalStore

  Synopsis : Set the additional store.

  Parameter: ISigner2 * pISigner - Pointer to signer object.
  
             HCERTSTORE hCertStore - Additional store handle.

  Remark   :
 
------------------------------------------------------------------------------*/

HRESULT PutSignerAdditionalStore (ISigner2   * pISigner,
                                  HCERTSTORE   hCertStore)
{
    HRESULT           hr        = S_OK;
    CComPtr<ICSigner> pICSigner = NULL;

    DebugTrace("Entering PutSignerAdditionalStore().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pISigner);
    ATLASSERT(hCertStore);

    //
    // Get ICSigner interface pointer.
    //
    if (FAILED(hr = pISigner->QueryInterface(IID_ICSigner, (void **) &pICSigner)))
    {
        DebugTrace("Error [%#x]: pISigner->QueryInterface() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Get the HCERTSTORE.
    //
    if (FAILED(hr = pICSigner->put_AdditionalStore((long) hCertStore)))
    {
        DebugTrace("Error [%#x]: pICSigner->put_AdditionalStore() failed.\n", hr);
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving PutSignerAdditionalStore().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// Local functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : SelectSignerCertCallback 

  Synopsis : Callback routine for CryptUIDlgSelectCertificateW() API for
             signer's cert selection.

  Parameter: See CryptUI.h for defination.

  Remark   : Filter out any cert that is not time valid or has no associated 
             private key.

             Also, note that we are not building chain here, since chain
             building is costly, and thus present poor user's experience.

             Instead, we will build the chain and check validity of the cert
             selected (see GetSignerCert function).

------------------------------------------------------------------------------*/

static BOOL WINAPI SelectSignerCertCallback (PCCERT_CONTEXT pCertContext,
                                             BOOL *         pfInitialSelectedCert,
                                             void *         pvCallbackData)
{
    BOOL  bResult   = FALSE;
    int   nValidity = 0;
    DWORD cb        = 0;

    //
    // Check availability of private key.
    //
    if (!::CertGetCertificateContextProperty(pCertContext, 
                                             CERT_KEY_PROV_INFO_PROP_ID, 
                                             NULL, 
                                             &cb))
    {
        DebugTrace("Info: SelectSignerCertCallback() - private key not found.\n");
        goto CommonExit;
    }

    //
    // Check cert time validity.
    //
    if (0 != (nValidity = ::CertVerifyTimeValidity(NULL, pCertContext->pCertInfo)))
    {
        DebugTrace("Info: SelectSignerCertCallback() - invalid time (%s).\n", 
                    nValidity < 0 ? "not yet valid" : "expired");
        goto CommonExit;
    }

    bResult = TRUE;

CommonExit:

    return bResult;
}


///////////////////////////////////////////////////////////////////////////////
//
// CSigner
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSigner::get_Certificate

  Synopsis : Return the signer's cert as an ICertificate object.

  Parameter: ICertificate ** pVal - Pointer to pointer to ICertificate to receive
                                    interface pointer.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CSigner::get_Certificate (ICertificate ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CSigner::get_Certificate().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure we indeed have a certificate.
        //
        if (!m_pICertificate)
        {
            hr = CAPICOM_E_SIGNER_NOT_INITIALIZED;

            DebugTrace("Error [%#x]: signer object currently does not have a certificate.\n", hr);
            goto ErrorExit;
        }

        //
        // Return interface pointer.
        //
        if (FAILED(hr = m_pICertificate->QueryInterface(pVal)))
        {
            DebugTrace("Unexpected error [%#x]: m_pICertificate->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CSigner::get_Certificate().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSigner::put_Certificate

  Synopsis : Set signer's cert.

  Parameter: ICertificate * newVal - Pointer to ICertificate.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CSigner::put_Certificate (ICertificate * newVal)
{
    HRESULT hr = S_OK;
    PCCERT_CONTEXT pCertContext = NULL;

    DebugTrace("Entering CSigner::put_Certificate().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure is a valid ICertificate by getting its CERT_CONTEXT.
        //
        if (FAILED(hr = ::GetCertContext(newVal, &pCertContext)))
        {
            DebugTrace("Error [%#x]: GetCertContext() failed.\n", hr);
            goto ErrorExit;
        }
        
        //
        // Free the CERT_CONTEXT.
        //
        if (!::CertFreeCertificateContext(pCertContext))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertFreeCertificateContext() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Reset.
        //
        if (FAILED(hr = m_pIAttributes->Clear()))
        {
            DebugTrace("Error [%#x]: m_pIAttributes->Clear() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Store new ICertificate.
        //
        m_pICertificate = newVal;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CSigner::put_Certificate().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSigner::get_AuthenticatedAttributes

  Synopsis : Property to return the IAttributes collection object authenticated
             attributes.

  Parameter: IAttributes ** pVal - Pointer to pointer to IAttributes to receive
                                   the interface pointer.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CSigner::get_AuthenticatedAttributes (IAttributes ** pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CSigner::get_AuthenticatedAttributes().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Sanity check.
        //
        ATLASSERT(m_pIAttributes);

        //
        // Return interface pointer to caller.
        //
        if (FAILED(hr = m_pIAttributes->QueryInterface(pVal)))
        {
            DebugTrace("Unexpected error [%#x]: m_pIAttributes->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CSigner::get_AuthenticatedAttributes().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSigner::get_Chain

  Synopsis : Return the signer's chain as an IChain object.

  Parameter: ICertificate ** pVal - Pointer to pointer to ICertificate to receive
                                    interface pointer.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CSigner::get_Chain (IChain ** pVal)
{
    HRESULT              hr            = S_OK;
    PCCERT_CONTEXT       pCertContext  = NULL;
    PCCERT_CHAIN_CONTEXT pChainContext = NULL;

    DebugTrace("Entering CSigner::get_Chain().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Build the chain, if not available.
        //
        if (!m_pIChain)
        {
            //
            // Make sure we have a certificate to build the chain.
            //
            if (!m_pICertificate)
            {
                hr = CAPICOM_E_SIGNER_NOT_INITIALIZED;

                DebugTrace("Error [%#x]: signer object currently does not have a certificate.\n", hr);
                goto ErrorExit;
            }

            if (FAILED(hr = ::GetCertContext(m_pICertificate, &pCertContext)))
            {
                DebugTrace("Error [%#x]: GetCertContext() failed.\n", hr);
                goto ErrorExit;
            }

            if (FAILED(hr = ::BuildChain(pCertContext, NULL, CERT_CHAIN_POLICY_BASE, &pChainContext)))
            {
                DebugTrace("Error [%#x]: BuildChain() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Now create the chain object.
            //
            if (FAILED(hr = ::CreateChainObject(pChainContext, &m_pIChain)))
            {
                DebugTrace("Error [%#x]: CreateChainObject() failed.\n", hr);
                goto ErrorExit;
            }
        }

        //
        // Return the signer's chain.
        //
        if (FAILED(hr = m_pIChain->QueryInterface(pVal)))
        {
            DebugTrace("Unexpected error [%#x]: m_pIChain->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resources.
    //
    if (pCertContext)
    {
        ::CertFreeCertificateContext(pCertContext);
    }
    if (pChainContext)
    {
        ::CertFreeCertificateChain(pChainContext);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CSigner::get_Chain().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSigner::get_Options

  Synopsis : Get signer's options.

  Parameter: CAPICOM_CERTIFICATE_INCLUDE_OPTION * pVal - Pointer to variable
                                                         receive value.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CSigner::get_Options (CAPICOM_CERTIFICATE_INCLUDE_OPTION * pVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CSigner::get_Options().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        *pVal = (CAPICOM_CERTIFICATE_INCLUDE_OPTION) m_dwIncludeOption;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CSigner::get_Options().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSigner::put_Options

  Synopsis : Set signer's options.

  Parameter: CAPICOM_CERTIFICATE_INCLUDE_OPTION newVal - Include option.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CSigner::put_Options (CAPICOM_CERTIFICATE_INCLUDE_OPTION newVal)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CSigner::put_Options().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        m_dwIncludeOption = (DWORD) newVal;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CSigner::put_Options().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSigner::Load

  Synopsis : Method to load signing certificate from a PFX file.

  Parameter: BSTR FileName - PFX file name.

             BSTR Password - Password.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CSigner::Load (BSTR FileName,
                            BSTR Password)
{
    HRESULT                hr            = S_OK;
    CAPICOM_STORE_INFO     StoreInfo     = {CAPICOM_STORE_INFO_HCERTSTORE, NULL};
    CComPtr<ICertificate2> pICertificate = NULL;

    DebugTrace("Entering CSigner::Load().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Not allowed if called from WEB script.
        //
        if (m_dwCurrentSafety)
        {
            hr = CAPICOM_E_NOT_ALLOWED;

            DebugTrace("Error [%#x]: Loading cert file from WEB script is not allowed.\n", hr);
            goto ErrorExit;
        }

        //
        // Check parameters.
        //
        if (NULL == FileName)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: FileName parameter is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Work around MIDL problem.
        //
        if (0 == ::SysStringLen(Password))
        {
            Password = NULL;
        }

        //
        // Load the PFX.
        //
        if (FAILED(hr = ::PFXLoadStore((LPWSTR) FileName, 
                                       (LPWSTR) Password,
                                       0,
                                       &StoreInfo.hCertStore)))
        {
            DebugTrace("Error [%#x]: PFXLoadStore() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Get the signer's cert (may prompt user to select signer's cert).
        //
        if (FAILED(hr = ::SelectCertificate(StoreInfo,
                                            SelectSignerCertCallback,
                                            &pICertificate)))
        {
            DebugTrace("Error [%#x]: SelectCertificate() failed.\n", hr);
            goto ErrorExit;
        }

        if (FAILED(hr = pICertificate->QueryInterface(__uuidof(ICertificate), (void **) &m_pICertificate)))
        {
            DebugTrace("Error [%#x]: pICertificate2->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Free any existing store, and then update the store.
        //
        if (m_hCertStore)
        {
            HRESULT hr2;

            //
            // Ignore error.
            //
            if (m_bPFXStore)
            {
                if (FAILED(hr2 = ::PFXFreeStore(m_hCertStore)))
                {
                    DebugTrace("Info [%#x]: PFXFreeStore() failed.\n", hr2);
                }
            }
            else
            {
                if (!::CertCloseStore(m_hCertStore, 0))
                {
                    hr2 = HRESULT_FROM_WIN32(::GetLastError());

                    DebugTrace("Info [%#x]: CertCloseStore() failed.\n", hr2);
                }
            }
        }

        m_hCertStore = StoreInfo.hCertStore;
        m_bPFXStore  = TRUE;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CSigner::Load().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resources.
    //
    if (StoreInfo.hCertStore)
    {
        ::PFXFreeStore(StoreInfo.hCertStore);
    }

    ReportError(hr);

    goto UnlockExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// Custom interfaces.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSigner::get_AdditionalStore

  Synopsis : Return the signer additional store handle.

  Parameter: long * phAdditionalStore - Pointer to long to receive the HCERTSTORE.

  Remark   : Caller must call CertCloseStore() for the handle returned.
  
------------------------------------------------------------------------------*/

STDMETHODIMP CSigner::get_AdditionalStore (long * phAdditionalStore)
{
    HRESULT    hr         = S_OK;
    HCERTSTORE hCertStore = NULL;

    DebugTrace("Entering CSigner::get_AdditionalStore().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameter.
        //
        if (NULL == phAdditionalStore)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter phAdditionalStore is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Initialize.
        //
        *phAdditionalStore = NULL;

        //
        // Duplicate store handle, if available.
        //
        if (NULL != m_hCertStore)
        {
            if (NULL == (hCertStore = ::CertDuplicateStore(m_hCertStore)))
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());

                DebugTrace("Error [%#x]: CertDuplicateStore() failed.\n", hr);
                goto ErrorExit;
            }

            *phAdditionalStore = (long) hCertStore;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CSigner::get_AdditionalStore().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    //
    // Release resources.
    //
    if (hCertStore)
    {
        ::CertCloseStore(hCertStore, 0);
    }

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSigner::put_AdditionalStore

  Synopsis : Set the additional sore handle.

  Parameter: long hAdditionalStore - Additional store handle.

  Remark   :
  
------------------------------------------------------------------------------*/

STDMETHODIMP CSigner::put_AdditionalStore (long hAdditionalStore)
{
    HRESULT    hr         = S_OK;
    HCERTSTORE hCertStore = (HCERTSTORE) hAdditionalStore;

    DebugTrace("Entering CSigner::put_AdditionalStore().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameter.
        //
        if (NULL == hCertStore)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter hAdditionalStore is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Free any existing store, and then update the store.
        //
        if (m_hCertStore)
        {
            HRESULT hr2;

            //
            // Ignore error.
            //
            if (m_bPFXStore)
            {
                if (FAILED(hr2 = ::PFXFreeStore(m_hCertStore)))
                {
                    DebugTrace("Info [%#x]: PFXFreeStore() failed.\n", hr2);
                }
            }
            else
            {
                if (!::CertCloseStore(m_hCertStore, 0))
                {
                    hr2 = HRESULT_FROM_WIN32(::GetLastError());

                    DebugTrace("Info [%#x]: CertCloseStore() failed.\n", hr2);
                }
            }
        }

        //
        // Don't know what kind of store this is, so mark it as such so that we
        // will always close it with CertCloseStore(), instead of PFXFreeStore().
        //
        m_bPFXStore = FALSE;

        //
        // Duplicate store handle.
        //
        if (NULL == (m_hCertStore = ::CertDuplicateStore(hCertStore)))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertDuplicateStore() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CSigner::put_AdditionalStore().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// Private methods.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSigner::Init

  Synopsis : Initialize the object.

  Parameter: PCERT_CONTEXT pCertContext - Poiner to CERT_CONTEXT used to 
                                          initialize this object, or NULL.

             CRYPT_ATTRIBUTES * pAuthAttrs - Pointer to CRYPT_ATTRIBUTES
                                             of authenticated attributes.

             PCCERT_CHAIN_CONTEXT pChainContext - Chain context.

             DWORD dwCurrentSafety - Current safety setting.

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CSigner::Init (PCCERT_CONTEXT       pCertContext, 
                            CRYPT_ATTRIBUTES   * pAuthAttrs,
                            PCCERT_CHAIN_CONTEXT pChainContext,
                            DWORD                dwCurrentSafety)
{
    HRESULT hr = S_OK;
    CComPtr<ICertificate2> pICertificate = NULL;
    CComPtr<IAttributes>   pIAttributes  = NULL;
    CComPtr<IChain>        pIChain       = NULL;

    DebugTrace("Entering CSigner::Init().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(pAuthAttrs);

    //
    // Create the embeded ICertificate2 object.
    //
    if (FAILED(hr = ::CreateCertificateObject(pCertContext, dwCurrentSafety, &pICertificate)))
    {
        DebugTrace("Error [%#x]: CreateCertificateObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Create the embeded IAttributes collection object.
    //
    if (FAILED(hr = ::CreateAttributesObject(pAuthAttrs, &pIAttributes)))
    {
        DebugTrace("Error [%#x]: CreateAttributesObject() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Created the embeded IChain object if available.
    //
    if (pChainContext)
    {
        if (FAILED(hr = ::CreateChainObject(pChainContext, &pIChain)))
        {
            DebugTrace("Error [%#x]: CreateChainObject() failed.\n", hr);
            goto ErrorExit;
        }
    }

    //
    // Reset.
    //
    m_pICertificate   = pICertificate;
    m_pIAttributes    = pIAttributes;
    m_pIChain         = pIChain;
    m_dwCurrentSafety = dwCurrentSafety;

CommonExit:

    DebugTrace("Leaving CSigner::Init().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\signeddata.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    SignedData.h

  Content: Declaration of the CSignedData.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#ifndef __SIGNEDDATA_H_
#define __SIGNEDDATA_H_

#include "Resource.h"
#include "Error.h"
#include "Lock.h"
#include "Debug.h"
#include "DialogUI.h"

///////////////////////////////////////////////////////////////////////////////
//
// CSignedData
//

class ATL_NO_VTABLE CSignedData : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSignedData, &CLSID_SignedData>,
    public ICAPICOMError<CSignedData, &IID_ISignedData>,
    public IPromptUser<CSignedData>,
    public IDispatchImpl<ISignedData, &IID_ISignedData, &LIBID_CAPICOM,
                         CAPICOM_MAJOR_VERSION, CAPICOM_MINOR_VERSION>,
    public IObjectSafetyImpl<CSignedData, INTERFACESAFE_FOR_UNTRUSTED_CALLER | 
                                          INTERFACESAFE_FOR_UNTRUSTED_DATA>
{
public:
    CSignedData()
    {
    }

DECLARE_REGISTRY_RESOURCEID(IDR_SIGNEDDATA)

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSignedData)
    COM_INTERFACE_ENTRY(ISignedData)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(IObjectWithSite)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CSignedData)
    IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
    IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
END_CATEGORY_MAP()


    HRESULT FinalConstruct()
    {
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for SignedData object.\n", hr);
            return hr;
        }

        m_bSigned   = FALSE;
        m_bDetached = VARIANT_FALSE;
        m_ContentBlob.cbData = 0;
        m_ContentBlob.pbData = NULL;
        m_MessageBlob.cbData = 0;
        m_MessageBlob.pbData = NULL;

        return S_OK;
    }

    void FinalRelease()
    {
        if (m_ContentBlob.pbData)
        {
            ::CoTaskMemFree(m_ContentBlob.pbData);
        }

        if (m_MessageBlob.pbData)
        {
            ::CoTaskMemFree(m_MessageBlob.pbData);
        }
    }

//
// ISignedData
//
public:
    STDMETHOD(Verify)
        (/*[in]*/ BSTR SignedMessage, 
         /*[in, defaultvalue(0)]*/ VARIANT_BOOL bDetached, 
         /*[in, defaultvalue(CAPICOM_VERIFY_SIGNATURE_AND_CERTIFICATE)]*/ CAPICOM_SIGNED_DATA_VERIFY_FLAG VerifyFlag);

    STDMETHOD(CoSign)
        (/*[in, defaultvalue(NULL)]*/ ISigner * pSigner,
         /*[in, defaultvalue(CAPICOM_BASE64_ENCODE)]*/ CAPICOM_ENCODING_TYPE EncodingType,
         /*[out, retval]*/ BSTR * pVal);

    STDMETHOD(Sign)
        (/*[in, defaultvalue(NULL)]*/ ISigner * pSigner,
         /*[in, defaultvalue(0)]*/ VARIANT_BOOL bDetached, 
         /*[in, defaultvalue(CAPICOM_BASE64_ENCODE)]*/ CAPICOM_ENCODING_TYPE EncodingType,
         /*[out, retval]*/ BSTR * pVal);

    STDMETHOD(get_Certificates)
        (/*[out, retval]*/ ICertificates ** pVal);

    STDMETHOD(get_Signers)
        (/*[out, retval]*/ ISigners ** pVal);

    STDMETHOD(get_Content)
        (/*[out, retval]*/ BSTR * pVal);

    STDMETHOD(put_Content)
        (/*[in]*/ BSTR newVal);

private:
    CLock        m_Lock;
    BOOL         m_bSigned;
    VARIANT_BOOL m_bDetached;
    DATA_BLOB    m_ContentBlob;
    DATA_BLOB    m_MessageBlob;

    STDMETHOD(OpenToEncode)
        (CMSG_SIGNER_ENCODE_INFO * pSignerEncodeInfo,
         DATA_BLOB * pChainBlob,
         CAPICOM_CERTIFICATE_INCLUDE_OPTION IncludeOption,
         HCRYPTMSG * phMsg);

    STDMETHOD(OpenToDecode)
        (HCRYPTPROV hCryptProv,
         HCRYPTMSG * phMsg);

    STDMETHOD(SignContent)
        (ISigner2 * pISigner2,
         CMSG_SIGNER_ENCODE_INFO * pSignerEncodeInfo,
         DATA_BLOB * pChainBlob,
         VARIANT_BOOL bDetached,
         CAPICOM_ENCODING_TYPE EncodingType,
         BSTR * pVal);

    STDMETHOD(CoSignContent)
        (ISigner2 * pISigner2,
         CMSG_SIGNER_ENCODE_INFO * pSignerEncodeInfo,
         DATA_BLOB * pChainBlob,
         CAPICOM_ENCODING_TYPE EncodingType,
         BSTR * pVal);
};

#endif //__SIGNEDDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\signer2.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Signer.h

  Content: Declaration of the CSigner.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/
    
#ifndef __SIGNER_H_
#define __SIGNER_H_

#include "Resource.h"
#include "Error.h"
#include "Lock.h"
#include "Debug.h"
#include "Attributes.h"
#include "PFXHlpr.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateSignerObject

  Synopsis : Create a ISigner object and initialize the object with the 
             specified certificate.

  Parameter: PCCERT_CONTEXT pCertContext - Pointer to CERT_CONTEXT.
  
             CRYPT_ATTRIBUTES * pAuthAttrs - Pointer to CRYPT_ATTRIBUTES
                                             of authenticated attributes.

             PCCERT_CHAIN_CONTEXT pChainContext - Chain context.

             DWORD dwCurrentSafety - Current safety setting.

             ISigner2 ** ppISigner2 - Pointer to pointer to ISigner object to
                                      receive the interface pointer.         
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateSignerObject (PCCERT_CONTEXT       pCertContext,
                            CRYPT_ATTRIBUTES   * pAuthAttrs,
                            PCCERT_CHAIN_CONTEXT pChainContext,
                            DWORD                dwCurrentSafety,
                            ISigner2 **          ppISigner2);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : GetSignerAdditionalStore

  Synopsis : Return the additional store, if any.

  Parameter: ISigner2 * pISigner - Pointer to signer object.
  
             HCERTSTORE * phCertStore - Pointer to HCERTSOTRE.

  Remark   : Caller must call CertCloseStore() for the handle returned.
 
------------------------------------------------------------------------------*/

HRESULT GetSignerAdditionalStore (ISigner2   * pISigner,
                                  HCERTSTORE * phCertStore);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : PutSignerAdditionalStore

  Synopsis : Set the additional store.

  Parameter: ISigner2 * pISigner - Pointer to signer object.
  
             HCERTSTORE hCertStore - Additional store handle.

  Remark   :
 
------------------------------------------------------------------------------*/

HRESULT PutSignerAdditionalStore (ISigner2   * pISigner,
                                  HCERTSTORE   hCertStore);

///////////////////////////////////////////////////////////////////////////////
//
// CSigner
//

class ATL_NO_VTABLE CSigner : ICSigner,
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSigner, &CLSID_Signer>,
    public ICAPICOMError<CSigner, &IID_ISigner>,
    public IDispatchImpl<ISigner2, &IID_ISigner2, &LIBID_CAPICOM,
                         CAPICOM_MAJOR_VERSION, CAPICOM_MINOR_VERSION>,
    public IObjectSafetyImpl<CSigner, INTERFACESAFE_FOR_UNTRUSTED_CALLER | 
                                      INTERFACESAFE_FOR_UNTRUSTED_DATA>
{
public:
    CSigner()
    {
    }

DECLARE_REGISTRY_RESOURCEID(IDR_SIGNER)

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSigner)
    COM_INTERFACE_ENTRY(ISigner)
    COM_INTERFACE_ENTRY(ISigner2)
    COM_INTERFACE_ENTRY(ICSigner)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CSigner)
    IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
    IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
END_CATEGORY_MAP()

    HRESULT FinalConstruct()
    {
        HRESULT hr;
        CRYPT_ATTRIBUTES attributes = {0, NULL};

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for Signer object.\n", hr);
            return hr;
        }

        //
        // Create the embeded IAttributes collection object.
        //
        if (FAILED(hr = ::CreateAttributesObject(&attributes, &m_pIAttributes)))
        {
            DebugTrace("Error [%#x]: CreateAttributesObject() failed.\n", hr);
            return hr;
        }

        m_pICertificate   = NULL;
        m_hCertStore      = NULL;
        m_dwIncludeOption = 0;
        m_bPFXStore       = FALSE;
        
        return S_OK;
    }

    void FinalRelease()
    {
        m_pICertificate.Release();
        m_pIAttributes.Release();
        m_pIChain.Release();
        if (m_hCertStore)
        {
            if (m_bPFXStore)
            {
                ::PFXFreeStore(m_hCertStore);
            }
            else
            {
                ::CertCloseStore(m_hCertStore, 0);
            }
         }
    }

//
// ISigner
//
public:
    STDMETHOD(get_Certificate)
        (/*[out, retval]*/ ICertificate ** pVal);

    STDMETHOD(put_Certificate)
        (/*[in]*/ ICertificate * newVal);

    STDMETHOD(get_AuthenticatedAttributes)
        (/*[out, retval]*/ IAttributes ** pVal);

    STDMETHOD(get_Chain)
        (/*[out, retval]*/ IChain ** pVal);

    STDMETHOD(get_Options)
        (/*[out, retval]*/ CAPICOM_CERTIFICATE_INCLUDE_OPTION * pVal);

    STDMETHOD(put_Options)
        (/*[in, defaultvalue(CAPICOM_CERTIFICATE_INCLUDE_CHAIN_EXCEPT_ROOT)]*/ CAPICOM_CERTIFICATE_INCLUDE_OPTION IncludeOption);

    STDMETHOD(Load)
        (/*[in]*/ BSTR FileName, 
         /*[in, defaultvalue("")]*/ BSTR Password);

    //
    // Custom inferfaces.
    //
    STDMETHOD(get_AdditionalStore)
        (/*[out, retval]*/ long * phAdditionalStore);

    STDMETHOD(put_AdditionalStore)
        (/*[in]*/ long hAdditionalStore);

    //
    // None COM functions.
    //
    STDMETHOD(Init)
        (PCCERT_CONTEXT       pCertContext, 
         CRYPT_ATTRIBUTES   * pAttributes,
         PCCERT_CHAIN_CONTEXT pChainContext,
         DWORD                dwCurrentSafety);

private:
    CLock                 m_Lock;
    CComPtr<ICertificate> m_pICertificate;
    CComPtr<IAttributes>  m_pIAttributes;
    CComPtr<IChain>       m_pIChain;
    HCERTSTORE            m_hCertStore;
    BOOL                  m_bPFXStore;
    DWORD                 m_dwIncludeOption;
};

#endif //__SIGNER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\signers.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Signers.h

  Content: Declaration of CSigners.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#ifndef __SIGNERS_H_
#define __SIGNERS_H_

#include "Resource.h"
#include "Lock.h"
#include "Debug.h"
#include "CopyItem.h"

////////////////////
//
// Locals
//

//
// typdefs to make life easier.
//
typedef std::map<CComBSTR, CComPtr<ISigner2> > SignerMap;
typedef CComEnumOnSTL<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _CopyMapItem<ISigner2>, SignerMap> SignerEnum;
typedef ICollectionOnSTLImpl<ISigners, SignerMap, VARIANT, _CopyMapItem<ISigner2>, SignerEnum> ISignersCollection;


////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateSignersObject

  Synopsis : Create an ISigners collection object, and load the object with 
             signers from the specified signed message for a specified level.

  Parameter: HCRYPTMSG hMsg - Message handle.

             DWORD dwLevel - Signature level (1 based).

             HCERTSTORE hStore - Additional store.

             DWORD dwCurrentSafety - Current safety setting.

             ISigners ** ppISigners - Pointer to pointer ISigners to receive
                                      interface pointer.             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateSignersObject (HCRYPTMSG   hMsg, 
                             DWORD       dwLevel, 
                             HCERTSTORE  hStore,
                             DWORD       dwCurrentSafety,
                             ISigners ** ppISigners);

////////////////////////////////////////////////////////////////////////////////
//
// CSigners
//

class ATL_NO_VTABLE CSigners : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSigners, &CLSID_Signers>,
    public IDispatchImpl<ISignersCollection, &IID_ISigners, &LIBID_CAPICOM,
                         CAPICOM_MAJOR_VERSION, CAPICOM_MINOR_VERSION>
{
public:
    CSigners()
    {
    }

DECLARE_NO_REGISTRY()

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSigners)
    COM_INTERFACE_ENTRY(ISigners)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CSigners)
END_CATEGORY_MAP()

    HRESULT FinalConstruct()
    {
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for Attributes object.\n", hr);
            return hr;
        }

        m_dwCurrentSafety = 0;

        return S_OK;
    }

//
// ISigners
//
public:
    //
    // These are the only ones that we need to implemented, others will be
    // handled by ATL ICollectionOnSTLImpl.
    //

    //
    // None COM functions.
    //
    STDMETHOD(Add)
        (PCCERT_CONTEXT       pCertContext, 
         CRYPT_ATTRIBUTES   * pAuthAttrs,
         PCCERT_CHAIN_CONTEXT pChainContext);

    STDMETHOD(LoadMsgSigners)
        (HCRYPTMSG  hMsg, 
         DWORD      dwLevel,
         HCERTSTORE hStore,
         DWORD      dwCurrentSafety);

#if (0)
    STDMETHOD(LoadCodeSigners)
        (CRYPT_PROVIDER_DATA * pProvData);
#endif

private:
    CLock   m_Lock;
    DWORD   m_dwCurrentSafety;
};

#endif //__SIGNERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\signhlpr.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000 - 2001.

  File:    SignHlpr.cpp

  Content: Helper functions for signing.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "SignHlpr.h"

#include "Common.h"
#include "CertHlpr.h"
#include "Certificate.h"
#include "Signer2.h"

////////////////////////////////////////////////////////////////////////////////
//
// Local functions.
//


////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : FreeAttributes

  Synopsis : Free elements of an attribute array.

  Parameter: DWORD cAttr - Number fo attributes
  
             PCRYPT_ATTRIBUTE rgAuthAttr - Pointer to CRYPT_ATTRIBUTE array.

  Remark   :

------------------------------------------------------------------------------*/

void FreeAttributes (DWORD            cAttr, 
                     PCRYPT_ATTRIBUTE rgAttr)
{
    DebugTrace("Entering FreeAttributes().\n");

    //
    // Free each element of the array.
    //
    for (DWORD i = 0; i < cAttr; i++)
    {
        //
        // Make sure pointer is valid.
        //
        if (rgAttr[i].rgValue)
        {
            for (DWORD j = 0; j < rgAttr[i].cValue; j++)
            {
                if (rgAttr[i].rgValue[j].pbData)
                {
                    ::CoTaskMemFree((LPVOID) rgAttr[i].rgValue[j].pbData);
                }
            }

            ::CoTaskMemFree((LPVOID) rgAttr[i].rgValue);   
        }
    }   
    
    DebugTrace("Leaving FreeAttributes().\n");

    return;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : FreeAttributes

  Synopsis : Free memory allocated for all attributes.

  Parameter: PCRYPT_ATTRIBUTES pAttributes

  Remark   :

------------------------------------------------------------------------------*/

void FreeAttributes (PCRYPT_ATTRIBUTES pAttributes)
{
    //
    // Sanity check.
    //
    ATLASSERT(pAttributes);

    //
    // Do we have any attribute?
    //
    if (pAttributes->rgAttr)
    {
        //
        // First free elements of array.
        //
        FreeAttributes(pAttributes->cAttr, pAttributes->rgAttr);

        //
        // Then free the array itself.
        //
        ::CoTaskMemFree((LPVOID) pAttributes->rgAttr);
    }

    ::ZeroMemory(pAttributes, sizeof(CRYPT_ATTRIBUTES));

    return;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : GetAuthenticatedAttributes

  Synopsis : Encode and return authenticated attributes of the specified signer.

  Parameter: ISigner * pISigner - Pointer to ISigner.
  
             PCRYPT_ATTRIBUTES pAttributes

  Remark   :

------------------------------------------------------------------------------*/

HRESULT GetAuthenticatedAttributes (ISigner         * pISigner,
                                    PCRYPT_ATTRIBUTES pAttributes)
{
    HRESULT hr          = S_OK;
    long                 cAttr = 0;
    PCRYPT_ATTRIBUTE     rgAttr = NULL;
    CComPtr<IAttributes> pIAttributes = NULL;

    DebugTrace("Entering GetAuthenticatedAttributes().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pISigner);
    ATLASSERT(pAttributes);

    //
    // Initialize.
    //
    ::ZeroMemory(pAttributes, sizeof(CRYPT_ATTRIBUTES));

    //
    // Get authenticated attributes.
    //
    if (FAILED(hr = pISigner->get_AuthenticatedAttributes(&pIAttributes)))
    {
        DebugTrace("Error [%#x]: pISigner->get_AuthenticatedAttributes() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Get count of attributes.
    //
    if (FAILED(hr = pIAttributes->get_Count(&cAttr)))
    {
        DebugTrace("Error [%#x]: pIAttributes->get_Count() failed.\n", hr);
        goto ErrorExit;
    }

    if (0 < cAttr)
    {
        //
        // Allocate memory for attribute array.
        //
        if (!(rgAttr = (PCRYPT_ATTRIBUTE) ::CoTaskMemAlloc(sizeof(CRYPT_ATTRIBUTE) * cAttr)))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error: out of memory.\n");
            goto ErrorExit;
        }

        ::ZeroMemory(rgAttr, sizeof(CRYPT_ATTRIBUTE) * cAttr);

        //
        // Loop thru each attribute and add to the array.
        //
        for (long i = 0; i < cAttr; i++)
        {
            CAPICOM_ATTRIBUTE AttrName;
            CComVariant varValue;
            CComVariant varIAttribute;
            CComPtr<IAttribute> pIAttribute = NULL;

            //
            // Get next attribute.
            //
            if (FAILED(hr = pIAttributes->get_Item(i + 1, &varIAttribute)))
            {
                DebugTrace("Error [%#x]: pIAttributes->get_Item() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Get custom interface.
            //
            if (FAILED(hr = varIAttribute.pdispVal->QueryInterface(IID_IAttribute, 
                                                                   (void **) &pIAttribute)))
            {
                DebugTrace("Error [%#x]: varIAttribute.pdispVal->QueryInterface() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Get attribute name.
            //
            if (FAILED(hr = pIAttribute->get_Name(&AttrName)))
            {
                DebugTrace("Error [%#x]: pIAttribute->get_Name() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Get attribute value.
            //
            if (FAILED(hr = pIAttribute->get_Value(&varValue)))
            {
                DebugTrace("Error [%#x]: pIAttribute->get_Value() failed.\n", hr);
                goto ErrorExit;
            }

            switch (AttrName)
            {
                case CAPICOM_AUTHENTICATED_ATTRIBUTE_SIGNING_TIME:
                {
                    FILETIME ft;
                    SYSTEMTIME st;

                    //
                    // Conver to FILETIME.
                    //
                    if (!::VariantTimeToSystemTime(varValue.date, &st))
                    {
                        hr = CAPICOM_E_ATTRIBUTE_INVALID_VALUE;

                        DebugTrace("Error [%#x]: VariantTimeToSystemTime() failed.\n");
                        goto ErrorExit;
                    }

                    if (!::SystemTimeToFileTime(&st, &ft))
                    {
                        hr = CAPICOM_E_ATTRIBUTE_INVALID_VALUE;

                        DebugTrace("Error [%#x]: VariantTimeToSystemTime() failed.\n");
                        goto ErrorExit;
                    }

                    //
                    // Now encode it.
                    //
                    rgAttr[i].cValue = 1;
                    rgAttr[i].pszObjId = szOID_RSA_signingTime;
                    if (!(rgAttr[i].rgValue = (CRYPT_ATTR_BLOB *) ::CoTaskMemAlloc(sizeof(CRYPT_ATTR_BLOB))))
                    {
                        hr = E_OUTOFMEMORY;

                        DebugTrace("Error: out of memory.\n");
                        goto ErrorExit;
                    }

                    if (FAILED(hr = ::EncodeObject((LPSTR) szOID_RSA_signingTime, 
                                                   (LPVOID) &ft, 
                                                   rgAttr[i].rgValue)))
                    {
                        DebugTrace("Error [%#x]: EncodeObject() failed.\n", hr);
                        goto ErrorExit;
                    }
                    
                    break;
                }

                case CAPICOM_AUTHENTICATED_ATTRIBUTE_DOCUMENT_NAME:
                {
                    CRYPT_DATA_BLOB NameBlob = {0, NULL};

                    NameBlob.cbData = ::SysStringByteLen(varValue.bstrVal);
                    NameBlob.pbData = (PBYTE) varValue.bstrVal;

                    rgAttr[i].cValue = 1;
                    rgAttr[i].pszObjId = szOID_CAPICOM_DOCUMENT_NAME;
                    if (!(rgAttr[i].rgValue = (CRYPT_ATTR_BLOB *) ::CoTaskMemAlloc(sizeof(CRYPT_ATTR_BLOB))))
                    {
                        hr = E_OUTOFMEMORY;

                        DebugTrace("Error: out of memory.\n");
                        goto ErrorExit;
                    }

                    if (FAILED(hr = ::EncodeObject((LPSTR) X509_OCTET_STRING, 
                                                   (LPVOID) &NameBlob, 
                                                   rgAttr[i].rgValue)))
                    {
                        DebugTrace("Error [%#x]: EncodeObject() failed.\n", hr);
                        goto ErrorExit;
                    }

                    break;
                }

                case CAPICOM_AUTHENTICATED_ATTRIBUTE_DOCUMENT_DESCRIPTION:
                {
                    CRYPT_DATA_BLOB DescBlob = {0, NULL};

                    DescBlob.cbData = ::SysStringByteLen(varValue.bstrVal);
                    DescBlob.pbData = (PBYTE) varValue.bstrVal;

                    rgAttr[i].cValue = 1;
                    rgAttr[i].pszObjId = szOID_CAPICOM_DOCUMENT_DESCRIPTION;
                    if (!(rgAttr[i].rgValue = (CRYPT_ATTR_BLOB *) ::CoTaskMemAlloc(sizeof(CRYPT_ATTR_BLOB))))
                    {
                        hr = E_OUTOFMEMORY;

                        DebugTrace("Error: out of memory.\n");
                        goto ErrorExit;
                    }

                    if (FAILED(hr = ::EncodeObject((LPSTR) X509_OCTET_STRING, 
                                                   (LPVOID) &DescBlob, 
                                                   rgAttr[i].rgValue)))
                    {
                        DebugTrace("Error [%#x]: EncodeObject() failed.\n", hr);
                        goto ErrorExit;
                    }

                    break;
                }

                default:
                {
                    hr = CAPICOM_E_ATTRIBUTE_INVALID_NAME;

                    DebugTrace("Error [%#x]: unknown attribute name.\n", hr);
                    goto ErrorExit;
                }
            }
        }

        //
        // Return attributes to caller.
        //
        pAttributes->cAttr = cAttr;
        pAttributes->rgAttr = rgAttr;
    }

CommonExit:

    DebugTrace("Leaving GetAuthenticatedAttributes().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resources.
    //
    if (rgAttr)
    {
        ::FreeAttributes(cAttr, rgAttr);

        ::CoTaskMemFree(rgAttr);
    }

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : IsValidForSigning

  Synopsis : Verify if the certificate is valid for signing.

  Parameter: PCCERT_CONTEXT pCertContext - CERT_CONTEXT of cert to verify.

             LPCSTR pszPolicy - Policy used to verify the cert (i.e.
                                CERT_CHAIN_POLICY_BASE).

  Remark   :

------------------------------------------------------------------------------*/

HRESULT IsValidForSigning (PCCERT_CONTEXT pCertContext, LPCSTR pszPolicy)
{
    HRESULT hr        = S_OK;
    DWORD   cb        = 0;
    int     nValidity = 0;

    DebugTrace("Entering IsValidForSigning().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);

    //
    // Make sure we have a private key.
    //
    if (!::CertGetCertificateContextProperty(pCertContext, 
                                            CERT_KEY_PROV_INFO_PROP_ID, 
                                            NULL, 
                                            &cb))
    {
         hr = CAPICOM_E_CERTIFICATE_NO_PRIVATE_KEY;

         DebugTrace("Error: signer's private key is not available.\n");
         goto ErrorExit;
    }

    //
    // Check cert time validity.
    //
    if (0 != (nValidity = ::CertVerifyTimeValidity(NULL, pCertContext->pCertInfo)))
    {
        hr = HRESULT_FROM_WIN32(CERT_E_EXPIRED);

        DebugTrace("Info: SelectSignerCertCallback() - invalid time (%s).\n", 
                    nValidity < 0 ? "not yet valid" : "expired");
        goto ErrorExit;
    }

#if (0) //DSIE: Flip this if we decide to build chain here.
    //
    // Make sure the cert is valid.
    //
    if (FAILED(hr = ::VerifyCertificate(pCertContext, NULL, pszPolicy)))
    {
        DebugTrace("Error [%#x]: VerifyCertificate() failed.\n", hr);
        goto ErrorExit;
    }
#endif

CommonExit:

    DebugTrace("Leaving IsValidForSigning().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : GetSignerCert

  Synopsis : Retrieve signer's cert from ISigner object. If signer's cert is
             not available in the ISigner object, pop UI to prompt user to 
             select a signing cert.

  Parameter: ISigner2 * pISigner2 - Pointer to ISigner2 or NULL.

             LPCSTR pszPolicy - Policy used to verify the cert (i.e.
                                CERT_CHAIN_POLICY_BASE).

             CAPICOM_STORE_INFO StoreInfo - Store to select from.

             PFNCFILTERPROC pfnFilterCallback - Pointer to filter callback
                                                function.

             ISigner2 ** ppISigner2 - Pointer to pointer to ISigner2 to receive
                                      interface pointer.

             ICertificate ** ppICertificate - Pointer to pointer to ICertificate
                                              to receive interface pointer.

             PCCERT_CONTEXT * ppCertContext - Pointer to pointer to CERT_CONTEXT
                                              to receive cert context.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT GetSignerCert (ISigner2         * pISigner2,
                       LPCSTR             pszPolicy,
                       CAPICOM_STORE_INFO StoreInfo,
                       PFNCFILTERPROC     pfnFilterCallback,
                       ISigner2        ** ppISigner2,
                       ICertificate    ** ppICertificate,
                       PCCERT_CONTEXT   * ppCertContext)
{
    HRESULT                hr                     = S_OK;
    BOOL                   bVerified              = FALSE;
    CComPtr<ISigner2>      pISelectedSigner2      = NULL;
    CComPtr<ICertificate>  pISelectedCertificate  = NULL;
    CComPtr<ICertificate2> pISelectedCertificate2 = NULL;
    PCCERT_CONTEXT         pSelectedCertContext   = NULL;

    DebugTrace("Entering GetSignerCert().\n");

    try
    {
        //
        // Initialize.
        //
        if (ppISigner2)
        {
            *ppISigner2 = NULL;
        }
        if (ppICertificate)
        {
            *ppICertificate = NULL;
        }
        if (ppCertContext)
        {
            *ppCertContext = NULL;
        }

        //
        // Did user pass us a signer?
        //
        if (pISigner2)
        {
            //
            // Retrieve the signer's cert.
            //
            if (FAILED(hr = pISigner2->get_Certificate((ICertificate **) &pISelectedCertificate)))
            {
                //
                // If signer's cert is not present, pop UI.
                //
                if (CAPICOM_E_SIGNER_NOT_INITIALIZED == hr)
                {
                    //
                    // Prompt user to select a certificate.
                    //
                    if (FAILED(hr = ::SelectCertificate(StoreInfo, 
                                                        pfnFilterCallback, 
                                                        &pISelectedCertificate2)))
                    {
                        DebugTrace("Error [%#x]: SelectCertificate() failed.\n", hr);
                        goto ErrorExit;
                    }

                    //
                    // QI for ICertificate.
                    //
                    if (FAILED(hr = pISelectedCertificate2->QueryInterface(&pISelectedCertificate)))
                    {
                        DebugTrace("Internal error [%#x]: pISelectedCertificate2->QueryInterface() failed.\n", hr);
                        goto ErrorExit;
                    }

                    bVerified = TRUE;
                }
                else
                {
                    DebugTrace("Error [%#x]: pISigner2->get_Certificate() failed.\n", hr);
                    goto ErrorExit;
                }
            }

            //
            // Get cert context.
            //
            if (FAILED(hr = ::GetCertContext(pISelectedCertificate, &pSelectedCertContext)))
            {
                DebugTrace("Error [%#x]: GetCertContext() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Verify cert, if not already done so.
            //
            if (!bVerified)
            {
                if (pfnFilterCallback && !pfnFilterCallback(pSelectedCertContext, NULL, NULL))
                {
                    hr = CAPICOM_E_SIGNER_INVALID_USAGE;

                    DebugTrace("Error [%#x]: Signing certificate is invalid.\n", hr);
                    goto ErrorExit;
                }
            }

            //
            // QI for ISigner2.
            //
            if (FAILED(hr = pISigner2->QueryInterface(&pISelectedSigner2)))
            {
                DebugTrace("Unexpected error [%#x]: pISigner2->QueryInterface() failed.\n", hr);
                goto ErrorExit;
            }
        }
        else
        {
            CRYPT_ATTRIBUTES attributes = {0, NULL};

            //
            // No signer specified, so prompt user to select a certificate.
            //
            if (FAILED(hr = ::SelectCertificate(StoreInfo, pfnFilterCallback, &pISelectedCertificate2)))
            {
                DebugTrace("Error [%#x]: SelectCertificate() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // QI for ICertificate.
            //
            if (FAILED(hr = pISelectedCertificate2->QueryInterface(&pISelectedCertificate)))
            {
                DebugTrace("Internal error [%#x]: pISelectedCertificate2->QueryInterface() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Get cert context.
            //
            if (FAILED(hr = ::GetCertContext(pISelectedCertificate, &pSelectedCertContext)))
            {
                DebugTrace("Error [%#x]: GetCertContext() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Create the ISigner2 object.
            //
            if (FAILED(hr = ::CreateSignerObject(pSelectedCertContext, 
                                                 &attributes, 
                                                 NULL,
                                                 INTERFACESAFE_FOR_UNTRUSTED_CALLER | 
                                                    INTERFACESAFE_FOR_UNTRUSTED_DATA,
                                                 &pISelectedSigner2)))
            {
                DebugTrace("Error [%#x]: CreateSignerObject() failed.\n", hr);
                goto ErrorExit;
            }
        }

        //
        // Make sure cert is valid for signing.
        //
        if (FAILED(hr = ::IsValidForSigning(pSelectedCertContext, pszPolicy)))
        {
            DebugTrace("Error [%#x]: IsValidForSigning() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return values to caller.
        //
        if (ppISigner2)
        {
            if (FAILED(hr = pISelectedSigner2->QueryInterface(ppISigner2)))
            {
                DebugTrace("Unexpected error [%#x]: pISelectedSigner2->QueryInterface() failed.\n", hr);
                goto ErrorExit;
            }
        }

        if (ppICertificate)
        {
            if (FAILED(hr = pISelectedCertificate->QueryInterface(ppICertificate)))
            {
                DebugTrace("Unexpected error [%#x]: pISelectedCertificate->QueryInterface() failed.\n", hr);
                goto ErrorExit;
            }
        }

        if (ppCertContext)
        {
            *ppCertContext = pSelectedCertContext;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving GetSignerCert().\n");
       
    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (pSelectedCertContext)
    {
        ::CertFreeCertificateContext(pSelectedCertContext);
    }
    if (ppICertificate && *ppICertificate)
    {
        (*ppICertificate)->Release();
        *ppICertificate = NULL;
    }
    if (ppISigner2 && *ppISigner2)
    {
        (*ppISigner2)->Release();
        *ppISigner2 = NULL;
    }

    goto CommonExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\signers.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Signers.cpp

  Content: Implementation of CSigners.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "Signers.h"

#include "CertHlpr.h"
#include "MsgHlpr.h"
#include "Signer2.h"

////////////////////////////////////////////////////////////////////////////////
//
// Exported functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateSignersObject

  Synopsis : Create an ISigners collection object, and load the object with 
             signers from the specified signed message for a specified level.

  Parameter: HCRYPTMSG hMsg - Message handle.

             DWORD dwLevel - Signature level (1 based).

             HCERTSTORE hStore - Additional store.

             DWORD dwCurrentSafety - Current safety setting.

             ISigners ** ppISigners - Pointer to pointer ISigners to receive
                                      interface pointer.             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateSignersObject (HCRYPTMSG   hMsg, 
                             DWORD       dwLevel, 
                             HCERTSTORE  hStore,
                             DWORD       dwCurrentSafety,
                             ISigners ** ppISigners)
{
    HRESULT hr = S_OK;
    CComObject<CSigners> * pCSigners = NULL;

    DebugTrace("Entering CreateSignersObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(hMsg);
    ATLASSERT(dwLevel);
    ATLASSERT(ppISigners);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CSigners>::CreateInstance(&pCSigners)))
        {
            DebugTrace("Error [%#x]: CComObject<CSigners>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Now load all signers from the specified signed message.
        //
        if (FAILED(hr = pCSigners->LoadMsgSigners(hMsg, dwLevel, hStore, dwCurrentSafety)))
        {
            DebugTrace("Error [%#x]: pCSigners->LoadMsgSigners() failed.\n");
            goto ErrorExit;
        }

        //
        // Return ISigners pointer to caller.
        //
        if (FAILED(hr = pCSigners->QueryInterface(ppISigners)))
        {
            DebugTrace("Error [%#x]: pCSigners->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreateSignersObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (pCSigners)
    {
       delete pCSigners;
    }

    goto CommonExit;
}

#if (0)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CreateSignersObject

  Synopsis : Create an ISigners collection object, and load the object with 
             signers from the specified CRYPT_PROVIDER_DATA.

  Parameter: CRYPT_PROVIDER_DATA * pProvData

             ISigners ** ppISigners - Pointer to pointer ISigners to receive
                                      interface pointer.             
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT CreateSignersObject (CRYPT_PROVIDER_DATA * pProvData,
                             ISigners           ** ppISigners)
{
    HRESULT hr = S_OK;
    CComObject<CSigners> * pCSigners = NULL;

    DebugTrace("Entering CreateSignersObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pProvData);
    ATLASSERT(ppISigners);

    try
    {
        //
        // Create the object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = CComObject<CSigners>::CreateInstance(&pCSigners)))
        {
            DebugTrace("Error [%#x]: CComObject<CSigners>::CreateInstance() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Now load all signers from the specified signed code.
        //
        if (FAILED(hr = pCSigners->LoadCodeSigners(pProvData)))
        {
            DebugTrace("Error [%#x]: pCSigners->LoadCodeSigners() failed.\n");
            goto ErrorExit;
        }

        //
        // Return ISigners pointer to caller.
        //
        if (FAILED(hr = pCSigners->QueryInterface(ppISigners)))
        {
            DebugTrace("Error [%#x]: pCSigners->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CreateSignersObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (pCSigners)
    {
       delete pCSigners;
    }

    goto CommonExit;
}
#endif

/////////////////////////////////////////////////////////////////////////////
//
// CSigners
//


////////////////////////////////////////////////////////////////////////////////
//
// Non COM functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSigners::Add

  Synopsis : Add a signer to the collection.

  Parameter: PCCERT_CONTEXT pCertContext - Cert of signer.

             CRYPT_ATTRIBUTES * pAuthAttrs - Pointer to CRYPT_ATTRIBUTES
                                             of authenticated attributes.

             PCCERT_CHAIN_CONTEXT pChainContext - Chain context.

  Remark   : This method is not part of the COM interface (it is a normal C++
             member function). We need it to initialize the object created 
             internally by us.

             Since it is only a normal C++ member function, this function can
             only be called from a C++ class pointer, not an interface pointer.
             
------------------------------------------------------------------------------*/

STDMETHODIMP CSigners::Add (PCCERT_CONTEXT       pCertContext,
                            CRYPT_ATTRIBUTES   * pAuthAttrs,
                            PCCERT_CHAIN_CONTEXT pChainContext)
{
    HRESULT  hr = S_OK;
    char     szIndex[33];
    CComBSTR bstrIndex;
    CComPtr<ISigner2> pISigner2 = NULL;

    DebugTrace("Entering CSigners::Add().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pCertContext);
    ATLASSERT(pAuthAttrs);

    try
    {
        //
        // Make sure we still have room to add.
        //
        if ((m_coll.size() + 1) > m_coll.max_size())
        {
            hr = CAPICOM_E_OUT_OF_RESOURCE;

            DebugTrace("Error [%#x]: Maximum entries (%#x) reached for Signers collection.\n", 
                        hr, m_coll.size() + 1);
            goto ErrorExit;
        }

        //
        // Create an ISigner object. Note that the ref count will still be 0 
        // after the object is created.
        //
        if (FAILED(hr = ::CreateSignerObject(pCertContext, 
                                             pAuthAttrs,
                                             pChainContext,
                                             m_dwCurrentSafety,
                                             &pISigner2)))
        {
            DebugTrace("Error [%#x]: CreateSignerObject() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // BSTR index of numeric value.
        //
        wsprintfA(szIndex, "%#08x", m_coll.size() + 1);

        if (!(bstrIndex = szIndex))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error [%#x]: bstrIndex = szIndex failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Now add signer to collection map.
        //
        // Note that the overloaded = operator for CComPtr will
        // automatically AddRef to the object. Also, when the CComPtr
        // is deleted (happens when the Remove or map destructor is called), 
        // the CComPtr destructor will automatically Release the object.
        //
        m_coll[bstrIndex] = pISigner2;
    }

    catch(...)
    {
        hr = CAPICOM_E_INTERNAL;

        DebugTrace("Exception: internal error.\n");
        goto ErrorExit;
    }

CommonExit:

    DebugTrace("Leaving CSigners::Add().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSigners::LoadMsgSigners

  Synopsis : Load all signers from a specified signed message.

  Parameter: HCRYPTMSG hMsg - Message handle.

             DWORD dwLevel - Signature level (1-based).

             HCERTSTORE hStore - Additional store.

             DWORD dwCurrentSafety - Current safety setting.

  Remark   :
  
------------------------------------------------------------------------------*/

STDMETHODIMP CSigners::LoadMsgSigners (HCRYPTMSG  hMsg, 
                                       DWORD      dwLevel,
                                       HCERTSTORE hStore,
                                       DWORD      dwCurrentSafety)
{
    HRESULT hr           = S_OK;
    DWORD   dwNumSigners = 0;
    DWORD   cbSigners    = sizeof(dwNumSigners);
    DWORD   dwSigner;

    DebugTrace("Entering CSigners::LoadMsgSigners().\n");

    //
    // Sanity check.
    //
    ATLASSERT(hMsg);
    ATLASSERT(dwLevel);

    //
    // MUST set current safety first.
    //
    m_dwCurrentSafety = dwCurrentSafety;

    //
    // Which signature level?
    //
    if (1 == dwLevel)
    {
        //
        // Get number of content signers (first level signers).
        //
        if (!::CryptMsgGetParam(hMsg, 
                                CMSG_SIGNER_COUNT_PARAM,
                                0,
                                (void **) &dwNumSigners,
                                &cbSigners))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CryptMsgGetParam() failed to get CMSG_SIGNER_COUNT_PARAM.\n", hr);
            goto ErrorExit;
        }

        //
        // Go through each content signer.
        //
        for (dwSigner = 0; dwSigner < dwNumSigners; dwSigner++)
        {
            PCERT_CONTEXT        pCertContext   = NULL;
            PCCERT_CHAIN_CONTEXT pChainContext  = NULL;
            CMSG_SIGNER_INFO   * pSignerInfo    = NULL;
            CRYPT_DATA_BLOB      SignerInfoBlob = {0, NULL};
        
            //
            // Get signer info.
            //
            if (FAILED(hr = ::GetMsgParam(hMsg,
                                          CMSG_SIGNER_INFO_PARAM,
                                          dwSigner,
                                          (void**) &SignerInfoBlob.pbData,
                                          &SignerInfoBlob.cbData)))
            {
                DebugTrace("Error [%#x]: GetMsgParam() failed to get CMSG_SIGNER_INFO_PARAM for signer #%d.\n", hr, dwSigner);
                goto ErrorExit;
            }

            pSignerInfo = (CMSG_SIGNER_INFO *) SignerInfoBlob.pbData;

            //
            // Find the cert in the message.
            //
            if (FAILED(hr = ::FindSignerCertInMessage(hMsg,
                                                      &pSignerInfo->Issuer,
                                                      &pSignerInfo->SerialNumber,
                                                      &pCertContext)))
            {
                ::CoTaskMemFree(SignerInfoBlob.pbData);

                DebugTrace("Error [%#x]: FindSignerCertInMessage() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Build the chain.
            //
            if (FAILED(hr = ::BuildChain(pCertContext, 
                                         hStore, 
                                         CERT_CHAIN_POLICY_BASE, 
                                         &pChainContext)))
            {
                DebugTrace("Error [%#x]: BuildChain() failed.\n", hr);
                goto ErrorExit;
            }

            //
            // Add the signer.
            //
            hr = Add((PCERT_CONTEXT) pCertContext, &pSignerInfo->AuthAttrs, pChainContext);

            ::CertFreeCertificateChain(pChainContext);
            ::CertFreeCertificateContext(pCertContext);
            ::CoTaskMemFree(SignerInfoBlob.pbData);

            if (FAILED(hr))
            {
                DebugTrace("Error [%#x]: CSigners::Add() failed.\n", hr);
                goto ErrorExit;
            }
        }
    }
    else
    {
        //
        // For version 1 and 2, should never reach here.
        //
        hr = CAPICOM_E_INTERNAL;
        goto CommonExit;
    }

CommonExit:

    DebugTrace("Leaving CSigners::LoadMsgSigners().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resources.
    //
    m_coll.clear();

    goto CommonExit;
}

#if (0)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CSigners::LoadCodeSigners

  Synopsis : Load all signers from a specified signed code.

  Parameter: CRYPT_PROVIDER_DATA * pProvData

  Remark   :
  
------------------------------------------------------------------------------*/

STDMETHODIMP CSigners::LoadCodeSigners (CRYPT_PROVIDER_DATA * pProvData)
{
    HRESULT hr = S_OK;
    PCRYPT_PROVIDER_SGNR pProvSigner = NULL;
    PCRYPT_PROVIDER_CERT pProvCert   = NULL;

    DebugTrace("Entering CSigners::LoadCodeSigners().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pProvData);

    //
    // Get provider signer data.
    //
    if (!(pProvSigner = WTHelperGetProvSignerFromChain(pProvData, 0, FALSE, 0)))
    {
        hr = CAPICOM_E_INTERNAL;

        DebugTrace("Internal error [%#x]: WTHelperGetProvSignerFromChain() failed.\n", hr);
        goto ErrorExit;
    }

    if (!(pProvCert = WTHelperGetProvCertFromChain(pProvSigner, 0)))
    {
        hr = CAPICOM_E_INTERNAL;

        DebugTrace("Internal error [%#x]: WTHelperGetProvCertFromChain() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Add the signer.
    //
    if (FAILED(hr = Add(pProvCert->pCert, &pProvSigner->psSigner->AuthAttrs, pProvSigner->pChainContext)))
    {
        hr = CAPICOM_E_INTERNAL;

        DebugTrace("Internal error [%#x]: CSigners::Add() failed.\n", hr);
        goto ErrorExit;
    }

    //
    // Add timestamper if available.
    //
    // Note: Authenticode only supports one counter signer (the timestamper).
    //
    if (pProvSigner->csCounterSigners)
    {
        //
        // Sanity check.
        //
        ATLASSERT(1 == pProvSigner->csCounterSigners);

        if (!(pProvCert = WTHelperGetProvCertFromChain(pProvSigner->pasCounterSigners, 0)))
        {
            hr = CAPICOM_E_INTERNAL;

            DebugTrace("Internal error [%#x]: WTHelperGetProvCertFromChain() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Add the signer.
        //
        if (FAILED(hr = Add(pProvCert->pCert, 
                            &pProvSigner->pasCounterSigners->psSigner->AuthAttrs,
                            pProvSigner->pasCounterSigners->pChainContext)))
        {
            hr = CAPICOM_E_INTERNAL;

            DebugTrace("Internal error [%#x]: CSigners::Add() failed.\n", hr);
            goto ErrorExit;
        }
    }

CommonExit:

    DebugTrace("Leaving CSigners::LoadCodeSigners().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resources.
    //
    m_coll.clear();

    goto CommonExit;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\signhlpr.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000 - 2001.

  File:    SignHlpr.h

  Content: Declaration of the signing helper functions.

  History: 09-07-2001    dsie     created

------------------------------------------------------------------------------*/

#ifndef __SIGNHLPR_H_
#define __SIGNHLPR_H_

////////////////////
//
// typedefs
//

typedef struct
{
    DWORD dwChoice;                 // 0 or 1
    union
    {
        LPWSTR     pwszStoreName;   // Store name, i.e. "My" if dwChoice = 0
        HCERTSTORE hCertStore;      // Cert store handle, if dwChoice = 1
    };
} CAPICOM_STORE_INFO, * PCAPICOM_STORE_INFO;

// Values for dwChoice.
#define CAPICOM_STORE_INFO_STORENAME    0
#define CAPICOM_STORE_INFO_HCERTSTORE   1

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : FreeAttributes

  Synopsis : Free memory allocated for attributes.

  Parameter: DWORD cAttr - Number fo attributes
  
             PCRYPT_ATTRIBUTE rgAuthAttr - Pointer to CRYPT_ATTRIBUTE array.

  Remark   :

------------------------------------------------------------------------------*/

void FreeAttributes (DWORD            cAttr, 
                     PCRYPT_ATTRIBUTE rgAttr);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : FreeAttributes

  Synopsis : Free memory allocated for all attributes.

  Parameter: PCRYPT_ATTRIBUTES pAttributes

  Remark   :

------------------------------------------------------------------------------*/

void FreeAttributes (PCRYPT_ATTRIBUTES pAttributes);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : GetAuthenticatedAttributes

  Synopsis : Encode and return authenticated attributes of the specified signer.

  Parameter: ISigner * pISigner - Pointer to ISigner.
  
             PCRYPT_ATTRIBUTES pAttributes

  Remark   :

------------------------------------------------------------------------------*/

HRESULT GetAuthenticatedAttributes (ISigner         * pISigner,
                                    PCRYPT_ATTRIBUTES pAttributes);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : IsValidForSigning

  Synopsis : Verify if the certificate is valid for signing.

  Parameter: PCCERT_CONTEXT pCertContext - CERT_CONTEXT of cert to verify.

             LPCSTR pszPolicy - Policy used to verify the cert (i.e.
                                CERT_CHAIN_POLICY_BASE).

  Remark   :

------------------------------------------------------------------------------*/

HRESULT IsValidForSigning (PCCERT_CONTEXT pCertContext, LPCSTR pszPolicy);

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : GetSignerCert

  Synopsis : Retrieve signer's cert from ISigner object. If signer's cert is
             not available in the ISigner object, pop UI to prompt user to 
             select a signing cert.

  Parameter: ISigner2 * pISigner2 - Pointer to ISigner2 or NULL.

             LPCSTR pszPolicy - Policy used to verify the cert (i.e.
                                CERT_CHAIN_POLICY_BASE).

             CAPICOM_STORE_INFO StoreInfo - Store to select from.

             PFNCFILTERPROC pfnFilterCallback - Pointer to filter callback
                                                function.

             ISigner2 ** ppISigner2 - Pointer to pointer to ISigner2 to receive
                                      interface pointer.

             ICertificate ** ppICertificate - Pointer to pointer to ICertificate
                                              to receive interface pointer.

             PCCERT_CONTEXT * ppCertContext - Pointer to pointer to CERT_CONTEXT
                                              to receive cert context.
  Remark   :

------------------------------------------------------------------------------*/

HRESULT GetSignerCert (ISigner2         * pISigner2,
                       LPCSTR             pszPolicy,
                       CAPICOM_STORE_INFO StoreInfo,
                       PFNCFILTERPROC     pfnFilterCallback,
                       ISigner2        ** ppISigner2,
                       ICertificate    ** ppICertificate,
                       PCCERT_CONTEXT   * ppCertContext);

#endif //__SIGNHLPR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\stdafx.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:     StdAfx.cpp

  Contents: Source file that includes just the standard includes, and some
            initialization routines.

  Remarks:  stdafx.pch will be the pre-compiled header.
            stdafx.obj will contain the pre-compiled type information.

  History:   09-15-1999    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\smartcard.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    SmartCard.h

  Content: Declaration SmartCard.cpp.

  History: 12-06-2001    dsie     created

------------------------------------------------------------------------------*/

#ifndef __SMARTCARD_H_
#define __SMARTCARD_H_

#include "Debug.h"

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : LoadFromSmartCard

  Synopsis : Load all certificates from all smart card readers.
  
  Parameter: HCERTSTORE hCertStore - Certificate store handle of store to 
                                     receive all the certificates.
                                     
  Remark   : 

------------------------------------------------------------------------------*/

HRESULT LoadFromSmartCard (HCERTSTORE hCertStore);

#endif // __SMARTCARD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\stdafx.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000 - 2001.

  File:    stdafx.h

  Content: Include file, generated by ATL, for standard system include files,
           or project specific include files that are used frequently,
           but are changed infrequently

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/


#if !defined(AFX_STDAFX_H__DC6F3774_66B7_4578_91AD_7950EF7CAF8A__INCLUDED_)
#define AFX_STDAFX_H__DC6F3774_66B7_4578_91AD_7950EF7CAF8A__INCLUDED_

//
// Turn off:
//
// - Unreferenced formal parameter warning.
// - Assignment within conditional expression warning.
//
#pragma warning (disable: 4100)
#pragma warning (disable: 4706)

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

// Extra fields in CERT_CHAIN_PARA.
#define CERT_CHAIN_PARA_HAS_EXTRA_FIELDS 1

#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlwin.h>
#include <atlctl.h>

//
// Global includes.
//
// Set warning level to 3 for MSVC vector class.
#pragma warning(push,3)
#include <vector>
#pragma warning(pop)
#include <map>
#include <activeds.h>
#include <cryptui.h>
#include <exdisp.h>
#include <mssip.h>
#include <servprov.h>
#include <shlguid.h>
#include <signer.h>
#include <softpub.h>
#include <unicode.h>
#include <wintrust.h>
#include <wincrypt.h>
#include <winscard.h>
#include <wininet.h>

//
// Global defines.
//
#define CAPICOM_VERSION                     ((DWORD) ((CAPICOM_MAJOR_VERSION << 16) | CAPICOM_MINOR_VERSION))
#define CAPICOM_ASN_ENCODING                (X509_ASN_ENCODING | PKCS_7_ASN_ENCODING)

#define ARRAYSIZE(x)                        (sizeof(x) / sizeof(x[0]))

#define szOID_CAPICOM                       "1.3.6.1.4.1.311.88"     // Reserved for CAPICOM.
#define szOID_CAPICOM_VERSION               "1.3.6.1.4.1.311.88.1"   // CAPICOM version
#define szOID_CAPICOM_ATTRIBUTE             "1.3.6.1.4.1.311.88.2"   // CAPICOM attribute
#define szOID_CAPICOM_DOCUMENT_NAME         "1.3.6.1.4.1.311.88.2.1" // Document type attribute
#define szOID_CAPICOM_DOCUMENT_DESCRIPTION  "1.3.6.1.4.1.311.88.2.2" // Document description attribute
#define szOID_CAPICOM_ENCRYPTED_DATA        "1.3.6.1.4.1.311.88.3"   // CAPICOM encrypted data message.
#define szOID_CAPICOM_ENCRYPTED_CONTENT     "1.3.6.1.4.1.311.88.3.1" // CAPICOM content of encrypted data.

#define CAPICOM_NO_PERSIST_CONTAINER_NAME   L"//Temporary Container Indicator//"

#ifndef SAFE_SUBTRACT_POINTERS
#define SAFE_SUBTRACT_POINTERS(__x__, __y__) ( DW_PtrDiffc(__x__, sizeof(*(__x__)), __y__, sizeof(*(__y__))) )

__inline DWORD
DW_PtrDiffc(
    IN void const *pb1,
    IN DWORD dwPtrEltSize1,
    IN void const *pb2,
    IN DWORD dwPtrEltSize2)
{
    // pb1 should be greater
    ATLASSERT((ULONG_PTR)pb1 >= (ULONG_PTR)pb2);

    // both should have same elt size
    ATLASSERT(dwPtrEltSize1 == dwPtrEltSize2);

    // assert that the result doesn't overflow 32-bits
    ATLASSERT((DWORD)((ULONG_PTR)pb1 - (ULONG_PTR)pb2) == (ULONG_PTR)((ULONG_PTR)pb1 - (ULONG_PTR)pb2));

    // return number of objects between these pointers
    return (DWORD) ( ((ULONG_PTR)pb1 - (ULONG_PTR)pb2) / dwPtrEltSize1 );
}
#endif SAFE_SUBTRACT_POINTERS

#pragma hdrstop

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__DC6F3774_66B7_4578_91AD_7950EF7CAF8A__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\store.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Store.cpp

  Content: Implementation of CStore.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "Store.h"

#include "ADHelpers.h"
#include "Certificate.h"
#include "Certificates.h"
#include "Common.h"
#include "Convert.h"
#include "PFXHlpr.h"
#include "Settings.h"
#include "SmartCard.h"

////////////////////////////////////////////////////////////////////////////////
//
// Internal functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : IsProtectedStore

  Synopsis : Determine if the requested store is proctected from update from 
             WEB within script.

  Parameter: CAPICOM_STORE_LOCATION StoreLocation - Store location.
  
             LPWSTR pwszStoreName - Store name.

  Remark   : 1) All LM stores are considered protected.

             2) CU\Root, CU\AuthRoot, CU\TrustedPeople, CU\TrustedPublisher,
                and CU\Disallowed are considered protected.

             3) All error conditions would be considered as protected.

             4) Otherwise, it is not considered protected.

------------------------------------------------------------------------------*/

static BOOL IsProtectedStore (CAPICOM_STORE_LOCATION StoreLocation,
                              LPWSTR                 pwszStoreName)
{
    BOOL bIsProtected = TRUE;

    switch (StoreLocation)
    {
        case CAPICOM_LOCAL_MACHINE_STORE:
        {
            //
            // 1) All LM stores are considered protected.
            //
            break;
        }

        case CAPICOM_CURRENT_USER_STORE:
        {
            //
            // Sanity check.
            //
            ATLASSERT(pwszStoreName);

            //
            // 2) CU\Root, CU\AuthRoot, CU\TrustedPeople, CU\TrustedPublisher,
            //    and CU\Disallowed are considered protected.
            //
            if (0 != _wcsicmp(L"root", pwszStoreName) &&
                0 != _wcsicmp(L"authroot", pwszStoreName) &&
                0 != _wcsicmp(L"trustedpeople", pwszStoreName) &&
                0 != _wcsicmp(L"trustedpublisher", pwszStoreName) &&
                0 != _wcsicmp(L"disallowed", pwszStoreName))
            {
                bIsProtected = FALSE;
            }

            break;
        }

        case CAPICOM_MEMORY_STORE:
        case CAPICOM_ACTIVE_DIRECTORY_USER_STORE:
        case CAPICOM_SMART_CARD_USER_STORE:
        {
            //
            // Memory backed store is not protected.
            //
            bIsProtected = FALSE;
            break;
        }

        default:
        {
            //
            // 3) All error conditions would be considered as protected.
            //
            break;
        }
    }
   
    return bIsProtected;
}

////////////////////////////////////////////////////////////////////////////////
//
// CStore
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CStore::get_Certificates

  Synopsis : Get the ICertificates collection object.

  Parameter: ICertificates ** ppCertificates - Pointer to pointer to 
                                               ICertificates to receive the
                                               interface pointer.

  Remark   : This is the default property which returns an ICertificates 
             collection object, which can then be accessed using standard COM 
             collection interface.

             The collection is not ordered, and can be accessed using a 1-based
             numeric index.

             Note that the collection is a snapshot of all current certificates
             in the store. In other words, the collection will not be affected
             by Add/Remove operations after the collection is obtained.

------------------------------------------------------------------------------*/

STDMETHODIMP CStore::get_Certificates (ICertificates ** pVal)
{
    HRESULT hr = S_OK;
    CComPtr<ICertificates2> pICertificates2 = NULL;
    CAPICOM_CERTIFICATES_SOURCE ccs = {CAPICOM_CERTIFICATES_LOAD_FROM_STORE, 0};

    DebugTrace("Entering CStore::get_Certificates().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Is the store object opened?
        //
        if (!m_hCertStore)
        {
            hr = CAPICOM_E_STORE_NOT_OPENED;

            DebugTrace("Error [%#x]: store has not been opened.\n", hr);
            goto ErrorExit; 
        }

        //
        // Create the ICertificates2 collection object.
        //
        ccs.hCertStore = m_hCertStore;

        if (FAILED(hr = ::CreateCertificatesObject(ccs, m_dwCurrentSafety, TRUE, &pICertificates2)))
        {
            DebugTrace("Error [%#x]: CreateCertificatesObject() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Return ICertificates to calller.
        //
        if (FAILED(hr = pICertificates2->QueryInterface(__uuidof(ICertificates), (void **) pVal)))
        {
            DebugTrace("Error [%#x]: pICertificates2->QueryInterface() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CStore::get_Certificates().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CStore::Open

  Synopsis : Open a certificate store for read/write. Note that for MEMORY_STORE
             and ACTIVE_DIRECTORY_USER_STORE, the write operation does not
             persist the certificate.

  Parameter: CAPICOM_STORE_LOCATION StoreLocation - Store location.

             BSTR StoreName - Store name or NULL.

                    For:

                    MEMORY_STORE                - This argument is ignored.

                    LOCAL_MACHINE_STORE         - System store name or NULL.
                    
                                                  If NULL, then "MY" is used.

                    CURRENT_USER_STORE          - See explaination for
                                                  LOCAL_MACHINE_STORE.

                    ACTIVE_DIRECTORY_USER_STORE - LDAP filter for user container 
                                                  or NULL,.
                    
                                                  If NULL, then all users in the 
                                                  default domain will be 
                                                  included, so this can be very 
                                                  slow. 
                                                  
                                                  If not NULL, then it should 
                                                  resolve to group of 0 or more
                                                  users.
                                                  
                                                  For example,

                                                  "cn=Daniel Sie"
                                                  "cn=Daniel *"
                                                  "sn=Sie"
                                                  "mailNickname=dsie"
                                                  "userPrincipalName=dsie@ntdev.microsoft.com"
                                                  "distinguishedName=CN=Daniel Sie,OU=Users,OU=ITG,DC=ntdev,DC=microsoft,DC=com"
                                                  "|((cn=Daniel Sie)(sn=Hallin))"

                    SMART_CARD_STORE            - This is ignored.

             CAPICOM_STORE_OPEN_MODE OpenMode - Always force to read only for
                                                MEMORY_STORE,
                                                ACTIVE_DIRECTORY_USER_STORE,
                                                and SMART_CARD_STORE.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CStore::Open (CAPICOM_STORE_LOCATION  StoreLocation, 
                           BSTR                    StoreName,
                           CAPICOM_STORE_OPEN_MODE OpenMode)
{
    HRESULT    hr                 = S_OK;
    LPWSTR     wszName            = NULL;
    LPCSTR     szProvider         = (LPCSTR) CERT_STORE_PROV_SYSTEM;
    DWORD      dwModeFlag         = 0;
    DWORD      dwArchivedFlag     = 0;
    DWORD      dwOpenExistingFlag = 0;
    DWORD      dwLocationFlag     = 0;
    HCERTSTORE hCertStore         = NULL;
    HMODULE    hDSClientDLL       = NULL;
    HMODULE    hWinSCardDLL       = NULL;

    DebugTrace("Entering CStore::Open().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Can't open remote store if called from WEB script.
        //
        if (m_dwCurrentSafety && wcschr(StoreName, L'\\'))
        {
            hr = CAPICOM_E_NOT_ALLOWED;

            DebugTrace("Error [%#x]: Openning remote store from WEB script is not allowed.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure parameters are valid.
        //
        switch (OpenMode & 0x3) // Only the last two bits.
        {
            case CAPICOM_STORE_OPEN_READ_ONLY:
            {
                dwModeFlag = CERT_STORE_READONLY_FLAG;
                break;
            }

            case CAPICOM_STORE_OPEN_READ_WRITE:
            {
                break;
            }

            case CAPICOM_STORE_OPEN_MAXIMUM_ALLOWED:
            {
                dwModeFlag = CERT_STORE_MAXIMUM_ALLOWED_FLAG;
                break;
            }

            default:
            {
                hr = E_INVALIDARG;

                DebugTrace("Error [%#x]: Unknown store open mode (%#x).\n", hr, OpenMode);
                goto ErrorExit;
            }
        }

        //
        // Set open existing flag if WEB client or specifically requested.
        //
        if (m_dwCurrentSafety || (OpenMode & CAPICOM_STORE_OPEN_EXISTING_ONLY))
        {
            dwOpenExistingFlag = CERT_STORE_OPEN_EXISTING_FLAG;
        }

        //
        // Set archive flag if requested.
        //
        if (OpenMode & CAPICOM_STORE_OPEN_INCLUDE_ARCHIVED)
        {
            dwArchivedFlag = CERT_STORE_ENUM_ARCHIVED_FLAG;
        }

        switch (StoreLocation)
        {
            case CAPICOM_MEMORY_STORE:
            {
                wszName = NULL;
                szProvider = (LPSTR) CERT_STORE_PROV_MEMORY;
                dwModeFlag = CERT_STORE_READONLY_FLAG;
                break;
            }

            case CAPICOM_LOCAL_MACHINE_STORE:
            {
                wszName = StoreName;
                dwLocationFlag = CERT_SYSTEM_STORE_LOCAL_MACHINE;
                break;
            }

            case CAPICOM_CURRENT_USER_STORE:
            {
                wszName = StoreName;
                dwLocationFlag = CERT_SYSTEM_STORE_CURRENT_USER;
                break;
            }

            case CAPICOM_ACTIVE_DIRECTORY_USER_STORE:
            {
                //
                // Make sure DSClient is installed.
                //
                if (!(hDSClientDLL = ::LoadLibrary("ActiveDS.dll")))
                {
                    hr = CAPICOM_E_NOT_SUPPORTED;

                    DebugTrace("Error [%#x]: DSClient not installed.\n", hr);
                    goto ErrorExit;
                }

                wszName = NULL;
                szProvider = (LPSTR) CERT_STORE_PROV_MEMORY;
                dwModeFlag = CERT_STORE_READONLY_FLAG;

                break;
            }

            case CAPICOM_SMART_CARD_USER_STORE:
            {
                //
                // Make sure WIn2K and above.
                //
                if (!IsWin2KAndAbove())
                {
                    hr = CAPICOM_E_NOT_SUPPORTED;

                    DebugTrace("Error [%#x]: Smart Card store not supported for pre-W2K platforms.\n", hr);
                    goto ErrorExit;
                }

                wszName = NULL;
                szProvider = (LPSTR) CERT_STORE_PROV_MEMORY;
                dwModeFlag = CERT_STORE_READONLY_FLAG;

                break;
            }

            default:
            {
                hr = E_INVALIDARG;

                DebugTrace("Error [%#x]: Unknown store location (%#x).\n", hr, StoreLocation);
                goto ErrorExit;
            }
        }

        //
        // Prompt user for approval to open store, if called from WEB script.
        //
        if ((m_dwCurrentSafety) &&
            (StoreLocation != CAPICOM_MEMORY_STORE) &&
            (FAILED(hr = OperationApproved(IDD_STORE_OPEN_SECURITY_ALERT_DLG))))
        {
            DebugTrace("Error [%#x]: OperationApproved() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // First close the store.
        //
        if (FAILED(hr = Close()))
        {
            DebugTrace("Error [%#x]: CStore::Close().\n", hr);
            goto ErrorExit;
        }

        //
        // Call CAPI to open the store.
        //
        if (!(hCertStore = ::CertOpenStore(szProvider,
                                           CAPICOM_ASN_ENCODING,
                                           NULL,
                                           dwModeFlag | 
                                               dwLocationFlag |
                                               dwArchivedFlag |
                                               dwOpenExistingFlag |
                                               CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
                                           (void *) (LPCWSTR) wszName)))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertOpenStore() failed.\n", hr);
            goto ErrorExit; 
        }

        //
        // Load certificates from virtual stores, if necessary.
        //
        switch (StoreLocation)
        {
            case CAPICOM_ACTIVE_DIRECTORY_USER_STORE:
            {
                //
                // Load userCertificate from the active directory.
                //
                if (FAILED(hr = ::LoadFromDirectory(hCertStore, StoreName)))
                {
                    DebugTrace("Error [%#x]: LoadFromDirectory() failed.\n", hr);
                    goto ErrorExit;
                }
                break;
            }

            case CAPICOM_SMART_CARD_USER_STORE:
            {
                //
                // Load certificate(s) from all smart card readers.
                //
                if (FAILED(hr = ::LoadFromSmartCard(hCertStore)))
                {
                    DebugTrace("Error [%#x]: LoadFromSmartCard() failed.\n", hr);
                    goto ErrorExit;
                }
                break;
            }

            default:
            {
                //
                // Not virtual store, so nothing to load.
                //
                break;
            }
        }

        //
        // Update member variables.
        //
        m_hCertStore = hCertStore;
        m_StoreLocation = StoreLocation;
        m_bIsProtected = ::IsProtectedStore(StoreLocation, StoreName);

        DebugTrace("Info: CStore::Open() for %s store.\n", m_bIsProtected ? "protected" : "non-protected");
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resource.
    //
    if (hDSClientDLL)
    {
        ::FreeLibrary(hDSClientDLL);
    }
    if (hWinSCardDLL)
    {
        ::FreeLibrary(hWinSCardDLL);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CStore::Open().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resource.
    //
    if (hCertStore)
    {
        ::CertCloseStore(hCertStore, 0);
    }

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CStore::Add

  Synopsis : Add a certificate to the store.

  Parameter: ICertificate * pVal - Pointer to ICertificate to add.

  Remark   : If called from web, UI will be displayed, if has not been 
             previuosly disabled, to solicit user's permission to add 
             certificate to the system store.

             Added certificates are not persisted for non-system stores.

------------------------------------------------------------------------------*/

STDMETHODIMP CStore::Add (ICertificate * pVal)
{
    HRESULT               hr            = S_OK;
    PCCERT_CONTEXT        pCertContext  = NULL;
    CComPtr<ICertificate> pICertificate = NULL;

    DebugTrace("Entering CStore::Add().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // QI for ICertificate pointer (Just to make sure it is indeed
        // an ICertificate object).
        //
        if (!(pICertificate = pVal))
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is not an ICertificate interface pointer.\n", hr);
            goto ErrorExit;
        }

        //
        // Is the store object opened?
        //
        if (!m_hCertStore)
        {
            hr = CAPICOM_E_STORE_NOT_OPENED;

            DebugTrace("Error [%#x]: Store has not been opened.\n", hr);
            goto ErrorExit;
        }

        //
        // Add is not allowed for protected store when called from WEB script.
        //
        if (m_dwCurrentSafety)
        {
            DebugTrace("Info: CStore::Add called from WEB script.\n");

            if (m_bIsProtected)
            {
                hr = CAPICOM_E_NOT_ALLOWED;

                DebugTrace("Error [%#x]: Adding to this store is not allowed from WEB script.\n", hr);
                goto ErrorExit;
            }

            if (CAPICOM_CURRENT_USER_STORE != m_StoreLocation && 
                CAPICOM_LOCAL_MACHINE_STORE != m_StoreLocation &&
                FAILED(hr = OperationApproved(IDD_STORE_ADD_SECURITY_ALERT_DLG)))
            {
                DebugTrace("Error [%#x]: OperationApproved() failed.\n", hr);
                goto ErrorExit;
            }
        }

        //
        // Get cert context from certificate object.
        //
        if (FAILED(hr = ::GetCertContext(pICertificate, &pCertContext)))
        {
            DebugTrace("Error [%#x]: GetCertContext() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(pCertContext);

        //
        // Add to the store.
        //
        if (!::CertAddCertificateContextToStore(m_hCertStore,
                                                pCertContext,
                                                CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES,
                                                NULL))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertAddCertificateContextToStore() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resource.
    //
    if (pCertContext)
    {
        ::CertFreeCertificateContext(pCertContext);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CStore::Add().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CStore::Remove

  Synopsis : Remove a certificate from the store.

  Parameter: ICertificate * - Pointer to certificate object to remove.

  Remark   : If called from web, UI will be displayed, if has not been 
             previuosly disabled, to solicit user's permission to remove 
             certificate to the system store.

             Removed certificates are not persisted for non-system stores.

------------------------------------------------------------------------------*/

STDMETHODIMP CStore::Remove (ICertificate * pVal)
{
    HRESULT               hr            = S_OK;
    PCCERT_CONTEXT        pCertContext  = NULL;
    PCCERT_CONTEXT        pCertContext2 = NULL;
    CComPtr<ICertificate> pICertificate = NULL;
    BOOL                  bResult       = FALSE;

    DebugTrace("Entering CStore::Remove().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // QI for ICertificate pointer (Just to make sure it is indeed
        // an ICertificate object).
        //
        if (!(pICertificate = pVal))
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is not an ICertificate interface pointer.\n", hr);
            goto ErrorExit;
        }

        //
        // Is the store object opened?
        //
        if (!m_hCertStore)
        {
            hr = CAPICOM_E_STORE_NOT_OPENED;

            DebugTrace("Error [%#x]: Store has not been opened.\n", hr);
            goto ErrorExit;
        }

        //
        // Remove is not allowed for protected store when called from WEB script.
        //
        if (m_dwCurrentSafety)
        {
            DebugTrace("Info: CStore::Remove called from WEB script.\n");

            if (m_bIsProtected)
            {
                hr = CAPICOM_E_NOT_ALLOWED;

                DebugTrace("Error [%#x]: Removing from this store is not allowed from WEB script.\n", hr);
                goto ErrorExit;
            }

            if (CAPICOM_CURRENT_USER_STORE != m_StoreLocation && 
                CAPICOM_LOCAL_MACHINE_STORE != m_StoreLocation &&
                FAILED(hr = OperationApproved(IDD_STORE_REMOVE_SECURITY_ALERT_DLG)))
            {
                DebugTrace("Error [%#x]: OperationApproved() failed.\n", hr);
                goto ErrorExit;
            }
        }

        //
        // Get cert context from certificate object.
        //
        if (FAILED(hr = ::GetCertContext(pICertificate, &pCertContext)))
        {
            DebugTrace("Error [%#x]: GetCertContext() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(pCertContext);
    
        //
        // Find the cert in store.
        //
        if (!(pCertContext2 = ::CertFindCertificateInStore(m_hCertStore, 
                                                           CAPICOM_ASN_ENCODING,
                                                           0, 
                                                           CERT_FIND_EXISTING, 
                                                           (const void *) pCertContext,
                                                           NULL)))
        {
            DebugTrace("Error [%#x]: CertFindCertificateInStore() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(pCertContext2);

        //
        // Remove from the store.
        //
        bResult =::CertDeleteCertificateFromStore(pCertContext2);

        //
        // Since CertDeleteCertificateFromStore always release the
        // context regardless of success or failure, we must first 
        // NULL the CERT_CONTEXT before checking for result.
        //
        pCertContext2 = NULL;

        if (!bResult)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertDeleteCertificateFromStore() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resource.
    //
    if (pCertContext2)
    {
        ::CertFreeCertificateContext(pCertContext2);
    }
    if (pCertContext)
    {
        ::CertFreeCertificateContext(pCertContext);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CStore::Remove().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CStore:Export

  Synopsis : Export all certificates in the store.

  Parameter: CAPICOM_STORE_SAVE_AS_TYPE SaveAs - Save as type.

             CAPICOM_ENCODING_TYPE EncodingType - Encoding type.

             BSTR * pVal - Pointer to BSTR to receive the store blob.

  Remark   : If called from web, UI will be displayed, if has not been 
             previuosly disabled, to solicit user's permission to export 
             certificate from the system store.

------------------------------------------------------------------------------*/

STDMETHODIMP CStore::Export (CAPICOM_STORE_SAVE_AS_TYPE SaveAs,
                             CAPICOM_ENCODING_TYPE      EncodingType, 
                             BSTR                     * pVal)
{
    HRESULT   hr       = S_OK;
    DWORD     dwSaveAs = 0;
    DATA_BLOB DataBlob = {0, NULL};

    DebugTrace("Entering CStore::Export().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == pVal)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pVal is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Determine SaveAs type.
        //
        switch (SaveAs)
        {
            case CAPICOM_STORE_SAVE_AS_SERIALIZED:
            {
                dwSaveAs = CERT_STORE_SAVE_AS_STORE;
                break;
            }

            case CAPICOM_STORE_SAVE_AS_PKCS7:
            {
                dwSaveAs = CERT_STORE_SAVE_AS_PKCS7;
                break;
            }

            default:
            {
                hr = E_INVALIDARG;

                DebugTrace("Error: invalid parameter, unknown save as type.\n");
                goto ErrorExit;
            }
        }

        //
        // Is the store object opened?
        //
        if (!m_hCertStore)
        {
            hr = CAPICOM_E_STORE_NOT_OPENED;

            DebugTrace("Error [%#x]: store has not been opened.\n", hr);
            goto ErrorExit;
        }

        //
        // Determine required length.
        //
        if (!::CertSaveStore(m_hCertStore,              // in
                             CAPICOM_ASN_ENCODING,      // in
                             dwSaveAs,                  // in
                             CERT_STORE_SAVE_TO_MEMORY, // in
                             (void *) &DataBlob,        // in/out
                             0))                        // in
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            DebugTrace("Error [%#x]: CertSaveStore() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Allocate memory.
        //
        if (!(DataBlob.pbData = (BYTE *) ::CoTaskMemAlloc(DataBlob.cbData)))
        {
            hr = E_OUTOFMEMORY;

            DebugTrace("Error [%#x]: DataBlob.pbData = (BYTE *) ::CoTaskMemAlloc(DataBlob.cbData).\n", hr);
            goto ErrorExit;
        }

        //
        // Now save the store to memory blob.
        //
        if (!::CertSaveStore(m_hCertStore,              // in
                             CAPICOM_ASN_ENCODING,      // in
                             dwSaveAs,                  // in
                             CERT_STORE_SAVE_TO_MEMORY, // in
                             (void *) &DataBlob,        // in/out
                             0))                        // in
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertSaveStore() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Export store.
        //
        if (FAILED(hr = ::ExportData(DataBlob, EncodingType, pVal)))
        {
            DebugTrace("Error [%#x]: ExportData() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Free resource.
    //
    if (DataBlob.pbData)
    {
        ::CoTaskMemFree((LPVOID) DataBlob.pbData);
    }

    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CStore::Export().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CStore::Import

  Synopsis : Import either a serialized or PKCS #7 certificate store.

  Parameter: BSTR EncodedStore - Pointer to BSTR containing the encoded 
                                 store blob.

  Remark   : Note that the SaveAs and EncodingType will be determined
             automatically.
  
             If called from web, UI will be displayed, if has not been 
             previuosly disabled, to solicit user's permission to import 
             certificate to the system store.

------------------------------------------------------------------------------*/

STDMETHODIMP CStore::Import (BSTR EncodedStore)
{
    HRESULT   hr        = S_OK;
    DATA_BLOB StoreBlob = {0, NULL};

    DebugTrace("Entering CStore::Import().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure parameters are valid.
        //
        if ((NULL == (StoreBlob.pbData = (LPBYTE) EncodedStore)) ||
            (0 == (StoreBlob.cbData = ::SysStringByteLen(EncodedStore))))
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter EncodedStore is NULL or empty.\n", hr);
            goto ErrorExit;
        }

        //
        // Is the store object opened?
        //
        if (!m_hCertStore)
        {
            hr = CAPICOM_E_STORE_NOT_OPENED;

            DebugTrace("Error [%#x]: store has not been opened.\n", hr);
            goto ErrorExit;
        }

        //
        // Import is not allowed if the store is protected when called from
        // WEB script.
        //
        if (m_dwCurrentSafety)
        {
            DebugTrace("Info: CStore::Import called from WEB script.\n");

            if (m_bIsProtected)
            {
                hr = CAPICOM_E_NOT_ALLOWED;

                DebugTrace("Error [%#x]: Importing to this store is not allowed from WEB script.\n", hr);
                goto ErrorExit;
            }

            if (CAPICOM_CURRENT_USER_STORE != m_StoreLocation && 
                CAPICOM_LOCAL_MACHINE_STORE != m_StoreLocation &&
                FAILED(hr = OperationApproved(IDD_STORE_ADD_SECURITY_ALERT_DLG)))
            {
                DebugTrace("Error [%#x]: OperationApproved() failed.\n", hr);
                goto ErrorExit;
            }
        }

        //
        // Now import the blob.
        //
        if (FAILED(hr = ImportCertObject(CERT_QUERY_OBJECT_BLOB, 
                                         (LPVOID) &StoreBlob, 
                                         FALSE, 
                                         NULL, 
                                         (CAPICOM_KEY_STORAGE_FLAG) 0)))
        {
            DebugTrace("Error [%#x]: CStore::ImportCertObject() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_INVALIDARG;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CStore::Import().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CStore::Load

  Synopsis : Method to load certificate(s) from a file.

  Parameter: BSTR FileName - File name.

             BSTR Password - Password (required for PFX file.)

             CAPICOM_KEY_STORAGE_FLAG KeyStorageFlag - Key storage flag.

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CStore::Load (BSTR                     FileName,
                           BSTR                     Password,
                           CAPICOM_KEY_STORAGE_FLAG KeyStorageFlag)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CStore::Load().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure parameters are valid.
        //
        if (0 == ::SysStringLen(FileName))
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Paremeter FileName is NULL or empty.\n", hr);
            goto ErrorExit;
        }

        //
        // Work around MIDL problem.
        //
        if (0 == ::SysStringLen(Password))
        {
            Password = NULL;
        }

        //
        // Is the store object opened?
        //
        if (!m_hCertStore)
        {
            hr = CAPICOM_E_STORE_NOT_OPENED;

            DebugTrace("Error [%#x]: store has not been opened.\n", hr);
            goto ErrorExit;
        }

        //
        // Not allowed if called from WEB script.
        //
        if (m_dwCurrentSafety)
        {
            hr = CAPICOM_E_NOT_ALLOWED;

            DebugTrace("Error [%#x]: Loading cert file from WEB script is not allowed.\n", hr);
            goto ErrorExit;
        }

        //
        // Make sure it is a disk file.
        //
        if (FAILED(hr = ::IsDiskFile(FileName)))
        {
            DebugTrace("Error [%#x]: CStore::IsDiskFile() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Now import the blob.
        //
        if (FAILED(hr = ImportCertObject(CERT_QUERY_OBJECT_FILE,
                                         (LPVOID) FileName,
                                         TRUE, 
                                         Password, 
                                         KeyStorageFlag)))
        {
            DebugTrace("Error [%#x]: CStore::ImportCertObject() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CStore::Load().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// Custom interfaces.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CStore::get_StoreHandle

  Synopsis : Return the store's HCERTSTORE.

  Parameter: long * pphCertStore - Pointer to HCERTSTORE disguished in a long.

  Remark   : We need to use long instead of HCERTSTORE because VB can't handle 
             double indirection (i.e. vb would bark on this HCERTSTORE * 
             phCertStore, as HCERTSTORE is defined as void *).
 
------------------------------------------------------------------------------*/

STDMETHODIMP CStore::get_StoreHandle (long * phCertStore)
{
    HRESULT    hr         = S_OK;
    HCERTSTORE hCertStore = NULL;

    DebugTrace("Entering CStore::get_StoreHandle().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameters.
        //
        if (NULL == phCertStore)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter phCertStore is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Is the store object opened?
        //
        if (!m_hCertStore)
        {
            hr = CAPICOM_E_STORE_NOT_OPENED;

            DebugTrace("Error [%#x]: store has not been opened.\n", hr);
            goto ErrorExit;
        }

        //
        // Duplicate the HCERTSTORE.
        //
        if (!(hCertStore = ::CertDuplicateStore(m_hCertStore)))
        {
            DebugTrace("Error [%#x]: CertDuplicateStore() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Returen handle to caller.
        //
        *phCertStore = (long) hCertStore;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CStore::get_StoreHandle().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CStore::put_StoreHandle

  Synopsis : Initialize the object with a HCERTSTORE.

  Parameter: long hCertStore - HCERTSTORE, disguised in a long, used to 
                               initialize this object.

  Remark   : Note that this is NOT 64-bit compatiable. Plese see remark of
             get_hCertStore for more detail.

------------------------------------------------------------------------------*/

STDMETHODIMP CStore::put_StoreHandle (long hCertStore)
{
    HRESULT    hr          = S_OK;
    HCERTSTORE hCertStore2 = NULL;

    DebugTrace("Entering CStore::put_StoreHandle().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameter.
        //
        if (0 == hCertStore)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter hCertStore is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Duplicate the HCERTSTORE.
        //
        if (!(hCertStore2 = ::CertDuplicateStore((HCERTSTORE) hCertStore)))
        {
            DebugTrace("Error [%#x]: CertDuplicateStore() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Close the store.
        //
        if (FAILED(hr = Close()))
        {
            DebugTrace("Error [%#x]: CStore::Close() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Reset the object with this handle.
        //
        m_hCertStore = hCertStore2;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CStore::put_StoreHandle().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    //
    // Free resources.
    //
    if (hCertStore2)
    {
        ::CertCloseStore(hCertStore2, 0);
    }

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CStore::get_StoreLocation

  Synopsis : Get the store location property.

  Parameter: CAPICOM_STORE_LOCATION * pStoreLocation - Pointer to 
                                                       CAPICOM_STORE_LOCATION
                                                       to recieve the value.

  Remark   : For custom interface, we only support CU, LM, and Memory store.

------------------------------------------------------------------------------*/

STDMETHODIMP CStore::get_StoreLocation (CAPICOM_STORE_LOCATION * pStoreLocation)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CStore::get_StoreLocation().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameter.
        //
        if (NULL == pStoreLocation)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter pStoreLocation is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Return value to caller.
        //
        *pStoreLocation = m_StoreLocation;
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CStore::get_StoreLocation().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CStore::put_StoreLocation

  Synopsis : Set the store location property.

  Parameter: CAPICOM_STORE_LOCATION StoreLocation - Store location.

  Remark   : For custom interface, we only support CU, LM, and Memory store.

------------------------------------------------------------------------------*/

STDMETHODIMP CStore::put_StoreLocation (CAPICOM_STORE_LOCATION StoreLocation)
{
    HRESULT    hr          = S_OK;

    DebugTrace("Entering CStore::put_StoreLocation().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Make sure it is a CAPI store (CU, LM, or Memory).
        //
        switch (StoreLocation)
        {
            case CAPICOM_MEMORY_STORE:
            case CAPICOM_LOCAL_MACHINE_STORE:
            case CAPICOM_CURRENT_USER_STORE:
            {
                //
                // Set it.
                //
                m_StoreLocation = StoreLocation;
                break;
            }

            default:
            {
                hr = E_INVALIDARG;

                DebugTrace("Error [%#x]: invalid store location (%#x).\n", hr, StoreLocation);
                goto ErrorExit;
            }
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CStore::put_StoreLocation().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CStore::CloseHandle

  Synopsis : Close a HCERTSTORE.

  Parameter: long hCertStoret - HCERTSTORE, disguised in a long, to be closed.

  Remark   : Note that this is NOT 64-bit compatiable. Plese see remark of
             get_hCertStore for more detail.

------------------------------------------------------------------------------*/

STDMETHODIMP CStore::CloseHandle (long hCertStore)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CStore::CloseHandle().\n");

    try
    {
        //
        // Lock access to this object.
        //
        m_Lock.Lock();

        //
        // Check parameter.
        //
        if (0 == hCertStore)
        {
            hr = E_INVALIDARG;

            DebugTrace("Error [%#x]: Parameter hCertStore is NULL.\n", hr);
            goto ErrorExit;
        }

        //
        // Duplicate the HCERTSTORE.
        //
        if (!::CertCloseStore((HCERTSTORE) hCertStore, 0))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertCloseStore() failed.\n", hr);
            goto ErrorExit;
        }
    }

    catch(...)
    {
        hr = E_POINTER;

        DebugTrace("Exception: invalid parameter.\n");
        goto ErrorExit;
    }

UnlockExit:
    //
    // Unlock access to this object.
    //
    m_Lock.Unlock();

    DebugTrace("Leaving CStore::CloseHandle().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    ReportError(hr);

    goto UnlockExit;
}

////////////////////////////////////////////////////////////////////////////////
//
// Private methods.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CStore::ImportCertObject

  Synopsis : Private function to import from a file.

  Parameter: DWORD dwObjectType - CERT_QUERY_OBJECT_FILE or 
                                  CERT_QUERY_OBJECT_BLOB.
  
             LPVOID pvObject - LPWSTR to file name for file object, and
                               DATA_BLOB * for blob object.

             BOOL bAllowPfx

             LPWSTR  pwszPassword (Optional)

             CAPICOM_KEY_STORAGE_FLAG KeyStorageFlag (Optional)

  Remark   :

------------------------------------------------------------------------------*/

STDMETHODIMP CStore::ImportCertObject (DWORD                    dwObjectType,
                                       LPVOID                   pvObject,
                                       BOOL                     bAllowPfx,
                                       LPWSTR                   pwszPassword,
                                       CAPICOM_KEY_STORAGE_FLAG KeyStorageFlag)
{
    HRESULT        hr             = S_OK;
    HCERTSTORE     hCertStore     = NULL;
    PCCERT_CONTEXT pEnumContext   = NULL;
    PCCERT_CONTEXT pCertContext   = NULL;
    DATA_BLOB      StoreBlob      = {0, NULL};
    DWORD          dwContentType  = 0;
    DWORD          dwExpectedType = CERT_QUERY_CONTENT_FLAG_CERT |
                                    CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE |
                                    CERT_QUERY_CONTENT_FLAG_SERIALIZED_CERT |
                                    CERT_QUERY_CONTENT_FLAG_PKCS7_UNSIGNED |
                                    CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED |
                                    CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED;

    DebugTrace("Entering CStore::ImportCertObject().\n");

    //
    // Sanity check.
    //
    ATLASSERT(pvObject);
    ATLASSERT(m_hCertStore);

    //
    // Set PFX flag, if allowed.
    //
    if (bAllowPfx)
    {
        dwExpectedType |= CERT_QUERY_CONTENT_FLAG_PFX;
    }

    //
    // Crack the blob.
    //
    if (!::CryptQueryObject(dwObjectType,
                            (LPCVOID) pvObject,
                            dwExpectedType,
                            CERT_QUERY_FORMAT_FLAG_ALL, 
                            0,
                            NULL,
                            &dwContentType,
                            NULL,
                            &hCertStore,
                            NULL,
                            NULL))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());

        DebugTrace("Error [%#x]: CryptQueryObject() failed.\n", hr);
        goto ErrorExit;
    }

    DebugTrace("Info: CryptQueryObject() returns dwContentType = %#x.\n", dwContentType);

    //
    // Need to import it ourselves for PFX.
    //
    if (CERT_QUERY_CONTENT_PFX == dwContentType)
    {
        DWORD dwFlags = 0;

        //
        // Make sure PFX is allowed.
        //
        if (!bAllowPfx)
        {
            hr = CAPICOM_E_NOT_SUPPORTED;

            DebugTrace("Error [%#x]: Importing PFX where not supported.\n", hr);
            goto ErrorExit;
        }

        //
        // Read the file if CERT_QUERY_OBJECT_FILE.
        //
        if (CERT_QUERY_OBJECT_FILE == dwObjectType)
        {
            if (FAILED(hr = ::ReadFileContent((LPWSTR) pvObject, &StoreBlob)))
            {
                DebugTrace("Error [%#x]: ReadFileContent() failed.\n", hr);
                goto ErrorExit;
            }
        }
        else
        {
            StoreBlob = * (DATA_BLOB *) pvObject;
        }

        // 
        // Setup import flags.
        //
        if (CAPICOM_LOCAL_MACHINE_STORE == m_StoreLocation)
        {
            dwFlags |= CRYPT_MACHINE_KEYSET;
        }
        else if (IsWin2KAndAbove())
        {
            dwFlags |= CRYPT_USER_KEYSET;
        }

        if (KeyStorageFlag & CAPICOM_KEY_STORAGE_EXPORTABLE)
        {
            dwFlags |= CRYPT_EXPORTABLE;
        }

        if (KeyStorageFlag & CAPICOM_KEY_STORAGE_USER_PROTECTED)
        {
            dwFlags |= CRYPT_USER_PROTECTED;
        }

        //
        // Now import the blob to store.
        //
        if (!(hCertStore = ::PFXImportCertStore((CRYPT_DATA_BLOB *) &StoreBlob,
                                                pwszPassword,
                                                dwFlags)))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: PFXImportCertStore() failed, dwFlags = %#x.\n", hr, dwFlags);
            goto ErrorExit;
        }
    }

    //
    // Sanity check.
    //
    ATLASSERT(hCertStore);

    //
    // Add all certificates to the current store.
    //
    while (pEnumContext = ::CertEnumCertificatesInStore(hCertStore, pEnumContext))
    {
        //
        // To avoid orphaning key container when importing PFX into system store, 
        // we need to find the cert in the target store. If we find the cert in the 
        // target store and the eixsitng cert also contain a key, then we will 
        // delete the new key container and key prov info before adding, if any.
        //
        if ((CERT_QUERY_CONTENT_PFX == dwContentType) && (CAPICOM_MEMORY_STORE != m_StoreLocation))
        {
            DWORD cbData = 0;
            DWORD cbData2 = 0;
            PCRYPT_KEY_PROV_INFO pKeyProvInfo = NULL;
            PCCERT_CONTEXT pExistingCertContext = NULL;

            //
            // Delete the new container, iif:
            // 1. The new cert exists in the target store, and
            // 2. The new cert has a key container, and
            // 3. The existing cert also has a key container.
            //
            if ((pExistingCertContext = ::CertFindCertificateInStore(m_hCertStore,
                                                                     CAPICOM_ASN_ENCODING,
                                                                     0,
                                                                     CERT_FIND_EXISTING,
                                                                     (PVOID) pEnumContext,
                                                                     NULL)) &&
                (::CertGetCertificateContextProperty(pEnumContext,
                                                     CERT_KEY_PROV_INFO_PROP_ID,
                                                     NULL,
                                                     &cbData)) &&
                (::CertGetCertificateContextProperty(pExistingCertContext,
                                                     CERT_KEY_PROV_INFO_PROP_ID,
                                                     NULL,
                                                     &cbData2)))

            {         
                HCRYPTPROV hCryptProv;

                //
                // Yes, so retrieve the new key prov info.
                //
                if (!(pKeyProvInfo = (PCRYPT_KEY_PROV_INFO) ::CoTaskMemAlloc(cbData)))
                {
                    hr = E_OUTOFMEMORY;

                    ::CertFreeCertificateContext(pExistingCertContext);

                    DebugTrace("Error [%#x]: CoTaskMemAlloc() failed.\n", hr);
                    goto ErrorExit;
                }

                if (!::CertGetCertificateContextProperty(pEnumContext,
                                                         CERT_KEY_PROV_INFO_PROP_ID,
                                                         pKeyProvInfo,
                                                         &cbData))
                {
                    hr = HRESULT_FROM_WIN32(::GetLastError());

                    ::CoTaskMemFree(pKeyProvInfo);
                    ::CertFreeCertificateContext(pExistingCertContext);

                    DebugTrace("Info [%#x]: CertGetCertificateContextProperty() failed.\n", hr);
                    goto ErrorExit;
                }

                //
                // Delete the new key container and its key prov info.
                //
                if (!::CertSetCertificateContextProperty(pEnumContext,
                                                         CERT_KEY_PROV_INFO_PROP_ID,
                                                         0,
                                                         NULL))
                {
                    hr = HRESULT_FROM_WIN32(::GetLastError());

                    ::CoTaskMemFree(pKeyProvInfo);
                    ::CertFreeCertificateContext(pExistingCertContext);

                    DebugTrace("Error [%#x]: CertSetCertificateContextProperty() failed.\n", hr);
                    goto ErrorExit;
                }

                if (FAILED(hr = ::AcquireContext(pKeyProvInfo->pwszProvName,
                                                 pKeyProvInfo->pwszContainerName,
                                                 pKeyProvInfo->dwProvType,
                                                 CRYPT_DELETEKEYSET | (pKeyProvInfo->dwFlags & CRYPT_MACHINE_KEYSET),
                                                 FALSE,
                                                 &hCryptProv)))
                {
                    ::CoTaskMemFree(pKeyProvInfo);
                    ::CertFreeCertificateContext(pExistingCertContext);

                    DebugTrace("Error [%#x]: AcquireContext(CRYPT_DELETEKEYSET) failed.\n", hr);
                    goto ErrorExit;
                }
                
                ::CoTaskMemFree(pKeyProvInfo);
                ::CertFreeCertificateContext(pExistingCertContext);
            }            
        }

        //
        // Add to store.
        //
        if (!::CertAddCertificateContextToStore(m_hCertStore,
                                                pEnumContext,
                                                CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES,
                                                &pCertContext))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DebugTrace("Error [%#x]: CertAddCertificateContextToStore() failed.\n", hr);
            goto ErrorExit;
        }

        //
        // Sanity check.
        //
        ATLASSERT(pCertContext);

        //
        // If loading a PFX, need to collect the key provider info for memory store
        // so that we know how to delete the key containers when the store is closed.
        //
        if (CERT_QUERY_CONTENT_PFX == dwContentType && 
            CAPICOM_MEMORY_STORE == m_StoreLocation)
        {
            DWORD cbData = 0;
            PCRYPT_KEY_PROV_INFO pKeyProvInfo = NULL;
            PCRYPT_KEY_PROV_INFO * rgpKeyProvInfo = NULL;

            //
            // Keep info of those with private key.
            //
            if (::CertGetCertificateContextProperty(pCertContext,
                                                    CERT_KEY_PROV_INFO_PROP_ID,
                                                    NULL,
                                                    &cbData))
            {
                if (!(pKeyProvInfo = (PCRYPT_KEY_PROV_INFO) ::CoTaskMemAlloc(cbData)))
                {
                    hr = E_OUTOFMEMORY;

                    DebugTrace("Error [%#x]: CoTaskMemAlloc() failed.\n", hr);
                    goto ErrorExit;
                }

                if (!::CertGetCertificateContextProperty(pCertContext,
                                                         CERT_KEY_PROV_INFO_PROP_ID,
                                                         pKeyProvInfo,
                                                         &cbData))
                {
                    hr = HRESULT_FROM_WIN32(::GetLastError());

                    ::CoTaskMemFree(pKeyProvInfo);

                    DebugTrace("Info [%#x]: CertGetCertificateContextProperty() failed.\n", hr);
                    goto ErrorExit;
                }

                //
                // Realloc the array.
                //
                if (!(rgpKeyProvInfo = (PCRYPT_KEY_PROV_INFO *) 
                    ::CoTaskMemRealloc(m_rgpKeyProvInfo, 
                                      (m_cKeyProvInfo + 1) * sizeof(PCRYPT_KEY_PROV_INFO))))
                {
                    hr = E_OUTOFMEMORY;

                    ::CoTaskMemFree(pKeyProvInfo);

                    DebugTrace("Error [%#x]: CoTaskMemRealloc() failed.\n", hr);
                    goto ErrorExit;
                }

                //
                // Store key info in array.
                //
                m_rgpKeyProvInfo = rgpKeyProvInfo;
                m_rgpKeyProvInfo[m_cKeyProvInfo++] = pKeyProvInfo;
            }
        }

        //
        // Free context.
        //
        ::CertFreeCertificateContext(pCertContext), pCertContext = NULL;
    }

    //
    // Above loop can exit either because there is no more certificate in
    // the store or an error. Need to check last error to be certain.
    //
    if (CRYPT_E_NOT_FOUND != ::GetLastError())
    {
       hr = HRESULT_FROM_WIN32(::GetLastError());
    
       DebugTrace("Error [%#x]: CertEnumCertificatesInStore() failed.\n", hr);
       goto ErrorExit;
    }

CommonExit:
    //
    // Free resources.
    //
    if (StoreBlob.pbData)
    {
        ::UnmapViewOfFile(StoreBlob.pbData);
    }
    if (pCertContext)
    {
        ::CertFreeCertificateContext(pCertContext);
    }
    if (pEnumContext)
    {
        ::CertFreeCertificateContext(pEnumContext);
    }
    if (hCertStore)
    {
        ::CertCloseStore(hCertStore, 0);
    }

    DebugTrace("Leaving CStore::ImportCertObject().\n");

    return hr;

ErrorExit:
    //
    // Sanity check.
    //
    ATLASSERT(FAILED(hr));

    goto CommonExit;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function : CStore::Close

  Synopsis : Private function to close the store.

  Parameter: 

  Remark   : Store is always closed even if error.

------------------------------------------------------------------------------*/

STDMETHODIMP CStore::Close (void)
{
    HRESULT hr = S_OK;

    DebugTrace("Entering CStore::Close().\n");

    //
    // Close it if opened.
    //
    if (m_hCertStore)
    {
        //
        // Delete key containers if necessary.
        //
        while (m_cKeyProvInfo--)
        {
            HCRYPTPROV hCryptProv = NULL;

            if (FAILED(hr = ::AcquireContext(m_rgpKeyProvInfo[m_cKeyProvInfo]->pwszProvName,
                                             m_rgpKeyProvInfo[m_cKeyProvInfo]->pwszContainerName,
                                             m_rgpKeyProvInfo[m_cKeyProvInfo]->dwProvType,
                                             CRYPT_DELETEKEYSET | 
                                                (m_rgpKeyProvInfo[m_cKeyProvInfo]->dwFlags & CRYPT_MACHINE_KEYSET),
                                             FALSE,
                                             &hCryptProv)))
            {
                DebugTrace("Info [%#x]: AcquireContext(CRYPT_DELETEKEYSET) failed.\n", hr);
            }

            ::CoTaskMemFree((LPVOID) m_rgpKeyProvInfo[m_cKeyProvInfo]);
        }

        //
        // Now free the arrays itself.
        //
        if (m_rgpKeyProvInfo)
        {
            ::CoTaskMemFree((LPVOID) m_rgpKeyProvInfo);
        }

        //
        // Close it.
        //
        ::CertCloseStore(m_hCertStore, 0);
    }

    //
    // Reset.
    //
    m_hCertStore = NULL;
    m_StoreLocation = CAPICOM_CURRENT_USER_STORE;
    m_bIsProtected = TRUE;
    m_cKeyProvInfo = 0;
    m_rgpKeyProvInfo = NULL;

    DebugTrace("Leaving CStore::Close().\n");

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\store.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Store.h

  Content: Declaration of CStore.

  History: 11-15-99    dsie     created

------------------------------------------------------------------------------*/

#ifndef __STORE_H_
#define __STORE_H_

#include "Resource.h"
#include "Error.h"
#include "Lock.h"
#include "Debug.h"
#include "DialogUI.h"

////////////////////////////////////////////////////////////////////////////////
//
// CStore
//

class ATL_NO_VTABLE CStore : 
    public ICertStore,
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CStore, &CLSID_Store>,
    public ICAPICOMError<CStore, &IID_IStore>,
    public IPromptUser<CStore>,
    public IDispatchImpl<IStore2, &IID_IStore2, &LIBID_CAPICOM,
                         CAPICOM_MAJOR_VERSION, CAPICOM_MINOR_VERSION>,
    public IObjectSafetyImpl<CStore, INTERFACESAFE_FOR_UNTRUSTED_CALLER | 
                                     INTERFACESAFE_FOR_UNTRUSTED_DATA>
{
public:
    CStore()
    {
    }

DECLARE_REGISTRY_RESOURCEID(IDR_STORE)

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CStore)
    COM_INTERFACE_ENTRY(IStore)
    COM_INTERFACE_ENTRY(IStore2)
    COM_INTERFACE_ENTRY(ICertStore)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(IObjectWithSite)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CStore)
    IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
    IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
END_CATEGORY_MAP()

    HRESULT FinalConstruct()
    {
        HRESULT hr;

        if (FAILED(hr = m_Lock.Initialized()))
        {
            DebugTrace("Error [%#x]: Critical section could not be created for Store object.\n", hr);
            return hr;
        }

        m_hCertStore = NULL;
        m_StoreLocation = CAPICOM_CURRENT_USER_STORE;
        m_bIsProtected = TRUE;
        m_cKeyProvInfo = 0;
        m_rgpKeyProvInfo = NULL;

        return S_OK;
    }

    void FinalRelease()
    {
        if (m_hCertStore)
        {
            Close();
        }
    }

//
// IStore
//
public:
    STDMETHOD(Import)
        (/*[in]*/ BSTR EncodedStore);

    STDMETHOD(Export)
        (/*[in, defaultvalue(CAPICOM_STORE_SAVE_AS_SERIALIZED)]*/ CAPICOM_STORE_SAVE_AS_TYPE SaveAs,
         /*[in, defaultvalue(CAPICOM_BASE64_ENCODE)]*/ CAPICOM_ENCODING_TYPE EncodingType,
         /*[out, retval]*/ BSTR * pVal);

    STDMETHOD(Remove)
        (/*[in]*/ ICertificate * pVal);

    STDMETHOD(Add)
        (/*[in]*/ ICertificate * pVal);

    STDMETHOD(Open)
        (/*[in]*/ CAPICOM_STORE_LOCATION StoreLocation,
         /*[in, defaultvalue("My")]*/ BSTR StoreName,
         /*[in, defaultvalue(CAPICOM_STORE_OPEN_MAXIMUM_ALLOWED)]*/ CAPICOM_STORE_OPEN_MODE OpenMode);

    STDMETHOD(get_Certificates)
        (/*[out, retval]*/ ICertificates ** pVal);

    //
    // v2.0
    //
    STDMETHOD(Load)
        (/*[in]*/ BSTR FileName, 
         /*[in, defaultvalue("")]*/ BSTR Password,
         /*[in, defaultvalue(CAPICOM_KEY_STORAGE_DEFAULT)]*/ CAPICOM_KEY_STORAGE_FLAG KeyStorageFlag);

    //
    // Custom interfaces.
    //
    STDMETHOD(get_StoreHandle)
        (/*[out, retval]*/ long * phCertStore);

    STDMETHOD(put_StoreHandle)
        (/*[in]*/ long hCertStore);

    STDMETHOD(get_StoreLocation)
        (/*[out, retval]*/ CAPICOM_STORE_LOCATION * pStoreLocation);

    STDMETHOD(put_StoreLocation)
        (/*[in]*/ CAPICOM_STORE_LOCATION StoreLocation);

    STDMETHOD(CloseHandle)
        (/*[in]*/ long hCertStore);

    //
    // None COM functions.
    //
    STDMETHOD(ImportCertObject)
        (DWORD                    dwObjectType,
         LPVOID                   pvObject,
         BOOL                     bAllowPfx,
         LPWSTR                   pwszPassword,
         CAPICOM_KEY_STORAGE_FLAG KeyStorageFlag);

    STDMETHOD(Close)
        (void);
    
private:
    CLock                  m_Lock;
    HCERTSTORE             m_hCertStore;
    CAPICOM_STORE_LOCATION m_StoreLocation;
    BOOL                   m_bIsProtected;
    DWORD                  m_cKeyProvInfo;
    PCRYPT_KEY_PROV_INFO * m_rgpKeyProvInfo;
};

#endif //__STORE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\activex\capicom\smartcard.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    SmartCard.cpp

  Content: Implementation of helper routines for accessing certificates in
           smart card. Functions in this module require that the Smart Card Base
           Component v1.1 to be installed.

  History: 12-06-2001    dsie     created

------------------------------------------------------------------------------*/

#include "StdAfx.h"
#include "CAPICOM.h"
#include "SmartCard.h"

//
// typedefs for SCardXXX APIs.
//
typedef WINSCARDAPI LONG (WINAPI * PFNSCARDESTABLISHCONTEXT) (
    IN     DWORD          dwScope,
    IN     LPCVOID        pvReserved1,
    IN     LPCVOID        pvReserved2,
    OUT    LPSCARDCONTEXT phContext);

typedef WINSCARDAPI LONG (WINAPI * PFNSCARDLISTREADERSA) (
    IN     SCARDCONTEXT hContext,
    IN     LPCSTR       mszGroups,
    OUT    LPSTR        mszReaders,
    IN OUT LPDWORD      pcchReaders);

typedef WINSCARDAPI LONG (WINAPI * PFNSCARDGETSTATUSCHANGEA) (
    IN     SCARDCONTEXT          hContext,
    IN     DWORD                 dwTimeout,
    IN OUT LPSCARD_READERSTATE_A rgReaderStates,
    IN     DWORD                 cReaders);

typedef WINSCARDAPI LONG (WINAPI * PFNSCARDLISTCARDSA) (
    IN     SCARDCONTEXT hContext,
    IN     LPCBYTE      pbAtr,
    IN     LPCGUID      rgquidInterfaces,
    IN     DWORD        cguidInterfaceCount,
    OUT    LPSTR        mszCards,
    IN OUT LPDWORD      pcchCards);

typedef WINSCARDAPI LONG (WINAPI* PFNSCARDGETCARDTYPEPROVIDERNAMEA) (
    IN     SCARDCONTEXT hContext,
    IN     LPCSTR       szCardName,
    IN     DWORD        dwProviderId,
    OUT    LPSTR        szProvider,
    IN OUT LPDWORD      pcchProvider);

typedef WINSCARDAPI LONG (WINAPI* PFNSCARDFREEMEMORY) (
    IN     SCARDCONTEXT hContext,
    IN     LPVOID       pvMem);

typedef WINSCARDAPI LONG (WINAPI * PFNSCARDRELEASECONTEXT) (
    IN     SCARDCONTEXT hContext);

//
// Function pointer to SCardXXX APIs.
//
static PFNSCARDESTABLISHCONTEXT           pfnSCardEstablishContext          = NULL;
static PFNSCARDLISTREADERSA               pfnSCardListReadersA              = NULL;
static PFNSCARDGETSTATUSCHANGEA           pfnSCardGetStatusChangeA          = NULL;
static PFNSCARDLISTCARDSA                 pfnSCardListCardsA                = NULL;
static PFNSCARDGETCARDTYPEPROVIDERNAMEA   pfnSCardGetCardTypeProviderNameA  = NULL;
static PFNSCARDFREEMEMORY                 pfnSCardFreeMemory                = NULL;
static PFNSCARDRELEASECONTEXT             pfnSCardReleaseContext            = NULL;

////////////////////////////////////////////////////////////////////////////////
//
// Local functions.
//

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Function : AddCert

 Synopsis : Add the specified certificate to the specified store.

 Parameter: - IN LPCSTR szCSPName
 
              CSP name string.
              
            - IN LPCSTR szContainerName
            
              Key container name string.
 
            - IN DWORD dwKeySpec

              AT_KEYEXCHANGZE or AT_SIGNATURE.
            
            - IN LPBYTE pbEncodedCert

              Pointer to encoded cert data to be added.

            - IN DWORD cbEncodedCert

              Length of encoded cert data.

            - IN HCERTSTORE hCertStore
            
              Handle of cert store where the cert will be added.

 Remarks  :

------------------------------------------------------------------------------*/

static HRESULT AddCert (IN LPCSTR     szCSPName,
                        IN LPCSTR     szContainerName,
                        IN DWORD      dwKeySpec,
                        IN LPBYTE     pbEncodedCert,
                        IN DWORD      cbEncodedCert,
                        IN HCERTSTORE hCertStore)
{
   HRESULT        hr                = S_OK;
   PCCERT_CONTEXT pCertContext      = NULL;
   CComBSTR       bstrCSPName;
   CComBSTR       bstrContainerName;
   CRYPT_KEY_PROV_INFO KeyProvInfo;

   DebugTrace("Entering AddCert().\n");

   //
   // Sanity check.
   //
   ATLASSERT(szCSPName);
   ATLASSERT(szContainerName);
   ATLASSERT(pbEncodedCert);
   ATLASSERT(cbEncodedCert);
   ATLASSERT(hCertStore);

   //
   // Create certificate context for the specified certificate.
   //
   if (!(pCertContext = ::CertCreateCertificateContext(CAPICOM_ASN_ENCODING,
                                                       pbEncodedCert,
                                                       cbEncodedCert)))
   {
       hr = HRESULT_FROM_WIN32(::GetLastError());

       DebugTrace("Error [%#x]: CertCreateCertificateContext() failed.\n", hr);
       goto ErrorExit;
   }

   //
   // Convert strings to UNICODE.
   //
   if (!(bstrCSPName = szCSPName))
   {
       hr = E_OUTOFMEMORY;

       DebugTrace("Error [%#x]: bstrCSPName = szCSPName failed.\n", hr);
       goto ErrorExit;
   }
   if (!(bstrContainerName = szContainerName))
   {
       hr = E_OUTOFMEMORY;

       DebugTr