hite();

    // Get/set colors

    VOID GetCenterColor(GpColor* color) const
    {
        if(color)
            *color = DeviceBrush.Colors[0];
    }

    VOID SetCenterColor(const GpColor& color)
    {
        DeviceBrush.Colors[0] = color;
        UpdateUid();
    }

    GpStatus GetSurroundColor(GpColor* color, INT index) const
    {
        if(color && index >= 0 && index < DeviceBrush.Count)
        {
            if(DeviceBrush.OneSurroundColor)
                *color = DeviceBrush.ColorsPtr[0];
            else
                *color = DeviceBrush.ColorsPtr[index];
            return Ok;
        }
        else
            return InvalidParameter;
    }

    GpStatus SetSurroundColor(GpColor& color, INT index);
    GpStatus SetSurroundColors(const GpColor* colors);

    GpStatus GetSurroundColors(GpColor* colors) const
    {
        GpStatus status = InvalidParameter;

        if(IsValid() && colors) {
            GpMemcpy(colors,
                     DeviceBrush.ColorsPtr,
                     DeviceBrush.Count*sizeof(GpColor));
            status = Ok;
        }

        return status;
    }

    // Get/set polygon

    GpStatus GetPolygon(GpPointF* points)
    {
        GpStatus status = InvalidParameter;

        ASSERT(DeviceBrush.Count > 0);

        if(IsValid() && points && DeviceBrush.Count > 0)
        {
            GpMemcpy(points,
                     DeviceBrush.PointsPtr,
                     DeviceBrush.Count*sizeof(GpPointF));
            status = Ok;
        }

        return status;
    }

    GpStatus SetPolygon(const GpPointF* points)
    {
        GpStatus status = InvalidParameter;

        ASSERT(DeviceBrush.Count > 0);

        if(IsValid() && points && DeviceBrush.Count > 0)
        {
            GpMemcpy(DeviceBrush.PointsPtr,
                     points,
                     DeviceBrush.Count*sizeof(GpPointF));

            UpdateUid();
            status = Ok;
        }

        return status;
    }

    GpStatus GetPoint(GpPointF* point, INT index) const
    {
        if(point && index >= 0 && index < DeviceBrush.Count)
        {
            *point = DeviceBrush.PointsPtr[index];
            return Ok;
        }
        else
            return GenericError;
    }

    GpStatus SetPoint(GpPointF& point, INT index)
    {
        if(index >= 0 && index < DeviceBrush.Count)
        {
            DeviceBrush.PointsPtr[index] = point;
            UpdateUid();
            return Ok;
        }
        else
            return InvalidParameter;
    }

    GpStatus GetCenterPoint(GpPointF* point) const
    {
        if(point)
        {
            *point = DeviceBrush.Points[0];
            return Ok;
        }
        else
            return InvalidParameter;
    }

    GpStatus SetCenterPoint(const GpPointF& point)
    {
        DeviceBrush.Points[0] = point;
        UpdateUid();
        return Ok;
    }

    GpStatus GetInflationFactor(REAL* inflation) const
    {
        if (inflation)
        {
            *inflation = InflationFactor;
            return Ok;
        }
        else
        {
            return InvalidParameter;
        }
    }
    
    GpStatus SetInflationFactor(REAL inflation)
    {
        InflationFactor = inflation;
        UpdateUid();
        return Ok;
    }

    GpStatus GetFocusScales(REAL* xScale, REAL* yScale)
    {
        if(xScale && yScale)
        {
            *xScale = DeviceBrush.FocusScaleX;
            *yScale = DeviceBrush.FocusScaleY;

            return Ok;
        }
        else
            return InvalidParameter;
    }

    GpStatus SetFocusScales(REAL xScale, REAL yScale)
    {
        DeviceBrush.FocusScaleX = xScale;
        DeviceBrush.FocusScaleY = yScale;

        UpdateUid();
        return Ok;
    }

    // Number of Surround Points and Colors.

    INT GetNumberOfPoints() const {return DeviceBrush.Count;}
    INT GetNumberOfColors() const {return DeviceBrush.Count;}
    BOOL UsesDefaultColorArray() const {return FALSE;}    // Don't use
                                                    // the default array.

    VOID GetColors(GpColor* colors) const // Implement a vurtual function.
    {
        GetSurroundColors(colors);
    }

    // Get/set falloff / blend-factors

    BOOL HasPresetColors() const
    {
        return DeviceBrush.UsesPresetColors;
    }

    INT GetBlendCount() const
    {
        return DeviceBrush.BlendCounts[0];
    }

    GpStatus GetBlend(REAL* blendFactors, REAL* blendPositions, INT count) const;
    GpStatus SetBlend(const REAL* blendFactors,
                       const REAL* blendPositions, INT count);

    // Get/set preset blend-factors

    INT GetPresetBlendCount() const;

    GpStatus GetPresetBlend(
                GpColor* blendColors,
                REAL* blendPositions,
                INT count) const;

    GpStatus SetPresetBlend(
                const GpColor* blendColors,
                const REAL* blendPositions,
                INT count);


    // Check if the Path Gradient is rectangular.
    BOOL IsRectangular() const
    {
        const GpPointF *points;
        INT count;
        
        if (DeviceBrush.Path != NULL) 
        {
            return DeviceBrush.Path->IsRectangular();
        }
        else
        {
            count = DeviceBrush.Count;
            points = DeviceBrush.PointsPtr;
        }

        if (count > 0 && points != NULL) 
        {
            for (INT i=0; i<count; i++) 
            {
                INT j = (i+1) % count;

                if (REALABS(points[i].X-points[j].X) > REAL_EPSILON &&
                    REALABS(points[i].Y-points[j].Y) > REAL_EPSILON) 
                {
                    // Points are not at 90 degree angles, not rectangular.
                    return FALSE;
                }
            }

            return TRUE;
        }

        return FALSE;
    }

    // Check the opacity of this brush element.

    virtual BOOL IsOpaque(BOOL ColorsOnly = FALSE) const
    {
        // This gradient brush is opaque only if
        // all the colors are opaque (including the center color
        // which is DeviceBrush.Colors[0]).
        // In case of WrapModeClamp mode, we need alpha channel to do
        // clipping outside of the polygon.

        BOOL test;

        if(ColorsOnly || DeviceBrush.Wrap != WrapModeClamp)
        {
            test = (ColorsOnly || IsRectangle()) &&
                   DeviceBrush.Colors[0].IsOpaque();
            INT i = 0;
            INT count = DeviceBrush.UsesPresetColors ? DeviceBrush.BlendCounts[0] : DeviceBrush.Count;

            while(i < count && test)
            {
                if (DeviceBrush.UsesPresetColors)
                {
                    test = (DeviceBrush.PresetColors[i] & Color::AlphaMask) == 
                           Color::AlphaMask;
                }
                else
                {
                    test = DeviceBrush.ColorsPtr[i].IsOpaque();
                }
                i++;
            }
        }
        else
            test = FALSE;

        return test;
    }

    virtual GpSpecialGradientType
        GetSpecialGradientType(const GpMatrix* matrix) const
    {
        if (DeviceBrush.UsesPresetColors) 
        {
            ARGB color1 = DeviceBrush.Colors[0].GetValue();         // Center color
            ARGB color2 = DeviceBrush.PresetColors[0];   // 1st Preset Color

            for (INT i=1; i<DeviceBrush.BlendCounts[0]; i++)
            {
                ARGB color = DeviceBrush.PresetColors[i];

                if ((color1 != color) && (color2 != color))
                {
                    if (color1 == color2)
                    {
                        color2 = color;
                    }
                    else
                    {
                        return GradientTypePathComplex;
                    }
                }
            }
        }
        else
        {
            if (DeviceBrush.OneSurroundColor || DeviceBrush.Count <= 2)
            {
                return GradientTypePathTwoStep;
            }

            GpColor *color1 = &(DeviceBrush.ColorsPtr[0]);
            GpColor *color2 = &(DeviceBrush.ColorsPtr[1]);

            for (INT i=2; i<DeviceBrush.Count; i++)
            {
                GpColor *color = &(DeviceBrush.ColorsPtr[i]);

                if (!color1->IsEqual(*color) && !color2->IsEqual(*color))
                {
                    if (color1->IsEqual(*color2))
                    {
                        color2 = color;
                    }
                    else
                    {
                        return GradientTypePathComplex;
                    }
                }
            }
        }

        return GradientTypePathTwoStep;
    }

    virtual BOOL IsSolid() const
    {
        //This is not optimal but is such a rare case that it probably 
        //shouldn't be fixed as long as we keep the defination of IsSolid 
        //that we are currently using.  See comment at GpBrush::IsSolid for 
        //definition.
        return FALSE;
    }

    virtual BOOL IsNearConstant(BYTE* MinAlpha, BYTE* MaxAlpha) const
    {
        if (HasPresetColors()) 
        {
            *MaxAlpha = DeviceBrush.Colors[0].GetAlpha();
            *MinAlpha = *MaxAlpha;
            
            for (INT i=0; i<DeviceBrush.BlendCounts[0]; i++)
            {
                *MaxAlpha = max(*MaxAlpha, GpColor(DeviceBrush.PresetColors[i]).GetAlpha());
                *MinAlpha = min(*MinAlpha, GpColor(DeviceBrush.PresetColors[i]).GetAlpha());
            }
        }
        else
        {
            if (DeviceBrush.OneSurroundColor)
            {
                *MaxAlpha = max((DeviceBrush.ColorsPtr[0]).GetAlpha(), // surround
                                (DeviceBrush.Colors[0]).GetAlpha()); // center
                *MinAlpha = min((DeviceBrush.ColorsPtr[0]).GetAlpha(), // surround
                                (DeviceBrush.Colors[0]).GetAlpha()); // center            }
            }
            else
            {
                *MaxAlpha = DeviceBrush.Colors[0].GetAlpha();
                *MinAlpha = *MaxAlpha;
                
                for (INT i=0; i<DeviceBrush.Count; i++)
                {
                    *MaxAlpha = max(*MaxAlpha, DeviceBrush.ColorsPtr[i].GetAlpha());
                    *MinAlpha = min(*MinAlpha, DeviceBrush.ColorsPtr[i].GetAlpha());
                }
            }
        }
        
        return (*MaxAlpha - *MinAlpha < NEARCONSTANTALPHA);
    }
    
    virtual BOOL IsEqual(const GpBrush * brush) const;

    virtual DpOutputSpan* CreateOutputSpan(
                DpScanBuffer *  scan,
                DpContext *context,
                const GpRect *drawBounds=NULL);

protected:  // GDI+ Internal

    GpPathGradient(const GpPathGradient* brush);

    VOID
    PrepareBrush();

    VOID
    InitializeBrush(
        const GpPointF* points,
        INT count,
        GpWrapMode wrapMode = WrapModeClamp
        )
    {
        DeviceBrush.Type = BrushTypePathGradient;
        DeviceBrush.Wrap = wrapMode;
        SetValid(FALSE);
        DeviceBrush.OneSurroundColor = TRUE;
        DeviceBrush.UsesPresetColors = FALSE;

        MorphedBrush = NULL;
        DeviceBrush.Path = NULL;
        DeviceBrush.PointsPtr = NULL;
        DeviceBrush.ColorsPtr = NULL;

        // Set the blending and fall off factors.

        DeviceBrush.Falloffs[0] = 1;
        DeviceBrush.BlendCounts[0] = 1;
        DeviceBrush.BlendFactors[0] = NULL;
        DeviceBrush.BlendPositions[0] = NULL;
        DeviceBrush.PresetColors = NULL;

        if(!WrapModeIsValid(wrapMode) || count <= 0 || points == NULL)
        {
            DeviceBrush.Count = 0;
            return;
        }

        DeviceBrush.Count = count;

        // Get the boundary rectangle.

        REAL xmin, xmax, ymin, ymax, x0, y0;

        x0 = xmin = xmax = points[0].X;
        y0 = ymin = ymax = points[0].Y;

        for(INT i = 1; i < DeviceBrush.Count; i++)
        {
            x0 += points[i].X;
            y0 += points[i].Y;
            xmin = min(xmin, points[i].X);
            xmax = max(xmax, points[i].X);
            ymin = min(ymin, points[i].Y);
            ymax = max(ymax, points[i].Y);
        }

        DeviceBrush.Rect.X = xmin;
        DeviceBrush.Rect.Width = xmax - xmin;
        DeviceBrush.Rect.Y = ymin;
        DeviceBrush.Rect.Height = ymax - ymin;

        if(DeviceBrush.Rect.Width <= 0 ||
           DeviceBrush.Rect.Height <= 0)
            return;

        // The default center point is the center of gravity.

        DeviceBrush.Points[0].X = x0 / DeviceBrush.Count;
        DeviceBrush.Points[0].Y = y0 / DeviceBrush.Count;

        DeviceBrush.PointsPtr =
            (GpPointF*) GpMalloc(DeviceBrush.Count *
                                 sizeof(GpPointF));

        if(!DeviceBrush.PointsPtr)
        {
            DeviceBrush.Count = 0;
            return;
        }

        DeviceBrush.ColorsPtr =
            (GpColor*) GpMalloc(DeviceBrush.Count *
                                sizeof(GpColor));

        if(!DeviceBrush.ColorsPtr)
        {
            GpFree(DeviceBrush.PointsPtr);
            DeviceBrush.PointsPtr = NULL;
            DeviceBrush.Count = 0;
            return;
        }

        // If this comes so far, both Points and Colors are valid.

        GpMemcpy(&DeviceBrush.PointsPtr[0],
                 points,
                 DeviceBrush.Count*sizeof(GpPointF));

        GpMemset(&DeviceBrush.ColorsPtr[0],
                 255,
                 DeviceBrush.Count*sizeof(GpColor));

        DeviceBrush.FocusScaleX = 0;
        DeviceBrush.FocusScaleY = 0;

        InflationFactor = 0.0f;

        SetValid(TRUE);
    }

    VOID DefaultBrush(VOID)
    {
        DeviceBrush.Type = BrushTypePathGradient;
        SetValid(FALSE);
        DeviceBrush.OneSurroundColor = TRUE;
        DeviceBrush.Wrap = WrapModeClamp;
        DeviceBrush.UsesPresetColors = FALSE;

        DeviceBrush.Path = NULL;
        DeviceBrush.PointsPtr = NULL;
        DeviceBrush.ColorsPtr = 0;
        DeviceBrush.Count = 0;

        // The default center point is the center of gravity.

        GpMemset(&DeviceBrush.Rect, 0, sizeof(GpRectF));
        GpMemset(&DeviceBrush.Points, 0, sizeof(GpPointF));
        GpMemset(&DeviceBrush.Colors, 255, sizeof(GpColor));

        DeviceBrush.FocusScaleX = 0;
        DeviceBrush.FocusScaleY = 0;

        // Set the blending and fall off factors.

        DeviceBrush.Falloffs[0] = 1;
        DeviceBrush.BlendCounts[0] = 1;
        DeviceBrush.BlendFactors[0] = NULL;
        DeviceBrush.BlendPositions[0] = NULL;
        DeviceBrush.PresetColors = NULL;

        MorphedBrush = NULL;
        InflationFactor = 0.0f;
    }

    // This does not update the Uid of the object because it's defined as const
    // But the object doesn't really change anyway
    GpStatus Flatten(GpMatrix* matrix) const;

    virtual
    const DpPath *
    GetOutlinePath(
        VOID
        ) const
    {
        return DeviceBrush.Path;
    }

protected:
    GpBrush* MorphedBrush;
    DynByteArray FlattenTypes;
    DynPointFArray FlattenPoints;
    REAL InflationFactor;
};

//--------------------------------------------------------------------------
// Represent hatch brush object
//--------------------------------------------------------------------------

class GpHatch : public GpBrush
{
friend class DpOutputHatchSpan;

public:

    // Constructors

    GpHatch(VOID)
    {
        DefaultBrush();
    }

    GpHatch(GpHatchStyle hatchStyle, const GpColor& foreColor)
    {
        InitializeBrush(hatchStyle, foreColor, 0);
    }

    GpHatch(
        GpHatchStyle hatchStyle,
        const GpColor& foreColor,
        const GpColor& backColor)
    {
        InitializeBrush(hatchStyle, foreColor, backColor);
    }

    GpBrush* Clone() const
    {
        return new GpHatch(this);
    }

    ~GpHatch() {}

    virtual UINT GetDataSize() const;
    virtual GpStatus GetData(IStream * stream) const;
    virtual GpStatus SetData(const BYTE * dataBuffer, UINT size);

    virtual GpStatus ColorAdjust(
        GpRecolor *             recolor,
        ColorAdjustType         type
        );

    virtual BOOL IsOpaque(BOOL ColorsOnly = FALSE) const
    {
        // This brush is opaque only if
        // all the colors are opaque.
        return (DeviceBrush.Colors[0].IsOpaque() &&
                DeviceBrush.Colors[1].IsOpaque());
    }

    virtual BOOL IsSolid() const
    {
        //This may have to change if we change the defination of IsSolid.  
        //See comment at GpBrush::IsSolid() for more info.
        return FALSE;
    }

    virtual BOOL IsNearConstant(BYTE* MinAlpha, BYTE* MaxAlpha) const
    {
        *MinAlpha = min(DeviceBrush.Colors[0].GetAlpha(),
                        DeviceBrush.Colors[1].GetAlpha());
        *MaxAlpha = max(DeviceBrush.Colors[0].GetAlpha(),
                        DeviceBrush.Colors[1].GetAlpha());
        
        return (*MaxAlpha - *MinAlpha < NEARCONSTANTALPHA);
    }
    
    virtual BOOL IsEqual(const GpBrush * brush) const;

    virtual DpOutputSpan* CreateOutputSpan(
                DpScanBuffer *  scan,
                DpContext *context,
                const GpRect *drawBounds=NULL);

    virtual GpSpecialGradientType
        GetSpecialGradientType(const GpMatrix* matrix) const
    {
        return GradientTypeNotSpecial;
    }

    GpHatchStyle GetHatchStyle()
    {
        return DeviceBrush.Style;
    }

    GpStatus GetForegroundColor(GpColor* color)
    {
        ASSERT(color != NULL);
        *color = DeviceBrush.Colors[0];

        return Ok;
    }

    GpStatus GetBackgroundColor(GpColor* color)
    {
        ASSERT(color != NULL);
        *color = DeviceBrush.Colors[1];

        return Ok;
    }

    VOID SetStretchFactor(INT stretch)
    {
        StretchFactor = stretch;
    }

private:

    GpHatch(const GpHatch* brush);

    VOID
    InitializeBrush(
        GpHatchStyle hatchStyle,
        const GpColor& foreColor,
        const GpColor& backColor
        )
    {
        DeviceBrush.Type = BrushTypeHatchFill;
        DeviceBrush.Style = hatchStyle;
        DeviceBrush.Colors[0] = foreColor;
        DeviceBrush.Colors[1] = backColor;
        StretchFactor = 1;
        InitializeData();
        SetValid(TRUE);
    }

    VOID DefaultBrush()
    {
        InitializeBrush(HatchStyle50Percent,
                        GpColor(Color::Black),
                        GpColor(Color::White));
    }

    VOID
    InitializeData();

    INT StretchFactor;
};

#endif _BRUSH_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\cachedbitmap.hpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   GpCachedBitmap object
*
*
* Created:
*
*   04/23/2000 asecchia
*      Created it.
*
**************************************************************************/

#ifndef _CACHEDBITMAP_HPP
#define _CACHEDBITMAP_HPP

class GpCachedBitmap
{
    friend GpGraphics;
    
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    
    ObjectTag           Tag;    // Keep this as the 1st value in the object!
    
    GpLockable Lockable;

    DpCachedBitmap DeviceCachedBitmap;

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectCachedBitmap : ObjectTagInvalid;
    }

public:

    // constructor and destructor

    GpCachedBitmap(GpBitmap *bitmap, GpGraphics *graphics);
    virtual ~GpCachedBitmap();

    // 'getter' state retrieval

    BOOL IsValid() const
    {
    #ifdef _X86_
        // We have to guarantee that the Tag field doesn't move for
        // versioning to work between releases of GDI+.
        ASSERT(offsetof(GpCachedBitmap, Tag) == 4);
    #endif
    
        ASSERT((Tag == ObjectCachedBitmap) || (Tag == ObjectTagInvalid)); 
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid CachedBitmap");
        }
    #endif

        return (Tag == ObjectCachedBitmap);
    }

    void GetSize(Size *s)
    {
        // Get the width and height from the DeviceCachedBitmap.

        s->Width = DeviceCachedBitmap.Width;
        s->Height = DeviceCachedBitmap.Height;
    }

    // Get the lock object

    GpLockable *GetObjectLock()
    {
        return &Lockable;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\compatibledib.hpp ===
/**************************************************************************\
*
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*    Compatible DIBSections
*
* Abstract:
*
*    Create a DIB section with an optimal format w.r.t. the specified hdc.
*    CreateSemiCompatibleDIB makes an exception if the format is <8bpp;
*    in such a case it returns an 8bpp DIBSection.
*
* Notes:
*
* History:
*
*  01/23/1996 gilmanw
*     Created it.
*  01/21/2000 agodfrey
*     Added it to GDI+ (from Gilman's 'fastdib.c'), and morphed it into 
*     'CreateSemiCompatibleDIB'.
*
\**************************************************************************/

#ifndef _COMPATIBLEDIB_HPP
#define _COMPATIBLEDIB_HPP

PixelFormatID
ExtractPixelFormatFromHDC(
    HDC hdc
    );

HBITMAP 
CreateSemiCompatibleDIB(
    HDC hdc, 
    ULONG ulWidth, 
    ULONG ulHeight,
    ColorPalette *palette,
    PVOID *ppvBits,
    PixelFormatID *pixelFormat
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\brush.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Implementation of GpBrush class
*
* Revision History:
*
*   12/09/1998 davidx
*       Flesh out brush interfaces.
*
*   12/08/1998 andrewgo
*       Initial placeholders.
*
\**************************************************************************/

#include "precomp.hpp"

// For GetData and SetData methods
#define GDIP_BRUSHFLAGS_PATH                0x00000001
#define GDIP_BRUSHFLAGS_TRANSFORM           0x00000002
#define GDIP_BRUSHFLAGS_PRESETCOLORS        0x00000004
#define GDIP_BRUSHFLAGS_BLENDFACTORS        0x00000008
#define GDIP_BRUSHFLAGS_BLENDFACTORSH       GDIP_BRUSHFLAGS_BLENDFACTORS
#define GDIP_BRUSHFLAGS_BLENDFACTORSV       0x00000010
#define GDIP_BRUSHFLAGS_BLENDFACTORS0       GDIP_BRUSHFLAGS_BLENDFACTORSH
#define GDIP_BRUSHFLAGS_BLENDFACTORS1       GDIP_BRUSHFLAGS_BLENDFACTORSV
#define GDIP_BRUSHFLAGS_BLENDFACTORS2       0x00000020
#define GDIP_BRUSHFLAGS_FOCUSSCALES         0x00000040
#define GDIP_BRUSHFLAGS_ISGAMMACORRECTED    0x00000080

// Defined in path.cpp
extern BOOL 
IsRectanglePoints(
    const GpPointF* points,
    INT count,
    const GpMatrix * matrix,
    GpRectF * transformedBounds
    );

GpStatus
GpElementaryBrush::MultiplyTransform(const GpMatrix& matrix,
                                   GpMatrixOrder order)
{
    GpStatus    status = Ok;

    if (matrix.IsInvertible())
    {
        if (order == MatrixOrderPrepend)
        {
            DeviceBrush.Xform.Prepend(matrix);
        }
        else
        {
            DeviceBrush.Xform.Append(matrix);
        }
        UpdateUid();
    }
    else
        status = InvalidParameter;

    return status;
}


/**************************************************************************\
*
* Function Description:
*
*   Calculate the brush transform from a starting point and two directions.
*
* Arguments:
*
*   [OUT] m         - matrix coefficients
*   [OUT] width     - width (the length of dP1)
*   [OUT] height    - height (the length of dP2)
*   [IN] p0         - the starting point of the brush.
*   [IN] dP1        - the vector to represent the transformed x-direction.
*   [IN] dP2        - the vector to represent the transformed y-direction.
*
* Return Vaule:
*
*   TRUE if the transform matrix is non-degenerate.
*   Otherwise returns FALSE.
*
* History:
*
*   06/03/1999 ikkof
*       Created it.
*
\**************************************************************************/

BOOL getLineGradientTransform(
    REAL* m,
    REAL* width,
    REAL* height,
    const GpPointF& p0,
    const GpPointF& dP1,
    const GpPointF& dP2
    )
{
    // Make sure the flat API has correctly set the FPU.

    FPUStateSaver::AssertMode();

    REAL l1 = dP1.X*dP1.X + dP1.Y*dP1.Y;
    REAL l2 = dP2.X*dP2.X + dP2.Y*dP2.Y;
    REAL test = dP1.X*dP2.Y - dP1.Y*dP2.X;

    if(l1 == 0 || l2 == 0 || test == 0)
        return FALSE;

    l1 = REALSQRT(l1);
    l2 = REALSQRT(l2);
    m[0] = TOREAL(dP1.X/l1);    // M11
    m[1] = TOREAL(dP1.Y/l1);    // M12
    m[2] = TOREAL(dP2.X/l2);   // M21
    m[3] = TOREAL(dP2.Y/l2);    // M22
    m[4] = TOREAL(p0.X - p0.X*m[0] - p0.Y*m[2]);    // Dx
    m[5] = TOREAL(p0.Y - p0.X*m[1] - p0.Y*m[3]);    // Dy

    *width = l1;
    *height = l2;

    return TRUE;
}

static GpStatus
LinearGradientRectFromPoints(
    const GpPointF& point1,
    const GpPointF& point2,
    GpRectF &       rect
    )
{
    // If the API specifies two coincident points, we
    // can't get information for the gradient, so we
    // fail the construction here.

    if( IsClosePointF(point1, point2) )
    {
        return InvalidParameter;
    }

    // Compute the bounding rectangle of the two input points.

    rect.X = min(point1.X, point2.X);
    rect.Y = min(point1.Y, point2.Y);
    rect.Width = REALABS(point1.X-point2.X);
    rect.Height = REALABS(point1.Y-point2.Y);

    // eliminate degenerate rectangles when the two
    // input points form a horizontal or vertical line.

    // This is a very odd way of coercing a 1d linear gradient
    // into a rect gradient and avoiding later matrix computation error
    // when we try get an affine warp between this rectangle and a
    // reference rectangle.

    if( IsCloseReal(point1.X, point2.X) )
    {
        rect.X -= rect.Height/2;
        rect.Width = rect.Height;
    }

    if( IsCloseReal(point1.Y, point2.Y) )
    {
        rect.Y -= rect.Width/2;
        rect.Height = rect.Width;
    }
    return Ok;
}

static GpStatus 
CalcLinearGradientXform(
    REAL                angle,
    BOOL                isAngleScalable,
    const GpRectF&      rect,
    GpMatrix&           xform
    )
{
    GpPointF p0, dP1, dP2;

    angle = GpModF(angle, 360);

    INT zone;
    REALD deltaTheta;
    const REALD degreeToRadian = 3.1415926535897932/180;

    if(angle < 90)
    {
        zone = 0;
        deltaTheta = angle;
    }
    else if(angle < 180)
    {
        zone = 1;
        deltaTheta = 180 - angle;
    }
    else if(angle < 270)
    {
        zone = 2;
        deltaTheta = angle - 180;
    }
    else
    {
        zone = 3;
        deltaTheta = 360 - angle;
    }

    REALD s, c;

    deltaTheta *= degreeToRadian;

    s = sin(deltaTheta);
    c = cos(deltaTheta);

    // d0 is the distance between p0 and the starting corner of the
    // original rectangle.
    // d1 and d2 is the length of dP1 and dP2, respectively.

    REALD top, left, w, h, d0, d1, d2;
    REALD x0, y0;   // Starting corner of the original rectangle.
    GpPointD norm;  // Direction of dP1.

    // Direction of dP2 = (-norm.Y, norm.X) which is 90 degree rotation
    // of dP1.

    if(!isAngleScalable)
    {
        left = rect.X;
        top = rect.Y;
        w = rect.Width;
        h = rect.Height;
    }
    else
    {
        // Scale to (0, 0, 1, 1) rectangle.

        top = 0.0;
        left = 0.0;
        w = 1.0;
        h = 1.0;
    }

    switch(zone)
    {
    case 0:
        d0 = w*s;
        norm.X = c;
        norm.Y = s;

        x0 = left;
        y0 = top;
        break;

    case 1:
        d0 = h*c;
        norm.X = - c;
        norm.Y = s;

        x0 = left + w;
        y0 = top;
        break;

    case 2:
        d0 = w*s;
        norm.X = - c;
        norm.Y = - s;

        x0 = left + w;
        y0 = top + h;
        break;

    case 3:
        d0 = h*c;
        norm.X = c;
        norm.Y = - s;

        x0 = left;
        y0 = top + h;
        break;
    }

    d2 = w*s + h*c;
    d1 = w*c + h*s;
    p0.X = TOREAL(x0 + d0*norm.Y);
    p0.Y = TOREAL(y0 - d0*norm.X);
    dP1.X = TOREAL(d1*norm.X);
    dP1.Y = TOREAL(d1*norm.Y);
    dP2.X = TOREAL(- d2*norm.Y);
    dP2.Y = TOREAL(d2*norm.X);

    if(isAngleScalable)
    {
        // Scale back.

        p0.X = rect.Width*p0.X + rect.X;
        p0.Y = rect.Height*p0.Y + rect.Y;

        dP1.X *= rect.Width;
        dP1.Y *= rect.Height;
        dP2.X *= rect.Width;
        dP2.Y *= rect.Height;
    }

    // Set up the transform.

    GpPointF points[3];

    points[0] = p0;
    points[1].X = p0.X + dP1.X;
    points[1].Y = p0.Y + dP1.Y;
    points[2].X = p0.X + dP2.X;
    points[2].Y = p0.Y + dP2.Y;

    GpStatus status;

    if(xform.InferAffineMatrix(&points[0], rect) == Ok)
    {
        return Ok;
    }
    return InvalidParameter;
}

GpStatus
GpLineGradient::ChangeLinePoints(
    const GpPointF&     point1,
    const GpPointF&     point2,
    BOOL                isAngleScalable
    )
{
    GpStatus    status;
    GpRectF     rect;
    
    if ((status = LinearGradientRectFromPoints(point1, point2, rect)) != Ok)
    {
        return status;
    }

    REAL        angle = GetAngleFromPoints(point1, point2);
    GpMatrix    xform;

    if ((status = CalcLinearGradientXform(angle, isAngleScalable, rect, xform)) == Ok)
    {
        DeviceBrush.Xform           = xform;
        DeviceBrush.Rect            = rect;
        DeviceBrush.IsAngleScalable = isAngleScalable;
        DeviceBrush.Points[0]       = point1;
        DeviceBrush.Points[1]       = point2;
        return Ok;
    }
    return status;
}

GpLineGradient::GpLineGradient(
    const GpPointF& point1,
    const GpPointF& point2,
    const GpColor& color1,
    const GpColor& color2,
    GpWrapMode wrapMode
    )
{
    // Make sure the flat API has correctly set the FPU.

    FPUStateSaver::AssertMode();

    REAL angle;
    GpRectF rect;

    if (LinearGradientRectFromPoints(point1, point2, rect) != Ok)
    {
        SetValid(FALSE);
        return;
    }

    // Compute the angle of the line formed by point1 and point2.
    // Note atan2 is only undefined if dP.Y == 0.0 and dP.X == 0.0
    // and then it returns 0 radians. We take care of that case separately
    // (above).
    // Also, atan2 correctly computes the quadrant from the two input points.

    GpPointF dP = point2 - point1;
    double rad = atan2((double)(dP.Y), (double)(dP.X));

    SetLineGradient(
        point1,
        point2,
        rect,
        color1,
        color2,

        // why aren't we working in radians???

        (REAL)(rad*180.0/3.1415926535897932),
        FALSE,
        wrapMode
    );
}


/**************************************************************************\
*
* Function Description:
*
*   Creates a LineGradient which is defined by the rectangle.
*
* Arguments:
*
*   [IN] rect       - the rectangle to define this gradient.
*   [IN] color1     - the color of the start point.
*   [IN] color2     - the color of the end point.
*   [IN] mode       - the line gradient mode
*   [IN] wrapMode   - the wrap mode of this brush.
*
* The start and end points of this gradient is defined as follows
* according to the line gradient mode:
*
*       mode                        start point     end point
*    -------------------------------------------------------------
*    LineGradientHorizontal         top-left        top-right
*    LineGradientVertical           top-right       bottom-right
*    LineGradientForwardDiagonal    top-left        bottom-right
*    LineGradientBackwardDiagonal   bottom-left     top-right
*
*
* History:
*
*   06/03/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpLineGradient::GpLineGradient(
    const GpRectF& rect,
    const GpColor& color1,
    const GpColor& color2,
    LinearGradientMode mode,
    GpWrapMode wrapMode
    )
{
    // Make sure the flat API has correctly set the FPU.

    FPUStateSaver::AssertMode();

    BOOL isAngleScalable = TRUE;
    REAL angle = 0;
    GpPointF    point1;
    GpPointF    point2;

    switch(mode)
    {
    case LinearGradientModeHorizontal:
        angle = 0;
        point1.X = rect.X;
        point1.Y = (rect.Y + rect.GetBottom()) / 2.0f;
        point2.X = rect.GetRight();
        point2.Y = point1.Y;
        break;

    case LinearGradientModeVertical:
        angle = 90;
        point1.X = (rect.X + rect.GetRight()) / 2.0f;
        point1.Y = rect.Y;
        point2.X = point1.X;
        point2.Y = rect.GetBottom();
        break;

    case LinearGradientModeForwardDiagonal:
        angle = 45;
        point1.X = rect.X;
        point1.Y = rect.Y;
        point2.X = rect.GetRight();
        point2.Y = rect.GetBottom();
        break;

    case LinearGradientModeBackwardDiagonal:
        angle = 135;
        point1.X = rect.GetRight();
        point1.Y = rect.Y;
        point2.X = rect.X;
        point2.Y = rect.GetBottom();
        break;

    default:
        // No such a case.
        ASSERT(0);

        SetValid(FALSE);
        return;
    }

    SetLineGradient(
        point1,
        point2,
        rect,
        color1,
        color2,
        angle,
        isAngleScalable,
        wrapMode);
}


/**************************************************************************\
*
* Function Description:
*
*   Creates a LineGradient which is defined by the rectangle.
*
* Arguments:
*
*   [IN] rect       - the rectangle to define this gradient.
*   [IN] color1     - the color of the start point.
*   [IN] color2     - the color of the end point.
*   [IN] angle      - the angle of the gradient
*   [IN] isAngleScalable - TRUE if 45 degree is corner to corner.
*                          The default value is FALSE.
*   [IN] wrapMode   - the wrap mode of this brush.
*
*
*
* History:
*
*   10/06/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpLineGradient::GpLineGradient(
    const GpRectF& rect,
    const GpColor& color1,
    const GpColor& color2,
    REAL angle,
    BOOL isAngleScalable,
    GpWrapMode wrapMode
    )
{
    // Make sure the flat API has correctly set the FPU.

    FPUStateSaver::AssertMode();
    GpPointF    point1;
    GpPointF    point2;
    
    // Not an Office scenario, but need to fix at some point
    // so we can print to PCL better.
    point1.X = point1.Y = point2.X = point2.Y = 0;

    SetLineGradient(
        point1,
        point2,
        rect,
        color1,
        color2,
        angle,
        isAngleScalable,
        wrapMode);
}

GpStatus
GpLineGradient::SetLineGradient(
    const GpPointF& point1,
    const GpPointF& point2,
    const GpRectF& rect,
    const GpColor& color1,
    const GpColor& color2,
    REAL angle,
    BOOL isAngleScalable,
    GpWrapMode wrapMode
    )
{
    // Make sure the flat API has correctly set the FPU.

    FPUStateSaver::AssertMode();

    DeviceBrush.Wrap = wrapMode;
    DeviceBrush.Colors[0] = color1;
    DeviceBrush.Colors[1] = color2;
    DeviceBrush.Colors[2] = color1;
    DeviceBrush.Colors[3] = color2;

    DeviceBrush.BlendCounts[0] = DeviceBrush.BlendCounts[1] = 1;
    DeviceBrush.BlendFactors[0] = DeviceBrush.BlendFactors[1] = NULL;
    DeviceBrush.Falloffs[0] = DeviceBrush.Falloffs[1] = 1;

    GpStatus status;
    
    if (CalcLinearGradientXform(angle, isAngleScalable, rect, DeviceBrush.Xform) == Ok)
    {
        SetValid(TRUE);
        DeviceBrush.Rect = rect;
        DeviceBrush.IsAngleScalable = isAngleScalable;
        DeviceBrush.Points[0] = point1;
        DeviceBrush.Points[1] = point2;
        status = Ok;
    }
    else
    {
        SetValid(FALSE);
        GpMemset(&DeviceBrush.Rect, 0, sizeof(DeviceBrush.Rect));
        GpMemset(DeviceBrush.Points, 0, sizeof(DeviceBrush.Points[0]) * 2);
        DeviceBrush.IsAngleScalable = FALSE;
        status = InvalidParameter;
    }

    return status;
}



GpStatus
GpLineGradient::SetLinePoints(
    const GpPointF& point1,
    const GpPointF& point2
    )
{
    // Make sure the flat API has correctly set the FPU.

    FPUStateSaver::AssertMode();

    GpPointF p0, dP1, dP2;

    p0 = point1;
    dP1.X = point2.X - point1.X;
    dP1.Y = point2.Y - point1.Y;
    dP2.X = - dP1.Y;
    dP2.Y = dP1.X;

    REAL m[6];
    REAL width, height;

    if(getLineGradientTransform(&m[0], &width, &height, p0, dP1, dP2))
    {
        SetValid(TRUE);

        DeviceBrush.Rect.X = p0.X;
        DeviceBrush.Rect.Y = p0.Y;
        DeviceBrush.Rect.Width = width;
        DeviceBrush.Rect.Height = height;
    }
    else
    {
        // Don't change the current state.

        return GenericError;
    }

    DeviceBrush.Xform.SetMatrix(m);
    UpdateUid();
    return Ok;
}


GpStatus
GpLineGradient::GetLinePoints(GpPointF* points)
{
    // Make sure the flat API has correctly set the FPU.

    FPUStateSaver::AssertMode();

    ASSERT(points);
    points[0].X = DeviceBrush.Rect.X;
    points[0].Y = DeviceBrush.Rect.Y;
    points[1].X = DeviceBrush.Rect.X + DeviceBrush.Rect.Width;
    points[1].Y = DeviceBrush.Rect.Y + DeviceBrush.Rect.Height;
    DeviceBrush.Xform.Transform(points, 2);

    return Ok;
}


INT
GpLineGradient::GetPresetBlendCount()
{
    if(DeviceBrush.UsesPresetColors)
        return DeviceBrush.BlendCounts[0];
    else
        return 0;
}

/*
** This returns the premultiplied colors
*/

GpStatus
GpLineGradient::GetPresetBlend(
    GpColor* blendColors,
    REAL* blendPositions,
    INT count)
{
    // Make sure the flat API has correctly set the FPU.

    FPUStateSaver::AssertMode();

    if(!blendColors || !blendPositions || count <= 1)
        return InvalidParameter;

    if(DeviceBrush.UsesPresetColors &&
       DeviceBrush.PresetColors &&
       DeviceBrush.BlendPositions[0])
    {
        for(INT i = 0; i < count; i++)
        {
            blendColors[i].SetColor(DeviceBrush.PresetColors[i]);
        }
        GpMemcpy(blendPositions,
                 DeviceBrush.BlendPositions[0],
                 count*sizeof(REAL));

        return Ok;
    }
    else
        return GenericError;
}

GpStatus
GpLineGradient::SetPresetBlend(
            const GpColor* blendColors,
            const REAL* blendPositions,
            INT count)
{
    // Make sure the flat API has correctly set the FPU.

    FPUStateSaver::AssertMode();

    if(!blendColors || !blendPositions || count <= 1)
        return InvalidParameter;

    ARGB* newColors = (ARGB*) GpRealloc(DeviceBrush.PresetColors,
                                        count*sizeof(ARGB));

    if (newColors != NULL)
    {
        DeviceBrush.PresetColors = newColors;
    }
    else
    {
        return OutOfMemory;
    }

    REAL* newPositions = (REAL*) GpRealloc(DeviceBrush.BlendPositions[0],
                                           count*sizeof(REAL));

    if (newPositions != NULL)
    {
        DeviceBrush.BlendPositions[0] = newPositions;
    }
    else
    {
        return OutOfMemory;
    }

    GpFree(DeviceBrush.BlendFactors[0]);

    // DeviceBrush.BlendFactors[1] is always NULL for LineGradient.
    DeviceBrush.BlendFactors[0] = NULL;

    DeviceBrush.UsesPresetColors = TRUE;

    for(INT i = 0; i < count; i++)
    {
        newColors[i] = blendColors[i].GetValue();
    }
    GpMemcpy(newPositions, blendPositions, count*sizeof(REAL));
    DeviceBrush.BlendCounts[0] = count;
    UpdateUid();
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Blend any transparent colors in this brush with white.  Note that
*   colors are premultiplied, since they will become fully opaque.
*
* Arguments:
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
\**************************************************************************/

GpStatus GpLineGradient::BlendWithWhite()
{
    if (DeviceBrush.UsesPresetColors)
    {
        GpColor color;
        
        for (INT i=0; i<DeviceBrush.BlendCounts[0]; i++)
        {
            color.SetValue(GpColor::ConvertToPremultiplied(DeviceBrush.PresetColors[i]));
            color.BlendOpaqueWithWhite();
            DeviceBrush.PresetColors[i] = color.GetValue();
        }
        return Ok;
    }
    else
    {
        return GpRectGradient::BlendWithWhite();
    }
}

BOOL
GpPathGradient::IsRectangle() const
{
    BOOL result = FALSE;

    if (DeviceBrush.PointsPtr != NULL)
        result = IsRectanglePoints(DeviceBrush.PointsPtr, DeviceBrush.Count, NULL, NULL);
    else
    {
        GpPath* path = static_cast<GpPath*> (DeviceBrush.Path);
        if(path)
            result = path->IsRectangle(NULL);
    }

    return result;
}

INT
GpPathGradient::GetPresetBlendCount() const
{
    if(DeviceBrush.UsesPresetColors)
        return DeviceBrush.BlendCounts[0];
    else
        return 0;
}

/*
** This returns the premultiplied colors
*/

GpStatus
GpPathGradient::GetPresetBlend(
    GpColor* blendColors,
    REAL* blendPositions,
    INT count) const
{
    if(!blendColors || !blendPositions || count <= 1)
        return InvalidParameter;

    if(DeviceBrush.UsesPresetColors && DeviceBrush.PresetColors && DeviceBrush.BlendPositions[0])
    {
        // Users will obtain the preset colors as radial blend colors.
        // 0 position means the center location and 1 position means the
        // the outer edge.  In order to convert those colors and position arrays
        // from the weight factor arrays in PathGradient,
        // we must invert the order of the returned arrays.

        for(INT i = 0; i < count; i++)
        {
            blendColors[count - 1 -i].SetColor(DeviceBrush.PresetColors[i]);
            blendPositions[count - 1 -i] = TOREAL(1.0 - DeviceBrush.BlendPositions[0][i]);
        }

        return Ok;
    }
    else
        return GenericError;
}

GpStatus
GpPathGradient::SetPresetBlend(
            const GpColor* blendColors,
            const REAL* blendPositions,
            INT count)
{
    if(!blendColors || !blendPositions || count <= 1)
        return InvalidParameter;

    ARGB* newColors = (ARGB*) GpRealloc(DeviceBrush.PresetColors, count*sizeof(ARGB));

    if (newColors != NULL)
    {
        DeviceBrush.PresetColors = newColors;
    }
    else
    {
        return OutOfMemory;
    }

    REAL* newPositions = (REAL*) GpRealloc(DeviceBrush.BlendPositions[0], count*sizeof(REAL));

    if (newPositions != NULL)
    {
        DeviceBrush.BlendPositions[0] = newPositions;
    }
    else
    {
        return OutOfMemory;
    }

    GpFree(DeviceBrush.BlendFactors[0]);
    DeviceBrush.BlendFactors[0] = NULL;

    DeviceBrush.UsesPresetColors = TRUE;

    // Users will supply the preset colors as radial blend colors.
    // 0 position means the center location and 1 position means the
    // the outer edge.  In order to convert those colors and position arrays
    // to the weight factor arrays in PathGradient,
    // we must invert the order of the given arrays.

    for(INT i = 0; i < count; i++)
    {
        // PresetColors are stored non-premultiplied.
        newColors[count - 1 - i] = blendColors[i].GetValue();
        newPositions[count - 1 - i] = TOREAL(1.0 - blendPositions[i]);
    }

    DeviceBrush.BlendCounts[0] = count;
    UpdateUid();
    return Ok;
}

//==================================================================
// Copy constructors
//==================================================================

GpElementaryBrush::GpElementaryBrush(const GpElementaryBrush *brush)
{
    if(brush && brush->IsValid())
    {
        // !!! [asecchia] we should really be asking the DeviceBrush to
        // copy it's members instead of duplicating the code all over
        // the place. Current code is error prone - each subclass is has to 
        // know all about how to copy and what has or hasn't been updated on
        // the chain down to it's ancestor.
        
        DeviceBrush.Xform = brush->DeviceBrush.Xform;
        DeviceBrush.Wrap = brush->DeviceBrush.Wrap;
        DeviceBrush.IsGammaCorrected = brush->DeviceBrush.IsGammaCorrected;
        
        SetValid(brush->IsValid());
    }
    else
        SetValid(FALSE);
}

GpTexture::GpTexture(
    const GpTexture *brush
    ) : GpElementaryBrush(brush)
{
    if(brush && brush->IsValid())
    {
        const DpBrush* devBrush = &(brush->DeviceBrush);

        InitializeBrush(brush->Image, devBrush->Wrap, NULL);
        SetTransform(devBrush->Xform);
    }
    else
        SetValid(FALSE);
}

GpRectGradient::GpRectGradient(
    const GpRectGradient *brush
    )  : GpGradientBrush(brush)
{
    if(brush && brush->IsValid())
    {
        const DpBrush* devBrush = &(brush->DeviceBrush);

        InitializeBrush(
            devBrush->Rect,
            &(devBrush->Colors[0]),
            devBrush->Wrap
            );

        SetTransform(devBrush->Xform);

        SetHorizontalBlend(
            devBrush->BlendFactors[0],
            devBrush->BlendPositions[0],
            devBrush->BlendCounts[0]
            );

        SetVerticalBlend(
            devBrush->BlendFactors[1],
            devBrush->BlendPositions[1],
            devBrush->BlendCounts[1]
            );

    }
    else
        SetValid(FALSE);
}

GpLineGradient::GpLineGradient(
    const GpLineGradient *brush
    ) : GpRectGradient(brush)
{
    if(brush && brush->IsValid())
    {
        // Copy the preset colors.
        // !!! [asecchia] why isn't this handled in a uniform way?
        const DpBrush* devBrush = &(brush->DeviceBrush);

        DeviceBrush.Points[0]       = devBrush->Points[0];
        DeviceBrush.Points[1]       = devBrush->Points[1];
        DeviceBrush.IsAngleScalable = devBrush->IsAngleScalable;

        if(devBrush->UsesPresetColors)
        {
            SetPresetBlend(
                (GpColor*)(devBrush->PresetColors),
                (REAL*)(devBrush->BlendPositions[0]),
                devBrush->BlendCounts[0]
            );
        }
    }
}

GpPathGradient::GpPathGradient(
    const GpPathGradient *brush
    ) : GpGradientBrush(brush)
{
    if(brush && brush->IsValid())
    {
        const DpBrush* devBrush = &(brush->DeviceBrush);

        // If a path exists for the brush, use that for initialization.
        // Otherwise, use the points collection.
        if (devBrush->Path != NULL)
        {
            DefaultBrush();
            DeviceBrush.Wrap = devBrush->Wrap;
            DeviceBrush.Path = devBrush->Path->ClonePath();
            PrepareBrush();
        }
        else
        {
            InitializeBrush(devBrush->PointsPtr, 
                            devBrush->Count, 
                            devBrush->Wrap);
        }

        if(IsValid())
        {
            SetTransform(devBrush->Xform);

            SetCenterPoint(devBrush->Points[0]);
            SetCenterColor(devBrush->Colors[0]);
            SetSurroundColors(devBrush->ColorsPtr);
            DeviceBrush.Falloffs[0] = devBrush->Falloffs[0];
            DeviceBrush.FocusScaleX = devBrush->FocusScaleX;
            DeviceBrush.FocusScaleY = devBrush->FocusScaleY;
            DeviceBrush.UsesPresetColors = devBrush->UsesPresetColors;
            
            INT blendCount = devBrush->BlendCounts[0];
            DeviceBrush.BlendCounts[0] = blendCount;

            // If we're cloning a brush with preset colors, copy preset colors 
            // and blend positions.  Otherwise, copy the blend factors and
            // blend positions.
            if (devBrush->UsesPresetColors)
            {
                ARGB* newColors = (ARGB*) GpRealloc(DeviceBrush.PresetColors, blendCount*sizeof(ARGB));
                if (newColors != NULL)
                {
                    DeviceBrush.PresetColors = newColors;

                    REAL* newPositions = (REAL*) GpRealloc(DeviceBrush.BlendPositions[0], blendCount*sizeof(REAL));

                    if (newPositions != NULL)
                    {
                        DeviceBrush.BlendPositions[0] = newPositions;
                        GpFree(DeviceBrush.BlendFactors[0]);
                        DeviceBrush.BlendFactors[0] = NULL;
                
                        memcpy(DeviceBrush.PresetColors,
                               devBrush->PresetColors,
                               blendCount*sizeof(ARGB));
                        memcpy(DeviceBrush.BlendPositions[0],
                               devBrush->BlendPositions[0],
                               blendCount*sizeof(REAL));
                    }
                    else
                    {
                        SetValid(FALSE);
                    }
                }
                else
                {
                    SetValid(FALSE);
                }
            }
            else if (devBrush->BlendFactors[0] && devBrush->BlendPositions[0])
            {
                REAL* newFactors = (REAL*) GpRealloc(DeviceBrush.BlendFactors[0], blendCount*sizeof(REAL));
                if (newFactors != NULL)
                {
                    DeviceBrush.BlendFactors[0] = newFactors;

                    REAL* newPositions = (REAL*) GpRealloc(DeviceBrush.BlendPositions[0], blendCount*sizeof(REAL));

                    if (newPositions != NULL)
                    {
                        DeviceBrush.BlendPositions[0] = newPositions;
                
                        memcpy(DeviceBrush.BlendFactors[0],
                               devBrush->BlendFactors[0],
                               blendCount*sizeof(REAL));
                        memcpy(DeviceBrush.BlendPositions[0],
                               devBrush->BlendPositions[0],
                               blendCount*sizeof(REAL));
                    }
                    else
                    {
                        SetValid(FALSE);
                    }
                }
                else
                {
                    SetValid(FALSE);
                }
            }
        }
    }
    else
        SetValid(FALSE);
}

GpHatch::GpHatch(const GpHatch* brush)
{
    if(brush && brush->IsValid())
    {
        const DpBrush* devBrush = &(brush->DeviceBrush);

        InitializeBrush(devBrush->Style,
                    devBrush->Colors[0],
                    devBrush->Colors[1]);
    }
    else
        SetValid(FALSE);
}

/**************************************************************************\
*
* Function Description:
*
*   Getting horizontal falloff / blend-factors for
*   a rectangular gradient brush object
*
* Arguments:
*
*   [OUT] blendFactors - Buffer for returning the horizontal
*               falloff or blend-factors.
*   count - Size of the buffer (in number of REAL elements)
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
GpRectGradient::GetHorizontalBlend(
    REAL* blendFactors,
    REAL* blendPositions,
    INT count
    )
{
    if(!blendFactors || !blendPositions || count < 1)
        return InvalidParameter;

    // Check if the input buffer is big enough

    if (count < DeviceBrush.BlendCounts[0])
        return InsufficientBuffer;

    if (DeviceBrush.BlendCounts[0] == 1)
    {
        // Return falloff parameter

        blendFactors[0] = DeviceBrush.Falloffs[0];
    }
    else
    {
        // Return blend factors

        GpMemcpy(
            blendFactors,
            DeviceBrush.BlendFactors[0],
            DeviceBrush.BlendCounts[0]*sizeof(REAL)
            );
        GpMemcpy(
            blendPositions,
            DeviceBrush.BlendPositions[0],
            DeviceBrush.BlendCounts[0]*sizeof(REAL)
            );
    }

    return Ok;
}


/**************************************************************************\
*
* Function Description:
*
*   Setting horizontal falloff / blend-factors for
*   a rectangular gradient brush object
*
* Arguments:
*
*   [IN] blendFactors - Specify the new blend factors
*   count - Number of elements in the blend factor array
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
GpRectGradient::SetHorizontalBlend(
    const REAL* blendFactors,
    const REAL* blendPositions,
    INT count
    )
{
    if(!blendFactors || !blendPositions || count < 1)
        return InvalidParameter;

    if (count == 1)
    {
        // Setting falloff parameter

        GpFree(DeviceBrush.BlendFactors[0]);
        DeviceBrush.BlendFactors[0] = NULL;
        GpFree(DeviceBrush.BlendPositions[0]);
        DeviceBrush.BlendPositions[0] = NULL;

        if (blendFactors == NULL)
            DeviceBrush.Falloffs[0] = 1;
        else
            DeviceBrush.Falloffs[0] = blendFactors[0];

        DeviceBrush.BlendCounts[0] = 1;
    }
    else
    {
        ASSERT(blendFactors != NULL && blendPositions != NULL);
        
        // blend positions must start at 0.0 and end at 1.0
        
        if (REALABS(blendPositions[0]) > REAL_EPSILON ||
            REALABS(1.0f - blendPositions[count-1]) > REAL_EPSILON)
        {
            return InvalidParameter;
        }

        // Setting blend factors

        REAL* newFactors;
        REAL* newPositions;

        newFactors = (REAL*) GpRealloc(DeviceBrush.BlendFactors[0], count*sizeof(REAL));

        if (newFactors != NULL)
        {
            DeviceBrush.BlendFactors[0] = newFactors;
        }
        else
        {
            return OutOfMemory;
        }

        newPositions = (REAL*) GpRealloc(DeviceBrush.BlendPositions[0], count*sizeof(REAL));

        if (newPositions != NULL)
        {
            DeviceBrush.BlendPositions[0] = newPositions;
        }
        else
        {
            return OutOfMemory;
        }

        if (newFactors == NULL || newPositions == NULL)
            return OutOfMemory;

        GpMemcpy(newFactors, blendFactors, count*sizeof(REAL));
        GpMemcpy(newPositions, blendPositions, count*sizeof(REAL));
        DeviceBrush.BlendCounts[0] = count;
    }

    DeviceBrush.UsesPresetColors = FALSE;
    GpFree(DeviceBrush.PresetColors);
    DeviceBrush.PresetColors = NULL;
    UpdateUid();
    return Ok;
}


/**************************************************************************\
*
* Function Description:
*
*   Getting vertical falloff / blend-factors for
*   a rectangular gradient brush object
*
* Arguments:
*
*   [OUT] blendFactors - Buffer for returning the vertical
*               falloff or blend-factors.
*   count - Size of the buffer (in number of REAL elements)
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
GpRectGradient::GetVerticalBlend(
    REAL* blendFactors,
    REAL* blendPositions,
    INT count
    )
{
    if(!blendFactors || !blendPositions || count < 1)
        return InvalidParameter;

    // Check if the input buffer is big enough

    if (count < DeviceBrush.BlendCounts[1])
        return InsufficientBuffer;

    if (DeviceBrush.BlendCounts[1] == 1)
    {
        // Return falloff parameter

        blendFactors[0] = DeviceBrush.Falloffs[1];
    }
    else
    {
        // Return blend factors

        GpMemcpy(
            blendFactors,
            DeviceBrush.BlendFactors[1],
            DeviceBrush.BlendCounts[1]*sizeof(REAL));
        GpMemcpy(
            blendPositions,
            DeviceBrush.BlendPositions[1],
            DeviceBrush.BlendCounts[1]*sizeof(REAL));
    }

    return Ok;
}


/**************************************************************************\
*
* Function Description:
*
*   Setting vertical falloff / blend-factors for
*   a rectangular gradient brush object
*
* Arguments:
*
*   [IN] blendFactors - Specify the new blend factors
*   count - Number of elements in the blend factor array
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
GpRectGradient::SetVerticalBlend(
    const REAL* blendFactors,
    const REAL* blendPositions,
    INT count
    )
{
    if(!blendFactors || !blendPositions || count < 1)
        return InvalidParameter;

    if (count == 1)
    {
        // Setting falloff parameter

        GpFree(DeviceBrush.BlendFactors[1]);
        DeviceBrush.BlendFactors[1] = NULL;
        GpFree(DeviceBrush.BlendPositions[1]);
        DeviceBrush.BlendPositions[1] = NULL;

        if (blendFactors == NULL)
            DeviceBrush.Falloffs[1] = 1;
        else
            DeviceBrush.Falloffs[1] = blendFactors[0];

        DeviceBrush.BlendCounts[1] = 1;
    }
    else
    {
        ASSERT(blendFactors != NULL && blendPositions != NULL);

        // Setting blend factors

        REAL* newFactors;
        REAL* newPositions;

        newFactors = (REAL*) GpRealloc(DeviceBrush.BlendFactors[1], count*sizeof(REAL));

        if (newFactors != NULL)
        {
            DeviceBrush.BlendFactors[1] = newFactors;
        }
        else
        {
            return OutOfMemory;
        }

        newPositions = (REAL*) GpRealloc(DeviceBrush.BlendPositions[1], count*sizeof(REAL));

        if (newPositions != NULL)
        {
            DeviceBrush.BlendPositions[1] = newPositions;
        }
        else
        {
            return OutOfMemory;
        }

        GpMemcpy(newFactors, blendFactors, count*sizeof(REAL));
        GpMemcpy(newPositions, blendPositions, count*sizeof(REAL));
        DeviceBrush.BlendCounts[1] = count;
    }

    DeviceBrush.UsesPresetColors = FALSE;
    GpFree(DeviceBrush.PresetColors);
    DeviceBrush.PresetColors = NULL;
    UpdateUid();

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Blend any transparent colors in this brush with white.  Note that colors
*   are converted to premultiplied first, since they will become fully opaque.
*
* Arguments:
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
\**************************************************************************/

GpStatus GpRectGradient::BlendWithWhite()
{
    GpColor color;
    
    for (INT i=0; i<4; i++)
    {
        color.SetValue(DeviceBrush.Colors[i].GetPremultipliedValue());
        color.BlendOpaqueWithWhite();
        DeviceBrush.Colors[i] = color.GetValue();
    }

    return Ok;
}

//--------------------------------------------------------------------------
// Path Gradient
//--------------------------------------------------------------------------

VOID
GpPathGradient::PrepareBrush()
{
    GpPath* path = static_cast<GpPath*> (DeviceBrush.Path);

    if (path)
    {
        DeviceBrush.Count = path->Points.GetCount();
        GpPointF* points = path->Points.GetDataBuffer();

        if(!DeviceBrush.ColorsPtr)
        {
           DeviceBrush.ColorsPtr = (GpColor*)GpMalloc(DeviceBrush.Count*sizeof(GpColor));

           if (DeviceBrush.ColorsPtr != NULL)
              GpMemset(&DeviceBrush.ColorsPtr[0], 255, DeviceBrush.Count*sizeof(GpColor));
        }

        REAL xmin, xmax, ymin, ymax, x0, y0; 

        x0 = xmin = xmax = points[0].X;
        y0 = ymin = ymax = points[0].Y;

        for(INT i = 1; i < DeviceBrush.Count; i++)
        {
            x0 += points[i].X;
            y0 += points[i].Y;
            xmin = min(xmin, points[i].X);
            xmax = max(xmax, points[i].X);
            ymin = min(ymin, points[i].Y);
            ymax = max(ymax, points[i].Y);
        }

        DeviceBrush.Rect.X = xmin;
        DeviceBrush.Rect.Width = xmax - xmin;
        DeviceBrush.Rect.Y = ymin;
        DeviceBrush.Rect.Height = ymax - ymin;

        if(!WrapModeIsValid(DeviceBrush.Wrap) || DeviceBrush.Rect.Width <= 0 || DeviceBrush.Rect.Height <= 0)
            return;

        DeviceBrush.Points[0].X = x0/DeviceBrush.Count;
        DeviceBrush.Points[0].Y = y0/DeviceBrush.Count;

        SetValid(TRUE);
    }
}

GpStatus
GpPathGradient::Flatten(GpMatrix* matrix) const
{
    GpPath* path = static_cast<GpPath*> (DeviceBrush.Path);

    if(!path)
        return Ok;

    if(path->HasCurve())
    {
        INT origCount = DeviceBrush.Count;

        GpStatus status = path->Flatten(
                            const_cast<DynByteArray*>(&FlattenTypes),
                            const_cast<DynPointFArray*> (&FlattenPoints),
                            matrix);

        if(status == Ok)
        {
            DeviceBrush.Count = FlattenPoints.GetCount();
            DeviceBrush.PointsPtr = FlattenPoints.GetDataBuffer();
            
            if ((DeviceBrush.Count > origCount) &&
                (DeviceBrush.ColorsPtr != NULL)) 
            {
                // The colors array is no longer the proper size.  Adjust the
                // size and copy up the last color.  It is the apps responsibility
                // to estimate and specify the correct number of flattened points.
                
                const_cast<GpColor*>(DeviceBrush.ColorsPtr) = (GpColor*) GpRealloc((VOID*)DeviceBrush.ColorsPtr, 
                                                             sizeof(GpColor)*DeviceBrush.Count);

                if (DeviceBrush.ColorsPtr != NULL)
                {
                     GpColor copyColor = (origCount > 1) ? 
                                        DeviceBrush.ColorsPtr[origCount-1] :
                                        GpColor(0xFFFFFFFF);

                     for (INT i=origCount; i<DeviceBrush.Count; i++) 
                     {
                          DeviceBrush.ColorsPtr[i] = copyColor;
                     }
                }
                else
                {
                    return OutOfMemory;
                }
            }
        }
    }
    else
    {
            DeviceBrush.Count = path->GetPointCount();
            DeviceBrush.PointsPtr = const_cast<GpPointF*> (path->GetPathPoints());
    }

    return Ok;
}


GpStatus
GpPathGradient::GetBlend(
    REAL* blendFactors,
    REAL* blendPositions,
    INT count
    ) const
{
    if(!blendFactors || !blendPositions || count < 1)
        return InvalidParameter;

    // Check if the input buffer is big enough

    if (count < DeviceBrush.BlendCounts[0])
        return InsufficientBuffer;

    if (DeviceBrush.BlendCounts[0] == 1)
    {
        // Return falloff parameter

        blendFactors[0] = DeviceBrush.Falloffs[0];
    }
    else
    {
        // Return blend factors

        // Users want to obtain the blend factor as radial blend factors.
        // 0 blend factor means 100 % center color and 0 position means
        // the center location.  In order to return those factor and
        // position arrays, we must invert the weight and position factor
        // arrays stored in this PathGradient class.

        for(INT i = 0; i < DeviceBrush.BlendCounts[0]; i++)
        {
            blendFactors[DeviceBrush.BlendCounts[0] - 1 - i] = TOREAL(1.0 - DeviceBrush.BlendFactors[0][i]);
            blendPositions[DeviceBrush.BlendCounts[0] - 1 - i] = TOREAL(1.0 - DeviceBrush.BlendPositions[0][i]);
        }
    }

    return Ok;
}

GpStatus
GpPathGradient::SetBlend(
    const REAL* blendFactors,
    const REAL* blendPositions,
    INT count
    )
{
    if(!blendFactors || !blendPositions || count < 1)
        return InvalidParameter;

    if (count == 1)
    {
        // Setting falloff parameter

        GpFree(DeviceBrush.BlendFactors[0]);
        DeviceBrush.BlendFactors[0] = NULL;
        GpFree(DeviceBrush.BlendPositions[0]);
        DeviceBrush.BlendPositions[0] = NULL;

        if (blendFactors == NULL)
            DeviceBrush.Falloffs[0] = 1;
        else
            DeviceBrush.Falloffs[0] = blendFactors[0];

        DeviceBrush.BlendCounts[0] = 1;
    }
    else
    {
        // blend positions must start at 0.0 and end at 1.0
        
        if (REALABS(blendPositions[0]) > REAL_EPSILON ||
            REALABS(1.0f - blendPositions[count-1]) > REAL_EPSILON)
        {
            return InvalidParameter;
        }

        // Setting blend factors

        REAL* newFactors;
        REAL* newPositions;

        newFactors = (REAL*) GpRealloc(DeviceBrush.BlendFactors[0], count*sizeof(REAL));

        if (newFactors != NULL)
        {
            DeviceBrush.BlendFactors[0] = newFactors;
        }
        else
        {
            return OutOfMemory;
        }

        newPositions = (REAL*) GpRealloc(DeviceBrush.BlendPositions[0], count*sizeof(REAL));

        if (newPositions != NULL)
        {
            DeviceBrush.BlendPositions[0] = newPositions;
        }
        else
        {
            return OutOfMemory;
        }

        // Users will supply the blend factor as radial blend factors.
        // 0 blend factor means 100 % center color and 0 position means
        // the center location.  In order to convert those factor and position arrays
        // to the weight and position factor arrays in PathGradient,
        // we must invert the given arrays.

        for(INT i = 0; i < count; i++)
        {
            newFactors[count - 1 - i] = TOREAL(1.0 - blendFactors[i]);
            newPositions[count - 1 - i] = TOREAL(1.0 - blendPositions[i]);
        }
        DeviceBrush.BlendCounts[0] = count;
    }

    DeviceBrush.UsesPresetColors = FALSE;
    GpFree(DeviceBrush.PresetColors);
    DeviceBrush.PresetColors = NULL;
    UpdateUid();

    return Ok;
}

GpStatus
GpGradientBrush::GetSigmaBlendArray(
    REAL focus,
    REAL scale,
    INT* count,
    REAL* blendFactors,
    REAL* blendPositions)
{
    // Make sure the FPU is set correctly.

    FPUStateSaver::AssertMode();

    if(!blendFactors || !blendPositions || !count)
        return InvalidParameter;

    // This gives 1/4 of the Sigma array.

    static REAL factors[] =
    {
            0,    59,   120,   182,   247,   314,   383,   454,
          527,   602,   680,   759,   841,   926,  1013,  1102,
         1194,  1288,  1385,  1485,  1587,  1692,  1800,  1911,
         2024,  2141,  2260,  2383,  2508,  2637,  2769,  2904,
         3042,  3183,  3328,  3477,  3628,  3783,  3942,  4104,
         4270,  4439,  4612,  4789,  4969,  5153,  5341,  5533,
         5728,  5928,  6131,  6338,  6549,  6764,  6983,  7206,
         7434,  7665,  7900,  8139,  8382,  8630,  8881,  9136,
         9396,  9660,  9927, 10199, 10475, 10755, 11039, 11327,
        11619, 11916, 12216, 12520, 12828, 13140, 13456, 13776,
        14099, 14427, 14758, 15093, 15431, 15774, 16119, 16469,
        16822, 17178, 17538, 17901, 18267, 18637, 19009, 19385,
        19764, 20146, 20530, 20918, 21308, 21701, 22096, 22494,
        22894, 23297, 23702, 24109, 24518, 24929, 25342, 25756,
        26173, 26591, 27010, 27431, 27853, 28276, 28701, 29126,
        29552, 29979, 30407, 30836, 31264, 31694, 32123, 32553
    };

    if(focus < 0 || focus > 1 || scale < 0 || scale > 1)
        return InvalidParameter;

    if(blendFactors && blendPositions)
    {
        INT i, n;
        scale /= 65536;
        REAL one = 65536;

        if(focus > 0 && focus < 1)
        {
            for(i = 0; i < 128; i++)
            {
                blendFactors[i] = factors[i];
                blendPositions[i] = focus*i/255;
            }
            for(i = 128; i < 256; i++)
            {
                blendFactors[i] = one - factors[255 - i];
                blendPositions[i] = focus*i/255;
            }

            // skip i = 256 since this gives the same data.

            for(i = 257; i < 384; i++)
            {
                blendFactors[i - 1] = one - factors[i - 256];
                blendPositions[i - 1] = TOREAL(focus + (1.0 - focus)*(i - 256)/255);
            }
            for(i = 384; i < 512; i++)
            {
                blendFactors[i - 1] = factors[511 - i];
                blendPositions[i - 1] = TOREAL(focus + (1.0 - focus)*(i - 256)/255);
            }

            // Set n to 511 because we skipped index 256 above to avoid
            // the duplicate 1 entry in the ramp from 0 to 1 to 0.

            n = 511;
        }
        else if(focus == 1)
        {
            for(i = 0; i < 128; i++)
            {
                blendFactors[i] = factors[i];
                blendPositions[i] = TOREAL(i)/255;
            }
            for(i = 128; i < 256; i++)
            {
                blendFactors[i] = one - factors[255 - i];
                blendPositions[i] = TOREAL(i)/255;
            }

            n = 256;
        }
        else    // focus == 0
        {
            for(i = 256; i < 384; i++)
            {
                blendFactors[i - 256] = one - factors[i - 256];
                blendPositions[i - 256] = TOREAL(i - 256)/255;
            }
            for(i = 384; i < 512; i++)
            {
                blendFactors[i - 256] = factors[511 - i];
                blendPositions[i - 256] = TOREAL(i - 256)/255;
            }

            n = 256;
        }

        for(i = 0; i < n; i++)
            blendFactors[i] *= scale;

        *count = n;
        return Ok;
    }
    else
        return InvalidParameter;
}

GpStatus
GpGradientBrush::GetLinearBlendArray(
    REAL focus,
    REAL scale,
    INT* count,
    REAL* blendFactors,
    REAL* blendPositions)
{
    if(!blendFactors || !blendPositions || !count)
        return InvalidParameter;

    if(focus < 0 || focus > 1 || scale < 0 || scale > 1)
        return InvalidParameter;

    if(blendFactors && blendPositions)
    {
        if(focus > 0 && focus < 1)
        {
            blendFactors[0] = 0.0f;
            blendFactors[1] = scale;
            blendFactors[2] = 0.0f;

            blendPositions[0] = 0.0f;
            blendPositions[1] = focus;
            blendPositions[2] = 1.0f;

            *count = 3;
        }
        else if(focus == 1)
        {
            blendFactors[0] = 0.0f;
            blendFactors[1] = scale;

            blendPositions[0] = 0.0f;
            blendPositions[1] = 1.0f;

            *count = 2;
        }
        else    // focus == 0
        {
            blendFactors[0] = scale;
            blendFactors[1] = 0.0f;

            blendPositions[0] = 0.0f;
            blendPositions[1] = 1.0f;

            *count = 2;
        }

        return Ok;
    }
    else
        return InvalidParameter;
}

GpStatus
GpGradientBrush::SetSigmaBlend(
            REAL focus,
            REAL scale)
{
    REAL*   blendFactors = (REAL*) GpMalloc(512*sizeof(REAL));
    REAL*   blendPositions = (REAL*) GpMalloc(512*sizeof(REAL));
    INT     count;
    GpStatus status;

    if(blendFactors && blendPositions)
    {
        status = GetSigmaBlendArray(focus, scale,
                    &count, blendFactors, blendPositions);

        if(status == Ok)
            status = SetBlend(&blendFactors[0], &blendPositions[0], count);
    }
    else
        status = OutOfMemory;

    GpFree(blendFactors);
    GpFree(blendPositions);

    return status;
}

GpStatus
GpGradientBrush::SetLinearBlend(
            REAL focus,
            REAL scale)
{
    REAL    blendFactors[3];
    REAL    blendPositions[3];
    INT     count;

    GpStatus status = GetLinearBlendArray(focus, scale,
                        &count, &blendFactors[0], &blendPositions[0]);

    if(status != Ok)
        return status;

    return SetBlend(&blendFactors[0], &blendPositions[0], count);
}

//--------------------------------------------------------------------------
// Hatch Brush
//--------------------------------------------------------------------------

const BYTE GdipHatchPatterns8bpp[HatchStyleTotal][64] = {
    {    //    HatchStyleHorizontal,                   0
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleVertical,                     1
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleForwardDiagonal,              2
        0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
        0x80, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x80, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x80, 0xff, 0x80, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x80, 0xff, 0x80, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0x80, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0x80,
        0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff,
    },
    {    //    HatchStyleBackwardDiagonal,             3
        0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0x80,
        0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0x80, 0x00,
        0x00, 0x00, 0x00, 0x80, 0xff, 0x80, 0x00, 0x00,
        0x00, 0x00, 0x80, 0xff, 0x80, 0x00, 0x00, 0x00,
        0x00, 0x80, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00,
        0x80, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
    },
    {    //    HatchStyleCross,                        4
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleDiagonalCross                 5
        0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff,
        0x80, 0xff, 0x80, 0x00, 0x00, 0x80, 0xff, 0x80,
        0x00, 0x80, 0xff, 0x80, 0x80, 0xff, 0x80, 0x00,
        0x00, 0x00, 0x80, 0xff, 0xff, 0x80, 0x00, 0x00,
        0x00, 0x00, 0x80, 0xff, 0xff, 0x80, 0x00, 0x00,
        0x00, 0x80, 0xff, 0x80, 0x80, 0xff, 0x80, 0x00,
        0x80, 0xff, 0x80, 0x00, 0x00, 0x80, 0xff, 0x80,
        0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff,
    },
    {    //    HatchStyle05Percent,                    6
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyle10Percent,                    7
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyle20Percent,                    8
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyle25Percent,                    9
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00,
    },
    {    //    HatchStyle30Percent,                    10
        0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00,
        0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,
        0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00,
        0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
        0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00,
        0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,
        0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00,
        0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
    },
    {    //    HatchStyle40Percent,                    11
        0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00,
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
        0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00,
        0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
        0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00,
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
        0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00,
        0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
    },
    {    //    HatchStyle50Percent,                    12
        0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00,
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
        0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00,
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
        0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00,
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
        0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00,
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
    },
    {    //    HatchStyle60Percent,                    13
        0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00,
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
        0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
        0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00,
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
        0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
    },
    {    //    HatchStyle70Percent,                    14
        0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff,
        0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff,
        0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff,
        0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff,
    },
    {    //    HatchStyle75Percent,                    15
        0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    },
    {    //    HatchStyle80Percent,                    16
        0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    },
    {    //    HatchStyle90Percent,                    17
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    },
    {    //    HatchStyleLightDownwardDiagonal,        18
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,
        0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00,
        0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,
        0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00,
        0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
    },
    {    //    HatchStyleLightUpwardDiagonal,          19
        0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
        0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00,
        0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
        0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00,
        0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleDarkDownwardDiagonal,         20
        0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
        0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00,
        0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,
        0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff,
        0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
        0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00,
        0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,
        0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff,
    },
    {    //    HatchStyleDarkUpwardDiagonal,           21
        0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,
        0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00,
        0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
        0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff,
        0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,
        0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00,
        0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
        0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff,
    },
    {    //    HatchStyleWideDownwardDiagonal,         22
        0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
        0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
    },
    {    //    HatchStyleWideUpwardDiagonal,           23
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00,
        0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
        0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
    },
    {    //    HatchStyleLightVertical,                24
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleLightHorizontal,              25
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleNarrowVertical,               26
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
    },
    {    //    HatchStyleNarrowHorizontal,             27
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleDarkVertical,                 28
        0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
        0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
        0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
        0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
        0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
        0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
        0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
        0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
    },
    {    //    HatchStyleDarkHorizontal,               29
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleDashedDownwardDiagonal,       30
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,
        0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00,
        0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleDashedUpwardDiagonal,         31
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
        0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00,
        0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleDashedHorizontal,             32
        0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleDashedVertical,               33
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleSmallConfetti,                34
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00,
        0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
        0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,
    },
    {    //    HatchStyleLargeConfetti,                35
        0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff,
        0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
        0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff,
        0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00,
        0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff,
    },
    {    //    HatchStyleZigZag,                       36
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
        0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00,
        0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
        0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00,
        0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleWave,                         37
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0xff,
        0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0xff,
        0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleDiagonalBrick,                38
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00,
        0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
    },
    {    //    HatchStyleHorizontalBrick,              39
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleWeave,                        40
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00,
        0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00,
        0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0xff,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00,
        0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00,
        0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
    },
    {    //    HatchStylePlaid,                        41
        0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00,
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
        0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00,
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
        0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleDivot,                        42
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleDottedGrid,                   43
        0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleDottedDiamond,                44
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleShingle,                      45
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
        0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,
        0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
    },
    {    //    HatchStyleTrellis,                      46
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff,
    },
    {    //    HatchStyleSphere,                       47
        0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff,
        0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff,
        0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleSmallGrid,                    48
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleSmallCheckerBoard,            49
        0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff,
        0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00,
        0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00,
        0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff,
        0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff,
        0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00,
        0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00,
        0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff,
    },
    {    //    HatchStyleLargeCheckerBoard,            50
        0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
    },
    {    //    HatchStyleOutlinedDiamond,              51
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00,
        0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,
        0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
    },
    {    //    HatchStyleSolidDiamond,                 52
        0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
        0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
        0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00,
        0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },
};

VOID
GpHatch::InitializeData()
{
    if ((DeviceBrush.Style >= HatchStyleMin) &&
        (DeviceBrush.Style <= HatchStyleMax))
    {
        GpMemcpy(DeviceBrush.Data, GdipHatchPatterns8bpp[DeviceBrush.Style], 64);
    }
    else
    {
        WARNING1("Bad Hatch Style Value");
        GpMemset(DeviceBrush.Data, 0x00, 64);   // make it transparent
    }
}

/***************************************************************************\
*
*   Equivalence comparsion functions
*
\***************************************************************************/

/**************************************************************************\
*
* Function Description:
*
*   Answer TRUE if brush and the receiver are equivalent (i.e. - they will
*   render indentically)
*
* Arguments:
*
*   [IN] brush - GpBrush, or subclass, to compare this against.
*
* Return Value:
*
*   TRUE if equivalent
*
* Created - 5/28/99 peterost
*
\**************************************************************************/

BOOL
GpHatch::IsEqual(const GpBrush * brush) const
{
    if(!brush)
        return FALSE;

    if (brush == this)
        return TRUE;

    if (GpBrush::IsEqual(brush))
    {
        const GpHatch * hbrush = static_cast<const GpHatch *>(brush);
        return hbrush->DeviceBrush.Style == DeviceBrush.Style &&
               hbrush->DeviceBrush.Colors[0].IsEqual(DeviceBrush.Colors[0]) &&
               hbrush->DeviceBrush.Colors[1].IsEqual(DeviceBrush.Colors[1]);
    }
    else
    {
        return FALSE;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Answer TRUE if brush and the receiver are equivalent (i.e. - they will
*   render indentically).  RectGradient brushes require all four colors and
*   blend factors to be equal.
*
* Arguments:
*
*   [IN] brush - GpBrush, or subclass, to compare this against.
*
* Return Value:
*
*   TRUE if equivalent
*
* Created - 5/28/99 peterost
*
\**************************************************************************/

BOOL
GpRectGradient::IsEqual(const GpBrush * brush) const
{
    if(!brush)
        return FALSE;

    if (brush == this)
        return TRUE;

    if (GpGradientBrush::IsEqual(brush))
    {
        const GpRectGradient * rbrush = static_cast<const GpRectGradient *>(brush);

        if (rbrush->DeviceBrush.UsesPresetColors == DeviceBrush.UsesPresetColors &&
            rbrush->DeviceBrush.BlendCounts[0] == DeviceBrush.BlendCounts[0] &&
            rbrush->DeviceBrush.BlendCounts[1] == DeviceBrush.BlendCounts[1])
        {
            INT i;

            if (DeviceBrush.UsesPresetColors)
            {
                // For preset colors, only the horizontal blend variables are used.
                for (INT i=0; i<DeviceBrush.BlendCounts[0]; i++)
                {
                    if (rbrush->DeviceBrush.PresetColors[i] != DeviceBrush.PresetColors[i] ||
                        rbrush->DeviceBrush.BlendPositions[0][i] != DeviceBrush.BlendPositions[0][i])
                        return FALSE;
                }

            }
            else
            {
                for (i=0; i<4; i++)
                {
                    if (!rbrush->DeviceBrush.Colors[i].IsEqual(DeviceBrush.Colors[i]))
                        return FALSE;
                }

                if (DeviceBrush.BlendCounts[0] > 1)
                {
                    for (i=0; i<DeviceBrush.BlendCounts[0]; i++)
                    {
                        if (rbrush->DeviceBrush.BlendFactors[0][i] != DeviceBrush.BlendFactors[0][i] ||
                            rbrush->DeviceBrush.BlendPositions[0][i] != DeviceBrush.BlendPositions[0][i])
                            return FALSE;
                    }
                }
                else if (rbrush->DeviceBrush.Falloffs[0] != DeviceBrush.Falloffs[0])
                {
                    return FALSE;
                }

                if (DeviceBrush.BlendCounts[1] > 1)
                {
                    for (i=0; i<DeviceBrush.BlendCounts[1]; i++)
                    {
                        if (rbrush->DeviceBrush.BlendFactors[1][i] != DeviceBrush.BlendFactors[1][i] ||
                            rbrush->DeviceBrush.BlendPositions[1][i] != DeviceBrush.BlendPositions[1][i])
                            return FALSE;
                    }
                }
                else if (rbrush->DeviceBrush.Falloffs[1] != DeviceBrush.Falloffs[1])
                {
                    return FALSE;
                }
            }

            return TRUE;

        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }

}

/**************************************************************************\
*
* Function Description:
*
*   Answer TRUE if brush and the receiver are equivalent (i.e. - they will
*   render indentically).
*
* Arguments:
*
*   [IN] brush - GpBrush, or subclass, to compare this against.
*
* Return Value:
*
*   TRUE if equivalent
*
* Created - 6/2/99 peterost
*
\**************************************************************************/
#if 0
BOOL
GpRadialGradient::IsEqual(const GpBrush * brush) const
{
    if(!brush)
        return FALSE;

    if (brush == this)
        return TRUE;

    if (GpGradientBrush::IsEqual(brush))
    {
        const GpRadialGradient * rbrush = static_cast<const GpRadialGradient *>(brush);
        if (rbrush->DeviceBrush.UsesPresetColors == DeviceBrush.UsesPresetColors &&
            rbrush->DeviceBrush.BlendCounts[0] == DeviceBrush.BlendCounts[0])
        {
            if (DeviceBrush.UsesPresetColors)
            {
                for (INT i=0; i<DeviceBrush.BlendCounts[0]; i++)
                {
                    if (rbrush->DeviceBrush.PresetColors[i] != DeviceBrush.PresetColors[i] ||
                        rbrush->DeviceBrush.BlendPositions[0][i] != DeviceBrush.BlendPositions[0][i])
                        return FALSE;
                }
            }
            else
            {
                if (rbrush->DeviceBrush.Colors[0].IsEqual(DeviceBrush.Colors[0]) &&
                    rbrush->DeviceBrush.Colors[1].IsEqual(DeviceBrush.Colors[1]))
                {
                    if (DeviceBrush.BlendCounts[0] > 1)
                    {
                        for (INT i=0; i<DeviceBrush.BlendCounts[0]; i++)
                        {
                            if (rbrush->DeviceBrush.BlendFactors[0][i] != DeviceBrush.BlendFactors[0][i] ||
                                rbrush->DeviceBrush.BlendPositions[0][i] != DeviceBrush.BlendPositions[0][i])
                                return FALSE;
                        }
                    }
                    else if (rbrush->DeviceBrush.Falloffs[0] != DeviceBrush.Falloffs[0])
                    {
                        return FALSE;
                    }
                }
                else
                {
                    return FALSE;
                }
            }

            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }

}

/**************************************************************************\
*
* Function Description:
*
*   Answer TRUE if brush and the receiver are equivalent (i.e. - they will
*   render indentically).
*
* Arguments:
*
*   [IN] brush - GpBrush, or subclass, to compare this against.
*
* Return Value:
*
*   TRUE if equivalent
*
* Created - 6/7/99 peterost
*
\**************************************************************************/

BOOL
GpTriangleGradient::IsEqual(const GpBrush * brush) const
{
    if(!brush)
        return FALSE;

    if (brush == this)
        return TRUE;

    if (GpGradientBrush::IsEqual(brush))
    {
        const GpTriangleGradient * tbrush = static_cast<const GpTriangleGradient *>(brush);
        if (tbrush->DeviceBrush.BlendCounts[0] == DeviceBrush.BlendCounts[0] &&
            tbrush->DeviceBrush.BlendCounts[1] == DeviceBrush.BlendCounts[1] &&
            tbrush->DeviceBrush.BlendCounts[2] == DeviceBrush.BlendCounts[2] &&
            tbrush->DeviceBrush.Rect.Equals(DeviceBrush.Rect))
        {
            INT   i;
            for (i=0; i<3; i++)
            {
                if (tbrush->DeviceBrush.Points[i].X != DeviceBrush.Points[i].X ||
                    tbrush->DeviceBrush.Points[i].Y != DeviceBrush.Points[i].Y ||
                    !(tbrush->DeviceBrush.Colors[i].IsEqual(DeviceBrush.Colors[i])))
                    return FALSE;
            }

            if (DeviceBrush.BlendCounts[0] > 1)
            {
                for (i=0; i<DeviceBrush.BlendCounts[0]; i++)
                {
                    if (tbrush->DeviceBrush.BlendFactors[0][i] != DeviceBrush.BlendFactors[0][i] ||
                        tbrush->DeviceBrush.BlendPositions[0][i] != DeviceBrush.BlendPositions[0][i])
                        return FALSE;
                }
            }
            else if (tbrush->DeviceBrush.Falloffs[0] != DeviceBrush.Falloffs[0])
            {
                return FALSE;
            }

            if (DeviceBrush.BlendCounts[1] > 1)
            {
                for (i=0; i<DeviceBrush.BlendCounts[1]; i++)
                {
                    if (tbrush->DeviceBrush.BlendFactors[1][i] != DeviceBrush.BlendFactors[1][i] ||
                        tbrush->DeviceBrush.BlendPositions[1][i] != DeviceBrush.BlendPositions[1][i])
                        return FALSE;
                }
            }
            else if (tbrush->DeviceBrush.Falloffs[1] != DeviceBrush.Falloffs[1])
            {
                return FALSE;
            }

            if (DeviceBrush.BlendCounts[2] > 1)
            {
                for (i=0; i<DeviceBrush.BlendCounts[2]; i++)
                {
                    if (tbrush->DeviceBrush.BlendFactors[2][i] != DeviceBrush.BlendFactors[2][i] ||
                        tbrush->DeviceBrush.BlendPositions[2][i] != DeviceBrush.BlendPositions[2][i])
                        return FALSE;
                }
            }
            else if (tbrush->DeviceBrush.Falloffs[2] != DeviceBrush.Falloffs[2])
            {
                return FALSE;
            }

            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }
}
#endif

/**************************************************************************\
*
* Function Description:
*
*   Answer TRUE if brush and the receiver are equivalent (i.e. - they will
*   render indentically).
*
* Arguments:
*
*   [IN] brush - GpBrush, or subclass, to compare this against.
*
* Return Value:
*
*   TRUE if equivalent
*
* Created - 6/7/99 peterost
*
\**************************************************************************/

BOOL
GpPathGradient::IsEqual(const GpBrush * brush) const
{
    if(!brush)
        return FALSE;

    if (brush == this)
        return TRUE;

    if (GpGradientBrush::IsEqual(brush))
    {
        const GpPathGradient * pbrush = static_cast<const GpPathGradient *>(brush);
        if (pbrush->DeviceBrush.BlendCounts[0] == DeviceBrush.BlendCounts[0] &&
            pbrush->DeviceBrush.Count == DeviceBrush.Count &&
            pbrush->DeviceBrush.OneSurroundColor == DeviceBrush.OneSurroundColor &&
            pbrush->DeviceBrush.UsesPresetColors == DeviceBrush.UsesPresetColors &&
            pbrush->DeviceBrush.Points[0].X == DeviceBrush.Points[0].X &&
            pbrush->DeviceBrush.Points[0].Y == DeviceBrush.Points[0].Y &&
            pbrush->DeviceBrush.Rect.Equals(DeviceBrush.Rect) &&
            pbrush->DeviceBrush.Colors[0].IsEqual(DeviceBrush.Colors[0])
            )
        {
            INT   i;
            for (i=0; i<DeviceBrush.Count; i++)
            {
                if (pbrush->DeviceBrush.PointsPtr[i].X != DeviceBrush.PointsPtr[i].X ||
                    pbrush->DeviceBrush.PointsPtr[i].Y != DeviceBrush.PointsPtr[i].Y ||
                    !(pbrush->DeviceBrush.ColorsPtr[i].IsEqual(DeviceBrush.ColorsPtr[i])))
                    return FALSE;
            }

            if (DeviceBrush.UsesPresetColors)
            {
                for (i=0; i<DeviceBrush.BlendCounts[0]; i++)
                {
                    if (pbrush->DeviceBrush.PresetColors[i] != DeviceBrush.PresetColors[i] ||
                        pbrush->DeviceBrush.BlendPositions[0][i] != DeviceBrush.BlendPositions[0][i])
                        return FALSE;
                }
            }
            else
            {
                if (DeviceBrush.BlendCounts[0] > 1)
                {
                    for (i=0; i<DeviceBrush.BlendCounts[0]; i++)
                    {
                        if (pbrush->DeviceBrush.BlendFactors[0][i] != DeviceBrush.BlendFactors[0][i] ||
                            pbrush->DeviceBrush.BlendPositions[0][i] != DeviceBrush.BlendPositions[0][i])
                            return FALSE;
                    }
                }
                else if (pbrush->DeviceBrush.Falloffs[0] != DeviceBrush.Falloffs[0])
                {
                    return FALSE;
                }
            }
        }

        return TRUE;
    }
    else
    {
        return FALSE;
    }

}


DpOutputSpan*
GpSolidFill::CreateOutputSpan(
    DpScanBuffer *  scan,
    DpContext *context,
    const GpRect *drawBounds)
{
    return new DpOutputSolidColorSpan(
                    DeviceBrush.SolidColor.GetPremultipliedValue(),
                    scan
                    );
}

DpOutputSpan*
GpRectGradient::CreateOutputSpan(
    DpScanBuffer *  scan,
    DpContext *context,
    const GpRect *drawBounds)
{
    DpOutputSpan* span = NULL;

    ARGB argb[4];

    for(INT i = 0; i < 4; i++)
    {
        argb[i] = DeviceBrush.Colors[i].GetValue();
    }

    BOOL isHorizontal = FALSE;
    BOOL isVertical = FALSE;

    if(HasPresetColors() && DeviceBrush.BlendCounts[0] > 1)
        isHorizontal = TRUE;

    if(!isHorizontal && argb[0] == argb[2] && argb[1] == argb[3])
        isHorizontal = TRUE;

    if(!isHorizontal && argb[0] == argb[1] && argb[2] == argb[3])
        isVertical = TRUE;

    if(!isHorizontal && !isVertical)
    {
        span = new DpOutputGradientSpan(this, scan, context);
    }
    else
    {
        // !!![andrewgo] Not sure why a LinearGradient is coming down to us
        //               as BrushRectGrad - if it comes down as a BrushTypeLinearGradient
        //               (as it should) then we don't have to do any of the
        //               above 'isHorizontal', 'isVertical' stuff

        FPUStateSaver fpuState; // Set the rounding mode.

        if ((GetBrushType() == BrushTypeLinearGradient) /*|| (GetBrushType() == BrushRectGrad)*/)
        {
            if (OSInfo::HasMMX)
            {
                span = new DpOutputLinearGradientSpan_MMX(this, scan, context);
            }
            else
            {
                span = new DpOutputLinearGradientSpan(this, scan, context);
            }
        }
        else
        {
            span = new DpOutputOneDGradientSpan(this, scan, context,
                                                isHorizontal, isVertical);
        }
    }

    if (span && !span->IsValid())
    {
        delete span;
        span = NULL;
    }

    return span;
}

#if 0
DpOutputSpan*
GpRadialGradient::CreateOutputSpan(
    DpScanBuffer *  scan,
    DpContext *context,
    const GpRect *drawBounds)
{
    return new DpOutputOneDGradientSpan(
                    this,
                    scan,
                    context
                    );
}


DpOutputSpan*
GpTriangleGradient::CreateOutputSpan(
    DpScanBuffer *  scan,
    DpContext *context,
    const GpRect *drawBounds)
{
    return new DpOutputTriangleGradientSpan(
                    this,
                    scan,
                    context
                    );
}
#endif

DpOutputSpan*
GpPathGradient::CreateOutputSpan(
    DpScanBuffer *  scan,
    DpContext *context,
    const GpRect *drawBounds)
{
    FPUStateSaver::AssertMode();

    DpOutputSpan* span = NULL;
    WrapMode  wrap = DeviceBrush.Wrap;

    // Check to see if a tiled gradient is really needed.  It 
    // is not necessary if the transformed drawbounds fit 
    // entirely within the bounds of the brush rectangle.
    if (drawBounds && wrap != WrapModeClamp)
    {
        GpMatrix inverseXForm = context->WorldToDevice;
        
        if (Ok == inverseXForm.Invert())
        {  
            GpRectF brushRect = DeviceBrush.Rect;
            GpRectF transformRect;
            
            TransformBounds(
                &inverseXForm, 
                (REAL)drawBounds->GetLeft(),
                (REAL)drawBounds->GetTop(),
                (REAL)drawBounds->GetRight(),
                (REAL)drawBounds->GetBottom(),
                &transformRect
            );

            if (brushRect.Contains(transformRect))
            {
                wrap = WrapModeClamp;
            }
        }
    }

    if(wrap == WrapModeClamp)
    {
        if(!DeviceBrush.OneSurroundColor)
        {
            span = new DpOutputPathGradientSpan(
                this,
                scan,
                context
            );

        }
        else
        {
            span = new DpOutputOneDPathGradientSpan(
                this,
                scan,
                context
            );
        }
    }
    else
    {
        INT width, height, ix, iy;

        GpRectF brushRect = DeviceBrush.Rect;

        // Create a texture brush to represent this path gradient brush.
        // We do this by creating a texture as close to device resolution 
        // as we can and computing the transform (brush to world) for the
        // texture brush decomposed into two transforms that take the 
        // brush via device space. The texture brush transform 
        // usually works out to be the inverse of the world to device, so
        // the final texture brush draws with a resultant identity transform
        // regardless of the world to device matrix. (exception when there is 
        // a rotation in the w2d).

        GpPointF worldDestPoints[3];
        worldDestPoints[0].X = brushRect.X ;
        worldDestPoints[0].Y = brushRect.Y;
        worldDestPoints[1].X = worldDestPoints[0].X + brushRect.Width;
        worldDestPoints[1].Y = worldDestPoints[0].Y;
        worldDestPoints[2].X = worldDestPoints[0].X;
        worldDestPoints[2].Y = worldDestPoints[0].Y + brushRect.Height;

        // Take into account transformation by both the brush xform and
        // the world to device. This will handle transforms such as
        // UnitInch and w2d scales.
        
        // First get the destination points in world space by applying the 
        // brush transform.
        
        DeviceBrush.Xform.Transform(worldDestPoints, 3);
        
        GpPointF deviceDestPoints[3];
        GpMemcpy(deviceDestPoints, worldDestPoints, sizeof(worldDestPoints));
        
        // Now get the device space destination points by applying the 
        // world to device transform.
        
        context->WorldToDevice.Transform(deviceDestPoints, 3);
        
        // Compute the bounds in device space.
        
        REAL xmin, xmax, ymin, ymax, nextX, nextY;
        
        xmin = xmax = deviceDestPoints[1].X + 
            deviceDestPoints[2].X - deviceDestPoints[0].X;
            
        ymin = ymax = deviceDestPoints[1].Y + 
            deviceDestPoints[2].Y - deviceDestPoints[0].Y;
        
        for(INT i = 0; i < 3; i++)
        {
            nextX = deviceDestPoints[i].X;
            nextY = deviceDestPoints[i].Y;

            if(nextX < xmin)
                xmin = nextX;
            else if(nextX > xmax)
                xmax = nextX;
            if(nextY < ymin)
                ymin = nextY;
            else if(nextY > ymax)
                ymax = nextY;
        }

        // Set the optimal bitmap bounds.

        ix = GpRound(xmin);
        iy = GpRound(ymin);
        width = GpRound(xmax) - ix;
        height = GpRound(ymax) - iy;
        GpRectF bitmapBounds(0, 0, TOREAL(width), TOREAL(height));

        // Decompose brushRect --> worldDestPoints transform into two matrix.
        // mat1: brushRect --> bitmapBounds (device space)
        // mat2: bitmapBounds --> worldDestPoints

        GpMatrix mat1, mat2;
        mat1.InferAffineMatrix(bitmapBounds, brushRect);
        mat2.InferAffineMatrix(worldDestPoints, bitmapBounds);

        if(width <= 0 || height <= 0)
            return NULL;

        // Create a bitmap which the gradient will be drawn onto.
        // Make it the full width and height of the gradient, even
        // though only a small portion may be used to simplify 
        // handling by downstream functions.
        
        GpBitmap* bitmap = new GpBitmap(width, height, PixelFormat32bppARGB);  

        if(bitmap)
        {
            GpGraphics* g = bitmap->GetGraphicsContext();
            if(g)
            {
                GpLock lock(g->GetObjectLock());
                
                // Set the transform to brushRect --> bitmapBounds.

                g->MultiplyWorldTransform(mat1);

                WrapMode savedWrapMode = DeviceBrush.Wrap;
                DeviceBrush.Wrap = WrapModeClamp;
                GpMatrix savedMat = DeviceBrush.Xform;
                DeviceBrush.Xform.Reset();

                g->FillRect(this, brushRect.X, brushRect.Y,
                            brushRect.Width, brushRect.Height);
                
                DeviceBrush.Wrap = savedWrapMode;
                DeviceBrush.Xform = savedMat;

                if(MorphedBrush)
                    delete MorphedBrush;

                // Create a texuture with a unit tile and set the
                // brush transform to bitmapBounds --> worldDestPoints.

                GpTexture* texture = new GpTexture(bitmap, savedWrapMode);
                
                // span must be NULL at this point. If it's not, we're going 
                // to leak memory when we create it below, or in the case of
                // an error out, we may end up with uninitialized memory
                // being returned to the caller.
                
                ASSERT(span == NULL);
                
                if(texture)
                {
                    texture->MultiplyTransform(mat2);
    
                    span = texture->CreateOutputSpan(scan, context, drawBounds);
                }
                
                // Even if we failed to create the texture, we still want to
                // set a reasonable (NULL) value for MorphedBrush so that we
                // don't have a dangling pointer.
                
                MorphedBrush = texture;
            }
            
            // We're done with this graphics.
            // NOTE: this is explicitly done outside of the scope of the 
            // GpLock object, so that the GpLock (which modifies the graphics
            // in its destructor) doesn't touch freed memory.
            
            delete g;

            bitmap->Dispose();            
        }
    }

    return span;
}

DpOutputSpan*
GpTexture::CreateOutputSpan(
    DpScanBuffer *scan,
    DpContext *context,
    const GpRect *drawBounds)
{
    DpOutputBilinearSpan *textureSpan = NULL;
    GpMatrix brushTransform;
    GpMatrix worldToDevice;

    // Figure out the world-to-device transform:

    worldToDevice = context->WorldToDevice;
    this->GetTransform(&brushTransform);
    worldToDevice.Prepend(brushTransform);

    // Go through our heirarchy of scan drawers:
    if (worldToDevice.IsIntegerTranslate() &&
        ((this->GetWrapMode() == WrapModeTile) ||
         (this->GetWrapMode() == WrapModeClamp)))
    {
        textureSpan = new DpOutputBilinearSpan_Identity(this,
                                                       scan,
                                                       &worldToDevice,
                                                       context);
    }
    else if (OSInfo::HasMMX &&
             GpValidFixed16(DeviceBrush.Rect.Width) &&
             GpValidFixed16(DeviceBrush.Rect.Height))
    {
        textureSpan = new DpOutputBilinearSpan_MMX(this,
                                                  scan,
                                                  &worldToDevice,
                                                  context);
    }

    // Scan drawer creation may fail, so clean up and try one last time
    if ((textureSpan) && !textureSpan->IsValid())
    {
        delete textureSpan;
        textureSpan = NULL;
    }

    if (!textureSpan)
    {
        textureSpan = new DpOutputBilinearSpan(this,
                                              scan,
                                              &worldToDevice,
                                              context);
    }

    if ((textureSpan) && !textureSpan->IsValid())
    {
        delete textureSpan;
        textureSpan = NULL;
    }

    return textureSpan;
}

DpOutputSpan*
GpHatch::CreateOutputSpan(
    DpScanBuffer *  scan,
    DpContext *context,
    const GpRect *drawBounds)
{
    if (StretchFactor == 1)
    {
        return new DpOutputHatchSpan(
                        this,
                        scan,
                        context
                        );
    }
    else
    {
        return new DpOutputStretchedHatchSpan(
                        this,
                        scan,
                        context,
                        StretchFactor
                        );
    }
}

class SolidBrushData : public ObjectTypeData
{
public:
    ARGB        SolidColor;
};

/**************************************************************************\
*
* Function Description:
*
*   Get the brush data.
*
* Arguments:
*
*   [IN] dataBuffer - fill this buffer with the data
*   [IN/OUT] size   - IN - size of buffer; OUT - number bytes written
*
* Return Value:
*
*   GpStatus - Ok or error code
*
* Created:
*
*   9/13/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpSolidFill::GetData(
    IStream *   stream
    ) const
{
    ASSERT (stream != NULL);

    SolidBrushData  brushData;
    brushData.Type       = DeviceBrush.Type;
    brushData.SolidColor = DeviceBrush.SolidColor.GetValue();
    stream->Write(&brushData, sizeof(brushData), NULL);
    return Ok;
}

UINT
GpSolidFill::GetDataSize() const
{
    return sizeof(SolidBrushData);
}

/**************************************************************************\
*
* Function Description:
*
*   Read the brush object from memory.
*
* Arguments:
*
*   [IN] dataBuffer - the data that was read from the stream
*   [IN] size - the size of the data
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   4/26/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpSolidFill::SetData(
    const BYTE *        dataBuffer,
    UINT                size
    )
{
    ASSERT ((GpBrushType)(((SolidBrushData *)dataBuffer)->Type) == BrushTypeSolidColor);

    if (dataBuffer == NULL)
    {
        WARNING(("dataBuffer is NULL"));
        return InvalidParameter;
    }

    if (size < sizeof(SolidBrushData))
    {
        WARNING(("size too small"));
        return InvalidParameter;
    }

    if (!((SolidBrushData *)dataBuffer)->MajorVersionMatches())
    {
        WARNING(("Version number mismatch"));
        return InvalidParameter;
    }

    SetColor(GpColor(((SolidBrushData *)dataBuffer)->SolidColor));

    return Ok;
}

GpStatus
GpSolidFill::ColorAdjust(
    GpRecolor *             recolor,
    ColorAdjustType         type
    )
{
    if(!recolor)
        return InvalidParameter;

    if (type == ColorAdjustTypeDefault)
    {
        type = ColorAdjustTypeBrush;
    }

    ARGB    solidColor32 = Color.GetValue();

    recolor->ColorAdjust(&solidColor32, 1, type);

    this->SetColor(GpColor(solidColor32));
    return Ok;
}

class TextureBrushData : public ObjectTypeData
{
public:
    INT32       Flags;
    INT32       Wrap;
};

/**************************************************************************\
*
* Function Description:
*
*   Get the brush data.
*
* Arguments:
*
*   [IN] dataBuffer - fill this buffer with the data
*   [IN/OUT] size   - IN - size of buffer; OUT - number bytes written
*
* Return Value:
*
*   GpStatus - Ok or error code
*
* Created:
*
*   9/13/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpTexture::GetData(
    IStream *   stream
    ) const
{
    ASSERT (stream != NULL);

    if (Image == NULL)
    {
        WARNING(("Image is NULL"));
        return Ok;
    }

    INT         flags = 0;

    if (DeviceBrush.IsGammaCorrected)
    {
        flags |= GDIP_BRUSHFLAGS_ISGAMMACORRECTED;
    }

    if (!DeviceBrush.Xform.IsIdentity())
    {
        flags |= GDIP_BRUSHFLAGS_TRANSFORM;
    }

    TextureBrushData    brushData;
    brushData.Type  = DeviceBrush.Type;
    brushData.Flags = flags;
    brushData.Wrap  = DeviceBrush.Wrap;
    stream->Write(&brushData, sizeof(brushData), NULL);

    if (flags & GDIP_BRUSHFLAGS_TRANSFORM)
    {
        DeviceBrush.Xform.WriteMatrix(stream);
    }

    return Image->GetData(stream);
}

UINT
GpTexture::GetDataSize() const
{
    if (Image == NULL)
    {
        WARNING(("Image is NULL"));
        return 0;
    }

    UINT    size = sizeof(TextureBrushData);

    if (!DeviceBrush.Xform.IsIdentity())
    {
        size += GDIP_MATRIX_SIZE;
    }

    size += Image->GetDataSize();

    return size;
}

/**************************************************************************\
*
* Function Description:
*
*   Read the brush object from memory.
*
* Arguments:
*
*   [IN] dataBuffer - the data that was read from the stream
*   [IN] size - the size of the data
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   4/26/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpTexture::SetData(
    const BYTE *        dataBuffer,
    UINT                size
    )
{
    ASSERT ((GpBrushType)(((TextureBrushData *)dataBuffer)->Type) == BrushTypeTextureFill);

    if (dataBuffer == NULL)
    {
        WARNING(("dataBuffer is NULL"));
        return InvalidParameter;
    }

    if (size < sizeof(TextureBrushData))
    {
        WARNING(("size too small"));
        return InvalidParameter;
    }

    const TextureBrushData *    brushData;

    brushData = reinterpret_cast<const TextureBrushData *>(dataBuffer);

    if (!brushData->MajorVersionMatches())
    {
        WARNING(("Version number mismatch"));
        return InvalidParameter;
    }

    DeviceBrush.Type             = BrushTypeTextureFill;
    DeviceBrush.Wrap             = (GpWrapMode) brushData->Wrap;
    DeviceBrush.IsGammaCorrected = ((brushData->Flags & GDIP_BRUSHFLAGS_ISGAMMACORRECTED) != 0);

    dataBuffer += sizeof(TextureBrushData);
    size       -= sizeof(TextureBrushData);

    if (brushData->Flags & GDIP_BRUSHFLAGS_TRANSFORM)
    {
        if (size < GDIP_MATRIX_SIZE)
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }
        DeviceBrush.Xform.SetMatrix((REAL *)dataBuffer);
        dataBuffer += GDIP_MATRIX_SIZE;
        size       -= GDIP_MATRIX_SIZE;
    }
    if (Image != NULL)
    {
        Image->Dispose();
        Image = NULL;
    }

    if (size >= sizeof(ObjectTypeData))
    {
        Image = (GpImage *)GpObject::Factory(ObjectTypeImage, (const ObjectData *)dataBuffer, size);

        if (Image != NULL)
        {
            if ((Image->SetData(dataBuffer, size) == Ok) && Image->IsValid() &&
                ((ImageType = Image->GetImageType()) == ImageTypeBitmap))
            {
                GpPageUnit  unit;
                Image->GetBounds(&DeviceBrush.Rect, &unit);
                SetValid(TRUE);
                UpdateUid();
                return Ok;
            }
            Image->Dispose();
            Image = NULL;
        }
    }
    WARNING(("Failure getting image"));
    GpMemset(&DeviceBrush.Rect, 0, sizeof(DeviceBrush.Rect));
    SetValid(FALSE);
    return GenericError;
}

GpStatus
GpTexture::ColorAdjust(
    GpRecolor *             recolor,
    ColorAdjustType         type
    )
{
    if (type == ColorAdjustTypeDefault)
    {
        type = ColorAdjustTypeBrush;
    }

    if (Image != NULL)
    {
        Image->ColorAdjust(recolor, type);
        UpdateUid();
    }

    return Ok;
}


VOID GpTexture::InitializeBrush(
    GpImage* image,
    GpWrapMode wrapMode,
    const GpRectF* rect,
    const GpImageAttributes *imageAttributes)
{
    ASSERT(image && image->IsValid());

    if (!WrapModeIsValid(wrapMode))
    {
        WARNING(("bad wrap mode"));
        goto Failure;
    }

    GpImageType imageType;

    imageType = image->GetImageType();

    if (imageType == ImageTypeBitmap)
    {
        InitializeBrushBitmap(
            static_cast<GpBitmap*>(image),
            wrapMode, rect, imageAttributes
        );
    }
    else if (imageType == ImageTypeMetafile)
    {
        // For now, convert the metafile into a bitmap image and use that to
        // create the brush.

        GpBitmap *  bitmapImage;

        if (rect != NULL)
        {
            // !!! we don't handle this case yet
            if ((rect->X != 0) || (rect->Y != 0))
            {
                WARNING(("No handling for non-zero start in metafiles"));
            }
            // Don't apply the imageAttributes now, because WMF/EMF rendering
            // doesn't support alpha.  So wait until it's been converted to
            // a bitmap to apply the imageAttributes.

            bitmapImage = ((GpMetafile *)image)->GetBitmap(
                            GpRound(rect->Width),
                            GpRound(rect->Height), NULL);
        }
        else
        {
            // Let the metafile decide how big the bitmap should be

            // Don't apply the imageAttributes now, because WMF/EMF rendering
            // doesn't support alpha.  So wait until it's been converted to
            // a bitmap to apply the imageAttributes.

            bitmapImage = ((GpMetafile *)image)->GetBitmap(0, 0, NULL);
        }

        if (bitmapImage != NULL)
        {
            ASSERT (bitmapImage->IsValid());

            InitializeBrushBitmap(bitmapImage, wrapMode, NULL, imageAttributes, TRUE);
            return;
        }
        goto Failure;
    }
    else    // unknown image type
    {
        WARNING(("unknown image type"));
Failure:
        Image = NULL;
        SetValid(FALSE);
    }
}

VOID GpTexture::InitializeBrushBitmap(
    GpBitmap* bitmap,
    GpWrapMode wrapMode,
    const GpRectF* rect,
    const GpImageAttributes *imageAttributes,
    BOOL useBitmap)
{
    DeviceBrush.Type = BrushTypeTextureFill;
    DeviceBrush.Wrap = wrapMode;

    ImageType = ImageTypeBitmap;

    Image = NULL;

    FPUStateSaver fpState;   // Setup the fpu state.

    if (bitmap && bitmap->IsValid())
    {
        GpRect *pRectI = NULL;
        GpRect recti;
        if(rect)
        {
            recti.X = GpRound(rect->X);
            recti.Y = GpRound(rect->Y);
            recti.Width = GpRound(rect->Width);
            recti.Height = GpRound(rect->Height);
            pRectI = &recti;
        }

        if(imageAttributes)
        {
            GpBitmap *dst = NULL;

            if (bitmap->Recolor(
                imageAttributes->recolor, &dst,
                NULL, NULL, pRectI
            ) == Ok)
            {
                Image = dst;
                
                // If useBitmap is TRUE that means the caller has transferred
                // ownership of bitmap to us. In this case, Recolor makes
                // a clone of the bitmap that we're going to use, so we have
                // to free the bitmap passed in and use the clone instead,
                // otherwise we leak.
                
                if(useBitmap)
                {
                    bitmap->Dispose();
                }
            }
        }

        // !!! note that this should be non-premultiplied ARGB.
        //     we'll fix this when we drop premultiplied data [asecchia]
        //     also note that the output of RecolorImage is 32BPP_ARGB

        // if it's not NULL it's because the RecolorImage code cloned it already
        if (Image == NULL)
        {
            if (useBitmap)
            {
                // This is for the case where we constructed a bitmap
                // from a metafile image.
                Image = bitmap;
            }
            else
            {
                #ifdef NO_PREMULTIPLIED_ALPHA
                Image = bitmap->Clone(pRectI, PIXFMT_32BPP_ARGB);
                #else
                Image = bitmap->Clone(pRectI, PIXFMT_32BPP_PARGB);
                #endif
            }
        }
    }

    if (Image && Image->IsValid())
    {
        SetValid(TRUE);

        // Rect is given as a pixel unit in bitmap.

        GpPageUnit unit;
        Image->GetBounds(&DeviceBrush.Rect, &unit);
    }
    else
    {
        SetValid(FALSE);

        GpMemset(&DeviceBrush.Rect,
                 0,
                 sizeof(DeviceBrush.Rect));
    }
}

// See if this texture fill is really a picture fill (with a bitmap, 
// not a metafile).
BOOL 
GpTexture::IsPictureFill(
    const GpMatrix *    worldToDevice,
    const GpRect *      drawBounds
    ) const
{
    ASSERT ((drawBounds->Width > 0) && (drawBounds->Height > 0));

    BOOL        isPictureFill = FALSE;
    GpMatrix    newBrushMatrix;
    
    this->GetTransform(&newBrushMatrix);

    if (worldToDevice != NULL)
    {
        newBrushMatrix.Append(*worldToDevice);
    }

    newBrushMatrix.Translate(
        (REAL)-(drawBounds->X),
        (REAL)-(drawBounds->Y),
        MatrixOrderAppend
    );

    // See if the texture is supposed to fill the drawBounds.  
    // If so, this is a picture fill.
    if (newBrushMatrix.IsTranslateScale())
    {
        Size    size;

        // If the texture is not a bitmap, this returns InvalidParameter.
        if (this->GetBitmapSize(&size) == Ok)
        {
            GpRectF     transformedRect(0.0f, 0.0f, (REAL)size.Width, (REAL)size.Height);
            newBrushMatrix.TransformRect(transformedRect);

            // get the transformed width
            INT     deltaValue = abs(GpRound(transformedRect.Width) - drawBounds->Width);
            
            // We might be off a little because of the pixel offset mode
            // or a matrix that isn't quite right for whatever reason.
            if (deltaValue <= 2)
            {
                // get the transformed height
                deltaValue = abs(GpRound(transformedRect.Height) - drawBounds->Height);

                if (deltaValue <= 2)
                {
                    if ((abs(GpRound(transformedRect.X)) <= 2) &&
                        (abs(GpRound(transformedRect.Y)) <= 2))
                    {
                        isPictureFill = TRUE;
                    }
                }
            }
        }
    }
    return isPictureFill;
}


class RectGradientBrushData : public ObjectTypeData
{
public:
    INT32       Flags;
    INT32       Wrap;
    GpRectF     Rect;
    UINT32      Color0;
    UINT32      Color1;
    UINT32      Color2;
    UINT32      Color3;
};

/**************************************************************************\
*
* Function Description:
*
*   Get the brush data.
*
* Arguments:
*
*   [IN] dataBuffer - fill this buffer with the data
*   [IN/OUT] size   - IN - size of buffer; OUT - number bytes written
*
* Return Value:
*
*   GpStatus - Ok or error code
*
* Created:
*
*   9/13/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRectGradient::GetData(
    IStream *   stream
    ) const
{
    ASSERT (stream != NULL);

    INT         flags    = 0;

    if (DeviceBrush.IsGammaCorrected)
    {
        flags |= GDIP_BRUSHFLAGS_ISGAMMACORRECTED;
    }

    if (!DeviceBrush.Xform.IsIdentity())
    {
        flags |= GDIP_BRUSHFLAGS_TRANSFORM;
    }

    // Note: can't have both blendFactors and presetColors at the same time
    // PresetColors used for GpLineGradient, but not for GpRectGradient.
    if (DeviceBrush.UsesPresetColors && (DeviceBrush.BlendCounts[0] > 1) && (DeviceBrush.PresetColors != NULL) &&
        (DeviceBrush.BlendPositions[0] != NULL) && (DeviceBrush.BlendFactors[0] == NULL))
    {
        flags |= GDIP_BRUSHFLAGS_PRESETCOLORS;
    }

    if ((DeviceBrush.BlendCounts[0] > 1) && (DeviceBrush.BlendFactors[0] != NULL) && (DeviceBrush.BlendPositions[0] != NULL))
    {
        flags |= GDIP_BRUSHFLAGS_BLENDFACTORSH;
    }

    if ((DeviceBrush.BlendCounts[1] > 1) && (DeviceBrush.BlendFactors[1] != NULL) && (DeviceBrush.BlendPositions[1] != NULL))
    {
        flags |= GDIP_BRUSHFLAGS_BLENDFACTORSV;
    }

    RectGradientBrushData   brushData;
    brushData.Type   = DeviceBrush.Type;
    brushData.Flags  = flags;
    brushData.Wrap   = DeviceBrush.Wrap;
    brushData.Rect   = DeviceBrush.Rect;
    brushData.Color0 = DeviceBrush.Colors[0].GetValue();
    brushData.Color1 = DeviceBrush.Colors[1].GetValue();
    brushData.Color2 = DeviceBrush.Colors[2].GetValue();
    brushData.Color3 = DeviceBrush.Colors[3].GetValue();
    stream->Write(&brushData, sizeof(brushData), NULL);

    if (flags & GDIP_BRUSHFLAGS_TRANSFORM)
    {
        DeviceBrush.Xform.WriteMatrix(stream);
    }

    if (flags & GDIP_BRUSHFLAGS_PRESETCOLORS)
    {
        INT     realSize = DeviceBrush.BlendCounts[0] * sizeof(REAL);
        INT     argbSize = DeviceBrush.BlendCounts[0] * sizeof(ARGB);

        stream->Write(&DeviceBrush.BlendCounts[0], sizeof(INT32), NULL);
        stream->Write(DeviceBrush.BlendPositions[0], realSize, NULL);
        stream->Write(DeviceBrush.PresetColors, argbSize, NULL);
    }

    if (flags & GDIP_BRUSHFLAGS_BLENDFACTORSH)
    {
        INT     realSize = DeviceBrush.BlendCounts[0] * sizeof(REAL);

        stream->Write(&DeviceBrush.BlendCounts[0], sizeof(INT32), NULL);
        stream->Write(DeviceBrush.BlendPositions[0], realSize, NULL);
        stream->Write(DeviceBrush.BlendFactors[0], realSize, NULL);
    }

    if (flags & GDIP_BRUSHFLAGS_BLENDFACTORSV)
    {
        INT     realSize = DeviceBrush.BlendCounts[1] * sizeof(REAL);

        stream->Write(&DeviceBrush.BlendCounts[1], sizeof(INT32), NULL);
        stream->Write(DeviceBrush.BlendPositions[1], realSize, NULL);
        stream->Write(DeviceBrush.BlendFactors[1], realSize, NULL);
    }

    return Ok;
}

UINT
GpRectGradient::GetDataSize() const
{
    UINT        size = sizeof(RectGradientBrushData);

    if (!DeviceBrush.Xform.IsIdentity())
    {
        size += GDIP_MATRIX_SIZE;
    }

    // Note: can't have both blendFactors and presetColors at the same time
    // PresetColors used for GpLineGradient, but not for GpRectGradient.
    if (DeviceBrush.UsesPresetColors && (DeviceBrush.BlendCounts[0] > 1) && (DeviceBrush.PresetColors != NULL) &&
        (DeviceBrush.BlendPositions[0] != NULL) && (DeviceBrush.BlendFactors[0] == NULL))
    {
        size += sizeof(INT32) + ((sizeof(ARGB) + sizeof(REAL)) * DeviceBrush.BlendCounts[0]);
    }

    if ((DeviceBrush.BlendCounts[0] > 1) && (DeviceBrush.BlendFactors[0] != NULL) && (DeviceBrush.BlendPositions[0] != NULL))
    {
        size += sizeof(INT32) + ((sizeof(REAL) + sizeof(REAL)) * DeviceBrush.BlendCounts[0]);
    }

    if ((DeviceBrush.BlendCounts[1] > 1) && (DeviceBrush.BlendFactors[1] != NULL) && (DeviceBrush.BlendPositions[1] != NULL))
    {
        size += sizeof(INT32) + ((sizeof(REAL) + sizeof(REAL)) * DeviceBrush.BlendCounts[1]);
    }

    return size;
}

/**************************************************************************\
*
* Function Description:
*
*   Read the brush object from memory.
*
* Arguments:
*
*   [IN] dataBuffer - the data that was read from the stream
*   [IN] size - the size of the data
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   4/26/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRectGradient::SetData(
    const BYTE *        dataBuffer,
    UINT                size
    )
{
    ASSERT ((GpBrushType)(((RectGradientBrushData *)dataBuffer)->Type) == BrushTypeLinearGradient);

    if (dataBuffer == NULL)
    {
        WARNING(("dataBuffer is NULL"));
        return InvalidParameter;
    }

    if (size < sizeof(RectGradientBrushData))
    {
        WARNING(("size too small"));
        return InvalidParameter;
    }

    const RectGradientBrushData *   brushData;
    GpColor                         colors[4];

    brushData = reinterpret_cast<const RectGradientBrushData *>(dataBuffer);

    if (!brushData->MajorVersionMatches())
    {
        WARNING(("Version number mismatch"));
        return InvalidParameter;
    }

    colors[0].SetValue(brushData->Color0);
    colors[1].SetValue(brushData->Color1);
    colors[2].SetValue(brushData->Color2);
    colors[3].SetValue(brushData->Color3);

    InitializeBrush(brushData->Rect, colors, (GpWrapMode) brushData->Wrap);

    DeviceBrush.IsGammaCorrected = ((brushData->Flags & GDIP_BRUSHFLAGS_ISGAMMACORRECTED) != 0);

    dataBuffer += sizeof(RectGradientBrushData);
    size       -= sizeof(RectGradientBrushData);

    if (brushData->Flags & GDIP_BRUSHFLAGS_TRANSFORM)
    {
        if (size < GDIP_MATRIX_SIZE)
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }
        DeviceBrush.Xform.SetMatrix((REAL *)dataBuffer);
        dataBuffer += GDIP_MATRIX_SIZE;
        size       -= GDIP_MATRIX_SIZE;
    }

    if (brushData->Flags & GDIP_BRUSHFLAGS_PRESETCOLORS)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        UINT count = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        UINT realSize = count * sizeof(REAL);
        UINT argbSize = count * sizeof(ARGB);

        if (size < (realSize + argbSize))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        ARGB* newColors    = (ARGB*) GpRealloc(DeviceBrush.PresetColors, argbSize);

        if (newColors != NULL)
        {
            // We have to just copy in the ARGB values, because they've already
            // been premultiplied.
            // Actually PresetColors is NON-premultiplied, but this code should
            // still be right because we write them out non-premultiplied too.
            
            GpMemcpy(newColors, dataBuffer + realSize, argbSize);
            DeviceBrush.PresetColors = newColors;

            REAL* newPositions = (REAL*) GpRealloc(DeviceBrush.BlendPositions[0], realSize);

            if (newPositions != NULL)
            {
                GpMemcpy(newPositions, dataBuffer, realSize);
                DeviceBrush.BlendPositions[0] = newPositions;

                GpFree(DeviceBrush.BlendFactors[0]);
                DeviceBrush.BlendFactors[0] = NULL;
                DeviceBrush.UsesPresetColors = TRUE;
                DeviceBrush.BlendCounts[0] = count;
            }
        }

        dataBuffer += (realSize + argbSize);
        size       -= (realSize + argbSize);
    }

    if (brushData->Flags & GDIP_BRUSHFLAGS_BLENDFACTORSH)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        UINT count = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        UINT realSize = count * sizeof(REAL);

        if (size < (2 * realSize))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        this->SetHorizontalBlend((REAL *)(dataBuffer + realSize),(REAL *)dataBuffer, count);
        dataBuffer += (2 * realSize);
        size       -= (2 * realSize);
    }

    if (brushData->Flags & GDIP_BRUSHFLAGS_BLENDFACTORSV)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        UINT count = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        UINT realSize = count * sizeof(REAL);

        if (size < (2 * realSize))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        this->SetVerticalBlend((REAL *)(dataBuffer + realSize), (REAL *)dataBuffer, count);
        dataBuffer += (2 * realSize);
        size       -= (2 * realSize);
    }
    UpdateUid();
    return Ok;
}

GpStatus
GpRectGradient::ColorAdjust(
    GpRecolor *             recolor,
    ColorAdjustType         type
    )
{
    if(!recolor)
        return InvalidParameter;

    if (type == ColorAdjustTypeDefault)
    {
        type = ColorAdjustTypeBrush;
    }

    ARGB    solidColor32[4];

    solidColor32[0] = DeviceBrush.Colors[0].GetValue();
    solidColor32[1] = DeviceBrush.Colors[1].GetValue();
    solidColor32[2] = DeviceBrush.Colors[2].GetValue();
    solidColor32[3] = DeviceBrush.Colors[3].GetValue();

    recolor->ColorAdjust(solidColor32, 4, type);

    DeviceBrush.Colors[0].SetValue(solidColor32[0]);
    DeviceBrush.Colors[1].SetValue(solidColor32[1]);
    DeviceBrush.Colors[2].SetValue(solidColor32[2]);
    DeviceBrush.Colors[3].SetValue(solidColor32[3]);

    if (DeviceBrush.UsesPresetColors && (DeviceBrush.BlendCounts[0] > 1) && (DeviceBrush.PresetColors != NULL))
    {
        recolor->ColorAdjust(DeviceBrush.PresetColors, DeviceBrush.BlendCounts[0], type);
    }

    UpdateUid();
    return Ok;
}

#if 0
class RadialGradientBrushData : public ObjectTypeData
{
public:
    INT32       Flags;
    INT32       Wrap;
    GpRectF     Rect;
    UINT32      CenterColor;
    UINT32      BoundaryColor;
};

/**************************************************************************\
*
* Function Description:
*
*   Get the brush data.
*
* Arguments:
*
*   [IN] dataBuffer - fill this buffer with the data
*   [IN/OUT] size   - IN - size of buffer; OUT - number bytes written
*
* Return Value:
*
*   GpStatus - Ok or error code
*
* Created:
*
*   9/13/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRadialGradient::GetData(
    IStream *   stream
    ) const
{
    ASSERT (stream != NULL);

    INT         flags    = 0;

    if (DeviceBrush.IsGammaCorrected)
    {
        flags |= GDIP_BRUSHFLAGS_ISGAMMACORRECTED;
    }

    if (!DeviceBrush.Xform.IsIdentity())
    {
        flags |= GDIP_BRUSHFLAGS_TRANSFORM;
    }

    // Note: can't have both blendFactors and presetColors at the same time
    if (DeviceBrush.UsesPresetColors && (DeviceBrush.BlendCounts[0] > 1) && (DeviceBrush.PresetColors != NULL) &&
        (DeviceBrush.BlendPositions[0] != NULL) && (DeviceBrush.BlendFactors[0] == NULL))
    {
        flags |= GDIP_BRUSHFLAGS_PRESETCOLORS;
    }

    if ((DeviceBrush.BlendCounts[0] > 1) && (DeviceBrush.BlendFactors[0] != NULL) && (DeviceBrush.BlendPositions[0] != NULL))
    {
        flags |= GDIP_BRUSHFLAGS_BLENDFACTORS;
    }

    RadialGradientBrushData brushData;
    brushData.Type          = DeviceBrush.Type;
    brushData.Flags         = flags;
    brushData.Wrap          = DeviceBrush.Wrap;
    brushData.Rect          = DeviceBrush.Rect;
    brushData.CenterColor   = DeviceBrush.Colors[0].GetValue();
    brushData.BoundaryColor = DeviceBrush.Colors[1].GetValue();
    stream->Write(&brushData, sizeof(brushData), NULL);

    if (flags & GDIP_BRUSHFLAGS_TRANSFORM)
    {
        DeviceBrush.Xform.WriteMatrix(stream);
    }

    if (flags & GDIP_BRUSHFLAGS_PRESETCOLORS)
    {
        INT     realSize = DeviceBrush.BlendCounts[0] * sizeof(REAL);
        INT     argbSize = DeviceBrush.BlendCounts[0] * sizeof(ARGB);

        stream->Write(&DeviceBrush.BlendCounts[0], sizeof(INT32), NULL);
        stream->Write(DeviceBrush.BlendPositions[0], realSize, NULL);
        stream->Write(DeviceBrush.PresetColors, argbSize, NULL);
    }

    if (flags & GDIP_BRUSHFLAGS_BLENDFACTORS)
    {
        INT     realSize = DeviceBrush.BlendCounts[0] * sizeof(REAL);

        stream->Write(&DeviceBrush.BlendCounts[0], sizeof(INT32), NULL);
        stream->Write(DeviceBrush.BlendPositions[0], realSize, NULL);
        stream->Write(DeviceBrush.BlendFactors[0], realSize, NULL);
    }

    return Ok;
}

UINT
GpRadialGradient::GetDataSize() const
{
    UINT    size = sizeof(RadialGradientBrushData);

    if (!DeviceBrush.Xform.IsIdentity())
    {
        size += GDIP_MATRIX_SIZE;
    }

    // Note: can't have both blendFactors and presetColors at the same time
    if (DeviceBrush.UsesPresetColors && (DeviceBrush.BlendCounts[0] > 1) && (DeviceBrush.PresetColors != NULL) &&
        (DeviceBrush.BlendPositions[0] != NULL) && (DeviceBrush.BlendFactors[0] == NULL))
    {
        size += sizeof(INT32) + ((sizeof(ARGB) + sizeof(REAL)) * DeviceBrush.BlendCounts[0]);
    }

    if ((DeviceBrush.BlendCounts[0] > 1) && (DeviceBrush.BlendFactors[0] != NULL) && (DeviceBrush.BlendPositions[0] != NULL))
    {
        size += sizeof(INT32) + ((sizeof(REAL) + sizeof(REAL)) * DeviceBrush.BlendCounts[0]);
    }

    return size;
}

/**************************************************************************\
*
* Function Description:
*
*   Read the brush object from memory.
*
* Arguments:
*
*   [IN] dataBuffer - the data that was read from the stream
*   [IN] size - the size of the data
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   4/26/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRadialGradient::SetData(
    const BYTE *        dataBuffer,
    UINT                size
    )
{
//    ASSERT ((GpBrushType)(((RadialGradientBrushData *)dataBuffer)->Type) == BrushTypeRadialGradient);

    if (dataBuffer == NULL)
    {
        WARNING(("dataBuffer is NULL"));
        return InvalidParameter;
    }

    if (size < sizeof(RadialGradientBrushData))
    {
        WARNING(("size too small"));
        return InvalidParameter;
    }

    const RadialGradientBrushData * brushData;
    GpColor                         centerColor;
    GpColor                         boundaryColor;

    brushData = reinterpret_cast<const RadialGradientBrushData *>(dataBuffer);

    if (!brushData->MajorVersionMatches())
    {
        WARNING(("Version number mismatch"));
        return InvalidParameter;
    }

    centerColor.SetValue(brushData->CenterColor);
    boundaryColor.SetValue(brushData->BoundaryColor);

    InitializeBrush(
        brushData->Rect,
        centerColor,
        boundaryColor,
        (GpWrapMode) brushData->Wrap
        );

    DeviceBrush.IsGammaCorrected = ((brushData->Flags & GDIP_BRUSHFLAGS_ISGAMMACORRECTED) != 0);

    dataBuffer += sizeof(RadialGradientBrushData);
    size       -= sizeof(RadialGradientBrushData);

    if (brushData->Flags & GDIP_BRUSHFLAGS_TRANSFORM)
    {
        if (size < GDIP_MATRIX_SIZE)
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        DeviceBrush.Xform.SetMatrix((REAL *)dataBuffer);
        dataBuffer += GDIP_MATRIX_SIZE;
        size       -= GDIP_MATRIX_SIZE;
    }

    if (brushData->Flags & GDIP_BRUSHFLAGS_PRESETCOLORS)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        UINT count = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        UINT realSize = count * sizeof(REAL);
        UINT argbSize = count * sizeof(ARGB);

        if (size < (realSize + argbSize))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        ARGB* newColors    = (ARGB*) GpRealloc(DeviceBrush.PresetColors, argbSize);

        if (newColors != NULL)
        {
            // We have to just copy in the ARGB values, because they've already
            // been premultiplied.
            GpMemcpy(newColors, dataBuffer + realSize, argbSize);
            DeviceBrush.PresetColors = newColors;

            REAL* newPositions = (REAL*) GpRealloc(DeviceBrush.BlendPositions[0], realSize);

            if (newPositions != NULL)
            {
                GpMemcpy(newPositions, dataBuffer, realSize);
                DeviceBrush.BlendPositions[0] = newPositions;

                GpFree(DeviceBrush.BlendFactors[0]);
                DeviceBrush.BlendFactors[0] = NULL;
                DeviceBrush.UsesPresetColors = TRUE;
                DeviceBrush.BlendCounts[0] = count;
            }
        }

        dataBuffer += (realSize + argbSize);
        size       -= (realSize + argbSize);
    }

    if (brushData->Flags & GDIP_BRUSHFLAGS_BLENDFACTORS)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        UINT count = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        UINT realSize = count * sizeof(REAL);

        if (size < (2 * realSize))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        this->SetBlend((REAL *)(dataBuffer + realSize), (REAL *)dataBuffer, count);
        dataBuffer += (2 * realSize);
        size       -= (2 * realSize);
    }

    UpdateUid();
    return Ok;
}

GpStatus
GpRadialGradient::ColorAdjust(
    GpRecolor *             recolor,
    ColorAdjustType         type
    )
{
    if(!recolor)
        return InvalidParameter;

    if (type == ColorAdjustTypeDefault)
    {
        type = ColorAdjustTypeBrush;
    }

    ARGB    solidColor32[2];

    solidColor32[0] = DeviceBrush.Colors[0].GetValue();
    solidColor32[1] = DeviceBrush.Colors[1].GetValue();

    recolor->ColorAdjust(solidColor32, 2, type);

    DeviceBrush.Colors[0].SetValue(solidColor32[0]);
    DeviceBrush.Colors[1].SetValue(solidColor32[1]);

    if (DeviceBrush.UsesPresetColors && (DeviceBrush.BlendCounts[0] > 1) && (DeviceBrush.PresetColors != NULL))
    {
        recolor->ColorAdjust(DeviceBrush.PresetColors, DeviceBrush.BlendCounts[0], type);
    }

    UpdateUid();
    return Ok;
}

class TriangleGradientBrushData : public ObjectTypeData
{
public:
    INT32       Flags;
    INT32       Wrap;
    GpPointF    Points[3];
    UINT32      Color0;
    UINT32      Color1;
    UINT32      Color2;
};

/**************************************************************************\
*
* Function Description:
*
*   Get the brush data.
*
* Arguments:
*
*   [IN] dataBuffer - fill this buffer with the data
*   [IN/OUT] size   - IN - size of buffer; OUT - number bytes written
*
* Return Value:
*
*   GpStatus - Ok or error code
*
* Created:
*
*   9/13/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpTriangleGradient::GetData(
    IStream *   stream
    ) const
{
    ASSERT (stream != NULL);

    INT         flags    = 0;

    if (DeviceBrush.IsGammaCorrected)
    {
        flags |= GDIP_BRUSHFLAGS_ISGAMMACORRECTED;
    }

    if (!DeviceBrush.Xform.IsIdentity())
    {
        flags |= GDIP_BRUSHFLAGS_TRANSFORM;
    }

    if ((DeviceBrush.BlendCounts[0] > 1) && (DeviceBrush.BlendFactors[0] != NULL) && (DeviceBrush.BlendPositions[0] != NULL))
    {
        flags |= GDIP_BRUSHFLAGS_BLENDFACTORS0;
    }

    if ((DeviceBrush.BlendCounts[1] > 1) && (DeviceBrush.BlendFactors[1] != NULL) && (DeviceBrush.BlendPositions[1] != NULL))
    {
        flags |= GDIP_BRUSHFLAGS_BLENDFACTORS1;
    }

    if ((DeviceBrush.BlendCounts[2] > 1) && (DeviceBrush.BlendFactors[2] != NULL) && (DeviceBrush.BlendPositions[2] != NULL))
    {
        flags |= GDIP_BRUSHFLAGS_BLENDFACTORS2;
    }

    TriangleGradientBrushData   brushData;
    brushData.Type      = DeviceBrush.Type;
    brushData.Flags     = flags;
    brushData.Wrap      = DeviceBrush.Wrap;
    brushData.Points[0] = DeviceBrush.Points[0];
    brushData.Points[1] = DeviceBrush.Points[1];
    brushData.Points[2] = DeviceBrush.Points[2];
    brushData.Color0    = DeviceBrush.Colors[0].GetValue();
    brushData.Color1    = DeviceBrush.Colors[1].GetValue();
    brushData.Color2    = DeviceBrush.Colors[2].GetValue();
    stream->Write(&brushData, sizeof(brushData), NULL);

    if (flags & GDIP_BRUSHFLAGS_TRANSFORM)
    {
        DeviceBrush.Xform.WriteMatrix(stream);
    }

    if (flags & GDIP_BRUSHFLAGS_BLENDFACTORS0)
    {
        INT     realSize = DeviceBrush.BlendCounts[0] * sizeof(REAL);

        stream->Write(&DeviceBrush.BlendCounts[0], sizeof(INT32), NULL);
        stream->Write(DeviceBrush.BlendPositions[0], realSize, NULL);
        stream->Write(DeviceBrush.BlendFactors[0], realSize, NULL);
    }

    if (flags & GDIP_BRUSHFLAGS_BLENDFACTORS1)
    {
        INT     realSize = DeviceBrush.BlendCounts[1] * sizeof(REAL);

        stream->Write(&DeviceBrush.BlendCounts[1], sizeof(INT32), NULL);
        stream->Write(DeviceBrush.BlendPositions[1], realSize, NULL);
        stream->Write(DeviceBrush.BlendFactors[1], realSize, NULL);
    }

    if (flags & GDIP_BRUSHFLAGS_BLENDFACTORS2)
    {
        INT     realSize = DeviceBrush.BlendCounts[2] * sizeof(REAL);

        stream->Write(&DeviceBrush.BlendCounts[2], sizeof(INT32), NULL);
        stream->Write(DeviceBrush.BlendPositions[2], realSize, NULL);
        stream->Write(DeviceBrush.BlendFactors[2], realSize, NULL);
    }

    return Ok;
}

UINT
GpTriangleGradient::GetDataSize() const
{
    UINT    size = sizeof(RectGradientBrushData);

    if (!DeviceBrush.Xform.IsIdentity())
    {
        size += GDIP_MATRIX_SIZE;
    }

    if ((DeviceBrush.BlendCounts[0] > 1) && (DeviceBrush.BlendFactors[0] != NULL) && (DeviceBrush.BlendPositions[0] != NULL))
    {
        size += sizeof(INT32) + ((sizeof(REAL) + sizeof(REAL)) * DeviceBrush.BlendCounts[0]);
    }

    if ((DeviceBrush.BlendCounts[1] > 1) && (DeviceBrush.BlendFactors[1] != NULL) && (DeviceBrush.BlendPositions[1] != NULL))
    {
        size += sizeof(INT32) + ((sizeof(REAL) + sizeof(REAL)) * DeviceBrush.BlendCounts[1]);
    }

    if ((DeviceBrush.BlendCounts[2] > 1) && (DeviceBrush.BlendFactors[2] != NULL) && (DeviceBrush.BlendPositions[2] != NULL))
    {
        size += sizeof(INT32) + ((sizeof(REAL) + sizeof(REAL)) * DeviceBrush.BlendCounts[2]);
    }

    return size;
}

/**************************************************************************\
*
* Function Description:
*
*   Read the brush object from memory.
*
* Arguments:
*
*   [IN] dataBuffer - the data that was read from the stream
*   [IN] size - the size of the data
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   4/26/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpTriangleGradient::SetData(
    const BYTE *        dataBuffer,
    UINT                size
    )
{
//    ASSERT ((GpBrushType)(((TriangleGradientBrushData *)dataBuffer)->Type) == BrushTypeTriangleGradient);

    if (dataBuffer == NULL)
    {
        WARNING(("dataBuffer is NULL"));
        return InvalidParameter;
    }

    if (size < sizeof(TriangleGradientBrushData))
    {
        WARNING(("size too small"));
        return InvalidParameter;
    }

    const TriangleGradientBrushData *   brushData;
    GpColor                             colors[3];

    brushData = reinterpret_cast<const TriangleGradientBrushData *>(dataBuffer);

    if (!brushData->MajorVersionMatches())
    {
        WARNING(("Version number mismatch"));
        return InvalidParameter;
    }

    colors[0].SetValue(brushData->Color0);
    colors[1].SetValue(brushData->Color1);
    colors[2].SetValue(brushData->Color2);

    InitializeBrush(brushData->Points, colors, (GpWrapMode) brushData->Wrap);

    DeviceBrush.IsGammaCorrected = ((brushData->Flags & GDIP_BRUSHFLAGS_ISGAMMACORRECTED) != 0);

    dataBuffer += sizeof(TriangleGradientBrushData);
    size       -= sizeof(TriangleGradientBrushData);

    if (brushData->Flags & GDIP_BRUSHFLAGS_TRANSFORM)
    {
        if (size < GDIP_MATRIX_SIZE)
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        DeviceBrush.Xform.SetMatrix((REAL *)dataBuffer);
        dataBuffer += GDIP_MATRIX_SIZE;
        size       -= GDIP_MATRIX_SIZE;
    }

    if (brushData->Flags & GDIP_BRUSHFLAGS_BLENDFACTORS0)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        UINT count = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        UINT realSize = count * sizeof(REAL);

        if (size < (2 * realSize))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        this->SetBlend0((REAL *)(dataBuffer + realSize), (REAL *)dataBuffer, count);
        dataBuffer += (2 * realSize);
        size       -= (2 * realSize);
    }

    if (brushData->Flags & GDIP_BRUSHFLAGS_BLENDFACTORS1)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        UINT count = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        UINT realSize = count * sizeof(REAL);

        if (size < (2 * realSize))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        this->SetBlend1((REAL *)(dataBuffer + realSize), (REAL *)dataBuffer, count);
        dataBuffer += (2 * realSize);
        size       -= (2 * realSize);
    }

    if (brushData->Flags & GDIP_BRUSHFLAGS_BLENDFACTORS2)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        UINT count = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        UINT realSize = count * sizeof(REAL);

        if (size < (2 * realSize))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        this->SetBlend2((REAL *)(dataBuffer + realSize), (REAL *)dataBuffer, count);
        dataBuffer += (2 * realSize);
        size       -= (2 * realSize);
    }

    UpdateUid();
    return Ok;
}

GpStatus
GpTriangleGradient::ColorAdjust(
    GpRecolor *             recolor,
    ColorAdjustType         type
    )
{
    if(!recolor)
        return InvalidParameter;

    if (type == ColorAdjustTypeDefault)
    {
        type = ColorAdjustTypeBrush;
    }

    ARGB    solidColor32[3];

    solidColor32[0] = DeviceBrush.Colors[0].GetValue();
    solidColor32[1] = DeviceBrush.Colors[1].GetValue();
    solidColor32[2] = DeviceBrush.Colors[2].GetValue();

    recolor->ColorAdjust(solidColor32, 3, type);

    DeviceBrush.Colors[0].SetValue(solidColor32[0]);
    DeviceBrush.Colors[1].SetValue(solidColor32[1]);
    DeviceBrush.Colors[2].SetValue(solidColor32[2]);

    UpdateUid();
    return Ok;
}
#endif

class PathGradientBrushData : public ObjectTypeData
{
public:
    INT32       Flags;
    INT32       Wrap;
    UINT32      CenterColor;
    GpPointF    CenterPoint;
    UINT32      SurroundingColorCount;
};

/**************************************************************************\
*
* Function Description:
*
*   Get the brush data.
*
* Arguments:
*
*   [IN] dataBuffer - fill this buffer with the data
*   [IN/OUT] size   - IN - size of buffer; OUT - number bytes written
*
* Return Value:
*
*   GpStatus - Ok or error code
*
* Created:
*
*   9/13/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpPathGradient::GetData(
    IStream *   stream
    ) const
{
    ASSERT (stream != NULL);

    UINT        pathSize              = 0;
    UINT        surroundingColorCount = DeviceBrush.OneSurroundColor ? 1 : DeviceBrush.Count;
    INT         flags                 = 0;
    GpPath *    path                  = GpPath::GetPath(DeviceBrush.Path);

    if (DeviceBrush.IsGammaCorrected)
    {
        flags |= GDIP_BRUSHFLAGS_ISGAMMACORRECTED;
    }

    if ((DeviceBrush.PointsPtr == NULL) && (path != NULL))
    {
        flags |= GDIP_BRUSHFLAGS_PATH;
        pathSize = path->GetDataSize();
        ASSERT((pathSize & 0x03) == 0);
    }

    if (!DeviceBrush.Xform.IsIdentity())
    {
        flags |= GDIP_BRUSHFLAGS_TRANSFORM;
    }

    // Note: can't have both blendFactors and presetColors at the same time
    if (DeviceBrush.UsesPresetColors && (DeviceBrush.BlendCounts[0] > 1) && (DeviceBrush.PresetColors != NULL) &&
        (DeviceBrush.BlendPositions[0] != NULL) && (DeviceBrush.BlendFactors[0] == NULL))
    {
        flags |= GDIP_BRUSHFLAGS_PRESETCOLORS;
    }

    if ((DeviceBrush.BlendCounts[0] > 1) && (DeviceBrush.BlendFactors[0] != NULL) && (DeviceBrush.BlendPositions[0] != NULL))
    {
        flags |= GDIP_BRUSHFLAGS_BLENDFACTORS;
    }

    if((DeviceBrush.FocusScaleX != 0) || (DeviceBrush.FocusScaleY != 0))
    {
        flags |= GDIP_BRUSHFLAGS_FOCUSSCALES;
    }

    PathGradientBrushData   brushData;
    brushData.Type                  = DeviceBrush.Type;
    brushData.Flags                 = flags;
    brushData.Wrap                  = DeviceBrush.Wrap;
    brushData.CenterColor           = DeviceBrush.Colors[0].GetValue();
    brushData.CenterPoint           = DeviceBrush.Points[0];
    brushData.SurroundingColorCount = surroundingColorCount;
    stream->Write(&brushData, sizeof(brushData), NULL);

    ARGB    argb;

    for (UINT i = 0; i < surroundingColorCount; i++)
    {
        argb = DeviceBrush.ColorsPtr[i].GetValue();
        stream->Write(&argb, sizeof(argb), NULL);
    }

    if (flags & GDIP_BRUSHFLAGS_PATH)
    {
        stream->Write(&pathSize, sizeof(INT32), NULL);
        path->GetData(stream);
    }
    else
    {
        INT     count = DeviceBrush.Count;

        if (DeviceBrush.PointsPtr == NULL)
        {
            count = 0;
        }
        stream->Write(&count, sizeof(INT32), NULL);
        if (count > 0)
        {
            INT pointsSize = count * sizeof(DeviceBrush.PointsPtr[0]);
            stream->Write(DeviceBrush.PointsPtr, pointsSize, NULL);
        }
    }

    if (flags & GDIP_BRUSHFLAGS_TRANSFORM)
    {
        DeviceBrush.Xform.WriteMatrix(stream);
    }

    if (flags & GDIP_BRUSHFLAGS_PRESETCOLORS)
    {
        INT     count = DeviceBrush.BlendCounts[0];
        INT     realSize = count * sizeof(REAL);
        INT     argbSize = count * sizeof(ARGB);

        REAL    *newPositions = (REAL*) GpMalloc(realSize);

        if (newPositions == NULL )
        {
            return OutOfMemory;
        }

        ARGB    *newARGB = (ARGB*) GpMalloc(argbSize);

        if (newARGB == NULL )
        {
            GpFree(newPositions);
            return OutOfMemory;
        }

        GpColor *newPresetColors = new GpColor[count];

        if (newPresetColors == NULL)
        {
            GpFree(newPositions);
            GpFree (newARGB);
            return OutOfMemory;
        }

        // Users will supply the preset colors as radial blend colors.
        // 0 position means the center location and 1 position means the
        // the outer edge.  These are stored inverted internally, so to get back
        // to the original user values, invert again.

        GetPresetBlend(newPresetColors, newPositions, count);

        for (INT i = 0; i < count; i++)
        {
            newARGB[i] = newPresetColors[i].GetValue();
        }

        stream->Write(&count, sizeof(INT32), NULL);
        stream->Write(newPositions, realSize, NULL);
        stream->Write(newARGB, argbSize, NULL);

        GpFree(newPositions);
        GpFree(newARGB);
        delete newPresetColors;
    }

    if (flags & GDIP_BRUSHFLAGS_BLENDFACTORS)
    {
        INT  count = DeviceBrush.BlendCounts[0];
        INT  realSize = count * sizeof(REAL);

        // Users will supply the blend factor as radial blend factors, and these are stored
        // with inverted values.  To get back the original user specified blend factors to
        // store, they must be inverted again.

        REAL *newFactors = (REAL*) GpMalloc(realSize);

        if (newFactors == NULL )
        {
            return OutOfMemory;
        }

        REAL *newPositions = (REAL*) GpMalloc(realSize);

        if (newPositions == NULL )
        {
            GpFree(newFactors);
            return OutOfMemory;
        }

        GetBlend(newFactors, newPositions, count);

        stream->Write(&count, sizeof(INT32), NULL);
        stream->Write(newPositions, realSize, NULL);
        stream->Write(newFactors, realSize, NULL);

        GpFree(newPositions);
        GpFree(newFactors);
    }

    if (flags & GDIP_BRUSHFLAGS_FOCUSSCALES)
    {
        INT     count = 2;
        REAL    focusScale[2];

        focusScale[0] = DeviceBrush.FocusScaleX;
        focusScale[1] = DeviceBrush.FocusScaleY;

        stream->Write(&count, sizeof(INT32), NULL);
        stream->Write(focusScale, 2 * sizeof(REAL), NULL);
    }

    return Ok;
}

UINT
GpPathGradient::GetDataSize() const
{
    UINT        pathSize;
    UINT        surroundingColorCount = DeviceBrush.OneSurroundColor ? 1 : DeviceBrush.Count;
    UINT        size                  = sizeof(PathGradientBrushData) +
                                        (surroundingColorCount * sizeof(ARGB));

    GpPath* path = static_cast<GpPath*> (DeviceBrush.Path);

    if (DeviceBrush.PointsPtr != NULL)
    {
        size += sizeof(INT32) + (DeviceBrush.Count * sizeof(DeviceBrush.PointsPtr[0]));
    }
    else if (path != NULL)
    {
        pathSize = path->GetDataSize();
        ASSERT((pathSize & 0x03) == 0);
        size += sizeof(INT32) + pathSize;
    }

    if (!DeviceBrush.Xform.IsIdentity())
    {
        size += GDIP_MATRIX_SIZE;
    }

    // Note: can't have both blendFactors and presetColors at the same time
    if (DeviceBrush.UsesPresetColors && (DeviceBrush.BlendCounts[0] > 1) && (DeviceBrush.PresetColors != NULL) &&
        (DeviceBrush.BlendPositions[0] != NULL) && (DeviceBrush.BlendFactors[0] == NULL))
    {
        size += sizeof(INT32) + ((sizeof(ARGB) + sizeof(REAL)) * DeviceBrush.BlendCounts[0]);
    }

    if ((DeviceBrush.BlendCounts[0] > 1) && (DeviceBrush.BlendFactors[0] != NULL) && (DeviceBrush.BlendPositions[0] != NULL))
    {
        size += sizeof(INT32) + ((sizeof(REAL) + sizeof(REAL)) * DeviceBrush.BlendCounts[0]);
    }

    if((DeviceBrush.FocusScaleX != 0) || (DeviceBrush.FocusScaleY != 0))
    {
        size += sizeof(INT32) + 2*sizeof(REAL);
    }

    return size;
}

/**************************************************************************\
*
* Function Description:
*
*   Read the brush object from memory.
*
* Arguments:
*
*   [IN] dataBuffer - the data that was read from the stream
*   [IN] size - the size of the data
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   4/26/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpPathGradient::SetData(
    const BYTE *        dataBuffer,
    UINT                size
    )
{
    ASSERT ((GpBrushType)(((PathGradientBrushData *)dataBuffer)->Type) == BrushTypePathGradient);

    if (dataBuffer == NULL)
    {
        WARNING(("dataBuffer is NULL"));
        return InvalidParameter;
    }

    if (size < sizeof(PathGradientBrushData))
    {
        WARNING(("size too small"));
        return InvalidParameter;
    }

    if (DeviceBrush.PointsPtr != NULL)
    {
        GpFree(DeviceBrush.PointsPtr);
        DeviceBrush.PointsPtr = NULL;
    }

    GpPath* path = static_cast<GpPath*> (DeviceBrush.Path);

    if (path != NULL)
    {
        delete path;
        path = NULL;
    }

    const PathGradientBrushData *   brushData;
    ARGB *                          surroundingColors;

    brushData = reinterpret_cast<const PathGradientBrushData *>(dataBuffer);

    if (!brushData->MajorVersionMatches())
    {
        WARNING(("Version number mismatch"));
        return InvalidParameter;
    }

    dataBuffer += sizeof(PathGradientBrushData);
    size       -= sizeof(PathGradientBrushData);

    if (size < (brushData->SurroundingColorCount * sizeof(ARGB)))
    {
        WARNING(("size too small"));
        return InvalidParameter;
    }

    surroundingColors = (ARGB *)dataBuffer;

    dataBuffer += (brushData->SurroundingColorCount * sizeof(ARGB));
    size       -= (brushData->SurroundingColorCount * sizeof(ARGB));

    if (brushData->Flags & GDIP_BRUSHFLAGS_PATH)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        UINT    pathSize = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        DefaultBrush();
        DeviceBrush.Wrap = (GpWrapMode) brushData->Wrap;

        if (size < pathSize)
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        path = new GpPath();
        if (path)
        {
            path->SetData(dataBuffer, pathSize);
        }

        DeviceBrush.Path = path;
        PrepareBrush();
        dataBuffer += pathSize;
        size       -= pathSize;
    }
    else
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        INT         count = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        if (size < (count * sizeof(GpPointF)))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        InitializeBrush((GpPointF *)dataBuffer, count, (GpWrapMode) brushData->Wrap);
        dataBuffer += (count * sizeof(GpPointF));
        size       -= (count * sizeof(GpPointF));
    }

    DeviceBrush.IsGammaCorrected = ((brushData->Flags & GDIP_BRUSHFLAGS_ISGAMMACORRECTED) != 0);

    SetCenterPoint(brushData->CenterPoint);
    SetCenterColor(GpColor(brushData->CenterColor));

    DeviceBrush.OneSurroundColor = (brushData->SurroundingColorCount == 1);

    if (DeviceBrush.ColorsPtr != NULL)
    {
        for (UINT32 i = 0; i < brushData->SurroundingColorCount; i++)
        {
            SetSurroundColor(GpColor(surroundingColors[i]), i);
        }
        
        // OneSurroundColor requires n colors and they are all set to the 
        // same value. This is a very weird requirement, but that's the way
        // it was written. One color simply isn't enough.
        
        if (i == 1)
        {
            for (i = 1; (INT)i < DeviceBrush.Count; i++)
            {
                DeviceBrush.ColorsPtr[i] = GpColor(surroundingColors[0]);
            }
        }
    }
    
    if (brushData->Flags & GDIP_BRUSHFLAGS_TRANSFORM)
    {
        if (size < GDIP_MATRIX_SIZE)
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        DeviceBrush.Xform.SetMatrix((REAL *)dataBuffer);
        dataBuffer += GDIP_MATRIX_SIZE;
        size       -= GDIP_MATRIX_SIZE;
    }

    if (brushData->Flags & GDIP_BRUSHFLAGS_PRESETCOLORS)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        UINT count = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        UINT realSize = count * sizeof(REAL);
        UINT argbSize = count * sizeof(ARGB);

        if (size < (realSize + argbSize))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        ARGB  *argbBuffer = (ARGB*)(dataBuffer + realSize);
        GpColor *colors = new GpColor[count];

        if (colors == NULL)
        {
            return OutOfMemory;
        }

        for (UINT i = 0; i < count; i++)
        {
            colors[i].SetValue(argbBuffer[i]);
        }

        this->SetPresetBlend(colors, (REAL *)dataBuffer, count);

        dataBuffer += (realSize + argbSize);
        size       -= (realSize + argbSize);

        delete colors;
    }

    if (brushData->Flags & GDIP_BRUSHFLAGS_BLENDFACTORS)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        UINT count = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        UINT realSize = count * sizeof(REAL);

        if (size < (2 * realSize))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        this->SetBlend((REAL *)(dataBuffer + realSize), (REAL *)dataBuffer, count);
        dataBuffer += (2 * realSize);
        size       -= (2 * realSize);
    }

    if (brushData->Flags & GDIP_BRUSHFLAGS_FOCUSSCALES)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        INT count = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        if (size < (2 * sizeof(REAL)))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        DeviceBrush.FocusScaleX = ((REAL *) dataBuffer)[0];
        DeviceBrush.FocusScaleY = ((REAL *) dataBuffer)[1];

        dataBuffer += (2 * sizeof(REAL));
        size       -= (2 * sizeof(REAL));
    }

    UpdateUid();
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Blend any transparent colors in this brush with white. Note that
*   colors are premultiplied, since they will become fully opaque.
*
* Arguments:
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
\**************************************************************************/

GpStatus GpPathGradient::BlendWithWhite()
{        
    DeviceBrush.Colors[0].SetValue(
        GpColor::ConvertToPremultiplied(DeviceBrush.Colors[0].GetValue()));
    DeviceBrush.Colors[0].BlendOpaqueWithWhite();
    
    if (DeviceBrush.UsesPresetColors)
    {
        GpColor color;
        
        for (INT i=0; i<DeviceBrush.BlendCounts[0]; i++)
        {
            color.SetValue(GpColor::ConvertToPremultiplied(DeviceBrush.PresetColors[i]));
            color.BlendOpaqueWithWhite();
            DeviceBrush.PresetColors[i] = color.GetValue();
        }
    }
    else
    {
        for (INT i=0; i<DeviceBrush.Count; i++)
        {
            DeviceBrush.ColorsPtr[i].SetValue(
                GpColor::ConvertToPremultiplied(DeviceBrush.ColorsPtr[i].GetValue()));
            DeviceBrush.ColorsPtr[i].BlendOpaqueWithWhite();
        }
    }
        
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Set the surround color.
*
* Arguments:
*
*   [IN] color - the color to set.
*   [IN] index - which color to set.
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
\**************************************************************************/

GpStatus GpPathGradient::SetSurroundColor(GpColor& color, INT index)
{
    if(index >= 0 && index < DeviceBrush.Count)
    {
        if(DeviceBrush.OneSurroundColor)
        {
            if(index == 0)
            {
                DeviceBrush.ColorsPtr[0] = color;
                
                // OneSurroundColor requires n colors and they are all set to the 
                // same value. This is a very weird requirement, but that's the way
                // it was written. One color simply isn't enough.
                
                for (INT i = 1; i < DeviceBrush.Count; i++)
                {
                    DeviceBrush.ColorsPtr[i] = GpColor(DeviceBrush.ColorsPtr[0]);
                }
                
                UpdateUid();
            }
            else
            {
                if(DeviceBrush.ColorsPtr[0].GetValue() !=
                   color.GetValue())
                {
                    DeviceBrush.OneSurroundColor = FALSE;
                    DeviceBrush.ColorsPtr[index] = color;
                    UpdateUid();
                }
            }
        }
        else
        {
            DeviceBrush.ColorsPtr[index] = color;
            UpdateUid();
        }

        return Ok;
    }
    else
        return InvalidParameter;
}

/**************************************************************************\
*
* Function Description:
*
*   Set the surround colors.
*
* Arguments:
*
*   [IN] color - the color to set.
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
\**************************************************************************/

GpStatus GpPathGradient::SetSurroundColors(const GpColor* colors)
{
    GpStatus status = InvalidParameter;

    ASSERT(DeviceBrush.Count > 0);

    if(IsValid() && colors && DeviceBrush.Count > 0)
    {
        GpMemcpy(
            DeviceBrush.ColorsPtr,
            colors,
            DeviceBrush.Count*sizeof(GpColor)
        );

        DeviceBrush.OneSurroundColor = TRUE;
        
        INT i = 1;
        ARGB value = colors[0].GetValue();

        while((i < DeviceBrush.Count) && (DeviceBrush.OneSurroundColor))
        {
            if(colors[i].GetValue() != value)
            {
                DeviceBrush.OneSurroundColor = FALSE;
            }

            i++;
        }

        UpdateUid();
        status = Ok;
    }

    return status;
}



GpStatus
GpPathGradient::ColorAdjust(
    GpRecolor *             recolor,
    ColorAdjustType         type
    )
{
    if(!recolor)
        return InvalidParameter;

    if (type == ColorAdjustTypeDefault)
    {
        type = ColorAdjustTypeBrush;
    }

    INT     surroundingColorCount = DeviceBrush.OneSurroundColor ? 1 : DeviceBrush.Count;

    if ((surroundingColorCount > 0) && (DeviceBrush.ColorsPtr != NULL))
    {
        ARGB    solidColor32[32];
        ARGB *  color32 = solidColor32;

        if (surroundingColorCount > 32)
        {
            color32 = new ARGB[surroundingColorCount];
            if (color32 == NULL)
            {
                return OutOfMemory;
            }
        }
        INT     i;

        for (i = 0; i < surroundingColorCount; i++)
        {
            color32[i] = DeviceBrush.ColorsPtr[i].GetValue();
        }

        recolor->ColorAdjust(color32, surroundingColorCount, type);

        for (i = 0; i < surroundingColorCount; i++)
        {
            DeviceBrush.ColorsPtr[i].SetValue(color32[i]);
        }

        if (color32 != solidColor32)
        {
            delete[] color32;
        }
    }

    if (DeviceBrush.UsesPresetColors && (DeviceBrush.BlendCounts[0] > 1) && (DeviceBrush.PresetColors != NULL))
    {
        recolor->ColorAdjust(DeviceBrush.PresetColors, DeviceBrush.BlendCounts[0], type);
    }

    UpdateUid();
    return Ok;
}

class HatchBrushData : public ObjectTypeData
{
public:
    INT32       Style;
    UINT32      ForeColor;
    UINT32      BackColor;
};

/**************************************************************************\
*
* Function Description:
*
*   Get the brush data.
*
* Arguments:
*
*   [IN] dataBuffer - fill this buffer with the data
*   [IN/OUT] size   - IN - size of buffer; OUT - number bytes written
*
* Return Value:
*
*   GpStatus - Ok or error code
*
* Created:
*
*   9/13/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpHatch::GetData(
    IStream *   stream
    ) const
{
    ASSERT (stream != NULL);

    HatchBrushData  brushData;
    brushData.Type      = DeviceBrush.Type;
    brushData.Style     = DeviceBrush.Style;
    brushData.ForeColor = DeviceBrush.Colors[0].GetValue();
    brushData.BackColor = DeviceBrush.Colors[1].GetValue();
    stream->Write(&brushData, sizeof(brushData), NULL);

    return Ok;
}

UINT
GpHatch::GetDataSize() const
{
    return sizeof(HatchBrushData);
}

/**************************************************************************\
*
* Function Description:
*
*   Read the brush object from memory.
*
* Arguments:
*
*   [IN] dataBuffer - the data that was read from the stream
*   [IN] size - the size of the data
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   4/26/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpHatch::SetData(
    const BYTE *        dataBuffer,
    UINT                size
    )
{
    ASSERT ((GpBrushType)(((HatchBrushData *)dataBuffer)->Type) == BrushTypeHatchFill);

    if (dataBuffer == NULL)
    {
        WARNING(("dataBuffer is NULL"));
        return InvalidParameter;
    }

    if (size < sizeof(HatchBrushData))
    {
        WARNING(("size too small"));
        return InvalidParameter;
    }

    const HatchBrushData *      brushData;

    brushData = reinterpret_cast<const HatchBrushData *>(dataBuffer);

    if (!brushData->MajorVersionMatches())
    {
        WARNING(("Version number mismatch"));
        return InvalidParameter;
    }

    InitializeBrush(static_cast<GpHatchStyle>(brushData->Style),
                    GpColor(brushData->ForeColor),
                    GpColor(brushData->BackColor));

    UpdateUid();
    return Ok;
}

GpStatus
GpHatch::ColorAdjust(
    GpRecolor *             recolor,
    ColorAdjustType         type
    )
{
    ASSERT(recolor != NULL);
    if (type == ColorAdjustTypeDefault)
    {
        type = ColorAdjustTypeBrush;
    }

    ARGB    solidColor32[2];

    solidColor32[0] = DeviceBrush.Colors[0].GetValue();

    //!!! bhouse: bug?
    //            seems that this should be BackColor ... I'm making the
    //            change!
//    solidColor32[1] = ForeColor.GetValue();
    solidColor32[1] = DeviceBrush.Colors[1].GetValue();

    recolor->ColorAdjust(solidColor32, 2, type);

    DeviceBrush.Colors[0].SetValue(solidColor32[0]);
    DeviceBrush.Colors[1].SetValue(solidColor32[1]);
    UpdateUid();
    return Ok;
}

static COLORREF
AverageColors(
    const GpColor *     colors,
    INT                 count
    )
{
    REAL    r = 0;
    REAL    g = 0;
    REAL    b = 0;

    if (count > 0)
    {
        for (INT i = 0; i < count; i++)
        {
            r += colors->GetRed();
            g += colors->GetGreen();
            b += colors->GetBlue();
        }

        r /= count;
        g /= count;
        b /= count;
    }

    INT     red   = GpRound(r);
    INT     green = GpRound(g);
    INT     blue  = GpRound(b);

    return RGB(red, green, blue);
}

static COLORREF
AverageColors(
    const GpColor &     color1,
    const GpColor &     color2
    )
{
    REAL    r = ((REAL)((INT)color1.GetRed()  + (INT)color2.GetRed()))   / 2.0f;
    REAL    g = ((REAL)((INT)color1.GetGreen()+ (INT)color2.GetGreen())) / 2.0f;
    REAL    b = ((REAL)((INT)color1.GetBlue() + (INT)color2.GetBlue()))  / 2.0f;

    INT     red   = GpRound(r);
    INT     green = GpRound(g);
    INT     blue  = GpRound(b);

    return RGB(red, green, blue);
}

COLORREF
ToCOLORREF(
    const DpBrush *     deviceBrush
    )
{
    switch (deviceBrush->Type)
    {
    default:
        ASSERT(0);
        // FALLTHRU

    case BrushTypeSolidColor:
        return deviceBrush->SolidColor.ToCOLORREF();

    case BrushTypeHatchFill:
        return AverageColors(deviceBrush->Colors[0],
                             deviceBrush->Colors[1]);

    case BrushTypeTextureFill:
        return RGB(0x80, 0x80, 0x80);

//    case BrushRectGrad:
    case BrushTypeLinearGradient:
        return AverageColors(deviceBrush->Colors, 4);
#if 0
    case BrushRadialGrad:
        return AverageColors(deviceBrush->Colors[0],
                             deviceBrush->Colors[1]);

    case BrushTriangleGrad:
        return AverageColors(deviceBrush->Colors, 3);
#endif

    case BrushTypePathGradient:
        return AverageColors(deviceBrush->Colors[0],
                             deviceBrush->ColorsPtr[0]);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\create.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998-1999  Microsoft Corporation
*
* Abstract:
*
*   Handle all the permutations of the creation and deletion of the
*   GpGraphics class.
*
* Revision History:
*
*   12/03/1998 andrewgo
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "..\Render\HtTables.hpp"

#include "printer.hpp"
#include "winspool.h"
#include "winbase.h"

/**************************************************************************\
*
* Function Description:
*
*   Updates the draw bounds of the graphics. Resets the clipping.
*
* Arguments:
*
*   [IN] x, y, width, height - Specifies the client drawable boundaries
*
* History:
*
*   03/30/2000 agodfrey
*       Created it.
*
\**************************************************************************/

VOID
GpGraphics::UpdateDrawBounds(
    INT x,
    INT y,
    INT width,
    INT height
    )
{
    DpContext *context  = Context;

    // Set up the surface bounds and the clip regions:

    SurfaceBounds.X = x;
    SurfaceBounds.Y = y;
    SurfaceBounds.Width = width;
    SurfaceBounds.Height = height;

    WindowClip.Set(x, y, width, height);
    context->VisibleClip.Set(x, y, width, height);

    // ContainerClip always contains the clipping for the container,
    // intersected with the WindowClip.  Currently, the container is
    // infinite, so just set it to the WindowClip.
    context->ContainerClip.Set(x, y, width, height);

    context->AppClip.SetInfinite();
}

/**************************************************************************\
*
* Function Description:
*
*   Resets the graphics state to its defaults.
*
* Arguments:
*
*   [IN] x, y, width, height - Specifies the client drawable boundaries
*
* History:
*
*   12/04/1998 andrewgo
*       Created it.
*
\**************************************************************************/

VOID
GpGraphics::ResetState(
    INT x,
    INT y,
    INT width,
    INT height
    )
{
    DpContext *context  = Context;

    context->CompositingMode    = CompositingModeSourceOver;
    context->CompositingQuality = CompositingQualityDefault;
    context->AntiAliasMode      = FALSE;
    context->TextRenderHint     = TextRenderingHintSystemDefault;
    context->TextContrast       = DEFAULT_TEXT_CONTRAST;
    context->FilterType         = InterpolationModeDefaultInternal;
    context->PixelOffset        = PixelOffsetModeDefault;
    context->InverseOk          = FALSE;
    context->WorldToPage.Reset();
    context->ContainerToDevice.Reset();
    this->SetPageTransform(UnitDisplay, 1.0f);  // updates the matrix

    UpdateDrawBounds(x, y, width, height);
}

/**************************************************************************\
*
* Function Description:
*
*   Get the drawing bounds of a DC. Only intended for use by
*   GpGraphics::GpGraphics(HWND, HDC).
*
* Arguments:
*
*   [IN]  hdc  - Specifies the DC
*   [OUT] rect - The returned client rectangle.
*
* Return Value:
*
*   Status code
*
* Notes:
*
*   See bug #93012. We used to just call GetClipBox, convert to device
*   coordinates, then boost the rectangle by one pixel on each side to cover
*   rounding error. But this was causing AV's - we really do need the exact
*   client rectangle.
*
*   But we need good perf in common cases. So we do a two-step process
*   - check if the transform is such that there won't be rounding error
*   (and simply use GetClipBox if so).
*   Otherwise, save the DC, reset the transform, and then query.
*
*   I tried an alternative - calling LPtoDP on 3 points to infer the transform
*   (as we do in InheritAppClippingAndTransform).
*   But because of rounding, and made worse by
*   NT bug #133322 (in the old NT RAID), it's nearly impossible
*   to infer the transform unambiguously. The particularly bad case is
*   when the world-to-device transform is a shrink, but the scale factor
*   is very close to 1. We'd decide it was a one-to-one transform, but it
*   would be susceptible to bug #133322.
*
*   So, to round off this novel: We're using a much simpler approach,
*   which restricts the cases in which we can use the fast method, but
*   should be ok.
*
* Notes:
*
*   This should really be a member of DpContext (bug #98174).
*
* History:
*
*   03/28/2000 agodfrey
*       Created it.
*
\**************************************************************************/

#if 0   // not used
GpStatus
GpGraphics::GetDCDrawBounds(
    HDC hdc,
    RECT *rect
    )
{
    BOOL hackResetClipping = FALSE;

    // Check if the transform is translation-only. If it is, we can avoid the
    // expense of cleaning the DC. GetGraphicsMode and GetMapMode are both
    // handled in user mode on NT.

    if (   (GetGraphicsMode(hdc) != GM_COMPATIBLE)
        || (GetMapMode(hdc) != MM_TEXT))
    {
        // Clean the DC, to set the transform back to translation-only.

        ASSERT(Context->SaveDc == 0);

        Context->SaveDc = ::SaveDC(hdc);
        if (!Context->SaveDc)
        {
            return GenericError;
        }

        // CleanTheHdc shouldn't be resetting the clipping, but it does,
        // which messes up GetClipBox below.
        // So until bug #99338 is resolved, we must work around it.

        hackResetClipping = TRUE;
        Context->CleanTheHdc(hdc, FALSE);
    }

    // The code above is necessary because GetClipBox returns
    // logical coordinates, but we want device coordinates.
    // By this point, we've made sure that the transform is translation-only.

    if (GetClipBox(hdc, rect) == ERROR)
    {
        return GenericError;
    }

    // See bug #99338. We must reset the clipping, because that's what
    // CleanTheHdc normally does, and apparently some of our code relies on it.
    // If #99338 is resolved as suggested, this should go away.

    if (hackResetClipping)
    {
        SelectClipRgn(hdc, NULL);
    }

    #if DBG
        // Save the world-coordinate rectangle.

        RECT checkRect = *rect;
    #endif

    // Convert to device coordinates.
    if (!LPtoDP(hdc, reinterpret_cast<POINT *>(rect), 2))
    {
        return GenericError;
    }

    // NT can sometimes return poorly-ordered rectangles,
    // but I don't think this applies to translation-only tranforms.

    ASSERT(   (rect->left <= rect->right)
           && (rect->top  <= rect->bottom));

    // Verify that the transform was translation-only.
    // Note that this sanity check could fail to catch some transforms
    // which are 'almost' translation-only. But ask me if I care.

    ASSERT(   (  (rect->right      - rect->left)
              == (checkRect.right  - checkRect.left))
           && (  (rect->bottom     - rect->top)
              == (checkRect.bottom - checkRect.top)));

    return Ok;
}
#endif

/**************************************************************************\
*
* Function Description:
*
*   Create a GpGraphics class from a window handle.
*
*   The advantage of this call over that of GetFromHdc is that
*   it can avoid the (slow) process of cleaning the DC.
*
*   NOTE: This does not provide BeginPaint/EndPaint functionality, so
*         the app will still have to call BeginPaint/EndPaint in its
*         WM_PAINT call.
*
* Arguments:
*
*   [IN] hwnd - Specifies the window
*
* Return Value:
*
*   NULL if failure (such as with an invalid hwnd).
*
* History:
*
*   12/04/1998 andrewgo
*       Created it.
*
\**************************************************************************/

GpGraphics::GpGraphics(
    HWND hwnd,
    HDC hdc,
    INT clientWidth,
    INT clientHeight,
    HdcIcmMode icmMode,
    BOOL gdiLayered
    ) : BottomContext((hwnd != NULL) ||
                      (GetDeviceCaps(hdc, TECHNOLOGY) == DT_RASDISPLAY))
{
    ASSERT((hdc != NULL) || (hwnd != NULL));

    //User doesn't have any protection against negative client areas so we 
    //should consider them to be valid although empty.
    clientWidth = max(clientWidth, 0);
    clientHeight = max(clientHeight, 0);
    
    SetValid(TRUE);

    Context = &BottomContext;

    Type = GraphicsScreen;
    Metafile = NULL;
    DownLevel = FALSE;
    Printer = FALSE;
    LockedByGetDC = 0;
    Driver = Globals::DesktopDriver;
    Surface = Globals::DesktopSurface;
    Device = Globals::DesktopDevice;
    GdipBitmap = NULL;
    CreatedDevice = FALSE;

    // We don't do GetDC(hwnd) here and store that here because,
    // among other things, we don't want to hit the cached DC
    // limit on Win9x:

    Context->Hdc = hdc;
    Context->Hwnd = hwnd;
    Context->IcmMode = icmMode;
    Context->GdiLayered = gdiLayered;

    HDC tempHdc = (hdc != NULL) ? hdc : Globals::DesktopDevice->DeviceHdc;

    if (GetDeviceCaps(tempHdc, BITSPIXEL) <= 8)
    {
        Context->PaletteMap = new EpPaletteMap(tempHdc);

        if (!Context->PaletteMap ||
            !Context->PaletteMap->IsValid())
        {
             WARNING(("Unable to compute palette translation vector"));
             SetValid(FALSE);
             return;
        }
        
        Context->PaletteMap->SetUniqueness(Globals::PaletteChangeCount);
    }

    ResetState(0, 0, clientWidth, clientHeight);

    // Now inherit state from the HDC:

    if (hwnd == NULL)
    {
        // In addition to extracting the HDC's transform state, this
        // will also extract app-specified clipping and combine it
        // with our other clipping state:

        if (IsValid())
        {
            SetValid(InheritAppClippingAndTransform(hdc) == Ok);
        }

        // Check the ICM Mode on the hdc - The ICM state in the HDC
        // passed in should override the flag setting.
        // IcmModeOn -> screen rendering will avoid using the
        // DCI codepath and instead render using GDI with the ICM enabled
        // HDC.

        if(::SetICMMode(hdc, ICM_QUERY)==ICM_ON)
        {
            Context->IcmMode = IcmModeOn;
        }
        else
        {
            // If the ICM mode is off or we failed somehow to query
            // the ICM mode, then set it to OFF.

            Context->IcmMode = IcmModeOff;
        }
    }
    else    // non-NULL hwnd
    {
        // Since the window could have CS_OWNDC style, we still have to
        // inherit from it.
        HDC hdc = ::GetDC(hwnd);

        if (hdc != NULL)
        {
            if (IsValid())
            {
                SetValid(InheritAppClippingAndTransform(hdc) == Ok);
            }

            ::ReleaseDC(hwnd, hdc);
        }
    }
}

/******************************Public*Routine******************************\
*
* Function Description:
*
*   Create a GpGraphics class from a DpBitmap.
*
* Arguments:
*
*   [IN] surface - Specifies the DpBitmap
*
* Return Value:
*
*   NULL if failure
*
\**************************************************************************/

GpGraphics::GpGraphics(DpBitmap * surface)
    : BottomContext(surface->IsDisplay)
{
    Surface                     = surface;
    BottomContext.ContainerDpiX = surface->DpiX;
    BottomContext.ContainerDpiY = surface->DpiY;
    Context                     = &BottomContext;
    Metafile                    = NULL;
    DownLevel                   = FALSE;
    Printer                     = FALSE;
    PrintInit                   = NULL;
    LockedByGetDC               = 0;
    CreatedDevice               = FALSE;
    GdipBitmap                  = NULL;
    Device                      = Globals::DesktopDevice;

    // Fail the creation of the destination if EpAlphaBlender
    // cannot convert to the DpBitmap pixel format.
    // The only reason to create a graphics around a bitmap is to be
    // able to draw onto it. If we can't convert the format to it,
    // we can't draw on it.

    if( (surface->Type != DpBitmap::GPBITMAP) ||
        (EpAlphaBlender::IsSupportedPixelFormat(surface->PixelFormat) &&
         surface->PixelFormat != PixelFormat8bppIndexed))
    {
        SetValid(TRUE);
    }
    else
    {
        SetValid(FALSE);
    }
}

/******************************Public*Routine******************************\
*
* Function Description:
*
*   Check whether the HWND has windows layering set.
*
* Arguments:
*
*   [IN] hwnd - Specifies the HWND
*
*   [OUT] isLayeredWindow - Points to BOOL that returns layering property
*
* Return Value:
*
*   FALSE if failure.
*
\**************************************************************************/

BOOL
CheckWindowsLayering(
    HWND hwnd,
    BOOL *isLayered
    )
{
    BOOL bRet = TRUE;

    // Assume no layering.

    *isLayered = FALSE;

    // Layering is only supported on NT5 or better.

    if ((Globals::IsNt) && (Globals::OsVer.dwMajorVersion >= 5)
        && (Globals::GetWindowInfoFunction))
    {
        WINDOWINFO wndInfo;
        
        // Initialize the structure with the appropriate size.
        
        GpMemset(&wndInfo, 0, sizeof(WINDOWINFO));
        wndInfo.cbSize = sizeof(WINDOWINFO);

        // NTRAID#NTBUG9-385929-2001/05/05-asecchia
        // See JasonSch's comments in the bug report.
        // Perf [agodfrey]: JStall pointed out that GetWindowInfo is very
        // slow (he quoted 2,700,000 clocks). Much better would be
        // GetWindowLong(hwnd, GWL_EXSTYLE).
        
        if (Globals::GetWindowInfoFunction(hwnd, &wndInfo))
        {
            *isLayered = ((wndInfo.dwExStyle & WS_EX_LAYERED) != 0);

            // An app using layered windows might only have the property set
            // on the topmost or root window.  So if we didn't find the
            // layered property on the window itself, need to check the root
            // window.

            if ((!*isLayered) && (Globals::GetAncestorFunction))
            {
                HWND hwndRoot = Globals::GetAncestorFunction(hwnd, GA_ROOT);

                // It's OK for GetAncestor to fail, which indicates that
                // hwnd is already the top level window.  If it succeeds,
                // then hwnd is a child window and we need to check the
                // root for layering.

                if (hwndRoot)
                {
                    // Perf [agodfrey]: Ditto here - GetWindowLong is better.

                    if (Globals::GetWindowInfoFunction(hwndRoot, &wndInfo))
                    {
                        *isLayered = ((wndInfo.dwExStyle & WS_EX_LAYERED) != 0);
                    }
                    else
                    {
                        WARNING(("GetWindowInfo failed"));
                        bRet = FALSE;
                    }
                }
            }
        }
        else
        {
            WARNING(("GetWindowInfo failed"));
            bRet = FALSE;
        }
    }

    return bRet;
}

/******************************Public*Routine******************************\
*
* Function Description:
*
*   Create a GpGraphics for a window.
*
* Arguments:
*
*   [IN] hwnd - Specifies the window
*
*   [IN] icmMode - Specifies the GDI ICM mode associated with this
*
* Return Value:
*
*   NULL if failure.
*
\**************************************************************************/

GpGraphics*
GpGraphics::GetFromHwnd(
    HWND        hwnd,
    HdcIcmMode  icmMode
    )
{
    // If hwnd is NULL, caller really meant that desktop
    // window should be used (Windows convention treats NULL hwnd
    // as a reference to desktop window).

    if (hwnd == NULL)
    {
        hwnd = GetDesktopWindow();
        ASSERT(hwnd != NULL);
    }

    RECT    rect;

    // Check if hwnd has layering enabled.  Need to let GpGraphics know
    // about it.  Only on NT5 or better.  Also note that GetWindowInfo
    // is only on NT4SP3 (or later) or Win98 (or later).

    BOOL isLayeredWindow;

    if (!CheckWindowsLayering(hwnd, &isLayeredWindow))
    {
        WARNING(("CheckWindowsLayering failed"));
        return NULL;
    }

    // GetClientRect is nice and fast (entirely user-mode on NT).

    if (::GetClientRect(hwnd, &rect))
    {
        ASSERT((rect.top == 0) && (rect.left == 0));

        GpGraphics *g = new GpGraphics(hwnd, NULL, rect.right, rect.bottom,
                                       icmMode, isLayeredWindow);
        CheckValid(g);
        return g;
    }
    else
    {
        WARNING(("GetClientRect failed"));
    }
    return NULL;
}

/******************************Public*Routine******************************\
*
* Function Description:
*
*   Create a GpGraphics for a screen DC.
*
* Arguments:
*
*   [IN] hdc - Specifies the DC
*
* Return Value:
*
*   NULL if failure.
*
\**************************************************************************/

GpGraphics*
GpGraphics::GetFromGdiScreenDC(
    HDC     hdc
    )
{
    // If hdc is NULL, caller really meant that desktop
    // window should be used (Windows convention treats NULL hwnd
    // as a reference to desktop window).

    if (hdc == NULL)
    {
        return GpGraphics::GetFromHwnd(NULL);
    }

    ASSERT(GetDCType(hdc) == OBJ_DC);

    HWND    hwnd = WindowFromDC(hdc);

    if (hwnd != NULL)
    {
        RECT    windowRect;
        POINT   dcOrg;

        // Check if hwnd has layering enabled.  Need to let GpGraphics know
        // about it.  Only on NT5 or better.  Also note that GetWindowInfo
        // is only on NT4SP3 (or later) or Win98 (or later).

        BOOL isLayeredWindow;

        if (!CheckWindowsLayering(hwnd, &isLayeredWindow))
        {
            WARNING(("CheckWindowsLayering failed"));
            return NULL;
        }

        // If the user did a GetWindowFromDC call, then they want to be
        // able to draw to the entire window, not just to the client area.
        // In that case we use the WindowRect for the surface size, instead
        // of using the ClientRect.  We determine this by seeing where the
        // DC origin is (the window rect or the client rect).

        if (::GetWindowRect(hwnd, &windowRect))
        {
            if (::GetDCOrgEx(hdc, &dcOrg))
            {
                if ((dcOrg.x == windowRect.left) && (dcOrg.y == windowRect.top))
                {
                    windowRect.right  -= windowRect.left;
                    windowRect.bottom -= windowRect.top;

                    GpGraphics *g = new GpGraphics(NULL,
                                                   hdc,
                                                   windowRect.right,
                                                   windowRect.bottom,
                                                   IcmModeOff,
                                                   isLayeredWindow);

                    CheckValid(g);
                    return g;
                }

                RECT    clientRect;

                // GetClientRect is nice and fast (entirely user-mode on NT).
                if (::GetClientRect(hwnd, &clientRect))
                {
                    ASSERT((clientRect.top == 0) && (clientRect.left == 0));

                    GpGraphics *g = new GpGraphics(NULL,
                                                   hdc,
                                                   clientRect.right,
                                                   clientRect.bottom,
                                                   IcmModeOff,
                                                   isLayeredWindow);

                    CheckValid(g);
                    return g;
                }
                else
                {
                    WARNING(("GetClientRect failed"));
                }
            }
            else
            {
                WARNING(("GetDCOrgEx failed"));
            }
        }
        else
        {
            WARNING(("GetWindowRect failed"));
        }
    }
    else    // WindowFromDC failed
    {
        // The client must have used CreateDC("DISPLAY") to get this hdc,
        // so we'll use the full bounds of the screen to create the graphics.

        INT     screenWidth;
        INT     screenHeight;

        screenWidth  = ::GetDeviceCaps(hdc, HORZRES);
        screenHeight = ::GetDeviceCaps(hdc, VERTRES);

        if ((screenWidth > 0) && (screenHeight > 0))
        {
            GpGraphics *g = new GpGraphics(NULL, hdc, screenWidth, screenHeight);
            CheckValid(g);
            return g;
        }
    }
    return NULL;
}

/**************************************************************************\
*
* Function Description:
*
*   Set the Graphics container transform to copy the transform set in
*   the DC.
*
*   NOTE: This function will be called a lot, and is therefore rather
*         performance critical.  Do not add gratuitous GDI or GDI+
*         calls!
*
* Arguments:
*
*   [IN] hdc - Specifies the DC to be copied
*
* Notes:
*
*   This should really be a member of DpContext (bug #98174).
*
* Return Value:
*
*   Ok if successful
*
* History:
*
*   12/04/1998 andrewgo
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::InheritAppClippingAndTransform(
    HDC hdc
    )
{
    POINT points[3];
    GpPointF destPoints[3];
    GpRectF srcRect;
    GpRectF destRect;
    GpStatus infer = GenericError;
    GpStatus status;
    BYTE stackBuffer[1024];

    // It would take a lot of time to call all the Win32 APIs to query
    // the transform: we would minimally have to call GetMapMode,
    // GetWindowOrgEx, and GetViewportOrgEx; and maximally also have to
    // call GetWorldTransform, GetViewportExtEx, and GetWindowExtEx.
    //
    // We cheat a little by making a single call to LPtoDP with a
    // parallelogram, and then inferring the result.  Note that we do
    // run the risk of some error, and on Win9x of overflow, since Win9x
    // only supports 16-bit coordinates.  To counteract this, we try to
    // choose large values that won't overflow.

    // There is a common scenario when LPtoDP will overflow returning
    // bad saturated values.  In printing to high DPI devices to avoid
    // overflow on Win9x, apps will use a large translate in the
    // window org to reposition the graphics.  In such cases, we do
    // the expensive work of determining the real WorldToDevice.
    if (!Globals::IsNt && Context->ContainerDpiX > 600.0f) 
    {
        INT mapMode = GetMapMode(hdc);

        if (mapMode == MM_ANISOTROPIC ||
            mapMode == MM_ISOTROPIC) 
        {
            POINT viewOrg, windOrg;
            GetViewportOrgEx(hdc, &viewOrg);
            GetWindowOrgEx(hdc, &windOrg);

            SIZE viewExt, windExt;
            GetViewportExtEx(hdc, &viewExt);
            GetWindowExtEx(hdc, &windExt);

            GpRectF windRect(TOREAL(windOrg.x), TOREAL(windOrg.y), 
                             TOREAL(windExt.cx), TOREAL(windExt.cy));
            GpRectF viewRect(TOREAL(viewOrg.x), TOREAL(viewOrg.y),
                             TOREAL(viewExt.cx), TOREAL(viewExt.cy));

            infer = Context->ContainerToDevice.InferAffineMatrix(viewRect,
                                                                 windRect);
        }
    }
    
    if (infer != Ok)
    {
        points[0].x = 0;
        points[0].y = 0;
        points[1].x = 8192;
        points[1].y = 0;
        points[2].x = 0;
        points[2].y = 8192;

        if (!LPtoDP(hdc, points, 3))
            return(GenericError);

        srcRect.X = TOREAL(0.0);
        srcRect.Y = TOREAL(0.0);
        srcRect.Width = TOREAL(8192.0);
        srcRect.Height = TOREAL(8192.0);

        if ((points[0].x == points[2].x) && (points[0].y == points[1].y))
        {
            // Win9x doesn't support rotation, and even on NT it will be
            // pretty rare.  Having a special-case like this for scaling
            // saves us some work in 'InferAffineMatrix':

            destRect.X = LTOF(points[0].x);
            destRect.Y = LTOF(points[0].y);
            destRect.Width = LTOF(points[1].x - points[0].x);
            destRect.Height = LTOF(points[2].y - points[0].y);

            infer = Context->ContainerToDevice.InferAffineMatrix(destRect,
                                                                 srcRect);
        }
        else
        {
            destPoints[0].X = LTOF(points[0].x);
            destPoints[0].Y = LTOF(points[0].y);
            destPoints[1].X = LTOF(points[1].x);
            destPoints[1].Y = LTOF(points[1].y);
            destPoints[2].X = LTOF(points[2].x);
            destPoints[2].Y = LTOF(points[2].y);

            infer = Context->ContainerToDevice.InferAffineMatrix(destPoints,
                                                                 srcRect);
        }
    }

    if (infer != Ok)
        return(infer);

    Context->UpdateWorldToDeviceMatrix();

    // Quickly get a GDI region object:

    HRGN regionHandle = GetCachedGdiRegion();
    if (regionHandle == NULL)
        return(OutOfMemory);

    // Verify that our cache is working properly, and we have a valid region:

    ASSERT(GetObjectTypeInternal(regionHandle) == OBJ_REGION);

    // No early-outs from here-in, because we have to cleanup:

    status = Ok;

    // Query the application clip region, if there is one.  The value of '1'
    // as a parameter is a magic value used by the metafile code on both
    // Win9x and NT to query the application clipping.  If a value of zero
    // is returned, there is no application-set clipping.
    //
    // Note that if we had passed in SYSRGN (a value of '4') instead of '1',
    // the result does NOT include the application level clipping.  (In other
    // words, SYSRGN is not equivalent to the Rao region, which is why we have
    // to explicitly query the application clipping here.)

    INT getResult = GetRandomRgn(hdc, regionHandle, 1);
    if (getResult == TRUE)
    {
        // If our stack buffer is big enough, get the clipping contents
        // in one gulp:

        INT newSize = GetRegionData(regionHandle,
                                    sizeof(stackBuffer),
                                    (RGNDATA*) &stackBuffer[0]);
        RGNDATA *regionBuffer = (RGNDATA*) &stackBuffer[0];

        // The spec says that  GetRegionData returns '1' in the event of
        // success, but NT returns the actual number of bytes written if
        // successful, and returns '0' if the buffer wasn't large enough:

        if ((newSize < 1) || (newSize > sizeof(stackBuffer)))
        {
            // Our stack buffer wasn't big enough.  Figure out the required
            // size:

            newSize = GetRegionData(regionHandle, 0, NULL);
            if (newSize > 1)
            {
                regionBuffer = (RGNDATA*) GpMalloc(newSize);
                if (regionBuffer == NULL)
                    return OutOfMemory;

                // Initialize to a decent result in the unlikely event of
                // failure of GetRegionData:

                regionBuffer->rdh.nCount = 0;

                GetRegionData(regionHandle, newSize, regionBuffer);
            }
        }

        // Set our GDI+ container clipping to be the same thing as the
        // GDI application clipping:

        status = Context->ContainerClip.Set((RECT*) &regionBuffer->Buffer[0],
                                            regionBuffer->rdh.nCount);

        if (status == Ok)
        {
            // the ContainerClip must always be intersected with the WindowClip
            status = Context->ContainerClip.And(&WindowClip);
        }

        if (status != Ok)
        {
            // use the best fall-back solution we can

            // guaranteed to succeed
            Context->ContainerClip.Set(&WindowClip);
        }

        // Now calculate the combined result:
        status = this->AndVisibleClip();

        // Free the temporary buffer if one was allocated:

        if (regionBuffer != (RGNDATA*) &stackBuffer[0])
            GpFree(regionBuffer);
    }

    ReleaseCachedGdiRegion(regionHandle);
    return(status);
}

/**************************************************************************\
*
* Function Description:
*
*   Create a GpGraphics class from a bitmap DC.
*
* History:
*
*   12/06/1998 andrewgo
*       Created it.
*
*   11/21/2000 minliu
*       Change the way GDI+ using the palette inside the DIBSection
*
\**************************************************************************/

GpGraphics*
GpGraphics::GetFromGdiBitmap(
    HDC hdc
    )
{
    ASSERT((hdc != NULL) && (GetDCType(hdc) == OBJ_MEMDC));

    HBITMAP hbitmap = (HBITMAP) GetCurrentObject(hdc, OBJ_BITMAP);
    if (hbitmap)
    {
        DpBitmap *bitmap = new DpBitmap(hdc);   // initializes Dpi
        if (CheckValid(bitmap))
        {
            INT             bitmapWidth;
            INT             bitmapHeight;
            EpPaletteMap*   pPaletteMap = NULL;
            DIBSECTION      dibInfo;
            INT             infoSize = GetObjectA(hbitmap, sizeof(dibInfo),
                                                  &dibInfo);
            BOOL            initialized = FALSE;
            BOOL            isHalftoneDIB = FALSE;
            DpDriver*       driver = NULL;
            ColorPalette*   pPalette = NULL;

            // WinNT/Win95 differences in GetObject:
            //
            // WinNT always returns the number of bytes filled, either
            // sizeof(BITMAP) or sizeof(DIBSECTION).
            //
            // Win95 always returns the original requested size (filling the
            // remainder with NULLs).  So if it is a DIBSECTION, we expect
            // dibInfo.dsBmih.biSize != 0; otherwise it is a BITMAP.

            if ( (infoSize == sizeof(DIBSECTION) )
               &&(Globals::IsNt || dibInfo.dsBmih.biSize != 0) )
            {
                // If this is an 8 bpp DIB, get its color palette and make a
                // matching palette map from our halftone palette.

                if ( dibInfo.dsBmih.biBitCount == 8 )
                {
                    // Create a new EpPaletteMap object.
                    // Note: If the colorTable is exactly the same as our
                    // GDI+ halftone palette, we will have a 1 to 1 color
                    // translation table in the EpPaletteMap object. If the
                    // color palette doesn't match exactly with our GDI+
                    // halftone palette and also within a certain
                    // mismatching range, we will have a translation table
                    // in EpPaletteMap object.
                    // Also, EpPaletteMap object will set up a IsVGAOnly()
                    // to tell us if GDI+ can do the halftone dithering or
                    // not (if IsVGAOnly() returns FALSE, it means GDI+ can
                    // do it
                    
                    // NOTE: EpPaletteMap may allocate storage for pPalette
                    // which must be freed with GpFree.

                    pPaletteMap = new EpPaletteMap(hdc, &pPalette, TRUE);

                    if ( pPaletteMap == NULL )
                    {
                        WARNING(("FromGdiBmp()-new EpPaletteMap failed"));
                    }
                    else if ( (pPaletteMap->IsValid() == TRUE)
                              &&(pPaletteMap->IsVGAOnly() == FALSE) )
                    {
                        ASSERT(pPalette != NULL);

                        // GDI+ can do the halftone dithering

                        isHalftoneDIB = TRUE;
                    }
                    else
                    {
                        // The supplied palette has insufficient
                        // matching colors for our halftone dithering,
                        // but we can still do VGA dithering. However,
                        // we'll use the GDI bitmap path instead, to
                        // be safe, since this is what we were doing
                        // before.

                        if (pPaletteMap->IsValid())
                        {
                            ASSERT(pPalette != NULL);

                            GpFree(pPalette);
                            pPalette = NULL;
                        }

                        delete pPaletteMap;
                        pPaletteMap = NULL;
                    }
                }// if ( dibInfo.dsBmih.biBitCount == 8 )

                // Up to this point, we will either have isHalftoneDIB = TRUE,
                // which means GDI+ can do the dithering or FALSE otherwise.

                if ((dibInfo.dsBmih.biBitCount > 8) || (isHalftoneDIB == TRUE) )
                {
                    initialized = bitmap->InitializeForDibsection(
                        hdc,
                        hbitmap,
                        Globals::DesktopDevice,
                        &dibInfo,
                        &bitmapWidth,
                        &bitmapHeight,
                        &driver
                    );
                }
            }// if it is a DIBSection

            if ( initialized == FALSE )
            {
                // Use GDI code path

                bitmapWidth = dibInfo.dsBm.bmWidth;
                bitmapHeight = dibInfo.dsBm.bmHeight;

                bitmap->InitializeForGdiBitmap(Globals::DesktopDevice,
                                               bitmapWidth,
                                               bitmapHeight);

                driver = Globals::GdiDriver;
            }

            GpGraphics *g = new GpGraphics(bitmap);

            if (g)
            {
                // NTRAID#NTBUG9-370409-2001/04/17-asecchia
                // This is error-prone code. The GpGraphics and the DpContext
                // objects should properly encapsulate their own construction.
                
                g->Type                 = GraphicsBitmap;
                g->Driver               = driver;
                g->Context->Hdc         = hdc;
                g->Context->PaletteMap  = NULL;
                g->Context->Palette     = NULL;

                g->ResetState(0, 0, bitmapWidth, bitmapHeight);

                if (g->InheritAppClippingAndTransform(hdc) == Ok)
                {
                    // If this is our special DIB, set the original palette in
                    // the Context so that later on when we doing alpha blend
                    // etc., we can use it to read pixel data from the
                    // DIBSection correctly

                    if ( isHalftoneDIB == TRUE )
                    {
                        g->Context->Palette = pPalette;
                        g->Context->PaletteMap = pPaletteMap;

                        return(g);
                    }
                    else if (GetDeviceCaps(hdc, BITSPIXEL) <= 8)
                    {
                        ASSERT(pPaletteMap == NULL);

                        pPaletteMap = new EpPaletteMap(hdc);

                        if ( NULL != pPaletteMap )
                        {    

                            pPaletteMap->SetUniqueness(
                                Globals::PaletteChangeCount
                            );

                            if ( pPaletteMap->IsValid() )
                            {
                                // Now that we know that the pPaletteMap is
                                // valid and we're returning a valid GpGraphics
                                // we can give up ownership of the pPaletteMap
                                // to the GpGraphics and return without 
                                // deleting it.
                                
                                g->Context->PaletteMap = pPaletteMap;
                                return(g);
                            }
                        }
                    }
                    else
                    {
                        // Higher than 8 bpp, this graphics object is fine

                        return(g);
                    }
                }// if (g->InheritAppClippingAndTransform(hdc) == Ok)

                delete g;
            }// if (g)
            else
            {
                delete bitmap;
            }

            // We fall into here only we failed to create the Graphics object

            if ( NULL != pPaletteMap )
            {
                delete pPaletteMap;
            }

            if ( NULL != pPalette )
            {
                GpFree(pPalette);
            }
        }// if (CheckValid(bitmap))
    }// if ( hbitmap )
    else
    {
        RIP(("GetCurrentObject failed"));
    }

    return(NULL);
}// GetFromGdiBitmap()

/**************************************************************************\
*
* Function Description:
*
*   Create a GpGraphics class from a GpBitmap.
*
* History:
*
*   09/22/1999 gilmanw
*       Created it.
*
\**************************************************************************/

GpGraphics*
GpGraphics::GetFromGdipBitmap(
    GpBitmap *      bitmap,
    ImageInfo *     imageInfo,
    EpScanBitmap *  scanBitmap,
    BOOL            isDisplay
    )
{
    DpBitmap *surface = new DpBitmap();

    if (CheckValid(surface))
    {
        // This call initializes the DPI and IsDisplay members
        surface->InitializeForGdipBitmap(imageInfo->Width, imageInfo->Height, imageInfo, scanBitmap, isDisplay);
        GpGraphics *g = new GpGraphics(surface);
        if (g)
        {
            g->Type         = GraphicsBitmap;
            g->Driver       = Globals::EngineDriver;
            g->Context->Hdc = NULL;
            g->GdipBitmap   = bitmap;

            g->ResetState(0, 0, imageInfo->Width, imageInfo->Height);

            return g;
        }
        else
        {
            delete surface;
        }
    }

    return(NULL);
}

/**************************************************************************\
*
* Function Description:
*
*   Create a GpGraphics class from a direct draw surface.
*
* History:
*
*   10/06/1999 bhouse
*       Created it.
*
\**************************************************************************/

GpGraphics*
GpGraphics::GetFromDirectDrawSurface(
    IDirectDrawSurface7 * surface
    )
{
    INT bitmapWidth;
    INT bitmapHeight;
    GpGraphics *g;
    DpDriver *driver;

    DpBitmap *bitmap = new DpBitmap();

    if (CheckValid(bitmap))
    {
        // Leave bitmap->IsDisplay and Dpi params at their default values.
        if( bitmap->InitializeForD3D(surface,
                                     &bitmapWidth,
                                     &bitmapHeight,
                                     &driver))
        {
            GpGraphics *g = new GpGraphics(bitmap);

            if (g)
            {
                g->Type         = GraphicsBitmap;
                g->Driver       = driver;
                g->Context->Hdc = NULL;

                g->ResetState(0, 0, bitmapWidth, bitmapHeight);

                return(g);
            }
            else
            {
                delete bitmap;
            }
        }
    }

    return(NULL);
}

/**************************************************************************\
*
* Function Description:
*
*   This should only be called by the GetFromHdc() for a printer DC.
*
* Arguments:
*
*
* Return Value:
*
*
* History:
*    6/1/1999 ericvan Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::StartPrinterEMF()
{
   IStream *stream = NULL;
   INT result;

   // Send escape to printer to determine if this supports the UNIDRV
   // escape codes.

   GDIPPRINTINIT printInit;
   printInit.dwSize = sizeof(GDIPPRINTINIT);

   // !! Query whether escape is supported first.

   result = ExtEscape(Context->Hdc,
                      GDIPLUS_UNI_INIT,
                      0,
                      NULL,
                      sizeof(GDIPPRINTINIT),
                      (LPSTR)&printInit);

   if (result<=0)
       return NotImplemented;


   // save printer data in structure

   PrintInit = new GDIPPRINTINIT;
   
   if(!PrintInit)
   {
       return OutOfMemory;
   }
   
   memcpy((LPVOID)PrintInit, (LPVOID)&printInit, sizeof(GDIPPRINTINIT));

   PrinterEMF = GlobalAlloc(GMEM_MOVEABLE, 1);

   if (!PrinterEMF)
   {
       return OutOfMemory;
   }

   if (CreateStreamOnHGlobal(PrinterEMF, FALSE, &stream) != S_OK)
   {
       GlobalFree(PrinterEMF);
       PrinterEMF = NULL;
       return Win32Error;
   }

   FPUStateSaver fpuState;

   PrinterMetafile = new GpMetafile(stream, Context->Hdc, EmfTypeEmfPlusOnly);

   stream->Release();

   if (!PrinterMetafile)
   {
      GlobalFree(PrinterEMF);
      PrinterEMF = NULL;
      return OutOfMemory;
   }

   PrinterGraphics = PrinterMetafile->GetGraphicsContext();

   Metafile = PrinterGraphics->Metafile;

   return Ok;
}

/**************************************************************************\
*
* Function Description:
*
* Arguments:
*
* Return Value:
*
* History:
*    6/1/1999 ericvan Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::EndPrinterEMF()
{
   LPVOID emfBlock;
   INT result = -1;
   GpStatus status;

   if (PrinterGraphics)
   {
       // end recording to metafile graphics context
       delete PrinterGraphics;
       PrinterGraphics = NULL;
   }

   // Disposing of metafile also Release() stream interface.
   if (PrinterMetafile)
   {
       PrinterMetafile->Dispose();
       PrinterMetafile = NULL;
       Metafile = NULL;
   }

   if (PrinterEMF)
   {
      emfBlock = GlobalLock(PrinterEMF);

      if (emfBlock)
         result = ExtEscape(Context->Hdc,
                            GDIPLUS_UNI_ESCAPE,
                            // This is a downcast on IA64, but I don't believe
                            // PrinterEMF will be bigger than MAXINT
                            (ULONG)GlobalSize(PrinterEMF),
                            (LPCSTR)emfBlock,
                            sizeof(GpStatus),
                            (LPSTR)&status);

      GlobalUnlock(PrinterEMF);
      GlobalFree(PrinterEMF);
      PrinterEMF = NULL;

      if (result>0)
         return status;
      else
         return Win32Error;

   }
   else
      return Ok;
}

/**************************************************************************\
*
* Function Description:
*
* Uses HDC and HANDLE for printer to determine the postscript level.  The
* caller must ensure this is a PS HDC so we don't waste our time.
*
* Arguments:
*
*  HDC - handle to device context for printer
*  HANDLE - handle to printer device (may be NULL)
*
* Return Value:
*
*  Postscript Level - (-1) if not found, must provide downlevel support
*
* History:
*    10/26/1999 ericvan Created it.
*
\**************************************************************************/

INT
GpGraphics::GetPostscriptLevel(HDC hDC, HANDLE hPrinter)
{
    // Place this code under the load library critical section.  We make
    // extensive use of Globals::variables and need protection.
    LoadLibraryCriticalSection llcs;

    INT feature = FEATURESETTING_PSLEVEL;

    INT level;

    if ((Globals::hCachedPrinter != 0) &&
        (Globals::hCachedPrinter == hPrinter))
    {
        return Globals::CachedPSLevel;
    }

    // !! Re-examine this, Nolan said he would add this to the HP ps driver
    //    so we may have this working on Win9x

    if (Globals::IsNt && Globals::OsVer.dwMajorVersion >= 5)
    {
        DWORD EscapeValue = POSTSCRIPT_IDENTIFY;

        if (ExtEscape(hDC,
                      QUERYESCSUPPORT,
                      sizeof(DWORD),
                      (LPSTR)&EscapeValue,
                      0,
                      NULL) != 0)
        {

           // must be in GDI centric mode to get PS feature settings...

           DWORD Mode = PSIDENT_GDICENTRIC;

           if (ExtEscape(hDC,
                         POSTSCRIPT_IDENTIFY,
                         sizeof(DWORD),
                         (LPSTR)&Mode,
                         0,
                         NULL)>0)
           {
               if (ExtEscape(hDC,
                             GET_PS_FEATURESETTING,
                             sizeof(INT),
                             (LPSTR)&feature,
                             sizeof(INT),
                             (LPSTR)&level)>0)
               {
                   Globals::hCachedPrinter = hPrinter;
                   Globals::CachedPSLevel = level;

                   return level;
               }
           }
        }
    }

    if (hPrinter == NULL)
        return -1;

    // get name of the PPD file.

    union
    {
        DRIVER_INFO_2A driverInfo;
        CHAR buftmp[1024];
    };
    DWORD size;

    // we require GetPrinterDriver() API to get the .PPD path+file.
    // unfortunately this API is buried in winspool.drv (112KB), so we
    // lazy load it here.

    if (Globals::WinspoolHandle == NULL)
    {
        Globals::WinspoolHandle = LoadLibraryA("winspool.drv");

        if (Globals::WinspoolHandle == NULL)
            return -1;

        Globals::GetPrinterDriverFunction = (WINSPOOLGETPRINTERDRIVERFUNCTION)
                                              GetProcAddress(
                                                     Globals::WinspoolHandle,
                                                     "GetPrinterDriverA");
    }

    if (Globals::GetPrinterDriverFunction == NULL)
        return -1;

    if (Globals::GetPrinterDriverFunction(hPrinter,
                          NULL,
                          2,
                          (BYTE*)&driverInfo,
                          1024,
                          &size) == 0)
        return -1;

    HANDLE hFile;

    hFile = CreateFileA(driverInfo.pDataFile,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if (hFile == INVALID_HANDLE_VALUE)
        return -1;

    // Obtain the file size
    //  NOTE: We don't support files larger than 4GB.

    DWORD sizeLow, sizeHigh;
    sizeLow = GetFileSize(hFile, &sizeHigh);

    // impose a 4GB limit (certainly reasonable)
    if (sizeLow == 0xffffffff || sizeHigh != 0)
    {
        CloseHandle(hFile);
        return -1;
    }

    // Map the file into memory

    HANDLE hFilemap;
    LPSTR fileview = NULL;

    hFilemap = CreateFileMappingA(hFile, NULL, PAGE_READONLY, 0, 0, NULL);

    if (hFilemap != NULL)
    {
         fileview = (LPSTR) MapViewOfFile(hFilemap, FILE_MAP_READ, 0, 0, 0);
         CloseHandle(hFilemap);
    }
    else
    {
         CloseHandle(hFile);
         return -1;
    }

    LPSTR buf = fileview;
    LPSTR topbuf = fileview + (sizeLow-16);

    // we actually expect the LanguageLevel to be early
    // in the file (likely in the first 2K of data).

    // !! What if this appears in comments (read starting at carriage returns?!

    level = -1;

    while (buf < topbuf)
    {
        if (*buf == 'L' &&
            GpMemcmp(buf, "LanguageLevel", 13) == 0)
        {
             while ((*buf < '0' || *buf > '9') && buf < topbuf)
                 buf++;

             CHAR ch = *buf;

             if (ch >= '0' && ch <= '9')
                 level = (INT)ch - (INT)'0';

             break;
        }
        buf++;
    }

    UnmapViewOfFile((LPCVOID)fileview);
    CloseHandle(hFile);

    Globals::hCachedPrinter = hPrinter;
    Globals::CachedPSLevel = level;

    return level;
}

/**************************************************************************\
*
* Function Description:
*
* Arguments:
*
* Return Value:
*
* History:
*    6/1/1999 ericvan Created it.
*
\**************************************************************************/

GpGraphics*
GpGraphics::GetFromGdiPrinterDC(
    HDC hdc,
    HANDLE hPrinter
    )
{
    ASSERT((hdc != NULL) &&
           ((GetDCType(hdc) == OBJ_DC) ||
            (GetDCType(hdc) == OBJ_ENHMETADC))&&
           (GetDeviceCaps(hdc, TECHNOLOGY) == DT_RASPRINTER));

    // !! Change to useNewPrinterCode when we've fully switched
    DriverPrint *driver = NULL;

    DpBitmap *bitmap = new DpBitmap(hdc);   // initializes Dpi
    if (CheckValid(bitmap))
    {
        GpPrinterDevice *pdevice;

        {   // FPU Sandbox for potentially unsafe FPU code.
            FPUStateSandbox fpsb;
            pdevice = new GpPrinterDevice(hdc);
        }   // FPU Sandbox for potentially unsafe FPU code.

        if (CheckValid(pdevice))
        {
            // we defer creating driver until we know which to create
            // change to use DIBSECTION instead of GDI operations

            // Check if this is a postscript printer
            CHAR strTech[30];
            strTech[0] = '\0';

            INT ScaleX;          // ratio of device DPI : capped DPI
            INT ScaleY;

            // It is a PostScript printer if POSTSCRIPT_PASSTHROUGH or
            // POSTSCRIPT_IGNORE is available.  For some reason querying
            // GETTECHNOLOGY for postscript fails in MS Publisher, it may
            // be because we are in GDI centric mode.

            int iWant1 = POSTSCRIPT_PASSTHROUGH;
            int iWant2 = POSTSCRIPT_IGNORE;

            BOOL postscript;
            {   // FPU Sandbox for potentially unsafe FPU code.
                FPUStateSandbox fpsb;
                postscript = (
                    (Escape(hdc, QUERYESCSUPPORT, sizeof(iWant1), (LPCSTR)&iWant1, NULL) != 0) || 
                    (Escape(hdc, QUERYESCSUPPORT, sizeof(iWant2), (LPCSTR)&iWant2, NULL) != 0));
            }   // FPU Sandbox for potentially unsafe FPU code.

            SIZEL szlDevice;

            szlDevice.cx = GetDeviceCaps(hdc, HORZRES);
            szlDevice.cy = GetDeviceCaps(hdc, VERTRES);

            // ScaleX and ScaleY should be power of two (2, 4, 8)

            if (bitmap->DpiX <= 100)
            {
                ScaleX = 1;
                ScaleY = 1;
            }
            else
            {
                if (bitmap->DpiX >= 1200)
                {
                    ScaleX = GpRound(TOREAL(bitmap->DpiX) / 200);
                    ScaleY = GpRound(TOREAL(bitmap->DpiY) / 200);
                }
                else
                {
                    ScaleX = 3;
                    ScaleY = 3;        // cap 600 to 200 dpi or 3:1
                }
            }

            // We no longer keep capped dpi -- we use the device dpi as
            // capped dpi so that the world to
            // device transformation is correct for the clipped region and
            // path transformation.  ScaleX and ScaleY are used to scale
            // the output rectangle region.

            bitmap->InitializeForPrinter(pdevice,
                                         szlDevice.cx,
                                         szlDevice.cy);

            GpGraphics *g = new GpGraphics(bitmap);
            if (g)
            {
                g->Printer               = TRUE;
                g->Context->Hdc          = hdc;
                g->Context->IsPrinter    = TRUE;

                // Note: Both 'Device' and 'Driver' are freed at
                // ~GpGraphics time when 'CreatedDevice' is set:

                g->PrinterMetafile = NULL;
                g->PrinterGraphics = NULL;
                g->PrinterEMF = NULL;

                if (postscript)
                {
                    g->Type = GraphicsBitmap;

                    INT level = GetPostscriptLevel(hdc, hPrinter);

                    driver = new DriverPS(pdevice, level);

                    // !! Should this stuff be shifted into some driver
                    //    initialization routine?!

                    // !! Interop - what about redefines or conflicts
                    //             (conflicts aren't likely, but are
                    //              theoretically possible with
                    //              GetDC/ReleaseDC)

                }
#if 0
                else if (g->StartPrinterEMF() == Ok) 
                {
                    g->Type = GraphicsMetafile;

                    RIP(("Setting CreatedDevice will free Driver"));

                    driver = NULL; new DriverMeta(pdevice);

                    // GDI has some optimization code to check the page for color
                    // content, if none is found, on play back, it sets the device
                    // as being monochrome.
                    //
                    // Unfortunately, since our stuff is encoded in escapes, we end up
                    // playing back in monochrome.  The work-around, is to call a GDI
                    // API that forces a color flag to be set in the EMF code.  A
                    // simple one is SetTextColor().

                    // !!! Might want to remove this SetTextColor stuff for version one:

                    COLORREF colorRef = GetTextColor(hdc);
                    SetTextColor(hdc, 0x00808080);
                    SetTextColor(hdc, colorRef);
                }
#endif
                else
                {
                    // We can't use escapes for optimization,
                    // Map to GDI HDC operations.

                    g->Type = GraphicsBitmap;

                    driver = new DriverNonPS(pdevice);
                }

                if (CheckValid(driver))
                {
                    g->Driver = driver;
                    g->Device = pdevice;

                    driver->ScaleX = ScaleX;
                    driver->ScaleY = ScaleY;

                    // check for supporting print clip escapes
                    // These may be supported on PCL as well as Postscript
                    DWORD EscapeValue1 = CLIP_TO_PATH;
                    DWORD EscapeValue2 = BEGIN_PATH;
                    DWORD EscapeValue3 = END_PATH;

                    // Although some PCL drivers support CLIP_TO_PATH we 
                    // currently disable their use due to some outstanding 
                    // bugs in HP and Lexmark PCL drivers.  See bug #182972
                    
                    {   // FPU Sandbox for potentially unsafe FPU code.
                        FPUStateSandbox fpsb;

                        driver->UseClipEscapes = postscript &&
                            (ExtEscape(hdc,
                                       QUERYESCSUPPORT,
                                       sizeof(DWORD),
                                       (LPSTR)&EscapeValue1,
                                       0,
                                       NULL) != 0) &&
                            (ExtEscape(hdc,
                                       QUERYESCSUPPORT,
                                       sizeof(DWORD),
                                       (LPSTR)&EscapeValue2,
                                       0,
                                       NULL) != 0) &&
                            (ExtEscape(hdc,
                                       QUERYESCSUPPORT,
                                       sizeof(DWORD),
                                       (LPSTR)&EscapeValue3,
                                       0,
                                       NULL) != 0);
                    }   // FPU Sandbox for potentially unsafe FPU code.

                    DWORD EscapeValue = CHECKJPEGFORMAT;

                    {   // FPU Sandbox for potentially unsafe FPU code.
                        FPUStateSandbox fpsb;
                        driver->SupportJPEGpassthrough = ExtEscape(
                            hdc,
                            QUERYESCSUPPORT,
                            sizeof(DWORD),
                            (LPSTR)&EscapeValue,
                            0,
                            NULL) != 0;
                    }   // FPU Sandbox for potentially unsafe FPU code.
                            
                    EscapeValue = CHECKPNGFORMAT;
                    {   // FPU Sandbox for potentially unsafe FPU code.
                        FPUStateSandbox fpsb;
                        driver->SupportPNGpassthrough = ExtEscape(
                            hdc,
                            QUERYESCSUPPORT,
                            sizeof(DWORD),
                            (LPSTR)&EscapeValue,
                            0,
                            NULL) != 0;
                    }   // FPU Sandbox for potentially unsafe FPU code.

                    driver->NumColors = GetDeviceCaps(hdc, NUMCOLORS);

                    driver->UseVDP = FALSE;

                    // !! VDP not supported in v1
                    //VDP_GetFormSupport(hdc,
                    //                       (WORD*)&(driver->SupportVDP));

                    g->CreatedDevice = TRUE;

                    g->ResetState(0, 0, szlDevice.cx, szlDevice.cy);

                    if (g->InheritAppClippingAndTransform(hdc) == Ok)
                    {
                        return(g);
                    }
                    else
                    {
                        // ~GpGraphics implicitly deletes bitmap, device, and driver
                        delete g;
                        return NULL;
                    }
                }

                delete g;

                delete pdevice;

                return NULL;
            }

            delete pdevice;
        }

        delete bitmap;
    }

    return NULL;
}

/**************************************************************************\
*
* Function Description:
*
*   This constructor is used internally for printer callback routine.
*
* Arguments:
*
*
* Return Value:
*
*
* History:
*    6/1/1999 ericvan Created it.
*
\**************************************************************************/

GpGraphics*
GpGraphics::GetFromHdcSurf(
    HDC           hdc,
    SURFOBJ*      surfObj,
    RECTL*        bandClip
    )
{
    static UINT16 PixelCount[] = { 1, 4, 8, 16, 24, 32 };

    INT width;
    INT height;
    GpGraphics* g;
    DpDriver *driver;

    // This is a weird surface.  It is a banded surface, so we set up a
    // clip and direct bits pointer.  We also have an HDC for it if we
    // decide to punt to GDI.

    DpBitmap *bitmap = new DpBitmap(hdc);   // initializes Dpi
    if (CheckValid(bitmap))
    {
        GpGraphics *g = new GpGraphics(bitmap);
        if (g)
        {
            width = GetDeviceCaps(hdc, HORZRES);
            height = GetDeviceCaps(hdc, VERTRES);

            // create DIB section for direct rendering of bits

            if (surfObj->iBitmapFormat < BMF_1BPP ||
                surfObj->iBitmapFormat > BMF_32BPP)
            {

InitializeHdcOnlyUse:
                // we don't support direct rendering to this type of
                // surface format.  Do everything through GDI HDC.

               driver = Globals::GdiDriver;

               bitmap->InitializeForGdiBitmap(Globals::DesktopDevice,
                                              width,
                                              height);


               g->Type         = GraphicsBitmap;
               g->Driver       = driver;
               g->Context->Hdc = hdc;

               g->ResetState(0, 0, 1, 1);
            }
            else
            {
               DIBSECTION dibSec;
               dibSec.dsBm.bmType = 0;
               dibSec.dsBm.bmWidth = surfObj->sizlBitmap.cx;

               if (surfObj->lDelta < 0)
               {
                  // bits pointer at top of frame buffer (scans down)

                  dibSec.dsBm.bmWidthBytes = -surfObj->lDelta;
                  dibSec.dsBm.bmHeight = -surfObj->sizlBitmap.cy;
               }
               else
               {
                  // bits pointer at base of frame buffer (scans up)

                  dibSec.dsBm.bmWidthBytes = surfObj->lDelta;
                  dibSec.dsBm.bmHeight = surfObj->sizlBitmap.cy;
               }

               dibSec.dsBm.bmPlanes = 1;
               dibSec.dsBm.bmBitsPixel = PixelCount[surfObj->iBitmapFormat-1];

               dibSec.dsBmih.biSize = sizeof(BITMAPINFOHEADER);
               dibSec.dsBmih.biWidth = width;
               dibSec.dsBmih.biHeight = height;
               dibSec.dsBmih.biPlanes = 1;
               dibSec.dsBmih.biBitCount = PixelCount[surfObj->iBitmapFormat-1];
               dibSec.dsBmih.biCompression = BI_BITFIELDS;
               dibSec.dsBmih.biSize = 0;

               dibSec.dsBitfields[0] = 0x000000FF;
               dibSec.dsBitfields[1] = 0x0000FF00;
               dibSec.dsBitfields[2] = 0x00FF0000;

               if (bitmap->InitializeForDibsection( hdc,
                                                    (HBITMAP) NULL,
                                                    Globals::DesktopDevice,
                                                    &dibSec,
                                                    &width,
                                                    &height,
                                                    &driver) == FALSE)
                                     goto InitializeHdcOnlyUse;

               // Init Valid now so later calls won't fail

               g->Type         = GraphicsBitmap;
               g->Driver       = driver;
               g->Context->Hdc = hdc;

               // How do we clip and map to correct band?
               // GDI has set the WorldToContainer transform to translate the
               // correct band to position (0,0) on the device surface.  So we
               // clip the size of the band relative to the surface.  The image
               // is mapped via the transform into this clipped region.

               // set visible client clip region for surface

               g->ResetState(0, 0,              // bandClip->left, bandClip->top,
                             bandClip->right - bandClip->left,
                             bandClip->bottom - bandClip->top);

               // Set the destination Graphics to represent device co-ordinates

               g->SetPageTransform(UnitPixel);

               if (g->InheritAppClippingAndTransform(hdc) == Ok)
               {
                   return(g);
               }
               else
               {
                   delete g;
               }
           }
       }
   }

   return(NULL);

}

GpGraphics*
GpGraphics::GetFromGdiEmfDC(
    HDC hdc
    )
{
    ASSERT (hdc != NULL);

    DpBitmap *bitmap = new DpBitmap(hdc);   // initializes Dpi
    if (CheckValid(bitmap))
    {
        bitmap->InitializeForMetafile(Globals::DesktopDevice);

        GpGraphics *g = new GpGraphics(bitmap);
        if (g)
        {
            g->Type                  = GraphicsMetafile;
            g->DownLevel             = TRUE;
            g->Driver                = Globals::MetaDriver;
            g->Context->Hdc          = hdc;
            g->Context->IsEmfPlusHdc = TRUE;

            g->ResetState(0, 0, 1, 1);

            // Override some state, as we don't want anything to be
            // clipped out of a metafile, unless there is clipping
            // in the hdc.

            g->WindowClip.SetInfinite();
            g->Context->ContainerClip.SetInfinite();
            g->Context->VisibleClip.SetInfinite();

            if (g->InheritAppClippingAndTransform(hdc) == Ok)
            {
                return g;
            }
            delete g;
        }
    }

    return NULL;
}

/**************************************************************************\
*
* Function Description:
*
*
* Arguments:
*
*
* Return Value:
*
*
* History:
*
*
\**************************************************************************/

GpGraphics*
GpGraphics::GetForMetafile(
    IMetafileRecord *   metafile,
    EmfType             type,
    HDC                 hdc
    )
{
    ASSERT ((metafile != NULL) && (hdc != NULL));

    DpBitmap *bitmap = new DpBitmap(hdc);   // initializes Dpi
    if (CheckValid(bitmap))
    {
        bitmap->InitializeForMetafile(Globals::DesktopDevice);

        GpGraphics *g = new GpGraphics(bitmap);
        if (g)
        {
            g->Type                  = GraphicsMetafile;
            g->Metafile              = metafile;
            g->DownLevel             = (type != EmfTypeEmfPlusOnly);
            g->Driver                = Globals::MetaDriver;
            g->Context->Hdc          = hdc;
            g->Context->IsEmfPlusHdc = TRUE;

            g->ResetState(0, 0, 1, 1);

            // Override some state, as we don't want anything to be
            // clipped out of a metafile

            g->WindowClip.SetInfinite();
            g->Context->ContainerClip.SetInfinite();
            g->Context->VisibleClip.SetInfinite();

            return(g);
        }
    }

    return(NULL);
}

/**************************************************************************\
*
* Function Description:
*
*   Create a GpGraphics class from a DC.
*
* Arguments:
*
*   [IN] hdc - Specifies the DC.
*
* Return Value:
*
*   NULL if failure (such as with an invalid DC).
*
* History:
*
*   12/04/1998 andrewgo
*       Created it.
*
\**************************************************************************/

GpGraphics*
GpGraphics::GetFromHdc(
    HDC hdc,
    HANDLE hDevice
    )
{
    GpGraphics *g = NULL;

    // GetObjectType is nice and fast (entirely user-mode on NT):

    switch (GetDCType(hdc))
    {
    case OBJ_DC:
        if (GetDeviceCaps(hdc, TECHNOLOGY) == DT_RASPRINTER )
        {
            g = GpGraphics::GetFromGdiPrinterDC(hdc, hDevice);
        }
        else
        {
            g = GpGraphics::GetFromGdiScreenDC(hdc);
        }

        break;

    case OBJ_MEMDC:
        g = GpGraphics::GetFromGdiBitmap(hdc);
        break;

    case OBJ_ENHMETADC:
        // When metafile spooling, the printer DC will be of type
        // OBJ_ENHMETADC on Win9x and NT4 (but not NT5 due to a fix
        // to NT bug 98810).  We need to do some more work to figure
        // out whether it's really a printer DC or a true metafile
        // DC:

        BOOL printDC;
        
        {   // FPU Sandbox for potentially unsafe FPU code.
            FPUStateSandbox fpsb;
            printDC = Globals::GdiIsMetaPrintDCFunction(hdc);
        }   // FPU Sandbox for potentially unsafe FPU code.
        
        if (printDC)
        {
            g = GpGraphics::GetFromGdiPrinterDC(hdc, hDevice);
        }
        else
        {
            g = GpGraphics::GetFromGdiEmfDC(hdc);
        }
        break;

    case OBJ_METADC:
        TERSE(("16-bit metafile DC support not yet implemented"));
        break;
    }

    return(g);
}

/**************************************************************************\
*
* Function Description:
*
*   Dispose of a GpGraphics object
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

GpGraphics::~GpGraphics()
{
    // How do we ensure that no one is using the graphics when we are here?
    // Flush any pending drawing commands before we go out of scope:

    Flush(FlushIntentionFlush);

    if (IsPrinter())
    {
        EndPrinterEMF();

        if (PrintInit)
            delete PrintInit;
    }

    BOOL    doResetHdc = TRUE;

    // Handle Graphics-type specific functionality:

    switch (Type)
    {
    case GraphicsMetafile:
        if (Metafile != NULL)
        {
            Metafile->EndRecording();
            doResetHdc = FALSE; // EndRecording closes the metafile HDC
        }
        // FALLTHRU

    case GraphicsBitmap:

        // if this is created on a GdipBitmap, dec the ref count
        // delete the bitmap if ref count <= 0

        if (GdipBitmap)
        {
            GdipBitmap->Dispose();
        }
        // We have to delete the temporary surface that we created:

        delete Surface;
        break;
    }

    // Restore the DC that we were derived from (if any).
    // We must NOT do this before the call to EndRecording because
    // EndRecording needs the context->Hdc to be in the saved state
    // so that the transforms are still reset like GDI+ requires.

    if (doResetHdc)
    {
        Context->ResetHdc();
    }

    // Free any device and driver objects that had to be created only for the
    // lifespan of the Graphics object:

    if (CreatedDevice)
    {
        delete Driver;
        delete Device;
    }

    SetValid(FALSE);    // so we don't use a deleted object
}


/**************************************************************************\
*
* Function Description:
*
*   Return a GDI DC handle associated with the current graphics context.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   GDI DC handle associated with the current graphics context
*   NULL if there is an error
*
* NOTE: We assume the caller has already obtained a lock on the
*       current graphics context.
*
* NOTE: This function does not return a clean DC!  That is, expect it
*       to have a funky transform, weird ROP mode, etc.  If you want
*       to use this internally, you should probably call Context->GetHdc()
*       directly.
*
\**************************************************************************/

HDC
GpGraphics::GetHdc()
{
    // We must flush the output of the Graphics before returning an HDC.
    this->Flush(FlushIntentionFlush);

    HDC hdc = NULL;

    if (Context->Hdc)
    {
        // If the Graphics was originally derived from an HDC, we simply
        // return back the original HDC (this avoids some issues as to
        // what to do about inherited transforms, etc.).  We may have
        // mucked with some of the DC state, though, so reset it back to
        // what it was originally:

        Context->ResetHdc();

        hdc = Context->Hdc;
    }
    else if (Context->Hwnd)
    {
        // The Graphics was originally derived from an HWND:

        hdc = GetDC(Context->Hwnd);
    }
    else if (Surface && (Surface->Type == DpBitmap::CreationType::GPBITMAP))
    {
        // The GpBitmap is accessible from the EpScanBitmap.  It will
        // create an HDC and GDI bitmap appropriate for interop.

        EpScanBitmap *scan = static_cast<EpScanBitmap*>(Surface->Scan);
        hdc = scan->GetBitmap()->GetHdc();
    }

    if (IsRecording() && (hdc != NULL))
    {
        if (IsPrinter())
        {
            EndPrinterEMF();
        }
        else
        {
            GpStatus status = Metafile->RecordGetDC();
        }
    }

    return(hdc);
}

/**************************************************************************\
*
* Function Description:
*
*   Release the GDI DC handle associated with the current graphics context.
*
* Arguments:
*
*   hdc - GDI DC handle returned by a previous GetHdc() call
*
* Return Value:
*
*   NONE
*
* Notes:
*
*   We assume the caller has already obtained a lock on the
*   current graphics context.
*
\**************************************************************************/

VOID
GpGraphics::ReleaseHdc(
    HDC hdc
    )
{
    if (Context->Hdc)
    {
        // The Graphics was originally derived from an HDC.  We don't
        // have to do anything here; ResetHdc() already marked the
        // DC as dirty.
    }
    else if (Context->Hwnd)
    {
        // The Graphics was originally derived from an HWND:

        ReleaseDC(Context->Hwnd, hdc);
    }
    else if (Surface && (Surface->Type == DpBitmap::CreationType::GPBITMAP))
    {
        // The GpBitmap is accessible from the EpScanBitmap.

        EpScanBitmap *scan = static_cast<EpScanBitmap*>(Surface->Scan);
        scan->GetBitmap()->ReleaseHdc(hdc);
    }

    if (IsRecording() && IsPrinter())
    {
        StartPrinterEMF();
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Save (push) the graphics context state.  Return the ID of the current
*   state (before the push) for the app to restore to later on.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   gstate - the state to restore the context to later
*
* Created:
*
*   3/4/1999 DCurtis
*
\**************************************************************************/
INT
GpGraphics::Save()
{
    DpContext *     newContext = new DpContext(Context);

    if ((newContext != NULL) &&
        (newContext->AppClip.Set(&(Context->AppClip), TRUE) == Ok) &&
        (newContext->ContainerClip.Set(&(Context->ContainerClip), TRUE)
                                                            == Ok) &&
        (newContext->VisibleClip.Set(&(Context->VisibleClip), TRUE) == Ok))
    {
        INT     gstate = newContext->Id;

        newContext->InverseOk         = Context->InverseOk;
        newContext->PageUnit          = Context->PageUnit;
        newContext->PageScale         = Context->PageScale;
        newContext->PageMultiplierX   = Context->PageMultiplierX;
        newContext->PageMultiplierY   = Context->PageMultiplierY;
        newContext->WorldToPage       = Context->WorldToPage;
        newContext->ContainerToDevice = Context->ContainerToDevice;
        newContext->WorldToDevice     = Context->WorldToDevice;
        newContext->DeviceToWorld     = Context->DeviceToWorld;
        newContext->IcmMode           = Context->IcmMode;
        newContext->GdiLayered        = Context->GdiLayered;

        Context->Next = newContext;
        Context = newContext;

        if (IsRecording())
        {
            GpStatus status = Metafile->RecordSave(gstate);
            if (status != Ok)
            {
                SetValid(FALSE);      // Prevent any more recording
            }
        }
        return gstate;
    }

    delete newContext;

    return 0;
}

#define CONTAINER_ID    0x00008000

/**************************************************************************\
*
* Function Description:
*
*   Restore (pop) the context to the state before the specified one.
*
* Arguments:
*
*   gstate - the pushed state (restore to state before this)
*
* Return Value:
*
*   NONE
*
* Created:
*
*   3/4/1999 DCurtis
*
\**************************************************************************/
VOID
GpGraphics::Restore(
    INT         gstate
    )
{
    DpContext *     cur = Context;
    DpContext *     prev;

    for (;;)
    {
        if ((prev = cur->Prev) == NULL)
        {
            return;
        }
        if (cur->Id == (UINT)gstate)
        {
            // don't double record EndContainer calls
            if (IsRecording() && ((gstate & CONTAINER_ID) == 0))
            {
                GpStatus status = Metafile->RecordRestore(gstate);
                if (status != Ok)
                {
                    SetValid(FALSE);      // Prevent any more recording
                }
            }
            prev->Next   = NULL;
            prev->SaveDc = cur->SaveDc;
            Context = prev;
            delete cur;
            return;
        }
        cur = prev;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   End a container.  Restores the state back to what it was before the
*   container was started.  The CONTAINER_ID bit is used to make sure that
*   Restore is not used with BeginContainer and that EndContainer is not
*   used with Save.
*
* Arguments:
*
*   [IN] containerState - the pushed container state
*
* Return Value:
*
*   NONE
*
* Created:
*
*   4/7/1999 DCurtis
*
\**************************************************************************/
VOID
GpGraphics::EndContainer(
    INT     containerState
    )
{
    if (IsRecording())
    {
        GpStatus status = Metafile->RecordEndContainer(containerState);
        if (status != Ok)
        {
            SetValid(FALSE);      // Prevent any more recording
        }
    }
    Restore(containerState | CONTAINER_ID);
}

/**************************************************************************\
*
* Function Description:
*
*   Begin a container.  This sets the container transform and the
*   container clip based on the current transform and the current clip.
*
*   We have to have a container transform for 2 reasons:
*       1)  If we tried to do it in the world transform, then a call
*           to (Re)SetWorldTransform would erase the container transform.
*
*       2)  We have APIs for setting the text size and the line width that
*           are based on the page units, so they are not affected by the
*           world transform, but they are affected by the container transform.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   gstate - the state to restore the context to later
*
* Created:
*
*   3/9/1999 DCurtis
*
\**************************************************************************/

INT
GpGraphics::BeginContainer(
    const GpRectF &     destRect,
    const GpRectF &     srcRect,
    GpPageUnit          srcUnit,
    REAL                srcDpiX,        // only set by metafile enumeration
    REAL                srcDpiY,
    BOOL                srcIsDisplay
    )
{
    GpMatrix        identityMatrix;
    DpContext *     newContext = new DpContext(Context);

    if (newContext == NULL)
    {
        return 0;
    }

    // leave newContext->AppClip set to identity

    if ((Context->AppClip.UpdateDeviceRegion(&identityMatrix) == Ok) &&
        (newContext->ContainerClip.Set(&(Context->AppClip.DeviceRegion),
                                                            TRUE) == Ok) &&
        (newContext->ContainerClip.And(&(Context->ContainerClip)) == Ok) &&
        (newContext->VisibleClip.Set(&(Context->VisibleClip), TRUE) == Ok))
    {
        REAL        unitMultiplierX;
        REAL        unitMultiplierY;
        GpRectF     deviceSrc;

        newContext->GetPageMultipliers(&unitMultiplierX, &unitMultiplierY,
                                       srcUnit);

        deviceSrc.X      = unitMultiplierX * srcRect.X;
        deviceSrc.Y      = unitMultiplierY * srcRect.Y;
        deviceSrc.Width  = unitMultiplierX * srcRect.Width;
        deviceSrc.Height = unitMultiplierY * srcRect.Height;

        if (newContext->ContainerToDevice.InferAffineMatrix(
                           destRect, deviceSrc) == Ok)
        {
            newContext->AntiAliasMode      = 0;
            newContext->TextRenderHint     = TextRenderingHintSystemDefault;
            newContext->TextContrast       = DEFAULT_TEXT_CONTRAST;
            newContext->CompositingMode    = CompositingModeSourceOver;
            newContext->CompositingQuality = CompositingQualityDefault;
            newContext->FilterType         = InterpolationModeDefaultInternal;
            newContext->PixelOffset        = PixelOffsetModeDefault;

            // Note that the world to device transform includes the previous
            // container to device transform.
            newContext->ContainerToDevice.Append(Context->WorldToDevice);
            newContext->InverseOk          = FALSE;
            newContext->PageUnit           = UnitDisplay;
            newContext->PageScale          = 1.0f;
            if ((srcDpiX > 0.0f) && (srcDpiY > 0.0f))
            {
                // When playing a metafile, we have to guarantee that
                // a unit inch is played now as it would have been
                // when it was recorded.  For example, if we recorded
                // the metafile at 300 dpi, then an inch was 300 pixels.
                // Even if we're playing it back to a 96-dpi display,
                // that metafile inch must still be transformed to
                // 300 pixels before going throught the container
                // transformation, so that all graphics are scaled
                // the same, whether pixel units or some other units.
                newContext->ContainerDpiX = srcDpiX;
                newContext->ContainerDpiY = srcDpiY;
                newContext->IsDisplay     = srcIsDisplay;
            }
            newContext->GetPageMultipliers();
            newContext->WorldToPage.Reset();

            // Have to inherit the ICM and layering state:

            newContext->IcmMode           = Context->IcmMode;
            newContext->GdiLayered        = Context->GdiLayered;

            INT     containerState = newContext->Id;
            newContext->Id |= CONTAINER_ID;

            Context->Next = newContext;
            Context = newContext;

            if (IsRecording())
            {
                GpStatus status = Metafile->RecordBeginContainer(destRect,
                                            srcRect, srcUnit, containerState);
                if (status != Ok)
                {
                    SetValid(FALSE);      // Prevent any more recording
                }
            }

            // Do this after switching over the context!
            Context->UpdateWorldToDeviceMatrix();

            return containerState;
        }
    }

    delete newContext;

    return 0;
}

/**************************************************************************\
*
* Function Description:
*
*   Begin a container.  This sets the container transform and the
*   container clip based on the current transform and the current clip.
*
*   We have to have a container transform for 2 reasons:
*       1)  If we tried to do it in the world transform, then a call
*           to (Re)SetWorldTransform would erase the container transform.
*
*       2)  We have APIs for setting the text size and the line width that
*           are based on the page units, so they are not affected by the
*           world transform, but they are affected by the container transform.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   gstate - the state to restore the context to later
*
* Created:
*
*   3/9/1999 DCurtis
*
\**************************************************************************/

INT
GpGraphics::BeginContainer(
    BOOL                forceIdentityTransform, // only set by metafile player
    REAL                srcDpiX,        
    REAL                srcDpiY,
    BOOL                srcIsDisplay
    )
{
    GpMatrix        identityMatrix;
    DpContext *     newContext = new DpContext(Context);

    if (newContext == NULL)
    {
        return 0;
    }

    // leave newContext->AppClip set to identity

    if ((Context->AppClip.UpdateDeviceRegion(&identityMatrix) == Ok) &&
        (newContext->ContainerClip.Set(&(Context->AppClip.DeviceRegion),
                                       TRUE) == Ok) &&
        (newContext->ContainerClip.And(&(Context->ContainerClip)) == Ok) &&
        (newContext->VisibleClip.Set(&(Context->VisibleClip), TRUE) == Ok))
    {
        // Note that the world to device transform includes the previous
        // container to device transform.
        GpMatrix    worldToDevice = Context->WorldToDevice;
        
        // We append the world to device transform below, which already
        // has the container transform in it.  We don't want to apply
        // the same transform twice, so we need to reset the container
        // transform here.
        newContext->ContainerToDevice.Reset();

        // When playing a GDI+ metafile into another metafile, we have to guarantee
        // that the transform is the identity so that the GDI+ records don't get
        // transformed by GDI+ and then get transformed again by GDI.
        if (forceIdentityTransform)
        {
            worldToDevice.Reset();
        }
        else
        {
            // The coordinates that the container transform is expecting are
            // world coordinates, but they will already have gone through
            // the new page to device transform, so convert from device
            // units back to page units before running them through the
            // the container to device transform.
            // In the routine above, this is done through an inferred transform
            // between device unit src rect and world unit dest rect.
            newContext->ContainerToDevice.Scale(1.0f / Context->PageMultiplierX, 
                                                1.0f / Context->PageMultiplierY);
        }

        newContext->AntiAliasMode        = 0;
        newContext->TextRenderHint       = TextRenderingHintSystemDefault;
        newContext->TextContrast         = DEFAULT_TEXT_CONTRAST;
        newContext->CompositingMode      = CompositingModeSourceOver;
        newContext->CompositingQuality   = CompositingQualityDefault;
        newContext->FilterType           = InterpolationModeDefaultInternal;
        newContext->PixelOffset          = PixelOffsetModeDefault;
        newContext->ContainerToDevice.Append(worldToDevice);
        newContext->InverseOk            = FALSE;
        newContext->PageUnit             = UnitDisplay;
        newContext->PageScale            = 1.0f;

        if ((srcDpiX > 0.0f) && (srcDpiY > 0.0f))
        {
            // When playing a metafile, we have to guarantee that
            // a unit inch is played now as it would have been
            // when it was recorded.  For example, if we recorded
            // the metafile at 300 dpi, then an inch was 300 pixels.
            // Even if we're playing it back to a 96-dpi display,
            // that metafile inch must still be transformed to
            // 300 pixels before going throught the container
            // transformation, so that all graphics are scaled
            // the same, whether pixel units or some other units.
            newContext->ContainerDpiX = srcDpiX;
            newContext->ContainerDpiY = srcDpiY;
            newContext->IsDisplay     = srcIsDisplay;
        }

        newContext->GetPageMultipliers();
        newContext->WorldToPage.Reset();

        // Have to inherit the ICM and layering state:

        newContext->IcmMode           = Context->IcmMode;
        newContext->GdiLayered        = Context->GdiLayered;

        INT     containerState = newContext->Id;
        newContext->Id |= CONTAINER_ID;

        Context->Next = newContext;
        Context = newContext;

        if (IsRecording())
        {
            GpStatus status = Metafile->RecordBeginContainer(containerState);
            if (status != Ok)
            {
                SetValid(FALSE);      // Prevent any more recording
            }
        }

        // Do this after switching over the context!
        Context->UpdateWorldToDeviceMatrix();

        return containerState;
    }

    delete newContext;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\copyonwritebitmap.hpp ===
#ifndef _COPYONWRITEBITMAP_HPP
#define _COPYONWRITEBITMAP_HPP

class CopyOnWriteBitmap : private CopyOnWrite
{
friend class GpBitmap;

private:

    // Constructors

    CopyOnWriteBitmap(const WCHAR* filename);
    CopyOnWriteBitmap(IStream* stream);
    CopyOnWriteBitmap(INT width, INT height, PixelFormatID format);
    CopyOnWriteBitmap(INT width, INT height, PixelFormatID format, GpGraphics * graphics);
    CopyOnWriteBitmap(
        INT width,
        INT height,
        INT stride,     // negative for bottom-up bitmaps
        PixelFormatID format,
        BYTE *  scan0
        );
    CopyOnWriteBitmap(
        BITMAPINFO* gdiBitmapInfo,
        VOID* gdiBitmapData,
        BOOL ownBitmapData
        );
    CopyOnWriteBitmap(IDirectDrawSurface7 *surface);

    static VOID CheckValid(CopyOnWriteBitmap *& p)
    {
        if ((p == NULL) || (!p->IsValid()))
        {
            delete p;
            p = NULL;
        }
    }

    static CopyOnWriteBitmap * Create(const WCHAR* filename)
    {
        CopyOnWriteBitmap * newBitmap = new CopyOnWriteBitmap(filename);
        CheckValid(newBitmap);
        return newBitmap;
    }

    static CopyOnWriteBitmap * Create(IStream* stream)
    {
        CopyOnWriteBitmap * newBitmap = new CopyOnWriteBitmap(stream);
        CheckValid(newBitmap);
        return newBitmap;
    }

    static CopyOnWriteBitmap * Create(INT width, INT height, PixelFormatID format)
    {
        CopyOnWriteBitmap * newBitmap = new CopyOnWriteBitmap(width, height, format);
        CheckValid(newBitmap);
        return newBitmap;
    }

    static CopyOnWriteBitmap * Create(INT width, INT height, PixelFormatID format, GpGraphics * graphics)
    {
        CopyOnWriteBitmap * newBitmap = new CopyOnWriteBitmap(width, height, format, graphics);
        CheckValid(newBitmap);
        return newBitmap;
    }

    static CopyOnWriteBitmap * Create(
        INT width,
        INT height,
        INT stride,     // negative for bottom-up bitmaps
        PixelFormatID format,
        BYTE *  scan0
        )
    {
        CopyOnWriteBitmap * newBitmap = new CopyOnWriteBitmap(width, height, stride, format, scan0);
        CheckValid(newBitmap);
        return newBitmap;
    }

    static CopyOnWriteBitmap * Create(
        BITMAPINFO* gdiBitmapInfo,
        VOID* gdiBitmapData,
        BOOL ownBitmapData
        )
    {
        CopyOnWriteBitmap * newBitmap = new CopyOnWriteBitmap(gdiBitmapInfo, gdiBitmapData, ownBitmapData);
        CheckValid(newBitmap);
        return newBitmap;
    }

    static CopyOnWriteBitmap * Create(IDirectDrawSurface7 *surface)
    {
        CopyOnWriteBitmap * newBitmap = new CopyOnWriteBitmap(surface);
        CheckValid(newBitmap);
        return newBitmap;
    }

    CopyOnWriteBitmap*
    Clone(
        const GpRect* rect,
        PixelFormatID format = PixelFormat32bppPARGB
    ) const;

    virtual CopyOnWrite * Clone() const
    {
        return Clone(NULL, PixelFormatDontCare);
    }

    CopyOnWriteBitmap*
    CloneColorAdjusted(
        GpRecolor *             recolor,
        ColorAdjustType         type = ColorAdjustTypeDefault
        ) const;

    GpStatus
    GetEncoderParameterListSize(
        IN  CLSID* clsidEncoder,
        OUT UINT* size
        );

    GpStatus
    GetEncoderParameterList(
        IN  CLSID* clsidEncoder,
        IN  UINT size,
        OUT EncoderParameters* pBuffer
        );

    GpStatus
    SaveToStream(
        IStream* stream,
        CLSID* clsidEncoder,
        EncoderParameters* encoderParams
        );

    GpStatus
    SaveToFile(
        const WCHAR* filename,
        CLSID* clsidEncoder,
        EncoderParameters* encoderParams
        );

    GpStatus
    DoSave(
        IStream* stream,
        const WCHAR* filename,
        CLSID* clsidEncoder,
        EncoderParameters* encoderParams
        );
    
    GpStatus
    SaveAdd(
        const EncoderParameters* encoderParams
        );

    GpStatus
    SaveAdd(
        CopyOnWriteBitmap*        newBits,
        const EncoderParameters*  encoderParams
        );

    // Dispose the bitmap object

    VOID Dispose()
    {
        if (InterlockedDecrement(&ObjRefCount) <= 0)
        {
            this->Release();
        }
    }

    // Get bitmap information

    VOID GetImageInfo(ImageInfo * imageInfo)
    {
        ASSERT(imageInfo != NULL);
        GpMemcpy(imageInfo, &SrcImageInfo, sizeof(ImageInfo));
    }

    CopyOnWriteBitmap* GetThumbnail(UINT thumbWidth, UINT thumbHeight,
                          GetThumbnailImageAbort callback,
                          VOID *callbackData);
    GpStatus GetFrameCount(const GUID* dimensionID,
                           UINT* count)                      const;
    GpStatus GetFrameDimensionsCount(OUT UINT* count)        const;
    GpStatus GetFrameDimensionsList(OUT GUID* dimensionIDs,
                                    IN UINT count)          const;
    GpStatus SelectActiveFrame(const GUID*  dimensionID,
                               UINT frameIndex);
    GpStatus GetPalette(ColorPalette *palette, INT size);
    GpStatus SetPalette(ColorPalette *palette);
    INT      GetPaletteSize();
    GpStatus GetTransparencyHint(DpTransparency* transparency);

    GpStatus SetTransparencyHint(DpTransparency transparency);

    GpStatus GetTransparencyFlags(DpTransparency* transparency,
                                  PixelFormatID loadFormat =PixelFormatDontCare,
                                  BYTE* minA = NULL,
                                  BYTE* maxA = NULL);

    // Property related functions

    GpStatus GetPropertyCount(UINT* numOfProperty);
    GpStatus GetPropertyIdList(UINT numOfProperty, PROPID* list);
    GpStatus GetPropertyItemSize(PROPID propId, UINT* size);
    GpStatus GetPropertyItem(PROPID propId,UINT propSize,
                             PropertyItem* buffer);
    GpStatus GetPropertySize(UINT* totalBufferSize,UINT* numProperties);
    GpStatus GetAllPropertyItems(UINT totalBufferSize,
                                 UINT numProperties,
                                 PropertyItem* allItems);
    GpStatus RemovePropertyItem(PROPID propId);
    GpStatus SetPropertyItem(PropertyItem* item);

    // Check if the CopyOnWriteBitmap object is valid

    virtual BOOL IsValid() const
    {
        return (State != Invalid);
    }

    // Retrieve bitmap data

    GpStatus
    LockBits(
        const GpRect* rect,
        UINT flags,
        PixelFormatID pixelFormat,
        BitmapData* bmpdata,
        INT width = 0,
        INT height = 0
    ) const;   // Does not change the image

    GpStatus
    UnlockBits(
        BitmapData* bmpdata,
        BOOL Destroy=FALSE
    ) const;

    // Get and set pixel on the bitmap.
    GpStatus GetPixel(INT x, INT y, ARGB *color);
    GpStatus SetPixel(INT x, INT y, ARGB color);

    // Derive an HDC for interop on top of the bitmap object

    HDC GetHdc();
    VOID ReleaseHdc(HDC hdc);

    // Serialization

    UINT GetDataSize() const;
    GpStatus GetData(IStream * stream) const;
    GpStatus SetData(const BYTE * dataBuffer, UINT size);

    GpStatus GetCompressedData(
            DpCompressedData * compressed_data,
            BOOL getJPEG = TRUE,
            BOOL getPNG = TRUE,
            HDC hdc = (HDC)NULL);

    GpStatus DeleteCompressedData(
            DpCompressedData * compressed_data) ;


    // Image transform

    GpStatus RotateFlip(
        RotateFlipType rfType
        );

    // Color adjust

    GpStatus ColorAdjust(
        GpRecolor *     recolor,
        ColorAdjustType type
        );

    GpStatus
    ColorAdjust(
        GpRecolor * recolor,
        PixelFormatID pixfmt,
        DrawImageAbort callback,
        VOID *callbackData
        );

    GpStatus GetPixelFormatID(PixelFormatID* pixfmt);

    enum
    {
        Invalid = 0,        // bitmap object is invalid
        ImageRef = 1,       // contains a reference only (e.g. filename)
        ExtStream = 2,      // contains a reference to a stream
        DecodedImg = 3,     // contains a decoded image object,
                            // but it's not decoded yet - name is misleading.
        MemBitmap = 4       // contains an in-memory bitmap object
    };

    GpStatus SetResolution(REAL xdpi, REAL ydpi);

    GpStatus
    PreDraw(
        INT numPoints,
        GpPointF *dstPoints,
        GpRectF *srcRect,
        INT numBitsPerPixel
        );

    // Interop:

    static GpStatus CreateFromHBITMAP(
        HBITMAP hbm,
        HPALETTE hpal,
        CopyOnWriteBitmap** bitmap
        );

    GpStatus CreateHBITMAP(HBITMAP *phbm, ARGB background);

    GpStatus Recolor(
        GpRecolor *recolor,
        CopyOnWriteBitmap **dstBitmap,
        DrawImageAbort callback,
        VOID *callbackData,
        GpRect *rect = NULL
    );

    GpStatus ICMFrontEnd(
        CopyOnWriteBitmap **dstBitmap,
        DrawImageAbort callback,
        VOID *callbackData,
        GpRect *rect = NULL
    );

    static GpStatus CreateFromHICON(
        HICON hicon,
        CopyOnWriteBitmap** bitmap
        );

    GpStatus CreateHICON(HICON *phicon);

    static GpStatus CreateFromResource(
        HINSTANCE hInstance,
        LPWSTR lpBitmapName,
        CopyOnWriteBitmap** bitmap
        );

private:
    CopyOnWriteBitmap(GpMemoryBitmap* membmp);
    
    mutable INT State;          // current state of the bitmap object
    mutable LONG ObjRefCount;   // object reference count used for LockBits
    WCHAR* Filename;
    IStream* Stream;
    mutable GpDecodedImage* Img;
    mutable GpMemoryBitmap* Bmp;
    UINT    CurrentFrameIndex;  // Frame index, zero based
    VOID* cleanupBitmapData;    // Bitmap(BITMAPINFO*, ...) ctor will
                                // set this if dtor should cleanup buffer
    IImageEncoder*  EncoderPtr; // Pointer to encoder pointer for saving
                                // multi-frame images
                                // Note: CopyOnWriteBitmap has to hold this pointer
                                // and do the close later. This is because
                                // 1) Both Bmp and Img will be destroied when
                                // navigating among frames
                                // 2) It is possible that sometime we call
                                // Img->SaveAppend and sometime for
                                // Bmp->SaveAppend, depends on if the frame is
                                // dirty or not.
                                // It make sense that 1 CopyOnWriteBitmap talks to 1
                                // encoder at a time
    BOOL SpecialJPEGSave;       // TRUE if do special lossless JPEG transform
    BOOL ICMConvert;            // TRUE if we should do ICM on this bitmap

    // We need to know how to handle the page transform when it is set
    // to UnitDisplay.  If Display is TRUE (which is the default), then
    // the page transform will be the identity, which is what we want
    // most of the time.  The only exception is when the image is
    // derived from a non-display graphics.
    BOOL Display;               // Set UnitDisplay to identity transform?
    REAL XDpiOverride;          // if non-zero, replaces native dpi
    REAL YDpiOverride;          // if non-zero, replaces native dpi
                                // supports scan interface to CopyOnWriteBitmap
                                // when drawing to bitmap via a Graphics
    mutable BOOL DirtyFlag;     // TRUE if the image bits got modified
    ImageInfo   SrcImageInfo;   // Image info for the source image
    mutable PixelFormatID PixelFormatInMem;
                                // Pixel format in the memory
                                // For example, if the source image is 4 bpp, we
                                // load it into memory as 32 PARGB. This
                                // variable will be set to 32PARGB.
    mutable BOOL HasChangedRequiredPixelFormat;
                                // Flag to remember if we have hacked the color
                                // formats or not in LoadIntoMemory(). Then this
                                // format will be restored in ICMFrontEnd() if
                                // this flag is TRUE

    struct                      // Interop data (information used to return
    {                           // an HDC that can draw into this CopyOnWriteBitmap)
        HDC     Hdc;
        HBITMAP Hbm;

        VOID*   Bits;
        INT_PTR Stride;
        INT     Width;
        INT     Height;
    } InteropData;


    VOID FreeData();            // called by destructor

    // Destructor
    //  We don't want apps to use delete operator directly.
    //  Instead, they should use Dispose method so that
    //  we can take care of reference counting.

    ~CopyOnWriteBitmap();

    // Initialize the bitmap object to its initial state

    VOID InitDefaults()
    {
        State = Invalid;
        ObjRefCount = 1;
        Filename = NULL;
        Stream = NULL;
        Img = NULL;
        Bmp = NULL;
        InteropData.Hdc = NULL;
        InteropData.Hbm = NULL;
        CurrentFrameIndex = 0;
        cleanupBitmapData = NULL;
        DirtyFlag = FALSE;
        XDpiOverride = 0.0f;          // if non-zero, replaces native dpi
        YDpiOverride = 0.0f;          // if non-zero, replaces native dpi
        ICMConvert = FALSE;           // default is don't do ICM (it's slow)
        SpecialJPEGSave = FALSE;

        // We must always treat the bitmap as if it is a display so that
        // the default page transform (in a graphics constructed from
        // the image) is the identity.  The only time we don't do this
        // is if the bitmap is contructed from a graphics that is not
        // associated with a display.  In that case, we want the image
        // to inherit the display property from the graphics so that
        // drawing to the image and drawing to the original graphics
        // will work the same, i.e. will have a similar page transform.
        Display = TRUE;
        EncoderPtr = NULL;
        PixelFormatInMem = PixelFormatUndefined;

        HasChangedRequiredPixelFormat = FALSE;
        GpMemset(&SrcImageInfo, 0, sizeof(ImageInfo));
    }

    // Convert the pixel data of a bitmap object
    // to the specified format

    GpStatus ConvertFormat(PixelFormatID format,
        DrawImageAbort callback = NULL,
        VOID *callbackData = NULL
        );

    // Perform color adjustment by the lower level codec if it can do it

    GpStatus
    ColorAdjustByCodec(
        GpRecolor * recolor,
        DrawImageAbort callback,
        VOID *callbackData
        );

    // Set decode parameters for icons

    GpStatus
    SetIconParameters(
        INT numPoints,
        GpPointF *dstPoints,
        GpRectF *srcRect,
        INT numBitsPerPixel
        );

    CopyOnWriteBitmap()
    {
        InitDefaults();
    }

    // Dereference the stream or file pointer and promote this bitmap object
    // to at least DecodedImg state.
    GpStatus CopyOnWriteBitmap::DereferenceStream() const;

    // Load bitmap image into memory
    // width and height are the suggested width and height to decode into.
    // zero means use the source width and height.

    GpStatus LoadIntoMemory(
        PixelFormatID format = PixelFormat32bppPARGB,
        DrawImageAbort callback = NULL,
        VOID *callbackData = NULL,
        INT width = 0,
        INT height = 0
    ) const;

    VOID SetDirtyFlag(BOOL flag) const
    {
        DirtyFlag = flag;
    }

    BOOL    IsDirty() const
    {
        return DirtyFlag;
    }

    VOID TerminateEncoder()
    {
        if ( EncoderPtr != NULL )
        {
            EncoderPtr->TerminateEncoder();
            EncoderPtr->Release();
            EncoderPtr = NULL;
        }
    }

    GpStatus ValidateMultiFrameSave();
    GpStatus ParseEncoderParameter(
        const EncoderParameters*    encoderParams,
        BOOL*                       pfIsMultiFrameSave,
        BOOL*                       pfSpecialJPEG,
        RotateFlipType*             rfType
        );
    GpStatus TransformThumbanil(
        CLSID* clsidEncoder,
        EncoderParameters* encoderParams,
        PropertyItem **ppOriginalItem
        );

    VOID CacheImageInfo(HRESULT hr);

private:
    GpStatus SaveAppend(
        const EncoderParameters* encoderParams,
        IImageEncoder* EncoderPtr
        );
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\device.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Internal class representing the device.
*
* Revision History:
*
*   12/04/1998 andrewgo
*       Created it.
*
\**************************************************************************/

#ifndef _DEVICE_HPP
#define _DEVICE_HPP

//--------------------------------------------------------------------------
// Represents the underlying physical device
//--------------------------------------------------------------------------

class GpDevice
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagDevice : ObjectTagInvalid;
    }

public:

    // Buffer data:

    INT BufferWidth;            // Buffer width in pixels, 0 if there are no
                                // buffers or they couldn't be allocated
    HBITMAP DIBSectionBitmap;
    HDC DIBSectionHdc;
    VOID *DIBSection;
    VOID *Buffers[5];
    PixelFormatID BufferFormat;

    // Scan interfaces:

    EpScanEngine ScanEngine;    // For accessing bitmap formats that are 
                                // directly writeable by GDI+
    EpScanGdiDci *ScanGdi;      // For accessing bitmap formats that are not
                                // directly accessible by GDI+, via GDI
                                // BitBlt calls
    EpScanGdiDci *ScanDci;      // For accessing the screen directly

    HDC DeviceHdc;              // Owned DC representing specific
                                // device

    HMONITOR hMonitor;          // Handle to monitor.  This is set if the
                                // device represents a physical device
                                // associated with monitor on the system.

                                // WARNING: current code uses hMonitor != NULL
                                // to indicate that GpDevice was created via
                                // GpDevice(HMONITOR) and that deletion of
                                // DeviceHdc is owned by destructor.  If
                                // somebody wants to change this, then they
                                // will need to fix how DeviceHdc is managed.

    INT ScreenOffsetX;          // Offset to screen for this device.  Needed
    INT ScreenOffsetY;          // to support multimon.  NOTE, currently we
                                // have not found a good way to derive the
                                // screen position of the monitor specific
                                // hdc.  If we find a way to get this
                                // from the DeviceHdc then we can remove
                                // this state.

    INT ScreenWidth;            // Width and Height of screen space.  There
    INT ScreenHeight;           // is probably a better place to store this
                                // information but we'll stick it here for
                                // now.  TODO - find a better place

    IDirectDraw7 * pdd;         // Direct Draw Interface for device
    IDirect3D7 * pd3d;          // Direct 3D Interface for device
    IDirectDrawSurface7 * pdds; // Direct draw primary surface of device

    IDirect3DDevice7 * pd3dDevice; // D3D device for monitor device
    IDirectDrawSurface7 * pddsRenderTarget; 
                                // Current render target that is
                                // selected into the D3D device

    ColorPalette * Palette;     // System palette color table

public:

    GpDevice(HDC hdc);
    GpDevice(HMONITOR hMonitor);

    // Allow subclass devices to cleanup before deleting DC
    virtual ~GpDevice();

    virtual BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagDevice) || (Tag == ObjectTagInvalid)); 
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid Device");
        }
    #endif

        return (Tag == ObjectTagDevice);
    }

    BOOL
    GetScanBuffers(
        INT width,
        VOID **dibSection        = NULL,
        HDC *hdcDibSection       = NULL,
        PixelFormatID *dstFormat = NULL,
        VOID *buffers[5]         = NULL
        );
    
    GpSemaphore DeviceLock;

private:

    static BOOL EnumDirectDrawCallback(
        GUID *      lpGUID,
        LPSTR       lpDriverDescription,
        LPSTR       lpDriverName,
        LPVOID      lpContext,
        HMONITOR    hMonitor);
                                       
};

class GpDeviceList 
{
public:

    GpDeviceList(void);
    ~GpDeviceList(void);

    GpStatus AddDevice(GpDevice * device);

    GpDevice * FindD3DDevice(IDirectDrawSurface7 * surface);

private:

#if 0
    void Build(void);

    static HRESULT EnumD3DDevicesCallback(LPSTR lpDevDesc,
                                   LPSTR lpDevName,
                                   LPD3DDEVICEDESC7 * d3dDevDesc,
                                   LPVOID lpConetxt);
#endif

    INT         mNumDevices;
    GpDevice ** mDevices;

};


//--------------------------------------------------------------------------
// Represents the underlying physical device
//--------------------------------------------------------------------------

class GpPrinterDevice : public GpDevice
{
public:

    // !! Split into two classes, we don't want to inherit the scan goop
    //    from above.  Don't forget DeviceLock->Initialize()

    EpScanDIB ScanPrint;

public:

    GpPrinterDevice(HDC hdc) : GpDevice(hdc) {};
    virtual ~GpPrinterDevice() 
    {
        // Don't delete the printer HDC
        DeviceHdc = NULL;
    };
};

//--------------------------------------------------------------------------
// GpDevice lock
//--------------------------------------------------------------------------

class Devlock
{
private:
    GpSemaphore *DeviceLock;

public:
    Devlock(GpDevice *device)
    {
        DeviceLock = &device->DeviceLock;
        DeviceLock->Lock();
    }
    
    ~Devlock()
    {
        DeviceLock->Unlock();
    }
};

#endif // !_DEVICE_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\customlinecap.hpp ===
/**************************************************************************\
*
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   CustomLineCap.hpp
*
* Abstract:
*
*   Class used for the custom line caps.
*
* Revision History:
*
*   02/21/00 ikkof
*       Created it.
*
\**************************************************************************/

#ifndef _CUSTOMLINECAP_HPP
#define _CUSTOMLINECAP_HPP

#define CLCAP_BUFFER_SIZE    16

class GpCustomLineCap : public DpCustomLineCap
{
friend class GpObject;
protected:
    // This is used by the object factory
    GpCustomLineCap(
        ) : GpFillPath  (NULL, 0, PointsBuffer1, TypesBuffer1, CLCAP_BUFFER_SIZE, FillModeWinding, DpPath::PossiblyNonConvex),
            GpStrokePath(NULL, 0, PointsBuffer2, TypesBuffer2, CLCAP_BUFFER_SIZE, FillModeWinding, DpPath::PossiblyNonConvex)
    { 
        Initialize(); 
    }

public:

    GpCustomLineCap(
        const DpPath* fillPath,
        const DpPath* strokePath,
        GpLineCap baseCap = LineCapFlat,
        REAL baseInset = 0
        );

    virtual ObjectType GetObjectType() const;
    virtual UINT GetDataSize() const;
    virtual GpStatus GetData(IStream * stream) const;
    virtual GpStatus SetData(const BYTE * dataBuffer, UINT size);

    virtual CustomLineCapType GetType() const
    {
        return CustomLineCapTypeDefault;
    }
    
    GpStatus SetFillPath(const DpPath* path);

    GpStatus SetFillPath(
        const GpPointF* fillPoints,
        const BYTE* fillTypes,
        INT fillCount);

    GpStatus GetFillPath(GpPath* fillPath) const;

    GpStatus SetStrokePath(const DpPath* path);

    GpStatus SetStrokePath(
        const GpPointF* strokePoints,
        const BYTE* strokeTypes,
        INT strokeCount);

    GpStatus GetStrokePath(GpPath* strokePath) const;

    virtual BOOL IsEqual(const DpCustomLineCap* customLineCap) const;

    virtual INT GetTransformedFillCap(
            GpPointF* points,
            BYTE* types,
            INT count,
            const GpPointF& origin,
            const GpPointF& tangent,
            REAL lineWidth,
            REAL minimumWidth
            ) const;

    virtual INT GetTransformedStrokeCap(
            INT cCapacity,       // In, initial pPoints & pTypes capacity
            GpPointF ** pPoints, // In/out, may be reallocated here
            BYTE ** pTypes,      // In/out, may be reallocated here
            INT * pCount,        // In/out, may change here if flattened
            const GpPointF& origin,
            const GpPointF& tangent,
            REAL lineWidth,
            REAL minimumWidth
            ) const;
            
    virtual REAL GetRadius(
            REAL lineWidth,
            REAL minimumWidth
            ) const;

    ~GpCustomLineCap();

    virtual GpCustomLineCap* Clone() const
    {
        return new GpCustomLineCap(this);
    }
    
    // Get the lock object
    GpLockable *GetObjectLock()
    {
        return &Lockable;
    }

    VOID ReverseFillPath();
    VOID ReverseStrokePath();
    
    GpStatus GetCreationStatus()
    {
        return m_creationStatus;
    }
    
protected:

    GpCustomLineCap(const GpCustomLineCap* customCap);

    VOID Initialize()
    {
        FillPath   = &GpFillPath;
        StrokePath = &GpStrokePath;

        FillLength = 0.0f;
        StrokeLength = 0.0f;
        BaseCap = LineCapFlat;
        BaseInset = 0;

        StrokeStartCap = LineCapFlat;
        StrokeEndCap = LineCapFlat;
        StrokeJoin = LineJoinMiter;
        StrokeMiterLimit = 10;
        WidthScale = 1;

        FillHotSpot.X = 0;
        FillHotSpot.Y = 0;
        StrokeHotSpot.X = 0;
        StrokeHotSpot.Y = 0;
        
        m_creationStatus = Ok;
        
        SetValid(TRUE);
    }

    VOID Reset();

    VOID ResetFillPath();

    VOID ResetStrokePath();

    GpStatus ComputeFillCapLength();
    GpStatus ComputeStrokeCapLength();
    
protected:
    GpLockable Lockable;
    GpPath GpFillPath;
    GpPath GpStrokePath;
    GpPointF PointsBuffer1[CLCAP_BUFFER_SIZE];
    GpPointF PointsBuffer2[CLCAP_BUFFER_SIZE];
    BYTE TypesBuffer1[CLCAP_BUFFER_SIZE];
    BYTE TypesBuffer2[CLCAP_BUFFER_SIZE];
    
    GpStatus m_creationStatus;  // check this if IsValid() == FALSE 
};


class GpAdjustableArrowCap : public GpCustomLineCap
{
friend class GpObject;
private:
    // This is only used by the object factory
    GpAdjustableArrowCap()
    {
        SetDefaultValue();
        Update();
    }

public:
    GpAdjustableArrowCap(REAL height, REAL width, BOOL isFilled = TRUE)
    {
        Height = height;
        Width = width;
        MiddleInset = 0;
        FillState = isFilled;

        Update();
    }

    virtual UINT GetDataSize() const;
    virtual GpStatus GetData(IStream * stream) const;
    virtual GpStatus SetData(const BYTE * dataBuffer, UINT size);

    CustomLineCapType GetType() const
    {
        return CustomLineCapTypeAdjustableArrow;
    }
    
    GpStatus SetHeight(REAL height)
    {
        if(Height == height)
            return Ok;

        Height = height;
        return Update();
    }

    REAL GetHeight() const { return Height; }

    GpStatus SetWidth(REAL width)
    {
        if(Width == width)
            return Ok;

        Width = width;
        return Update();
    }

    REAL GetWidth() const { return Width; }

    GpStatus SetMiddleInset(REAL middleInset)
    {
        if(MiddleInset == middleInset)
            return Ok;

        MiddleInset = middleInset;
        return Update();
    }

    REAL GetMiddleInset() const { return MiddleInset; }

    GpStatus SetFillState(BOOL isFilled)
    {
        if(FillState == isFilled)
            return Ok;

        FillState = isFilled;
        return Update();
    }

    BOOL IsFilled() const {return FillState;}

    virtual GpCustomLineCap* Clone() const
    {
        return new GpAdjustableArrowCap(this);
    }

protected:

    GpAdjustableArrowCap(const GpAdjustableArrowCap* customCap);

    VOID SetDefaultValue()
    {
        Height = 2;
        Width = 2;
        MiddleInset = 0;
        FillState = TRUE;
    }

    GpStatus GetPathData(
        GpPathData* pathData,
        REAL height,
        REAL width,
        REAL middleInset,
        BOOL isFilled
        );

    GpStatus Update();

protected:
    REAL Width;
    REAL Height;
    REAL MiddleInset;
    BOOL FillState;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\drawglyphdata.hpp ===
#ifndef _DRAWGLYPHDATA_
#define _DRAWGLYPHDATA_

struct DrawGlyphData
{
    DpContext                *context;
    DpBitmap                 *surface;
    const GpRect             *drawBounds;
    const GpGlyphPos         *glyphPos;
    const GpGlyphPos         *glyphPathPos;
    INT                       count;
    const DpBrush            *brush;
    const GpFaceRealization  *faceRealization;
    const UINT16             *glyphs;
    const UINT16             *glyphMap;
    const PointF             *glyphOrigins;
    INT                       glyphCount;   // (May differ from count)
    const WCHAR              *string;
    UINT                      stringLength;
    ItemScript                script;
    INT                       edgeGlyphAdvance;
    BOOL                      rightToLeft;
    INT                       flags;         // DG_NOGDI - testing only
};

#endif // _DRAWGLYPHDATA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\customlinecap.cpp ===
/**************************************************************************\
* 
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   CustomLineCap.cpp
*
* Abstract:
*
*   Implementation of custom line cap class
*
* Revision History:
*
*   02/21/00 ikkof
*       Created it
*
\**************************************************************************/

#include "precomp.hpp"


/**************************************************************************\
*  
* Function Description:
*
*   ComputeCapLength
*
*   Compute the length of the cap from zero along the + y axis
*   Typically custom caps will return a negative length.
*
* Arguments:
*
*    GpPointF *points,    the points representing the cap path.
*    BYTE *types,         the types  "
*    INT pointCount       how many points in the above arrays.
*
* Return Value:
*   REAL    -- the length.
*
*   08/25/2000 [asecchia]
*       Created it
*
\**************************************************************************/

static REAL ComputeCapLength(
    DpPath * path
)
{
    const GpPointF *points = path->GetPathPoints();
    const BYTE *types = path->GetPathTypes();
    INT pointCount = path->GetPointCount();

    REAL length = 0.0f;
    BOOL isClosed = (types[pointCount-1] & PathPointTypeCloseSubpath) != 0;
    
    // Eliminate degenerate paths and uninitialized paths.
    
    if( points && (pointCount>1) )
    {
        REAL curlength = 0.0f;
        
        GpArrayIterator<GpPointF> pIt(const_cast<GpPointF *>(points), pointCount);
        
        // Get the last item in the list.
        
        pIt.SeekLast();
        GpPointF *lastPoint = pIt.CurrentItem();
        
        // Begin at the first item.
        
        pIt.SeekFirst();
        GpPointF *curPoint;
        
        if(!isClosed)
        {
            // if it's not a closed path, skip the last-to-first point line.
            
            lastPoint = pIt.CurrentItem();
        }
        
        while(!pIt.IsDone())
        {
            curPoint = pIt.CurrentItem();
            
            if(intersect_line_yaxis(*curPoint, *lastPoint, &curlength))
            {
                length = min(length, curlength);
            }
            
            lastPoint = curPoint;
            pIt.Next();
        }
    }
    
    return length;
}

GpStatus GpCustomLineCap::ComputeFillCapLength()
{
    FillLength = -ComputeCapLength(FillPath);
    
    // Fill paths cannot have a length of zero or less.
    
    if(FillLength < REAL_EPSILON)
    {
        return NotImplemented;
    }
    
    return Ok;
}

GpStatus GpCustomLineCap::ComputeStrokeCapLength()
{
    StrokeLength = -ComputeCapLength(StrokePath);
    
    // Stroke paths can have a length of zero - we explicitly check for 
    // this and handle it.
    
    if(StrokeLength < -REAL_EPSILON)
    {
        return NotImplemented;
    }
    
    return Ok;
}

GpCustomLineCap::GpCustomLineCap(
    const DpPath* fillPath,
    const DpPath* strokePath,
    GpLineCap baseCap,
    REAL baseInset
    ) : GpFillPath  (NULL, 0, PointsBuffer1, TypesBuffer1, CLCAP_BUFFER_SIZE, FillModeWinding, DpPath::PossiblyNonConvex),
        GpStrokePath(NULL, 0, PointsBuffer2, TypesBuffer2, CLCAP_BUFFER_SIZE, FillModeWinding, DpPath::PossiblyNonConvex)
{
    Initialize();

    GpStatus status = Ok;

    if(fillPath)
    {
        GpPath* gpFillPath = GpPath::GetPath(fillPath);
        status = SetFillPath(gpFillPath);
    }

    if(status == Ok && strokePath)
    {
        GpPath* gpStrokePath = GpPath::GetPath(strokePath);
        status = SetStrokePath(gpStrokePath);
    }

    if(status == Ok)
    {
        switch(baseCap)
        {
        case LineCapFlat:
        case LineCapSquare:
        case LineCapRound:
        case LineCapTriangle:
            BaseCap = baseCap;
            break;

        default:
            BaseCap = LineCapFlat;
            break;
        }

        BaseInset = baseInset;
    }
    else
    {
        Reset();
        SetValid(FALSE);
        m_creationStatus = status;  // this defaults to Ok.
    }
}

VOID
GpCustomLineCap::ResetFillPath()
{
    GpFillPath.Reset(FillModeWinding);
}

VOID
GpCustomLineCap::ResetStrokePath()
{
    GpStrokePath.Reset(FillModeWinding);
}

VOID 
GpCustomLineCap::ReverseFillPath()
{
    GpFillPath.Reverse();
}

VOID 
GpCustomLineCap::ReverseStrokePath()
{
    GpStrokePath.Reverse();
}

VOID
GpCustomLineCap::Reset()
{
    // Clean up and reset to the default state.

    Initialize();
    ResetFillPath();
    ResetStrokePath();
}

GpCustomLineCap::GpCustomLineCap(
    const GpCustomLineCap* customCap
    ) : GpFillPath  (NULL, 0, PointsBuffer1, TypesBuffer1, CLCAP_BUFFER_SIZE, FillModeWinding, DpPath::PossiblyNonConvex),
        GpStrokePath(NULL, 0, PointsBuffer2, TypesBuffer2, CLCAP_BUFFER_SIZE, FillModeWinding, DpPath::PossiblyNonConvex)
{
    Initialize();

    if(customCap == NULL)
        return;

    GpStatus status = Ok;

    status = SetFillPath(customCap->FillPath);

    if(status == Ok)
        status = SetStrokePath(customCap->StrokePath);

    if(status == Ok)
    {
        GpLineCap baseCap = customCap->BaseCap;

        switch(baseCap)
        {
        case LineCapFlat:
        case LineCapSquare:
        case LineCapRound:
        case LineCapTriangle:
            BaseCap = baseCap;
            break;

        default:
            BaseCap = LineCapFlat;
            break;
        }

        BaseInset = customCap->BaseInset;

        StrokeStartCap = customCap->StrokeStartCap;
        StrokeEndCap = customCap->StrokeEndCap;
        StrokeJoin = customCap->StrokeJoin;
        WidthScale = customCap->WidthScale;
    }
    else
    {
        Reset();
        SetValid(FALSE);
        m_creationStatus = status;  // this defaults to Ok.
    }
}


GpCustomLineCap::~GpCustomLineCap()
{
}

GpStatus 
GpCustomLineCap::SetFillPath(
    const DpPath* path
    )
{
    // If the given path is NULL, empty the fill path.

    if(path == NULL)
    {
        ResetFillPath();
        return Ok;
    }

    INT count = path->GetPointCount();

    return SetFillPath(path->GetPathPoints(), path->GetPathTypes(), count);
}

GpStatus
GpCustomLineCap::SetFillPath(
    const GpPointF* fillPoints,
    const BYTE* fillTypes,
    INT fillCount)
{
    if(fillCount == 0)
    {
        ResetFillPath();
        return Ok;
    }

    if(fillCount <= 2 || fillPoints == NULL || fillTypes == NULL)
        return InvalidParameter;

    GpPathData pathData;

    pathData.Points = const_cast<GpPointF *>(fillPoints);
    pathData.Types = const_cast<BYTE *>(fillTypes);
    pathData.Count = fillCount;

    GpStatus status = FillPath->SetPathData(&pathData);

    if(status == Ok)
    {
        status = ComputeFillCapLength();
    }

    return status;
}

GpStatus
GpCustomLineCap::GetFillPath(
    GpPath* path
    ) const
{
    if(!path)
        return InvalidParameter;

    GpPathData pathData;

    pathData.Points = const_cast<GpPointF *>(FillPath->GetPathPoints());
    pathData.Types  = const_cast<BYTE *>(FillPath->GetPathTypes());
    pathData.Count  = FillPath->GetPointCount();

    return path->SetPathData(&pathData);
}

GpStatus
GpCustomLineCap::SetStrokePath(
    const DpPath* path
    )
{
    // If the given path is NULL, empty the stroke path.

    if(path == NULL)
    {
        ResetStrokePath();
        return Ok;
    }

    INT count = path->GetPointCount();

    return SetStrokePath(path->GetPathPoints(), path->GetPathTypes(), count);
}

GpStatus
GpCustomLineCap::SetStrokePath(
    const GpPointF* strokePoints,
    const BYTE* strokeTypes,
    INT strokeCount)
{
    if(strokeCount == 0)
    {
        ResetStrokePath();
        return Ok;
    }

    if(strokeCount <= 1 || strokePoints == NULL || strokeTypes == NULL)
        return InvalidParameter;

    GpPathData pathData;

    pathData.Points = const_cast<GpPointF *>(strokePoints);
    pathData.Types = const_cast<BYTE *>(strokeTypes);
    pathData.Count = strokeCount;

    GpStatus status = StrokePath->SetPathData(&pathData);

    if(status == Ok)
    {
        status = ComputeStrokeCapLength();
    }

    return status;
}

GpStatus
GpCustomLineCap::GetStrokePath(
    GpPath* path
    ) const
{
    if(!path)
        return InvalidParameter;

    GpPathData pathData;

    pathData.Points = const_cast<GpPointF *>(StrokePath->GetPathPoints());
    pathData.Types  = const_cast<BYTE *>(StrokePath->GetPathTypes());
    pathData.Count  = StrokePath->GetPointCount();

    return path->SetPathData(&pathData);
}

BOOL
GpCustomLineCap::IsEqual(
    const DpCustomLineCap* customLineCap
    ) const
{
    if(!customLineCap)
        return FALSE;

    const GpCustomLineCap* otherCap;
    otherCap = static_cast<const GpCustomLineCap*>(customLineCap);

    return (
        (BaseCap == otherCap->BaseCap) &&
        (BaseInset == otherCap->BaseInset) &&
        (StrokeStartCap == otherCap->StrokeStartCap) &&
        (StrokeEndCap == otherCap->StrokeEndCap) &&
        (StrokeJoin == otherCap->StrokeJoin) &&
        (WidthScale == otherCap->WidthScale) &&
        GpFillPath.IsEqual(&(otherCap->GpFillPath)) &&
        GpStrokePath.IsEqual(&(otherCap->GpStrokePath))
        );
}

INT getTransformedPoints(
    GpPointF* points,
    BYTE* types,
    INT count,
    const GpPointF* srcPoints,
    const BYTE* srcTypes,
    INT srcCount,
    const GpPointF& origin,
    const GpPointF& tangent,
    REAL lineWidth,
    REAL minLineWidth,
    const GpPointF& hotSpot
    )
{
    if(points == NULL && types == NULL)
    {
        return 0;
    }

    ASSERT(srcPoints && srcTypes);

    if(srcPoints == NULL || srcTypes == NULL)
    {
        return 0;
    }

    INT count1 = srcCount;
    if(count1 > count)
    {
        count1 = count;
    }

    if(types)
    {
        GpMemcpy(types, srcTypes, count1);
    }

    // Make sure the line width used for the cap path is
    // larger than the minimum line width.

    REAL width = lineWidth;
    if(lineWidth < minLineWidth)
    {
        width = minLineWidth;
    }

    if(points)
    {
        GpPointF* dstPts = points;
        const GpPointF* srcPts = srcPoints;

        REAL m11, m12, m21, m22, tx, ty;
        m11 = width*tangent.Y;
        m21 = width*tangent.X;
        m12 = - width*tangent.X;
        m22 = width*tangent.Y;
        
        // Adjust the origin according to the hot spot.

        tx = hotSpot.X*(1.0f - width);
        ty = hotSpot.Y*(1.0f - width);
        REAL savedTx = tx;
        tx = tx*tangent.Y + ty*tangent.X + origin.X;
        ty = - savedTx*tangent.X + ty*tangent.Y + origin.Y;

        // Transform the points.

        for(INT i = 0; i < count1; i++)
        {
            dstPts->X = m11*srcPts->X + m21*srcPts->Y + tx;
            dstPts->Y = m12*srcPts->X + m22*srcPts->Y + ty;

            dstPts++;
            srcPts++;
        }
    }

    return count1;
}

INT
GpCustomLineCap::GetTransformedFillCap(
    GpPointF* points,
    BYTE* types,
    INT count,
    const GpPointF& origin,
    const GpPointF& tangent,
    REAL lineWidth,
    REAL minimumWidth
    ) const
{
    INT fillCount = GetFillPointCount();
    
    if(fillCount <= 0)
        return 0;

    // Calculate the minimum line width and hot spot.
    // FillHotSpot is defined relative to the minimumWidth.

    REAL minLineWidth = minimumWidth;
    GpPointF hotSpot;

    hotSpot.X = minimumWidth*FillHotSpot.X;
    hotSpot.Y = minimumWidth*FillHotSpot.Y;

    return getTransformedPoints(
                points,
                types,
                count,
                GetFillPoints(),
                GetFillTypes(),
                fillCount,
                origin,
                tangent,
                lineWidth,
                minLineWidth,
                hotSpot);
}

INT
GpCustomLineCap::GetTransformedStrokeCap(
    INT cCapacity,          // In, initial pPoints & pTypes capacity
    GpPointF ** pPoints,    // In/out, may be reallocated here
    BYTE ** pTypes,         // In/out, may be reallocated here
    INT * pCount,           // In/out, may change here if flattened
    const GpPointF& origin,
    const GpPointF& tangent,
    REAL lineWidth,
    REAL minimumWidth
    ) const
{
    INT strokeCount = GetStrokePointCount();

    if(strokeCount <= 0 || lineWidth <= 0)
        return 0;
	if (!pPoints  ||  !pTypes  ||  !pCount)
        return 0;

    // Calculate the minimum line width and hot spot.
    // StrokeHotSpot is defined relative to the minimumWidth.

    GpPointF hotSpot;

    hotSpot.X = minimumWidth*StrokeHotSpot.X;
    hotSpot.Y = minimumWidth*StrokeHotSpot.Y;

	strokeCount = getTransformedPoints(
                *pPoints,
                *pTypes,
                *pCount,
                GetStrokePoints(),
                GetStrokeTypes(),
                strokeCount,
                origin,
                tangent,
                lineWidth,
                minimumWidth,
                hotSpot);

	// The widener expects a flattened path
	GpPath path(*pPoints, *pTypes, strokeCount, FillModeWinding);
	if (Ok == path.Flatten(NULL, FlatnessDefault))
	{
		// Flattening succeeded
		strokeCount = path.GetPointCount();
		if (strokeCount > cCapacity)
        {
			// Reallocate the points and types arrays
			GpPointF * ptfTemp = (GpPointF*) GpRealloc(*pPoints, 
									strokeCount*sizeof(GpPointF));
			if (ptfTemp)
				*pPoints = ptfTemp;
			else
				strokeCount	= 0;
			BYTE * pbTemp = (BYTE*)GpRealloc(*pTypes, strokeCount);
			if (pbTemp)
				*pTypes = pbTemp;
			else
				strokeCount	= 0;
        }

		if (strokeCount)
		{
			// Replace with the flattened points
			GpMemcpy(*pPoints, path.GetPathPoints(), strokeCount*sizeof(GpPointF));
			GpMemcpy(*pTypes, path.GetPathTypes(), strokeCount);
		}
		*pCount = strokeCount;

    } // end if flattening succeeded
	return strokeCount;
}

REAL
GpCustomLineCap::GetRadius(
    REAL lineWidth,
    REAL minimumWidth
    ) const
{
    INT fillCount = GetFillPointCount();
    INT strokeCount = GetStrokePointCount();

    if((fillCount <= 0 && strokeCount <= 0) || lineWidth <= 0)
        return 0;

    INT maxCount = max(fillCount, strokeCount);

    const INT buffCount = 32;
    GpPointF pointBuff[buffCount];
    BYTE typeBuff[buffCount];
    GpPointF* points = NULL;
    BYTE* types = NULL;

    if(maxCount <= buffCount)
    {
        points = &pointBuff[0];
        types = &typeBuff[0];
    }
    else
    {
        points = (GpPointF*) GpMalloc(maxCount*sizeof(GpPointF));
        types = (BYTE*) GpMalloc(maxCount);
    }

    REAL maxR = 0;

    if(points && types)
    {
        GpPointF origin(0, 0);
        GpPointF tangent(0, 1);

        REAL minLineWidth;
        GpPointF hotSpot;
        REAL d;
        INT count;
        
        if(fillCount > 0)
        {
            // Calculate the minimum line width and hot spot.
            // FillHotSpot is defined relative to the minimumWidth.

            minLineWidth = minimumWidth;

            hotSpot.X = minimumWidth*FillHotSpot.X;
            hotSpot.Y = minimumWidth*FillHotSpot.Y;

            count = getTransformedPoints(
                    points,
                    types,
                    fillCount,
                    GetFillPoints(),
                    GetFillTypes(),
                    fillCount,
                    origin,
                    tangent,
                    lineWidth,
                    minLineWidth,
                    hotSpot);

            REAL i;
            GpPointF* pts = points;
            maxR = pts->X*pts->X + pts->Y*pts->Y;

            for(i = 1, pts++; i < count; i++, pts++)
            {
                d = pts->X*pts->X + pts->Y*pts->Y;

                if(d > maxR)
                    maxR = d;
            }
        }

        if(strokeCount > 0)
        {
            // Calculate the minimum line width and hot spot.
            // FillHotSpot is defined relative to the minimumWidth.

            minLineWidth = minimumWidth;
            hotSpot.X = minimumWidth*StrokeHotSpot.X;
            hotSpot.Y = minimumWidth*StrokeHotSpot.Y;

            count = getTransformedPoints(
                    points,
                    types,
                    strokeCount,
                    GetStrokePoints(),
                    GetStrokeTypes(),
                    strokeCount,
                    origin,
                    tangent,
                    lineWidth,
                    minLineWidth,
                    hotSpot);

            GpPath strokePath(points, types, count, FillModeWinding);
            GpRectF rect;
            strokePath.GetBounds(&rect);
            REAL sharpestAngle = strokePath.GetSharpestAngle();

            REAL delta0 = max(lineWidth*WidthScale, minimumWidth);
            REAL delta = delta0/2;

            if(StrokeJoin == LineJoinMiter ||
               StrokeJoin == LineJoinMiterClipped)
            {
                REAL miterLimit = StrokeMiterLimit;

                delta = delta0*miterLimit;

                if(delta > 20)
                {
                    delta = GpPen::ComputeMiterLength(
                        sharpestAngle,
                        miterLimit
                    );

                    delta *= delta0;
                }
            }

            REAL left, right, top, bottom;
            left = rect.X - delta;
            right = rect.X + delta;
            top = rect.Y - delta;
            bottom = rect.Y + delta;

            d = left*left + top*top;
            if(d > maxR)
                maxR = d;
            d = left*left + bottom*bottom;
            if(d > maxR)
                maxR = d;
            d = right*right + top*top;
            if(d > maxR)
                maxR = d;
            d = right*right + bottom*bottom;
            if(d > maxR)
                maxR = d;            
        }
    }
    else
    {
        //!!! Do something when the memory is not available.
    }

    if(points != &pointBuff[0])
        GpFree(points);

    if(types != &typeBuff[0])
        GpFree(types);

    if(maxR > 0)
        maxR = REALSQRT(maxR);

    return maxR;
}


GpAdjustableArrowCap::GpAdjustableArrowCap(
    const GpAdjustableArrowCap* arrowCap
    ) : GpCustomLineCap(arrowCap)
{
    if(arrowCap)
    {
        Height = arrowCap->Height;
        Width = arrowCap->Width;
        MiddleInset = arrowCap->MiddleInset;
        FillState = arrowCap->FillState;
    }
    else
    {
        SetDefaultValue();
    }
    
    Update();
}

GpStatus
GpAdjustableArrowCap::GetPathData(
    GpPathData* pathData,
    REAL height,
    REAL width,
    REAL middleInset,
    BOOL isFilled
    )
{
    if(pathData == NULL)
        return InvalidParameter;

    GpPointF* points = pathData->Points;
    BYTE* types = pathData->Types;

    points[0].X = width/2;
    points[0].Y = - height;
    points[1].X = 0;
    points[1].Y = 0;
    points[2].X = - width/2;
    points[2].Y = - height;
    points[3].X = 0;
    points[3].Y = - height + middleInset;

    types[0] = PathPointTypeStart;
    types[1] = PathPointTypeLine;
    types[2] = PathPointTypeLine;
    types[3] = PathPointTypeLine;

    INT lastIndex = 2;

    if(middleInset != 0 && isFilled)
        lastIndex = 3;

    if(isFilled)
        types[lastIndex] |= PathPointTypeCloseSubpath;

    pathData->Count = lastIndex + 1;

    return Ok;
}

GpStatus
GpAdjustableArrowCap::Update()
{
    GpPointF points[4];
    BYTE types[4];
    GpPathData pathData;
    pathData.Points = &points[0];
    pathData.Types = &types[0];
    pathData.Count = 3;

    BaseCap   = LineCapTriangle;
    BaseInset = (Width != 0) ? (Height / Width) : 0;

    GetPathData(&pathData, Height, Width, MiddleInset, FillState);

    GpPath path(FillModeWinding);
    path.SetPathData(&pathData);

    if(FillState)
    {
        // Fill path only.

        SetFillPath(&path);
        SetStrokePath(NULL);
    }
    else
    {
        // Stroke path only.

        SetStrokePath(&path);
        SetFillPath(NULL);
    }

    return Ok;
}

ObjectType 
GpCustomLineCap::GetObjectType() const 
{
    return ObjectTypeCustomLineCap;
}

#define GDIP_CAPFLAGS_FILLPATH        0x00000001
#define GDIP_CAPFLAGS_STROKEPATH      0x00000002

class CustomLineCapData : public ObjectTypeData
{
public:
    INT32               Flags;
    INT32               BaseCap;
    REAL                BaseInset;
    INT32               StrokeStartCap;
    INT32               StrokeEndCap;
    INT32               StrokeJoin;
    REAL                StrokeMiterLimit;
    REAL                WidthScale;
    GpPointF            FillHotSpot;
    GpPointF            StrokeHotSpot;
};

UINT 
GpCustomLineCap::GetDataSize() const 
{ 
    ASSERT(IsValid());

    UINT            size           = sizeof(CustomLineCapData);
    INT             fillPathSize   = 0;
    INT             strokePathSize = 0;
    
    if ((GetFillPointCount() > 2) &&
        ((fillPathSize = FillPath->GetDataSize()) > 0))
    {
        ASSERT((fillPathSize & 0x03) == 0);
        size += sizeof(INT32) + fillPathSize;
    }
        
    if ((GetStrokePointCount() > 2) &&
        ((strokePathSize = StrokePath->GetDataSize()) > 0))
    {
        ASSERT((strokePathSize & 0x03) == 0);
        size += sizeof(INT32) + strokePathSize;
    }

    return size;
}

GpStatus 
GpCustomLineCap::GetData(
    IStream *       stream
    ) const 
{ 
    ASSERT(IsValid());

    INT             flags          = 0;
    INT             fillPathSize   = 0;
    INT             strokePathSize = 0;
    
    if ((GetFillPointCount() > 2) &&
        ((fillPathSize = FillPath->GetDataSize()) > 0))
    {
        ASSERT((fillPathSize & 0x03) == 0);
        flags |= GDIP_CAPFLAGS_FILLPATH;
    }
        
    if ((GetStrokePointCount() > 2) &&
        ((strokePathSize = StrokePath->GetDataSize()) > 0))
    {
        ASSERT((strokePathSize & 0x03) == 0);
        flags |= GDIP_CAPFLAGS_STROKEPATH;
    }

    CustomLineCapData   capData;
    
    capData.Type             = GetType();
    capData.Flags            = flags;
    capData.BaseCap          = BaseCap;
    capData.BaseInset        = BaseInset;
    capData.StrokeStartCap   = StrokeStartCap;
    capData.StrokeEndCap     = StrokeEndCap;
    capData.StrokeJoin       = StrokeJoin;
    capData.StrokeMiterLimit = StrokeMiterLimit;
    capData.WidthScale       = WidthScale;
    capData.FillHotSpot      = FillHotSpot;
    capData.StrokeHotSpot    = StrokeHotSpot;
    
    stream->Write(&capData, sizeof(capData), NULL);

    if (flags & GDIP_CAPFLAGS_FILLPATH)
    {
        stream->Write(&fillPathSize, sizeof(INT32), NULL);
        FillPath->GetData(stream);
    }

    if (flags & GDIP_CAPFLAGS_STROKEPATH)
    {
        stream->Write(&strokePathSize, sizeof(INT32), NULL);
        StrokePath->GetData(stream);
    }

    return Ok; 
}

GpStatus 
GpCustomLineCap::SetData(
    const BYTE *    dataBuffer, 
    UINT            size
    ) 
{ 
    this->Reset();

    if (dataBuffer == NULL)
    {
        WARNING(("dataBuffer is NULL"));
        return InvalidParameter;
    }

    if (size < sizeof(CustomLineCapData))
    {
        WARNING(("size too small"));
        return InvalidParameter;
    }

    const CustomLineCapData *   capData;
    capData = reinterpret_cast<const CustomLineCapData *>(dataBuffer);

    ASSERT((CustomLineCapType)(capData->Type) == CustomLineCapTypeDefault);

    if (!capData->MajorVersionMatches())
    {
        WARNING(("Version number mismatch"));
        return InvalidParameter;
    }

    BaseCap          = (GpLineCap)capData->BaseCap;
    BaseInset        = capData->BaseInset;
    StrokeStartCap   = (GpLineCap)capData->StrokeStartCap;
    StrokeEndCap     = (GpLineCap)capData->StrokeEndCap;
    StrokeJoin       = (GpLineJoin)capData->StrokeJoin;
    StrokeMiterLimit = capData->StrokeMiterLimit;
    WidthScale       = capData->WidthScale;
    FillHotSpot      = capData->FillHotSpot;
    StrokeHotSpot    = capData->StrokeHotSpot;

    dataBuffer += sizeof(CustomLineCapData);
    size       -= sizeof(CustomLineCapData);

    GpStatus    status = Ok;

    if (capData->Flags & GDIP_CAPFLAGS_FILLPATH)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        UINT    pathSize = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        if (size < pathSize)
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        if ((status = FillPath->SetData(dataBuffer, pathSize)) != Ok)
        {
            return status;
        }

        if(Ok == status)
        {
            status = ComputeFillCapLength();
        }

        dataBuffer += pathSize;
        size       -= pathSize;
    }

    if (capData->Flags & GDIP_CAPFLAGS_STROKEPATH)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        UINT    pathSize = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        if (size < pathSize)
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        status = StrokePath->SetData(dataBuffer, pathSize);

        if(Ok == status)
        {
            status = ComputeStrokeCapLength();
        }

        dataBuffer += pathSize;
        size       -= pathSize;
    }

    UpdateUid();
    return status;
}

class AdjustableArrowCapData : public ObjectTypeData
{
public:
    REAL                Width;
    REAL                Height;
    REAL                MiddleInset;
    INT32               FillState;
    INT32               StrokeStartCap;
    INT32               StrokeEndCap;
    INT32               StrokeJoin;
    REAL                StrokeMiterLimit;
    REAL                WidthScale;
    GpPointF            FillHotSpot;
    GpPointF            StrokeHotSpot;
};

UINT 
GpAdjustableArrowCap::GetDataSize() const 
{ 
    ASSERT(IsValid());

    return sizeof(AdjustableArrowCapData);
}

GpStatus 
GpAdjustableArrowCap::GetData(
    IStream *       stream
    ) const 
{ 
    ASSERT(IsValid());

    AdjustableArrowCapData   arrowCapData;

    arrowCapData.Type             = GetType();
    arrowCapData.Width            = Width;
    arrowCapData.Height           = Height;
    arrowCapData.MiddleInset      = MiddleInset;
    arrowCapData.FillState        = FillState;
    arrowCapData.StrokeStartCap   = StrokeStartCap;
    arrowCapData.StrokeEndCap     = StrokeEndCap;
    arrowCapData.StrokeJoin       = StrokeJoin;
    arrowCapData.StrokeMiterLimit = StrokeMiterLimit;
    arrowCapData.WidthScale       = WidthScale;
    arrowCapData.FillHotSpot      = FillHotSpot;
    arrowCapData.StrokeHotSpot    = StrokeHotSpot;
    
    stream->Write(&arrowCapData, sizeof(arrowCapData), NULL);
    
    return Ok;
}

GpStatus 
GpAdjustableArrowCap::SetData(
    const BYTE *    dataBuffer, 
    UINT            size
    ) 
{ 
    this->Reset();

    if (dataBuffer == NULL)
    {
        WARNING(("dataBuffer is NULL"));
        return InvalidParameter;
    }

    if (size < sizeof(AdjustableArrowCapData))
    {
        WARNING(("size too small"));
        return InvalidParameter;
    }

    const AdjustableArrowCapData *   arrowCapData;
    arrowCapData = reinterpret_cast<const AdjustableArrowCapData *>(dataBuffer);

    ASSERT((CustomLineCapType)(arrowCapData->Type) == CustomLineCapTypeAdjustableArrow);

    if (!arrowCapData->MajorVersionMatches())
    {
        WARNING(("Version number mismatch"));
        return InvalidParameter;
    }

    Width            = arrowCapData->Width;
    Height           = arrowCapData->Height;
    MiddleInset      = arrowCapData->MiddleInset;
    FillState        = arrowCapData->FillState;
    StrokeStartCap   = (GpLineCap)arrowCapData->StrokeStartCap;
    StrokeEndCap     = (GpLineCap)arrowCapData->StrokeEndCap;
    StrokeJoin       = (GpLineJoin)arrowCapData->StrokeJoin;
    StrokeMiterLimit = arrowCapData->StrokeMiterLimit;
    WidthScale       = arrowCapData->WidthScale;
    FillHotSpot      = arrowCapData->FillHotSpot;
    StrokeHotSpot    = arrowCapData->StrokeHotSpot;

    this->Update();

    UpdateUid();
    return Ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\drvtextout.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Engine text out routines.
*
* Revision History:
*
*   3/25/1999 cameronb
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

struct GlyphScanBuf
{
    INT left;
    INT top;
    INT bottom;
    INT widthInBytes;
    DpRegion::Visibility visibility;
};

const BYTE GRAYSCALE_LEVEL = 16;

/**************************************************************************\
*
* Function Description:
*
*   Draws text at a position.
*
* Arguments:
*
*   [IN] context    - the context (matrix and clipping)
*   [IN] surface    - the surface to fill
*   [IN] drawBounds - the surface bounds
*   [IN] text       - the typeset text to be drawn
*   [IN] font       - the font to use
*   [IN] fgBrush    - the brush to use for the text
*   [IN] bgBrush    - the brush to use for the background (default = NULL)
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   3/25/1999 cameronb
*
\**************************************************************************/

GpStatus
DpDriver::DrawGlyphs
(
    DrawGlyphData *drawGlyphData
)
{
    GpStatus status = GenericError;
    HDC hdc = NULL;

    ASSERT(!drawGlyphData->glyphPathPos);

    //  Choose appropriate brush behaviour

    switch(drawGlyphData->brush->Type)
    {
        case BrushTypeSolidColor:

            INT angle;  // Passed from GetTextOutputHdc to GdiText

            if (!(drawGlyphData->flags & DG_NOGDI))
            {
                hdc = drawGlyphData->context->GetTextOutputHdc(
                    drawGlyphData->faceRealization,
                    drawGlyphData->brush->SolidColor,
                    drawGlyphData->surface,
                    &angle
                );
            }
            if (hdc)
            {
                BOOL isClip;
                BOOL usePathClipping = FALSE;
                SetupClipping(hdc, drawGlyphData->context,
                              drawGlyphData->drawBounds, isClip,
                              usePathClipping, FALSE);

                status = GdiText(
                    hdc,
                    angle,
                    drawGlyphData->glyphs,
                    drawGlyphData->glyphOrigins,
                    drawGlyphData->glyphCount,
                    drawGlyphData->rightToLeft
                );
                RestoreClipping(hdc, isClip, usePathClipping);
                drawGlyphData->context->ReleaseTextOutputHdc(hdc);
            }
            else
            {

                status = SolidText(
                    drawGlyphData->context,
                    drawGlyphData->surface,
                    drawGlyphData->drawBounds,
                    drawGlyphData->brush->SolidColor,
                    drawGlyphData->glyphPos,
                    drawGlyphData->count,
                    drawGlyphData->faceRealization->RealizationMethod(),
                    drawGlyphData->rightToLeft
                );
            }
            break;

//        case BrushRectGrad:
//        case BrushRadialGrad:
        case BrushTypeTextureFill:
        case BrushTypeHatchFill:
//        case BrushTriangleGrad:
        case BrushTypePathGradient:
        case BrushTypeLinearGradient:

            status = BrushText(
                drawGlyphData->context,
                drawGlyphData->surface,
                drawGlyphData->drawBounds,
                drawGlyphData->brush,
                drawGlyphData->glyphPos,
                drawGlyphData->count,
                drawGlyphData->faceRealization->RealizationMethod()
            );
            break;

        default:
            status = GenericError;
            break;
    }

    return status;
}

static GpStatus
OutputSolidNormalText (
    DpContext* context,
    DpDriver *driver,
    DpBitmap* surface,
    const GpRect* drawBounds,
    GpColor   color,
    const GpGlyphPos *glyphPos,
    INT count
    )
{
    DpScanBuffer scan(
        surface->Scan,
        driver,
        context,
        surface,
        (color.IsOpaque() &&
        (!context->AntiAliasMode)));

    if (!scan.IsValid())
    {
        return(GenericError);
    }

    FPUStateSaver fpuState;

    ARGB argb = color.GetPremultipliedValue();

    DpOutputSolidColorSpan  outputSolid(argb, &scan);
    DpClipRegion * clipRegion = NULL;

    if (context->VisibleClip.GetRectVisibility(
        drawBounds->X, drawBounds->Y,
        drawBounds->GetRight(), drawBounds->GetBottom()) !=
        DpRegion::TotallyVisible)
    {
        clipRegion = &(context->VisibleClip);
        clipRegion->InitClipping(&outputSolid, drawBounds->Y);
    }

    for (int i = 0; i < count; i++)
    {
        INT left = glyphPos[i].GetLeft();
        INT top = glyphPos[i].GetTop();
#if 0
        printf("Drawing glyph at [%d,%d]\n", left, top);
#endif
        INT widthInPixels = glyphPos[i].GetWidth();
        INT right = left + widthInPixels;
        INT height = glyphPos[i].GetHeight();
        INT bottom = top + height;

        INT widthInBytes = (widthInPixels + 7) / 8;

        const BYTE* mask = glyphPos[i].GetBits();

        if (widthInPixels == 0 || height == 0)
            continue;

        ASSERT(mask != NULL);

        if (clipRegion != NULL)
        {
            //  Clipping
            GpRect clippedRect;
            DpRegion::Visibility visibility =
                clipRegion->GetRectVisibility(
                    left, top, right, bottom, &clippedRect
                );

            if (visibility == DpRegion::Invisible)
                continue;

            for (INT y = top, my = 0; y < bottom && my < height; y++, my++)
            {
                const BYTE* maskPtr = mask + my * widthInBytes;

                BYTE bit = 0x80;
                BYTE nextPixel = (*(maskPtr) & bit) ? 255 : 0;

                INT runStart = 0;

                for (INT mx = 0; mx < widthInPixels; mx++)
                {
                    BYTE pixel = nextPixel;

                    bit = (bit == 0x01) ? 0x80 : bit >> 1;
                    nextPixel = (mx == widthInPixels - 1)
                                    ? 0
                                    : ( (*(maskPtr + (mx + 1) / 8) & bit) ? 255 : 0);

                    if (pixel != nextPixel)
                    {
                        if (pixel)
                        {

                        //  Draw this run

                            INT runLength = mx - runStart + 1;
                            INT from = left + runStart;

                            if (visibility == DpRegion::TotallyVisible)
                            {

                            //  Draw the entire run

                                FillMemoryInt32( scan.NextBuffer(from, y, runLength),
                                                    runLength, argb);
                            }
                            else
                            {

                            //  Clip the run

                                INT to = from + runLength; // reference needed
                                clipRegion->OutputSpan(y, from, to);
                            }

                        };

                        if (nextPixel)
                        {
                            //  Start a new run
                            runStart = mx + 1;
                        }
                    }

                }
            }
        }
        else
        {
           //  No clipping
           for (INT y = top, my = 0; y < bottom && my < height; y++, my++)
           {
               const BYTE* maskPtr = mask + my * widthInBytes;
               BYTE bit = 0x80;

               INT runLength = 0;
               INT runStart;

               for (INT mx = 0; mx < widthInPixels; mx++)
               {
                   BOOL pixelOn = *(maskPtr + mx / 8) & bit;

                   if (pixelOn)
                   {
                       if (runLength == 0)
                       {
                           // Start a new run
                           runStart = mx;
                       }
                       runLength++;
                   }

                   if
                   (
                        runLength > 0 && !pixelOn
                        ||
                        runLength > 0 && mx == widthInPixels - 1
                   )
                   {
                       //  Finish this run and draw it
                       FillMemoryInt32(
                           scan.NextBuffer(left + runStart, y, runLength),
                           runLength, argb
                       );
                       runLength = 0;
                   };
                   bit = (bit == 0x01) ? 0x80 : bit >> 1;
               }
           }
        }
    }

    if (clipRegion != NULL)
    {
        clipRegion->EndClipping();
    }

    return(Ok);

}

static inline
VOID GetGlyphDimensions(
    const GpGlyphPos & glyphPos,
    INT * left,
    INT * top,
    INT * widthInPixels,
    INT * right,
    INT * height,
    INT * bottom
    )
{
    *left = glyphPos.GetLeft();
    *top = glyphPos.GetTop();
    *widthInPixels = glyphPos.GetWidth();
    *right = *left + *widthInPixels;
    *height = glyphPos.GetHeight();
    *bottom = *top + *height;
} // GetGlyphDimensions

template <typename MASKTYPE>
class DpOutputOptimizedSpan : public DpOutputSpan
{
public:
    typedef MASKTYPE    SCANMASKTYPE;

    DpOutputOptimizedSpan(DpScanBuffer * scan)
        : Scan(scan)
    {}

    virtual BOOL IsValid() const
    {
        return TRUE;
    }

    void SetMaskAndLeft(const MASKTYPE * maskPtr, INT left)
    {
        ASSERT(maskPtr != 0);
        MaskPtr = maskPtr;
        Left = left;
    }

protected:
    DpScanBuffer *  Scan;
    INT             Left;
    const MASKTYPE *MaskPtr;
};

template <class OUTPUT_SPAN>
static GpStatus
OutputTextOptimized(
    DpContext* context,
    const GpRect* drawBounds,
    const GpGlyphPos *glyphPos,
    INT count,
    OUTPUT_SPAN & outputSpan
    )
{
    ASSERT(context->CompositingMode == CompositingModeSourceOver);

    DpClipRegion * clipRegion = &(context->VisibleClip);
    clipRegion->InitClipping(&outputSpan, drawBounds->Y);

    // measure bounding box for all glyphs
    INT minX = INT_MAX, maxX = INT_MIN, minY = INT_MAX, maxY = INT_MIN;
    for (INT i = 0; i < count; ++i)
    {
        INT left, top, widthInPixels, right, height, bottom;
        GetGlyphDimensions(glyphPos[i], &left, &top, &widthInPixels, &right, &height, &bottom);

        if (widthInPixels == 0 ||
            height == 0 ||
            clipRegion->GetRectVisibility(left, top, right, bottom) ==
                DpRegion::Invisible)
            continue;

        if (left   < minX)  minX = left;
        if (top    < minY)  minY = top;
        if (right  > maxX)  maxX = right;
        if (bottom > maxY)  maxY = bottom;
    }

    ASSERT(drawBounds->GetLeft() <= minX);
    ASSERT(drawBounds->GetTop() <= minY);
    ASSERT(drawBounds->GetRight() >= maxX);
    ASSERT(drawBounds->GetBottom() >= maxY);

    if (minX >= maxX || minY >= maxY)
        return Ok;

    AutoArray<OUTPUT_SPAN::SCANMASKTYPE> scanLine(new OUTPUT_SPAN::SCANMASKTYPE[maxX - minX]);
    if (!scanLine)
        return OutOfMemory;

    outputSpan.SetMaskAndLeft(scanLine.Get(), minX);

    for (INT line = minY; line < maxY; ++line)
    {
        GpMemset(scanLine.Get(), 0, (maxX - minX) * sizeof(OUTPUT_SPAN::SCANMASKTYPE));

        for (INT i = 0; i < count; ++i)
        {
            INT left, top, widthInPixels, right, height, bottom;
            GetGlyphDimensions(glyphPos[i], &left, &top, &widthInPixels, &right, &height, &bottom);

            if (widthInPixels == 0 ||
                height == 0 ||
                top > line ||
                line >= bottom ||
                clipRegion->GetRectVisibility(left, top, right, bottom) ==
                    DpRegion::Invisible)
                continue; // is the last check necessary? [mleonov]

            // now, render glyph into the horizontal merge buffer

            outputSpan.RenderGlyph(
                glyphPos[i].GetBits(),
                &scanLine[left-minX],
                widthInPixels,
                line - top
            );
        }

        // now, clip and render scan line
        clipRegion->OutputSpan(line, minX, maxX);
    }

    clipRegion->EndClipping();

    return Ok;
} // OutputTextOptimized

class DpOutputSolidColorOptimizedSpan : public DpOutputOptimizedSpan<ARGB>
{
    typedef DpOutputOptimizedSpan<ARGB> super;

public:
    DpOutputSolidColorOptimizedSpan(DpScanBuffer * scan, ARGB argb)
        : super(scan), Argb(argb)
    {}

    virtual GpStatus OutputSpan(INT y, INT xMin, INT xMax)
    {
        INT width = xMax - xMin;
        const ARGB * maskPtr = MaskPtr + xMin - Left;
        ARGB * buf = Scan->NextBuffer(xMin, y, width);
        GpMemcpy(buf, maskPtr, width * sizeof(ARGB));
        return Ok;
    }

    void RenderGlyph(const BYTE * glyphBits,
                     SCANMASKTYPE * dst,
                     INT widthInPixels,
                     INT y)
    {
        const INT widthInBytes = (widthInPixels + 7) / 8;
        const BYTE * mask = glyphBits + widthInBytes * y;

        for (INT pos = 0; pos < widthInPixels; ++dst, ++pos)
        {
            if (!*dst && (mask[pos>>3] & (0x80 >> (pos & 7))))
                *dst = Argb;
        }
    } // RenderGlyph

protected:
    const ARGB  Argb;
}; // class DpOutputSolidColorOptimizedSpan

static GpStatus
OutputSolidNormalTextOptimized(
    DpContext* context,
    DpDriver *driver,
    DpBitmap* surface,
    const GpRect* drawBounds,
    const GpColor & color,
    const GpGlyphPos *glyphPos,
    INT count
    )
{
    DpScanBuffer scan(surface->Scan, driver, context, surface);

    if (!scan.IsValid())
        return GenericError;

    DpOutputSolidColorOptimizedSpan  outputSolid(&scan, color.GetPremultipliedValue());

    return OutputTextOptimized(context, drawBounds, glyphPos, count, outputSolid);
} // OutputSolidNormalTextOptimized

class DpOutputClearTypeOptimizedSpan : public DpOutputOptimizedSpan<BYTE>
{
    typedef DpOutputOptimizedSpan<BYTE> super;

public:
    DpOutputClearTypeOptimizedSpan(DpScanBuffer * scan)
        : super(scan)
    {}

    void RenderGlyph(const BYTE * glyphBits,
                     SCANMASKTYPE * dst,
                     INT widthInPixels,
                     INT y)
    {
        const BYTE * mask = glyphBits + widthInPixels * y;

        for (INT pos = 0; pos < widthInPixels; ++pos, ++dst)
        {
            const BYTE src = mask[pos];
            ASSERT(0 <= *dst && *dst <= CT_LOOKUP - 1);
            ASSERT(0 <= src && src <= CT_LOOKUP - 1);

            if (*dst == 0)
            {
                *dst = src;
            }
            else if (src != 0)
            {
                // merge ClearType data
                ULONG kR = (ULONG)Globals::gaOutTable[*dst].kR + (ULONG)Globals::gaOutTable[src].kR;
                ULONG kG = (ULONG)Globals::gaOutTable[*dst].kG + (ULONG)Globals::gaOutTable[src].kG;
                ULONG kB = (ULONG)Globals::gaOutTable[*dst].kB + (ULONG)Globals::gaOutTable[src].kB;

                if (kR > CT_SAMPLE_F) {kR = CT_SAMPLE_F;}
                if (kG > CT_SAMPLE_F) {kG = CT_SAMPLE_F;}
                if (kB > CT_SAMPLE_F) {kB = CT_SAMPLE_F;}

                *dst = Globals::FilteredCTLut[kB + 7 * kG + 49 * kR];
            }
        }
    } // RenderGlyph
}; // class DpOutputClearTypeOptimizedSpan

class DpOutputClearTypeSolidOptimizedSpan : public DpOutputClearTypeOptimizedSpan
{
    typedef DpOutputClearTypeOptimizedSpan super;

public:
    DpOutputClearTypeSolidOptimizedSpan(DpScanBuffer * scan)
        : super(scan)
    {}

    virtual GpStatus OutputSpan(INT y, INT xMin, INT xMax)
    {
        const INT width = xMax - xMin;
        const BYTE * maskPtr = MaskPtr + xMin - Left;
        Scan->NextBuffer(xMin, y, width);
        BYTE * buf = reinterpret_cast<BYTE *>(Scan->GetCurrentCTBuffer());
        for (INT i = 0; i < width; ++i)
        {
            ASSERT(0 <= *maskPtr && *maskPtr <= CT_LOOKUP - 1);
            *buf = *maskPtr;
            ++buf;
            ++maskPtr;
        }
        return Ok;
    }
}; // class DpOutputClearTypeSolidOptimizedSpan

class DpOutputClearTypeBrushOptimizedSpan : public DpOutputClearTypeOptimizedSpan
{
    typedef DpOutputClearTypeOptimizedSpan super;

public:
    DpOutputClearTypeBrushOptimizedSpan(DpScanBuffer * scan, DpOutputSpan * output)
        : super(scan), Output(output)
    {}

    virtual GpStatus OutputSpan(INT y, INT xMin, INT xMax)
    {
        GpStatus status = Output->OutputSpan(y, xMin, xMax);
        if (status != Ok)
            return status;

        const INT width = xMax - xMin;
        const BYTE * maskPtr = MaskPtr + xMin - Left;
        BYTE * buf = reinterpret_cast<BYTE *>(Scan->GetCurrentCTBuffer());
        for (INT i = 0; i < width; ++i)
        {
            ASSERT(0 <= *maskPtr && *maskPtr <= CT_LOOKUP - 1);
            *buf = *maskPtr;
            ++buf;
            ++maskPtr;
        }
        return Ok;
    }

protected:
    DpOutputSpan *  Output;
}; // class DpOutputClearTypeBrushOptimizedSpan

static GpStatus
OutputBrushClearTypeText(
    DpContext* context,
    DpDriver *driver,
    DpBitmap* surface,
    const GpRect* drawBounds,
    const DpBrush * brush,
    const GpGlyphPos *glyphPos,
    INT count
    )
{
    DpScanBuffer scan(
        surface->Scan,
        driver,
        context,
        surface,
        FALSE,
        EpScanTypeCT);

    if (!scan.IsValid())
    {
        return GenericError;
    }

    AutoPointer<DpOutputSpan> output(DpOutputSpan::Create(brush, &scan, context));
    if (!output)
        return OutOfMemory;

    DpOutputClearTypeBrushOptimizedSpan  outputCTSpan(&scan, output.Get());

    return OutputTextOptimized(context, drawBounds, glyphPos, count, outputCTSpan);
} // OutputBrushClearTypeText

static GpStatus
OutputSolidClearTypeText(
    DpContext* context,
    DpDriver *driver,
    DpBitmap* surface,
    const GpRect* drawBounds,
    GpColor color,
    const GpGlyphPos *glyphPos,
    INT count
    )
{
    DpScanBuffer scan(
        surface->Scan,
        driver,
        context,
        surface,
        FALSE,
        EpScanTypeCTSolidFill,
        PixelFormat32bppPARGB,
        PixelFormat32bppPARGB,
        color.GetValue());

    if (!scan.IsValid())
    {
        return GenericError;
    }

    DpOutputClearTypeSolidOptimizedSpan outputCTSpan(&scan);

    return OutputTextOptimized(context, drawBounds, glyphPos, count, outputCTSpan);
} // OutputSolidClearTypeText


class DpOutputAntiAliasSolidColorOptimizedSpan : public DpOutputOptimizedSpan<BYTE>
{
    typedef DpOutputOptimizedSpan<BYTE> super;

public:
    DpOutputAntiAliasSolidColorOptimizedSpan(DpScanBuffer * scan, const GpColor & color, ULONG gammaValue)
        : super(scan)
    {
        TextGammaTable.CreateTextColorGammaTable(&color, gammaValue, GRAYSCALE_LEVEL);
    }

    virtual GpStatus OutputSpan(INT y, INT xMin, INT xMax)
    {
        INT width = xMax - xMin;
        const BYTE * maskPtr = MaskPtr + xMin - Left;
        ARGB * buf = Scan->NextBuffer(xMin, y, width);

        for (ARGB * cur = buf; cur < buf + width; ++cur, ++maskPtr)
        {
            if (*maskPtr)
                *cur = TextGammaTable.argb[*maskPtr];
            else
                *cur = 0;
        }
        return Ok;
    }
protected:
    TextColorGammaTable TextGammaTable;

    BYTE MergeGrayscale(BYTE src, BYTE dst)
    {
        return max(src, dst);

/*      how do we correctly merge overlapping antialiased glyphs?
        we need to know if subpixels come from the same glyph
        UINT res = src + dst;
        if (res >= GsLevel)
            return GsLevel - 1;
        return (BYTE)res;
*/
    } // MergeGrayscale

}; // class DpOutputAntiAliasSolidColorOptimizedSpan

class DpOutputAntiAliasSolid8BPPOptimizedSpan : public DpOutputAntiAliasSolidColorOptimizedSpan
{
    typedef DpOutputAntiAliasSolidColorOptimizedSpan    super;
public:
    DpOutputAntiAliasSolid8BPPOptimizedSpan(DpScanBuffer * scan, const GpColor & color, ULONG gammaValue)
        : super(scan, color, gammaValue)
    {}

    void RenderGlyph(const BYTE * glyphBits,
                     SCANMASKTYPE * dst,
                     INT widthInPixels,
                     INT y)
    {
        const BYTE * mask = glyphBits + widthInPixels * y;

        for (INT pos = 0; pos < widthInPixels; ++pos, ++dst)
        {
            *dst = MergeGrayscale(*dst, mask[pos]);
        }
    } // RenderGlyph
}; // class DpOutputAntiAliasSolid8BPPOptimizedSpan

class DpOutputAntiAliasSolid4BPPOptimizedSpan : public DpOutputAntiAliasSolidColorOptimizedSpan
{
    typedef DpOutputAntiAliasSolidColorOptimizedSpan    super;
public:
    DpOutputAntiAliasSolid4BPPOptimizedSpan(DpScanBuffer * scan, const GpColor & color, ULONG gammaValue)
        : super(scan, color, gammaValue)
    {}

    void RenderGlyph(const BYTE * glyphBits,
                     SCANMASKTYPE * dst,
                     INT widthInPixels,
                     INT y)
    {
        const INT widthInBytes = (widthInPixels + 1) / 2;
        const BYTE * mask = glyphBits + widthInBytes * y;
        for (INT pos = 0; pos < widthInPixels; ++dst, ++pos)
        {
            BYTE value = mask[pos / 2];
            value >>= 4 * ((pos + 1) & 1);
            value &= 0x0F;
            *dst = MergeGrayscale(*dst, value);
        }
    } // RenderGlyph
}; // class DpOutputAntiAliasSolid4BPPOptimizedSpan

static GpStatus
OutputSolidAntiAliasText8BPPOptimized(
    DpContext*  context,
    DpDriver *  driver,
    DpBitmap*   surface,
    const       GpRect* drawBounds,
    GpColor     color,
    const       GpGlyphPos *glyphPos,
    INT         count
    )
{
    DpScanBuffer scan(surface->Scan, driver, context, surface);

    if (!scan.IsValid())
        return GenericError;

    DpOutputAntiAliasSolid8BPPOptimizedSpan outputAASolid(&scan, color, context->TextContrast);

    return OutputTextOptimized(context, drawBounds, glyphPos, count, outputAASolid);
} // OutputSolidAntiAliasText8BPPOptimized

static GpStatus
OutputSolidAntiAliasText4BPPOptimized(
    DpContext*  context,
    DpDriver *  driver,
    DpBitmap*   surface,
    const       GpRect* drawBounds,
    GpColor     color,
    const       GpGlyphPos *glyphPos,
    INT         count
    )
{
    DpScanBuffer scan(surface->Scan, driver, context, surface);

    if (!scan.IsValid())
        return GenericError;

    DpOutputAntiAliasSolid4BPPOptimizedSpan outputAASolid(&scan, color, context->TextContrast);
    return OutputTextOptimized(context, drawBounds, glyphPos, count, outputAASolid);
} // OutputSolidAntiAliasText4BPPOptimized

static GpStatus
OutputSolidAntiAliasText8BPP (
    DpContext*  context,
    DpDriver *  driver,
    DpBitmap*   surface,
    const       GpRect* drawBounds,
    GpColor     color,
    const       GpGlyphPos *glyphPos,
    INT         count
    )
{
    INT i;

    DpScanBuffer scan(
        surface->Scan,
        driver,
        context,
        surface,
        FALSE);

    if (!scan.IsValid())
    {
        return(GenericError);
    }

    FPUStateSaver fpuState;

    DpOutputAntiAliasSolidColorSpan  outputAASolid(color, &scan, context->TextContrast, GRAYSCALE_LEVEL);
    DpClipRegion * clipRegion = NULL;

    if (context->VisibleClip.GetRectVisibility(
        drawBounds->X, drawBounds->Y,
        drawBounds->GetRight(), drawBounds->GetBottom()) !=
        DpRegion::TotallyVisible)
    {
        clipRegion = &(context->VisibleClip);
        clipRegion->InitClipping(&outputAASolid, drawBounds->Y);
    }

//////////////////////////////////////////////////////////////////////////////

    for (i = 0; i < count; i++)
    {
        INT left = glyphPos[i].GetLeft();
        INT top = glyphPos[i].GetTop();
        INT widthInPixels = glyphPos[i].GetWidth();
        INT right = left + widthInPixels;
        INT height = glyphPos[i].GetHeight();
        INT bottom = top + height;

        if (widthInPixels == 0 || height == 0)
            continue;

        INT widthInBytes = widthInPixels;

        const BYTE* mask = glyphPos[i].GetBits();

        ASSERT(mask != NULL);

        if (clipRegion != NULL)
        {
            //  Clipping
            GpRect clippedRect;
            DpRegion::Visibility visibility =
                clipRegion->GetRectVisibility(
                    left, top, right, bottom, &clippedRect
                );

            if (visibility == DpRegion::Invisible)
                continue;

            for (INT y = top, my = 0; y < bottom && my < height; y++, my++)
            {
                const BYTE* maskPtr = mask + my * widthInBytes;

                BYTE grayscaleValue = *maskPtr;

                INT runStart = 0;

                for (INT mx = 0; mx <= widthInPixels; mx++)
                {
                    BYTE nextgrayscaleValue;

                    if (mx == widthInPixels)
                    {
                        nextgrayscaleValue = 0;
                    }
                    else
                    {
                        nextgrayscaleValue = *maskPtr;
                        maskPtr++;
                    }

                    if (grayscaleValue != nextgrayscaleValue)
                    {

                        if (grayscaleValue != 0)
                        {

                         //  Draw this run

                            INT runLength = mx - runStart;
                            INT from = left + runStart;

                            if (visibility == DpRegion::TotallyVisible)
                            {

                            //  Draw the entire run
                                FillMemoryInt32( scan.NextBuffer(from, y, runLength), runLength,
                                                    outputAASolid.GetAASolidColor((ULONG) grayscaleValue));
                            }
                            else
                            {

                            //  Clip the run

                                INT to = from + runLength; // reference needed
                                outputAASolid.GetAASolidColor((ULONG) grayscaleValue);

                                clipRegion->OutputSpan(y, from, to);
                            }

                            //  Start a new run
                            runStart = mx;
                            grayscaleValue = nextgrayscaleValue;
                        }
                        else
                        {
                         //  Start a new run
                            runStart = mx;
                            grayscaleValue = nextgrayscaleValue;
                        }
                    }
                }
            }
        }
        else
        {
            ARGB * buf;
            //  No clipping
            for (INT y = top, my = 0; y < bottom && my < height; y++, my++)
            {
                // Get the first byte in the scan line
                const BYTE* maskPtr = mask + my * widthInBytes;

                buf = scan.NextBuffer(left, y, widthInPixels);

                for (INT mx = 0; mx < widthInPixels; mx++)
                {
                    *buf++ = outputAASolid.GetAASolidColor((ULONG) *maskPtr);
                    maskPtr++;
                }
            }
        }
    }

    if (clipRegion != NULL)
    {
        clipRegion->EndClipping();
    }

    return(Ok);

}

static GpStatus
OutputSolidAntiAliasText4BPP (
    DpContext*  context,
    DpDriver *  driver,
    DpBitmap*   surface,
    const       GpRect* drawBounds,
    GpColor     color,
    const       GpGlyphPos *glyphPos,
    INT         count
    )
{
    INT i;

    DpScanBuffer scan(
        surface->Scan,
        driver,
        context,
        surface,
        FALSE);

    if (!scan.IsValid())
    {
        return(GenericError);
    }

    FPUStateSaver fpuState;

    DpOutputAntiAliasSolidColorSpan  outputAASolid(color, &scan, context->TextContrast, GRAYSCALE_LEVEL);
    DpClipRegion * clipRegion = NULL;

    if (context->VisibleClip.GetRectVisibility(
        drawBounds->X, drawBounds->Y,
        drawBounds->GetRight(), drawBounds->GetBottom()) !=
        DpRegion::TotallyVisible)
    {
        clipRegion = &(context->VisibleClip);
        clipRegion->InitClipping(&outputAASolid, drawBounds->Y);
    }

//////////////////////////////////////////////////////////////////////////////

    for (i = 0; i < count; i++)
    {
        INT left = glyphPos[i].GetLeft();
        INT top = glyphPos[i].GetTop();
        INT widthInPixels = glyphPos[i].GetWidth();
        INT right = left + widthInPixels;
        INT height = glyphPos[i].GetHeight();
        INT bottom = top + height;

        if (widthInPixels == 0 || height == 0)
            continue;

        INT widthInBytes = ((widthInPixels + 1) / 2);

        const BYTE* mask = glyphPos[i].GetBits();

        ASSERT(mask != NULL);

        if (clipRegion != NULL)
        {
            //  Clipping
            GpRect clippedRect;
            DpRegion::Visibility visibility =
                clipRegion->GetRectVisibility(
                    left, top, right, bottom, &clippedRect
                );

            if (visibility == DpRegion::Invisible)
                continue;

            for (INT y = top, my = 0; y < bottom && my < height; y++, my++)
            {
                const BYTE* maskPtr = mask + my * widthInBytes;

                BYTE grayscaleValue = *maskPtr >> 4;

                INT runStart = 0;

                for (INT mx = 0; mx <= widthInPixels; mx++)
                {
                    BYTE nextgrayscaleValue;

                    if (mx == widthInPixels)
                    {
                        nextgrayscaleValue = 0;
                    }
                    else
                    {
                       if (mx % 2)
                        {
                            nextgrayscaleValue = *maskPtr & 0x0F;
                            maskPtr++;
                        }
                        else
                        {
                            nextgrayscaleValue = *maskPtr >> 4;
                        }
                    }

                    if (grayscaleValue != nextgrayscaleValue)
                    {

                        if (grayscaleValue != 0)
                        {

                         //  Draw this run

                            INT runLength = mx - runStart;
                            INT from = left + runStart;

                            if (visibility == DpRegion::TotallyVisible)
                            {

                            //  Draw the entire run
                                FillMemoryInt32( scan.NextBuffer(from, y, runLength), runLength,
                                                    outputAASolid.GetAASolidColor((ULONG) grayscaleValue));
                            }
                            else
                            {

                            //  Clip the run

                                INT to = from + runLength; // reference needed
                                outputAASolid.GetAASolidColor((ULONG) grayscaleValue);

                                clipRegion->OutputSpan(y, from, to);
                            }

                            //  Start a new run
                            runStart = mx;
                            grayscaleValue = nextgrayscaleValue;
                        }
                        else
                        {
                         //  Start a new run
                            runStart = mx;
                            grayscaleValue = nextgrayscaleValue;
                        }
                    }
                }
            }
        }
        else
        {
            ARGB * buf;
            //  No clipping
            for (INT y = top, my = 0; y < bottom && my < height; y++, my++)
            {
                // Get the first byte in the scan line
                const BYTE* maskPtr = mask + my * widthInBytes;

                buf = scan.NextBuffer(left, y, widthInPixels);

                for (INT mx = 0; mx < widthInPixels; mx++)
                {
                    if (!(mx % 2))
                        *buf++ = outputAASolid.GetAASolidColor((ULONG) (*maskPtr >> 4));
                    else
                    {
                        *buf++ = outputAASolid.GetAASolidColor((ULONG) (*maskPtr & 0x0F));
                        maskPtr++;
                    }
                }
            }
        }
    }

    if (clipRegion != NULL)
    {
        clipRegion->EndClipping();
    }

    return(Ok);

}

/**************************************************************************\
*
* Function Description:
*
*   Engine version of routine to draw solid text.
*
* Arguments:
*
*   [IN] - DDI parameters.
*
* Return Value:
*
*   TRUE if successful.
*
* History:
*
*   4/4/1999 cameronb
*       Created it.
*
\**************************************************************************/

GpStatus
DpDriver::SolidText(
    DpContext* context,
    DpBitmap* surface,
    const GpRect* drawBounds,
    GpColor   color,
    const GpGlyphPos *glyphPos,
    INT count,
    TextRenderingHint textMode,
    BOOL rightToLeft
    )
{
    ASSERT (textMode != TextRenderingHintSystemDefault);
    switch(textMode)
    {
        case TextRenderingHintSingleBitPerPixelGridFit:
        case TextRenderingHintSingleBitPerPixel:
            if (context->CompositingMode == CompositingModeSourceCopy)
                return OutputSolidNormalText(context, this, surface, drawBounds, color, glyphPos, count);
            // we are allowed to output transparent pixels
            // version with minimized number of scan records
            return OutputSolidNormalTextOptimized(context, this, surface, drawBounds, color, glyphPos, count);

        case TextRenderingHintAntiAlias:
            if (context->CompositingMode == CompositingModeSourceCopy)
                return OutputSolidAntiAliasText8BPP(context, this, surface, drawBounds, color, glyphPos, count);
            return OutputSolidAntiAliasText8BPPOptimized(context, this, surface, drawBounds, color, glyphPos, count);
        case TextRenderingHintAntiAliasGridFit:
            if (context->CompositingMode == CompositingModeSourceCopy)
                return OutputSolidAntiAliasText4BPP(context, this, surface, drawBounds, color, glyphPos, count);

            return OutputSolidAntiAliasText4BPPOptimized(context, this, surface, drawBounds, color, glyphPos, count);

        case TextRenderingHintClearTypeGridFit:
            return OutputSolidClearTypeText(context, this, surface, drawBounds, color, glyphPos, count);
        default:
            break;
    }

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Engine version of routine to draw text based on a brush.
*
* Arguments:
*
*   [IN] - DDI parameters.
*
* Return Value:
*
*   TRUE if successful.
*
* History:
*   5-1-2000 YungT rewrite it.
*   2/7/2000 YungT modify it.
*   4/14/1999 cameronb
*       Created it.
*
\**************************************************************************/
static GpStatus
OutputBrushNormalText(
    DpContext*        context,
    DpDriver *        driver,
    DpBitmap*         surface,
    const GpRect*     drawBounds,
    const DpBrush*    brush,
    const GpGlyphPos* glyphPos,
    INT               count
    )
{
    DpScanBuffer scan(
        surface->Scan,
        driver,
        context,
        surface,
        FALSE); // (color64.IsOpaque() &&
                // (!context->AntiAliasMode)));
                // !!! If you fix this, you'll get a perf improvement for
                // text that has no transparency.

    if (!scan.IsValid())
    {
        return(GenericError);
    }

    FPUStateSaver fpuState;

    DpOutputSpan* output = DpOutputSpan::Create(brush, &scan, context);

    if (output != NULL)
    {

        INT i;
        INT my;
        GlyphScanBuf glyphScanBuf[256], *pglyphScanBuf;
        DpClipRegion* clipRegion = NULL;

        INT topY = drawBounds->Y;
        INT bottomY = drawBounds->GetBottom();

    // Allocate enough space for glyph scan buffer
        if (count < 256)
        {
            pglyphScanBuf = &glyphScanBuf[0];
        }
        else
        {
            pglyphScanBuf = (GlyphScanBuf *) GpMalloc(count * sizeof(GlyphScanBuf));

            if (!pglyphScanBuf)
                return (OutOfMemory);
        }

        if (context->VisibleClip.GetRectVisibility(drawBounds->X, topY, drawBounds->GetRight(),
                                                    bottomY) != DpRegion::TotallyVisible)
        {
            clipRegion = &(context->VisibleClip);
            clipRegion->InitClipping(output, drawBounds->Y);
        }


        // Scan evrey Glyph and get the Visibility
        // Also we cache some data we will need to for later computation
        for (i = 0; i < count; i++)
        {
            GpRect clippedRect;
            pglyphScanBuf[i].left = glyphPos[i].GetLeft();
            pglyphScanBuf[i].top = glyphPos[i].GetTop();
            pglyphScanBuf[i].widthInBytes = (glyphPos[i].GetWidth() + 7) / 8;
            pglyphScanBuf[i].bottom = pglyphScanBuf[i].top + glyphPos[i].GetHeight();

            // Set the glyph as invisible if it is empty.
            if (glyphPos[i].GetWidth() == 0 || glyphPos[i].GetHeight() == 0)
                pglyphScanBuf[i].visibility = DpRegion::Invisible;
            else if (clipRegion != NULL)
                pglyphScanBuf[i].visibility = clipRegion->GetRectVisibility(pglyphScanBuf[i].left,
                                                                        pglyphScanBuf[i].top,
                                                                        pglyphScanBuf[i].left + glyphPos[i].GetWidth(),
                                                                        pglyphScanBuf[i].bottom, &clippedRect);
            else
                pglyphScanBuf[i].visibility = DpRegion::TotallyVisible;

        }

        // Start to scan from top of bounding box to bottom
        for (int y = topY; y < bottomY; y++)
        {
            for (i = 0; i < count; i++)
            {
                const BYTE* maskPtr;

                INT runLength, runStart;
                INT from, to;

                BYTE thisBit;
                BYTE nextPixel;
                BYTE pixel;

                // Invisible glyph
                if (pglyphScanBuf[i].visibility == DpRegion::Invisible)
                {
                    continue;
                }

                // check the scan line with y.top and y.bottom
                if (y < pglyphScanBuf[i].top || y >= pglyphScanBuf[i].bottom)
                    continue;

                if (pglyphScanBuf[i].visibility != DpRegion::TotallyVisible)
                {
                    // Get the relateive y-scan line for each glyph
                    my = y - pglyphScanBuf[i].top;

                    // Get the address of glyph bits
                    maskPtr = glyphPos[i].GetBits();

                    ASSERT(maskPtr != NULL);

                    maskPtr += my * pglyphScanBuf[i].widthInBytes;

                    thisBit = 0x80;
                    nextPixel = (*(maskPtr) & thisBit) ? 255 : 0;

                    runStart = 0;

                    for (INT mx = 0; mx < glyphPos[i].GetWidth(); mx++)
                    {
                        pixel = nextPixel;
                        thisBit = (thisBit == 0x01) ? 0x80 : thisBit >> 1;
                        nextPixel = (mx == glyphPos[i].GetWidth() - 1) ? 0 : ( (*(maskPtr + (mx + 1) / 8) & thisBit) ? 255 : 0);

                        if (pixel != nextPixel)
                        {
                            if (pixel)
                            {
                                //  Draw this run
                                runLength = mx - runStart + 1;

                                //  Clip the run
                                 from = pglyphScanBuf[i].left + runStart;
                                 to =   from + runLength;

                                 clipRegion->OutputSpan(y, from, to);
                            }

                            if (nextPixel)
                            {
                            //  Start a new run
                                runStart = mx + 1;
                            }
                        }

                    }
                }
                else
                {
                    my = y - pglyphScanBuf[i].top;

                    maskPtr = glyphPos[i].GetBits();

                    ASSERT(maskPtr != NULL);

                    maskPtr += my * pglyphScanBuf[i].widthInBytes;

                    thisBit = 0x80;

                    runLength = 0;

                    for (INT mx = 0; mx < glyphPos[i].GetWidth(); mx++)
                    {
                        BOOL pixelOn = *(maskPtr + mx / 8) & thisBit;

                        if (pixelOn)
                        {
                            if (runLength == 0)
                            {
                            // Start a new run
                                runStart = mx;
                            }

                            runLength++;
                        }

                        if (runLength > 0 && !pixelOn || runLength > 0 && mx == glyphPos[i].GetWidth() - 1)
                        {
                            //  Finish this run and draw it
                            from = pglyphScanBuf[i].left + runStart;
                            to =   from + runLength;
                            output->OutputSpan(y, from, to);
                            runLength = 0;
                        };

                        thisBit = (thisBit == 0x01) ? 0x80 : thisBit >> 1;
                    }
                }
            }

        } // next scan line

        if (clipRegion != NULL)
        {
            clipRegion->EndClipping();
        }

        delete output;

        if (pglyphScanBuf != &glyphScanBuf[0])
            GpFree(pglyphScanBuf);

    }

    return(Ok);
}



/**************************************************************************\
*
* Function Description:
*
*   Antialias version of routine to draw text based on a brush.
*
* Arguments:
*
*   [IN] - same as DDI parameters.
*
* Return Value:
*
*   Ok if successful.
*
* History:
*
*   2/20/00 YungT
*       Created it.
*
\**************************************************************************/

static GpStatus
OutputBrushAntiAliasText8BPP(
    DpContext*          context,
    DpDriver *          driver,
    DpBitmap*           surface,
    const GpRect*       drawBounds,
    const DpBrush*      brush,
    const GpGlyphPos*   glyphPos,
    INT                 count
    )
{
    DpScanBuffer scan(
        surface->Scan,
        driver,
        context,
        surface,
        FALSE); // (color64.IsOpaque() &&
                // (!context->AntiAliasMode)));
                // !!! If you fix this, you'll get a perf improvement for
                // text that has no transparency.

    if (!scan.IsValid())
    {
        return(GenericError);
    }

    DpOutputSpan* output = DpOutputSpan::Create(brush, &scan, context);

    DpOutputAntiAliasBrushOutputSpan aaBrushSpan;

    if (output != NULL)
    {
        INT i;

        TextColorGammaTable textContrastTable;
        textContrastTable.CreateTextColorGammaTable((GpColor *) NULL, context->TextContrast, GRAYSCALE_LEVEL);

        DpClipRegion* clipRegion = NULL;

        if (context->VisibleClip.GetRectVisibility( drawBounds->X, drawBounds->Y,
                                                    drawBounds->GetRight(), drawBounds->GetBottom()) !=
                                                    DpRegion::TotallyVisible)
        {
            aaBrushSpan.Init(output);

            clipRegion = &(context->VisibleClip);
            clipRegion->InitClipping(&aaBrushSpan, drawBounds->Y);
        }

        for (i = 0; i < count; i++)
        {
            INT left = glyphPos[i].GetLeft();
            INT top = glyphPos[i].GetTop();
            INT widthInPixels = glyphPos[i].GetWidth();
            INT right = left + widthInPixels;
            INT height = glyphPos[i].GetHeight();
            INT bottom = top + height;

            if (widthInPixels == 0 || height == 0)
                continue;

            INT widthInBytes = widthInPixels;

            const BYTE* mask = glyphPos[i].GetBits();

            ASSERT(mask != NULL);

            if (clipRegion != NULL)
            {
                GpRect clippedRect;
                DpRegion::Visibility visibility =
                        clipRegion->GetRectVisibility(left, top, right, bottom, &clippedRect);

                if (visibility == DpRegion::Invisible)
                    continue;

                for (INT y = top, my = 0; y < bottom && my < height; y++, my++)
                {
                    const BYTE* maskPtr = mask + my * widthInBytes;

                    BYTE grayscaleValue = *maskPtr;

                    INT runStart = 0;

                    for (INT mx = 0; mx <= widthInPixels; mx++)
                    {
                        BYTE nextgrayscaleValue;

                        if (mx == widthInPixels)
                        {
                            nextgrayscaleValue = 0;
                        }
                        else
                        {
                            nextgrayscaleValue = *maskPtr;
                            maskPtr++;
                        }

                        if (grayscaleValue != nextgrayscaleValue)
                        {

                            if (grayscaleValue != 0)
                            {

                             //  Draw this run

                                INT runLength = mx - runStart;
                                INT from = left + runStart;

                                if (visibility == DpRegion::TotallyVisible)
                                {

                                //  Clip the run
                                    INT to = from + runLength; // reference needed
                                    output->OutputSpan(y, from, to);

                                    ARGB *buffer;
                                    buffer = output->GetScanBuffer()->GetCurrentBuffer();

                                    for (INT j = from; j < to; j++)
                                    {
                                        *buffer++ = GpColor::MultiplyCoverage(*buffer,
                                                           textContrastTable.GetGammaTableIndexValue(grayscaleValue, GRAYSCALE_LEVEL));
                                    }

                                }
                                else
                                {

                                //  Clip the run

                                    INT to = from + runLength; // reference needed
                                    aaBrushSpan.SetCoverage(textContrastTable.GetGammaTableIndexValue(grayscaleValue, GRAYSCALE_LEVEL));

                                    clipRegion->OutputSpan(y, from, to);
                                }

                                //  Start a new run
                                runStart = mx;
                                grayscaleValue = nextgrayscaleValue;
                            }
                            else
                            {
                             //  Start a new run
                                runStart = mx;
                                grayscaleValue = nextgrayscaleValue;
                            }
                        }
                    }
                }
            }
            else
            {


                for (INT y = top, my = 0; y < bottom && my < height; y++, my++)
                {
                    const BYTE* maskPtr = mask + my * widthInBytes;

                    BYTE grayscaleValue = *maskPtr;

                    INT runStart = 0;

                    for (INT mx = 0; mx <= widthInPixels; mx++)
                    {
                        BYTE nextgrayscaleValue;

                        if (mx == widthInPixels)
                        {
                            nextgrayscaleValue = 0;
                        }
                        else
                        {
                            nextgrayscaleValue = *maskPtr;
                            maskPtr++;
                        }

                        if (grayscaleValue != nextgrayscaleValue)
                        {

                            if (grayscaleValue != 0)
                            {
                             //  Draw this run

                                INT runLength = mx - runStart;
                                INT from = left + runStart;


                            //  Clip the run
                                INT to = from + runLength; // reference needed

                                output->OutputSpan(y, from, to);
                                ARGB *buffer;
                                buffer = output->GetScanBuffer()->GetCurrentBuffer();
                                for (INT j = from; j < to; j++)
                                {
                                    *buffer++ = GpColor::MultiplyCoverage(*buffer,
                                                           textContrastTable.GetGammaTableIndexValue(grayscaleValue, GRAYSCALE_LEVEL));
                                }

                             //  Start a new run
                                runStart = mx;
                                grayscaleValue = nextgrayscaleValue;
                            }
                            else
                            {
                             //  Start a new run
                                runStart = mx;
                                grayscaleValue = nextgrayscaleValue;
                            }
                        }
                    }
                }
            }
        }

        if (clipRegion != NULL)
        {
            clipRegion->EndClipping();
        }

        delete output;
    }

    return(Ok);
}

/**************************************************************************\
*
* Function Description:
*
*   Antialias version of routine to draw text based on a brush.
*
* Arguments:
*
*   [IN] - same as DDI parameters.
*
* Return Value:
*
*   Ok if successful.
*
* History:
*
*   1/28/00 YungT
*       Created it.
*
\**************************************************************************/

static GpStatus
OutputBrushAntiAliasText4BPP(
    DpContext*          context,
    DpDriver *          driver,
    DpBitmap*           surface,
    const GpRect*       drawBounds,
    const DpBrush*      brush,
    const GpGlyphPos*   glyphPos,
    INT                 count
    )
{
    DpScanBuffer scan(
        surface->Scan,
        driver,
        context,
        surface,
        FALSE); // (color64.IsOpaque() &&
                // (!context->AntiAliasMode)));
                // !!! If you fix this, you'll get a perf improvement for
                // text that has no transparency.

    if (!scan.IsValid())
    {
        return(GenericError);
    }

    DpOutputSpan* output = DpOutputSpan::Create(brush, &scan, context);

    DpOutputAntiAliasBrushOutputSpan aaBrushSpan;

    if (output != NULL)
    {
        INT i;

        TextColorGammaTable textContrastTable;
        textContrastTable.CreateTextColorGammaTable((GpColor *) NULL, context->TextContrast, GRAYSCALE_LEVEL);

        DpClipRegion* clipRegion = NULL;

        if (context->VisibleClip.GetRectVisibility( drawBounds->X, drawBounds->Y,
                                                    drawBounds->GetRight(), drawBounds->GetBottom()) !=
                                                    DpRegion::TotallyVisible)
        {
            aaBrushSpan.Init(output);

            clipRegion = &(context->VisibleClip);
            clipRegion->InitClipping(&aaBrushSpan, drawBounds->Y);
        }

        for (i = 0; i < count; i++)
        {
            INT left = glyphPos[i].GetLeft();
            INT top = glyphPos[i].GetTop();
            INT widthInPixels = glyphPos[i].GetWidth();
            INT right = left + widthInPixels;
            INT height = glyphPos[i].GetHeight();
            INT bottom = top + height;

            if (widthInPixels == 0 || height == 0)
                continue;

            INT widthInBytes = ((widthInPixels + 1) / 2);

            const BYTE* mask = glyphPos[i].GetBits();

            ASSERT(mask != NULL);

            if (clipRegion != NULL)
            {
                GpRect clippedRect;
                DpRegion::Visibility visibility =
                        clipRegion->GetRectVisibility(left, top, right, bottom, &clippedRect);

                if (visibility == DpRegion::Invisible)
                    continue;

                for (INT y = top, my = 0; y < bottom && my < height; y++, my++)
                {
                    const BYTE* maskPtr = mask + my * widthInBytes;

                    BYTE grayscaleValue = *maskPtr >> 4;

                    INT runStart = 0;

                    for (INT mx = 0; mx <= widthInPixels; mx++)
                    {
                        BYTE nextgrayscaleValue;

                        if (mx == widthInPixels)
                        {
                            nextgrayscaleValue = 0;
                        }
                        else
                        {
                           if (mx % 2)
                            {
                                nextgrayscaleValue = *maskPtr & 0x0F;
                                maskPtr++;
                            }
                            else
                            {
                                nextgrayscaleValue = *maskPtr >> 4;
                            }
                        }

                        if (grayscaleValue != nextgrayscaleValue)
                        {

                            if (grayscaleValue != 0)
                            {

                             //  Draw this run

                                INT runLength = mx - runStart;
                                INT from = left + runStart;

                                if (visibility == DpRegion::TotallyVisible)
                                {

                                //  Clip the run
                                    INT to = from + runLength; // reference needed
                                    output->OutputSpan(y, from, to);

                                    ARGB *buffer;
                                    buffer = output->GetScanBuffer()->GetCurrentBuffer();

                                    for (INT j = from; j < to; j++)
                                    {
                                        *buffer++ = GpColor::MultiplyCoverage(*buffer,
                                                           textContrastTable.GetGammaTableIndexValue(grayscaleValue, GRAYSCALE_LEVEL));
                                    }

                                }
                                else
                                {

                                //  Clip the run

                                    INT to = from + runLength; // reference needed
                                    aaBrushSpan.SetCoverage(textContrastTable.GetGammaTableIndexValue(grayscaleValue, GRAYSCALE_LEVEL));

                                    clipRegion->OutputSpan(y, from, to);
                                }

                                //  Start a new run
                                runStart = mx;
                                grayscaleValue = nextgrayscaleValue;
                            }
                            else
                            {
                             //  Start a new run
                                runStart = mx;
                                grayscaleValue = nextgrayscaleValue;
                            }
                        }
                    }
                }
            }
            else
            {


                for (INT y = top, my = 0; y < bottom && my < height; y++, my++)
                {
                    const BYTE* maskPtr = mask + my * widthInBytes;

                    BYTE grayscaleValue = *maskPtr >> 4;

                    INT runStart = 0;

                    for (INT mx = 0; mx <= widthInPixels; mx++)
                    {
                        BYTE nextgrayscaleValue;

                        if (mx == widthInPixels)
                        {
                            nextgrayscaleValue = 0;
                        }
                        else
                        {
                            if (mx % 2)
                            {
                                nextgrayscaleValue = *maskPtr & 0x0F;
                                maskPtr++;
                            }
                            else
                            {
                                nextgrayscaleValue = *maskPtr >> 4;
                            }
                        }

                        if (grayscaleValue != nextgrayscaleValue)
                        {

                            if (grayscaleValue != 0)
                            {
                             //  Draw this run

                                INT runLength = mx - runStart;
                                INT from = left + runStart;


                            //  Clip the run
                                INT to = from + runLength; // reference needed

                                output->OutputSpan(y, from, to);
                                ARGB *buffer;
                                buffer = output->GetScanBuffer()->GetCurrentBuffer();
                                for (INT j = from; j < to; j++)
                                {
                                    *buffer++ = GpColor::MultiplyCoverage(*buffer,
                                                           textContrastTable.GetGammaTableIndexValue(grayscaleValue, GRAYSCALE_LEVEL));
                                }

                             //  Start a new run
                                runStart = mx;
                                grayscaleValue = nextgrayscaleValue;
                            }
                            else
                            {
                             //  Start a new run
                                runStart = mx;
                                grayscaleValue = nextgrayscaleValue;
                            }
                        }
                    }
                }
            }
        }

        if (clipRegion != NULL)
        {
            clipRegion->EndClipping();
        }

        delete output;
    }

    return(Ok);
}

/**************************************************************************\
*
* Function Description:
*
*   Engine version of routine to draw solid text.
*
* Arguments:
*
*   [IN] - DDI parameters.
*
* Return Value:
*
*   TRUE if successful.
*
* History:
*   1/24/2000 YungT modified it
*   4/4/1999 cameronb
*       Created it.
*
\**************************************************************************/

GpStatus
DpDriver::BrushText(
    DpContext* context,
    DpBitmap* surface,
    const GpRect* drawBounds,
    const DpBrush*    brush,
    const GpGlyphPos *glyphPos,
    INT count,
    TextRenderingHint textMode
    )
{
    ASSERT (textMode != TextRenderingHintSystemDefault);
    switch(textMode)
    {
        case TextRenderingHintSingleBitPerPixelGridFit:
        case TextRenderingHintSingleBitPerPixel:
            return OutputBrushNormalText(context, this, surface, drawBounds, brush, glyphPos, count);
        case TextRenderingHintAntiAlias:
            return OutputBrushAntiAliasText8BPP(context, this, surface, drawBounds, brush, glyphPos, count);
        case TextRenderingHintAntiAliasGridFit:
            return OutputBrushAntiAliasText4BPP(context, this, surface, drawBounds, brush, glyphPos, count);
// version 2 :
//        case TextRenderingHintClearType:
        case TextRenderingHintClearTypeGridFit:
            return OutputBrushClearTypeText(context, this, surface, drawBounds, brush, glyphPos, count);
        default:
            break;
    }

    return Ok;

}






/////   GdiText - Draw glyph on downlevel DC
//
//      !!! Optimize to use lpdx
//      NOTE:
//      Here we explicitly call ExtTextOutW because we calling it with
//      ETO_GLYPH_INDEX. It will be fine even if we are running on Windows 9x
//      because internally it calls ExtTextOutA.
//      We didn't use Global::ExtTextOutFunction because we don't want to call
//      ExtTextOutA with ETO_GLYPH_INDEX while recording to a Meta file under
//      Windows 9x. And in that case Windows 9x fails to record it.
//      The code in Windows 9x is recording glyph indexes only if we are spooling
//      only otherwise it will not record.

GpStatus
DpDriver::GdiText(
    HDC             hdc,
    INT             angle,  // Tenths of a degree
    const UINT16   *glyphs,
    const PointF   *glyphOrigins,
    INT             glyphCount,
    BOOL            rightToLeft,
    UINT16          blankGlyph
)
{
    UINT16 lastTwoGlyphs[2];

    if (    glyphCount > 1
        &&  angle == 0)
    {
        // Try to optimise for horizintal text. (We don't try for vertical
        // text since GDI and GDI+ rotation semantics are not compatible)

        INT i=1;
        while (    i < glyphCount
               &&  abs(GpRound(glyphOrigins[i].Y - glyphOrigins[i-1].Y)) == 0)
        {
            i++;
        }

        if (i == glyphCount)
        {
            // All text is at the same dy

            AutoArray<INT> advances(new INT[glyphCount]);

            if (!advances)
            {
                return OutOfMemory;
            }

            if (rightToLeft && !Globals::IsNt && glyphCount>1)
            {
                // Windows 9x doesn't work with the negative advanced widths

                AutoArray<UINT16> bidiGlyphs(new UINT16[glyphCount]);
                if (!bidiGlyphs)
                {
                    return OutOfMemory;
                }

                for (i=0; i<glyphCount-1; i++)
                {
                    bidiGlyphs[i] = glyphs[glyphCount - i - 1];
                    advances[i]   = GpRound(glyphOrigins[glyphCount- i - 2].X - glyphOrigins[glyphCount- i - 1].X);
                }

                bidiGlyphs[glyphCount-1] = glyphs[0];
                advances[glyphCount-1]   = 0;

                if (blankGlyph > 0 && (glyphCount & 1))
                {
                    if (!ExtTextOutW(
                        hdc,
                        GpRound(glyphOrigins[glyphCount - 1].X),
                        GpRound(glyphOrigins[glyphCount - 1].Y),
                        ETO_GLYPH_INDEX,
                        NULL,
                        (PWSTR)bidiGlyphs.Get(),
                        glyphCount-1,
                        advances.Get()
                    )) {
                        return Win32Error;
                    }

                    lastTwoGlyphs[0] = bidiGlyphs[glyphCount-1];
                    lastTwoGlyphs[1] = blankGlyph;
                    
                    if (!ExtTextOutW(
                        hdc,
                        GpRound(glyphOrigins[0].X),
                        GpRound(glyphOrigins[0].Y),
                        ETO_GLYPH_INDEX,
                        NULL,
                        (PWSTR)lastTwoGlyphs,
                        2,
                        NULL
                    )) {
                        return Win32Error;
                    }
                }
                else
                {
                    if (!ExtTextOutW(
                        hdc,
                        GpRound(glyphOrigins[glyphCount - 1].X),
                        GpRound(glyphOrigins[glyphCount - 1].Y),
                        ETO_GLYPH_INDEX,
                        NULL,
                        (PWSTR)bidiGlyphs.Get(),
                        glyphCount,
                        advances.Get()
                    )) {
                        return Win32Error;
                    }
                }
                return Ok;
            }


            INT offset = GpRound(glyphOrigins[0].X);

            for (i=0; i<glyphCount-1; i++)
            {
                advances[i] = GpRound(glyphOrigins[i+1].X) - offset;
                offset += advances[i];
            }
            advances[glyphCount-1] = 0;


            if (blankGlyph > 0 && (glyphCount & 1))
            {
                if (!ExtTextOutW(
                    hdc,
                    GpRound(glyphOrigins[0].X),
                    GpRound(glyphOrigins[0].Y),
                    ETO_GLYPH_INDEX,
                    NULL,
                    (PWSTR)glyphs,
                    glyphCount-1,
                    advances.Get()
                )) {
                    return Win32Error;
                }

                lastTwoGlyphs[0] = glyphs[glyphCount-1];
                lastTwoGlyphs[1] = blankGlyph;
                
                if (!ExtTextOutW(
                    hdc,
                    GpRound(glyphOrigins[glyphCount-1].X),
                    GpRound(glyphOrigins[glyphCount-1].Y),
                    ETO_GLYPH_INDEX,
                    NULL,
                    (PWSTR)lastTwoGlyphs,
                    2,
                    NULL
                )) {
                    return Win32Error;
                }
            }
            else
            {
                if (!ExtTextOutW(
                    hdc,
                    GpRound(glyphOrigins[0].X),
                    GpRound(glyphOrigins[0].Y),
                    ETO_GLYPH_INDEX,
                    NULL,
                    (PWSTR)glyphs,
                    glyphCount,
                    advances.Get()
                )) {
                    return Win32Error;
                }
            }

            
            return Ok;
        }
    }



    if (blankGlyph > 0)
    {
        lastTwoGlyphs[1] = blankGlyph;
        
        for (INT i=0; i<glyphCount; i++)
        {
            if (glyphs[i] != 0xffff)    // 0xffff is never displayed
            {
                lastTwoGlyphs[0] = glyphs[i];
            
                if (!ExtTextOutW(
                    hdc,
                    GpRound(glyphOrigins[i].X),
                    GpRound(glyphOrigins[i].Y),
                    ETO_GLYPH_INDEX,
                    NULL,
                    (PWSTR)lastTwoGlyphs,
                    2,
                    NULL
                )) {
                    return Win32Error;
                }
            }
        }
    }
    else
    {
        // Failed to optimise ...
        for (INT i=0; i<glyphCount; i++)
        {
            if (glyphs[i] != 0xffff)    // 0xffff is never displayed
            {
                if (!ExtTextOutW(
                    hdc,
                    GpRound(glyphOrigins[i].X),
                    GpRound(glyphOrigins[i].Y),
                    ETO_GLYPH_INDEX,
                    NULL,
                    (PWSTR)glyphs+i,
                    1,
                    NULL
                )) {
                    return Win32Error;
                }
            }
        }
    }

    return Ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\dispnotify.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998-1999  Microsoft Corporation
*
* Abstract:
*
*  Display/Palette notification routines for GDI+.
*
* Revision History:
*
*   7/19/99 ericvan
*       Created it.
*   9/15/2000 agodfrey
*       #175866: Improved GDI+ startup, shutdown and event notification
*
\**************************************************************************/

#include "precomp.hpp"

#include "..\render\vgahash.hpp"

#include <winuser.h>

VOID DisplayNotify();
VOID PaletteNotify();
VOID SysColorNotify();

/////////////////////////////// MESSAGE HANDLERS ///////////////////////////////

/**************************************************************************\
*
* Function Description:
*
*   This routine receives a display notification request and appropriately
*   readjusts the size and resolution of DCI screen surface.
*
* History:
*
*   7/23/1999 ericvan
*       Created it.
*
\**************************************************************************/

VOID DisplayNotify()
{
    GpDevice *device = Globals::DesktopDevice;

    Devlock devlock(device);

    // Check to see if we have switched to a Terminal Server Session
    if (GetSystemMetrics(SM_REMOTESESSION))
    {
        // it is a remote session
        Globals::IsTerminalServer = TRUE;
    }
    else
    {
        // it isn't a remote session.
        Globals::IsTerminalServer = FALSE;
    }

    
    Globals::DesktopDriver->DesktopChangeNotification();

    DWORD width, height;

    width = GetSystemMetrics(SM_CXVIRTUALSCREEN);
    height = GetSystemMetrics(SM_CYVIRTUALSCREEN);

    if ((device != NULL) &&
        (device->DeviceHdc != NULL) &&
        (GetDeviceCaps(device->DeviceHdc, BITSPIXEL) <= 8))
    {
        // <SystemPalette>
        
        if (device->Palette == NULL) 
        {
            device->Palette = (ColorPalette*)GpMalloc(sizeof(ColorPalette)
                                                      + sizeof(ARGB) * 256);
            if (device->Palette == NULL)
            {
                return;
            }
        }
       
        INT           numEntries;
        PALETTEENTRY  palentry[256];
        RGBQUAD       rgb[256];
        ColorPalette* palette;

        palette = device->Palette;

        // [agodfrey] On Win9x, GetSystemPaletteEntries(hdc, 0, 256, NULL) 
        //    doesn't do what MSDN says it does. It seems to return the number
        //    of entries in the logical palette of the DC instead. So we have
        //    to make it up ourselves.
        
        numEntries = (1 << (GetDeviceCaps(device->DeviceHdc, BITSPIXEL) *
                            GetDeviceCaps(device->DeviceHdc, PLANES)));

        GetSystemPaletteEntries(device->DeviceHdc, 0, 256, &palentry[0]);

        palette->Count = numEntries;
        
        for (INT i=0; i<numEntries; i++) 
        {
            palette->Entries[i] = GpColor::MakeARGB(0xFF,
                                                    palentry[i].peRed,
                                                    palentry[i].peGreen,
                                                    palentry[i].peBlue);
            rgb[i].rgbRed = palentry[i].peRed;
            rgb[i].rgbGreen = palentry[i].peGreen;
            rgb[i].rgbBlue = palentry[i].peBlue;
            rgb[i].rgbReserved = 0;
        }
    
        if (device->DIBSectionBitmap != NULL) 
        {
            SetDIBColorTable(device->DIBSectionHdc, 0, numEntries, &rgb[0]);
        }

        Globals::PaletteChangeCount++;
    }

    // Set BufferWidth to 0.  This forces ::Start() to recreate the temporary
    // BufferDIB at the correct bit depth next time we process any cached records.

    // This needs to be done especially if the screen mode is not palettized
    // any more since the BufferDIB shouldn't be 8bpp, but reformatted to 32bpp.
    
    device->BufferWidth = 0;

    // Recreate the DCI object.  If the allocation fails, keep the old one
    // so that we don't access violate 'ScanDci' (although we might quite
    // happily draw wrong):

    EpScanGdiDci *scanDci = new EpScanGdiDci(Globals::DesktopDevice, TRUE);
    if (scanDci != NULL)
    {
        delete Globals::DesktopDevice->ScanDci;
        Globals::DesktopDevice->ScanDci = scanDci;
    }
    
    // update width and height on desktop surface
    // this copies the Device ScanDCI to Screen bitmap.

    Globals::DesktopSurface->InitializeForGdiScreen(
        Globals::DesktopDevice,
        width,
        height
    );
    
    // Give the driver an opportunity to adjust the surface.
    
    Globals::DesktopDriver->UpdateSurfacePixelFormat(
        Globals::DesktopSurface
    );
}

/**************************************************************************\
*
* Function Description:
*
*   This routine receives a palette change notification request and appropriately
*   readjusts the system palette matching.
*
* History:
*
*   7/23/1999 ericvan
*       Created it.
*
\**************************************************************************/

VOID PaletteNotify()
{
    Devlock devlock(Globals::DesktopDevice);

    // update count to force lazy recomputation of translation vector
    Globals::PaletteChangeCount++;

    // update the system palette 
    Globals::DesktopDriver->PaletteChangeNotification();
}

/**************************************************************************\
*
* Function Description:
*
*   This routine receives a WM_SYSCOLORCHANGE notifications and updates the
*   system magic colors.
*
* History:
*
*   1/10/2K ericvan
*       Created it.
*
\**************************************************************************/

VOID SysColorNotify()
{
    // [ericvan] There is no synchronization here.  If a synchronization 
    // problem should occur, the worst side effect would be a bad
    // color which would go away on a repaint.  I think we can live with it.

    Globals::SystemColors[16] = ::GetSysColor(COLOR_3DSHADOW);
    Globals::SystemColors[17] = ::GetSysColor(COLOR_3DFACE);
    Globals::SystemColors[18] = ::GetSysColor(COLOR_3DHIGHLIGHT);
    Globals::SystemColors[19] = ::GetSysColor(COLOR_DESKTOP);
    
    VGAHashRebuildTable(&Globals::SystemColors[16]);
}

////////////////////////// MESSAGE/WINEVENT CALLBACKS //////////////////////////

/**************************************************************************\
*
* Function Description:
*
*   This routine is the GDI+ hidden window message pump.  If the app doesn't
*   hook us directly, then we add a top-level window to intercept
*   WM_DISPLAYCHANGE and WM_PALETTECHANGED directly.
*
* History:
*
*   7/23/1999 ericvan
*       Created it.
*
\**************************************************************************/

LRESULT 
CALLBACK
NotificationWndProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
   switch (uMsg) 
   {
   case WM_DISPLAYCHANGE:
      DisplayNotify();
      break;

   case WM_PALETTECHANGED:
      PaletteNotify();
      break;

   case WM_SYSCOLORCHANGE:
      SysColorNotify();
      break;

   case WM_WININICHANGE:
      if(lParam != 0 &&
         lstrcmpiA((LPCSTR)(lParam), "intl") == 0)
      {
          Globals::UserDigitSubstituteInvalid = TRUE;
      } else if ((wParam == SPI_SETFONTSMOOTHING) || (wParam == SPI_SETFONTSMOOTHINGTYPE) ||
          (wParam == SPI_SETFONTSMOOTHINGCONTRAST) || (wParam == SPI_SETFONTSMOOTHINGORIENTATION))
      {
          Globals::CurrentSystemRenderingHintInvalid  = TRUE;
      }
      break;
      
   default:
       if (Globals::g_nAccessibilityMessage == uMsg && uMsg >= WM_USER)
       {
            Globals::g_fAccessibilityPresent = TRUE;
       }
       else
       {
           return DefWindowProcA(hwnd, uMsg, wParam, lParam);
       }
   }

   // return 0 if we processed it.
   return 0;
}

/**************************************************************************\
*
* Function Description:
*
*   This routine is the GDI+ win-event hook.  It watches for full-drag
*   messages, to let the DCI renderer know when full-drag is being done.
*
* History:
*
*   3/21/2000 andrewgo
*       Created it.
*
\**************************************************************************/

VOID
CALLBACK
WinEventProcedure(
    HWINEVENTHOOK hWinEventHook,
    DWORD         event,
    HWND          hwnd,
    LONG          idObject,
    LONG          idChild,
    DWORD         idEventThread,
    DWORD         dwmsEventTime
    )
{
    ASSERT((event == EVENT_SYSTEM_MOVESIZESTART) ||
           (event == EVENT_SYSTEM_MOVESIZEEND));

    Globals::IsMoveSizeActive = (event == EVENT_SYSTEM_MOVESIZESTART);
}

/////////////////////// MESSAGE/WINEVENT INITIALIZATION ////////////////////////

VOID InternalNotificationShutdown();

/**************************************************************************\
*
* Function Description:
*
*   Called by NotificationStartup and BackgroundThreadProc.
*   Initializes the hidden window and WinEvent hook.
*
* Preconditions:
*
*   BackgroundThreadCriticalSection must be held.
*
* History:
*
*   9/15/2000 agodfrey
*       Created it.
*
\**************************************************************************/

BOOL
InternalNotificationStartup()
{
    // register a window class
    // we force ANSI rep using GDI+ for benefit of Win9x

    WNDCLASSA wndClass =
    {   
        0,
        &NotificationWndProc,
        0,
        0,
        DllInstance,
        NULL,
        NULL,
        NULL,
        "GDI+ Hook Window",
        "GDI+ Hook Window Class",
    };
    
    Globals::WindowClassAtom = RegisterClassA(&wndClass);

    if (!Globals::WindowClassAtom)
    {
        WARNING(("RegisterClass failed"));
        return FALSE;
    }
    
    // If this fails, we continue.  It just means we won't work properly
    // with accessibility software.
    
    Globals::g_nAccessibilityMessage =
        RegisterWindowMessageA("GDI+ Accessibility");
    
    Globals::HwndNotify = CreateWindowA((LPCSTR) Globals::WindowClassAtom,
                                        (LPCSTR) "GDI+ Window",
                                        WS_OVERLAPPED | WS_POPUP | WS_MINIMIZE,
                                        0,
                                        0,
                                        1,
                                        1,         // x,y,width,height
                                        NULL,      // hWndParent
                                        NULL,      // hMenu
                                        DllInstance,
                                        NULL);
    
    if (!Globals::HwndNotify) 
    {
        WARNING(("CreateWindowA failed, the GDI+ hook window does not exist!"));
        InternalNotificationShutdown();
        return FALSE;
    }

    // [ericvan] This is BS, but must be done.  We only receive palette 
    // messages if we have called SelectPalette at least once on our primary DC.
    
    {
        struct {
            LOGPALETTE logpal;
            PALETTEENTRY palEntry[256];
        } lp;
        
        const ColorPalette* colorPal = GetDefaultColorPalette(PIXFMT_8BPP_INDEXED);
        
        lp.logpal.palVersion = 0x300;
        lp.logpal.palNumEntries = static_cast<WORD>(colorPal->Count);
        
        for (INT i=0; i<lp.logpal.palNumEntries; i++)
        {
            GpColor color(colorPal->Entries[i]);
        
            lp.logpal.palPalEntry[i].peRed = color.GetRed();
            lp.logpal.palPalEntry[i].peGreen = color.GetGreen();
            lp.logpal.palPalEntry[i].peBlue = color.GetBlue();
            lp.logpal.palPalEntry[i].peFlags = 0;
        }
        
        HPALETTE hPal = CreatePalette(&lp.logpal);
        HDC hdc = GetDC(Globals::HwndNotify);
        SelectPalette(hdc, hPal, FALSE);
        ReleaseDC(Globals::HwndNotify, hdc);
        DeleteObject(hPal);
    }
    
    // [andrewgo] On NT, if a DCI lock is held while a window moves, NT is 
    // forced to redraw the whole screen.  If "Show window contents while 
    // dragging" (AKA "Full-drag") is enabled (it's on by default), 
    // then this can result in repeated, excessive repaints 
    // of the whole screen while somone is dragging a window around.
    //
    // We work around this by disabling DCI rendering while we notice
    // that window moves are happening.  
    
    if ((Globals::IsNt) && (Globals::SetWinEventHookFunction))
    {
        Globals::WinEventHandle = 
            (Globals::SetWinEventHookFunction)(EVENT_SYSTEM_MOVESIZESTART,
                                               EVENT_SYSTEM_MOVESIZEEND,
                                               NULL,
                                               WinEventProcedure,
                                               0,
                                               0,
                                               WINEVENT_OUTOFCONTEXT);
    
        ASSERT(Globals::WinEventHandle != NULL);

        if (!Globals::WinEventHandle)
        {
            InternalNotificationShutdown();
            return FALSE;
        }
    }
    
    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*   Called by NotificationStartup and BackgroundThreadProc.
*   (Also by InternalNotificationStartup, to clean up when there's an 
*   error.)
*
*   Destroys the hidden window and WinEvent hook.
*
*   Keep this synchronized with SimulateInternalNotificationShutdown.
*
* Preconditions:
*
*   BackgroundThreadSection must be held.
*
* History:
*
*   9/15/2000 agodfrey
*       Created it.
*
\**************************************************************************/

VOID
InternalNotificationShutdown()
{
    if (Globals::UnhookWinEventFunction && Globals::WinEventHandle)
    {
        (Globals::UnhookWinEventFunction)(Globals::WinEventHandle);
        Globals::WinEventHandle = NULL;
    }
    
    if (Globals::HwndNotify) 
    {
        if (Globals::IsNt && (Globals::OsVer.dwMajorVersion == 4))
        {
            // NT 4.0 has a problem in its DestroyWindow that will
            // leave the application in a zombie state. 
            // Leak the window and rely on process cleanup.
        }
        else
        {
            DestroyWindow(Globals::HwndNotify);
        }
        Globals::HwndNotify = NULL;
    }
    
    if (Globals::WindowClassAtom)
    {
        UnregisterClassA((LPCSTR)Globals::WindowClassAtom, DllInstance);
        Globals::WindowClassAtom = NULL;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   If the thread quits without cleaning up, this fixes our state
*   to avoid crashing later.
*
*   "Cleans up" what it can - keeps the state consistent, but may leak.
*
* Preconditions:
*
*   BackgroundThreadCriticalSection must be held.
*
* History:
*
*   9/16/2000 agodfrey
*       Created it.
*
\**************************************************************************/

VOID
SimulateInternalNotificationShutdown()
{
    // UnhookWinEvent can't be called from a different thread; so if this
    // causes a leak, we can't help it.
    
    Globals::WinEventHandle = NULL;

    // DestroyWindow can't be called from a different thread; so if this
    // causes a leak, we can't help it.    
    
    Globals::HwndNotify = NULL;
    
    // I don't know about UnregisterClass. I'm assuming we can't call it here.
    // Anyway, the window may not have been destroyed, and MSDN says that must
    // happen first. So, if need be, we'll leak this too.
    
    Globals::WindowClassAtom = NULL;
}

/**************************************************************************\
*
* Function Description:
*
*   Starts our top-level window, and sets up the WndProc and WinEventHook.
*   This must be called from a GUI thread - it's called from either our
*   own background thread, or by the app (via callback pointers returned
*   from GdiplusStartup).
*
* History:
*
*   9/15/2000 agodfrey
*       Created it.
*
\**************************************************************************/

GpStatus WINAPI 
NotificationStartup(
    OUT ULONG_PTR *token
    )
{
    GdiplusStartupCriticalSection critsec;

    // Generate the first token, if necessary.
    // Also handles wraparound.
    
    if (Globals::NotificationInitToken == 0)
    {
        Globals::NotificationInitToken = GenerateInitToken();
        
        // Make sure that the token isn't one of the "special" values.
        
        if (Globals::NotificationInitToken <= NotificationModuleTokenMax)
        {
            Globals::NotificationInitToken = NotificationModuleTokenMax + 1;
        }
    }
    
    // If there's no hidden window yet, create one.
    
    if (Globals::HiddenWindowOwnerToken == NotificationModuleTokenNobody)
    {
        // If there's a background thread, then the owner should be set to
        // 'NotificationModuleTokenGdiplus'.
        
        ASSERT (Globals::ThreadNotify == NULL);

        {
            // We take BackgroundThreadCriticalSection because that's a
            // precondition for InternalNotificationStartup(). I know that we
            // don't actually need to (there's no background thread at this
            // point) - but code can change, so this is safer.

            BackgroundThreadCriticalSection critsec;

            if (!InternalNotificationStartup())
            {
                return GenericError;
            }
        }

        // Store the token of this calling module - when it calls
        // NotificationShutdown, we must destroy the hidden window (and
        // start up the background thread, if necessary).

        Globals::HiddenWindowOwnerToken = Globals::NotificationInitToken;
    }
        
    *token = Globals::NotificationInitToken;

    // Increment the token counter for the next module
    
    Globals::NotificationInitToken++;
    
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Shuts down our top-level window, WndProc and WinEventHook.
*   This must be called from a GUI thread - it's called from either our
*   own background thread, or by the app (via callback pointers returned
*   from GdiplusStartup).
*
* History:
*
*   9/15/2000 agodfrey
*       Created it.
*
\**************************************************************************/

VOID WINAPI
NotificationShutdown(
    ULONG_PTR token
    )
{
    GdiplusStartupCriticalSection critsec;
    
    // The token they pass us should be the one we gave them, so it shouldn't
    // be one of the 'special values'.
    
    if (token <= NotificationModuleTokenMax)
    {
        RIP(("Invalid token passed to NotificationShutdown"));
        
        // Ignore the call.
        
        return;
    }
    
    if (token == Globals::HiddenWindowOwnerToken)
    {
        // The module that created the hidden window is shutting down.
        
        // There shouldn't be a background thread.
        ASSERT (Globals::ThreadNotify == NULL);
            
        {
            BackgroundThreadCriticalSection critsec;

            InternalNotificationShutdown();
        }

        Globals::HiddenWindowOwnerToken = NotificationModuleTokenNobody;

        // If this is not the final module to shut down, start up the
        // background thread

        if (Globals::LibraryInitRefCount > 1)
        {
            if (!BackgroundThreadStartup())
            {
                // !!! [johnstep] Ack, what can we do now? Another client may
                //                be happily using GDI+ and now we've lost
                //                our message notifications.

                WARNING(("Could not start background thread"));
            }
        }
    }
}    

////////////////////////////// BACKGROUND THREAD ///////////////////////////////

/**************************************************************************\
*
* Function Description:
*
*   Thread proc for our background GUI thread. Sets up a hidden window,
*   WndProc and WinEventHook, then starts the message loop.
*
* History:
*
*   7/23/1999 ericvan
*       Created it.
*   9/15/2000 agodfrey
*       #175866: Improved GDI+ startup, shutdown and event notification
*
\**************************************************************************/

DWORD
WINAPI
BackgroundThreadProc(
    VOID*
    )
{
    BOOL error=FALSE;
    HANDLE threadQuitEvent;
    
    {
        BackgroundThreadCriticalSection critsec;

        // Read threadQuitEvent under the critical section - ensures that
        // we don't get the NULL that was there before the main thread
        // initialized it. We can assume, though, that it won't change until
        // this thread ends.
        
        threadQuitEvent = Globals::ThreadQuitEvent;

        if (!InternalNotificationStartup())
        {
            error = TRUE;
        }
    }

    if (error)
    {
        return 0;
    }

    // [agodfrey] We used to have a call to "WaitForInputIdle" here, 
    // which caused problems. It was motivated by Shell and DDE - 
    // since calling GetMessage() signals user that "the app is 
    // ready to receive DDE messages", and we were doing
    // it in PROCESS_ATTACH, long before the app was really ready.
    //
    // Now, we simply disallow initializing GDI+ in PROCESS_ATTACH.
    
    // Process window messages
    // We use MsgWaitForMultipleObjects, so that we can catch both messages
    // and our "quit" event being signalled.
    
    DWORD dwWake;
    
    MSG msg;
    BOOL quit = FALSE;
    
    while (!quit)
    {
        dwWake = MsgWaitForMultipleObjects(
            1,
            &threadQuitEvent,
            FALSE,
            INFINITE,
            QS_ALLINPUT);
            
        if (dwWake == WAIT_OBJECT_0)
        {
            // Our "quit" event was signaled.
            
            quit = TRUE;
            break;
        }
        else if (dwWake == WAIT_OBJECT_0 + 1)
        {
            // We received a message
            while (PeekMessageA(&msg, NULL, 0, 0, PM_REMOVE))
            {
                if (msg.message == WM_QUIT)
                {
                    quit = TRUE;
                    break;
                }
                TranslateMessage(&msg);
                DispatchMessageA(&msg);
            }
        }
        else
        {
            RIP(("Unexpected return value from MsgQaitForMultipleObjects"));
        }
    }

    // Clean up:
    
    {
        BackgroundThreadCriticalSection critsec;
        InternalNotificationShutdown();
    }
    
    return 1;
}

/**************************************************************************\
*
* Function Description:
*
*   Starts up the background thread. If the user doesn't ask us to piggyback
*   our hidden window onto their main GUI thread, we end up here, to create
*   our own.
*
* Preconditions:
*
*   GdiplusStartupCriticalSection must be held.
*
* History:
*
*   7/23/1999 ericvan
*       Created it.
*   9/15/2000 agodfrey
*       #175866: Improved GDI+ startup, shutdown and event notification
*
\**************************************************************************/

BOOL
BackgroundThreadStartup()
{
    ASSERT(Globals::HiddenWindowOwnerToken == NotificationModuleTokenNobody);
    
    // [agodfrey] Create an event object. We'll use this to tell the 
    // background thread to quit.

    HANDLE threadQuitEvent = CreateEventA(NULL, TRUE, FALSE, NULL);
    if (threadQuitEvent == NULL)
    {
        WARNING(("CreateEvent failed: %d", GetLastError()));
        BackgroundThreadShutdown();
        return FALSE;
    }
    
    {
        // Store threadQuitEvent while holding the correct critsec.

        BackgroundThreadCriticalSection critsec;
    
        Globals::ThreadQuitEvent = threadQuitEvent;
    }

    // Create the background thread.

    Globals::ThreadNotify = CreateThread(NULL,                        // LPSECURITY_ATTRIBUTES
                                         0,                           // same stack size
                                         &BackgroundThreadProc,
                                         0,                           // parameter to thread
                                         0,                           // creation flags
                                         &Globals::ThreadId);


    if (Globals::ThreadNotify == NULL)
    {
       BackgroundThreadShutdown();
       return FALSE;
    }
    
    // Record the fact that GDI+ has its own hidden window, and so
    // NotificationStartup shouldn't create another one.
    
    Globals::HiddenWindowOwnerToken = NotificationModuleTokenGdiplus;
    
    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*   Shuts down the background thread.
*
* Preconditions:
*
*   GdiplusStartupCriticalSection must be held.
*   BackgroundThreadCriticalSection must *NOT* be held (we would deadlock).
*
* History:
*
*   7/23/1999 ericvan
*       Created it.
*   9/15/2000 agodfrey
*       #175866: Improved GDI+ startup, shutdown and event notification.
*       Made it more robust by adding an event, and changing the thread's
*       message loop so that it quits when the event is signaled.
*
\**************************************************************************/

VOID
BackgroundThreadShutdown()
{
    // Stop the background thread
    
    if (Globals::ThreadNotify != NULL)
    {
        ASSERT(Globals::HiddenWindowOwnerToken == NotificationModuleTokenGdiplus);
    
        // We want to be careful not to hold BackgroundThreadCriticalSection
        // while we wait for the thread to terminate, since that could
        // cause a deadlock situation (our wait would time out).
        
        HANDLE threadQuitEvent;
        
        {
            BackgroundThreadCriticalSection critsec;
    
            threadQuitEvent = Globals::ThreadQuitEvent;
        }
    
        ASSERT(threadQuitEvent); // If it's NULL, ThreadNotify should be NULL.
        
        SetEvent(threadQuitEvent);

        DWORD ret = WaitForSingleObject(Globals::ThreadNotify, INFINITE);
        ASSERT(ret == WAIT_OBJECT_0);
        
        CloseHandle(Globals::ThreadNotify);
        Globals::ThreadNotify = NULL;
        Globals::ThreadId = 0;
    
        Globals::HiddenWindowOwnerToken = NotificationModuleTokenNobody;
    }

    {
        BackgroundThreadCriticalSection critsec;
            
        // [agodfrey] I discovered that, if InternalGdiplusShutdown is called 
        // from PROCESS_DETACH, the system will have terminated the thread 
        // already; WaitForSingleObject returns immediately because the 
        // thread has already stopped running. 
        //
        // In this case, InternalNotificationShutdown() isn't called, i.e. the
        // globals it cleans up are still non-NULL. I deem this "ok" because,
        // if we're in PROCESS_DETACH, no-one's going to read those variables
        // again.
        //
        // Still, I don't know if there are other legitimate ways for the 
        // thread to end without it cleaning up properly. So we call 
        // SimulateInternalNotificationShutdown() just to be safe - it's not
        // very expensive.
        
        SimulateInternalNotificationShutdown();
        
        // Destroy the "quit" event
        
        if (Globals::ThreadQuitEvent)
        {
            CloseHandle(Globals::ThreadQuitEvent);
            Globals::ThreadQuitEvent = NULL;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\device.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Handle all the device associations.
*
* Revision History:
*
*   12/03/1998 andrewgo
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

#include "compatibledib.hpp"

BOOL gbUseD3DHAL = TRUE;
/**************************************************************************\
*
* Function Description:
*
*   Creates a GpDevice class that represents the (meta) desktop.
*
* Arguments:
*
*   [IN] hdc - Owned DC representing the device.  Note that this has to
*              live for the lifetime of this 'GpDevice' object.  Caller
*              is responsible for deletion or management of the HDC.
*
* Return Value:
*
*   IsValid() is FALSE in the event of failure.
*
* History:
*
*   12/04/1998 andrewgo
*       Created it.
*
\**************************************************************************/

GpDevice::GpDevice(
    HDC hdc
    )
{
    hMonitor = NULL;
    Buffers[0] = NULL;

    __try
    {
        DeviceLock.Initialize();
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // We couldn't allocate the criticalSection
        // Return an error
        WARNING(("Unable to allocate the DeviceLock"));
        SetValid(FALSE);
        return;
    }

    DeviceHdc = hdc;
    BufferWidth = 0;

    DIBSectionBitmap = NULL;
    DIBSection = NULL;
    ScanDci = NULL;
        
    pdd = NULL;
    pd3d = NULL;
    pdds = NULL;
    pd3dDevice = NULL;

    DIBSectionHdc = CreateCompatibleDC(hdc);

    if ((GetDeviceCaps(hdc, TECHNOLOGY) == DT_RASDISPLAY) &&
        (GetDeviceCaps(hdc, BITSPIXEL)  <= 8))
    {
        // Query and cache color palette
        
        // !!! [agodfrey] This is hard to maintain. We have much the same
        //     palette code spread all over the place. It should be abstracted
        //     into a single location. I've marked each instance with
        //     <SystemPalette>.
        
        Palette = (ColorPalette*) GpMalloc(sizeof(ColorPalette) + sizeof(ARGB)*256);
       
        if (Palette == NULL) 
        {
            WARNING(("Unable to allocate color palette"));
            SetValid(FALSE);
            return;
        }

        INT i;
        INT numEntries;
        PALETTEENTRY palEntry[256];

        // [agodfrey] On Win9x, GetSystemPaletteEntries(hdc, 0, 256, NULL) 
        //    doesn't do what MSDN says it does. It seems to return the number
        //    of entries in the logical palette of the DC instead. So we have
        //    to make it up ourselves.
        
        numEntries = (1 << (GetDeviceCaps(hdc, BITSPIXEL) * 
                            GetDeviceCaps(hdc, PLANES)));

        ASSERT(numEntries <= 256); 
 
        GetSystemPaletteEntries(hdc, 0, numEntries, &palEntry[0]);
           
        Palette->Count = numEntries;
        for (i=0; i<numEntries; i++) 
        {
             Palette->Entries[i] = Color::MakeARGB(0xFF,
                                                   palEntry[i].peRed,
                                                   palEntry[i].peGreen,
                                                   palEntry[i].peBlue);
        }
    }
    else
    {
        Palette = NULL;
    }

    ScreenOffsetX = 0;
    ScreenOffsetY = 0;

    ScreenWidth = GetDeviceCaps(hdc,  HORZRES);
    ScreenHeight = GetDeviceCaps(hdc, VERTRES);

    ScanDci = new EpScanGdiDci(this, TRUE);
    ScanGdi = new EpScanGdiDci(this);

    SetValid((ScanDci != NULL) && (ScanGdi != NULL) && (DIBSectionHdc != NULL));
}

/**************************************************************************\
*
* Function Description:
*
*   Creates a GpDevice class that represents a device associated with
*   a particular monitor on the desktop.
*
* Arguments:
*
*   [IN] hMonitor - Identifies the monitor on the system.
*
* Return Value:
*
*   IsValid() is FALSE in the event of failure.
*
* History:
*
*   10/13/1999 bhouse
*       Created it.
*
\**************************************************************************/

GpDevice::GpDevice(
    HMONITOR inMonitor
    )
{
    hMonitor = NULL;
    Buffers[0] = NULL;
    
    MONITORINFOEXA   mi;
    
    mi.cbSize = sizeof(mi);

    DIBSectionBitmap = NULL;
    DIBSection = NULL;
    ScanDci = NULL;
    ScanGdi = NULL;

    pdd = NULL;
    pd3d = NULL;
    pdds = NULL;
    pd3dDevice = NULL;

    DIBSectionHdc = NULL;
    Palette = NULL;
        
    __try
    {
        DeviceLock.Initialize();
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // We couldn't allocate the criticalSection
        // Return an error
        WARNING(("Unable to allocate the DeviceLock"));
        SetValid(FALSE);
        return;
    }
    
    SetValid(FALSE);

    if(Globals::GetMonitorInfoFunction == NULL)
    {
        WARNING(("GpDevice with HMONITOR called with no multi-monitor support"));
    }
    else if(Globals::GetMonitorInfoFunction(inMonitor, &mi))
    {
        HDC hdc;

        if (Globals::IsNt)
        {
            hdc = CreateDCA("Display", mi.szDevice, NULL, NULL);
        }
        else
        {
            hdc = CreateDCA(NULL, mi.szDevice, NULL, NULL);
        }
        
        // Note: because we created the hdc, the ~GpDevice destructor is
        // responsible for for its deletion.  We currently recognize this
        // case by a non-NULL hMonitor.

        if(hdc != NULL)
        {
            hMonitor = inMonitor;

            DeviceHdc = hdc;
            BufferWidth = 0;

            DIBSectionHdc = CreateCompatibleDC(hdc);

            if ((GetDeviceCaps(hdc, TECHNOLOGY) == DT_RASDISPLAY) &&
                (GetDeviceCaps(hdc, BITSPIXEL)  <= 8))
            {
                // Query and cache color palette
                // <SystemPalette>
        
                Palette = (ColorPalette*) GpMalloc(sizeof(ColorPalette) + sizeof(ARGB)*256);
                
                if (Palette == NULL) 
                {
                    WARNING(("Unable to allocate color palette"));
                    return;
                }
        
                INT i;
                INT numEntries;
                PALETTEENTRY palEntry[256];
                        
                // [agodfrey] On Win9x, GetSystemPaletteEntries(hdc, 0, 256, NULL) 
                //    doesn't do what MSDN says it does. It seems to return the number
                //    of entries in the logical palette of the DC instead. So we have
                //    to make it up ourselves.
                
                numEntries = (1 << (GetDeviceCaps(hdc, BITSPIXEL) *
                                    GetDeviceCaps(hdc, PLANES)));

                ASSERT(numEntries <= 256);
        
                GetSystemPaletteEntries(hdc, 0, numEntries, &palEntry[0]);
                    
                Palette->Count = numEntries;
                for (i=0; i<numEntries; i++) 
                {
                     Palette->Entries[i] = Color::MakeARGB(0xFF,
                                                           palEntry[i].peRed,
                                                           palEntry[i].peGreen,
                                                           palEntry[i].peBlue);
                }
            }

            ScreenOffsetX = mi.rcMonitor.left;
            ScreenOffsetY = mi.rcMonitor.top;

            ScreenWidth = (mi.rcMonitor.right - mi.rcMonitor.left);
            ScreenHeight = (mi.rcMonitor.bottom - mi.rcMonitor.top);

            ScanDci = new EpScanGdiDci(this, TRUE);
            ScanGdi = new EpScanGdiDci(this);

#if HW_ACCELERATION_SUPPORT

            if(InitializeDirectDrawGlobals())
            {
                HRESULT hr = Globals::DirectDrawEnumerateExFunction(
                                GpDevice::EnumDirectDrawCallback,
                                this,
                                DDENUM_ATTACHEDSECONDARYDEVICES);

                if(pdd == NULL)
                {
                    // This could happen if this is a single monitor
                    // machine. Try again to create the DirectDraw Object.
                    hr = Globals::DirectDrawCreateExFunction(NULL,
                                                    &pdd,
                                                    IID_IDirectDraw7,
                                                    NULL);

                    if(hr != DD_OK)
                    {
                        WARNING(("Unable to create monitor Direct Draw interface"));
                    }

                    hr = pdd->SetCooperativeLevel(NULL, DDSCL_NORMAL);

                    if(hr != DD_OK)
                    {
                        WARNING(("Unable to set cooperative level for monitor device"));
                        pdd->Release();
                        pdd = NULL;
                    }
                }

                if(pdd != NULL)
                {
                    DDSURFACEDESC2  sd;

                    memset(&sd, 0, sizeof(sd));
                    sd.dwSize = sizeof(sd);

                    sd.dwFlags = DDSD_CAPS;
                    sd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE | DDSCAPS_3DDEVICE;

                    hr = pdd->CreateSurface(&sd, &pdds, NULL);

                    if(hr != DD_OK)
                    {
                        WARNING(("Unable to create primary surface for monitor"));
                    }

                    hr = pdd->QueryInterface(IID_IDirect3D7, (void **) &pd3d);

                    if(hr != DD_OK)
                    {
                        WARNING(("Unable to get monitor D3D interface"));
                    }

                    if(pd3d != NULL && pdds != NULL)
                    {

                        if(gbUseD3DHAL)
                            hr = pd3d->CreateDevice(IID_IDirect3DHALDevice, pdds, &pd3dDevice);
                        else
                            hr = pd3d->CreateDevice(IID_IDirect3DRGBDevice, pdds, &pd3dDevice);

                        if(hr != DD_OK)
                        {
                            WARNING(("Unable to create D3D device"));
                        }

                        if(pd3dDevice != NULL)
                        {
                            pddsRenderTarget = pdds;

                            hr = pd3dDevice->SetRenderState(D3DRENDERSTATE_ZENABLE, 0);
        
                            if(hr == DD_OK) hr = pd3dDevice->SetRenderState(D3DRENDERSTATE_ZWRITEENABLE, 0);
        
                            if(hr == DD_OK) hr = pd3dDevice->SetRenderState(D3DRENDERSTATE_SHADEMODE, D3DSHADE_FLAT);
        
                            if(hr == DD_OK) hr = pd3dDevice->SetRenderState(D3DRENDERSTATE_CLIPPING, FALSE);
                            if(hr == DD_OK) hr = pd3dDevice->SetRenderState(D3DRENDERSTATE_LIGHTING, FALSE);
                            if(hr == DD_OK) hr = pd3dDevice->SetRenderState(D3DRENDERSTATE_CULLMODE,     D3DCULL_NONE);
                            if(hr == DD_OK) hr = pd3dDevice->SetRenderState(D3DRENDERSTATE_DITHERENABLE, FALSE);
        
                            if(hr == DD_OK) hr = pd3dDevice->SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, FALSE);
                            if(hr == DD_OK) hr = pd3dDevice->SetRenderState(D3DRENDERSTATE_SRCBLEND,     D3DBLEND_SRCALPHA);
                            if(hr == DD_OK) hr = pd3dDevice->SetRenderState(D3DRENDERSTATE_DESTBLEND,     D3DBLEND_INVSRCALPHA);
                            if(hr == DD_OK) hr = pd3dDevice->SetRenderState(D3DRENDERSTATE_TEXTUREPERSPECTIVE, FALSE);
        
                            // Setup viewport
        
                            D3DVIEWPORT7 viewData;
        
                            viewData.dwX = 0;
                            viewData.dwY = 0;
                            viewData.dwWidth  = ScreenWidth;
                            viewData.dwHeight = ScreenHeight;
                            viewData.dvMinZ = 0.0f;
                            viewData.dvMaxZ = 1.0f;
        
                            if(hr == DD_OK) hr = pd3dDevice->SetViewport(&viewData);
        
                            if(hr != DD_OK)
                            {
                                WARNING(("Failed setting default D3D state"));
                                pd3d->Release();
                                pd3d = NULL;
                            }

                        }

                    }

                }

            }

#endif // HW_ACCELERATION_SUPPORT

            SetValid((ScanDci != NULL) && (ScanGdi != NULL) && (DIBSectionHdc != NULL));
            
        }
        else
        {
            WARNING(("Failed creating HDC from HMONITOR"));
        }
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Callback function used to D3D Device Enumeration  
*
* Arguments:
*
*   See D3D SDK
*
* Return Value:
*
*   See D3D SDK
*
* History:
*
*   10/11/1999 bhouse
*       Created it.
*
\**************************************************************************/

BOOL GpDevice::EnumDirectDrawCallback(
    GUID *      lpGUID,
    LPSTR       lpDriverDescription,
    LPSTR       lpDriverName,
    LPVOID      lpContext,
    HMONITOR    hMonitor)
{
    GpDevice * device = (GpDevice *) lpContext;

    if(device->hMonitor == hMonitor && lpGUID)
    {
        HRESULT hr = Globals::DirectDrawCreateExFunction(lpGUID,
                                                    &device->pdd,
                                                    IID_IDirectDraw7,
                                                    NULL);

        if(hr != DD_OK)
        {
            WARNING(("Unable to create monitor Direct Draw interface"));
        }

        hr = device->pdd->SetCooperativeLevel(NULL, DDSCL_NORMAL);

        if(hr != DD_OK)
        {
            WARNING(("Unable to set cooperative level for monitor device"));
            device->pdd->Release();
            device->pdd = NULL;
        }

        return(FALSE);
        
    }

    return(TRUE);
}

/**************************************************************************\
*
* Function Description:
*
*   Destroys a GpDevice class.
*
* Arguments:
*
*   None
*
* Return Value:
*
*   NONE
*
* History:
*
*   12/04/1998 andrewgo
*       Created it.
*
\**************************************************************************/

GpDevice::~GpDevice(
    VOID
    )
{
    DeviceLock.Uninitialize();

#if 0
    // !!!TODO: Find out why we are getting an access fault when we try and
    //          release the pd3d7 interface
    if(pd3dDevice != NULL)
        pd3dDevice->Release();

    if(pd3d != NULL)
        pd3d->Release();
#endif

    if(pdds != NULL)
        pdds->Release();

    if(pdd != NULL)
        pdd->Release();

    DeleteObject(DIBSectionBitmap);
    DeleteDC(DIBSectionHdc);

    if (hMonitor != NULL)
    {
        // If GpDevice was created by the GpDevice(HMONITOR) contructor,
        // then the HDC was created by the object.  Therefore, in that case
        // the destructor is responsible for deletion.

        if (DeviceHdc != NULL)
        {
            DeleteDC(DeviceHdc);
        }
    }

    GpFree(Buffers[0]);
    GpFree(Palette);
    
    delete ScanDci;
    delete ScanGdi;

    SetValid(FALSE);    // so we don't use a deleted object
}

/**************************************************************************\
*
* Function Description:
*
*   Returns 5 scan buffers of a specified width, from a cache in
*   the device.
*
*   One is a DIBSection which is compatible with the device (or 8bpp if
*   the device format is smaller than 8bpp.)
*
* Arguments:
*
*   [IN] width - Specifies the requested width in pixels
*   [OUT] [OPTIONAL] dibSection - Returns the pointer to the DIBSection
*   [OUT] [OPTIONAL] hdcDibSection - Returns an HDC to the DIBSection
*   [OUT] [OPTIONAL] dstFormat - Returns the format of the DIBSection.
*   [OUT] [OPTIONAL] buffers - Returns an array of 5 pointers to
*                    buffers, each big enough to hold <width> pixels in 64bpp.
*
* Return Value:
*
*   FALSE if there was an allocation error.
*
* History:
*
*   12/04/1998 andrewgo
*       Created it.
*   01/21/2000 agodfrey
*       Changed it to create just 1 DIBSection, and 4 memory buffers.
*
\**************************************************************************/

BOOL
GpDevice::GetScanBuffers(
    INT width,
    VOID **dibSection,
    HDC *hdcDibSection,
    PixelFormatID *dstFormat,
    VOID *buffers[5]
    )
{
    // If BufferWidth is 0 this means that the DIBSectionBitmap should be
    // recreated.  This is used, for instance, when switching bit depths
    // to a palettized format.
    if (width > BufferWidth)
    {
        if (DIBSectionBitmap != NULL)
        {
            DeleteObject(DIBSectionBitmap);
        }

        DIBSectionBitmap = CreateSemiCompatibleDIB(
            DeviceHdc, 
            width, 
            1, 
            Palette,
            &DIBSection,
            &BufferFormat);

        if (DIBSectionBitmap)
        {
            BufferWidth = width;
        
            SelectObject(DIBSectionHdc, DIBSectionBitmap);

        }
        else
        {
            BufferWidth = 0;
        }
        
        // Allocate the 5 memory buffers from one chunk.
        
        if (Buffers[0])
        {
            GpFree(Buffers[0]);
        }
        
        Buffers[0] = GpMalloc(sizeof(ARGB64) * width * 5);
        if (Buffers[0])
        {
            int i;
            for (i=1;i<5;i++)
            {
                Buffers[i] = static_cast<BYTE *>(Buffers[i-1]) + 
                             sizeof(ARGB64) * width;
            }
        }
        else
        {
            BufferWidth = 0;
        }
    }
    
    if (dibSection != NULL)
    {
        *dibSection = DIBSection;
    }
    if (hdcDibSection != NULL)
    {
        *hdcDibSection = DIBSectionHdc;
    }
    if (buffers != NULL)
    {
        int i;
        for (i=0;i<5;i++)
        {
            buffers[i] = Buffers[i];
        }
    }
    if (dstFormat != NULL)
    {
        *dstFormat = BufferFormat;
    }

    return(BufferWidth != 0);
}

/**************************************************************************\
*
* Function Description:
*
*   Constructor of GpDeviceList  
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* History:
*
*   10/08/1999 bhouse
*       Created it.
*
\**************************************************************************/

GpDeviceList::GpDeviceList()
{
    mNumDevices = 0;
    mDevices = NULL;
}

/**************************************************************************\
*
* Function Description:
*
*   Destructor of GpDeviceList  
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* History:
*
*   10/08/1999 bhouse
*       Created it.
*
\**************************************************************************/

GpDeviceList::~GpDeviceList()
{
    GpFree(mDevices);
}

/**************************************************************************\
*
* Function Description:
*
*   Add device to device list.  
*
* Arguments:
*
*   inDevice - device to add
*
* Return Value:
*
*   Ok if device was successfully added otherwise OutOfMemory
*
* History:
*
*   10/08/1999 bhouse
*       Created it.
*
\**************************************************************************/


GpStatus GpDeviceList::AddDevice(GpDevice * inDevice)
{
    GpDevice ** newList = (GpDevice **) GpMalloc((mNumDevices + 1) * sizeof(GpDevice *));

    if(newList == NULL)
        return OutOfMemory;

    memcpy(newList, mDevices, (mNumDevices * sizeof(GpDevice *)));
    newList[mNumDevices++] = inDevice;

    GpFree(mDevices);

    mDevices = newList;

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Add device to device list.  
*
* Arguments:
*
*   inSurface - surface for which we need to find matching D3DDevice
*
* Return Value:
*
*   GpDevice if found otherwise NULL
*
* History:
*
*   10/08/1999 bhouse
*       Created it.
*
\**************************************************************************/

GpDevice * GpDeviceList::FindD3DDevice(IDirectDrawSurface7 * inSurface)
{
    HRESULT     hr;
    IUnknown *  unknown;

    hr = inSurface->GetDDInterface((void **) &unknown);

    if(hr != DD_OK)
        return NULL;

    IDirectDraw7 * pddMatch;

    hr = unknown->QueryInterface(IID_IDirectDraw7, (void **) &pddMatch);

    if(hr != DD_OK)
        return NULL;

#if 0
    IDirect3D7 * pd3dMatch;

    hr = pddMatch->QueryInterface(IID_IDirect3D7, (void **) &pd3dMatch);

    if(hr != DD_OK)
    {
        pddMatch->Release();
        return NULL;
    }

    GpDevice * device = NULL;

    for(INT i = 0; i < mNumDevices; i++)
    {
        if(mDevices[i]->pd3d == pd3dMatch)
        {
            device = mDevices[i];
            break;
        }
    }

    pd3dMatch->Release();
#else
    GpDevice * device = NULL;

    for(INT i = 0; i < mNumDevices; i++)
    {
        if(mDevices[i]->pdd == pddMatch)
        {
            device = mDevices[i];
            break;
        }
    }
#endif

    pddMatch->Release();

    return device;
}

#if 0
/**************************************************************************\
*
* Function Description:
*
*   Callback function used to D3D Device Enumeration  
*
* Arguments:
*
*   See D3D SDK
*
* Return Value:
*
*   See D3D SDK
*
* History:
*
*   10/11/1999 bhouse
*       Created it.
*
\**************************************************************************/

HRESULT GpDeviceList::EnumD3DDevicesCallback(
    LPSTR lpDevDesc,
    LPSTR lpDevName,
    LPD3DDEVICEDESC7 * d3dDevDesc,
    LPVOID lpContext)
{
    GpDeviceList * devList = (GpDeviceList *) lpContext;


}

/**************************************************************************\
*
* Function Description:
*
*   Build a device list.  
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* History:
*
*   10/08/1999 bhouse
*       Created it.
*
\**************************************************************************/


void GpDeviceList::Build(void)
{
    if(!InitializeDirectDrawGlobals())
        return;

    HRESULT hr;

    hr = Globals::Direct3D->EnumDevices(EnumD3DDevicesCallback, this);

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\dpbitmap.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Device bitmap APIs and internals.
*
* Revision History:
*
*   12/02/1998 andrewgo
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "compatibleDIB.hpp"

/**************************************************************************\
*
* Function Description:
*
*   Temporary function to see if the bitmap is a standard format type
*   (5-5-5, 5-6-5, 24bpp or 32bpp).
*
* Notes:
*
*   Code which calls this assumes that there are no standard formats which
*   support alpha.
*
* History:
*
*   12/04/1998 andrewgo
*       Created it.
*
\**************************************************************************/

BOOL
DpBitmap::StandardFormat(
    VOID
    )
{
    INT BitsPerPixel = GetPixelFormatSize(PixelFormat);
    BOOL standardFormat = FALSE;

    if ((RedMask == 0x00ff0000) &&       
        (GreenMask == 0x0000ff00) &&     
        (BlueMask == 0x000000ff))        
    {                                             
        if (BitsPerPixel == 24)          
        {                                         
            standardFormat = TRUE;
        }                                         
        else if (BitsPerPixel == 32)     
        {
            standardFormat = TRUE;
        }
    }
    else if ((RedMask == 0x00007c00) &&  
             (GreenMask == 0x000003e0) &&
             (BlueMask == 0x0000001f) && 
             (BitsPerPixel == 16))       
    {
        standardFormat = TRUE;
    }
    else if ((RedMask == 0x0000f800) &&  
             (GreenMask == 0x000007e0) &&
             (BlueMask == 0x0000001f) && 
             (BitsPerPixel == 16))       
    {
        standardFormat = TRUE;
    }

    return(standardFormat);
}

/**************************************************************************\
*
* Function Description:
*
*   This function computes the PixelFormatID corresponding to a particular
*   combination of bit depth and color channel masks in the DpBitmap.
*
* Notes:
*
*   Code which calls this assumes that there are no standard formats which
*   support alpha.
*
* History:
*
*   05/17/2000 asecchia
*       Created it.
*
\**************************************************************************/

PixelFormatID DpBitmap::GetPixelFormatFromBitDepth(INT bits)
{
    switch(bits)
    {
        // !!! [asecchia] not sure if we support these indexed modes
        //     from this codepath.

        case 1:
            return PixelFormat1bppIndexed;
    
        case 4:
            return PixelFormat4bppIndexed;
    
        case 8:
            return PixelFormat8bppIndexed;
    
        case 16:
            if (RedMask == 0x00007c00)
            {
                return PixelFormat16bppRGB555;
            }
            if (RedMask == 0x0000f800)  
            {
                return PixelFormat16bppRGB565;
            }
            break;
    
        case 24:
            if (RedMask == 0x00ff0000)
            {
                return PixelFormat24bppRGB;
            }
            if (RedMask == 0x000000ff)  
            {
                return PIXFMT_24BPP_BGR;    
            }
            break;
    
        case 32:
            if (RedMask == 0x00ff0000)
            {
                return PixelFormat32bppRGB;
            }
            break;
    }
    
    WARNING(("Unsupported pixel format"));
    return PixelFormatUndefined;
}

/**************************************************************************\
*
* Function Description:
*
*   Initializes a bitmap for drawing on via the GDI routines.
*
* Arguments:
*
*   [IN] device - Identifies the device
*   [IN] width - Bitmap width
*   [IN] height - Bitmap height
*   [OUT] driver - Driver interface to be used
*
* History:
*
*   12/06/1998 andrewgo
*       Created it.
*
\**************************************************************************/

VOID
DpBitmap::InitializeForGdiBitmap(
    GpDevice *device,
    INT width,
    INT height
    )
{
    SurfaceTransparency = TransparencyNoAlpha;
    
    // !!![andrewgo] Disable this assert until MetaFiles stop calling
    //               with a zero dimension surface
    //
    // ASSERTMSG((width > 0) && (height > 0), ("Dimensions must be positive"));

    Width = width;
    Height = height;
    
    NumBytes = 0;
    Uniqueness = (DWORD)GpObject::GenerateUniqueness();

    PixelFormat = ExtractPixelFormatFromHDC(device->DeviceHdc);
    
    Scan = device->ScanGdi;

    SetValid(TRUE);
    Bits = NULL;
    Delta = 0;

    DdrawSurface7 = NULL;

    Type = GDI; 
}

/**************************************************************************\
*
* Function Description:
*
*   Initializes a bitmap for drawing on via the DCI routines, if possible.
*
* Arguments:
*
*   [IN] device - Identifies the device
*   [IN] width - Bitmap width
*   [IN] height - Bitmap height
*   [OUT] driver - Driver interface to be used
*
* History:
*
*   12/06/1998 andrewgo
*       Created it.
*
\**************************************************************************/

VOID
DpBitmap::InitializeForGdiScreen(
    GpDevice *device,
    INT width,
    INT height
    )
{
    InitializeForGdiBitmap(device, width, height);

    // Even if GDI bitmaps change to support alpha, the screen doesn't.
    
    SurfaceTransparency = TransparencyNoAlpha;
    ASSERT(!IsAlphaPixelFormat(PixelFormat));
    
    if(device->pdds != NULL)
    {
        DdrawSurface7 = device->pdds;
        DdrawSurface7->AddRef();
    }

    Scan = device->ScanDci;
}

/**************************************************************************\
*
* Function Description:
*
*   Initializes a bitmap for drawing on via D3D/DD access.
*
* Arguments:
*
*   [IN] device - Identifies the device
*   [IN] width - Bitmap width
*   [IN] height - Bitmap height
*   [OUT] driver - Driver interface to be used
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   09/28/1999 bhouse
*       Created it.
*
\**************************************************************************/

BOOL
DpBitmap::InitializeForD3D(
    HDC hdc,
    INT *width,
    INT *height,
    DpDriver **driver
    )
{
    HRESULT ddVal;
    HDC hdcDevice;
    DDSURFACEDESC2 ddsd;

    if(!InitializeDirectDrawGlobals())
            return FALSE;

    IDirectDrawSurface7 * surface;

    ddVal = Globals::DirectDraw->GetSurfaceFromDC(hdc, &surface);

    if(ddVal != DD_OK)
        return(FALSE);

    return InitializeForD3D(surface, width, height, driver);
}

/**************************************************************************\
*
* Function Description:
*
*   Initializes a bitmap for drawing on via D3D/DD access.
*
* Arguments:
*
*   [IN] device - Identifies the device
*   [IN] width - Bitmap width
*   [IN] height - Bitmap height
*   [OUT] driver - Driver interface to be used
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   09/28/1999 bhouse
*       Created it.
*
\**************************************************************************/

BOOL
DpBitmap::InitializeForD3D(
    IDirectDrawSurface7 * surface,
    INT *width,
    INT *height,
    DpDriver **driver
    )
{
    HRESULT ddVal;
    HDC hdcDevice;
    DDSURFACEDESC2 ddsd;

    GpDevice * device = Globals::DeviceList->FindD3DDevice(surface);

    if(device == NULL || device->pd3d == NULL)
        return FALSE;

    DdrawSurface7 = surface;

    ddsd.dwSize = sizeof(ddsd);
    ddVal = DdrawSurface7->GetSurfaceDesc(&ddsd);

    if (ddVal == DD_OK)
    {
        // Initialize bitmap class stuff:

        Bits = NULL;
        Delta = ddsd.lPitch;
        Width = ddsd.dwWidth;
        Height = ddsd.dwHeight;

        // AlphaMask is initialized to zero because we don't use it -
        // non-alpha format.

        AlphaMask = 0x00000000;
        RedMask = ddsd.ddpfPixelFormat.dwRBitMask;
        GreenMask = ddsd.ddpfPixelFormat.dwGBitMask;
        BlueMask = ddsd.ddpfPixelFormat.dwBBitMask;

        PixelFormat = GetPixelFormatFromBitDepth(ddsd.ddpfPixelFormat.dwRGBBitCount);

        if (StandardFormat())
        {
            // Our standard formats don't have alpha.
            
            SurfaceTransparency = TransparencyNoAlpha;
    
            *driver = Globals::D3DDriver;
            Scan = &Globals::DesktopDevice->ScanEngine;

            NumBytes = 0;
            Uniqueness = (DWORD)GpObject::GenerateUniqueness();
        
            Type = D3D; 
            SetValid(TRUE);

            // Return some stuff:

            *width = Width;
            *height = Height;

            // Grab a reference:

            DdrawSurface7->AddRef();

            return(TRUE);
        }
    }

    return(FALSE);
}

/**************************************************************************\
*
* Function Description:
*
*   Initializes a bitmap for drawing on via printer routines, if possible.
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   12/06/1998 andrewgo
*       Created it.
*
\**************************************************************************/

BOOL
DpBitmap::InitializeForPrinter(
    GpPrinterDevice *device,
    INT width,
    INT height
    )
{
    InitializeForGdiBitmap(device, width, height);
        
    // Even if GDI bitmaps change to support alpha, printers don't.
    
    SurfaceTransparency = TransparencyNoAlpha;
    ASSERT(!IsAlphaPixelFormat(PixelFormat));

    Scan = &device->ScanPrint;
    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*   Initializes a bitmap for drawing on via direct access to the 
*   DIBsection bits.
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   12/06/1998 andrewgo
*       Created it.
*
\**************************************************************************/

BOOL
DpBitmap::InitializeForDibsection(
    HDC hdc,
    HBITMAP hbitmap,            // [IN] Bitmap handle, needed for determing
                                //       if bitmap is really top-down or not
    GpDevice *device,           // [IN] Identifies the device
    DIBSECTION *dib,            // [IN] Structure describing the bitmap
    INT *width,                 // [OUT] Bitmap width
    INT *height,                // [OUT] Bitmap height
    DpDriver **driver           // [OUT] Driver interface to be used
    )
{
    BOOL isTopDown;

    // On NT5, drivers have the option of supporting GetDC with DirectDraw
    // surfaces in such a way that the surfaces are not Locked when GDI
    // does the GetDC on them.  This means that there may be no user-mode 
    // mapping of the underlying surface.  So we have to check here for 
    // that case, because we obviously cannot render directly to those 
    // surfaces via software:

    // NOTE: if the surface is actually a DDraw surface, this check is not
    // actually enough. It is up to the driver to return a pointer here and
    // on occasion it simply returns its KM address. I.e. it will return a
    // non-NULL pointer that we can't access.
    // See the DDraw special case below.
    // This has been verified on a number of video drivers on Windows 2000
    // and Windows XP. (for instance, the inbox win2k permedia driver).
    
    if (dib->dsBm.bmBits == NULL)
    {
        return(FALSE);
    }

    LONG scans = abs(dib->dsBm.bmHeight);
    LONG widthInBytes = dib->dsBm.bmWidthBytes;

    // For backwards compatibility with Get/SetBitmapBits, GDI does
    // not accurately report the bitmap pitch in bmWidthBytes.  It
    // always computes bmWidthBytes assuming WORD-aligned scanlines
    // regardless of the platform.
    //
    // Therefore, if the platform is WinNT, which uses DWORD-aligned
    // scanlines, adjust the bmWidthBytes value.

    if (Globals::IsNt)
    {
        widthInBytes = (widthInBytes + 3) & ~3;
    }

    DWORD* topDown = (DWORD*) dib->dsBm.bmBits;
    DWORD* bottomUp = (DWORD*) ((ULONG_PTR) topDown + (scans - 1) * widthInBytes);

    if (Globals::IsNt)
    {
        // Unfortunately, on NT there is no simple means of determining
        // whether the DIB-section or DDraw surface is bottom-up or
        // top-down.  (NT should really set biHeight as Win9x does, but
        // unfortunately this is a bug that due to compatibility with
        // older versions of NT, will never be fixed.)
        //
        // At least we know that DirectDraw surfaces will always be
        // top-down, and we can recognize DDraw surfaces by the fact
        // that they have biSizeImage set to 0.  (Note that we can't let
        // this fall into the SetBitmapBits case because NT5 doesn't
        // permit SetBitmapBits calls on DDraw surface handles.)

        if (dib->dsBmih.biSizeImage == 0)
        {
            // This is a DirectDraw surface.
            
            // Currently we don't support direct rendering on DDraw surfaces
            // that are not backed by a system memory DIB Section so we simply 
            // fail here and drop into the GDI fallback code if we detect 
            // this condition.
        
            isTopDown = TRUE;
                                
            if(!InitializeDirectDrawGlobals() ||
               (Globals::GetDdrawSurfaceFromDcFunction == NULL))
            {
                // If we can't talk to the DDraw surface, we simply fall back
                // to our GDI rendering codepath.
                
                return FALSE;
            }
            
            HDC driverHdc;
            LPDIRECTDRAWSURFACE pDDS = NULL;
            
            HRESULT hr = Globals::GetDdrawSurfaceFromDcFunction(
                hdc, 
                &pDDS,
                &driverHdc
            );
            
            if (FAILED(hr) || (pDDS == NULL)) 
            {
                // Bail out if we can't get a DirectDraw Surface object.
                
                return FALSE;
            }
            
            // Lock the surface so we can see what the user mode bits pointer
            // is. If it's the same as the one in dib->dsBm.bmBits, then 
            // the DDraw surface is backed by a DIB section and we can continue
            // to treat this bitmap as a DIB. Otherwise we must fall back
            // to GDI.
            
            DDSURFACEDESC2 DDSD;
            DDSD.dwSize = sizeof(DDSURFACEDESC);
            
            hr = pDDS->Lock(
                NULL, 
                (LPDDSURFACEDESC)&DDSD, 
                DDLOCK_WAIT, 
                NULL
            );
            
            if (FAILED(hr))
            {
                pDDS->Release();
                return FALSE;
            }
            
            // Get the correct pitch from the DDSD. Note this may not be the
            // same as the pitch in the dib info structure.
            
            widthInBytes = DDSD.lPitch;
            
            // If the lpSurface is not the same as the dib->dsBm.bmBits then
            // this is not a DIB backed DDraw surface, so we (currently) have
            // no way of drawing on it besides our GDI fallback codepath.
            // Fail this call and release resources so that we can pick up
            // the StretchBlt fallback case.
            
            if(DDSD.lpSurface != dib->dsBm.bmBits)
            {
                pDDS->Unlock(NULL);
                pDDS->Release();
                return FALSE;
            }
            
            pDDS->Unlock(NULL);
            pDDS->Release();
            
            // We're set: this is a DIB backed DDraw surface so we can continue
            // to treat it as a DIB - now that we have the correct pitch.    
        }
        else
        {
            // When it's not a DDraw surface, we have to go through a
            // somewhat more indirect method to figure out where pixel
            // (0, 0) is in memory.  
            //
            // We use SetBitmapBits instead of something like SetPixel
            // or PatBlt because those would need to use the 'hdc'
            // given to us by the application, which might have a
            // transform set that maps (0, 0) to something other than
            // the top-left pixel of the bitmap.

            DWORD top = *topDown;
            DWORD bottom = *bottomUp;
            DWORD setBits = 0x000000ff;

            // Our SetBitmapBits call will set the top-left dword of
            // the bitmap to 0x000000ff.  If it's a top-down bitmap,
            // that will have modified the value at address 'topDown':

            *topDown = 0;
            LONG bytes = SetBitmapBits(hbitmap, sizeof(setBits), &setBits);
            isTopDown = (*topDown != 0);

            // The scanlines are guaranteed to be DWORD aligned, so there
            // really is at least a DWORD that we can directly access via
            // the pointer.  However, if the bitmap dimensions are such
            // that there is less than a DWORD of active data per scanline
            // (for example, a 3x3 8bpp bitmap or a 1x1 16bpp bitmap),
            // SetBitmapBits may use less than a DWORD of data.

            ASSERT(bytes > 0);

            // Restore the bitmap portions that we may have modified:

            *topDown = top;
            *bottomUp = bottom;
        }
    }
    else
    {
        // On Win9x, we can simply look at the sign of 'biHeight' to
        // determine whether the surface is top-down or bottom-up:

        isTopDown = (dib->dsBmih.biHeight < 0);
    }

    // Fill in our bitmap fields:

    if (isTopDown)
    {
        Bits = (BYTE*) topDown;
        Delta = widthInBytes;
    }
    else
    {
        Bits = (BYTE*) bottomUp;
        Delta = -widthInBytes;
    }

    Width = dib->dsBm.bmWidth;
    Height = dib->dsBm.bmHeight;
    
    // Note that this code doesn't handle palettes!

    if (dib->dsBmih.biCompression == BI_BITFIELDS)
    {
        RedMask = dib->dsBitfields[0];
        GreenMask = dib->dsBitfields[1];
        BlueMask = dib->dsBitfields[2];
    }
    else
    {
        if((dib->dsBmih.biCompression == BI_RGB) &&
           (dib->dsBm.bmBitsPixel == 16))
        {
            // According to MSDN, 16bpp BI_RGB implies 555 format.
            
            RedMask = 0x00007c00;
            GreenMask = 0x000003e0;
            BlueMask = 0x0000001F;
        }
        else
        {
            RedMask = 0x00ff0000;
            GreenMask = 0x0000ff00;
            BlueMask = 0x000000ff;
        }
    }
    
    // DibSections don't have alpha, but we don't want to leave this
    // field uninitialized because we peek at it occasionally.

    AlphaMask = 0x00000000;

    PixelFormat = GetPixelFormatFromBitDepth(dib->dsBm.bmBitsPixel);

    // if we are here and the bits per pel is 8, this is a DIB
    // with halftone colortable

    if ((dib->dsBm.bmBitsPixel == 8) || StandardFormat())
    {
        // Our standard formats don't have alpha.
        
        SurfaceTransparency = TransparencyNoAlpha;
        
        *driver = Globals::EngineDriver;
        Scan = &device->ScanEngine;

        NumBytes = 0;
        Uniqueness = (DWORD)GpObject::GenerateUniqueness();
    
        Type = GDIDIBSECTION; 
        SetValid(TRUE);

        // Return some stuff:

        *width = Width;
        *height = Height;

        return(TRUE);
    }

    return(FALSE);
}

/**************************************************************************\
*
* Function Description:
*
*   Initializes a GDI+ bitmap for drawing on via GpBitmap.Lock/UnlockBits.
*
* Arguments:
*
*   [IN] bitmap - Specifies the target GpBitmap
*
* Return Value:
*
*   TRUE is successful, FALSE otherwise.
*
* History:
*
*   09/22/1999 gilmanw
*       Created it based on DpBitmap::InitializeForGdiBitmap.
*
\**************************************************************************/

VOID
DpBitmap::InitializeForGdipBitmap(
    INT             width,
    INT             height,
    ImageInfo *     imageInfo,
    EpScanBitmap *  scanBitmap,
    BOOL            isDisplay
    )
{
    Width  = width;
    Height = height;

    NumBytes   = 0;
    Uniqueness = (DWORD)GpObject::GenerateUniqueness();
    AlphaMask = 0xff000000;
    RedMask   = 0x00ff0000;
    GreenMask = 0x0000ff00;
    BlueMask  = 0x000000ff;

    SetValid(TRUE);
    Bits = NULL;
    Delta = 0;

    Type = GPBITMAP;

    Scan = scanBitmap;

    PaletteTable = NULL;

    PixelFormat = imageInfo->PixelFormat;

    // GetTransparencyHint is called from DrvDrawImage
    // bitmap->GetTransparencyHint(&SurfaceTransparency);
    
    IsDisplay = isDisplay;
    DpiX = (REAL)imageInfo->Xdpi;
    DpiY = (REAL)imageInfo->Ydpi;
}

/**************************************************************************\
*
* Function Description:
*
*   Bitmap destructor
*
\**************************************************************************/

DpBitmap::~DpBitmap()
{ 
    if (PaletteTable != NULL) 
        GpFree(PaletteTable);
    
    if (DdrawSurface7 != NULL)
        DdrawSurface7->Release();

    SetValid(FALSE);    // so we don't use a deleted object
}

/**************************************************************************\
*
* Function Description:
*
*   Flush any rendering pending to this surface
*
\**************************************************************************/

VOID
DpBitmap::Flush(
    GpFlushIntention intention
    )
{
    Scan->Flush();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\facerealization.cpp ===
#include "precomp.hpp"

#define PATH_HEIGHT_THRESHOLD 800

#define PAGE_SIZE (8*1024)
#define ROUND_TO_PAGE(x)  (((x)+PAGE_SIZE-1)&~(PAGE_SIZE-1))

#define CJMININCREMENT     0x2000
#define CJMAX              (16 * 0x2000)

#define FONT_GRAYSCALE_OR_CT_OR_MONOUNHINTED (FO_GRAYSCALE | FO_SUBPIXEL_4 | FO_CLEARTYPE_GRID | FO_CLEARTYPE | FO_MONO_UNHINTED | FO_COMPATIBLE_WIDTH)

// we want number divisible by 8 containing about 75 glyphs,
// almost an upper limit on number of glyphs in the metrics cache
// when running winstone memory constrained scenario

#define GD_INC  (76 * sizeof(GpGlyphData) * 2)

// GD_INC amounts to 1520 == 000005f0H, far less than a page.

// according to Kirk's statistics, very few realizations cache more
// than 60 glyphs, so we shall start with a block which contains about
// 60 glyphs

#define C_GLYPHS_IN_BLOCK 64

ULONG ulClearTypeFilter(GLYPHBITS *GlyphBits, ULONG cjBuf, CacheFaceRealization *prface);

BOOL SetFontXform(
    const GpGraphics *pdc,
    const GpFontFace *pfe,
    REAL              height,
    Unit              unit,
    FD_XFORM         *pfdx,
    BOOL              needPaths,
    const GpMatrix   *pmx
)
{
    REAL EmHt, scale;
    REAL DpiX, DpiY;

    if (needPaths && unit != UnitWorld)
        return FALSE;

    EmHt = pfe->GetDesignEmHeight();

    if (!needPaths)
    {
        DpiX = pdc->GetDpiX();
        DpiY = pdc->GetDpiY();

        // UnitDisplay is device dependent and cannot be used as a font unit
        ASSERT(unit != UnitDisplay);

        if (unit != UnitWorld && unit != UnitPixel)
        {
            height *= DpiY;

            switch (unit)
            {
            case UnitPoint:
                height /= 72.0;
                break;
            case UnitDocument:
                height /= 300.0;
                break;
            case UnitMillimeter:
                height *= 10.0;
                height /= 254.0;
                break;
            default:
                return FALSE;
            }
        }
    }

    scale = height / EmHt;

    GpMatrix tempMatrix(scale, 0, 0, scale, 0, 0);
    GpMatrix wtodMatrix;
    REAL m[6];

    if (pmx)
        tempMatrix.Append(*pmx);

    if (!needPaths)
    {
        pdc->GetWorldToDeviceTransform(&wtodMatrix);
        tempMatrix.Append(wtodMatrix);
    }

    tempMatrix.GetMatrix(m);

    pfdx->eXX = m[0];
    pfdx->eXY = m[1];
    pfdx->eYX = m[2];
    pfdx->eYY = m[3];

    // Adjust for the non-square resolution

    if (!needPaths)
    {
        if (DpiY != DpiX)
        {
            DpiX /= DpiY;
            pfdx->eXX *= DpiX;
            pfdx->eYX *= DpiX;
        }
    }

    return TRUE;
}



//////////////////////////////////////////////////////////////////////////////

GpFaceRealization::GpFaceRealization(
    const GpFontFace  *face,
    INT                style,
    const GpMatrix    *matrix,
    const SizeF        dpi,
    TextRenderingHint  textMode,
    BOOL               bPath,
    BOOL               bCompatibleWidth,  /* we want ClearType compatible width when we come from DrawDriverString */
    BOOL               bSideways  /* for far east vertical writing, run of glyph layed out sideways,
                                    used to do the italic simulation in the right direction */
) :
    prface        (NULL),
    Style         (style),
    Status        (GenericError),
    LimitSubpixel (FALSE)
{
    if (bInit(face, style, matrix, dpi, textMode, bPath, bCompatibleWidth, bSideways))
    {
        vGetCache();
        Status = Ok;
    }
}

void GpFaceRealization::CloneFaceRealization(
    const GpFaceRealization *  pfaceRealization,
    BOOL                bPath
)
{
    BOOL    bOK = FALSE;
    SizeF   dpi;

// Adjust for the non-square resolution
// Now we will not do it but eventually we will need to do it.

    prface = NULL;

    if (FindRealizedFace(pfaceRealization->pfdx(), pfaceRealization->GetFontFace(),
                            bPath, pfaceRealization->prface->fobj.flFontType))
        bOK = TRUE;

    dpi.Width = (REAL) pfaceRealization->prface->fobj.sizLogResPpi.cx;
    dpi.Height = (REAL) pfaceRealization->prface->fobj.sizLogResPpi.cy;

    if (!bOK && Realize(dpi, pfaceRealization->GetFontFace(), pfaceRealization->GetStyle(),
                    pfaceRealization->pfdx(), pfaceRealization->prface->fobj.flFontType, bPath))
    {
        prface->Face->pff->cRealizedFace +=1;
        bOK = TRUE;
    }

    if (bOK)
    {
        vGetCache();
        Status = Ok;
    }
}

BOOL GpFaceRealization::bInit(
    const GpFontFace *  pface,
    INT                 style,
    const GpMatrix *    matrix,
    SizeF               dpi,
    TextRenderingHint   textMode,
    BOOL                bPath,
    BOOL                bCompatibleWidth,  /* we want ClearType compatible width when we come from DrawDriverString */
    BOOL                bSideways  /* for far east vertical writing, run of glyph layed out sideways,
                                      used to do the italic simulation in the right direction */
)
{

// It is a new version of face realization

    REAL        m[6];
    FD_XFORM    fdxTmp;
    BOOL        canSimulate = TRUE;

    ULONG fl = FO_EM_HEIGHT;
    ULONG flSim = 0;

    matrix->GetMatrix(m);

    fdxTmp.eXX = m[0];
    fdxTmp.eXY = m[1];
    fdxTmp.eYX = m[2];
    fdxTmp.eYY = m[3];

// Adjust for the non-square resolution
// Now we will not do it but eventually we will need to do it.

    prface = NULL;

    // TextRenderingHintSystemDefault should already been converted through GetTextRenderingHintInternal
    ASSERT (textMode != TextRenderingHintSystemDefault);

    if (textMode == TextRenderingHintSingleBitPerPixel)
        fl |= FO_MONO_UNHINTED;
    else if (textMode == TextRenderingHintAntiAliasGridFit)
        fl |= FO_GRAYSCALE;
    else if (textMode == TextRenderingHintAntiAlias)
        fl |= FO_GRAYSCALE | FO_SUBPIXEL_4;
    else if (textMode == TextRenderingHintClearTypeGridFit)
    {
        fl |= FO_GRAYSCALE | FO_CLEARTYPE_GRID;
        if (bCompatibleWidth)
            fl |= FO_COMPATIBLE_WIDTH;
    }
// version 2 :
//    else if (textMode == TextRenderingHintClearType)
//        fl |= FO_GRAYSCALE | FO_CLEARTYPE;


    if (    style & FontStyleBold
        &&  !(pface->GetFaceStyle() & FontStyleBold))
    {
        if (pface->SimBold())
        {
            fl |= FO_SIM_BOLD;
        }
        else
        {
            return FALSE;   // Bold required but cannot be simulated
        }
    }


    if (    style & FontStyleItalic
        &&  !(pface->GetFaceStyle() & FontStyleItalic))
    {
        if (pface->SimItalic())
        {
            if (bSideways)
            {
                fl |= FO_SIM_ITALIC_SIDEWAYS;
            }
            else
            {
                fl |= FO_SIM_ITALIC;
            }
        }
        else
        {
            return FALSE;   // Italic required but cannot be simulated
        }
    }


    if (FindRealizedFace(&fdxTmp, pface, bPath, fl))
        return TRUE;

    if (Realize(dpi, pface, style, &fdxTmp, fl, bPath))
    {
        pface->pff->cRealizedFace +=1;
        return TRUE;
    }

    return FALSE;
}




// Destructor -- Unlocks the CacheFaceRealization

GpFaceRealization::~GpFaceRealization ()
{
    if (prface != (CacheFaceRealization *) NULL )
    {
        vReleaseCache();
    }
}


GpFaceRealization::ReuseRealizedFace()
{

    if (prface != (CacheFaceRealization *) NULL )
    {
        // free glyphbit cache

        GlyphBitsBlock *pbblfree, *pbbl = prface->FirstGlyphBitsBlock;
        while(pbbl)
        {
            pbblfree = pbbl;
            pbbl = pbbl->NextGlyphBitsBlock;
            GpFree((PVOID)pbblfree);
        }

        // free glyphdata cache

        GlyphDataBlock *pdblfree, *pdbl = prface->FirstGlyphDataBlock;
        while (pdbl)
        {
            pdblfree = pdbl;
            pdbl = pdbl->NextGlyphDataBlock;
            GpFree((PVOID)pdblfree);
        }

        GpFree(prface->GlyphDataArray);

        vDestroyRealizedFace(); /* release the FontContext Memory */
    }
    return TRUE;

}



GpFaceRealization::DeleteRealizedFace()
{

    if (prface != (CacheFaceRealization *) NULL )
    {
        ReuseRealizedFace();
        GpFree(prface);
    }

    return TRUE;
}

static inline
BOOL SwitchToPath(FLONG flFontType, const FD_DEVICEMETRICS & deviceMetrics)
{
    BOOL fResult = FALSE;
    INT pathThreshold = PATH_HEIGHT_THRESHOLD;

    if (flFontType & FO_CLEARTYPE_GRID)
        pathThreshold /= 8;
    else if (flFontType & FO_GRAYSCALE)
        pathThreshold /= 4;

    // Note: This function need quite a bit of reworking so that it takes
    // the rotation of the font into account when determining the transition
    // point between bitmap/CT and path. Currently the size where we switch
    // rendering modes is based on the maximum dimension of the bounding
    // box of the largest rotated character. Also note that if a single
    // glyph in the font is significantly offset from the rest of the
    // glyphs in the font, the deviceMetrics will indicate a much larger
    // required bitmap than we would normally use. This switch to path really
    // needs to be strictly based on the ascent of the font above the
    // baseline, independent of the rotation or the maximum bounding
    // rectangle for the rendered glyphs.

    if (flFontType & FO_CLEARTYPE_GRID)
    {
        // Cleartype should not take width of the bitmap into account.
        // For rotated text, we will cache larger bitmaps for ClearType
        // than for other rendering modes, but this will allow us to more
        // closely match the behavior of ClearType in notepad.

        fResult =
            (deviceMetrics.yMax - deviceMetrics.yMin) > pathThreshold;
    }
    else
    {
        fResult =
            (deviceMetrics.xMax - deviceMetrics.xMin) > pathThreshold ||
            (deviceMetrics.yMax - deviceMetrics.yMin) > pathThreshold;
    }

    return fResult;
} // SwitchToPath

BOOL GpFaceRealization::FindRealizedFace(
    FD_XFORM            *fdx,
    const GpFontFace    *fontFace,
    BOOL                needPaths,
    FLONG               fl
) const
{

    FLONG fltemp1 = fl & FONT_GRAYSCALE_OR_CT_OR_MONOUNHINTED;
    FLONG fltemp2 = fl & (FO_SIM_BOLD | FO_SIM_ITALIC | FO_SIM_ITALIC_SIDEWAYS);

    for (prface = fontFace->pff->prfaceList;
         prface != NULL;
         prface = (prface->NextCacheFaceRealization == fontFace->pff->prfaceList) ? NULL : prface->NextCacheFaceRealization)
    {
        if (prface->Face == fontFace)
        {
            if ((prface->ForcedPath || (needPaths == IsPathFont())) &&
                MatchFDXForm(fdx))
            {
                if (IsPathFont())
                {
                    // if for given text rendering hint we can't switch to path
                    // skip this realization (unless someone really wants path)
                    if (!needPaths && !SwitchToPath(fl, prface->DeviceMetrics))
                        continue;
                }
                else
                {
                    // FO_NOGRAY16 means that for this transform, grayscale was turned off following the "gasp" table
                    // see vSetGrayState__FONTCONTEXT in TrueType driver
                    FLONG fltemp = fltemp1;
                    if (prface->fobj.flFontType & FO_NOGRAY16)
                        fltemp &= ~FO_GRAYSCALE;

                    if (prface->fobj.flFontType & FO_NOCLEARTYPE)
                    {
                        if (fltemp & FO_CLEARTYPE_GRID)
                            fltemp &= ~(FO_CLEARTYPE_GRID | FO_GRAYSCALE | FO_COMPATIBLE_WIDTH);
                    }

                    if ((prface->fobj.flFontType & FONT_GRAYSCALE_OR_CT_OR_MONOUNHINTED) != fltemp)
                    {
                        continue;
                    }
                }

                if ((prface->fobj.flFontType & (FO_SIM_BOLD | FO_SIM_ITALIC | FO_SIM_ITALIC_SIDEWAYS)) != fltemp2)
                    continue;

                // We need to update the recently used list here!
                Globals::FontCacheLastRecentlyUsedList->RemoveFace(prface);
                Globals::FontCacheLastRecentlyUsedList->AddMostRecent(prface);

                return TRUE;
            }
        }
    }

    prface = NULL;

    return FALSE;
}




BOOL GpFaceRealization::bGetDEVICEMETRICS()
{

    if (ttfdSemQueryFontData(
        &prface->fobj,
        QFD_MAXEXTENTS,
        HGLYPH_INVALID,
        (GLYPHDATA *) NULL,
        &prface->DeviceMetrics) == FD_ERROR)
    {
    // The QFD_MAXEXTENTS mode is required of all drivers.
    // However must allow for the possibility of this call to fail.
    // This could happen if the
    // font file is on the net and the net connection dies, and the font
    // driver needs the font file to produce device metrics [bodind]

        return FALSE;
    }


    if (prface->fobj.flFontType & FO_CLEARTYPE_GRID)
    {
        // need to compute the filtering correction for CLEAR_TYPE:
        // x filtering adds a pixel on each side of the glyph
        prface->MaxGlyphByteCount = CJ_CTGD(
            prface->DeviceMetrics.cxMax + 2,
            prface->DeviceMetrics.cyMax
        );
    }
    else
    {
        prface->MaxGlyphByteCount = prface->DeviceMetrics.cjGlyphMax; // used to get via QFD_MAXGLYPHBITMAP
    }


    // Everythings OK.

    return TRUE;
}




VOID  GpFaceRealization::vDestroyRealizedFace()
{
    ttfdSemDestroyFont(&prface->fobj);
}

BOOL GpFaceRealization::Realize(
    SizeF             dpi,
    const GpFontFace *pfe,
    INT               style,      // style - which may require simulation
    PFD_XFORM         pfdx,       // font xform (Notional to Device)
    FLONG             fl,         // these two really modify the xform
    BOOL              bNeedPaths
)
{
    BOOL result = FALSE;

// prface is a member variable pointing to the embedded CacheFaceRealization

    if (Globals::FontCacheLastRecentlyUsedList->GetCount() >= MAXRECENTLYUSEDCOUNT)
    {
        prface = Globals::FontCacheLastRecentlyUsedList->ReuseLeastRecent();

        ASSERT(prface);
    }
    else
    {
        prface = (CacheFaceRealization *)GpMalloc(sizeof(CacheFaceRealization));
    }

    if (!prface)
        return FALSE;

// Copy the font transform passed in.

    prface->fobj.fdx = *pfdx;

// Initialize the DDI callback EXFORMOBJ.

    GpMatrix tmpMatrix(pfdx->eXX, pfdx->eXY, pfdx->eYX, pfdx->eYY, 0, 0);
    prface->mxForDDI = tmpMatrix;

// Initialize the FONTOBJ inherited by the embedded CacheFaceRealization

// Save identifiers to the source of the font (physical font).

    prface->Face = pfe;

// GetDpiX() and GetDpiY() return REALs

    prface->fobj.sizLogResPpi.cx = GpRound(dpi.Width);
    prface->fobj.sizLogResPpi.cy = GpRound(dpi.Height);

    prface->fobj.ulPointSize = 0;
    prface->fobj.flFontType = fl | FO_TYPE_TRUETYPE;              // fl contains simulation flag(s)
    prface->fobj.pvProducer = (PVOID) NULL;          // the true type driver will init this field
    prface->fobj.iFace = prface->Face->iFont;
    prface->fobj.iFile = prface->Face->pff->hff;


// Get the device metrics info

    if (!bGetDEVICEMETRICS())
    {
        vDestroyRealizedFace(); // kill the driver realization
        GpFree(prface);
        prface = NULL;
        return result;        // return FALSE
    }

    prface->CacheType = bNeedPaths ? CachePath : CacheBits;
    prface->ForcedPath = FALSE;

    if (!bNeedPaths)
    {
        // We force drawing with a path if size is to large
        if (SwitchToPath(prface->fobj.flFontType, prface->DeviceMetrics))
        {
            prface->CacheType = CachePath;
            prface->ForcedPath = TRUE;
        }
    }


// If you force the path mode then turn off antialiasing

    if (IsPathFont())
    {
        prface->fobj.flFontType &= ~FONT_GRAYSCALE_OR_CT_OR_MONOUNHINTED;
        prface->realizationMethod = TextRenderingHintSingleBitPerPixelGridFit;
        prface->QueryFontDataMode = QFD_GLYPHANDOUTLINE;
    }
    else
    {
        if (prface->fobj.flFontType & FO_GRAYSCALE)
        {
// version 2 :
//            if (prface->fobj.flFontType & FO_CLEARTYPE)
//            {
//                prface->realizationMethod = TextRenderingHintClearType;
//                prface->QueryFontDataMode = QFD_CT;
//            }
            if (prface->fobj.flFontType & FO_CLEARTYPE_GRID)
            {
                prface->realizationMethod = TextRenderingHintClearTypeGridFit;
                prface->QueryFontDataMode = QFD_CT_GRID;
            }
            else if (prface->fobj.flFontType & FO_SUBPIXEL_4)
            {
                prface->CacheType = CacheAABits;
                prface->realizationMethod = TextRenderingHintAntiAlias;
                prface->QueryFontDataMode = QFD_TT_GRAY4_BITMAP;
            }
            else
            {
                prface->realizationMethod = TextRenderingHintAntiAliasGridFit;
                prface->QueryFontDataMode = QFD_TT_GRAY4_BITMAP;
            }
        }
        else
        {
            if (prface->fobj.flFontType & FO_MONO_UNHINTED)
            {
                prface->realizationMethod  = TextRenderingHintSingleBitPerPixel;
                prface->QueryFontDataMode = QFD_GLYPHANDBITMAP_SUBPIXEL;
            }
            else
            {
                prface->realizationMethod  = TextRenderingHintSingleBitPerPixelGridFit;
                prface->QueryFontDataMode = QFD_GLYPHANDBITMAP;
            }
        }
    }

    if (!bInitCache())
    {
        vDestroyRealizedFace(); // kill the driver realization
        GpFree(prface);
        prface = NULL;
        return result;        // return FALSE
    }

// Made it this far, so everything is OK

    result = TRUE;

    Globals::FontCacheLastRecentlyUsedList->AddMostRecent(prface);

    vInsert(&prface->Face->pff->prfaceList);

    return result;
}




VOID GpFaceRealization::vInsert(CacheFaceRealization **pprfaceHead)
{

    if (*pprfaceHead != NULL)
    {
        prface->NextCacheFaceRealization = *pprfaceHead;

        prface->PreviousCacheFaceRealization = (*pprfaceHead)->PreviousCacheFaceRealization;

        prface->PreviousCacheFaceRealization->NextCacheFaceRealization = prface;

        (*pprfaceHead)->PreviousCacheFaceRealization = prface;
    }
    else
    {
        prface->NextCacheFaceRealization = prface;
        prface->PreviousCacheFaceRealization = prface;
    }

    *pprfaceHead = prface;

}




BOOL GpFaceRealization::bInitCache() const
{
    BOOL result = TRUE;     // unless proven otherwise

    // Set the pointer to null.  vDeleteCache will free memory from
    // any non-null pointers.  This simplifies cleanup, since bRealize
    // ensures that vDeleteCache is called if this routine fails.

    // metrics portion

    prface->FirstGlyphDataBlock = NULL;
    prface->GlyphDataBlockUnderConstruction = NULL;
    prface->NextFreeGlyphDataIndex    = 0;

    // glyphbits portion

    prface->FirstGlyphBitsBlock = NULL;
    prface->GlyphBitsBlockUnderConstruction = NULL;
    prface->SizeGlyphBitsBlockUnderConstruction    = 0;
    prface->UsedBytesGlyphBitsBlockUnderConstruction    = 0;

    // aux mem portion

    prface->LookasideGlyphData = NULL;
    prface->LookasideByteCount = 0;
    prface->GlyphDataArray = NULL; // to be allocated later, big allocation


    prface->NextCacheFaceRealization = NULL;
    prface->PreviousCacheFaceRealization = NULL;

    // First, figure out how big the max glyph will be
    // Default is zero - glyphdata size is not counted!

    ULONG  cjGlyphMaxX2;

    if (IsPathFont())
    {
        cjGlyphMaxX2 = CJMAX;
    }
    else
    {
        cjGlyphMaxX2 = 2 * prface->MaxGlyphByteCount;
    }

    // if we can't even get one glyph in a maximum size cache, don't cache
    // Note that we need room for the default glyph and one other glyph

    prface->NoCache = FALSE;

    if (cjGlyphMaxX2 > CJMAX)
    {

        // Glyph exceeds maximum cache memory size, so we will revert to
        // caching just the metrics.  This will speed up things like
        // GetCharWidths, and stuff that just *has* to have the glyphs
        // will use the lookaside stuff (previously called BigGlyph)

        /* we don't support NoCache and Path */
        ASSERT(!IsPathFont())
        prface->NoCache = TRUE;
    }


    // set up the cache semaphore.
    // InitializeCriticalSection(&prface->FaceRealizationCritSection);

    return result;
}




BOOL GpFaceRealization::AllocateCache() const
{
    BOOL result = TRUE;     // unless proven otherwise

    ULONG cGlyphsTotal = 0;

    cGlyphsTotal = GetGlyphsSupported();

    if (!cGlyphsTotal)
        return FALSE;

    // The distribution of metics per realized font w/ Winstone97 is:
    //
    //      43% <= 0 Metrics
    //      50% <= 6 Metrics
    //      76% <= 32 Metrics
    //      99% <= 216 Metrics
    //      100% <= 249 Metrics
    //


    // allocate memory for the glyphDataArray :

    if ((prface->GlyphDataArray = (GpGlyphData **) GpMalloc(cGlyphsTotal * sizeof(GpGlyphData*))) == NULL)
    {
        return FALSE;
    }

    // init all glyphdata pointers to zero

    memset(prface->GlyphDataArray, 0, sizeof(GpGlyphData*) * cGlyphsTotal);


    // Allocate memory for the first GpGlyphData block

    if ((prface->GlyphDataBlockUnderConstruction = (GlyphDataBlock *)GpMalloc(sizeof(GlyphDataBlock))) == NULL)
    {
        return FALSE;
    }
    prface->FirstGlyphDataBlock = prface->GlyphDataBlockUnderConstruction;
    prface->FirstGlyphDataBlock->NextGlyphDataBlock = NULL;
    prface->NextFreeGlyphDataIndex = 0;

    // we shall re-interpret cjMax to mean the max number of bytes in
    // glyphbits portion of the cache per 1K of glyphs in the font.
    // That is for larger fonts we shall allow more glyphbits
    // memory per realization than for ordinary US fonts. This will be
    // particularly important for FE fonts. This same code will work fine
    // in their case too:

    ULONG cjBytes = 16 * prface->MaxGlyphByteCount;

    ULONG AllocationSize = ROUND_TO_PAGE(cjBytes);

    if (AllocationSize == 0)
        prface->cBlocksMax = 1;
    else
    {
        prface->cBlocksMax =
            (CJMAX * ((cGlyphsTotal + 1024 - 1)/1024)) /
            AllocationSize;

        /* at least one block */
        if (prface->cBlocksMax == 0)
            prface->cBlocksMax = 1;
    }
    prface->cBlocks = 0;

    return result;
}




////  ConvertGLYPHDATAToGpGlyphMetrics
//
//    Populate GpGlyphMetrics field of GpGlyphData from font driver GLYPHDATA


VOID GpFaceRealization::ConvertGLYPHDATAToGpGlyphMetrics(
    IN   INT           glyphIndex,
    IN   GLYPHDATA    *pgd,
    OUT  GpGlyphData  *pgpgd
) const
{
    // horizontal metrics:

    pgpgd->GlyphMetrics[0].AdvanceWidth        = pgd->fxD;
    pgpgd->GlyphMetrics[0].LeadingSidebearing  = pgd->fxA;
    pgpgd->GlyphMetrics[0].TrailingSidebearing = pgd->fxD - pgd->fxAB;
    pgpgd->GlyphMetrics[0].Origin              = PointF(0,0);

    // vertical metrics:

    pgpgd->GlyphMetrics[1].AdvanceWidth        = pgd->fxD_Sideways;
    pgpgd->GlyphMetrics[1].LeadingSidebearing  = pgd->fxA_Sideways;
    pgpgd->GlyphMetrics[1].TrailingSidebearing = pgd->fxD_Sideways - pgd->fxAB_Sideways;

    pgpgd->GlyphMetrics[1].Origin.X = pgd->VerticalOrigin_X / 16.0f;
    pgpgd->GlyphMetrics[1].Origin.Y = pgd->VerticalOrigin_Y / 16.0f;

    pgpgd->GlyphBits = NULL;
}




GpStatus GpFaceRealization::IsMetricsCached
(
    UINT16      glyphIndex,
    ULONG       *pcjNeeded
) const
{
    ULONG cjNeeded = 0;

    if (prface->GlyphDataArray == NULL)
        if (!AllocateCache())
            return OutOfMemory;

    if (glyphIndex >= prface->Face->NumGlyphs)
        return InvalidParameter;

    if (!prface->GlyphDataArray[glyphIndex])
    {
        GLYPHDATA   gd;

        // Verify enough room in metrics cache area, grow if needed.
        // Note that failure to fit a glyphdata is a hard error, get out now.

        if (!CheckMetricsCache())
        {
            return GenericError;
        }

        // Call font driver to get the metrics.

        cjNeeded = ttfdSemQueryFontData(
            &prface->fobj,
            prface->QueryFontDataMode,
            (HGLYPH)glyphIndex,
            &gd,
            NULL
        );
        if (cjNeeded == FD_ERROR)
        {
            return GenericError;
        }

        gd.gdf.pgb = NULL;

        if (prface->fobj.flFontType & FO_CLEARTYPE_GRID)
        {
            ULONG cx = (ULONG)(gd.rclInk.right  - gd.rclInk.left);
            ULONG cy = (ULONG)(gd.rclInk.bottom - gd.rclInk.top);
            ASSERT(cjNeeded <= CJ_CTGD(cx+2,cy));
            cjNeeded = CJ_CTGD(cx+2,cy);
        }

        prface->GlyphDataArray[glyphIndex] = &prface->GlyphDataBlockUnderConstruction->GlyphDataArray[prface->NextFreeGlyphDataIndex];

        // Populate GpGlyphMetrics field of GpGlyphData from font driver GLYPHDATA

        ConvertGLYPHDATAToGpGlyphMetrics(glyphIndex, &gd, prface->GlyphDataArray[glyphIndex]);

        prface->NextFreeGlyphDataIndex ++;
    }

    if (pcjNeeded)
    {
        *pcjNeeded = cjNeeded;
    }


    ASSERT(prface->GlyphDataArray[glyphIndex])

    return Ok;
}




BOOL GpFaceRealization::InsertGlyphPath(
    UINT16          glyphIndex,
    BOOL            bFlushOk
) const
{

// Call font driver to get the metrics.

    GpGlyphPath  *fontPath;

    GLYPHDATA   gd;
    GpPath      path;

    ASSERT(IsPathFont());
    ASSERT(prface->GlyphDataArray[glyphIndex]);

    if (prface->GlyphDataArray[glyphIndex]->GlyphPath)
        return TRUE;

    ULONG cjNeeded = ttfdSemQueryFontData(
        &prface->fobj,
        prface->QueryFontDataMode,
        (HGLYPH)glyphIndex,
        &gd,
        (PVOID)&path
    );

    if ( cjNeeded == FD_ERROR )
        return FALSE;

    if (!path.IsValid())
        return FALSE;

    cjNeeded = sizeof(GpGlyphPath) +
               path.GetPointCount() * (sizeof(GpPointF) + sizeof(BYTE));
    cjNeeded = ALIGN(void*, cjNeeded);

    /* a GpGlyphPath* need to be aligned to the next valid pointer address */
    ALIGN(void*, prface->UsedBytesGlyphBitsBlockUnderConstruction);

    VOID *GlyphBits;

    while ((GlyphBits = (GLYPHBITS *)pgbCheckGlyphCache(cjNeeded)) == NULL)
    {
        if ( !bFlushOk )
            return FALSE;

        //TRACE_INSERT(("InsertGlyphBits: Flushing the cache\n"));

        FlushCache();
        bFlushOk = FALSE;
    }

    fontPath = (GpGlyphPath*)GlyphBits;

    if (fontPath->CopyPath(&path) != Ok)
        return FALSE;

    prface->GlyphDataArray[glyphIndex]->GlyphPath = fontPath;

    prface->UsedBytesGlyphBitsBlockUnderConstruction += cjNeeded;

    return TRUE;
}




BOOL GpFaceRealization::InsertGlyphBits(
    UINT16      glyphIndex,
    ULONG       cjNeeded,
    BOOL        bFlushOk
) const
{
    if (prface->NoCache)
    {
        return FALSE;
    }

    ASSERT(!IsPathFont());
    ASSERT(prface->GlyphDataArray[glyphIndex]);

    if (prface->GlyphDataArray[glyphIndex]->GlyphBits)
        return TRUE;

    // Look to see if there is room in the glyphbits cache
    // Grow the glyphbits cache if neccessary, but don't flush the cache

    GLYPHDATA gd;

    // If max glyph will fit, assume max glyph
    // otherwise, call up and ask how big

    if ( (prface->MaxGlyphByteCount < (SIZE_T)(prface->SizeGlyphBitsBlockUnderConstruction - prface->UsedBytesGlyphBitsBlockUnderConstruction))  )
    {
        cjNeeded = prface->MaxGlyphByteCount;
    }
    else
    {
        if (!cjNeeded)
        {
            cjNeeded = ttfdSemQueryFontData(
                &prface->fobj,
                prface->QueryFontDataMode,
                glyphIndex,
                &gd,
                NULL
            );

            if ( cjNeeded == FD_ERROR )
                return FALSE;

            if (prface->fobj.flFontType & FO_CLEARTYPE_GRID)
            {
                ULONG cx = (ULONG)(gd.rclInk.right  - gd.rclInk.left);
                ULONG cy = (ULONG)(gd.rclInk.bottom - gd.rclInk.top);
                ASSERT(cjNeeded <= CJ_CTGD(cx+2,cy));
                cjNeeded = CJ_CTGD(cx+2,cy);
            }
        }
    }

    // Now, we try to fit the bits in.  If they fit, fine.
    // If not, and we can flush the cache, we flush it and try again.
    // If we couldn't flush, or we flushed and still fail, just return.

    GLYPHBITS *GlyphBits;

    //TRACE_INSERT(("InsertGlyphBits: attempting to insert bits at: 0x%lx\n", prface->UsedBytesGlyphBitsBlockUnderConstruction));

    while ((GlyphBits = (GLYPHBITS *)pgbCheckGlyphCache(cjNeeded)) == NULL)
    {
        if ( !bFlushOk )
            return FALSE;

        //TRACE_INSERT(("InsertGlyphBits: Flushing the cache\n"));

        FlushCache();
        bFlushOk = FALSE;
    }

    // Call font driver to get glyph bits.

    cjNeeded = ttfdSemQueryFontData(
                         &prface->fobj,
                         prface->QueryFontDataMode,
                         glyphIndex,
                         &gd,
                         (VOID *)GlyphBits
                         );

    if ( cjNeeded == FD_ERROR )
            return FALSE;

    ASSERT(cjNeeded <= prface->MaxGlyphByteCount);
    if (prface->fobj.flFontType & FO_CLEARTYPE_GRID)
    {
        ULONG cx = (ULONG)(gd.rclInk.right  - gd.rclInk.left);
        ULONG cy = (ULONG)(gd.rclInk.bottom - gd.rclInk.top);

        ASSERT(cjNeeded <= CJ_CTGD(cx+2,cy));
        cjNeeded = CJ_CTGD(cx+2,cy);

        ASSERT(cjNeeded <= prface->MaxGlyphByteCount);

        if (GlyphBits)
        {
            cjNeeded = ulClearTypeFilter(GlyphBits, cjNeeded, prface);
        }
    }

    // Only the glyph bits we need.

    prface->GlyphDataArray[glyphIndex]->GlyphBits = GlyphBits;

    // Adjust the cache next pointers as needed.

    prface->UsedBytesGlyphBitsBlockUnderConstruction += cjNeeded;

    return TRUE;
}




////    GetGlyphDataLookaside
//
//      Returns glyph data for a single glyph, using the lookaside buffer
//      instead of the cache.



GpGlyphData *GpFaceRealization::GetGlyphDataLookaside(
    UINT16      glyphIndex
) const
{
    if (!IsPathFont())
    {
        // Make sure the lookaside buffer has enough room for the bitmap

        ULONG cjMaxBitmap = prface->MaxGlyphByteCount + sizeof(GpGlyphData);

        // Allocate the buffer and save its size if existing buffer isn't big enough

        if (prface->LookasideByteCount < cjMaxBitmap)
        {
            if (prface->LookasideGlyphData != NULL)
            {
                GpFree(prface->LookasideGlyphData);
            }

            prface->LookasideGlyphData = (GpGlyphData  *)GpMalloc(cjMaxBitmap);

            if (prface->LookasideGlyphData == NULL)
                return NULL;

            prface->LookasideByteCount = cjMaxBitmap;
        }

        GpGlyphData *pgd       = prface->LookasideGlyphData;
        GLYPHBITS   *glyphBits = (GLYPHBITS *)(pgd + 1);
        GLYPHDATA    gd;

        ULONG cjNeeded = ttfdSemQueryFontData(
            &prface->fobj,
            prface->QueryFontDataMode,
            glyphIndex,
            &gd,
            glyphBits
        );

        if (cjNeeded == FD_ERROR)
            return NULL;

        ASSERT(cjNeeded <= prface->MaxGlyphByteCount);

        if (prface->fobj.flFontType & FO_CLEARTYPE_GRID)
        {
            ULONG cx = (ULONG)(gd.rclInk.right  - gd.rclInk.left);
            ULONG cy = (ULONG)(gd.rclInk.bottom - gd.rclInk.top);

            ASSERT(cjNeeded <= CJ_CTGD(cx+2,cy));
            cjNeeded = CJ_CTGD(cx+2,cy);

            ASSERT(cjNeeded <= prface->MaxGlyphByteCount);

            if (glyphBits)
            {
                cjNeeded = ulClearTypeFilter(glyphBits, cjNeeded, prface);
            }
        }

        // Populate GpGlyphMetrics field of GpGlyphData from font driver GLYPHDATA

        ConvertGLYPHDATAToGpGlyphMetrics(glyphIndex, &gd, pgd);

        // Set the returned value

        pgd->GlyphBits = glyphBits;

        return pgd;
    }
    else
    {
        // For glyph path

        // Call font driver to get the metrics.

        GLYPHDATA   gd;
        GpPath      path;

        // Verify enough room in metrics cache area, grow if needed.
        // Note that failure to fit a glyphdata is a hard error, get out now.


        ULONG cjNeeded = ttfdSemQueryFontData(
                               &prface->fobj,
                               prface->QueryFontDataMode,
                               (HGLYPH)glyphIndex,
                               &gd,
                               (PVOID)&path
        );

        if ( cjNeeded == FD_ERROR )
            return NULL;

        if (!path.IsValid())
            return NULL;

        cjNeeded = sizeof(GpGlyphData) + sizeof(GpGlyphPath) + path.GetPointCount() * (sizeof(GpPointF) + sizeof(BYTE));
        cjNeeded = ALIGN(void*, cjNeeded);

        // Make sure the lookaside buffer is allocated

        if ( ( prface->LookasideByteCount < cjNeeded ) &&
             ( prface->LookasideGlyphData != NULL ))
        {
           GpFree((PVOID) prface->LookasideGlyphData);
           prface->LookasideGlyphData = NULL;
           prface->LookasideByteCount = 0;
        }

        if ( prface->LookasideGlyphData == NULL )
        {
            prface->LookasideGlyphData = (GpGlyphData *)GpMalloc(cjNeeded);

            if ( prface->LookasideGlyphData == NULL )
                return NULL;

            prface->LookasideByteCount = cjNeeded;
        }

        GpGlyphData *   pgd = prface->LookasideGlyphData;
        GpGlyphPath *   fontPath = (GpGlyphPath *)(pgd + 1);

        // Populate GpGlyphMetrics field of GpGlyphData from font driver GLYPHDATA
        ConvertGLYPHDATAToGpGlyphMetrics(glyphIndex, &gd, pgd);

        if (fontPath->CopyPath(&path) != Ok)
            return FALSE;

        // Set the returned value

        pgd->GlyphPath = fontPath;

        return pgd;
    }

}




BOOL GpFaceRealization::CheckMetricsCache() const
{

// Verify enough room in metrics cache area, grow if needed.

    if (prface->NextFreeGlyphDataIndex >= GLYPHDATABLOCKCOUNT)
    {
        GlyphDataBlock *NewGlyphDataBlock;

        // allocate a new block of GpGlyphData structs

        if ((NewGlyphDataBlock = (GlyphDataBlock *)GpMalloc(sizeof(GlyphDataBlock))) == NULL)
        {
            return FALSE;
        }
        NewGlyphDataBlock->NextGlyphDataBlock = NULL;

        prface->GlyphDataBlockUnderConstruction->NextGlyphDataBlock = NewGlyphDataBlock;

        prface->GlyphDataBlockUnderConstruction = NewGlyphDataBlock;
        prface->NextFreeGlyphDataIndex = 0;
    }

    return TRUE;
}


PVOID GpFaceRealization::pgbCheckGlyphCache(SIZE_T cjNeeded) const
{
    if ((prface->UsedBytesGlyphBitsBlockUnderConstruction + cjNeeded) > prface->SizeGlyphBitsBlockUnderConstruction)
    {
        ULONG cjBlockSize;


        ASSERT (!(prface->NoCache));

        if (IsPathFont())
        {
            // this seems to work and this is what we did before DavidFie changes
            // for PATHOBJ case

            cjBlockSize = CJMAX;
        }
        else
        {
            ULONG cjBytes = 16 * prface->MaxGlyphByteCount;

            cjBlockSize = ROUND_TO_PAGE(cjBytes);

            if (prface->FirstGlyphBitsBlock == NULL)
            {
                // first block designed to contain 16 glyphs

                cjBlockSize =  cjBytes;
            }
        }

        if (    !(prface->NoCache)
            &&  (prface->cBlocks < prface->cBlocksMax)
            &&  ((offsetof(GlyphBitsBlock,Bits) + cjNeeded) <= cjBlockSize))
        {
            // The only reason we need the last check is the PATHOBJ case
            // where cjNeeded may actually not fit in the block of SizeGlyphBitsBlock bytes.
            // This is because we have no way of knowing how big the paths
            // are going to be (especailly after doing bFlatten) and our
            // prface->MaxGlyphByteCount is just a good guess in this case.

            // We are going to append another block at the end of the list

            GlyphBitsBlock  *newGlyphBitsBlock = (GlyphBitsBlock *) GpMalloc(cjBlockSize);

            if (!newGlyphBitsBlock)
            {
                return NULL;
            }

            //  we have just allocated another block, update cBlocks:

            prface->cBlocks += 1;

            // append this block to the end of the list

            newGlyphBitsBlock->NextGlyphBitsBlock = NULL;

            if (prface->GlyphBitsBlockUnderConstruction != NULL)
                prface->GlyphBitsBlockUnderConstruction->NextGlyphBitsBlock = newGlyphBitsBlock;

            prface->GlyphBitsBlockUnderConstruction = newGlyphBitsBlock;

            if (!prface->FirstGlyphBitsBlock) // first block ever for this rfont
            {
                prface->FirstGlyphBitsBlock  = newGlyphBitsBlock;
            }
            prface->GlyphBitsBlockUnderConstruction->SizeGlyphBitsBlock = cjBlockSize;
            prface->SizeGlyphBitsBlockUnderConstruction = cjBlockSize;
            prface->UsedBytesGlyphBitsBlockUnderConstruction = offsetof(GlyphBitsBlock,Bits);
            ALIGN(void*, prface->UsedBytesGlyphBitsBlockUnderConstruction);


        }
        else
        {
            // tough luck, we are not allowed to add more blocks

            return NULL;
        }
    }

    return (BYTE *)prface->GlyphBitsBlockUnderConstruction + prface->UsedBytesGlyphBitsBlockUnderConstruction;
}


VOID GpFaceRealization::FlushCache() const
{

    // all the pointers to glyphs bits will be invalidated and we will start
    // filling the glyphbits cache all over again. Therefore, we set the current
    // block to be the same as base block and pgbN to the first available field in
    // in the Current block.
    // Note that vFlushCache is allways called after pgbCheckGlyphCache has failed.
    // pgbCheckGlyphCache could fail for one of the two following reasons:
    //
    // a) (pc->cBlocks == pc->cBlocksMax) && (no room in the last block)
    // b) (pc->cBlocks < pc->cBlocksMax) &&
    //    (failed to alloc mem for the new bitblock).
    //
    // In the latter case we do not want to flush glyphbits cache.
    // Instead we shall try to allocate one more time a bit later.


    if (prface->FirstGlyphBitsBlock && (prface->cBlocks == prface->cBlocksMax))
    {
        prface->GlyphBitsBlockUnderConstruction = prface->FirstGlyphBitsBlock;
        prface->UsedBytesGlyphBitsBlockUnderConstruction = offsetof(GlyphBitsBlock,Bits);
        ALIGN(void*, prface->UsedBytesGlyphBitsBlockUnderConstruction);

        // we do not want to use the last 8 bytes in the BITBLOCK. Some drivers
        // read the last dword (or quadword) past the end of the GLYPHBITS.
        // If there is a GLYPHBITS at the very and of the BITBLOCK AND the
        // allocation happens to be at the end of the page the read will AV.

        prface->SizeGlyphBitsBlockUnderConstruction = prface->GlyphBitsBlockUnderConstruction->SizeGlyphBitsBlock;
    }

        // now go and invalidate the glyphbit pointers in the glyphdata cache

    for
    (
        GlyphDataBlock *pdbl = prface->FirstGlyphDataBlock;
        pdbl != (GlyphDataBlock*)NULL;
        pdbl = pdbl->NextGlyphDataBlock
    )
    {
        UINT i;

        for (i = 0; i < GLYPHDATABLOCKCOUNT; i++)
        {
            pdbl->GlyphDataArray[i].GlyphBits = NULL;
        }
    }
}




////    CheckGlyphStringMetricsCached
//
//      Ensures that glyph metric information for all the glyphs in the
//      given glyph string are already cached.


GpStatus GpFaceRealization::CheckGlyphStringMetricsCached(
    const UINT16 *glyphs,
    INT           glyphCount
) const
{
    ASSERT(glyphCount >= 0);

    // Create glyph data array if none yet exists

    if (prface->GlyphDataArray == NULL)
    {
        if (!AllocateCache())
        {
            return OutOfMemory;
        }
    }

    GpGlyphData **glyphData = prface->GlyphDataArray;


    // Check each glyph

    INT glyphIndexLimit = prface->Face->NumGlyphs;

    INT i=0;

    while (i < glyphCount)
    {
        // Loop quickly through glyphs that are already cached

        while (    i < glyphCount
               &&  (    glyphs[i] == EMPTY_GLYPH_FFFF
                    ||  (    glyphs[i] < glyphIndexLimit
                         &&  glyphData[glyphs[i]] != NULL)))
        {
            i++;
        }

        // Use IsMetricsCached for glyphs not already cached

        if (i < glyphCount)
        {
            GpStatus status = IsMetricsCached(glyphs[i], NULL);
            if (status != Ok)
            {
                return status;
            }
        }
    }

    return Ok;
}




////    GetGlyphStringIdealAdvanceVector
//
//      Returns the realized advance vector scaled to ideal units.


GpStatus GpFaceRealization::GetGlyphStringIdealAdvanceVector(
    const UINT16  *glyphs,
    INT            glyphCount,
    REAL           deviceToIdeal,
    BOOL           vertical,
    INT           *idealAdvances
) const
{
    GpStatus status = CheckGlyphStringMetricsCached(glyphs, glyphCount);
    IF_NOT_OK_WARN_AND_RETURN(status);

    vertical = vertical ? 1 : 0;    // Prepare vertical flag for use as index

    // Provide advance width for each glyph

    for (INT i=0; i<glyphCount; i++)
    {
        if (glyphs[i] == EMPTY_GLYPH_FFFF)
        {
            idealAdvances[i] = 0;
        }
        else
        {
            idealAdvances[i] = GpRound(
                  prface->GlyphDataArray[glyphs[i]]->GlyphMetrics[vertical].AdvanceWidth
                * deviceToIdeal
                / 16
            );
        }
    }

    return Ok;
}




////    GetGlyphStringDeviceAdvanceVector
//
//      Returns the realized advance vector in device units


GpStatus GpFaceRealization::GetGlyphStringDeviceAdvanceVector(
    const UINT16  *glyphs,
    INT            glyphCount,
    BOOL           vertical,
    REAL          *deviceAdvances
) const
{
    GpStatus status = CheckGlyphStringMetricsCached(glyphs, glyphCount);
    IF_NOT_OK_WARN_AND_RETURN(status);

    vertical = vertical ? 1 : 0;    // Prepare vertical flag for use as index

    // Provide advance width for each glyph

    for (INT i=0; i<glyphCount; i++)
    {
        if (glyphs[i] == EMPTY_GLYPH_FFFF)
        {
            deviceAdvances[i] = 0;
        }
        else
        {
            deviceAdvances[i] = TOREAL(prface->GlyphDataArray[glyphs[i]]->GlyphMetrics[vertical].AdvanceWidth) / 16;
        }
    }

    return Ok;
}


// INT 28.4 variant

GpStatus GpFaceRealization::GetGlyphStringDeviceAdvanceVector(
    const UINT16  *glyphs,
    INT            glyphCount,
    BOOL           vertical,
    INT           *deviceAdvances
) const
{
    GpStatus status = CheckGlyphStringMetricsCached(glyphs, glyphCount);
    IF_NOT_OK_WARN_AND_RETURN(status);

    GpGlyphData **glyphDataArray = prface->GlyphDataArray;

    vertical = vertical ? 1 : 0;    // Prepare vertical flag for use as index

    // Provide advance width for each glyph

    for (INT i=0; i<glyphCount; i++)
    {
        if (glyphs[i] == EMPTY_GLYPH_FFFF)
        {
            deviceAdvances[i] = 0;
        }
        else
        {
            deviceAdvances[i] = glyphDataArray[glyphs[i]]
                                ->GlyphMetrics[vertical]
                                .AdvanceWidth;
        }
    }

    return Ok;
}





GpStatus GpFaceRealization::GetGlyphStringVerticalOriginOffsets(
    const UINT16  *glyphs,
    INT            glyphCount,
    PointF        *offsets
) const
{

    GpStatus status = CheckGlyphStringMetricsCached(glyphs, glyphCount);
    IF_NOT_OK_WARN_AND_RETURN(status);

    GpGlyphData **glyphDataArray = prface->GlyphDataArray;

    for (INT i=0; i<glyphCount; i++)
    {
        if (glyphs[i] == EMPTY_GLYPH_FFFF)
        {
            offsets[i] = PointF(0,0);
        }
        else
        {
            offsets[i] = glyphDataArray[glyphs[i]]->GlyphMetrics[1].Origin;
        }
    }

    return Ok;
}




////    GetGlyphStringSidebearings
//
//      Sidebearings - the sidebearings returned are the largest distances
//      over the ends of the string. i.e. if the first glyph has no negative A
//      width, but the second glyph has a negative A width large enough to reach
//      back over the whole of the first glyph, we return that part of the 2nd
//      glyphs A width that overhangs the left end of the line.
//      This situation is common with scripts that make extensive use of
//      combining characters.


GpStatus GpFaceRealization::GetGlyphStringSidebearings(
    const UINT16  *glyphs,
    INT            glyphCount,
    BOOL           vertical,
    BOOL           reverse,     // For example right-to-left
    INT           *leadingSidebearing,  // 28.4
    INT           *trailingSidebearing  // 28.4
) const
{
    GpStatus status = CheckGlyphStringMetricsCached(glyphs, glyphCount);

    IF_NOT_OK_WARN_AND_RETURN(status);

    GpGlyphData **glyphDataArray = prface->GlyphDataArray;

    INT orientation = vertical ? 1 : 0;    // Prepare vertical flag for use as index

    INT maxSupportedSidebearing28p4 = (prface->DeviceMetrics.yMax-prface->DeviceMetrics.yMin) * 2 * 16;

    if (leadingSidebearing)
    {
        // Determine largest overhang to left of string of any glyph
        // in the string.
        //
        // We assume that no overhang exceeds approx 2 ems.
        //
        // NOTE: If you make a change to for leadingsizdebeating, also fix
        // trailingsidebearing below.

        INT offset28p4      = 0;
        INT sidebearing28p4 = maxSupportedSidebearing28p4;

        INT i = 0;

        while (    i < glyphCount
               &&  offset28p4 < maxSupportedSidebearing28p4)
        {
            INT glyphSidebearing28p4;

            if (reverse)
            {
                glyphSidebearing28p4 = glyphDataArray[glyphs[i]]
                                       ->GlyphMetrics[orientation]
                                       .TrailingSidebearing;
            }
            else
            {
                glyphSidebearing28p4 = glyphDataArray[glyphs[i]]
                                       ->GlyphMetrics[orientation]
                                       .LeadingSidebearing;
            }


            if (glyphSidebearing28p4 + offset28p4 < sidebearing28p4)
            {
                sidebearing28p4 = glyphSidebearing28p4+offset28p4;
            }

            offset28p4 += glyphDataArray[glyphs[i]]
                          ->GlyphMetrics[orientation]
                          .AdvanceWidth;
            i++;
        }

        *leadingSidebearing = sidebearing28p4;
    }


    if (trailingSidebearing)
    {
        INT offset28p4 = 0;
        INT sidebearing28p4 = maxSupportedSidebearing28p4;

        INT i = glyphCount-1;

        while (    i >= 0
               &&  offset28p4 < maxSupportedSidebearing28p4)
        {
            INT glyphSidebearing28p4;

            if (reverse)
            {
                glyphSidebearing28p4 = glyphDataArray[glyphs[i]]
                                       ->GlyphMetrics[orientation]
                                       .LeadingSidebearing;
            }
            else
            {
                glyphSidebearing28p4 = glyphDataArray[glyphs[i]]
                                       ->GlyphMetrics[orientation]
                                       .TrailingSidebearing;
            }

            if (glyphSidebearing28p4 + offset28p4 < sidebearing28p4)
            {
                sidebearing28p4 = glyphSidebearing28p4+offset28p4;
            }

            offset28p4 += glyphDataArray[glyphs[i]]
                          ->GlyphMetrics[orientation]
                          .AdvanceWidth;
            i--;
        }

        *trailingSidebearing = sidebearing28p4;
    }

    return Ok;
}




GpStatus
GpFaceRealization::GetGlyphPath(
    const UINT16     glyphIndice,
    GpGlyphPath    **pFontPath,
    PointF          *sidewaysOffset
) const
{
    VOID *glyphBuffer, *glyphBits;
    GpStatus status;

    if ((status = IsMetricsCached(glyphIndice, NULL)) != Ok)
    {
        return status;
    }

    if (!InsertGlyphPath(glyphIndice, TRUE))
        return GenericError;

    *pFontPath = prface->GlyphDataArray[glyphIndice]->GlyphPath;

    if (sidewaysOffset)
    {
        // Return sideways offset as REAL
        *sidewaysOffset = prface->GlyphDataArray[glyphIndice]->GlyphMetrics[1].Origin;
    }

    return Ok;
}




INT GpFaceRealization::GetGlyphPos(
    const INT      cGlyphs,      // How many glyphs Client want to request
    const UINT16  *glyphs,       // An array of glyph index
    GpGlyphPos    *pgpos,        // An array of GLYPHPOS
    const PointF  *glyphOrigins, // X,Y positions for sub-pixel calculation
    INT           *cParsed,      // How many glyphs we parsed
    BOOL           sideways      // e.g. FE characters in vertical text
) const
{
    INT  cgpos    = 0;
    BOOL noCache  = prface->NoCache;
    BOOL pathFont = IsPathFont();

    *cParsed  = 0;

    INT glyphLimit = noCache ? 1 : cGlyphs;

    if (prface->CacheType == CacheAABits)
    {
        /* we could be in noCache mode with a surrogate sequence, doing one glyph at a time
           and with glyphs[0] == EMPTY_GLYPH_FFFF */
        for (INT i=0; (i < cGlyphs) && (cgpos < glyphLimit); i++)
        {
            if (glyphs[i] != EMPTY_GLYPH_FFFF)
            {
                INT x = GpRound(TOREAL(glyphOrigins[i].X * 16.0));
                INT y = GpRound(TOREAL(glyphOrigins[i].Y * 16.0));

                if (!GetAAGlyphDataCached(glyphs[i], pgpos+cgpos, i==0, x, y, sideways))
                {
                    break;
                }
                cgpos++;
            }
            (*cParsed)++;
        }
    }
    else
    {
        ASSERT(prface->realizationMethod != TextRenderingHintAntiAlias);

       /* we could be in noCache mode with a surrogate sequence, doing one glyph at a time
           and with glyphs[0] == EMPTY_GLYPH_FFFF */
        for (INT i=0; (i < cGlyphs) && (cgpos < glyphLimit); i++)
        {
            if (glyphs[i] != EMPTY_GLYPH_FFFF)
            {
                INT x = GpRound(TOREAL(glyphOrigins[i].X * 16.0));
                INT y = GpRound(TOREAL(glyphOrigins[i].Y * 16.0));

                GpGlyphData *pgd = NULL;

                if (noCache)
                {
                    pgd = GetGlyphDataLookaside(glyphs[i]);
                }
                else
                {
                    pgd = GetGlyphDataCached(glyphs[i], i==0);
                }

                if (!pgd || !pgd->GlyphBits)
                {
                    // No more glyph data available. (Cache may be full)
                    break;
                }

                if (pathFont)
                {
                    INT left = (x+8) >> 4;
                    INT top  = (y+8) >> 4;

                    if (sideways)
                    {
                        left -= GpRound(pgd->GlyphMetrics[1].Origin.X);
                        top  -= GpRound(pgd->GlyphMetrics[1].Origin.Y);
                    }

                    pgpos[cgpos].SetLeft  (left);
                    pgpos[cgpos].SetTop   (top);
                    pgpos[cgpos].SetWidth (1);
                    pgpos[cgpos].SetHeight(1);
                    pgpos[cgpos].SetPath(pgd->GlyphPath);
                }
                else
                {
                    if (sideways)
                    {
                        pgpos[cgpos].SetLeft(pgd->GlyphBits->ptlSidewaysOrigin.x + ((x + 8)>>4));
                        pgpos[cgpos].SetTop (pgd->GlyphBits->ptlSidewaysOrigin.y + ((y + 8)>>4));
                    }
                    else
                    {
                        pgpos[cgpos].SetLeft(pgd->GlyphBits->ptlUprightOrigin.x + ((x + 8)>>4));
                        pgpos[cgpos].SetTop (pgd->GlyphBits->ptlUprightOrigin.y + ((y + 8)>>4));
                    }

                    pgpos[cgpos].SetWidth (pgd->GlyphBits->sizlBitmap.cx);
                    pgpos[cgpos].SetHeight(pgd->GlyphBits->sizlBitmap.cy);
                    pgpos[cgpos].SetBits(pgd->GlyphBits->aj);
                }

                cgpos++;
            }

            (*cParsed)++;
        }
    }

    return cgpos;
}


// Serch the glyph data from cache array.

GpGlyphData *
GpFaceRealization::GetGlyphDataCached(
    UINT16  glyphIndex,
    BOOL    allowFlush
) const
{
    VOID *glyphBuffer, *glyphBits;
    ULONG   cjNeeded = 0;

    GpStatus status;

    if ((status = IsMetricsCached(glyphIndex, &cjNeeded)) != Ok)
    {
        return NULL;
    }

    if (IsPathFont())
    {
        if (!InsertGlyphPath(glyphIndex, allowFlush))
            return NULL;
    }
    else
    {
        if (!InsertGlyphBits(glyphIndex, cjNeeded, allowFlush))
            return NULL;
    }

    ASSERT(prface->GlyphDataArray[glyphIndex]);

    if (!prface->GlyphDataArray[glyphIndex])
        return NULL;

    return prface->GlyphDataArray[glyphIndex];
}





BOOL
GpFaceRealization::GetAAGlyphDataCached(
    UINT16  glyphIndex,
    GpGlyphPos * pgpos,
    BOOL    bFlushOk,
    INT     x,
    INT     y,
    BOOL    sideways        // e.g. FE characters in vertical text
) const
{
    const GpFaceRealization * pfaceRealization = this;

    UINT xsubPos = ((UINT) (((x+1) & 0x0000000F) >> 1));
    // we need to be carefull that y axis is downwards
    UINT ysubPos = ((UINT) (7 - (((y+1) & 0x0000000F) >> 1)));

    // limit the subpixel position to 1/4 of a pixel to have only a maximum of 16 different bitmaps to cache
    xsubPos = xsubPos & 0x6;
    ysubPos = ysubPos & 0x6;

    if (LimitSubpixel)
    {
        // Now limit the subpixel position further so that large font sizes do
        // not generate all 16 subpixel glyphs!

        if ((prface->DeviceMetrics.yMax-prface->DeviceMetrics.yMin) > 50)
        {
            // Force to 4 possible values...
            xsubPos &= 0x4;
            ysubPos &= 0x4;

            if ((prface->DeviceMetrics.yMax-prface->DeviceMetrics.yMin) > 100)
            {
                // Force to 1 possible value...
                xsubPos = 0x4;
                ysubPos = 0x4;
            }
        }
    }

    ASSERT(!pfaceRealization->IsPathFont())

    // Look to see if there is room in the glyphbits cache
    // Grow the glyphbits cache if neccessary, but don't flush the cache

    ULONG   subPosX;
    if (xsubPos <= 7)
        subPosX = xsubPos << 13;
    else
        subPosX = 0;

    ULONG   subPosY;
    if (ysubPos)
        subPosY = ysubPos << 13;
    else
        subPosY = 0;

    // If max glyph will fit, assume max glyph
    // otherwise, call up and ask how big

    ASSERT (pfaceRealization->QueryFontDataMode() == QFD_TT_GRAY4_BITMAP ||
            pfaceRealization->QueryFontDataMode() == QFD_GLYPHANDBITMAP_SUBPIXEL);

    if (IsMetricsCached(glyphIndex, 0) != Ok)
        return FALSE;

    GpGlyphData * glyphData = prface->GlyphDataArray[glyphIndex];
    ASSERT(glyphData);

    // check if we already have a bitmap for this subposition
    for (GpGlyphAABits * cur = glyphData->GlyphAABits; cur != 0; cur = cur->Next)
    {
        if (cur->X == subPosX && cur->Y == subPosY)
            break;
    }

    GLYPHBITS * pgb = 0;
    if (cur)
        pgb = reinterpret_cast<GLYPHBITS *>(&cur->Bits);
    else
    {
        ULONG cjNeeded = ttfdSemQueryFontDataSubPos(
                                       &prface->fobj,
                                       prface->QueryFontDataMode,
                                       glyphIndex,
                                       0,
                                       NULL,
                                       subPosX,
                                       subPosY
                                       );
        if (cjNeeded == FD_ERROR)
            return FALSE;

        ASSERT(cjNeeded != 0);

        cjNeeded += offsetof(GpGlyphAABits, Bits);


        if (prface->NoCache)
        {
            if (prface->LookasideByteCount < cjNeeded)
            {
                GpFree(prface->LookasideGlyphData);

                prface->LookasideGlyphData = (GpGlyphData  *)GpMalloc(cjNeeded);

                if (!prface->LookasideGlyphData)
                    return FALSE;

                prface->LookasideByteCount = cjNeeded;
            }

            cur = reinterpret_cast<GpGlyphAABits *>(prface->LookasideGlyphData);
        }
        else
        {
            // Now, we try to fit the bits in.  If they fit, fine.
            // If not, and we can flush the cache, we flush it and try again.
            // If we couldn't flush, or we flushed and still fail, just return.

            cjNeeded = ALIGN(void*, cjNeeded);

            // a GpGlyphAABits * needs to be aligned to the next valid pointer address
            ALIGN(void*, prface->UsedBytesGlyphBitsBlockUnderConstruction);

            while ((cur = (GpGlyphAABits *)pgbCheckGlyphCache(cjNeeded)) == NULL)
            {
                if ( !bFlushOk )
                    return FALSE;

                FlushCache();
                bFlushOk = FALSE;
            }
            prface->UsedBytesGlyphBitsBlockUnderConstruction += cjNeeded;
        }

        pgb = reinterpret_cast<GLYPHBITS *>(&cur->Bits);

        cjNeeded = ttfdSemQueryFontDataSubPos(
                             pfaceRealization->pfo(),
                             pfaceRealization->QueryFontDataMode(),
                             glyphIndex,
                             0,
                             pgb,
                             subPosX,
                             subPosY
                             );
        if (cjNeeded == FD_ERROR)
            return FALSE;

        cur->X = subPosX;
        cur->Y = subPosY;
        if (!prface->NoCache)
            cur->Next = glyphData->GlyphAABits, glyphData->GlyphAABits = cur;
    }

    // the pixel origin is computed by rouding the real origin minus the subpixel position
    // to get to the placement of the origin of the bitmap, we add to that origin
    // we cast (xsubPos << 1) and (ysubPos << 1) to INT to avoid
    // converting possibly negative x and y to UINTs
    if (sideways)
    {
        pgpos->SetLeft  (pgb->ptlSidewaysOrigin.x + ((x - (INT)(xsubPos << 1) + 8 ) >> 4));
        // we need to be careful that the y axis go downwards
        pgpos->SetTop   (pgb->ptlSidewaysOrigin.y + ((y + (INT)(ysubPos << 1) + 8) >> 4));
    }
    else
    {
        pgpos->SetLeft  (pgb->ptlUprightOrigin.x + ((x - (INT)(xsubPos << 1) + 8 ) >> 4));
        // we need to be careful that the y axis go downwards
        pgpos->SetTop   (pgb->ptlUprightOrigin.y + ((y + (INT)(ysubPos << 1) + 8) >> 4));
    }
    pgpos->SetWidth (pgb->sizlBitmap.cx);
    pgpos->SetHeight(pgb->sizlBitmap.cy);
    pgpos->SetBits(pgb->aj);

    return TRUE;

} // GpFaceRealization::GetAAGlyphDataCached




GpCacheFaceRealizationList::~GpCacheFaceRealizationList()
{
    // elements in that list get released when the font table get released
    ASSERT(count == 0);
}




void GpCacheFaceRealizationList::AddMostRecent(CacheFaceRealization *prface)
{
    count ++;

    if (head != NULL)
    {
        prface->NextRecentCacheFaceRealization = head;

        prface->PreviousRecentCacheFaceRealization = head->PreviousRecentCacheFaceRealization;

        prface->PreviousRecentCacheFaceRealization->NextRecentCacheFaceRealization = prface;

        head->PreviousRecentCacheFaceRealization = prface;
    }
    else
    {
        prface->NextRecentCacheFaceRealization = prface;
        prface->PreviousRecentCacheFaceRealization = prface;
    }

    head = prface;
}




void GpCacheFaceRealizationList::RemoveFace(CacheFaceRealization *prface)
{
    if ((prface->PreviousRecentCacheFaceRealization != NULL) && (prface->NextRecentCacheFaceRealization != NULL))
    {
        if (prface->PreviousRecentCacheFaceRealization == prface)
        {
            head = NULL;
        }
        else
        {
            prface->PreviousRecentCacheFaceRealization->NextRecentCacheFaceRealization = prface->NextRecentCacheFaceRealization;
            prface->NextRecentCacheFaceRealization->PreviousRecentCacheFaceRealization = prface->PreviousRecentCacheFaceRealization;
            if (head == prface)
            {
                head = prface->NextRecentCacheFaceRealization;
            }
        }

        prface->PreviousRecentCacheFaceRealization = NULL;
        prface->NextRecentCacheFaceRealization = NULL;
        count --;
        ASSERT(count >= 0);
    }
}


CacheFaceRealization *GpCacheFaceRealizationList::ReuseLeastRecent (void)
{
    CacheFaceRealization *prface = NULL;
    CacheFaceRealization *prfaceList;
    if (head != NULL)
    {
        prface = head->PreviousRecentCacheFaceRealization;
    }

    ASSERT(prface);

    // remove prface from GpCacheFaceRealizationList

    if (head == prface)
    {
        ASSERT(count == 1);
        head = NULL;
    }
    else
    {
        prface->PreviousRecentCacheFaceRealization->NextRecentCacheFaceRealization = head;
        head->PreviousRecentCacheFaceRealization = prface->PreviousRecentCacheFaceRealization;
    }

    count--;

    if (prface != NULL)
    {
        GpFaceRealizationTMP rface(prface);
        rface.ReuseRealizedFace();

        // remove the face from the face list

        prfaceList = prface->Face->pff->prfaceList;
        ASSERT(prfaceList);

        if ((prfaceList == prface) && (prfaceList->NextCacheFaceRealization == prface))
        {
            // there is only oine face in the faceList for that font face
            prface->Face->pff->prfaceList = NULL;

        } else
        {
            if (prfaceList == prface)
            {
                // set the beginning of the list to the next one
                prface->Face->pff->prfaceList = prfaceList->NextCacheFaceRealization;
            }

            // update the pointers in the faceList

            prface->PreviousCacheFaceRealization->NextCacheFaceRealization = prface->NextCacheFaceRealization;
            prface->NextCacheFaceRealization->PreviousCacheFaceRealization = prface->PreviousCacheFaceRealization;
        }

    }

    return prface;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\endcap.hpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   End Cap Creator.
*
* Abstract:
*
*   This module defines a class called GpEndCapCreator. This class is 
*   responsible for constructing a path containing all the custom endcaps
*   and anchor endcaps for a given path. These are correctly transformed
*   and positioned.
*
*   This class is used to create and position all the endcaps for a
*   given path and pen. This class is also responsible for trimming
*   the original path down so that it fits the end caps properly.
*   This class will handle all types of end caps except the base endcaps
*   (round, flat and triangle) which may be used as dash caps.
*   Caps that are handled are CustomCaps and the 3 Anchor caps (round,
*   diamond and arrow). Note that the round anchor cap is distinct from
*   the round base cap.
*
* Created:
*
*   10/09/2000 asecchia
*      Created it.
*
**************************************************************************/
#ifndef _ENDCAP_HPP
#define _ENDCAP_HPP
class GpEndCapCreator
{
public:
    
    GpEndCapCreator(
        GpPath *path, 
        DpPen *pen, 
        const GpMatrix *m,
        REAL dpi_x, 
        REAL dpi_y,
        bool antialias
    );
    
    ~GpEndCapCreator();
    
    GpStatus CreateCapPath(GpPath **caps);
    
    static bool PenNeedsEndCapCreator(const DpPen *pen);
    
protected:
    
    GpStatus GetCapsForSubpath(
        GpPath **startCapPath,
        GpPath **endCapPath,
        GpPointF *centerPoints,
        BYTE *centerTypes,
        INT centerCount
    );
    
    GpStatus SetCustomStrokeCaps(
        GpCustomLineCap* customStartCap,
        GpCustomLineCap* customEndCap,
        const GpPointF& startPoint,
        const GpPointF& endPoint,
        const GpPointF *centerPoints,
        const BYTE *centerTypes,
        INT centerPointCount,
        DynPointFArray *startCapPoints,
        DynPointFArray *endCapPoints,
        DynByteArray *startCapTypes,
        DynByteArray *endCapTypes
    );
    
    GpStatus SetCustomFillCaps(
        GpCustomLineCap* customStartCap,
        GpCustomLineCap* customEndCap,
        const GpPointF& startPoint,
        const GpPointF& endPoint,
        const GpPointF *centerPoints,
        const BYTE *centerTypes,
        INT centerPointCount,
        DynPointFArray *startCapPoints,
        DynPointFArray *endCapPoints,
        DynByteArray *startCapTypes,
        DynByteArray *endCapTypes
    );
    
    void ComputeCapGradient(
        GpIterator<GpPointF> &pointIterator, 
        BYTE *types,
        IN  REAL lengthSquared,
        IN  REAL baseInset,
        OUT GpVector2D *grad
    );
    
    VOID PrepareDpPenForCustomCap(
        DpPen* pen,
        const GpCustomLineCap* customCap
    ) const;

    static GpCustomLineCap *ReferenceArrowAnchor();
    static GpCustomLineCap *ReferenceDiamondAnchor();
    static GpCustomLineCap *ReferenceRoundAnchor();
    static GpCustomLineCap *ReferenceSquareAnchor();

    // Data member variables.

    GpPath *Path;
    DpPen *Pen;
    GpMatrix XForm;
    bool Antialias;
    
    GpCustomLineCap *StartCap;
    GpCustomLineCap *EndCap;
    
    // Note that the widener doesn't use these, so we should actually remove
    // this and the parameters to the widener.
    
    REAL DpiX, DpiY;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\endcap.cpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   End Cap Creator.
*
* Abstract:
*
*   This module defines a class called GpEndCapCreator. This class is 
*   responsible for constructing a path containing all the custom endcaps
*   and anchor endcaps for a given path. These are correctly transformed
*   and positioned.
*
*   This class is used to create and position all the endcaps for a
*   given path and pen. This class is also responsible for trimming
*   the original path down so that it fits the end caps properly.
*   This class will handle all types of end caps except the base endcaps
*   (round, flat and triangle) which may be used as dash caps.
*   Caps that are handled are CustomCaps and the 3 Anchor caps (round,
*   diamond and arrow). Note that the round anchor cap is distinct from
*   the round base cap.
*
* Created:
*
*   10/09/2000 asecchia
*      Created it.
*
**************************************************************************/
#include "precomp.hpp"

//-------------------------------------------------------------
// GetMajorAndMinorAxis() is defined in PathWidener.cpp.
//-------------------------------------------------------------

extern GpStatus
GetMajorAndMinorAxis(
    REAL* majorR,
    REAL* minorR,
    const GpMatrix* matrix
    );

GpEndCapCreator::GpEndCapCreator(
    GpPath *path, 
    DpPen *pen, 
    const GpMatrix *m,
    REAL dpi_x, 
    REAL dpi_y,
    bool antialias
)
{
    Path = path;
    Pen = pen;
    if(m) {XForm = *m;}
    XForm.Prepend(pen->Xform);
    DpiX = dpi_x;
    DpiY = dpi_y;
    Antialias = antialias;
    
    StartCap = NULL;
    EndCap = NULL;
    
    switch(Pen->StartCap)
    {
        case LineCapCustom:
        StartCap = static_cast<GpCustomLineCap*>(Pen->CustomStartCap);
        break;
        
        case LineCapArrowAnchor:
        StartCap = GpEndCapCreator::ReferenceArrowAnchor();
        break;
        
        case LineCapDiamondAnchor:
        StartCap = GpEndCapCreator::ReferenceDiamondAnchor();
        break;
        
        case LineCapRoundAnchor:
        StartCap = GpEndCapCreator::ReferenceRoundAnchor();
        break;
        
        case LineCapSquareAnchor:
        StartCap = GpEndCapCreator::ReferenceSquareAnchor();
        break;
        
        // The non-anchor caps are handled by the widener.
    };
    
    switch(Pen->EndCap)
    {
        case LineCapCustom:
        EndCap = static_cast<GpCustomLineCap*>(Pen->CustomEndCap);
        break;
        
        case LineCapArrowAnchor:
        EndCap = GpEndCapCreator::ReferenceArrowAnchor();
        break;
        
        case LineCapDiamondAnchor:
        EndCap = GpEndCapCreator::ReferenceDiamondAnchor();
        break;
        
        case LineCapRoundAnchor:
        EndCap = GpEndCapCreator::ReferenceRoundAnchor();
        break;

        case LineCapSquareAnchor:
        EndCap = GpEndCapCreator::ReferenceSquareAnchor();
        break;
        
        // The non-anchor caps are handled by the widener.
    };

    // If we're flipped in the X or Y direction (but not both), 
    // reverse the fill and stroke paths so that the winding 
    // mode will be correct.
    if (pen->Xform.GetDeterminant() < 0)
    {
        if (StartCap)
        {
            StartCap->ReverseFillPath();
            StartCap->ReverseStrokePath();
        }
        if (EndCap)
        {
            EndCap->ReverseFillPath();
            EndCap->ReverseStrokePath();
        }
    }

}


/**************************************************************************\
*
* Function Description:
*
*   This function will return true if the GpEndCapCreator is required for
*   the given pen. If the pen only has simple endcaps, then the 
*   GpEndCapCreator can skipped.
*
*   The GpEndCapCreator is used for creating Anchor and/or Custom caps.
*   LineCap- Flat, Round, Square and Triangle are handled directly by the
*   widener.
*
* Revision History:
*
*   11/10/2000 asecchia
*       Created it
*
\**************************************************************************/

bool GpEndCapCreator::PenNeedsEndCapCreator(const DpPen *pen)
{
    return (
        (pen->StartCap == LineCapCustom) ||
        (pen->EndCap == LineCapCustom) ||
        ((pen->StartCap & LineCapAnchorMask) != 0) ||
        ((pen->EndCap & LineCapAnchorMask) != 0)
    );
}


GpEndCapCreator::~GpEndCapCreator()
{
    // If we allocated memory for temporary custom caps, then 
    // throw that memory away.
    
    if(Pen->StartCap != LineCapCustom)
    {
        delete StartCap;
        StartCap = NULL;
    }
    
    if(Pen->EndCap != LineCapCustom)
    {
        delete EndCap;
        EndCap = NULL;
    }
}
    
/**************************************************************************\
*
* Function Description:
*
*    Creates a reference GpCustomLineCap representing an ArrowAnchor.
*    This is an equilateral triangle with edge equal to 2. This means
*    that the scaling will create a 2xStrokeWidth cap edge length.
*
* Revision History:
*
*   10/08/2000 asecchia
*       Created it
*
\**************************************************************************/

GpCustomLineCap *GpEndCapCreator::ReferenceArrowAnchor()
{
    // the square root of 3
    
    const REAL root3 = 1.732050808f;
    
    // Anti-clockwise definition of an equilateral triangle of side length 2.0f
    // with a vertex on the origin and axis extending along the negative
    // y axis.
     
    const GpPointF points[3] = {
        GpPointF(0.0f, 0.0f),
        GpPointF(-1.0f, -root3),
        GpPointF(1.0f, -root3)
    };
    
    GpPath arrowAnchor(FillModeWinding);
    arrowAnchor.AddPolygon(points, 3);
    
    // Create the custom line cap. If it fails it will return NULL.
    GpCustomLineCap *cap = new GpCustomLineCap(&arrowAnchor, NULL);
    if(cap)
    {
        cap->SetBaseInset(1.0f);
    }
    return cap;
}

/**************************************************************************\
*
* Function Description:
*
*    Creates a reference GpCustomLineCap representing a DiamondAnchor.
*    This is a square centered on the end point of the path with it's 
*    diagonal along the axis of the spine.
*
* Revision History:
*
*   10/08/2000 asecchia
*       Created it
*
\**************************************************************************/

GpCustomLineCap *GpEndCapCreator::ReferenceDiamondAnchor()
{
    // Anti-clockwise definition of a square of diagonal size 2.0f
    // with the center on the origin and axis extending along the negative
    // y axis.
     
    const GpPointF points[4] = {
        GpPointF(0.0f, 1.0f),
        GpPointF(-1.0f, 0.0f),
        GpPointF(0.0f, -1.0f),
        GpPointF(1.0f, 0.0f)
    };
    
    GpPath diamondAnchor(FillModeWinding);
    diamondAnchor.AddPolygon(points, 4);
    
    // Create the custom line cap. If it fails it will return NULL.
    
    GpCustomLineCap *cap = new GpCustomLineCap(&diamondAnchor, NULL);
    if(cap)
    {
        cap->SetBaseInset(0.0f);
    }
    return cap;
}

/**************************************************************************\
*
* Function Description:
*
*    Creates a reference GpCustomLineCap representing a SquareAnchor.
*    This is a square that has a 2 unit long diagonal and is centered on 
*    the end point of the path.
*
* Revision History:
*
*   10/17/2000 peterost
*       Created it
*
\**************************************************************************/

GpCustomLineCap *GpEndCapCreator::ReferenceSquareAnchor()
{    
    const REAL halfRoot2 = 0.7071068f;
    
    const GpPointF points[4] = {
        GpPointF(-halfRoot2, -halfRoot2),
        GpPointF(halfRoot2, -halfRoot2),
        GpPointF(halfRoot2, halfRoot2),
        GpPointF(-halfRoot2, halfRoot2)
    };
    
    GpPath squareAnchor(FillModeWinding);
    squareAnchor.AddPolygon(points, 4);
    
    // Create the custom line cap. If it fails it will return NULL.
    
    GpCustomLineCap *cap = new GpCustomLineCap(&squareAnchor, NULL);
    if(cap)
    {
        cap->SetBaseInset(0.0f);
    }
    return cap;
}

/**************************************************************************\
*
* Function Description:
*
*    Creates a reference GpCustomLineCap representing a RoundAnchor.
*    This is a circle centered on the end point of the path.
*
* Revision History:
*
*   10/08/2000 asecchia
*       Created it
*
\**************************************************************************/

GpCustomLineCap *GpEndCapCreator::ReferenceRoundAnchor()
{
    // Create the custom line cap. If it fails it will return NULL.
    
    GpPath roundAnchor(FillModeWinding);
    roundAnchor.AddEllipse(-1.0f, -1.0f, 2.0f, 2.0f);
    GpCustomLineCap *cap = new GpCustomLineCap(&roundAnchor, NULL);
    if(cap)
    {
        cap->SetBaseInset(0.0f);
    }
    return cap;
}


/**************************************************************************\
*
* Function Description:
*
*   ComputeCapGradient.
*
*   Compute the correct gradient for a line cap of a given length.
*   Work out the direction of the cap from the list of input 
*   points in the path and the length of the cap.
*   Simply put, the direction is the line segment formed by 
*   the end point of the path and the first intersection along the 
*   path with a circle of length "length" and centered at the 
*   first point of the path.
*
* Arguments:
*
*    GpIterator<GpPointF> &pointIterator,
*    BYTE *types,
*    IN  REAL lengthSquared,            length of the cap squared.
*    IN  baseInset,                     amount to draw into the shape.
*    OUT GpVector2D *grad,              output gradient vector
*
*
* Revision History:
*
*   08/23/00 asecchia
*       Created it
*
\**************************************************************************/

void GpEndCapCreator::ComputeCapGradient(
    GpIterator<GpPointF> &pointIterator, 
    BYTE *types,
    IN  REAL lengthSquared,
    IN  REAL baseInset,
    OUT GpVector2D *grad
)
{
    // Start at the beginning of the iterator (end of the list of
    // points if isStartCap is FALSE)
    
    GpPointF *endPoint = pointIterator.CurrentItem();
    GpPointF *curPoint = endPoint;
    INT index;
    bool intersectionFound = false;
    bool priorDeletion = false;
    
    while(!pointIterator.IsDone())
    {
        curPoint = pointIterator.CurrentItem();
        if(lengthSquared < distance_squared(*curPoint, *endPoint))
        {
            intersectionFound = true;
            break;
        }
        
        // Mark this point for deletion by the trimming algorithm.
        
        index = pointIterator.CurrentIndex();
        
        // Check to see if anyone already deleted this segment.
        // PathPointTypeInternalUse is the marked-for-deletion flag.
        
        priorDeletion = (types[index] & PathPointTypeInternalUse) ==
            PathPointTypeInternalUse;
        
        types[index] |= PathPointTypeInternalUse;
        
        pointIterator.Next();
    }
    
    // Now we have the segment that intersects the base of the arrow.
    // or the last segment.
    
    pointIterator.Prev();
    
    // if we couldn't get the Prev, then we were at the beginning.
    #if DBG
    if(pointIterator.IsDone())
    {
        ONCE(WARNING(("not enough points in array")));
    }
    #endif
    
    // If the intersection was not found we have marked the entire subpath
    // for deletion.
    
    if(intersectionFound && !priorDeletion)
    {
        // We overagressively marked this point for deletion,
        // instead of deleting this point, we're going to move it.
        // Note: we may have found an intersection point in a segment
        // that has already been marked for deletion. Checking priorDeletion
        // here ensures that we don't incorrectly undelete this point.
        
        index = pointIterator.CurrentIndex();
        
        // PathPointTypeInternalUse is the marked-for-deletion flag.
        
        types[index] &= ~PathPointTypeInternalUse;
    }
    
    GpPointF *prevPoint = pointIterator.CurrentItem();
    GpPointF intersectionPoint;
    
    if(!intersect_circle_line(
        *endPoint,           // center
        lengthSquared,       // radius^2
        *curPoint,           // P0
        *prevPoint,          // P1
        &intersectionPoint
    ))
    {
        // If there is no intersection, then the line segment is likely too 
        // short, so just take the previous point as the intersection.
        // This is our best guess and in this case will give us the slope from
        // the start to end point as the cap direction.
        
        intersectionPoint.X = prevPoint->X;
        intersectionPoint.Y = prevPoint->Y;
    }
    
    // Compute the gradient - and normalize the vector.
    
    *grad = intersectionPoint - *endPoint;
    grad->Normalize();
    
    // Update the point in the path directly.
    GpVector2D v = *endPoint - intersectionPoint;
    
    *prevPoint = intersectionPoint + (v*(1.0f-baseInset));
}

/**************************************************************************\
*
* Function Description:
*
*   This creates a path containing all the custom end caps for all
*   the open subpaths in the input path.
*
* Return
* 
*   Status
*
* Arguments:
*
*   [OUT]    caps  -- this is where we put the caps we generate
*
* Created:
*
*   10/05/2000 asecchia
*       created it.
*
\**************************************************************************/
GpStatus
GpEndCapCreator::CreateCapPath(GpPath **caps)
{
    // Validate our input data.
    
    ASSERT(Pen != NULL);
    ASSERT(Path != NULL);
    ASSERT(caps != NULL);
    ASSERT(*caps == NULL);
    
    // Create our cap path.
    
    *caps = new GpPath(FillModeWinding);
    if(*caps==NULL) 
    { 
        return OutOfMemory; 
    }
    
    // Create a path points iterator because our GpPath doesn't know how
    // to iterate over its own data *sigh*
    
    GpPathPointIterator pathIterator(
        const_cast<GpPointF*>(Path->GetPathPoints()),
        const_cast<BYTE*>(Path->GetPathTypes()),
        Path->GetPointCount()
    );
    
    GpSubpathIterator subpathIterator(&pathIterator);
    
    // Loop through all the available subpaths.
    
    while(!subpathIterator.IsDone())
    {
        // Compute the length of the subpath.
        
        INT startIndex = subpathIterator.CurrentIndex();
        GpPointF *points = subpathIterator.CurrentItem();
        BYTE *types = subpathIterator.CurrentType();
        subpathIterator.Next();
        INT elementCount = subpathIterator.CurrentIndex() - startIndex;
        
        // Work out if it's a closed subpath.
        // Leave the subpath iterator in the same state.
        
        pathIterator.Prev();
        
        bool isClosed = 
            ((*(pathIterator.CurrentType()) & PathPointTypeCloseSubpath) ==
            PathPointTypeCloseSubpath);
            
        pathIterator.Next();
        
        // only want to add end caps if this is an open subpath.
        
        if(!isClosed)
        {
            GpPath *startCap = NULL;
            GpPath *endCap = NULL;
        
            // Create the cap using the points and types
            
            GetCapsForSubpath(
                &startCap,
                &endCap,                
                points,
                types,
                elementCount
            );
            
            // Add the cap to our caps path.
            
            (*caps)->AddPath(startCap, FALSE);
            (*caps)->AddPath(endCap, FALSE);
            
            // Clean up the temporary caps for the next iteration.
            
            delete startCap;
            delete endCap;
        }
    }
    
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*    This takes a pen and sets it up to match the internal Pen, but modified
*    to support stroking the StrokeCap. E.g. the caps are removed to avoid
*    recursive compound capping etc.
*
* Arguments:
*
*   [OUT]    pen       -- this is where we put the pen we generate
*   [IN]     customCap -- input custom cap.
*
* Created:
*
*   10/09/2000 asecchia
*       rewrote it.
*
\**************************************************************************/

VOID GpEndCapCreator::PrepareDpPenForCustomCap(
    DpPen* pen,
    const GpCustomLineCap* customCap
    ) const
{
    ASSERT(pen);

    *pen = *Pen;
    
    pen->StartCap = LineCapFlat;
    pen->EndCap = LineCapFlat;
    pen->Join = LineJoinMiter;
    pen->MiterLimit = 10;
    pen->PenAlignment = PenAlignmentCenter;
    pen->DashStyle = DashStyleSolid;
    pen->DashCap = LineCapFlat;
    pen->DashCount = 0;
    pen->DashOffset = 0;
    pen->DashArray = NULL;
    pen->CompoundCount = 0;
    pen->CompoundArray = NULL;
    pen->CustomEndCap = NULL;
    pen->CustomStartCap = NULL;

    GpLineCap startCap, endCap;
    GpLineJoin lineJoin;

    if(customCap)
    {
        REAL widthScale;

        customCap->GetStrokeCaps(&startCap, &endCap);
        customCap->GetStrokeJoin(&lineJoin);
        customCap->GetWidthScale(&widthScale);

        pen->Width *= widthScale;
        pen->StartCap = startCap;
        pen->EndCap = endCap;
        pen->Join = lineJoin;
    }
}

GpStatus
GpEndCapCreator::SetCustomFillCaps(
    GpCustomLineCap* customStartCap,
    GpCustomLineCap* customEndCap,
    const GpPointF& startPoint,
    const GpPointF& endPoint,
    const GpPointF *centerPoints,
    const BYTE *centerTypes,
    INT centerPointCount,
    DynPointFArray *startCapPoints,
    DynPointFArray *endCapPoints,
    DynByteArray *startCapTypes,
    DynByteArray *endCapTypes
    )
{
    GpStatus status = Ok;

    startCapPoints->Reset(FALSE);
    startCapTypes->Reset(FALSE);
    endCapPoints->Reset(FALSE);
    endCapTypes->Reset(FALSE);

    INT count;
    GpPointF tangent;
    GpPointF* points;
    BYTE* types;
    REAL width, widthScale;
    
    // Get minimum line width based on the transform currently in effect.
    REAL majorR, minorR, unitScale;
    GetMajorAndMinorAxis(&majorR, &minorR, &XForm);
    unitScale = min(majorR, minorR);

    if(customStartCap)
    {
        // Get the start cap and inset of the base start cap.

        count = customStartCap->GetFillPointCount();
        
        if(count > 0)
        {            
            points = startCapPoints->AddMultiple(count);
            types = startCapTypes->AddMultiple(count);

            if(!points || !types)
            {
                startCapPoints->Reset(FALSE);
                startCapTypes->Reset(FALSE);
                status = OutOfMemory;
            }

            if(status == Ok)
            {
                customStartCap->GetWidthScale(&widthScale);
                width = Pen->Width*widthScale;
                
                REAL length = customStartCap->GetFillLength();
                
                // Compute the base inset. Divide by the length to get a 
                // number between 0 and 1. 0=no inset, 1=inset to the full
                // length of the cap.
                
                REAL inset;
                customStartCap->GetBaseInset(&inset);
                if(REALABS(length) < REAL_EPSILON)
                { 
                    inset = 0.0f;
                }
                else
                {
                    inset /= length;
                }
                
                length *= max(width, 1.0f/unitScale);

                // Compute the gradient of the cap.
    
                GpArrayIterator<GpPointF> pointIterator(
                    const_cast<GpPointF*>(centerPoints),
                    centerPointCount
                );
                
                GpVector2D gradient;
                
                ComputeCapGradient(
                    pointIterator,
                    const_cast<BYTE*>(centerTypes),
                    length*length, 
                    inset,
                    &gradient           // OUT parameters
                );
                
                tangent.X = -gradient.X;
                tangent.Y = -gradient.Y;

                // Move start point left or right to account for inset
                // pens, if needed.
                GpPointF start;
                start.X = startPoint.X;
                start.Y = startPoint.Y;
                
                customStartCap->GetTransformedFillCap(
                    points, 
                    types, 
                    count,
                    start, 
                    tangent, 
                    width, 
                    2.0f / unitScale
                );
            }
        }
    }

    if(status == Ok && customEndCap)
    {
        // Get the start cap and inset of the base start cap.

        count = customEndCap->GetFillPointCount();

        if(count > 0)
        {

            points = endCapPoints->AddMultiple(count);
            types = endCapTypes->AddMultiple(count);

            if(!points || !types)
            {
                endCapPoints->Reset(FALSE);
                endCapTypes->Reset(FALSE);
                status = OutOfMemory;
            }

            if(status == Ok)
            {
                customEndCap->GetWidthScale(&widthScale);

                width = Pen->Width*widthScale;
                
                REAL length = customEndCap->GetFillLength();
                
                // Compute the base inset. Divide by the length to get a 
                // number between 0 and 1. 0=no inset, 1=inset to the full
                // length of the cap.
                
                REAL inset;
                customEndCap->GetBaseInset(&inset);
                if(REALABS(length) < REAL_EPSILON)
                { 
                    inset = 0.0f;
                }
                else
                {
                    inset /= length;
                }
                
                length *= max(width, 1.0f/unitScale);
                
                // Compute the gradient of the cap.

                GpArrayIterator<GpPointF> pointIterator(
                    const_cast<GpPointF*>(centerPoints),
                    centerPointCount
                );
                GpReverseIterator<GpPointF> pointReverse(&pointIterator);
                pointReverse.SeekFirst();
    
                GpVector2D gradient;
                
                ComputeCapGradient(
                    pointReverse,
                    const_cast<BYTE*>(centerTypes),
                    length*length, 
                    inset,
                    &gradient            // OUT parameters
                );
                
                tangent.X = - gradient.X;
                tangent.Y = - gradient.Y;
                
                // Move end point left or right to account for inset
                // pens, if needed.
                GpPointF end;
                end.X = endPoint.X;
                end.Y = endPoint.Y;
                customEndCap->GetTransformedFillCap(
                    points, 
                    types, 
                    count,
                    end, 
                    tangent, 
                    width, 
                    2.0f / unitScale
                );
            }
        }
    }
    
    return status;
}

GpStatus
GpEndCapCreator::SetCustomStrokeCaps(
    GpCustomLineCap* customStartCap,
    GpCustomLineCap* customEndCap,
    const GpPointF& startPoint,
    const GpPointF& endPoint,
    const GpPointF *centerPoints,
    const BYTE *centerTypes,
    INT centerPointCount,
    DynPointFArray *startCapPoints,
    DynPointFArray *endCapPoints,
    DynByteArray *startCapTypes,
    DynByteArray *endCapTypes
    )
{
    GpStatus status = Ok;
        
    GpPointF* points = NULL;
    BYTE* types = NULL;

    INT count;
    GpPointF tangent, start, end;

    INT startCount = 0;
    INT endCount = 0;

    if(customStartCap)
    {
        startCount = customStartCap->GetStrokePointCount();
    }

    if(customEndCap)
    {
        endCount = customEndCap->GetStrokePointCount();
    }

    INT maxCount = max(startCount, endCount);

    if(maxCount <= 0)
    {
        return Ok;
    }

    points = (GpPointF*) GpMalloc(maxCount*sizeof(GpPointF));
    types = (BYTE*) GpMalloc(maxCount);

    if(!points || !types)
    {
        GpFree(points);
        GpFree(types);

        return OutOfMemory;
    }

    DpPen pen;
    GpPointF* widenedPts;
    INT widenedCount;
    REAL widthScale, width;

    if(customStartCap && startCount > 0)
    {
        startCapPoints->Reset(FALSE);
        startCapTypes->Reset(FALSE);
        
        customStartCap->GetWidthScale(&widthScale);

        width = Pen->Width*widthScale;
        
        REAL length = customStartCap->GetStrokeLength();
        
        // Handle the case of a non-closed stroke path
        // in this case the length is typically zero.
        
        if(REALABS(length)<REAL_EPSILON)
        {
            length = 1.0f;
        }
        
        // Compute the base inset. Divide by the length to get a 
        // number between 0 and 1. 0=no inset, 1=inset to the full
        // length of the cap.
        
        REAL inset;
        customStartCap->GetBaseInset(&inset);
        inset /= length;
        
        length *= width;
        
        // Compute the gradient of the cap.

        GpArrayIterator<GpPointF> pointIterator(
            const_cast<GpPointF*>(centerPoints),
            centerPointCount
        );
        
        GpVector2D gradient;
        
        ComputeCapGradient(
            pointIterator, 
            const_cast<BYTE*>(centerTypes),
            length*length, 
            inset,
            &gradient            // OUT parameters
        );
        
        tangent.X = -gradient.X;
        tangent.Y = -gradient.Y;

        // Move start point left or right to account for inset
        // pens, if needed.
        GpPointF start;
        start.X = startPoint.X;
        start.Y = startPoint.Y;
                
        customStartCap->GetTransformedStrokeCap(
            maxCount,
            &points, 
            &types, 
            &startCount,
            start, 
            tangent, 
            width, 
            width   
        );

        PrepareDpPenForCustomCap(&pen, customStartCap);
        
        GpPathWidener widener(
            points, 
            types, 
            startCount,
            &pen, 
            &XForm, 
            DpiX,          // widener doesn't use these.
            DpiY, 
            Antialias
        );

        widener.Widen(startCapPoints, startCapTypes);
    }

    if(customEndCap && endCount > 0)
    {
        endCapPoints->Reset(FALSE);
        endCapTypes->Reset(FALSE);
        
        customEndCap->GetWidthScale(&widthScale);

        width = Pen->Width*widthScale;
        
        REAL length = customEndCap->GetStrokeLength();
        
        // Handle the case of a non-closed stroke path
        // in this case the length is typically zero.
        
        if(REALABS(length)<REAL_EPSILON)
        {
            length = 1.0f;
        }
        
        // Compute the base inset. Divide by the length to get a 
        // number between 0 and 1. 0=no inset, 1=inset to the full
        // length of the cap.
        
        REAL inset;
        customEndCap->GetBaseInset(&inset);
        inset /= length;
        
        length *= width;
        
        // Compute the gradient of the cap.

        GpArrayIterator<GpPointF> pointIterator(
            const_cast<GpPointF*>(centerPoints),
            centerPointCount
        );
        GpReverseIterator<GpPointF> pointReverse(&pointIterator);
        pointReverse.SeekFirst();
        
        GpVector2D gradient;
        
        ComputeCapGradient(
            pointReverse, 
            const_cast<BYTE*>(centerTypes),
            length*length, 
            inset,
            &gradient            // OUT parameter
        );
        
        tangent.X = - gradient.X;
        tangent.Y = - gradient.Y;
        
        // Move end point left or right to account for inset
        // pens, if needed.
        GpPointF end;
        end.X = endPoint.X;
        end.Y = endPoint.Y;
                
        customEndCap->GetTransformedStrokeCap(
            maxCount,
            &points, 
            &types, 
            &endCount,
            end, 
            tangent, 
            width, 
            width
        );

        PrepareDpPenForCustomCap(&pen, customEndCap);
        
        GpPathWidener widener(
            points, 
            types, 
            endCount,
            &pen, 
            &XForm, 
            DpiX,    // widener doesn't use these. 
            DpiY, 
            Antialias
        );

        widener.Widen(endCapPoints, endCapTypes);
    }

    GpFree(points);
    GpFree(types);

    return status;
}



/**************************************************************************\
*
* Function Description:
*
*   This creates and returns two GpPaths containing the start and end cap.
*   The two caps are correctly positioned and scaled.
*
* Return
* 
*   Status
*
* Arguments:
*
*   [OUT]    startCapPath, endCapPath
*
* Created:
*
*   10/05/2000 asecchia
*       created it.
*
\**************************************************************************/

GpStatus
GpEndCapCreator::GetCapsForSubpath(
    GpPath **startCapPath,
    GpPath **endCapPath,
    GpPointF *centerPoints,
    BYTE *centerTypes,
    INT centerCount
    )
{
    // Validate our input parameters.
    
    ASSERT(startCapPath != NULL);
    ASSERT(endCapPath != NULL);
    ASSERT(*startCapPath == NULL);
    ASSERT(*endCapPath == NULL);

    DynPointFArray startCapPoints;
    DynPointFArray endCapPoints;
    DynByteArray startCapTypes;
    DynByteArray endCapTypes; 
    
    GpPointF startPoint, endPoint;

    startPoint = *(centerPoints);
    endPoint = *(centerPoints + centerCount - 1);
    
    GpStatus status = Ok;

    if(StartCap || EndCap)
    {
        status = SetCustomFillCaps(
            StartCap, 
            EndCap,
            startPoint, 
            endPoint, 
            centerPoints,
            centerTypes,
            centerCount,
            &startCapPoints,
            &endCapPoints,
            &startCapTypes,
            &endCapTypes
        );

        if(status == Ok)
        {
            status = SetCustomStrokeCaps(
                StartCap, 
                EndCap,
                startPoint, 
                endPoint, 
                centerPoints,
                centerTypes,
                centerCount,
                &startCapPoints,
                &endCapPoints,
                &startCapTypes,
                &endCapTypes
            );
        }
    }

    if(startCapPoints.GetCount() > 0)
    {
        *startCapPath = new GpPath(
            startCapPoints.GetDataBuffer(),
            startCapTypes.GetDataBuffer(),
            startCapPoints.GetCount()
        );
        
        if(*startCapPath == NULL)
        {
            status = OutOfMemory;
        }
    }
    
    if(endCapPoints.GetCount() > 0)
    {
        *endCapPath = new GpPath(
            endCapPoints.GetDataBuffer(),
            endCapTypes.GetDataBuffer(),
            endCapPoints.GetCount()
        );
        
        if(*endCapPath == NULL)
        {
            status = OutOfMemory;
        }
    }
    
    if(status != Ok)
    {
        delete *startCapPath;
        delete *endCapPath;
        *startCapPath = NULL;
        *endCapPath = NULL;
        status = OutOfMemory;
    }
    
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\family.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Abstract:
*
*       Implementation of GpFontFamily and GpFontFamilyList
*
* Revision History:
*
*   27/06/1999 cameronb
*       Created it.
*
\**************************************************************************/
#include "precomp.hpp"

#if DBG
#include <mmsystem.h>
#endif

#define QWORD_ALIGN(x) (((x) + 7L) & ~7L)

#define SWAP_LANGID(pj)                                \
    (                                                \
        ((USHORT)(((PBYTE)(pj))[0]) << 8) |          \
        (USHORT)(((PBYTE)(pj))[1])                   \
    )

//
VOID CopyFamilyName(WCHAR * dest, const WCHAR * src, BOOL bCap)
{

    GpMemset(dest, 0, FamilyNameMax * sizeof(WCHAR));

    if (src != NULL)
    {
        for (int c = 0; src[c] && c < FamilyNameMax - 1; c++)
            dest[c] = src[c];
    }

    if (bCap)
        UnicodeStringToUpper(dest, dest);
}

//////////////////////////////////////////////////////////////////////////////

GpFontFamily::GpFontFamily(const WCHAR *name,  GpFontFile * fontfile, INT index, 
                            FAMILYCACHEENTRY * pCacheEntry, GpFontCollection *fontCollection)
{
    SetValid(TRUE); // set initial valid state to TRUE (valid)


//    InitializeCriticalSection(&FontFamilyCritSection);

    cacheEntry = pCacheEntry;
    
    CopyFamilyName(cacheEntry->Name, name, TRUE);

    for (INT ff = 0; ff < NumFontFaces; ff++)
    {
        Face[ff] = NULL;
        FontFile[ff] = NULL;
        cacheEntry->cFilePathName[ff] = 0;
        cacheEntry->LastWriteTime[ff].LowPart = 0;
        cacheEntry->LastWriteTime[ff].HighPart = 0;
    }

    cFontFamilyRef = 0;

    cacheEntry->iFont = index;

// Get font entry for the font file
    GpFontFace * fontface = fontfile->GetFontFace(cacheEntry->iFont);

// Get LandID for Family Name
    cacheEntry->LangID = SWAP_LANGID((LANGID *) &fontface->pifi->familyNameLangID);
    cacheEntry->AliasLnagID = SWAP_LANGID((LANGID *) &fontface->pifi->familyAliasNameLangID);

// Process Alias name
    cacheEntry->bAlias = fontface->IsAliasName();

    if (cacheEntry->bAlias)
    {
        CopyFamilyName(cacheEntry->FamilyAliasName, fontface->GetAliasName(), TRUE);
        CopyFamilyName(cacheEntry->NormalFamilyAliasName, fontface->GetAliasName(), FALSE);
    }

    CopyFamilyName(cacheEntry->NormalName, fontfile->GetFamilyName(cacheEntry->iFont), FALSE);

    //  Determine face type(s) of font
    FontStyle style = FontStyleRegular;
    //  ...

//    SetFont(face, font);

    cacheEntry->lfCharset = DEFAULT_CHARSET;
    if (fontCollection == NULL)
    {
        associatedFontCollection = GpInstalledFontCollection::GetGpInstalledFontCollection();
    }
    else
    {
        associatedFontCollection = fontCollection;
    }

    FamilyFallbackInitialized = FALSE;

    bLoadFromCache = FALSE;
    bFontFileLoaded = TRUE;

}

GpFontFamily::GpFontFamily(FAMILYCACHEENTRY * pCacheEntry)
{
    SetValid(TRUE); // set initial valid state to TRUE (valid)

//    InitializeCriticalSection(&FontFamilyCritSection);

    cacheEntry = pCacheEntry;
    
    for (INT ff = 0; ff < NumFontFaces; ff++)
    {
        Face[ff] = NULL;
        FontFile[ff] = NULL;
    }

    cFontFamilyRef = 0;

    // It will be from Cache entry.
    bFontFileLoaded = FALSE;

    //  Determine face type(s) of font
    FontStyle style = FontStyleRegular;
    
    associatedFontCollection = GpInstalledFontCollection::GetGpInstalledFontCollection();

    FamilyFallbackInitialized = FALSE;

    bLoadFromCache = TRUE;

}

GpFontFamily::~GpFontFamily()
{
    if (FamilyFallbackInitialized)
    {
        FamilyFallbackInitialized = FALSE;
        fallback.Destroy();
    }

    ReleaseCacheEntry();

//    DeleteCriticalSection(&FontFamilyCritSection);

    SetValid(FALSE);    // so we don't use a deleted object
}


BOOL GpFontFamily::IsPrivate() const
{
    return associatedFontCollection != GpInstalledFontCollection::GetGpInstalledFontCollection();
}


void GpFontFamily::SetFaceAndFile(INT style, GpFontFace *face, GpFontFile * fontfile)
{
//    EnterCriticalSection(&FontFamilyCritSection);
    Face[style & 3] = face;
    FontFile[style & 3] = fontfile;
    cacheEntry->LastWriteTime[style & 3].QuadPart = (fontfile->GetFileView())->LastWriteTime.QuadPart;
    

//    LeaveCriticalSection(&FontFamilyCritSection);
}

GpStatus GpFontFamily::GetFamilyName(WCHAR   name[LF_FACESIZE], LANGID  language) const
{
    ASSERT(FamilyNameMax == LF_FACESIZE);

    if (cacheEntry->bAlias && language == cacheEntry->AliasLnagID)
    {
        CopyFamilyName(name, cacheEntry->NormalFamilyAliasName, FALSE);
    }
    else
    {
        CopyFamilyName(name, cacheEntry->NormalName, FALSE);
    }

    return Ok;
}

BOOL GpFontFamily::IsFileLoaded(BOOL loadFontFile) const
{

    // If file is not loaed yet then load it.
    if (!bFontFileLoaded)
    {
        if (loadFontFile)
        {
            if (bLoadFromCache)
            {
                GpFontTable *fontTable;
                GpFontFile * fontFile;
                WCHAR *      fontfilepath;
            
                fontTable = (GpInstalledFontCollection::GetGpInstalledFontCollection())->GetFontTable();

                fontfilepath = (WCHAR *) ((BYTE *) cacheEntry + QWORD_ALIGN(sizeof(FAMILYCACHEENTRY)));
            
                for (UINT i = 0; i < NumFontFaces; i++)
                {
                    if (cacheEntry->cFilePathName[i])
                    {
                        fontFile = fontTable->AddFontFile(fontfilepath);
    
                        if (!fontFile)
                        {
                            return FALSE;
                        }
                        else
                        {
                            GpFontFace* face = fontFile->GetFontFace(cacheEntry->iFont);
                            FontStyle style  = face->GetFaceStyle();
        
                            Face[style & 3] = face;
                        
                            face->cGpFontFamilyRef = cFontFamilyRef;
                        
                            FontFile[style & 3] = fontFile;
                        
                            cacheEntry->LastWriteTime[style & 3].QuadPart = 
                                            (fontFile->GetFileView())->LastWriteTime.QuadPart;
                        }

                        fontfilepath = (WCHAR *) ((BYTE *) fontfilepath + cacheEntry->cFilePathName[i]);
                    }                    
                }

                bFontFileLoaded = TRUE;
            }
            else
            {
                ASSERT(!bLoadFromCache);
            }
        }
        else
        {
            return FALSE;
        }
    }

    return bFontFileLoaded;
}
    

GpFontFace *GpFontFamily::GetFace(INT style) const
{
    // Return face for the given style - either the direct face
    // or one which can support this style through simulation.

    GpFontFace *fontFace = NULL;
//    EnterCriticalSection(&FontFamilyCritSection);

    if (IsFileLoaded())
    {        
        if (Face[style&3])
        {
            // Distinct font exists
            fontFace = Face[style&3];
        }
        else
        {
            // Will need simulation
            switch (style & 3)
            {
                case FontStyleBold:
                case FontStyleItalic:
                    fontFace = Face[0];
                    break;

                case FontStyleBold|FontStyleItalic:
                    if (Face[FontStyleBold])
                    {
                        fontFace = Face[FontStyleBold];
                    }
                    else if (Face[FontStyleItalic])
                    {
                        fontFace = Face[FontStyleItalic];
                    }
                    else
                    {
                        fontFace = Face[0];
                    }
                    break;

                default:
                case 0:
                    ;
            }
        }
    }
//    LeaveCriticalSection(&FontFamilyCritSection);
    return fontFace;
}

GpFontFace *GpFontFamily::GetFaceAbsolute(INT style) const
{
    // Return face for the given style, where the style is one of
    // the four basic types.  If it does not exist, return NULL.

    GpFontFace *fontFace = NULL;

//    EnterCriticalSection(&FontFamilyCritSection);
    if (IsFileLoaded())
        fontFace = Face[style & 3];

//    LeaveCriticalSection(&FontFamilyCritSection);
    return (fontFace);
}

UINT16 GpFontFamily::GetDesignEmHeight (INT style) const
{
    UINT16 result;
    GpFontFace *fontface;

//    EnterCriticalSection(&FontFamilyCritSection);
    fontface = GetFace(style);
    result = ((fontface != NULL) ? fontface->GetDesignEmHeight() : 0);

//    LeaveCriticalSection(&FontFamilyCritSection);
    return result;

}

UINT16 GpFontFamily::GetDesignCellAscent (INT style) const
{
    UINT16 result;
    GpFontFace *fontface;

//    EnterCriticalSection(&FontFamilyCritSection);
    fontface = GetFace(style);
    result = ((fontface != NULL) ? fontface->GetDesignCellAscent() : 0);

//    LeaveCriticalSection(&FontFamilyCritSection);
    return result;
}

UINT16 GpFontFamily::GetDesignCellDescent (INT style) const
{
    UINT16 result;
    GpFontFace *fontface;

//    EnterCriticalSection(&FontFamilyCritSection);
    fontface = GetFace(style);
    result = ((fontface != NULL) ? fontface->GetDesignCellDescent() : 0);

//    LeaveCriticalSection(&FontFamilyCritSection);
    return result;
}

UINT16 GpFontFamily::GetDesignLineSpacing (INT style) const
{
    UINT16 result;
    GpFontFace *fontface;

//    EnterCriticalSection(&FontFamilyCritSection);
    fontface = GetFace(style);
    result = ((fontface != NULL) ? fontface->GetDesignLineSpacing() : 0);

//    LeaveCriticalSection(&FontFamilyCritSection);
    return result;
}

UINT16 GpFontFamily::GetDesignUnderscoreSize (INT style) const
{
    UINT16 result;
    GpFontFace *fontface;

//    EnterCriticalSection(&FontFamilyCritSection);
    fontface = GetFace(style);
    result = ((fontface != NULL) ? fontface->GetDesignUnderscoreSize() : 0);

//    LeaveCriticalSection(&FontFamilyCritSection);
    return result;
}

INT16 GpFontFamily::GetDesignUnderscorePosition (INT style) const
{
    INT16 result;
    GpFontFace *fontface;

//    EnterCriticalSection(&FontFamilyCritSection);
    fontface = GetFace(style);
    result = ((fontface != NULL) ? fontface->GetDesignUnderscorePosition() : 0);

//    LeaveCriticalSection(&FontFamilyCritSection);
    return result;
}

UINT16 GpFontFamily::GetDesignStrikeoutSize (INT style) const
{
    UINT16 result;
    GpFontFace *fontface;

//    EnterCriticalSection(&FontFamilyCritSection);
    fontface = GetFace(style);
    result = ((fontface != NULL) ? fontface->GetDesignStrikeoutSize() : 0);

//    LeaveCriticalSection(&FontFamilyCritSection);
    return result;
}

INT16 GpFontFamily::GetDesignStrikeoutPosition (INT style) const
{
    INT16 result;
    GpFontFace *fontface;

//    EnterCriticalSection(&FontFamilyCritSection);
    fontface = GetFace(style);
    result = ((fontface != NULL) ? fontface->GetDesignStrikeoutPosition() : 0);

//    LeaveCriticalSection(&FontFamilyCritSection);
    return result;
}


/**************************************************************************\
*
* Function Description:
*
*   Determines available (non-NULL) faces for this family
*
* Arguments:
*
*       None
*
* Returns:
*
*       Bitset of available face flags
*
* History:
*
*   27/06/1999 cameronb
*       Created it.
*
\**************************************************************************/

INT GpFontFamily::AvailableFaces(void) const
{
    INT faces = 0;

    if (bFontFileLoaded)
    {
        for (int ff = 0; ff < NumFontFaces; ff++)
        {
            if (Face[ff] != NULL)
            {
                //  Map index to FontFace flag
                faces |= (0x01 << ff);
            }
        }
    }
    else
    {
    // At least one face exists.
    
        faces = 1;
    }
    
    return faces;
}




/**************************************************************************\
*
* Function Description:
*
*   Determines whether the specified face supports a given string
*
* Arguments:
*
*   style:  font face to test for support
*   lang:   language id
*
* Returns:
*
*       Boolean result
*
* History:
*
*   27/06/1999 cameronb
*       Created it.
*
\**************************************************************************/

BOOL GpFontFamily::SupportsLanguage(INT style, LANGID lang) const
{
    BOOL result = TRUE;

    //  ...

    return result;
}


/**************************************************************************\
*
* Function Description:
*
*   Determines whether the specified face supports a given string
*
* Arguments:
*
*   style:  font face to test for support
*       str:    target string
*   len:    string length
*
* Returns:
*
*       Boolean result
*
* History:
*
*   27/06/1999 cameronb
*       Created it.
*
\**************************************************************************/

BOOL GpFontFamily::SupportsCharacters(INT style, WCHAR* str, INT len) const
{
    BOOL result = TRUE;

    //  ...

    return result;
}


/**************************************************************************\
*
* Function Description:
*
*   Internal, access the tables from the font, return a pointer
*
* Arguments:
*
*   style:  font style
*   tag: 4 bytes tag for the table, a null tag means return the whole file
*
* Returns:
*
*       table size and pointer to the table
*
* History:
*
*   09/10/1999 caudebe
*       Created it.
*
\**************************************************************************/

GpStatus GpFontFamily::GetFontData(FontStyle style, UINT32 tag, INT* tableSize, BYTE** pjTable)
{
    GpFontFace *face;
    GpStatus status;

//    EnterCriticalSection(&FontFamilyCritSection);

    face = GetFace(style);
    if (face == NULL)
    {
        return GenericError;
    }

    status = face->GetFontData (tag, tableSize, pjTable);

//    LeaveCriticalSection(&FontFamilyCritSection);
    return status;
}

void GpFontFamily::ReleaseFontData(FontStyle style)
{
    GpFontFace *face;

//    EnterCriticalSection(&FontFamilyCritSection);

    face = GetFace(style);
    if (face != NULL)
    {
        face->ReleaseFontData();
    }

//    LeaveCriticalSection(&FontFamilyCritSection);
}

/**************************************************************************\
*
* Function Description:
*
*   Determines whether a font family is deletable.  Returns TRUE
*   if its ref count is 0 and all of its Face pointers are NULL.
*
* Arguments:
*   none
*
* Returns:
*
*       Boolean result
*
* History:
*
*   2/21/2000 dchinn
*       Created it.
*
\**************************************************************************/

/**************************************************************************\
*
* Function Description:
*
*   Returns TRUE exactly when all faces of the font family have had
*   RemoveFontFile() called on their corresponding font files.
*
* Arguments:
*   none
*
* Returns:
*   boolean
*
* History:
*
*   03/08/2000 dchinn
*       Created it.
*
\**************************************************************************/
BOOL GpFontFamily::AreAllFacesRemoved()
{
    /* no need for critical section, called only internally */

    if (!bFontFileLoaded)
    {
        ASSERT (bLoadFromCache);

        return FALSE;
    }
    else
    {
        for (UINT iFace = 0; iFace < NumFontFaces; iFace++)
        {
            if (Face[iFace] != NULL)
            {
                ASSERT (Face[iFace]->pff);
                if (!Face[iFace]->pff->bRemoved)
                {
                    // if the GpFontFile corresponding to the GpFontFace
                    // has not been removed, then the face is still "active"
                    // and so the font family is still "active".
                    return FALSE;
                }
            }
        }
    }
    
    return TRUE;

}


BOOL GpFontFamily::Deletable()
{
    BOOL bAllFacesNull = TRUE;

    if (cFontFamilyRef != 0)
    {
        return FALSE;
    }

    for (UINT iFace = 0; iFace < NumFontFaces; iFace++)
    {
        if (Face[iFace] != NULL)
        {
            bAllFacesNull= FALSE;
        }
    }
    return bAllFacesNull;
}

/**************************************************************************\
*
* Function Description:
*
*   Increments/decrements the reference count for the fontFamily and each GpFontFace (PFE)
*   pointed to by the Face pointers of the GpFontFamily object.
*
* Arguments:
*   none
*
* Returns:
*   nothing
*
* History:
*
*   2/21/2000 dchinn
*       Created it.
*
\**************************************************************************/
BOOL GpFontFamily::IncFontFamilyRef()
{
//    EnterCriticalSection(&FontFamilyCritSection);
    if (AreAllFacesRemoved())
    {
//        LeaveCriticalSection(&FontFamilyCritSection);
        return FALSE;
    }
    else
    {
        cFontFamilyRef++;
        
        if (bFontFileLoaded)
        {
            for (UINT iFace = 0; iFace < NumFontFaces; iFace++)
            {
                if (Face[iFace])
                {
                    Face[iFace]->IncGpFontFamilyRef();
                }
            }
        }
        
//        LeaveCriticalSection(&FontFamilyCritSection);
        return TRUE;
    }
}

void GpFontFamily::DecFontFamilyRef()
{
//    EnterCriticalSection(&FontFamilyCritSection);
    cFontFamilyRef--;

    if (bFontFileLoaded)
    {
        for (UINT iFace = 0; iFace < NumFontFaces; iFace++)
        {
            if (Face[iFace])
            {
                Face[iFace]->DecGpFontFamilyRef();
            }
        }
    }

//    LeaveCriticalSection(&FontFamilyCritSection);
}


GpStatus GpFontFamily::CreateFontFamilyFromName(
            const WCHAR *name,
            GpFontCollection *fontCollection,
            GpFontFamily **fontFamily)
{
    GpFontTable *fontTable;
    GpFontCollection *gpFontCollection;

    if (!name || !fontFamily)
    {
        return InvalidParameter;
    }
    
    GpStatus status = Ok;

    // ASSERT: if fontCollection is NULL, then the caller wants to
    // act on the GpInstalledFontCollection object.  Otherwise, the
    // caller has passed in a GpPrivateFontCollection.

    if (fontCollection == NULL)
    {
        gpFontCollection = GpInstalledFontCollection::GetGpInstalledFontCollection();
    }
    else
    {
        gpFontCollection = fontCollection;
    }

    if (gpFontCollection == NULL)
        return WrongState;

    fontTable = gpFontCollection->GetFontTable();

    if (!fontTable->IsValid())
        return OutOfMemory;

    if (!fontTable->IsPrivate() && !fontTable->IsFontLoaded())
        fontTable->LoadAllFonts();

    *fontFamily = fontTable->GetFontFamily(name);

    if (*fontFamily == NULL)
    {
        GetFamilySubstitution(name, fontFamily);
    }


    if (!*fontFamily)
        status = FontFamilyNotFound;

    // NOTE: We assume here that GdipCreateFontFamilyFromName gets
    // called externally (e.g., the FontFamily constructor).
    if (*fontFamily && (!(*fontFamily)->IncFontFamilyRef()))
    {
        // all the faces of the found fontFamily have been removed.
        // we do not want to return the fontFamily.
        *fontFamily = NULL;
        status = FontFamilyNotFound;
    }

    return status;
}

GpStatus GpFontFamily::GetGenericFontFamilySansSerif(
            GpFontFamily **nativeFamily)
{
    GpStatus status;

    if (!nativeFamily)
    {
        return InvalidParameter;
    }
    // return FontFamily::GetGenericSansSerif(nativeFamily);
    status = CreateFontFamilyFromName(L"Microsoft Sans Serif", NULL, nativeFamily);

    if (status == FontFamilyNotFound)
    {
        // Not found Arial in system so we got to find another font
        
        status = CreateFontFamilyFromName(L"Arial", NULL, nativeFamily);

        if (status == FontFamilyNotFound)
            status = CreateFontFamilyFromName(L"Tahoma", NULL, nativeFamily);

        // We are in the worst case so trying to find any font we can.

        if (status == FontFamilyNotFound)
        {
            GpFontTable *fontTable;
            GpFontCollection *gpFontCollection;

            gpFontCollection = GpInstalledFontCollection::GetGpInstalledFontCollection();

            fontTable = gpFontCollection->GetFontTable();

            if (!fontTable->IsValid())
                return OutOfMemory;

            *nativeFamily = fontTable->GetAnyFamily();

            if (!*nativeFamily)
                status = FontFamilyNotFound;
            else
                status = Ok;
        }
    }
    
    return status;
}

GpStatus GpFontFamily::GetGenericFontFamilySerif(
            GpFontFamily **nativeFamily)
{
    GpStatus status;

    if (!nativeFamily)
    {
        return InvalidParameter;
    }
    
    // return FontFamily::GetGenericSerif(nativeFamily);
    status = CreateFontFamilyFromName(L"Times New Roman", NULL, nativeFamily);

    // Get the font family from SansSerif
    if (status == FontFamilyNotFound)
        status = GetGenericFontFamilySansSerif(nativeFamily);

    return status;
}


GpStatus GpFontFamily::GetGenericFontFamilyMonospace(
            GpFontFamily **nativeFamily)
{
    GpStatus status;

    if (!nativeFamily)
    {
        return InvalidParameter;
    }
    // return FontFamily::GetGenericMonospace(nativeFamily);
    status = CreateFontFamilyFromName(L"Courier New", NULL, nativeFamily);

    if (status == FontFamilyNotFound)
        status = CreateFontFamilyFromName(L"Lucida Console", NULL, nativeFamily);

    // We are in the worst case so trying to find any font we can.
    if (status == FontFamilyNotFound)
        status = GetGenericFontFamilySansSerif(nativeFamily);

    return status;
}


//////////////////////////////////////////////////////////////////////////////
//  GpFontFamilyList

GpFontFamilyList::GpFontFamilyList()
:   Head(NULL), FamilyCacheEntry(NULL)
{}


GpFontFamilyList::~GpFontFamilyList()
{
    DeleteList();
}

void GpFontFamilyList::DeleteList(void)
{
    for (FamilyNode* node = Head; node != NULL; )
    {
        FamilyNode * next = node->Next;
        delete node->Item;
        delete node;
        node = next;
    }

    if (FamilyCacheEntry)
    {
        GpFree(FamilyCacheEntry);
        FamilyCacheEntry = NULL;
    }
    
    Head = NULL;
}


/**************************************************************************\
*
* Function Description:
*
*   Counts number of enumerable families
*
* Arguments:
*
*   filter:         filter describing the desired font styles
*
* Returns:
*
*       Number of available families
*
* History:
*
*   27/06/1999 cameronb
*       Created it.
*
\**************************************************************************/

INT GpFontFamilyList::Enumerable(GpGraphics* graphics) const
{
    INT result = 0;
    for (FamilyNode* node = Head; node != NULL; node = node->Next)
    {
        if (node->Item == NULL)
        {
            ASSERT(node->Item);
        }
        else if ( node->Item->AvailableFaces() != 0)
        {
            result++;
        }
    }

    return result;
}


/**************************************************************************\
*
* Function Description:
*
*   Enumerates the available font families.
*
*   If numExpected == 0 then Enumerate() counts the number of available families
*       and returns the result in numExpected.
*
*   If numExpected != 0 then Enumerate() sets pointers to as many available
*       families as possible.
*
*   The total number of emurated families is return in numEnumerated.
*
* Arguments:
*
*   numExpected:    number of families expected and allocated in families array
*   families:       array to hold pointers to enumerated families (preallocated)
*   numEnumerated:  the actual number of fonts enumerated in this pass
*   filter:         filter describing the desired font styles
*
* Returns:
*
*       Status of the operation, which may include:
*       - success
*       - too few available fonts
*       - too many available fonts
*
* History:
*
*   27/06/1999 cameronb
*       Created it.
*
\**************************************************************************/

Status GpFontFamilyList::Enumerate(
    INT                     numSought,
    GpFontFamily*           gpfamilies[],
    INT&                    numFound,
    GpGraphics*             graphics
) const
{
    Status status = Ok;

    numFound = 0;
    for
    (
        FamilyNode* node = Head;
        node != NULL && numFound < numSought;
        node = node->Next
    )
    {
        if (node->Item == NULL)
        {
            ASSERT(node->Item);
        }
        else if ( node->Item->AvailableFaces() != 0)
        {
            gpfamilies[numFound++] = node->Item;
        }
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Finds the any font (except Marlett) in the family list
*
* Arguments:
*
* Returns:
*
*       Pointer to family if found any, else NULL
*
* History:
*
*   07/14/2000 YungT
*       Created it.
*
\**************************************************************************/

GpFontFamily* GpFontFamilyList::GetAnyFamily() const
{

    for (FamilyNode* node = Head; node != NULL; node = node->Next)
    {
        if (node->Item == NULL)
        {
            //ASSERT
        }
        else
        {
            if (!UnicodeStringCompare(L"MARLETT", node->Item->GetCaptializedName()) == 0)
            {
                return node->Item;
            }
       }
    }

    return NULL;
}

/**************************************************************************\
*
* Function Description:
*
*   Finds the named font in the family list
*
* Arguments:
*
*       name:   name of the font family to be found
*
* Returns:
*
*       Pointer to family if found, else NULL
*
* History:
*
*   27/06/1999 cameronb
*       Created it.
*
\**************************************************************************/

GpFontFamily* GpFontFamilyList::GetFamily(const WCHAR *familyName) const
{
    WCHAR       nameCap[FamilyNameMax];  // Family name

    GpMemset(nameCap, 0, sizeof(nameCap));

    for (int c = 0; familyName[c] && c < FamilyNameMax - 1; c++)
       nameCap[c] = familyName[c];

    UnicodeStringToUpper(nameCap, nameCap);

    for (FamilyNode* node = Head; node != NULL; node = node->Next)
    {
        if (node->Item == NULL)
        {
            //ASSERT
        }
        else
        {
            if (UnicodeStringCompare(nameCap, node->Item->GetCaptializedName()) == 0)
            {
                return node->Item;
            }

            if (node->Item->IsAliasName())
            {
                if (UnicodeStringCompare(nameCap, node->Item->GetAliasName()) == 0)
                {
                    return node->Item;
                }
            }
        }
    }

    return NULL;
}


/**************************************************************************\
*
* Function Description:
*
*   Adds a font family to the enumeration list ordered alphabetically
*       by family name.
*
* Arguments:
*
*       fontFile:   the font to be added.
*
* Returns:
*
*       Boolean indicating success
*
* History:
*
*   27/06/1999 cameronb
*       Created it.
*
\**************************************************************************/

BOOL GpFontFamilyList::AddFont(GpFontFile* fontFile,
                               GpFontCollection *fontCollection)
{
    BOOL newFamily = FALSE;
    BOOL newNodeInserted = FALSE;

    //  Loop over each entry per font file
    for (ULONG e = 0; e < fontFile->GetNumEntries(); e++)
    {
        VERBOSE(("Adding \"%ws\" to family list...", fontFile->GetFamilyName(e)))

        //  Check if the family already exists, if not create a new entry
        GpFontFamily* family = GetFamily(fontFile->GetFamilyName(e));

        if (family == NULL)
        {
            FAMILYCACHEENTRY *  pCacheEntry;

            UINT cjSize = sizeof(FAMILYCACHEENTRY);
            
            // This family is not in the list, create a new GpFontFamily object
            if (!(pCacheEntry = (FAMILYCACHEENTRY *) GpMalloc(cjSize)))
            {
                return FALSE;
            }

            pCacheEntry->cjThis = cjSize;
            
            family = new GpFontFamily(fontFile->GetFamilyName(e), fontFile, e, pCacheEntry, fontCollection);
            if (family == NULL)
            {
                GpFree(pCacheEntry);
                WARNING(("Error constructing family."))
                return FALSE;
            }

            newFamily = TRUE;
        }

        //  Insert entry into the enumeration list, ordered alphabetically
        GpFontFace* face = fontFile->GetFontFace(e);
        FontStyle style  = face->GetFaceStyle();

        if (InsertOrdered(family, style, fontFile, face, TRUE))
            newNodeInserted = TRUE;

        if (newFamily && !newNodeInserted)
        {
            // New GpFontFamily object not used, delete it
            delete family;
            return FALSE;
        }
    }

    return TRUE;
}


/**************************************************************************\
*
* Function Description:
*
*   Inserts font family into the enumeration list ordered alphabetically
*       by family name, and links up the face pointer to the font entry.
*
* Arguments:
*
*   family:     the font family
*   face:       the font face
*   entry:      the font entry
*
* Returns:
*
*       Boolean indicating whether family was added (a new node was created)
*
* History:
*
*   29/07/1999 cameronb
*       Created it.
*
\**************************************************************************/

BOOL GpFontFamilyList::InsertOrdered(
    GpFontFamily*   family,
    FontStyle       style,
    GpFontFile *    fontfile,          
    GpFontFace *    face,
    BOOL            bSetFace
)
{
    BOOL result = FALSE;

    if (Head == NULL)
    {
        //  First entry
        FamilyNode *new_node = new FamilyNode(family);
        if (!new_node)
            return FALSE;

        if(bSetFace)
            new_node->Item->SetFaceAndFile(style, face, fontfile);
            
            
        Head = new_node;
        return TRUE;
    }
    else
    {
        //  Search the enumeration list
        for (FamilyNode* node = Head; node != NULL; node = node->Next)
        {
            int comp = UnicodeStringCompare(node->Item->GetCaptializedName(), family->GetCaptializedName());
            if (comp == 0)
            {
                //  FontFamily found in list
                if (bSetFace && node->Item->FaceExist(style & 3))
                {
                    //  This face already exists for this family, do nothing
                    VERBOSE(("Face collision: face %d exists for family \"%ws\".", style, family->GetCaptializedName()))
                }
                else
                {
                    if (bSetFace)
                    {
                        //  Update face pointer
                        node->Item->SetFaceAndFile(style, face, fontfile);
                    }
                }

                return FALSE;
            }
            else if (comp > 0)
            {
                //  Add new family node
                FamilyNode *new_node = new FamilyNode(family);
                if (!new_node)
                    return FALSE;

                if (bSetFace)
                {
                    //  Update face pointer
                    new_node->Item->SetFaceAndFile(style, face, fontfile);
                }

                //  Insert before node
                if (node->Prev == NULL)
                {
                    //  Insert at head
                    new_node->Next = node;
                    node->Prev = new_node;
                    Head = new_node;
                }
                else
                {
                    //  Insert between node and prev
                    new_node->Next = node;
                    new_node->Prev = node->Prev;
                    node->Prev->Next = new_node;
                    node->Prev = new_node;
                }
                return TRUE;
            }
            else if (node->Next == NULL)
            {
                //  Add new family node
                FamilyNode *new_node = new FamilyNode(family);
                if (!new_node)
                    return FALSE;

                if (bSetFace)
                {
                        //  Update face pointer

                    new_node->Item->SetFaceAndFile(style, face, fontfile);
                }
                
                //  Insert at tail
                new_node->Prev = node;
                node->Next = new_node;

                return TRUE;
            }
        }
    }

    return result;
}


/**************************************************************************\
*
* Function Description:
*
*   Given a pointer to a font family, remove that font family from the list,
*   but only if its ref count is 0 and its Face pointers are all NULL.
*   The parameter bDeleted is set to TRUE if a GpFontFamily was deleted from
*   the list.
*
* Arguments:
*
*   fontFamily: the font family to be removed
*
* Returns:
*
*   Boolean indicating success
*
* History:
*
*   27/06/1999 cameronb
*       Created it.
*
\**************************************************************************/

BOOL GpFontFamilyList::RemoveFontFamily(GpFontFamily* fontFamily)
{
    FamilyNode *node;

    node = Head;

    while(node)
    {
        if (node->Item == fontFamily)
        {
            if (node->Item->Deletable())
            {
                if (node->Prev)
                    node->Prev->Next = node->Next;
                if (node->Next)
                    node->Next->Prev = node->Prev;

                if (node == Head)
                    Head = node->Next;

                delete node->Item;
                delete node;
                node = NULL;
            }
            else
            {
                // We found the font family, but it's not deletable, so
                // we can quit trying to delete the font family from the list.
                break;
            }
        }
        else
        {
            node = node->Next;
        }
    }
    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*   Create a cache list from GpFontFamily.cacheEntry
*   We will load it when the Family list is touched
*
* Arguments:
*
*   None
*
* Returns:
*
*   None
*
* History:
*
*   27/06/1999 cameronb
*       Created it.
*
\**************************************************************************/

VOID GpFontFamilyList::UpdateFamilyListToCache(BOOL bLoadFromRegistry, HKEY hkey, 
                                ULONG registrySize, ULONG numExpected)
{
    FamilyNode *node;

    UINT                cachedSize = 0;    
    UINT                entrySize = 0;
    GpFontFile *        fontfile;
    GpFontFamily *      family;
    FAMILYCACHEENTRY *  pEntry;
    
    node = Head;

    if (bLoadFromRegistry)
        cachedSize = QWORD_ALIGN(registrySize + 8);

    while(node)
    {
        entrySize = 0;

        // Get the current GpFontFamily from family list
        
        family = node->Item;

        pEntry = family->GetCacheEntry();

        // Here we need to calcuatle the size for each cache entry
        // it include FAMILYCACHEENTRY + fontfilepathname1 + fontfilepathname2
        //   A fmaily could have 1 more font file included
        
        entrySize += QWORD_ALIGN(pEntry->cjThis);

        for (UINT i = 0; i < NumFontFaces; i++)
        {
            
            if (fontfile = family->GetFontFile(i))
            {
                pEntry->cFilePathName[i] = QWORD_ALIGN(fontfile->GetPathNameSize() * 2);
                entrySize += pEntry->cFilePathName[i];                
            }
        }

        cachedSize += entrySize;
        
        node = node->Next;
    }

    BYTE * pCacheEntry = (BYTE *)FontFileCacheAlloc(cachedSize);
    
    if (!pCacheEntry)
    {
        FontFileCacheFault();
        return;
    }

    if (bLoadFromRegistry)
    {
        DWORD   allDataSize = 0;
        ULONG   index = 0;
        LONG    error = ERROR_SUCCESS;
        
        PBYTE   pRegistryData;

        *((ULONG *) pCacheEntry) = 0xBFBFBFBF;
        
        *((ULONG *) (pCacheEntry + 4)) = registrySize;

        pRegistryData = pCacheEntry + 8;

        while (index < numExpected && error != ERROR_NO_MORE_ITEMS && allDataSize < registrySize)
        {
            DWORD   regType = 0;
            DWORD   labelSize = MAX_PATH;
            DWORD   dataSize = MAX_PATH;
            CHAR    label[MAX_PATH];
            BYTE    data[MAX_PATH];

            error = RegEnumValueA(hkey, index, label, &labelSize, NULL, &regType, data, &dataSize);

            if (error == ERROR_NO_MORE_ITEMS)
                break;

            memcpy(pRegistryData, data, dataSize);

            pRegistryData += dataSize;

            allDataSize += dataSize;            

            index ++;
        }

        pCacheEntry += QWORD_ALIGN(registrySize + 8);
    }
       

    node = Head;

    while(node)
    {
        entrySize = 0;


        family = node->Item;

        pEntry = family->GetCacheEntry();

        ASSERT(pEntry->cjThis == sizeof(FAMILYCACHEENTRY));
        
        entrySize = QWORD_ALIGN(pEntry->cjThis);
        
        memcpy((VOID *) pCacheEntry, (VOID *) pEntry, pEntry->cjThis);

        for (UINT i = 0; i < NumFontFaces; i++)
        {

            // cache the font file path name
            if (fontfile = family->GetFontFile(i))
            {
                memcpy((VOID *) (pCacheEntry + entrySize), (VOID *) fontfile->GetPathName(), 
                                fontfile->GetPathNameSize() * 2);
                entrySize += pEntry->cFilePathName[i];                
            }
        }

        ((FAMILYCACHEENTRY *)pCacheEntry)->cjThis = entrySize;

        pCacheEntry += entrySize;
        
        node = node->Next;
    }

    return;
}

/**************************************************************************\
*
* Function Description:
*
*   Create a family list form the cache file
*   
*   
* Arguments:
*
*   NONE
*
* Returns:
*
*   Boolean indicating the list is created successfully or not
*
* History:
*
*   06/28/20000 YungT [Yung-Jen Tony Tsai]
*       Created it.
*
\**************************************************************************/

BOOL GpFontFamilyList::BuildFamilyListFromCache(BOOL bLoadFromRegistry)
{
    ULONG cachedSize = 0;
    ULONG calcSize = 0;
    FAMILYCACHEENTRY * pCacheEntry;
    
    BYTE * pCached= (BYTE *)FontFileCacheLookUp(&cachedSize);

    // We can not get data from cached file
    if (!cachedSize)
        return FALSE;

    if (bLoadFromRegistry)
    {
        ASSERT(!Globals::IsNt);
        
        ULONG registrySize = 0;

        if (*((ULONG *) pCached) != 0xBFBFBFBF)
            return FALSE;

        registrySize = *((ULONG *) (pCached + 4)) ;

    	cachedSize -= QWORD_ALIGN(registrySize + 8);
    	
        pCached += QWORD_ALIGN(registrySize + 8);
	}
    else
    {
        if (*((ULONG *) pCached) == 0xBFBFBFBF)
            return FALSE;
    }

    
    
    FamilyCacheEntry = (BYTE *) GpMalloc(cachedSize);

    if (!FamilyCacheEntry)
        return FALSE;

    memcpy(FamilyCacheEntry, pCached, cachedSize);
    
    while (calcSize < cachedSize) 
    {
        pCacheEntry = (FAMILYCACHEENTRY *) (FamilyCacheEntry + calcSize);

        GpFontFamily * family = new GpFontFamily(pCacheEntry);

        if (family == NULL)
        {
        // Clean up we have created.
            DeleteList();
            
            WARNING(("Error constructing family from cache."))
            
            return FALSE;
        }

        if (!InsertOrdered(family, FontStyleRegular, (GpFontFile *) NULL, 
                           (GpFontFace *) NULL, FALSE))
        {
            WARNING(("Error constructing family from cache."))

            // New GpFontFamily object not used, delete it
            // Something wrong with this case so we need to delete it.
            delete family;

            DeleteList();
            
            return FALSE;
        }
        
        
        calcSize += QWORD_ALIGN(pCacheEntry->cjThis);
    }

    ASSERT(calcSize == cachedSize);
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\family.hpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Abstract:
*
*   Font family
*
* Revision History:
*
*   27/06/1999 cameronb
*       Created it.
*
\**************************************************************************/

#ifndef _GDIPLUSFONTFAMILY_H
#define _GDIPLUSFONTFAMILY_H

#define  NumFontFaces  4

#define  PFF_ENUMERABLE     0x1

#include "fontable.hpp"

class GpFontFace;
class FontFamily;

class GpFamilyFallback;

const UINT FamilyNameMax = 32;

typedef struct _FAMILYCACHEENTRY
{
    UINT        cjThis;
// Cache the data from here
    INT         iFont;

// Cache engine supprt
    UINT        cFilePathName[NumFontFaces];

    WCHAR       Name[FamilyNameMax];        // Captialized Family name
    WCHAR       NormalName[FamilyNameMax];  // Family name

//  Alias name
    WCHAR       FamilyAliasName[FamilyNameMax];         // Captialized FamilyAliasName
    WCHAR       NormalFamilyAliasName[FamilyNameMax];   // FamilyAliasName

    BOOL        bAlias;

// Lang ID for Family name and FamilyAliasName

    LANGID      LangID;
    LANGID      AliasLnagID;

    ULARGE_INTEGER  LastWriteTime[NumFontFaces];

// We need to get a charset to let font select into DC
    BYTE        lfCharset;
} FAMILYCACHEENTRY;

struct FallbackFactory
{
    GpStatus            Create(const GpFontFamily *family);
    void                Destroy();
    GpFamilyFallback    *familyfallback;
};


/*********************************Class************************************\
* class GpFontFamily
*
*       Font family consisiting of pointers to the following font styles:
*       (1) regular
*       (2) italic
*       (3) bold
*       (4) bold italic
*
* History:
*
*   27/06/1999 cameronb created it
*
\**************************************************************************/

class GpFontFamily
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagFontFamily : ObjectTagInvalid;
    }

    // This method is here so that we have a virtual function table so
    // that we can add virtual methods in V2 without shifting the position
    // of the Tag value within the data structure.
    virtual VOID DontCallThis()
    {
        DontCallThis();
    }

public:
    GpFontFamily(const WCHAR *name, GpFontFile * fontfile, INT iFont, FAMILYCACHEENTRY * pCacheEntry, GpFontCollection *fontCollection = NULL);

    GpFontFamily(FAMILYCACHEENTRY * pCacheEntry);

    ~GpFontFamily();

    // If the famly came from a different version of GDI+, its tag
    // will not match, and it won't be considered valid.
    BOOL IsValid() const
    {
    #ifdef _X86_
        // We have to guarantee that the Tag field doesn't move for
        // versioning to work between releases of GDI+.
        ASSERT(offsetof(GpFontFamily, Tag) == 4);
    #endif
    
        ASSERT((Tag == ObjectTagFontFamily) || (Tag == ObjectTagInvalid)); 
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid Font Family");
        }
    #endif

        return (Tag == ObjectTagFontFamily);
    }

// Name has been captialized
    const WCHAR *GetCaptializedName() {return cacheEntry->Name;}

// The original name is not capitalized
    GpStatus GetFamilyName(WCHAR   name[LF_FACESIZE], LANGID  language = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)) const;

    void SetFaceAndFile(INT style, GpFontFace *face, GpFontFile * fontfile);

    GpFontFace *GetFace(INT style) const;

    GpFontFace *GetFaceAbsolute(INT style) const;

    BOOL GpFontFamily::IsFileLoaded(BOOL loadFontFile = TRUE) const;

    GpFontFile * GetFontFile(UINT i) { return FontFile[i]; }

    GpFontCollection *GetFontCollection ()
    {
        return associatedFontCollection;
    }

    BOOL FaceExist(INT style) const
    {
        // Return face for the given style - either the direct face
        // or one which can support this style through simulation.

        if (Face[style&3])
        {
            // Distinct font exists
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }

    GpFamilyFallback *GetFamilyFallback() const
    {
        if (!FamilyFallbackInitialized)
        {
            if (fallback.Create(this) != Ok)
                return NULL;

            FamilyFallbackInitialized = TRUE;
        }

        return  fallback.familyfallback;
    }

    BOOL IsPrivate() const;

    INT     AvailableFaces(void) const;

    BOOL    SupportsLanguage  (INT style, LANGID lang) const;
    BOOL    SupportsCharacters(INT style, WCHAR* str, INT len) const;

    BOOL    IsStyleAvailable             (INT style) const {return GetFace(style) != NULL;}

    UINT16  GetDesignEmHeight            (INT style) const;
    UINT16  GetDesignCellAscent          (INT style) const;
    UINT16  GetDesignCellDescent         (INT style) const;
    UINT16  GetDesignLineSpacing         (INT style) const;
    UINT16  GetDesignUnderscoreSize      (INT style) const;
    INT16   GetDesignUnderscorePosition  (INT style) const;
    UINT16  GetDesignStrikeoutSize       (INT style) const;
    INT16   GetDesignStrikeoutPosition   (INT style) const;


    GpStatus GetFontData(FontStyle style, UINT32 tag, INT* tableSize, BYTE** pjTable);
    void     ReleaseFontData(FontStyle style);

    BOOL    Deletable(); /* the font family can be removed from the font family list */
    BOOL    IncFontFamilyRef(void); /* return false if all the faces are removed */
    void    DecFontFamilyRef(void);

// API support for Family Alias name
    BOOL    IsAliasName() const
    {
        return cacheEntry->bAlias;
    }

    WCHAR * GetAliasName()
    {
        return cacheEntry->bAlias ? cacheEntry->FamilyAliasName : NULL;
    }

    FAMILYCACHEENTRY * GetCacheEntry()
    {
        return cacheEntry;
    }

    VOID ReleaseCacheEntry()
    {

        ASSERT(cacheEntry);

        if (!bLoadFromCache && cacheEntry)
        {
            GpFree(cacheEntry);
            cacheEntry = NULL;
        }
    }

    static GpStatus CreateFontFamilyFromName
                        (const WCHAR *name,
                         GpFontCollection *fontCollection,
                         GpFontFamily **fontFamily);

    static GpStatus GetGenericFontFamilySansSerif
                        (GpFontFamily **nativeFamily);
                         
    static GpStatus GetGenericFontFamilySerif
                        (GpFontFamily **nativeFamily);

    static GpStatus GetGenericFontFamilyMonospace
                        (GpFontFamily **nativeFamily);

// private member function
private:
    BOOL    AreAllFacesRemoved();
    BOOL    WriteToCache();
    BOOL    ReadFromCache();

// private data
private:
    FAMILYCACHEENTRY *  cacheEntry;

// Indicate
    mutable BOOL        bFontFileLoaded;

//  Ref count for FontFamily objects that point to this GpFontFamily
    INT                 cFontFamilyRef;

// GpFontFace
    mutable GpFontFace *Face[NumFontFaces];     // Pointers to instance of each face

// GpFontFile
    mutable GpFontFile *FontFile[NumFontFaces]; // Pointer to font file


    mutable FallbackFactory  fallback;
    mutable BOOL             FamilyFallbackInitialized;
    BOOL                     bLoadFromCache;

    GpFontCollection *  associatedFontCollection; // if NULL, then GpInstalledFontCollection
};


/*********************************Class************************************\
* class GpFontFamilyList
*
*       Handles the enumerated list of font families
*
* History:
*
*   27/06/1999 cameronb created it
*
\**************************************************************************/

class GpFontFamilyList
{
public:

    //  Internal structure for list handling
    struct FamilyNode
    {
        GpFontFamily   *Item;
        FamilyNode     *Prev;
        FamilyNode     *Next;

        FamilyNode(GpFontFamily *family=NULL)
        {
            Item = family;
            Prev = NULL;
            Next = NULL;
        }

    };

public:
    GpFontFamilyList();
    ~GpFontFamilyList();

private:
    void    DeleteList(void);

public:
    INT     Enumerable(GpGraphics* graphics = 0) const;
    Status  Enumerate(INT numSought, GpFontFamily * gpfamilies[], INT& numFound,
                        GpGraphics * graphics = 0) const;

    GpFontFamily* GetFamily(const WCHAR *familyName) const;
    GpFontFamily* GetAnyFamily() const;

    BOOL    AddFont(GpFontFile* fontFile, GpFontCollection *fontCollection);
    BOOL    RemoveFontFamily(GpFontFamily* fontFamily);
    VOID    UpdateFamilyListToCache(BOOL bLoadFromRegistry, HKEY hkey, ULONG registrySize, ULONG numExpected);
    BOOL    BuildFamilyListFromCache(BOOL bLoadFromRegistry);

private:
    BOOL    InsertOrdered(GpFontFamily * family, FontStyle style, GpFontFile * fontfile,
                            GpFontFace * face, BOOL bSetFace);

//      Data members
private:
    FamilyNode*  Head;   //  The enumerated list
    BYTE * FamilyCacheEntry;

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\filetime.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   FileTime.hpp
*
* Abstract:
*
*   Declare the CFILETIME class.  This class wraps the FILETIME
*   structure, and gives it operators and conversion functions
*   (type-cast operators) to make it usable in equations.
*   This class adds no state, so a CFILETIME object is bitwise
*   compatible with a FILETIME object.
*
*   This class is completely inline.  There is no implementation
*   file.
*
* Created:
*
*   4/26/1999 Mike Hillberg
*
\**************************************************************************/

#ifndef _FILETIME_HPP
#define _FILETIME_HPP

#include <tchar.h>  // _tcsftime


class CFILETIME         // cft
{
    //  ------------
    //  Construction
    //  ------------

public:

    CFILETIME()
    {
        SetToUTC();
    }

    CFILETIME( const CFILETIME &cft )
    {
        _ll = cft._ll;
    }

    CFILETIME( const SYSTEMTIME &st )
    {
        SystemTimeToFileTime( &st, &_filetime );
    }

    CFILETIME( const FILETIME &ft )
    {
        _ll = *(LONGLONG*) &ft;
    }

    CFILETIME( const LONGLONG ll )
    {
        _ll = ll;
    }

    CFILETIME( const LARGE_INTEGER &li )
    {
        _li = li;
    }

    CFILETIME( const ULARGE_INTEGER &uli )
    {
        _uli = uli;
    }


    //  --------------------
    //  Conversion Functions
    //  --------------------

public:

    // Convert to a struct _FILETIME
    operator FILETIME () const
    {
        return( _filetime );
    }

    // Convert to a SYSTEMTIME (fails if the current _filetime)
    // is greater than 0x80000000
    operator SYSTEMTIME () const
    {
        SYSTEMTIME st;
        if( !FileTimeToSystemTime( &_filetime, &st ))
        {
            // The current _filetime is negative.
            memset( &st, 0, sizeof(st) );
        }

        return( st );
    }

    operator LARGE_INTEGER () const
    {
        return( _li );
    }

    operator LONGLONG () const
    {
        return( _ll );
    }

    operator ULARGE_INTEGER () const
    {
        return( _uli );
    }

    //  ---------
    //  Operators
    //  ---------

public:

    // Assignment

    CFILETIME &operator= (const CFILETIME &cft)
    {
        _filetime = cft._filetime;
        return (*this);
    }

    // Addition of an offset

    CFILETIME operator+ ( CFILETIME &cft ) const
    {
        return (CFILETIME) ( _ll + cft._ll );
    }
    CFILETIME &operator+= ( CFILETIME &cft )
    {
        _ll += cft._ll;
        return( *this );
    }

    // Subtraction of an offset (note that this can result in a negative
    // number).

    CFILETIME operator- ( CFILETIME &cft ) const
    {
        return (CFILETIME) ( _ll - cft._ll );
    }
    CFILETIME &operator-= ( CFILETIME &cft )
    {
        _ll -= cft._ll;
        return( *this );
    }

    // Comparisson

    BOOL operator== ( const CFILETIME &cft ) const
    {
        return( cft._ll == _ll );
    }

    BOOL operator> ( const CFILETIME &cft ) const
    {
        return( _ll > cft._ll );
    }

    BOOL operator< ( const CFILETIME &cft ) const
    {
        return( _ll < cft._ll );
    }

    BOOL operator>= ( const CFILETIME &cft ) const
    {
        return( *this == cft || *this > cft );
    }

    BOOL operator<= ( const CFILETIME &cft ) const
    {
        return( *this == cft || *this < cft );
    }



    //  -------
    //  Methods
    //  -------

public:

    void IncrementTickCount( DWORD dwTickCount )
    {
        // Add the tick count offset, converted from milliseconds
        // to 100 nanosecond units

        _ll += (LONGLONG) dwTickCount * 10*1000;
    }

    void DecrementTickCount( DWORD dwTickCount )
    {
        _ll -= (LONGLONG) dwTickCount * 10*1000;
    }

    void IncrementSeconds( DWORD dwSeconds )
    {
        _ll += (LONGLONG) dwSeconds * 10*1000*1000;
    }

    void DecrementSeconds( DWORD dwSeconds )
    {
        _ll -= (LONGLONG) dwSeconds * 10*1000*1000;
    }

    void IncrementMilliseconds( DWORD dwMilliseconds )
    {
        _ll += (LONGLONG) dwMilliseconds * 10*1000;
    }

    void DecrementMilliseconds( DWORD dwMilliseconds )
    {
        _ll -= (LONGLONG) dwMilliseconds * 10*1000;
    }

    void SetToUTC()
    {
        SYSTEMTIME st;
        GetSystemTime( &st );
        SystemTimeToFileTime( &st, (FILETIME*) this );
    }

    void SetToLocal()
    {
        SYSTEMTIME st;
        GetLocalTime( &st );
        SystemTimeToFileTime( &st, (FILETIME*) this );
    }

    // Convert from UTC to Local.  A time of zero, though, converts to zero.
    CFILETIME ConvertUtcToLocal() const
    {
        CFILETIME cftLocal(0);

        if( cftLocal == *this
            ||
            !FileTimeToLocalFileTime( &_filetime, reinterpret_cast<FILETIME*>(&cftLocal) ))
        {
            cftLocal = 0;
        }

        return( cftLocal );
    }

    DWORD HighDateTime() const
    {
        return( _filetime.dwHighDateTime );
    }

    DWORD LowDateTime() const
    {
        return( _filetime.dwLowDateTime );
    }

    // Format the time to a string using a strftime format string.
    // The time is not converted to local or wrt daylight savings
    // Cannot handle times before 1/1/1900.
    void Format( ULONG cch, TCHAR *ptszResult, const TCHAR *ptszFormat ) const
    {
        struct tm tm;
        SYSTEMTIME st = static_cast<SYSTEMTIME>(*this);

        memset( &tm, 0, sizeof(tm) );
        tm.tm_sec   = st.wSecond;
        tm.tm_min   = st.wMinute;
        tm.tm_hour  = st.wHour;
        tm.tm_mday  = st.wDay;
        tm.tm_mon   = st.wMonth - 1;        // tm_mon is 0 based
        tm.tm_year  = st.wYear - 1900;      // tm_year is 1900 based
        tm.tm_isdst = 0;                    // This method does no time zone conversion
        tm.tm_wday  = st.wDayOfWeek;

        if( 0 == _tcsftime( ptszResult, cch, ptszFormat, &tm ))
            ptszResult[0] = TEXT('\0');
    }

    // Default string-ization
    void Stringize( ULONG cch, TCHAR *ptsz ) const
    {
        // E.g. "Sunday, 3/22/98, 13:30:22"
        Format( cch, ptsz, TEXT("%a, %m/%d/%y, %H:%M:%S") );
    }


    //  ------------
    //  Data Members
    //  ------------

private:

    union
    {
        FILETIME _filetime;
        LONGLONG _ll;
        LARGE_INTEGER _li;
        ULARGE_INTEGER _uli;
    };

};

#endif // #ifndef _FILETIME_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\fasttext.hpp ===
/////   FastTextImager
//
//      Handles common case string measurement and display



const INT FAST_TEXT_PREALLOCATED_CHARACTERS = 64;

typedef AutoBuffer<UINT16, FAST_TEXT_PREALLOCATED_CHARACTERS> Uint16StackBuffer;
typedef AutoBuffer<INT,    FAST_TEXT_PREALLOCATED_CHARACTERS> IntStackBuffer;


class FastTextImager
{
public:
    GpStatus Initialize(
        GpGraphics            *graphics,
        const WCHAR           *string,
        INT                    length,
        const RectF           &layoutRectangle,
        const GpFontFamily    *family,
        INT                    style,
        REAL                   emSize,   // Preconverted to world units
        const GpStringFormat  *format,
        const GpBrush         *brush
    );

    GpStatus MeasureString(
        RectF *boundingBox,
        INT   *codepointsFitted,
        INT   *linesFilled
    );

    GpStatus DrawString();

private:
    GpStatus RemoveHotkeys();

    GpStatus FastLayoutString();

    GpStatus DrawFontStyleLine(
        const PointF    *baselineOrigin,    // base line origin in device unit
        REAL            baselineLength,     // base line length in device unit
        INT             style               // font styles
    );

    void FastAdjustGlyphPositionsProportional(
        IN   const INT       *hintedWidth,            // 28.4  device
        OUT  INT             *x,                      // 28.4  device Initial x
        OUT  IntStackBuffer  &dx,                     // 32.0  device Glyph advances
        OUT  const UINT16   **displayGlyphs,          // First displayable glyph
        OUT  INT             *displayGlyphCount,
        OUT  INT             *leadingBlankCount
    );

    void GetWorldTextRectangleOrigin(
        PointF &origin
    );

    void GetDeviceBaselineOrigin(
        IN   GpFaceRealization  &faceRealization,
        OUT  PointF             &origin
    );

    GpStatus FastDrawGlyphsGridFit(
        GpFaceRealization  &faceRealization
    );

    GpStatus FastDrawGlyphsNominal(
        GpFaceRealization  &faceRealization
    );


    // Initialisation parameters

    GpGraphics            *Graphics;
    const UINT16          *String;
    INT                    Length;  // Measured, if necessary
    RectF                  LayoutRectangle;
    const GpFontFamily    *Family;
    INT                    Style;
    REAL                   EmSize;  // In world units
    const GpStringFormat  *Format;
    const GpBrush         *Brush;


    // Derived. All are set if Initialize succeeds

    INT               FormatFlags;
    StringAlignment   Alignment;
    GpFontFace       *Face;
    GpMatrix          WorldToDevice;
    REAL              LeftMargin;
    REAL              RightMargin;
    INT               OverflowAvailable;   // Available for advance width expansion 32.0
    REAL              LeftOffset;          // Allowance to reduce adjustment
    INT               GlyphCount;
    REAL              TotalWorldAdvance;
    GpMatrix          FontTransform;
    REAL              LineLengthLimit;
    REAL              WorldToDeviceX;
    REAL              WorldToDeviceY;
    UINT16            BlankGlyph;
    UINT16            DesignEmHeight;
    REAL              CellHeight;
    INT               NominalToBaselineScale;   // 16.16
    TextRenderingHint TextRendering;
    INT               HotkeyPosition;


    // Auto buffers common to drawing and measurement

    AutoBuffer<UINT16, FAST_TEXT_PREALLOCATED_CHARACTERS> Glyphs;
    AutoBuffer<UINT16, FAST_TEXT_PREALLOCATED_CHARACTERS> NominalWidths; // 16.0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\facerealization.hpp ===
#ifndef _FACEREALIZATION_
#define _FACEREALIZATION_

#define GLYPHDATABLOCKCOUNT 16
#define MAXRECENTLYUSEDCOUNT 32

#define EMPTY_GLYPH_FFFF 0xFFFF   // Display nothing, neither ink nor width.


// Typedefs for cached funtion pointers in GpFaceRealization.
class GpFaceRealization;

/* used in aatext.cxx and facerealization.cpp : */
#define CJ_CTGD(cx,cy) (ALIGN4(offsetof(GLYPHBITS,aj)) + ALIGN4((cx) * (cy)))
#define ALIGN4(X) (((X) + 3) & ~3)
#define ALIGN(object, p) p =    (p + ((UINT)sizeof(object) - 1)) & ~((UINT)sizeof(object) - 1);


inline BOOL IsGridFittedTextRealizationMethod(TextRenderingHint method)
{
    switch (method)
    {
    case TextRenderingHintSingleBitPerPixelGridFit:
    case TextRenderingHintAntiAliasGridFit:
    case TextRenderingHintClearTypeGridFit:
        return TRUE;

    default:
        return FALSE;
    }
}


/////   GpGlyphMetrics
//
//      Metrics for text handling and glyph placement.
//      There are separate records for horizontal and vertical baselines.

struct GpGlyphMetrics {

    // Metrics along baseline in 28.4

    INT     AdvanceWidth;
    INT     LeadingSidebearing;
    INT     TrailingSidebearing;
    PointF  Origin;   // Float
};

struct GpGlyphAABits
{
    GpGlyphAABits * Next;
    ULONG           X, Y;
    BYTE            Bits[1];    // variable size
};

struct GpGlyphData {
    GpGlyphMetrics      GlyphMetrics[2];          // one for horizontal metrics  and one for vertical metrics
    union {
        GLYPHBITS     *GlyphBits;                 // Same as GDI structure at this moment
        GpGlyphPath   *GlyphPath;
        GpGlyphAABits *GlyphAABits;     // null terminated singly-linked list
    };
};

struct GlyphDataBlock
{
    GlyphDataBlock  *NextGlyphDataBlock;
    GpGlyphData      GlyphDataArray[GLYPHDATABLOCKCOUNT];
};

// blocks of memory used to store glyphbits

struct GlyphBitsBlock
{
    GlyphBitsBlock  *NextGlyphBitsBlock;     // next block in the list
    UINT             SizeGlyphBitsBlock;        // Bytes allocated
    BYTE             Bits[1];    // bits
};


////    CacheFaceRealization - cache entries referenced by FaceRealization
//
//



class EXTFONTOBJ
{
public:
    FONTOBJ     fobj;           // pass to DDI, we need to have it to back compatible with GDI
};

enum GpGlyphDataCacheType
{
    CacheBits,
    CachePath,
    CacheAABits
};

class CacheFaceRealization : public EXTFONTOBJ
{
public:

    // New type information

    BOOL                    NoCache;         // Cache type -
    GpGlyphDataCacheType    CacheType;   // bits, path or AA bits
    BOOL                    ForcedPath;   // was this CacheFaceRealization forced to use path because of huge font size

    // claudebe, try to get rid of both, redundant with fontObj flags : should correspond to what is actually realized
    TextRenderingHint   realizationMethod;
    ULONG               QueryFontDataMode;

    // Physical font information (font source).

    const GpFontFace    *Face;           // pointer to physical font entry

    // Font transform information.

    // DDI callback transform object.  A reference to this EXFORMOBJ is passed
    // to the driver so that it can callback XFORMOBJ_ services for the notional
    // to device transform for this font.

    GpMatrix            mxForDDI;       // xoForDDI's matrix

    // cached here upon font realization for fast access

    ULONG               MaxGlyphByteCount; // (MaxGlyphPixelWidth + 7)/8 * MaxGlyphPixelHeight, or at least it should be for 1 bpp
    FD_DEVICEMETRICS    DeviceMetrics;     // Hinted metric indformation

    // Root of per glyph metrics and images

    GpGlyphData         **GlyphDataArray;          // array of pointers to GpGlyphData's

    // CacheFaceRealization linked list for a particular face

    CacheFaceRealization *NextCacheFaceRealization;
    CacheFaceRealization *PreviousCacheFaceRealization;

    // CacheFaceRealization last recently used linked list

    CacheFaceRealization *NextRecentCacheFaceRealization;
    CacheFaceRealization *PreviousRecentCacheFaceRealization;

    // Font cache information.


    GlyphDataBlock  *FirstGlyphDataBlock;      // First block in chain - used for destruction
    GlyphBitsBlock  *FirstGlyphBitsBlock;

    // Info for GlyphDataBlock being constructed

    GlyphDataBlock  *GlyphDataBlockUnderConstruction;
    UINT             NextFreeGlyphDataIndex;     // (All other blocks are already full)

    // Info for GlyphBitBlock under construction

    GlyphBitsBlock  *GlyphBitsBlockUnderConstruction;
    UINT             SizeGlyphBitsBlockUnderConstruction;        // Bytes allocated
    UINT             UsedBytesGlyphBitsBlockUnderConstruction;   // Bytes used

    // Lookaside cache - holds bits or path and metrics for a single glyph, used whern
    // data too big for cache block.

    GpGlyphData     *LookasideGlyphData;                    // Same as GDI structure at this moment

    SIZE_T           LookasideByteCount;      // size of current lookaside buffer


    // claudebe : still need to be updated to use the global cache size limit :

    UINT        cBlocksMax;       // max # of blocks allowed
    UINT        cBlocks;          // # of blocks allocated so far
};






////    FaceRealization
//
//      Represents a font at a given size (?on a given device?)


class GpFaceRealization
{
private:
    mutable CacheFaceRealization  *prface;
    GpStatus                       Status;
    INT                            Style;
    BOOL                           LimitSubpixel;


public:

    // Constructors -- Lock the CacheFaceRealization.

    GpFaceRealization()
    :   prface  (NULL),
        Status  (InvalidParameter)
    {}


    GpFaceRealization(
        const GpFontFace *pface,
        INT               style,
        const GpMatrix   *matrix,
        const SizeF       dpi,
        TextRenderingHint renderMethod,
        BOOL              bPath,
        BOOL              bCompatibleWidth,  /* we want ClearType compatible width when we come from DrawDriverString */
        BOOL              bSideways  /* for far east vertical writing, run of glyph layed out sideways,
                                       used to do the italic simulation in the right direction */
    );

// Destructor -- Unlocks the CacheFaceRealization

   ~GpFaceRealization();

// To clone another GpFaceRealiztion from Bits to Path

    void CloneFaceRealization(
        const GpFaceRealization *  pfaceRealizaton,
        BOOL                bPath
    );

// GetStatus - Called following instantiation to check that construction worked.

    GpStatus GetStatus() const {return Status;}

    INT GetStyle() const
    {

#if DBG
        INT style = 0;

        if (    prface->Face->pifi->fsSelection & FM_SEL_BOLD
            ||  prface->fobj.flFontType         & FO_SIM_BOLD)
        {
            style |= FontStyleBold;
        }

        if (    prface->Face->pifi->fsSelection & FM_SEL_ITALIC
            ||  prface->fobj.flFontType         & FO_SIM_ITALIC_SIDEWAYS
            ||  prface->fobj.flFontType         & FO_SIM_ITALIC)
        {
            style |= FontStyleItalic;
        }

        ASSERT(style == (Style & (FontStyleBold | FontStyleItalic)));
#endif

        return Style;
    }


    BOOL bInit(
        const GpFontFace   *pface,
        INT                 style,
        const GpMatrix     *matrix,
        SizeF               dpi,
        TextRenderingHint   textMode,
        BOOL                bPath,
        BOOL                bCompatibleWidth,  /* we want ClearType compatible width when we come from DrawDriverString */
        BOOL                bSideways  /* for far east vertical writing, run of glyph layed out sideways,
                                          used to do the italic simulation in the right direction */
    );


    // bDelete -- Removes an CacheFaceRealization

    BOOL   DeleteRealizedFace();

    // Reuse an CacheFaceRealization

    BOOL   ReuseRealizedFace();

    // bInitCache -- Initialize the cache

    BOOL   bInitCache() const;
    BOOL   AllocateCache() const;

    // vDeleteCache -- Delete the CACHE from existence.

    VOID   vDeleteCache() const;

    BOOL   noCache() const {return prface->NoCache ;}

    // FindRealizedFace -- check to see whether there is existing realization
    //              on the CacheFaceRealization list in the GpFontFile.

    BOOL FindRealizedFace(
            FD_XFORM            *fdx,
            const GpFontFace    *fontFace,
            BOOL                needPaths,
            FLONG               fl
            ) const;

    // RealizeFont -- Initializer; for IFI, calls driver to realize
    //                 font represented by PFE.

    BOOL Realize(
        SizeF              dpi,
        const GpFontFace  *pfe,
        INT                style,      // style - which may require simulation
        PFD_XFORM          pfdx,       // font xform (Notional to Device)
        FLONG              fl,         // these two really modify the xform
        BOOL               bNeedPaths
    );

    // Valid -- Returns TRUE if object was successfully locked

    BOOL IsValid ()
    {
        return(prface != 0);
    }

    ULONG QueryFontDataMode() const
    {
        return prface->QueryFontDataMode;
    }

    BOOL bGetDEVICEMETRICS();

    // return the font face for this RFace
    const GpFontFace * GetFontFace() const {return(prface->Face);}

    //  Is it in private font file table or not

    BOOL IsPrivate() const {return prface->Face->IsPrivate();}

    // pfdx -- Return pointer to the notional to device font transform.

    FD_XFORM *pfdx() const {return (&prface->fobj.fdx);}

    // pfo -- Return pointer to the font object

    FONTOBJ *pfo() const {return(&prface->fobj);}

    // kill driver realization of the font, i.e. "FONT CONTEXT" in the old lingo.
    // Method calling DrvDestroyFont before CacheFaceRealization is killed itself.

    VOID vDestroyRealizedFace();

    // vGetCache -- Claims the cache semaphore

    VOID    vGetCache ()
    {
    //    EnterCriticalSection(&prface->FaceRealizationCritSection);
    }

    // vReleaseCache -- Releases the cache semaphore

    VOID    vReleaseCache ()
    {

    if ( prface->LookasideGlyphData != NULL )
        {
            GpFree((PVOID) prface->LookasideGlyphData);
            prface->LookasideByteCount = 0;
            prface->LookasideGlyphData = NULL;
        }

        //    LeaveCriticalSection(&prface->FaceRealizationCritSection);
    }


    ULONG GetGlyphsSupported() const
    {
        if (prface && prface->Face)
        {
            return (prface->Face->NumGlyphs);
        }
        return 0;
    }

    GpStatus GetGlyphStringDeviceAdvanceVector(
        const UINT16  *glyphs,
        INT            glyphCount,
        BOOL           vertical,
        REAL          *deviceAdvances
    ) const;

    GpStatus GetGlyphStringDeviceAdvanceVector(
        const UINT16  *glyphs,
        INT            glyphCount,
        BOOL           vertical,
        INT           *deviceAdvances   // Returned in 28.4
    ) const;

    GpStatus GetGlyphStringIdealAdvanceVector(
        const UINT16  *glyphs,
        INT            glyphCount,
        REAL           deviceToIdeal,
        BOOL           vertical,
        INT           *idealAdvances
    ) const;

    GpStatus GetGlyphStringSidebearings(
        const UINT16  *glyphs,
        INT            glyphCount,
        BOOL           vertical,
        BOOL           reverse,     // For example right-to-left
        INT           *leadingSidebearing,  // 28.4
        INT           *trailingSidebearing  // 28.4
    ) const;

    GpStatus GetGlyphStringVerticalOriginOffsets(
        IN  const UINT16  *glyphs,
        IN  INT            glyphCount,
        OUT PointF        *offsets
    ) const;



    // GetGlyphPath

    GpStatus
    GetGlyphPath(
        const UINT16     glyphIndice,
        GpGlyphPath    **pGlyphPath,
        PointF          *sidewaysOffset
    ) const;


    // GetGlyphPos

    INT GetGlyphPos(
        const INT      cGlyphs,     // How many glyphs Client want to request
        const UINT16  *glyphIndex,  // An array of glyph index
        GpGlyphPos    *pgpos,       // An array of GLYPHPOS
        const PointF  *glyphOrigin, // X,Y positions for sub-pixel calculation
        INT           *cParsed,     // How many glyphs we parsed
        BOOL          sideways      // e.g. FE characters in vertical text
    ) const;


    // Realization mode
    inline TextRenderingHint RealizationMethod() const {return(prface->realizationMethod);}

    // IisPathFont -- Is this a path font?

    inline BOOL IsPathFont() const {return(prface->CacheType == CachePath);}


    VOID FlushCache() const;

    // Construction hack used by GpFaceRealizationTMP during CacheFaceRealization cleanup

    void Setprface(CacheFaceRealization *rface) {prface = rface;}
    CacheFaceRealization *Getprface() const {return prface;}


    INT  GetXMin()               const {return prface->DeviceMetrics.xMin;};
    INT  GetXMax()               const {return prface->DeviceMetrics.xMax;};
    INT  GetYMin()               const {return prface->DeviceMetrics.yMin;};
    INT  GetYMax()               const {return prface->DeviceMetrics.yMax;};
    BOOL IsHorizontalTransform() const {return prface->DeviceMetrics.HorizontalTransform;};
    BOOL IsVerticalTransform()   const {return prface->DeviceMetrics.VerticalTransform;};
    BOOL IsFixedPitch()          const {return (prface->Face->pifi->flInfo & FM_INFO_OPTICALLY_FIXED_PITCH);};

    BOOL GetLimitSubpixel() { return LimitSubpixel; }
    void SetLimitSubpixel(BOOL limitSubpixel) { LimitSubpixel = limitSubpixel; }

private:

    GpStatus CheckGlyphStringMetricsCached(const UINT16 *glyphs, INT glyphCount) const;



    // vInsert -- Insert this CacheFaceRealization onto the head of an CacheFaceRealization doubly linked list.

    VOID vInsert (CacheFaceRealization **pprfaceHead);

    // vRemove -- Remove this CacheFaceRealization from an CacheFaceRealization doubly linked list.

    VOID vRemove (CacheFaceRealization **pprfaceHead);

    // Access to cached glyph data

    GpGlyphData *GetGlyphDataCached(UINT16 glyphIndex, BOOL   allowFlush) const;

    GpGlyphData *GetGlyphDataLookaside(UINT16 glyphIndex) const;


    BOOL CheckMetricsCache() const;
    VOID *pgbCheckGlyphCache(SIZE_T cjNeeded) const;


    VOID ConvertGLYPHDATAToGpGlyphMetrics(
        IN   INT           glyphIndex,
        IN   GLYPHDATA    *pgd,
        OUT  GpGlyphData  *pgpgd
    ) const;

    GpStatus IsMetricsCached(UINT16 glyph, ULONG * pcjNeeded) const;

    BOOL InsertGlyphBits(UINT16 glyph, ULONG cjNeeded, BOOL  bFlushOk) const;
    BOOL InsertGlyphPath(UINT16 glyph, BOOL allowFlush) const;

    // bMatchFDXForm -- Is pfdx identical to current font xform?

    inline BOOL MatchFDXForm(FD_XFORM *pfdx) const
    {
        return(!memcmp((PBYTE)pfdx, (PBYTE)&prface->fobj.fdx, sizeof(FD_XFORM)));
    }


    // Calculating sub-pixel position
    BOOL GetAAGlyphDataCached(
        UINT16  glyphIndex,
        GpGlyphPos * pgpos,
        BOOL    allowFlush,
        INT     x,
        INT     y,
        BOOL    sideways        // e.g. FE characters in vertical text
    ) const;
};


class GpFaceRealizationTMP : public GpFaceRealization
{
public:
    GpFaceRealizationTMP(CacheFaceRealization *_prface) {Setprface(_prface);}
    ~GpFaceRealizationTMP()             {Setprface(NULL);}
};



class GpCacheFaceRealizationList
{
public:
    GpCacheFaceRealizationList() { head = NULL; count = 0; }
    ~GpCacheFaceRealizationList();

    void AddMostRecent(CacheFaceRealization *prface);

    void RemoveFace(CacheFaceRealization *prface);

    CacheFaceRealization *ReuseLeastRecent (void);

    INT GetCount() {return count; }

private:
    CacheFaceRealization *head;
    INT count;
};


#endif // __FACEREALIZATION__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\fontable.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Abstract:
*
*   Font table and font loading operations
*
* Revision History:
*
*   23/06/1999 cameronb
*       Created it.
*
\**************************************************************************/

#ifndef GP_FONT_TABLE_DEFINED
#define GP_FONT_TABLE_DEFINED

class GpFontFile;
class GpFontFamily;
class GpFontFamilyList;
class FontFamily;

/*********************************Class************************************\
* class GpFontTable
*
*	Font table for GpFontFile objects
*
* History:
*   11/12/99 YungT modify it.
*   23/06/1999 cameronb created it
*
\**************************************************************************/

class GpFontTable
{
public:
    GpFontTable();
    ~GpFontTable();

    BOOL IsValid()   
    { 
        return (Table && EnumList); 
    }
    
    BOOL UnloadFontFiles(GpFontFile* fontFile);
    
    GpStatus AddFontFile(const WCHAR* fileName, GpFontCollection *fontCollection);
    GpFontFile * AddFontFile(WCHAR* fileName);
                            
    GpStatus AddFontMemImage(const BYTE* fontMemoryImage, INT   fontImageSize,
                              GpFontCollection *fontCollection);
                                    
    GpStatus RemoveFontFile(const WCHAR* filename);

    GpFontFamily* GetFontFamily(const WCHAR* familyName);
    GpFontFamily* GetAnyFamily();

    INT EnumerableFonts(GpGraphics* graphics = 0);
    
    GpStatus EnumerateFonts(INT numSought, GpFontFamily* gpfamilies[],
                               INT& numFound, GpGraphics* graphics = 0);
    
    void LoadAllFonts(const WCHAR *familyName = NULL); 

    GpFontFile* GetFontFile(const WCHAR* fileName) const;

    UINT GetNumFilesLoaded(void) const
    { 
        return NumFilesLoaded; 
    }
    
    BOOL IsPrivate()
    {
        return bPrivate;
    }
    
    void SetPrivate(BOOL bTable) 
    { 
        bPrivate = bTable;
    }

    BOOL IsFontLoaded()
    {
        return bFontFilesLoaded;
    }
    
    void SetFontFileLoaded(BOOL bLoaded) 
    { 
        bFontFilesLoaded = bLoaded;
    }
   
private:    
    UINT        HashIt(const WCHAR* str) const;

    GpFontFile* GetFontFile(const WCHAR* fileName, UINT hash) const;
    void        LoadAllFontsFromRegistry(BOOL bLoadFromRegistry);
    void        LoadAllFontsFromCache(BOOL bLoadFromRegistry);
    void        UpdateCacheFileFromFontTable(void);

public:
    static  ULONG MemImageUnique;

//	Data members
private:
    UINT                NumFilesLoaded;         // Number of files loaded into Table
    UINT                NumHashEntries;         // Number of possible hash entries
    GpFontFile**        Table;                  // The table
    GpFontFamilyList*   EnumList;               // Sorted enumeration list
    BOOL                bPrivate;               // indicate the files in table are private or public
    BOOL                bFontFilesLoaded;       // indicacte the font file loaded    
};


inline ULONG GetNewMemImageUniqueness(ULONG &ulUnique)
{
    InterlockedIncrement((LPLONG)&ulUnique);
    return ulUnique;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\font.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   font.cpp
*
* Revision History:
*
*   Aug/12/1999 Xudong Wu [tessiew]
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

const DOUBLE PI = 3.1415926535897932384626433832795;

#if DBG
#include <mmsystem.h>
#endif

//
//  Masks for supported code pages in the font
//

#define Latine1CodePageMask                     0x0000000000000001
#define Latine2CodePageMask                     0x0000000000000002
#define CyrillicCodePageMask                    0x0000000000000004
#define GreekCodePageMask                       0x0000000000000008
#define TurkishCodePageMask                     0x0000000000000010
#define HebrewCodePageMask                      0x0000000000000020
#define ArabicCodePageMask                      0x0000000000000040
#define BalticCodePageMask                      0x0000000000000080
#define Reserved1CodePageMask                   0x000000000000FF00
#define ThaiCodePageMask                        0x0000000000010000
#define JapanCodePageMask                       0x0000000000020000
#define ChineseCodePageMask                     0x0000000000040000
#define KoreanCodePageMask                      0x0000000000080000
#define TraditionalChineseCodePageMask          0x0000000000100000
#define KoreanJohabCodePageMask                 0x0000000000200000
#define Reserved2CodePageMask                   0x000000001FC00000
#define MacintoshPageMask                       0x0000000020000000
#define OEMCodePageMask                         0x0000000040000000
#define SymbolCodePageMask                      0x0000000080000000
#define Reserved3CodePageMask                   0x0000FFFF00000000
#define IBMGreekCodePageMask                    0x0001000000000000
#define RussianMsDosCodePageMask                0x0002000000000000
#define NordicCodePageMask                      0x0004000000000000
#define ArabicMsDosCodePageMask                 0x0008000000000000
#define CanandianMsDosCodePageMask              0x0010000000000000
#define HebrewMsDosCodePageMask                 0x0020000000000000
#define IcelandicMsDosCodePageMask              0x0040000000000000
#define PortugueseMsDosCodePageMask             0x0080000000000000
#define IBMTurkishCodePageMask                  0x0100000000000000
#define IBMCyrillicCodePageMask                 0x0200000000000000
#define Latin2MsDosCodePageMask                 0x0400000000000000
#define BalticMsDosCodePageMask                 0x0800000000000000
#define Greek437CodePageMask                    0x1000000000000000
#define ArabicAsmoCodePageMask                  0x2000000000000000
#define WeLatinCodePageMask                     0x4000000000000000
#define USCodePageMask                          0x8000000000000000


/////   Create fonts from DC and optional ANSI or Unicode logfont
//
//

GpFont::GpFont(
    REAL                 size,
    const GpFontFamily  *family,
    INT                  style,
    Unit                 unit
) :
        Family   (family),
        EmSize   (size),
        Style    (style),
        SizeUnit (unit)
{
    SetValid(TRUE);     // default is valid

    if (!(Family && Family->IsFileLoaded()))
        Family = NULL;
}

GpFont::GpFont(
    HDC hdc
)
{
    SetValid(TRUE);     // default is valid

    // intialize it as invalid
    Family = NULL;
    InitializeFromDc(hdc);
}



GpFont::GpFont(
    HDC       hdc,
    LOGFONTW *logfont
)
{
    SetValid(TRUE);     // default is valid

    HFONT hOldFont = NULL;
    // intialize it as invalid
    Family = NULL;

    if (!hdc)
        return;

    HFONT hFont = CreateFontIndirectW(logfont);

    if (!hFont) return;

    hOldFont = (HFONT) SelectObject(hdc, hFont);

    InitializeFromDc(hdc);

    if (!hOldFont)
        return;

    DeleteObject(SelectObject(hdc, hOldFont));
}


GpFont::GpFont(
    HDC       hdc,
    LOGFONTA *logfont
)
{
    SetValid(TRUE);     // default is valid

    HFONT hOldFont = NULL;
    // intialize it as invalid
    Family = NULL;

    if (!hdc)
        return;

    HFONT hFont = CreateFontIndirectA(logfont);

    if (!hFont)
        return;

    hOldFont = (HFONT) SelectObject(hdc, hFont);

    InitializeFromDc(hdc);

    if (!hOldFont)
        return;

    DeleteObject(SelectObject(hdc, hOldFont));
}


VOID GpFont::InitializeFromDc(
    HDC hdc
)
{
    WCHAR faceName[LF_FACESIZE];
    GpFontTable *fontTable;

    fontTable = (GpInstalledFontCollection::GetGpInstalledFontCollection())->GetFontTable();

    if (!fontTable->IsValid())
        return;

    if (!fontTable->IsPrivate() && !fontTable->IsFontLoaded())
        fontTable->LoadAllFonts();

    if (Globals::IsNt) {
        TEXTMETRICW tmw;

        if (!GetTextMetricsW(hdc, &tmw)) {
            return;
        }

        GetTextFaceW(hdc, LF_FACESIZE, faceName);

        EmSize = REAL(tmw.tmHeight-tmw.tmInternalLeading);

        Style = FontStyleRegular;
        if (tmw.tmWeight > 400)  {Style |= FontStyleBold;}
        if (tmw.tmItalic)        {Style |= FontStyleItalic;}
        if (tmw.tmUnderlined)    {Style |= FontStyleUnderline;}
        if (tmw.tmStruckOut)     {Style |= FontStyleStrikeout;}
    }
    else
    {
        TEXTMETRICA tma;

        if (!GetTextMetricsA(hdc, &tma)) {
            return;
        }

        char faceNameA[LF_FACESIZE];
        GetTextFaceA(hdc, LF_FACESIZE, faceNameA);
        AnsiToUnicodeStr(faceNameA, faceName, LF_FACESIZE);

        EmSize = REAL(tma.tmHeight-tma.tmInternalLeading);

        Style = FontStyleRegular;
        if (tma.tmWeight > 400)  {Style |= FontStyleBold;}
        if (tma.tmItalic)        {Style |= FontStyleItalic;}
        if (tma.tmUnderlined)    {Style |= FontStyleUnderline;}
        if (tma.tmStruckOut)     {Style |= FontStyleStrikeout;}
    }

    if (faceName[0] == L'@')
        UnicodeStringCopy(&faceName[0], &faceName[1]);


    Family = fontTable->GetFontFamily(faceName);

    if (Family == NULL)
    {
        GetFamilySubstitution(faceName, (GpFontFamily **) &Family);
    }

    if (!(Family && Family->IsFileLoaded()))
        Family = NULL;

    SizeUnit = UnitWorld;
}



GpStatus GpFont::GetLogFontA(
    GpGraphics * g,
    LOGFONTA * lfa
)
{
    PointF   scale;
    REAL     rotateRadians;
    REAL     shear;
    PointF   translate;
    GpMatrix worldToDevice;

    g->GetWorldToDeviceTransform(&worldToDevice);


    SplitTransform(
        worldToDevice,
        scale,
        rotateRadians,
        shear,
        translate);

    INT rotateDeciDegrees = 3600 - (INT) (rotateRadians * 1800 / PI);

    if (rotateDeciDegrees == 3600)
        rotateDeciDegrees = 0;

    REAL emHeight = EmSize * scale.Y * g->GetScaleForAlternatePageUnit(SizeUnit);

    lfa->lfHeight = -GpRound(emHeight);
    lfa->lfWidth = 0;
    lfa->lfEscapement = rotateDeciDegrees;
    lfa->lfOrientation = rotateDeciDegrees;
    lfa->lfWeight = Style & FontStyleBold   ? 700 : 400;
    lfa->lfItalic = Style & FontStyleItalic ? 1 : 0;
    lfa->lfUnderline = Style & FontStyleUnderline ? 1 : 0;
    lfa->lfStrikeOut = Style & FontStyleStrikeout ? 1 : 0;
    lfa->lfCharSet = (((GpFontFamily *)Family)->GetFace(Style))->GetCharset(g->GetHdc());
    lfa->lfOutPrecision = 0;
    lfa->lfClipPrecision = 0;
    lfa->lfQuality = 0;
    lfa->lfPitchAndFamily = 0;


    UnicodeToAnsiStr((WCHAR*)( (BYTE*)(((GpFontFamily *)Family)->GetFace(Style))->pifi +
                                (((GpFontFamily *)Family)->GetFace(Style))->pifi->dpwszFamilyName),
                               lfa->lfFaceName, LF_FACESIZE);

    // Do we need to have a scale value for width????
    // We still need to think about it.


    return Ok;
}

GpStatus GpFont::GetLogFontW(
    GpGraphics * g,
    LOGFONTW * lfw)
{
    PointF   scale;
    REAL     rotateRadians;
    REAL     shear;
    PointF   translate;
    GpMatrix worldToDevice;

    g->GetWorldToDeviceTransform(&worldToDevice);

    SplitTransform(
        worldToDevice,
        scale,
        rotateRadians,
        shear,
        translate);

    INT rotateDeciDegrees = 3600 - (INT) (rotateRadians * 1800 / PI);

    if (rotateDeciDegrees == 3600)
        rotateDeciDegrees = 0;

    REAL emHeight = EmSize * scale.Y * g->GetScaleForAlternatePageUnit(SizeUnit);

    lfw->lfHeight = -GpRound(emHeight);
    lfw->lfWidth = 0;
    lfw->lfEscapement = rotateDeciDegrees;
    lfw->lfOrientation = rotateDeciDegrees;
    lfw->lfWeight = Style & FontStyleBold   ? 700 : 400;
    lfw->lfItalic = Style & FontStyleItalic ? 1 : 0;
    lfw->lfUnderline = Style & FontStyleUnderline ? 1 : 0;
    lfw->lfStrikeOut = Style & FontStyleStrikeout ? 1 : 0;

    ASSERT(((GpFontFamily *)Family)->GetFace(Style));
    lfw->lfCharSet = (((GpFontFamily *)Family)->GetFace(Style))->GetCharset(g->GetHdc());

    lfw->lfOutPrecision = 0;
    lfw->lfClipPrecision = 0;
    lfw->lfQuality = 0;
    lfw->lfPitchAndFamily = 0;


    memcpy(lfw->lfFaceName, (WCHAR*)( (BYTE*)(((GpFontFamily *)Family)->GetFace(Style))->pifi +
                            (((GpFontFamily *)Family)->GetFace(Style))->pifi->dpwszFamilyName),
           sizeof(lfw->lfFaceName));


    return Ok;
}

/**************************************************************************\
*
*
* Revision History:
*
*   02/11/1999 YungT
*       Created it.
*
\**************************************************************************/

int CALLBACK GpFontFace::EnumFontFamExProcW(
  const ENUMLOGFONTEXW   *lpelfe,    // pointer to logical-font data
  const NEWTEXTMETRICEXW *lpntme,    // pointer to physical-font data
  int                     FontType,  // type of font
  LPARAM                  lParam     // application-defined data
)
{
    if (FontType == TRUETYPE_FONTTYPE)
    {
        (*(BYTE *) lParam) = lpelfe->elfLogFont.lfCharSet;

        return 0;
    }
    else
    {
        return 1;   // Don't stop!
    }
}


/**************************************************************************\
*
*
* Revision History:
*
*   02/11/1999 YungT
*       Created it.
*
\**************************************************************************/

int CALLBACK GpFontFace::EnumFontFamExProcA(
  const ENUMLOGFONTEXA   *lpelfe,    // pointer to logical-font data
  const NEWTEXTMETRICEXA *lpntme,    // pointer to physical-font data
  int                     FontType,  // type of font
  LPARAM                  lParam     // application-defined data
)
{
    if (FontType == TRUETYPE_FONTTYPE)
    {
        (*(BYTE *) lParam) = lpelfe->elfLogFont.lfCharSet;

        return 0;
    }
    else
    {
        return 1;   // Don't stop!
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Get the charset from GDI
*
* Arguments:
*
*   We need it for we need to select a logfont into DC. Or
*   Convert a GpFont to LOGFONT
*
* Returns:
*
*       BYTE value of charset
*
* History:
*
*   02/11/2000 YungT
*       Created it.
*
\**************************************************************************/

BYTE GpFontFace::GetCharset(HDC hDc) const
{
    if (lfCharset == DEFAULT_CHARSET)
    {
        if (Globals::IsNt) {

            LOGFONTW lfw = {
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                DEFAULT_CHARSET,       // charset
                0,
                0,
                0,
                0,
                L""
            };

            memcpy(lfw.lfFaceName, (WCHAR*)( (BYTE*)pifi + pifi->dpwszFamilyName),
                    sizeof(lfw.lfFaceName));

            EnumFontFamiliesExW(hDc, &lfw, (FONTENUMPROCW) EnumFontFamExProcW, (LPARAM) &lfCharset, 0);
        }
        else
        {
            // ANSI version for Win9X

            LOGFONTA lfa = {
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                DEFAULT_CHARSET,       // charset
                0,
                0,
                0,
                0,
                ""
            };

            UnicodeToAnsiStr((WCHAR*)( (BYTE*)pifi + pifi->dpwszFamilyName),
                                        lfa.lfFaceName, LF_FACESIZE);

            EnumFontFamiliesExA(hDc, &lfa, (FONTENUMPROCA) EnumFontFamExProcA, (LPARAM) &lfCharset, 0);
        }
    }

    return lfCharset;
}

/////   InitializeImagerTables
//
//      Load character to glyph map and design advance widths

static inline
UINT16 byteSwapUINT16(UINT16 u)
{
    return    ((u & 0x00FF) << 8)
           |  ((u & 0xFF00) >> 8);
}


#pragma pack(push, 1)

struct HheaTable {

    // NOTE: all fields are stored in Big Endian (Motorola) ordering

    UINT32 version;                 // Table version number 0x00010000 for version 1.0.
    INT16  Ascender;                // Typographic ascent.
    INT16  Descender;               // Typographic descent.
    INT16  LineGap;                 // Typographic line gap. Negative LineGap values are
                                    // treated as zero in Windows 3.1, System 6, and System 7.
    UINT16 advanceWidthMax;         // Maximum advance width value in 'hmtx' table.
    INT16  minLeftSideBearing;      // Minimum left sidebearing value in 'hmtx' table.
    INT16  minRightSideBearing;     // Minimum right sidebearing value; calculated as Min(aw - lsb - (xMax - xMin)).
    INT16  xMaxExtent;              // Max(lsb + (xMax - xMin)).
    INT16  caretSlopeRise;          // Used to calculate the slope of the cursor (rise/run); 1 for vertical.
    INT16  caretSlopeRun;           // 0 for vertical.
    INT16  reserved1;               // set to 0
    INT16  reserved2;               // set to 0
    INT16  reserved3;               // set to 0
    INT16  reserved4;               // set to 0
    INT16  reserved5;               // set to 0
    INT16  metricDataFormat;        // 0 for current format.
    UINT16 numberOfHMetrics;        // Number of hMetric entries in 'hmtx' table; must be equal to the CharStrings INDEX count in the 'CFF ' table.
};

struct VheaTable {

    // NOTE: all fields are stored in Big Endian (Motorola) ordering

    UINT32 version;             // Version number of the vertical header table (0x00010000 for the initial version).
    INT16  ascent;              // Distance in FUnits from the centerline to the previous line's descent.
    INT16  descent;             // Distance in FUnits from the centerline to the next line's ascent.
    INT16  lineGap;             // Reserved; set to 0
    INT16  advanceHeightMax;    // The maximum advance height measurement -in FUnits found in the font.
                                // This value must be consistent with the entries in the vertical metrics table.
    INT16  minTop;              // SideBearing The minimum top sidebearing measurement found in the font, in FUnits.
                                // This value must be consistent with the entries in the vertical metrics table.
    INT16  minBottom;           // SideBearing The minimum bottom sidebearing measurement found in the font, in FUnits.
                                // This value must be consistent with the entries in the vertical metrics table.
    INT16  yMaxExtent;          // Defined as yMaxExtent=minTopSideBearing+(yMax-yMin)
    INT16  caretSlopeRise;      // The value of the caretSlopeRise field divided by the value of the caretSlopeRun Field
                                // determines the slope of the caret. A value of 0 for the rise and a value of 1 for the
                                // run specifies a horizontal caret. A value of 1 for the rise and a value of 0 for the
                                // run specifies a vertical caret. Intermediate values are desirable for fonts whose
                                // glyphs are oblique or italic. For a vertical font, a horizontal caret is best.
    INT16  caretSlopeRun;       // See the caretSlopeRise field. Value=1 for nonslanted vertical fonts.
    INT16  caretOffset;         // The amount by which the highlight on a slanted glyph needs to be shifted away from
                                // the glyph in order to produce the best appearance. Set value equal to 0 for nonslanted fonts.
    INT16  reserved1;           // Set to 0.
    INT16  reserved2;           // Set to 0.
    INT16  reserved3;           // Set to 0.
    INT16  reserved4;           // Set to 0.
    INT16  metricDataFormat;    // Set to 0.
    UINT16 numOfLongVerMetrics; // Number of advance heights in the vertical metrics table; must be equal to the
                                // CharStrings INDEX count field in the 'CFF ' table.
};

#pragma pack(pop)


GpStatus GpFontFace::GetFontData(UINT32 tag, INT* tableSize, BYTE** pjTable) const
{
    GpStatus status = Ok;
    ULONG  cjTable;

    if (ttfdSemGetTrueTypeTable (pff->hff, iFont, tag, pjTable, &cjTable) == FD_ERROR)
    {
        return GenericError;
    }
    *tableSize = cjTable;

    return status;
}


void GpFontFace::ReleaseFontData() const
{
    ttfdSemReleaseTrueTypeTable (pff->hff);
}



/////   GetGlyphDesignAdvances
//
//      Returns advance widths along or perpendicular to baseline in
//      font design units.


void GpFontFace::GetGlyphDesignAdvances(
    const UINT16  *glyphs,     // In
    INT            glyphCount, // In
    INT            style,      // In  - causes adjustment for algorithmic style emulation
    BOOL           vertical,   // In  - Use vmtx, not hmtx
    REAL           tracking,   // In  - expansion factor
    UINT16        *advances    // Out
) const
{
    if (vertical)
    {
        if (DesignVerticalAdvance)
        {
            DesignVerticalAdvance->Lookup(glyphs, glyphCount, advances);
        }
        else
        {
            // There's no vmtx - fallback appropriately

            // Win 9x uses the typographic height (typo ascender - typo descender),
            // but NT uses the cell height (cell ascender + cell descender).

            // Which shall we use? The problem with the cell height is that in a
            // multilingual font it may be much taller than the Far East glyphs,
            // causing the common case (Far East vertical text) to appear too
            // widely spaced. The problem with the typographic height is that it
            // includes little or no extra space for diacritic marks.

            // Choice: use the Typographic height: It is best for FE, and the font
            // can fix non FE diacritic cases if it wishes by providing a vmtx.

            for (INT i=0; i<glyphCount; i++)
            {
                advances[i] = pifi->fwdTypoAscender - pifi->fwdTypoDescender;
            }

        }
    }
    else
    {
        DesignAdvance->Lookup(glyphs, glyphCount, advances);

        if (    (style & FontStyleBold)
            &&  !(GetFaceStyle() & FontStyleBold))
        {
            // Algorithmic emboldening increases glyph width

            UINT16 extraAdvance = ((pifi->fwdUnitsPerEm * 2 - 1) / 100);

            for (INT i=0; i<glyphCount; i++)
            {
                if (advances[i] != 0)
                {
                    advances[i] += extraAdvance;
                }
            }
        }

        if (tracking != 1.0)
        {
            for (INT i=0; i<glyphCount; i++)
            {
                advances[i] = static_cast<UINT16>(GpRound(advances[i] * tracking));
            }
        }
    }
}



/////   GetGlyphDesignAdvancesIdeal
//
//      Returns advance widths along or perpendicular to baseline scaled to
//      ideal units.


void GpFontFace::GetGlyphDesignAdvancesIdeal(
    const UINT16  *glyphs,        // In
    INT            glyphCount,    // In
    INT            style,         // In  - Causes adjustment for algorithmic style emulation
    BOOL           vertical,      // In  - Use vtmx, not htmx
    REAL           designToIdeal, // In  - Scale factor for each advance width
    REAL           tracking,      // In  - Expansion factor
    INT           *advances       // Out
) const
{
    if (vertical)
    {
        if (DesignVerticalAdvance)
        {
            for (INT i=0; i<glyphCount; i++)
            {
                advances[i] = GpRound(TOREAL(DesignVerticalAdvance->Lookup(glyphs[i]) * designToIdeal));
            }
        }
        else
        {
            INT commonVerticalAdvance = GpRound(TOREAL(
                   //(pifi->fwdMacAscender - pifi->fwdMacDescender)
                   pifi->fwdUnitsPerEm
                *  designToIdeal
            ));
            for (INT i=0; i<glyphCount; i++)
            {
                advances[i] = commonVerticalAdvance;
            }
        }
    }
    else
    {
        // Horizontal advance width

        for (INT i=0; i<glyphCount; i++)
        {
            advances[i] = GpRound(TOREAL(DesignAdvance->Lookup(glyphs[i]) * designToIdeal * tracking));
        }

        if (    (style & FontStyleBold)
            &&  !(GetFaceStyle() & FontStyleBold))
        {
            // Algorithmic emboldening increases glyph width

            UINT16 extraAdvance = ((pifi->fwdUnitsPerEm * 2 - 1) / 100);

            for (INT i=0; i<glyphCount; i++)
            {
                if (advances[i] != 0)
                {
                    advances[i] += extraAdvance;
                }
            }
        }
    }
}


BOOL GpFontFace::IsCodePageSupported(UINT codePage)
{
    switch (codePage)
    {
        case 1252:
            return SupportedCodePages & Latine1CodePageMask ? TRUE : FALSE;
            break;

        case 1250:
            return SupportedCodePages & Latine2CodePageMask ? TRUE : FALSE;
            break;

        case 1251:
            return SupportedCodePages & CyrillicCodePageMask ? TRUE : FALSE;
            break;

        case 1253:
            return SupportedCodePages & GreekCodePageMask ? TRUE : FALSE;
            break;

        case 1254:
            return SupportedCodePages & TurkishCodePageMask ? TRUE : FALSE;
            break;

        case 1255:
            return SupportedCodePages & HebrewCodePageMask ? TRUE : FALSE;
            break;

        case 1256:
            return SupportedCodePages & ArabicCodePageMask ? TRUE : FALSE;
            break;

        case 1257:
            return SupportedCodePages & BalticCodePageMask ? TRUE : FALSE;
            break;

        case 874:
            return SupportedCodePages & ThaiCodePageMask ? TRUE : FALSE;
            break;

        case 932:
            return SupportedCodePages & JapanCodePageMask ? TRUE : FALSE;
            break;

        case 936:
            return SupportedCodePages & ChineseCodePageMask ? TRUE : FALSE;
            break;

        case 949:
            return SupportedCodePages & KoreanCodePageMask ? TRUE : FALSE;
            break;

        case 950:
            return SupportedCodePages & TraditionalChineseCodePageMask ? TRUE : FALSE;
            break;

        case 1361:
            return SupportedCodePages & KoreanJohabCodePageMask? TRUE : FALSE;
            break;

        case 869:
            return SupportedCodePages & IBMGreekCodePageMask ? TRUE : FALSE;
            break;

        case 866:
            return SupportedCodePages & RussianMsDosCodePageMask ? TRUE : FALSE;
            break;

        case 865:
            return SupportedCodePages & NordicCodePageMask ? TRUE : FALSE;
            break;

        case 864:
            return SupportedCodePages & ArabicMsDosCodePageMask ? TRUE : FALSE;
            break;

        case 863:
            return SupportedCodePages & CanandianMsDosCodePageMask ? TRUE : FALSE;
            break;

        case 862:
            return SupportedCodePages & HebrewMsDosCodePageMask ? TRUE : FALSE;
            break;

        case 861:
            return SupportedCodePages & IcelandicMsDosCodePageMask ? TRUE : FALSE;
            break;

        case 860:
            return SupportedCodePages & PortugueseMsDosCodePageMask ? TRUE : FALSE;
            break;

        case 857:
            return SupportedCodePages & IBMTurkishCodePageMask ? TRUE : FALSE;
            break;

        case 855:
            return SupportedCodePages & IBMCyrillicCodePageMask ? TRUE : FALSE;
            break;

        case 852:
            return SupportedCodePages & Latin2MsDosCodePageMask  ? TRUE : FALSE;
            break;

        case 775:
            return SupportedCodePages & BalticMsDosCodePageMask ? TRUE : FALSE;
            break;

        case 737:
            return SupportedCodePages & Greek437CodePageMask ? TRUE : FALSE;
            break;

        case 708:
            return SupportedCodePages & ArabicAsmoCodePageMask ? TRUE : FALSE;
            break;

        case 850:
            return SupportedCodePages & WeLatinCodePageMask ? TRUE : FALSE;
            break;

        case 437:
            return SupportedCodePages & USCodePageMask ? TRUE : FALSE;
            break;
    }
    return FALSE;
}


static inline UINT16 MapGetUINT16(UINT16 *p, Status* pStatus)
{
    UINT16 r;
    __try
    {
        r = *p;
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        *pStatus = GenericError;
    }
    return r;
}

BOOL GpFontFace::InitializeImagerTables()
{
    // MissingGlyph Should be initialized before calling Shaping.Create()
    // because it depends on it.

    MissingGlyph = 0;   // !!! Not true for all FE fonts

    // We goining to initialize it correctly in shaping.cpp
    SupportedCodePages = 0;

    // Initialise tables to default values
    Cmap = 0;
    DesignAdvance = 0;

    DesignVerticalAdvance             = NULL;
    DesignTopSidebearing              = NULL;
    MissingGlyph                      = 0;   // !!! Not true for all FE fonts
    BlankGlyph                        = 0;
    RequiresFullText                  = FALSE;
    Shaping.Cache                     = NULL;
    Gsub                              = NULL;
    Mort                              = NULL;
    Gpos                              = NULL;
    Gdef                              = NULL;
    VerticalSubstitutionCount         = 0;
    VerticalSubstitutionOriginals     = NULL;
    VerticalSubstitutionSubstitutions = NULL;

    BYTE * hheaTable = 0;
    INT    hheaLength = 0;

    if (GetFontData('aehh', &hheaLength, &hheaTable) != Ok)
    {
        return FALSE;
    }

    // from now on we can't return early, because we need to release font data in the end of the function
    GpStatus status = Ok;

    Cmap = new IntMap<UINT16>;
    if (!Cmap)
        status = OutOfMemory;
    else
        status = Cmap->GetStatus();

    if (status == Ok)
    {
        DesignAdvance = new IntMap<UINT16>;
        if (!DesignAdvance)
            status = OutOfMemory;
        else
            status = DesignAdvance->GetStatus();
    }
    /// Load CMAP
    //
    //
    if (status == Ok)
    {
        INT    cmapLength = 0;
        BYTE  *cmapTable = 0;

        if (Cmap &&
            GetFontData('pamc', &cmapLength, &cmapTable) == Ok)
        {
            AutoArray<BYTE> cmapCopy(new BYTE [cmapLength]);       // copy of cmap table

            if (!cmapCopy)
                status = OutOfMemory;
            else
                MapCopy (cmapCopy.Get(), cmapTable, cmapLength, &status);

            ReleaseFontData();          // deref cmap

            if (status == Ok)
            {
                bSymbol = FALSE;

                status = ReadCmap(cmapCopy.Get(), cmapLength, Cmap, &bSymbol);

                // !!! Fix up CMAP for special font types here

                // We fallback to Microsoft Sans serif for Arabic scripts which does not have
                // a glyph for Arabic percent sign (before Whistler)
                // We replace its glyph with the Latin precent sign.

                if (status == Ok &&
                    !UnicodeStringCompareCI((PWSTR)((BYTE*)pifi + pifi->dpwszFamilyName),L"Microsoft Sans Serif") &&
                    Cmap->Lookup(0x066A) == 0)
                {
                    status = Cmap->Insert(0x066A, Cmap->Lookup(0x0025));
                }
            }
        }
    }

    /// Load horizontal metrics
    //
    //
    if (status == Ok)
    {
        INT     hmtxLength = 0;
        BYTE    *hmtxTable = 0;

        if (DesignAdvance &&
            GetFontData('xtmh', &hmtxLength, &hmtxTable) == Ok)
        {
            AutoArray<BYTE> hmtxCopy(new BYTE [hmtxLength]);       // copy of hmtx table

            // Copy the hmtx so we can party on it (byte swap for example)

            if (!hmtxCopy)
                status = OutOfMemory;
            else
                MapCopy (hmtxCopy.Get(), hmtxTable, hmtxLength, &status);

            ReleaseFontData();          // deref hmtx

            if (status == Ok)
            {
                UINT16 numberOfHMetrics = MapGetUINT16(
                    &((HheaTable *)hheaTable)->numberOfHMetrics,
                    &status);

                if (status == Ok)
                    status = ReadMtx(
                        hmtxCopy.Get(),
                        hmtxLength,
                        NumGlyphs,
                        byteSwapUINT16(numberOfHMetrics),
                        DesignAdvance
                    );
            }
        }
    }

    /// Load vertical metrics, if any
    //
    //
    if (status == Ok)
    {
        BYTE   *vheaTable = 0;
        INT     vheaLength = 0;

        if (GetFontData('aehv', &vheaLength, &vheaTable) == Ok)
        {
            INT     vmtxLength = 0;
            BYTE   *vmtxTable = 0;
            if (GetFontData('xtmv', &vmtxLength, &vmtxTable) == Ok)
            {
                AutoArray<BYTE> vmtxCopy(new BYTE [vmtxLength]);       // copy of vmtx table

                if (!vmtxCopy)
                    status = OutOfMemory;
                else
                    MapCopy (vmtxCopy.Get(), vmtxTable, vmtxLength, &status);

                ReleaseFontData();  // deref vmtx

                if (status == Ok)
                {
                    UINT16 numOfLongVerMetrics = MapGetUINT16(
                            &((VheaTable *)vheaTable)->numOfLongVerMetrics,
                            &status);

                    if (status == Ok)
                    {
                        numOfLongVerMetrics = byteSwapUINT16(numOfLongVerMetrics);

                        DesignVerticalAdvance = new IntMap<UINT16>;
                        if (!DesignVerticalAdvance)
                            status = OutOfMemory;
                        else
                        {
                            status = ReadMtx(
                                vmtxCopy.Get(),
                                vmtxLength,
                                NumGlyphs,
                                numOfLongVerMetrics,
                                DesignVerticalAdvance
                            );
                        }

                        if (status == Ok)
                        {
                            DesignTopSidebearing  = new IntMap<UINT16>;
                            if (!DesignTopSidebearing)
                                status = OutOfMemory;
                            else
                            {
                                status = ReadMtxSidebearing(
                                    vmtxCopy.Get(),
                                    vmtxLength,
                                    NumGlyphs,
                                    numOfLongVerMetrics,
                                    DesignTopSidebearing
                                );
                            }
                        }
                    }
                }
            }
            ReleaseFontData();  // deref vhea
        }
    }


    ///  Load OTL tables
    //
    //
    if (status == Ok)
    {
        INT   tableSize = 0;
        BYTE *tableAddress = 0;

        if (GetFontData('BUSG', &tableSize, &tableAddress) == Ok)  // GSUB
        {
            Gsub = new BYTE[tableSize];
            if (!Gsub)
                status = OutOfMemory;
            else
            {
                MapCopy(Gsub, tableAddress, tableSize, &status);
                
                // Override the table first fix32 version field to our own use,
                // it now contains the size of each table in byte.
                
                ((UINT32 *)Gsub)[0] = tableSize;            
            }
            ReleaseFontData();
        }
        else
        {
            if (GetFontData('trom', &tableSize, &tableAddress) == Ok)  // mort
            {
                Mort = new BYTE[tableSize];
                if (!Mort)
                    status = OutOfMemory;
                else
                {
                    MapCopy(Mort, tableAddress, tableSize, &status);
                
                    // Override the table first fix32 version field to our own use,
                    // it now contains the size of each table in byte.
                
                    ((UINT32 *)Mort)[0] = tableSize;            
                }
                ReleaseFontData();
            }
        }

        if (status == Ok && GetFontData('SOPG', &tableSize, &tableAddress) == Ok)  // GPOS
        {
            Gpos = new BYTE[tableSize];
            if (!Gpos)
                status = OutOfMemory;
            else
            {
                MapCopy(Gpos, tableAddress, tableSize, &status);
                ((UINT32 *)Gpos)[0] = tableSize;            
            }
            ReleaseFontData();
        }

        if (status == Ok && GetFontData('FEDG', &tableSize, &tableAddress) == Ok)  // GDEF
        {
            Gdef = new BYTE[tableSize];
            if (!Gdef)
                status = OutOfMemory;
            else
            {
                MapCopy(Gdef, tableAddress, tableSize, &status);
                ((UINT32 *)Gdef)[0] = tableSize;            
            }
            ReleaseFontData();
        }

        if (status == Ok)
        {
            if (Gsub)
            {
                // Get address of vertical substitution info, if any

                LoadVerticalSubstitution(
                    Gsub,
                    &VerticalSubstitutionCount,
                    &VerticalSubstitutionOriginals,
                    &VerticalSubstitutionSubstitutions
                );
            } 
            else if (Mort)
            {
                LoadMortVerticalSubstitution(
                    Mort,
                    &VerticalSubstitutionCount,
                    &VerticalSubstitutionOriginals,
                    &VerticalSubstitutionSubstitutions
                );
            }
        }
    }

    ///  Build shaping cache
    //
    //
    if (status == Ok)
        status = Shaping.Create(this);

    if (status == Ok)
        BlankGlyph = Cmap->Lookup(' ');

    // All done

    ReleaseFontData();             // deref hhea

    if (status != Ok)
    {
        FreeImagerTables();
        return FALSE;
    }
    return TRUE;
}

void GpFontFace::FreeImagerTables()
{
    delete Cmap, Cmap = NULL;
    delete DesignAdvance, DesignAdvance = NULL;

    Shaping.Destroy();

    delete DesignVerticalAdvance, DesignVerticalAdvance = NULL;
    delete DesignTopSidebearing, DesignTopSidebearing = NULL;
    delete [] Gsub, Gsub = NULL;
    delete [] Mort, Mort = NULL;
    delete [] Gpos, Gpos = NULL;
    delete [] Gdef, Gdef = NULL;
} // GpFontFace::FreeImagerTables

GpStatus
GpGlyphPath::CopyPath(GpPath *path)
{
    ASSERT(path->IsValid());

    INT count;

    curveCount = path->GetSubpathCount();
    hasBezier = path->HasCurve();
    pointCount = count = path->GetPointCount();

    if (count)
    {
        points = (GpPointF*) ((BYTE*)this + sizeof(GpGlyphPath));
        types = (BYTE*) ((BYTE*)points + sizeof(GpPointF) * count);

        const GpPointF *pathPoints = path->GetPathPoints();
        const BYTE *pathTypes = path->GetPathTypes();

        GpMemcpy(points, pathPoints, count * sizeof(GpPointF));
        GpMemcpy(types, pathTypes, count * sizeof(BYTE));
    }
    else  // 'blank' glyph
    {
        points = NULL;
        types = NULL;
    }

    return Ok;
}


/////   GetHeight
//
//      Returns height in world units for a given graphics. If graphics passed
//      as NULL works as if passed a graphics derived from GetDC(NULL).

GpStatus
GpFont::GetHeightAtWorldEmSize(REAL worldEmSize, REAL *height) const
{
    const GpFontFace *face = Family->GetFace(Style);

    if (!face)
    {
        return InvalidParameter;
    }

    *height = TOREAL(worldEmSize * face->GetDesignLineSpacing()
                                 / face->GetDesignEmHeight());

    return Ok;
}

GpStatus
GpFont::GetHeight(REAL dpi, REAL *height) const
{
    REAL worldEmSize = EmSize;

    switch (SizeUnit)
    {
    case UnitPoint:       worldEmSize = EmSize * dpi / 72.0f;   break;
    case UnitInch:        worldEmSize = EmSize * dpi;           break;
    case UnitDocument:    worldEmSize = EmSize * dpi / 300.0f;  break;
    case UnitMillimeter:  worldEmSize = EmSize * dpi / 25.4f;   break;
    }

    return GetHeightAtWorldEmSize(worldEmSize, height);
}


GpStatus
GpFont::GetHeight(const GpGraphics *graphics, REAL *height) const
{
    REAL worldEmSize =    EmSize
                       *  graphics->GetScaleForAlternatePageUnit(SizeUnit);

    return GetHeightAtWorldEmSize(worldEmSize, height);
}


class FontRecordData : public ObjectData
{
public:
    REAL EmSize;
    Unit SizeUnit;
    INT Style;
    UINT Flag;
    UINT Length;
};

/**************************************************************************\
*
* Function Description:
*
*   Get the font data.
*
* Arguments:
*
*   [IN] dataBuffer - fill this buffer with the data
*   [IN/OUT] size   - IN - size of buffer; OUT - number bytes written
*
* Return Value:
*
*   GpStatus - Ok or error code
*
* Created:
*
*   9/13/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpFont::GetData(
    IStream *   stream
    ) const
{
    ASSERT (stream != NULL);

    WCHAR *     familyName = const_cast<WCHAR *>((const_cast<GpFontFamily *>(Family))->GetCaptializedName());
    UINT        length     = 0;

    if (familyName)
    {
        length = UnicodeStringLength(familyName);
    }

    FontRecordData  fontData;

    fontData.EmSize   =  EmSize;
    fontData.SizeUnit = SizeUnit;
    fontData.Style    =   Style;

    // !!! For now, we assume the next block of bytes is the
    // family name (flag == 0).  In the future, we need to handle
    // memory images (flag == 1).
    fontData.Flag     = 0;
    fontData.Length   = length;

    stream->Write(&fontData, sizeof(fontData), NULL);
    stream->Write(familyName, length * sizeof(WCHAR), NULL);

    // align
    if ((length & 0x01) != 0)
    {
        length = 0;
        stream->Write(&length, sizeof(WCHAR), NULL);
    }

    return Ok;
}

UINT
GpFont::GetDataSize() const
{
    UINT                dataSize   = sizeof(FontRecordData);
    WCHAR *             familyName = const_cast<WCHAR *>((const_cast<GpFontFamily *>(Family))->GetCaptializedName());

    if (familyName)
    {
        dataSize += (UnicodeStringLength(familyName) * sizeof(WCHAR));
    }

    return ((dataSize + 3) & (~3)); // align
}

/**************************************************************************\
*
* Function Description:
*
*   Read the font object from memory.
*
* Arguments:
*
*   [IN] dataBuffer - the data that was read from the stream
*   [IN] size - the size of the data
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   4/26/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpFont::SetData(
    const BYTE *        dataBuffer,
    UINT                size
    )
{
    if ((dataBuffer == NULL) || (size < sizeof(FontRecordData)))
    {
        WARNING(("dataBuffer is NULL or size is too small"));
        return InvalidParameter;
    }

    UINT flag;
    UINT length;
    WCHAR familyName[FamilyNameMax];
    const FontRecordData * fontData = (const FontRecordData *)dataBuffer;

    if (!fontData->MajorVersionMatches())
    {
        WARNING(("Version number mismatch"));
        return InvalidParameter;
    }

    EmSize = fontData->EmSize;
    SizeUnit = fontData->SizeUnit;
    Style = fontData->Style;
    length = fontData->Length;
    dataBuffer += sizeof(FontRecordData);

    if (size < (sizeof(FontRecordData) + (length * sizeof(WCHAR))))
    {
        WARNING(("size is too small"));
        return InvalidParameter;
    }

    // !!! For now, we assume the next block of bytes is the
    // family name (flag == 0).  In the future, we need to handle
    // memory images (flag == 1).

    if (length > FamilyNameMax)
    {
        length = FamilyNameMax;
    }

    // read in the familyName/data
    UnicodeStringCopyCount (familyName,
                            (WCHAR *)dataBuffer,
                            length);

    familyName[length] = 0;

    // !!! For now, we assume that the font family comes from
    // the installed font collection
    //
    // also make sure the font table is loaded the application may play
    // the meta file before loading the font table.

    GpFontTable *fontTable = Globals::FontCollection->GetFontTable();

    if (!fontTable->IsValid())
        return OutOfMemory;

    if (!fontTable->IsPrivate() && !fontTable->IsFontLoaded())
        fontTable->LoadAllFonts();

    Family = fontTable->GetFontFamily(familyName);

    if (Family == NULL)
    {
        GpStatus status = GpFontFamily::GetGenericFontFamilySansSerif((GpFontFamily **) &Family);
        if (status != Ok)
        {
            Family = NULL;
            return status;
        }
    }

    if (!(Family && Family->IsFileLoaded()))
    {
        Family = NULL;
    }

    if (Family == NULL)
    {
        return GenericError;
    }

    UpdateUid();
    return Ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\font.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   font.hpp
*
* Abstract:
*
*   Font and text related header file
*
* Revision History:
*
*   05/05/1999 ikkof
*       Added more constructors.
*
*   12/94/1998 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _FONT_HPP
#define _FONT_HPP

//
// Represent a font object
//
// !!!
//  In the current version, we'll continue to use the existing
//  WFC font related classes. In the managed interface layer,
//  we can extract an HFONT out of the WFC Font object. Internally,
//  we'll use GpFont, which is just an HFONT.
//

class GpFont : public GpObject
{
protected:
    VOID SetValid(BOOL valid)
    {
        GpObject::SetValid(valid ? ObjectTagFont : ObjectTagInvalid);
    }

public:

    GpFont() // used by object factory
    {
        SetValid(TRUE);     // default is valid
    }
    GpFont(HDC hdc);
    GpFont(HDC hdc, LOGFONTW *logfont);
    GpFont(HDC hdc, LOGFONTA *logfont);

    GpFont(const GpFont &font)
    {
        Family   = font.Family;
        EmSize   = font.EmSize;
        Style    = font.Style;
        SizeUnit = font.SizeUnit;

        SetValid(TRUE);     // default is valid
    }

    GpFont(
        REAL                 size,
        const GpFontFamily  *family,
        INT                  style  = FontStyleRegular,
        Unit                 unit   = UnitPoint
    ) ;

    ~GpFont()
    {
    }

    GpFont* Clone() const
    {
        return new GpFont(*this);
    }

    GpStatus    GetLogFontA(GpGraphics * g, LOGFONTA * lfA);
    GpStatus    GetLogFontW(GpGraphics * g, LOGFONTW * lfW);

    BOOL IsValid() const
    {
        // If the font came from a different version of GDI+, its tag
        // will not match, and it won't be considered valid.
        return ((Family != NULL) && GpObject::IsValid(ObjectTagFont));
    }

    const GpFontFamily *GetFamily() const {return Family;}

    REAL                GetEmSize()            const {return EmSize;}
    GpStatus            SetEmSize(REAL size)         {EmSize = size;    UpdateUid(); return Ok;}

    INT                 GetStyle()             const {return Style;}
    GpStatus            SetStyle(INT newStyle)       {Style=newStyle;   UpdateUid(); return Ok;}

    Unit                GetUnit()              const {return SizeUnit;}
    GpStatus            SetUnit(Unit newUnit)        {SizeUnit=newUnit; UpdateUid(); return Ok;}

    GpFontFace *GetFace() const
    {
        return Family ? Family->GetFace(Style) : NULL;
    }

    GpStatus GetHeight(REAL dpi, REAL *height) const;
    GpStatus GetHeight(const GpGraphics *graphics, REAL *height) const;
    GpStatus GetHeightAtWorldEmSize(REAL worldEmSize, REAL *height) const;

    UINT16  GetDesignEmHeight()           const {return GetFace()->GetDesignEmHeight();}
    UINT16  GetDesignCellAscent()         const {return GetFace()->GetDesignCellAscent();}
    UINT16  GetDesignCellDescent()        const {return GetFace()->GetDesignCellDescent();}
    UINT16  GetDesignLineSpacing()        const {return GetFace()->GetDesignLineSpacing();}
    UINT16  GetDesignUnderscoreSize()     const {return GetFace()->GetDesignUnderscoreSize();}
    INT16   GetDesignUnderscorePosition() const {return GetFace()->GetDesignUnderscorePosition();}
    UINT16  GetDesignStrikeoutSize()      const {return GetFace()->GetDesignStrikeoutSize();}
    INT16   GetDesignStrikeoutPosition()  const {return GetFace()->GetDesignStrikeoutPosition();}


    virtual ObjectType GetObjectType() const { return ObjectTypeFont; }

    virtual UINT GetDataSize() const;
    virtual GpStatus GetData(IStream * stream) const;
    virtual GpStatus SetData(const BYTE * dataBuffer, UINT size);

private:

    VOID InitializeFromDc(HDC hdc);

    const GpFontFamily  *Family;
    REAL                 EmSize;
    INT                  Style;
    Unit                 SizeUnit;
};


class GpGlyphPath : public _PATHOBJ
{
public:

    BOOL      hasBezier;
    INT       pointCount;
    GpPointF *points;
    BYTE     *types;

    GpGlyphPath() {};
    ~GpGlyphPath() {};

    BOOL IsValid() const   { return (pointCount ? (points && types) : TRUE); }
    BOOL IsEmpty() const   { return (pointCount ? FALSE : TRUE); }

    GpStatus
    CopyPath(GpPath *path);
};


// wrappers to protect against possible exception
// on accessing data in memory mapped file
static inline void MapCopy(void *pDst,
                          const void *pSrc,
                          size_t size,
                          Status* pStatus)
{
    __try
    {
        memcpy(pDst, pSrc, size);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        *pStatus = GenericError;
    }
}

#endif // !_FONT_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\fontable.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Abstract:
*
*   Font table operations
*
* Revision History:
*
*   23/06/1999 cameronb
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\

    Windows 9x compatibility:

    const WCHAR* strW;

    if (Globals::IsNT)
    {
        FunctionW(strW);
    }
    else
    {
        AnsiStrFromUnicode strA(strW);
        FunctionA(strA);
    }

\**************************************************************************/


/**************************************************************************\
*
* Function Description:
*
*   Constructs a GpFontTable object
*
* Arguments:
*
*       none
*
* Returns:
*
*       nothing
*
* History:
*
*   23/06/1999 cameronb
*       Created it.
*
\**************************************************************************/

GpFontTable::GpFontTable() : NumFilesLoaded(0), NumHashEntries(61), Table(NULL), EnumList(NULL)
{
    Table = new GpFontFile *[NumHashEntries];

    if (Table != NULL)
    {
        GpMemset(Table, 0, sizeof(GpFontFile *) * NumHashEntries);

        EnumList = new GpFontFamilyList();
    }

    bPrivate = FALSE;
    bFontFilesLoaded = FALSE;
}


/**************************************************************************\
*
* Function Description:
*
*   Destroys a GpFontTable object
*
* Arguments:
*
*       none
*
* Returns:
*
*       nothing
*
* History:
*
*   23/06/1999 cameronb
*       Created it.
*
\**************************************************************************/

GpFontTable::~GpFontTable()
{
    if (EnumList)
    {
        delete EnumList;
    }

    if (Table)
    {
        for (UINT h = 0; h < NumHashEntries; h++)
        {
            if (Table[h] != NULL)
            {
                UnloadFontFiles(Table[h]);
            }
        }

        delete [] Table;
    }
}

BOOL GpFontTable::UnloadFontFiles(GpFontFile* fontFile)
{
    if (fontFile->GetNext() != NULL)
    {
        UnloadFontFiles(fontFile->GetNext());
    }

    CacheFaceRealization *prface = fontFile->prfaceList;

    while(prface)
    {
        GpFaceRealizationTMP rface(prface);

        // specially for the case of font added and removed from a private font collection, we need to remove it from the
        // last recently used list
        Globals::FontCacheLastRecentlyUsedList->RemoveFace(prface);

        prface = (prface->NextCacheFaceRealization == fontFile->prfaceList) ? NULL : prface->NextCacheFaceRealization;

        rface.DeleteRealizedFace();
    }

    ttfdSemUnloadFontFile(fontFile->hff);

    // Free objects allocated by text support

    for (UINT i=0; i<fontFile->GetNumEntries(); i++)
    {
        fontFile->GetFontFace(i)->FreeImagerTables();
    }

    if (fontFile->pfv != NULL)
    {
        if (fontFile->pfv->pwszPath == NULL)  // memory image
            GpFree(fontFile->pfv->pvView);

        GpFree(fontFile->pfv);
    }

    GpFree(fontFile);

    return TRUE;
}



/**************************************************************************\
*
* Function Description:
*
*   Load all the fonts from cache or the registry to the font table
*
*
* History:
*
*   11/12/1999 yungt created it.
*
\**************************************************************************/

void GpFontTable::LoadAllFonts(const WCHAR *familyName)
{
    InitFontFileCache();
            
    if (GetFontFileCacheState() & FONT_CACHE_LOOKUP_MODE)
    {
    // Do the fast way to load all the fonts, we will be no need to touch any registry
    // and font file.
        LoadAllFontsFromCache(FontFileCacheReadRegistry());
    }
    else
    {
    // We do need to load the fonts from registry also we need to 
        if (GetFontFileCacheState() & FONT_CACHE_CREATE_MODE)
        {
            LoadAllFontsFromRegistry(TRUE);
        }
        else
        {
            LoadAllFontsFromRegistry(FALSE);
        }
    }
    
    vCloseFontFileCache();
}

/**************************************************************************\
*
* Function Description:
*
*   Adds a font from the font table
*
* Arguments:
*
*       str:    name of font to be added
*
* Returns:
*
*       GpFontFile *:   It will not be NULL if succeeded
*
* History:
*
*   28/06/YungT cameronb
*       Created it.
*
\**************************************************************************/

GpFontFile * GpFontTable::AddFontFile(WCHAR* fileName)
{
// This rountine is called from GpFontFamily which we have load the family from cache
// We need to load the font file now if it is being used.

    GpFontFile* fontFile = NULL;
    
    UINT hash = HashIt(fileName);
    {
        fontFile = GetFontFile(fileName, hash);
    
        if (fontFile != NULL)
        {
            // font exists in the table
            fontFile->cLoaded++;
        }
        else
        {
            if ((fontFile = LoadFontFile(fileName)) == NULL)
            {
                return NULL;
            }
    
            
            // Add to the head of the appropriate hash list (hash bucket)
            
            fontFile->SetPrev(NULL);
            fontFile->SetNext(Table[hash]);
            if (Table[hash] != NULL)
                Table[hash]->SetPrev(fontFile);
            Table[hash] = fontFile;
    
            // loop over pfe's, init the data:
            GpFontFace * face = (GpFontFace *)fontFile->aulData;

            for (ULONG iFont = 0; iFont < fontFile->cFonts; iFont++)
            {
                face[iFont].SetPrivate(bPrivate);
            }

            // Add to the emuneration list
    
            NumFilesLoaded++;
        }
    }   
    
    return fontFile;
}



/**************************************************************************\
*
* Function Description:
*
*   Adds a font from the font table
*
* Arguments:
*
*       str:    name of font to be added
*
* Returns:
*
*       BOOL:   indicating success
*
* History:
*
*   23/06/1999 cameronb
*       Created it.
*
\**************************************************************************/

GpStatus GpFontTable::AddFontFile(const WCHAR* fileName,
                                  GpFontCollection *fontCollection)
{
    WCHAR awcPath[MAX_PATH];

    GpStatus status = Ok;
    
    if (!MakePathName(awcPath, const_cast<WCHAR *>(fileName)))
        return FileNotFound;

//  Determine whether font is already in the table
    UnicodeStringToUpper (awcPath, awcPath);
    UINT hash = HashIt(awcPath);
    {
        GpFontFile* fontFile = GetFontFile(awcPath, hash);
    
        if (fontFile != NULL)
        {
            // font exists in the table
            fontFile->cLoaded++;
        }
        else
        {
            if ((fontFile = LoadFontFile(awcPath)) == NULL)
            {
                return FileNotFound;
            }
    
            
            // Add to the head of the appropriate hash list (hash bucket)
            
            fontFile->SetPrev(NULL);
            fontFile->SetNext(Table[hash]);
            if (Table[hash] != NULL)
                Table[hash]->SetPrev(fontFile);
            Table[hash] = fontFile;
    
            // loop over pfe's, init the data:
            GpFontFace * face = (GpFontFace *)fontFile->aulData;

            for (ULONG iFont = 0; iFont < fontFile->cFonts; iFont++)
            {
                face[iFont].SetPrivate(bPrivate);
            }

            // Add to the emuneration list
    
            if (!EnumList->AddFont(fontFile, fontCollection))
                return OutOfMemory;
            NumFilesLoaded++;
        }
    }   
    
    return Ok;
}


/************************************************************\
*
* Function Description:
*
*   Adds a font from the memory image
*
*
* History:
*
*   Nov/09/1999 Xudong Wu [tessiew]
*       Created it.
*
\************************************************************/
ULONG GpFontTable::MemImageUnique = 0;

GpStatus GpFontTable::AddFontMemImage(
    const BYTE* fontMemoryImage,
    INT   fontImageSize,
    GpFontCollection *fontCollection
    )
{
    WCHAR awcPath[MAX_PATH];
    UINT  hash;
    GpFontFile *fontFile;

    // generate a "MEMORY xxx" style file name

    wsprintfW(awcPath, L"MEMORY-%u", GetNewMemImageUniqueness(GpFontTable::MemImageUnique));

    UnicodeStringToUpper (awcPath, awcPath);
    hash = HashIt(awcPath);
    
    fontFile = LoadFontMemImage(awcPath, const_cast<BYTE *>(fontMemoryImage), fontImageSize);
    
    if (fontFile == NULL)   // unable to load font
	{
         return FileNotFound;
	}
    
    // Add to the head of the appropriate hash list (hash bucket)
    
    fontFile->SetNext(Table[hash]);
    if (Table[hash] != NULL)
        Table[hash]->SetPrev(fontFile);
    Table[hash] = fontFile;

    // Add to the emuneration list

    if (!EnumList->AddFont(fontFile, fontCollection))
        return OutOfMemory;
    NumFilesLoaded++;
    
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Searched the font table for the any font
*
* Arguments:
*
*
* Returns:
*
*       GpFontFamily *: pointer to font file if found, else NULL
*
* History:
*
*  7/15/2000 YungT
*       Created it.
*
\**************************************************************************/

GpFontFamily* GpFontTable::GetAnyFamily()
{
    return EnumList->GetAnyFamily();
}

/**************************************************************************\
*
* Function Description:
*
*   Searched the font table for the specified font
*
* Arguments:
*
*       fileName:       name of font to be removed
*   hash:       its hash value
*
* Returns:
*
*       GpFontFile*: pointer to font file if found, else NULL
*
* History:
*
*   23/06/1999 cameronb
*       Created it.
*
\**************************************************************************/

GpFontFamily* GpFontTable::GetFontFamily(const WCHAR* familyName)
{
    return EnumList->GetFamily(familyName);
}


/**************************************************************************\
*
* Function Description:
*
*   Removes a font from the font table.
*
*   Note: If the ref count of any of the PFEs in the font file is greater
*   than zero, then we do not delete the font file entry in the font table.
*   However, the bRemoved flag is set in this function.  So, in the case when
*   a ref count decrement could cause a font file to be removed, the caller
*   should first test bRemoved before calling this function.
*
* History:
*
*   Nov/28/1999  Xudong Wu [tessiew]
*       Created it.
*
\**************************************************************************/

GpStatus GpFontTable::RemoveFontFile(const WCHAR* fontFileName)
{
    WCHAR awcPath[MAX_PATH];
    GpFontFile *fontFile = NULL;

    if (!MakePathName(awcPath, const_cast<WCHAR *>(fontFileName)))
        return GenericError;

    UnicodeStringToUpper (awcPath, awcPath);
    UINT hash = HashIt(awcPath);

    GpFontFile *ff = Table[hash];

    while(ff && !fontFile)
    {
        if ( UnicodeStringCompare(awcPath, ff->pwszPathname_) == 0 )
        {
            fontFile = ff;
        }
        ff = ff->GetNext();
    }

    if (fontFile)
    {
        fontFile->bRemoved = TRUE;

        if (fontFile->cLoaded)
        {
            fontFile->cLoaded--;
        }

        // see if any of the PFEs have a ref count on them
        BOOL bFontFamilyRef = TRUE;
        for (UINT iFont = 0; iFont < fontFile->cFonts; iFont++)
        {
            GpFontFace *pfe = &(((GpFontFace *) &(fontFile->aulData))[iFont]);
            if (pfe->cGpFontFamilyRef > 0)
            {
                bFontFamilyRef = FALSE;
            }
        }
        // ASSERT: if there are no references by any FontFamily to
        // any of the PFEs in this object (via GpFontFamily objects),
        // then bFontFamilyRef is TRUE.  bFontFamilyRef is FALSE otherwise.

        if (fontFile->cLoaded == 0 &&
            bFontFamilyRef &&
            fontFile->prfaceList == NULL)
        {
            // set the Face pointers of the corresponding FontFamily objects
            // to NULL and attempt to remove each font family in the file
            for (UINT iFont = 0; iFont < fontFile->cFonts; iFont++)
            {
                GpFontFamily *gpFontFamily = GetFontFamily(fontFile->GetFamilyName(iFont));
                if (gpFontFamily)
                {
                    for (UINT iFace = 0; iFace < NumFontFaces; iFace++)
                    {
                        if (gpFontFamily->GetFaceAbsolute(iFace) ==
                            (&(((GpFontFace *) (&(fontFile->aulData))) [iFont])))
                        {
                            gpFontFamily->SetFaceAndFile(iFace, NULL, NULL);
                        }
                    }
                    EnumList->RemoveFontFamily(gpFontFamily);
                }
            }

            // remove GpFontFile from the FontTable
            NumFilesLoaded--;

            if (fontFile->GetPrev())
                fontFile->GetPrev()->SetNext(fontFile->GetNext());
            if (fontFile->GetNext())
                fontFile->GetNext()->SetPrev(fontFile->GetPrev());
            
            if (fontFile == Table[hash])
                Table[hash] = fontFile->GetNext();
            
            ttfdSemUnloadFontFile(fontFile->hff);

            // Free objects allocated by text support

            for (ULONG i=0; i<fontFile->GetNumEntries(); i++)
            {
                fontFile->GetFontFace(i)->FreeImagerTables();
            }

            if (fontFile->pfv != NULL)
            {
                if (fontFile->pfv->pwszPath == NULL)  // memory image
                GpFree(fontFile->pfv->pvView);

                GpFree(fontFile->pfv);
            }
            GpFree(fontFile);

            return Ok;
        }
    }
    else
    {
        // couldn't find the font file in the hash table
        return GenericError;
    }
    
    return Ok;
}


/**************************************************************************\
*
* Function Description:
*
*   Counts the number of enumerable fonts in the table
*
* Arguments:
*
*
*
* Returns:
*
*       Number of enumerable fonts
*
* History:
*
*   12/07/1999 cameronb
*       Created it.
*
\**************************************************************************/

INT GpFontTable::EnumerableFonts(GpGraphics* graphics)
{
    return EnumList->Enumerable(graphics);
}

/**************************************************************************\
*
* Function Description:
*
*   Enumerates fonts.
*
*   First call EnumerableFonts() to determine the number to expect.
*
* Arguments:
*
*
*
* Returns:
*
*       Status of the enumeration operation
*
* History:
*
*   12/07/1999 cameronb
*       Created it.
*
\**************************************************************************/

GpStatus GpFontTable::EnumerateFonts(
    INT                     numSought,
    GpFontFamily*           gpfamilies[],
    INT&                    numFound,
    GpGraphics*               graphics
) 
{
    GpStatus status = EnumList->Enumerate(numSought, gpfamilies, numFound, graphics);

#if FONTTABLE_DBG
    TERSE(("Enumerated font list:"));
    EnumList->Dump();
    TERSE(("Done."));
#endif

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Returns a pseudorandom hash value for a given string
*
* Arguments:
*
*       str:    string to be hashed
*
* Returns:
*
*       UINT:   hash value for str
*
* Note: All strings must be capitalized!                                   *
*                                                                          *
* History:
*
*   23/06/1999 cameronb
*       Created it.
* History:                                                                 *
*  Wed 07-Sep-1994 08:12:22 by Kirk Olynyk [kirko]                         *
* Since chuck is gone the mice are free to play. So I have replaced        *
* it with my own variety. Tests show that this one is better. Of           *
* course, once I have gone someone will replace mine. By the way,          *
* just adding the letters and adding produces bad distributions.           *
*  Tue 15-Dec-1992 03:13:15 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.  It looks crazy, but I claim there's a theory behind it.       *
*
\**************************************************************************/

UINT GpFontTable::HashIt(const WCHAR* str) const
{
    UINT result = 0;

    //ASSERT(NumHashEntries != 0);

    while (*str)
    {
        // use the lower byte since that is where most of the
        // interesting stuff happens
        //result += 256 * result + (UCHAR)towupper(*str++);
        result += 256 * result + (UCHAR)*str++;
    }

    return result % NumHashEntries;
}

GpFontFile* GpFontTable::GetFontFile(const WCHAR* fileName) const
{
    WCHAR fileNameCopy[MAX_PATH];
    UnicodeStringToUpper (fileNameCopy, const_cast<WCHAR *>(fileName));
    UINT hash = HashIt(fileNameCopy);
    return GetFontFile(fileNameCopy, hash);
}

GpFontFile* GpFontTable::GetFontFile(const WCHAR* fileName, UINT hash) const
{
    for (GpFontFile* ff = Table[hash]; ff != NULL; ff = ff->GetNext())
        if (UnicodeStringCompareCI(fileName, ff->GetPathName()) == 0)
        {
            return ff;
        }

    return NULL;
}

/**************************************************************************\
*
* Function Description:
*
*   Adds fonts from the cache file to the font table
*
* Arguments:
*
* Returns:
*
*       nothing
*
* History:
*
*   6/21/2000 YungT
*       Created it.
*
\**************************************************************************/

void GpFontTable::LoadAllFontsFromCache(BOOL bLoadFromRegistry)
{
    if (!EnumList->BuildFamilyListFromCache(bLoadFromRegistry))
    {
        LoadAllFontsFromRegistry(FALSE);
    }
    else
    {
        bFontFilesLoaded = TRUE;
    }

    return ;
}

/**************************************************************************\
*
* Function Description:
*
*   Adds fonts from the registry to the font table
*
* Arguments:
*
*       numExpected:    number of fonts expected in the registry.  This includes
*                   *.FON files which the TT font driver will not load.
*
* Returns:
*
*       nothing
*
* History:
*
*   23/06/1999 cameronb
*       Created it.
*
\**************************************************************************/

void GpFontTable::LoadAllFontsFromRegistry(BOOL bUpdateCache)
{
    ULONG numExpected;
    
    //  Open the key

    HKEY hkey;

    LONG error = (Globals::IsNt) ? RegOpenKeyExW(HKEY_LOCAL_MACHINE, Globals::FontsKeyW, 0, KEY_QUERY_VALUE, &hkey)
                                 : RegOpenKeyExA(HKEY_LOCAL_MACHINE, Globals::FontsKeyA, 0, KEY_QUERY_VALUE, &hkey);

    if (error == ERROR_SUCCESS)
    {
        //  Must read from the registry in Ascii format for some unfathomable reason

        CHAR  label[MAX_PATH];
        BYTE  data[MAX_PATH];
        WCHAR labelW[MAX_PATH];
        WCHAR fileNameW[MAX_PATH];

        //  Loop through fonts in registry

        //  Note:
        //      Don't make (error != ERROR_NO_MORE_ITEMS) the sole
        //      terminating condition for this loop.  The last entry
        //      may produce a different type of error.

        ULONG index = 0;
        ULONG registrySize = 0;

        error = RegQueryInfoKeyA(hkey, NULL, NULL, NULL, NULL, NULL, NULL, &numExpected, NULL, NULL, NULL, NULL);

        if (error != ERROR_SUCCESS)
        {
            numExpected = NumHashEntries << 3;
            error = ERROR_SUCCESS;
        }

		/* we need to add the font Marlett separately since it's hidden and not listed in the registry */
        if (AddFontFile(L"Marlett.ttf", NULL) != Ok)
        {
            VERBOSE(("Error loading font Marlett.ttf.\n"))
        }

        while (index < numExpected && error != ERROR_NO_MORE_ITEMS)
        {
            DWORD   regType = 0;
            DWORD   labelSize = MAX_PATH;
            DWORD   dataSize = MAX_PATH;
            DWORD   dataSizeW = MAX_PATH * sizeof(WCHAR);

            if (Globals::IsNt)
                error = RegEnumValueW(hkey, index, labelW, &labelSize, NULL, &regType, (PBYTE) fileNameW, &dataSizeW );
            else
                error = RegEnumValueA(hkey, index, label, &labelSize, NULL, &regType, data, &dataSize);

            if (error == ERROR_NO_MORE_ITEMS)
                break;
            else if (error != ERROR_SUCCESS)
            {
                index ++;
                //ASSERT
                VERBOSE(("Bad RegEnumValueA %d for %s.", error, data))
                continue;
            }

            if (!Globals::IsNt)
            {
                memset(fileNameW, 0, MAX_PATH * sizeof(WCHAR));
                MultiByteToWideChar(CP_ACP, 0, (CHAR*)data, -1, fileNameW, MAX_PATH);

                registrySize += dataSize; 
            }

            if (AddFontFile(fileNameW, NULL) != Ok)
            {
                VERBOSE(("Error loading font %ws.\n", fileNameW))
            }
    
            index ++;
        }

        if (NumFilesLoaded)
        {
            // loaded all the fonts from reg

            if (bUpdateCache)
                EnumList->UpdateFamilyListToCache(FontFileCacheReadRegistry(), hkey, registrySize, numExpected);

            bFontFilesLoaded = TRUE;
        }

        RegCloseKey(hkey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\fontcollection.cpp ===
/**************************************************************************\
*
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   fontcollection.cpp
*
* Revision History:
*
*   03/06/00 DChinn
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"


INT
GpFontCollection::GetFamilyCount()
{
    if (!FontTable->IsPrivate() && !FontTable->IsFontLoaded())
        FontTable->LoadAllFonts();

    return FontTable->EnumerableFonts();
}


GpStatus
GpFontCollection::GetFamilies(
    INT             numSought,
    GpFontFamily*   gpfamilies[],
    INT*            numFound
    )
{
    if (!FontTable->IsPrivate() && !FontTable->IsFontLoaded())
        FontTable->LoadAllFonts();
    return FontTable->EnumerateFonts(numSought, gpfamilies, *numFound);
}

GpInstalledFontCollection::GpInstalledFontCollection()
{
    FontTable = new GpFontTable;

    if (FontTable != NULL)
    {
        /* verify if we were running out of memory during the creation */
        if (!FontTable->IsValid())
        {
            delete FontTable;
            FontTable = NULL;
        }
        else
        {
            FontTable->SetPrivate(FALSE);
        }
    }
}

GpInstalledFontCollection::~GpInstalledFontCollection()
{
    delete FontTable;
    instance = NULL;
}

// definition of static data member of the singleton class GpInstalledFontCollection
GpInstalledFontCollection* GpInstalledFontCollection::instance = NULL;

GpInstalledFontCollection* GpInstalledFontCollection::GetGpInstalledFontCollection()
{
    if (instance == NULL)
    {
        instance = new GpInstalledFontCollection;

        /* verify if there was any memory error during the creation */
        if (instance != NULL) 
        {
            if (instance->FontTable == NULL)
            {
                 delete instance;
                instance = NULL;
            }
        }
    }
    return instance;
}


GpStatus
GpInstalledFontCollection::InstallFontFile(const WCHAR *filename)
{
    return (FontTable->AddFontFile(filename, this));
}

GpStatus
GpInstalledFontCollection::UninstallFontFile(const WCHAR *filename)
{
    return (FontTable->RemoveFontFile(filename));
}


GpPrivateFontCollection::GpPrivateFontCollection()
{
    FontTable = new GpFontTable;
    if (FontTable != NULL)
    {
        /* verify if we were running out of memory during the creation */
        if (!FontTable->IsValid())
        {
            delete FontTable;
            FontTable = NULL;
        }
        else
        {
            FontTable->SetPrivate(TRUE);
            FontTable->SetFontFileLoaded(TRUE);
        }
    }
}

GpPrivateFontCollection::~GpPrivateFontCollection()
{
    delete FontTable;
}

GpStatus
GpPrivateFontCollection::AddFontFile(const WCHAR* filename)
{
    return (FontTable->AddFontFile(filename, this));
}

GpStatus
GpPrivateFontCollection::AddMemoryFont(const VOID *memory, INT length)
{
    return (FontTable->AddFontMemImage(static_cast<const BYTE *>(memory),
                                       length,
                                       this));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\fontfile.hpp ===
#ifndef FONT_FILE_DEFINED
#define FONT_FILE_DEFINED


class GpFontTable;

class CacheFaceRealization;

class GpFontFile
{

public:
    GpFontFile() : Next(NULL), Prev(NULL), FamilyName(NULL) {}
    ~GpFontFile() {}

public:
    GpFontFile* GetNext(void) const         
    {
        return Next; 
    }
    
    GpFontFile* GetPrev(void) const         
    { 
        return Prev; 
    }

    void SetNext(GpFontFile* ff)     
    { 
        Next = ff; 
    }

    void SetPrev(GpFontFile* ff)     
    { 
        Prev = ff; 
    }
    
	void AllocateNameHolders(WCHAR** hFamilyName, int numFonts) 
	{
		FamilyName = hFamilyName;
        //  Initialize each name to NULL
        for (INT n = 0; n < numFonts; n++)
        {
            FamilyName[n] = NULL;
        }
	}
	
    const WCHAR*    GetFamilyName(int i) const         
    { 
        return FamilyName[i]; 
    } 

    void            SetFamilyName(int i, WCHAR* name)   
    { 
        FamilyName[i] = name; 
    } 

    const WCHAR*    GetPathName(void) const      
    { 
        return pwszPathname_; 
    } 

    const UINT      GetPathNameSize(void) const  
    { 
        return cwc; 
    }
    
    void SetPathName(WCHAR* name)      
    { 
        pwszPathname_ = name; 
    } 

    BOOL operator== (GpFontFile const& ff) const
    {
        if (this == &ff)
            return TRUE;

        return (wcscmp(pwszPathname_, ff.pwszPathname_) == 0);
    }
    
    ULONG       GetNumEntries(void) const       
    { 
        return cFonts; 
    }
    
    GpFontFace* GetFontFace(ULONG iFont)        
    { 
        return( &(((GpFontFace*)(&aulData))[iFont]) ); 
    }

    FONTFILEVIEW * GetFileView() const
    {
        return pfv;
    }
    
//  Data members
public:
    ULONG           SizeOfThis;

private:

    // Connects GpFontFile's sharing the same hash bucket
    
    GpFontFile*     Next;
    GpFontFile*     Prev;

    WCHAR**         FamilyName;     //  Array of family name in this font file

public:

// pwszPathname_ points to the Unicode upper case path
// name of the associated font file which is stored at the
// end of the data structure.

    WCHAR *         pwszPathname_;
    ULONG           cwc;            // total for all strings

// state

    FLONG           flState;        // state (ready to die?)
    ULONG           cLoaded;        // load count
    ULONG           cRealizedFace;         // total number of RealizedFaces
    ULONG           bRemoved;       // TRUE if the font file has been removed
                                    // (RemoveFontFile() )

// CacheFaceRealization list

    CacheFaceRealization    *prfaceList;      // pointer to head of doubly linked list

// driver information

    ULONG_PTR       hff;            // font driver handle to font file, RETURNED by DrvLoadGpFontFile

// fonts in this file (and filename slimed in)

    ULONG           cFonts;         // number of fonts (same as chpfe)

    FONTFILEVIEW    *pfv;           // address of FILEVIEW structure, passed to DrvLoadFontFile

    ULONG_PTR       aulData[1];     // data buffer for HFontEntry and filename
};



GpFontFile *LoadFontInternal(WCHAR *pwszName, ULONG cwc, FONTFILEVIEW *pffv, BOOL bMem);
GpFontFile *LoadFontFile(WCHAR * pwszFontFileName);
GpFontFile *LoadFontMemImage(WCHAR* fontImageName, BYTE* fontMemoryImage, INT fontImageSize);
VOID   UnloadFontFile(GpFontFile *pFontFile);

BOOL   MakePathName(WCHAR  *dst, WCHAR  *src);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\fontface.hpp ===
#ifndef _FONTFACE_

#define _FONTFACE_

class GpFontFile;

class ShapingCache;     // implemented in ..\text\uniscribe\shaping

struct ShapingCacheFactory
{
    GpStatus        Create(const GpFontFace *face);
    void            Destroy();
    ShapingCache    *Cache;
};






/////   GpFontFace
//
//


class GpFontFace
{

public:
    FontStyle GetFaceStyle(void) const
    {
        switch (pifi->fsSelection & (FM_SEL_BOLD | FM_SEL_ITALIC))
        {
            case FM_SEL_BOLD:                  return FontStyleBold;
            case FM_SEL_ITALIC:                return FontStyleItalic;
            case FM_SEL_BOLD | FM_SEL_ITALIC:  return FontStyleBoldItalic;
            default:                           return FontStyleRegular;
        }
    }

    BOOL SimBold() const
    {
        BOOL ret = FALSE;

        if (pifi->dpFontSim)
        {
            FONTSIM *pfs = (FONTSIM*) ((BYTE*)pifi + pifi->dpFontSim);

            ret = (pifi->fsSelection & FM_SEL_ITALIC) ?
                    (BOOL) pfs->dpBoldItalic : (BOOL) pfs->dpBold;
        }
        return (ret);
    }

    BOOL SimItalic() const
    {
        BOOL ret = FALSE;

        if (pifi->dpFontSim)
        {
            FONTSIM *pfs = (FONTSIM*) ((BYTE*)pifi + pifi->dpFontSim);

            ret = (pifi->fsSelection & FM_SEL_BOLD) ?
                    (BOOL) pfs->dpBoldItalic : (BOOL) pfs->dpItalic;
        }
        return (ret);
    }

    void IncGpFontFamilyRef(void) { cGpFontFamilyRef++; }
    void DecGpFontFamilyRef(void) { cGpFontFamilyRef--; }


public:

    // The following internal class variables are public because they
    // are initialised and manipulated by classless code ported from GDI.

    // Location of font.

    GpFontFile     *pff;      // pointer to physical font file object
    ULONG           iFont;    // index of the font for IFI or device, 1 based
    FLONG           flPFE;

    // Font data.

    GP_IFIMETRICS  *pifi;     // pointer to ifimetrics
    ULONG           idifi;    // id returned by driver for IFIMETRICS

    // information needed to support ETO_GLYPHINDEX mode of ExtTextOut.

    ULONG           NumGlyphs;

    //  Ref count for GpFontFamily objects that point to this GpFontFace
    ULONG           cGpFontFamilyRef;

    mutable BYTE lfCharset;

    static int CALLBACK EnumFontFamExProcA(
                    const ENUMLOGFONTEXA   *lpelfe,    // logical-font data
                    const NEWTEXTMETRICEXA *lpntme,    // physical-font data
                    int                     FontType,  // type of font
                    LPARAM                  lParam     // application-defined data
                );

    static int CALLBACK EnumFontFamExProcW(
                    const ENUMLOGFONTEXW   *lpelfe,    // logical-font data
                    const NEWTEXTMETRICEXW *lpntme,    // physical-font data
                    int                     FontType,  // type of font
                    LPARAM                  lParam     // application-defined data
                );



    // Text support

    UINT16  GetDesignEmHeight()           const {return pifi->fwdUnitsPerEm;}
    UINT16  GetDesignCellAscent()         const {return pifi->fwdWinAscender;}
    UINT16  GetDesignCellDescent()        const {return pifi->fwdWinDescender;}
    UINT16  GetDesignLineSpacing()        const {return max(pifi->fwdMacAscender-pifi->fwdMacDescender+pifi->fwdMacLineGap, pifi->fwdWinAscender+pifi->fwdWinDescender);}
    UINT16  GetDesignUnderscoreSize()     const {return pifi->fwdUnderscoreSize;}
    INT16   GetDesignUnderscorePosition() const {return pifi->fwdUnderscorePosition;}
    UINT16  GetDesignStrikeoutSize()      const {return pifi->fwdStrikeoutSize;}
    INT16   GetDesignStrikeoutPosition()  const {return pifi->fwdStrikeoutPosition;}


    GpStatus GetFontData(UINT32     tag,
                         INT*       size,
                         BYTE**     pjTable) const;

    void ReleaseFontData() const;

    BYTE GetCharset(HDC hdc) const;

    const IntMap<UINT16> &GetCmap()                               const {return *Cmap;}
    const IntMap<UINT16> &GetDesignAdvance()                      const {return *DesignAdvance;}
    const IntMap<UINT16> *GetDesignVerticalAdvance()              const {return DesignVerticalAdvance;}
    BOOL                  RequiresFullTextImager()                const {return RequiresFullText;}
    UINT16                GetMissingGlyph()                       const {return MissingGlyph;}
    UINT16                GetBlankGlyph()                         const {return BlankGlyph;}
    BYTE                 *GetGSUB()                               const {return Gsub;}
    BYTE                 *GetGPOS()                               const {return Gpos;}
    BYTE                 *GetGDEF()                               const {return Gdef;}
    BYTE                 *GetMort()                               const {return Mort;}
    UINT16                GetVerticalSubstitutionCount()          const {return VerticalSubstitutionCount;}
    const UINT16         *GetVerticalSubstitutionOriginals()      const {return VerticalSubstitutionOriginals;}
    const UINT16         *GetVerticalSubstitutionSubstitutions()  const {return VerticalSubstitutionSubstitutions;}


    void GetGlyphDesignAdvances(
        IN  const UINT16  *glyphs,     //
        IN  INT            glyphCount, //
        IN  INT            style,      // Causes adjustment for algorithmic style emulation
        IN  BOOL           vertical,   // Use vtmx, not htmx
        IN  REAL           tracking,   // Expansion factor
        OUT UINT16        *advances    //
    ) const;

    void GetGlyphDesignAdvancesIdeal(
        IN  const UINT16  *glyphs,        //
        IN  INT            glyphCount,    //
        IN  INT            style,         // Causes adjustment for algorithmic style emulation
        IN  BOOL           vertical,      // Use vtmx, not htmx
        IN  REAL           designToIdeal, // Scale factor for each advance width
        IN  REAL           tracking,      // Expansion factor
        OUT INT           *advances       //
    ) const;

    inline ShapingCache *GetShapingCache() const
    {
        return  Shaping.Cache;
    }

    void FreeImagerTables();

    BOOL IsAliasName()
    {
        BOOL    bOk = FALSE;

        if (pifi->flInfo & FM_INFO_FAMILY_EQUIV)
        {
            bOk = TRUE;
        }

        return bOk;
    }

    WCHAR * GetAliasName()
    {
        size_t length;

        length = UnicodeStringLength((WCHAR *)(((BYTE*) pifi) + pifi->dpwszFamilyName)) + 1;


        if (!(pifi->flInfo & FM_INFO_FAMILY_EQUIV))
        {
           return (WCHAR *) NULL;
        }

        return((WCHAR *)(((BYTE*) pifi) + pifi->dpwszFamilyName) + length);
    }

    BOOL IsPrivate() const { return bPrivateFace;}
    BOOL IsSymbol()  const { return bSymbol;}

    void SetPrivate(BOOL bPrivate) { bPrivateFace = bPrivate;}
    void SetSymbol(BOOL symbol) { bSymbol = symbol;}

    BOOL InitializeImagerTables();

    void SetSupportedCodePages(__int64 codePages)
    {
        SupportedCodePages  =    ((codePages & 0xFF00000000000000) >> 24);
        SupportedCodePages |=    ((codePages & 0x00FF000000000000) >> 8 );
        SupportedCodePages |=    ((codePages & 0x0000FF0000000000) << 8 );
        SupportedCodePages |=    ((codePages & 0x000000FF00000000) << 24);
        SupportedCodePages |=    ((codePages & 0x00000000FF000000) >> 24);
        SupportedCodePages |=    ((codePages & 0x0000000000FF0000) >> 8 );
        SupportedCodePages |=    ((codePages & 0x000000000000FF00) << 8 );
        SupportedCodePages |=    ((codePages & 0x00000000000000FF) << 24);
    }

    BOOL IsCodePageSupported(UINT codePage);

private:
    mutable IntMap<UINT16> *Cmap;
    mutable IntMap<UINT16> *DesignAdvance;
    mutable IntMap<UINT16> *DesignVerticalAdvance;
    mutable IntMap<UINT16> *DesignTopSidebearing;

    mutable ShapingCacheFactory Shaping;

    mutable BOOL RequiresFullText;

    mutable UINT16 MissingGlyph;
    mutable UINT16 BlankGlyph;

    BOOL    bPrivateFace;

    mutable BOOL    bSymbol;
    mutable __int64 SupportedCodePages;

    mutable BYTE         *Gsub;                              // OTL glyph substitution table
    mutable BYTE         *Gpos;                              // OTL glyph positioning table
    mutable BYTE         *Gdef;                              // OTL glyph definition table
    mutable BYTE         *Mort;                              // legacy vertical substitution table
    mutable UINT16        VerticalSubstitutionCount;         // Number of substitutable glyphs
    mutable const UINT16 *VerticalSubstitutionOriginals;     // Pointer into cached GSUB
    mutable const UINT16 *VerticalSubstitutionSubstitutions; // Pointer into cached GSUB

};

#endif // FONTFACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\fontcollection.hpp ===
/**************************************************************************\
*
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   fontcollection.hpp
*
* Abstract:
*
*   Font collection.  These objects implement the internal GdiPlus
*   installable fonts (system fonts) and private fonts (fonts an
*   application can temporarily install).
*
* Revision History:
*
*   03/06/00  DChinn
*       Created it.
*
\**************************************************************************/

#ifndef _FONTCOLLECTION_HPP
#define _FONTCOLLECTION_HPP


class GpFontCollection
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagFontCollection : ObjectTagInvalid;
    }

public:

    BOOL IsValid() const
    {
    #ifdef _X86_
        // We have to guarantee that the Tag field doesn't move for
        // versioning to work between releases of GDI+.
        ASSERT(offsetof(GpFontCollection, Tag) == 4);
    #endif
    
        ASSERT((Tag == ObjectTagFontCollection) || (Tag == ObjectTagInvalid)); 
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid FontCollection");
        }
    #endif

        return (Tag == ObjectTagFontCollection);
    }

    GpFontCollection()
    {
        SetValid(TRUE);     // default is valid
    }

    ~GpFontCollection()
    {
        SetValid(FALSE);    // so we don't use a deleted object
    }
    
    INT GetFamilyCount ();                         // number of enumerable families in the collection
    GpStatus GetFamilies (                         // enumerate the fonts in a collection
        INT             numSought,
        GpFontFamily*   gpfamilies[],
        INT*            numFound
        );

    virtual BOOL LoadRegistered()=0;    // is TRUE if we should load all registered
                                        // fonts every time we try to enumerate
                                        // (e.g., if the object is an installed
                                        // font collection)
    GpFontTable *GetFontTable()     { return FontTable; }

protected:
    GpFontTable *FontTable;             // hash table of GpFontFile
};


class GpInstalledFontCollection : public GpFontCollection
{
public:

    ~GpInstalledFontCollection();
    static GpInstalledFontCollection* GetGpInstalledFontCollection();
    GpStatus InstallFontFile (const WCHAR *filename);
    GpStatus UninstallFontFile (const WCHAR *filename);
    virtual BOOL LoadRegistered()       { return TRUE; }

protected:
    GpInstalledFontCollection();

private:
    static GpInstalledFontCollection* instance;
};

class GpPrivateFontCollection : public GpFontCollection
{
public:
    GpPrivateFontCollection();
    ~GpPrivateFontCollection();
    
    GpStatus AddFontFile (const WCHAR *filename);
    GpStatus AddMemoryFont (const void *memory, INT length);
    virtual BOOL LoadRegistered()       { return FALSE; }
};

#endif // FONTCOLLECTION_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\fontfileplus.cpp ===
// formerly pffobj.cxx

#include "precomp.hpp"

INT APIENTRY EngPlusMultiByteToWideChar(
    UINT CodePage,
    LPWSTR WideCharString,
    INT BytesInWideCharString,
    LPSTR MultiByteString,
    INT BytesInMultiByteString
    )
{
    return MultiByteToWideChar(CodePage, 0,
                               MultiByteString,BytesInMultiByteString,
                               WideCharString, BytesInWideCharString/sizeof(WCHAR)
                               );
    // returns zero on error
}

INT APIENTRY EngWideCharToMultiByte(
    UINT CodePage,
    LPWSTR WideCharString,
    INT BytesInWideCharString,
    LPSTR MultiByteString,
    INT BytesInMultiByteString
    )
{
    return WideCharToMultiByte(
    CodePage, 0,
    WideCharString,  BytesInWideCharString,
    MultiByteString,BytesInMultiByteString,
    NULL, NULL
    );
}

VOID APIENTRY EngGetCurrentCodePage(
    PUSHORT pOemCodePage,
    PUSHORT pAnsiCodePage
    )
{
    *pAnsiCodePage = (USHORT) GetACP();
    *pOemCodePage = (USHORT) GetOEMCP();
}


VOID APIENTRY EngUnmapFontFileFD(
    ULONG_PTR iFile
    )
{
    FONTFILEVIEW *pffv = (FONTFILEVIEW *)iFile;

    pffv->mapCount--;

    if ((pffv->mapCount == 0) && pffv->pvView)
    {
        if (pffv->pwszPath)
        {
            UnmapViewOfFile(pffv->pvView);
            pffv->pvView = NULL;
        }
    }
}


BOOL APIENTRY EngMapFontFileFD(
    ULONG_PTR  iFile,
    PULONG *ppjBuf,
    ULONG  *pcjBuf
    )
{
    FONTFILEVIEW *pffv = (FONTFILEVIEW *)iFile;
    BOOL bRet = FALSE;

    if (pffv->mapCount)
    {
        pffv->mapCount++;
        if (ppjBuf)
        {
            *ppjBuf = (PULONG)pffv->pvView;
        }
        if (pcjBuf)
        {
            *pcjBuf = pffv->cjView;
        }
        return TRUE;
    }

    if (pffv->pwszPath)
    {
        HANDLE hFile;

        if (Globals::IsNt)
        {
            hFile = CreateFileW(pffv->pwszPath, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
        }
        else  // Windows 9x - non-Unicode
        {
            AnsiStrFromUnicode ansiPath(pffv->pwszPath);

            if (ansiPath.IsValid())
            {
                hFile = CreateFileA(ansiPath, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
            } else {
                hFile = INVALID_HANDLE_VALUE;
            }
        }

        if (hFile != INVALID_HANDLE_VALUE)
        {
            ULARGE_INTEGER lastWriteTime;
            
            if (GetFileTime(hFile, NULL, NULL, (FILETIME *) &lastWriteTime.QuadPart) &&
                lastWriteTime.QuadPart == pffv->LastWriteTime.QuadPart)
            {

                *pcjBuf = GetFileSize(hFile, NULL);

                if (*pcjBuf != -1)
                {
                    HANDLE hFileMapping = CreateFileMappingA(hFile, 0, PAGE_READONLY, 0, 0, NULL); // "mappingobject");

                    if (hFileMapping)
                    {
                        *ppjBuf = (PULONG)MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);
    
                        if (*ppjBuf)
                        {
                            bRet = TRUE;
                            pffv->pvView = *ppjBuf;
                            pffv->cjView = *pcjBuf;
                            pffv->mapCount = 1;
                        }
    
                        CloseHandle(hFileMapping);
                    }
                }
            }
            
            CloseHandle(hFile);
        }
    }

    return bRet;
}


GpFontFile *LoadFontMemImage(
    WCHAR* fontImageName,
    BYTE* fontMemoryImage,
    INT fontImageSize
    )
{
    ULONG cwc = UnicodeStringLength(fontImageName) + 1;
    FONTFILEVIEW *pffv;
    
    if ((pffv = (FONTFILEVIEW *)GpMalloc(sizeof(FONTFILEVIEW))) == NULL)
        return NULL;
    else
    {
        PVOID pvImage;
    
        if ((pvImage = (PVOID)GpMalloc(fontImageSize)) == NULL)
        {
            GpFree(pffv);
            return NULL;
        }
    
        GpMemcpy(pvImage, fontMemoryImage, fontImageSize);
    
        pffv->LastWriteTime.QuadPart = 0;
        pffv->pvView = pvImage;
        pffv->cjView = fontImageSize;
        pffv->mapCount = 1;
        pffv->pwszPath = NULL;
    
        return (LoadFontInternal(fontImageName, cwc, pffv, TRUE));
    }
}


GpFontFile *LoadFontFile(WCHAR *awcPath)
{
    // convert font file name to fully qualified path
    
    ULONG cwc = UnicodeStringLength(awcPath) + 1; // for term. zero

    FONTFILEVIEW *pffv;
    HANDLE       hFile;

    if ((pffv = (FONTFILEVIEW *)GpMalloc(sizeof(FONTFILEVIEW))) == NULL)
    {
        return NULL;
    }

    pffv->LastWriteTime.QuadPart = 0;
    pffv->pvView = NULL;
    pffv->cjView = 0;
    pffv->mapCount = 0;
    pffv->pwszPath = awcPath;

    if (Globals::IsNt)
    {
        hFile = CreateFileW(pffv->pwszPath, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
    }
    else  // Windows 9x - non-Unicode
    {
        AnsiStrFromUnicode ansiPath(pffv->pwszPath);

        if (ansiPath.IsValid())
        {
            hFile = CreateFileA(ansiPath, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
        } else {
            hFile = INVALID_HANDLE_VALUE;
        }
    }

    if (hFile != INVALID_HANDLE_VALUE)
    {
        if (!(pffv->cjView = GetFileSize(hFile, NULL)))
        {
            CloseHandle(hFile);
            goto error;
        }

        if (!GetFileTime(hFile, NULL, NULL, (FILETIME *) &pffv->LastWriteTime.QuadPart))
        {
            CloseHandle(hFile);
            goto error;
        }

        CloseHandle(hFile);
        
        return (LoadFontInternal(awcPath, cwc, pffv, FALSE));
    }

error:

    GpFree(pffv);
    
    return NULL;
        
}


GpFontFile *LoadFontInternal(
    WCHAR *         awcPath,
    ULONG           cwc,
    FONTFILEVIEW *  pffv,
    BOOL            bMem
)
{
    GpFontFile *pFontFile = NULL;

    
    ULONG_PTR  hffNew = ttfdSemLoadFontFile(// 1, // #OF FILES
                                       (ULONG_PTR *)&pffv,
                                       (ULONG) Globals::LanguageID //   for english US
                                       );

    if (hffNew)
    {
        ULONG cFonts = ttfdQueryNumFaces(hffNew);

        if (cFonts && cFonts != FD_ERROR)
        {
            ULONG cjFontFile = offsetof(GpFontFile, aulData) +
                               cFonts * sizeof(GpFontFace)   +
                               cFonts * sizeof(ULONG_PTR)    +
                               cwc * sizeof(WCHAR);

            pFontFile = (GpFontFile *)GpMalloc(cjFontFile);
            if (!pFontFile)
            {
                ttfdSemUnloadFontFile(hffNew);
                if (pffv->pwszPath == NULL)
                    GpFree(pffv->pvView);
                GpFree(pffv);
                return NULL;
            }

            pFontFile->SizeOfThis = cjFontFile;

            // Connect GpFontFile's sharing the same hash bucket
            
            pFontFile->SetNext(NULL);
            pFontFile->SetPrev(NULL);       

            // Point family names to appropriate memory
            
            pFontFile->AllocateNameHolders( 
                (WCHAR **)(
                            (BYTE *)pFontFile               + 
                            offsetof(GpFontFile, aulData)   +
                            cFonts * sizeof(GpFontFace)), cFonts);

            // pwszPathname_ points to the Unicode upper case path
            // name of the associated font file which is stored at the
            // end of the data structure.
            pFontFile->pwszPathname_ =  (WCHAR *)((BYTE *)pFontFile   +
                                        offsetof(GpFontFile, aulData) +
                                        cFonts * sizeof(ULONG_PTR)    +
                                        cFonts * sizeof(GpFontFace));

            UnicodeStringCopy(pFontFile->pwszPathname_, awcPath);
            pFontFile->cwc = cwc;            // total for all strings

            // state
            pFontFile->flState  = 0;        // state (ready to die?)
            pFontFile->cLoaded = 1;
            
            pFontFile->cRealizedFace = 0;        // total number of RFONTs
            pFontFile->bRemoved = FALSE;    // number of referring FontFamily objects

            // RFONT list

            pFontFile->prfaceList = NULL;    // pointer to head of doubly linked list

            // driver information

            pFontFile->hff = hffNew;          // font driver handle to font file, RETURNED by DrvLoadGpFontFile

            // identifies the font driver, it could be a printer driver as well

            // ULONG           ulCheckSum;     // checksum info used for UFI's

            // fonts in this file (and filename slimed in)

            pFontFile->cFonts = cFonts;     // number of fonts (same as chpfe)

            pFontFile->pfv = pffv;          // FILEVIEW structure, passed to DrvLoadFontFile
            
            if (pFontFile->pfv->pwszPath)   // not a memory image
            {
                pFontFile->pfv->pwszPath = pFontFile->pwszPathname_;
            }
  
            // loop over pfe's, init the data:
            GpFontFace *pfe = (GpFontFace *)pFontFile->aulData;
            for (ULONG iFont = 0; iFont < cFonts; iFont++)
            {
                pfe[iFont].pff = pFontFile;   // pointer to physical font file object
                pfe[iFont].iFont = iFont + 1;     // index of the font for IFI or device, 1 based

                pfe[iFont].flPFE = 0;         //!!! REVIEW carefully

                if ((pfe[iFont].pifi = ttfdQueryFont(hffNew, (iFont + 1), &pfe[iFont].idifi)) == NULL )
                {
                    VERBOSE(("Error setting pifi for entry %d.", iFont));

                    ttfdSemUnloadFontFile(hffNew);
                    GpFree(pFontFile);
                    if (pffv->pwszPath == NULL)
                        GpFree(pffv->pvView);
                    GpFree(pffv);
                    return NULL;
                }

                pfe[iFont].NumGlyphs = 0;

                pfe[iFont].NumGlyphs = pfe[iFont].pifi->cig;

                pfe[iFont].cGpFontFamilyRef = 0;

                pfe[iFont].lfCharset = DEFAULT_CHARSET;

                pfe[iFont].SetSymbol(FALSE);

                if (pfe[iFont].InitializeImagerTables() == FALSE)
                {
                    VERBOSE(("Error initializing imager tables for entry %d.", iFont));

                    ttfdSemUnloadFontFile(hffNew);
                    GpFree(pFontFile);
                    if (pffv->pwszPath == NULL)
                        GpFree(pffv->pvView);
                    GpFree(pffv);
                    return NULL;
                }

                //  Set the font family name from the first font entry

                pFontFile->SetFamilyName(iFont, ((WCHAR *)(((BYTE*) pfe[iFont].pifi) + pfe[iFont].pifi->dpwszFamilyName)));
            }
        }
    }

    if (pFontFile == NULL)
    {
        if (pffv->pwszPath == NULL)
            GpFree(pffv->pvView);
        GpFree(pffv);
    }

    return pFontFile;
}


VOID UnloadFontFile(GpFontFile *pFontFile)
{
    return;
}


/******************************Public*Routine******************************\
* bMakePathNameW (PWSZ pwszDst, PWSZ pwszSrc, PWSZ *ppwszFilePart)
*
* Converts the filename pszSrc into a fully qualified pathname pszDst.
* The parameter pszDst must point to a WCHAR buffer at least
* MAX_PATH*sizeof(WCHAR) bytes in size.
*
* An attempt is made find the file first in the new win95 directory
* %windows%\fonts (which also is the first directory in secure font path,
* if one is defined) and then we do the old fashioned windows stuff
* where SearchPathW searches directories in usual order
*
* ppwszFilePart is set to point to the last component of the pathname (i.e.,
* the filename part) in pwszDst.  If this is null it is ignored.
*
* Returns:
*   TRUE if sucessful, FALSE if an error occurs.
*
* History:
*  Mon 02-Oct-1995 -by- Bodin Dresevic [BodinD]
* update: added font path stuff
*  30-Sep-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/
extern "C" int __cdecl 
HackStrncmp( 
    const char *str1, 
    const char *str2, 
    size_t count 
    ) ;


BOOL MakePathName(
    WCHAR  *dst, WCHAR  *src
)
{
    WCHAR*  pwszF;
    ULONG   path_length = 0;    // essential to initialize


    if (OSInfo::IsNT)
    {

    //    ASSERTGDI(Globals::FontsDir, "gpwcFontsDir not initialized\n");

    // if relative path

        if ( (src[0] != L'\\') && !((src[1] == L':') && (src[2] == L'\\')) )
        {
        // find out if the font file is in %windir%\fonts

            path_length = SearchPathW(
                                Globals::FontsDirW,
                                src,
                                NULL,
                                MAX_PATH,
                                dst,
                                &pwszF);

    #ifdef DEBUG_PATH
            TERSE(("SPW1: pwszSrc = %ws", src));
            if (path_length)
                TERSE(("SPW1: pwszDst = %ws", dst));
    #endif // DEBUG_PATH
        }

    // Search for file using default windows path and return full pathname.
    // We will only do so if we did not already find the font in the
    // %windir%\fonts directory or if pswzSrc points to the full path
    // in which case search path is ignored

        if (path_length == 0)
        {
            path_length = SearchPathW (
                            NULL,
                            src,
                            NULL,
                            MAX_PATH,
                            dst,
                            &pwszF);
    #ifdef DEBUG_PATH
            TERSE(("SPW2: pwszSrc = %ws", src));
            if (path_length)
                TERSE(("SPW2: pwszDst = %ws", dst));
    #endif // DEBUG_PATH
        }
    } else {
        /* Windows 9x */
        CHAR*  pwszFA;

        CHAR srcA[MAX_PATH];
        CHAR dstA[MAX_PATH];
        CHAR file_partA[MAX_PATH];

        memset(srcA, 0, sizeof(srcA));
        memset(dstA, 0, sizeof(dstA));
        memset(file_partA, 0, sizeof(file_partA));


        WideCharToMultiByte(CP_ACP, 0, src, UnicodeStringLength(src), srcA, MAX_PATH, 0, 0);

    //    ASSERTGDI(Globals::FontsDir, "gpwcFontsDir not initialized\n");

    // if relative path

        if ( (srcA[0] != '\\') && !((srcA[1] == ':') && (srcA[2] == '\\')) )
        {
        // find out if the font file is in %windir%\fonts

            path_length = SearchPathA(
                                Globals::FontsDirA,
                                srcA,
                                NULL,
                                MAX_PATH,
                                dstA,
                                (char**)&pwszFA);

        }

    // Search for file using default windows path and return full pathname.
    // We will only do so if we did not already find the font in the
    // %windir%\fonts directory or if pswzSrc points to the full path
    // in which case search path is ignored

        if (path_length == 0)
        {
            path_length = SearchPathA (
                                NULL,
                                srcA,
                                NULL,
                                MAX_PATH,
                                dstA,
                                &pwszFA);
    #ifdef DEBUG_PATH
            TERSE(("SPW2: pwszSrc = %ws", src));
            if (path_length)
                TERSE(("SPW2: pwszDst = %ws", dst));
    #endif // DEBUG_PATH
        }
        MultiByteToWideChar(CP_ACP, 0, dstA, strlen(dstA), dst, MAX_PATH);
        dst[path_length] = 0; /* null termination */

    }


// If search was successful return TRUE:

    return (path_length != 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\fontfilecache.hpp ===
/*****************************************************************************
* Module Name: fontfilecache.hpp
*
* Font File Cahce for GDI+.
*
* History:
*
*  11-9-99 Yung-Jen Tony Tsai   Wrote it.
*
* Copyright (c) 1999-2000 Microsoft Corporation
*****************************************************************************/

#ifndef _FONTFILECACHE_
#if DBG
#include <mmsystem.h>
#endif

#define _FONTFILECACHE_

// For system fonts do not include in font reg 

#define QWORD_ALIGN(x) (((x) + 7L) & ~7L)

#define SZ_FONTCACHE_HEADER() QWORD_ALIGN(sizeof(FONTFILECACHEHEADER))

// 3 modes of font boot cache operation

#define FONT_CACHE_CLOSE_MODE        0x0
#define FONT_CACHE_LOOKUP_MODE       0x1
#define FONT_CACHE_CREATE_MODE       0x2
#define FONT_CACHE_ERROR_MODE        0x3

#define FONT_CACHE_MASK (FONT_CACHE_LOOKUP_MODE | FONT_CACHE_CREATE_MODE)

typedef struct _FONTFILECACHEHEADER 
{
    ULONG           CheckSum;
    ULONG           ulMajorVersionNumber;
    ULONG           ulMinorVersionNumber;
    ULONG           ulLanguageID;     // For NT5 or later version
    ULONG           ulFileSize;     // total size of fntcache.dat
    ULONG           ulDataSize;
    ULARGE_INTEGER  FntRegLWT;
} FONTFILECACHEHEADER;

typedef struct _FONTFILECACHE
{
    FONTFILECACHEHEADER *pFile;
    HANDLE              hFile;                  // Handle of file of font file cache
    HANDLE              hFileMapping;           // Handle of file mapping
    HMODULE             hShFolder; 
    ULONG               cjFileSize;             // size of font file cache
    PBYTE               pCacheBuf;              // read pointers point to the old table
    BOOL                bReadFromRegistry;    
} FONTFILECACHE;

VOID    InitFontFileCache();
FLONG   GetFontFileCacheState();
VOID    vCloseFontFileCache();

VOID  FontFileCacheFault();
PVOID FontFileCacheAlloc(ULONG ulSize);
PVOID FontFileCacheLookUp(ULONG *pcjData);
BOOL  FontFileCacheReadRegistry();

#if DBG
class MyTimer
{
public:
    MyTimer()
    {
    
    // Set the timer resolution to 1ms
        timerOn = TRUE;
        
        if (timeBeginPeriod(1) == TIMERR_NOCANDO)
        {
            WARNING(("The multimedia timer doesn't work"));
            timerOn=FALSE;
        }
        start = timeGetTime();
    }

    ~MyTimer() {}

    DWORD GetElapsedTime(void)
    {
        DWORD elapsed = 0;
        
        if (timerOn)
        {
            end = timeGetTime();
            elapsed = end-start;

            timeEndPeriod(1);
        }

        return elapsed;
    }

    BOOL On(void)
    {
        return (timerOn);
    }
    
    
private:
    BOOL timerOn;
    DWORD start, end;
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\fontfilecache.cpp ===
#include "precomp.hpp"
#include <shlobj.h>
#include <strsafe.h>

#define FONTFILECACHEPATH_W TEXT("\\GDIPFONTCACHEV1.DAT")
#define FONTFILECACHEPATH_A "\\GDIPFONTCACHEV1.DAT"
#define FONTFILECACHEREGLOC_W TEXT("Software\\Microsoft\\GDIPlus")
#define FONTFILECACHEREGKEY_W TEXT("FontCachePath")

#define FONTLOADCACHE_NAMEOBJ "GdiplusFontCacheFileV1"

#define FONT_CACHE_EXTRA_SIZE (8 * 1024)

// Just for tempary use
#define FONTFILECACHE_VER   0x185

//--------------------------------------------------------------------------
// Unicode wrappers for win9x - defined in imgutils.hpp (include file conflict)
//--------------------------------------------------------------------------

LONG
_RegCreateKey(
    HKEY rootKey,
    const WCHAR* keyname,
    REGSAM samDesired,
    HKEY* hkeyResult
    );

LONG
_RegSetString(
    HKEY hkey,
    const WCHAR* name,
    const WCHAR* value
    );

// todo: this should replace _RegGetString and go away to better place (mikhaill 2/14/2002)
LONG
_RegGetStringSafe(
    HKEY hkey,
    const WCHAR* name,
    WCHAR* buf,
    DWORD size
    )
{
    LONG status;
    DWORD regtype;
    DWORD regsize;

    if (OSInfo::IsNT)
    {   // Windows NT - Unicode

        regsize = size;

        status = RegQueryValueExW(
                    hkey,
                    name,
                    NULL,
                    &regtype,
                    (BYTE*) buf,
                    &regsize);

        if (status != ERROR_SUCCESS) return status;
        if (regtype != REG_SZ) return ERROR_INVALID_DATA;
        DWORD wregsize = regsize/sizeof(WCHAR);
        if (wregsize == 0 || buf[wregsize-1] != 0) return ERROR_INVALID_DATA;
        return ERROR_SUCCESS;
    }
    else
    {   // Windows 9x - non-Unicode

        CHAR ansibuf[MAX_PATH];
        AnsiStrFromUnicode nameStr(name);

        if (!nameStr.IsValid())
            return ERROR_INVALID_DATA;

        regsize = MAX_PATH;

        status = RegQueryValueExA(
                    hkey,
                    nameStr,
                    NULL,
                    &regtype,
                    (BYTE*) ansibuf,
                    &regsize);

        if (status != ERROR_SUCCESS) return status;
        if (regtype != REG_SZ) return ERROR_INVALID_DATA;
        if (regsize == 0 || ansibuf[regsize-1] != 0
            || regsize*sizeof(WCHAR) > size) return ERROR_INVALID_DATA;

        BOOL ok = AnsiToUnicodeStr(ansibuf, buf, regsize);
        return ok ? ERROR_SUCCESS : ERROR_INVALID_DATA;
    }
}

#define SIZED(x) x, sizeof(x)

#define STRCPY_W(dst, src, fail) if ( FAILED( StringCbCopyW  ( SIZED(dst), src ) ) ) goto fail
#define STRCAT_W(dst, src, fail) if ( FAILED( StringCbCatW   ( SIZED(dst), src ) ) ) goto fail
#define STRCPY_A(dst, src, fail) if ( FAILED( StringCbCopyA  ( SIZED(dst), src ) ) ) goto fail
#define STRCAT_A(dst, src, fail) if ( FAILED( StringCbCatA   ( SIZED(dst), src ) ) ) goto fail
#define STRCHK_W(     src, fail) if ( FAILED( StringCbLengthW( SIZED(src), 0   ) ) ) goto fail


// There are 2 levels synchronization mechanism need to take care
// First level: The lock for GDIPFONTCACHEV1.DAT
//    GDIPFONTCACHEV1.DAT is a gloabl file and will be share by different process
// Second level: The lock fof gflFontCacheState and gFontFileCache
//    They should be shared by different thread in the same process.
//    We define a CriticalSec in gFontFileCache.

// mikhaill 02/15/02: at this time there is no separate critical section for cache file;
// instead the common Globals::TextCriticalSection is used - see comments by claudebe in globals.hpp.

FLONG           gflFontCacheState;
FONTFILECACHE   gFontFileCache;
HANDLE          ghsemFontFileCache = NULL;

ULONG CalcFontFileCacheCheckSum(PVOID pvFile, ULONG cjFileSize);
VOID vReleaseFontCacheFile(VOID);

typedef HRESULT (* PSHGETFOLDERPATHA) (HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPSTR pszPath);
typedef HRESULT (* PSHGETFOLDERPATHW) (HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPWSTR pszPath);

/*****************************************************************************
 * VOID vReleaseFontCacheFile(VOID)
 *
 * Unmap the view of the file
 *
 * History
 *  11-09-99 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

VOID vReleaseFontCacheFile(VOID)
{

    if (gFontFileCache.pFile)
    {
        UnmapViewOfFile(gFontFileCache.pFile);
        gFontFileCache.pFile = NULL;
    }

    if (gFontFileCache.hFileMapping)
    {
        CloseHandle(gFontFileCache.hFileMapping);
        gFontFileCache.hFileMapping = 0;
    }

    if (gFontFileCache.hFile)
    {
        CloseHandle(gFontFileCache.hFile);
        gFontFileCache.hFile = 0;
    }
}

/*****************************************************************************
 * BOOL  bOpenFontFileCache()
 *
 * Initialize font file cache, open the cacheplus.dat file and create hash table
 *
 * History
 *  11-09-99 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

BOOL bOpenFontCacheFile(BOOL bOpenOnly, ULONG cjFileSize, BOOL bReAlloc)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    PBYTE  pFile = NULL;
    BOOL   bOK = FALSE;
    DWORD  dwCreation = 0;
#if DBG
    DWORD  dwError = 0;
#endif
    WCHAR  wszFilePath[MAX_PATH];
    WCHAR  wszPathOnly[MAX_PATH];
    CHAR   szFilePath[MAX_PATH];
    CHAR   szPathOnly[MAX_PATH];
    BOOL   bRegValid = FALSE;

    // initialize strings...
    wszFilePath[0] = 0;
    wszPathOnly[0] = 0;
    szFilePath[0]  = 0;
    szPathOnly[0]  = 0;

    if (bOpenOnly)
    {
        dwCreation = OPEN_EXISTING;
    }
    else
    {
        dwCreation = CREATE_ALWAYS;
    }

    // First check the registry to see if we can bypass loading SHFolder
    HKEY hkey = (HKEY)NULL;
    const WCHAR wchLocation[] = FONTFILECACHEREGLOC_W;
    const WCHAR wchValue[] = FONTFILECACHEREGKEY_W;
    DWORD valueLength = sizeof(wszFilePath);

    // If this fails, we cannot access the registry key...
    if (_RegCreateKey(HKEY_CURRENT_USER, wchLocation, KEY_ALL_ACCESS, &hkey) != ERROR_SUCCESS)
        hkey = NULL;


    if (hkey && _RegGetStringSafe(hkey, wchValue, wszFilePath, valueLength) == ERROR_SUCCESS)
    {
        // The key exists, so we should read the location of the font file
        // from there instead of loading the SHFolder.DLL...

        STRCPY_W(wszPathOnly, wszFilePath, fail_1);

        // Append the name of cache file
        STRCAT_W(wszFilePath, FONTFILECACHEPATH_W, fail_1);

        if (Globals::IsNt)
        {
            hFile = CreateFileW(
                wszFilePath,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                dwCreation,
                FILE_ATTRIBUTE_NORMAL,
                NULL);
        }
        else
        {
            AnsiStrFromUnicode ansiStr(wszFilePath);

            if (ansiStr.IsValid())
            {
                hFile = CreateFileA(
                    ansiStr,
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    dwCreation,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);
            }
        }

        if (hFile != INVALID_HANDLE_VALUE)
            bRegValid = TRUE;

        fail_1:;
    }

    if (hFile == INVALID_HANDLE_VALUE)
    {
        // Use SHFolder.DLL to find the proper location for the file if the
        // registry key is not present or is incorrect.

        if (Globals::IsNt)
        {
            // Two steps to get the cache file
            // If SHFolder.DLL is existed then we will put the cache file in CSIDL_LOCAL_APPDATA
            // Or put it on %SystemRoot%\system32 for WINNT

            PSHGETFOLDERPATHW pfnSHGetFolderPathW = NULL;

            // Load SHFolder.DLL
            if (!gFontFileCache.hShFolder)
                gFontFileCache.hShFolder = LoadLibraryW(L"ShFolder.DLL");

            // If SHFolder.DLL is existed then we will put the cache file in CSIDL_LOCAL_APPDATA
            if (gFontFileCache.hShFolder)
            {
                // Get the function SHGetFolderPath
                pfnSHGetFolderPathW = (PSHGETFOLDERPATHW) GetProcAddress(gFontFileCache.hShFolder, "SHGetFolderPathW");

                if (pfnSHGetFolderPathW)
                {
                    // On NT and higher we should use the CSIDL_LOCAL_APPDATA so that this data
                    // does not roam...

                    if ((*pfnSHGetFolderPathW) (NULL, CSIDL_LOCAL_APPDATA | CSIDL_FLAG_CREATE,
                                            NULL, 0, wszFilePath) == E_INVALIDARG)
                    {
                        // CSIDL_LOCAL_APPDATA not understood, use CSIDL_APPDATA (IE 5.0 not present)
                        (*pfnSHGetFolderPathW) (NULL, CSIDL_APPDATA | CSIDL_FLAG_CREATE,
                                            NULL, 0, wszFilePath);
                    }

                    // Check whether ShFolder.DLL generated good string
                    STRCHK_W(wszFilePath, fail_2);

                    // Keep a copy of the path for registry update...
                    STRCPY_W(wszPathOnly, wszFilePath, fail_2);

                    // Append the name of cache file
                    STRCAT_W(wszFilePath, FONTFILECACHEPATH_W, fail_2);

                    hFile = CreateFileW(wszFilePath, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
                                            NULL, dwCreation, FILE_ATTRIBUTE_NORMAL, NULL);
                    fail_2:;
                }
            }

            // Try to put it on %SystemRoot%\system32 for WINNT
            if (hFile == INVALID_HANDLE_VALUE)
            {
                // Get path for system Dircectory
                UINT size = GetSystemDirectoryW(wszFilePath, MAX_PATH);
                if (size >= MAX_PATH) goto fail_3;

                // Keep a copy of the path for registry update...
                STRCPY_W(wszPathOnly, wszFilePath, fail_3);

                // Append the name of the cache file
                STRCAT_W(wszFilePath, FONTFILECACHEPATH_W, fail_3);

                hFile = CreateFileW(wszFilePath, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
                                        NULL, dwCreation, FILE_ATTRIBUTE_NORMAL, NULL);
                fail_3:;
            }
        }
        else
        {
            // Windows 9x - non-Unicode

            // Two steps to get the cache file
            // If SHFolder.DLL is existed then we will put the cache file in CSIDL_APPDATA
            // Or put it on %SystemRoot%\system for Win9x

            if (!gFontFileCache.hShFolder)
                gFontFileCache.hShFolder = LoadLibraryA("ShFolder.DLL");

            if (gFontFileCache.hShFolder)
            {
                PSHGETFOLDERPATHA pfnSHGetFolderPathA;

                pfnSHGetFolderPathA = (PSHGETFOLDERPATHA) GetProcAddress(gFontFileCache.hShFolder, "SHGetFolderPathA");

                if (pfnSHGetFolderPathA)
                {
                    (*pfnSHGetFolderPathA) (NULL, CSIDL_APPDATA | CSIDL_FLAG_CREATE,
                                                NULL, 0, szFilePath);

                    // Keep a copy of the path for registry update...
                    STRCPY_A(szPathOnly, szFilePath, fail_4);

                    STRCAT_A(szFilePath, FONTFILECACHEPATH_A, fail_4);

                    hFile = CreateFileA(szFilePath, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
                                            NULL, dwCreation, FILE_ATTRIBUTE_NORMAL, NULL);
                    fail_4:;
                }
            }

            if (hFile == INVALID_HANDLE_VALUE)
            {
                UINT size = GetSystemDirectoryA(szFilePath, MAX_PATH);
                if (size >= MAX_PATH) goto fail_5;

                // Keep a copy of the path for registry update...
                STRCPY_A(szPathOnly, szFilePath, fail_5);

                STRCAT_A(szFilePath, FONTFILECACHEPATH_A, fail_5);

                hFile = CreateFileA(szFilePath, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
                                        NULL, dwCreation, FILE_ATTRIBUTE_NORMAL, NULL);
                fail_5:;
            }

            if (hFile != INVALID_HANDLE_VALUE)
            {
                // szFilePath contains the ANSI full path, convert to unicode...
                AnsiToUnicodeStr(szPathOnly, wszPathOnly, sizeof(wszPathOnly)/sizeof(wszPathOnly[0]));
            }
        }
    }

    if (hkey)
    {
        if (hFile != INVALID_HANDLE_VALUE && !bRegValid)
        {
            // wszPathOnly contains the full path to the font cache file
            // so write it out to the registry key...

            _RegSetString(hkey, wchValue, wszPathOnly);
        }

        RegCloseKey(hkey);
    }

    if (hFile != INVALID_HANDLE_VALUE)
    {
        if ((dwCreation == OPEN_EXISTING) && !bReAlloc)
        {
            cjFileSize = GetFileSize(hFile, NULL);
        }

        if (cjFileSize != 0xffffffff)
        {
            HANDLE hFileMapping;

            if (Globals::IsNt)
            {
                hFileMapping = CreateFileMappingW(hFile, 0, PAGE_READWRITE, 0, cjFileSize, NULL);
            }
            else
            {
                hFileMapping = CreateFileMappingA(hFile, 0, PAGE_READWRITE, 0, cjFileSize, NULL);
            }

            if (hFileMapping)
            {

                pFile = (PBYTE)MapViewOfFile(hFileMapping, FILE_MAP_ALL_ACCESS, 0, 0, cjFileSize);

                // It should not be NULL if it is then we must know something wrong

                if (pFile)
                {
                    gFontFileCache.cjFileSize = cjFileSize;
                    gFontFileCache.hFile = hFile;
                    gFontFileCache.hFileMapping = hFileMapping;
                    gFontFileCache.pFile = (FONTFILECACHEHEADER *) pFile;
                    bOK = TRUE;
                }
                else
                {
                    CloseHandle(hFile);
#if DBG
                    dwError = GetLastError();
                    TERSE(("Error to map a view of a file %x", dwError));
#endif
                }
            }
            else
            {
                CloseHandle(hFile);
#if DBG
                dwError = GetLastError();
                TERSE(("Error to map a file %x", dwError));
#endif
            }
        }
    }
#if DBG
    else
    {
        if (!bOpenOnly)
        {
            dwError = GetLastError();
            TERSE(("Error to create a file %x", dwError));
        }
    }
#endif

    if (!bOK)
    {
        vReleaseFontCacheFile();
    }

    return bOK;
}


/*****************************************************************************
 * BOOL bReAllocCacheFile(ULONG ulSize)
 *
 * ReAlloc font cache buffer
 *
 * History
 * 11/16/99 YungT create it
 * Wrote it.
 *****************************************************************************/

BOOL bReAllocCacheFile(ULONG ulSize)
{
    BOOL            bOK = FALSE;
    ULONG           ulFileSizeOrg;
    ULONG           ulSizeExtra;
    ULONG           ulFileSize;

    ulFileSizeOrg = gFontFileCache.pFile->ulFileSize;

    ASSERT(ulSize > gFontFileCache.pFile->ulDataSize);

// Calculate the extra cache we need

    ulSizeExtra = QWORD_ALIGN(ulSize - gFontFileCache.pFile->ulDataSize);

    ulFileSize = ulFileSizeOrg + ulSizeExtra;

    if (gFontFileCache.pFile)
    {
       vReleaseFontCacheFile();
    }

    if (bOpenFontCacheFile(TRUE, ulFileSize, TRUE))
    {

        gFontFileCache.pFile->ulFileSize = ulFileSize;
        gFontFileCache.pFile->ulDataSize = ulSize;

        gFontFileCache.pCacheBuf = (PBYTE) gFontFileCache.pFile + SZ_FONTCACHE_HEADER();

        bOK = TRUE;
    }

    return bOK;
}

/*****************************************************************************
 * BOOL FontFileCacheReadRegistry()
 *
 * Decide we need to open registry or not when load from cache
 *
 * History
 *  07-28-2k Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

BOOL FontFileCacheReadRegistry()
{
    return gFontFileCache.bReadFromRegistry;
}

/*****************************************************************************
 * VOID    FontFileCacheFault()
 *
 * Fault reprot for Engine font cache.
 *
 * History
 *  11-15-99 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

VOID    FontFileCacheFault()
{
    gflFontCacheState = FONT_CACHE_ERROR_MODE;
}

/*****************************************************************************
 * PVOID FontFileCacheAlloc(ULONG ulFastCheckSum, ULONG ulSize)
 *
 * Alloc the cached buffer for font driver
 *
 * History
 *  11-15-99 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

PVOID FontFileCacheAlloc(ULONG ulSize)
{

    PVOID pvIfi = NULL;

    {
        ASSERT(gflFontCacheState & FONT_CACHE_CREATE_MODE);

        if (ghsemFontFileCache == NULL)
            return pvIfi;

        if (gflFontCacheState & FONT_CACHE_CREATE_MODE)
        {

            if ( (QWORD_ALIGN(ulSize) < gFontFileCache.pFile->ulDataSize)
                || bReAllocCacheFile(ulSize))
            {
                pvIfi = (PVOID) gFontFileCache.pCacheBuf;

            // Gaurantee the cache pointer is at 8 byte boundary
                gFontFileCache.pFile->ulDataSize = ulSize;
            }
            else
            {
                gflFontCacheState = FONT_CACHE_ERROR_MODE;
            }

        }
    }

    return pvIfi;
}

/*****************************************************************************
 * PVOID FontFileCacheLookUp(ULONG FastCheckSum, ULONG *pcjData)
 *
 * Lookup font cache
 *
 * History
 *  11-15-99 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

PVOID FontFileCacheLookUp(ULONG *pcjData)
{
    PBYTE       pCache = NULL;

    *pcjData = 0;

    ASSERT(ghsemFontFileCache);

    if (ghsemFontFileCache == NULL)
       return pCache;


    if (gflFontCacheState & FONT_CACHE_LOOKUP_MODE)
    {
            ASSERT(gFontFileCache.pFile);
            ASSERT(gFontFileCache.pCacheBuf == ((PBYTE) gFontFileCache.pFile +
                                                    SZ_FONTCACHE_HEADER()));
            *pcjData = gFontFileCache.pFile->ulDataSize;
            pCache = gFontFileCache.pCacheBuf;

            gFontFileCache.pCacheBuf += QWORD_ALIGN(*pcjData);
    }


    return (PVOID) pCache;
}

/*****************************************************************************
 * VOID  GetFontFileCacheState()
 *
 * Clean font file cache after load or update the cache file.
 *
 * History
 *  11-12-99 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

FLONG    GetFontFileCacheState()
{
    return gflFontCacheState;
}

/*****************************************************************************
 * VOID  vCloseFontFileCache()
 *
 * Clean font file cache after load or update the cache file.
 *
 * History
 *  11-12-99 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

VOID  vCloseFontFileCache()
{

// do paranoid check

    if (!ghsemFontFileCache)
        return;


    if (gflFontCacheState & FONT_CACHE_MASK)
    {

        if (gflFontCacheState & FONT_CACHE_CREATE_MODE)
        {
            // Close the file, we are done recreating it

            if (gFontFileCache.pFile)
            {
                gFontFileCache.pFile->CheckSum = CalcFontFileCacheCheckSum((PVOID) ((PBYTE) gFontFileCache.pFile + 4), (gFontFileCache.cjFileSize - 4));
            }
        }
    }

    if (gFontFileCache.hShFolder)
    {
        FreeLibrary(gFontFileCache.hShFolder);
        gFontFileCache.hShFolder = NULL;
    }

    vReleaseFontCacheFile();

    ReleaseSemaphore(ghsemFontFileCache, 1, NULL);

    CloseHandle(ghsemFontFileCache);

    ghsemFontFileCache = NULL;

    gflFontCacheState = 0;
}

/*****************************************************************************
 * ULONG CalcFontFileCacheCheckSum(PVOID pvFile, ULONG cjFileSize)
 *
 * Helper function for query fonts information from font registry
 *
 * History
 *  11-11-99 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

ULONG CalcFontFileCacheCheckSum(PVOID pvFile, ULONG cjFileSize)
{
    ULONG sum;
    PULONG pulCur,pulEnd;

    pulCur = (PULONG) pvFile;

    __try
    {
        for (sum = 0, pulEnd = pulCur + cjFileSize / sizeof(ULONG); pulCur < pulEnd; pulCur += 1)
        {
            sum += 256 * sum + *pulCur;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        sum = 0; // oh well, not very unique.
    }

    return ( sum < 2 ) ? 2 : sum;  // 0 is reserved for device fonts
                                      // 1 is reserved for TYPE1 fonts
}

/*****************************************************************************
 * ULONG QueryFontReg(ULARGE_INTEGER *pFontRegLastWriteTime, ULONG *pulFonts)
 *
 * Helper function for query fonts information from font registry
 *
 * History
 *  11-15-99 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

BOOL QueryFontReg(ULARGE_INTEGER *pFontRegLastWriteTime)
{
    BOOL bOK = FALSE;
    ULONG ulFonts;

    HKEY hkey;

    LONG error = (Globals::IsNt) ? RegOpenKeyExW(HKEY_LOCAL_MACHINE, Globals::FontsKeyW, 0, KEY_QUERY_VALUE, &hkey)
                                 : RegOpenKeyExA(HKEY_LOCAL_MACHINE, Globals::FontsKeyA, 0, KEY_QUERY_VALUE, &hkey);

    if (error == ERROR_SUCCESS)
    {
    // There is no difference between A or W APIs at this case.

        error = RegQueryInfoKeyA(hkey, NULL, NULL, NULL, NULL, NULL, NULL, &ulFonts, NULL, NULL, NULL,
                                        (FILETIME *)pFontRegLastWriteTime);

        if (error == ERROR_SUCCESS)
        {
            bOK = TRUE;
        }

        RegCloseKey(hkey);
    }

    return bOK;
}


/*****************************************************************************
 * BOOL  bCreateFontFileCache()
 *
 * Initialize font file cache, open the cacheplus.dat file and create hash table
 *
 * History
 *  11-09-99 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

BOOL bCreateFontCacheFile(ULARGE_INTEGER FntRegLWT)
{
    ULONG   ulSize;
    BOOL bOk = FALSE;

    ulSize = SZ_FONTCACHE_HEADER() + FONT_CACHE_EXTRA_SIZE;

    if (gFontFileCache.pFile)
    {
       vReleaseFontCacheFile();
    }


    if(bOpenFontCacheFile(FALSE, ulSize, FALSE))
    {
        gFontFileCache.pFile->ulLanguageID = (ULONG) Globals::LanguageID;
        gFontFileCache.pFile->CheckSum = 0;
        gFontFileCache.pFile->ulMajorVersionNumber = FONTFILECACHE_VER;
        gFontFileCache.pFile->FntRegLWT.QuadPart = FntRegLWT.QuadPart;
        gFontFileCache.pFile->ulFileSize = ulSize;
        gFontFileCache.pFile->ulDataSize = FONT_CACHE_EXTRA_SIZE;
        bOk = TRUE;
    }

    return bOk;
}

#if DBG
/*****************************************************************************
 * BOOL bFontFileCacheDisabled()
 *
 * Tempary routine for performance evaluation
 *
 * History
 *  11-29-99 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

BOOL bFontFileCacheDisabled()
{
    return FALSE;
}
#endif


BOOL bScanRegistry()
{
    ASSERT(!Globals::IsNt);

    BOOL bOK = TRUE;
    ULONG index = 0;
    ULONG registrySize = 0;
    ULONG numExpected;

    //  Open the key

    HKEY hkey;


    PBYTE pCached = (PBYTE) gFontFileCache.pFile + SZ_FONTCACHE_HEADER();

    if (*((ULONG *) pCached) != 0xBFBFBFBF)
        return FALSE;

    LONG error = RegOpenKeyExA(HKEY_LOCAL_MACHINE, Globals::FontsKeyA, 0, KEY_QUERY_VALUE, &hkey);

    if (error == ERROR_SUCCESS)
    {

        DWORD   allDataSize = 0;
        error = RegQueryInfoKeyA(hkey, NULL, NULL, NULL, NULL, NULL, NULL, &numExpected, NULL, NULL, NULL, NULL);

        if (error != ERROR_SUCCESS)
        {
            RegCloseKey(hkey);
            return FALSE;
        }

        PBYTE  pRegistryData;

        registrySize = *((ULONG *) (pCached + 4)) ;

        pRegistryData = pCached + 8;

        while (index < numExpected)
        {
            DWORD   regType = 0;
            DWORD   labelSize = MAX_PATH;
            DWORD   dataSize = MAX_PATH;
            CHAR    label[MAX_PATH];
            BYTE    data[MAX_PATH];

            error = RegEnumValueA(hkey, index, label, &labelSize, NULL, &regType, data, &dataSize);

            if (error == ERROR_NO_MORE_ITEMS)
            {
               bOK = FALSE;
               break;
            }

            if (allDataSize >= registrySize)
            {
               bOK = FALSE;
               break;
            }


            if (memcmp(pRegistryData, data, dataSize))
            {
               bOK = FALSE;
               break;
            }

            pRegistryData += dataSize;

            allDataSize += dataSize;

            index ++;
        }

        RegCloseKey(hkey);

        if (bOK && (allDataSize == registrySize))
            return TRUE;
    }

    return FALSE;

}
/*****************************************************************************
 * VOID  InitFontFileCache()
 *
 * Initialize font file cache, open the cacheplus.dat file and create hash table
 *
 * History
 *  11-09-99 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

VOID InitFontFileCache()
{
    ULARGE_INTEGER          FntRegLWT = { 0, 0};


    if (gflFontCacheState)
    {
        return;
    }

#if DBG
// Only for performance evaluation.
    if (bFontFileCacheDisabled())
    {
        goto CleanUp;
    }
#endif

// If the named semaphore object existed before the function call,
// the function returns a handle to the existing object and
// GetLastError returns ERROR_ALREADY_EXISTS.

    ghsemFontFileCache = CreateSemaphoreA( NULL, 1, 1, FONTLOADCACHE_NAMEOBJ);

// Something wrong, we can not go with font file cache
    if (ghsemFontFileCache == NULL)
    {
        goto CleanUp;
    }
    else
    {
        // Wait 5 seconds until the semaphore released.
        // No further attempts to create font file cache on timeout.
        // This does not mean deial of service - just will work
        // slower using GpFontTable::LoadAllFontsFromRegistry(FALSE).
        DWORD dwr = WaitForSingleObject(ghsemFontFileCache, 5000);
        if (dwr == WAIT_TIMEOUT) goto CleanUp;
    }

    gFontFileCache.pFile = NULL;

// now open the TT Fonts key :

    if (!QueryFontReg(&FntRegLWT))
    {
        goto CleanUp;
    }

    if (bOpenFontCacheFile(TRUE, 0, FALSE))
    {

     // File did not change from last time boot.

        if (gFontFileCache.pFile->CheckSum && gFontFileCache.cjFileSize == gFontFileCache.pFile->ulFileSize &&
            gFontFileCache.pFile->CheckSum == CalcFontFileCacheCheckSum((PVOID) ((PBYTE) gFontFileCache.pFile + 4), (gFontFileCache.cjFileSize - 4)) &&
            gFontFileCache.pFile->ulMajorVersionNumber == FONTFILECACHE_VER &&
            gFontFileCache.pFile->ulLanguageID == (ULONG) Globals::LanguageID && // If locale changed, we need to re-create the cache
            gFontFileCache.pFile->FntRegLWT.QuadPart == FntRegLWT.QuadPart && // If registry has been updated we need to re-create the cache file
            (FntRegLWT.QuadPart != 0 || bScanRegistry())
        )
        {
            gflFontCacheState = FONT_CACHE_LOOKUP_MODE;
        }
        else
        {
            if(bCreateFontCacheFile(FntRegLWT))
            {
            // If something will not match, then it means we need to create FNTCACHE again

                    gflFontCacheState = FONT_CACHE_CREATE_MODE;
            }
        }
    }
    else
    {

    // If there is no GDIPFONTCACHE.DAT file
    // Then we need to create it.

        if(bCreateFontCacheFile(FntRegLWT))
        {
            gflFontCacheState = FONT_CACHE_CREATE_MODE;

        }
    }

CleanUp:

// Semaphore initialized

    if (gflFontCacheState & FONT_CACHE_MASK)
    {

    // Initialize the start pointer of current Cache table

        gFontFileCache.pCacheBuf = (PBYTE) gFontFileCache.pFile + SZ_FONTCACHE_HEADER();

        if (FntRegLWT.QuadPart == (ULONGLONG) 0)
            gFontFileCache.bReadFromRegistry = TRUE;
        else
            gFontFileCache.bReadFromRegistry = FALSE;
    }
    else
    {
        gflFontCacheState = 0;

    // Clean up the memory

        if (gFontFileCache.pFile)
        {
            vReleaseFontCacheFile();
        }

        if (ghsemFontFileCache)
        {
            ReleaseSemaphore(ghsemFontFileCache, 1, NULL);
            CloseHandle( ghsemFontFileCache);
            ghsemFontFileCache = NULL;
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\fontlinking.cpp ===
/**************************************************************************\
*
* Copyright (c) 2000  Microsoft Corporation
*
* Abstract:
*
*   Font linking handling
*
* Revision History:
*
*   3/03/2000 Tarek Mahmoud Sayed
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

static const WCHAR FontLinkKeyW[] = 
    L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\FontLink\\SystemLink";

static const WCHAR FontSubstitutesKeyW[] =
    L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\FontSubstitutes";
    
static const WCHAR EudcKeyW[]=L"EUDC\\";
static const char  EudcKeyA[]= "EUDC\\";

static const char  WinIniFontSubstitutionSectionName[] = "FontSubstitutes";

/**************************************************************************\
*
* Function Description:
*   Font Linking constructor.
*   caches the font linking and EUDC from the registry.
*   
*
* Arguments:
*
* Returns:
*       
*
* History:
*
*   3/3/2000 Tarek Mahmoud Sayed
*       Created it.
*
\**************************************************************************/

GpFontLink::GpFontLink():
    DefaultFamily          (NULL),
    linkedFonts            (NULL),
    eudcCache              (NULL),
    privateFonts           (NULL),
    FontSubstitutionTable  (NULL),
    substitutionCount      (0)
{
    // Before we cache the font linking and substitution data we need to 
    // make sure we loaded the font table data.

    GpFontTable *fontTable = Globals::FontCollection->GetFontTable();

    if (!fontTable->IsValid())
        return;

    if (!fontTable->IsFontLoaded())
        fontTable->LoadAllFonts();

    if (Globals::IsNt)
    {
        GetFontLinkingDataFromRegistryW();
        GetEudcDataFromTheRegistryW();
        CacheFontSubstitutionDataW();
    }
    else
    {
        // There is no font linking in Win9x. and we don't support the font association 
        // because it is for Ansi support and not Unicode.
        // we support the font substitution under win9x.
        GetEudcDataFromTheRegistryA();
        CacheFontSubstitutionDataA();
    }
}



/**************************************************************************\
*
* Function Description:
*
*   If not already cached, create the default family to be used for font
*   that is not linked by default.
*
*   o  Search for the subtitution font of "MS Shell Dlg"
*   o  Use the font the "MS Shell Dlg" substitution is linked to if exist
*   o  If no "MS Shell Dlg" found, use the final font of the first fontlink
*      entry found if fontlinking is supported in the system.
*   o  If not, lookup hardcoded UI font via system default ansi codepage.
*
* History:
*
*   4/19/2001 Worachai Chaoweeraprasit
*       Created it.
*
\**************************************************************************/

const AssociatedFamilies *GpFontLink::GetDefaultFamily()
{
    if (!DefaultFamily)
    {
        AssociatedFamilies *associated = NULL;
        
        GpFontFamily *family = GetFamilySubstitution(L"MS Shell Dlg");

        if (family)
        {
            associated = GetLinkedFonts(family);
        }
        else
        {
            //  "MS Shell Dlg" not found,
            //  try the first linking font found if one existed

            if (linkedFonts)
            {
                family = linkedFonts->family;
                associated = linkedFonts->associatedFamilies;
            }
            else
            {
                //  No fontlinking supported in this machine. This is likely a Win9x system, 
                //  lookup default UI font via ACP.
                
                typedef struct
                {
                    UINT AnsiCodepage;
                    const WCHAR* FamilyName;
                } AssociatedUIFonts;

                static const UINT MaxEastAsianCodepages = 4;
                static const AssociatedUIFonts uiFonts[MaxEastAsianCodepages] =
                {
                    { 932, L"MS UI Gothic" },   // Japanese
                    { 949, L"Gulim" },          // Korean
                    { 950, L"PMingLiu" },       // Traditional Chinese
                    { 936, L"Simsun" }          // Simplified Chinese
                };

                const WCHAR *familyName = NULL;

                for (UINT i = 0; i < MaxEastAsianCodepages; i++)
                {
                    if (uiFonts[i].AnsiCodepage == Globals::ACP)
                    {
                        familyName = uiFonts[i].FamilyName;
                        break;
                    }
                }

                if (familyName)
                {
                    GpFontTable *fontTable = Globals::FontCollection->GetFontTable();
                    if (fontTable)
                    {
                        family = fontTable->GetFontFamily(familyName);
                    }
                }
            }
        }

        if (family)
        {
            DefaultFamily = &DefaultFamilyBuffer;
            DefaultFamily->family = family;
            DefaultFamily->next = associated;
        }
        else
        {
            //  Nothing we could use,
            //  let's make sure we wouldnt try to cache it again.
            
            DefaultFamily = (AssociatedFamilies *)(-1);
        }
    }

    ASSERT(DefaultFamily != NULL);
    
    return (DefaultFamily && DefaultFamily != (AssociatedFamilies *)(-1)) ?
            DefaultFamily : NULL;
}



/**************************************************************************\
*
* Function Description:
*   Font linking destructor. it should be called when free theGDIPLUS library
*   it free all allocated data.
*   
*
* Arguments:
*
* Returns:
*       
*
* History:
*
*   3/3/2000 Tarek Mahmoud Sayed
*       Created it.
*
\**************************************************************************/

GpFontLink::~GpFontLink()
{
    FontLinkingFamily   *tempFontLinkingFamily = linkedFonts;
    AssociatedFamilies  *tempAssocFonts;
    PrivateLoadedFonts  *loadedFontsList;

    while (linkedFonts != NULL)
    {
        while (linkedFonts->associatedFamilies != NULL)
        {
            tempAssocFonts = linkedFonts->associatedFamilies->next;
            GpFree(linkedFonts->associatedFamilies);
            linkedFonts->associatedFamilies = tempAssocFonts;
        }
        
        linkedFonts = linkedFonts->next;
        GpFree(tempFontLinkingFamily);
        tempFontLinkingFamily = linkedFonts;
    }

    if (eudcCache != NULL)
    {
        EUDCMAP *tempEUDCMapList;
        
        while (eudcCache->eudcMapList != NULL)
        {
            tempEUDCMapList = eudcCache->eudcMapList->next;
            GpFree(eudcCache->eudcMapList);
            eudcCache->eudcMapList = tempEUDCMapList;
        }
        GpFree(eudcCache);
    }

    while (privateFonts != NULL)
    {
        delete privateFonts->fontCollection;
        loadedFontsList = privateFonts;
        privateFonts = privateFonts->next;
        GpFree(loadedFontsList);
    }

    if (FontSubstitutionTable)
    {
        GpFree(FontSubstitutionTable);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Read the font linking registry data for the NT 
*
* Arguments:
*
* Returns:
*       nothing
*
* History:
*
*   3/3/2000 Tarek Mahmoud Sayed
*       Created it.
*
\**************************************************************************/

void GpFontLink::GetFontLinkingDataFromRegistryW()
{
    //  Open the key

    HKEY hkey;
    ULONG index = 0;

    WCHAR subKey[MAX_PATH];
    DWORD allocatedDataSize= 2 * MAX_PATH;
    unsigned char *allocatedBuffer = NULL;
    DWORD subKeyLength  ;
    DWORD RegDataLength ;

    LONG error = RegOpenKeyExW(
            HKEY_LOCAL_MACHINE, 
            FontLinkKeyW, 
            0, 
            KEY_ENUMERATE_SUB_KEYS  | KEY_QUERY_VALUE, 
            &hkey);

    if (error == ERROR_SUCCESS)
    {
        allocatedBuffer = (unsigned char *) GpMalloc(allocatedDataSize);
        if (allocatedBuffer == NULL)
        {
            return;
        }    

        while (error != ERROR_NO_MORE_ITEMS)
        {
            subKeyLength  = MAX_PATH;
            RegDataLength = allocatedDataSize;

            error = RegEnumValueW(
                        hkey, 
                        index, 
                        subKey, 
                        &subKeyLength, 
                        NULL, 
                        NULL, 
                        allocatedBuffer, 
                        &RegDataLength);
                        
            if (error == ERROR_MORE_DATA)
            {
                allocatedDataSize  *= 2;
                GpFree(allocatedBuffer);
                allocatedBuffer = (unsigned char *) GpMalloc(allocatedDataSize);
                if (allocatedBuffer == NULL)
                {
                    RegCloseKey(hkey);
                    return;
                }    
                RegDataLength = allocatedDataSize;
                error = RegEnumValueW(
                            hkey, 
                            index, 
                            subKey, 
                            &subKeyLength, 
                            NULL, 
                            NULL, 
                            allocatedBuffer, 
                            &RegDataLength);
            }
            
            if (error != ERROR_SUCCESS)
            {
                break;
            }    
                
            index ++;

            // record current node. 
            FontLinkingFamily *tempLinkedFonts;
            
            tempLinkedFonts = 
                (FontLinkingFamily *) GpMalloc( sizeof (FontLinkingFamily) );
                
            if (tempLinkedFonts)
            {
                AssociatedFamilies * tailAssociatedFamilies = NULL;
                
                tempLinkedFonts->family = 
                    Globals::FontCollection->GetFontTable()->GetFontFamily(subKey);
                if (tempLinkedFonts->family == NULL)
                {
                    GpFree(tempLinkedFonts);
                    continue;
                }
                tempLinkedFonts->associatedFamilies = NULL;
                tempLinkedFonts->next = NULL;

                DWORD i = 0;
                WCHAR nextFontFile[MAX_PATH];
                WCHAR awcPath[MAX_PATH];
                DWORD charIndex = 0;
                UINT  hash ;
                GpFontFile* fontFile;
                AssociatedFamilies *tempAssocFamilies;
                GpFontFamily *family;
                
                BOOL hasFontFileName = FALSE;
                
                RegDataLength /= 2;
                while (charIndex < RegDataLength)
                {
                    if (((WCHAR *)allocatedBuffer)[charIndex] == 0x002C)
                    {
                        i = 0;
                        hasFontFileName = TRUE;
                    }
                    else
                    if (((WCHAR *)allocatedBuffer)[charIndex] == 0x0000)
                    {
                        if (i > 0)
                        {
                            nextFontFile[i] = 0x0;
                            i = 0;
                            if (hasFontFileName)
                            {
                                family = Globals::FontCollection->GetFontTable()->GetFontFamily(nextFontFile);
                                hasFontFileName = FALSE;
                            }
                            else
                            {
                                family = NULL;
                                INT j =0;
                                WCHAR charNumber;

                                if (MakePathName(awcPath, nextFontFile))
                                {
                                    UnicodeStringToUpper(awcPath, awcPath);
                                    
                                    fontFile = Globals::FontCollection->GetFontTable()->GetFontFile(awcPath);
                                    if (fontFile != NULL)
                                    {
                                        family = Globals::FontCollection->GetFontTable()->GetFontFamily(fontFile->GetFamilyName(0));
                                    }
                                    else
                                    {
                                        fontFile = Globals::FontCollection->GetFontTable()->AddFontFile(awcPath);
                                        if (fontFile != NULL)
                                        {
                                            family = Globals::FontCollection->GetFontTable()->GetFontFamily(fontFile->GetFamilyName(0));
                                        }
                                    }
                                }
                            }

                            if (family != NULL)
                            {
                                tempAssocFamilies = (AssociatedFamilies *) GpMalloc( sizeof (AssociatedFamilies) );
                                if (tempAssocFamilies != NULL)
                                {
                                    if (!tailAssociatedFamilies)
                                    {
                                        tempAssocFamilies->family = family;
                                        tempAssocFamilies->next   = tempLinkedFonts->associatedFamilies;
                                        tempLinkedFonts->associatedFamilies = tempAssocFamilies;
                                    }
                                    else
                                    {
                                        tempAssocFamilies->family = family;
                                        tempAssocFamilies->next   = NULL;
                                        tailAssociatedFamilies->next = tempAssocFamilies;
                                    }

                                    tailAssociatedFamilies = tempAssocFamilies;
                                }
                            }
                        }
                    }
                    else  // ! 0 
                    {   
                        nextFontFile[i] = ((WCHAR *)allocatedBuffer)[charIndex];
                        i++;
                    }
                    charIndex++;
                }
                
                tempLinkedFonts->next = linkedFonts;
                linkedFonts = tempLinkedFonts;
            }
        }

        if (allocatedBuffer != NULL)
        {
            GpFree(allocatedBuffer);
        }    
            
        RegCloseKey(hkey);
    }
    return;
}


/**************************************************************************\
*
* Function Description:
*   return the linked list of all fonts linked to family
*   
*
* Arguments:
*   family[in]  the original family
*
* Returns:
*   AssociatedFamilies* the linked list of the linked fonts       
*
* History:
*
*   3/3/2000 Tarek Mahmoud Sayed
*       Created it.
*
\**************************************************************************/

AssociatedFamilies* GpFontLink::GetLinkedFonts(const GpFontFamily *family)
{
    GpFontFamily *linkedFamily;
    if (family->IsPrivate())
    {
        WCHAR   name[LF_FACESIZE];
        if (family->GetFamilyName(name) != Ok)
        {
            return NULL;
        }

        GpInstalledFontCollection *gpFontCollection = GpInstalledFontCollection::GetGpInstalledFontCollection();

        if (gpFontCollection == NULL)
        {
            return NULL;
        }
        
        GpFontTable *fontTable = gpFontCollection->GetFontTable();

        if (fontTable == NULL)
        {
            return NULL;
        }

        linkedFamily = fontTable->GetFontFamily(name);
        if (linkedFamily == NULL)
        {
            return NULL;
        }
    }
    else
    {
        linkedFamily = (GpFontFamily *) family;
    }

    FontLinkingFamily *currentFontLink = linkedFonts;
    while (currentFontLink != NULL)
    {
        if (currentFontLink->family == linkedFamily)
        {
            return currentFontLink->associatedFamilies;
        }    
        currentFontLink = currentFontLink->next;
    }
    return NULL;
}


/**************************************************************************\
*
* Function Description:
*   caches EUDC data from the registry
*   
*
* Arguments:
*
* Returns:
*       
*
* History:
*
*   3/3/2000 Tarek Mahmoud Sayed
*       Created it.
*
\**************************************************************************/

void GpFontLink::GetEudcDataFromTheRegistryW()
{
    eudcCache = (EUDC *) GpMalloc(sizeof(EUDC));
    if (eudcCache == NULL)
    {
        return;
    }    

    eudcCache->defaultFamily    = NULL;
    eudcCache->eudcMapList      = NULL;

    WCHAR tempString[MAX_PATH];
    INT i = 0;
    
    while ( EudcKeyW[i] != 0x0000)
    {
        tempString[i] = EudcKeyW[i];
        i++;
    }

    INT j = 0;
    WCHAR acpString[5];
    UINT acp = GetACP();

    while (j < 5 && acp > 0)
    {
        acpString[j] = (acp % 10) + 0x0030;
        acp /= 10;
        j++;
    }

    j--;
    while (j>=0)
    {
        tempString[i] = acpString[j];
        i++;
        j--;
    }

    tempString[i] = 0x0;

    HKEY hkey = NULL;
    ULONG index = 0;
    LONG error = RegOpenKeyExW(
                    HKEY_CURRENT_USER, 
                    tempString, 
                    0, 
                    KEY_ENUMERATE_SUB_KEYS  | KEY_QUERY_VALUE, 
                    &hkey);

    WCHAR subKey[MAX_PATH];
    DWORD subKeyLength  ;
    DWORD RegDataLength ;
    GpFontFamily *family;
    GpFontFamily *linkedfamily;
    EUDCMAP      *eudcMap;
    BOOL         isDefaultNotCached = TRUE;

    while (error == ERROR_SUCCESS)
    {
        subKeyLength  = MAX_PATH;
        RegDataLength = MAX_PATH;
        
        error = RegEnumValueW(hkey, 
                    index, 
                    subKey, 
                    &subKeyLength, 
                    NULL, 
                    NULL, 
                    (unsigned char *) tempString, 
                    &RegDataLength);

        if (error == ERROR_SUCCESS)
        {
            if (isDefaultNotCached && UnicodeStringCompareCI(subKey, L"SystemDefaultEUDCFont") == 0)
            {
                isDefaultNotCached = FALSE;
                family = CheckAndLoadTheFile(tempString);
                if (family != NULL)
                {
                    eudcCache->defaultFamily = family;
                }
            }
            else
            {
                family = Globals::FontCollection->GetFontTable()->GetFontFamily(subKey);
                if (family != NULL)
                {
                    linkedfamily = CheckAndLoadTheFile(tempString);
                    if (linkedfamily != NULL)
                    {
                        eudcMap = (EUDCMAP *) GpMalloc(sizeof(EUDCMAP));
                        
                        if (eudcMap != NULL)
                        {
                            eudcMap->inputFamily = family;
                            eudcMap->eudcFamily  = linkedfamily;
                            
                            if (eudcCache->eudcMapList == NULL)
                            {
                                eudcCache->eudcMapList = eudcMap;
                                eudcMap->next = NULL;
                            }
                            else
                            {
                                eudcMap->next = eudcCache->eudcMapList;
                                eudcCache->eudcMapList = eudcMap;
                            }
                        }
                    }
                }
            }
        }

        index++;
    }

    if (hkey != NULL)
    {
        RegCloseKey(hkey);
    }

    return;
}

/**************************************************************************\
*
* Function Description:
*   caches EUDC data from the registry
*   
*
* Arguments:
*
* Returns:
*       
*
* History:
*
*   3/3/2000 Tarek Mahmoud Sayed
*       Created it.
*
\**************************************************************************/

void GpFontLink::GetEudcDataFromTheRegistryA()
{
    eudcCache = (EUDC *) GpMalloc(sizeof(EUDC));
    if (eudcCache == NULL)
    {
        return;
    }    

    eudcCache->defaultFamily    = NULL;
    eudcCache->eudcMapList      = NULL;

    char   tempStringA[MAX_PATH];
    WCHAR  tempString[MAX_PATH];
    INT i = 0;
    
    while ( EudcKeyA[i] != 0x00)
    {
        tempStringA[i] = EudcKeyA[i];
        i++;
    }

    INT j = 0;
    char acpString[5];
    UINT acp = GetACP();

    while (j < 5 && acp > 0)
    {
        acpString[j] = (acp % 10) + 0x30;
        acp /= 10;
        j++;
    }

    j--;
    while (j>=0)
    {
        tempStringA[i] = acpString[j];
        i++;
        j--;
    }

    tempStringA[i] = 0x0;

    HKEY hkey = NULL;
    ULONG index = 0;
    LONG error = RegOpenKeyExA(
                    HKEY_CURRENT_USER, 
                    tempStringA, 
                    0, 
                    KEY_ENUMERATE_SUB_KEYS  | KEY_QUERY_VALUE, 
                    &hkey);

    WCHAR subKey[MAX_PATH];
    char  subKeyA[MAX_PATH];
    DWORD subKeyLength  ;
    DWORD RegDataLength ;
    GpFontFamily *family;
    GpFontFamily *linkedfamily;
    EUDCMAP      *eudcMap;
    BOOL         isDefaultNotCached = TRUE;

    while (error == ERROR_SUCCESS)
    {
        subKeyLength  = MAX_PATH;
        RegDataLength = MAX_PATH;
        
        error = RegEnumValueA(
                    hkey, 
                    index, 
                    subKeyA, 
                    &subKeyLength, 
                    NULL, 
                    NULL, 
                    (unsigned char *) tempStringA, 
                    &RegDataLength);
        

        if (error == ERROR_SUCCESS)
        {
            if (!AnsiToUnicodeStr(
                    subKeyA, 
                    subKey, 
                    MAX_PATH) || 

                !AnsiToUnicodeStr(
                    tempStringA, 
                    tempString, 
                    MAX_PATH))
                    
                continue;
            
            if (isDefaultNotCached && UnicodeStringCompareCI(subKey, L"SystemDefaultEUDCFont") == 0)
            {
                isDefaultNotCached = FALSE;
                family = CheckAndLoadTheFile(tempString);
                if (family != NULL)
                {
                    eudcCache->defaultFamily = family;
                }
            }
            else
            {
                family = Globals::FontCollection->GetFontTable()->GetFontFamily(subKey);
                if (family != NULL)
                {
                    linkedfamily = CheckAndLoadTheFile(tempString);
                    if (linkedfamily != NULL)
                    {
                        eudcMap = (EUDCMAP *) GpMalloc(sizeof(EUDCMAP));
                        
                        if (eudcMap != NULL)
                        {
                            eudcMap->inputFamily = family;
                            eudcMap->eudcFamily  = linkedfamily;
                            
                            if (eudcCache->eudcMapList == NULL)
                            {
                                eudcCache->eudcMapList = eudcMap;
                                eudcMap->next = NULL;
                            }
                            else
                            {
                                eudcMap->next = eudcCache->eudcMapList;
                                eudcCache->eudcMapList = eudcMap;
                            }
                        }
                    }
                }
            }
        }

        index++;
    }
    
    if (hkey != NULL)
    {
        RegCloseKey(hkey);
    }
    return;
}


/**************************************************************************\
*
* Function Description:
*   check if the font file name is loaded, 
*   and load it if it is not loaded before.
*   
*
* Arguments:
*   fileName[In]    font file name
*
* Returns:
*  GpFontFamily*    the family object for that font
*
* History:
*
*   3/3/2000 Tarek Mahmoud Sayed
*       Created it.
*
\**************************************************************************/

GpFontFamily* GpFontLink::CheckAndLoadTheFile(WCHAR *fileName)
{
    WCHAR           awcPath[MAX_PATH];
    UINT            hash ;
    GpFontFamily    *family = NULL;
    GpFontFile      *fontFile;
    GpFontTable     *fontTable;
    
    if (MakePathName(awcPath, fileName))
    {
        PrivateLoadedFonts *currentCell = privateFonts;
        while (currentCell != NULL)
        {
            if ( UnicodeStringCompareCI(fileName, currentCell->FileName) == 0 )
            {
                fontTable = currentCell->fontCollection->GetFontTable();
                fontFile  = fontTable->GetFontFile(awcPath);
                if (fontFile)
                {
                    family = fontTable->GetFontFamily(fontFile->GetFamilyName(0));
                };
                break;
            }
            else
            {
                currentCell = currentCell->next;
            }
        }
        
        if (family == NULL)
        {
            GpPrivateFontCollection *privateFontCollection = new GpPrivateFontCollection();
            if (privateFontCollection != NULL)
            {
                if (privateFontCollection->AddFontFile(awcPath) == Ok)
                {
                    fontTable = privateFontCollection->GetFontTable();
                    fontFile = fontTable->GetFontFile(awcPath);
                    if (fontFile != NULL)
                    {
                        family = fontTable->GetFontFamily(fontFile->GetFamilyName(0));
                        PrivateLoadedFonts *tempLoadedFonts = (PrivateLoadedFonts *) GpMalloc(sizeof(PrivateLoadedFonts));
                        if (tempLoadedFonts != NULL)
                        {
                            tempLoadedFonts->fontCollection = privateFontCollection;
                            UnicodeStringCopy(tempLoadedFonts->FileName, fileName);
                            tempLoadedFonts->next = privateFonts;
                            privateFonts = tempLoadedFonts;
                        }
                        else 
                        {
                            delete privateFontCollection;
                        }
                    }
                    else
                    {
                        delete privateFontCollection;
                    }
                }
                else
                {
                    delete privateFontCollection;
                }
            }
        }
    }
    return family;
}

/**************************************************************************\
*
* Function Description:
*   return the default family used as fallback for the EUDC
*   
*
* Arguments:
*
* Returns:
*   GpFontFamily* the family of the EUDC font
*
* History:
*
*   3/3/2000 Tarek Mahmoud Sayed
*       Created it.
*
\**************************************************************************/
GpFontFamily *GpFontLink::GetDefaultEUDCFamily()
{

    if (eudcCache != NULL)
    {
        return eudcCache->defaultFamily;
    }
    return NULL;
}

/**************************************************************************\
*
* Function Description:
*   return the family of the EUDC font mapped from the font family
*   
* Arguments:
*   family[In]  original font family
*
* Returns:
*   GpFontFamily* the family of the EUDC font
*
* History:
*
*   3/3/2000 Tarek Mahmoud Sayed
*       Created it.
*
\**************************************************************************/
GpFontFamily *GpFontLink::GetMappedEUDCFamily(const GpFontFamily *family)
{
    EUDCMAP *eudcMaping;
    if (eudcCache != NULL)
    {
        eudcMaping = eudcCache->eudcMapList;
        while (eudcMaping != NULL)
        {
            if (eudcMaping->inputFamily == family)
            {
                return eudcMaping->eudcFamily;
            }
            eudcMaping = eudcMaping->next;
        }
    }
    return NULL;
}

/**************************************************************************\
*
* Function Description:
*   Read and cache the font substitution data from the registry under
*   Windows NT
*   
* Arguments:
*
* Returns:
*
* History:
*
*   4/12/2000 Tarek Mahmoud Sayed
*       Created it.
*
\**************************************************************************/

void GpFontLink::CacheFontSubstitutionDataW()
{
    HKEY hkey;

    // open this key for query and enumeration.
    LONG error = RegOpenKeyExW(
                    HKEY_LOCAL_MACHINE, 
                    FontSubstitutesKeyW, 
                    0, 
                    KEY_ENUMERATE_SUB_KEYS  | KEY_QUERY_VALUE, 
                    &hkey);

    if (error != ERROR_SUCCESS)
    {
        // failed to find these data in the registry.
        return;
    }

    DWORD numberOfValues = 0;
    error = RegQueryInfoKeyW(
                hkey, NULL, NULL, NULL, NULL, NULL, NULL, &numberOfValues, 
                NULL, NULL, NULL, NULL);

    if (error != ERROR_SUCCESS || numberOfValues==0)
    {
        RegCloseKey(hkey);
        return;
    }


    // Now let's allocate for data.
    // we allocate memory enough to hold all font substitution data but might
    // not use all the allocated memory. I did that to just call the GpMalloc
    // one time.

    FontSubstitutionTable = (FontSubstitutionEntry*)
            GpMalloc(numberOfValues*sizeof(FontSubstitutionEntry));

    if (FontSubstitutionTable == NULL)
    {
        // we can't support font substitution while we out of memory.
        RegCloseKey(hkey);
        return;
    }

    // Time to read the data from the registry.
    ULONG index = 0;
    
    WCHAR subKey[MAX_PATH];
    WCHAR subKeyValue[MAX_PATH];
    DWORD subKeyLength  ;
    DWORD regDataLength ;
    
    while (error == ERROR_SUCCESS)
    {
        subKeyLength  = MAX_PATH;
        regDataLength = MAX_PATH;

        error = RegEnumValueW(
                    hkey, index, subKey, &subKeyLength, NULL, NULL, 
                    (unsigned char *) subKeyValue, &regDataLength);
                        
        if (error != ERROR_SUCCESS)
        {
            break;
        }    
                
        index ++;

        // If the font substitution mentioned the charset, then neglect the charset
        // and keep the family name only.

        for (INT i=regDataLength-1; i>=0; i--)
        {
            if (subKeyValue[i] == 0x002C) // ','
            {
                subKeyValue[i] = 0x0000;
                break;
            }
        }
        
        // we found one. then try to get substitution GpFontFamily
        GpFontFamily *family;

        ASSERT(Globals::FontCollection != NULL);
        
        family = Globals::FontCollection->GetFontTable()->GetFontFamily(subKeyValue);
        if (family != NULL)
        {
            FontSubstitutionTable[substitutionCount].family = family;
            DWORD j;
            for (j=0 ; j<subKeyLength; j++)
            {
                if (subKey[j] == 0x002C) // ','
                {
                    break;
                }
                else
                {
                    FontSubstitutionTable[substitutionCount].familyName[j] = subKey[j];
                }
            }
            FontSubstitutionTable[substitutionCount].familyName[j]    = 0x0000;
            FontSubstitutionTable[substitutionCount].familyNameLength = j;
            substitutionCount++;
        }
    }

    RegCloseKey(hkey);
    return;
}

/**************************************************************************\
*
* Function Description:
*   Read and cache the font substitution data from win.ini under Windows 9x
*   
* Arguments:
*
* Returns:
*
* History:
*
*   6/1/2000 Tarek Mahmoud Sayed
*       Created it.
*
\**************************************************************************/

void GpFontLink::CacheFontSubstitutionDataA()
{
    DWORD   bufferSize      = 2048; // 2K to allocate for data reading
    DWORD   count           = 2048;
    char    *buffer         = (char*) GpMalloc(bufferSize);
    
    if (!buffer)
    {
        // OutOfMemory
        return;
    }

    // This loop insure we did read all the requested data in the win.ini
    while (bufferSize == count)
    {
        count = GetProfileSectionA(
            WinIniFontSubstitutionSectionName,
            buffer,
            bufferSize);
            
        if (count == 0)
        {
            // something wrong
            GpFree(buffer);
            return;
        }

        if (bufferSize-2 <= count)
        {
            // we didn't read all data, make the buffer bigger
            GpFree(buffer);
            bufferSize += 1024;
            
            if (bufferSize > 32*1024)
            {
                // the upper limit for Windows 95 is 32 KB
                return;
            }
            
            count  = bufferSize; // to continue the loop
            buffer = (char *) GpMalloc(bufferSize);
            if (buffer == NULL)
            {
                // Out of memory
                return;
            }
        }
    }

    // Now we have the filled data buffer and the count. start parsing
    // first we need to know how much memory need to allocate for caching
    // then we fill this cache with useful data.

    DWORD i             = 0;
    INT   entriesCount  = 0;
    
    while (i<count)
    {
        while (i<count && buffer[i] != 0)
        {
            i++;
        }
        
        entriesCount++;
        i++;
    }

    // Now allocate for the font substitution cache according to entriesCount
    FontSubstitutionTable = (FontSubstitutionEntry*)
            GpMalloc(entriesCount*sizeof(FontSubstitutionEntry));

    if (FontSubstitutionTable == NULL)
    {
        // we can't support font substitution while we out of memory.
        GpFree(buffer);
        return;
    }

    ASSERT(Globals::FontCollection != NULL);

    char *fontName;
    char *fontSubstitutionName;
    
    WCHAR               familyName[MAX_PATH];
    GpFontFamily        *family;
    substitutionCount   = 0;
    i                   = 0;

    while (i<count)
    {
        fontName = &buffer[i];
        
        while ( i<count && 
                buffer[i] != '=' && 
                buffer[i] != ',')
        {
            i++;
        }

        if (i>=count-1)
        {
            // something wrong in the data.
            break;
        }

        if (buffer[i] == ',')
        {
            buffer[i] = 0x0;
            i++;
            while (i<count && buffer[i] != '=')
            {
                i++;
            }
            if (i>=count-1)
            {
                // something wrong in the data.
                break;        
            }
        }

        buffer[i] = 0x0;
        i++; 

        fontSubstitutionName = &buffer[i];
        
        while ( i<count && 
                buffer[i] != 0x0 &&
                buffer[i] != ',')
        {
            i++;
        }

        if (i>=count)
        {
            i++;
            // last line may not have a null terminator
            // we sure we have a buffer has space more than the count
            buffer[i] = 0x0;
        }
        
        if (buffer[i] == ',')
        {
            buffer[i] = 0x0;
            i++;
            while (i<count && buffer[i] != 0x0)
            {
                i++;
            }
        }

        i++;
            
        if (!AnsiToUnicodeStr(
                    fontSubstitutionName, 
                    familyName, 
                    MAX_PATH))
        {
            continue;
        }

        family = Globals::FontCollection->GetFontTable()->GetFontFamily(familyName);
        if (family != NULL)
        {
            if (!AnsiToUnicodeStr(
                        fontName, 
                        FontSubstitutionTable[substitutionCount].familyName, 
                        MAX_PATH))
            {
                continue;
            }

            FontSubstitutionTable[substitutionCount].family = family;
            
            INT j=0;
            while (FontSubstitutionTable[substitutionCount].familyName[j] != 0x0000)
            {
                j++;
            }
            
            FontSubstitutionTable[substitutionCount].familyNameLength = j;
            substitutionCount++;
        }
    }

    // clean up the allocated buffer
    GpFree(buffer);
    return;
}

/**************************************************************************\
*
* Function Description:
*   Search for matched substitution font family
*   
* Arguments:
*   familyName [in] name of the font to be substituted 
*
* Returns:
*   font family in success, NULL otherwise
*
* History:
*
*   4/12/2000 Tarek Mahmoud Sayed
*       Created it.
*
\**************************************************************************/

GpFontFamily *GpFontLink::GetFamilySubstitution(const WCHAR* familyName) const
{
    INT nameLength = UnicodeStringLength(familyName);

    for (INT i=0 ; i<substitutionCount ; i++)
    {
        // to speed up the search, we use the string length comparison before
        // comparing the string itself.
        if (nameLength == FontSubstitutionTable[i].familyNameLength &&
            UnicodeStringCompareCI(FontSubstitutionTable[i].familyName, 
                                    familyName) == 0)
        {
            ASSERT(FontSubstitutionTable[i].family != NULL);
            return FontSubstitutionTable[i].family;
        }
    }

    // Not found;
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\fontlinking.hpp ===
/**************************************************************************\
* 
* Copyright (c) 2000  Microsoft Corporation
*
* Abstract:
*
*   Font linking class definition
*
* Revision History:
*
*   3/03/2000 Tarek Mahmoud Sayed
*       Created it.
*
\**************************************************************************/

#ifndef GP_FONT_LINKING_HPP
#define GP_FONT_LINKING_HPP

struct AssociatedFamilies 
{
    GpFontFamily        *family;
    AssociatedFamilies  *next;
};


struct FontLinkingFamily
{
    GpFontFamily        *family;
    AssociatedFamilies  *associatedFamilies;
    FontLinkingFamily   *next;
};


struct EUDCMAP
{
    GpFontFamily    *inputFamily;
    GpFontFamily    *eudcFamily;
    EUDCMAP         *next;
};

struct EUDC
{
    GpFontFamily    *defaultFamily;
    EUDCMAP         *eudcMapList;
};


struct PrivateLoadedFonts
{
    GpPrivateFontCollection *fontCollection;
    WCHAR                   FileName[MAX_PATH];
    PrivateLoadedFonts      *next;
};


struct FontSubstitutionEntry
{
    WCHAR         familyName[MAX_PATH];
    INT           familyNameLength;
    GpFontFamily *family;
};


//  definition of the Font linking class. it has an global object defined in the Global name space
//  and created in the Font fallback class exist on the \Text\Uniscribe\shaping folder.

class GpFontLink
{
public:
    GpFontLink();
    ~GpFontLink();
    AssociatedFamilies* GetLinkedFonts(const GpFontFamily *family);
    GpFontFamily *GetDefaultEUDCFamily();
    GpFontFamily *GetMappedEUDCFamily(const GpFontFamily *family);
    GpFontFamily *GetFamilySubstitution(const WCHAR* familyName) const;
    const AssociatedFamilies *GetDefaultFamily();
    
private:
    void GetFontLinkingDataFromRegistryW();
    void GetEudcDataFromTheRegistryW();
    void GetEudcDataFromTheRegistryA();
    GpFontFamily* CheckAndLoadTheFile(WCHAR *fileName);
    void CacheFontSubstitutionDataW();
    void CacheFontSubstitutionDataA();

private:
    FontLinkingFamily       *linkedFonts;
    EUDC                    *eudcCache;
    PrivateLoadedFonts      *privateFonts;
    FontSubstitutionEntry   *FontSubstitutionTable;
    INT                      substitutionCount;
    AssociatedFamilies      *DefaultFamily;
    AssociatedFamilies       DefaultFamilyBuffer; // buffer for self-created linking font
};




// wrapper function to get the substitution Family from the FontLinkTable
// but first it make sure that the FontLinkTable is created.


inline void GetFamilySubstitution(const WCHAR* familyName, GpFontFamily **Family)
{
    if (Globals::FontLinkTable == NULL)
    {
        // All APIs are bounded by critical section. we are sure we will not have
        // multithreading problem.
        Globals::FontLinkTable = new GpFontLink;

    }
        
    if (Globals::FontLinkTable != NULL)
    {
        *Family = Globals::FontLinkTable->GetFamilySubstitution(familyName);
    }
    
    return;
}



#endif // GP_FONT_LINKING_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\geometry.hpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Geometry: Some 2D geometry helper routines.
*
* Created:
*
*   08/26/2000 asecchia
*      Created it.
*
**************************************************************************/

#ifndef _GEOMETRY_HPP
#define _GEOMETRY_HPP


// return the square of the distance between point 1 and point 2.

inline REAL distance_squared(const GpPointF &p1, const GpPointF &p2)
{
    return ((p1.X-p2.X)*(p1.X-p2.X)+(p1.Y-p2.Y)*(p1.Y-p2.Y));
}

// return the dot product of two points treated as 2-vectors.

inline double dot_product(const GpPointF &a, const GpPointF &b)
{
    return (a.X*b.X + a.Y*b.Y);
}

// Return the intersection of a line specified by p0-p1 along the
// y axis. Returns FALSE if p0-p1 is parallel to the yaxis.
// Only returns intersections between p0 and p1 (inclusive).

BOOL intersect_line_yaxis(
    IN  const GpPointF &p0,
    IN  const GpPointF &p1,
    OUT REAL *length
);

// Return the intersection of a line p0-p1 with the line r0-r1
// The return value

BOOL IntersectLines(
    IN const GpPointF &line1Start,
    IN const GpPointF &line1End,
    IN const GpPointF &line2Start,
    IN const GpPointF &line2End,
    OUT REAL *line1Length,
    OUT REAL *line2Length,
    OUT GpPointF *intersectionPoint
);


INT intersect_circle_line(
    IN  const GpPointF &C,      // center
    IN  REAL radius2,           // radius * radius  (i.e. squared)
    IN  const GpPointF &P0,     // line first point (origin)
    IN  const GpPointF &P1,     // line last point (end)
    OUT GpPointF *intersection  // return intersection point.
);

// Return true if point is inside the polygon defined by poly and count.
// Use the FillModeAlternate (even-odd) rule.

BOOL PointInPolygonAlternate(
    GpPointF point,
    INT count, 
    GpPointF *poly
);

GpStatus GetFastAngle(REAL* angle, const GpPointF& vector);


class GpVector2D : public GpPointF
{
    public:
    GpVector2D()
    {
        X = Y = 0.0f;
    }

    GpVector2D(IN const PointF &point)
    {
        X = point.X;
        Y = point.Y;
    } 
    
    GpVector2D(IN const GpVector2D &vec)
    {
        X = vec.X;
        Y = vec.Y;
    } 

    GpVector2D(IN REAL x, IN REAL y)
    {
        X = x;
        Y = y;
    }

    // Scale.
    
    GpVector2D operator*(REAL k)
    {
        return GpVector2D(X*k, Y*k);
    }
    
    // Dot Product
    
    REAL operator*(IN const GpVector2D &V)
    {
        return (X*V.X+Y*V.Y);
    }
    
   
    VOID operator+=(IN const GpVector2D &V)
    {
        X += V.X;
        Y += V.Y;
    } 
    
    VOID operator-=(IN const GpVector2D &V)
    {
        X -= V.X;
        Y -= V.Y;
    } 
        
    VOID operator*=(IN const REAL k)
    {
        X *= k;
        Y *= k;
    } 

    // Length or Vector Norm of the Vector.
    
    REAL Norm()
    {
        double length = (double)X*X+(double)Y*Y;
        length = sqrt(length);
        
        if( fabs(length) < REAL_EPSILON )
        {
            return 0.0f;
        }
        else
        {
            return (REAL)length;
        }
    }
    
    // Unitize the vector. If it is degenerate, return 0.0f
    
    REAL Normalize()
    {
        double length = (double)X*X+(double)Y*Y;
        
        if( length < 0.0 )
        {
            X = 0.0f;
            Y = 0.0f;
            return 0.0f;
        }
        
        length = sqrt(length);
        
        if( fabs(length) < REAL_EPSILON )
        {
            X = 0.0f;
            Y = 0.0f;
            return 0.0f;
        }
        else
        {
            X /= (REAL)length;
            Y /= (REAL)length;
            return (REAL)length;
        }
    }
    
    // This is the determinant of two 2-vectors. The formula is defined to
    // be the determinant of the 2x2 matrix formed by using the two vectors
    // as the columns of the matrix.
    // This is also known as the cross product of the two input vectors
    // though some math texts claim that cross products are only defined
    // for 3-vectors.
    
    static REAL Determinant(const GpVector2D &a, const GpVector2D &b)
    {
        return (a.X*b.Y-a.Y*b.X);
    }
};
    

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\gdipfontstubs.cpp ===
#include "precomp.hpp"


GpStatus
GpPath::MoveTo(const GpPointF point)
{
    INT origCount = GetPointCount();

    GpPointF* pointbuf = Points.AddMultiple(1);
    BYTE* typebuf = Types.AddMultiple(1);

    if (pointbuf == NULL || typebuf == NULL)
    {
        Points.SetCount(origCount);
        Types.SetCount(origCount);

        return OutOfMemory;
    }

    *typebuf = PathPointTypeStart;
    SubpathCount++;         // start a new subpath

    GpMemcpy(pointbuf, (PVOID)&point, sizeof(GpPointF));
    
    IsSubpathActive = TRUE;

    return Ok;
}


BOOL APIENTRY PATHOBJ_bMoveTo(
    PVOID      *ppo,
    POINTFIX    ptfx
    )
{
    GpPointF point(FIX4TOREAL(ptfx.x), FIX4TOREAL(ptfx.y));
    GpPath *path = (GpPath*)ppo;
    
    return (path->MoveTo(point) == Ok ? TRUE : FALSE);
}


GpStatus
GpPath::AddPoints(
    const GpPointF *points,
    ULONG count,
    PathPointType pointType)
{
    if (pointType != PathPointTypeLine && pointType != PathPointTypeBezier)
        return InvalidParameter;
    
    INT origCount = GetPointCount();

    GpPointF* pointbuf = Points.AddMultiple(count);
    BYTE* typebuf = Types.AddMultiple(count);

    if(pointbuf == NULL || typebuf == NULL)
    {
        // Resize the original size.

        Points.SetCount(origCount);
        Types.SetCount(origCount);

        return OutOfMemory;
    }

    // Copy path point data

    GpMemcpy(pointbuf, points, count*sizeof(GpPointF));
    GpMemset(typebuf, pointType, count);

    return Ok;
}

#define POINTS_BUFFER_SIZE   3*6

BOOL APIENTRY PATHOBJ_bPolyLineTo(
    PVOID     *ppo,
    POINTFIX  *pptfx,
    ULONG      cptfx
    )
{
    GpPath *path = (GpPath*)ppo;
    GpPointF *points = NULL, apoint[POINTS_BUFFER_SIZE];
    BOOL ret = FALSE;
    
    if (!path->IsValid() || !pptfx || cptfx == 0)
        return FALSE;
    
    if (cptfx > POINTS_BUFFER_SIZE)
    {
        points = new GpPointF[cptfx];
        
        if (points == NULL)
            return FALSE;
    }
    else
        points = apoint;

    // convert FIX4 to REAL

    for (ULONG i = 0; i < cptfx; i++)
    {
        points[i].X = FIX4TOREAL(pptfx[i].x);
        points[i].Y = FIX4TOREAL(pptfx[i].y);
    }
        
    if (path->AddPoints(points, cptfx, PathPointTypeLine) == Ok)
        ret = TRUE;
    
    if (points != apoint)
        delete [] points;
    
    return ret;
}


BOOL APIENTRY PATHOBJ_bPolyBezierTo(
    PVOID     *ppo,
    POINTFIX  *pptfx,
    ULONG      cptfx
    )
{
    GpPath *path = (GpPath*)ppo;
    GpPointF *points = NULL, apoint[POINTS_BUFFER_SIZE];
    BOOL ret = FALSE;

    ASSERT(cptfx % 3 == 0);

    if (!path->IsValid() || pptfx == NULL || cptfx == 0 || (cptfx % 3 != 0))
        return FALSE;

    if (cptfx > POINTS_BUFFER_SIZE)
    {
        points = new GpPointF[cptfx];
        
        if (points == NULL)
            return FALSE;
    }
    else
        points = apoint;

    // convert FIX4 to REAL

    for (ULONG i = 0; i < cptfx; i++)
    {
        points[i].X = FIX4TOREAL(pptfx[i].x);
        points[i].Y = FIX4TOREAL(pptfx[i].y);
    }
               
    if (path->AddPoints(points, cptfx, PathPointTypeBezier) == Ok)
    {
        path->SetHasBezier(TRUE);
        ret = TRUE;
    }
    
    if (points != apoint)
    delete [] points;
    
    return ret;
}

BOOL APIENTRY PATHOBJ_bCloseFigure(
    PVOID *ppo
    )
{
    ((GpPath*)ppo)->CloseFigure();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\gpbitmap.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   GpBitmap.hpp
*
* Abstract:
*
*   Bitmap related declarations
*
* Revision History:
*
*   12/09/1998 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _GPBITMAP_HPP
#define _GPBITMAP_HPP

#define NEARCONSTANTALPHA 0x10

//--------------------------------------------------------------------------
// Abstract base class for bitmap image and metafile
//--------------------------------------------------------------------------

class GpImage : public GpObject
{
protected:
    VOID SetValid(BOOL valid)
    {
        GpObject::SetValid(valid ? ObjectTagImage : ObjectTagInvalid);
    }

public:

    // Construct a GpImage object from a disk file

    static GpImage* LoadImage(const WCHAR* filename);

    // Construct a GpImage object from a data stream

    static GpImage* LoadImage(IStream* stream);

    virtual ObjectType GetObjectType() const { return ObjectTypeImage; }

    // Make a copy of the image object

    virtual GpImage* Clone() const= 0;

    virtual GpImage* CloneColorAdjusted(
        GpRecolor *             recolor,
        ColorAdjustType         type = ColorAdjustTypeDefault
        ) const = 0;

    // Get the encoder parameter list size

    virtual GpStatus
    GetEncoderParameterListSize(
        CLSID* clsidEncoder,
        UINT* size
        ) = 0;

    // Get the encoder parameter list

    virtual GpStatus
    GetEncoderParameterList(
        CLSID* clsidEncoder,
        UINT size,
        OUT EncoderParameters* pBuffer
        ) = 0;

    // Save images

    virtual GpStatus
    SaveToStream(
        IStream* stream,
        CLSID* clsidEncoder,
        EncoderParameters* encoderParams
        ) = 0;

    virtual GpStatus
    SaveToFile(
        const WCHAR* filename,
        CLSID* clsidEncoder,
        EncoderParameters* encoderParams
        ) = 0;

    virtual GpStatus
    SaveAdd(
        const EncoderParameters* encoderParams
        ) = 0;

    virtual GpStatus
    SaveAdd(
        GpImage*           newBits,
        const EncoderParameters*  encoderParams
        ) = 0;

    // Dispose of the image object

    virtual VOID Dispose() = 0;

    // Derive a graphics context to draw into the GpImage object

    virtual GpGraphics* GetGraphicsContext() = 0;

    // Check if the GpImage object is valid

    virtual BOOL IsValid() const
    {
        return GpObject::IsValid(ObjectTagImage);
    }

    virtual BOOL IsSolid()
    {
        return FALSE;
    }

    virtual BOOL IsOpaque()
    {
        return FALSE;
    }

    // Get image information:
    //  resolution
    //  physical dimension in 0.01mm units
    //  bounding rectangle
    //  structure ImageInfo
    //  thumbnail

    virtual GpStatus GetResolution(REAL* xdpi, REAL* ydpi)           const = 0;
    virtual GpStatus GetPhysicalDimension(REAL* width, REAL* height) const = 0;
    virtual GpStatus GetBounds(GpRectF* rect, GpPageUnit* unit)      const = 0;
    virtual GpStatus GetImageInfo(ImageInfo *imageInfo)              const = 0;
    virtual GpStatus GetFrameCount(const GUID* dimensionID,
                                   UINT* count)                      const = 0;
    virtual GpStatus GetFrameDimensionsCount(OUT UINT* count)        const = 0;
    virtual GpStatus GetFrameDimensionsList(OUT GUID* dimensionIDs,
                                            IN  UINT count)          const = 0;
    virtual GpStatus SelectActiveFrame(const GUID*  dimensionID,
                                       UINT frameIndex)                    = 0;
    virtual GpImage* GetThumbnail(UINT thumbWidth, UINT thumbHeight,
                                  GetThumbnailImageAbort callback, VOID *callbackData) = 0;
    virtual GpStatus GetPalette(ColorPalette *palette, INT size) = 0;
    virtual GpStatus SetPalette(ColorPalette *palette) = 0;
    virtual INT GetPaletteSize() = 0;

    // Rotate and Flip

    virtual GpStatus RotateFlip(RotateFlipType rfType) = 0;

    // Property related functions

    virtual GpStatus GetPropertyCount(UINT* numOfProperty) = 0;
    virtual GpStatus GetPropertyIdList(UINT numOfProperty, PROPID* list) = 0;
    virtual GpStatus GetPropertyItemSize(PROPID propId, UINT* size) = 0;
    virtual GpStatus GetPropertyItem(PROPID propId,UINT propSize,
                                     PropertyItem* buffer) = 0;
    virtual GpStatus GetPropertySize(UINT* totalBufferSize,
                                     UINT* numProperties) = 0;
    virtual GpStatus GetAllPropertyItems(UINT totalBufferSize,
                                         UINT numProperties,
                                         PropertyItem* allItems) = 0;
    virtual GpStatus RemovePropertyItem(PROPID propId) = 0;

    virtual GpStatus SetPropertyItem(PropertyItem* item) = 0;

    // Determine the type of image object

    GpImageType GetImageType() const
    {
        return ImgType;
    }

    GpLockable* GetObjectLock() const
    {
        return &Lockable;
    }

    // Default ICM mode is off. Default behaviour for this function is to
    // do nothing.
    // If a derived class supports embedded color correction, it needs
    // to respect this call to turn ICM on or off.

    virtual VOID SetICMConvert(BOOL icm) { }


private:

    // Prevent apps from directly using new and delete operators
    // on GpImage objects.

    GpImage()
    {
        ImgType = ImageTypeUnknown;

        // Set the tag in the object, even if IsValid overridden by
        // GpBitmap or GpMetafile.
        GpObject::SetValid(ObjectTagImage);
    }

protected:

    GpImage(GpImageType imgType)
    {
        ImgType = imgType;

        // Set the tag in the object, even if IsValid overridden by
        // GpBitmap or GpMetafile.
        GpObject::SetValid(ObjectTagImage);
    }

    virtual ~GpImage() {}

    GpImageType ImgType;    // type of image object

    // Object lock

    mutable GpLockable Lockable;
};


//--------------------------------------------------------------------------
// Represent raster bitmap objects
//--------------------------------------------------------------------------

class GpDecodedImage;
class GpMemoryBitmap;
class CopyOnWriteBitmap;

class GpBitmap : public GpImage
{
friend class GpObject;      // for empty constructor
friend class CopyOnWriteBitmap;

private:

    CopyOnWriteBitmap *     InternalBitmap;
    LONG ScanBitmapRef;         // ref count used for when a GpGraphics is wrapped around a GpBitmap
    EpScanBitmap ScanBitmap;

    VOID IncScanBitmapRef()
    {
         InterlockedIncrement(&ScanBitmapRef);
    }

    VOID DecScanBitmapRef()
    {
         InterlockedDecrement(&ScanBitmapRef);
    }

    GpBitmap(BOOL createInternalBitmap = TRUE);
    GpBitmap(const GpBitmap * bitmap);
    GpBitmap(const CopyOnWriteBitmap * internalBitmap);

    // Destructor
    //  We don't want apps to use delete operator directly.
    //  Instead, they should use the Dispose method.

    virtual ~GpBitmap();

protected:

    CopyOnWriteBitmap * LockForWrite();
    VOID Unlock() const;
    VOID LockForRead() const;

public:

    // Constructors

    GpBitmap(const WCHAR* filename);
    GpBitmap(IStream* stream);
    GpBitmap(INT width, INT height, PixelFormatID format);
    GpBitmap(INT width, INT height, PixelFormatID format, GpGraphics * graphics);
    GpBitmap(
        INT width,
        INT height,
        INT stride,     // negative for bottom-up bitmaps
        PixelFormatID format,
        BYTE *  scan0
        );
    GpBitmap(
        BITMAPINFO* gdiBitmapInfo,
        VOID* gdiBitmapData,
        BOOL ownBitmapData
        );
    GpBitmap(IDirectDrawSurface7 *surface);

    // Check if the GpBitmap object is valid

    virtual BOOL IsValid() const;

    GpImage*
    Clone() const;

    GpBitmap*
    Clone(
        const GpRect* rect,
        PixelFormatID format = PixelFormat32bppPARGB
    ) const;

    virtual GpImage*
    CloneColorAdjusted(
        GpRecolor *             recolor,
        ColorAdjustType         type = ColorAdjustTypeDefault
        ) const;

    // Similar to CloneColorAdjusted
    GpStatus Recolor(
        GpRecolor *recolor,
        GpBitmap **dstBitmap,
        DrawImageAbort callback,
        VOID *callbackData,
        GpRect *rect = NULL
    );

    GpStatus
    GetEncoderParameterListSize(
        IN  CLSID* clsidEncoder,
        OUT UINT* size
        );

    GpStatus
    GetEncoderParameterList(
        IN  CLSID* clsidEncoder,
        IN  UINT size,
        OUT EncoderParameters* pBuffer
        );

    GpStatus
    SaveToStream(
        IStream* stream,
        CLSID* clsidEncoder,
        EncoderParameters* encoderParams
        );

    GpStatus
    SaveToFile(
        const WCHAR* filename,
        CLSID* clsidEncoder,
        EncoderParameters* encoderParams
        );

    GpStatus
    SaveAdd(
        const EncoderParameters* encoderParams
        );

    GpStatus
    SaveAdd(
        GpImage*            newBits,
        const EncoderParameters*  encoderParams
        );

    // Dispose the bitmap object

    VOID Dispose();

    // Get bitmap information

    virtual GpStatus GetResolution(REAL* xdpi, REAL* ydpi)           const;
    virtual GpStatus GetPhysicalDimension(REAL* width, REAL* height) const;
    virtual GpStatus GetBounds(GpRectF* rect, GpPageUnit* unit)      const;
    virtual GpStatus GetSize(Size* size)                             const;
    virtual GpStatus GetImageInfo(ImageInfo *imageInfo)              const;
    virtual GpImage* GetThumbnail(UINT thumbWidth, UINT thumbHeight,
                                  GetThumbnailImageAbort callback,
                                  VOID *callbackData);
    virtual GpStatus GetFrameCount(const GUID* dimensionID,
                                   UINT* count)                      const;
    virtual GpStatus GetFrameDimensionsCount(OUT UINT* count)        const;
    virtual GpStatus GetFrameDimensionsList(OUT GUID* dimensionIDs,
                                            IN UINT count)           const;
    virtual GpStatus SelectActiveFrame(const GUID*  dimensionID,
                                       UINT frameIndex);
    virtual GpStatus GetPalette(ColorPalette *palette, INT size);
    virtual GpStatus SetPalette(ColorPalette *palette);
    virtual INT GetPaletteSize();

    GpStatus GetTransparencyHint(DpTransparency* transparency);
    GpStatus SetTransparencyHint(DpTransparency transparency);

    GpStatus GetTransparencyFlags(DpTransparency* transparency,
                                  PixelFormatID loadFormat = PixelFormatDontCare,
                                  BYTE* minAlpha = NULL,
                                  BYTE* maxAlpha = NULL);

    // Property related functions

    virtual GpStatus GetPropertyCount(UINT* numOfProperty);
    virtual GpStatus GetPropertyIdList(UINT numOfProperty, PROPID* list);
    virtual GpStatus GetPropertyItemSize(PROPID propId, UINT* size);
    virtual GpStatus GetPropertyItem(PROPID propId,UINT propSize,
                                     PropertyItem* buffer);
    virtual GpStatus GetPropertySize(UINT* totalBufferSize,UINT* numProperties);
    virtual GpStatus GetAllPropertyItems(UINT totalBufferSize,
                                         UINT numProperties,
                                         PropertyItem* allItems);
    virtual GpStatus RemovePropertyItem(PROPID propId);
    virtual GpStatus SetPropertyItem(PropertyItem* item);

    // Retrieve bitmap data

    GpStatus
    LockBits(
        const GpRect* rect,
        UINT flags,
        PixelFormatID pixelFormat,
        BitmapData* bmpdata,
        INT width = 0,
        INT height = 0
    ) const;

    GpStatus
    UnlockBits(
        BitmapData* bmpdata,
        BOOL Destroy=FALSE
    ) const;

    // Flush batched drawing operations and optionally wait for drawing to
    // complete.  This is currently a nop operation.  If the behavior
    // of a GpBitmap changes to a model where rendering operations are
    // non-immediate then this routine will need to be implemented.

    VOID
    Flush(GpFlushIntention intention) {};

    // Get and set pixel on the bitmap.
    GpStatus GetPixel(INT x, INT y, ARGB *color);
    GpStatus SetPixel(INT x, INT y, ARGB color);

    // Rotate and Flip

    GpStatus RotateFlip(
        RotateFlipType rfType
        );

    // Derive a graphics context on top of the bitmap object

    GpGraphics* GetGraphicsContext();

    GpStatus
    GpBitmap::InitializeSurfaceForGdipBitmap(
        DpBitmap *      surface,
        INT             width,
        INT             height
        );

    // Derive an HDC for interop on top of the bitmap object

    HDC GetHdc();
    VOID ReleaseHdc(HDC hdc);

    // Serialization

    virtual UINT GetDataSize() const;
    virtual GpStatus GetData(IStream * stream) const;
    virtual GpStatus SetData(const BYTE * dataBuffer, UINT size);

    GpStatus GetCompressedData(
            DpCompressedData * compressed_data,
            BOOL getJPEG = TRUE,
            BOOL getPNG = TRUE,
            HDC hdc = (HDC)NULL);

    GpStatus DeleteCompressedData(
            DpCompressedData * compressed_data);

    BOOL IsDirty() const;

    // Color adjust

    virtual GpStatus ColorAdjust(
        GpRecolor *     recolor,
        ColorAdjustType type
        );

    GpStatus
    ColorAdjust(
        GpRecolor * recolor,
        PixelFormatID pixfmt,
        DrawImageAbort callback,
        VOID *callbackData
        );

    GpStatus GetPixelFormatID(PixelFormatID* pixfmt);

    enum
    {
        Invalid = 0,        // bitmap object is invalid
        ImageRef = 1,       // contains a reference only (e.g. filename)
        ExtStream = 2,      // contains a reference to a stream
        DecodedImg = 3,     // contains a decoded image object,
                            // but it's not decoded yet - name is misleading.
        MemBitmap = 4       // contains an in-memory bitmap object
    };

    INT GetDecodeState();

    GpStatus ForceValidation();

    GpStatus SetResolution(REAL xdpi, REAL ydpi);

    GpStatus
    PreDraw(
        INT numPoints,
        GpPointF *dstPoints,
        GpRectF *srcRect,
        INT numBitsPerPixel
        );

    DWORD GetUniqueness() { return (DWORD)GetUid(); }

    // Interop:

    static GpStatus CreateFromHBITMAP(
        HBITMAP hbm,
        HPALETTE hpal,
        GpBitmap** bitmap
        );

    static GpStatus CreateBitmapAndFillWithBrush(
        InterpolationMode   interpolationMode,
        PixelOffsetMode     pixelOffsetMode,
        const GpMatrix *    worldToDevice,
        const GpRect *      drawBounds,
        GpBrush *           brush,
        GpBitmap **         bitmap,
        PixelFormatID       pixelFormat = PIXFMT_32BPP_ARGB
        );

    static GpStatus DrawAndHalftoneForStretchBlt(
        HDC                 hdc,
        BITMAPINFO *        bmpInfo,
        BYTE       *        bits,
        INT                 srcX,
        INT                 srcY,
        INT                 srcWidth,
        INT                 srcHeight,
        INT                 destWidth,
        INT                 destHeight,
        BITMAPINFO **       destBmpInfo,
        BYTE       **       destBmpBits,
        HBITMAP    *        destDIBSection,
        InterpolationMode   interpolationMode
        );

    GpStatus CreateHBITMAP(HBITMAP *phbm, ARGB background);

    GpStatus ICMFrontEnd(
        GpBitmap **dstBitmap,
        DrawImageAbort callback,
        VOID *callbackData,
        GpRect *rect = NULL
    );

    static GpStatus CreateFromHICON(
        HICON hicon,
        GpBitmap** bitmap
        );

    GpStatus CreateHICON(HICON *phicon);

    static GpStatus CreateFromResource(
        HINSTANCE hInstance,
        LPWSTR lpBitmapName,
        GpBitmap** bitmap
        );

    // We need to know if the bitmap is associated with a display
    // so we know how to handle the page transform when it is
    // set to UnitDisplay.
    BOOL IsDisplay() const;
    VOID SetDisplay(BOOL display);

    BOOL IsICMConvert() const;
    virtual VOID SetICMConvert(BOOL icm);
};

// This is the base class for any class that implements the CopyOnWrite
// technology that enable cloning to be very light-weight when cloning for
// read access. It implements read and write locking for synchronization
// using a critical section, and it keeps track of reference counting
// the object so that it can be deleted at the right time.

class CopyOnWrite
{
protected:
    // Constructor: notice that when an object is first
    // created, its reference count is set to 1.

    CopyOnWrite()
    {
        RefCount = 1;
#if DBG
        Lock = NotLocked;
        LockCount = 0;
#endif
        InitializeCriticalSection(&Semaphore);
    }

    virtual ~CopyOnWrite()
    {
        DeleteCriticalSection(&Semaphore);
    }

#if DBG
    enum LockedType
    {
        NotLocked,
        LockedForRead,
        LockedForWrite
    };
#endif

    virtual CopyOnWrite * Clone() const = 0;
    virtual BOOL IsValid() const = 0;

    // Returns NULL if it fails to lock for writing

    CopyOnWrite * LockForWrite()
    {
        EnterCriticalSection(&Semaphore);

        CopyOnWrite *  writeableObject = this;

        // If there is more than one reference to this object, we must
        // clone it before giving write access to it.

        if (RefCount > 1)
        {
            writeableObject = this->Clone();

            if (writeableObject == NULL)
            {
                LeaveCriticalSection(&Semaphore);
                return NULL;
            }

            ASSERT(writeableObject->IsValid());

            // else we succeeded in cloning the object

            RefCount--;

            EnterCriticalSection(&(writeableObject->Semaphore));
            LeaveCriticalSection(&Semaphore);
        }

#if DBG
        writeableObject->Lock = LockedForWrite;
        writeableObject->LockCount++;
#endif

        return writeableObject;
    }

    VOID LockForRead() const
    {
        EnterCriticalSection(&Semaphore);

#if DBG
        if (Lock == NotLocked)
        {
            Lock = LockedForRead;
        }
        LockCount++;
#endif
    }

    VOID Unlock() const
    {
#if DBG
        ASSERT(Lock != NotLocked);
        if (--LockCount <= 0)
        {
            Lock = NotLocked;
            LockCount = 0;
        }
#endif
        LeaveCriticalSection(&Semaphore);
    }

    // Increment reference count
    // Note that we must use the critical section to control access, rather
    // than using interlocked increment.

    LONG AddRef() const
    {
        EnterCriticalSection(&Semaphore);
        RefCount++;
        LeaveCriticalSection(&Semaphore);
        return RefCount;
    }

    // Decrement reference count
    // Note that we must use the critical section to control access, rather
    // than using interlocked decrement.

    LONG Release() const
    {
        EnterCriticalSection(&Semaphore);

        ULONG count = --RefCount;

        // must leave the critical section before calling delete so that
        // we don't try to access the freed memory.

        LeaveCriticalSection(&Semaphore);

        if (count == 0)
        {
            delete this;
        }

        return count;
    }

private:

    mutable LONG                RefCount;
    mutable CRITICAL_SECTION    Semaphore;

#if DBG
    mutable INT                 LockCount;
protected:
    mutable LockedType          Lock;
#endif
};

GpStatus
ConvertTo16BppAndFlip(
    GpBitmap *      sourceBitmap,
    GpBitmap * &    destBitmap
    );

VOID
HalftoneColorRef_216(
    COLORREF color,     // color to halftone
    UNALIGNED VOID *dib // packed 8 bpp DIB buffer with 8 colors
                        // The DIB buffer should be this size:
                        //     sizeof(BITMAPINFOHEADER) + // DIB 8 bpp header
                        //     (8 * sizeof(RGBQUAD)) +    // DIB 8 colors
                        //     (8 * 8)                    // DIB 8x8 pixels
    );

#endif // !_GPBITMAP_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\geometry.cpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Geometry: Some 2D geometry helper routines.
*
* Created:
*
*   08/26/2000 asecchia
*      Created it.
*
**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*  
* Function Description:
*
*   intersect_circle_line
*
*   Intersection of a circle and a line specified by two points.
*
*   This algorithm is adapted from the geometric line-sphere intersection
*   algorithm by Eric Haines in "An Introduction to Ray Tracing" pp39 edited
*   by Andrew S Glassner.
*
*   Note: This routine only returns positive intersections. 
*
* Arguments:
*
*    const GpPointF &C,      // center
*    const REAL radius2,     // radius * radius  (i.e. squared)
*    const GpPointF &P0,     // line first point (origin)
*    const GpPointF &P1,     // line last point (end)
*    GpPointF &intersection  // return intersection point.
*
*
* Return Value:
*   0 - no intersection
*   1 - intersection.
*
*   08/25/2000 [asecchia]
*       Created it
*
\**************************************************************************/

INT intersect_circle_line(
    IN  const GpPointF &C,      // center
    IN  REAL radius2,           // radius * radius  (i.e. squared)
    IN  const GpPointF &P0,     // line first point (origin)
    IN  const GpPointF &P1,     // line last point (end)
    OUT GpPointF *intersection  // return intersection point.
)
{
    GpPointF vI = P1-P0;    // Vector Line equation  P0 + t*vI
    
    // Normalize vI
    double length = sqrt(dot_product(vI, vI));
    
    if(length < REAL_EPSILON)
    {
        return 0;           // no intersection for degenerate points.
    }
    
    double lv = 1.0/length;
    vI.X *= (REAL)lv;
    vI.Y *= (REAL)lv;
    
    GpPointF vOC = C-P0;    // Vector from line origin to circle center
    
    double L2oc = dot_product(vOC, vOC);
    
    // Distance to closest approach to circle center.
    
    double tca = dot_product(vOC, vI);
    
    // Trivial rejection.
    
    if(tca < REAL_EPSILON && 
       L2oc >= radius2) 
    {
        return 0;           // missed.
    }
    
    // Half chord distance squared.
    
    double t2hc = radius2 - L2oc + tca*tca;
    
    // Trivial rejection. 
    
    if(t2hc < REAL_EPSILON) {
        return 0;          // missed.
    }
    
    t2hc = sqrt(t2hc);
    
    double t;
    
    if(L2oc >= radius2)
    {
        t = tca-t2hc;
        if(t > REAL_EPSILON)
        {
            if(t>=0.0)
            {
                // hit the circle.
                
                *intersection = vI;
                intersection->X *= (REAL)t;
                intersection->Y *= (REAL)t;
                *intersection = *intersection+P0;
                
                return 1;
            }
        }
    }
    
    t = tca+t2hc;
    if(t > REAL_EPSILON)
    {
        if(t>=0.0)
        {
            // hit the circle.
            
            *intersection = vI;
            intersection->X *= (REAL)t;
            intersection->Y *= (REAL)t;
            *intersection = *intersection+P0;
            
            return 1;
        }
    }
    
    return 0;              // missed.
}


/**************************************************************************\
*  
* Function Description:
*
*   intersect_line_yaxis
*
*   Return the intersection of a line specified by p0-p1 along the
*   y axis. Returns FALSE if p0-p1 is parallel to the yaxis.
*
*   Intersection is defined as between p0 and p1 (inclusive). Any
*   intersection point along the line outside of p0 and p1 is ignored.
*
* Arguments:
*
*    IN  const GpPointF &p0,    first point.
*    IN  const GpPointF &p1,    second point.
*    OUT REAL *length           Length along the y axis from zero.
*
* Return Value:
*   0 - no intersection
*   1 - intersection.
*
*   08/25/2000 [asecchia]
*       Created it
*
\**************************************************************************/

BOOL intersect_line_yaxis(
    IN  const GpPointF &p0,
    IN  const GpPointF &p1,
    OUT REAL *length
)
{
    // using vector notation: Line == p0+t(p1-p0)
    
    GpPointF V = p1-p0;
    
    // Check if the line is parallel to the y-axis.
    
    if( REALABS(V.X) < REAL_EPSILON )
    {
        return (FALSE);
    }
    
    // y-axis intersection: p0.X + t V.X = 0
    
    REAL t =  -p0.X/V.X;     
    
    // Check to see that t is between 0 and 1
    
    if( (t < -REAL_EPSILON) ||
        (t-1.0f > REAL_EPSILON) )
    {
        return (FALSE);
    }
        

    // Compute the actual length along the y-axis.
    
    *length = p0.Y + V.Y * t;
    return (TRUE);
}


/**************************************************************************\
*  
* Function Description:
*
*   IntersectLines
*
*   Returns the intersection between two lines specified by their end points.
*
*   The intersection point is returned in intersectionPoint and the 
*   parametric distance along each line is also returned.
*
*   line1Length ranges between [0, 1] for the first line
*   if line1Length is outside of [0, 1] it means that the intersection 
*   extended the line.
*   line2Length ranges between [0, 1] for the second line
*   if r is outside of [0, 1] it means that the intersection extended the line.
*
*   Note: 
*
*   Because we use the vector formulation of the line intersection, there
*   is none of that icky mucking about with vertical line infinities, etc.
*   The only special case we need to consider is the (almost) zero length 
*   line - and that's considered to miss everything.
*
*   Derivation:
*   
*   for the derivation below  
*   p1 == line1End
*   p0 == line1Start
*   r1 == line2End
*   r0 == line2Start
*
*   V = p1-p0
*   W = r1-r0
*   
*   The vector formulation of the two line equations 
*   p0 + tV and r0 + rW
*   
*   The intersection point is derived as follows:
*   Set the two line equations equal to each other
* 
*        p0 + tV = r0 + rW
*    
*   Expand by coordinates to reflect the fact that the vector equation is 
*   actually two simultaneous linear equations.
*
*   <=> (1) p0.x + tV.x = r0.x + rW.x
*       (2) p0.y + tV.y = r0.y + rW.y
*    
*   <=>     p0.x-r0.x      V.x
*       (3) ---------  + t --- = r
*              W.x         W.x
*
*           p0.y-r0.y      V.y
*       (4) ---------  + t --- = r
*              W.y         W.y
*   
*   <=> W.y(p0.x-r0.x) - W.x(p0.y-r0.y) = t(W.x V.y - V.x W.y)   [subst 3, 4]
*   
*   Setting N.x = -W.y and N.y = W.x  (N is normal to W)
*   
*   <=> - N.x(p0.x-r0.x) - N.y(p0.y-r0.y) = t(N.y V.y + N.x V.x)
*   <=> - N.(p0-r0) = t(N.V)                             [rewrite as vectors]
*   <=> t = -N.(p0-r0)/(N.V)
*   
*       r0 + rW = I
*   <=> rW = I - r0
*   <=> r = (I.x - r0.x)/W.x or (I.y - r0.y)/W.y
*   
*
* Arguments:
*
*    IN  const GpPointF &p0,    first line origin
*    IN  const GpPointF &p1,    
*    IN  const GpPointF &r0,    second line origin
*    IN  const GpPointF &r1,    
*    OUT REAL *t                Length along the first line.
*    OUT REAL *r                Length along the second line.
*    OUT GpPointF *intersect    intersection point.
*
* Return Value:
*   FALSE - no intersection
*   TRUE - intersection.
*
*   10/15/2000 [asecchia]
*       Created it
*
\**************************************************************************/

BOOL IntersectLines(
    IN const GpPointF &line1Start,
    IN const GpPointF &line1End,
    IN const GpPointF &line2Start,
    IN const GpPointF &line2End,
    OUT REAL *line1Length,
    OUT REAL *line2Length,
    OUT GpPointF *intersectionPoint
)
{
    GpVector2D V = line1End-line1Start;
    GpVector2D W = line2End-line2Start;
    
    // Fail for zero length lines.
    
    if((REALABS(V.X) < REAL_EPSILON) &&
       (REALABS(V.Y) < REAL_EPSILON) )
    {
        return FALSE;
    }
    
    if((REALABS(W.X) < REAL_EPSILON) &&
       (REALABS(W.Y) < REAL_EPSILON) )
    {
        return FALSE;
    }
    
    // Normal to W
    
    GpVector2D N;
    N.X = -W.Y;
    N.Y = W.X;
    
    REAL denom = N*V;
    
    // No intersection or collinear lines.
    
    if(REALABS(denom) < REAL_EPSILON)
    {
        return FALSE;
    }
    
    GpVector2D I = line1Start-line2Start;
    
    *line1Length = -((N*I)/denom);
    *intersectionPoint = line1Start + (V * (*line1Length));
    
    // At this point we already know that W.X and W.Y are not both zero because
    // of the trivial rejection step at the top.
    // Pick the divisor with the largest magnitude to preserve precision. 
    
    if(REALABS(W.X) > REALABS(W.Y))
    {
        *line2Length = (intersectionPoint->X - line2Start.X)/W.X;
    }
    else
    {
        *line2Length = (intersectionPoint->Y - line2Start.Y)/W.Y;
    }
    
    return TRUE;
}


/**************************************************************************\
*  
* Function Description:
*
*   PointInPolygonAlternate 
*
*   This function computes the point in polygon test for an input polygon
*   using the fill mode alternate method (even-odd rule).
*
*   This algorithm was constructed from an Eric Haines discussion in 
*   'An Introduction to Ray Tracing' (Glassner) p.p. 53-59
*
*   This algorithm translates the polygon so that the requested point is 
*   at the origin and then fires a ray along the horizontal positive x axis
*   and counts the number of lines in the polygon that cross the axis (NC)
*
* Return Value:
*   
*   TRUE iff point is inside the polygon.
*  
* Input Parameters:
*
*   point - the test point.
*   count - the number of points in the polygon.
*   poly  - the polygon points.
*
*   10/11/2000 [asecchia]
*       Created it
*
\**************************************************************************/

BOOL PointInPolygonAlternate(
    GpPointF point,
    INT count, 
    GpPointF *poly
)
{
    UINT crossingCount = 0;
    
    // Sign holder: stores +1 if the point is above the x axis, -1 for below.
    // Points on the x axis are considered to be above.
    
    INT signHolder = ((poly[0].Y-point.Y) >=0) ? 1 : -1;
    INT nextSignHolder;
    
    // a and b are the indices for the current point and the next point.
    
    for(INT a = 0; a < count; a++)
    {
        // Get the next vertex with modulo arithmetic.
        
        INT b = a + 1;
        
        if(b >= count)
        {
            b = 0;
        }
        
        // Compute the next sign holder.
        
        ((poly[b].Y - point.Y) >= 0) ? nextSignHolder = 1: nextSignHolder = -1;
        
        // If the sign holder and next sign holder are different, this may 
        // indicate a crossing of the x axis - determine if it's on the 
        // positive side.
        
        if(signHolder != nextSignHolder)
        {
            // Both X coordinates are positive, we have a +xaxis crossing.
            
            if( ((poly[a].X - point.X) >= 0) &&
                ((poly[b].X - point.X) >= 0))
            {
                crossingCount++;
            }
            else
            {
                // if at least one of the points is positive, we could intersect
                
                if( ((poly[a].X - point.X) >= 0) ||
                    ((poly[b].X - point.X) >= 0))
                {
                    // Compute the line intersection with the xaxis.
                    
                    if( (REALABS(poly[b].Y-poly[a].Y) > REAL_EPSILON ) &&
                        ((poly[a].X - point.X) - 
                             (poly[a].Y - point.Y) * 
                             (poly[b].X - poly[a].X) / 
                             (poly[b].Y - poly[a].Y)    
                        ) > 0)
                    {
                        crossingCount++;
                    }
                }
            }
            signHolder = nextSignHolder;
        }
    }
    return (BOOL)!(crossingCount & 0x1);
}

/**************************************************************************\
*
* Function Description:
*
*   GetFastAngle computes a NON-angle. It is simply a number representing
*   a monotonically increasing ordering on angles starting at 0 at 0 radians
*   and ending at 8 for 2PI radians. It has a NON-linear relation to the angle.
*
*   Starting on the x-axis with the number 0, we increase by one for
*   each octant as we traverse around the origin in an anti-clockwise direction.
*   This is a very useful (fast) way of comparing angles without working out
*   tricky square roots or arctangents.
*
*   The 'angle' is based on the gradient of the input vector.
*
*  \  |  /
*   \3|2/
*   4\|/1
*  -------
*   5/|\8
*   /6|7\
*  /  |  \
*
*
* Arguments:
*
*   [OUT]  angle  - the angle substitute.
*   [IN]   vector - the input vector.
*
* Return Value:
*
*   Status
*
\**************************************************************************/

GpStatus GetFastAngle(REAL* angle, const GpPointF& vector)
{
    // 0, 0 is an invalid angle.
    
    if(vector.X == 0 && vector.Y == 0)
    {
        *angle = 0.0f;
        return InvalidParameter;
    }

    // Perform a binary octant search. 3 comparisons and 1 divide.
    
    // Are we on the right or the left half of the plane.
    
    if(vector.X >= 0)
    {
        // Right hand half plane.
        // Top or bottom half of the right half plane.
        
        if(vector.Y >= 0)
        {
            // Top right quadrant - check if we're the first or second 
            // octant.
            
            if(vector.X >= vector.Y)
            {
                // First octant - our range is from 0 to 1
                
                *angle = vector.Y/vector.X;
            }
            else
            {
                // Second octant - our range is from 1 to 2
                // reverse the direction to keep the angle increasing
                
                *angle = 2 - vector.X/vector.Y;
            }
        }
        else
        {
            // Bottom right quadrant
            
            if(vector.X >= - vector.Y)
            {
                // eighth (last) octant. y is actually negative, so we're 
                // doing an 8- here. Range 7 to 8
                
                *angle = 8 + vector.Y/vector.X;
            }
            else
            {
                // 7th octant. Our range is 6 to 7
                
                *angle = 6 - vector.X/vector.Y;
            }
        }
    }
    else
    {
        // Left halfplane.
        
        if(vector.Y >= 0)
        {
            // Top left
            
            if(-vector.X >= vector.Y)
            {
                // 4th octant - our range is 3 to 4
                
                *angle = 4 + vector.Y/vector.X;
            }
            else
            {
                // 3rd octant - our range is 2 to 3
                
                *angle = 2 - vector.X/vector.Y;
            }
        }
        else
        {
            // Bottom left
            
            if(-vector.X >= - vector.Y)
            {
                // 5th octant - 4 to 5
                
                *angle = 4 + vector.Y/vector.X;
            }
            else
            {
                // 6th octant - 5 to 6
                
                *angle = 6 - vector.X/vector.Y;
            }
        }
    }

    return Ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\graphics.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998-1999  Microsoft Corporation
*
* Module Name:
*
*   Graphics.hpp
*
* Abstract:
*
*   Declarations for Graphics class
*
* Revision History:
*
*   12/04/1998 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _GRAPHICS_HPP
#define _GRAPHICS_HPP

#include "printer.hpp"

#define GDIP_NOOP_ROP3              0x00AA0029      // do-nothing ROP

// definitions copied from winddi.h :

#ifndef _WINDDI_

DECLARE_HANDLE(HSURF);
DECLARE_HANDLE(DHSURF);
DECLARE_HANDLE(DHPDEV);

typedef struct _SURFOBJ
{
    DHSURF  dhsurf;
    HSURF   hsurf;
    DHPDEV  dhpdev;
    HDEV    hdev;
    SIZEL   sizlBitmap;
    ULONG   cjBits;
    PVOID   pvBits;
    PVOID   pvScan0;
    LONG    lDelta;
    ULONG   iUniq;
    ULONG   iBitmapFormat;
    USHORT  iType;
    USHORT  fjBitmap;
} SURFOBJ;

#endif

// Forward declaration of the GpCachedBitmap class.
class GpCachedBitmap;
class CopyOnWriteBitmap;

/**
 * Represent a graphics context
 */
class GpGraphics
{
friend class GpBitmap;
friend class CopyOnWriteBitmap;
friend class GpMetafile;
friend class MetafilePlayer;
friend class HdcLock;
friend class DriverUni;
friend class MetafileRecorder;
friend class DriverStringImager;
friend class FullTextImager;
friend class FastTextImager;
friend class GpCachedBitmap;

private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagGraphics : ObjectTagInvalid;
    }

    // This method is here so that we have a virtual function table so
    // that we can add virtual methods in V2 without shifting the position
    // of the Tag value within the data structure.
    virtual VOID DontCallThis()
    {
        DontCallThis();
    }

public:
    LONG LockedByGetDC;         // Used by GdipGetDC and GdipReleaseDC

protected:
    static GpGraphics*
    GetForMetafile(
        IMetafileRecord *   metafile,
        EmfType             type,
        HDC                 hdc
        );

    // used by the MetafileRecorder in the EndRecording method
    VOID NoOpPatBlt(
        INT     left,
        INT     top,
        INT     width,
        INT     height
        )
    {
        // Get the devlock because the surface will be flushed when we get the
        // HDC
        Devlock devlock(Device);

        // Get the HDC in the correct state
        HDC hdc = Context->GetHdc(Surface);
        if (hdc != NULL)
        {
            ::PatBlt(hdc, left, top, width, height, GDIP_NOOP_ROP3);
            Context->ReleaseHdc(hdc);
        }

        // Now Reset the HDC so that this happens before the
        // EndOfFile record (which has to be the last record before the
        // EMF's EOF record).
        Context->ResetHdc();
    }

    // If we should send rects to the driver instead of a path
    BOOL UseDriverRects() const
    {
        return (Context->WorldToDevice.IsTranslateScale() &&
                ((!Context->AntiAliasMode) || DownLevel));
    }


public:

    // Get a graphics context from an existing Win32 HDC or HWND

    static GpGraphics* GetFromHdc(HDC hdc, HANDLE hDevice = NULL);

    // Default behaviour is to ignore ICM mode.

    static GpGraphics* GetFromHwnd(
        HWND hwnd,
        HdcIcmMode icmMode = IcmModeOff
        );

    ~GpGraphics();

    // Internal use only

    static GpGraphics* GetFromHdcSurf(HDC hdc,
                                      SURFOBJ* surfObj,
                                      RECTL* bandClip);

    static GpGraphics* GetFromGdiScreenDC(HDC hdc);

    // Get the lock object

    GpLockable *GetObjectLock() const
    {
        return &Lockable;
    }

    // Check to see if the object is valid

    BOOL IsValid() const
    {
    #ifdef _X86_
        // We have to guarantee that the Tag field doesn't move for
        // versioning to work between releases of GDI+.
        ASSERT(offsetof(GpGraphics, Tag) == 4);
    #endif

        ASSERT((Tag == ObjectTagGraphics) || (Tag == ObjectTagInvalid));
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid Graphics");
        }
    #endif

        return (Tag == ObjectTagGraphics);
    }

    // Derive a win32 HDC from the graphics context

    HDC GetHdc();
    VOID ReleaseHdc(HDC hdc);

    // Flush any pending rendering

    VOID Flush(GpFlushIntention intention)
    {
        Devlock devlock(Device);

        DrvFlush(intention);
    }

    //------------------------------------------------------------------------
    // Manipulate the current world transform
    //------------------------------------------------------------------------

    GpStatus SetWorldTransform(const GpMatrix& matrix);

    GpStatus ResetWorldTransform();

    GpStatus MultiplyWorldTransform(const GpMatrix& matrix,
                                    GpMatrixOrder order = MatrixOrderPrepend);

    GpStatus TranslateWorldTransform(REAL dx, REAL dy,
                                     GpMatrixOrder order = MatrixOrderPrepend);

    GpStatus ScaleWorldTransform(REAL sx, REAL sy,
                                 GpMatrixOrder order = MatrixOrderPrepend);

    GpStatus RotateWorldTransform(REAL angle,
                                  GpMatrixOrder order = MatrixOrderPrepend);

    VOID GetWorldTransform(GpMatrix & matrix) const
    {
        matrix = Context->WorldToPage;
    }

    GpStatus GetDeviceToWorldTransform(GpMatrix * matrix) const;

    VOID GetWorldToDeviceTransform(GpMatrix * matrix) const
    {
        *matrix = Context->WorldToDevice;
    }
    VOID GetWorldToDeviceTransform(REAL * m) const
    {
        Context->WorldToDevice.GetMatrix(m);
    }

    VOID GetWorldPixelSize(REAL & xSize, REAL & ySize);

    // Manipulate the current page transform

    // !! *PageTransform's to be phased out...
    GpStatus SetPageTransform(GpPageUnit unit, REAL scale = 1);

    GpStatus ResetPageTransform()
    {
        return SetPageTransform(UnitDisplay);
    }

    GpPageUnit GetPageUnit() const   { return Context->PageUnit; }
    REAL GetPageScale() const        { return Context->PageScale; }

    GpStatus SetPageUnit(GpPageUnit unit)
    {
        return SetPageTransform(unit, GetPageScale());
    }

    GpStatus SetPageScale(REAL scale)
    {
        return SetPageTransform(GetPageUnit(), scale);
    }

    GpStatus TransformPoints(
        GpPointF *          points,
        INT                 count,
        GpCoordinateSpace   source = CoordinateSpaceWorld,
        GpCoordinateSpace   dest   = CoordinateSpaceDevice
        );


    /// GetScaleForAlternatePageUnit
    //
    //  Return world unit scale factor corresponding to the difference
    //  between the page units selected in the graphics and a unit specified
    //  to an API such as pen thickness or font height.
    //
    //  The returned vector provides the amount by which to multiply world
    //  x and y coordinates so that they will behave according to the
    //  alternate unit when passed through Context.WorldToDevice.

    REAL GetScaleForAlternatePageUnit(Unit unit) const
    {
        // pen width and font height must not use UnitDisplay because
        // it is a device dependent unit.
        ASSERT(unit != UnitDisplay);

        // The x:Y aspect ratio of the device resolution doesn't matter here,
        // we get exactly the same values whether we use DpiX/PageMultiplierX
        // or DpiY/PageMiltiplierY.

        switch (unit)
        {
            case UnitDocument:
                return ((GetDpiX()/300.0f) / Context->PageMultiplierX);
            case UnitPoint:
                return ((GetDpiX()/72.0f)  / Context->PageMultiplierX);
            case UnitMillimeter:
                return ((GetDpiX()/25.4f)  / Context->PageMultiplierX);
            case UnitInch:
                return (GetDpiX()          / Context->PageMultiplierX);
            case UnitWorld:
            case UnitPixel:
            default:
                return 1.0f;
        }
    }



    // Clipping related methods

    GpStatus SetClip(GpGraphics* g, CombineMode combineMode);

    GpStatus SetClip(const GpRectF& rect, CombineMode combineMode);

    GpStatus SetClip(GpPath* path, CombineMode combineMode,
                     BOOL isDevicePath = FALSE);

    GpStatus SetClip(GpRegion* region, CombineMode combineMode);

    GpStatus SetClip(HRGN hRgn, CombineMode combineMode);

    GpStatus ResetClip();

    GpStatus OffsetClip(REAL dx, REAL dy);

    GpRegion* GetClip() const;

    GpStatus GetClip(GpRegion* region) const;

    // save and restore graphics state

    INT Save();
    VOID Restore(INT gstate);

    // start and end container drawing

    INT
    BeginContainer(
        const GpRectF &     destRect,
        const GpRectF &     srcRect,
        GpPageUnit          srcUnit,
        REAL                srcDpiX      = 0.0f,  // for metafile playback only
        REAL                srcDpiY      = 0.0f,
        BOOL                srcIsDisplay = TRUE   // for metafile playback only
        );

    INT BeginContainer(
        // all these params are only applicable for metafile playback
        BOOL                forceIdentityTransform = FALSE,
        REAL                srcDpiX      = 0.0f,
        REAL                srcDpiY      = 0.0f,
        BOOL                srcIsDisplay = TRUE
        );

    VOID EndContainer(INT containerState);

    // Hit testing operations

    VOID GetClipBounds(GpRectF& rect) const;

    BOOL IsClipEmpty() const;

    VOID GetVisibleClipBounds(GpRectF& rect) const;

    BOOL IsVisibleClipEmpty() const;

    GpRegion* GetVisibleClip() const;

    HRGN GetVisibleClipHRgn() const
    {
        return Context->VisibleClip.GetHRgn();
    }

    BOOL IsVisible(const GpPointF& point) const;

    BOOL IsVisible(const GpRectF& rect) const;

    GpStatus GetPixelColor(REAL x, REAL y, ARGB* argb) const;

    // Set antialiasing mode

    VOID SetAntiAliasMode( BOOL newMode )
    {
        ASSERT(Context);

        // for Printer DC never set AA
        if (IsPrinter())
        {
            Context->AntiAliasMode = FALSE;
            return;
        }

        if (IsRecording() && (newMode != Context->AntiAliasMode))
        {
            Metafile->RecordSetAntiAliasMode(newMode);
        }
        Context->AntiAliasMode = newMode;
    }

    BOOL GetAntiAliasMode() const
    {
        ASSERT(Context);
        return(Context->AntiAliasMode);
    }

  // Set antialiasing text

    VOID SetTextRenderingHint( TextRenderingHint newMode)
    {
        ASSERT(Context);

        // for Printer DC never set AA or Clear Type text
        if (IsPrinter())
        {
            Context->TextRenderHint = TextRenderingHintSingleBitPerPixelGridFit;
            return;
        }

        if (IsRecording() && (newMode != Context->TextRenderHint))
        {
            Metafile->RecordSetTextRenderingHint(newMode);
        }

        Context->TextRenderHint = newMode;
    }

    TextRenderingHint GetTextRenderingHint() const
    {
        ASSERT(Context);
        return(Context->TextRenderHint);
    }

    // this procedure is meant to be used by internal text routines
    // and will return real text rendering hint (not TextRenderingHintSystemDefault)
    // we should always call CalculateTextRenderingHintInternal() before
    // calling GetTextRenderingHintInternal()
    TextRenderingHint GetTextRenderingHintInternal() const
    {
        return TextRenderingHintInternal;
    }

    Status SetTextContrast(UINT contrast)
    {
        ASSERT(Context);

        if (contrast > MAX_TEXT_CONTRAST_VALUE)
            return InvalidParameter;

        // for Printer DC never set AA or Clear Type text
        if (IsPrinter())
        {
            Context->TextContrast = 0;
            return Ok;
        }

        if (IsRecording() && (contrast != Context->TextContrast))
        {
            Metafile->RecordSetTextContrast(contrast);
        }

        Context->TextContrast = contrast;
        return Ok;
    }

    UINT GetTextContrast() const
    {
        ASSERT(Context);

        return Context->TextContrast;
    }

    // Rendering Origin
    // This is the origin used for Dither and Halftone matrix origins
    // and should be used for any raster operations that need an origin.

    VOID SetRenderingOrigin(INT x, INT y)
    {
        ASSERT(Context);

        if (IsRecording() &&
            (x != Context->RenderingOriginX ||
             y != Context->RenderingOriginY)
           )
        {
            Metafile->RecordSetRenderingOrigin(x, y);
        }
        Context->RenderingOriginX = x;
        Context->RenderingOriginY = y;
    }


    // Rendering Origin
    // Returns the origin used for the Dither and Halftone matrix origin.

    VOID GetRenderingOrigin(INT *x, INT *y) const
    {
        ASSERT(Context);
        ASSERT(x);
        ASSERT(y);

        *x = Context->RenderingOriginX;
        *y = Context->RenderingOriginY;
    }


    // Compositing mode

    VOID SetCompositingMode( GpCompositingMode newMode )
    {
        ASSERT(Context);

        if (IsRecording() && (newMode != Context->CompositingMode))
        {
            Metafile->RecordSetCompositingMode(newMode);
        }
        Context->CompositingMode = newMode;
    }

    GpCompositingMode GetCompositingMode() const
    {
        ASSERT(Context);
        return(Context->CompositingMode);
    }

    // Compositing quality

    VOID SetCompositingQuality( GpCompositingQuality newQuality )
    {
        ASSERT(Context);

        if (IsRecording() && (newQuality != Context->CompositingQuality))
        {
            Metafile->RecordSetCompositingQuality(newQuality);
        }
        Context->CompositingQuality = newQuality;
    }

    GpCompositingQuality GetCompositingQuality() const
    {
        ASSERT(Context);
        return(Context->CompositingQuality);
    }

    VOID SetInterpolationMode(InterpolationMode newMode)
    {
        ASSERT(Context);

        if (IsRecording() && (newMode != Context->FilterType))
        {
            Metafile->RecordSetInterpolationMode(newMode);
        }

        Context->FilterType = newMode;
    }
    InterpolationMode GetInterpolationMode() const
    {
        ASSERT(Context);
        return Context->FilterType;
    }

    VOID SetPixelOffsetMode(PixelOffsetMode newMode)
    {
        ASSERT(Context);

        if (newMode != Context->PixelOffset)
        {
            if (IsRecording())
            {
                Metafile->RecordSetPixelOffsetMode(newMode);
            }
            Context->PixelOffset = newMode;
            Context->InverseOk = FALSE;
            Context->UpdateWorldToDeviceMatrix();
        }
    }

    PixelOffsetMode GetPixelOffsetMode() const
    {
        ASSERT(Context);
        return Context->PixelOffset;
    }

    //------------------------------------------------------------------------
    // GetNearestColor (for <= 8bpp surfaces)
    //------------------------------------------------------------------------

    ARGB
    GetNearestColor(
        ARGB        argb
        );

    //------------------------------------------------------------------------
    // Stroke vector shapes
    //------------------------------------------------------------------------

    GpStatus
    DrawLine(
        GpPen* pen,
        const GpPointF& pt1,
        const GpPointF& pt2
        )
    {
        GpPointF points[2];

        points[0] = pt1;
        points[1] = pt2;

        return(DrawLines(pen, &points[0], 2));
    }

    GpStatus
    DrawLine(
        GpPen* pen,
        REAL x1,
        REAL y1,
        REAL x2,
        REAL y2
        )
    {
        GpPointF points[2];

        points[0].X = x1;
        points[0].Y = y1;
        points[1].X = x2;
        points[1].Y = y2;

        return(DrawLines(pen, &points[0], 2));
    }

    GpStatus
    DrawLines(
        GpPen* pen,
        const GpPointF* points,
        INT count,
        BOOL closed = FALSE
        );

    GpStatus
    DrawArc(
        GpPen* pen,
        const GpRectF& rect,
        REAL startAngle,
        REAL sweepAngle
        );

    GpStatus
    DrawArc(
        GpPen* pen,
        REAL x,
        REAL y,
        REAL width,
        REAL height,
        REAL startAngle,
        REAL sweepAngle
        )
    {
        GpRectF rect(x, y, width, height);

        return DrawArc(pen, rect, startAngle, sweepAngle);
    }

    GpStatus
    DrawBezier(
        GpPen* pen,
        const GpPointF& pt1,
        const GpPointF& pt2,
        const GpPointF& pt3,
        const GpPointF& pt4
        )
    {
        GpPointF points[4];

        points[0] = pt1;
        points[1] = pt2;
        points[2] = pt3;
        points[3] = pt4;

        return DrawBeziers(pen, points, 4);
    }

    GpStatus
    DrawBezier(
        GpPen* pen,
        REAL x1, REAL y1,
        REAL x2, REAL y2,
        REAL x3, REAL y3,
        REAL x4, REAL y4
        )
    {
        GpPointF points[4];

        points[0].X = x1;
        points[0].Y = y1;
        points[1].X = x2;
        points[1].Y = y2;
        points[2].X = x3;
        points[2].Y = y3;
        points[3].X = x4;
        points[3].Y = y4;

        return DrawBeziers(pen, points, 4);
    }

    GpStatus
    DrawBeziers(
        GpPen* pen,
        const GpPointF* points,
        INT count
        );

    GpStatus
    DrawRect(
        GpPen* pen,
        const GpRectF& rect
        )
    {
        return(DrawRects(pen, &rect, 1));
    }

    GpStatus
    DrawRect(
        GpPen* pen,
        REAL x,
        REAL y,
        REAL width,
        REAL height
        )
    {
        GpRectF rect(x, y, width, height);
        return(DrawRects(pen, &rect, 1));
    }

    GpStatus
    DrawRects(
        GpPen* pen,
        const GpRectF* rects,
        INT count
        );

    GpStatus
    DrawEllipse(
        GpPen* pen,
        const GpRectF& rect
        );

    GpStatus
    DrawEllipse(
        GpPen* pen,
        REAL x,
        REAL y,
        REAL width,
        REAL height
        )
    {
        GpRectF rect(x, y, width, height);
        return DrawEllipse(pen, rect);
    }

    GpStatus
    DrawPie(
        GpPen* pen,
        const GpRectF& rect,
        REAL startAngle,
        REAL sweepAngle
        );

    GpStatus
    DrawPie(
        GpPen* pen,
        REAL x,
        REAL y,
        REAL width,
        REAL height,
        REAL startAngle,
        REAL sweepAngle
        )
    {
        GpRectF rect(x, y, width, height);
        return DrawPie(pen, rect, startAngle, sweepAngle);
    }

    GpStatus
    DrawPolygon(
        GpPen* pen,
        const GpPointF* points,
        INT count
        )
    {
        return(DrawLines(pen, points, count, TRUE));
    }

    GpStatus
    DrawPath(
        GpPen* pen,
        GpPath* path
        );

    GpStatus
    DrawPathData(
        GpPen* pen,
        const GpPointF* points,
        const BYTE *types,
        INT count,
        GpFillMode fillMode
        )
    {
        GpStatus status = GenericError;

        GpPath path(points, types, count, fillMode);
        if(path.IsValid())
            status = DrawPath(pen, &path);

        return status;
    }

    GpStatus
    DrawCurve(
        GpPen* pen,
        const GpPointF* points,
        INT count
        );

    GpStatus
    DrawCurve(
        GpPen* pen,
        const GpPointF* points,
        INT count,
        REAL tension,
        INT offset,
        INT numberOfSegments
        );

    GpStatus
    DrawClosedCurve(
        GpPen* pen,
        const GpPointF* points,
        INT count
        );

    GpStatus
    DrawClosedCurve(
        GpPen* pen,
        const GpPointF* points,
        INT count,
        REAL tension
        );


    //------------------------------------------------------------------------
    // Fill shapes
    //------------------------------------------------------------------------

    GpStatus
    Clear(
        const GpColor &color
        );

    GpStatus
    FillRect(
        GpBrush* brush,
        const GpRectF& rect
        )
    {
        return(FillRects(brush, &rect, 1));
    }

    GpStatus
    FillRect(
        GpBrush* brush,
        REAL x,
        REAL y,
        REAL width,
        REAL height
        )
    {
        GpRectF rect(x, y, width, height);
        return(FillRects(brush, &rect, 1));
    }

    GpStatus
    FillRects(
        GpBrush* brush,
        const GpRectF* rects,
        INT count
        );

    GpStatus
    FillPolygon(
        GpBrush* brush,
        const GpPointF* points,
        INT count
        )
    {
        return FillPolygon(brush, points, count, FillModeAlternate);
    }

    GpStatus
    FillPolygon(
        GpBrush* brush,
        const GpPointF* points,
        INT count,
        GpFillMode fillMode
        );

    GpStatus
    FillEllipse(
        GpBrush* brush,
        const GpRectF& rect
        );

    GpStatus
    FillEllipse(
        GpBrush* brush,
        REAL x,
        REAL y,
        REAL width,
        REAL height
        )
    {
        GpRectF rect(x, y, width, height);
        return FillEllipse(brush, rect);
    }

    GpStatus
    FillPie(
        GpBrush* brush,
        const GpRectF& rect,
        REAL startAngle,
        REAL sweepAngle
        );

    GpStatus
    FillPie(
        GpBrush* brush,
        REAL x,
        REAL y,
        REAL width,
        REAL height,
        REAL startAngle,
        REAL sweepAngle
        )
    {
        GpRectF rect(x, y, width, height);
        return FillPie(brush, rect, startAngle, sweepAngle);
    }

    GpStatus
    FillPath(
        const GpBrush* brush,
        GpPath* path
        );

    GpStatus
    FillPathData(
        GpBrush* brush,
        const GpPointF* points,
        const BYTE *types,
        INT count,
        GpFillMode fillMode
        )
    {
        GpStatus status = GenericError;

        GpPath path(points, types, count, fillMode);
        if(path.IsValid())
            status = FillPath(brush, &path);

        return status;
    }

    GpStatus
    FillClosedCurve(
        GpBrush* brush,
        const GpPointF* points,
        INT count,
        REAL tension = 0.5,
        GpFillMode fillMode = FillModeAlternate
        );

    GpStatus
    FillRegion(
        GpBrush* brush,
        GpRegion* region
        );


    //------------------------------------------------------------------------
    // Draw text strings
    //------------------------------------------------------------------------


#define DG_NOGDI        4   // Disable optimisation through GDI
#define DG_SIDEWAY      0x80000000   // flag used by the drivers (Meta Driver) for sideway runs.


    // To be removed, replaced by DrawRealizedGlyphs and GdiDrawGlyphs

    GpStatus
    DrawGlyphs(
        const UINT16     *glyphIndices,
        INT               count,
        const GpFontFace *face,
        INT               style,
        REAL              emSize,
        Unit              unit,
        const GpBrush    *brush,
        const UINT32     *px,
        const UINT32     *py,
        INT               flags,
        const GpMatrix   *pmx = NULL
    );


    // Internal text drawing APIs

protected:
    // should be called once per DrawString/DrawDriverString call
    // checks for invalid text rendering hint combinations
    GpStatus CheckTextMode();

    // this method is meant to calculate TextRenderingHintInternal
    // we call this method once and only once before using GetTextRenderingHintInternal()
    void CalculateTextRenderingHintInternal();

public:

    GpStatus DrawPlacedGlyphs(
        const GpFaceRealization *faceRealization,
        const GpBrush           *brush,
        INT                      flags,
        const WCHAR             *string,
        UINT                     stringLength,
        BOOL                     rightToLeft,
        const UINT16            *glyphs,
        const UINT16            *glyphMap,
        const PointF            *glyphOrigins,
        INT                      glyphCount,
        ItemScript               Script,
        BOOL                     sideways        // e.g. FE characters in vertical text
    );


    GpStatus DrawDriverGlyphs(
        const UINT16     *glyphs,
        INT               glyphCount,
        const GpFont     *font,
        const GpFontFace *face,
        const GpBrush    *brush,
        const WCHAR      *string,
        const PointF     *positions,
        INT               flags,
        const GpMatrix   *matrix
    );


    // External text drawing APIs
    GpStatus
    DrawString(
        const WCHAR          *string,
        INT                   length,
        const GpFont         *font,
        const RectF          *layoutRect,
        const GpStringFormat *format,
        const GpBrush        *brush
    );

    GpStatus
    MeasureString(
        const WCHAR          *string,
        INT                   length,
        const GpFont         *font,
        const RectF          *layoutRect,
        const GpStringFormat *format,
        RectF                *boundingBox,
        INT                  *codepointsFitted,
        INT                  *linesFilled
    );


    GpStatus
    MeasureCharacterRanges(
        const WCHAR          *string,
        INT                   length,
        const GpFont         *font,
        const RectF          &layoutRect,
        const GpStringFormat *format,
        INT                   regionCount,
        GpRegion            **regions
    );

/// Start API for graphicstext.cpp

    GpStatus
    RecordEmfPlusDrawDriverString(
        const UINT16     *text,
        INT               glyphCount,
        const GpFont     *font,
        const GpFontFace *face,
        const GpBrush    *brush,
        const PointF     *positions,
        INT               flags,
        const GpMatrix   *matrix        // optional
    );

    GpStatus
    DrawDriverString(
        const UINT16    *text,
        INT              length,
        const GpFont    *font,
        const GpBrush   *brush,
        const PointF    *positions,
        INT              flags,
        const GpMatrix        *matrix
    );

    GpStatus
    MeasureDriverString(
        const UINT16     *text,
        INT               glyphCount,
        const GpFont     *font,
        const PointF     *positions,
        INT               flags,
        const GpMatrix   *matrix,       // In  - Optional glyph transform
        RectF            *boundingBox   // Out - Overall bounding box of cells
    );

    GpStatus
    DrawFontStyleLine(
        const PointF        *baselineOrigin,    // baseline origin
        REAL                baselineLength,     // baseline length
        const GpFontFace    *face,              // font face
        const GpBrush       *brush,             // brush
        BOOL                vertical,           // vertical text?
        REAL                emSize,             // font EM size in world unit
        INT                 style,              // kind of lines to be drawn
        const GpMatrix      *matrix = NULL      // additional transform
    );

    REAL GetDevicePenWidth(
        REAL            widthInWorldUnits,
        const GpMatrix  *matrix = NULL
    );

/// End API for graphicstext.cpp


    GpStatus
    DrawCachedBitmap(
        GpCachedBitmap *cb,
        INT x,
        INT y
    )
    {
        return DrvDrawCachedBitmap(cb, x, y);
    }

    //------------------------------------------------------------------------
    // Draw images (both bitmap and metafile)
    //------------------------------------------------------------------------

    GpStatus
    DrawImage(
        GpImage* image,
        const GpPointF& point
        );

    GpStatus
    DrawImage(
        GpImage* image,
        REAL x,
        REAL y
        )
    {
        GpPointF point(x, y);
        return DrawImage(image, point);
    }

    GpStatus
    DrawImage(
        GpImage* image,
        const GpRectF& destRect
        );

    GpStatus
    DrawImage(
        GpImage* image,
        REAL x,
        REAL y,
        REAL width,
        REAL height
        )
    {
        GpRectF destRect(x, y, width, height);
        return DrawImage(image, destRect);
    }

    GpStatus
    DrawImage(
        GpImage* image,
        const GpPointF* destPoints,
        INT count
        );

    GpStatus
    DrawImage(
        GpImage* image,
        REAL            x,
        REAL            y,
        const GpRectF & srcRect,
        GpPageUnit      srcUnit
        );

    GpStatus
    DrawImage(
        GpImage*         image,
        const GpRectF&   destRect,
        const GpRectF&   srcRect,
        GpPageUnit       srcUnit,
        const GpImageAttributes* imageAttributes = NULL,
        DrawImageAbort   callback = NULL,
        VOID*            callbackData = NULL
        );

    GpStatus
    DrawImage(
        GpImage*             image,
        const GpPointF*      destPoints,
        INT                  count,
        const GpRectF&       srcRect,
        GpPageUnit           srcUnit,
        const GpImageAttributes*   imageAttributes = NULL,
        DrawImageAbort       callback = NULL,
        VOID*                callbackData = NULL
        );

    GpStatus
    EnumerateMetafile(
        const GpMetafile *      metafile,
        const PointF &          destPoint,
        EnumerateMetafileProc   callback,
        VOID *                  callbackData,
        const GpImageAttributes *     imageAttributes
        );

    GpStatus
    EnumerateMetafile(
        const GpMetafile *      metafile,
        const RectF &           destRect,
        EnumerateMetafileProc   callback,
        VOID *                  callbackData,
        const GpImageAttributes *     imageAttributes
        );

    GpStatus
    EnumerateMetafile(
        const GpMetafile *      metafile,
        const PointF *          destPoints,
        INT                     count,
        EnumerateMetafileProc   callback,
        VOID *                  callbackData,
        const GpImageAttributes *     imageAttributes
        );

    GpStatus
    EnumerateMetafile(
        const GpMetafile *      metafile,
        const PointF &          destPoint,
        const RectF &           srcRect,
        Unit                    srcUnit,
        EnumerateMetafileProc   callback,
        VOID *                  callbackData,
        const GpImageAttributes *     imageAttributes
        );

    GpStatus
    EnumerateMetafile(
        const GpMetafile *      metafile,
        const RectF &           destRect,
        const RectF &           srcRect,
        Unit                    srcUnit,
        EnumerateMetafileProc   callback,
        VOID *                  callbackData,
        const GpImageAttributes *     imageAttributes
        );

    GpStatus
    EnumerateMetafile(
        const GpMetafile *      metafile,
        const PointF *          destPoints,
        INT                     count,
        const RectF &           srcRect,
        Unit                    srcUnit,
        EnumerateMetafileProc   callback,
        VOID *                  callbackData,
        const GpImageAttributes *     imageAttributes
        );

    GpStatus
    Comment(
        UINT            sizeData,
        const BYTE *    data
        )
    {
        GpStatus        status = InvalidParameter;

        if (IsRecording())
        {
            status = Metafile->RecordComment(sizeData, data);
            if (status != Ok)
            {
                SetValid(FALSE);      // Prevent any more recording
            }
        }
        return status;
    }

   // Called only by metafile player
    GpStatus
    EnumEmf(
        MetafilePlayer *        player,
        HENHMETAFILE            hEmf,
        const GpRectF &         destRect,
        const GpRectF &         srcRect,
        const GpRectF &         deviceDestRect,
        MetafileType            type,
        BOOL                    isTranslateScale,
        BOOL                    renderToBitmap,
        const GpMatrix &        flipAndCropTransform
        );

    // Called only by metafile player
    GpStatus
    EnumEmfPlusDual(
        MetafilePlayer *        player,
        HENHMETAFILE            hEmf,
        const GpRectF&          destRect,       // inclusive, exclusive
        const GpRectF&          deviceDestRect, // inclusive, exclusive
        BOOL                    isTranslateScale,
        BOOL                    renderToBitmap
        );

protected:

    // if an HWND is passed in, the default ICM mode is off.
    // if an HDC is passed in, the icmMode flag is ignored.

    GpGraphics(
        HWND hwnd,
        HDC hdc,
        INT clientWidth,
        INT clientHeight,
        HdcIcmMode icmMode = IcmModeOff,
        BOOL gdiLayered = FALSE
    );

    GpGraphics(DpBitmap * surface);

    GpStatus GetDCDrawBounds(HDC hdc, RECT *rect);

public:

    // The Context dpi and the Surface dpi are always the same,
    // except possibly during metafile playback when the Context
    // may be using the metafile dpi (which is what rendering
    // should use).

    REAL GetDpiX() const        { return Context->GetDpiX(); }
    REAL GetDpiY() const        { return Context->GetDpiY(); }

    BOOL IsPrinter() const { return Printer; }

protected:

    enum HalftoneType
    {
        HalftoneTypeNone,
        HalftoneType16Color,
        HalftoneType216Color,
        HalftoneType15Bpp,
        HalftoneType16Bpp,
    };

    HalftoneType GetHalftoneType() const
    {
        EpPaletteMap* paletteMap = BottomContext.PaletteMap;

        // !! TODO: Verify this works on when switching modes
        if (paletteMap != NULL)
        {
            // we are doing 8bpp palette map
            if (paletteMap->IsVGAOnly())
            {
                return HalftoneType16Color;
            }
            else
            {
                return HalftoneType216Color;
            }
        }
        else if (Surface->PixelFormat == PixelFormat16bppRGB555)
        {
            return HalftoneType15Bpp;
        }
        else if (Surface->PixelFormat == PixelFormat16bppRGB565)
        {
            return HalftoneType16Bpp;
        }
        else
        {
            return HalftoneTypeNone;
        }
    }

    //--------------------------------------------------------------
    // Internal fill and draw routines that do not record
    // path, rect, or region in a metafile.
    //--------------------------------------------------------------

    GpStatus
    RenderFillRects(
        GpRectF*        bounds,
        INT             count,
        const GpRectF*  rects,
        GpBrush*        brush
        )
    {
        GpRect      deviceBounds;
        GpStatus status = BoundsFToRect(bounds, &deviceBounds);

        if (status == Ok && !IsTotallyClipped(&deviceBounds))
        {
            // Now that we've done a bunch of work in accumulating the bounds,
            // acquire the device lock before calling the driver:

            Devlock devlock(Device);

            return DrvFillRects(&deviceBounds, count, rects, brush->GetDeviceBrush());
        }
        return status;
    }

    GpStatus
    RenderFillRegion(
        GpRectF*    bounds,
        GpRegion*   region,
        GpBrush*    brush,
        GpRect*     metafileBounds
        )
    {
        GpRect      deviceBounds;
        GpStatus status = BoundsFToRect(bounds, &deviceBounds);
        BOOL isInfinite = FALSE;
        GpMatrix identity;

        if (status == Ok && !IsTotallyClipped(&deviceBounds))
        {
            // Now that we've done a bunch of work in accumulating the bounds,
            // acquire the device lock before calling the driver:

            status = region->UpdateDeviceRegion(&(Context->WorldToDevice));

            if (status == Ok)
            {
                DpRegion *  deviceRegion = &(region->DeviceRegion);
                DpRegion    metafileRegion;

                if (metafileBounds != NULL)
                {
                    metafileRegion.Set(metafileBounds);
                    metafileRegion.And(deviceRegion);
                    if (!metafileRegion.IsValid())
                    {
                        return GenericError;
                    }
                    deviceRegion = &metafileRegion;
                }

                // Get the actual bounds now to give to the driver
                deviceRegion->GetBounds(&deviceBounds);

                // Make sure there is still something to fill so we
                // don't ASSERT later on.
                if ((deviceBounds.Width > 0) && (deviceBounds.Height > 0))
                {
                    Devlock devlock(Device);

                    return DrvFillRegion(&deviceBounds, deviceRegion, brush->GetDeviceBrush());
                }
            }
        }
        return status;
    }

    GpStatus RenderDrawPath(
        GpRectF *bounds,
        GpPath *path,
        GpPen *pen
    );

    GpStatus RenderFillPath(
        GpRectF *bounds,
        GpPath *path,
        const GpBrush *brush
    );

    VOID
    GetImageDestPageSize(
        const GpImage *     image,
        REAL                srcWidth,
        REAL                srcHeight,
        GpPageUnit          srcUnit,
        REAL &              destWidth,
        REAL &              destHeight
        );

    VOID
    DeviceToWorldTransformRect(
        const GpRect &    deviceRect,
        GpRectF &   rect
        ) const;

    static GpGraphics *GetFromGdiBitmap(HDC hdc);
    static GpGraphics *GetFromGdipBitmap(
        GpBitmap*       bitmap,
        ImageInfo *     imageInfo,
        EpScanBitmap *  scanBitmap,
        BOOL            isDisplay
        );
    static GpGraphics *GetFromGdiPrinterDC(HDC hdc);
    static GpGraphics *GetFromGdiEmfDC(HDC hdc);
    static GpGraphics *GetFromDirectDrawSurface(IDirectDrawSurface7 * surface);
    static GpGraphics *GetFromGdiPrinterDC(HDC hdc, HANDLE hPrinter);

    static INT GetPostscriptLevel(HDC hdc, HANDLE hPrinter);

    GpStatus StartPrinterEMF();

    GpStatus EndPrinterEMF();

    BOOL IsTotallyClipped(GpRect *rect) const;

    BOOL IsRecording() const { return Metafile != NULL; }

    BOOL IsDisplay() const { return Context->IsDisplay; }

    VOID DoResetClip()
    {
        Context->AppClip.SetInfinite();

        // ContainerClip always contains the clipping for the container,
        // intersected with the WindowClip.
        Context->VisibleClip.Set(&(Context->ContainerClip));
    }

    // The AppClip has been set into VisibleClip; now intersect it with
    // the container clip and the window clip.
    GpStatus AndVisibleClip()
    {
        // ContainerClip always contains the clipping for the container,
        // intersected with the WindowClip.
        return Context->VisibleClip.And(&(Context->ContainerClip));
    }

    GpStatus
    CombineClip(
        const GpRectF & rect,
        CombineMode     combineMode
        );

    GpStatus
    CombineClip(
        const GpPath *  path,
        CombineMode     combineMode,
        BOOL            isDevicePath = FALSE
        );

    GpStatus
    CombineClip(
        GpRegion *      region,
        CombineMode     combineMode
        );

    GpStatus
    InheritAppClippingAndTransform(
        HDC hdc
        );

    VOID
    ResetState(
        INT x,
        INT y,
        INT width,
        INT height
        );

    VOID
    UpdateDrawBounds(
        INT x,
        INT y,
        INT width,
        INT height
        );

    //--------------------------------------------------------------------------
    // Routines for calling the driver
    //--------------------------------------------------------------------------

    VOID
    DrvFlush(
        GpFlushIntention intention
        )
    {
        ASSERTMSG(Device->DeviceLock.IsLockedByCurrentThread(),
            ("DeviceLock must be held by current thread"));

        Driver->Flush(Device, Surface, intention);

    }

    GpStatus
    DrvStrokePath(
        const GpRect *drawBounds,
        const DpPath *path,
        const DpPen  *pen
        )
    {
        ASSERTMSG(GetObjectLock()->IsLocked(),
                  ("Graphics object must be locked"));

        ASSERTMSG(Device->DeviceLock.IsLockedByCurrentThread(),
            ("DeviceLock must be held by current thread"));

        FPUStateSaver::AssertMode();

        Surface->Uniqueness = (DWORD)GpObject::GenerateUniqueness();
        return(Driver->StrokePath(Context, Surface, drawBounds, path, pen));
    }

    GpStatus
    DrvFillRects(
        const GpRect *drawBounds,
        INT numRects,
        const GpRectF *rects,
        const DpBrush *brush
        )
    {
        ASSERTMSG(GetObjectLock()->IsLocked(),
                  ("Graphics object must be locked"));

        ASSERTMSG(Device->DeviceLock.IsLockedByCurrentThread(),
            ("DeviceLock must be held by current thread"));

        FPUStateSaver::AssertMode();

        Surface->Uniqueness = (DWORD)GpObject::GenerateUniqueness();
        return(Driver->FillRects(Context, Surface, drawBounds,
                                 numRects, rects, brush));
    }

    GpStatus
    DrvFillPath(
        const GpRect *drawBounds,
        const DpPath *path,
        const DpBrush *brush
        )
    {
        ASSERTMSG(GetObjectLock()->IsLocked(),
                  ("Graphics object must be locked"));

        ASSERTMSG(Device->DeviceLock.IsLockedByCurrentThread(),
            ("DeviceLock must be held by current thread"));

        FPUStateSaver::AssertMode();

        Surface->Uniqueness = (DWORD)GpObject::GenerateUniqueness();
        return(Driver->FillPath(Context, Surface, drawBounds, path, brush));
    }

    GpStatus
    DrvFillRegion(
        const GpRect *drawBounds,
        const DpRegion *region,
        const DpBrush *brush
        )
    {
        ASSERTMSG(GetObjectLock()->IsLocked(),
                  ("Graphics object must be locked"));

        ASSERTMSG(Device->DeviceLock.IsLockedByCurrentThread(),
            ("DeviceLock must be held by current thread"));

        FPUStateSaver::AssertMode();

        Surface->Uniqueness = (DWORD)GpObject::GenerateUniqueness();
        return(Driver->FillRegion(Context, Surface, drawBounds, region, brush));
    }

    GpStatus
    DrvDrawGlyphs(
        const GpRect             *drawBounds,
        const GpGlyphPos         *glyphPos,
        const GpGlyphPos         *glyphPathPos,
        INT                       count,
        const DpBrush            *brush,
        const GpFaceRealization  *faceRealization,
        const UINT16             *glyphs,
        const UINT16             *glyphMap,
        const PointF             *glyphOrigins,
        INT                       glyphCount,
        const WCHAR              *string,
        UINT                      stringLength,
        ItemScript                script,
        INT                       edgeGlyphAdvance,
        BOOL                      rightToLeft,
        INT                       flags
    )
    {
        // check the input parameter!!

        GpStatus status;
        DrawGlyphData drawGlyphData;

        drawGlyphData.context           = Context;
        drawGlyphData.surface           = Surface;
        drawGlyphData.drawBounds        = drawBounds;
        drawGlyphData.glyphPos          = glyphPos;
        drawGlyphData.glyphPathPos      = glyphPathPos;
        drawGlyphData.count             = count;
        drawGlyphData.brush             = brush;
        drawGlyphData.faceRealization   = faceRealization;
        drawGlyphData.glyphs            = glyphs;
        drawGlyphData.glyphMap          = glyphMap;
        drawGlyphData.glyphOrigins      = glyphOrigins;
        drawGlyphData.glyphCount        =  glyphCount;
        drawGlyphData.string            = string;
        drawGlyphData.stringLength      = stringLength;
        drawGlyphData.script            = script;
        drawGlyphData.edgeGlyphAdvance  = edgeGlyphAdvance;
        drawGlyphData.rightToLeft       = rightToLeft;
        drawGlyphData.flags             =  flags;

        status = Driver->DrawGlyphs(&drawGlyphData);

        return status;
    }

    // Draw the CachedBitmap on this graphics.
    // This routine sets up the rendering origin and the locks
    // and calls the appropriate driver.

    GpStatus
    DrvDrawCachedBitmap(
        GpCachedBitmap *inputCachedBitmap,
        INT x,
        INT y
    );

    GpStatus
    DrvDrawImage(
        const GpRect *drawBounds,
        GpBitmap *intputBitmap,
        INT numPoints,
        const GpPointF *dstPoints,
        const GpRectF *srcRect,
        const GpImageAttributes *imageAttributes,
        DrawImageAbort callback,
        VOID *callbackData,
        DriverDrawImageFlags flags
    );

    GpStatus
    DrvMoveBits(
        const GpRect *drawBounds,
        const GpRect *dstRect,
        const GpPoint *srcPoint
        )
    {
        GpStatus status;

        ASSERTMSG(GetObjectLock()->IsLocked(),
                  ("Graphics object must be locked"));

        ASSERTMSG(Device->DeviceLock.IsLockedByCurrentThread(),
            ("DeviceLock must be held by current thread"));

        FPUStateSaver::AssertMode();

        Surface->Uniqueness = (DWORD)GpObject::GenerateUniqueness();
        status = Driver->MoveBits(Context, Surface, drawBounds, dstRect,
                                  srcPoint);

        return status;
    }

public:
    // Simple inline function to return the selected surface.

    DpBitmap *GetSurface() {
        return Surface;
    }

    // Simple inline function to return the driver.

    DpDriver *GetDriver() {
        return Driver;
    }

protected:

    enum GraphicsType
    {
        GraphicsBitmap   = 1,
        GraphicsScreen   = 2,
        GraphicsMetafile = 3,
    };

    mutable GpLockable Lockable;
    GpRect SurfaceBounds;       // Bounds of surface in device units.
    DpBitmap *Surface;          // Selected surface

    GpBitmap   *GdipBitmap;     // point to GpBitmap if the graphics is created from one

    IMetafileRecord * Metafile; // For recording metafiles

    BOOL Printer;               // Whether this object is a printer
    PGDIPPRINTINIT PrintInit;   // Initialization data for printer types
    HGLOBAL PrinterEMF;
    GpMetafile *PrinterMetafile;
    GpGraphics *PrinterGraphics;

    BOOL DownLevel;             // Whether or not to do down-level metafile
    GraphicsType Type;          // Type of GpGraphics created

    BOOL CreatedDevice;         // Whether 'Device' was created at GpGraphics
                                //    construction time, and so needs to be
                                //    freed in the GpGraphics destructor
    GpDevice *Device;           // Associated device
    DpDriver *Driver;           // Associate driver interface
    DpContext *Context;         // Contains all the driver-viewable state:
                                //   Transforms, clipping, alpha/antialias/etc.
                                //   modes
    DpContext BottomContext;    // Always the bottom of the Context Stack
    DpRegion WindowClip;        // The clip region of the window

    TextRenderingHint TextRenderingHintInternal; // cached internal value of TextRenderingHint
                                                 // valid during one call to Draw(Driver)String
};

#endif // !_GRAPHICS_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\gpbitmap.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Abstract:
*
*   Implemenation of GpBitmap class
*
* Revision History:
*
*   06/28/1998 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

#include "..\imaging\api\comutils.hpp"
#include "..\imaging\api\decodedimg.hpp"
#include "..\imaging\api\icmdll.hpp"
#include "..\imaging\api\memstream.hpp"
#include "..\imaging\api\imgutils.hpp"
#include "..\imaging\api\imgfactory.hpp"
#include "..\render\scanoperationinternal.hpp"
#include "..\render\FormatConverter.hpp"
#include "CopyOnWriteBitmap.hpp"

#define GDIP_TRANSPARENT_COLOR_KEY  0x000D0B0C
static const CLSID InternalJpegClsID =
{
    0x557cf401,
    0x1a04,
    0x11d3,
    {0x9a, 0x73, 0x00, 0x00, 0xf8, 0x1e, 0xf3, 0x2e}
};

//!!! TO DO: need to go through all the routines to
// map image error codes to gdi+ error codes

GpStatus
MapHRESULTToGpStatus(HRESULT hr)
{
    GpStatus status;

    switch(hr)
    {
    case S_OK:
        status = Ok;
        break;
    case E_INVALIDARG:
        status = InvalidParameter;
        break;
    case E_OUTOFMEMORY:
        status = OutOfMemory;
        break;
    case IMGERR_OBJECTBUSY:
        status = ObjectBusy;
        break;
    case E_NOTIMPL:
        status = NotImplemented;
        break;
    case IMGERR_ABORT:
        status = Aborted;
        break;
    case IMGERR_CODECNOTFOUND:
    case IMGERR_FAILLOADCODEC:
        status = FileNotFound;
        break;
    case IMGERR_PROPERTYNOTFOUND:
        status = PropertyNotFound;
        break;
    case IMGERR_PROPERTYNOTSUPPORTED:
        status = PropertyNotSupported;
        break;
    default:
        status = Win32Error;
   }
   return status;
}

/**************************************************************************\
*
* Function Description:
*   ICM conversion from the embedded profile - if any - to SRGB
*
* Arguments:
*   dstBitmap - pass in pointer to destination buffer or NULL to do conversion
*   in place.
*
* Return Value:
*
*   The image is cloned and the operations performed on the clone.
*   The result is returned in dst.
*   NULL indicates that the operation didn't happen
*
\**************************************************************************/

GpStatus CopyOnWriteBitmap::ICMFrontEnd(
    CopyOnWriteBitmap **dstBitmap,
    DrawImageAbort callback,
    VOID *callbackData,
    GpRect *rect
)
{

    // check to see if we're doing a conversion.
    if(!ICMConvert || Globals::NoICM)
    {
        return Ok;
    }

    GpStatus status = Ok;
    UINT size;
    CopyOnWriteBitmap *dst = NULL;

    status = GetPropertyItemSize(TAG_ICC_PROFILE, &size);

    if(status==Ok)
    {
        PropertyItem *pi = (PropertyItem *)GpMalloc(size);

        if(pi)
        {
            status = GetPropertyItem(TAG_ICC_PROFILE, size, pi);
        }
        else
        {
            status = OutOfMemory;
        }

        if(status == Ok)
        {
            HRESULT hr = LoadICMDll();
            if(SUCCEEDED(hr))
            {
                // Get Embedded profile
                PROFILE p;
                p.dwType = PROFILE_MEMBUFFER;
                p.pProfileData = pi->value;
                p.cbDataSize = size-sizeof(PropertyItem);

                // destination profile for our internal space.
                char profilename[40] = "sRGB Color Space Profile.icm";
                PROFILE srgb;
                srgb.dwType = PROFILE_FILENAME;
                srgb.pProfileData = profilename;
                srgb.cbDataSize = 40;

                HPROFILE profiles[2];
                profiles[0] = (*pfnOpenColorProfile)(&p,
                                                     PROFILE_READ,
                                                     FILE_SHARE_READ,
                                                     OPEN_EXISTING);
                profiles[1] = (*pfnOpenColorProfile)(&srgb,
                                                     PROFILE_READ,
                                                     FILE_SHARE_READ,
                                                     OPEN_EXISTING);

                if ( profiles[0] && profiles[1] )
                {
                    HTRANSFORM trans;
                    DWORD intent[2] = {INTENT_PERCEPTUAL, INTENT_PERCEPTUAL};
                    trans = (*pfnCreateMultiProfileTransform)(
                        profiles, 2, intent, 2,
                        BEST_MODE | USE_RELATIVE_COLORIMETRIC,
                        0
                    );
                    if(trans)
                    {
                        // Translate bitmap bits at bit depth.
                        PixelFormatID pixFmt = PixelFormat32bppARGB;
                        if (IsIndexedPixelFormat(PixelFormatInMem))
                        {
                            pixFmt = PixelFormatInMem;
                        }

                        if(dstBitmap)
                        {
                            *dstBitmap = Clone(rect, pixFmt);
                            dst = *dstBitmap;
                        }
                        else
                        {
                            dst = this;
                            if (pixFmt != PixelFormatInMem)
                            {
                                ConvertFormat(pixFmt, callback, callbackData);
                            }
                        }

                        // Up to this point, PixelFormatInMem is preserved if
                        // indexed palette is available, otherwise we set to
                        // PIXFMT_32BPP_ARGB.

                        if(dst)
                        {
                            ASSERT(dst->Bmp != NULL);
                            ASSERT(dst->State == CopyOnWriteBitmap::MemBitmap);

                            BOOL result = FALSE;

                            if (IsIndexedPixelFormat(pixFmt))
                            {
                                // Translate the palette on bitmap
                                const ColorPalette *srcPalette;

                                srcPalette = dst->Bmp->GetCurrentPalette();

                                if (srcPalette != NULL)
                                {
                                    ColorPalette *dstPalette;
                                    dstPalette = CloneColorPalette(srcPalette, FALSE);

                                    if (dstPalette != NULL)
                                    {
                                        // Do ICM
                                        result = (*pfnTranslateBitmapBits)(
                                                trans,
                                                (PVOID)&(srcPalette->Entries[0]),
                                                BM_xRGBQUADS,
                                                1,
                                                srcPalette->Count,
                                                sizeof(ARGB),
                                                (PVOID)&(dstPalette->Entries[0]),
                                                BM_xRGBQUADS,
                                                sizeof(ARGB),
                                                NULL,
                                                NULL
                                            );

                                        if (result)
                                        {
                                            // Set transformed palette into
                                            // the destination MemoryBitmap

                                            hr = dst->Bmp->SetPalette(dstPalette);
                                            if (FAILED(hr))
                                            {
                                                result = FALSE;
                                            }
                                        }
                                        else
                                        {
                                            DWORD err = GetLastError();
                                            status = Win32Error;
                                            WARNING(("TranslateBitmapBits failed %d", err));
                                        }
                                        

                                        GpFree(dstPalette);
                                    }
                                }
                            }// Indexed format conversion
                            else
                            {
                                // Make a new Bmp structure.
                                GpMemoryBitmap *icmBmp = new GpMemoryBitmap();
                                
                                if(icmBmp)
                                {
                                    icmBmp->InitNewBitmap(
                                        dst->Bmp->Width,
                                        dst->Bmp->Height,
                                        pixFmt
                                    );
    
                                    // Do ICM
    
                                    BMFORMAT ulSrcColorMode = BM_xRGBQUADS;
                                    BMFORMAT ulDstColorMode = BM_xRGBQUADS;
    
                                    if ( dst->SrcImageInfo.Flags
                                        & IMGFLAG_COLORSPACE_CMYK )
                                    {
                                        // Source image is in CMYK color space
    
                                        ulSrcColorMode = BM_CMYKQUADS;
                                    }
    
                                    result = (*pfnTranslateBitmapBits)(
                                            trans,
                                            dst->Bmp->Scan0,
                                            ulSrcColorMode,
                                            dst->Bmp->Width,
                                            dst->Bmp->Height,
                                            dst->Bmp->Stride,
    
                                            icmBmp->Scan0,
                                            ulDstColorMode,
                                            icmBmp->Stride,
                                            NULL,
                                            NULL
                                        );
    
                                    if (result)
                                    {
                                        // switch in the corrected bmp.
    
                                        GpMemoryBitmap *tmp = dst->Bmp;
                                        dst->Bmp = icmBmp;
                                        icmBmp = tmp;
                                    } 
                                    else
                                    {
                                        DWORD err = GetLastError();
                                        status = Win32Error;
                                        WARNING(("TranslateBitmapBits failed %d", err));
                                    }
    
    
                                    // delete the appropriate one - based on success or failure
                                    // of the TranslateBitmapBits
                                    
                                    delete icmBmp;
                                    
                                    // Convert from RGB to 32 ARGB
                                    // Note: ICC doesn't support alpha. If we fall into
                                    // this piece of code, we are sure we are in
                                    // 32BPP_RGB mode. So we can just set the image as
                                    // opaque.
                                    
                                    ASSERT(dst->PixelFormatInMem==PixelFormat32bppARGB);
        
                                    BYTE* pBits = (BYTE*)dst->Bmp->Scan0;
        
                                    for ( int i = 0; i < (int)dst->Bmp->Height; ++i )
                                    {
                                        BYTE* pTemp = pBits;
                                        for ( int j = 0; j < (int)dst->Bmp->Width; ++j )
                                        {
                                            pTemp[3] = 0xff;
                                            pTemp += 4;
                                        }
        
                                        pBits += dst->Bmp->Stride;
                                    }
    
                                    // If we have hacked the color format in
                                    // LoadIntomemory() to avoid the color format
                                    // conversion, then we need to restore it back
                                    // here
    
                                    if ( HasChangedRequiredPixelFormat == TRUE )
                                    {
                                        PixelFormatInMem = PixelFormat32bppPARGB;
                                        HasChangedRequiredPixelFormat = FALSE;
                                    }
                                }
                                else  //if icmBmp
                                {
                                    status = OutOfMemory;
                                }
                            }
                        }
                        else
                        {
                            status = Win32Error;
                            WARNING(("Failed to clone bitmap\n"));
                        }

                        (*pfnDeleteColorTransform)(trans);
                    }// if ( trans )
                    else
                    {
                        status = Win32Error;
                        WARNING(("CreateMultiProfileTransform failed"));
                    }
                }// if ( profiles[0] && profiles[1] )
                else
                {
                    status = Win32Error;
                    WARNING(("OpenColorProfile failed"));
                }

                if(profiles[0])
                {
                    (*pfnCloseColorProfile)(profiles[0]);
                }

                if(profiles[1])
                {
                    (*pfnCloseColorProfile)(profiles[1]);
                }
            }
            else
            {
                status = Win32Error;
                WARNING(("Failed to load ICM dll\n"));
            }
        }
        else
        {
            WARNING(("Failed to get the ICC property"));
        }
        GpFree(pi);
    }
    else
    {
        // Try do gamma and chromaticity.
        PropertyItem *piGamma= NULL;
        status = GetPropertyItemSize(TAG_GAMMA, &size);
        if(status==Ok)
        {
            piGamma = (PropertyItem *)GpMalloc(size);
            status = GetPropertyItem(TAG_GAMMA, size, piGamma);
        }
        else
        {
            status = Ok;
        }

        PropertyItem *piWhitePoint= NULL;
        PropertyItem *piRGBPoint= NULL;
        status = GetPropertyItemSize(TAG_WHITE_POINT, &size);
        if(status==Ok)
        {
            piWhitePoint = (PropertyItem *)GpMalloc(size);
            status = GetPropertyItem(TAG_WHITE_POINT, size, piWhitePoint);
        }

        status = GetPropertyItemSize(TAG_PRIMAY_CHROMATICS, &size);
        if(status==Ok)
        {
            piRGBPoint = (PropertyItem *)GpMalloc(size);
            status = GetPropertyItem(TAG_PRIMAY_CHROMATICS, size,
                                     piRGBPoint);
        }
        else
        {
            status = Ok;
        }

        GpImageAttributes imageAttributes;

        if(piGamma)
        {
            REAL gamma;
            ASSERT((piGamma->type == TAG_TYPE_RATIONAL));

            // get 1.0/gamma from the (source) gamma chunk
            // formula is dstgamma/srcgamma
            // we have to invert the gamma to account to how it is stored
            // in the file format
            gamma = (REAL)*((long *)piGamma->value)/ *((long *)piGamma->value+1);
            gamma = gamma * 0.4545f;   // our destination gamma is 1/2.2

            // don't do any work if gamma is 1.0
            // !!! need to work out what the best value for the tolerance is.
            if(REALABS(gamma-1.0f) >= REAL_EPSILON)
            {
                imageAttributes.SetGamma(
                    ColorAdjustTypeBitmap, TRUE, gamma
                );
            }

        }
        using namespace VectorMath;

        if(piWhitePoint && piRGBPoint)
        {
            Matrix R;

            // Please refer to gdiplus\Specs\pngchrm.xls for all the formula
            // and calculations below

            LONG* llTemp = (long*)(piWhitePoint->value);

            REAL Rx, Ry, Gx, Gy, Bx, By, Wx, Wy;

            Wx = (REAL)llTemp[0] / llTemp[1];
            Wy = (REAL)llTemp[2] / llTemp[3];

            llTemp = (long*)(piRGBPoint->value);

            Rx = (REAL)llTemp[0] / llTemp[1];
            Ry = (REAL)llTemp[2] / llTemp[3];
            Gx = (REAL)llTemp[4] / llTemp[5];
            Gy = (REAL)llTemp[6] / llTemp[7];
            Bx = (REAL)llTemp[8] / llTemp[9];
            By = (REAL)llTemp[10] / llTemp[11];

            // White point
            Vector Wp(Wx, Wy, 1.0f-(Wx+Wy));

            // Within some obscurely small amount
            // !!! We need to work out what the actual tolerance should be.
            BOOL accelerate =
                (REALABS(Wx-0.3127f) < REAL_EPSILON) &&
                (REALABS(Wy-0.3290f) < REAL_EPSILON);

            Wp = Wp * (1.0f/Wy);

            // Transpose of the input matrix.
            Matrix I(
                Rx,           Gx,           Bx,
                Ry,           Gy,           By,
                1.0f-(Rx+Ry), 1.0f-(Gx+Gy), 1.0f-(Bx+By)
            );

            Matrix II = I.Inverse();

            Vector IIW = II*Wp;
            Matrix DIIW(IIW);   // Diagonalize vector IIW
            Matrix Q = I*DIIW;
            Matrix sRGB(
                3.2406f, -1.5372f, -0.4986f,
               -0.9689f,  1.8758f,  0.0415f,
                0.0557f, -0.2040f,  1.0570f
            );

            if(accelerate)
            {
                R = sRGB*Q;
            }
            else
            {

                Matrix B(
                    0.40024f, 0.70760f, -0.08081f,
                   -0.22630f, 1.16532f,  0.04570f,
                    0.00000f, 0.00000f,  0.91822f
                );

                Matrix BI(
                    1.859936387f, -1.129381619f,    0.21989741f,
                    0.361191436f, 0.638812463f,-6.3706E-06f,
                    0.000000000f, 0.000000000f, 1.089063623f
                );

                Vector LMS = B * Wp;

                // Get Diag( LMS^(-1) ), cell F50 in the XLS file

                if ( LMS.data[0] != 0 )
                {
                    LMS.data[0] = 1.0f / LMS.data[0];
                }

                if ( LMS.data[1] != 0 )
                {
                    LMS.data[1] = 1.0f / LMS.data[1];
                }

                if ( LMS.data[2] != 0 )
                {
                    LMS.data[2] = 1.0f / LMS.data[2];
                }

                Matrix L(LMS);      // Diagonalize vector LMS

                Matrix T = BI * L * B;
                R = sRGB * T * Q;
            }

            // Make a 5x5 Color matrix for the recolor pipeline.
            ColorMatrix ChM = {
                R.data[0][0], R.data[1][0], R.data[2][0], 0, 0,
                R.data[0][1], R.data[1][1], R.data[2][1], 0, 0,
                R.data[0][2], R.data[1][2], R.data[2][2], 0, 0,
                0,            0,            0,            1, 0,
                0,            0,            0,            0, 1
            };

            imageAttributes.SetColorMatrix(
                ColorAdjustTypeBitmap, TRUE, &ChM, NULL, ColorMatrixFlagsDefault
            );
        }

        // If we initialized the imageAttributes to anything other than
        // no-op then do the recoloring.

        if(piGamma || (piWhitePoint && piRGBPoint))
        {
            // Note under certain conditions, the imageAttributes could still
            // be no-op at this point. For instance if the gamma was really
            // close to 1 and we had no chromaticities.
            // Fortunately the recolor pipeline knows how to optimize the
            // no-op case.

            // Apply the Chromaticities and Gamma if they have been set.
            status = Recolor(
                imageAttributes.recolor,
                dstBitmap, NULL, NULL, rect
            );

            // Recolor() will set Dirty flag on this image. Actually it is not
            // dirty since we just apply the color correction on the image to
            // display it. So we should reverse it back to not dirty.
            // Note: this is a real issue for digital images from some cameras
            // like Fuji. It always have White balance in it. If we don't do
            // the reverse below, we can't do lossless transform on these
            // images.
            // Note: Unfortunately this kind of "dirty flag restore" breaks this
            // scenario: (windows bug #583962)
            // Source image is a 48 BPP PNG with embedded gamma. Without
            // restoring the dirty flag here, if the caller asks for save(), we
            // will save PNG using the bits in memory. If we set it to not dirty
            // the save code path will let the PNG decoder talk to the encoder
            // which will have 48 to 32 and to 48 conversion. This is a known
            // GDI+ issue that this kind of conversion will produce wrong data.
            // In order to avoid the PNG problem, we only restore the dirty flag
            // here if the source is a JPEG image.

            if (SrcImageInfo.RawDataFormat == IMGFMT_JPEG)
            {
                SetDirtyFlag(FALSE);
            }
        }

        GpFree(piGamma);
        GpFree(piWhitePoint);
        GpFree(piRGBPoint);
    }

    return status;
}


/**************************************************************************\
*
* Function Description:
*   Performs recoloring
*
* Arguments:
*
*   recolor contains the recolor object.
*   dstBitmap is the destination bitmap - set to NULL to recolor in place
*
* Return Value:
*
*   The image is cloned and the operations performed on the clone.
*   The result is returned in dst.
*   NULL indicates that the operation didn't happen
*
\**************************************************************************/
GpStatus
CopyOnWriteBitmap::Recolor(
    GpRecolor *recolor,
    CopyOnWriteBitmap **dstBitmap,
    DrawImageAbort callback,
    VOID *callbackData,
    GpRect *rect
    )
{
    GpStatus status = Ok;
    CopyOnWriteBitmap *dst = NULL;

    // If recolor exists, do color adjustment in a temporary bitmap.

    if (recolor)
    {
        PixelFormatID pixfmt;

        if (State >= MemBitmap)
        {
            // Bitmap has been decoded already

            pixfmt = PixelFormatInMem;
        }
        else
        {
            // Bitmap hasn't been decoded yet.  Let's make sure we
            // decode it in a good format to avoid an expensive format
            // conversion step later.

            pixfmt = SrcImageInfo.PixelFormat;
        }

        // If indexed, color adjust natively; otherwise,
        // convert to 32bpp ARGB and then do color adjust.

        if (!IsIndexedPixelFormat(pixfmt))
        {
            pixfmt = PIXFMT_32BPP_ARGB;
        }

        if (dstBitmap)
        {
            *dstBitmap = Clone(rect, pixfmt);
            dst = *dstBitmap;
        }
        else
        {
            dst = this;
            ConvertFormat(pixfmt, callback, callbackData);
        }

        if (dst)
        {
            if (callback && ((*callback)(callbackData)))
            {
                status = Aborted;
            }

            if (status == Ok)
            {
                status = dst->ColorAdjust(recolor, pixfmt,
                                          callback, callbackData);
            }
        }
        else
        {
            status = OutOfMemory;
        }
    }
    return status;
}// Recolor()

/**************************************************************************\
*
* Function Description:
*
*   ICM corrects from an embedded profile - if any - to SRGB and then
*   performs Recoloring.
*
* Arguments:
*
*   ImageAttributes contains the recolor object and the ICM on/off flag.
*
* Return Value:
*
*   The image is cloned and the operations performed on the clone.
*   The result is returned in dst.
*   NULL indicates that the operation didn't happen
*
\**************************************************************************/

/*GpStatus CopyOnWriteBitmap::RecolorAndICM(
    GpImageAttributes *imageAttributes,
    CopyOnWriteBitmap **dstBitmap,
    DrawImageAbort callback,
    VOID *callbackData,
    GpRect *rect
)
{
    GpStatus status = Ok;

    if(imageAttributes)
    {
        *dstBitmap = NULL;

        if(imageAttributes->DeviceImageAttributes.ICMMode)
        {

            status = ICMFrontEnd(
                dstBitmap, callback, callbackData, rect
            );

            if( (status == Ok) && (imageAttributes->recolor != NULL) )
            {
                status = (*dstBitmap)->ColorAdjust(
                    imageAttributes->recolor,
                    callback, callbackData
                );
            }
        }

        if(*dstBitmap == NULL)
        {
            status = Recolor(
                imageAttributes->recolor,
                dstBitmap, callback, callbackData, rect
            );
        }
    }
    return status;
}
*/




/**************************************************************************\
*
* Function Description:
*
*   Load an image from a file
*
* Arguments:
*
*   filename - Specifies the name of the image file
*
* Return Value:
*
*   Pointer to the newly loaded image object
*   NULL if there is an error
*
\**************************************************************************/

GpImage*
GpImage::LoadImage(
    const WCHAR* filename
    )
{
    // Try to create a metafile.
    // If we do, and the metafile is valid then return it
    // if the metafile isn't valid then create a bitmap
    GpMetafile* metafile = new GpMetafile(filename);
    if (metafile != NULL && !metafile->IsValid())
    {
        if (metafile->IsCorrupted())
        {
            metafile->Dispose();
            return NULL;
        }

        // Dispose of the bad metafile and try a Bitmap
        metafile->Dispose();

        GpImage* bitmap = new GpBitmap(filename);
        if (bitmap != NULL && !bitmap->IsValid())
        {
            bitmap->Dispose();
            return NULL;
        }
        else
        {
            return bitmap;
        }
    }
    else
    {
        return metafile;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Load an image from an input data stream
*
* Arguments:
*
*   stream - Specifies the input data stream
*
* Return Value:
*
*   Pointer to the newly loaded image object
*   NULL if there is an error
*
\**************************************************************************/

GpImage*
GpImage::LoadImage(
    IStream* stream
    )
{
    // See if the stream is a metafile
    GpMetafile* metafile = new GpMetafile(stream);
    if (metafile != NULL)
    {
        if (metafile->IsValid())
            return metafile;
        else
        {
            BOOL isCorrupted = metafile->IsCorrupted();
            metafile->Dispose();
            if (isCorrupted)
            {
                return NULL;
            }
        }
    }

    // it's not a valid metafile -- it must be a bitmap
    GpBitmap* bitmap = new GpBitmap(stream);

    return bitmap;
}


/**************************************************************************\
*
* Function Description:
*
*   Construct a bitmap image object from a file
*
* Arguments:
*
*   filename - Specifies the name of the bitmap image file
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

CopyOnWriteBitmap::CopyOnWriteBitmap(
    const WCHAR* filename
    )
{
    InitDefaults();
    Filename = UnicodeStringDuplicate(filename);

    if ( Filename != NULL )
    {
        State = ImageRef;
    }

    if ( DereferenceStream() == Ok )
    {
        ASSERT(Img != NULL);

        // Get source image info

        if ( Img->GetImageInfo(&SrcImageInfo) == S_OK )
        {
            return;
        }

        // If we can't do a GetImageInfo(), there must be something wrong
        // with this image. So we should release the DecodedImage object
        // and set the State to Invalid

        WARNING(("CopyOnWriteBitmap::CopyOnWriteBitmap(filename)---GetImageInfo() failed"));
        Img->Release();
        Img = NULL;
    }

    GpFree(Filename);
    Filename = NULL;

    State = Invalid;
}

/**************************************************************************\
*
* Function Description:
*
*   Construct a bitmap image object from a stream
*
* Arguments:
*
*   stream - Specifies the input data stream
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

CopyOnWriteBitmap::CopyOnWriteBitmap(
    IStream* stream
    )
{
    InitDefaults();

    Stream = stream;
    Stream->AddRef();
    State = ExtStream;

    if ( DereferenceStream() == Ok )
    {
        ASSERT(Img != NULL);

        // Get source image info

        if ( Img->GetImageInfo(&SrcImageInfo) == S_OK )
        {
            return;
        }

        // If we can't do a GetImageInfo(), there must be something wrong
        // with this image. So we should release the DecodedImage object
        // and set the State to Invalid

        WARNING(("CopyOnWriteBitmap::CopyOnWriteBitmap(stream)---GetImageInfo() failed"));

        Img->Release();
        Img = NULL;
    }

    Stream->Release();
    Stream = NULL;
    State = Invalid;
}

/**************************************************************************\
*
* Function Description:
*
*   Macro style function to save some common code in some constructors. The
*   main purpose of this method is to cache the image info structure
*
* Arguments:
*
*   hr - Specifies the return code from previous function call
*
* Return Value:
*
*   NONE
*
* Note:
*   Not an elegant method. Just for reducing code size
*
\**************************************************************************/

inline VOID
CopyOnWriteBitmap::CacheImageInfo(
    HRESULT hr
    )
{
    if ( SUCCEEDED(hr) )
    {
        // Fill image info structure

        if ( Bmp->GetImageInfo(&SrcImageInfo) == S_OK )
        {
            State = MemBitmap;
            PixelFormatInMem = SrcImageInfo.PixelFormat;

            return;
        }

        // There must be some problems if the basic GetImageInfo() failed.
        // So we let it fall through to clean up even though the previous
        // function succeed
        // Notice: we haven't change the State yet. It is still at Invaliad
    }

    WARNING(("CopyOnWriteBitmap::CopyOnWriteBitmap()----failed"));
    delete Bmp;
    Bmp = NULL;

    return;
}// CacheImageInfo()

/**************************************************************************\
*
* Function Description:
*
*   INTEROP
*
*   Derive a bitmap image from the given direct draw surface
*
* Arguments:
*
*   surface - Direct draw surface
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

CopyOnWriteBitmap::CopyOnWriteBitmap(
    IDirectDrawSurface7 * surface
    )
{
    InitDefaults();
    Bmp = new GpMemoryBitmap();

    if (!Bmp)
    {
        WARNING(("CopyOnWriteBitmap::CopyOnWriteBitmap(IDirectDrawSurface7)----Out of memory"));
        return;
    }

    HRESULT hr = Bmp->InitDirectDrawBitmap(surface);

    CacheImageInfo(hr);
}

/**************************************************************************\
*
* Function Description:
*
*   Create a bitmap image with the specified dimension and pixel format
*
* Arguments:
*
*   width, height - Desired bitmap image dimension
*   format - Desired pixel format
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

CopyOnWriteBitmap::CopyOnWriteBitmap(
    INT width,
    INT height,
    PixelFormatID format
    )
{
    InitDefaults();
    Bmp = new GpMemoryBitmap();

    if (!Bmp)
    {
        WARNING(("CopyOnWriteBitmap::GpBimap(w, h, p)---Out of memory"));
        return;
    }

    // Initialize the bitmap, clearing it (to opaque black).

    HRESULT hr = Bmp->InitNewBitmap(width, height, format, TRUE);

    CacheImageInfo(hr);
}

CopyOnWriteBitmap::CopyOnWriteBitmap(
    INT width,
    INT height,
    PixelFormatID format,
    GpGraphics * graphics
    )
{
    InitDefaults();
    Bmp = new GpMemoryBitmap();

    if (!Bmp)
    {
        WARNING(("CopyOnWriteBitmap::CopyOnWriteBitmap(w, h, f, g)----Out of memory"));
        return;
    }

    // Initialize the bitmap, clearing it (to opaque black).

    HRESULT hr = Bmp->InitNewBitmap(width, height, format, TRUE);

    if ( SUCCEEDED(hr) )
    {
        if ( Bmp->GetImageInfo(&SrcImageInfo) == S_OK )
        {
            REAL    dpiX = graphics->GetDpiX();
            REAL    dpiY = graphics->GetDpiY();

            // Note: SrcImageInfo will be updated for dpi in SetResolution()

            if ( this->SetResolution(dpiX, dpiY) == Ok )
            {
                this->Display = graphics->IsDisplay();
            }

            State = MemBitmap;
            PixelFormatInMem = SrcImageInfo.PixelFormat;

            return;
        }

        // There must be some problems if the basic GetImageInfo() failed. So we
        // let it fall through to clean up even though InitNewBitmap() succeed
        // Notice: we haven't change the State yet. It is still at Invaliad
    }

    WARNING(("CopyOnWriteBitmap::CopyOnWriteBitmap(w, h, f, g)---InitNewBitmap() failed"));
    delete Bmp;
    Bmp = NULL;

    return;
}

/**************************************************************************\
*
* Function Description:
*
*   Create a bitmap image with the specified dimension and pixel format
*
* Arguments:
*
*   width, height - Desired bitmap image dimension
*   format - Desired pixel format
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

CopyOnWriteBitmap::CopyOnWriteBitmap(
    INT width,
    INT height,
    INT stride,     // negative for bottom-up bitmaps
    PixelFormatID format,
    BYTE *  scan0
    )
{
    this->InitDefaults();
    Bmp = new GpMemoryBitmap();

    if (Bmp != NULL)
    {
        BitmapData      bmData;

        bmData.Width       = width;
        bmData.Height      = height;
        bmData.Stride      = stride;
        bmData.PixelFormat = format;
        bmData.Scan0       = scan0;
        bmData.Reserved    = NULL;

        HRESULT hr = Bmp->InitMemoryBitmap(&bmData);

        CacheImageInfo(hr);
    }
    else
    {
        WARNING(("CopyOnWriteBitmap::CopyOnWriteBitmap(w, h, s, f, scan)----Out of memory"));
    }
    return;
}

/**************************************************************************\
*
* Function Description:
*
*   Create an in-memory bitmap image
*
* Arguments:
*
*   membmp - [IN]Memory bitmap current object is based on
*
* Return Value:
*
*   NONE
*
* Note:
*   This is a private constructor
*
*   [minliu] It would be safer if this constructor did a Bmp->AddRef() and
*   the caller was required to do a Bmp->Release() during its own cleanup.
*   However, since we don't currently call Bmp->AddRef(), the caller MUST
*   be very careful not to delete/release the GpMemoryBitmap passed into
*   this contructor.  Fortunately, this this constructor is only
*   used in Clone() and GetThumbnail() and in each case the caller is
*   properly managing the objects.
*
*   New code which uses this contructor will similarly have to manage
*   the membmp passed in properly.
*
\**************************************************************************/
inline
CopyOnWriteBitmap::CopyOnWriteBitmap(
    GpMemoryBitmap* membmp
    )
{
    ASSERT(membmp != NULL);

    InitDefaults();
    Bmp = membmp;   // [minliu] Dangerous assignment, see header comments above

    if ( Bmp->GetImageInfo(&SrcImageInfo) == S_OK )
    {
        PixelFormatInMem = SrcImageInfo.PixelFormat;

        State = MemBitmap;
    }
    else
    {
        Bmp = NULL;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   INTEROP
*
*   Decode an RLE_8 bitmap into an 8bpp allocated bitmap.  This only works
*   for bitmaps with positive stride because the RLE stream doesn't necessarily
*   respect end of line tags, and we would otherwise need to keep track of it.
*   Caller must fix up in such cases.
*
* Arguments:
*
*   gdiBitmapInfo - Points to a BITMAPINFO, describing bitmap format
*   gdiBitmapData - Points to the bits used to initialize image
*   bitmapData----- Points to the BitmapData we return to the caller
*
* Comments:
*
*   10/13/2000 ericvan
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID *
DecodeCompressedRLEBitmap(
    BITMAPINFO *    gdiBitmapInfo,
    VOID *          gdiBitmapData,
    BitmapData *    bitmapData
)
{
    ASSERT(gdiBitmapInfo->bmiHeader.biCompression == BI_RLE8);
    ASSERT(gdiBitmapInfo->bmiHeader.biSizeImage>0);
    ASSERT(gdiBitmapData != NULL);

    BYTE* outputBitmap;
    INT stride = bitmapData->Stride;
    if (stride<0)
    {
        stride = -stride;
    }

    outputBitmap = (BYTE*)GpMalloc(stride*gdiBitmapInfo->bmiHeader.biHeight);

    if (outputBitmap != NULL)
    {
        BYTE * srcPtr = (BYTE*)gdiBitmapData;
        BYTE * endStrPtr = srcPtr + gdiBitmapInfo->bmiHeader.biSizeImage;
        BYTE * dstPtr = outputBitmap;
        BYTE * dstRasterPtr = outputBitmap;
        BYTE * endDstPtr = outputBitmap + stride*gdiBitmapInfo->bmiHeader.biHeight;

        while (srcPtr < endStrPtr)
        {
            INT numPixels = *srcPtr++;

            if (numPixels == 0)
            {
                BYTE encode = *srcPtr++;
                switch (encode)
                {
                case 0: // End of line.
                    dstRasterPtr += stride;
                    dstPtr = dstRasterPtr;

                    ASSERT(dstRasterPtr <= endDstPtr);
                    if (dstRasterPtr > endDstPtr)
                    {
                        GpFree(outputBitmap);
                        return NULL;
                    }
                    break;

                case 1: // End of bitmap.
                    goto FinishedDecode;

                case 2: // Delta.  The 2 bytes following the escape contain
                        // unsigned values indicating the horizontal and vertical
                        // offsets of the next pixel from the current position.
                    {
                        BYTE horzOff = *srcPtr++;
                        BYTE vertOff = *srcPtr++;

                        dstPtr = dstPtr + horzOff + vertOff*stride;
                        dstRasterPtr += vertOff*stride;

                        ASSERT(dstRasterPtr <= endDstPtr);
                        if (dstRasterPtr > endDstPtr)
                        {
                            GpFree(outputBitmap);
                            return NULL;
                        }

                        break;
                    }

                default:
                    numPixels = (INT)encode;

                    while (numPixels--)
                    {
                        *dstPtr++ = *srcPtr++;
                    }

                    // Force word alignment if not WORD aligned
                    if (((ULONG_PTR)srcPtr) % 2 == 1) srcPtr++;
                }
            }
            else
            {
                BYTE outPixel = *srcPtr++;

                while (numPixels--)
                {
                    *dstPtr++ = outPixel;
                }
            }
        }
    }

FinishedDecode:

    if (outputBitmap && bitmapData->Stride<0)
    {
        BYTE* flippedBitmap = (BYTE *)GpMalloc(stride*gdiBitmapInfo->bmiHeader.biHeight);

        if (flippedBitmap != NULL)
        {
            BYTE * srcPtr = outputBitmap + stride*(bitmapData->Height-1);
            BYTE * dstPtr = flippedBitmap;

            for (UINT cntY = 0; cntY<bitmapData->Height; cntY++)
            {
                GpMemcpy(dstPtr, srcPtr, stride);
                srcPtr -= stride;
                dstPtr += stride;
            }

            GpFree(outputBitmap);
            outputBitmap = flippedBitmap;
            bitmapData->Stride = stride;
        }
    }

    return outputBitmap;
}

/**************************************************************************\
*
* Function Description:
*
*   INTEROP
*
*   Create a bitmap image from a GDI-style BITMAPINFO and pointer to
*   the bits. Also, fill the ColorPalette info
*
* Arguments:
*
*   gdiBitmapInfo - Points to a BITMAPINFO, describing bitmap format
*   gdiBitmapData - Points to the bits used to initialize image
*   bitmapData----- Points to the BitmapData we return to the caller
*   palette-------- Points to a ColorPalette which will be filled in this method
*
* Comments:
*
*   Does not handle compressed formats.  Not identified as a customer need,
*   but could add for completeness...
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

BOOL
ValidateBitmapInfo(
    BITMAPINFO* gdiBitmapInfo,
    VOID* gdiBitmapData,
    BitmapData* bitmapData,
    ColorPalette* palette
    )
{
    BOOL status = FALSE;

    ASSERT(gdiBitmapInfo != NULL);
    ASSERT(gdiBitmapData != NULL);
    ASSERT(bitmapData != NULL);
    ASSERT(palette != NULL);

    // Only understand BI_RGB and BI_BITFIELDS.

    //!!!TODO: could handle BI_JPEG and BI_PNG by creating a GpMemoryStream
    //!!!      and passing to Bitmap::Bitmap(IStream*)

    //!!!TODO: could handle BI_RLEx by creating a DIB to render into and
    //!!!      grabbing the decompressed bits

    if ((gdiBitmapInfo->bmiHeader.biCompression != BI_RGB) &&
        (gdiBitmapInfo->bmiHeader.biCompression != BI_BITFIELDS) &&
        (gdiBitmapInfo->bmiHeader.biCompression != BI_RLE8))
    {
        return status;
    }

    // Scanlines are aligned to 4 byte boundaries.

    INT colorBits = gdiBitmapInfo->bmiHeader.biPlanes *
                    gdiBitmapInfo->bmiHeader.biBitCount;

    INT stride = (((gdiBitmapInfo->bmiHeader.biWidth * colorBits) + 31)
                  & ~31) / 8;

    // Determine GDI+ Pixelformat.  Note that GDI bitmaps do not have alpha.

    PixelFormatID format = PIXFMT_UNDEFINED;

    switch (colorBits)
    {
    case 1:

        format = PIXFMT_1BPP_INDEXED;
        break;

    case 4:

        format = PIXFMT_4BPP_INDEXED;
        break;

    case 8:

        format = PIXFMT_8BPP_INDEXED;
        break;

    case 16:

        if (gdiBitmapInfo->bmiHeader.biCompression == BI_RGB)
            format = PIXFMT_16BPP_RGB555;
        else
        {
            ASSERT(gdiBitmapInfo->bmiHeader.biCompression == BI_BITFIELDS);

            ULONG* colorMasks = reinterpret_cast<ULONG*>
                                (&gdiBitmapInfo->bmiColors[0]);

            if ((colorMasks[0] == 0x00007c00) &&        // red
                (colorMasks[1] == 0x000003e0) &&        // green
                (colorMasks[2] == 0x0000001f))          // blue
                format = PIXFMT_16BPP_RGB555;
            else if ((colorMasks[0] == 0x0000F800) &&   // red
                     (colorMasks[1] == 0x000007e0) &&   // green
                     (colorMasks[2] == 0x0000001f))     // blue
                format = PIXFMT_16BPP_RGB565;

            //!!!TODO: Win9x does not support any other combination for
            //!!!      16bpp BI_BITFIELDS.  WinNT does and we could support
            //!!!      via same mechanism as for BI_RLEx, but is it worth it?
        }
        break;

    case 24:

        format = PIXFMT_24BPP_RGB;
        break;

    case 32:

        if (gdiBitmapInfo->bmiHeader.biCompression == BI_RGB)
            format = PIXFMT_32BPP_RGB;
        else
        {
            ASSERT(gdiBitmapInfo->bmiHeader.biCompression == BI_BITFIELDS);

            ULONG* colorMasks = reinterpret_cast<ULONG*>
                                (&gdiBitmapInfo->bmiColors[0]);

            if ((colorMasks[0] == 0x00ff0000) &&        // red
                (colorMasks[1] == 0x0000ff00) &&        // green
                (colorMasks[2] == 0x000000ff))          // blue
                format = PIXFMT_32BPP_RGB;
            else
                format = PIXFMT_UNDEFINED;

            //!!!TODO: Win9x does not support any other combination for
            //!!!      32bpp BI_BITFIELDS.  WinNT does and we could support
            //!!!      via same mechanism as for BI_RLEx, but is it worth it?
        }
        break;

    default:

        format = PIXFMT_UNDEFINED;
        break;
    }

    if (format == PIXFMT_UNDEFINED)
        return status;

    // Deal with color table.

    switch(format)
    {
    case PIXFMT_1BPP_INDEXED:
    case PIXFMT_4BPP_INDEXED:
    case PIXFMT_8BPP_INDEXED:

        palette->Count = 1 << colorBits;

        if ((gdiBitmapInfo->bmiHeader.biClrUsed > 0) &&
            (gdiBitmapInfo->bmiHeader.biClrUsed < palette->Count))
            palette->Count = gdiBitmapInfo->bmiHeader.biClrUsed;

        break;

    default:

        palette->Count = 0;
        break;
    }

    ASSERT(palette->Count <= 256);
    if (palette->Count)
    {
        palette->Flags = 0;

        RGBQUAD* rgb = gdiBitmapInfo->bmiColors;
        ARGB* argb = palette->Entries;
        ARGB* argbEnd = argb + palette->Count;

        for (; argb < argbEnd; argb++, rgb++)
        {
            *argb = Color::MakeARGB(255, rgb->rgbRed, rgb->rgbGreen, rgb->rgbBlue);
        }
    }

    // Compute scan0.  The stride will allow us to determine top-down or
    // bottom-up.

    VOID* scan0;
    INT height;

    if (gdiBitmapInfo->bmiHeader.biHeight > 0)
    {
        // Bottom-up:

        height = gdiBitmapInfo->bmiHeader.biHeight;
        scan0  = static_cast<VOID*>
                 (static_cast<BYTE*>(gdiBitmapData) + (height - 1) * stride);
        stride = -stride;
    }
    else
    {
        // Top-down:

        height = -gdiBitmapInfo->bmiHeader.biHeight;
        scan0  = gdiBitmapData;
    }

    // Setup the BitmapData.

    bitmapData->Width       = gdiBitmapInfo->bmiHeader.biWidth;
    bitmapData->Height      = height;
    bitmapData->Stride      = stride;
    bitmapData->PixelFormat = format;
    bitmapData->Scan0       = scan0;
    bitmapData->Reserved    = NULL;

    status = TRUE;

    return status;
}

CopyOnWriteBitmap::CopyOnWriteBitmap(
    BITMAPINFO* gdiBitmapInfo,
    VOID*       gdiBitmapData,
    BOOL        ownBitmapData
    )
{
    this->InitDefaults();

    if ( ownBitmapData )
    {
        cleanupBitmapData = gdiBitmapData;
    }

    Bmp = new GpMemoryBitmap();

    if ( Bmp != NULL )
    {
        BitmapData bitmapData;
        UINT colorTableSize;
        BYTE paletteBuffer[sizeof(ColorPalette) + 255*sizeof(ARGB)];
        ColorPalette* palette = reinterpret_cast<ColorPalette*>
                                (&paletteBuffer[0]);

        // Validate image info
        // Note: "palette" and "bitmapData" structures will be filled after
        // return from ValidateBitmapInfo()

        if ( ValidateBitmapInfo(gdiBitmapInfo, gdiBitmapData,
                                &bitmapData, palette) )
        {
            HRESULT hr;

            if (gdiBitmapInfo->bmiHeader.biCompression == BI_RLE8)
            {
                VOID* decodedBitmapBits;

                decodedBitmapBits = DecodeCompressedRLEBitmap(gdiBitmapInfo,
                                                              gdiBitmapData,
                                                              &bitmapData);
                if (decodedBitmapBits == NULL)
                {
                    goto CleanupBmp;
                }

                if (ownBitmapData)
                {
                    GpFree(gdiBitmapData);
                }

                cleanupBitmapData = decodedBitmapBits;
                ownBitmapData = TRUE;
                bitmapData.Scan0 = cleanupBitmapData;
            }

            hr = Bmp->InitMemoryBitmap(&bitmapData);

            if ( SUCCEEDED(hr) )
            {
                // Set the current state

                State = MemBitmap;

                // If it is indexed mode, set the palette

                if ( palette->Count )
                {
                    hr = Bmp->SetPalette(palette);
                }

                if ( SUCCEEDED(hr) )
                {
                    // Set proper image flags

                    UINT imageFlags;
                    BITMAPINFOHEADER *bmih = &gdiBitmapInfo->bmiHeader;
                    imageFlags = SinkFlagsTopDown
                               | SinkFlagsFullWidth
                               | ImageFlagsHasRealPixelSize
                               | ImageFlagsColorSpaceRGB;

                    // If both XPelsPerMeter and YPelsPerMeter are greater than
                    // 0, then we claim that the file has real dpi info in the
                    // flags.  Otherwise, claim that the dpi's are fake.

                    if ( (bmih->biXPelsPerMeter > 0)
                       &&(bmih->biYPelsPerMeter > 0) )
                    {
                        imageFlags |= ImageFlagsHasRealDPI;
                    }

                    hr = Bmp->SetImageFlags(imageFlags);

                    if ( SUCCEEDED(hr) )
                    {
                        // Get source image info

                        hr = Bmp->GetImageInfo(&SrcImageInfo);
                        if ( SUCCEEDED(hr) )
                        {
                            PixelFormatInMem = SrcImageInfo.PixelFormat;

                            // Return successfully

                            return;
                        }
                        else
                        {
                            WARNING(("::CopyOnWriteBitmap(b, d)-GetImageInfo() failed"));
                        }
                    }
                }
            }// If ( SUCCEEDED() on InitMemoryBitmap() )

CleanupBmp:
            ;
        }// if ( ValidateBitmapInfo() )

        // If we fall into here, it means something is wrong above if the basic
        // GetImageInfo() or SetImageFlags() failed.
        // So we let it fall through to clean up
        // Notice: we have to reset the State to Invaliad afetr clean up

        WARNING(("CopyOnWriteBitmap::CopyOnWriteBitmap(bmpinfo, data)--InitMemoryBitmap failed"));
        Bmp->Release();
        Bmp = NULL;
        State = Invalid;

        return;
    }// If ( Bmp != NULL )

    WARNING(("Out of memory"));
    return;
}

/**************************************************************************\
*
* Function Description:
*
*   INTEROP
*
*   Create CopyOnWriteBitmap from a GDI HBITMAP.  The HBITMAP must not be selected
*   into an HDC.  The hpal defines the color table if hbm is a 4bpp or 8bpp
*   DDB.
*
* Arguments:
*
*   hbm -- Initialize CopyOnWriteBitmap with contents of this HBITMAP
*   hpal -- Defines color table if hbm is palettized DDB
*   bitmap -- Return created bitmap via this buffer
*
* Return Value:
*
*   Ok if successful
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::CreateFromHBITMAP(
    HBITMAP hbm,
    HPALETTE hpal,
    CopyOnWriteBitmap** bitmap
    )
{
    GpStatus status = Win32Error;

    BYTE bufferBitmapInfo[sizeof(BITMAPINFO) + 255*sizeof(RGBQUAD)];
    BITMAPINFO *gdiBitmapInfo = (BITMAPINFO *) bufferBitmapInfo;

    memset(bufferBitmapInfo, 0, sizeof(bufferBitmapInfo));

    HDC hdc = CreateCompatibleDC(NULL);
    if (hdc)
    {
        // Select palette (ignored if bitmap is not DDB or not palettized):

        HPALETTE hpalOld = (HPALETTE) SelectObject(hdc, hpal);

        // Call GetDIBits to get info about size, etc. of the GDI bitmap:

        gdiBitmapInfo->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);

        if (GetDIBits(hdc, hbm, 0, 0, NULL, gdiBitmapInfo, DIB_RGB_COLORS) &&
            (gdiBitmapInfo->bmiHeader.biSizeImage != 0))
        {
            // Allocate memory for the bitmap bits:

            VOID *gdiBitmapData = GpMalloc(gdiBitmapInfo->bmiHeader.biSizeImage);

            if (gdiBitmapData != NULL)
            {
                // Get the bitmap bits:

                if (GetDIBits(hdc, hbm,
                              0, abs(gdiBitmapInfo->bmiHeader.biHeight),
                              gdiBitmapData, gdiBitmapInfo, DIB_RGB_COLORS))
                {
                    // Create a GDI+ bitmap from the BITMAPINFO and bits.
                    // Let the GDI+ bitmap take ownership of the memory
                    // (i.e., Bitmap::Dispose() will delete the bitmap
                    // bits buffer):

                    *bitmap = new CopyOnWriteBitmap(gdiBitmapInfo, gdiBitmapData, TRUE);

                    if (*bitmap != NULL)
                    {
                        if ((*bitmap)->IsValid())
                            status = Ok;
                        else
                        {
                            (*bitmap)->Dispose();
                            *bitmap = NULL;
                            status = InvalidParameter;
                        }
                    }
                    else
                    {
                        // Bitmap ctor failed, so we still have responsiblity
                        // for cleaning up the bitmap bits buffer:

                        GpFree(gdiBitmapData);
                        status = OutOfMemory;
                    }
                }
                else
                {
                    GpFree(gdiBitmapData);
                }
            }
            else
            {
                status = OutOfMemory;
            }
        }

        SelectObject(hdc, hpalOld);
        DeleteDC(hdc);
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   INTEROP
*
*   Create CopyOnWriteBitmap from a Win32 HICON.
*
* Arguments:
*
*   hicon -- Initialize CopyOnWriteBitmap with contents of this HICON
*   bitmap -- Return created bitmap via this buffer
*
* Return Value:
*
*   Ok if successful
*
\**************************************************************************/

VOID ImportMask32BPP(BitmapData* dst, BitmapData* mask)
{
    ASSERT(dst->PixelFormat == PIXFMT_32BPP_ARGB);
    ASSERT(mask->PixelFormat == PIXFMT_32BPP_RGB);
    ASSERT(dst->Width == mask->Width);
    ASSERT(dst->Height == mask->Height);
    ASSERT(dst->Scan0 != NULL);
    ASSERT(mask->Scan0 != NULL);

    BYTE* dstScan = static_cast<BYTE*>(dst->Scan0);
    BYTE* maskScan = static_cast<BYTE*>(mask->Scan0);

    for (UINT row = 0; row < dst->Height; row++)
    {
        ARGB *dstPixel = static_cast<ARGB*>(static_cast<VOID*>(dstScan));
        ARGB *maskPixel = static_cast<ARGB*>(static_cast<VOID*>(maskScan));

        for (UINT col = 0; col < dst->Width; col++)
        {
            if (*maskPixel)
                *dstPixel = 0;

            dstPixel++;
            maskPixel++;
        }

        dstScan = dstScan + dst->Stride;
        maskScan = maskScan + mask->Stride;
    }
}

GpStatus
CopyOnWriteBitmap::CreateFromHICON(
    HICON hicon,
    CopyOnWriteBitmap** bitmap
    )
{
    GpStatus status = Ok;

    // Get icon bitmaps via Win32:

    ICONINFO iconInfo;

    if (GetIconInfo(hicon, &iconInfo))
    {
        if (iconInfo.fIcon && (iconInfo.hbmColor != NULL))
        {
            // Create a Bitmap from the icon's hbmColor:

            status = CreateFromHBITMAP(iconInfo.hbmColor,
                                       (HPALETTE)GetStockObject(DEFAULT_PALETTE),
                                       bitmap);

            // Convert Bitmap to 32bpp ARGB (need the alpha channel):

            if (status == Ok && (*bitmap != NULL))
                (*bitmap)->ConvertFormat(PIXFMT_32BPP_ARGB, NULL, NULL);

            // Retrieve the icon mask:

            if ((status == Ok) && (iconInfo.hbmMask != NULL))
            {
                status = Win32Error;

                HDC hdc = GetDC(NULL);

                if (hdc)
                {
                    // Get some basic information about the bitmap mask:

                    BYTE bufferBitmapInfo[sizeof(BITMAPINFO) + 255*sizeof(RGBQUAD)];
                    BITMAPINFO *gdiBitmapInfo = (BITMAPINFO *) bufferBitmapInfo;

                    memset(bufferBitmapInfo, 0, sizeof(bufferBitmapInfo));
                    gdiBitmapInfo->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);

                    if (GetDIBits(hdc,
                                  iconInfo.hbmMask,
                                  0,
                                  0,
                                  NULL,
                                  gdiBitmapInfo,
                                  DIB_RGB_COLORS))
                    {
                        // Get the bitmap mask as a 32bpp top-down DIB:

                        gdiBitmapInfo->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
                        gdiBitmapInfo->bmiHeader.biHeight = -abs(gdiBitmapInfo->bmiHeader.biHeight);
                        gdiBitmapInfo->bmiHeader.biPlanes       = 1;
                        gdiBitmapInfo->bmiHeader.biBitCount     = 32;
                        gdiBitmapInfo->bmiHeader.biCompression  = BI_RGB;
                        gdiBitmapInfo->bmiHeader.biSizeImage    = 0;
                        gdiBitmapInfo->bmiHeader.biClrUsed      = 0;
                        gdiBitmapInfo->bmiHeader.biClrImportant = 0;

                        VOID *gdiBitmapData = GpMalloc(gdiBitmapInfo->bmiHeader.biHeight
                                                       * gdiBitmapInfo->bmiHeader.biHeight
                                                       * 4);

                        if (gdiBitmapData != NULL)
                        {
                            if (GetDIBits(hdc,
                                          iconInfo.hbmMask,
                                          0,
                                          -gdiBitmapInfo->bmiHeader.biHeight,
                                          gdiBitmapData,
                                          gdiBitmapInfo,
                                          DIB_RGB_COLORS))
                            {
                                // Convert non-zero mask values to alpha = 0:

                                BitmapData bmpData;

                                status = (*bitmap)->LockBits(NULL,
                                                             IMGLOCK_READ|IMGLOCK_WRITE,
                                                             PIXFMT_32BPP_ARGB,
                                                             &bmpData);

                                if (status == Ok)
                                {
                                    BitmapData maskData;

                                    maskData.Width = gdiBitmapInfo->bmiHeader.biWidth;
                                    maskData.Height = -gdiBitmapInfo->bmiHeader.biHeight;
                                    maskData.Stride = gdiBitmapInfo->bmiHeader.biWidth * 4;
                                    maskData.PixelFormat = PIXFMT_32BPP_RGB;
                                    maskData.Scan0 = gdiBitmapData;
                                    maskData.Reserved = 0;

                                    ImportMask32BPP(&bmpData, &maskData);

                                    (*bitmap)->UnlockBits(&bmpData);
                                }
                            }
                            else
                            {
                                WARNING(("GetDIBits failed on icon mask bitmap"));
                            }

                            GpFree(gdiBitmapData);
                        }
                        else
                        {
                            WARNING(("memory allocation failed"));
                            status = OutOfMemory;
                        }
                    }
                    else
                    {
                        WARNING(("GetDIBits failed on icon color bitmap"));
                    }

                    ReleaseDC(NULL, hdc);
                }
            }
        }
        else
        {
            status = InvalidParameter;
        }

        if (iconInfo.hbmMask != NULL)
            DeleteObject(iconInfo.hbmMask);

        if (iconInfo.hbmColor != NULL)
            DeleteObject(iconInfo.hbmColor);
    }
    else
    {
        status = InvalidParameter;
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   INTEROP
*
*   Create CopyOnWriteBitmap from a resource.
*
* Arguments:
*
*   hInstance -- Specifies instance that contains resource
*   lpBitmapName -- Specifies resource name or ordinal
*   bitmap -- Return created bitmap via this buffer
*
* Return Value:
*
*   Ok if successful
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::CreateFromResource(
    HINSTANCE hInstance,
    LPWSTR lpBitmapName,
    CopyOnWriteBitmap** bitmap
    )
{
    GpStatus status = Ok;

    HBITMAP hbm = (HBITMAP) _LoadBitmap(hInstance, lpBitmapName);

    if (hbm)
    {
        status = CreateFromHBITMAP(hbm, (HPALETTE) NULL, bitmap);
        DeleteObject(hbm);
    }
    else
    {
        status = InvalidParameter;
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   CopyOnWriteBitmap object destructor
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

CopyOnWriteBitmap::~CopyOnWriteBitmap()
{
    this->FreeData();
    
    // Close the encoder object attached to this

    TerminateEncoder();    
}

VOID
CopyOnWriteBitmap::FreeData()
{
    GpFree(Filename);
    if (Stream) Stream->Release();
    if (Img) Img->Release();
    if (Bmp) Bmp->Release();
    if (InteropData.Hdc) DeleteDC(InteropData.Hdc);
    if (InteropData.Hbm) DeleteObject(InteropData.Hbm);
    if (cleanupBitmapData) GpFree(cleanupBitmapData);
}


/**************************************************************************\
*
* Function Description:
*
*   Dereferences the stream or filename image into a non-decoded image.
*
* Arguments:
*
*   format - Specifies the preferred pixel format
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::DereferenceStream() const
{
    HRESULT hr;

    if (State < DecodedImg)
    {
        ASSERT(Img == NULL);

        if (State == ExtStream)
        {
            ASSERT(Stream != NULL);
            hr = GpDecodedImage::CreateFromStream(Stream, &Img);
        }
        else
        {
            ASSERT(State == ImageRef && Filename != NULL);
            hr = GpDecodedImage::CreateFromFile(Filename, &Img);
        }

        if (FAILED(hr))
        {
            WARNING(("Failed to create decoded image: %x", hr));
            State = Invalid;
            return (MapHRESULTToGpStatus(hr));
        }

        State = DecodedImg;
    }

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Load the memory image into memory
*
* Arguments:
*
*   format - Specifies the preferred pixel format
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::LoadIntoMemory(
    PixelFormatID format,
    DrawImageAbort callback,
    VOID *callbackData,
    INT width,
    INT height
) const
{
    ASSERT(IsValid());

    if (State >= MemBitmap)
        return Ok;

    // Create decoded image object if necessary

    HRESULT hr;

    // Dereference the stream or file pointer and create an encoded image
    // object that can be decoded by the codec.
    // If the bitmap is already greater or equal to DecodedImg state, this
    // is a nop.

    GpStatus status = DereferenceStream();
    if ( status != Ok )
    {
        return status;
    }

    ASSERT(Img != NULL);

    if ( format == PixelFormatUndefined )
    {
        // If the caller doesn't care about the pixel format, then we load it
        // as the source image format

        format = SrcImageInfo.PixelFormat;
    }

    if ( ICMConvert == TRUE )
    {
        // Check if the OS supports ICM. We are doing this by checking if the
        // ICM dlls we need are available on the system or not.
        // Note: NT4 doesn't have ICM2 functionality. So the LoadICMDll() call
        // should fail
        // Note: LoadICMDll() is expensive only for the first time. If it has
        // already beed loaded, then it is a very small cost

        hr = LoadICMDll();
        if(SUCCEEDED(hr))
        {
            // We should let the codec know that we need the native data format
            // and we will do the conversion in ICMFrontEnd()
            
            BOOL    fUseICC = TRUE;
            hr = Img->SetDecoderParam(DECODER_USEICC, 1, &fUseICC);

            // Note: we don't need to check the return code of this call because
            // it just pass the info down to the codec. If the codec doesn't
            // support this. It is still fine

            // If the source is in CMYK color space and we need to do ICM
            // conversion, then we can't load the image in as 32PARGB. The reason
            // is that the lower lever codec will return CMYK in native format,
            // as we require it to. But if we ask
            // GpMemoryBitmap::CreateFromImage() to create a 32PARGB, then it
            // will do a format conversion and treat the C channel as ALPHA.
            // That's completely wrong.
            // So the solution here is to change the caller's requirement from
            // 32PARGB to 32ARGB, remember it. Load the image in as 32ARGB, call
            // ICMFrontEnd() to do the ICM conversion. Then before it is done,
            // change the format back to 32 PARGB
            // A complicated work around.  MinLiu (01/25/2001)

            if ( (format == PixelFormat32bppPARGB)
               &&(SrcImageInfo.Flags & IMGFLAG_COLORSPACE_CMYK) )
            {
                HasChangedRequiredPixelFormat = TRUE;
                format = PixelFormat32bppARGB;
            }
        }

        // If the OS doesn't support ICM, then we don't set DECODER_USEICC and
        // the codec will return RGB format to us
    }

    // Now load the image into memory

    ASSERT(Bmp == NULL);

    hr = GpMemoryBitmap::CreateFromImage(
        Img,
        width,
        height,
        format,
        InterpolationHintAveraging,
        &Bmp,
        callback,
        callbackData
    );

    if (FAILED(hr))
    {
        WARNING(("Failed to load image into memory: %x", hr));

        return MapHRESULTToGpStatus(hr);
    }

    // If resolution has been overridden, make sure GpMemoryBitmap is
    // consistent with the set value

    if ( (XDpiOverride > 0.0) && (YDpiOverride > 0.0) )
    {
        // Note: we don't need to check return code here since SetResolution()
        // will not fail if both parameters are > 0

        Bmp->SetResolution(XDpiOverride, YDpiOverride);
    }

    State = MemBitmap;

    // Remember pixel format in the memory

    PixelFormatInMem = format;

    // We must be in MemBitmap state otherwise ICMFrontEnd will call us
    // recursively.
    ASSERT((State == MemBitmap));

    // !!! ack - we have to call a huge chain of non-const stuff here from this
    // const function. This should be fixed by removing the const from this
    // function, but it's a pretty massive change.
    const_cast<CopyOnWriteBitmap *>(this)->ICMFrontEnd(NULL, callback, callbackData, NULL);

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Get the encoder parameter list size from an encoder object specified by
*   input clsid
*
* Arguments:
*
*   clsidEncoder - Specifies the encoder class ID
*   size---------- The size of the encoder parameter list
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   03/22/2000 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::GetEncoderParameterListSize(
    CLSID* clsidEncoder,
    UINT*  size
    )
{
    ASSERT(IsValid());

    GpStatus status;

    HRESULT hResult;

    // If the image has a source and it is not dirty, we let the decoder
    // directly talk to the encoder

    if ( (Img != NULL) && (IsDirty() == FALSE) )
    {
        hResult = Img->GetEncoderParameterListSize(clsidEncoder, size);
    }
    else
    {
        status = LoadIntoMemory();

        if ( status != Ok )
        {
            return status;
        }

        hResult = Bmp->GetEncoderParameterListSize(clsidEncoder, size);
    }

    return MapHRESULTToGpStatus(hResult);
}// GetEncoderParameterListSize()

/**************************************************************************\
*
* Function Description:
*
*   Get the encoder parameter list from an encoder object specified by
*   input clsid
*
* Arguments:
*
*   clsidEncoder --- Specifies the encoder class ID
*   size------------ The size of the encoder parameter list
*   pBuffer--------- Buffer for storing the list
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   03/22/2000 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::GetEncoderParameterList(
    CLSID* clsidEncoder,
    UINT  size,
    EncoderParameters* pBuffer
    )
{
    ASSERT(IsValid());

    GpStatus status;
    HRESULT hResult;

    // If the image has a source and it is not dirty, we let the decoder
    // directly talk to the encoder

    if ( (Img != NULL) && (IsDirty() == FALSE) )
    {
        hResult = Img->GetEncoderParameterList(clsidEncoder, size, pBuffer);
    }
    else
    {
        status = LoadIntoMemory();

        if ( status != Ok )
        {
            return status;
        }

        hResult = Bmp->GetEncoderParameterList(clsidEncoder, size, pBuffer);
    }

    return MapHRESULTToGpStatus(hResult);
}// GetEncoderParameterList()

/**************************************************************************\
*
* Function Description:
*
*   Parse the input encoder parameter
*
* Arguments:
*
*   encoderParams ------ Pointer to a set of encoder parameters
*   pbIsMultiFrameSave--Return flag to tell the caller if this is a multi-frame
*                       saving operation or not
*
* Return Value:
*
*   Status code
*
* Note:
*   We don't validate input parameter because this is a private function.
*   For performance reason the caller should validate the parameter before it
*   calls this function. For the moment only those saving methods call it
*
* Revision History:
*
*   07/19/2000 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::ParseEncoderParameter(
    const EncoderParameters*    encoderParams,
    BOOL*                       pfIsMultiFrameSave,
    BOOL*                       pfSpecialJPEG,
    RotateFlipType*             rfType
    )
{
    ASSERT(encoderParams != NULL);
    ASSERT(pfIsMultiFrameSave != NULL);
    ASSERT(pfSpecialJPEG != NULL);
    ASSERT(rfType != NULL);

    *pfIsMultiFrameSave = FALSE;
    *pfSpecialJPEG = FALSE;
    *rfType = RotateNoneFlipNone;

    // Parse the encoder parameter caller set for:
    // 1) Check if the caller has specified this is a multi-frame save OP or not
    // 2) The caller can't set lossless transformation for JPEG if the image is
    //    dirty or the image size is not multiple of 16

    for ( UINT i = 0; (i < encoderParams->Count); ++i )
    {
        if ( (encoderParams->Parameter[i].Guid == ENCODER_SAVE_FLAG)
             &&(encoderParams->Parameter[i].Type == EncoderParameterValueTypeLong)
             &&(encoderParams->Parameter[i].NumberOfValues == 1) )
        {
            UINT*   pValue = (UINT*)encoderParams->Parameter[i].Value;

            if ( *pValue == EncoderValueMultiFrame )
            {
                *pfIsMultiFrameSave = TRUE;
            }
        }
        else if ( encoderParams->Parameter[i].Guid == ENCODER_TRANSFORMATION )
        {
            // We should check if the image format user wants to save is
            // JPEG or not. But we can't do this since it might possible that
            // other image codec supports "transformation". Also, we don't need
            // to check this now since the codec will return "InvalidParameter"
            // if it doesn't supports it.
            //
            // For transformation, the type has to be "ValueTypeLong" and
            // "NumberOfValue" should be "1" because you can set only one
            // transformation at a time
            // Of course, the image has to be not dirty

            if ( (encoderParams->Parameter[i].Type
                   != EncoderParameterValueTypeLong)
               ||(encoderParams->Parameter[i].NumberOfValues != 1)
               ||(encoderParams->Parameter[i].Value == NULL)
               ||(IsDirty() == TRUE) )
            {
                WARNING(("COWBmap::ParseEncoderParameter-invalid input args"));
                return InvalidParameter;
            }

            if (SrcImageInfo.RawDataFormat == IMGFMT_JPEG)
            {
                // If the width or height is not multiple of 16, set it as a
                // special JPEG so that we have to tranform it in memory

                if (((SrcImageInfo.Width & 0x000F) != 0) ||
                    ((SrcImageInfo.Height & 0x000F) != 0))
                {
                    *pfSpecialJPEG = TRUE;
                }

                // If the source is JPEG, we will return "rfType" according to
                // the encoder parameter

                EncoderValue requiredTransform =
                           *((EncoderValue*)encoderParams->Parameter[i].Value);

                switch ( requiredTransform )
                {
                case EncoderValueTransformRotate90:
                    *rfType = Rotate90FlipNone;
                    break;

                case EncoderValueTransformRotate180:
                    *rfType = Rotate180FlipNone;
                    break;

                case EncoderValueTransformRotate270:
                    *rfType = Rotate270FlipNone;
                    break;

                case EncoderValueTransformFlipHorizontal:
                    *rfType = RotateNoneFlipX;
                    break;

                case EncoderValueTransformFlipVertical:
                    *rfType = RotateNoneFlipY;
                    break;

                default:
                    break;
                }
            }
        }// GUID == ENCODER_TRANSFORMATION
    }// Loop all the settings

    return Ok;
}// ParseEncoderParameter()

/**************************************************************************\
*
* Function Description:
*
*   Transform embedded JPEG thumbnail so that it matches the transform applied
*   to the main image.
*
* Return Value:
*
*   Status code
*
* Note:
*   This function should be called iff and source image is JPEG and the caller
*   wants to do a lossless transformation during save.
*   Of course, if the source is not JPEG, this function won't do any harm to the
*   result, just waste of time.
*
* Revision History:
*
*   01/10/2002 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::TransformThumbanil(
    IN CLSID* clsidEncoder,                 // CLSID for Destination format
    IN EncoderParameters* encoderParams,    // Encoder parameters
    OUT PropertyItem **ppOriginalItem       // Pointer to original thumbnail
                                            // property item
    )
{
    if (ppOriginalItem == NULL)
    {
        return InvalidParameter;
    }

    if (NULL == encoderParams)
    {
        // Nothing we need to do

        return Ok;
    }

    *ppOriginalItem = NULL;

    Status status = Ok;
    HRESULT hr = S_OK;

    // The condition to transform the thumbnail are:
    // 1) Source and dest are JPEGs. But we can't check the format here since it
    //    might have been transformed in memory due to the non-multiple of 16
    //    issue. The caller should control this, as said above.
    // 2) Has a meaningful transform type

    if (*clsidEncoder == InternalJpegClsID)
    {
        // Check if the source has thumbnail

        UINT cSize = 0;
        status = GetPropertyItemSize(PropertyTagThumbnailData, &cSize);
        if (Ok == status)
        {
            // Allocate memory buffer for receiving it

            PropertyItem *pItem = (PropertyItem*)GpMalloc(cSize);
            if (pItem)
            {
                // Get the thumbnail data

                status = GetPropertyItem(PropertyTagThumbnailData, cSize,pItem);
                if (Ok == status)
                {
                    GpImagingFactory imgFact;
                    GpDecodedImage *pThumbImage = NULL;
                    GpReadOnlyMemoryStream *pSrcStream =
                        new GpReadOnlyMemoryStream();

                    if (pSrcStream)
                    {
                        pSrcStream->InitBuffer(pItem->value, pItem->length);

                        // Create a decoded image object from the stream

                        hr = GpDecodedImage::CreateFromStream(
                            pSrcStream,
                            &pThumbImage
                            );

                        if (SUCCEEDED(hr))
                        {
                            // Check the thumbnail size to see if it is multiple
                            // of 16 or not

                            ImageInfo imgInfo;
                            hr = pThumbImage->GetImageInfo(&imgInfo);

                            if (SUCCEEDED(hr))
                            {
                                BOOL fTrimEdge = FALSE;

                                // Number of encoder parameters to set

                                int cParams = 1;

                                if (((imgInfo.Width & 0x000F) != 0) ||
                                    ((imgInfo.Height & 0x000F) != 0))
                                {
                                    // Do edge trim if it is non-multiple of 16

                                    fTrimEdge = TRUE;
                                    cParams++;
                                }

                                // Parameter index

                                int iParam = 0;

                                // Make up a transform encoder parameter

                                EncoderParameters *pThumbParam =
                                    (EncoderParameters*)GpMalloc(
                                        sizeof(EncoderParameters) +
                                        cParams * sizeof(EncoderParameter));
                                UINT uTransformType = 0;

                                if (pThumbParam)
                                {
                                    // Get the transform info from the main
                                    // image's encoder parameter

                                    for (UINT i = 0; i < (encoderParams->Count);
                                         ++i)
                                    {
                                        if (encoderParams->Parameter[i].Guid ==
                                            ENCODER_TRANSFORMATION)
                                        {
                                 pThumbParam->Parameter[iParam].Guid=
                                                ENCODER_TRANSFORMATION;
                                 pThumbParam->Parameter[iParam].NumberOfValues =
                                    encoderParams->Parameter[i].NumberOfValues;
                                            pThumbParam->Parameter[iParam].Type=
                                    encoderParams->Parameter[i].Type;

                                            uTransformType =
                                    *((UINT*)encoderParams->Parameter[i].Value);
                                 pThumbParam->Parameter[iParam].Value =
                                     &uTransformType;
                                            
                                            iParam++;

                                            // Only one transform parameter is
                                            // allowed

                                            break;
                                        }
                                    }

                                    // Set the trim edge info if necessary

                                    if (fTrimEdge)
                                    {
                                        BOOL trimFlag = TRUE;

                                        pThumbParam->Parameter[iParam].Guid =
                                            ENCODER_TRIMEDGE;
                                        pThumbParam->Parameter[iParam].Type =
                                            EncoderParameterValueTypeByte;
                                   pThumbParam->Parameter[iParam].NumberOfValues
                                        = 1;
                               pThumbParam->Parameter[iParam].Value = &trimFlag;
                                        iParam++;
                                    }

                                    pThumbParam->Count = iParam;

                                    // Create a memory stream for writing JPEG

                                    GpWriteOnlyMemoryStream *pDestStream =
                                        new GpWriteOnlyMemoryStream();
                                    if (pDestStream)
                                    {
                                        // Set initiali buffer size to 2 times
                                        // the source thumbnail image. This
                                        // should be enough. On the other hand,
                                        // GpWriteOnlyMemoryStream object will
                                        // do realloc if necessary

                                        hr = pDestStream->InitBuffer(
                                            2 * pItem->length);

                                        if (SUCCEEDED(hr))
                                        {
                                            // Save thumbnail to memory stream

                                            IImageEncoder *pDstJpegEncoder =
                                                NULL;
                                            hr = pThumbImage->SaveToStream(
                                                pDestStream,
                                                clsidEncoder,
                                                pThumbParam,
                                                &pDstJpegEncoder
                                                );

                                            // Note: SaveToStream might fail.
                                            // But the encoder might still be
                                            // allocated before the failure.
                                            // There are some  code path
                                            // limitations which causes this.
                                            // Need to be revisited in Avalon.
                                            // For now, we should release the
                                            // encoder object if it is not NULL

                                            if (pDstJpegEncoder)
                                            {
                                            pDstJpegEncoder->TerminateEncoder();
                                                pDstJpegEncoder->Release();
                                            }

                                            if (SUCCEEDED(hr))
                                            {
                                                // Get the bits from the stream
                                                // and set the property

                                                BYTE *pRawBits = NULL;
                                                UINT nLength = 0;

                                                hr = pDestStream->GetBitsPtr(
                                                    &pRawBits,
                                                    &nLength
                                                    );

                                                if (SUCCEEDED(hr))
                                                {
                                                    PropertyItem dstItem;
                                                    
                                                    dstItem.id =
                                                       PropertyTagThumbnailData;
                                                    dstItem.length = nLength;
                                                    dstItem.type =
                                                       PropertyTagTypeByte;
                                                    dstItem.value = pRawBits;

                                                    status = SetPropertyItem(
                                                        &dstItem);
                                                }
                                            }// SaveToStream succeed
                                        }// InitBuffer() succeed

                                        pDestStream->Release();
                                    }// Create GpWriteOnlyMemoryStream() succeed

                                    GpFree(pThumbParam);
                                }// Allocate a encoder parameter block succeed
                            }// GetImageInfo succeed

                            pThumbImage->Release();
                        }// Create thumbImage succeed

                        pSrcStream->Release();
                    }// Create source stream
                    else
                    {
                        status = OutOfMemory;
                    }
                }// Get thumbnail data

                if ((Ok == status) && SUCCEEDED(hr))
                {
                    // Pass the original thumbnail property item to the caller
                    // so that it can undo the transformation after the save()

                    *ppOriginalItem = pItem;
                }
                else
                {
                    GpFree(pItem);
                }
            }// GpMalloc() succeed
            else
            {
                status = OutOfMemory;
            }
        }// GetPropertyItemSize() Ok

        if (PropertyNotFound == status)
        {
            // If we can't find thumbnail in the image, that's OK. We don't need
            // to transform it. So this function should return Ok

            status = Ok;
        }
    }// Condition check

    if ((Ok == status) && FAILED(hr))
    {
        status = MapHRESULTToGpStatus(hr);
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Validate if the encoder we created can really support multi-frame saving.
*   If not, call TerminateEncoder()
*   This method is called after we saved the image and we are not sure if we
*   need to keep the encoder pointer.
*
* Arguments:
*
*   VOID
*
* Return Value:
*
*   Status code
*
* Note:
*   We don't validate input parameter because this is a private function.
*   For performance reason the caller should validate the parameter before it
*   calls this method. For the moment only those saving methods call it
*
* Revision History:
*
*   07/19/2000 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::ValidateMultiFrameSave()
{
    // Though the user sets the encoder parameter for multi-frame save, we
    // still need to check if the lower level codec supports saving multi-
    // frame or not.
    // The reason we need to do this is that if the user sets this flag, we
    // don't close the image file handle so that it can saving multi-frame.
    // But for images like JPEG, it supports only single frame. If the user
    // calls SaveAdd() subsequently, we will damage the file which has been
    // saved with current Save() call

    ASSERT(EncoderPtr != NULL);

    UINT    uiSize;
    HRESULT hResult = EncoderPtr->GetEncoderParameterListSize(&uiSize);

    if ( hResult == S_OK )
    {
        EncoderParameters*  pParams = (EncoderParameters*)GpMalloc(uiSize);

        if ( pParams == NULL )
        {
            // Though we are out of memory here. But we succeed in saving
            // the image. So we should keep that result

            WARNING(("CopyOnWriteBitmap::ValidateMultiFrameSave---Out of memory"));
            TerminateEncoder();

            return OutOfMemory;
        }

        hResult = EncoderPtr->GetEncoderParameterList(uiSize, pParams);
        if ( hResult == S_OK )
        {
            // Check if the codec supports multi-frame save or not

            UINT uiTemp;

            for ( uiTemp = 0; (uiTemp < pParams->Count); ++uiTemp )
            {
                if ( (pParams->Parameter[uiTemp].Guid == ENCODER_SAVE_FLAG)
                   &&(pParams->Parameter[uiTemp].Type == EncoderParameterValueTypeLong)
                   &&(pParams->Parameter[uiTemp].NumberOfValues == 1)
                   &&(EncoderValueMultiFrame
                        == *((ULONG*)pParams->Parameter[uiTemp].Value) ) )
                {
                    break;
                }
            }

            if ( uiTemp == pParams->Count )
            {
                // Not found clue for supporting multi-frame save

                TerminateEncoder();
            }
        }

        GpFree(pParams);
    }
    else
    {
        // This encoder doesn't provide encoder parameter query. It mustn't
        // support multi-frame save

        TerminateEncoder();
    }

    return Ok;
}// ValidateFrameSave()

/**************************************************************************\
*
* Function Description:
*
*   Save the image to a stream using the specified encoder
*
* Arguments:
*
*   stream - Specifies the target stream
*   clsidEncoder - Specifies the CLSID of the encoder
*   encoderParams - Parameters passed to the encoder
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::SaveToStream(
    IStream* stream,
    CLSID* clsidEncoder,
    EncoderParameters* encoderParams
    )
{
    return DoSave(stream, NULL, clsidEncoder, encoderParams);
}// SaveToStream()

/**************************************************************************\
*
* Function Description:
*
*   Save the image to a file using the specified encoder
*
* Arguments:
*
*   stream - Specifies the filename to save to
*   clsidEncoder - Specifies the CLSID of the encoder
*   encoderParams - Parameters passed to the encoder
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::SaveToFile(
    const WCHAR* filename,
    CLSID* clsidEncoder,
    EncoderParameters* encoderParams
    )
{
    return DoSave(NULL,filename,clsidEncoder,encoderParams);
}// SaveToFile()

GpStatus
CopyOnWriteBitmap::DoSave(
    IStream* stream,
    const WCHAR* filename,
    CLSID* clsidEncoder,
    EncoderParameters* pEncoderParams
    )
{
    ASSERT(IsValid());

    // We already have an encoder attached to this bitmap. Need to close it
    // first before we open a new one

    TerminateEncoder();

    GpStatus status = Ok;
    HRESULT hr = S_OK;

    BOOL fMultiFrameSave = FALSE;
    BOOL fSpecialJPEG = FALSE;
    RotateFlipType  rfType = RotateNoneFlipNone;

    if (pEncoderParams)
    {
        // Validate the encoder parameter caller set

        status = ParseEncoderParameter(
            pEncoderParams,
            &fMultiFrameSave,
            &fSpecialJPEG,
            &rfType
            );

        if (status != Ok)
        {
            WARNING(("CopyOnWriteBitmap::DoSave--ParseEncoderParameter() failed"));
            return status;
        }
    }

    // If the destination file format is JPEG and it needs special JPEG
    // treatment, that is, the size doesn't meet the lossless transformation
    // requirement. But the caller wants to do a lossless transformation. So we
    // rotate or flip it in memory. Then pass this flag down to GpMemoryBitmap
    // which will set the luminance and chrominance table before save. This way
    // we can do our best to preserve the original JPEG image quality

    if ((fSpecialJPEG == TRUE) &&
        (rfType != RotateNoneFlipNone) &&
        (*clsidEncoder == InternalJpegClsID))
    {
        // We are handling special lossless JPEG transform saving request

        SpecialJPEGSave = TRUE;

        // Rotate or flip in memory.

        hr = RotateFlip(rfType);

        if (FAILED(hr))
        {
            WARNING(("CopyOnWriteBitmap::DoSave-RotateFlip() failed"));
            return MapHRESULTToGpStatus(hr);
        }
    }

    // If the image has a source and it is not dirty, we let the decoder
    // directly talk to the encoder

    PropertyItem *pSrcItem = NULL;
    BOOL fNeedToRestoreThumb = FALSE;

    if ((Img != NULL) && (IsDirty() == FALSE))
    {
        // Since we can't save CMYK TIFF for now. So we shouldn't pass CMYK bits
        // to the encoder. JPEG decoder doesn't support this decoder parameter
        // yet. See windows bug#375298 for more details.
        // In V2, after we add CMYK as one of the color format, after we move
        // all the color conversion stuff to an approprite place, we will
        // re-visit the code here.

        BOOL fUseICC = FALSE;
        hr = Img->SetDecoderParam(DECODER_USEICC, 1, &fUseICC);

        // Note: we don't need to check the return code for SetDecoderParam()
        // Most codec not support it. Then it will be a Nop.
        
        // Handle thumbnail transformation if it is lossless JPEG transformation
        // Note: rfType will be set to a non-RotateNoneFlipNone value iff the
        // source image is JPEG

        if (rfType != RotateNoneFlipNone)
        {
            status = TransformThumbanil(clsidEncoder,pEncoderParams, &pSrcItem);
        }

        if (Ok == status)
        {
            fNeedToRestoreThumb = TRUE;

            if (stream)
            {
                hr = Img->SaveToStream(
                    stream,
                    clsidEncoder,
                    pEncoderParams,
                    &EncoderPtr
                    );
            }
            else if (filename)
            {
                hr = Img->SaveToFile(
                    filename,
                    clsidEncoder,
                    pEncoderParams,
                    &EncoderPtr
                    );
            }
            else
            {
                // This should not happen that both stream and filename are NULL

                hr = E_FAIL;
            }
        }
    }
    else
    {
        status = LoadIntoMemory();

        if (status != Ok)
        {
            return status;
        }

        EncoderParameters *pNewParam = pEncoderParams;
        BOOL fFreeExtraParamBlock = FALSE;

        // PAY attention to the scope of "fSuppressAPP0". Its address is used as
        // parameter passed into Save() call below. So this variable can't be
        // destroyed before the save() is called.

        BOOL fSuppressAPP0 = TRUE;

        if (fSpecialJPEG == TRUE)
        {
            // We are in a situation that the caller asks us to do a lossless
            // transformation. Due to the size limitation, we have to
            // transform it in memory.
            // Since it is not correct to save APP0 in a Exif file. So we check
            // if the source is Exif, then we suppress APP0 header

            int cParams = 1;

            pNewParam = (EncoderParameters*)GpMalloc(
                sizeof(EncoderParameters) +
                cParams * sizeof(EncoderParameter));

            if (pNewParam)
            {
                // Set the Suppress APP0 parameter

                pNewParam->Parameter[cParams - 1].Guid = ENCODER_SUPPRESSAPP0;
                pNewParam->Parameter[cParams - 1].NumberOfValues = 1;
                pNewParam->Parameter[cParams - 1].Type = TAG_TYPE_BYTE;
                pNewParam->Parameter[cParams - 1].Value = (VOID*)&fSuppressAPP0;

                pNewParam->Count = cParams;
                
                // Set the flag to TRUE so that we can free it later

                fFreeExtraParamBlock = TRUE;
                
                // Handle thumbnail transformation if it is lossless
                // transformation

                if (rfType != RotateNoneFlipNone)
                {
                    status = TransformThumbanil(
                        clsidEncoder,
                        pEncoderParams,
                        &pSrcItem
                        );

                    if (Ok == status)
                    {
                        fNeedToRestoreThumb = TRUE;
                    }
                }
            }
            else
            {
                status = OutOfMemory;
            }
        }// Special JPEG case

        if (SUCCEEDED(hr) && (Ok == status))
        {
            // Determine how should we pass the GpDecodedImage pointer down to
            // the save() call. If we are handling special lossless transform,
            // we know that we have RotateFlip() the image in memory, so we
            // should not pass any GpDecodedImage info down, just pass NULL.
            // Otherwise, pass the pointer to GpDecodedImage down.

            GpDecodedImage *pSrc = Img;
            if (SpecialJPEGSave == TRUE)
            {
                pSrc = NULL;
            }

            if (stream)
            {
                hr = Bmp->SaveToStream(
                    stream,
                    clsidEncoder,
                    pNewParam,
                    fSpecialJPEG,
                    &EncoderPtr,
                    pSrc
                    );
            }
            else if (filename)
            {
                hr = Bmp->SaveToFile(
                    filename,
                    clsidEncoder,
                    pNewParam,
                    fSpecialJPEG,
                    &EncoderPtr,
                    pSrc
                    );
            }
            else
            {
                // This should not happen that both stream and filename are NULL

                hr = E_FAIL;
            }
        }

        // When we handle the special lossless transform request, we rotate/flip
        // the image in memory. The Img pointer should be released when
        // RotateFlip() is done. But we couldn't do that since Save() function
        // in JPEG encoder needs to get all the private APP headers from the
        // source image. So we delay the release for the Img pointer until the
        // save() is done.

        if (Img && (SpecialJPEGSave == TRUE))
        {
            Img->Release();
            Img = NULL;
            SpecialJPEGSave = FALSE;
        }

        if (fFreeExtraParamBlock && pNewParam)
        {
            GpFree(pNewParam);
        }
    }

    if ((TRUE == fNeedToRestoreThumb) && pSrcItem)
    {
        // If pSrcIetm is not NULL, it means we have transformed the thumbnail
        // of current image. Restore the original thumbnail info

        status = SetPropertyItem(pSrcItem);
        GpFree(pSrcItem);
    }
    
    if (FAILED(hr))
    {
        // If SaveToFile/Stream() filed, we should terminate the encoder
        // immediately.
        // We don't need to check if it is multi-frame save or not.

        TerminateEncoder();
        return MapHRESULTToGpStatus(hr);
    }

    // If it is a single frame save OP, close the encoder

    if (fMultiFrameSave == FALSE)
    {
        TerminateEncoder();
    }
    else
    {
        // The caller set the multi-frame save flag in encoder parameter. But
        // we still need to check if the encoder really supports it. If not,
        // the encoder will be closed in ValidateMultiFrameSave()

        ValidateMultiFrameSave();
    }

    return status;
}// DoSave()

/**************************************************************************\
*
* Function Description:
*
* Append current frame to current encoder object
*
* Arguments:
*
*   encoderParams - Encoder parameters
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   04/21/2000 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::SaveAdd(
    const EncoderParameters* encoderParams
    )
{
    // Caller has to call Save() first to establish the encoder object

    if ( EncoderPtr == NULL )
    {
        WARNING(("CopyOnWriteBitmap::SaveAdd---Caller hasn't call Save() yet"));
        return Win32Error;
    }

    // We don't need to check if encoderParams is NULL or not because it has
    // been checked in flatapi.cpp

    ASSERT(encoderParams != NULL);
    ASSERT(IsValid());

    BOOL bLastFrame = FALSE;
    BOOL bSetFrameDimension = FALSE;
    GUID tempGuid;

    // Check if the caller has specified this is the last frame or a flush OP
    // Also, according to spec, the caller also has to specify the type of
    // dimension for next frame

    for ( UINT i = 0; (i < encoderParams->Count); ++i )
    {
        if ( (encoderParams->Parameter[i].Guid == ENCODER_SAVE_FLAG )
           &&(encoderParams->Parameter[i].Type == EncoderParameterValueTypeLong)
           &&(encoderParams->Parameter[i].NumberOfValues == 1) )
        {
            UINT   ulValue = *((UINT*)(encoderParams->Parameter[i].Value));

            if ( ulValue == EncoderValueLastFrame )
            {
                bLastFrame = TRUE;
            }
            else if ( ulValue == EncoderValueFlush )
            {
                // The caller just wants to close the file

                TerminateEncoder();

                return Ok;
            }
            else if ( ulValue == EncoderValueFrameDimensionPage )
            {
                tempGuid = FRAMEDIM_PAGE;
                bSetFrameDimension = TRUE;
            }
            else if ( ulValue == EncoderValueFrameDimensionTime )
            {
                tempGuid = FRAMEDIM_TIME;
                bSetFrameDimension = TRUE;
            }
            else if ( ulValue == EncoderValueFrameDimensionResolution )
            {
                tempGuid = FRAMEDIM_RESOLUTION;
                bSetFrameDimension = TRUE;
            }
        }
    }// Loop all the settings

    HRESULT hResult = S_OK;
    GpStatus status;

    if ( bSetFrameDimension == FALSE )
    {
        WARNING(("CopyOnWriteBitmap::SaveAdd---Caller doesn't set frame dimension"));
        return InvalidParameter;
    }
    else
    {
        hResult = EncoderPtr->SetFrameDimension(&tempGuid);
        if ( FAILED(hResult) )
        {
            return MapHRESULTToGpStatus(hResult);
        }
    }

    // If the image has a source and it is not dirty, we let the decoder
    // directly talk to the encoder

    if ( (Img != NULL) && (IsDirty() == FALSE) )
    {
        hResult = Img->SaveAppend(encoderParams, EncoderPtr);
    }
    else
    {
        status = LoadIntoMemory();

        if ( status != Ok )
        {
            return status;
        }

        hResult = Bmp->SaveAppend(encoderParams, EncoderPtr, Img);
    }

    if ( FAILED(hResult) )
    {
        return MapHRESULTToGpStatus(hResult);
    }

    // If it is the last frame, close the encoder

    if ( bLastFrame == TRUE )
    {
        TerminateEncoder();
    }

    return Ok;
}// SaveAdd()

/**************************************************************************\
*
* Function Description:
*
* Append the bitmap object(newBits) to current encoder object
*
* Arguments:
*
*   newBits-------- Image object to be appended
*   encoderParams - Encoder parameters
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   04/21/2000 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::SaveAdd(
    CopyOnWriteBitmap*        newBits,
    const EncoderParameters*  encoderParams
    )
{
    // Caller has to call Save() first to establish the encoder object

    if ( EncoderPtr == NULL )
    {
        WARNING(("CopyOnWriteBitmap::SaveAdd---Caller hasn't call Save() yet"));
        return Win32Error;
    }

    // Note: we don't need to check if "newBits" is NULL and encoderParams is
    // NULL since it has been checked in flatapi.cpp

    ASSERT(newBits != NULL);
    ASSERT(encoderParams != NULL);
    ASSERT(IsValid());

    BOOL bLastFrame = FALSE;
    BOOL bSetFrameDimension = FALSE;
    GUID tempGuid;

    // Check if the caller has specified this is the last frame
    // Also, according to spec, the caller also has to specify the type of
    // dimension for next frame

    for ( UINT i = 0; (i < encoderParams->Count); ++i )
    {
        if ( (encoderParams->Parameter[i].Guid == ENCODER_SAVE_FLAG)
           &&(encoderParams->Parameter[i].Type == EncoderParameterValueTypeLong)
           &&(encoderParams->Parameter[i].NumberOfValues == 1) )
        {
            UINT    ulValue = *((UINT*)(encoderParams->Parameter[i].Value));

            if ( ulValue == EncoderValueLastFrame )
            {
                bLastFrame = TRUE;
            }
            else if ( ulValue == EncoderValueFrameDimensionPage )
            {
                tempGuid = FRAMEDIM_PAGE;
                bSetFrameDimension = TRUE;
            }
            else if ( ulValue == EncoderValueFrameDimensionTime )
            {
                tempGuid = FRAMEDIM_TIME;
                bSetFrameDimension = TRUE;
            }
            else if ( ulValue == EncoderValueFrameDimensionResolution )
            {
                tempGuid = FRAMEDIM_RESOLUTION;
                bSetFrameDimension = TRUE;
            }
        }
    }// Loop all the settings

    HRESULT hResult = S_OK;

    if ( bSetFrameDimension == FALSE )
    {
        WARNING(("CopyOnWriteBitmap::SaveAdd---Caller doesn't set frame dimension"));
        return InvalidParameter;
    }
    else
    {
        hResult = EncoderPtr->SetFrameDimension(&tempGuid);
        if ( FAILED(hResult) )
        {
            return (MapHRESULTToGpStatus(hResult));
        }
    }

    // We just need to call newBits->SaveAppend() and passing the EncoderPtr to
    // it. newBits->SaveAppend() should append all the frames in the object at
    // the end of the stream pointed by EncoderPtr

    CopyOnWriteBitmap* newBitmap = (CopyOnWriteBitmap*)newBits;
    Status rCode = newBitmap->SaveAppend(encoderParams, EncoderPtr);

    // If it is the last frame, close the encoder

    if ( bLastFrame == TRUE )
    {
        TerminateEncoder();
    }

    return rCode;
}// SaveAdd()

/**************************************************************************\
*
* Function Description:
*
* Append current frame to the encoder object caller passed in
* Note: This function is called from another CopyOnWriteBitmap object which holds the
*       encoder object. It asks current frame to be appended at the end of its
*       encoder object
*
* Arguments:
*
*   encoderParams - Encoder parameters
*   pDestEncoderPtr---Encoder object for saving this frame to
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   04/21/2000 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::SaveAppend(
    const EncoderParameters* encoderParams,
    IImageEncoder* pDestEncoderPtr
    )
{
    // We don't need to check if EncoderPtr is NULL since this is not a public
    // function. The caller should check

    ASSERT(pDestEncoderPtr != NULL);

    ASSERT(IsValid());

    HRESULT hResult;
    GpStatus status;

    // If the image has a source and it is not dirty, we let the decoder
    // directly talk to the encoder

    if ( (Img != NULL) && (IsDirty() == FALSE) )
    {
        hResult = Img->SaveAppend(encoderParams, pDestEncoderPtr);
    }
    else
    {
        status = LoadIntoMemory();

        if ( status != Ok )
        {
            return status;
        }

        hResult = Bmp->SaveAppend(encoderParams, pDestEncoderPtr, Img);
    }

    if ( FAILED(hResult) )
    {
        return (MapHRESULTToGpStatus(hResult));
    }

    return Ok;
}// SaveAppend()

/**************************************************************************\
*
* Function Description:
*
*   Make a copy of the bitmap image object
*
* Arguments:
*
*   rect - Specifies the area of the bitmap to be copied
*   format - Specifies the desired pixel format
*
* Return Value:
*
*   Pointer to the newly copied bitmap image object
*   NULL if there is an error
*
* Revision History:
*
*   06/30/2000 minliu
*       Rewrote it.
*
\**************************************************************************/

CopyOnWriteBitmap*
CopyOnWriteBitmap::Clone(
    const GpRect* rect,
    PixelFormatID format
    ) const
{
    // At this stage, the state should be >= 3 for a CopyOnWriteBitmap

    ASSERT(State >= 3);

    // Input parameter validate

    if ( (rect != NULL)
       &&( (rect->X < 0)
         ||(rect->Y < 0)
         ||(rect->Width < 0)
         ||(rect->Height < 0) ) )
    {
        // We can't clone negative coordinates or size

        WARNING(("CopyOnWriteBitmap::Clone---invalid input rect"));
        return NULL;
    }

    if ( (rect != NULL)
       &&( ( (rect->X + rect->Width) > (INT)SrcImageInfo.Width)
         ||( (rect->Y + rect->Height) > (INT)SrcImageInfo.Height) ) )
    {
        // We can't clone an area which is bigger than the source image

        WARNING(("CopyOnWriteBitmap::Clone---invalid input rect size"));
        return NULL;
    }

    if ( format == PixelFormatUndefined )
    {
        // If the caller doesn't care about the pixel format, then we clone it
        // as the source image format
        // Note: This is the most frequently used the scenario since we have
        // Image::Clone() which doesn't take any parameters.
        // And we have
        // GpImage* Clone() const
        // {
        //      return Clone(NULL, PixelFormatDontCare);
        // }

        format = SrcImageInfo.PixelFormat;
    }

    CopyOnWriteBitmap*   pRetBmp = NULL;

    // Flag to indicate if we need to undo the LoadIntoMemory() or not
    // Note: This flag will be set to TRUE iff the current State is "DecodedImg"
    // and this function does a LoadIntoMemory()

    BOOL        bNeedToDiscard = FALSE;

    // A non-identical clone will happen if:
    // 1) the caller wants clone only a portion of the source image
    // 2) the dest image has a different pixel format than the current one
    // A non-identical clone means the newly created image doesn't have any
    // connections to the original image in terms of FileName or Stream etc.
    // Note: For a non-identical clone, we don't clone the property items either

    BOOL        bIdenticalClone = TRUE;

    if ( (rect != NULL)
       &&(  (rect->X != 0)
         || (rect->Y != 0)
         || (rect->Width != (INT)SrcImageInfo.Width)
         || (rect->Height != (INT)SrcImageInfo.Height)
         || (SrcImageInfo.PixelFormat != format) ) )
    {
        bIdenticalClone = FALSE;
    }

    // If the image is:
    // 1) Not dirty
    // 2) We have an source image
    // 3) The image has been loaded into memory
    //
    // Then we need to throw away the memory copy. The reasons are:
    // 1) Avoid the color conversion failure. One example will be: if the
    //    source image is 1 bpp indexed and we load it into memory at 32 PARGB
    //    for drawing. If we don't throw away the 32PARGB copy in memory, we
    //    will fail the clone() because the color conversion will fail
    // 2) Keep property item intact. for example, if the image is 24 bpp with
    //    property items in it. But it was loaded into memory for some reason.
    //    If we don't throw away the memory copy here, the code below will fall
    //    into "else if ( State == MemBitmap )" case. Then it will call
    //    Bmp->Clone() to make another copy in memory. Since the source "Bmp"
    //    doesn't contain any property info. The cloned one won't have any
    //    property info either. See Windows bug#325413
    // 3) If current image is "Dirty", we don't need to keep property items.

    if ( (IsDirty() == FALSE)
       &&(State >= MemBitmap)
       &&(Img != NULL) )
    {
        ASSERT( Bmp != NULL )
        Bmp->Release();
        Bmp = NULL;
        State = DecodedImg;
        PixelFormatInMem = PixelFormatUndefined;
    }

    // We have to clone the image in memory if it is not an identical clone.
    // So if the image hasn't been loaded into memory yet, load it

    if ( (State == DecodedImg)
       &&(FALSE == bIdenticalClone) )
    {
        // Note: Due to some general pixel format conversion limitation in the
        // whole Engine, we try to avoid doing LoadIntoMemory(). Hopefully this
        // will be fixed sometime later. So I add a !!!TODO {minliu} here.
        // But for now, we have to load the current image into memory with the
        // desired pixel format and throw it away when we are done.

        if ( LoadIntoMemory(format) != Ok )
        {
            WARNING(("CopyOnWriteBitmap::Clone---LoadIntoMemory() failed"));
            return NULL;
        }

        bNeedToDiscard = TRUE;
    }

    // Do clone according to the current Image State

    if ( State == DecodedImg )
    {
        // Current source image hasn't been loaded and the caller wants to
        // clone the WHOLE image
        // Note: there are only two ways to construct a CopyOnWriteBitmap object
        // and with the State = DecodedImg: CopyOnWriteBitmap(IStream*) and
        // CopyOnWriteBitmap(WCHAR*). So what we need to do is to create a
        // CopyOnWriteBitmap object by calling the same constructor

        if ( this->Filename != NULL )
        {
            pRetBmp = new CopyOnWriteBitmap(this->Filename);
            if ( pRetBmp == NULL )
            {
                WARNING(("CopyOnWrite::Clone--new CopyOnWriteBitmap() failed"));
                return NULL;
            }
        }
        else if ( this->Stream != NULL )
        {
            pRetBmp = new CopyOnWriteBitmap(this->Stream);

            if ( pRetBmp == NULL )
            {
                WARNING(("CopyOnWrite::Clone--new CopyOnWriteBitmap() failed"));
                return NULL;
            }
        }
    }// State == DecodedImg
    else if ( State == MemBitmap )
    {
        // Current source image has already been loaded into memory
        // Note: the above checking (State == MemBitmap) might not be necessary.
        // But we leave it here just to prevent someone adds another state in
        // the State enum later.

        IBitmapImage* newbmp = NULL;
        HRESULT hResult;

        if ( rect == NULL )
        {
            hResult = Bmp->Clone(NULL, &newbmp, bIdenticalClone);
        }
        else
        {
            RECT r =
            {
                rect->X,
                rect->Y,
                rect->GetRight(),
                rect->GetBottom()
            };

            hResult = Bmp->Clone(&r, &newbmp, bIdenticalClone);
        }

        if ( FAILED(hResult) )
        {
            WARNING(("CopyOnWriteBitmap::Clone---Bmp->clone() failed"));
            goto cleanup;
        }

        // !!! TODO
        //  We assume that IBitmapImage is the very first
        //  interface implemented by GpMemoryBitmap class.

        pRetBmp = new CopyOnWriteBitmap((GpMemoryBitmap*)newbmp);

        if ( pRetBmp == NULL )
        {
            WARNING(("CopyOnWriteBmp::Clone---new CopyOnWriteBitmap() failed"));
            newbmp->Release();
            goto cleanup;
        }

        // Clone the source info as well if it is an identical clone

        if ( TRUE == bIdenticalClone )
        {
            if ( this->Filename != NULL )
            {
                pRetBmp->Filename = UnicodeStringDuplicate(this->Filename);
            }
            else if ( this->Stream != NULL )
            {
                pRetBmp->Stream = this->Stream;
                pRetBmp->Stream->AddRef();
            }
        }

        // Make sure clone has requested format. The reason we need to do this
        // is because the source image might have different pixel format as the
        // caller wants. This would be caused someone already did an
        // LoadIntoMemory() call on current object before this clone() is called

        PixelFormatID formatRetbmp;

        GpStatus status = pRetBmp->GetPixelFormatID(&formatRetbmp);

        if ( (status == Ok) && (format != formatRetbmp) )
        {
            status = pRetBmp->ConvertFormat(format, NULL, NULL);
        }

        if ( status != Ok )
        {
            WARNING(("CopyOnWrite:Clone-GetPixelFormatID() or Convert failed"));
            pRetBmp->Dispose();
            pRetBmp = NULL;
        }
    }// State == MemBitmap

cleanup:
    if ( bNeedToDiscard == TRUE )
    {
        // Throw away the memory bits we loaded in this function and restore
        // the State

        if ( Bmp != NULL )
        {
            Bmp->Release();
            Bmp = NULL;
            State = DecodedImg;
        }
    }

    // We need to check if the result of the clone is valid or not. If it is
    // not valid, we should return a NULL pointer

    if ( (pRetBmp != NULL) && (!pRetBmp->IsValid()) )
    {
        pRetBmp->Dispose();
        pRetBmp = NULL;
    }
    
    if (pRetBmp)
    {
        // copy internal state into the new CopyOnWriteBitmap.

        pRetBmp->ICMConvert = ICMConvert;
    }

    return pRetBmp;
}// Clone()

/**************************************************************************\
*
* Function Description:
*
*   Set the palette for this bitmap
*
* Arguments:
*
*   OUT palette - contains the palette.
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::SetPalette(
    ColorPalette *palette
)
{
    ASSERT(IsValid());

    GpStatus status;

    switch(State) {
    case ImageRef:
    case ExtStream:
        status = DereferenceStream();
        if(status != Ok) { return status; }
        // Put the image in at least DecodedImg state and
        // fallthrough

    case DecodedImg:
        // Get the info from the encoded image without forcing the codec
        // to decode the entire thing.

        // !!! TODO: Actually we don't yet have a way of setting the palette
        // directly from the codec.

        status = LoadIntoMemory(PIXFMT_DONTCARE);

        // Load into memory failed? Return the error code.

        if(status != Ok) { return status; }

        // !!! break; Fallthrough for now - till we get the codec query implemented

    case MemBitmap:
        {
            // We're already fully decoded, just set the information.

            HRESULT hr = Bmp->SetPalette(palette);

            // Did we fail to set the palette?

            if(hr != S_OK)
            {
                return GenericError;
            }

        }
    break;

    default:
        // All image states need to be handled above.
        // If we get in here, we have a CopyOnWriteBitmap in an invalid state or
        // someone added a new state and needs to update the switch above.
        ASSERT(FALSE);
        return InvalidParameter;
    }

    return Ok;
}


/**************************************************************************\
*
* Function Description:
*
*   Get the palette for this bitmap
*
* Arguments:
*
*   OUT palette - contains the palette.
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::GetPalette(
    ColorPalette *palette,
    INT size
)
{
    ASSERT(IsValid());
    ASSERT(palette != NULL);    // need a buffer to store the data in.

    if ( size < sizeof(ColorPalette) )
    {
        return InvalidParameter;
    }

    GpStatus status;

    switch(State) {
    case ImageRef:
    case ExtStream:
        status = DereferenceStream();
        if(status != Ok) { return status; }
        // Put the image in at least DecodedImg state and
        // fallthrough

    case DecodedImg:
        // Get the info from the encoded image without forcing the codec
        // to decode the entire thing.

        // !!! TODO: Actually we don't yet have a way of getting the palette
        // directly from the codec.

        status = LoadIntoMemory(PIXFMT_DONTCARE);

        // Load into memory failed? Return the error code.

        if(status != Ok) { return status; }

        // !!! break; Fallthrough for now - till we get the codec query implemented

    case MemBitmap:
        {
            // We're already fully decoded, just get the information.
            const ColorPalette *pal = Bmp->GetCurrentPalette();
            if(pal)
            {
                // Make sure the size is correct.
                if(size != (INT) (sizeof(ColorPalette)+(pal->Count-1)*sizeof(ARGB)) )
                {
                    return InvalidParameter;
                }
                // Copy the palette into the user buffer.
                GpMemcpy(palette, pal, sizeof(ColorPalette)+(pal->Count-1)*sizeof(ARGB));
            }
            else
            {
                // If there is no palette, we need to properly set the
                // ColorPalette structure.

                palette->Count = 0;
            }
        }
    break;

    default:
        // All image states need to be handled above.
        // If we get in here, we have a CopyOnWriteBitmap in an invalid state or
        // someone added a new state and needs to update the switch above.
        ASSERT(FALSE);
        return InvalidParameter;
    }

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Returns the size, in bytes, needed for holding a palette for this bitmap
*
* Arguments:
*
* Return Value:
*
*   The size, in bytes. Return 0 if there is no palette or something is wrong
*
* Note: should return -1 for something wrong.
*
\**************************************************************************/

INT
CopyOnWriteBitmap::GetPaletteSize(
    )
{
    ASSERT(IsValid());

    GpStatus status;

    switch(State)
    {
    case ImageRef:
    case ExtStream:
        status = DereferenceStream();

        if(status != Ok)
        {
            return 0;
        }

        // Put the image in at least DecodedImg state and
        // fallthrough

    case DecodedImg:
        // Get the info from the encoded image without forcing the codec
        // to decode the entire thing.

        // !!! TODO: Actually we don't yet have a way of getting the palette
        // directly from the codec.

        status = LoadIntoMemory(PIXFMT_DONTCARE);

        // Load into memory failed? Return a zero palette size.

        if ( status != Ok )
        {
            return 0;
        }

        // !!! break; Fallthrough for now - till we get the codec query implemented

    case MemBitmap:
        {
            // We're already fully decoded, just get the information.

            const ColorPalette *pal = Bmp->GetCurrentPalette();

            // Extract the size.

            if(pal)
            {
                return (sizeof(ColorPalette)+(pal->Count-1)*sizeof(ARGB));
            }
            else
            {
                // Note: if the image doesn't have a palette, we should still
                // return at least the size of a ColorPalette, not zero here.
                // The reason is to prevent some bad app which can cause GDI+'s
                // GetPalette() to AV, see bug#372163

                return sizeof(ColorPalette);
            }
        }
        break;

    default:
        // All image states need to be handled above.
        // If we get in here, we have a CopyOnWriteBitmap in an invalid state or
        // someone added a new state and needs to update the switch above.

        ASSERT(FALSE);
        return 0;
    }

    return 0;
}

/**************************************************************************\
*
* Function Description:
*
*   Returns total number of frames in the bitmap image
*
* Arguments:
*
*   dimensionID  - Dimension GUID the caller wants to query the count
*   count        - Total number of frames under specified dimension
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   11/19/1999 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::GetFrameCount(
    const GUID* dimensionID,
    UINT* count
    ) const
{
    ASSERT(IsValid());

    if ( Img == NULL )
    {
        // This CopyOnWriteBitmap is not created from a source image. It doesn't
        // have source Stream, nor source file name. It might be created
        // from a BITMAPINFO structure or a memory bitmap. But anyway, it has
        // one frame. So we return 1 here.

        *count = 1;
        return Ok;
    }

    HRESULT hResult = Img->GetFrameCount(dimensionID, count);

    if ( hResult == E_NOTIMPL )
    {
        return NotImplemented;
    }
    else if ( hResult != S_OK )
    {
        return Win32Error;
    }

    return Ok;
}// GetFrameCount()

/**************************************************************************\
*
* Function Description:
*
*     Get the total number of dimensions the image supports
*
* Arguments:
*
*     count -- number of dimensions this image format supports
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   03/20/2000 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::GetFrameDimensionsCount(
    UINT* count
    ) const
{
    ASSERT(IsValid());

    if ( count == NULL )
    {
        return InvalidParameter;
    }

    if ( Img == NULL )
    {
        // This CopyOnWriteBitmap is not created from a source image. It doesn't
        // have source Stream, nor source file name. It might be created
        // from a BITMAPINFO structure or a memory bitmap. But anyway, it has
        // one PAGE frame. So we set the return values accordingly.

        *count = 1;

        return Ok;
    }

    // Ask the lower level codec to give us the answer

    HRESULT hResult = Img->GetFrameDimensionsCount(count);

    if ( hResult == E_NOTIMPL )
    {
        return NotImplemented;
    }
    else if ( hResult != S_OK )
    {
        return Win32Error;
    }

    return Ok;
}// GetFrameDimensionsCount()

/**************************************************************************\
*
* Function Description:
*
*     Get an ID list of dimensions the image supports
*
* Arguments:
*
*     dimensionIDs---Memory buffer to hold the result ID list
*     count -- number of dimensions this image format supports
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   03/20/2000 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::GetFrameDimensionsList(
    GUID*   dimensionIDs,
    UINT    count
    ) const
{
    ASSERT(IsValid());

    if ( dimensionIDs == NULL )
    {
        return InvalidParameter;
    }

    if ( Img == NULL )
    {
        // This CopyOnWriteBitmap is not created from a source image. It doesn't
        // have source Stream, nor source file name. It might be created
        // from a BITMAPINFO structure or a memory bitmap. But anyway, it has
        // one PAGE frame. So we set the return values accordingly.
        // Note: in this case, the "count" has to be 1

        if ( count == 1 )
        {
            dimensionIDs[0] = FRAMEDIM_PAGE;

            return Ok;
        }
        else
        {
            return InvalidParameter;
        }
    }

    // Ask the lower level codec to give us the answer

    HRESULT hResult = Img->GetFrameDimensionsList(dimensionIDs, count);

    if ( hResult == E_NOTIMPL )
    {
        return NotImplemented;
    }
    else if ( hResult != S_OK )
    {
        return Win32Error;
    }

    return Ok;
}// GetFrameDimensionsList()

/**************************************************************************\
*
* Function Description:
*
*   Select active frame in a bitmap image
*
* Arguments:
*
*   dimensionID - dimension GUID used to specify which dimention you want to
*                 set the active frame, PAGE, TIMER, RESOLUTION
*   frameIndex -- Index number of the frame you want to set
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   11/19/1999 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::SelectActiveFrame(
    const GUID* dimensionID,
    UINT        frameIndex
    )
{
    ASSERT(IsValid());

    if ( frameIndex == CurrentFrameIndex )
    {
        // We are already at the required frame. Do nothing

        return Ok;
    }

    // Cannot move onto another frame if the current bits is locked

    if ( ObjRefCount > 1 )
    {
        return WrongState;
    }

    // Set active frame to caller asks for
    // Note: we don't need to validate the "frameIndex" range since the lower
    // level will return fail if the page number if not correct. By doing this
    // way, we avoid remembering the total number of frames in an image

    HRESULT hResult = S_OK;

    if ( Img == NULL )
    {
        // Try to create a GpDecodedImage*

        if ( NULL != Stream )
        {
            hResult = GpDecodedImage::CreateFromStream(Stream, &Img);
        }
        else if ( NULL != Filename )
        {
            hResult = GpDecodedImage::CreateFromFile(Filename, &Img);
        }
        else
        {
            // This CopyOnWriteBitmap is not created from a source image. It
            // might be created from a BITMAPINFO structure or a memory bitmap.
            // But anyway, the caller is allowed to call this function though it
            // is just a NO-OP.

            return Ok;
        }

        if ( FAILED(hResult) )
        {
            WARNING(("CopyOnWriteBitmap::SelectActiveFrame-Create Img failed"));
            return Win32Error;
        }
    }

    hResult = Img->SelectActiveFrame(dimensionID, frameIndex);

    if ( hResult == E_NOTIMPL )
    {
        return NotImplemented;
    }
    else if ( hResult != S_OK )
    {
        WARNING(("Bitmap::SelectActiveFrame--Img->SelectActiveFrame() failed"));
        return Win32Error;
    }

    // Get the image info of the new frame
    // Note: we can't overwrite our "SrcImageInfo" for now until all the OPs
    // are successful

    ImageInfo   tempImageInfo;
    hResult = Img->GetImageInfo(&tempImageInfo);

    if ( FAILED(hResult) )
    {
        return Win32Error;
    }

    // Create a temporary memory bitmap for the active frame.
    // Note: we can't release Bmp first and stick &Bmp in the call because
    // this call might fail. We don't want to lose the original if this happens

    GpMemoryBitmap* newbmp;

    hResult = GpMemoryBitmap::CreateFromImage(Img,
                                              0,
                                              0,
                                              tempImageInfo.PixelFormat,
                                              InterpolationHintDefault,
                                              &newbmp,
                                              NULL,
                                              NULL);

    if ( FAILED(hResult) )
    {
        return Win32Error;
    }

    // We can release the old one if there is one since we got the new frame
    // successfully
    // Note: it is possible there is no any old one because we haven't load the
    // image into memory yet (Bmp == NULL)

    if ( Bmp != NULL )
    {
        Bmp->Release();
    }

    Bmp = newbmp;
    State = MemBitmap;

    // Remember the image info of the source image and the pixel format in the
    // memory. They are the same at this moment

    GpMemcpy(&SrcImageInfo, &tempImageInfo, sizeof(ImageInfo));
    PixelFormatInMem = SrcImageInfo.PixelFormat;

    // Remember current frame index number

    CurrentFrameIndex = frameIndex;

    return Ok;
}// SelectActiveFrame()

/**************************************************************************\
*
* Function Description:
*
*   Get the count of property items in the image
*
* Arguments:
*
*   [OUT]numOfProperty - The number of property items in the image
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   02/28/2000 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::GetPropertyCount(
    UINT* numOfProperty
    )
{
    ASSERT(IsValid());

    // Check if we have a source image. Img is NULL means this CopyOnWriteBitmap
    // is not created from a source image.It might be created from a BITMAPINFO
    // structure or a memory bitmap.

    HRESULT hResult = S_OK;

    if ( Img != NULL )
    {
        hResult = Img->GetPropertyCount(numOfProperty);
    }
    else
    {
        ASSERT(Bmp != NULL);

        hResult = Bmp->GetPropertyCount(numOfProperty);
    }

    return MapHRESULTToGpStatus(hResult);
}// GetPropertyCount()

/**************************************************************************\
*
* Function Description:
*
*   Get a list of property IDs for all the property items in the image
*
* Arguments:
*
*   [IN]  numOfProperty - The number of property items in the image
*   [OUT] list----------- A memory buffer the caller provided for storing the
*                         ID list
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   02/28/2000 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::GetPropertyIdList(
    IN UINT numOfProperty,
    IN OUT PROPID* list
    )
{
    ASSERT(IsValid());

    // Check if we have a source image. Img is NULL means this CopyOnWriteBitmap
    // is not created from a source image.It might be created from a BITMAPINFO
    // structure or a memory bitmap.

    HRESULT hResult = S_OK;

    if ( Img != NULL )
    {
        hResult = Img->GetPropertyIdList(numOfProperty, list);
    }
    else
    {
        ASSERT(Bmp != NULL);
        hResult = Bmp->GetPropertyIdList(numOfProperty, list);
    }

    return MapHRESULTToGpStatus(hResult);
}// GetPropertyIdList()

/**************************************************************************\
*
* Function Description:
*
*   Get the size, in bytes, of a specific property item, specified by the
*   property ID
*
* Arguments:
*
*   [IN]propId - The ID of a property item caller is interested
*   [OUT]size--- Size of this property, in bytes
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   02/28/2000 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::GetPropertyItemSize(
    IN PROPID propId,
    OUT UINT* size
    )
{
    ASSERT(IsValid());

    HRESULT hResult = S_OK;

    // Check if we have a source image. Img is NULL means this CopyOnWriteBitmap
    // is not created from a source image.It might be created from a BITMAPINFO
    // structure or a memory bitmap.

    if ( Img != NULL )
    {
        hResult = Img->GetPropertyItemSize(propId, size);
    }
    else
    {
        ASSERT(Bmp != NULL);

        hResult = Bmp->GetPropertyItemSize(propId, size);
    }
    
    return MapHRESULTToGpStatus(hResult);
}// GetPropertyItemSize()

/**************************************************************************\
*
* Function Description:
*
*   Get a specific property item, specified by the prop ID.
*
* Arguments:
*
*   [IN]propId -- The ID of the property item caller is interested
*   [IN]propSize- Size of the property item. The caller has allocated these
*                 "bytes of memory" for storing the result
*   [OUT]pBuffer- A memory buffer for storing this property item
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   02/28/2000 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::GetPropertyItem(
    IN PROPID               propId,
    IN UINT                 propSize,
    IN OUT PropertyItem*    pBuffer
    )
{
    ASSERT(IsValid());

    // Check if we have a source image. Img is NULL means this CopyOnWriteBitmap
    // is not created from a source image.It might be created from a BITMAPINFO
    // structure or a memory bitmap.

    HRESULT hResult = S_OK;

    if ( Img != NULL )
    {
        hResult = Img->GetPropertyItem(propId, propSize, pBuffer);
    }
    else
    {
        ASSERT(Bmp != NULL);
        hResult = Bmp->GetPropertyItem(propId, propSize, pBuffer);
    }
    
    return MapHRESULTToGpStatus(hResult);
}// GetPropertyItem()

/**************************************************************************\
*
* Function Description:
*
*   Get the size of ALL property items in the image
*
* Arguments:
*
*   [OUT]totalBufferSize-- Total buffer size needed, in bytes, for storing all
*                          property items in the image
*   [OUT]numOfProperty --- The number of property items in the image
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   02/28/2000 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::GetPropertySize(
    OUT UINT* totalBufferSize,
    OUT UINT* numProperties
    )
{
    ASSERT(IsValid());

    // Check if we have a source image. Img is NULL means this CopyOnWriteBitmap
    // is not created from a source image.It might be created from a BITMAPINFO
    // structure or a memory bitmap.

    HRESULT hResult = S_OK;

    if ( Img != NULL )
    {
        hResult = Img->GetPropertySize(totalBufferSize, numProperties);
    }
    else
    {
        ASSERT(Bmp != NULL);
        hResult = Bmp->GetPropertySize(totalBufferSize, numProperties);
    }

    return MapHRESULTToGpStatus(hResult);
}// GetPropertySize()

/**************************************************************************\
*
* Function Description:
*
*   Get ALL property items in the image
*
* Arguments:
*
*   [IN]totalBufferSize-- Total buffer size, in bytes, the caller has allocated
*                         memory for storing all property items in the image
*   [IN]numOfProperty --- The number of property items in the image
*   [OUT]allItems-------- A memory buffer caller has allocated for storing all
*                         the property items
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   02/28/2000 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::GetAllPropertyItems(
    IN UINT totalBufferSize,
    IN UINT numProperties,
    IN OUT PropertyItem* allItems
    )
{
    ASSERT(IsValid());

    // Check if we have a source image. Img is NULL means this CopyOnWriteBitmap
    // is not created from a source image.It might be created from a BITMAPINFO
    // structure or a memory bitmap.

    HRESULT hResult = S_OK;

    if ( Img != NULL )
    {
        hResult = Img->GetAllPropertyItems(totalBufferSize, numProperties,
                                           allItems);
    }
    else
    {
        ASSERT(Bmp != NULL);
        hResult = Bmp->GetAllPropertyItems(totalBufferSize, numProperties,
                                           allItems);
    }

    return MapHRESULTToGpStatus(hResult);
}// GetAllPropertyItems()

/**************************************************************************\
*
* Function Description:
*
*   Remove a specific property item, specified by the prop ID.
*
* Arguments:
*
*   [IN]propId -- The ID of the property item to be removed
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   02/28/2000 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::RemovePropertyItem(
    IN PROPID   propId
    )
{
    ASSERT(IsValid());

    // Check if we have a source image. Img is NULL means this CopyOnWriteBitmap
    // is not created from a source image.It might be created from a BITMAPINFO
    // structure or a memory bitmap.

    HRESULT hResult = S_OK;

    if ( Img != NULL )
    {
        hResult = Img->RemovePropertyItem(propId);
    }
    else
    {
        ASSERT(Bmp != NULL);
        hResult = Bmp->RemovePropertyItem(propId);
    }

    return MapHRESULTToGpStatus(hResult);
}// RemovePropertyItem()

/**************************************************************************\
*
* Function Description:
*
*   Set a property item, specified by the propertyitem structure. If the item
*   already exists, then its contents will be updated. Otherwise a new item
*   will be added
*
* Arguments:
*
*   [IN]item -- A property item the caller wants to set
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   02/28/2000 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::SetPropertyItem(
    IN PropertyItem* item
    )
{
    if ( item == NULL )
    {
        WARNING(("CopyOnWriteBitmap::SetPropertyItem-Invalid input parameter"));
        return InvalidParameter;
    }

    ASSERT(IsValid());

    HRESULT hResult = S_OK;

    // Check if we have a source image. Img is NULL means this CopyOnWriteBitmap
    // is not created from a source image.It might be created from a BITMAPINFO
    // structure or a memory bitmap.
    // If "SpecialJPEGSave" is TRUE, it means, the image has been rotated in
    // memory, but the "Img" pointer might not be released yet

    if (( Img != NULL ) && (SpecialJPEGSave == FALSE))
    {
        hResult = Img->SetPropertyItem(*item);
    }
    else
    {
        ASSERT(Bmp != NULL);

        hResult = Bmp->SetPropertyItem(*item);
    }

    return MapHRESULTToGpStatus(hResult);
}// SetPropertyItem()

/**************************************************************************\
*
* Function Description:
*
*   Get bitmap image thumbnail
*
* Arguments:
*
*   thumbWidth, thumbHeight - Desired width and height of thumbnail
*       Both zero means pick a default size
*
* Return Value:
*
*   Pointer to the new thumbnail image object
*   NULL if there is an error
*
\**************************************************************************/

CopyOnWriteBitmap *
CopyOnWriteBitmap::GetThumbnail(
    UINT thumbWidth,
    UINT thumbHeight,
    GetThumbnailImageAbort callback,
    VOID *callbackData
    )
{
    ASSERT(IsValid());

    HRESULT hr = S_OK;
    IImage *newImage = NULL;

    // Ask the lower level codec to give us the thumbnail stored in the image.
    // Note: If there is no thumbnail stored in the original image, this
    // function will return us a scaled version of the original image as the
    // thumbnail image, at DEFAULT_THUMBNAIL_SIZE
    // Note: Img might be zero, it means this CopyOnWriteBitmap is not created from an
    // stream or file. It might be created from an memory buffer or something
    // else. One scenario will be Do a GetThumbnail() and then do another
    // GetThumbnail from this thumbnail. Though it is a weird scenario. But it
    // could happen. So if the Img is NULL, then we create a thumbnail from
    // the memory bitmap

    if ( Img != NULL )
    {
        hr = Img->GetThumbnail(thumbWidth, thumbHeight, &newImage);
    }
    else
    {
        GpStatus status = LoadIntoMemory();

        if ( status != Ok )
        {
            return NULL;
        }

        hr = Bmp->GetThumbnail(thumbWidth, thumbHeight, &newImage);
    }

    if ( FAILED(hr) )
    {
        return NULL;
    }

    // Create a GpMemoryBitmap from IImage

    ImageInfo   srcImageInfo;
    newImage->GetImageInfo(&srcImageInfo);

    GpMemoryBitmap* pMemBitmap;

    hr = GpMemoryBitmap::CreateFromImage(newImage,
                                         srcImageInfo.Width,
                                         srcImageInfo.Height,
                                         srcImageInfo.PixelFormat,
                                         InterpolationHintDefault,
                                         &pMemBitmap,
                                         (DrawImageAbort) callback,
                                         callbackData
                                         );

    // Release the COM obj IImage

    newImage->Release();

    if ( FAILED(hr) )
    {
        return NULL;
    }

    CopyOnWriteBitmap* thumbBitmap = new CopyOnWriteBitmap(pMemBitmap);

    return thumbBitmap;
}

/**************************************************************************\
*
* Function Description:
*
*   Access bitmap pixel data
*
* Arguments:
*
*   rect - Specifies the interested image area
*       NULL means the entire image
*   flags - Desired access mode
*   format - Desired pixel format
*   bmpdata - Returns information about bitmap pixel data
*   width,
*   height  - suggested width and height to decode to.
*             zero is the source image width and height.
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::LockBits(
    const GpRect* rect,
    UINT flags,
    PixelFormatID format,
    BitmapData* bmpdata,
    INT width,
    INT height
) const
{
    ASSERT(IsValid());
    ASSERT(width>=0);
    ASSERT(height>=0);

    // LockBits cannot be nested

    if ( ObjRefCount > 1 )
    {
        return WrongState;
    }

    // Do some sanity check to see if we can do it or not

    if ( (format == PIXFMT_DONTCARE)
       ||(!IsValidPixelFormat(format)) )
    {
        // Wrong pixel format

        WARNING(("CopyOnWriteBitmap::LockBits---invalid format"));
        return InvalidParameter;
    }

    // Valid format. If the lock is for READ, we need to check if we can
    // convert the current source to this format

    EpFormatConverter linecvt;

    if ( flags & ImageLockModeRead )
    {
        if ( IsDirty() == FALSE )
        {
            if ( linecvt.CanDoConvert(SrcImageInfo.PixelFormat, format)==FALSE )
            {
                WARNING(("LockBits--can't convert src to specified fmt"));
                return InvalidParameter;
            }
        }
        else if (linecvt.CanDoConvert(PixelFormatInMem, format) == FALSE )
        {
            WARNING(("LockBits--can't convert src to specified fmt"));
            return InvalidParameter;
        }
    }

    // If the lock is for WRITE, we need to check if we can convert the format
    // back to current source format. The reason we need to do this checking is
    // when the user calls UnLockBits() after he has modified the locked area,
    // we need to convert this small area back to the format the whole image is
    // at. E.x. For an 4 bpp image, the caller can lock a small area at 32 bpp
    // (this makes the app code easier), do some pixel modification on that
    // area, unlock it. We need to convert that small area back to 4 bpp.

    if ( flags & ImageLockModeWrite )
    {
        if ( IsDirty() == FALSE )
        {
            if ( linecvt.CanDoConvert(format, SrcImageInfo.PixelFormat)==FALSE )
            {
                WARNING(("LockBits--can't convert specified fmt back to src"));
                return InvalidParameter;
            }
        }
        else if (linecvt.CanDoConvert(format, PixelFormatInMem) == FALSE )
        {
            WARNING(("LockBits--can't convert specified format back to src"));
            return InvalidParameter;
        }
    }

    HRESULT hr;

    if ( (IsDirty() == FALSE)
       &&(State >= MemBitmap)
       &&(format != PixelFormatInMem)
       &&(SrcImageInfo.PixelFormat != PixelFormatInMem)
       &&(Img != NULL) )
    {
        // If the image is:
        // 1) Not dirty
        // 2) Was loaded into memory with different color depth for some reason,
        //    like DrawImage()
        // 3) The color depth the caller wants to locked for is different than
        //    the one in memory
        // 4) We have an source image
        //
        // Then we can throw away the bits in memory and reload the bits from
        // the original with the color depth user asks for. The purpose of this
        // is to increase the success rate for LockBits(). One of the problem
        // we are having now is that our DrawImage() always load image into
        // memory at 32PARGB format. This makes tasks like printing very
        // expensive because it has to send 32PARGB format to the print. We'd
        // like to send the original color depth to the printer
        //
        // Note: this "throw away" approach won't hurt our DrawImage() work flow
        // Here is the reason why: say we have a 4 bpp source image. We do a
        // DrawImage() first, thus we load it into memory at 32 PARGB. When the
        // printing request coming. It prefers to send down 4bpp to the printer.
        // So we through away the 32 PARGB in memory and reload the image in
        // 4 bpp mode and send it to printer. Later on, if DrawImage() is called
        // again. It can still pass the above "if" checking condition and reload
        // the image in as 32 PARGB.

        ASSERT( Bmp != NULL )
        Bmp->Release();
        Bmp = NULL;
        State = DecodedImg;
        PixelFormatInMem = PixelFormatUndefined;
    }

    // Load the image into memory using the suggested width and height.
    // if the suggested width and height are zero, use the source
    // image width and height.
    // Load the image into memory before querying the pixel format because
    // the load could potentially change the in-memory format.

    GpStatus status = LoadIntoMemory(format, NULL, NULL, width, height);

    if (status != Ok)
    {
        WARNING(("CopyOnWriteBitmap::LockBits()----LoadIntoMemory() failed"));
        return status;
    }

    if ( rect == NULL )
    {
        hr = Bmp->LockBits(NULL, flags, format, bmpdata);
    }
    else
    {
        RECT r =
        {
            rect->X,
            rect->Y,
            rect->GetRight(),
            rect->GetBottom()
        };

        hr = Bmp->LockBits(&r, flags, format, bmpdata);
    }

    if ( FAILED(hr) )
    {
        WARNING(("CopyOnWriteBitmap::LockBits()----LockBits() failed"));
        return (MapHRESULTToGpStatus(hr));
    }

    ObjRefCount++;

    if ( flags & ImageLockModeWrite )
    {
        // Mark the bits dirty since the user might have changed the bits during
        // the lock period

        SetDirtyFlag(TRUE);
    }

    return Ok;
}// LockBits()

GpStatus
CopyOnWriteBitmap::UnlockBits(
    BitmapData* bmpdata,
    BOOL Destroy
) const
{
    ASSERT(ObjRefCount == 2);

    if ( NULL == Bmp )
    {
        // The caller should not call UnlockBits() if it hasn't called
        // LockBits() yet

        WARNING(("UnlockBits---Call UnlockBits() without calling LockBits()"));
        return GenericError;
    }

    HRESULT hr = Bmp->UnlockBits(bmpdata);
    ObjRefCount--;

    // Called to destroy the decoded bits because we decoded a partial image
    // and it won't be valid on the next call.

    if(Destroy)
    {
        // Revert the state back to DecodedImg (which means not decoded).

        ASSERT(Img != NULL);
        delete Bmp;
        Bmp = NULL;
        State = DecodedImg;
    }

    if (FAILED(hr))
    {
        WARNING(("GpBitmap::UnlockBits---Bmp->UnlockBits() failed"));
        return (MapHRESULTToGpStatus(hr));
    }

    return Ok;
}// UnlockBits()

/**************************************************************************\
*
* Function Description:
*
*   Get a pixel
*
* Arguments:
*
*   IN x, y: Coordinates of the pixel to get.
*   OUT color: color value of the specified pixel.
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::GetPixel(INT x, INT y, ARGB *color)
{
    // Get the bitmap info.
    BitmapData bmpData;

    // Only lock the required rectangle.
    GpRect pixelRect(x, y, 1, 1);

    GpStatus status = LockBits(
        &pixelRect,
        IMGLOCK_READ,
        PIXFMT_32BPP_ARGB,
        &bmpData
    );

    // Failed to lock the bits.
    if(status != Ok)
    {
        return(status);
    }

    ARGB *pixel = static_cast<ARGB *>(bmpData.Scan0);
    *color = *pixel;

    return UnlockBits(&bmpData);
}

/**************************************************************************\
*
* Function Description:
*
*   Set a pixel
*
* Arguments:
*
*   IN x, y: Coordinates of the pixel to set.
*   IN color: color value for the specified pixel.
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::SetPixel(INT x, INT y, ARGB color)
{
    // Get the bitmap info.
    BitmapData bmpData;

    // Only lock the required rectangle.
    GpRect pixelRect(x, y, 1, 1);

    GpStatus status = LockBits(
        &pixelRect,
        IMGLOCK_WRITE,
        PIXFMT_32BPP_ARGB,
        &bmpData
    );

    // Failed to lock the bits.
    if(status != Ok)
    {
        return(status);
    }

    ARGB* pixel = static_cast<ARGB *>(bmpData.Scan0);
    *pixel = color;

    return UnlockBits(&bmpData);
}

/**************************************************************************\
*
* Function Description:
*
*   Convert bitmap image to a different pixel format
*
* Arguments:
*
*   format - Specifies the new pixel format
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::ConvertFormat(
    PixelFormatID format,
    DrawImageAbort callback,
    VOID *callbackData
    )
{
    ASSERT(ObjRefCount == 1);

    // If bitmap not in memory yet, simply force load using specified format:

    if ( State < MemBitmap )
    {
        return LoadIntoMemory(format, callback, callbackData);
    }

    HRESULT hr;

    if ( PixelFormatInMem != format)
    {
        GpMemoryBitmap* newbmp;

        hr = GpMemoryBitmap::CreateFromImage(
                    Bmp,
                    0,
                    0,
                    format,
                    InterpolationHintDefault,
                    &newbmp,
                    callback,
                    callbackData);

        if ( FAILED(hr) )
        {
            WARNING(("CopyOnWriteBitmap::ConvertFormat---CreateFromImage() failed"));
            return OutOfMemory;
        }

        Bmp->Release();
        Bmp = newbmp;

        PixelFormatInMem = format;

        // We change the source pixel format info as well because this image
        // is dirty now and we should not convert it back to original format

        SrcImageInfo.PixelFormat = format;

        // Mark the bits dirty since the original image bits got changed

        // !!! TODO: we can't set it dirty for now because DrawImage() always
        // convert an image to 32 bpp first. When this temporary solution is removed
        // we should reset this flag
        //
        // SetDirtyFlag(TRUE);
    }

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Derive a graphics context on top of the bitmap object
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Pointer to the derived graphics context
*   NULL if there is an error
*
\**************************************************************************/

/******************************Public*Routine******************************\
*
* Function Description:
*
*   Derive an HDC on top of the bitmap object for GDI interop
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   HDC with a bitmap selected into it that is associated with this GDI+
*   bitmap.
*   NULL if there is an error
*
\**************************************************************************/

HDC
CopyOnWriteBitmap::GetHdc()
{
    HDC hdc = NULL;
    HBITMAP hbm = NULL;

    // Create the HDC and HBITMAP if needed.

    if (InteropData.Hdc == NULL)
    {
        ImageInfo imageInfo;

        CopyOnWriteBitmap::GetImageInfo(&imageInfo);

        hdc = CreateCompatibleDC(NULL);

        if (hdc == NULL)
        {
            goto cleanup_exit;
        }

        BITMAPINFO gdiBitmapInfo;

        gdiBitmapInfo.bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
        gdiBitmapInfo.bmiHeader.biWidth         = imageInfo.Width;
        gdiBitmapInfo.bmiHeader.biHeight        = - static_cast<LONG>
                                                    (imageInfo.Height);
        gdiBitmapInfo.bmiHeader.biPlanes        = 1;
        gdiBitmapInfo.bmiHeader.biBitCount      = 32;
        gdiBitmapInfo.bmiHeader.biCompression   = BI_RGB;
        gdiBitmapInfo.bmiHeader.biSizeImage     = 0;
        gdiBitmapInfo.bmiHeader.biXPelsPerMeter = 0;
        gdiBitmapInfo.bmiHeader.biYPelsPerMeter = 0;
        gdiBitmapInfo.bmiHeader.biClrUsed       = 0;
        gdiBitmapInfo.bmiHeader.biClrImportant  = 0;

        hbm = CreateDIBSection(hdc,
                               &gdiBitmapInfo,
                               DIB_RGB_COLORS,
                               &InteropData.Bits,
                               NULL,
                               0);

        DIBSECTION gdiDibInfo;

        if ((hbm == NULL) ||
            (GetObjectA(hbm, sizeof(gdiDibInfo), &gdiDibInfo) == 0) ||
            (gdiDibInfo.dsBmih.biSize == 0) ||
            (SelectObject(hdc, hbm) == NULL))
        {
            goto cleanup_exit;
        }

        InteropData.Hdc = hdc;
        InteropData.Hbm = hbm;

        InteropData.Width  = imageInfo.Width;
        InteropData.Height = imageInfo.Height;
        InteropData.Stride = gdiDibInfo.dsBm.bmWidthBytes;

        // Since it's a 32bpp bitmap, we can assume that a tightly packed
        // bitmap is already satisfies the scanline align constraints
        // (letting us fill the bitmap with a very simple loop).
        ASSERT(gdiDibInfo.dsBm.bmWidthBytes == static_cast<LONG>(imageInfo.Width * 4));
    }

    ASSERT(InteropData.Hdc != NULL);

    // Fill the bitmap with a sentinal pattern.

    {
        INT count = InteropData.Width * InteropData.Height;
        UINT32 *bits = static_cast<UINT32*>(InteropData.Bits);

        while (count--)
        {
            *bits++ = GDIP_TRANSPARENT_COLOR_KEY;
        }
    }

    return InteropData.Hdc;

cleanup_exit:

    if (hdc)
        DeleteDC(hdc);

    if (hbm)
        DeleteObject(hbm);

    return reinterpret_cast<HDC>(NULL);
}


/******************************Public*Routine******************************\
*
* Function Description:
*
*   Release the HDC returned by CopyOnWriteBitmap::GetHdc.  If necessary, updates
*   the GDI+ bitmap with the GDI drawing (may not be necessary if the
*   GDI and GDI+ bitmaps share a common underlying pixel buffer).
*
* Arguments:
*
*   HDC to release
*
* Return Value:
*
*   Pointer to the derived graphics context
*   NULL if there is an error
*
\**************************************************************************/

VOID
CopyOnWriteBitmap::ReleaseHdc(HDC hdc)
{
    ASSERT(hdc == InteropData.Hdc);

    GdiFlush();

    // Scan the GDI bitmap to see if any of the sentinal pixels have changed.
    // If any are detected, copy it to the GDI+ bitmap with opaque alpha set.

    int curRow, curCol;
    BYTE *interopScan = static_cast<BYTE*>(InteropData.Bits);

    GpStatus status = Ok;

    for (curRow = 0; (curRow < InteropData.Height) && (status == Ok); curRow++)
    {
        BOOL rowLocked = FALSE;
        BitmapData bitmapData;

        ARGB *interopPixel = static_cast<ARGB*>(static_cast<VOID*>(interopScan));
        ARGB *pixel = NULL;

        for (curCol = 0; curCol < InteropData.Width; curCol++)
        {
            if ((*interopPixel & 0x00ffffff) != GDIP_TRANSPARENT_COLOR_KEY)
            {
                if (!rowLocked)
                {
                    GpRect lockRect(0, curRow, InteropData.Width, 1);

                    status = LockBits(&lockRect,
                                      IMGLOCK_READ | IMGLOCK_WRITE,
                                      PIXFMT_32BPP_ARGB,
                                      &bitmapData);

                    if (status == Ok)
                    {
                        pixel = static_cast<ARGB*>(bitmapData.Scan0) + curCol;
                        rowLocked = TRUE;
                    }
                    else
                    {
                        break;
                    }
                }

                *pixel = *interopPixel | 0xFF000000;
            }

            interopPixel++;
            pixel++;
        }

        if (rowLocked)
            UnlockBits(&bitmapData);

        interopScan += InteropData.Stride;
    }
}

// Data flags
#define COMPRESSED_IMAGE 0x00000001

class BitmapRecordData : public ObjectTypeData
{
public:
    INT32       Width;
    INT32       Height;
    INT32       Stride;
    INT32       PixelFormat;
    INT32       Flags;
};

/**************************************************************************\
*
* Function Description:
*
*   Get the bitmap data.
*
* Arguments:
*
*   [IN] dataBuffer - fill this buffer with the data
*   [IN/OUT] size   - IN - size of buffer; OUT - number bytes written
*
* Return Value:
*
*   GpStatus - Ok or error code
*
* Created:
*
*   9/13/1999 DCurtis
*
\**************************************************************************/
GpStatus
CopyOnWriteBitmap::GetData(
    IStream *   stream
    ) const
{
    ASSERT(stream);

    GpStatus            status;
    BitmapRecordData    bitmapRecordData;

    IStream*    imageStream = NULL;
    STATSTG     statStg;
    BOOL        needRelease = FALSE;

    // variables used to track the stream state

    LARGE_INTEGER zero = {0,0};
    LARGE_INTEGER oldPos;
    BOOL          isSeekableStream = FALSE;

    // try to get a imageStream

    if (!IsDirty())
    {
        HRESULT hr;

        if (Stream != NULL)
        {
            hr = Stream->Seek(zero, STREAM_SEEK_CUR, (ULARGE_INTEGER *)&oldPos);

            if (SUCCEEDED(hr))
            {
                hr = Stream->Seek(zero, STREAM_SEEK_SET, NULL);

                if (SUCCEEDED(hr))
                {
                    isSeekableStream = TRUE;
                    imageStream = Stream;
                }
            }
        }

        // if we don't have a CopyOnWriteBitmap::Stream but we have a filename

        if ((imageStream == NULL) && (Filename != NULL))
        {
            hr = CreateStreamOnFileForRead(Filename, &imageStream);

            if (SUCCEEDED(hr))
            {
                needRelease = TRUE;
            }
        }

    }

    // try to write the imageStream out to the metafile Stream
    if (imageStream && imageStream->Stat(&statStg, STATFLAG_NONAME) == S_OK)
    {
        bitmapRecordData.Type        = ImageTypeBitmap;
        bitmapRecordData.Width       = 0;
        bitmapRecordData.Height      = 0;
        bitmapRecordData.Stride      = 0;
        bitmapRecordData.PixelFormat = 0;
        bitmapRecordData.Flags       = COMPRESSED_IMAGE;
        stream->Write(&bitmapRecordData, sizeof(bitmapRecordData), NULL);

        // Read data from the imageStream into the dest stream
        // Unfortunately, we can't assume that CopyTo has been implemented.
        // Is there some way to find out? !!!
    #define COPY_BUFFER_SIZE    2048

        BYTE    buffer[COPY_BUFFER_SIZE];
        UINT    streamSize  = statStg.cbSize.LowPart;
        UINT    sizeToRead  = COPY_BUFFER_SIZE;
        UINT    numPadBytes = 0;

        if ((streamSize & 0x03) != 0)
        {
            numPadBytes = 4 - (streamSize & 0x03);
        }

        status = Ok;

        if (status == Ok)
        {
            HRESULT hr;
            ULONG bytesRead = 0;
            ULONG bytesWrite = 0;

            while (streamSize > 0)
            {
                if (sizeToRead > streamSize)
                {
                    sizeToRead = streamSize;
                }

                hr = imageStream->Read(buffer, sizeToRead, &bytesRead);

                if (!SUCCEEDED(hr) || (sizeToRead != bytesRead))
                {
                    WARNING(("Failed to read stream in CopyOnWriteBitmap::GetData"));
                    status = Win32Error;
                    break;
                }

                hr = stream->Write(buffer, sizeToRead, &bytesWrite);

                if (!SUCCEEDED(hr) || (sizeToRead != bytesWrite))
                {
                    WARNING(("Failed to write stream in CopyOnWriteBitmap::GetData"));
                    status = Win32Error;
                    break;
                }

                streamSize -= sizeToRead;
            }

            // align
            if (numPadBytes > 0)
            {
                INT     pad = 0;
                stream->Write(&pad, numPadBytes, NULL);
            }
        }

        if (isSeekableStream)
        {
            // move back to the old pos
            Stream->Seek(oldPos, STREAM_SEEK_SET, NULL);
        }

        if (needRelease)
        {
            imageStream->Release();
        }

        return status;
    }

    // we can't record compressed data, record the uncompressed data

    if ((status = (const_cast<CopyOnWriteBitmap *>(this))->LoadIntoMemory()) != Ok)
    {
        WARNING(("Couldn't load the image into memory"));
        return status;
    }

    BitmapData  bitmapData     = *Bmp;
    INT         positiveStride = bitmapData.Stride;
    BOOL        upsideDown     = FALSE;
    INT         paletteSize    = 0;
    INT         pixelDataSize;

    if (positiveStride < 0)
    {
        positiveStride = -positiveStride;
        upsideDown = TRUE;
    }

    pixelDataSize = (bitmapData.Height * positiveStride);

    if (IsIndexedPixelFormat(bitmapData.PixelFormat))
    {
        // We're an indexed pixel format - must have a valid palette.
        ASSERT(Bmp->colorpal != NULL);

        // Note sizeof(ColorPalette) includes the first palette entry.
        paletteSize = sizeof(ColorPalette) +
                      sizeof(ARGB)*(Bmp->colorpal->Count-1);
    }

    bitmapRecordData.Type        = ImageTypeBitmap;
    bitmapRecordData.Width       = bitmapData.Width;
    bitmapRecordData.Height      = bitmapData.Height;
    bitmapRecordData.Stride      = positiveStride;
    bitmapRecordData.PixelFormat = bitmapData.PixelFormat;
    bitmapRecordData.Flags       = 0;
    stream->Write(&bitmapRecordData, sizeof(bitmapRecordData), NULL);

    if (paletteSize > 0)
    {
        // Write out the palette
        stream->Write(Bmp->colorpal, paletteSize, NULL);
    }

    if (pixelDataSize > 0)
    {
        if (!upsideDown)
        {
            stream->Write(bitmapData.Scan0, pixelDataSize, NULL);
        }
        else
        {
            BYTE *      scan = (BYTE *)bitmapData.Scan0;
            for (INT i = bitmapData.Height; i > 0; i--)
            {
                stream->Write(scan, positiveStride, NULL);
                scan -= positiveStride;
            }
        }
    }

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Get the compressed image data.
*
* Arguments:
*
*   OUT compressed_data
*
* Return Value:
*
*   GpStatus - Ok or error code
*
* Created:
*
\**************************************************************************/
GpStatus
CopyOnWriteBitmap::GetCompressedData(
    DpCompressedData * compressed_data,
    BOOL getJPEG,
    BOOL getPNG,
    HDC hdc
    )
{
    GpStatus    status = Ok;

    IStream*    imageStream = NULL;
    STATSTG     statStg;
    BOOL        needRelease = FALSE;

    // variables used to track the stream state

    LARGE_INTEGER zero = {0,0};
    LARGE_INTEGER oldPos;
    BOOL          isSeekableStream = FALSE;

    ASSERT(compressed_data->buffer == NULL);

    if (Img)
    {
        if (SrcImageInfo.RawDataFormat == IMGFMT_JPEG)
        {
            if (!getJPEG)
            {
                return Ok;
            }
            compressed_data->format = BI_JPEG;
        }
        else if (SrcImageInfo.RawDataFormat == IMGFMT_PNG)
        {
            if (!getPNG)
            {
                return Ok;
            }
            compressed_data->format = BI_PNG;
        }
        else
            return Ok;
    }
    else
    {
        WARNING(("GetCompressedData: Decoded image not available."));
        return Ok;
    }
    // try to get a imageStream

    if (!IsDirty())
    {
        HRESULT hr;

        if (Stream != NULL)
        {
            hr = Stream->Seek(zero, STREAM_SEEK_CUR, (ULARGE_INTEGER *)&oldPos);

            if (SUCCEEDED(hr))
            {
                hr = Stream->Seek(zero, STREAM_SEEK_SET, NULL);

                if (SUCCEEDED(hr))
                {
                    isSeekableStream = TRUE;
                    imageStream = Stream;
                }
            }
        }

        // if we don't have a CopyOnWriteBitmap::Stream but we have a filename

        if ((imageStream == NULL) && (Filename != NULL))
        {
            hr = CreateStreamOnFileForRead(Filename, &imageStream);

            if (SUCCEEDED(hr))
            {
                needRelease = TRUE;
            }
        }

    }

    if (imageStream && (imageStream->Stat(&statStg, STATFLAG_NONAME) == S_OK))
    {
        UINT streamSize  = statStg.cbSize.LowPart;
        ULONG bytesRead = 0;

        VOID * buffer = (PVOID)GpMalloc(streamSize);

        if (buffer)
        {
            HRESULT hr;

            hr = imageStream->Read(buffer, streamSize, &bytesRead);

            if (!SUCCEEDED(hr) || (streamSize != bytesRead))
            {
                WARNING(("Failed to read stream in CopyOnWriteBitmap::GetData"));
                status = Win32Error;
            }
            else
            {
                compressed_data->bufferSize = streamSize;
                compressed_data->buffer = buffer;
            }
        }
        else
        {
            WARNING(("Out of memory"));
            status = OutOfMemory;
        }
    }

    if (isSeekableStream)
    {
        // move back to the old pos
        Stream->Seek(oldPos, STREAM_SEEK_SET, NULL);
    }

    if (needRelease)
    {
        imageStream->Release();
    }

    if ((hdc != NULL) && (compressed_data->buffer != NULL))
    {
        DWORD EscapeValue = (compressed_data->format == BI_JPEG) ?
                             CHECKJPEGFORMAT : CHECKPNGFORMAT;

        DWORD result = 0;

        // Call escape to determine if this particular image is supported
        if ((ExtEscape(hdc,
                      EscapeValue,
                      compressed_data->bufferSize,
                      (LPCSTR)compressed_data->buffer,
                      sizeof(DWORD),
                      (LPSTR)&result) <= 0) || (result != 1))
        {
            // Failed to support passthrough of this image, delete the
            // compressed bits.

            DeleteCompressedData(compressed_data);
        }
    }

    return status;
}

GpStatus
CopyOnWriteBitmap::DeleteCompressedData(
    DpCompressedData * compressed_data
    )
{
    GpStatus    status = Ok;

    if (compressed_data && compressed_data->buffer)
    {
        GpFree(compressed_data->buffer);
        compressed_data->buffer = NULL;
    }

    return status;
}


UINT
CopyOnWriteBitmap::GetDataSize() const
{
    UINT    dataSize = 0;

    // if CopyOnWriteBitmap is not dirty, we look at compressed data

    if (!IsDirty())
    {
        STATSTG     statStg;
        HRESULT     hr;

        if (Stream != NULL)
        {
            // variables used to track the stream state
            LARGE_INTEGER zero = {0,0};
            LARGE_INTEGER oldPos;
            BOOL          isSeekableStream = FALSE;

            hr = Stream->Seek(zero, STREAM_SEEK_CUR, (ULARGE_INTEGER *)&oldPos);

            if (SUCCEEDED(hr))
            {
                hr = Stream->Seek(zero, STREAM_SEEK_SET, NULL);

                if (SUCCEEDED(hr))
                {
                    if (Stream->Stat(&statStg, STATFLAG_NONAME) == S_OK)
                    {
                        dataSize = sizeof(BitmapRecordData) + statStg.cbSize.LowPart;
                    }

                    // move back to the old pos

                    Stream->Seek(oldPos, STREAM_SEEK_SET, NULL);

                    return ((dataSize + 3) & (~3)); // align

                }
            }

        }

        if (Filename != NULL)
        {
            IStream* stream = NULL;

            hr = CreateStreamOnFileForRead(Filename, &stream);

            if (SUCCEEDED(hr))
            {
                if (stream->Stat(&statStg, STATFLAG_NONAME) == S_OK)
                {
                    dataSize = sizeof(BitmapRecordData) + statStg.cbSize.LowPart;
                }

                stream->Release();
            }

            return ((dataSize + 3) & (~3)); // align
        }
    }

    // if we cannot get the compressed data
    if ((const_cast<CopyOnWriteBitmap *>(this))->LoadIntoMemory() == Ok)
    {
        BitmapData  bitmapData     = *Bmp;
        INT         positiveStride = bitmapData.Stride;
        INT         paletteSize    = 0;
        INT         pixelDataSize;

        if (positiveStride < 0)
        {
            positiveStride = -positiveStride;
        }

        pixelDataSize = (bitmapData.Height * positiveStride);

        if (IsIndexedPixelFormat(bitmapData.PixelFormat))
        {
            // We're an indexed pixel format - must have a valid palette.
            ASSERT(Bmp->colorpal != NULL);

            // Note sizeof(ColorPalette) includes the first palette entry.
            paletteSize = sizeof(ColorPalette) +
                          sizeof(ARGB)*(Bmp->colorpal->Count - 1);
        }

        dataSize = sizeof(BitmapRecordData) + paletteSize + pixelDataSize;
    }

    return ((dataSize + 3) & (~3)); // align
}

/**************************************************************************\
*
* Function Description:
*
*   Read the bitmap object from memory.
*
* Arguments:
*
*   [IN] dataBuffer - the data that was read from the stream
*   [IN] size - the size of the data
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   4/26/1999 DCurtis
*
\**************************************************************************/
GpStatus
CopyOnWriteBitmap::SetData(
    const BYTE *        dataBuffer,
    UINT                size
    )
{
    ASSERT ((GpImageType)(((BitmapRecordData *)dataBuffer)->Type) == ImageTypeBitmap);

    GpStatus    status = Ok;

    this->FreeData();
    this->InitDefaults();

    if (dataBuffer == NULL)
    {
        WARNING(("dataBuffer is NULL"));
        return InvalidParameter;
    }

    if (size < sizeof(BitmapRecordData))
    {
        WARNING(("size too small"));
        return InvalidParameter;
    }

    const BitmapRecordData *    bitmapData;

    bitmapData = reinterpret_cast<const BitmapRecordData *>(dataBuffer);

    if (!bitmapData->MajorVersionMatches())
    {
        WARNING(("Version number mismatch"));
        return InvalidParameter;
    }

    if (!(bitmapData->Flags & COMPRESSED_IMAGE))
    {
        Bmp = new GpMemoryBitmap();

        if (Bmp != NULL)
        {
            // Mask out the pixel format
            PixelFormatID pixelFormat = MaskPixelFormat(bitmapData->PixelFormat);
            HRESULT hr = Bmp->InitNewBitmap(bitmapData->Width,
                                            bitmapData->Height,
                                            pixelFormat);

            if (FAILED(hr))
            {
                WARNING(("InitNewBitmap failed"));
                delete Bmp;
                Bmp = NULL;
                return GenericError;
            }

            // Fill image info structure

            if ( Bmp->GetImageInfo(&SrcImageInfo) != S_OK )
            {
                WARNING(("InitNewBitmap failed"));
                delete Bmp;
                Bmp = NULL;
                return GenericError;
            }

            PixelFormatInMem = SrcImageInfo.PixelFormat;

            ASSERT(Bmp->Stride == bitmapData->Stride);
            dataBuffer += sizeof(BitmapRecordData);
            size       -= sizeof(BitmapRecordData);

            State = MemBitmap;

            // If it's an indexed format, we'll have stored the palette next
            if(IsIndexedPixelFormat(pixelFormat))
            {
                if (size < sizeof(ColorPalette))
                {
                    WARNING(("size too small"));
                    return InvalidParameter;
                }

                UINT paletteSize;
                ColorPalette *pal;
                pal = (ColorPalette *)dataBuffer;

                // Work out how big the palette is.
                // sizeof(ColorPalette) includes the first entry.
                paletteSize = sizeof(ColorPalette)+sizeof(ARGB)*(pal->Count-1);

                if (size < paletteSize)
                {
                    WARNING(("size too small"));
                    return InvalidParameter;
                }

                // Make the GpMemoryBitmap clone the palette into the right place
                Bmp->SetPalette(pal);

                // Update the dataBuffer stream to the beginning of the pixel data
                dataBuffer += paletteSize;
                size       -= paletteSize;
            }
        }
        else
        {
            WARNING(("Out of memory"));
            return OutOfMemory;
        }

        ASSERT((Bmp != NULL) && (Bmp->Scan0 != NULL));

        ULONG   pixelSize = Bmp->Stride * Bmp->Height;

        if (size >= pixelSize)
        {
            size = pixelSize;
        }
        else
        {
            WARNING(("Insufficient data to fill bitmap"));
            status = InvalidParameter;
        }

        if (size > 0)
        {
            GpMemcpy(Bmp->Scan0, dataBuffer, size);
        }
    }
    else
    {
        // Create an IStream on top of the memory buffer

        GpReadOnlyMemoryStream* stream;

        stream = new GpReadOnlyMemoryStream();

        if (!stream)
        {
            WARNING(("Out of memory"));
            return OutOfMemory;
        }

        dataBuffer += sizeof(BitmapRecordData);
        size -= sizeof(BitmapRecordData);

        stream->InitBuffer(dataBuffer, size);

        // since we don't want to hold dataBuffer or make a copy of
        // it, we just Load it into memory here.

        Stream = stream;
        State = ExtStream;

        status = LoadIntoMemory();

        if ( status == Ok )
        {
            // The source image is loaded into memory and we are not going to
            // keep the source image connection any more. So we fill the image
            // info with the memory bits info

            if ( Bmp->GetImageInfo(&SrcImageInfo) != S_OK )
            {
                status = GenericError;
            }
            else
            {
                PixelFormatInMem = SrcImageInfo.PixelFormat;
            }
        }

        stream->Release();
        Stream = NULL;

        if (Img)
        {
            Img->Release();
            Img = NULL;
        }
    }

    return status;
}

char    ColorChannelName[4] = {'C', 'M', 'Y', 'K'};

/**************************************************************************\
*
* Function Description:
*
*   Do the color adjustment if the lower level codec can do it.
*
* Arguments:
*
*   [IN]  recolor     - Pointer to image attributes
*
* Return Value:
*
*   Status code
*       Return Ok -------------Lower level does it
*       Return NotImplemented--Lower level can't do it
*       Other status code
*
* Revision History:
*
*   11/22/1999 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::ColorAdjustByCodec(
    GpRecolor * recolor,
    DrawImageAbort callback,
    VOID *callbackData
    )
{
    if (recolor == NULL)
    {
        // The lower level codec doesn't know how to handle this, let the
        // up level do it

        return NotImplemented;
    }

    HRESULT     hResult;

    UINT    uiCurrentFlag = recolor->GetValidFlags(ColorAdjustTypeBitmap);
    BOOL    bImgCreatedHere = FALSE;

    // First we need to check if the current lower level decoder can do the
    // job or not

    if ( Img == NULL )
    {
        // Create a GpDecodedImage*

        if ( NULL != Stream )
        {
            hResult = GpDecodedImage::CreateFromStream(Stream, &Img);
        }
        else
        {
            if ( Filename == NULL )
            {
                // We can't continue. Let the higher level do it

                return NotImplemented;
            }

            hResult = GpDecodedImage::CreateFromFile(Filename, &Img);
        }

        if ( FAILED(hResult) )
        {
            WARNING(("Failed to create decoded image: %x", hResult));
            return Win32Error;
        }

        // Remember that we creat a copy of Img here. Should be freed when done

        bImgCreatedHere = TRUE;
    }// (Img == NULL)

    GUID        DecoderParamGuid;
    UINT        DecoderParamLength;
    PVOID       DecoderParamPtr;
    GpStatus    rCode = Win32Error;

    // Set the GUID and other parameters with respect to the image attributes
    // Note: we won't have a recolor which has both ValidColorKeys and
    // ValidOutputChannel set. This function won't be called if this case is
    // TRUE. We checked this in ColorAdjust()

    UINT value[2];
    if ( uiCurrentFlag & (GpRecolorObject::ValidColorKeys) )
    {
        // Set color key

        DecoderParamGuid = DECODER_TRANSCOLOR;
        DecoderParamLength = 8;

        value[0] = (UINT)(recolor->GetColorKeyLow(ColorAdjustTypeBitmap));
        value[1] = (UINT)(recolor->GetColorKeyHigh(ColorAdjustTypeBitmap));

        DecoderParamPtr = (VOID*)value;
    }
    else if ( uiCurrentFlag & (GpRecolorObject::ValidOutputChannel) )
    {
        // Asks the codec doing a color separation makes sense only when the
        // source image is in CMYK space. Otherwise, we do it in our recolor
        // object which contains a generic algorithem for doing it

        if ( !( (SrcImageInfo.Flags & ImageFlagsColorSpaceCMYK)
              ||(SrcImageInfo.Flags & ImageFlagsColorSpaceYCCK) ) )
        {
            // Not a CMYK image, do it in recolor object

            rCode = NotImplemented;
            goto CleanUp;
        }

        // Set channel output

        DecoderParamGuid = DECODER_OUTPUTCHANNEL;
        DecoderParamLength = 1;

        DecoderParamPtr =
            (VOID*)(&ColorChannelName[recolor->GetChannelIndex(ColorAdjustTypeBitmap)]);
    }

    // Query to see if the decoder can do it or not

    hResult = Img->QueryDecoderParam(DecoderParamGuid);

    if ( (hResult != E_NOTIMPL) && (hResult != S_OK) )
    {
        WARNING(("Failed to query decoder param: %x", hResult));
        goto CleanUp;
    }
    else if ( hResult == E_NOTIMPL )
    {
        // The lower level decoder doesn't support this.

        rCode = NotImplemented;
        goto CleanUp;
    }

    // Set the decoder param to tell the lower level how to decode

    hResult = Img->SetDecoderParam(DecoderParamGuid, DecoderParamLength,
                                   DecoderParamPtr);

    if ( (hResult != E_NOTIMPL) && (hResult != S_OK) )
    {
        WARNING(("Failed to set decoder param: %x", hResult));
        goto CleanUp;
    }
    else if ( hResult == E_NOTIMPL )
    {
        // The lower level decoder doesn't support this.

        rCode = NotImplemented;
        goto CleanUp;
    }

    // Now we don't need the previous "Bmp" since we are going to ask the
    // lower level decoder to create one for us

    if ( Bmp != NULL )
    {
        Bmp->Release();
        Bmp = NULL;
    }

    // Ask the decoder to create a 32BPP ARGB GpMemoryBitmap.

    hResult = GpMemoryBitmap::CreateFromImage(Img,
                                              0,
                                              0,
                                              PIXFMT_32BPP_ARGB,
                                              InterpolationHintDefault,
                                              &Bmp,
                                              callback,
                                              callbackData);

    if ( FAILED(hResult) )
    {
        WARNING(("Failed to load image into memory: %x", hResult));
        goto CleanUp;
    }

    State = MemBitmap;
    PixelFormatInMem = PIXFMT_32BPP_ARGB;

    // The lower level does the job for us.

    rCode = Ok;

CleanUp:
    if ( bImgCreatedHere == TRUE )
    {
        // Note: we don't need to check if Img == NULL or not because this flag
        // would only be set when we successed in creating Img

        Img->Release();
        Img = NULL;
    }

    return rCode;
}// ColorAdjustByCodec()

GpStatus
CopyOnWriteBitmap::ColorAdjust(
    GpRecolor * recolor,
    PixelFormatID pixfmt,
    DrawImageAbort callback,
    VOID *callbackData
    )
{
    HRESULT hr;

    ASSERT(ObjRefCount == 1);
    ASSERT(recolor != NULL);

    // Mark the result image (color adjusted image) as dirty
    // Note: this won't damage the original source image because we always
    // color adjust on a cloned copy of the original image

    SetDirtyFlag(TRUE);

    UINT    uiCurrentFlag = recolor->GetValidFlags(ColorAdjustTypeBitmap);

    // For color key output: we will ask the lower level decoder to do the job
    //    if there is no other recoloring flag is specified
    // For color separation(channel output), we will ask the lower level decoder
    //    to do the job if there is no other recoloring flag is specified except
    //    for ValidColorProfile.
    //    If the codec can handle CMYK separation, then the profile is ignored.
    //    If the source is RGB image, then ColorAdjustByCodec() will do nothing
    //    and we will use the profile to do RGB to CMYK conversion before
    //    channel separation

    if ( uiCurrentFlag
       &&( ((uiCurrentFlag & GpRecolorObject::ValidColorKeys) == uiCurrentFlag)
         ||((uiCurrentFlag
           &(~GpRecolorObject::ValidChannelProfile)
           &(GpRecolorObject::ValidOutputChannel))
             == (GpRecolorObject::ValidOutputChannel) ) ) )
    {
        Status rCode = ColorAdjustByCodec(recolor, callback, callbackData);

        if ( rCode != NotImplemented )
        {
            // Either the lower level did the job for us (rCode == Ok) or it
            // failed somehow (rCode == Win32Error etc.). We just return here

            return rCode;
        }

        // Lower level can't do it. We can just slip here to do the normal
        // software version of color adjust

    }// Color key and color channel handling

    GpStatus status = LoadIntoMemory(pixfmt);

    if ( status != Ok )
    {
        return status;
    }

    hr = Bmp->PerformColorAdjustment(recolor,
                                     ColorAdjustTypeBitmap,
                                     callback, callbackData);

    if ( SUCCEEDED(hr) )
    {
        Bmp->SetAlphaHint(GpMemoryBitmap::ALPHA_UNKNOWN);
        return Ok;
    }
    else if (hr == IMGERR_ABORT)
    {
        WARNING(("CopyOnWriteBitmap::ColorAdjust---Aborted"));
        return Aborted;
    }
    else
    {
        WARNING(("CopyOnWriteBitmap::ColorAdjust---PerformColorAdjustment() failed"));
        return GenericError;
    }
}// ColorAdjust()

/**************************************************************************\
*
* Function Description:
*
*   Get the (current) pixel format of the CopyOnWriteBitmap.
*   Here "current" means the pixel format in the memory if it has been loaded,
*   aka, a GpMemoryBitmap. If it is not in the memory, then we return the
*   PixelFormat of the original image
*
*
* Arguments:
*
*   [OUT]  pixfmt     - Pointer to pixel format
*
* Return Value:
*
*   Status code
*       Ok - success
*       Win32Error - failed
*
* Revision History:
*
*   06/10/2000   asecchia
*       Created it.
*   07/26/2000   minliu
*       Re-wrote it
*
\**************************************************************************/


GpStatus
CopyOnWriteBitmap::GetPixelFormatID(
    PixelFormatID *pixfmt
)
{
    ASSERT(IsValid());

    // If the image is in the memory, then we return the memory bitmap pixel
    // format. Otherwise, return the source image format

    if ( (State == MemBitmap) && (PixelFormatInMem != PixelFormatDontCare) )
    {
        *pixfmt = PixelFormatInMem;
    }
    else
    {
        *pixfmt = SrcImageInfo.PixelFormat;
    }

    return Ok;
}

CopyOnWriteBitmap*
CopyOnWriteBitmap::CloneColorAdjusted(
    GpRecolor *             recolor,
    ColorAdjustType         type
    ) const
{
    ASSERT(recolor != NULL);

    CopyOnWriteBitmap *  clonedBitmap = (CopyOnWriteBitmap *)this->Clone();

    if (clonedBitmap != NULL)
    {
        if ((clonedBitmap->IsValid()) &&
            (clonedBitmap->ColorAdjust(recolor, type) == Ok))
        {
            clonedBitmap->SetDirtyFlag(TRUE);
            return clonedBitmap;
        }
        delete clonedBitmap;
    }
    return NULL;
}

GpStatus
CopyOnWriteBitmap::ColorAdjust(
    GpRecolor *     recolor,
    ColorAdjustType type
    )
{
    ASSERT(recolor != NULL);
    ASSERT(ObjRefCount == 1);

    GpStatus status = LoadIntoMemory();

    if (status != Ok)
    {
        return status;
    }

    if (type == ColorAdjustTypeDefault)
    {
        type = ColorAdjustTypeBitmap;
    }

    HRESULT hr = Bmp->PerformColorAdjustment(recolor, type, NULL, NULL);

    if ( SUCCEEDED(hr) )
    {
        SetDirtyFlag(TRUE);
        return Ok;
    }

    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Override the native resolution of the bitmap.
*
* Arguments:
*
*   xdpi, ydpi - New resolution
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::SetResolution(
    REAL    xdpi,
    REAL    ydpi
    )
{
    if ( (xdpi > 0.0) && (ydpi > 0.0) )
    {
        XDpiOverride = xdpi;
        YDpiOverride = ydpi;

        if ( Img )
        {
            Img->SetResolution(xdpi, ydpi);
        }

        if ( Bmp )
        {
            Bmp->SetResolution(xdpi, ydpi);
        }

        SrcImageInfo.Xdpi = xdpi;
        SrcImageInfo.Ydpi = ydpi;

        // Mark the bits dirty since we have to save the image with the new
        // resolution info.

        SetDirtyFlag(TRUE);

        return Ok;
    }
    else
    {
        return InvalidParameter;
    }
}// SetResolution()

/**************************************************************************\
*
* Function Description:
*
*   INTEROP
*
*   Create a GDI bitmap (HBITMAP) from a GDI+ bitmap.
*
* Arguments:
*
*   phbm -- Return HBITMAP via this pointer
*   background -- If GDI+ bitmap has alpha, blend with this color as the
*                 background
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::CreateHBITMAP(HBITMAP *phbm, ARGB background)
{
    GpStatus status;

    // These objects need cleanup:

    HDC hdc = NULL;
    HBITMAP hbmOld = NULL;
    HBITMAP hbmNew = NULL;
    HBRUSH hbr = NULL;
    HBRUSH hbrOld = NULL;
    GpGraphics *g = NULL;

    // Get format information for this bitmap:

    // Create HDC:

    hdc = CreateCompatibleDC(NULL);
    if (!hdc)
    {
        WARNING(("CreateHBITMAP: CreateCompatibleDC failed"));
        status = Win32Error;
        goto error_cleanup;
    }

    // Create DIB section:

    BITMAPINFO bmi;
    VOID *pv;

    GpMemset(&bmi, 0, sizeof(bmi));
    bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth       = SrcImageInfo.Width;
    bmi.bmiHeader.biHeight      = SrcImageInfo.Height;
    bmi.bmiHeader.biPlanes      = 1;
    bmi.bmiHeader.biBitCount    = 32;
    bmi.bmiHeader.biCompression = BI_RGB;

    hbmNew = CreateDIBSection(hdc, &bmi, DIB_RGB_COLORS, &pv, NULL, 0);
    if (!hbmNew)
    {
        WARNING(("CreateHBITMAP: CreateDIBSection failed\n"));
        status = Win32Error;
        goto error_cleanup;
    }

    // Select DIB into DC:

    hbmOld = (HBITMAP) SelectObject(hdc, hbmNew);
    if (!hbmOld)
    {
        WARNING(("CreateHBITMAP: SelectObject(hbm) failed\n"));
        status = Win32Error;
        goto error_cleanup;
    }

    // Clear DIB to specified ARGB color:

    LOGBRUSH lbr;

    lbr.lbStyle = BS_SOLID;
    lbr.lbColor = RGB(background & 0x00ff0000,
                      background & 0x0000ff00,
                      background & 0x000000ff);

    hbr = CreateBrushIndirect(&lbr);
    if (!hbr)
    {
        WARNING(("CreateHBITMAP: CreateBrushIndirect failed\n"));
        status = Win32Error;
        goto error_cleanup;
    }

    hbrOld = (HBRUSH) SelectObject(hdc, hbr);
    if (!hbrOld)
    {
        WARNING(("CreateHBITMAP: SelectObject(hbr) failed\n"));
        status = Win32Error;
        goto error_cleanup;
    }

    PatBlt(hdc, 0, 0, SrcImageInfo.Width, SrcImageInfo.Height, PATCOPY);

    // Derive Graphics from HDC:

    g = GpGraphics::GetFromHdc(hdc);
    if (!g)
    {
        WARNING(("CreateHBITMAP: GpGraphics::GetFromHdc failed\n"));
        status = OutOfMemory;
        goto error_cleanup;
    }

    // DrawImage bitmap to Graphics:

    {
        GpLock lock(g->GetObjectLock());
        if (lock.IsValid())
        {
            FPUStateSaver fpState;

            GpRectF rect(0.0, 0.0, TOREAL(SrcImageInfo.Width),
                         TOREAL(SrcImageInfo.Height));
            GpBitmap tmpBitmap(this);
            status = g->DrawImage(&tmpBitmap, rect, rect, UnitPixel);

            if (status == Ok)
            {
                // Bypass cleanup of the bitmap, we want to keep it:

                *phbm = hbmNew;
                hbmNew = NULL;
            }
            else
            {
                WARNING(("CreateHBITMAP: GpGraphics::DrawImage failed"));
            }
        }
        else
        {
            status = ObjectBusy;
        }
    }

error_cleanup:

    if (hdc)
    {
        if (hbmOld)
            SelectObject(hdc, hbmOld);

        if (hbrOld)
            SelectObject(hdc, hbrOld);

        DeleteDC(hdc);
    }

    if (hbmNew)
        DeleteObject(hbmNew);

    if (hbr)
        DeleteObject(hbr);

    if (g)
        delete g;

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   INTEROP
*
*   Create a Win32 icon (HICON) from a GDI+ bitmap.
*
* Arguments:
*
*   phicon -- Return HICON via this pointer
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

VOID ExportMask32BPP(BitmapData* mask, BitmapData* src)
{
    ASSERT(src->PixelFormat == PIXFMT_32BPP_ARGB);
    ASSERT(mask->PixelFormat == PIXFMT_32BPP_RGB);
    ASSERT(src->Width == mask->Width);
    ASSERT(src->Height == mask->Height);
    ASSERT(src->Scan0 != NULL);
    ASSERT(mask->Scan0 != NULL);

    BYTE* srcScan = static_cast<BYTE*>(src->Scan0);
    BYTE* maskScan = static_cast<BYTE*>(mask->Scan0);

    for (UINT row = 0; row < src->Height; row++)
    {
        ARGB *srcPixel = static_cast<ARGB*>(static_cast<VOID*>(srcScan));
        ARGB *maskPixel = static_cast<ARGB*>(static_cast<VOID*>(maskScan));

        for (UINT col = 0; col < src->Width; col++)
        {
            if ((*srcPixel & 0xff000000) == 0xff000000)
                *maskPixel = 0;            // Opaque
            else
                *maskPixel = 0x00ffffff;   // Transparent

            srcPixel++;
            maskPixel++;
        }

        srcScan = srcScan + src->Stride;
        maskScan = maskScan + mask->Stride;
    }
}

GpStatus
CopyOnWriteBitmap::CreateHICON(
    HICON *phicon
    )
{
    GpStatus status = Win32Error;

    ICONINFO iconInfo;

    iconInfo.fIcon = TRUE;

    status = CreateHBITMAP(&iconInfo.hbmColor, 0);

    if (status == Ok)
    {
        BitmapData bmpDataSrc;

        status = this->LockBits(NULL,
                                IMGLOCK_READ,
                                PIXFMT_32BPP_ARGB,
                                &bmpDataSrc);

        if (status == Ok)
        {
            // From this point on, assume failure until we succeed:

            status = Win32Error;

            // Create empty bitmap for the icon mask:

            iconInfo.hbmMask = CreateBitmap(bmpDataSrc.Width,
                                            bmpDataSrc.Height,
                                            1, 1, NULL);

            if (iconInfo.hbmMask != NULL)
            {
                VOID *gdiBitmapData = GpMalloc(bmpDataSrc.Width
                                               * bmpDataSrc.Height
                                               * 4);

                if (gdiBitmapData)
                {
                    // Convert alpha channel into a 32bpp DIB mask:

                    BitmapData bmpDataMask;

                    bmpDataMask.Width  = bmpDataSrc.Width;
                    bmpDataMask.Height = bmpDataSrc.Height;
                    bmpDataMask.Stride = bmpDataSrc.Width * 4;
                    bmpDataMask.PixelFormat = PIXFMT_32BPP_RGB;
                    bmpDataMask.Scan0 = gdiBitmapData;
                    bmpDataMask.Reserved = 0;

                    ExportMask32BPP(&bmpDataMask, &bmpDataSrc);

                    // Set mask bits:

                    BYTE bufferBitmapInfo[sizeof(BITMAPINFO)];
                    BITMAPINFO *gdiBitmapInfo = (BITMAPINFO *) bufferBitmapInfo;

                    memset(bufferBitmapInfo, 0, sizeof(bufferBitmapInfo));
                    gdiBitmapInfo->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);

                    gdiBitmapInfo->bmiHeader.biWidth  = bmpDataSrc.Width;
                    gdiBitmapInfo->bmiHeader.biHeight = - static_cast<LONG>
                                                          (bmpDataSrc.Height);
                    gdiBitmapInfo->bmiHeader.biPlanes       = 1;
                    gdiBitmapInfo->bmiHeader.biBitCount     = 32;
                    gdiBitmapInfo->bmiHeader.biCompression  = BI_RGB;

                    HDC hdc = GetDC(NULL);

                    if (hdc != NULL)
                    {
                        SetTextColor(hdc, RGB(0, 0, 0));
                        SetBkColor(hdc, RGB(0xff, 0xff, 0xff));
                        SetBkMode(hdc, OPAQUE);

                        if (SetDIBits(hdc,
                                      iconInfo.hbmMask,
                                      0,
                                      bmpDataSrc.Height,
                                      gdiBitmapData,
                                      gdiBitmapInfo,
                                      DIB_RGB_COLORS
                                     ))
                        {
                            // Create icon:

                            *phicon = CreateIconIndirect(&iconInfo);

                            if (*phicon != NULL)
                                status = Ok;
                            else
                            {
                                WARNING(("CreateIconIndirect failed"));
                            }
                        }
                        else
                        {
                            WARNING(("SetDIBits failed"));
                        }

                        ReleaseDC(NULL, hdc);
                    }

                    GpFree(gdiBitmapData);
                }
                else
                {
                    WARNING(("memory allocation failed"));
                    status = OutOfMemory;
                }

                DeleteObject(iconInfo.hbmMask);
            }
            else
            {
                WARNING(("CreateBitmap failed"));
            }

            this->UnlockBits(&bmpDataSrc);
        }
        else
        {
            WARNING(("LockBits failed"));
        }

        DeleteObject(iconInfo.hbmColor);
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Prep the bitmap for drawing.
*
*   Currently, the only thing we do is check if the bitmap is an ICON.
*   If so, we set the DECODER_ICONRES parameters if supported.
*
* Arguments:
*
*   numPoints
*   dstPoints           Specifies the destination area
*
*   srcRect             Specifies the source area
*
*   numBitsPerPixel     Specifies the bits-per-pixel of the destination
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::PreDraw(
    INT numPoints,
    GpPointF *dstPoints,
    GpRectF *srcRect,
    INT numBitsPerPixel
    )
{
    // Check if ICON:

    GpStatus status = Ok;

    if ( SrcImageInfo.RawDataFormat == IMGFMT_ICO )
    {
        status = SetIconParameters(numPoints, dstPoints, srcRect,
                                   numBitsPerPixel);
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Set the decode parameters for multi-resolution icons.
*
* Arguments:
*
*   numPoints
*   dstPoints           Specifies the destination area
*
*   srcRect             Specifies the source area
*
*   numBitsPerPixel     Specifies the bits-per-pixel of the destination
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::SetIconParameters(
    INT numPoints,
    GpPointF *dstPoints,
    GpRectF *srcRect,
    INT numBitsPerPixel
    )
{
    // Check if DECODER_ICONRES supported:

    HRESULT hResult;

    BOOL imageCleanupNeeded = FALSE;

    // First we need to check if the current lower level decoder can do the
    // job or not

    if (Img == NULL)
    {
        // Create a GpDecodedImage*

        if (NULL != Stream)
        {
            hResult = GpDecodedImage::CreateFromStream(Stream, &Img);
        }
        else
        {
            if (Filename == NULL)
            {
                // We can't continue. Let the higher level do it

                return GenericError;
            }

            hResult = GpDecodedImage::CreateFromFile(Filename, &Img);
        }

        if (FAILED(hResult))
        {
            WARNING(("Failed to create decoded image: %x", hResult));
            return Win32Error;
        }

        // Remember that we creat a copy of Img here. Should be freed when done

        imageCleanupNeeded = TRUE;
    }

    GpStatus status = Win32Error;

    // Query to see if the decoder can do it or not

    hResult = Img->QueryDecoderParam(DECODER_ICONRES);

    if (hResult != S_OK)
    {
        if ((hResult == E_FAIL) || (hResult == E_NOTIMPL))
        {
            // Decoder doesn't want it, which is OK.

            status = Ok;
            goto CleanUp;
        }
        else
        {
            // Something else is wrong

            goto CleanUp;
        }
    }

    // Setup the GUID and decode parameters

    {
        UINT value[3];
        value[0] = static_cast<UINT>
                   (GetDistance(dstPoints[0], dstPoints[1]) + 0.5);
        value[1] = static_cast<UINT>
                   (GetDistance(dstPoints[0], dstPoints[2]) + 0.5);
        value[2] = numBitsPerPixel;

        UINT  DecoderParamLength = 3*sizeof(UINT);
        PVOID DecoderParamPtr = (VOID*) value;

        // Set the decoder param to tell the lower level how to decode

        hResult = Img->SetDecoderParam(DECODER_ICONRES,
                                       DecoderParamLength,
                                       DecoderParamPtr);
    }

    if (hResult != S_OK)
    {
        if ((hResult == E_FAIL) || (hResult == E_NOTIMPL))
        {
            // Decoder doesn't want it, which is OK.

            status = Ok;
            goto CleanUp;
        }
        else
        {
            // Something else is wrong

            goto CleanUp;
        }
    }

    // Now we don't need the previous "Bmp" since we are going to ask the
    // lower level decoder to create one for us

    if ( Bmp != NULL )
    {
        Bmp->Release();
        Bmp = NULL;
    }

    // Ask the decoder to create a 32BPP ARGB GpMemoryBitmap.

    hResult = GpMemoryBitmap::CreateFromImage(Img,
                                              0,
                                              0,
                                              PIXFMT_32BPP_ARGB,
                                              InterpolationHintDefault,
                                              &Bmp,
                                              NULL,
                                              NULL);

    if ( FAILED(hResult) )
    {
        WARNING(("Failed to load image into memory: %x", hResult));
        goto CleanUp;
    }

    State = MemBitmap;
    PixelFormatInMem = PIXFMT_32BPP_ARGB;

    // The lower level does the job for us.

    status = Ok;

CleanUp:

    if ((status == Ok) && (srcRect != NULL))
    {
        // Icons are not allowed to clip

        srcRect->X = 0;
        srcRect->Y = 0;
        srcRect->Width  = (REAL) SrcImageInfo.Width;
        srcRect->Height = (REAL) SrcImageInfo.Height;
    }

    if (imageCleanupNeeded == TRUE)
    {
        Img->Release();
        Img = NULL;
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Get the transparency state of the bitmap
*
* Arguments:
*
*   transparency        Returned state
*
* Return Value:
*
*   Status code
*
\**************************************************************************/
GpStatus
CopyOnWriteBitmap::GetTransparencyHint(
    DpTransparency* transparency
    )
{
    GpStatus status = GenericError;

    if (Bmp != NULL)
    {
        INT alphaHint;

        HRESULT hr = Bmp->GetAlphaHint(&alphaHint);

        if (SUCCEEDED(hr))
        {
            // It's unfortunate that GpMemoryBitmap does not have
            // a DpTransparency flag internally, but there's a conflict
            // with imaging.dll and the include file structure that for
            // now makes it necessary to keep a separate type for this info.

            // In fact, ultimately it would be best if the overlap
            // between DpBitmap and GpMemoryBitmap is resolved including
            // a DpBitmap structure within the GpMemoryBitmap and then
            // removing the redundant info out GpMemoryBitmap.

            switch (alphaHint)
            {
            case GpMemoryBitmap::ALPHA_SIMPLE:
                *transparency = TransparencySimple;
                break;

            case GpMemoryBitmap::ALPHA_OPAQUE:
                *transparency = TransparencyOpaque;
                break;

            case GpMemoryBitmap::ALPHA_NONE:
                *transparency = TransparencyNoAlpha;
                break;

            case GpMemoryBitmap::ALPHA_COMPLEX:
                *transparency = TransparencyComplex;
                break;

            default:
                *transparency = TransparencyUnknown;
                break;
            }

            status = Ok;
        }
        else
        {
            ASSERT(SUCCEEDED(hr));
            *transparency = TransparencyUnknown;
        }
    }
    else
    {
        *transparency = TransparencyUnknown;
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Get the transparency state of the bitmap.  This routine returns accurate
* info while GetTransparencyHint just returns a hint
*
*   This routine could scan the whole bitmap (32bpp) so whoever uses it should
* consider the perf hit.
*
*   This is currently only for use by the printer drivers.
*
* Arguments:
*
*   transparency        Returned state
*
* Return Value:
*
*   Status code
*
\**************************************************************************/
GpStatus
CopyOnWriteBitmap::GetTransparencyFlags(
    DpTransparency* transparency,
    PixelFormatID   loadFormat,
    BYTE*           minA,
    BYTE*           maxA
    )
{
    GpStatus status = GenericError;

    ARGB argb;
    ARGB minAlpha = 0xff000000;
    ARGB maxAlpha = 0;

    INT newAlphaHint = GpMemoryBitmap::ALPHA_OPAQUE;

TestBmp:
    if (Bmp != NULL)
    {
        INT alphaHint;

        // the alpha transparency could change if the bitmap has changed

        HRESULT hr = Bmp->GetAlphaHint(&alphaHint);

        if (SUCCEEDED(hr))
        {
            // It's unfortunate that GpMemoryBitmap does not have
            // a DpTransparency flag internally, but there's a conflict
            // with imaging.dll and the include file structure that for
            // now makes it necessary to keep a separate type for this info.

            // In fact, ultimately it would be best if the overlap
            // between DpBitmap and GpMemoryBitmap is resolved including
            // a DpBitmap structure within the GpMemoryBitmap and then
            // removing the redundant info out GpMemoryBitmap.

            switch (alphaHint)
            {
            case GpMemoryBitmap::ALPHA_SIMPLE:
                *transparency = TransparencySimple;
                break;

            case GpMemoryBitmap::ALPHA_OPAQUE:
                *transparency = TransparencyOpaque;
                break;

            case GpMemoryBitmap::ALPHA_NONE:
                *transparency = TransparencyNoAlpha;
                break;

            case GpMemoryBitmap::ALPHA_COMPLEX:
                *transparency = TransparencyComplex;
                break;

            case GpMemoryBitmap::ALPHA_NEARCONSTANT:
                *transparency = TransparencyNearConstant;

                if (minA != NULL && maxA != NULL)
                {
                    // if the flag is nearconstant alpha, we must have got valid min and max alpha
                    Bmp->GetMinMaxAlpha(minA, maxA);
                }

                break;

            default:
                *transparency = TransparencyUnknown;
                break;
            }

            status = Ok;

            // printing needs more accuarate info and is always loaded into memory
            // before send down to the printer drivers

            // 16bpp1555 is handled at initialization already.

            // TransparencyUnknown means the bitmap can have alpha we just don't know what we have
            // TransparencyNoAlpha means the bitmap format doesn't support alpha

            if (*transparency == TransparencyUnknown)
            {
                if (IsAlphaPixelFormat(Bmp->PixelFormat))
                {
                    // the memory bitmap must be locked before we enter here
                    // We don't require the object to be locked.  The object should be
                    // decoded already in memory.  This is true in the case of DrvDrawImage
                    // and texture brush images.
                    //ASSERT(ObjRefCount > 1);
                    *transparency = TransparencyOpaque;


                    if ((Bmp->PixelFormat == PIXFMT_32BPP_ARGB) || (Bmp->PixelFormat == PIXFMT_32BPP_PARGB))
                    {
                        *transparency = TransparencyOpaque;

                        UINT x, y;

                        BYTE *scanStart = static_cast<BYTE *>(Bmp->Scan0);
                        ARGB *scanPtr;

                        for (y = 0; y < Bmp->Height; y++)
                        {
                            scanPtr = reinterpret_cast<ARGB *>(scanStart);

                            for (x = 0; x < Bmp->Width; x++)
                            {
                                argb = (*scanPtr++) & 0xff000000;

                                if (argb < minAlpha)
                                {
                                    minAlpha = argb;
                                }

                                if (argb > maxAlpha)
                                {
                                    maxAlpha = argb;
                                }

                                if (argb != 0xff000000)
                                {
                                    if (argb == 0)
                                    {
// Prefast bug 518296 - the condition below is always true, this is definitely a bug
// and the || must be replaced with &&. We have no precedent however that this
// causes customer problems, hence it does not meet the SP bar.
/*
                                        if ((*transparency != TransparencyComplex) ||
                                            (*transparency != TransparencyNearConstant))
*/
                                        {
                                            *transparency = TransparencySimple;
                                        }
                                    }
                                    else
                                    {
                                        if ((maxAlpha - minAlpha) <= (NEARCONSTANTALPHA << 24))
                                        {
                                            *transparency = TransparencyNearConstant;
                                        }
                                        else
                                        {
                                            *transparency = TransparencyComplex;
                                            goto done;
                                        }
                                    }
                                }
                            }

                            scanStart += Bmp->Stride;
                        }

                        goto done;
                    }
                    else
                    {
                        RIP(("TransparencyUnknown returned for pixel format w/ alpha"));

                        goto done;
                    }
                }
                else if (IsIndexedPixelFormat(Bmp->PixelFormat) &&
                         Bmp->colorpal)
                {
                    // Compute transparancy hint from palette
                    // if we worry about cases
                    // that the transparent index is not used in the bitmap
                    // then we have to scan the whole bitmap.
                    // I believe this is sufficient for now unless someone
                    // run into problems that really need to scan the whole bitmap

                    *transparency = TransparencyOpaque;

                    for (UINT i = 0; i < Bmp->colorpal->Count; i++)
                    {
                        argb = Bmp->colorpal->Entries[i] & 0xff000000;

                        if (argb < minAlpha)
                        {
                            minAlpha = argb;
                        }

                        if (argb > maxAlpha)
                        {
                            maxAlpha = argb;
                        }

                        if (argb != 0xff000000)
                        {
                            if (argb == 0)
                            {
// See the comments above.
/*
                                if ((*transparency != TransparencyComplex) ||
                                    (*transparency != TransparencyNearConstant))
*/
                                {
                                    *transparency = TransparencySimple;
                                }
                            }
                            else
                            {
                                if ((maxAlpha - minAlpha) <= (NEARCONSTANTALPHA << 24))
                                {
                                    *transparency = TransparencyNearConstant;
                                }
                                else
                                {
                                    *transparency = TransparencyComplex;
                                    goto done;
                                }
                            }
                        }

                    }

                    goto done;
                }
                else
                {
                    // Native pixel format does not support alpha
                    *transparency = TransparencyNoAlpha;
                }
            }
        }
        else
        {
            *transparency = TransparencyUnknown;
        }
    }
    else
    {
        status = LoadIntoMemory(loadFormat);

        if (status == Ok)
        {
            ASSERT(Bmp != NULL);
            goto TestBmp;
        }

        *transparency = TransparencyUnknown;
    }

    return status;

done:
    // Set alpha hint back into GpMemoryBitmap
    // so we don't have to scan the bitmap again later

    if (*transparency == TransparencySimple)
    {
        newAlphaHint = GpMemoryBitmap::ALPHA_SIMPLE;
    }
    else if (*transparency == TransparencyComplex)
    {
        newAlphaHint = GpMemoryBitmap::ALPHA_COMPLEX;
    }
    else if (*transparency == TransparencyNearConstant)
    {
        if (minA != NULL && maxA != NULL)
        {
            *minA = (BYTE)(minAlpha >> 24);
            *maxA = (BYTE)(maxAlpha >> 24);
        }

        Bmp->SetMinMaxAlpha((BYTE)(minAlpha >> 24), (BYTE)(maxAlpha >> 24));

        newAlphaHint = GpMemoryBitmap::ALPHA_NEARCONSTANT;
    }
    else if (*transparency == TransparencyOpaque)
    {
        newAlphaHint = GpMemoryBitmap::ALPHA_OPAQUE;
    }

    Bmp->SetAlphaHint(newAlphaHint);

   return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Set the transparency state of the bitmap
*
* Arguments:
*
*   transparency        Returned state
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::SetTransparencyHint(
    DpTransparency transparency
    )
{
    GpStatus status = GenericError;

    if (Bmp != NULL)
    {
        INT alphaHint;

        // It's unfortunate that GpMemoryBitmap does not have
        // a DpTransparency flag internally, but there's a conflict
        // with imaging.dll and the include file structure that for
        // now makes it necessary to keep a separate type for this info.

        // In fact, ultimately it would be best if the overlap
        // between DpBitmap and GpMemoryBitmap is resolved including
        // a DpBitmap structure within the GpMemoryBitmap and then
        // removing the redundant info out GpMemoryBitmap.

        switch (transparency)
        {
        case TransparencySimple:
            alphaHint = GpMemoryBitmap::ALPHA_SIMPLE;
            break;

        case TransparencyOpaque:
            alphaHint = GpMemoryBitmap::ALPHA_OPAQUE;
            break;

        case TransparencyNoAlpha:
            alphaHint = GpMemoryBitmap::ALPHA_NONE;
            break;

        case TransparencyUnknown:
            alphaHint = GpMemoryBitmap::ALPHA_UNKNOWN;
            break;

        default:
            alphaHint = GpMemoryBitmap::ALPHA_COMPLEX;
            break;
        }

        HRESULT hr = Bmp->SetAlphaHint(alphaHint);

        if (SUCCEEDED(hr))
            status = Ok;
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Rotate and Flip the image in memory.
*
* Arguments:
*
*   [IN]rfType -- Rotate and Flip type
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   10/06/2000 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::RotateFlip(
    RotateFlipType rfType
    )
{
    if ( rfType == RotateNoneFlipNone )
    {
        // Same for Rotate180FlipXY, this is a No-OP

        return Ok;
    }

    if ( (IsDirty() == FALSE)
       &&(State >= MemBitmap)
       &&(SrcImageInfo.PixelFormat != PixelFormatInMem)
       &&(Img != NULL) )
    {
        // If the image is:
        // 1) Not dirty
        // 2) Was loaded into memory with different color depth for some reason,
        //    like DrawImage()
        // 3) We have an source image
        //
        // Then we can throw away the bits in memory and reload the bits from
        // the original. The purpose of this is that we should always do Rotate
        // or Flip on the original image.

        ASSERT( Bmp != NULL )
        Bmp->Release();
        Bmp = NULL;
        State = DecodedImg;
        PixelFormatInMem = PixelFormatUndefined;
    }

    // Rotate and Flip OP can only be done in memory
    // If the image hasn't been loaded, load into memory with the original
    // pixel format

    GpStatus    status = LoadIntoMemory(SrcImageInfo.PixelFormat);
    if ( status != Ok )
    {
        WARNING(("CopyOnWriteBitmap::RotateFlip---LoadIntoMemory() failed"));
        return status;
    }

    IBitmapImage* newBmp = NULL;

    HRESULT hResult = S_OK;

    switch ( rfType )
    {
    case Rotate90FlipNone:
        // Rotate270FlipXY    = Rotate90FlipNone

        hResult = Bmp->Rotate(90, INTERP_DEFAULT, &newBmp);
        break;

    case Rotate180FlipNone:
        // RotateNoneFlipXY   = Rotate180FlipNone

        hResult = Bmp->Rotate(180, INTERP_DEFAULT, &newBmp);
        break;

    case Rotate270FlipNone:
        // Rotate90FlipXY

        hResult = Bmp->Rotate(270, INTERP_DEFAULT, &newBmp);
        break;

    case RotateNoneFlipX:
        // Rotate180FlipY     = RotateNoneFlipX

        hResult = Bmp->Flip(TRUE, FALSE, &newBmp);
        break;

    case Rotate90FlipX:
        // Rotate270FlipY     = Rotate90FlipX

        hResult = Bmp->Rotate(90, INTERP_DEFAULT, &newBmp);
        if ( SUCCEEDED(hResult) )
        {
            Bmp->Release();
            Bmp = (GpMemoryBitmap*)newBmp;

            hResult = Bmp->Flip(TRUE, FALSE, &newBmp);
        }

        break;

    case Rotate180FlipX:
        // RotateNoneFlipY    = Rotate180FlipX

        hResult = Bmp->Rotate(180, INTERP_DEFAULT, &newBmp);
        if ( SUCCEEDED(hResult) )
        {
            Bmp->Release();
            Bmp = (GpMemoryBitmap*)newBmp;

            hResult = Bmp->Flip(TRUE, FALSE, &newBmp);
        }

        break;

    case Rotate270FlipX:
        // Rotate90FlipY      = Rotate270FlipX

        hResult = Bmp->Rotate(270, INTERP_DEFAULT, &newBmp);
        if ( SUCCEEDED(hResult) )
        {
            Bmp->Release();
            Bmp = (GpMemoryBitmap*)newBmp;

            hResult = Bmp->Flip(TRUE, FALSE, &newBmp);
        }

        break;

    default:
        WARNING(("CopyOnWriteBitmap::RotateFlip---Invalid input parameter"));
        return InvalidParameter;
    }

    if ( FAILED(hResult) )
    {
        WARNING(("CopyOnWriteBitmap::RotateFlip---Rotate failed"));
        return Win32Error;
    }

    // Check how many property items in this image

    UINT    uiNumOfProperty = 0;
    status = GetPropertyCount(&uiNumOfProperty);

    if ( status != Ok )
    {
        // It is OK if we failed to get property. We still have the Rotate/Flip
        // result

        WARNING(("CopyOnWriteBitmap::RotateFlip---GetPropertyCount() failed"));
    }

    if ( uiNumOfProperty > 0 )
    {
        PROPID* pList = (PROPID*)GpMalloc(uiNumOfProperty * sizeof(PROPID));
        if ( pList == NULL )
        {
            WARNING(("CopyOnWriteBitmap::RotateFlip---GpMalloc() failed"));
            return OutOfMemory;
        }

        status = GetPropertyIdList(uiNumOfProperty, pList);
        if ( status != Ok )
        {
            WARNING(("COnWriteBitmap::RotateFlip-GetPropertyIdList() failed"));
            GpFree(pList);
            return status;
        }

        UINT            uiItemSize = 0;
        PropertyItem*   pItem = NULL;

        GpMemoryBitmap* pTempBmp = (GpMemoryBitmap*)newBmp;

        // Loop through all the property items, get it from current image and
        // set it to the new image. Filter out and adjust some if necessary

        for ( int i = 0; i < (int)uiNumOfProperty; ++i )
        {
            // Get size for the i th property item

            status = GetPropertyItemSize(pList[i], &uiItemSize);
            if ( status != Ok )
            {
                WARNING(("COWBitmap::RotateFlip-GetPropertyItemSize() failed"));
                GpFree(pList);
                return status;
            }

            // Allocate memory buffer for receiving it

            pItem = (PropertyItem*)GpMalloc(uiItemSize);
            if ( pItem == NULL )
            {
                WARNING(("CopyOnWriteBitmap::RotateFlip---GpMalloc() failed"));
                GpFree(pList);
                return OutOfMemory;
            }

            // Get the i th property item

            status = GetPropertyItem(pList[i], uiItemSize, pItem);
            if ( status != Ok )
            {
                WARNING(("COWriteBitmap::RotateFlip-GetPropertyItem() failed"));
                GpFree(pItem);
                GpFree(pList);
                return status;
            }

            // We need to do some property information adjustment here according
            // to the rfType

            if ( (rfType == Rotate90FlipNone)
               ||(rfType == Rotate270FlipNone)
               ||(rfType == Rotate90FlipX)
               ||(rfType == Rotate270FlipX) )
            {
                // Swap the X and Y dimension info if rotate 90 or 270

                switch ( pList[i] )
                {
                case PropertyTagImageWidth:
                    pItem->id = PropertyTagImageHeight;
                    break;

                case PropertyTagImageHeight:
                    pItem->id = PropertyTagImageWidth;
                    break;

                case PropertyTagXResolution:
                    pItem->id = PropertyTagYResolution;
                    break;

                case PropertyTagYResolution:
                    pItem->id = PropertyTagXResolution;
                    break;

                case PropertyTagResolutionXUnit:
                    pItem->id = PropertyTagResolutionYUnit;
                    break;

                case PropertyTagResolutionYUnit:
                    pItem->id = PropertyTagResolutionXUnit;
                    break;

                case PropertyTagResolutionXLengthUnit:
                    pItem->id = PropertyTagResolutionYLengthUnit;
                    break;

                case PropertyTagResolutionYLengthUnit:
                    pItem->id = PropertyTagResolutionXLengthUnit;
                    break;

                case PropertyTagExifPixXDim:
                    pItem->id = PropertyTagExifPixYDim;
                    break;

                case PropertyTagExifPixYDim:
                    pItem->id = PropertyTagExifPixXDim;
                    break;

                default:
                    // For rest of property IDs, no need to swap

                    break;
                }
            }// Case of rotate 90 degree

            // Set the property item in the new GpMemoryBitmap object

            hResult = pTempBmp->SetPropertyItem(*pItem);
            if ( hResult != S_OK )
            {
                WARNING(("COWriteBitmap::RotateFlip-SetPropertyItem() failed"));
                GpFree(pItem);
                GpFree(pList);
                return MapHRESULTToGpStatus(hResult);
            }

            GpFree(pItem);
            pItem = NULL;
        }// Loop through all the property items

        GpFree(pList);
    }// if ( uiNumOfProperty > 0 )

    // Replace the image

    Bmp->Release();
    Bmp = (GpMemoryBitmap*)newBmp;
    State = MemBitmap;

    // Set special hack for JPEG image

    if (Img && (SpecialJPEGSave == TRUE))
    {
        Bmp->SetSpecialJPEG(Img);
    }

    SetDirtyFlag(TRUE);

    // Since this image is dirty now, we don't need to have any connection
    // with the original image if there is one

    GpFree(Filename);
    Filename = NULL;

    if ( NULL != Stream )
    {
        Stream->Release();
        Stream = NULL;
    }

    // We can't release the Img pointer until save() is called if this is a
    // special JPEG lossless transform save case

    if (Img && (SpecialJPEGSave == FALSE))
    {
        Img->Release();
        Img = NULL;
    }

    // Update image info

    hResult = Bmp->GetImageInfo(&SrcImageInfo);

    if ( SUCCEEDED(hResult) )
    {
        PixelFormatInMem = SrcImageInfo.PixelFormat;
    }
    else
    {
        WARNING(("CopyOnWriteBitmap::RotateFlip---GetImageInfo() failed"));
        return MapHRESULTToGpStatus(hResult);
    }

    return Ok;
}// RotateFlip()

// -------------------------------------------------------------------------

GpBitmap::GpBitmap(
    const CopyOnWriteBitmap *   internalBitmap
    ) : GpImage(ImageTypeBitmap), ScanBitmapRef(1)
{
    ASSERT((internalBitmap != NULL) && internalBitmap->IsValid());
    InternalBitmap = (CopyOnWriteBitmap *)internalBitmap;
    InternalBitmap->AddRef();
    ScanBitmap.SetBitmap(this);
}

GpBitmap::GpBitmap(
    BOOL    createInternalBitmap
    ) : GpImage(ImageTypeBitmap), ScanBitmapRef(1)
{
    if (createInternalBitmap)
    {
        // this case is used by the object factory for metafile playback
        InternalBitmap = new CopyOnWriteBitmap();
    }
    else
    {
        InternalBitmap = NULL;
    }
    ScanBitmap.SetBitmap(this);
}

GpBitmap::GpBitmap(
    const GpBitmap *    bitmap
    ) : GpImage(ImageTypeBitmap), ScanBitmapRef(1)
{
    ASSERT ((bitmap != NULL) && (bitmap->InternalBitmap != NULL) && bitmap->InternalBitmap->IsValid());
    InternalBitmap = (CopyOnWriteBitmap *)bitmap->InternalBitmap;
    InternalBitmap->AddRef();
    ScanBitmap.SetBitmap(this);
}

// Destructor
//  We don't want apps to use delete operator directly.
//  Instead, they should use the Dispose method.

GpBitmap::~GpBitmap()
{
    if (InternalBitmap != NULL)
    {
        InternalBitmap->Release();
        InternalBitmap = NULL;
    }
    ScanBitmap.FreeData();
}

CopyOnWriteBitmap *
GpBitmap::LockForWrite()
{
    ASSERT(InternalBitmap != NULL);

    CopyOnWriteBitmap *     writeableBitmap;

    writeableBitmap = (CopyOnWriteBitmap *)InternalBitmap->LockForWrite();

    if (writeableBitmap != NULL)
    {
        InternalBitmap = writeableBitmap;
        UpdateUid();
        return writeableBitmap;
    }

    return NULL;
}

VOID
GpBitmap::Unlock() const
{
    ASSERT(InternalBitmap != NULL);

    BOOL    valid = InternalBitmap->IsValid();

    InternalBitmap->Unlock();

    // If the operation we did on the internal bitmap somehow invalidated
    // it then invalidate this GpBitmap object as well.
    if (!valid)
    {
        InternalBitmap->Release();
        ((GpBitmap *)this)->InternalBitmap = NULL;
    }
}

VOID
GpBitmap::LockForRead() const
{
    ASSERT(InternalBitmap != NULL);

    InternalBitmap->LockForRead();
}

// Constructors

GpBitmap::GpBitmap(
    const WCHAR*    filename
    ) : GpImage(ImageTypeBitmap), ScanBitmapRef(1)
{
    InternalBitmap = CopyOnWriteBitmap::Create(filename);
    ASSERT((InternalBitmap == NULL) || InternalBitmap->IsValid());
    ScanBitmap.SetBitmap(this);
}

GpBitmap::GpBitmap(
    IStream*    stream
    ) : GpImage(ImageTypeBitmap), ScanBitmapRef(1)
{
    InternalBitmap = CopyOnWriteBitmap::Create(stream);
    ASSERT((InternalBitmap == NULL) || InternalBitmap->IsValid());
    ScanBitmap.SetBitmap(this);
}

GpBitmap::GpBitmap(
    INT             width,
    INT             height,
    PixelFormatID   format
    ) : GpImage(ImageTypeBitmap), ScanBitmapRef(1)
{
    InternalBitmap = CopyOnWriteBitmap::Create(width, height, format);
    ASSERT((InternalBitmap == NULL) || InternalBitmap->IsValid());
    ScanBitmap.SetBitmap(this);
}

GpBitmap::GpBitmap(
    INT             width,
    INT             height,
    PixelFormatID   format,
    GpGraphics *    graphics
    ) : GpImage(ImageTypeBitmap), ScanBitmapRef(1)
{
    InternalBitmap = CopyOnWriteBitmap::Create(width, height, format, graphics);
    ASSERT((InternalBitmap == NULL) || InternalBitmap->IsValid());
    ScanBitmap.SetBitmap(this);
}

GpBitmap::GpBitmap(
    INT             width,
    INT             height,
    INT             stride,     // negative for bottom-up bitmaps
    PixelFormatID   format,
    BYTE *          scan0
    ) : GpImage(ImageTypeBitmap), ScanBitmapRef(1)
{
    InternalBitmap = CopyOnWriteBitmap::Create(width, height, stride, format, scan0);
    ASSERT((InternalBitmap == NULL) || InternalBitmap->IsValid());
    ScanBitmap.SetBitmap(this);
}

GpBitmap::GpBitmap(
    BITMAPINFO*     gdiBitmapInfo,
    VOID*           gdiBitmapData,
    BOOL            ownBitmapData
    ) : GpImage(ImageTypeBitmap), ScanBitmapRef(1)
{
    InternalBitmap = CopyOnWriteBitmap::Create(gdiBitmapInfo, gdiBitmapData, ownBitmapData);
    ASSERT((InternalBitmap == NULL) || InternalBitmap->IsValid());
    ScanBitmap.SetBitmap(this);
}

GpBitmap::GpBitmap(
    IDirectDrawSurface7 *   surface
    ) : GpImage(ImageTypeBitmap), ScanBitmapRef(1)
{
    InternalBitmap = CopyOnWriteBitmap::Create(surface);
    ASSERT((InternalBitmap == NULL) || InternalBitmap->IsValid());
    ScanBitmap.SetBitmap(this);
}

GpImage*
GpBitmap::Clone() const
{
    return new GpBitmap(this);
}

GpBitmap*
GpBitmap::Clone(
    const GpRect*   rect,
    PixelFormatID   format
    ) const
{
    BOOL            isFullRect;

    isFullRect = ((rect == NULL) ||
                  ((rect->X == 0) && (rect->Y == 0) &&
                   (rect->Width == (INT)InternalBitmap->SrcImageInfo.Width) &&
                   (rect->Height == (INT)InternalBitmap->SrcImageInfo.Height)));

    // If rect is full size and format is same,
    // don't have to clone InternalBitmap.
    if (isFullRect &&
        ((format == PixelFormatDontCare) ||
         (format == InternalBitmap->SrcImageInfo.PixelFormat)))
    {
        return (GpBitmap *)this->Clone();
    }

    // else we have to do a clone of the internal bitmap
    GpBitmap *      newBitmap = new GpBitmap(FALSE);

    if (newBitmap != NULL)
    {
        LockForRead();
        if (isFullRect)
        {
            // It's faster to do the clone followed by the convert than
            // to do the convert as part of the clone.
            newBitmap->InternalBitmap = (CopyOnWriteBitmap *)InternalBitmap->Clone();
            if (newBitmap->InternalBitmap != NULL)
            {
                if (newBitmap->InternalBitmap->ConvertFormat(format, NULL, NULL) != Ok)
                {
                    newBitmap->InternalBitmap->Release();
                    newBitmap->InternalBitmap = NULL;
                }
            }
        }
        else
        {
            newBitmap->InternalBitmap = InternalBitmap->Clone(rect, format);
        }
        Unlock();
        if (newBitmap->InternalBitmap == NULL)
        {
            delete newBitmap;
            newBitmap = NULL;
        }
        else
        {
            ASSERT(newBitmap->InternalBitmap->IsValid());
        }
    }
    return newBitmap;
}

GpImage*
GpBitmap::CloneColorAdjusted(
    GpRecolor *             recolor,
    ColorAdjustType         type
    ) const
{
    GpBitmap * newBitmap = new GpBitmap(FALSE);

    if (newBitmap != NULL)
    {
        LockForRead();
        newBitmap->InternalBitmap = InternalBitmap->CloneColorAdjusted(recolor, type);
        Unlock();
        if (newBitmap->InternalBitmap == NULL)
        {
            delete newBitmap;
            newBitmap = NULL;
        }
        else
        {
            ASSERT(newBitmap->InternalBitmap->IsValid());
        }
    }
    return newBitmap;
}

// Similar to CloneColorAdjusted
GpStatus
GpBitmap::Recolor(
    GpRecolor *             recolor,
    GpBitmap **             dstBitmap,
    DrawImageAbort          callback,
    VOID *                  callbackData,
    GpRect *                rect
    )
{
    GpStatus        status    = GenericError;

    if (dstBitmap == NULL)
    {
        // recolor this object -- need write lock
        CopyOnWriteBitmap *     writeableBitmap = LockForWrite();

        if (writeableBitmap != NULL)
        {
            status = writeableBitmap->Recolor(recolor, NULL, callback, callbackData, rect);
            writeableBitmap->Unlock();
            UpdateUid();
        }
    }
    else    // recolor into dstBitmap
    {
        GpBitmap *      newBitmap = new GpBitmap(FALSE);

        if (newBitmap != NULL)
        {
            LockForRead();
            status = InternalBitmap->Recolor(recolor, &newBitmap->InternalBitmap, callback, callbackData, rect);
            Unlock();

            if (status != Ok)
            {
                delete newBitmap;
                newBitmap = NULL;
            }
            else
            {
                ASSERT((newBitmap->InternalBitmap != NULL) && (newBitmap->InternalBitmap->IsValid()));
            }
        }
        *dstBitmap = newBitmap;
    }
    return status;
}

GpStatus
GpBitmap::GetEncoderParameterListSize(
    IN  CLSID*              clsidEncoder,
    OUT UINT*               size
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->GetEncoderParameterListSize(clsidEncoder, size);
    Unlock();
    return status;
}

GpStatus
GpBitmap::GetEncoderParameterList(
    IN  CLSID*              clsidEncoder,
    IN  UINT                size,
    OUT EncoderParameters*  pBuffer
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->GetEncoderParameterList(clsidEncoder, size, pBuffer);
    Unlock();
    return status;
}

GpStatus
GpBitmap::SaveToStream(
    IStream*                stream,
    CLSID*                  clsidEncoder,
    EncoderParameters*      encoderParams
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->SaveToStream(stream, clsidEncoder, encoderParams);
    Unlock();
    return status;
}

GpStatus
GpBitmap::SaveToFile(
    const WCHAR*            filename,
    CLSID*                  clsidEncoder,
    EncoderParameters*      encoderParams
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->SaveToFile(filename, clsidEncoder, encoderParams);
    Unlock();
    return status;
}

GpStatus
GpBitmap::SaveAdd(
    const EncoderParameters*    encoderParams
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->SaveAdd(encoderParams);
    Unlock();
    return status;
}

GpStatus
GpBitmap::SaveAdd(
    GpImage*                    newBits,
    const EncoderParameters*    encoderParams
    )
{
    ASSERT(newBits != NULL);

    GpStatus status = InvalidParameter;

    if (newBits->GetImageType() == ImageTypeBitmap)
    {
        LockForRead();
        status = InternalBitmap->SaveAdd(((GpBitmap *)newBits)->InternalBitmap, encoderParams);
        Unlock();
    }
    return status;
}

// Dispose the bitmap object

VOID
GpBitmap::Dispose()
{
    if (InterlockedDecrement(&ScanBitmapRef) <= 0)
    {
        delete this;
    }
}

// Get bitmap information

GpStatus
GpBitmap::GetResolution(
    REAL*               xdpi,
    REAL*               ydpi
    ) const
{
    GpStatus status = Ok;
    LockForRead();
    *xdpi = (REAL)InternalBitmap->SrcImageInfo.Xdpi;
    *ydpi = (REAL)InternalBitmap->SrcImageInfo.Ydpi;
    Unlock();
    return status;
}

GpStatus
GpBitmap::GetPhysicalDimension(
    REAL*               width,
    REAL*               height
    ) const
{
    GpStatus status = Ok;
    LockForRead();
    *width  = (REAL)InternalBitmap->SrcImageInfo.Width;
    *height = (REAL)InternalBitmap->SrcImageInfo.Height;
    Unlock();
    return status;
}

GpStatus
GpBitmap::GetBounds(
    GpRectF*            rect,
    GpPageUnit*         unit
    ) const
{
    GpStatus status = Ok;
    LockForRead();
    rect->X = rect->Y = 0;
    rect->Width  = (REAL) InternalBitmap->SrcImageInfo.Width;
    rect->Height = (REAL) InternalBitmap->SrcImageInfo.Height;
    *unit = UnitPixel;
    Unlock();
    return status;
}

GpStatus
GpBitmap::GetSize(
    Size*               size
    ) const
{
    GpStatus status = Ok;
    LockForRead();
    size->Width  = InternalBitmap->SrcImageInfo.Width;
    size->Height = InternalBitmap->SrcImageInfo.Height;
    Unlock();
    return status;
}

GpStatus
GpBitmap::GetImageInfo(
    ImageInfo *         imageInfo
    ) const
{
    if (NULL == imageInfo)
    {
        return InvalidParameter;
    }

    GpStatus status = Ok;
    LockForRead();
    InternalBitmap->GetImageInfo(imageInfo);
    Unlock();
    return status;
}

GpImage*
GpBitmap::GetThumbnail(
    UINT                    thumbWidth,
    UINT                    thumbHeight,
    GetThumbnailImageAbort  callback,
    VOID *                  callbackData
    )
{
    GpBitmap * newBitmap = new GpBitmap(FALSE);

    if (newBitmap != NULL)
    {
        LockForRead();
        newBitmap->InternalBitmap = InternalBitmap->GetThumbnail(thumbWidth, thumbHeight, callback, callbackData);
        Unlock();
        if (newBitmap->InternalBitmap == NULL)
        {
            delete newBitmap;
            newBitmap = NULL;
        }
        else
        {
            ASSERT(newBitmap->InternalBitmap->IsValid());
        }
    }
    return newBitmap;
}

GpStatus
GpBitmap::GetFrameCount(
    const GUID*     dimensionID,
    UINT*           count
    ) const
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->GetFrameCount(dimensionID, count);
    Unlock();
    return status;
}

GpStatus
GpBitmap::GetFrameDimensionsCount(
    OUT UINT*       count
    ) const
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->GetFrameDimensionsCount(count);
    Unlock();
    return status;
}

GpStatus
GpBitmap::GetFrameDimensionsList(
    OUT GUID*       dimensionIDs,
    IN UINT         count
    ) const
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->GetFrameDimensionsList(dimensionIDs, count);
    Unlock();
    return status;
}

GpStatus
GpBitmap::SelectActiveFrame(
    const GUID*     dimensionID,
    UINT            frameIndex
    )
{
    CopyOnWriteBitmap *     writeableBitmap = LockForWrite();

    if (writeableBitmap != NULL)
    {
        GpStatus    status;
        status = writeableBitmap->SelectActiveFrame(dimensionID, frameIndex);
        writeableBitmap->Unlock();
        UpdateUid();
        return status;
    }
    return GenericError;
}

GpStatus
GpBitmap::GetPalette(
    ColorPalette *      palette,
    INT                 size
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->GetPalette(palette, size);
    Unlock();
    return status;
}

GpStatus
GpBitmap::SetPalette(
    ColorPalette *      palette
    )
{
    CopyOnWriteBitmap *     writeableBitmap = LockForWrite();

    if (writeableBitmap != NULL)
    {
        GpStatus    status;
        status = writeableBitmap->SetPalette(palette);
        writeableBitmap->Unlock();
        UpdateUid();
        return status;
    }
    return GenericError;
}

INT
GpBitmap::GetPaletteSize()
{
    INT size;
    LockForRead();
    size = InternalBitmap->GetPaletteSize();
    Unlock();
    return size;
}

GpStatus
GpBitmap::GetTransparencyHint(
    DpTransparency*     transparency
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->GetTransparencyHint(transparency);
    Unlock();
    return status;
}

GpStatus
GpBitmap::SetTransparencyHint(
    DpTransparency      transparency
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->SetTransparencyHint(transparency);
    Unlock();
    UpdateUid();
    return status;
}

GpStatus
GpBitmap::GetTransparencyFlags(
    DpTransparency*     transparency,
    PixelFormatID       loadFormat,
    BYTE*               minAlpha,
    BYTE*               maxAlpha
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->GetTransparencyFlags(transparency, loadFormat, minAlpha, maxAlpha);
    Unlock();
    return status;
}

// Property related functions

GpStatus
GpBitmap::GetPropertyCount(
    UINT*       numOfProperty
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->GetPropertyCount(numOfProperty);
    Unlock();
    return status;
}

GpStatus
GpBitmap::GetPropertyIdList(
    UINT        numOfProperty,
    PROPID*     list
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->GetPropertyIdList(numOfProperty, list);
    Unlock();
    return status;
}

GpStatus
GpBitmap::GetPropertyItemSize(
    PROPID      propId,
    UINT*       size
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->GetPropertyItemSize(propId, size);
    Unlock();
    return status;
}

GpStatus
GpBitmap::GetPropertyItem(
    PROPID          propId,
    UINT            propSize,
    PropertyItem*   buffer
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->GetPropertyItem(propId, propSize, buffer);
    Unlock();
    return status;
}

GpStatus
GpBitmap::GetPropertySize(
    UINT*           totalBufferSize,
    UINT*           numProperties
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->GetPropertySize(totalBufferSize, numProperties);
    Unlock();
    return status;
}

GpStatus
GpBitmap::GetAllPropertyItems(
    UINT            totalBufferSize,
    UINT            numProperties,
    PropertyItem*   allItems
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->GetAllPropertyItems(totalBufferSize, numProperties, allItems);
    Unlock();
    return status;
}

GpStatus
GpBitmap::RemovePropertyItem(
    PROPID      propId
    )
{
    CopyOnWriteBitmap *     writeableBitmap = LockForWrite();

    if (writeableBitmap != NULL)
    {
        GpStatus    status;
        status = writeableBitmap->RemovePropertyItem(propId);
        writeableBitmap->Unlock();
        UpdateUid();
        return status;
    }
    return GenericError;
}

GpStatus
GpBitmap::SetPropertyItem(
    PropertyItem*       item
    )
{
    CopyOnWriteBitmap *     writeableBitmap = LockForWrite();

    if (writeableBitmap != NULL)
    {
        GpStatus    status;
        status = writeableBitmap->SetPropertyItem(item);
        writeableBitmap->Unlock();
        UpdateUid();
        return status;
    }
    return GenericError;
}

// Retrieve bitmap data

GpStatus
GpBitmap::LockBits(
    const GpRect*   rect,
    UINT            flags,
    PixelFormatID   pixelFormat,
    BitmapData*     bmpdata,
    INT             width,
    INT             height
    ) const
{
    ASSERT(InternalBitmap != NULL);
    
    if (flags & ImageLockModeWrite)
    {
        CopyOnWriteBitmap *     writeableBitmap = ((GpBitmap *)this)->LockForWrite();

        if (writeableBitmap != NULL)
        {
            GpStatus    status;
            status = writeableBitmap->LockBits(rect, flags, pixelFormat, bmpdata, width, height);
            writeableBitmap->Unlock();
            return status;
        }
        return GenericError;
    }
    else
    {
        // Lock For read case
        // First we need to check if this is the 1st LockForRead on this image
        // object or not.

        if ( InternalBitmap->ObjRefCount > 1 )
        {
            // We have more than one LockForRead on this object
            // Note: this part needs to be re-visited in V2. We have a big
            // problem here not allowing user to do more than once for LockBits
            // for read. So we need to make a copy even though theory says
            // that we should not have to.

            CopyOnWriteBitmap *     writeableBitmap = ((GpBitmap *)this)->LockForWrite();

            if (writeableBitmap != NULL)
            {
                GpStatus    status;
                status = writeableBitmap->LockBits(rect, flags, pixelFormat, bmpdata, width, height);
                writeableBitmap->Unlock();
                return status;
            }
            return GenericError;
        }
        else
        {
            GpStatus status;
            LockForRead();
            status = InternalBitmap->LockBits(rect, flags, pixelFormat, bmpdata, width, height);
            Unlock();
            return status;
        }
    }
}

GpStatus
GpBitmap::UnlockBits(
    BitmapData*     bmpdata,
    BOOL            Destroy
    ) const
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->UnlockBits(bmpdata, Destroy);
    Unlock();
    return status;
}

// Get and set pixel on the bitmap.
GpStatus
GpBitmap::GetPixel(
    INT         x,
    INT         y,
    ARGB *      color
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->GetPixel(x, y, color);
    Unlock();
    return status;
}

GpStatus
GpBitmap::SetPixel(
    INT         x,
    INT         y,
    ARGB        color
    )
{
    CopyOnWriteBitmap *     writeableBitmap = LockForWrite();

    if (writeableBitmap != NULL)
    {
        GpStatus    status;
        status = writeableBitmap->SetPixel(x, y, color);
        writeableBitmap->Unlock();
        UpdateUid();
        return status;
    }
    return GenericError;
}

GpStatus
GpBitmap::RotateFlip(
    RotateFlipType rfType
    )
{
    CopyOnWriteBitmap*     pWriteableBitmap = LockForWrite();

    if ( pWriteableBitmap != NULL )
    {
        GpStatus    status = pWriteableBitmap->RotateFlip(rfType);

        pWriteableBitmap->Unlock();
        UpdateUid();

        return status;
    }

    return GenericError;
}// RotateFlip()

BOOL
GpBitmap::IsDirty() const
{
    LockForRead();
    BOOL dirty = InternalBitmap->IsDirty();
    Unlock();
    return dirty;
}

// Derive a graphics context on top of the bitmap object

GpGraphics*
GpBitmap::GetGraphicsContext()
{
    CopyOnWriteBitmap *     writeableBitmap = LockForWrite();

    if (writeableBitmap != NULL)
    {
        GpGraphics *    g = NULL;

        // NTRAID#NTBUG9-368452-2001-04-13-gilmanw "ISSUE: allow only one GpGraphics per bitmap"
        //
        // Currently create a new GpGraphics each time GetGraphicsContext
        // is called.  Perhaps should cache the GpGraphics and return that
        // to all callers.  Otherwise, there may be synchronization issues
        // if there are multiple GpGraphics per surface.

        if (writeableBitmap->State == MemBitmap && writeableBitmap->Bmp != NULL &&
            writeableBitmap->Bmp->creationFlag == GpMemoryBitmap::CREATEDFROM_DDRAWSURFACE)
        {
            // NTRAID#NTBUG9-368458-2001-04-13-gilmanw "ISSUE: lose association with Image for DDraw surfs"
            //
            // The Image as well as the graphics are only wrappers around the
            // direct draw surface.  When we create the GpGraphics in this
            // way we lose all association with the Image (CopyOnWriteBitmap)
            // object.  This may not be the right behavior.

            g = GpGraphics::GetFromDirectDrawSurface(writeableBitmap->Bmp->ddrawSurface);
        }
        else
        {
            ImageInfo imageInfo;
            writeableBitmap->GetImageInfo(&imageInfo);

            // since GpGraphics will end up pointing to ScanBitmap structure
            // we need to make sure bitmap won't be deleted while
            // there is a graphics wrapped around it

            IncScanBitmapRef();
            g = GpGraphics::GetFromGdipBitmap(this, &imageInfo, &ScanBitmap, writeableBitmap->Display);
            if (!CheckValid(g))
            {
                DecScanBitmapRef();
            }
        }

        writeableBitmap->Unlock();
        return g;
    }
    return NULL;
}

GpStatus
GpBitmap::InitializeSurfaceForGdipBitmap(
    DpBitmap *      surface,
    INT             width,
    INT             height
    )
{
    GpStatus status = Ok;

    // Currently this is only called when preparing a surface as a source
    // surface, not as a dest surface, so we only need a read lock.
    LockForRead();
    ImageInfo imageInfo;
    InternalBitmap->GetImageInfo(&imageInfo);
    surface->InitializeForGdipBitmap(width, height, &imageInfo, &ScanBitmap, InternalBitmap->Display);
    Unlock();
    return status;
}

// Derive an HDC for interop on top of the bitmap object

HDC
GpBitmap::GetHdc()
{
    CopyOnWriteBitmap *     writeableBitmap = LockForWrite();

    if (writeableBitmap != NULL)
    {
        HDC     hdc;
        hdc = writeableBitmap->GetHdc();
        writeableBitmap->Unlock();
        return hdc;
    }
    return NULL;
}

VOID
GpBitmap::ReleaseHdc(HDC hdc)
{
    LockForRead();
    InternalBitmap->ReleaseHdc(hdc);
    Unlock();
    return;
}

// Serialization

UINT
GpBitmap::GetDataSize() const
{
    UINT dataSize;
    LockForRead();
    dataSize = InternalBitmap->GetDataSize();
    Unlock();
    return dataSize;
}

GpStatus
GpBitmap::GetData(
    IStream *       stream
    ) const
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->GetData(stream);
    Unlock();
    return status;
}

GpStatus
GpBitmap::SetData(
    const BYTE *        dataBuffer,
    UINT                size
    )
{
    CopyOnWriteBitmap *     writeableBitmap = LockForWrite();

    if (writeableBitmap != NULL)
    {
        GpStatus    status;
        status = writeableBitmap->SetData(dataBuffer, size);
        writeableBitmap->Unlock();
        UpdateUid();
        return status;
    }
    return GenericError;
}

GpStatus
GpBitmap::GetCompressedData(
    DpCompressedData *      compressed_data,
    BOOL                    getJPEG,
    BOOL                    getPNG,
    HDC                     hdc
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->GetCompressedData(compressed_data, getJPEG, getPNG, hdc);
    Unlock();
    return status;
}

GpStatus
GpBitmap::DeleteCompressedData(
    DpCompressedData *  compressed_data
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->DeleteCompressedData(compressed_data);
    Unlock();
    UpdateUid();
    return status;
}

// Color adjust

GpStatus
GpBitmap::ColorAdjust(
    GpRecolor *         recolor,
    ColorAdjustType     type
    )
{
    CopyOnWriteBitmap *     writeableBitmap = LockForWrite();

    if (writeableBitmap != NULL)
    {
        GpStatus    status;
        status = writeableBitmap->ColorAdjust(recolor, type);
        writeableBitmap->Unlock();
        UpdateUid();
        return status;
    }
    return GenericError;
}

GpStatus
GpBitmap::ColorAdjust(
    GpRecolor *         recolor,
    PixelFormatID       pixfmt,
    DrawImageAbort      callback,
    VOID *              callbackData
    )
{
    CopyOnWriteBitmap *     writeableBitmap = LockForWrite();

    if (writeableBitmap != NULL)
    {
        GpStatus    status;
        status = writeableBitmap->ColorAdjust(recolor, pixfmt, callback, callbackData);
        writeableBitmap->Unlock();
        UpdateUid();
        return status;
    }
    return GenericError;
}

GpStatus
GpBitmap::GetPixelFormatID(
    PixelFormatID*      pixfmt
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->GetPixelFormatID(pixfmt);
    Unlock();
    return status;
}

INT
GpBitmap::GetDecodeState()
{
    INT decodeState;
    LockForRead();
    decodeState = InternalBitmap->State;
    Unlock();
    return decodeState;
}

GpStatus
GpBitmap::ForceValidation()
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->LoadIntoMemory(PixelFormatDontCare, NULL, NULL);
    Unlock();
    return status;
}

GpStatus
GpBitmap::SetResolution(
    REAL    xdpi,
    REAL    ydpi
    )
{
    CopyOnWriteBitmap *     writeableBitmap = LockForWrite();

    if (writeableBitmap != NULL)
    {
        GpStatus    status;
        status = writeableBitmap->SetResolution(xdpi, ydpi);
        writeableBitmap->Unlock();
        UpdateUid();
        return status;
    }
    return GenericError;
}

GpStatus
GpBitmap::PreDraw(
    INT             numPoints,
    GpPointF *      dstPoints,
    GpRectF *       srcRect,
    INT             numBitsPerPixel
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->PreDraw(numPoints, dstPoints, srcRect, numBitsPerPixel);
    Unlock();
    return status;
}

// Interop:

GpStatus
GpBitmap::CreateFromHBITMAP(
    HBITMAP         hbm,
    HPALETTE        hpal,
    GpBitmap**      bitmap
    )
{
    ASSERT(bitmap != NULL);
    GpStatus        status    = GenericError;
    GpBitmap *      newBitmap = new GpBitmap(FALSE);

    if (newBitmap != NULL)
    {
        status = CopyOnWriteBitmap::CreateFromHBITMAP(hbm, hpal, &newBitmap->InternalBitmap);

        if (status != Ok)
        {
            delete newBitmap;
            newBitmap = NULL;
        }
        else
        {
            ASSERT((newBitmap->InternalBitmap != NULL) && (newBitmap->InternalBitmap->IsValid()));
        }
    }
    *bitmap = newBitmap;
    return status;
}

GpStatus
GpBitmap::CreateBitmapAndFillWithBrush(
    InterpolationMode   interpolationMode,
    PixelOffsetMode     pixelOffsetMode,
    const GpMatrix *    worldToDevice,
    const GpRect *      drawBounds,
    GpBrush *           brush,
    GpBitmap **         bitmap,
    PixelFormatID       pixelFormat
    )
{
    ASSERT ((drawBounds->Width > 0) && (drawBounds->Height > 0));
    ASSERT (bitmap != NULL);

    GpStatus    status = GenericError;

    *bitmap = NULL;

    // First, construct the correct brush transform to use when rendering
    // into the bitmap.  The brush transform is the concatenation of the
    // current brush transform, the current worldToDevice transform, and
    // a translation transform that maps from the drawBounds to the
    // bitmap bounds.

    GpMatrix    saveBrushMatrix;
    GpMatrix *  deviceMatrix = const_cast<GpMatrix *>(&((brush->GetDeviceBrush())->Xform));

    saveBrushMatrix = *deviceMatrix;

    GpMatrix    newBrushMatrix = saveBrushMatrix;

    if (worldToDevice != NULL)
    {
        newBrushMatrix.Append(*worldToDevice);
    }

    newBrushMatrix.Translate(
        (REAL)-(drawBounds->X),
        (REAL)-(drawBounds->Y),
        MatrixOrderAppend
    );


    BOOL    restoreWrapMode = FALSE;

    // When we're drawing a texture brush into a bitmap, if the texture is
    // supposed to fill the bitmap, then don't use clamp mode, because clamp
    // mode will end up bleeding alpha into the image along the right and
    // bottom edges, which is undesirable -- especially for down-level bitmaps
    // where we end up with what looks like a dotted line along the edges
    // of the bitmap.
    if ((brush->GetBrushType() == BrushTypeTextureFill) &&
        (((GpTexture *)brush)->GetWrapMode() == WrapModeClamp) &&
        (newBrushMatrix.IsTranslateScale()))
    {
        GpBitmap* brushBitmap = ((GpTexture *)brush)->GetBitmap();
        if (brushBitmap != NULL)
        {
            Size    size;
            brushBitmap->GetSize(&size);

            GpRectF     transformedRect(0.0f, 0.0f, (REAL)size.Width, (REAL)size.Height);
            newBrushMatrix.TransformRect(transformedRect);

            // get the transformed width
            INT     deltaValue = abs(GpRound(transformedRect.Width) - drawBounds->Width);

            // We might be off a little because of the pixel offset mode
            // or a matrix that isn't quite right for whatever reason.
            if (deltaValue <= 2)
            {
                // get the transformed height
                deltaValue = abs(GpRound(transformedRect.Height) - drawBounds->Height);

                if (deltaValue <= 2)
                {
                    if ((abs(GpRound(transformedRect.X)) <= 2) &&
                        (abs(GpRound(transformedRect.Y)) <= 2))
                    {
                        ((GpTexture *)brush)->SetWrapMode(WrapModeTileFlipXY);
                        restoreWrapMode = TRUE;
                    }
                }
            }
        }
    }

    if (newBrushMatrix.IsInvertible())
    {
        *deviceMatrix = newBrushMatrix;

        GpBitmap *  bitmapImage = new GpBitmap(drawBounds->Width, drawBounds->Height, pixelFormat);

        if (bitmapImage != NULL)
        {
            if (bitmapImage->IsValid())
            {
                GpGraphics *    graphics = bitmapImage->GetGraphicsContext();

                if (graphics != NULL)
                {
                    if (graphics->IsValid())
                    {
                        // we have to lock the graphics so the driver doesn't assert
                        GpLock  lockGraphics(graphics->GetObjectLock());

                        ASSERT(lockGraphics.IsValid());

                        graphics->SetCompositingMode(CompositingModeSourceCopy);
                        graphics->SetInterpolationMode(interpolationMode);
                        graphics->SetPixelOffsetMode(pixelOffsetMode);

                        // now fill the bitmap image with the brush
                        GpRectF     destRect(0.0f, 0.0f, (REAL)drawBounds->Width, (REAL)drawBounds->Height);
                        status = graphics->FillRects(brush, &destRect, 1);
                    }
                    else
                    {
                        WARNING(("graphics from bitmap image not valid"));
                    }
                    delete graphics;
                }
                else
                {
                    WARNING(("could not create graphics from bitmap image"));
                }
            }
            else
            {
                WARNING(("bitmap image is not valid"));
            }
            if (status == Ok)
            {
                *bitmap = bitmapImage;
            }
            else
            {
                bitmapImage->Dispose();
            }
        }
        else
        {
            WARNING(("could not create bitmap image"));
        }
        *deviceMatrix = saveBrushMatrix;
    }

    if (restoreWrapMode)
    {
        ((GpTexture *)brush)->SetWrapMode(WrapModeClamp);
    }
    return status;
}

GpStatus
GpBitmap::DrawAndHalftoneForStretchBlt(
    HDC                 hdc,
    BITMAPINFO *        bmpInfo,
    BYTE       *        bits,
    INT                 srcX,
    INT                 srcY,
    INT                 srcWidth,
    INT                 srcHeight,
    INT                 destWidth,
    INT                 destHeight,
    BITMAPINFO **       destBmpInfo,
    BYTE       **       destBmpBits,
    HBITMAP    *        destDIBSection,
    InterpolationMode   interpolationMode
    )
{
    ASSERT(hdc != NULL && bmpInfo != NULL && bits != NULL &&
           destBmpInfo != NULL && destBmpBits != NULL &&
           destDIBSection != NULL);
    ASSERT(destWidth > 0 && destHeight > 0);

    GpStatus status = GenericError;

    ASSERT(::GetDeviceCaps(hdc, BITSPIXEL) == 8);
    *destBmpInfo = (BITMAPINFO*) GpMalloc(sizeof(BITMAPINFOHEADER) + 256 * sizeof(RGBQUAD));

    if (*destBmpInfo == NULL)
    {
        return OutOfMemory;
    }

    BITMAPINFO *dst = *destBmpInfo;
    GpMemset(dst, 0, sizeof(BITMAPINFOHEADER) + 256 * sizeof(RGBQUAD));
    dst->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    dst->bmiHeader.biPlanes = 1;
    dst->bmiHeader.biBitCount = 8;
    dst->bmiHeader.biWidth = destWidth;
    dst->bmiHeader.biHeight = destHeight;

    // We need to create a Memory DC to select a DibSection into it and finally
    // wrap a graphics around it.

    HPALETTE currentPalette = (HPALETTE)::GetCurrentObject(hdc, OBJ_PAL);
    WORD paletteEntries;
    ::GetObjectA(currentPalette, sizeof(WORD), (LPVOID)&paletteEntries);
    ::GetPaletteEntries(currentPalette, 0, paletteEntries, (LPPALETTEENTRY) &(dst->bmiColors));
    dst->bmiHeader.biClrUsed = paletteEntries;
    HDC     memDC   = ::CreateCompatibleDC(hdc);
    *destDIBSection = ::CreateDIBSection(hdc, dst, DIB_RGB_COLORS,
                                         (VOID**) destBmpBits, NULL, 0);

    if (*destDIBSection != NULL && memDC != NULL)
    {
        ::SelectObject(memDC, *destDIBSection);
        ::SelectPalette(memDC, currentPalette, FALSE);
        ::RealizePalette(memDC);
        GpGraphics *g = GpGraphics::GetFromHdc(memDC);
        if (g != NULL)
        {
            if(g->IsValid())
            {
                GpBitmap *src = new GpBitmap(bmpInfo, bits, FALSE);
                if (src != NULL)
                {
                    if( src->IsValid())
                    {
                        GpLock lock(g->GetObjectLock());
                        g->SetCompositingMode(CompositingModeSourceCopy);
                        g->SetInterpolationMode(interpolationMode);
                        g->SetPixelOffsetMode(PixelOffsetModeHalf);
                        status = g->DrawImage(src,
                                              GpRectF(0.0f, 0.0f, (REAL)destWidth, (REAL)destHeight),
                                              GpRectF((REAL)srcX, (REAL)srcY, (REAL)srcWidth, (REAL)srcHeight),
                                              UnitPixel);
                    }
                    src->Dispose();
                }
                delete g;
            }
        }
    }


    if (memDC != NULL)
    {
        ::DeleteDC(memDC);
    }

    // If we failed delete our allocations
    if (status != Ok)
    {
        GpFree(*destBmpInfo);
        *destBmpInfo = NULL;
        if (*destDIBSection != NULL)
        {
            ::DeleteObject(*destDIBSection);
            *destDIBSection = NULL;
        }
        *destBmpBits = NULL;
    }

    return status;
}



GpStatus
GpBitmap::CreateHBITMAP(
    HBITMAP *       phbm,
    ARGB            background
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->CreateHBITMAP(phbm, background);
    Unlock();
    return status;
}

GpStatus
GpBitmap::ICMFrontEnd(
    GpBitmap **     dstBitmap,
    DrawImageAbort  callback,
    VOID *          callbackData,
    GpRect *        rect
    )
{
    GpStatus        status    = GenericError;

    if (dstBitmap == NULL)
    {
        // change this object -- need write lock
        CopyOnWriteBitmap *     writeableBitmap = LockForWrite();

        if (writeableBitmap != NULL)
        {
            status = writeableBitmap->ICMFrontEnd(NULL, callback, callbackData, rect);
            writeableBitmap->Unlock();
            UpdateUid();
        }
    }
    else    // use dstBitmap
    {
        GpBitmap *      newBitmap = new GpBitmap(FALSE);

        if (newBitmap != NULL)
        {
            LockForRead();
            status = InternalBitmap->ICMFrontEnd(&newBitmap->InternalBitmap, callback, callbackData, rect);
            Unlock();

            if (status != Ok)
            {
                delete newBitmap;
                newBitmap = NULL;
            }
            else
            {
                ASSERT((newBitmap->InternalBitmap != NULL) && (newBitmap->InternalBitmap->IsValid()));
            }
        }
        *dstBitmap = newBitmap;
    }
    return status;
}

GpStatus
GpBitmap::CreateFromHICON(
    HICON           hicon,
    GpBitmap**      bitmap
    )
{
    ASSERT(bitmap != NULL);
    GpStatus        status    = GenericError;
    GpBitmap *      newBitmap = new GpBitmap(FALSE);

    if (newBitmap != NULL)
    {
        status = CopyOnWriteBitmap::CreateFromHICON(hicon, &newBitmap->InternalBitmap);

        if (status != Ok)
        {
            delete newBitmap;
            newBitmap = NULL;
        }
        else
        {
            ASSERT((newBitmap->InternalBitmap != NULL) && (newBitmap->InternalBitmap->IsValid()));
        }
    }
    *bitmap = newBitmap;
    return status;
}

GpStatus
GpBitmap::CreateHICON(
    HICON *     phicon
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->CreateHICON(phicon);
    Unlock();
    return status;
}

GpStatus
GpBitmap::CreateFromResource(
    HINSTANCE       hInstance,
    LPWSTR          lpBitmapName,
    GpBitmap**      bitmap
    )
{
    ASSERT(bitmap != NULL);
    GpStatus        status    = GenericError;
    GpBitmap *      newBitmap = new GpBitmap(FALSE);

    if (newBitmap != NULL)
    {
        status = CopyOnWriteBitmap::CreateFromResource(hInstance, lpBitmapName, &newBitmap->InternalBitmap);

        if (status != Ok)
        {
            delete newBitmap;
            newBitmap = NULL;
        }
        else
        {
            ASSERT((newBitmap->InternalBitmap != NULL) && (newBitmap->InternalBitmap->IsValid()));
        }
    }
    *bitmap = newBitmap;
    return status;
}

// We need to know if the bitmap is associated with a display
// so we know how to handle the page transform when it is
// set to UnitDisplay.
BOOL
GpBitmap::IsDisplay() const
{
    BOOL    isDisplay;
    LockForRead();
    isDisplay = InternalBitmap->Display;
    Unlock();
    return isDisplay;
}

VOID
GpBitmap::SetDisplay(
    BOOL        display
    )
{
    CopyOnWriteBitmap *     writeableBitmap = LockForWrite();

    if (writeableBitmap != NULL)
    {
        writeableBitmap->Display = display;
        writeableBitmap->Unlock();
        UpdateUid();
    }
    return;
}

BOOL
GpBitmap::IsICMConvert() const
{
    BOOL    isICMConvert;
    LockForRead();
    isICMConvert = InternalBitmap->ICMConvert;
    Unlock();
    return isICMConvert;
}

VOID
GpBitmap::SetICMConvert(
    BOOL        icm
    )
{
    CopyOnWriteBitmap *     writeableBitmap = LockForWrite();

    if (writeableBitmap != NULL)
    {
        writeableBitmap->ICMConvert = icm;
        writeableBitmap->Unlock();
        UpdateUid();
    }
    return;
}

BOOL
GpBitmap::IsValid() const
{
    // If the bitmap came from a different version of GDI+, its tag
    // will not match, and it won't be considered valid.
    return ((InternalBitmap != NULL) && InternalBitmap->IsValid()
            && GpImage::IsValid());
}

GpStatus
ConvertTo16BppAndFlip(
    GpBitmap *      sourceBitmap,
    GpBitmap * &    destBitmap
    )
{
    ASSERT ((sourceBitmap != NULL) && sourceBitmap->IsValid());

    GpStatus    status = GenericError;
    Size        size;

    sourceBitmap->GetSize(&size);
    
    destBitmap = new GpBitmap(size.Width, size.Height, PixelFormat16bppRGB555);
    if ((destBitmap != NULL) && destBitmap->IsValid())
    {
        // We have to draw it with a graphics, because if we just
        // clone it, then the format converter is used which doesn't
        // do dithering.
        GpGraphics * g = destBitmap->GetGraphicsContext();

        if (g != NULL)
        {
            if (g->IsValid())
            {
                // we have to lock the graphics so the driver doesn't assert
                GpLock  lockGraphics(g->GetObjectLock());

                ASSERT(lockGraphics.IsValid());

                // flip it upside down like GDI wants it
                GpRectF realDestRect(0.0f, (REAL)size.Height, (REAL)size.Width, (REAL)(-size.Height));
                g->SetCompositingMode(CompositingModeSourceCopy);
                g->SetInterpolationMode(InterpolationModeNearestNeighbor);
                g->SetPixelOffsetMode(PixelOffsetModeHalf);
                status = g->DrawImage(sourceBitmap, realDestRect);
            }
            delete g;
        }
    }
    if ((status != Ok) && (destBitmap != NULL))
    {
        destBitmap->Dispose();
        destBitmap = NULL;
    }
    
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\graphicsclip.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   GraphicsClip.cpp
*
* Abstract:
*
*   Clipping methods of Graphics class
*
* Created:
*
*   02/05/1999 DCurtis
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Function Description:
*
*   Get a copy of the current clipping region.  Transform it through the
*   inverse of the current world-to-device matrix, so that if this region
*   was immediately set as the clipping, then the clipping wouldn't change.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   GpRegion * region - a copy of the current clipping region; must be
*                       deleted by the application.
*
* Created:
*
*   02/09/1999 DCurtis
*
\**************************************************************************/
GpRegion*
GpGraphics::GetClip() const
{
    ASSERT(this->IsValid());

    GpRegion *  region = new GpRegion(&(Context->AppClip));

    if (region != NULL)
    {
        if (region->IsValid())
        {
            GpMatrix    deviceToWorld;

            if ((GetDeviceToWorldTransform(&deviceToWorld) == Ok) &&
                (region->Transform(&deviceToWorld) == Ok))
            {
                return region;
            }
        }
        delete region;
    }
    return NULL;
}

/**************************************************************************\
*
* Function Description:
*
*   Get a copy of the current clipping region.  Transform it through the
*   inverse of the current world-to-device matrix, so that if this region
*   was immediately set as the clipping, then the clipping wouldn't change.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   GpRegion * region - an already created region, we set the contents of it.
*
* Created:
*
*   02/09/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpGraphics::GetClip(GpRegion* region) const
{
    ASSERT(this->IsValid());

    region->Set(&(Context->AppClip));

    if (region->IsValid())
    {
        GpMatrix    deviceToWorld;

        if ((GetDeviceToWorldTransform(&deviceToWorld) == Ok) &&
            (region->Transform(&deviceToWorld) == Ok))
        {
            return Ok;
        }
    }
    
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Reset the clipping back to its default state.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   02/09/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpGraphics::ResetClip()
{
    ASSERT(this->IsValid());

    GpStatus    status = Ok;

    if (IsRecording())
    {
        status = Metafile->RecordResetClip();
        if (status != Ok)
        {
            SetValid(FALSE);      // Prevent any more recording
            return status;
        }
    }

    DoResetClip();
    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Set the clipping in the graphics context to be the specified rect.
*
* Arguments:
*
*   [IN]  rect        - the rectangle, in world units
*   [IN]  combineMode - the combine operator (and, or, xor, exclude, complement)
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   02/05/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpGraphics::SetClip(
    const GpRectF&  rect,
    CombineMode     combineMode
    )
{
    ASSERT(this->IsValid());

    GpStatus    status = Ok;

    GpRectF     tmpRect = rect;
    
    // handle flipped rects
    if (tmpRect.Width < 0)
    {
        tmpRect.X += tmpRect.Width;
        tmpRect.Width = -tmpRect.Width;
    }
    
    if (tmpRect.Height < 0)
    {
        tmpRect.Y += tmpRect.Height;
        tmpRect.Height = -tmpRect.Height;
    }

    // crop to infinity
    if (tmpRect.X < INFINITE_MIN)
    {
        if (tmpRect.Width < INFINITE_SIZE)
        {
            tmpRect.Width -= (INFINITE_MIN - tmpRect.X);
        }
        tmpRect.X = INFINITE_MIN;
    }
    if (tmpRect.Y < INFINITE_MIN)
    {
        if (tmpRect.Height < INFINITE_SIZE)
        {
            tmpRect.Height -= (INFINITE_MIN - tmpRect.Y);
        }
        tmpRect.Y = INFINITE_MIN;
    }

    if ((tmpRect.Width <= REAL_EPSILON) || (tmpRect.Height <= REAL_EPSILON))
    {
        GpRegion    emptyRegion;
        
        emptyRegion.SetEmpty();
        return this->SetClip(&emptyRegion, combineMode);
    }

    if (tmpRect.Width >= INFINITE_SIZE)
    {
        if (tmpRect.Height >= INFINITE_SIZE)
        {
            GpRegion    infiniteRegion;
            return this->SetClip(&infiniteRegion, combineMode);
        }
        tmpRect.Width = INFINITE_SIZE;  // crop to infinite
    }
    else if (tmpRect.Height > INFINITE_SIZE)
    {
        tmpRect.Height = INFINITE_SIZE; // crop to infinite
    }
    
    if (IsRecording())
    {
        status = Metafile->RecordSetClip(rect, combineMode);
        if (status != Ok)
        {
            SetValid(FALSE);      // Prevent any more recording
            return status;
        }
    }

    if (combineMode != CombineModeReplace)
    {
        return this->CombineClip(rect, combineMode);
    }
    
    if (Context->WorldToDevice.IsTranslateScale())
    {
        GpRectF     transformedRect = rect;

        Context->WorldToDevice.TransformRect(transformedRect);
        Context->AppClip.Set(transformedRect.X,
                             transformedRect.Y,
                             transformedRect.Width,
                             transformedRect.Height);

        // Try to match the GDI+ rasterizer
        // In theory, this could cause a floating point exception, but
        // the transform would have to be a very big scaling transform to do it.
        INT     left   = RasterizerCeiling(transformedRect.X);
        INT     top    = RasterizerCeiling(transformedRect.Y);
        INT     right  = RasterizerCeiling(transformedRect.GetRight());
        INT     bottom = RasterizerCeiling(transformedRect.GetBottom());

        Context->VisibleClip.Set(left, top, right - left, bottom - top);
        goto AndClip;
    }
    else
    {
        GpPointF    points[4];
        REAL        left   = rect.X;
        REAL        top    = rect.Y;
        REAL        right  = rect.X + rect.Width;
        REAL        bottom = rect.Y + rect.Height;

        points[0].X = left;
        points[0].Y = top;
        points[1].X = right;
        points[1].Y = top;
        points[2].X = right;
        points[2].Y = bottom;
        points[3].X = left;
        points[3].Y = bottom;

        // Transform the points now so we only have to do it once
        Context->WorldToDevice.Transform(points, 4);

        GpPath      path;

        path.AddLines(points, 4);

        if (path.IsValid())
        {
            GpMatrix    identityMatrix;

            if ((Context->AppClip.Set(&path) == Ok) &&
                (Context->VisibleClip.Set(&path, &identityMatrix) == Ok))
            {
                goto AndClip;
            }
        }
    }

ErrorExit:
    DoResetClip();
    return GenericError;

AndClip:
    if (AndVisibleClip() == Ok)
    {
        return status;
    }
    goto ErrorExit;
}

/**************************************************************************\
*
* Function Description:
*
*   Set the clipping in the graphics context to be the specified region.
*
* Arguments:
*
*   [IN]  region      - the region to clip to
*   [IN]  combineMode - the combine operator (and, or, xor, exclude, complement)
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   02/05/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpGraphics::SetClip(
    GpRegion *      region,
    CombineMode     combineMode
    )
{
    ASSERT(this->IsValid());
    ASSERT((region != NULL) && (region->IsValid()));

    GpStatus    status = Ok;

    if (IsRecording())
    {
        status = Metafile->RecordSetClip(region, combineMode);
        if (status != Ok)
        {
            SetValid(FALSE);      // Prevent any more recording
            return status;
        }
    }

    if (combineMode != CombineModeReplace)
    {
        return this->CombineClip(region, combineMode);
    }
    
    if ((Context->AppClip.Set(region) == Ok) &&
        (Context->AppClip.Transform(&(Context->WorldToDevice)) == Ok))
    {
        GpMatrix        identityMatrix;

        if ((Context->AppClip.UpdateDeviceRegion(&identityMatrix) == Ok) &&
            (Context->VisibleClip.Set(&(Context->AppClip.DeviceRegion)) == Ok)&&
            (AndVisibleClip() == Ok))
        {
            return status;
        }
    }

    DoResetClip();
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Set the clipping in the graphics context to be the specified region.
*
* Arguments:
*
*   [IN]  hRgn        - the region to clip to (already in device units)
*   [IN]  combineMode - the combine operator (and, or, xor, exclude, complement)
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   02/05/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpGraphics::SetClip(
    HRGN            hRgn,
    CombineMode     combineMode
    )
{
    ASSERT(this->IsValid());

    GpPath  path(hRgn);
    
    if (path.IsValid())
    {
        return this->SetClip(&path, combineMode, TRUE/*isDevicePath*/);
    }
    return OutOfMemory;
}

/**************************************************************************\
*
* Function Description:
*
*   Set the clipping in the graphics context to be the same as what
*   the specified graphics has.
*
*   Currently, this only works if the other graphics has the same
*   resolution as this one does.
*
* Arguments:
*
*   [IN]  g           - the graphics to copy the clipping from
*   [IN]  combineMode - the combine operator (and, or, xor, exclude, complement)
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   02/09/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpGraphics::SetClip(
    GpGraphics*     g,
    CombineMode     combineMode
    )
{
    ASSERT(this->IsValid() && (g != NULL) && g->IsValid());

    GpStatus    status = GenericError;
    GpRegion *  region = new GpRegion(&(g->Context->AppClip));

    if (region != NULL)
    {
        if (region->IsValid())
        {
            
            GpMatrix    deviceToWorld;

            if ((GetDeviceToWorldTransform(&deviceToWorld) == Ok) &&
                (region->Transform(&deviceToWorld) == Ok))
            {
                status = this->SetClip(region, combineMode);
            }
        }
        delete region;
    }
    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Set the clipping in the graphics context to be the specified path.
*
* Arguments:
*
*   [IN]  path        - the path to clip to
*   [IN]  combineMode - the combine operator (and, or, xor, exclude, complement)
*   [IN]  isDevicePath- if path is already in device units
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   02/09/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpGraphics::SetClip(
    GpPath*         path,
    CombineMode     combineMode,
    BOOL            isDevicePath    // if path is already in device units
    )
{
    ASSERT(this->IsValid() && (path != NULL) && path->IsValid());

    GpStatus        status = Ok;

    if (IsRecording())
    {
        status = Metafile->RecordSetClip(path, combineMode, isDevicePath);
        if (status != Ok)
        {
            SetValid(FALSE);      // Prevent any more recording
            return status;
        }
    }

    if (combineMode != CombineModeReplace)
    {
        return this->CombineClip(path, combineMode, isDevicePath);
    }
    
    if ((Context->AppClip.Set(path) == Ok) &&
        (isDevicePath ||
         (Context->AppClip.Transform(&(Context->WorldToDevice)) == Ok)))
    {
        GpMatrix        identityMatrix;

        if ((Context->AppClip.UpdateDeviceRegion(&identityMatrix) == Ok) &&
            (Context->VisibleClip.Set(&(Context->AppClip.DeviceRegion)) == Ok)&&
            (AndVisibleClip() == Ok))
        {
            return status;
        }
    }

    DoResetClip();
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Combine the region with the current clipping using the specified
*   combine type.
*
* Arguments:
*
*   [IN]  region      - the region to combine the clipping with.
*   [IN]  combineMode - the combine operator (and, or, xor, exclude, complement)
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   02/09/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpGraphics::CombineClip(
    GpRegion *      region,
    CombineMode     combineMode
    )
{
    ASSERT(this->IsValid());
    ASSERT((region != NULL) && (region->IsValid()));
    ASSERT(CombineModeIsValid(combineMode));

    GpRegion        regionCopy;

    if (!Context->WorldToDevice.IsIdentity())
    {
        regionCopy.Set(region);

        if ((!regionCopy.IsValid()) ||
            (regionCopy.Transform(&(Context->WorldToDevice)) != Ok))
        {
            return GenericError;
        }
        region = &regionCopy;
    }

    if (Context->AppClip.Combine(region, combineMode) == Ok)
    {
        GpMatrix        identityMatrix;

        if ((Context->AppClip.UpdateDeviceRegion(&identityMatrix) == Ok) &&
            (Context->VisibleClip.Set(&(Context->AppClip.DeviceRegion)) == Ok)&&
            (AndVisibleClip() == Ok))
        {
            return Ok;
        }
    }

    DoResetClip();
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Combine the rect with the current clipping using the specified
*   combine type.
*
* Arguments:
*
*   [IN]  path        - the path to combine the clipping with.
*   [IN]  combineMode - the combine operator (and, or, xor, exclude, complement)
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   02/09/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpGraphics::CombineClip(
    const GpPath *  path,
    CombineMode     combineMode,
    BOOL            isDevicePath    // if path is already in device units
    )
{
    ASSERT(this->IsValid());
    ASSERT((path != NULL) && (path->IsValid()));
    ASSERT(CombineModeIsValid(combineMode));

    GpPath *        pathCopy = NULL;

    if (!isDevicePath && (!Context->WorldToDevice.IsIdentity()))
    {
        pathCopy = path->Clone();

        if (!CheckValid(pathCopy))
        {
            return OutOfMemory;
        }
        pathCopy->Transform(&(Context->WorldToDevice));
        path = pathCopy;
    }

    GpStatus    status = Context->AppClip.Combine(path, combineMode);

    delete pathCopy;

    if (status == Ok)
    {
        GpMatrix        identityMatrix;

        if ((Context->AppClip.UpdateDeviceRegion(&identityMatrix) == Ok) &&
            (Context->VisibleClip.Set(&(Context->AppClip.DeviceRegion)) == Ok)&&
            (AndVisibleClip() == Ok))
        {
            return Ok;
        }
    }

    DoResetClip();
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Combine the rect with the current clipping using the specified
*   combine type.
*
* Arguments:
*
*   [IN]  rect        - the rect to combine the clipping with.
*   [IN]  combineMode - the combine operator (and, or, xor, exclude, complement)
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   02/09/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpGraphics::CombineClip(
    const GpRectF&  rect,
    CombineMode     combineMode
    )
{
    ASSERT(this->IsValid());
    ASSERT(CombineModeIsValid(combineMode));

    if (Context->WorldToDevice.IsTranslateScale())
    {
        GpRectF     transformedRect = rect;

        Context->WorldToDevice.TransformRect(transformedRect);

        if (Context->AppClip.Combine(&transformedRect, combineMode) == Ok)
        {
            goto SetVisibleClip;
        }
    }
    else
    {
        GpPointF    points[4];
        REAL        left   = rect.X;
        REAL        top    = rect.Y;
        REAL        right  = rect.X + rect.Width;
        REAL        bottom = rect.Y + rect.Height;

        points[0].X = left;
        points[0].Y = top;
        points[1].X = right;
        points[1].Y = top;
        points[2].X = right;
        points[2].Y = bottom;
        points[3].X = left;
        points[3].Y = bottom;

        Context->WorldToDevice.Transform(points, 4);

        GpPath      path;

        path.AddLines(points, 4);

        if (path.IsValid())
        {
            if ( Context->AppClip.Combine(&path, combineMode) == Ok)
            {
                goto SetVisibleClip;
            }
        }
    }

ErrorExit:
    DoResetClip();
    return GenericError;

SetVisibleClip:
    {
        GpMatrix        identityMatrix;

        if ((Context->AppClip.UpdateDeviceRegion(&identityMatrix) == Ok) &&
            (Context->VisibleClip.Set(&(Context->AppClip.DeviceRegion)) == Ok)&&
            (AndVisibleClip() == Ok))
        {
            return Ok;
        }
        goto ErrorExit;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Offset (translate) the current clipping region by the specified
*   world unit amounts.
*
* Arguments:
*
*   [IN]  dx - the amount of X to offset the region by, in world units
*   [IN]  dy - the amount of Y to offset the region by, in world units
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   02/09/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpGraphics::OffsetClip(
    REAL        dx,
    REAL        dy
    )
{
    ASSERT(this->IsValid());

    GpStatus        status = Ok;

    if (IsRecording())
    {
        status = Metafile->RecordOffsetClip(dx, dy);
        if (status != Ok)
        {
            SetValid(FALSE);      // Prevent any more recording
            return status;
        }
    }

    GpPointF    offset(dx, dy);

    Context->WorldToDevice.VectorTransform(&offset);

    if (Context->AppClip.Offset(offset.X, offset.Y) == Ok)
    {
        GpMatrix        identityMatrix;

        if ((Context->AppClip.UpdateDeviceRegion(&identityMatrix) == Ok) &&
            (Context->VisibleClip.Set(&(Context->AppClip.DeviceRegion)) == Ok)&&
            (AndVisibleClip() == Ok))
        {
            return status;
        }
    }

    DoResetClip();
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Determine if the specified rect is completely outside the current
*   clipping region.
*
* Arguments:
*
*   [IN]  rect - the rect to check, in device units
*
* Return Value:
*
*   TRUE  - the rect is completely outside the current clipping region
*   FALSE - the rect is at least partially visible
*
* Created:
*
*   02/05/1999 DCurtis
*
\**************************************************************************/
BOOL
GpGraphics::IsTotallyClipped(
    GpRect *        rect        // rect in device units
    ) const
{
    ASSERT(rect != NULL);

    return !(Context->VisibleClip.RectVisible(rect));
}

/**************************************************************************\
*
* Function Description:
*
*   Determine if the current clipping is empty or not
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   BOOL - whether or not the current clipping area is empty.
*
* Created:
*
*   02/09/1999 DCurtis
*
\**************************************************************************/
BOOL
GpGraphics::IsClipEmpty() const
{
    ASSERT(this->IsValid());

    GpMatrix    identityMatrix;
    BOOL        isEmpty = FALSE;

    Context->AppClip.IsEmpty(&identityMatrix, &isEmpty);

    return isEmpty;
}

/**************************************************************************\
*
* Function Description:
*
*   Return a rect with the bounds (in world units) of the current clip region.
*
* Arguments:
*
*   [OUT]  rect - the bounds of the current clip region, in world units
*
* Return Value:
*
*   NONE
*
* Created:
*
*   02/09/1999 DCurtis
*
\**************************************************************************/
VOID
GpGraphics::GetClipBounds(
    GpRectF&            rect
    ) const
{
    ASSERT(this->IsValid());

    GpRect      deviceRect;
    GpMatrix    identityMatrix;

    // We keep AppClip in device units
    Context->AppClip.GetBounds(&identityMatrix, &deviceRect);

    DeviceToWorldTransformRect(deviceRect, rect);
}


/**************************************************************************\
*
* Function Description:
*
*   Transform a device units rect to a world units rect.
*
* Arguments:
*
*   [IN]   deviceRect - the bounds in device units
*   [OUT]  rect       - the bounds, in world units
*
* Return Value:
*
*   NONE
*
* Created:
*
*   04/07/1999 DCurtis
*
\**************************************************************************/
VOID
GpGraphics::DeviceToWorldTransformRect(
    const GpRect &    deviceRect,
    GpRectF &   rect
    ) const
{
    if (Context->WorldToDevice.IsIdentity())
    {
        rect.X      = LTOF(deviceRect.X);
        rect.Y      = LTOF(deviceRect.Y);
        rect.Width  = LTOF(deviceRect.Width);
        rect.Height = LTOF(deviceRect.Height);
    }
    else
    {
        GpMatrix    deviceToWorld;

        if (GetDeviceToWorldTransform(&deviceToWorld) != Ok)
        {
            rect.X = rect.Y = rect.Width = rect.Height = 0;
            return;
        }

        if (deviceToWorld.IsTranslateScale())
        {
            rect.X      = LTOF(deviceRect.X);
            rect.Y      = LTOF(deviceRect.Y);
            rect.Width  = LTOF(deviceRect.Width);
            rect.Height = LTOF(deviceRect.Height);

            deviceToWorld.TransformRect(rect);
        }
        else
        {
            GpPointF    points[4];
            REAL        left   = LTOF(deviceRect.X);
            REAL        top    = LTOF(deviceRect.Y);
            REAL        right  = LTOF(deviceRect.X + deviceRect.Width);
            REAL        bottom = LTOF(deviceRect.Y + deviceRect.Height);

            points[0].X = left;
            points[0].Y = top;
            points[1].X = right;
            points[1].Y = top;
            points[2].X = right;
            points[2].Y = bottom;
            points[3].X = left;
            points[3].Y = bottom;

            deviceToWorld.Transform(points, 4);

            REAL    value;

            left   = points[0].X;
            right  = left;
            top    = points[0].Y;
            bottom = top;

            INT     count = 3;

            do
            {
                value = points[count].X;

                if (value < left)
                {
                    left = value;
                }
                else if (value > right)
                {
                    right = value;
                }

                value = points[count].Y;

                if (value < top)
                {
                    top = value;
                }
                else if (value > bottom)
                {
                    bottom = value;
                }
            } while (--count > 0);

            rect.X      = left;
            rect.Y      = top;
            rect.Width  = right - left;
            rect.Height = bottom - top;
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Return a rect with the bounds (in world units) of the current
*   visible clip region.
*
* Arguments:
*
*   [OUT]  rect - the bounds of the current clip region, in world units
*
* Return Value:
*
*   NONE
*
* Created:
*
*   02/09/1999 DCurtis
*
\**************************************************************************/
VOID
GpGraphics::GetVisibleClipBounds(
    GpRectF&            rect
    ) const
{
    ASSERT(this->IsValid());

    GpRect  deviceRect;
    Context->VisibleClip.GetBounds(&deviceRect);

    DeviceToWorldTransformRect(deviceRect, rect);
}

/**************************************************************************\
*
* Function Description:
*
*   Determine if the current visible clipping is empty or not
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   BOOL - whether or not the current clipping area is empty.
*
* Created:
*
*   02/09/1999 DCurtis
*
\**************************************************************************/
BOOL
GpGraphics::IsVisibleClipEmpty() const
{
    ASSERT(this->IsValid());

    return Context->VisibleClip.IsEmpty();
}

/**************************************************************************\
*
* Function Description:
*
*   Determine if the specified point is visible within the current clip region.
*
* Arguments:
*
*   point - the point to test, in world units.
*
* Return Value:
*
*   BOOL - whether or not the point is inside the current clipping.
*
* Created:
*
*   02/09/1999 DCurtis
*
\**************************************************************************/
BOOL
GpGraphics::IsVisible(
    const GpPointF&     point
    ) const
{
    ASSERT(this->IsValid());

    GpPointF    pointCopy = point;

    Context->WorldToDevice.Transform(&pointCopy);


    return Context->VisibleClip.PointInside(GpRound(pointCopy.X),
                                            GpRound(pointCopy.Y));
}

/**************************************************************************\
*
* Function Description:
*
*   Determine if the specified rect is visible within the current clip region.
*
* Arguments:
*
*   rect - the rect to test, in world units.
*
* Return Value:
*
*   BOOL - whether or not the rect is inside/overlaps the current clipping.
*
* Created:
*
*   02/09/1999 DCurtis
*
\**************************************************************************/
BOOL
GpGraphics::IsVisible(
    const GpRectF&      rect
    ) const
{
    ASSERT(this->IsValid());

    if (Context->WorldToDevice.IsTranslateScale())
    {
        GpRectF     transformedRect = rect;

        Context->WorldToDevice.TransformRect(transformedRect);

        // use ceiling to match rasterizer
        return Context->VisibleClip.RectVisible(
                    GpCeiling(transformedRect.X),
                    GpCeiling(transformedRect.Y),
                    GpCeiling(transformedRect.GetRight()),
                    GpCeiling(transformedRect.GetBottom()));
    }
    else
    {
        GpRectF     bounds;
        GpRect      deviceBounds;
        GpRect      clipBounds;

        TransformBounds(&(Context->WorldToDevice),
                        rect.X, rect.Y,
                        rect.GetRight(), rect.GetBottom(),
                        &bounds);

        GpStatus status = BoundsFToRect(&bounds, &deviceBounds);
        Context->VisibleClip.GetBounds(&clipBounds);

        // try trivial reject
        if (status == Ok && clipBounds.IntersectsWith(deviceBounds))
        {
            // couldn't reject, so do full test
            GpRegion        region(&rect);

            if (region.IsValid() &&
                (region.UpdateDeviceRegion(&(Context->WorldToDevice)) == Ok))
            {
                return Context->VisibleClip.RegionVisible(&region.DeviceRegion);
            }
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\graphics.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Graphics APIs.
*
* Revision History:
*
*   11/23/1999 asecchia
*       Created it.
*   05/08/2000 gillesk
*       Added code to handle rotations and shears in metafiles
*
\**************************************************************************/

#include "precomp.hpp"

const CLSID EncoderTransformationInternal =
{
    0x8d0eb2d1,
    0xa58e,
    0x4ea8,
    {0xaa, 0x14, 0x10, 0x80, 0x74, 0xb7, 0xb6, 0xf9}
};

const CLSID JpegCodecClsIDInternal =
{
    0x557cf401,
    0x1a04,
    0x11d3,
    {0x9a, 0x73, 0x00, 0x00, 0xf8, 0x1e, 0xf3, 0x2e}
};

/**************************************************************************\
*
* Function Description:
*
*   Engine function to draw image.
*   Note: this function is not a driver function despite it's name.
*   it probably makes more sense to call this EngDrawImage.
*   This function sets up the call to the driver to draw an image.
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   11/23/1999 asecchia
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::DrvDrawImage(
    const GpRect *drawBounds,
    GpBitmap *inputBitmap,
    INT numPoints,
    const GpPointF *dstPointsOriginal,
    const GpRectF *srcRectOriginal,
    const GpImageAttributes *imageAttributes,
    DrawImageAbort callback,
    VOID *callbackData,
    DriverDrawImageFlags flags
    )
{
    // Validate the input state.
    
    ASSERTMSG(
        GetObjectLock()->IsLocked(),
        ("Graphics object must be locked")
    );
    
    ASSERTMSG(
        Device->DeviceLock.IsLockedByCurrentThread(),
        ("DeviceLock must be held by current thread")
    );

    FPUStateSaver::AssertMode();

    // must be called with a parallelogram destination.

    ASSERT(numPoints==3);
    
    // Make a local copy of the points.
    
    GpPointF dstPoints[3];
    memcpy(dstPoints, dstPointsOriginal, sizeof(dstPoints));
    GpRectF srcRect = *srcRectOriginal;
    

    // trivial return if the parallelogram is empty, either there are at least
    // two points overlap or they are on one line

    // We check if the slope between point2 and point1 equals to the slope
    // between point0 and point1

    if (REALABS(
        (dstPoints[2].Y - dstPoints[0].Y) * (dstPoints[0].X - dstPoints[1].X) -
        (dstPoints[2].X - dstPoints[0].X) * (dstPoints[0].Y - dstPoints[1].Y)
        ) < REAL_EPSILON)
    {
        return Ok;
    }

    // Done input parameter validation.
    
    
    // Check some useful state up front.
    
    BOOL IsMetafile = (Driver == Globals::MetaDriver);

    BOOL IsRecolor = (
       (imageAttributes != NULL) &&
       (imageAttributes->recolor != NULL) &&
       (imageAttributes->recolor->HasRecoloring(ColorAdjustTypeBitmap))
    );

    // This is the format we will use to lock the bits.
    // Default is premultiplied, but some cases require non-premultiplied.
    
    PixelFormat lockedPixelFormat = PixelFormat32bppPARGB;
    
    // Metafiles need non-premultiplied pixel data.
    // Also, Recoloring uses ARGB as it's initial format, so we want
    // to respect that if we load the image into memory before the 
    // recolor code.
    
    if(IsMetafile || IsRecolor)
    {
        lockedPixelFormat = PixelFormat32bppARGB;
    }

    Surface->Uniqueness = (DWORD)GpObject::GenerateUniqueness();

    // Set up the local tracking state.
    // Note: inputBitmap can change during the processing in this routine -
    // specifically when recoloring is done, it may be pointing to a clone
    // of the input bitmap with recoloring applied. Because of this, the
    // inputBitmap should never be directly referenced from here onward.

    GpStatus status = Ok;
    GpBitmap *srcBitmap = inputBitmap;
    GpBitmap *xformBitmap = NULL;
    BOOL     restoreClipping = FALSE;
    GpRegion *clipRegion     = NULL;

    // Compute the transform between the source rectangle and the destination
    // points transformed to device coordinates. This is used to detect and
    // intercept processing for some high level optimizations and workarounds.
    
    GpMatrix xForm;
    xForm.InferAffineMatrix(dstPoints, srcRect);

    // Special optimization for JPEG passthrough of rotated bitmaps.
    // Why does this not take the world to device matrix into account?
    // If the world to device is a non-trivial rotation, then this is invalid.
    
    if (IsPrinter())
    {
        MatrixRotate rotateBy;

        DriverPrint *dprint = (DriverPrint*)Driver;
        
        // Check if the source rectangle to destination point map is
        // simply a 90, 180, or 270 rotation, and the driver supports JPEG
        // passthrough, It's a JPEG image, no recoloring, not dirty.

        if (!Globals::IsWin95 && 
            dprint->SupportJPEGpassthrough && 
            Context->WorldToDevice.IsTranslateScale() &&
            ((rotateBy = xForm.GetRotation()) != MatrixRotateByOther) &&
            (rotateBy != MatrixRotateBy0) && 
            (!srcBitmap->IsDirty()) &&
            ((imageAttributes == NULL) ||
             (imageAttributes->recolor == NULL) ||
             (!imageAttributes->recolor->HasRecoloring(ColorAdjustTypeBitmap))))
        {
            ImageInfo imageInfo;
            status = srcBitmap->GetImageInfo(&imageInfo);
            
            if((status == Ok) && 
               (imageInfo.RawDataFormat == IMGFMT_JPEG))
            {
                // Allocate a stream to store the rotated JPEG.
                                
                IStream * outputStream = NULL;
                BOOL succeededWithRotate = FALSE;

                if ((CreateStreamOnHGlobal(NULL,
                                           FALSE,
                                           &outputStream) == S_OK) &&
                    outputStream != NULL)
                {
                    EncoderParameters encoderParams;
                    EncoderValue encoderValue;

                    encoderParams.Count = 1;

                    // Re-orient the destination parallelogram (rectangle) since
                    // we now are assuming a 0 degree rotation.

                    GpPointF newDestPoints[3] = 
                    { 
                      GpPointF(min(min(dstPoints[0].X, dstPoints[1].X), dstPoints[2].X),
                               min(min(dstPoints[0].Y, dstPoints[1].Y), dstPoints[2].Y)),
                      GpPointF(max(max(dstPoints[0].X, dstPoints[1].X), dstPoints[2].X),
                               min(min(dstPoints[0].Y, dstPoints[1].Y), dstPoints[2].Y)),
                      GpPointF(min(min(dstPoints[0].X, dstPoints[1].X), dstPoints[2].X),
                               max(max(dstPoints[0].Y, dstPoints[1].Y), dstPoints[2].Y)) 
                    };

                    // Since the image is potentially flipped, the srcRect needs
                    // to be flipped also. 
                    
                    GpRectF newSrcRect = srcRect;
                    GpMatrix transformSrc;
                    
                    // Construct the appropriate encoder parameters type.
                    switch (rotateBy) 
                    {
                    case MatrixRotateBy90:
                        transformSrc.SetMatrix(0.0f, 
                                               1.0f, 
                                               -1.0f, 
                                               0.0f, 
                                               TOREAL(imageInfo.Height), 
                                               0.0f);
                        encoderValue = EncoderValueTransformRotate90;
                        break;

                    case MatrixRotateBy180:
                        transformSrc.SetMatrix(-1.0f, 
                                               0.0f, 
                                               0.0f, 
                                               -1.0f, 
                                               TOREAL(imageInfo.Width),
                                               TOREAL(imageInfo.Height));
                        encoderValue = EncoderValueTransformRotate180;
                        break;
                    
                    case MatrixRotateBy270:
                        transformSrc.SetMatrix(0.0f, 
                                               -1.0f, 
                                               1.0f, 
                                               0.0f, 
                                               0.0f,
                                               TOREAL(imageInfo.Width));
                        encoderValue = EncoderValueTransformRotate270;
                        break;
                    
                    default:
                        encoderParams.Count = 0;
                        ASSERT(FALSE);
                        break;
                    }
                
                    // Transform the source rectangle from source image space
                    // to rotated image space.  Normalize the destination source
                    // rectangle.
                    
                    // Note that the source rectangle may not originally be
                    // normalized, but any rotational effects it emparts on the
                    // draw image is represented by the xForm and thus our
                    // newDestPoints. 
                    
                    // NTRAID#NTBUG9-407211-2001-05-31-gillessk "Bad assert triggers when it shouldn't" 
                    // assert was transformSrc.IsTranslateScale, which fires when rotation is involved
                     
                    ASSERT(transformSrc.IsTranslateScale() || (transformSrc.GetRotation()==MatrixRotateBy90) 
                        || (transformSrc.GetRotation()==MatrixRotateBy270));
                    transformSrc.TransformRect(newSrcRect);

                    encoderParams.Parameter[0].Guid = EncoderTransformationInternal;
                    encoderParams.Parameter[0].Type = EncoderParameterValueTypeLong;
                    encoderParams.Parameter[0].NumberOfValues = 1;
                    encoderParams.Parameter[0].Value = (VOID*)&encoderValue;

                    // Specify built in JPEG enocder for simplicity.  We should
                    // really copy the CLSID encoder from the srcBitmap.
                    
                    if (encoderParams.Count != 0 &&
                        srcBitmap->SaveToStream(outputStream, 
                                                const_cast<CLSID*>(&JpegCodecClsIDInternal),
                                                &encoderParams) == Ok)
                    {
                        // The stream contains the rotated JPEG.  Wrap a bitmap
                        // around this and recursively call on ourself.  This sucks,
                        // but the destructor to rotatedJPEG is private so we can't
                        // define it as a stack variable.  
                        
                        GpBitmap *rotatedJPEG = new GpBitmap(outputStream);

                        if (rotatedJPEG != NULL)
                        {
                            if (rotatedJPEG->IsValid()) 
                            {
                                // Transform the source rectangle by the scale & translate
                                // of the original xForm, but not the rotation!  This could
                                // equivalently be determined by querying M11,M22, Dx, Dy.

                                status = DrvDrawImage(drawBounds,
                                                      rotatedJPEG,
                                                      numPoints,
                                                      &newDestPoints[0],
                                                      &newSrcRect,
                                                      imageAttributes,
                                                      callback,
                                                      callbackData,
                                                      flags);

                                succeededWithRotate = TRUE;
                            }

                            rotatedJPEG->Dispose();
                        }
                    }

                    outputStream->Release();

                    if (succeededWithRotate) 
                    {
                        return status;
                    }
                    else
                    {
                        return OutOfMemory;
                    }
                }
            }
        }
    }

    // Create complete source image to device space transform.
    
    xForm.Append(Context->WorldToDevice);
    
    GpBitmap *cloneBitmap = NULL;
    
    // GpMatrix has a default constructor which sets it to ID so we may 
    // as well copy it always.
    
    GpMatrix saveWorldToDevice = Context->WorldToDevice;

    // Check for special case rotate or flip.
    // Integer translate is handled natively by the driver.
    
    if(!xForm.IsIntegerTranslate()) 
    {
        RotateFlipType specialRotate = xForm.AnalyzeRotateFlip();
        if(specialRotate != RotateNoneFlipNone)
        {
            ImageInfo imageInfo;
            status = srcBitmap->GetImageInfo(&imageInfo);
            if(status != Ok)
            {
                goto cleanup;
            }
            
            // Clone the bitmap in the same format we'll be using later.
            // This will save a format conversion.
            // !!! PERF [asecchia]
            // This clones the entire image. When we do the RotateFlip call
            // it'll decode the entire image - which is potentially a
            // waste - we should clone only the relevant rectangle.
            // Note: this would have to be accounted for in the transform and
            // Clone would need to be fixed to account for outcropping.
            
            cloneBitmap = srcBitmap->Clone(NULL, lockedPixelFormat);
            
            if(cloneBitmap == NULL)
            {
                status = OutOfMemory;
                goto cleanup;
            }
            
            srcBitmap = cloneBitmap;
            
            // perform lossless pixel rotation in place.
            
            srcBitmap->RotateFlip(specialRotate);

            // Undo the pixel offset mode. We know we're not scaling so 
            // this is correct.
            // Why do we have two different enums meaning exactly 
            // the same thing?
            
            if((Context->PixelOffset == PixelOffsetModeHalf) ||
               (Context->PixelOffset == PixelOffsetModeHighQuality))
            {
                // Undo the pixel offset in the source rectangle.
                
                srcRect.Offset(0.5f, 0.5f);
                
                // Undo the pixel offset in the matrix. We apply the pre-offset
                // from the source rect and the post offset from the W2D matrix
                // For identity this would be a NOP because the matrixes for 
                // pixel offset and non-pixel offset are identical, but they 
                // apply in two different spaces for rotation.
                
                xForm.Translate(0.5f, 0.5f, MatrixOrderAppend);
                xForm.Translate(-0.5f, -0.5f, MatrixOrderPrepend);
            }

            
            // Remove the world to device rotation.
            
            xForm.SetMatrix(
                1.0f, 0.0f,
                0.0f, 1.0f,
                xForm.GetDx(),
                xForm.GetDy()
            );
            
            // Because RotateFlip applies in place, the resulting bitmap is 
            // always still at the origin. This is actually a non-trivial 
            // rotation in most cases - i.e. there is an implied translate 
            // from where the real simple rotate matrix puts the image and
            // where it is now. Fix up the translate in the xForm to take
            // this into account.
            
            REAL temp;
            
            switch(specialRotate)
            {
                case RotateNoneFlipX:
                    temp = (2.0f*srcRect.X+srcRect.Width);
                    xForm.Translate(-(REAL)imageInfo.Width, 0.0f);
                    srcRect.Offset(imageInfo.Width-temp, 0.0f);
                break;
                
                case RotateNoneFlipY:
                    temp = (2.0f*srcRect.Y+srcRect.Height);
                    xForm.Translate(0.0f, -(REAL)imageInfo.Height);
                    srcRect.Offset(0.0f, imageInfo.Height-temp);
                break;
                
                case Rotate90FlipNone:
                    SWAP(temp, srcRect.X, srcRect.Y);
                    SWAP(temp, srcRect.Width, srcRect.Height);
                    temp = (2.0f*srcRect.X+srcRect.Width);
                    xForm.Translate(-(REAL)imageInfo.Height, 0.0f);
                    srcRect.Offset(imageInfo.Height-temp, 0.0f);
                break;
                
                case Rotate90FlipX:
                    SWAP(temp, srcRect.X, srcRect.Y);
                    SWAP(temp, srcRect.Width, srcRect.Height);
                break;
                
                case Rotate180FlipNone:
                    xForm.Translate(
                        -(REAL)imageInfo.Width, 
                        -(REAL)imageInfo.Height
                    );
                    srcRect.Offset(
                        imageInfo.Width -(2.0f*srcRect.X+srcRect.Width),
                        imageInfo.Height-(2.0f*srcRect.Y+srcRect.Height)
                    );
                break;
                
                case Rotate270FlipX:
                    SWAP(temp, srcRect.X, srcRect.Y);
                    SWAP(temp, srcRect.Width, srcRect.Height);
                    xForm.Translate(
                        -(REAL)imageInfo.Height, 
                        -(REAL)imageInfo.Width
                    );
                    srcRect.Offset(
                        imageInfo.Height-(2.0f*srcRect.X+srcRect.Width),
                        imageInfo.Width -(2.0f*srcRect.Y+srcRect.Height)
                    );
                break;
                
                case Rotate270FlipNone:
                    SWAP(temp, srcRect.X, srcRect.Y);
                    SWAP(temp, srcRect.Width, srcRect.Height);
                    temp = (2.0f*srcRect.Y+srcRect.Height);
                    xForm.Translate(0.0f, -(REAL)imageInfo.Width);
                    srcRect.Offset(0.0f, imageInfo.Width-temp);
                break;
            };
            
            // Set the world to device transform in the context. This causes
            // the driver to use our updated transform. We fix this up at the 
            // end of this routine. (see goto cleanup)
            
            Context->WorldToDevice = xForm;
            
            // Normalize the destination because we've incorporated the 
            // entire affine transform into the world to device matrix.
            
            dstPoints[0].X = srcRect.X;
            dstPoints[0].Y = srcRect.Y;
            dstPoints[1].X = srcRect.X+srcRect.Width;
            dstPoints[1].Y = srcRect.Y;
            dstPoints[2].X = srcRect.X;
            dstPoints[2].Y = srcRect.Y+srcRect.Height;
        }
    }
    
    // HighQuality filters doing rotation/shear?
    // This is a workable temporary solution to high quality bicubic
    // rotation. Note that when the underlying bicubic filtering code
    // is updated to support rotation, this block should be removed.

    if( (!xForm.IsTranslateScale()) && (!IsMetafile) && // don't scale down-level metafile record
        ((Context->FilterType==InterpolationModeHighQualityBicubic) ||
         (Context->FilterType==InterpolationModeHighQualityBilinear))
         )
    {
        // Before allocating the srcBitmap, see if we can save some memory
        // by only allocating the part of the srcBitmap that gets transfromed
        // in the case that we are outcropping.
        // This is only valid if we are in ClampMode and printing

        // We should do this all the time, but we would have to calculate the
        // area of influence of the kernel.
        // Printing doesn't support PixelOffsetting yet, so don't move the
        // srcRect
        
        if (IsPrinter() &&
            ((!imageAttributes) ||
             (imageAttributes->DeviceImageAttributes.wrapMode == WrapModeClamp)))
        {
            RectF clampedSrcRect;
            Unit  srcUnit;
            srcBitmap->GetBounds(&clampedSrcRect, &srcUnit);

            ASSERT(srcUnit == UnitPixel);

            // Find the area of the srcrect that is included in the image
            clampedSrcRect.Intersect(srcRect);

            // If there's no intersection then don't do anything
            if (clampedSrcRect.IsEmptyArea())
            {
                goto cleanup;
            }

            // Don't do anything else if the srcRect is not outcropping
            if (!clampedSrcRect.Equals(srcRect))
            {
                GpMatrix srcDstXForm;
                if (srcDstXForm.InferAffineMatrix(dstPoints, srcRect) == Ok)
                {
                    // Modify the srcRect and the dstPoints to match the new
                    // section of the bitmap
                    dstPoints[0] = PointF(clampedSrcRect.X, clampedSrcRect.Y);
                    dstPoints[1].X = clampedSrcRect.GetRight();
                    dstPoints[1].Y = clampedSrcRect.Y;
                    dstPoints[2].X = clampedSrcRect.X;
                    dstPoints[2].Y = clampedSrcRect.GetBottom();
                    srcDstXForm.Transform(dstPoints, 3);

                    srcRect = clampedSrcRect;
                }
            }
        }

        // Must make the determination of intermediate size based on the actual
        // device coordinates of the final destination points.
        
        GpPointF points[3];
        memcpy(points, dstPoints, sizeof(points));
        Context->WorldToDevice.Transform(points, 3);
        
        // Compute the width and height of the scale factor so that we
        // can decompose into a scale and then rotation.

        INT iwidth = GpCeiling( REALSQRT(
            (points[1].X-points[0].X)*(points[1].X-points[0].X)+
            (points[1].Y-points[0].Y)*(points[1].Y-points[0].Y)
        ));

        INT iheight = GpCeiling( REALSQRT(
            (points[2].X-points[0].X)*(points[2].X-points[0].X)+
            (points[2].Y-points[0].Y)*(points[2].Y-points[0].Y)
        ));

        ASSERT(iwidth>0);
        ASSERT(iheight>0);

        // Only do the scale if we really need to.
        // Note: This if statement prevents infinite recursion in DrvDrawImage

        if( (REALABS(iwidth-srcRect.Width) > REAL_EPSILON) &&
            (REALABS(iheight-srcRect.Height) > REAL_EPSILON) )
        {
            // Create a temporary bitmap to scale the image into.

            GpBitmap *scaleBitmap = NULL;

            // Crack the recoloring to figure out the optimal temporary bitmap
            // format.
            // Metafiles also need non-premultiplied (see the final LockBits
            // in this routine before calling the driver)

            PixelFormatID scaleFormat = PixelFormat32bppPARGB;

            if((IsMetafile) ||
               ( (imageAttributes) &&
                 (imageAttributes->recolor) &&
                 (imageAttributes->recolor->HasRecoloring(ColorAdjustTypeBitmap))
              ))
            {
                // Recoloring is enabled - optimal format is non-premultiplied.
                // In fact it's incorrect (lossy) to go to premultiplied before
                // recoloring is applied.

                scaleFormat = PixelFormat32bppARGB;
            }

            scaleBitmap = new GpBitmap(
                iwidth,
                iheight,
                scaleFormat
            );

            GpGraphics *scaleG = NULL;

            if(scaleBitmap && scaleBitmap->IsValid())
            {
                // The high quality filtering should be to an equivalent
                // dpi surface, bounded by the ultimate surface destination dpi.

                REAL dpiX, dpiY;

                srcBitmap->GetResolution(&dpiX, &dpiY);

                scaleBitmap->SetResolution(min(dpiX, Context->ContainerDpiX), 
                                           min(dpiY, Context->ContainerDpiY));
                
                scaleG = scaleBitmap->GetGraphicsContext();
            }

            if(scaleG && scaleG->IsValid())
            {
                GpLock lock(scaleG->GetObjectLock());
                scaleG->SetInterpolationMode(Context->FilterType);
                scaleG->SetCompositingMode(CompositingModeSourceCopy);

                GpRectF scaleDst(
                    0,
                    0,
                    (REAL)iwidth,
                    (REAL)iheight
                );

                // To avoid bleeding transparent black into our image when 
                // printing we temporarily set the WrapMode to TileFlipXY on 
                // our preliminary drawimage (the scaling part) and clip to the 
                // bounds later on when we do the rotate/skew.
                GpImageAttributes *tempImageAttributes = const_cast<GpImageAttributes*>(imageAttributes);
                if (IsPrinter())
                {
                    if (imageAttributes == NULL)
                    {
                        tempImageAttributes = new GpImageAttributes();
                        if(tempImageAttributes)
                        {
                            tempImageAttributes->SetWrapMode(WrapModeTileFlipXY);
                        }
                    }
                    else if (imageAttributes->DeviceImageAttributes.wrapMode == WrapModeClamp)
                    {
                        tempImageAttributes = imageAttributes->Clone();
                        if(tempImageAttributes)
                        {
                            tempImageAttributes->SetWrapMode(WrapModeTileFlipXY);
                        }
                    }
                }
                
                // Do the scale.

                status = scaleG->DrawImage(
                    srcBitmap,
                    scaleDst,
                    srcRect,
                    UnitPixel,
                    tempImageAttributes,
                    callback,
                    callbackData
                );

                // If we allocated a new copy of the imageAttributes then delete it.
                if (tempImageAttributes != imageAttributes)
                {
                    delete tempImageAttributes;
                }

                // Now we're at the right size, lets actually do some rotation.
                // Note we don't bother resetting the filtering mode because the
                // underlying driver code for HighQuality filters defaults to
                // the correct resampling code.
                // Also we shouldn't get recursion because of the width and height
                // check protecting this codeblock.

                if(status==Ok)
                {
                    status = this->DrawImage(
                        scaleBitmap,
                        dstPoints,
                        3,
                        scaleDst,
                        UnitPixel,
                        NULL,
                        callback,
                        callbackData
                    );
                }
            }
            else
            {
                status = OutOfMemory;
            }

            delete scaleG;
            
            if (scaleBitmap)
            {
                scaleBitmap->Dispose();
            }

            goto cleanup;                 // completed or error.
        }
    }

    // Prep the bitmap for drawing:
    // if rendering to a meta surface (multimon) assume 32bpp for
    // the icon codec.

    status = srcBitmap->PreDraw(
        numPoints,
        dstPoints,
        &srcRect,
        GetPixelFormatSize(
            (Surface->PixelFormat == PixelFormatMulti) ? 
             PixelFormat32bppRGB : Surface->PixelFormat
        )
    );

    if (status != Ok)
    {
        goto cleanup;
    }

    // Get the cached ImageInfo from the source bitmap. Any time the image
    // is changed or forced to be re-decoded, this will be invalidated and
    // will require an explicit re-initialization.

    ImageInfo srcBitmapImageInfo;
    status = srcBitmap->GetImageInfo(&srcBitmapImageInfo);
    if(status != Ok)
    {
        goto cleanup;
    }

    // Do the recoloring.
    // Note that Recoloring will clone the image if it needs to change the bits.
    // This means that srcBitmap will not be pointing to inputBitmap after
    // a successful call to the recoloring code.

    if((status == Ok) && (IsRecolor))
    {
        // cloneBitmap is set to NULL. Recolor into a cloned bitmap
        // cloneBitmap != NULL - we previously cloned, so it's ok to 
        // recolor in place.
        
        status = srcBitmap->Recolor(
            imageAttributes->recolor,
            (cloneBitmap == NULL) ? &cloneBitmap : NULL,
            callback,
            callbackData
        );

        // Recoloring worked - set the srcBitmap to the clone that's been
        // recolored so that the rest of the pipe works on the recolored bitmap.

        if(status == Ok)
        {
            srcBitmap = cloneBitmap;
            status = srcBitmap->GetImageInfo(&srcBitmapImageInfo);
            
            // If it's not a metafile, we need to convert to PARGB for the 
            // filtering.
            
            if(!IsMetafile)
            {
                lockedPixelFormat = PixelFormat32bppPARGB;
            }
        }
    }

    // Check the callbacks.

    if ((status == Ok) &&
        (callback) &&
        ((*callback)(callbackData)))
    {
        status = Aborted;
    }


    if(status == Ok)
    {
        // The code below explicitly assumes numPoints == 3. Yes I know we've
        // already asserted this above, but you can't be too careful.
        
        ASSERT(numPoints==3);

        // If we don't write a rotation into a metafile, copy the
        // points to the buffers that are used by the driver
        // These will only be changed if everything succeeded
        
        GpPointF fDst[3];
        GpRectF  bboxSrcRect;
        GpMatrix worldDevice = Context->WorldToDevice;

        GpMemcpy(fDst, dstPoints, sizeof(GpPointF)*numPoints);
        bboxSrcRect = srcRect;

        // Before calling the driver if we have a rotated bitmap then try to 
        // rotate it now and draw it transparent
        
        INT complexity = xForm.GetComplexity() ;
        if (!xForm.IsTranslateScale() && IsMetafile)
        {
            // We have a shear/rotate transformation.
            // Create a transparent bitmap and render into it

            // first, get new dest points
            GpPointF newDestPoints[3];

            GpRectF bboxWorkRectF;
            TransformBounds(&xForm,
                srcRect.X,
                srcRect.Y,
                srcRect.X+srcRect.Width,
                srcRect.Y+srcRect.Height,
                &bboxWorkRectF
            );

            newDestPoints[0].X = bboxWorkRectF.X;
            newDestPoints[0].Y = bboxWorkRectF.Y;
            newDestPoints[1].X = bboxWorkRectF.X + bboxWorkRectF.Width;
            newDestPoints[1].Y = bboxWorkRectF.Y;
            newDestPoints[2].X = bboxWorkRectF.X;
            newDestPoints[2].Y = bboxWorkRectF.Y + bboxWorkRectF.Height;

            // To keep the metafile size small, take out most of the
            // scaling up from the transform.  We could do this by
            // a sophisticated algorithm to calculate the amount of
            // scaling in the matrix, but instead just assume anything
            // greater than 1 is a scale, which means we could actually
            // scale up by as much as 1.4 (for a 45-degree angle), but
            // that's close enough.
            
            GpMatrix    unscaledXform = xForm;
            
            REAL    xScale = 1.0f;
            REAL    yScale = 1.0f;
            REAL    col1;
            REAL    col2;
            REAL    max;
            
            // This should really use REALABS and max()
            
            col1 = xForm.GetM11();
            if (col1 < 0.0f)
            {
                col1 = -col1;                       // get absolute value
            }
            
            col2 = xForm.GetM12();
            if (col2 < 0.0f)
            {
                col2 = -col2;                       // get absolute value
            }
            
            max = (col1 >= col2) ? col1 : col2;     // max scale value
            if (max > 1.0f)
            {
                xScale = 1.0f / max;
            }

            col1 = xForm.GetM21();
            if (col1 < 0.0f)
            {
                col1 = -col1;                       // get absolute value
            }
            
            col2 = xForm.GetM22();
            if (col2 < 0.0f)
            {
                col2 = -col2;                       // get absolute value
            }
            
            max = (col1 >= col2) ? col1 : col2;     // max scale value
            if (max > 1.0f)
            {
                yScale = 1.0f / max;
            }
            
            unscaledXform.Scale(xScale, yScale, MatrixOrderPrepend);

            // Transform the original src coordinates to obtain the 
            // dimensions of the bounding box for the rotated bitmap.

            TransformBounds(&unscaledXform,
                srcRect.X,
                srcRect.Y,
                srcRect.X+srcRect.Width,
                srcRect.Y+srcRect.Height,
                &bboxWorkRectF
            );

            // Add 1 because the rect for bitmaps is inclusive-inclusive
            INT     rotatedWidth  = GpRound(bboxWorkRectF.GetRight()  - bboxWorkRectF.X + 1.0f);
            INT     rotatedHeight = GpRound(bboxWorkRectF.GetBottom() - bboxWorkRectF.Y + 1.0f);

            // Convert the bounding box back to a 3 point system
            // This will be what's passed to the driver
            
            xformBitmap = new GpBitmap(rotatedWidth, rotatedHeight, PIXFMT_32BPP_ARGB);
            if (xformBitmap != NULL && xformBitmap->IsValid())
            {
                GpGraphics *graphics = xformBitmap->GetGraphicsContext();
                if (graphics != NULL && graphics->IsValid())
                {
                    // we have to lock the graphics so the driver doesn't assert
                    GpLock lockGraphics(graphics->GetObjectLock());

                    graphics->Clear(GpColor(0,0,0,0));

                    // Translate the world to be able to draw the whole image
                    graphics->TranslateWorldTransform(-bboxWorkRectF.X, -bboxWorkRectF.Y);

                   // Apply the transform from the Src to the Destination
                    if (graphics->MultiplyWorldTransform(unscaledXform, MatrixOrderPrepend) == Ok)
                    {
                        GpImageAttributes   imageAttributes;
                        
                        imageAttributes.SetWrapMode(WrapModeTileFlipXY);
                        graphics->SetPixelOffsetMode(Context->PixelOffset);
                        
                        // Draw the rotated xformBitmap at the origin
                        if (graphics->DrawImage(srcBitmap, srcRect, srcRect, UnitPixel, &imageAttributes) == Ok)
                        {
                            // Now that we have succeeded change the parameters
                            bboxSrcRect.X      = 0.0f;
                            bboxSrcRect.Y      = 0.0f;
                            bboxSrcRect.Width  = (REAL)rotatedWidth;
                            bboxSrcRect.Height = (REAL)rotatedHeight;
                            
                            // Set the clipping in the graphics to be able to
                            // mask out the edges
                            clipRegion = GetClip();
                            if (clipRegion != NULL)
                            {
                                // Create the outline of the picture as a path
                                GpPointF pathPoints[4];
                                BYTE     pathTypes[4] = {
                                    PathPointTypeStart,
                                    PathPointTypeLine,
                                    PathPointTypeLine,
                                    PathPointTypeLine | PathPointTypeCloseSubpath };

                                GpPointF pixelOffset(0.0f, 0.0f);

                                if (Context->PixelOffset == PixelOffsetModeHalf || Context->PixelOffset == PixelOffsetModeHighQuality)
                                {
                                    // Cannot use GetWorldPixelSize because it does an ABS
                                    GpMatrix deviceToWorld;
                                    if (GetDeviceToWorldTransform(&deviceToWorld) == Ok)
                                    {
                                        pixelOffset = GpPointF(-0.5f, -0.5f);
                                        deviceToWorld.VectorTransform(&pixelOffset);
                                    }
                                }

                                pathPoints[0] = dstPoints[0] + pixelOffset;
                                pathPoints[1] = dstPoints[1] + pixelOffset;
                                pathPoints[2].X = dstPoints[1].X - dstPoints[0].X + dstPoints[2].X + pixelOffset.X;
                                pathPoints[2].Y = dstPoints[2].Y - dstPoints[0].Y + dstPoints[1].Y + pixelOffset.Y; 
                                pathPoints[3] = dstPoints[2] + pixelOffset;

                                GpPath path(pathPoints, pathTypes, 4);
                                if (path.IsValid())
                                {
                                    if (SetClip(&path, CombineModeIntersect) == Ok)
                                    {
                                        restoreClipping = TRUE;
                                    }
                                }
                            }
                            GpMemcpy(fDst, newDestPoints, sizeof(GpPointF)*3);
                            Context->WorldToDevice.Reset();
                            srcBitmap = xformBitmap;
                            srcBitmap->GetImageInfo(&srcBitmapImageInfo);
                        }
                    }
                }
                if( graphics != NULL )
                {
                    delete graphics ;
                }
            }

        }


        // This is the size we're going to request the codec decode into.
        // Both width and height == 0 means use the source width and height.
        // If a width and height are specified, the codec may decode to
        // something close - always larger than the requested size.

        REAL width  = 0.0f;
        REAL height = 0.0f;

        // !!! PERF [asecchia] We should probably compute the size of
        // a rotational minification and work out the correct transforms
        // to take advantage of the codec minification for rotation.

        // Is an axis aligned minification happening?

        if(xForm.IsMinification())
        {
            // The code below explicitly assumes numPoints == 3. Yes I know 
            // we've already asserted this above, but you can't be too careful.

            ASSERT(numPoints == 3);

            // We're axis aligned so we can assume a simplified width and
            // height computation.

            RectF boundsRect;
            
            TransformBounds(
                &xForm,
                srcRect.X,
                srcRect.Y,
                srcRect.X+srcRect.Width,
                srcRect.Y+srcRect.Height,                
                &boundsRect
            );
            
            // Compute an upper bound on the width and height of the
            // destination.
            // we'll let the driver handle vertical an horizontal flips with
            // the scale transform.
            
            width = REALABS(boundsRect.GetRight()-boundsRect.GetLeft());
            height = REALABS(boundsRect.GetBottom()-boundsRect.GetTop());

            // In this case the Nyquist limit specifies that we can use a
            // cheap averaging decimation type algorithm for minification
            // down to double the size of the destination - after which we
            // must use the more expensive filter convolution for minification.
            
            // Note that the decimation algorithm is roughly equivalient to our 
            // regular Bilinear interpolation so we can decimate below the 
            // Nyquist limit for Bilinear.

            if(Context->FilterType != InterpolationModeBilinear)
            {
                width *= 2.0f;
                height *= 2.0f;
            }

            // The source image is smaller than the Nyquist limit in X
            // simply use the source width.

            if(width >= srcRect.Width)
            {
                width = srcRect.Width;
            }

            // The source image is smaller than the Nyquist limit in Y
            // simply use the source height.

            if(height >= srcRect.Height)
            {
                height = srcRect.Height;
            }

            // The source image is smaller than the Nyquist limit in
            // both X and Y. Set the parameters to zero to do no scaling
            // in the codec.
            // If width,height greater or equal to srcRect, set zero in the 
            // width to ask the codec to return us the image native size.

            if( (width - srcRect.Width >= -REAL_EPSILON) &&
                (height - srcRect.Height >= -REAL_EPSILON) )
            {
                width = 0.0f;
                height = 0.0f;
            }
            
            // Undo the cropping effect to figure out how much to decimate
            // the entire image before cropping takes place.
            
            width = width * srcBitmapImageInfo.Width / srcRect.Width;
            height = height * srcBitmapImageInfo.Height / srcRect.Height;
        }
        
        BitmapData bmpDataSrc;
        DpCompressedData compressedData;
        DpTransparency transparency;
        BYTE minAlpha = 0, maxAlpha = 0xFF;
        
        // Determine the transparency status of the bitmap.  If printing, then
        // must be accurate, otherwise we use cached flag.
        
        if ((status == Ok) &&
            (srcBitmap != NULL) &&
            (srcBitmap->IsValid()))
        {
            // Mark that we haven't locked the bits yet.
            BOOL bitsLoaded = FALSE;

            POINT     gdiPoints[3];

            // When printing we want to punt simple DrawImage calls to
            // GDI using StretchDIBits.  We check the criteria here, must
            // have simple transoformation.

            if (IsPrinter() &&
                (Context->WorldToDevice.IsTranslateScale()) &&
                (numPoints == 3) &&
                (REALABS(fDst[0].X - fDst[2].X) < REAL_EPSILON) &&
                (REALABS(fDst[0].Y - fDst[1].Y) < REAL_EPSILON) &&
                (fDst[1].X > fDst[0].X) && 
                (fDst[2].Y > fDst[0].Y) &&
                (Context->WorldToDevice.Transform(fDst, gdiPoints, 3),
                ((gdiPoints[1].x > gdiPoints[0].x) &&        // no flipping
                 (gdiPoints[2].y > gdiPoints[0].y)) ) )
            {
                // try PNG or JPG passthrough of compressed bits on Win98/NT
                if (!Globals::IsWin95 && 
                    (cloneBitmap == NULL) && // no recoloring
                    (srcRect.Height >= ((height*9)/10)) &&
                    (srcRect.Width >= ((width*9)/10)) &&
                    (srcRect.Height >= 32) &&
                    (srcRect.Width >= 32))
                {
                    
                    // !! ICM convert??
                    // !! Source rectangle is outside of image or WrapMode* on bitmap

                    HDC hdc;
                    
                    {   // FPU Sandbox for potentially unsafe FPU code.
                        FPUStateSandbox fpsb;
                        hdc = Context->GetHdc(Surface);
                    }   // FPU Sandbox for potentially unsafe FPU code.
                    
                    if (hdc != NULL) 
                    {
                        DriverPrint *dprint = (DriverPrint*)Driver;

                        status = srcBitmap->GetCompressedData(&compressedData,
                                               dprint->SupportJPEGpassthrough,
                                               dprint->SupportPNGpassthrough,
                                               hdc);
                    
                        if (compressedData.buffer != NULL) 
                        {
                            if (REALABS(width) < REAL_EPSILON || 
                                REALABS(height) < REAL_EPSILON )
                            {
                                bmpDataSrc.Width = srcBitmapImageInfo.Width;
                                bmpDataSrc.Height = srcBitmapImageInfo.Height;
                            }
                            else
                            {
                                bmpDataSrc.Width = GpRound(width);
                                bmpDataSrc.Height = GpRound(height);
                            }

                            bmpDataSrc.Stride = 0;
                            bmpDataSrc.PixelFormat = PixelFormatDontCare; 
                            bmpDataSrc.Scan0 = NULL;
                            bmpDataSrc.Reserved = 0;
                            bitsLoaded = TRUE;

                            // Since the driver supports passthrough of 
                            // this image, it is responsible for any
                            // transparency at printer level.  From here,
                            // we treat image as opaque.

                            transparency = TransparencyOpaque;
                            
                            lockedPixelFormat = PixelFormatDontCare;
                        }

                        Context->ReleaseHdc(hdc, Surface);
                    }
                }

                if (!bitsLoaded) 
                {
                    // If reasonable pixel format then get GDI to understand
                    // the format natively.
                    
                    if (((srcBitmapImageInfo.PixelFormat & PixelFormatGDI) != 0) &&
                        !IsAlphaPixelFormat(srcBitmapImageInfo.PixelFormat) &&
                        !IsExtendedPixelFormat(srcBitmapImageInfo.PixelFormat) && 
                        (GetPixelFormatSize(srcBitmapImageInfo.PixelFormat) <= 8))
                    {
                        lockedPixelFormat = srcBitmapImageInfo.PixelFormat;
                    }

                    if (Context->CompositingMode == CompositingModeSourceCopy)
                    {
                        transparency = TransparencyNoAlpha;
                    }
                    else
                    {
                        if (srcBitmap->GetTransparencyFlags(&transparency,
                                                        lockedPixelFormat,
                                                        &minAlpha,
                                                        &maxAlpha) != Ok)
                        {
                            transparency = TransparencyUnknown;
                        }

                        // We only want to lock at this pixel format if it 
                        // is opaque, otherwise we won't punt to GDI.  We take
                        // the hit of decoding twice, but notice it will likely
                        // be cheaper to load & test transparency at original 
                        // depth.

                        if (transparency != TransparencyOpaque &&
                            transparency != TransparencyNoAlpha)
                        {
                            lockedPixelFormat = PIXFMT_32BPP_PARGB;
                        }
                    }
                }
            }
            else
            {
                if (IsPrinter()) 
                {
                    // SourceCopy implies there is no alpha transfer to 
                    // destination.
                    if (Context->CompositingMode == CompositingModeSourceCopy)
                    {
                        transparency = TransparencyNoAlpha;
                    }
                    else
                    {
                        // Query image for accurate transparency flags.  If
                        // necessary, load into memory at 32bpp PARGB. 
                        if (srcBitmap->GetTransparencyFlags(&transparency,
                                                            lockedPixelFormat,
                                                            &minAlpha,
                                                            &maxAlpha) != Ok)
                        {
                            transparency = TransparencyUnknown;
                        }
                    }
                }
                else
                {
                    // non-printing scenarios query transparency flags only
                    if (srcBitmap->GetTransparencyHint(&transparency) != Ok)
                    {
                        transparency = TransparencyUnknown;
                    }
                }
            }
            
            // Lock the bits.
            // It's important that we lock the bits in a premultiplied
            // pixel format because the image filtering code for stretches
            // and rotation requires premultiplied input data to avoid the
            // "halo effect" on transparent borders.
            // This is going to trigger an expensive image format conversion
            // if the input data is not already premultiplied. This is 
            // obviously true if we've done Recoloring which requires 
            // and outputs non-premultiplied data.
            
            // A notable exception is metafiling which requires 
            // non-premultiplied data.

            // Note that the width and height that we get back in the
            // bmpDataSrc are the 'real' width and height. They represent
            // what the codec was actually able to do for us and may not
            // be equal to the width and height passed in.

            if (!bitsLoaded) 
            {
                status = srcBitmap->LockBits(
                    NULL,
                    IMGLOCK_READ,
                    lockedPixelFormat,
                    &bmpDataSrc,
                    GpRound(width),
                    GpRound(height)
                );
            }
        }
        else
        {
            status = InvalidParameter;
        }

        // We have been successful at everything including locking the bits.
        // Now lets actually set up the driver call.

        if(status == Ok)
        {
            DpBitmap driverSurface;

            // Fake up a DpBitmap for the driver call.
            // We do this because the GpBitmap doesn't maintain the
            // DpBitmap as a driver surface - instead it uses a
            // GpMemoryBitmap.
            
            srcBitmap->InitializeSurfaceForGdipBitmap(
                &driverSurface, 
                bmpDataSrc.Width, 
                bmpDataSrc.Height
            );

            driverSurface.Bits = bmpDataSrc.Scan0;
            driverSurface.Width = bmpDataSrc.Width;
            driverSurface.Height = bmpDataSrc.Height;
            driverSurface.Delta = bmpDataSrc.Stride;

            driverSurface.PixelFormat = lockedPixelFormat;
            
            // only valid when PixelFormat is 32bpp
            
            driverSurface.NumBytes = 
                bmpDataSrc.Width*
                bmpDataSrc.Height*
                sizeof(ARGB);

            if (compressedData.buffer != NULL)
            {
                driverSurface.CompressedData = &compressedData;
            }

            if (IsIndexedPixelFormat(lockedPixelFormat)) 
            {
                INT size = srcBitmap->GetPaletteSize();

                if (size > 0) 
                {   
                    driverSurface.PaletteTable = (ColorPalette*)GpMalloc(size);
                    
                    if(driverSurface.PaletteTable)
                    {
                        status = srcBitmap->GetPalette(
                            driverSurface.PaletteTable, 
                            size
                        );
                    }
                    else
                    {
                        status = OutOfMemory;
                    }
                    
                    if(Ok != status)
                    {
                        goto cleanup;
                    }
                }
            }

            driverSurface.SurfaceTransparency = transparency;
            driverSurface.MinAlpha = minAlpha;
            driverSurface.MaxAlpha = maxAlpha;

            // Fake up a DpImageAttributes if the imageAttributes is NULL

            // !!! PERF: [asecchia] It would be more efficient to not have
            // to do the multiple DpImageAttributes copies here - rather
            // we should pass it by pointer - that way we could use NULL
            // for the common case (no imageAttributes).

            DpImageAttributes dpImageAttributes;
            if(imageAttributes)
            {
                dpImageAttributes = imageAttributes->DeviceImageAttributes;
            }

            BOOL DestroyBitsWhenDone = FALSE;

            if(((INT)(bmpDataSrc.Width) != srcBitmapImageInfo.Width) ||
               ((INT)(bmpDataSrc.Height) != srcBitmapImageInfo.Height))
            {
                ASSERT(srcBitmapImageInfo.Width != 0);
                ASSERT(srcBitmapImageInfo.Height != 0);

                // The size we got back from LockBits is different from
                // the queried size of the image. This means that the codec
                // was able to perform some scaling for us (presumably for
                // some performance benefit).
                // Scale the source rectangle appropriately.

                REAL scaleFactorX = (REAL)(bmpDataSrc.Width)/srcBitmapImageInfo.Width;
                REAL scaleFactorY = (REAL)(bmpDataSrc.Height)/srcBitmapImageInfo.Height;
                bboxSrcRect.X = scaleFactorX*bboxSrcRect.X;
                bboxSrcRect.Y = scaleFactorY*bboxSrcRect.Y;
                bboxSrcRect.Width = scaleFactorX*bboxSrcRect.Width;
                bboxSrcRect.Height = scaleFactorY*bboxSrcRect.Height;

                // We have only a partial decode. That means the bits we have
                // in memory may not be sufficient for the next draw, so
                // blow the bits away to force a decode on the next draw.

                DestroyBitsWhenDone = TRUE;
            }

            // Call the driver to draw the image.

            status = Driver->DrawImage(
                Context, &driverSurface, Surface,
                drawBounds,
                &dpImageAttributes,
                numPoints, fDst,
                &bboxSrcRect, flags
             );

            if (lockedPixelFormat != PixelFormatDontCare) 
            {
                ASSERT(bmpDataSrc.Scan0 != NULL);

                srcBitmap->UnlockBits(&bmpDataSrc, DestroyBitsWhenDone);
            }

        }

        // delete compressed data allocation if any
        
        if (compressedData.buffer != NULL)
        {
            srcBitmap->DeleteCompressedData(&compressedData);
        }

        // Restore the Transformation
        
        Context->WorldToDevice = worldDevice;

        if (clipRegion != NULL)
        {
            // What if we fail this?
            if (restoreClipping)
            {
                SetClip(clipRegion, CombineModeReplace);
            }
            delete clipRegion;
        }

    }

    
    cleanup:
    
    // Throw away any temporary storage we used and clean up any state changes.

    Context->WorldToDevice = saveWorldToDevice;
    
    if (cloneBitmap)
    {
        cloneBitmap->Dispose();
    }
    
    if (xformBitmap)
    {
        xformBitmap->Dispose();
    }

    return status;
}

// This is really an ARGB array
BYTE GdipSolidColors216[224 * 4] = {
//  blue  grn   red   alpha
    0x00, 0x00, 0x00, 0xFF,
    0x00, 0x00, 0x80, 0xFF,
    0x00, 0x80, 0x00, 0xFF,
    0x00, 0x80, 0x80, 0xFF,
    0x80, 0x00, 0x00, 0xFF,
    0x80, 0x00, 0x80, 0xFF,
    0x80, 0x80, 0x00, 0xFF,
    0x80, 0x80, 0x80, 0xFF,
    0xC0, 0xC0, 0xC0, 0xFF,
    0xFF, 0x00, 0x00, 0xFF,
    0x00, 0xFF, 0x00, 0xFF,
    0xFF, 0xFF, 0x00, 0xFF,
    0x00, 0x00, 0xFF, 0xFF,
    0xFF, 0x00, 0xFF, 0xFF,
    0x00, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF,
    0x33, 0x00, 0x00, 0xFF,
    0x66, 0x00, 0x00, 0xFF,
    0x99, 0x00, 0x00, 0xFF,
    0xCC, 0x00, 0x00, 0xFF,
    0x00, 0x33, 0x00, 0xFF,
    0x33, 0x33, 0x00, 0xFF,
    0x66, 0x33, 0x00, 0xFF,
    0x99, 0x33, 0x00, 0xFF,
    0xCC, 0x33, 0x00, 0xFF,
    0xFF, 0x33, 0x00, 0xFF,
    0x00, 0x66, 0x00, 0xFF,
    0x33, 0x66, 0x00, 0xFF,
    0x66, 0x66, 0x00, 0xFF,
    0x99, 0x66, 0x00, 0xFF,
    0xCC, 0x66, 0x00, 0xFF,
    0xFF, 0x66, 0x00, 0xFF,
    0x00, 0x99, 0x00, 0xFF,
    0x33, 0x99, 0x00, 0xFF,
    0x66, 0x99, 0x00, 0xFF,
    0x99, 0x99, 0x00, 0xFF,
    0xCC, 0x99, 0x00, 0xFF,
    0xFF, 0x99, 0x00, 0xFF,
    0x00, 0xCC, 0x00, 0xFF,
    0x33, 0xCC, 0x00, 0xFF,
    0x66, 0xCC, 0x00, 0xFF,
    0x99, 0xCC, 0x00, 0xFF,
    0xCC, 0xCC, 0x00, 0xFF,
    0xFF, 0xCC, 0x00, 0xFF,
    0x33, 0xFF, 0x00, 0xFF,
    0x66, 0xFF, 0x00, 0xFF,
    0x99, 0xFF, 0x00, 0xFF,
    0xCC, 0xFF, 0x00, 0xFF,
    0x00, 0x00, 0x33, 0xFF,
    0x33, 0x00, 0x33, 0xFF,
    0x66, 0x00, 0x33, 0xFF,
    0x99, 0x00, 0x33, 0xFF,
    0xCC, 0x00, 0x33, 0xFF,
    0xFF, 0x00, 0x33, 0xFF,
    0x00, 0x33, 0x33, 0xFF,
    0x33, 0x33, 0x33, 0xFF,
    0x66, 0x33, 0x33, 0xFF,
    0x99, 0x33, 0x33, 0xFF,
    0xCC, 0x33, 0x33, 0xFF,
    0xFF, 0x33, 0x33, 0xFF,
    0x00, 0x66, 0x33, 0xFF,
    0x33, 0x66, 0x33, 0xFF,
    0x66, 0x66, 0x33, 0xFF,
    0x99, 0x66, 0x33, 0xFF,
    0xCC, 0x66, 0x33, 0xFF,
    0xFF, 0x66, 0x33, 0xFF,
    0x00, 0x99, 0x33, 0xFF,
    0x33, 0x99, 0x33, 0xFF,
    0x66, 0x99, 0x33, 0xFF,
    0x99, 0x99, 0x33, 0xFF,
    0xCC, 0x99, 0x33, 0xFF,
    0xFF, 0x99, 0x33, 0xFF,
    0x00, 0xCC, 0x33, 0xFF,
    0x33, 0xCC, 0x33, 0xFF,
    0x66, 0xCC, 0x33, 0xFF,
    0x99, 0xCC, 0x33, 0xFF,
    0xCC, 0xCC, 0x33, 0xFF,
    0xFF, 0xCC, 0x33, 0xFF,
    0x00, 0xFF, 0x33, 0xFF,
    0x33, 0xFF, 0x33, 0xFF,
    0x66, 0xFF, 0x33, 0xFF,
    0x99, 0xFF, 0x33, 0xFF,
    0xCC, 0xFF, 0x33, 0xFF,
    0xFF, 0xFF, 0x33, 0xFF,
    0x00, 0x00, 0x66, 0xFF,
    0x33, 0x00, 0x66, 0xFF,
    0x66, 0x00, 0x66, 0xFF,
    0x99, 0x00, 0x66, 0xFF,
    0xCC, 0x00, 0x66, 0xFF,
    0xFF, 0x00, 0x66, 0xFF,
    0x00, 0x33, 0x66, 0xFF,
    0x33, 0x33, 0x66, 0xFF,
    0x66, 0x33, 0x66, 0xFF,
    0x99, 0x33, 0x66, 0xFF,
    0xCC, 0x33, 0x66, 0xFF,
    0xFF, 0x33, 0x66, 0xFF,
    0x00, 0x66, 0x66, 0xFF,
    0x33, 0x66, 0x66, 0xFF,
    0x66, 0x66, 0x66, 0xFF,
    0x99, 0x66, 0x66, 0xFF,
    0xCC, 0x66, 0x66, 0xFF,
    0xFF, 0x66, 0x66, 0xFF,
    0x00, 0x99, 0x66, 0xFF,
    0x33, 0x99, 0x66, 0xFF,
    0x66, 0x99, 0x66, 0xFF,
    0x99, 0x99, 0x66, 0xFF,
    0xCC, 0x99, 0x66, 0xFF,
    0xFF, 0x99, 0x66, 0xFF,
    0x00, 0xCC, 0x66, 0xFF,
    0x33, 0xCC, 0x66, 0xFF,
    0x66, 0xCC, 0x66, 0xFF,
    0x99, 0xCC, 0x66, 0xFF,
    0xCC, 0xCC, 0x66, 0xFF,
    0xFF, 0xCC, 0x66, 0xFF,
    0x00, 0xFF, 0x66, 0xFF,
    0x33, 0xFF, 0x66, 0xFF,
    0x66, 0xFF, 0x66, 0xFF,
    0x99, 0xFF, 0x66, 0xFF,
    0xCC, 0xFF, 0x66, 0xFF,
    0xFF, 0xFF, 0x66, 0xFF,
    0x00, 0x00, 0x99, 0xFF,
    0x33, 0x00, 0x99, 0xFF,
    0x66, 0x00, 0x99, 0xFF,
    0x99, 0x00, 0x99, 0xFF,
    0xCC, 0x00, 0x99, 0xFF,
    0xFF, 0x00, 0x99, 0xFF,
    0x00, 0x33, 0x99, 0xFF,
    0x33, 0x33, 0x99, 0xFF,
    0x66, 0x33, 0x99, 0xFF,
    0x99, 0x33, 0x99, 0xFF,
    0xCC, 0x33, 0x99, 0xFF,
    0xFF, 0x33, 0x99, 0xFF,
    0x00, 0x66, 0x99, 0xFF,
    0x33, 0x66, 0x99, 0xFF,
    0x66, 0x66, 0x99, 0xFF,
    0x99, 0x66, 0x99, 0xFF,
    0xCC, 0x66, 0x99, 0xFF,
    0xFF, 0x66, 0x99, 0xFF,
    0x00, 0x99, 0x99, 0xFF,
    0x33, 0x99, 0x99, 0xFF,
    0x66, 0x99, 0x99, 0xFF,
    0x99, 0x99, 0x99, 0xFF,
    0xCC, 0x99, 0x99, 0xFF,
    0xFF, 0x99, 0x99, 0xFF,
    0x00, 0xCC, 0x99, 0xFF,
    0x33, 0xCC, 0x99, 0xFF,
    0x66, 0xCC, 0x99, 0xFF,
    0x99, 0xCC, 0x99, 0xFF,
    0xCC, 0xCC, 0x99, 0xFF,
    0xFF, 0xCC, 0x99, 0xFF,
    0x00, 0xFF, 0x99, 0xFF,
    0x33, 0xFF, 0x99, 0xFF,
    0x66, 0xFF, 0x99, 0xFF,
    0x99, 0xFF, 0x99, 0xFF,
    0xCC, 0xFF, 0x99, 0xFF,
    0xFF, 0xFF, 0x99, 0xFF,
    0x00, 0x00, 0xCC, 0xFF,
    0x33, 0x00, 0xCC, 0xFF,
    0x66, 0x00, 0xCC, 0xFF,
    0x99, 0x00, 0xCC, 0xFF,
    0xCC, 0x00, 0xCC, 0xFF,
    0xFF, 0x00, 0xCC, 0xFF,
    0x00, 0x33, 0xCC, 0xFF,
    0x33, 0x33, 0xCC, 0xFF,
    0x66, 0x33, 0xCC, 0xFF,
    0x99, 0x33, 0xCC, 0xFF,
    0xCC, 0x33, 0xCC, 0xFF,
    0xFF, 0x33, 0xCC, 0xFF,
    0x00, 0x66, 0xCC, 0xFF,
    0x33, 0x66, 0xCC, 0xFF,
    0x66, 0x66, 0xCC, 0xFF,
    0x99, 0x66, 0xCC, 0xFF,
    0xCC, 0x66, 0xCC, 0xFF,
    0xFF, 0x66, 0xCC, 0xFF,
    0x00, 0x99, 0xCC, 0xFF,
    0x33, 0x99, 0xCC, 0xFF,
    0x66, 0x99, 0xCC, 0xFF,
    0x99, 0x99, 0xCC, 0xFF,
    0xCC, 0x99, 0xCC, 0xFF,
    0xFF, 0x99, 0xCC, 0xFF,
    0x00, 0xCC, 0xCC, 0xFF,
    0x33, 0xCC, 0xCC, 0xFF,
    0x66, 0xCC, 0xCC, 0xFF,
    0x99, 0xCC, 0xCC, 0xFF,
    0xCC, 0xCC, 0xCC, 0xFF,
    0xFF, 0xCC, 0xCC, 0xFF,
    0x00, 0xFF, 0xCC, 0xFF,
    0x33, 0xFF, 0xCC, 0xFF,
    0x66, 0xFF, 0xCC, 0xFF,
    0x99, 0xFF, 0xCC, 0xFF,
    0xCC, 0xFF, 0xCC, 0xFF,
    0xFF, 0xFF, 0xCC, 0xFF,
    0x33, 0x00, 0xFF, 0xFF,
    0x66, 0x00, 0xFF, 0xFF,
    0x99, 0x00, 0xFF, 0xFF,
    0xCC, 0x00, 0xFF, 0xFF,
    0x00, 0x33, 0xFF, 0xFF,
    0x33, 0x33, 0xFF, 0xFF,
    0x66, 0x33, 0xFF, 0xFF,
    0x99, 0x33, 0xFF, 0xFF,
    0xCC, 0x33, 0xFF, 0xFF,
    0xFF, 0x33, 0xFF, 0xFF,
    0x00, 0x66, 0xFF, 0xFF,
    0x33, 0x66, 0xFF, 0xFF,
    0x66, 0x66, 0xFF, 0xFF,
    0x99, 0x66, 0xFF, 0xFF,
    0xCC, 0x66, 0xFF, 0xFF,
    0xFF, 0x66, 0xFF, 0xFF,
    0x00, 0x99, 0xFF, 0xFF,
    0x33, 0x99, 0xFF, 0xFF,
    0x66, 0x99, 0xFF, 0xFF,
    0x99, 0x99, 0xFF, 0xFF,
    0xCC, 0x99, 0xFF, 0xFF,
    0xFF, 0x99, 0xFF, 0xFF,
    0x00, 0xCC, 0xFF, 0xFF,
    0x33, 0xCC, 0xFF, 0xFF,
    0x66, 0xCC, 0xFF, 0xFF,
    0x99, 0xCC, 0xFF, 0xFF,
    0xCC, 0xCC, 0xFF, 0xFF,
    0xFF, 0xCC, 0xFF, 0xFF,
    0x33, 0xFF, 0xFF, 0xFF,
    0x66, 0xFF, 0xFF, 0xFF,
    0x99, 0xFF, 0xFF, 0xFF,
    0xCC, 0xFF, 0xFF, 0xFF,
};

ARGB
GpGraphics::GetNearestColor(
    ARGB        argb
    )
{
    HalftoneType    halftoneType = this->GetHalftoneType();

    // See if we are doing any halftoning
    if (halftoneType < HalftoneType16Color)
    {
        return argb;
    }

    INT         r = GpColor::GetRedARGB(argb);
    INT         g = GpColor::GetGreenARGB(argb);
    INT         b = GpColor::GetBlueARGB(argb);

    // Handle 15 and 16 bpp halftoning:
    
    if (halftoneType == HalftoneType15Bpp)
    {
        if (!Globals::IsNt)
        {
            // Subtract the bias, saturated to 0:

            r = (r < 4) ? 0 : (r - 4);
            g = (g < 4) ? 0 : (g - 4);
            b = (b < 4) ? 0 : (b - 4);
        }

        // Clear low 3 bits of each for a solid color:
        
        r &= 248;
        g &= 248;
        b &= 248;

        return GpColor((BYTE) r, (BYTE) g, (BYTE) b).GetValue();
    }
    else if (halftoneType == HalftoneType16Bpp)
    {
        if (!Globals::IsNt)
        {
            // Subtract the bias, saturated to 0:

            r = (r < 4) ? 0 : (r - 4);
            g = (g < 2) ? 0 : (g - 2);
            b = (b < 4) ? 0 : (b - 4);
        }

        // Clear low n bits of each for a solid color:

        r &= 248; // 5, n = 3
        g &= 252; // 6, n = 2
        b &= 248; // 5, n = 3

        return GpColor((BYTE) r, (BYTE) g, (BYTE) b).GetValue();
    }

    // Handle remaining cases, 4 bpp and 8 bpp halftoning:
    
    ASSERT((halftoneType == HalftoneType16Color) ||
           (halftoneType == HalftoneType216Color));

    INT         i;
    INT         deltaR;
    INT         deltaG;
    INT         deltaB;
    INT         curError;
    INT         minError = (255 * 255) + (255 * 255) + (255 * 255) + 1;
    ARGB        nearestColor;
    INT         max = (halftoneType == HalftoneType216Color) ? 224 * 4 : 16 * 4;

    i = 0;
    do
    {
        deltaR = GdipSolidColors216[i+2] - r;
        deltaG = GdipSolidColors216[i+1] - g;
        deltaB = GdipSolidColors216[i+0] - b;

        curError = (deltaR * deltaR) + (deltaG * deltaG) + (deltaB * deltaB);

        if (curError < minError)
        {
            nearestColor = *((ARGB *)(GdipSolidColors216 + i));
            if (curError == 0)
            {
                goto Found;
            }
            minError = curError;
        }
        i += 4;
    }  while (i < max);

    // Check to see if it is one of the four system colors.
    // Only return a system color if it is an exact match.
    
    COLORREF    rgb;
    rgb = RGB(r,g,b);

    if ((rgb == Globals::SystemColors[16]) ||
        (rgb == Globals::SystemColors[17]) ||
        (rgb == Globals::SystemColors[18]) ||
        (rgb == Globals::SystemColors[19]))
    {
        return argb;
    }

Found:
    // return the same alpha value

    INT         a = argb & Color::AlphaMask;

    if (a != Color::AlphaMask)
    {
        nearestColor = (nearestColor & (~Color::AlphaMask)) | a;
    }

    return nearestColor;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\graphicsimage.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Graphics image APIs.
*
* Revision History:
*
*   12/02/1998 andrewgo
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\graphicsstroke.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Graphics vector stroke APIs.
*
* Revision History:
*
*   12/02/1998 andrewgo
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\graphicsfill.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Graphics vector fill APIs.
*
* Revision History:
*
*   12/02/1998 andrewgo
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

#include "QuadTransforms.hpp"

/**************************************************************************\
*
* Function Description:
*
*   API to clear the surface to a specified color
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   03/13/2000 agodfrey
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::Clear(
    const GpColor &color
    )
{
    INT i;
    GpStatus status = Ok;

    ASSERT(this->IsValid());

    RectF drawRect(
        static_cast<float>(SurfaceBounds.X),
        static_cast<float>(SurfaceBounds.Y),
        static_cast<float>(SurfaceBounds.Width),
        static_cast<float>(SurfaceBounds.Height));

    if (IsRecording())
    {
        status = Metafile->RecordClear(&drawRect, color);

        if (status != Ok)
        {
            SetValid(FALSE);      // Prevent any more recording
            return status;
        }
        if (!DownLevel)
        {
            return Ok;
        }

        // else we need to record down-level GDI EMF records as well
    }

    GpSolidFill brush(color);

    if (!IsTotallyClipped(&SurfaceBounds))
    {
        // Remember the compositing mode, antialiasing mode, and world
        // transform, and then set them up for this call.

        GpMatrix oldWorldToDevice = Context->WorldToDevice;
        INT oldAntiAliasMode = Context->AntiAliasMode;
        GpCompositingMode oldCompositingMode = Context->CompositingMode;

        Context->WorldToDevice.Reset();
        Context->AntiAliasMode = 0;
        Context->CompositingMode = CompositingModeSourceCopy;

        Devlock devlock(Device);

        status = DrvFillRects(
            &SurfaceBounds,
            1,
            &drawRect,
            brush.GetDeviceBrush());

        // Restore the context state we changed

        Context->WorldToDevice = oldWorldToDevice;
        Context->AntiAliasMode = oldAntiAliasMode;
        Context->CompositingMode = oldCompositingMode;
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   API to fill rectangles using the specified brush
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   12/06/1998 andrewgo
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::FillRects(
    GpBrush* brush,
    const GpRectF* rects,
    INT count
    )
{
    INT i;
    GpStatus status = Ok;

    // Objects returned from the API must always be in a valid state:

    ASSERT((brush != NULL) && (rects != NULL));
    ASSERT(this->IsValid() && brush->IsValid());
    
    // See RAID bug:
    // 301407 GDI+ Globals::DesktopDC has thread affinity

    ASSERT(GetObjectType(Globals::DesktopIc) == OBJ_DC);

    if (count < 0)
    {
        return InvalidParameter;
    }

    if (count == 0)
    {
        return Ok;
    }

    // Zoom through the list and accumulate the bounds.  What a pain, but
    // we have to do this.

    REAL left   = rects[0].X;
    REAL top    = rects[0].Y;
    REAL right  = rects[0].GetRight();
    REAL bottom = rects[0].GetBottom();

    // !!![andrewgo] We have a bug here, in that we don't properly handle
    //               rectangles with negative dimensions (which after the
    //               transform might be positive dimensions):

    for (i = 1; i < count; i++)
    {
        if (rects[i].X < left)
        {
            left = rects[i].X;
        }
        if (rects[i].GetRight() > right)
        {
            right = rects[i].GetRight();
        }
        if (rects[i].Y < top)
        {
            top = rects[i].Y;
        }
        if (rects[i].GetBottom() > bottom)
        {
            bottom = rects[i].GetBottom();
        }
    }

    // Convert the bounds to device space:

    GpRectF bounds;

    TransformBounds(&(Context->WorldToDevice), left, top, right, bottom, &bounds);

    if (IsRecording())
    {
        status = Metafile->RecordFillRects(&bounds, brush, rects, count);
        if (status != Ok)
        {
            SetValid(FALSE);      // Prevent any more recording
            return status;
        }
        if (!DownLevel)
        {
            return Ok;
        }
        // else we need to record down-level GDI EMF records as well
    }

    if (UseDriverRects())
    {
        status = RenderFillRects(&bounds, count, rects, brush);
    }
    else
    {
        for (i = 0; i < count; i++)
        {
            if ((rects[i].Width > REAL_EPSILON) &&
                (rects[i].Height > REAL_EPSILON)   )
            {
                GpPointF points[4];

                left = rects[i].X;
                top = rects[i].Y;
                right = rects[i].X + rects[i].Width;
                bottom = rects[i].Y + rects[i].Height;

                points[0].X = left;
                points[0].Y = top;
                points[1].X = right;
                points[1].Y = top;
                points[2].X = right;
                points[2].Y = bottom;
                points[3].X = left;
                points[3].Y = bottom;

                const INT stackCount = 10;
                GpPointF stackPoints[stackCount];
                BYTE stackTypes[stackCount];

                GpPath path(
                    points,
                    4,
                    &stackPoints[0],
                    &stackTypes[0],
                    stackCount,
                    FillModeAlternate,
                    DpPath::ConvexRectangle
                );

                path.CloseFigure();

                if (path.IsValid())
                {
                    // Call internal FillPath so that path doesn't get recorded in
                    // the metafile again.

                    status = RenderFillPath(&bounds, &path, brush);

                    // Terminate if we failed to render.

                    if(status != Ok)
                    {
                        break;
                    }
                }
            }
        }
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   API to fill polygons using the specified brush
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   12/06/1998 andrewgo
*
\**************************************************************************/

GpStatus
GpGraphics::FillPolygon(
    GpBrush* brush,
    const GpPointF* points,
    INT count,
    GpFillMode fillMode
    )
{
    GpStatus status = Ok;

    ASSERT((brush != NULL) && (points != NULL));

    if ((count < 0) ||
        ((fillMode != FillModeWinding) && (fillMode != FillModeAlternate)))
    {
        return InvalidParameter;
    }

    // Two vertices or less constitutes an empty fill:

    if (count <= 2)
    {
        return Ok;
    }

    // Objects returned from the API must always be in a valid state:

    ASSERT(this->IsValid() && brush->IsValid());

    const stackCount = 30;
    GpPointF stackPoints[stackCount];
    BYTE stackTypes[stackCount];

    GpPath path(points, count, &stackPoints[0], &stackTypes[0], stackCount, fillMode);

    if (path.IsValid())
    {
        GpRectF     bounds;

        // If the path is a rectangle, we can draw it much faster and
        // save space in spool files and metafiles if we fill it as a
        // rect instead of as a path.
        if (this->UseDriverRects() && path.IsRectangle(&(Context->WorldToDevice)))
        {
            path.GetBounds(&bounds, NULL);
            return this->FillRects(brush, &bounds, 1);
        }

        path.GetBounds(&bounds, &(Context->WorldToDevice));

        if (IsRecording())
        {
            status = Metafile->RecordFillPolygon(&bounds, brush, points,
                                                 count, fillMode);
            if (status != Ok)
            {
                SetValid(FALSE);      // Prevent any more recording
                return status;
            }
            if (!DownLevel)
            {
                return Ok;
            }
            // else we need to record down-level GDI EMF records as well
        }

        // Call internal FillPath so that path doesn't get recorded in
        // the metafile again.
        status = RenderFillPath(&bounds, &path, brush);
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   API to fill an ellipse using the specified brush
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   02/18/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::FillEllipse(
    GpBrush* brush,
    const GpRectF& rect
    )
{
    ASSERT(brush != NULL);

    // Objects returned from the API must always be in a valid state:
    ASSERT(this->IsValid() && brush->IsValid());

    GpPath path;
    GpStatus status = path.AddEllipse(rect);

    if ((status == Ok) && path.IsValid())
    {
        GpRectF     bounds;

        path.GetBounds(&bounds, &(Context->WorldToDevice));

        if (IsRecording())
        {
            status = Metafile->RecordFillEllipse(&bounds, brush, rect);
            if (status != Ok)
            {
                SetValid(FALSE);      // Prevent any more recording
                return status;
            }
            if (!DownLevel)
            {
                return Ok;
            }
            // else we need to record down-level GDI EMF records as well
        }

        // Call internal FillPath so that path doesn't get recorded in
        // the metafile again.
        status = RenderFillPath(&bounds, &path, brush);
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   API to fill a pie shape using the specified brush
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   02/18/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::FillPie(
    GpBrush* brush,
    const GpRectF& rect,
    REAL startAngle,
    REAL sweepAngle
    )
{
    ASSERT(brush != NULL);

    // Objects returned from the API must always be in a valid state:
    ASSERT(this->IsValid() && brush->IsValid());

    GpPath      path;
    GpStatus    status = path.AddPie(rect, startAngle, sweepAngle);

    if ((status == Ok) && path.IsValid())
    {
        GpRectF     bounds;

        path.GetBounds(&bounds, &(Context->WorldToDevice));

        if (IsRecording())
        {
            status = Metafile->RecordFillPie(&bounds, brush, rect,
                                             startAngle, sweepAngle);
            if (status != Ok)
            {
                SetValid(FALSE);      // Prevent any more recording
                return status;
            }
            if (!DownLevel)
            {
                return Ok;
            }
            // else we need to record down-level GDI EMF records as well
        }

        // Call internal FillPath so that path doesn't get recorded in
        // the metafile again.
        status = RenderFillPath(&bounds, &path, brush);
    }

    return status;
}


/**************************************************************************\
*
* Function Description:
*
*   API to fill region  using the specified brush
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   12/18/1998 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::FillRegion(
    GpBrush* brush,
    GpRegion* region
    )
{
    GpStatus status;

    ASSERT((brush != NULL) && (region != NULL));

    // Objects returned from the API must always be in a valid state:

    ASSERT(this->IsValid() && brush->IsValid() && region->IsValid());

    BOOL    regionIsEmpty;

    if ((status = region->IsEmpty(&Context->WorldToDevice, &regionIsEmpty)) != Ok)
    {
        return status;
    }

    if (regionIsEmpty)
    {
        return Ok;
    }

    GpRectF     bounds;

    if ((status = region->GetBounds(this, &bounds, TRUE)) == Ok)
    {
        // The region may have very large bounds if it is infinite or if
        // an infinite region was combined with another region.  We don't
        // want to draw a huge region into a metafile, because it will
        // mess up the bounds of the metafile. So intersect the region
        // with the appropriate bounding rect.

        GpRect  metafileBounds; // in device units
        BOOL    isMetafileGraphics = (this->Type == GraphicsMetafile);

        if (isMetafileGraphics)
        {
            if (this->Metafile != NULL)
            {
                this->Metafile->GetMetafileBounds(metafileBounds);
                metafileBounds.Width++;     // make exclusive
                metafileBounds.Height++;
            }
            else    // use size of HDC
            {
                HDC         hdc = Context->GetHdc(Surface);
                metafileBounds.X = 0;
                metafileBounds.Y = 0;
                metafileBounds.Width  = ::GetDeviceCaps(hdc, HORZRES);
                metafileBounds.Height = ::GetDeviceCaps(hdc, VERTRES);
                Context->ReleaseHdc(hdc);
            }
            GpRectF     metafileBoundsF;
            metafileBoundsF.X      = (REAL)metafileBounds.X;
            metafileBoundsF.Y      = (REAL)metafileBounds.Y;
            metafileBoundsF.Width  = (REAL)metafileBounds.Width;
            metafileBoundsF.Height = (REAL)metafileBounds.Height;
            bounds.Intersect(metafileBoundsF);
        }

        if (IsRecording())
        {
            status = Metafile->RecordFillRegion(&bounds, brush, region);
            if (status != Ok)
            {
                SetValid(FALSE);      // Prevent any more recording
                return status;
            }
            if (!DownLevel)
            {
                return Ok;
            }
            // else we need to record down-level GDI EMF records as well
        }

        if (isMetafileGraphics)
        {
            status = RenderFillRegion(&bounds, region, brush, &metafileBounds);
        }
        else    // not an infinite region
        {
            // call internal FillRegion that doesn't do recording
            status = RenderFillRegion(&bounds, region, brush, NULL);
        }
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   API to fill path using the specified brush
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   12/18/1998 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::FillPath(
    const GpBrush* brush,
    GpPath* path
    )
{
    GpStatus status = Ok;

    ASSERT((brush != NULL) && (path != NULL));

    // Objects returned from the API must always be in a valid state:

    ASSERT(this->IsValid() && brush->IsValid() && path->IsValid());

    // Don't do anything with less then 2 points.

    if (path->GetPointCount() < 3)
    {
        return status;
    }

    GpRectF     bounds;

    // If the path is a rectangle, we can draw it much faster and
    // save space in spool files and metafiles if we fill it as a
    // rect instead of as a path.
    if (this->UseDriverRects() && path->IsRectangle(&(Context->WorldToDevice)))
    {
        path->GetBounds(&bounds, NULL);
        return this->FillRects(const_cast<GpBrush *>(brush), &bounds, 1);
    }

    path->GetBounds(&bounds, &(Context->WorldToDevice));

    if (IsRecording())
    {
        status = Metafile->RecordFillPath(&bounds, brush, path);
        if (status != Ok)
        {
            SetValid(FALSE);      // Prevent any more recording
            return status;
        }
        if (!DownLevel)
        {
            return Ok;
        }
        // else we need to record down-level GDI EMF records as well
    }

    // call internal FillPath that doesn't do recording
    status = RenderFillPath(&bounds, path, brush);

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   API to fill a closed curve using the specified brush
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   02/18/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::FillClosedCurve(
    GpBrush* brush,
    const GpPointF* points,
    INT count,
    REAL tension,
    GpFillMode fillMode
    )
{
    ASSERT((brush != NULL) && (points != NULL));

    // Objects returned from the API must always be in a valid state:
    ASSERT(this->IsValid() && brush->IsValid());

    if ((count < 0) ||
        ((fillMode != FillModeWinding) && (fillMode != FillModeAlternate)))
    {
        return InvalidParameter;
    }

    // Less than three vertices constitutes an empty fill:
    if (count < 3)
    {
        return Ok;
    }

    GpPath      path(fillMode);
    GpStatus    status = path.AddClosedCurve(points, count, tension);

    if ((status == Ok) && path.IsValid())
    {
        GpRectF     bounds;

        path.GetBounds(&bounds, &(Context->WorldToDevice));

        if (IsRecording())
        {
            status = Metafile->RecordFillClosedCurve(&bounds, brush,
                                                     points, count, tension,
                                                     fillMode);
            if (status != Ok)
            {
                SetValid(FALSE);      // Prevent any more recording
                return status;
            }
            if (!DownLevel)
            {
                return Ok;
            }
            // else we need to record down-level GDI EMF records as well
        }

        // Call internal FillPath so that path doesn't get recorded in
        // the metafile again.
        status = RenderFillPath(&bounds, &path, brush);
    }

    return status;
}


/**************************************************************************\
*
* Function Description:
*
*   API to draw polygons using the specified pen
*
* Arguments:
*
*   [IN] pen    - the pen for stroking.
*   [IN] points - the point data.
*   [IN] count  - the number of points given in points array.
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   01/06/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::DrawLines(
    GpPen* pen,
    const GpPointF* points,
    INT count,
    BOOL closed
    )
{
    GpStatus status = Ok;

    ASSERT((pen != NULL) && (points != NULL));

    if (count < 2)
    {
        return InvalidParameter;
    }

    // Objects returned from the API must always be in a valid state:

    ASSERT(this->IsValid() && pen->IsValid());

    const stackCount = 30;
    GpPointF stackPoints[stackCount];
    BYTE stackTypes[stackCount];

    GpPath path(points, count, stackPoints, stackTypes, stackCount, FillModeWinding);
    if(closed)
        path.CloseFigure();

    if (path.IsValid())
    {
        GpRectF     bounds;

        REAL dpiX = GetDpiX();
        REAL dpiY = GetDpiY();
        path.GetBounds(&bounds, &(Context->WorldToDevice), pen->GetDevicePen(), dpiX, dpiY);

        if (IsRecording())
        {
            status = Metafile->RecordDrawLines(&bounds, pen, points,
                                               count, closed);
            if (status != Ok)
            {
                SetValid(FALSE);      // Prevent any more recording
                return status;
            }
            if (!DownLevel)
            {
                return Ok;
            }
            // else we need to record down-level GDI EMF records as well
        }

        // Call internal DrawPath so that path doesn't get recorded in
        // the metafile again.
        status = RenderDrawPath(&bounds, &path, pen);
   }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   API to draw an arc using the specified pen
*
* Arguments:
*
*   [IN] pen            - the pen for stroking.
*   [IN] rect           - the boundary rect.
*   [IN] startAndle     - the start angle in degrees
*   [IN] sweepAngle     - the sweep angle in degrees in clockwise
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   02/18/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::DrawArc(
    GpPen* pen,
    const GpRectF& rect,
    REAL startAngle,
    REAL sweepAngle
    )
{
    ASSERT(pen != NULL);

    // Objects returned from the API must always be in a valid state:
    ASSERT(this->IsValid() && pen->IsValid());

    GpPath      path;
    GpStatus    status = path.AddArc(rect, startAngle, sweepAngle);

    if ((status == Ok) && path.IsValid())
    {
        GpRectF     bounds;

        REAL dpiX = GetDpiX();
        REAL dpiY = GetDpiY();
        path.GetBounds(&bounds, &(Context->WorldToDevice), pen->GetDevicePen(), dpiX, dpiY);

        if (IsRecording())
        {
            status = Metafile->RecordDrawArc(&bounds, pen, rect,
                                             startAngle, sweepAngle);
            if (status != Ok)
            {
                SetValid(FALSE);      // Prevent any more recording
                return status;
            }
            if (!DownLevel)
            {
                return Ok;
            }
            // else we need to record down-level GDI EMF records as well
        }

        // Call internal DrawPath so that path doesn't get recorded in
        // the metafile again.
        status = RenderDrawPath(&bounds, &path, pen);
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   API to draw Cubic Bezier curves using the specified pen
*
* Arguments:
*
*   [IN] pen    - the pen for stroking.
*   [IN] points - the control points.
*   [IN] count  - the number of control points (must be 3n + 1).
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   02/18/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::DrawBeziers(
    GpPen* pen,
    const GpPointF* points,
    INT count
    )
{
    ASSERT((pen != NULL) && (points != NULL));

    // Objects returned from the API must always be in a valid state:
    ASSERT(this->IsValid() && pen->IsValid());

    // Nothing to draw
    if (count <= 3)
    {
        return Ok;
    }

    GpPath      path;
    GpStatus    status = path.AddBeziers(points, count);

    if ((status == Ok) && path.IsValid())
    {
        GpRectF     bounds;

        REAL dpiX = GetDpiX();
        REAL dpiY = GetDpiY();
        path.GetBounds(&bounds, &(Context->WorldToDevice), pen->GetDevicePen(), dpiX, dpiY);

        if (IsRecording())
        {
            status = Metafile->RecordDrawBeziers(&bounds, pen,
                                                 points, count);
            if (status != Ok)
            {
                SetValid(FALSE);      // Prevent any more recording
                return status;
            }
            if (!DownLevel)
            {
                return Ok;
            }
            // else we need to record down-level GDI EMF records as well
        }

        // Call internal DrawPath so that path doesn't get recorded in
        // the metafile again.
        status = RenderDrawPath(&bounds, &path, pen);
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   API to draw rectangles using the specified brush
*
* Arguments:
*
*   [IN] pen    - the pen for stroking.
*   [IN] rects  - the rectangle array.
*   [IN] count  - the number of rectangles given in rects array.
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   01/15/1998 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::DrawRects(
    GpPen* pen,
    const GpRectF* rects,
    INT count
    )
{
    INT i;
    GpStatus status = Ok;

    // !!! Change Eng function to do clipping
    // !!! Create a stack path
    // !!! Fix multiple inheritence thing
    // !!! Check tail merging
    // !!! Add alignment checks
    // !!! Change DDIs to return GpStatus?
    // !!! Add ICM hooks?
    // !!! Change path constant to include 'single figure'?
    // !!! Create .LIB
    // !!! Add convention for alpha

    // Objects returned from the API must always be in a valid state:

    ASSERT((pen != NULL) && (rects != NULL));
    ASSERT(this->IsValid() && pen->IsValid());

    if (count < 0)
    {
        return InvalidParameter;
    }

    if (count == 0)
    {
        return Ok;
    }

    // Zoom through the list and accumulate the bounds.  What a pain, but
    // we have to do this.

    // !!! We're doing 'double' goop, so we should ensure correct stack
    //     alignment

    REAL left   = rects[0].X;
    REAL top    = rects[0].Y;
    REAL right  = rects[0].GetRight();
    REAL bottom = rects[0].GetBottom();

    for (i = 1; i < count; i++)
    {
        if (rects[i].X < left)
        {
            left = rects[i].X;
        }
        if (rects[i].GetRight() > right)
        {
            right = rects[i].GetRight();
        }
        if (rects[i].Y < top)
        {
            top = rects[i].Y;
        }
        if (rects[i].GetBottom() > bottom)
        {
            bottom = rects[i].GetBottom();
        }
    }

    GpRectF     bounds;

    // Convert the bounds to device space and adjust for the pen width

    REAL dpiX = GetDpiX();
    REAL dpiY = GetDpiY();

    DpPen *dpPen = pen->GetDevicePen();

    REAL penWidth = 0;
    Unit penUnit = UnitWorld;
    REAL delta = 0;

    if(dpPen)
    {
        penWidth = dpPen->Width;
        penUnit = dpPen->Unit;

        if(penUnit == UnitWorld)
        {
            // If the pen is in World unit, strech the rectangle
            // by pen width before the transform.

            // For a case of the centered pen.
            // penWidth/2 is OK. But here, we
            // just use penWidth for all pen mode.

            delta = penWidth;

            left -= delta;
            top -= delta;
            right += delta;
            bottom += delta;
        }
    }

    TransformBounds(&(Context->WorldToDevice), left, top, right, bottom,
        &bounds);

    if(dpPen)
    {
        if(penUnit != UnitWorld)
        {
            // If the pen is not in World unit, strech the rectangle
            // by pen's device width after the transform.

            REAL dpi = max(dpiX, dpiY);
            penWidth = ::GetDeviceWidth(penWidth, penUnit, dpi);

            // For a case of the centered pen.
            // penWidth/2 is OK. But here, we
            // just use penWidth for all pen mode.

            delta = penWidth;

            bounds.X -= delta;
            bounds.Y -= delta;
            bounds.Width += 2*delta;
            bounds.Height += 2*delta;
        }
    }

    if (IsRecording())
    {
        status = Metafile->RecordDrawRects(&bounds, pen, rects, count);
        if (status != Ok)
        {
            SetValid(FALSE);      // Prevent any more recording
            return status;
        }
        if (!DownLevel)
        {
            return Ok;
        }
        // else we need to record down-level GDI EMF records as well
    }

    // Increase the bounds to account for the widener's minimum pen width.
    // For some arcane reason, the widener doesn't use 1.0 as the minimum
    // pen width. Rather it uses 1.000001f. Also it has some interesting
    // rounding properties, so our epsilon here is much larger 0.001f

    bounds.Inflate(1.001f, 1.001f);

    for (i = 0; i < count; i++)
    {
        if ((rects[i].Width > REAL_EPSILON) &&
            (rects[i].Height > REAL_EPSILON)   )
        {
            // !!! Should use a stack-path
            // !!! For StrokePath case, should check start of rectangle
            //     for styled lines

            GpPointF points[4];

            left = rects[i].X;
            top = rects[i].Y;
            right = rects[i].X + rects[i].Width;
            bottom = rects[i].Y + rects[i].Height;

            points[0].X = left;
            points[0].Y = top;
            points[1].X = right;
            points[1].Y = top;
            points[2].X = right;
            points[2].Y = bottom;
            points[3].X = left;
            points[3].Y = bottom;

            const INT stackCount = 10;
            GpPointF stackPoints[stackCount];
            BYTE stackTypes[stackCount];

            GpPath path(
                points,
                4,
                stackPoints,
                stackTypes,
                stackCount,
                FillModeAlternate,
                DpPath::ConvexRectangle
            );

            path.CloseFigure();

            if(path.IsValid())
            {
                // Call internal DrawPath so that path doesn't get recorded in
                // the metafile again.
                status = RenderDrawPath(&bounds, &path, pen);

                if(status != Ok)
                {
                    break;
                }
            }
        }
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   API to draw an ellipse using the specified pen
*
* Arguments:
*
*   [IN] pen    - the pen for stroking.
*   [IN] rect   - the boundary rectangle
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   02/18/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::DrawEllipse(
    GpPen* pen,
    const GpRectF& rect
    )
{
    ASSERT(pen != NULL);

    // Objects returned from the API must always be in a valid state:
    ASSERT(this->IsValid() && pen->IsValid());

    GpPath      path;
    GpStatus    status = path.AddEllipse(rect);

    if ((status == Ok) && path.IsValid())
    {
        GpRectF     bounds;

        REAL dpiX = GetDpiX();
        REAL dpiY = GetDpiY();
        path.GetBounds(&bounds, &(Context->WorldToDevice), pen->GetDevicePen(), dpiX, dpiY);

        if (IsRecording())
        {
            status = Metafile->RecordDrawEllipse(&bounds, pen, rect);
            if (status != Ok)
            {
                SetValid(FALSE);      // Prevent any more recording
                return status;
            }
            if (!DownLevel)
            {
                return Ok;
            }
            // else we need to record down-level GDI EMF records as well
        }

        // Call internal DrawPath so that path doesn't get recorded in
        // the metafile again.
        status = RenderDrawPath(&bounds, &path, pen);
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   API to draw a pie using the specified pen
*
* Arguments:
*
*   [IN] pen    - the pen for stroking.
*   [IN] rect   - the boundary rectangle
*   [IN] startAngle - the start angle in degrees.
*   [IN] sweepAngle - the sweep angle in degrees in clockwise.
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   02/18/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::DrawPie(
    GpPen* pen,
    const GpRectF& rect,
    REAL startAngle,
    REAL sweepAngle
    )
{
    ASSERT(pen != NULL);

    // Objects returned from the API must always be in a valid state:
    ASSERT(this->IsValid() && pen->IsValid());

    GpPath      path;
    GpStatus    status = path.AddPie(rect, startAngle, sweepAngle);

    if ((status == Ok) && path.IsValid())
    {
        GpRectF     bounds;

        REAL dpiX = GetDpiX();
        REAL dpiY = GetDpiY();
        path.GetBounds(&bounds, &(Context->WorldToDevice), pen->GetDevicePen(), dpiX, dpiY);

        if (IsRecording())
        {
            status = Metafile->RecordDrawPie(&bounds, pen, rect,
                                             startAngle, sweepAngle);
            if (status != Ok)
            {
                SetValid(FALSE);      // Prevent any more recording
                return status;
            }
            if (!DownLevel)
            {
                return Ok;
            }
            // else we need to record down-level GDI EMF records as well
        }

        // Call internal DrawPath so that path doesn't get recorded in
        // the metafile again.
        status = RenderDrawPath(&bounds, &path, pen);
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   API to draw path using the specified pen
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   01/27/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::DrawPath(
        GpPen* pen,
        GpPath* path
    )
{
    GpStatus status = Ok;

    ASSERT((pen != NULL) && (path != NULL));


    // Objects returned from the API must always be in a valid state:

    ASSERT(this->IsValid() && pen->IsValid() && path->IsValid());

    // Don't do anything unless we have at least one point

    if (path->GetPointCount() < 1)
    {
        return status;
    }

    GpRectF     bounds;

    REAL dpiX = GetDpiX();
    REAL dpiY = GetDpiY();
    path->GetBounds(&bounds, &(Context->WorldToDevice), pen->GetDevicePen(), dpiX, dpiY);

    if (IsRecording())
    {
        status = Metafile->RecordDrawPath(&bounds, pen, path);
        if (status != Ok)
        {
            SetValid(FALSE);      // Prevent any more recording
            return status;
        }
        if (!DownLevel)
        {
            return Ok;
        }
        // else we need to record down-level GDI EMF records as well
    }

    // call internal DrawPath that doesn't do recording
    status = RenderDrawPath(&bounds, path, pen);

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   API to draw a curve using the specified pen.
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   02/18/1999 ikkof
*       Created it.
*
\**************************************************************************/

#define DEFAULT_TENSION     0.5

GpStatus
GpGraphics::DrawCurve(
    GpPen* pen,
    const GpPointF* points,
    INT count
    )
{
    return DrawCurve(pen, points, count, DEFAULT_TENSION, 0, count - 1);
}

GpStatus
GpGraphics::DrawCurve(
    GpPen* pen,
    const GpPointF* points,
    INT count,
    REAL tension,
    INT offset,
    INT numberOfSegments
    )
{
    ASSERT((pen != NULL) && (points != NULL));

    // Objects returned from the API must always be in a valid state:
    ASSERT(this->IsValid() && pen->IsValid());

    if (count < 2)
    {
        return InvalidParameter;
    }

    GpPath      path;
    GpStatus    status = path.AddCurve(points,
                                       count,
                                       tension,
                                       offset,
                                       numberOfSegments);

    if ((status == Ok) && path.IsValid())
    {
        GpRectF     bounds;

        REAL dpiX = GetDpiX();
        REAL dpiY = GetDpiY();
        path.GetBounds(&bounds, &(Context->WorldToDevice), pen->GetDevicePen(), dpiX, dpiY);

        if (IsRecording())
        {
            status = Metafile->RecordDrawCurve(&bounds, pen, points,
                                               count, tension, offset,
                                               numberOfSegments);
            if (status != Ok)
            {
                SetValid(FALSE);      // Prevent any more recording
                return status;
            }
            if (!DownLevel)
            {
                return Ok;
            }
            // else we need to record down-level GDI EMF records as well
        }

        // Call internal DrawPath so that path doesn't get recorded in
        // the metafile again.
        status = RenderDrawPath(&bounds, &path, pen);
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   API to draw a closed curve using the specified pen.
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   02/18/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::DrawClosedCurve(
    GpPen* pen,
    const GpPointF* points,
    INT count
    )
{
    return DrawClosedCurve (pen, points, count, DEFAULT_TENSION);
}

GpStatus
GpGraphics::DrawClosedCurve(
        GpPen* pen,
        const GpPointF* points,
        INT count,
        REAL tension
    )
{
    ASSERT((pen != NULL) && (points != NULL));

    // Objects returned from the API must always be in a valid state:
    ASSERT(this->IsValid() && pen->IsValid());

    if (count < 3)
    {
        return InvalidParameter;
    }

    GpPath      path;
    GpStatus    status = path.AddClosedCurve(points, count, tension);

    if ((status == Ok) && path.IsValid())
    {
        GpRectF     bounds;

        REAL dpiX = GetDpiX();
        REAL dpiY = GetDpiY();
        path.GetBounds(&bounds, &(Context->WorldToDevice), pen->GetDevicePen(), dpiX, dpiY);

        if (IsRecording())
        {
            status = Metafile->RecordDrawClosedCurve(&bounds, pen, points,
                                                     count, tension);
            if (status != Ok)
            {
                SetValid(FALSE);      // Prevent any more recording
                return status;
            }
            if (!DownLevel)
            {
                return Ok;
            }
            // else we need to record down-level GDI EMF records as well
        }

        // Call internal DrawPath so that path doesn't get recorded in
        // the metafile again.
        status = RenderDrawPath(&bounds, &path, pen);
    }

    return status;
}


/**************************************************************************\
*
* Function Description:
*
*   Internal Drawing routine for a path.  Various functions will
*   call RenderFillPath.
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   09/18/2000 asecchia
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::RenderFillPath(
    GpRectF*    bounds,
    GpPath*     path,
    const GpBrush*    brush
    )
{
    // Are they asking us to draw nothing?

    if( REALABS(bounds->Width) < REAL_EPSILON ||
        REALABS(bounds->Height) < REAL_EPSILON )
    {
        // Yes. Ok, we did it.
        return Ok;
    }

    GpRect      deviceBounds;
    GpStatus status = BoundsFToRect(bounds, &deviceBounds);

    if (status == Ok && !IsTotallyClipped(&deviceBounds))
    {
        // Now that we've done a bunch of work in accumulating the bounds,
        // acquire the device lock before calling the driver:

        Devlock devlock(Device);

        return DrvFillPath(&deviceBounds, path, brush->GetDeviceBrush());
    }
    return status;
}


/**************************************************************************\
*
* Function Description:
*
*   Internal Drawing routine for a path.  Various functions will
*   call RenderDrawPath.
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   10/28/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::RenderDrawPath(
    GpRectF *   bounds,
    GpPath *    path,
    GpPen *     pen
    )
{
    // Are they asking us to draw nothing?

    if( REALABS(bounds->Width) < REAL_EPSILON ||
        REALABS(bounds->Height) < REAL_EPSILON )
    {
        // Yes. Ok, we did it.
        return Ok;
    }

    GpRect      deviceBounds;
    GpStatus status = BoundsFToRect(bounds, &deviceBounds);
    INT         savedState = 0;

    if (status == Ok && !IsTotallyClipped(&deviceBounds))
    {
        // Now that we've done a bunch of work in accumulating the bounds,
        // acquire the device lock before calling the driver:

        Devlock devlock(Device);

        status = DrvStrokePath(&deviceBounds, path, pen->GetDevicePen());
    }
    return status;
}

VOID
GetEmfDpi(
    HDC     hdc,
    REAL *  dpiX,
    REAL *  dpiY
    )
{
    SIZEL   szlDevice;          // Size of the reference device in pels
    SIZEL   szlMillimeters;     // Size of the reference device in millimeters

    szlDevice.cx = GetDeviceCaps(hdc, HORZRES);
    szlDevice.cy = GetDeviceCaps(hdc, VERTRES);

    szlMillimeters.cx = GetDeviceCaps(hdc, HORZSIZE);
    szlMillimeters.cy = GetDeviceCaps(hdc, VERTSIZE);

    if ((szlDevice.cx > 0) && (szlDevice.cy > 0) &&
        (szlMillimeters.cx > 0) && (szlMillimeters.cy > 0))
    {
        *dpiX = (static_cast<REAL>(szlDevice.cx) /
                 static_cast<REAL>(szlMillimeters.cx)) * 25.4f;
        *dpiY = (static_cast<REAL>(szlDevice.cy) /
                 static_cast<REAL>(szlMillimeters.cy)) * 25.4f;
    }
    else
    {
        WARNING(("GetDeviceCaps failed"));

        *dpiX = DEFAULT_RESOLUTION;
        *dpiY = DEFAULT_RESOLUTION;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Get the size of the destination image in the current page units.
*
* Arguments:
*
*   [IN]  srcDpiX    - horizontal resolution of the source image
*   [IN]  srcDpiY    - vertical resolution of the source image
*   [IN]  srcWidth   - width  of the source image in srcUnit units
*   [IN]  srcHeight  - height of the source image in srcUnit units
*   [IN]  srcUnit    - units of the srcWidth and srcHeight
*   [OUT] destWidth  - destination width  in the current page units
*   [OUT] destHeight - destination height in the current page units
*
* Return Value:
*
*   NONE
*
* Created:
*
*   05/10/1999 DCurtis
*
\**************************************************************************/
VOID
GpGraphics::GetImageDestPageSize(
    const GpImage *     image,
    REAL                srcWidth,
    REAL                srcHeight,
    GpPageUnit          srcUnit,
    REAL &              destWidth,
    REAL &              destHeight
    )
{
    // UnitDisplay is device-dependent and cannot be used for a source unit
    ASSERT(srcUnit != UnitDisplay);

    if (srcUnit == UnitPixel)
    {
        REAL        srcDpiX;
        REAL        srcDpiY;
        REAL        destDpiX;
        REAL        destDpiY;

        image->GetResolution(&srcDpiX, &srcDpiY);

        // We don't want to create a bitmap just to get the dpi
        // so check if we can get an Hdc easily from the context.
        if ((image->GetImageType() == ImageTypeMetafile) &&
            (((GpMetafile *)(image))->IsEmfOrEmfPlus()) &&
            (Context->Hwnd || Context->Hdc))
        {
            // EMFs use a different style of dpi than other images that
            // is based off the screen size instead of the font size.

            if (Context->Hwnd)
            {
                // We don't need a clean dc to find out the dpi
                HDC     hdc = GetDC(Context->Hwnd);
                GetEmfDpi(hdc, &destDpiX, &destDpiY);
                ReleaseDC(Context->Hwnd, hdc);
            }
            else
            {
                GetEmfDpi(Context->Hdc, &destDpiX, &destDpiY);
            }
        }
        else
        {
            destDpiX = GetDpiX();
            destDpiY = GetDpiY();
        }

        // To get the dest size, convert the width and height from the image
        // resolution to the resolution of this graphics and then convert
        // them to page units by going through the inverse of the page to
        // device transform.

        destWidth  = (srcWidth * destDpiX) /
                     (srcDpiX * Context->PageMultiplierX);
        destHeight = (srcHeight * destDpiY) /
                     (srcDpiY * Context->PageMultiplierY);
    }
    else
    {
        // Just convert from the units of the image to the current
        // page units.

        REAL        unitMultiplierX;
        REAL        unitMultiplierY;

        Context->GetPageMultipliers(&unitMultiplierX, &unitMultiplierY,
                                    srcUnit);

        destWidth  = (srcWidth  * unitMultiplierX) / Context->PageMultiplierX;
        destHeight = (srcHeight * unitMultiplierY) / Context->PageMultiplierY;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   API to draw image
*
* Arguments:
*
*   [IN] image  - the image to draw.
*   [IN] point  - the top-left corner of the drawing boundary.
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   01/06/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::DrawImage(
    GpImage* image,
    const GpPointF& point
    )
{
    GpStatus status;

    ASSERT((image != NULL));

    // Objects returned from the API must always be in a valid state:

    ASSERT(this->IsValid() && image->IsValid());

    GpRectF     srcRect;
    GpPageUnit  srcUnit;
    REAL        destWidth;
    REAL        destHeight;

    status = image->GetBounds(&srcRect, &srcUnit);
    if(status != Ok) {return status;}

    // UnitDisplay is device-dependent and cannot be used for a source unit
    ASSERT(srcUnit != UnitDisplay);

    if (status == Ok)
    {
        // Get the dest size in page units
        GetImageDestPageSize(image, srcRect.Width, srcRect.Height,
                             srcUnit, destWidth, destHeight);

        GpRectF destRect(point.X, point.Y, destWidth, destHeight);

        return DrawImage(image, destRect, srcRect, srcUnit);
    }
    return status;
}

GpStatus
GpGraphics::DrawImage(
    GpImage*        image,
    REAL            x,
    REAL            y,
    const GpRectF & srcRect,
    GpPageUnit      srcUnit
    )
{
    // UnitDisplay is device-dependent and cannot be used for a source unit
    ASSERT(srcUnit != UnitDisplay);

    REAL        srcDpiX, srcDpiY;
    REAL        destWidth;
    REAL        destHeight;

    // Get the dest size in page units
    GetImageDestPageSize(image, srcRect.Width, srcRect.Height,
                         srcUnit, destWidth, destHeight);

    GpRectF destRect(x, y, destWidth, destHeight);

    return DrawImage(image, destRect, srcRect, srcUnit);
}

/**************************************************************************\
*
* Function Description:
*
*   API to draw image.
*
*   [IN] image  - the image to draw.
*   [IN] rect   - the the drawing boundary.
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   01/12/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::DrawImage(
    GpImage* image,
    const GpRectF& destRect
    )
{
    GpStatus status;

    ASSERT((image != NULL));

    // Objects returned from the API must always be in a valid state:

    ASSERT(this->IsValid() && image->IsValid());

    GpPageUnit  srcUnit;
    GpRectF     srcRect;

    status = image->GetBounds(&srcRect, &srcUnit);
    if(status != Ok) { return status; }

    // UnitDisplay is device-dependent and cannot be used for a source unit
    ASSERT(srcUnit != UnitDisplay);

    if (status == Ok)
    {
        return DrawImage(image, destRect, srcRect, srcUnit);
    }
    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   API to draw image.
*
*   [IN] image    - the image to draw.
*   [IN] destPoints - the destination quad.
*   [IN] count - the number of count in destPoints[] (3 or 4).
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   04/14/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::DrawImage(
        GpImage* image,
        const GpPointF* destPoints,
        INT count
        )
{
    GpStatus status;

    // count of 4 is not implemented yet (perspective blt)

    if(count == 4)
    {
        return NotImplemented;
    }

    if(count != 3)
    {
        return InvalidParameter;
    }

    ASSERT(count == 3); // Currently only supports Affine transform.
    ASSERT((image != NULL));

    // Objects returned from the API must always be in a valid state:

    ASSERT(this->IsValid() && image->IsValid());

    GpPageUnit  srcUnit;
    GpRectF     srcRect;

    status = image->GetBounds(&srcRect, &srcUnit);
    if(status != Ok) { return status; }

    // UnitDisplay is device-dependent and cannot be used for a source unit
    ASSERT(srcUnit != UnitDisplay);

    if (status == Ok)
    {
        return DrawImage(image, destPoints, count, srcRect, srcUnit);
    }
    return status;
}


/**************************************************************************\
*
* Function Description:
*
*   API to draw image.
*
*   [IN] image    - the image to draw.
*   [IN] destRect - the destination rectangle.
*   [IN] srcRect  - the portion of the image to copy.
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   01/12/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::DrawImage(
    GpImage*           image,
    const GpRectF&     destRect,
    const GpRectF&     srcRect,
    GpPageUnit         srcUnit,
    const GpImageAttributes* imageAttributes,
    DrawImageAbort     callback,
    VOID*              callbackData
    )
{
    GpStatus status = Ok;

    ASSERT((image != NULL));

    // Objects returned from the API must always be in a valid state:

    ASSERT(this->IsValid() && image->IsValid());

    // UnitDisplay is device-dependent and cannot be used for a source unit
    ASSERT(srcUnit != UnitDisplay);

    GpRectF offsetSrcRect = srcRect ;

    GpPointF destPoints[3];
    destPoints[0].X = destRect.X;
    destPoints[0].Y = destRect.Y;
    destPoints[1].X = destRect.X + destRect.Width;
    destPoints[1].Y = destRect.Y;
    destPoints[2].X = destRect.X;
    destPoints[2].Y = destRect.Y + destRect.Height;

    GpRectF     bounds;
    TransformBounds(
        &(Context->WorldToDevice),
        destPoints[0].X,
        destPoints[0].Y,
        destPoints[1].X,
        destPoints[2].Y,
        &bounds
        );

    GpImageType     imageType = image->GetImageType();

    DriverDrawImageFlags flags = 0;

    GpRecolor *     recolor = NULL;

    if (imageAttributes != NULL)
    {
        if (imageAttributes->cachedBackground)
            flags |= DriverDrawImageCachedBackground;

        if (imageType == ImageTypeBitmap)
        {
            if (imageAttributes->HasRecoloring(ColorAdjustTypeBitmap))
            {
                goto HasRecoloring;
            }
        }
        else if (imageAttributes->HasRecoloring())
        {
HasRecoloring:
            recolor = imageAttributes->recolor;
            recolor->Flush();
        }
    }

    GpImage *           adjustedImage = NULL;
    GpImageAttributes   noRecoloring;

    if (IsRecording())
    {
        if (recolor != NULL)
        {
            // We assume that the image is a bitmap.
            // For Bitmaps, we want to recolor into an image that will have an
            // alpha. CloneColorAdjusted keeps the same pixel format as the
            // original image and therefore might not have an alpha channel.
            // recolor will convert to ARGB. When recording to a metafile this
            // will only create an ARGB image if the original image is not
            // palettized, therefore only for 16bit and higher. The most
            // space we can waste is twice the image.
            if(image->GetImageType() == ImageTypeBitmap)
            {
                GpBitmap * bitmap         = reinterpret_cast<GpBitmap*>(image);
                GpBitmap * adjustedBitmap = NULL;
                if (bitmap != NULL)
                {
                    status = bitmap->Recolor(recolor, &adjustedBitmap, NULL, NULL);
                    if (status == Ok)
                    {
                        adjustedImage = adjustedBitmap;
                    }
                }
            }
            else
            {
                adjustedImage = image->CloneColorAdjusted(recolor);
            }
            if (adjustedImage != NULL)
            {
                image = adjustedImage;

                // have to set the recolor to NULL in the image attributes
                // or else the down-level image will be double recolored.
                GpRecolor *     saveRecolor = noRecoloring.recolor;
                noRecoloring = *imageAttributes;
                noRecoloring.recolor = saveRecolor;
                imageAttributes = &noRecoloring;
                recolor         = noRecoloring.recolor;
            }
        }

        //  Record recolored image.
        status = Metafile->RecordDrawImage(
            &bounds,
            image,
            destRect,
            srcRect,
            srcUnit,
            imageAttributes
        );

        if (status != Ok)
        {
            SetValid(FALSE);      // Prevent any more recording
            goto Done;
        }

        if (!DownLevel)
        {
            goto Done;
        }
        // else we need to record down-level GDI EMF records as well
    }

    // Metafiles do not require PixelOffsetting, in fact it results in bad
    // side effects in some cases when the source metafile dpi is low. But
    // we still need to offset the DestRect to match the rendering with other
    // primitives
    // GillesK: If we are in HalfPixelMode, then offset the source and the
    // destination rects by -0.5 pixels

    if ((image->GetImageType() != ImageTypeMetafile) &&
        (!Context->IsPrinter) &&
        ((Context->PixelOffset == PixelOffsetModeHalf) ||
         (Context->PixelOffset == PixelOffsetModeHighQuality)))
    {
        offsetSrcRect.Offset(-0.5f, -0.5f);
    }

    {
        GpRect   deviceBounds;
        status = BoundsFToRect(&bounds, &deviceBounds);

        if (status == Ok && !IsTotallyClipped(&deviceBounds))
        {
            if (imageType == ImageTypeBitmap)
            {
                INT numPoints = 3;

                if (status == Ok)
                {
                    // Now that we've done a bunch of work in accumulating the bounds,
                    // acquire the device lock before calling the driver:

                    Devlock devlock(Device);
                    ASSERT(srcUnit == UnitPixel); // !!! for now

                    // Set the fpu state.
                    FPUStateSaver fpuState;

                    status = DrvDrawImage(
                        &deviceBounds,
                        (GpBitmap*)(image),
                        numPoints,
                        &destPoints[0],
                        &offsetSrcRect, imageAttributes,
                        callback, callbackData,
                        flags
                        );
                }
            }
            else if (imageType == ImageTypeMetafile)
            {
                // If we are recording to a different metafile, then we have
                // already recorded this metafile as an image, and now we just
                // want to record the down-level parts, so we have to set
                // g->Metafile to NULL so we don't record all the GDI+ records
                // in the metafile again -- only the down-level ones.
                // Make sure to pass in the imageAttributes recolorer since it
                // might have been changed if we already recolored the image
                IMetafileRecord * recorder = this->Metafile;
                this->Metafile = NULL;

                status = (static_cast<const GpMetafile *>(image))->Play(
                            destRect, offsetSrcRect, srcUnit, this, recolor,
                            ColorAdjustTypeDefault, callback, callbackData);

                this->Metafile = recorder;     // restore the recorder (if any)
            }
            else
            {
                ASSERT(0);
                status = NotImplemented;
            }
        }
    }

Done:
    if (adjustedImage != NULL)
    {
        adjustedImage->Dispose();
    }

    return status;
}


/**************************************************************************\
*
* Function Description:
*
*   API to draw image.
*
*   [IN] image    - the image to draw.
*   [IN] destPoints - the destination quad.
*   [IN] count - the number of count in destPoints[] (3 or 4).
*   [IN] srcRect  - the portion of the image to copy.
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   04/14/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::DrawImage(
        GpImage*           image,
        const GpPointF*    destPoints,
        INT                count,
        const GpRectF&     srcRect,
        GpPageUnit         srcUnit,
        const GpImageAttributes* imageAttributes,
        DrawImageAbort     callback,
        VOID*              callbackData
        )
{
    GpStatus status = Ok;

    // count of 4 is not implemented yet (perspective blt)

    if(count == 4)
    {
        return NotImplemented;
    }

    if(count != 3)
    {
        return InvalidParameter;
    }

    ASSERT(count == 3); // Currently only supports Affine transform.
    ASSERT((image != NULL));

    // Objects returned from the API must always be in a valid state:

    ASSERT(this->IsValid() && image->IsValid());

    // UnitDisplay is device-dependent and cannot be used for a source unit
    ASSERT(srcUnit != UnitDisplay);

    GpRectF offsetSrcRect = srcRect ;

    // NOTE: We could do this for all image types, including Bitmaps!!!
    //       It would save code to do this always.
    if (image->GetImageType() != ImageTypeBitmap)
    {
        // Metafiles don't handle the destPoints API directly, so we
        // have to convert to using the destRect API instead.  To do so,
        // we assume a canonical destRect and set up the transform to
        // map from that destRect to the destPoints.

        if (count == 3)
        {
            GpMatrix    matrix;
            GpRectF     destRect(0.0f, 0.0f, 1000.0f, 1000.0f);

            if (matrix.InferAffineMatrix(destPoints, destRect) == Ok)
            {
                INT         gstate;

                if ((gstate = this->Save()) != 0)
                {
                    if ((status = this->MultiplyWorldTransform(
                                                matrix, MatrixOrderPrepend)) == Ok)
                    {
                        status = this->DrawImage(image,
                                                 destRect,
                                                 srcRect,
                                                 srcUnit,
                                                 imageAttributes,
                                                 callback,
                                                 callbackData);
                    }
                    this->Restore(gstate);
                    return status;
                }
            }
            return GenericError;
        }
        return NotImplemented;
    }
    // else it is a Bitmap

    REAL xmin, xmax, ymin, ymax;

    ASSERT(count == 3); // Currently only supports Affine transform.

    // Set to the fourth corner point.

    xmin = xmax = destPoints[1].X + destPoints[2].X - destPoints[0].X;
    ymin = ymax = destPoints[1].Y + destPoints[2].Y - destPoints[0].Y;

    // Compare with the other three corners.

    for(INT i = 0; i < 3; i++)
    {
        xmin = min(xmin, destPoints[i].X);
        xmax = max(xmax, destPoints[i].X);
        ymin = min(ymin, destPoints[i].Y);
        ymax = max(ymax, destPoints[i].Y);
    }

    GpRectF     bounds;
    TransformBounds(&(Context->WorldToDevice), xmin, ymin, xmax, ymax, &bounds);

    INT numPoints = 3;

    GpImageType     imageType = image->GetImageType();

    DriverDrawImageFlags flags = 0;

    GpRecolor *     recolor = NULL;

    if (imageAttributes != NULL)
    {
        if (imageAttributes->cachedBackground)
            flags |= DriverDrawImageCachedBackground;

        if (imageType == ImageTypeBitmap)
        {
            if (imageAttributes->HasRecoloring(ColorAdjustTypeBitmap))
            {
                goto HasRecoloring;
            }
        }
        else if (imageAttributes->HasRecoloring())
        {
HasRecoloring:
            recolor = imageAttributes->recolor;
            recolor->Flush();
        }
    }

    GpImage *           adjustedImage = NULL;
    GpImageAttributes   noRecoloring;

    if (IsRecording())
    {
        if (recolor != NULL)
        {
            // We assume that the image is a bitmap.
            // For Bitmaps, we want to recolor into an image that will have an
            // alpha. CloneColorAdjusted keeps the same pixel format as the
            // original image and therefore might not have an alpha channel.
            // recolor will convert to ARGB. When recording to a metafile this
            // will only create an ARGB image if the original image is not
            // palettized, therefore only for 16bit and higher. The most
            // space we can waste is twice the image.
            if(image->GetImageType() == ImageTypeBitmap)
            {
                GpBitmap * bitmap         = reinterpret_cast<GpBitmap*>(image);
                GpBitmap * adjustedBitmap = NULL;
                if (bitmap != NULL)
                {
                    status = bitmap->Recolor(recolor, &adjustedBitmap, NULL, NULL);
                    if (status == Ok)
                    {
                        adjustedImage = adjustedBitmap;
                    }
                }
            }
            else
            {
                adjustedImage = image->CloneColorAdjusted(recolor);
            }
            if (adjustedImage != NULL)
            {
                image = adjustedImage;

                // have to set the recolor to NULL in the image attributes
                // or else the down-level image will be double recolored.
                GpRecolor *     saveRecolor = noRecoloring.recolor;
                noRecoloring = *imageAttributes;
                noRecoloring.recolor = saveRecolor;
                imageAttributes = &noRecoloring;
            }
        }

        //  Record recolored image.
        status = Metafile->RecordDrawImage(
            &bounds,
            image,
            destPoints,
            count,
            srcRect,
            srcUnit,
            imageAttributes
        );

        if (status != Ok)
        {
            SetValid(FALSE);      // Prevent any more recording
            goto Done;
        }
        if (!DownLevel)
        {
            goto Done;
        }
        // else we need to record down-level GDI EMF records as well
    }

    // GillesK: If we are in HalfPixelMode, then offset the source and the
    // destination rects by -0.5 pixels
    if ((image->GetImageType() != ImageTypeMetafile) &&
        (!Context->IsPrinter) &&
        ((Context->PixelOffset == PixelOffsetModeHalf) ||
         (Context->PixelOffset == PixelOffsetModeHighQuality)))
    {
        offsetSrcRect.Offset(-0.5f, -0.5f);
    }

    {
        GpRect      deviceBounds;
        status = BoundsFToRect(&bounds, &deviceBounds);

        if (status == Ok && !IsTotallyClipped(&deviceBounds))
        {
            // Now that we've done a bunch of work in accumulating the bounds,
            // acquire the device lock before calling the driver:

            Devlock devlock(Device);

            ASSERT(srcUnit == UnitPixel); // !!! for now

            // Set the fpu state.
            FPUStateSaver fpuState;

            // We assume that the image is a bitmap.
            ASSERT(image->GetImageType() == ImageTypeBitmap);

            status = DrvDrawImage(
                &deviceBounds,
                static_cast<GpBitmap*>(image),
                numPoints,
                &destPoints[0], &offsetSrcRect,
                imageAttributes,
                callback, callbackData,
                flags
            );
        }
    }

Done:
    if (adjustedImage != NULL)
    {
        adjustedImage->Dispose();
    }

    return status;
}

GpStatus
GpGraphics::EnumerateMetafile(
    const GpMetafile *      metafile,
    const PointF &          destPoint,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    const GpImageAttributes *     imageAttributes
    )
{
    GpStatus    status;

    ASSERT(metafile != NULL);
    ASSERT(callback != NULL);

    // Objects from the API must always be in a valid state:

    ASSERT(this->IsValid() && metafile->IsValid());

    GpPageUnit  srcUnit;
    GpRectF     srcRect;

    status = metafile->GetBounds(&srcRect, &srcUnit);
    if(status != Ok) { return status; }

    // UnitDisplay is device-dependent and cannot be used for a source unit
    ASSERT(srcUnit != UnitDisplay);

    if (status == Ok)
    {
        return this->EnumerateMetafile(
                    metafile,
                    destPoint,
                    srcRect,
                    srcUnit,
                    callback,
                    callbackData,
                    imageAttributes
                    );
    }
    return status;
}

GpStatus
GpGraphics::EnumerateMetafile(
    const GpMetafile *      metafile,
    const RectF &           destRect,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    const GpImageAttributes *     imageAttributes
    )
{
    GpStatus    status;

    ASSERT(metafile != NULL);
    ASSERT(callback != NULL);

    // Objects from the API must always be in a valid state:

    ASSERT(this->IsValid() && metafile->IsValid());

    GpPageUnit  srcUnit;
    GpRectF     srcRect;

    status = metafile->GetBounds(&srcRect, &srcUnit);
    if(status != Ok) { return status; }

    // UnitDisplay is device-dependent and cannot be used for a source unit
    ASSERT(srcUnit != UnitDisplay);

    if (status == Ok)
    {
        return this->EnumerateMetafile(
                    metafile,
                    destRect,
                    srcRect,
                    srcUnit,
                    callback,
                    callbackData,
                    imageAttributes
                    );
    }
    return status;
}

GpStatus
GpGraphics::EnumerateMetafile(
    const GpMetafile *      metafile,
    const PointF *          destPoints,
    INT                     count,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    const GpImageAttributes *     imageAttributes
    )
{
    GpStatus    status;

    ASSERT(metafile != NULL);
    ASSERT(callback != NULL);

    // Objects from the API must always be in a valid state:

    ASSERT(this->IsValid() && metafile->IsValid());

    GpPageUnit  srcUnit;
    GpRectF     srcRect;

    status = metafile->GetBounds(&srcRect, &srcUnit);
    if(status != Ok) { return status; }

    // UnitDisplay is device-dependent and cannot be used for a source unit
    ASSERT(srcUnit != UnitDisplay);

    if (status == Ok)
    {
        return this->EnumerateMetafile(
                    metafile,
                    destPoints,
                    count,
                    srcRect,
                    srcUnit,
                    callback,
                    callbackData,
                    imageAttributes
                    );
    }
    return status;
}

GpStatus
GpGraphics::EnumerateMetafile(
    const GpMetafile *      metafile,
    const PointF &          destPoint,
    const RectF &           srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    const GpImageAttributes *     imageAttributes
    )
{
    ASSERT(metafile != NULL);
    ASSERT(callback != NULL);

    // Objects from the API must always be in a valid state:

    ASSERT(this->IsValid() && metafile->IsValid());

    // UnitDisplay is device-dependent and cannot be used for a source unit
    ASSERT(srcUnit != UnitDisplay);

    REAL        srcDpiX, srcDpiY;
    REAL        destWidth;
    REAL        destHeight;

    // Get the dest size in page units
    GetImageDestPageSize(metafile, srcRect.Width, srcRect.Height,
                         srcUnit, destWidth, destHeight);

    GpRectF destRect(destPoint.X, destPoint.Y, destWidth, destHeight);

    return this->EnumerateMetafile(
                metafile,
                destRect,
                srcRect,
                srcUnit,
                callback,
                callbackData,
                imageAttributes
                );
}

// All the EnumerateMetafile methods end up calling this one
GpStatus
GpGraphics::EnumerateMetafile(
    const GpMetafile *      metafile,
    const RectF &           destRect,
    const RectF &           srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    const GpImageAttributes *     imageAttributes
    )
{
    ASSERT(metafile != NULL);
    ASSERT(callback != NULL);

    // Objects from the API must always be in a valid state:

    ASSERT(this->IsValid() && metafile->IsValid());

    // UnitDisplay is device-dependent and cannot be used for a source unit
    ASSERT(srcUnit != UnitDisplay);

    GpStatus    status;

    GpRecolor *     recolor = NULL;

    if ((imageAttributes != NULL) && imageAttributes->HasRecoloring())
    {
        recolor = imageAttributes->recolor;
        recolor->Flush();
    }

    // NOTE: I don't check the bounds, because even if the entire
    // metafile is out of the clip bounds, I still want to enumerate it.

    status = metafile->EnumerateForPlayback(
                            destRect,
                            srcRect,
                            srcUnit,
                            this,
                            callback,
                            callbackData,
                            recolor
                            );
    return status;
}

GpStatus
GpGraphics::EnumerateMetafile(
    const GpMetafile *      metafile,
    const PointF *          destPoints,
    INT                     count,
    const RectF &           srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    const GpImageAttributes *     imageAttributes
    )
{
    ASSERT(metafile != NULL);
    ASSERT(callback != NULL);

    // Objects from the API must always be in a valid state:

    ASSERT(this->IsValid() && metafile->IsValid());

    // UnitDisplay is device-dependent and cannot be used for a source unit
    ASSERT(srcUnit != UnitDisplay);

    GpStatus    status = Ok;

    // Metafiles don't handle the destPoints API directly, so we
    // have to convert to using the destRect API instead.  To do so,
    // we assume a canonical destRect and set up the transform to
    // map from that destRect to the destPoints.

    ASSERT(count == 3); // Currently only supports Affine transform.

    if (count == 3)
    {
        GpMatrix    matrix;
        GpRectF     destRect(0.0f, 0.0f, 100.0f, 100.0f);

        if (matrix.InferAffineMatrix(destPoints, destRect) == Ok)
        {
            INT         gstate;

            if ((gstate = this->Save()) != 0)
            {
                if ((status = this->MultiplyWorldTransform(
                                            matrix, MatrixOrderPrepend)) == Ok)
                {
                    status = this->EnumerateMetafile(
                                metafile,
                                destRect,
                                srcRect,
                                srcUnit,
                                callback,
                                callbackData,
                                imageAttributes
                                );
                }
                this->Restore(gstate);
                return status;
            }
        }
        return GenericError;
    }
    return NotImplemented;
}

/**************************************************************************\
*
* Function Description:
*
*   API to get color ARGB value at pixel x,y.  This is private GDI+ API.
*
*   [IN] x - horizontal position
*   [IN] y - vertical position
*   [IN] argb - argb color value
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   05/13/1999 ericvan
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::GetPixelColor(
        REAL            x,
        REAL            y,
        ARGB*           argb
        ) const
{
    GpPointF pt(x,y);

    if (!IsVisible(pt))
        return InvalidParameter;

    Devlock devlock(Device);

    DpScanBuffer scan(Surface->Scan,
                      Driver,
                      Context,
                      Surface,
                      CompositingModeSourceCopy);

    Context->WorldToDevice.Transform(&pt, 1);

    ARGB* buffer = scan.NextBuffer((INT)x, (INT)y, 1);

    if (buffer)
       *argb = *buffer;
    else
       return InvalidParameter;

    return Ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\initialize.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998-1999  Microsoft Corporation
*
* Abstract:
*
*  Initialization routines for GDI+.
*
* Revision History:
*
*   7/19/99 ericvan
*       Created it.
*
\**************************************************************************/

BOOL InitImagingLibrary(BOOL suppressExternalCodecs);
VOID CleanupImagingLibrary();

BOOL BackgroundThreadStartup();
VOID BackgroundThreadShutdown();

ULONG_PTR GenerateInitToken();

GpStatus InternalGdiplusStartup(
    const GdiplusStartupInput *input);
VOID InternalGdiplusShutdown();
    
GpStatus WINAPI NotificationStartup(OUT ULONG_PTR *token);
VOID WINAPI NotificationShutdown(ULONG_PTR token);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\graphicstext.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   GraphicsText.cpp
*
* Abstract:
*
*   Text layout and display, Text measurement, Unicode to glyph mapping
*
* Notes:
*
*   Provides support to allow apps to work with Unicode in logical order,
*   hides the mapping from Unicode to glyphs.
*
* Created:
*
*   06/01/99 dbrown
*
\**************************************************************************/


#include "precomp.hpp"

const DOUBLE PI = 3.1415926535897932384626433832795;


/////   Coordinate systems
//
//      The following coordinate systems are used:
//
//      World coordinates (REAL) - the coordinate system used by client
//      applications and passed to most Graphics APIs (for example
//      DrawLine). Text is always purely vertical or purely horizontal in
//      world coordinates. Fonts constructed with emSize specified in
//      alternate units are first converted to world units by calling
//      GetScaleForAlternatePageUnit.
//
//      Device coordinates (REAL) - Coordinates used on the device surface.
//      World coordinates are transformed to device coordinates using the
//      Graphics.Context.WorldToDevice.Transform function. REAL device
//      coordinates may have non-integral values when addressing sub-pixels.
//
//      Font nominal coordinates (INT) - (aka deign units) coordinates used to
//      define a scalable font independant of scaled size.
//      GpFontFace.GetDesignEmHeight is the emSize of a font in nominal units.
//      Nominal coordinates are always a pure scale factor of world units with
//      no shear. For horizontal text there there is no rotation between
//      nominal and world coordinates. For vertical text, most non Far East
//      script characters are rotated by 90 degrees.
//
//      Ideal coordinates (INT) - world coordinates mapped to integers by
//      a pure scale factor for use in Line Services, OpenType services and
//      Uniscribe shaping engine interfaces. The scale factor is usually
//      2048 divided by the emSize of the default font in a text imager.


/////   Transforms
//
//      WorldToDevice - stored in a Graphics. May include scaling,
//      shearing and/or translation.
//
//      WorldToIdeal - stored in a text imager while the imager is attached
//      to a Graphics. A pure scale factor, usually 2048 divided by the emSize
//      of the imager default font.
//
//      FontTransform - stored in a FaceRealization. Maps font nominal units
//      to device coordinates, May include scaling, shearing and rotation, but
//      not translation.


/////   Common buffer parameters
//
//      glyphAdvance - per-glyph advance widths stored in ideal units measured
//      along the text baseline.
//
//      glyphOffset - combining character offsets stored in ideal units
//      measured along and perpendicular to the baseline. The glyphOffset
//      buffer is required by Line Services, OpenType services and the
//      complex script shaping engines, but may somethimes be bypassed for
//      simple scripts.
//
//      glyphOrigins - per glyph device coordinates of the glyph origin (the
//      initial point on the baseline of the glyhps advance vector).
//      Represented as PointF. Non integer values represent sub pixel
//      positions.


/////   Glyph positioning functions
//
//
//      DrawPlacedGlyphs - Builds glyphPos array and passes it to the device driver.
//          ALL text device output output eventually comes through here.
//
//      GetDeviceGlyphOriginsNominal
//          Used when there's no hinting to be accounted for.
//          Places glyph on device using nominal metrics passed in glyphAdvances
//          and glyphOffsets.
//
//      GetDeviceGlyphOriginsAdjusted
//          Used to adjust for the difference between nominal and hinted metrics
//          Generates glyph origins in device units, and adjusts the width of spaces
//          to achieve the totalRequiredIdealAdvance parameter.
//          !!! Need to add support for kashida and inter-glyph justification.
//
//      GetRealizedGlyphPlacement
//          Used to obtain hinted advance metrics along the baseline.
//          !!! Needs to be updated to call complex script shaping engines.
//
//      GetFontTransformForAlternateResolution
//          Used during XMF playback.
//          Generates a font transform to match a font that was recorded at
//          a different resolution.
//
//      MeasureGlyphsAtAlternateResolution
//          Used during XMF playback.
//          Measures glyphs passed to DrawDriverString as if they were to be rendered
//          at the original XMF recording resolution.

/**************************************************************************\
*
* GpGraphics::DrawString
*
*   Draw plain, marked up  or formatted text in a rectangle
*
* Arguments:
*
*
* Return Value:
*
*   GDIPlus status
*
* Created:
*
*   06/25/99 dbrown
*
\**************************************************************************/

GpStatus
GpGraphics::DrawString(
    const WCHAR          *string,
    INT                   length,
    const GpFont         *font,
    const RectF          *layoutRect,
    const GpStringFormat *format,
    const GpBrush        *brush
)
{
    ASSERT(string && font && brush);

    GpStatus status = CheckTextMode();
    if (status != Ok)
    {
        if (IsRecording())
            SetValid(FALSE);      // Prevent any more recording
        return status;
    }

    // Check that the clipping rectangle, if any, is visible, at least in part.

    if (    !IsRecording()       // Metafile clipping happens at playback
        &&  layoutRect->Width
        &&  layoutRect->Height
        &&  (    !format
             ||  !(format->GetFormatFlags() & StringFormatFlagsNoClip)))
    {
        if (    layoutRect->Width < 0
            ||  layoutRect->Height < 0)
        {
            // Client has requested clipping to an empty rectangle, nothing
            // will display.
            return Ok;
        }

        // If client clipping rectangle is outside the visible clipping region -- were done.

        GpRectF     deviceClipRectFloat;
        GpRect      deviceClipRectPixel;
        GpMatrix    worldToDevice;

        TransformBounds(
            &Context->WorldToDevice,
            layoutRect->X,
            layoutRect->Y,
            layoutRect->X + layoutRect->Width,
            layoutRect->Y + layoutRect->Height,
            &deviceClipRectFloat
        );

        status = BoundsFToRect(&deviceClipRectFloat, &deviceClipRectPixel);
        if(status != Ok)
        {
            return status;
        }

        if (IsTotallyClipped(&deviceClipRectPixel))
        {
            // Since nothing will be visible, we need do no more.
            return Ok;
        }
    }



    REAL emSize = font->GetEmSize() * GetScaleForAlternatePageUnit(font->GetUnit());

    if (IsRecording())
    {
        // Record Gdiplus metafile record

        // first measure the text bounding rectangle

        RectF   boundingBox;

        status = MeasureString(
             string,
             length,
             font,
             layoutRect,
             format,
            &boundingBox,
             NULL,
             NULL);

        if (status != Ok)
        {
            SetValid(FALSE);      // Prevent any more recording
            return status;
        }


        GpRectF bounds;
        TransformBounds(&(Context->WorldToDevice), boundingBox.X, boundingBox.Y,
                         boundingBox.GetRight(), boundingBox.GetBottom(), &bounds);

        status = Metafile->RecordDrawString(
            &bounds,
            string,
            length,
            font,
            layoutRect,
            format,
            brush
        );

        if (status != Ok)
        {
            SetValid(FALSE);      // Prevent any more recording
            return status;
        }

        if (!DownLevel)
        {
            return Ok;
        }
        // else we need to record down-level GDI EMF records as well

        // Since we have recorded all the parameters to DrawString,
        // we don't need to do anything more.  For the downlevel case,
        // we need to record the DrawString call as a sequence of
        // ExtTextOut calls.
    }
    else
    {
        // Not recording a metafile, so it is safe to try using the fast text imager.

        FastTextImager fastImager;
        status = fastImager.Initialize(
            this,
            string,
            length,
            *layoutRect,
            font->GetFamily(),
            font->GetStyle(),
            emSize,
            format,
            brush
        );

        if (status == Ok)
        {
            status = fastImager.DrawString();
        }

        // If the fast text imager couldn't handle this case, it returns
        // NotImplemented, and we continue into the full text imager.
        // Otherwise it either completed successfully or hit an error
        // that we need to report.

        if (status != NotImplemented)
        {
            return status;
        }
    }

    // Draw text with the full text imager

    GpTextImager *imager;
    status = newTextImager( // Always creates a fulltextimager.
        string,
        length,
        layoutRect->Width,
        layoutRect->Height,
        font->GetFamily(),
        font->GetStyle(),
        emSize,
        format,
        brush,
        &imager,
        TRUE        // Fast way to set NoChange flag to allow simple imager
    );

    IF_NOT_OK_WARN_AND_RETURN(status);

    imager->GetMetaFileRecordingFlag() = IsRecording();

    EmfPlusDisabler disableEmfPlus(&Metafile);

    status = imager->Draw(this, &PointF(layoutRect->X, layoutRect->Y));

    delete imager;

    return status;
}





/**************************************************************************\
*
* GpGraphics::MeasureString
*
*   Measure plain, marked up  or formatted text in a rectangle
*
* Arguments:
*
*
* Return Value:
*
*   GDIPlus status
*
* Created:
*
*   10/26/99 dbrown
*
\**************************************************************************/


GpStatus
GpGraphics::MeasureString(
    const WCHAR          *string,
    INT                   length,
    const GpFont         *font,
    const RectF          *layoutRect,
    const GpStringFormat *format,
    RectF                *boundingBox,
    INT                  *codepointsFitted,
    INT                  *linesFilled
)
{
    CalculateTextRenderingHintInternal();
    ASSERT(string && font && boundingBox);
    if (!string || !font || !boundingBox)
    {
        return InvalidParameter;
    }

    GpStatus status;

    REAL emSize = font->GetEmSize() * GetScaleForAlternatePageUnit(font->GetUnit());

    if (!IsRecording())
    {
        // Try using the fast imager

        FastTextImager fastImager;
        status = fastImager.Initialize(
            this,
            string,
            length,
            *layoutRect,
            font->GetFamily(),
            font->GetStyle(),
            emSize,
            format,
            NULL
        );

        if (status == Ok)
        {
            status = fastImager.MeasureString(
                boundingBox,
                codepointsFitted,
                linesFilled
            );
        }

        // If the fast text imager couldn't handle this case, it returns
        // NotImplemented, and we continue into the full text imager.
        // Otherwise it either completed successfully or hit an error
        // that we need to report.

        if (status != NotImplemented)
        {
            return status;
        }
    }


    // Measure text with the full text imager

    GpTextImager *imager;
    status = newTextImager(
        string,
        length,
        layoutRect->Width,
        layoutRect->Height,
        font->GetFamily(),
        font->GetStyle(),
        emSize,
        format,
        NULL,
        &imager,
        TRUE        // Enable use of simple formatter when no format passed
    );
    IF_NOT_OK_WARN_AND_RETURN(status);

    *boundingBox = *layoutRect;

    REAL nearGlyphEdge;
    REAL farGlyphEdge;
    REAL textDepth;

    status = imager->Measure(   // Returned edges exclude overhang
        this,
        &nearGlyphEdge,
        &farGlyphEdge,
        &textDepth,
        codepointsFitted,
        linesFilled
    );


    // Generate bounding box (excluding overhang) from near and far glyph edges

    if (status == Ok)
    {
        // Fix up near/far glyph edges for empty box

        if (nearGlyphEdge > farGlyphEdge)
        {
            nearGlyphEdge = 0;
            farGlyphEdge = 0;
        }

        if (   format
            && format->GetFormatFlags() & StringFormatFlagsDirectionVertical)
        {
            boundingBox->Y      = layoutRect->Y + nearGlyphEdge;
            boundingBox->Height = farGlyphEdge - nearGlyphEdge;

            if (format)
            {
                StringAlignment lineAlign = format->GetLineAlign();
                REAL leadingOffset = 0.0;   // positive offset to the leading side edge of the textbox

                if (lineAlign == StringAlignmentCenter)
                {
                    leadingOffset = (boundingBox->Width - textDepth)/2;
                }
                else if (lineAlign == StringAlignmentFar)
                {
                    leadingOffset = boundingBox->Width - textDepth;
                }

                if (format->GetFormatFlags() & StringFormatFlagsDirectionRightToLeft)
                {
                    boundingBox->X += (boundingBox->Width - textDepth - leadingOffset);
                }
                else
                {
                    boundingBox->X += leadingOffset;
                }
            }
            boundingBox->Width  = textDepth;
        }
        else
        {
            boundingBox->X      = layoutRect->X + nearGlyphEdge;
            boundingBox->Width  = farGlyphEdge - nearGlyphEdge;

            if (format)
            {
                StringAlignment lineAlign = format->GetLineAlign();

                if (lineAlign == StringAlignmentCenter)
                {
                    boundingBox->Y += (boundingBox->Height - textDepth) / 2;
                }
                else if (lineAlign == StringAlignmentFar)
                {
                    boundingBox->Y += boundingBox->Height - textDepth;
                }
            }
            boundingBox->Height = textDepth;
        }

        if (!format
            || !(format->GetFormatFlags() & StringFormatFlagsNoClip))
        {
            //  Make sure display bounding box never exceeds layout rectangle
            //  in case of clipping.

            if (   layoutRect->Width > 0.0
                && boundingBox->Width > layoutRect->Width)
            {
                boundingBox->Width = layoutRect->Width;
                boundingBox->X     = layoutRect->X;
            }

            if (   layoutRect->Height > 0.0
                && boundingBox->Height > layoutRect->Height)
            {
                boundingBox->Height = layoutRect->Height;
                boundingBox->Y      = layoutRect->Y;
            }
        }
    }

    delete imager;

    return status;
}



/**************************************************************************\
*
* GpGraphics::MeasureCharacterRanges
*
*   Produce a bounding regions of all given character ranges in stringformat
*
* Arguments:
*
*
* Return Value:
*
*   GDIPlus status
*
* Created:
*
*   10-9-2000 wchao
*
\**************************************************************************/
GpStatus
GpGraphics::MeasureCharacterRanges(
    const WCHAR          *string,
    INT                   length,
    const GpFont         *font,
    const RectF          &layoutRect,
    const GpStringFormat *format,
    INT                   regionCount,
    GpRegion            **regions
)
{
    CalculateTextRenderingHintInternal();
    ASSERT(format && string && font && regions);


    INT rangeCount = format->GetMeasurableCharacterRanges();

    if (regionCount < rangeCount)
    {
        return InvalidParameter;
    }

    INT stringLength;
    if (length == -1)
    {
        stringLength = 0;
        while (string[stringLength])
        {
            stringLength++;
        }
    }
    else
    {
        stringLength = length;
    }

    GpStatus status;

    REAL emSize = font->GetEmSize() * GetScaleForAlternatePageUnit(font->GetUnit());

    GpTextImager *imager;
    status = newTextImager(
        string,
        stringLength,
        layoutRect.Width,
        layoutRect.Height,
        font->GetFamily(),
        font->GetStyle(),
        emSize,
        format,
        NULL,
        &imager,
        TRUE        // Enable use of simple formatter when no format passed
    );
    IF_NOT_OK_WARN_AND_RETURN(status);

    imager->GetMetaFileRecordingFlag() = IsRecording();

    PointF imagerOrigin(layoutRect.X , layoutRect.Y);

    status = imager->MeasureRanges(
        this,
        &imagerOrigin,
        regions
    );

    delete imager;

    return status;
}




/////   DrawPlacedGlyphs - Draw glyphs with arbitrary transform at device coordinates
//
//


GpStatus
GpGraphics::DrawPlacedGlyphs(
    const GpFaceRealization *faceRealization,
    const GpBrush           *brush,
    INT                      flags,         // For DG_NOGDI
    const WCHAR             *string,
    UINT                     stringLength,
    BOOL                     rightToLeft,
    const UINT16            *glyphs,
    const UINT16            *glyphMap,
    const PointF            *glyphOrigins,
    INT                      glyphCount,
    ItemScript               Script,
    BOOL                     sideways        // e.g. FE characters in vertical text
)
{
    IF_NOT_OK_WARN_AND_RETURN(faceRealization->GetStatus());

    INT     i;
    BOOL    bNeedPath = FALSE;
    GpFaceRealization cloneFaceRealization;
    GpGlyphPos *glyphPositions = NULL;
    GpGlyphPos *glyphPathPositions = NULL;

    // Display glyphs for Bits. Handle as many as possible in one go.

    INT glyphStart = 0;     // start of this display run
    INT glyphsProcessed;    // Number of glyphs processed by this GetGlyphPos call
    INT glyphPositionCount; // Number of glyphPositions generated by this GetGlyphPos call

    // Display glyphs for path. Handle as many as possible in one go.

    INT glyphPathStart = 0;     // start of this display run
    INT glyphsPathProcessed, glyphsPathProcessedTemp;    // Number of glyphs processed by this GetGlyphPos call
    INT glyphPathPositionCount, glyphPathPositionCountTemp; // Number of glyphPositions generated by this GetGlyphPos call


    GpStatus status = Ok;

    if (!glyphOrigins)
    {
        ASSERT(glyphOrigins);
        return GenericError;
    }


    // For sideways text, we have been passed glyph origins at the
    // top baseline, but we need to pass leftside baseline origins
    // to DrvDrawGlyphs for the benefit of metafiles and GDI positioning.

    AutoBuffer<PointF, 16> adjustedGlyphOrigins;
    const PointF *leftsideGlyphOrigins = glyphOrigins;

    if (sideways && Driver != Globals::MetaDriver)
    {
        adjustedGlyphOrigins.SetSize(glyphCount);
        if (!adjustedGlyphOrigins)
        {
            status = OutOfMemory;
            goto error;
        }

        status = faceRealization->GetGlyphStringVerticalOriginOffsets(
            glyphs,
            glyphCount,
            adjustedGlyphOrigins.Get()
        );
        if (status != Ok)
        {
            goto error;
        }

        for (INT i=0; i<glyphCount; i++)
        {
            adjustedGlyphOrigins[i].X = glyphOrigins[i].X - adjustedGlyphOrigins[i].X;
            adjustedGlyphOrigins[i].Y = glyphOrigins[i].Y - adjustedGlyphOrigins[i].Y;
        }

        leftsideGlyphOrigins = adjustedGlyphOrigins.Get();
    }



    glyphPositions = new GpGlyphPos[glyphCount];

    if (!glyphPositions)
    {
        status = OutOfMemory;
        goto error;
    }

    ASSERT(!faceRealization->IsPathFont() || Driver == Globals::MetaDriver);

    if (Driver == Globals::MetaDriver)
    {
        INT     minX = MAXLONG;
        INT     minY = MAXLONG;
        INT     maxX = MINLONG;
        INT     maxY = MINLONG;
        INT     glyphPositionCountTemp = 0;

        while (glyphStart < glyphCount)
        {
            glyphPositionCount = faceRealization->GetGlyphPos(
                glyphCount     - glyphStart,
                glyphs         + glyphStart,
                glyphPositions + glyphStart,
                glyphOrigins   + glyphStart,
                &glyphsProcessed,
                sideways
            );

            if (glyphPositionCount == 0 && ((glyphsProcessed +  glyphStart) < glyphCount))
            {
                status = OutOfMemory;
                goto error;
            }

            for (i = 0; i < glyphPositionCount; i++)
            {
                INT j = glyphPositionCountTemp + i;

                if (glyphPositions[j].GetWidth()  != 0 &&
                    glyphPositions[j].GetHeight() != 0)
                {
                    minX = min(minX, glyphPositions[j].GetLeft());
                    minY = min(minY, glyphPositions[j].GetTop());
                    maxX = max(maxX, glyphPositions[j].GetLeft() + glyphPositions[j].GetWidth());
                    maxY = max(maxY, glyphPositions[j].GetTop()  + glyphPositions[j].GetHeight());
                }

                if (glyphPositions[j].GetTempBits() != NULL)
                {
                    GpFree(glyphPositions[j].GetTempBits());
                    glyphPositions[j].SetTempBits(0);
                }
            }

            glyphStart += glyphsProcessed;
            glyphPositionCountTemp += glyphPositionCount;
        }

        glyphPositionCount = glyphPositionCountTemp;


        if (minX < maxX && minY < maxY)
        {
            // must grab the devlock before going into the driver.

            Devlock devlock(Device);

            GpRect drawBounds(minX, minY, maxX-minX, maxY-minY);

            REAL edgeGlyphAdvance;

            if (rightToLeft)
            {
                status = faceRealization->GetGlyphStringDeviceAdvanceVector(glyphs,
                                                                   1,
                                                                   FALSE,
                                                                   &edgeGlyphAdvance);
            }
            else
            {
                status = faceRealization->GetGlyphStringDeviceAdvanceVector(&glyphs[glyphCount-1],
                                                                    1,
                                                                    FALSE,
                                                                    &edgeGlyphAdvance);
            }
            if (status != Ok)
                goto error;


            if (sideways)
            {
                flags |= DG_SIDEWAY;
            }

            status = DrvDrawGlyphs(
                &drawBounds,
                glyphPositions,
                NULL,
                glyphPositionCount,
                brush->GetDeviceBrush(),
                faceRealization,
                glyphs,
                glyphMap,
                leftsideGlyphOrigins,
                glyphCount,
                string,
                stringLength,
                Script,
                GpRound(edgeGlyphAdvance),
                rightToLeft,
                flags
            );
            if (status != Ok)
                goto error;
        }
    }
    else
    {
        if (IsPrinter())
        {
            DriverPrint *pdriver = (DriverPrint*) Driver;

            if (pdriver->DriverType == DriverPostscript)
            {
                if (brush->GetBrushType() != BrushTypeSolidColor)
                {
                // generate bitmap & path in glyphPos
                    bNeedPath = TRUE;
                }
             }
        }

        if (bNeedPath)
        {
            cloneFaceRealization.CloneFaceRealization(faceRealization, TRUE);

            if (!cloneFaceRealization.IsValid())
            {
                status = OutOfMemory;
                goto error;
            }

            ASSERT(cloneFaceRealization.IsPathFont());
        }


        if (bNeedPath)
        {
            glyphPathPositions = new GpGlyphPos[glyphCount];

            if (!glyphPathPositions)
            {
                status = OutOfMemory;
                goto error;
            }
        }


        while (glyphStart < glyphCount)
        {
            glyphPositionCount = faceRealization->GetGlyphPos(
                glyphCount   - glyphStart,
                glyphs       + glyphStart,
                glyphPositions,
                glyphOrigins + glyphStart,
                &glyphsProcessed,
                sideways
            );

            // glyphPositionCount = number of entries added to glyphPositions array
            // glyphsPositioned   = number of glyph indices processed from glyph buffer


            if (glyphPositionCount == 0 && ((glyphsProcessed +  glyphStart) < glyphCount))
            {
                status = OutOfMemory;
                goto error;
            }

            glyphsPathProcessed = 0;
            glyphPathPositionCount = 0;

            while (glyphsPathProcessed < glyphsProcessed)
            {
                INT     minX = MAXLONG;
                INT     minY = MAXLONG;
                INT     maxX = MINLONG;
                INT     maxY = MINLONG;

                if (bNeedPath)
                {
                    glyphPathPositionCountTemp = cloneFaceRealization.GetGlyphPos(
                        glyphsProcessed - glyphsPathProcessed,
                        glyphs + glyphPathStart + glyphsPathProcessed,
                        glyphPathPositions,
                        glyphOrigins + glyphPathStart + glyphsPathProcessed,
                        &glyphsPathProcessedTemp,
                        sideways
                    );

                    glyphsPathProcessed += glyphsPathProcessedTemp;

                    if (glyphPathPositionCountTemp == 0 && (glyphsPathProcessed < glyphsProcessed))
                    {
                        ASSERT(glyphPathPositionCount != glyphPositionCount);

                        status = OutOfMemory;
                        goto error;
                    }
                }
                else
                {
                    glyphsPathProcessed = glyphsProcessed;
                    glyphPathPositionCountTemp = glyphPositionCount;
                }

                for (i = 0; i < glyphPathPositionCountTemp; i++)
                {
                    INT j = glyphPathPositionCount + i;

                    if (glyphPositions[j].GetWidth()  != 0 &&
                        glyphPositions[j].GetHeight() != 0)
                    {
                        minX = min(minX, glyphPositions[j].GetLeft());
                        minY = min(minY, glyphPositions[j].GetTop());
                        maxX = max(maxX, glyphPositions[j].GetLeft() + glyphPositions[j].GetWidth());
                        maxY = max(maxY, glyphPositions[j].GetTop()  + glyphPositions[j].GetHeight());
                    }
                }

                if (minX < maxX && minY < maxY)
                {
                    // must grab the devlock before going into the driver.

                    Devlock devlock(Device);

                    GpRect drawBounds(minX, minY, maxX-minX, maxY-minY);

                    REAL edgeGlyphAdvance;

                    if (rightToLeft)
                    {
                        status = faceRealization->GetGlyphStringDeviceAdvanceVector(glyphs,
                                                                            1,
                                                                            FALSE,
                                                                            &edgeGlyphAdvance);
                    }
                    else
                    {
                        status = faceRealization->GetGlyphStringDeviceAdvanceVector(&glyphs[glyphCount-1],
                                                                            1,
                                                                            FALSE,
                                                                            &edgeGlyphAdvance);
                    }
                    if (status != Ok)
                        goto error;

                    status = DrvDrawGlyphs(
                        &drawBounds,
                        &glyphPositions[glyphPathPositionCount],
                        glyphPathPositions,
                        glyphPathPositionCountTemp,
                        brush->GetDeviceBrush(),
                        faceRealization,
                        glyphs + glyphPathStart,
                        glyphMap + glyphPathStart,
                        leftsideGlyphOrigins + glyphPathStart,
                        glyphsProcessed,
                        string,
                        stringLength,
                        Script,
                        GpRound(edgeGlyphAdvance),
                        rightToLeft,
                        flags
                    );
                    if (status != Ok)
                        goto error;
                }

                glyphPathPositionCount += glyphPathPositionCountTemp;
            }

            ASSERT (glyphsPathProcessed == glyphsProcessed);
            ASSERT (glyphPathPositionCount == glyphPositionCount);

            // Free any temporary bitmap buffers created by subpixelling

            for (i=0; i<glyphPositionCount; i++)
            {
                if (glyphPositions[i].GetTempBits() != NULL)
                {
                    GpFree(glyphPositions[i].GetTempBits());
                    glyphPositions[i].SetTempBits(0);
                }
            }

            glyphStart += glyphsProcessed;
            glyphPathStart += glyphsPathProcessed;
        }
    }
error:

    // free memory allocated

    if (glyphPositions)
        delete [] glyphPositions;

    if (glyphPathPositions)
        delete [] glyphPathPositions;

    return status;
}

// GpGraphics::CheckTextMode
// disallow ClearType text for CompositingModeSourceCopy
GpStatus GpGraphics::CheckTextMode()
{
    CalculateTextRenderingHintInternal();

    if (GetCompositingMode() == CompositingModeSourceCopy &&
        GetTextRenderingHintInternal() == TextRenderingHintClearTypeGridFit)
    {
        ONCE(WARNING(("CompositingModeSourceCopy cannot be used with ClearType text")));
        return InvalidParameter;
    }
    return Ok;
} // GpGraphics::CheckTextMode


void GpGraphics::CalculateTextRenderingHintInternal()
{
    // this procedure is meant to be used by internal text routine and will convert TextRenderingHintSystemDefault
    // to the current system mode
    ASSERT(Context);

    TextRenderingHint  textMode = Context->TextRenderHint;

    if (IsPrinter())
    {
        textMode = TextRenderingHintSingleBitPerPixelGridFit;
    }
    else if (textMode == TextRenderingHintSystemDefault)
    {
        if (Globals::CurrentSystemRenderingHintInvalid)
        {
            // Get the current text antialiazing mode from the system
            DWORD       bOldSF, dwOldSFT;
            SystemParametersInfoA( SPI_GETFONTSMOOTHING, 0, (PVOID)&bOldSF, 0 );
            if (bOldSF)
            {
                SystemParametersInfoA( SPI_GETFONTSMOOTHINGTYPE, 0, (PVOID)&dwOldSFT, 0 );

                if( dwOldSFT & FE_FONTSMOOTHINGCLEARTYPE )
                {
                    Globals::CurrentSystemRenderingHint = TextRenderingHintClearTypeGridFit;
                } else
                {
                    Globals::CurrentSystemRenderingHint = TextRenderingHintAntiAliasGridFit;
                }
            } else
            {
                Globals::CurrentSystemRenderingHint = TextRenderingHintSingleBitPerPixelGridFit;
            }
        }
        textMode = Globals::CurrentSystemRenderingHint;
    }

    // Lead and PM decision to disable ClearType on downlevel system, we allow only on Windows NT 5.1 or later
    if ((textMode == TextRenderingHintClearTypeGridFit) &&
          (!Globals::IsNt ||
             (Globals::OsVer.dwMajorVersion < 5) ||
             ((Globals::OsVer.dwMajorVersion == 5) && (Globals::OsVer.dwMinorVersion < 1))
             )
           )
    {
        textMode = TextRenderingHintSingleBitPerPixelGridFit;
    }

    if (textMode == TextRenderingHintClearTypeGridFit ||
        textMode == TextRenderingHintAntiAlias ||
        textMode == TextRenderingHintAntiAliasGridFit)
    {
        if (Surface &&
            GetPixelFormatSize(Surface->PixelFormat) <= 8 &&
            Surface->PixelFormat != PixelFormatMulti)
        {
            // disable AA & ClearType in 256 bit color mode and less
            textMode = TextRenderingHintSingleBitPerPixelGridFit;
        }
        else if (Globals::IsTerminalServer)
        {
            // disable AA & ClearType for Terminal Server desktop surface
            if (Surface && Surface->IsDesktopSurface())
            {
                textMode = TextRenderingHintSingleBitPerPixelGridFit;
            } 
        }
    }
    
    if (textMode == TextRenderingHintClearTypeGridFit)
    {
        if (Globals::CurrentSystemRenderingHintInvalid)
        {
            // get ClearType orientation setting from the system
            UpdateLCDOrientation();
        }
    }

    Globals::CurrentSystemRenderingHintInvalid = FALSE;
    TextRenderingHintInternal = textMode;
} // GpGraphics::CalculateTextRenderingHintInternal




/////   DrawFontStyleLine
//
//      Draw underline or strikethrough or both depending on what style is used
//      in the font. Given points are in world coordinate.
//
//      Make sure the line thickness is at least 1 pixel wide.


GpStatus GpGraphics::DrawFontStyleLine(
    const PointF        *baselineOrigin,    // baseline origin
    REAL                baselineLength,     // baseline length
    const GpFontFace    *face,              // font face
    const GpBrush       *brush,             // brush
    BOOL                vertical,           // vertical text?
    REAL                emSize,             // font EM size in world unit
    INT                 style,              // kind of lines to be drawn
    const GpMatrix      *matrix             // additional transform
)
{
    REAL fontToWorld = emSize / TOREAL(face->GetDesignEmHeight());

    PointF  drawingParams[2];   // X is offset from baseline, Y is device pen width
    INT     count = 0;

    GpStatus status = Ok;

    if (style & FontStyleUnderline)
    {
        //  underlining metric

        const REAL penPos   = face->GetDesignUnderscorePosition() * fontToWorld;
        REAL penWidth = face->GetDesignUnderscoreSize() * fontToWorld;
        penWidth = GetDevicePenWidth(penWidth, matrix);

        drawingParams[count].X   = penPos;
        drawingParams[count++].Y = penWidth;
    }

    if (style & FontStyleStrikeout)
    {
        //  strikethrough metric

        const REAL penPos   = face->GetDesignStrikeoutPosition() * fontToWorld;
        REAL penWidth = face->GetDesignStrikeoutSize() * fontToWorld;
        penWidth = GetDevicePenWidth(penWidth, matrix);

        drawingParams[count].X   = penPos;
        drawingParams[count++].Y = penWidth;
    }


    for (INT i = 0; i < count; i++)
    {
        PointF points[2];
        points[0] = *baselineOrigin;

        if (vertical)
        {
            points[0].X += drawingParams[i].X;  // offset from baseline
            points[1].X = points[0].X;
            points[1].Y = points[0].Y + baselineLength;
        }
        else
        {
            points[0].Y -= drawingParams[i].X;  // offset from baseline
            points[1].Y = points[0].Y;
            points[1].X = points[0].X + baselineLength;
        }

        if (matrix)
        {
            matrix->Transform(points, 2);
        }

        status = DrawLine(
            &GpPen(
                brush,
                drawingParams[i].Y,
                UnitPixel
            ),
            points[0],
            points[1]
        );

        IF_NOT_OK_WARN_AND_RETURN(status);
    }

    return status;
}




//  fix up pen width for strikeout/underline/hotkey cases
//  to avoid varying line width within the same paragraph
//  return value is in pixel units

REAL GpGraphics::GetDevicePenWidth(
    REAL            widthInWorldUnits,
    const GpMatrix  *matrix
)
{
    GpMatrix worldToDevice;
    GetWorldToDeviceTransform(&worldToDevice);

    if (matrix)
    {
        worldToDevice.Prepend(*matrix);
    }

    PointF underlineVector(widthInWorldUnits, 0.0f);
    worldToDevice.VectorTransform(&underlineVector);
    REAL penWidth = (REAL)GpRound(VectorLength(underlineVector));
    if (penWidth < 1.0f)
        penWidth = 1.0f;
    return penWidth;
}


/////   DriverString APIs
//
//      Driver string APIs are in engine\text\DriverStringImager.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\initialize.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998-1999  Microsoft Corporation
*
* Abstract:
*
*   Initialization routines for GDI+.
*
* Revision History:
*
*   12/02/1998 andrewgo
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

#if GP_ICECAP>1
#include "icecap.h"
#endif


// Add this to the Globals namespace.

namespace Globals {
    extern BOOL RuntimeInitialized;
};


/**************************************************************************\
*
* Function Description:
*
*   Generates a token that an init API can return, used to match the
*   startup call with the shutdown call.
*
* Return value:
*
*   A non-zero value. It doesn't really matter what it is - it could be
*   a simple magic number, but we don't want apps relying on it being a
*   particular value.
*
* History:
*
*   09/15/2000 agodfrey
*       Created it.
*
\**************************************************************************/

ULONG_PTR GenerateInitToken()
{
    ULONG_PTR ret = GetTickCount();
    if (ret == 0)
    {
        ret = 1;
    }
    return ret;
}

/**************************************************************************\
*
* Function Description:
*
*   This routine should undo all of the initialization done in
*   'InternalGdiplusStartup'.
*
* Notes:
*
*   Whenever this function, or the functions it calls, frees a pointer or
*   destroys a resource, it should set the corresponding global to NULL.
*   This is because it's legal for clients to call GdiplusStartup later.
*
*   In addition, for resources, like DC's and DLL handles, we don't want to
*   call the "destroy" API if the handle is NULL, since it can waste time -
*   some API's take their time about recognizing the NULL.
*
*   "delete" doesn't have this problem (the compiler generates a
*   NULL check for us.)
*
* Preconditions:
*
*   GdiplusStartupCriticalSection must be held.
*
* History:
*
*   12/02/1998 andrewgo
*       Created it.
*   10/03/2000 agodfrey
*       Changed it to zero out any pointers/handles that it cleans up,
*       so that InternalGdiplusStartup can safely be called later.
*
\**************************************************************************/

VOID
InternalGdiplusShutdown(
    VOID
    )
{
    if (Globals::ThreadNotify != NULL)
    {
        BackgroundThreadShutdown();
    }

    // BackgroundThreadShutdown should NULL this variable itself:
    ASSERT(Globals::ThreadNotify == NULL);

    delete Globals::PathLookAside;        Globals::PathLookAside   = NULL;
    delete Globals::MatrixLookAside;      Globals::MatrixLookAside = NULL;
    delete Globals::PenLookAside;         Globals::PenLookAside    = NULL;

    delete Globals::DesktopDevice;        Globals::DesktopDevice   = NULL;
    delete Globals::DeviceList;           Globals::DeviceList      = NULL;
    delete Globals::EngineDriver;         Globals::EngineDriver    = NULL;
    delete Globals::DesktopDriver;        Globals::DesktopDriver   = NULL;
    delete Globals::GdiDriver;            Globals::GdiDriver       = NULL;
    delete Globals::D3DDriver;            Globals::D3DDriver       = NULL;
    delete Globals::InfoDriver;           Globals::InfoDriver      = NULL;
    delete Globals::MetaDriver;           Globals::MetaDriver      = NULL;
    delete Globals::DesktopSurface;       Globals::DesktopSurface  = NULL;

    if (Globals::DdrawHandle)
    {
        FreeLibrary(Globals::DdrawHandle);
        Globals::DdrawHandle = NULL;
    }
    if (Globals::CachedGdiRegion)
    {
        DeleteObject(Globals::CachedGdiRegion);
        Globals::CachedGdiRegion = NULL;
    }
    if (Globals::DesktopIc)
    {
        DeleteDC(Globals::DesktopIc);
        Globals::DesktopIc = NULL;
    }

    delete Globals::FontCollection;       Globals::FontCollection  = NULL;
    delete Globals::FontLinkTable;        Globals::FontLinkTable   = NULL;

    if (Globals::SurrogateFontsTable!= NULL &&
        Globals::SurrogateFontsTable!= (GpFontFamily **)-1)
    {
        GpFree(Globals::SurrogateFontsTable);
    }
    Globals::SurrogateFontsTable = (GpFontFamily **) -1;

    delete Globals::FontCacheLastRecentlyUsedList;
        Globals::FontCacheLastRecentlyUsedList = NULL;

    delete Globals::NationalDigitCache;   Globals::NationalDigitCache = NULL;

    // destroy the Generic objects
    GpStringFormat::DestroyStaticObjects();

    delete [] Globals::FontsDirW;         Globals::FontsDirW       = NULL;
    delete [] Globals::FontsDirA;         Globals::FontsDirA       = NULL;

    if (Globals::LookAsideBuffer)
    {
        GpFree(Globals::LookAsideBuffer);
        Globals::LookAsideBuffer = NULL;
    }

    if (Globals::TextCriticalSectionInitialized)
    {
        DeleteCriticalSection(&Globals::TextCriticalSection);
        Globals::TextCriticalSectionInitialized = FALSE;
    }

    if (Globals::DcimanHandle)
    {
        FreeLibrary(Globals::DcimanHandle);
        Globals::DcimanHandle = NULL;
    }

    // Uninitialize imaging library

    CleanupImagingLibrary();

    GpTextImager::CleanupTextImager();

    if (Globals::UniscribeDllModule)
    {
        FreeLibrary(Globals::UniscribeDllModule);
        Globals::UniscribeDllModule = NULL;
    }

    if (Globals::RuntimeInitialized)
    {
        GpRuntime::Uninitialize();
        Globals::RuntimeInitialized = FALSE;
    }

    // We leak Globals::Monitors intentionally, so that it can be used
    // around GdiplusShutdown as well. It's okay because:
    //
    // 1) Unless the user has called GdipMonitorControl (to be removed before
    //    we ship), nothing will be leaked.
    // 2) GpMonitors defines its own new and delete, which bypass GpMalloc/
    //    GpFree. So, this won't cause us to hit the memory leak assertion.
    
    // delete Globals::Monitors;             Globals::Monitors = NULL;

    LoadLibraryCriticalSection::DeleteCriticalSection();
    BackgroundThreadCriticalSection::DeleteCriticalSection();

    // Perform memory leak detection.
    // Must be done after all memory cleanup.

    GpAssertShutdownNoMemoryLeaks();

    VERBOSE(("InternalGdiplusShutdown completed"));

    // This must be done last.

    GpMallocTrackingCriticalSection::DeleteCriticalSection();

    if (GpRuntime::GpMemHeap)
    {
        HeapDestroy(GpRuntime::GpMemHeap);
        GpRuntime::GpMemHeap = NULL;
    }
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   GetLanguageID
*
* Routine Description:
*
*   This routines returns the default language ID.  Normally, we would call
*   GetLocaleInfoW to get this information but that API is not available in
*   kernel mode.  Since GetLocaleInfoW gets it from the registry we'll do the
*   same.
*
* Arguments: none
*
* Called by:
*
* Return Value:
*
*   The default language ID.  If the call fails it will just return 0x0409
*   for English.
*
\**************************************************************************/

USHORT GetLanguageID(VOID)
{
    //  Language ID is the low word of lcid
    DWORD lcid = GetSystemDefaultLCID();
    USHORT result = USHORT(lcid & 0x0000ffff);

#if INITIALIZE_DBG
    TERSE(("Language ID = 0x%04x", result));
#endif

    return(result);
}

/**************************************************************************\
*
* Function Description:
*
*   Initialize the version-related data.  This may be called several times,
*   so this must not allocate memory, etc.  This is called both by
*   InternalGdiplusStartup() and by the GpObject class constructor.  Since an
*   object can be global, an object may be created before
*   InternalGdiplusStartup() is called, which is why the GpObject
*   constructor may need to call this.
*
*   Only state that is needed by our initialization routines should be
*   initialized here.
*
*   !!! [agodfrey] I disagree with the above. I don't think it's safe to let
*   apps call us before they call GdiplusStartup. For one thing, we will
*   erroneously assert that memory was leaked - but I think we could AV.
*
*   It does make life a little tricky for app developers if
*   they want global objects that call us in their constructors.
*   We need to publish sample code for how to do this safely
*   (e.g. see test\gpinit.inc)
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* Created:
*
*   7/26/1999 DCurtis
*
\**************************************************************************/

VOID
InitVersionInfo()
{
    if (!Globals::VersionInfoInitialized)
    {
        Globals::OsVer.dwOSVersionInfoSize = sizeof(Globals::OsVer);
        GetVersionExA(&Globals::OsVer);

        Globals::IsNt = (Globals::OsVer.dwPlatformId == VER_PLATFORM_WIN32_NT);
        Globals::IsWin95 = ((Globals::OsVer.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) &&
                            (Globals::OsVer.dwMajorVersion == 4) &&
                            (Globals::OsVer.dwMinorVersion == 0));
        Globals::ACP = GetACP();

        Globals::VersionInfoInitialized = TRUE;
    }
}

VOID SysColorNotify();

/**************************************************************************\
*
* Function Description:
*
*   Initialize globals for the GDI+ engine.
*
*   NOTE: Initialization should not be extremely expensive!
*         Do NOT put a lot of gratuitous junk into here; consider instead
*         doing lazy initialization.
*
* Arguments:
*
*   debugEventFunction - A function the caller can give us that we'll call
*                        to report ASSERTs or WARNINGs. Can be NULL.
*
* Preconditions:
*
*   GdiplusStartupCriticalSection must be held.
*
* Return Value:
*
*   FALSE if failure (such as low memory).
*
* History:
*
*   12/02/1998 andrewgo
*       Created it.
*
\**************************************************************************/

GpStatus
InternalGdiplusStartup(
    const GdiplusStartupInput *input)
{
    // Set up the debug event reporting function, before we use ASSERT or
    // WARNING.

    Globals::UserDebugEventProc = input->DebugEventCallback;

#if GDIPPRIVATEBUILD
#define GDIPCREATEUSERNAMEMESSAGE() "This is a private build from " USERNAME \
"\nBuilt on " __DATE__ " " __TIME__
        ::MessageBoxA(NULL, GDIPCREATEUSERNAMEMESSAGE(), "Private Build", MB_OK);
#undef GDIPCREATEUSERNAMEMESSAGE
#endif
        

    // Create the GDI+ heap...
    ASSERT(!GpRuntime::GpMemHeap);
    GpRuntime::GpMemHeap = HeapCreate(GPMEMHEAPFLAGS, GPMEMHEAPINITIAL, GPMEMHEAPLIMIT);

    // If we cannot create the heap, give up!
    if (!GpRuntime::GpMemHeap)
        goto ErrorOut;

    // This must happen first.

    __try
    {
        GpMallocTrackingCriticalSection::InitializeCriticalSection();
        BackgroundThreadCriticalSection::InitializeCriticalSection();
        LoadLibraryCriticalSection::InitializeCriticalSection();
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // We couldn't allocate the criticalSection
        // Return an error
        goto ErrorOut;
    }


    // If Allocation failures are turned on, do some initialization here.

    GpInitializeAllocFailures();
    GpStartInitializeAllocFailureMode();

    INT height;
    INT width;
    GpDevice *device;

    Globals::RuntimeInitialized = GpRuntime::Initialize();
    if (!Globals::RuntimeInitialized)
        goto ErrorOut;

    InitVersionInfo();

    Globals::CachedGdiRegion = CreateRectRgn(0, 0, 1, 1);
    if (!Globals::CachedGdiRegion)
        goto ErrorOut;


    // Initialize Stack Back Trace functionality if necessary.
    
    Globals::CaptureStackBackTraceFunction = NULL;
    
    // This stuff requires NT (ntdll.dll)
    
    #if GPMEM_ALLOC_CHK
    
    if(Globals::IsNt)
    {
        HMODULE module = GetModuleHandleA("ntdll.dll");

        Globals::CaptureStackBackTraceFunction = (CAPTURESTACKBACKTRACEFUNCTION)
            GetProcAddress(module, "RtlCaptureStackBackTrace");
    }

    #endif

    // Memory allocation subsystem is initialized. It is now safe to use
    // GpMalloc.




    // Initialize multi-monitor and window event related function pointers

    {
        HMODULE module = GetModuleHandleA("user32.dll");

        Globals::GetWindowInfoFunction = (GETWINDOWINFOFUNCTION)
            GetProcAddress(module, "GetWindowInfo");

        Globals::GetAncestorFunction = (GETANCESTORFUNCTION)
            GetProcAddress(module, "GetAncestor");

        Globals::GetMonitorInfoFunction = (GETMONITORINFOFUNCTION)
            GetProcAddress(module, "GetMonitorInfoA");

        Globals::EnumDisplayMonitorsFunction = (ENUMDISPLAYMONITORSFUNCTION)
            GetProcAddress(module, "EnumDisplayMonitors");

        Globals::EnumDisplayDevicesFunction = (ENUMDISPLAYDEVICESFUNCTION)
            GetProcAddress(module, "EnumDisplayDevicesA");

        Globals::SetWinEventHookFunction = (SETWINEVENTHOOKFUNCTION)
            GetProcAddress(module, "SetWinEventHook");

        Globals::UnhookWinEventFunction = (UNHOOKWINEVENTFUNCTION)
            GetProcAddress(module, "UnhookWinEvent");
    }

    // Create the default desktop device representation.

    if (GetSystemMetrics(SM_REMOTESESSION))
    {
        // it is a remote session
        Globals::IsTerminalServer = TRUE;
    }
    else
    {
        // it isn't a remote session.
        Globals::IsTerminalServer = FALSE;
    }

    // On the NT codebase, the CreateDC(DISPLAY, NULL, NULL, NULL) call has
    // thread affinity. This means that the desktop DC would go away if the
    // thread which called GdiplusStartup terminated even if we were still 
    // using it.
    // On NT we create an Info DC which has process affinity. Rendering onto
    // an Info DC is not supported but that's ok because we always create
    // DriverMulti on NT - and therefore always render on a monitor specific
    // DC instead.
    // Win9x does not have the thread affinity problem and we'd use an IC
    // if it weren't for the fact that win95 doesn't have EnumDisplayMonitors
    // and hence uses DriverGdi instead of DriverMulti - rendering directly
    // on the DesktopIc
    // see RAID:
    // 301407 GDI+ Globals::DesktopDc has thread affinity
    // 312342 CreateDC("Display", NULL, NULL, NULL) has thread affinity.
    // and gdiplus/test/multithread for a test app that exposes this problem.

    
    if(Globals::IsNt)
    {
        Globals::DesktopIc = CreateICA("DISPLAY", NULL, NULL, NULL);
    }
    else
    {
        Globals::DesktopIc = CreateDCA("DISPLAY", NULL, NULL, NULL);
    }
    
    if (!Globals::DesktopIc)
    {
        goto ErrorOut;
    }

    Globals::DesktopDpiX = (REAL)::GetDeviceCaps(Globals::DesktopIc, LOGPIXELSX);
    Globals::DesktopDpiY = (REAL)::GetDeviceCaps(Globals::DesktopIc, LOGPIXELSY);

    if ((Globals::DesktopDpiX <= 0) || (Globals::DesktopDpiY <= 0))
    {
        WARNING(("GetDeviceCaps failed"));
        Globals::DesktopDpiX = DEFAULT_RESOLUTION;
        Globals::DesktopDpiY = DEFAULT_RESOLUTION;
    }

    device = Globals::DesktopDevice = new GpDevice(Globals::DesktopIc);
    if (!CheckValid(Globals::DesktopDevice))
        goto ErrorOut;

    Globals::DeviceList = new GpDeviceList();
    if(Globals::DeviceList == NULL)
        goto ErrorOut;

    // Create the virtual driver representing all GDI+ Eng drawing:

    Globals::EngineDriver = new DpDriver(device);
    if (!CheckValid(Globals::EngineDriver))
        goto ErrorOut;

    // Create the driver for use with the desktop device
    // NOTE: for now we always use the multimon driver.  In the future
    //       we will be able to dynamically redirect desktop drawing
    //       through different drivers as the desktop changes.  This will
    //       require that we have a mechanism to safely modify various
    //       GDI+ objects in response to the mode change.

    // Only use multi-mon driver on multi-mon capable systems

    if(Globals::GetMonitorInfoFunction != NULL &&
       Globals::EnumDisplayMonitorsFunction != NULL)
    {
        Globals::DesktopDriver = new DriverMulti(device);
        if (!CheckValid(Globals::DesktopDriver))
            goto ErrorOut;
    }
    else
    {
        Globals::DesktopDriver = new DriverGdi(device);
        if (!CheckValid(Globals::DesktopDriver))
            goto ErrorOut;
    }

    Globals::GdiDriver = new DriverGdi(device);
    if (!CheckValid(Globals::GdiDriver))
        goto ErrorOut;

    Globals::D3DDriver = new DriverD3D(device);
    if (!CheckValid(Globals::D3DDriver))
        goto ErrorOut;

    Globals::InfoDriver = new DriverInfo(device);
    if (!CheckValid(Globals::InfoDriver))
        goto ErrorOut;

    Globals::MetaDriver = new DriverMeta(device);
    if (!CheckValid(Globals::MetaDriver))
        goto ErrorOut;

    Globals::DesktopSurface = new DpBitmap();
    if (!CheckValid(Globals::DesktopSurface))
        goto ErrorOut;

    // Get the multimon meta-desktop resolution.  SM_CX/CYVIRTUALSCREEN
    // doesn't work on Win95 or NT4, though...

    width = GetSystemMetrics(SM_CXVIRTUALSCREEN);
    height = GetSystemMetrics(SM_CYVIRTUALSCREEN);

    if ((width == 0) || (height == 0))
    {
        width = GetSystemMetrics(SM_CXSCREEN);
        height = GetSystemMetrics(SM_CYSCREEN);
    }

    Globals::DesktopSurface->InitializeForGdiScreen(
        Globals::DesktopDevice,
        width,
        height);

    // Give the driver an opportunity to adjust the surface.
    // If we're on multimon, we need to fix up the
    // pixel format for the DesktopSurface.

    Globals::DesktopDriver->UpdateSurfacePixelFormat(
        Globals::DesktopSurface
    );

    // GDI+ v1 DCR 336742
    // We are disabling image codecs for v1, so ignore the 
    // input->SuppressExternalCodecs flag and hardwire to TRUE.
    // Jbronsk
    if (!InitImagingLibrary(TRUE /* suppressExternalCodecs */))
    {
        // If we couldn't initialize the ImagingLibrary
        goto ErrorOut;
    }

    // Initialize the system colors in fastest search order
    Globals::SystemColors [0] = RGB(0x00,0x00,0x00);
    Globals::SystemColors [1] = RGB(0xFF,0xFF,0xFF);
    Globals::SystemColors [2] = RGB(0xC0,0xC0,0xC0);
    Globals::SystemColors [3] = RGB(0x80,0x80,0x80);
    Globals::SystemColors [4] = RGB(0x00,0x00,0xFF);
    Globals::SystemColors [5] = RGB(0x00,0x00,0x80);
    Globals::SystemColors [6] = RGB(0x00,0xFF,0x00);
    Globals::SystemColors [7] = RGB(0x00,0x80,0x00);
    Globals::SystemColors [8] = RGB(0xFF,0x00,0x00);
    Globals::SystemColors [9] = RGB(0x80,0x00,0x00);
    Globals::SystemColors[10] = RGB(0xFF,0xFF,0x00);
    Globals::SystemColors[11] = RGB(0x80,0x80,0x00);
    Globals::SystemColors[12] = RGB(0x00,0xFF,0xFF);
    Globals::SystemColors[13] = RGB(0x00,0x80,0x80);
    Globals::SystemColors[14] = RGB(0xFF,0x00,0xFF);
    Globals::SystemColors[15] = RGB(0x80,0x00,0x80);
    SysColorNotify();   // update last 4 colors


    if (Globals::IsNt)
    {
        HMODULE module = GetModuleHandle(TEXT("gdi32.dll"));

        Globals::ExtTextOutFunction = (EXTTEXTOUTFUNCTION)
            GetProcAddress(module, "ExtTextOutW");

        Globals::GdiIsMetaPrintDCFunction = (GDIISMETAPRINTDCFUNCTION)
            GetProcAddress(module, "GdiIsMetaPrintDC");
    }
    else
    {
        HMODULE module = GetModuleHandleA("gdi32.dll");

        Globals::ExtTextOutFunction = (EXTTEXTOUTFUNCTION)
            GetProcAddress(module, "ExtTextOutA");

        Globals::GdiIsMetaPrintDCFunction = GdiIsMetaPrintDCWin9x;
    }

    Globals::LanguageID = GetLanguageID();
    if (!InitSystemFontsDirs())
       goto ErrorOut;

    // globals are initialized to NULL
    ASSERT(Globals::NationalDigitCache == NULL);

    Globals::UserDigitSubstituteInvalid = TRUE;
    Globals::CurrentSystemRenderingHintInvalid  = TRUE;
    Globals::CurrentSystemRenderingHint = TextRenderingHintSingleBitPerPixelGridFit;

    VERBOSE(("Loading fonts..."));

    Globals::FontCollection = GpInstalledFontCollection::GetGpInstalledFontCollection();
    if (!Globals::FontCollection || !(Globals::FontCollection->GetFontTable()))
        goto ErrorOut;

    // font caching, least recently used list
    Globals::FontCacheLastRecentlyUsedList = new GpCacheFaceRealizationList;
    if (!Globals::FontCacheLastRecentlyUsedList)
        goto ErrorOut;

    // Initialize for font file cache criticalization

    __try
    {
        InitializeCriticalSection(&Globals::TextCriticalSection);
        Globals::TextCriticalSectionInitialized = TRUE;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // We couldn't allocate the criticalSection
        // Return an error
        goto ErrorOut;
    }

    // If allocation failures are on, start default failure rate

    GpDoneInitializeAllocFailureMode();

    // Now that everything's initialized, it's safe to start the background
    // thread. (The danger: It may immediately receive a message, and the
    // message-handling code assumes that we've been initialized already.)

    if (!input->SuppressBackgroundThread)
    {
        if (!BackgroundThreadStartup())
        {
            goto ErrorOut;
        }
    }

#if GP_ICECAP>1
    CommentMarkProfile(1, "InternalGdiplusStartup completed");
#endif
    VERBOSE(("InternalGdiplusStartup completed successfully"));
    return Ok;

ErrorOut:

    WARNING(("InternalGdiplusStartup: Initialization failed"));

    // Note that the following should free anything we've stuck in
    // the 'globals' class:

    InternalGdiplusShutdown();

    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Initialize font directory goop.
*
* Return Value:
*
*   FALSE if failure (such as low memory).
*
* History:
*
*   6/10/1999 bodind
*       Created it.
*
*   3/1/2002 mikhaill - fixed bug 556954
\**************************************************************************/

#define numberof(x) (sizeof(x)/sizeof(x[0]))

BOOL InitSystemFontsDirs(void)
{
    // Check if already initialized
    if (Globals::FontsDirW) return TRUE;

    WCHAR windowsStr[MAX_PATH+1];
    UINT  windowsStrLength; // size of windows directory path, placed in windowsStr,
                            // without trailing zero, in wide chars

    if (Globals::IsNt)
    {
    // GetWindowsDirectoryW is not working with TS
    // Also GetSystemWidowsDirectoryW is not supported in NT4
    // So we only can use GetSystemDirectory and truncated system32
        windowsStrLength = GetSystemDirectoryW(windowsStr, numberof(windowsStr));
        if (windowsStrLength <= 0 || windowsStrLength >= numberof(windowsStr))
            return FALSE;

        for (INT i = windowsStrLength - 1; i >= 0; i--)
        {
            if (windowsStr[i] == L'\\')
            {
                windowsStrLength = (UINT)i;
                break;
            }
        }

    }
    else
    {
        CHAR windowsStrA[numberof(windowsStr)];
        windowsStrLength = GetWindowsDirectoryA(windowsStrA, numberof(windowsStrA));
        if (windowsStrLength <= 0 || windowsStrLength >= numberof(windowsStrA))
            return FALSE;

        int r = MultiByteToWideChar(CP_ACP, 0, windowsStrA, -1,
                                    windowsStr, numberof(windowsStr));
        if (r == 0) return FALSE;

        // (mikhaill) The following check for trailing '\\' was inherited from old code.
        // Seems to be useless, but harmless.
        // In theory, can serve some weird situations, say, when
        // GetWindowsDirectory() returns "C:\\".
        if ((windowsStr[windowsStrLength - 1] == L'\\'))
        {
            windowsStrLength -= 1;
        }
    }

    if (windowsStrLength == 0) return FALSE;

    // Compute the font directory pathname length, including NULL
    static const WCHAR FontsSubdirW[] = L"\\fonts";

    UINT fontsTotalLength  = windowsStrLength + numberof(FontsSubdirW);

    // compose unicode path
    Globals::FontsDirW = new WCHAR[fontsTotalLength];
    if (!Globals::FontsDirW) return FALSE;

    memcpy(Globals::FontsDirW, windowsStr, windowsStrLength*sizeof(WCHAR));
    memcpy(Globals::FontsDirW + windowsStrLength, FontsSubdirW, sizeof(FontsSubdirW));

    // make ansi path from unicode:

    // get the required buffer length
    int ansiLng = WideCharToMultiByte(CP_ACP, 0, Globals::FontsDirW, -1,
                                      NULL, 0, 0, 0);
    if (ansiLng == 0) goto fail;

    Globals::FontsDirA = new CHAR[ansiLng];
    if (!Globals::FontsDirA) goto fail;

    int ansiLn2 = WideCharToMultiByte(CP_ACP, 0, Globals::FontsDirW, -1,
                                      Globals::FontsDirA, ansiLng,
                                      0, 0);
    if (ansiLn2 != ansiLng) goto fail;

#if INITIALIZE_DBG
        TERSE(("Fonts  path is %ws (%d chars).", Globals::FontsDirW, fontsTotalLength));
#endif

    return TRUE;

fail:
    delete[] Globals::FontsDirW; Globals::FontsDirW = NULL;
    delete[] Globals::FontsDirA; Globals::FontsDirA = NULL;
    return FALSE;
}
/**************************************************************************\
*
* Function Description:
*
*   Initializes direct draw and direct 3D related globals.
*
* Arguments:
*
*       NONE
*
* Return Value:
*
*   TRUE for success otherwise FALSE.
*
* History:
*
*   10/06/1999 bhouse
*       Created it.
*
\**************************************************************************/

BOOL InitializeDirectDrawGlobals(void)
{
    if(Globals::DirectDrawInitialized)
            return TRUE;

    if(Globals::DirectDrawInitAttempted)
            return FALSE;

    // This critical section is used to protect LoadLibrary calls.
    
    LoadLibraryCriticalSection llcs;

    Globals::DirectDrawInitAttempted = TRUE;

    Globals::DdrawHandle = LoadLibraryA("ddraw.dll");

    if(Globals::DdrawHandle == NULL)
    {
        WARNING(("Unable to load direct draw library"));
        return(FALSE);
    }

    Globals::GetDdrawSurfaceFromDcFunction
        = (GETDDRAWSURFACEFROMDCFUNCTION)
                GetProcAddress(Globals::DdrawHandle,
                               "GetSurfaceFromDC");

    if(Globals::GetDdrawSurfaceFromDcFunction == NULL)
    {
        WARNING(("Unable to get GetSurfaceFromDC procedure address"));
        return(FALSE);
    }

    Globals::DirectDrawCreateExFunction
            = (DIRECTDRAWCREATEEXFUNCTION)
                            GetProcAddress(Globals::DdrawHandle,
                                                       "DirectDrawCreateEx");

    if(Globals::DirectDrawCreateExFunction == NULL)
    {
        WARNING(("Unable to get DirectDrawCreateEx procedure address"));
        return(FALSE);
    }


    Globals::DirectDrawEnumerateExFunction
            = (DIRECTDRAWENUMERATEEXFUNCTION)
                            GetProcAddress(Globals::DdrawHandle,
                                          "DirectDrawEnumerateExA");

    if(Globals::DirectDrawEnumerateExFunction == NULL)
    {
        WARNING(("Unable to get DirectDrawEnumerateEx procedure address"));
        return(FALSE);
    }


    HRESULT hr;

    hr = Globals::DirectDrawCreateExFunction(NULL,
                                                &Globals::DirectDraw,
                                                IID_IDirectDraw7,
                                                NULL);

    if(hr != DD_OK)
    {
        WARNING(("Unable to create Direct Draw interface"));
        return(FALSE);
    }

    hr = Globals::DirectDraw->SetCooperativeLevel(NULL, DDSCL_NORMAL);

    if(hr != DD_OK)
    {
        WARNING(("Unable to set DDSCL_NORMAL cooperative level"));
        return(FALSE);
    }

    hr = Globals::DirectDraw->QueryInterface(IID_IDirect3D7,
                                              (void **) &Globals::Direct3D);

    if(hr != DD_OK)
    {
        WARNING(("Unable to get D3D interface"));
        return(FALSE);
    }

    Globals::DirectDrawInitialized = TRUE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\imageattr.hpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   ImageAttr.hpp
*
* Abstract:
*
*   ImageAttribute (recolor) related declarations
*
* Revision History:
*
*   14-Nov-1999 gilmanw
*       Created it.
*
\**************************************************************************/

#ifndef _IMAGEATTR_HPP
#define _IMAGEATTR_HPP

class GpImageAttributes : public GpObject
{
protected:
    VOID SetValid(BOOL valid)
    {
        GpObject::SetValid(valid ? ObjectTagImageAttributes : ObjectTagInvalid);
    }

public:
    GpImageAttributes();

    GpImageAttributes* Clone() const;

    VOID Dispose();

    GpLockable* GetObjectLock() const
    {
        return &Lockable;
    }

    // Set to identity, regardless of what the default color adjustment is.
    GpStatus
    SetToIdentity(
        ColorAdjustType     type
        );

    // Remove any individual color adjustments, and go back to using the default
    GpStatus
    Reset(
        ColorAdjustType     type
        );

    GpStatus
    SetColorMatrix(
        ColorAdjustType type,
        BOOL enable,
        ColorMatrix* colorMatrix,
        ColorMatrix* grayMatrix,
        ColorMatrixFlags flags);

    GpStatus
    SetThreshold(
        ColorAdjustType type,
        BOOL enable,
        REAL threshold);

    GpStatus
    SetGamma(
        ColorAdjustType type,
        BOOL enable,
        REAL gamma);

    GpStatus SetNoOp(
        ColorAdjustType type,
        BOOL enable);

    GpStatus
    SetColorKeys(
        ColorAdjustType type,
        BOOL enable,
        Color* colorLow,
        Color* colorHigh);

    GpStatus
    SetOutputChannel(
        ColorAdjustType type,
        BOOL enable,
        ColorChannelFlags channelFlags);

    GpStatus
    SetOutputChannelProfile(
        ColorAdjustType type,
        BOOL enable,
        WCHAR *profile);

    GpStatus
    SetRemapTable(
        ColorAdjustType type,
        BOOL enable,
        UINT mapSize,
        ColorMap* map);

    GpStatus
    SetCachedBackground(
        BOOL enableFlag);

    BOOL HasRecoloring(
        ColorAdjustType type = ColorAdjustTypeAny
        ) const;

    GpStatus SetWrapMode(WrapMode wrap, ARGB color = 0, BOOL Clamp = FALSE); 
    GpStatus SetICMMode(BOOL on); 
    
    VOID GetAdjustedPalette(
        ColorPalette * colorPalette,
        ColorAdjustType colorAdjustType
        );

    //----------------------------------------------------------------------
    // GpObject virtuals
    //----------------------------------------------------------------------

    virtual BOOL IsValid() const
    {
        // If the image attribtes came from a different version of GDI+, its tag
        // will not match, and it won't be considered valid.
        return ((recolor != NULL) && GpObject::IsValid(ObjectTagImageAttributes));
    }

    virtual ObjectType GetObjectType() const
    {
        return ObjectTypeImageAttributes;
    }

    // Serialization

    virtual UINT GetDataSize() const;
    virtual GpStatus GetData(IStream * stream) const;
    virtual GpStatus SetData(const BYTE * dataBuffer, UINT size);

public:
    GpRecolor* recolor;

    // !!! should move this into the DpImageAttributes
    BOOL cachedBackground;

    // Contains DrawImage Wrap-Mode settings
    DpImageAttributes DeviceImageAttributes;

protected:

    // Object lock

    mutable GpLockable Lockable;

public:

    ~GpImageAttributes();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\imageattr.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   ImageAttr.cpp
*
* Abstract:
*
*   GpImageAttributes (recolor) methods
*
* Revision History:
*
*   14-Nov-1999 gilmanw
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

#include "..\imaging\api\comutils.hpp"
#include "..\imaging\api\decodedimg.hpp"

/**************************************************************************\
*
* Function Description:
*
*   Create a default GpImageAttributes.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

GpImageAttributes::GpImageAttributes()
{
    SetValid(TRUE);     // default is valid

    recolor = new GpRecolor();

    // default WrapMode settings;
    DeviceImageAttributes.wrapMode = WrapModeClamp;
    DeviceImageAttributes.clampColor = (ARGB)0x00000000;    // Fully transparent black
    DeviceImageAttributes.srcRectClamp = FALSE;

    cachedBackground = TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*   Release GpImageAttributes.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID GpImageAttributes::Dispose()
{
    delete this;
}

GpImageAttributes::~GpImageAttributes()
{
    if (recolor)
        recolor->Dispose();
}

/**************************************************************************\
*
* Function Description:
*
*   Clone GpImageAttributes.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Pointer to new GpImageAttributes if successful.
*
\**************************************************************************/

GpImageAttributes* GpImageAttributes::Clone() const
{
    GpImageAttributes* clone = new GpImageAttributes();

    if (clone)
    {
        if ( clone->IsValid() && this->IsValid() )
        {
            *clone->recolor = *this->recolor;
        }
        else
        {
            clone->Dispose();
            clone = NULL;
        }
    }

    return clone;
}

// Set to identity, regardless of what the default color adjustment is.
GpStatus
GpImageAttributes::SetToIdentity(
    ColorAdjustType     type
    )
{
    recolor->SetToIdentity(type);
    UpdateUid();
    return Ok;
}

// Remove any individual color adjustments, and go back to using the default
GpStatus
GpImageAttributes::Reset(
    ColorAdjustType     type
    )
{
    recolor->Reset(type);
    UpdateUid();
    return Ok;
}

GpStatus
GpImageAttributes::SetColorMatrix(
    ColorAdjustType type,
    BOOL enable,
    ColorMatrix* colorMatrix,
    ColorMatrix* grayMatrix,
    ColorMatrixFlags flags)
{
    HRESULT result;

    if (enable)
        result = recolor->SetColorMatrices(type, colorMatrix, grayMatrix, flags);
    else
        result = recolor->ClearColorMatrices(type);

    UpdateUid();

    if (FAILED(result))
    {
        if (result == E_OUTOFMEMORY)
            return OutOfMemory;
        else
            return InvalidParameter;
    }
    else
        return Ok;
}

GpStatus
GpImageAttributes::SetThreshold(
    ColorAdjustType type,
    BOOL enable,
    REAL threshold)
{
    HRESULT result;

    if (enable)
        result = recolor->SetThreshold(type, threshold);
    else
        result = recolor->ClearThreshold(type);

    UpdateUid();

    if (FAILED(result))
        return InvalidParameter;
    else
        return Ok;
}

GpStatus
GpImageAttributes::SetGamma(
    ColorAdjustType type,
    BOOL enable,
    REAL gamma)
{
    HRESULT result;

    if (enable)
        result = recolor->SetGamma(type, gamma);
    else
        result = recolor->ClearGamma(type);

    UpdateUid();

    if (FAILED(result))
        return InvalidParameter;
    else
        return Ok;
}

GpStatus GpImageAttributes::SetNoOp(
    ColorAdjustType type,
    BOOL enable
    )
{
    HRESULT result;

    if (enable)
        result = recolor->SetNoOp(type);
    else
        result = recolor->ClearNoOp(type);

    UpdateUid();

    if (FAILED(result))
        return InvalidParameter;
    else
        return Ok;
}

GpStatus
GpImageAttributes::SetColorKeys(
    ColorAdjustType type,
    BOOL enable,
    Color* colorLow,
    Color* colorHigh)
{
    HRESULT result;

    if (enable)
        result = recolor->SetColorKey(type, colorLow, colorHigh);
    else
        result = recolor->ClearColorKey(type);

    UpdateUid();

    if (FAILED(result))
        return InvalidParameter;
    else
        return Ok;
}

GpStatus
GpImageAttributes::SetOutputChannel(
    ColorAdjustType type,
    BOOL enable,
    ColorChannelFlags channelFlags
    )
{
    HRESULT result;

    if (enable)
        result = recolor->SetOutputChannel(type, channelFlags);
    else
        result = recolor->ClearOutputChannel(type);

    UpdateUid();

    if (FAILED(result))
        return InvalidParameter;
    else
        return Ok;
}

GpStatus
GpImageAttributes::SetOutputChannelProfile(
    ColorAdjustType type,
    BOOL enable,
    WCHAR *profile)
{
    HRESULT result;

    if (enable)
        result = recolor->SetOutputChannelProfile(type, profile);
    else
        result = recolor->ClearOutputChannelProfile(type);

    UpdateUid();

    if (SUCCEEDED(result))
        return Ok;
    else
    {
        if (result == E_INVALIDARG)
            return InvalidParameter;
        else if (result == E_OUTOFMEMORY)
            return OutOfMemory;
        else
            return Win32Error;
    }
}

GpStatus
GpImageAttributes::SetRemapTable(
    ColorAdjustType type,
    BOOL enable,
    UINT mapSize,
    ColorMap* map)
{
    HRESULT result;

    if (enable)
        result = recolor->SetRemapTable(type, mapSize, map);
    else
        result = recolor->ClearRemapTable(type);

    UpdateUid();

    if (FAILED(result))
        return InvalidParameter;
    else
        return Ok;
}

GpStatus
GpImageAttributes::SetCachedBackground(
    BOOL enableFlag
    )
{
    if (cachedBackground != enableFlag)
    {
        cachedBackground = enableFlag;
        UpdateUid();
    }

    return Ok;
}

BOOL
GpImageAttributes::HasRecoloring(
    ColorAdjustType type
    ) const
{
    return (recolor) && (recolor->HasRecoloring(type) != 0);
}

GpStatus GpImageAttributes::SetWrapMode(WrapMode wrap, ARGB color, BOOL Clamp)
{
    DeviceImageAttributes.wrapMode = wrap;
    DeviceImageAttributes.clampColor = color;
    DeviceImageAttributes.srcRectClamp = Clamp;
    UpdateUid();
    return Ok;
}

GpStatus GpImageAttributes::SetICMMode(BOOL on)
{
    if( DeviceImageAttributes.ICMMode!= on)
    {
        DeviceImageAttributes.ICMMode = on;
        UpdateUid();
    }
    return Ok;
}

VOID GpImageAttributes::GetAdjustedPalette(
    ColorPalette * colorPalette,
    ColorAdjustType colorAdjustType
    )
{
    ASSERT((colorPalette != NULL) && (colorPalette->Count > 0));

    if (!this->HasRecoloring(colorAdjustType))
    {
        return;
    }
    this->recolor->Flush();
    this->recolor->ColorAdjust(colorPalette->Entries, colorPalette->Count,
                               colorAdjustType);
}


// Serialization


class ImageAttributesData : public ObjectData
{
public:
    BOOL                CachedBackground;
    DpImageAttributes   DeviceImageAttributes;
};


/**************************************************************************\
*
* Function Description:
*
*   Get the data from the GpImageAttributes for serialization.
*
* Return - size of GpImageAttributes
*
* 05/15/2000 asecchia - created it.
*
\**************************************************************************/

GpStatus
GpImageAttributes::GetData(
    IStream *   stream
    ) const
{
    ASSERT (stream != NULL);

    ImageAttributesData     imageAttributesData;
    imageAttributesData.CachedBackground      = cachedBackground;
    imageAttributesData.DeviceImageAttributes = DeviceImageAttributes;
    stream->Write(&imageAttributesData, sizeof(imageAttributesData), NULL);

    return Ok;
}

UINT
GpImageAttributes::GetDataSize() const
{
    return sizeof(ImageAttributesData);
}

/**************************************************************************\
*
* Function Description:
*
*   Set the GpImageAttributes from the data buffer for serialization.
*
* 05/15/2000 asecchia - created it.
*
\**************************************************************************/

GpStatus
GpImageAttributes::SetData(
    const BYTE *        dataBuffer,
    UINT                size
    )
{
    if (dataBuffer == NULL)
    {
        WARNING(("dataBuffer is NULL"));
        return InvalidParameter;
    }

    if (size < sizeof(ImageAttributesData))
    {
        WARNING(("size too small"));
        return InvalidParameter;
    }

    const ImageAttributesData *imageAttributes;
    imageAttributes = reinterpret_cast<const ImageAttributesData *>(dataBuffer);

    if (!imageAttributes->MajorVersionMatches())
    {
        WARNING(("Version number mismatch"));
        return InvalidParameter;
    }

    cachedBackground = imageAttributes->CachedBackground;
    DeviceImageAttributes = imageAttributes->DeviceImageAttributes;

    UpdateUid();

    // Might consider resetting the recolor objects to identity, but
    // for now don't need to since we know this method only gets called
    // right after the object has been constructed.
    
    return Ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\intmap.hpp ===
#ifndef _INTMAP_HPP
#define _INTMAP_HPP

/////   IntMap - sparse array indexed by int value
//
//      Used to store tables indexed by Unicode codepoint or
//      by glyph index.
//
//      !!! This implementation maps values in the range [0..1114112]
//          which is the subset of ISO 10664 addressable (using surrogates)
//          in Unicode UTF16.
//
//      (1114112 is 17*65536)


template <class C> class IntMap {
public:

    IntMap() : Status(Ok)
    {
        if (UsageCount == 0)
        {
            // Note that this is not thread safe.
            // Currently all font/text APIs are protected by a single critical
            // section.

            if (!EmptyPage)
                EmptyPage = new C[256];

            if (!EmptyPage)
            {
                Status = OutOfMemory;
                return;
            }

            for (INT i=0; i<256; i++)
            {
                EmptyPage[i] = 0;
            }

            if (!EmptyPlane)
                EmptyPlane = new C*[256];

            if (!EmptyPlane)
            {
                Status = OutOfMemory;
                return;
            }

            for (INT i=0; i<256; i++)
            {
                EmptyPlane[i] = EmptyPage;
            }
        }
        ++UsageCount;

        for (INT i=0; i<17; i++)
        {
            map[i] = EmptyPlane;
        }

        #if DBG
        ASSERT(map[0][0x05][0x31] == 0);
        for (INT i=0; i<256; i++)
        {
            ASSERT(EmptyPlane[i] == EmptyPage);
            ASSERT(EmptyPage[i] == 0);
        }
        #endif
    }

    ~IntMap()
    {
        if (Status != Ok)
            return;

        for (INT i=0; i<17; i++)
        {
            if (map[i] != EmptyPlane)
            {
                for (INT j=0; j<256; j++)
                {
                    if (map[i][j] != EmptyPage)
                    {
                        delete map[i][j];
                    }
                }
                delete map[i];
            }
        }

        --UsageCount;
        if (UsageCount == 0)
        {
            // Release memory used by static empty pages for IntMap<C>
            delete [] EmptyPlane, EmptyPlane = 0;
            delete [] EmptyPage, EmptyPage = 0;
        }
    }


    // Insert value for single codepoint

    GpStatus Insert(INT i, const C &v)
    {
        ASSERT(Status == Ok);
        ASSERT(i < 17*65536);

        ASSERT(map[i>>16] != NULL);

        if (map[i>>16] == EmptyPlane)
        {
            map[i>>16] = new C*[256];

            if (!map[i>>16])
            {
                map[i>>16] = EmptyPlane;
                return OutOfMemory;
            }

            for (INT j=0; j<256; j++)
            {
                map [i>>16] [j] = EmptyPage;
            }
        }

        ASSERT(map [i>>16] [i>>8 & 0xff] != NULL);

        if (map [i>>16] [i>>8 & 0xff] == EmptyPage)
        {
            if (!(map [i>>16] [i>>8 & 0xff] = new C[256]))
            {
                map [i>>16] [i>>8 & 0xff] = EmptyPage;
                return OutOfMemory;
            }

            memcpy(map [i>>16] [i>>8 & 0xff], EmptyPage, sizeof(C) * 256);
        }

        map [i>>16] [i>>8 & 0xff] [i & 0xff] = v;
        return Ok;
    }

    ////    Lookup single codepoint

    C& Lookup(INT i) const
    {
        ASSERT(Status == Ok);
        ASSERT(i < 17*65536);
        return map [i>>16] [i>>8 & 0xff] [i & 0xff];
    }


    ////    Lookup codepoint expressed as surrogate pair

    C& Lookup(UINT16 h, UINT16 l) const
    {
        ASSERT(Status == Ok);
        ASSERT((h & 0xFC00) == 0xD800);
        ASSERT((l & 0xFC00) == 0xDC00);

        INT i = 0x10000 + (((h & 0x3ff) << 10) | (l & 0x3ff));

        ASSERT(i < 17*65536);
        return map [i>>16] [i>>8 & 0xff] [i & 0xff];
    }


    ////    Lookup array of 16 bit unsigned values

    void Lookup(
        const UINT16 *source,
        INT           sourceCount,
        C            *values
    ) const
    {
        ASSERT(Status == Ok);
        for (INT i=0; i<sourceCount; i++)
        {
            values[i] = Lookup(source[i]);
        }
    }


    ////    Lookup 16 bit Unicode character string with surrogate interpretation
    //
    //      If the oneToOne parameter is set, surrogate pairs are translated to
    //      the correct glyph, followed by 0xffff so as to generate the same
    //      number of glyphs as codepoints.

    void LookupUnicode(
        const WCHAR *characters,
        INT          characterCount,
        C           *values,
        UINT32      *valueCount,
        BOOL         oneToOne            // Glyph count == character count
    ) const
    {
        ASSERT(Status == Ok);
        ASSERT(characterCount >= 0);

        INT ci = 0;  // Character array index
        INT vi = 0;  // Value array index

        while (    ci < characterCount)
        {
            // Efficient loop through non-surrogates

            while (    ci < characterCount
                   &&  (characters[ci] & 0xF800) != 0xD800)
            {
                values[vi++] = Lookup(characters[ci++]);
            }

            // Loop through surrogates

            while (    ci < characterCount
                   &&  (characters[ci] & 0xF800) == 0xD800)
            {

                // Fast loop through valid surrogate pairs

                while (    ci+1 < characterCount
                       &&  (characters[ci]   & 0xFC00) == 0xD800
                       &&  (characters[ci+1] & 0xFC00) == 0xDC00)
                {
                    values[vi++] = Lookup(characters[ci], characters[ci+1]);
                    if (oneToOne)
                    {
                        values[vi++] = 0xffff;
                    }
                    ci += 2;
                }

                // Either
                // 1. We came to the end of the run of surrogate codepoints
                // 2. There's one or more high surrogates with no matching low surrogates
                // 3. There's one or more low surrogates

                // Handle any misplaced high surrogates as normal codepoints

                while (    ci < characterCount
                       &&  (characters[ci] & 0xFC00) == 0xD800
                       &&  (    ci+1 >= characterCount
                            ||  (characters[ci+1] & 0xFC00) != 0xDC00))
                {
                    values[vi++] = Lookup(characters[ci++]);
                }


                // Handle any misplaced low surrogates as normal codepoints

                while (    ci < characterCount
                       &&  (characters[ci] & 0xFC00) == 0xDC00)
                {
                    values[vi++] = Lookup(characters[ci++]);
                }
            }
        }

        if (valueCount)
        {
            *valueCount = vi;
        }
        else
        {
            ASSERT(vi == characterCount);
        }
    }

    GpStatus GetStatus() const
    {
        return Status;
    }

private:
    GpStatus    Status;
    C            **map[17];
    static C     **EmptyPlane;
    static C      *EmptyPage;
    static LONG   UsageCount;
};


template<class C> LONG IntMap<C>::UsageCount = 0;  // Tracks static memory usage
template<class C> C **IntMap<C>::EmptyPlane;
template<class C> C *IntMap<C>::EmptyPage;
#endif _INTMAP_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\largeint.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   LargeInt.hpp
*
* Abstract:
*
*   Large Integer Wrapper
*
* Created:
*
*   4/26/1999 Mike Hillberg
*
\**************************************************************************/

#ifndef _LARGEINT_HPP
#define _LARGEINT_HPP


template <class TXLargeInteger, class TSubType, class TQuadType>
// Either LARGE_INTEGER/LONG/LONGLONG or ULARGE_INTEGER/ULONG/ULONGLONG
class TXLargeIntegerWrapper
{

public:

    TXLargeIntegerWrapper()
    {
        QuadPart = 0;
    }

    TXLargeIntegerWrapper( const TXLargeIntegerWrapper &xliWrapper )
    {
        QuadPart = xliWrapper.QuadPart;
    }

    TXLargeIntegerWrapper( const TXLargeInteger xli )
    {
        QuadPart = xli.QuadPart;
    }

    TXLargeIntegerWrapper( const int i )
    {
        QuadPart = i;
    }

    TXLargeIntegerWrapper( const ULONG ul )
    {
        LowPart = ul;
        HighPart = 0;
    }

    TXLargeIntegerWrapper( const UINT ui )
    {
        LowPart = ui;
        HighPart = 0;
    }

    TXLargeIntegerWrapper( const LONG l )
    {
        QuadPart = static_cast<TSubType>(l);    // Sign-extend
    }

    TXLargeIntegerWrapper( const TQuadType q )
    {
        QuadPart = q;
    }


public:

    TXLargeIntegerWrapper &operator=( const TXLargeIntegerWrapper xli )
    {
        QuadPart = xli.QuadPart;
        return(*this);
    }


public:

    BOOL operator==( const TXLargeIntegerWrapper xli ) const
    {
        return( QuadPart == xli.QuadPart );
    }

    BOOL operator!=( const TXLargeIntegerWrapper xli ) const
    {
        return( QuadPart != xli.QuadPart );
    }

    BOOL operator<( const TXLargeIntegerWrapper xli ) const 
    {
        return( QuadPart < xli.QuadPart );
    }

    BOOL operator<=( const TXLargeIntegerWrapper xli ) const
    {
        return( QuadPart <= xli.QuadPart );
    }

    BOOL operator>( const TXLargeIntegerWrapper xli ) const
    {
        return( QuadPart > xli.QuadPart );
    }

    BOOL operator>=( TXLargeIntegerWrapper xli ) const
    {
        return( QuadPart >= xli.QuadPart );
    }

    TXLargeIntegerWrapper operator-() const
    {
	TXLargeIntegerWrapper ret;
	ret.QuadPart = -QuadPart;
	return( ret );
    }

public:

    TXLargeIntegerWrapper operator+( TXLargeIntegerWrapper xli )
    {
        TXLargeIntegerWrapper ret;
        ret.QuadPart = QuadPart + xli.QuadPart;
        return(ret);
    }

    TXLargeIntegerWrapper& operator+=( TXLargeIntegerWrapper xli )
    {
        QuadPart += xli.QuadPart;
        return(*this);
    }

    TXLargeIntegerWrapper& operator++( )	// prefix
    {
        ++QuadPart;
        return(*this);
    }

    TXLargeIntegerWrapper operator++(int)	// postfix
    {
		TQuadType QuadPartReturn = QuadPart++;
        return(QuadPartReturn);
    }

    TXLargeIntegerWrapper operator-( TXLargeIntegerWrapper xli )
    {
        TXLargeIntegerWrapper ret;
        ret.QuadPart = QuadPart - xli.QuadPart;
        return(ret);
    }
	
    TXLargeIntegerWrapper& operator-=( TXLargeIntegerWrapper xli )
    {
        QuadPart -= xli.QuadPart;
        return(*this);
    }

    TXLargeIntegerWrapper& operator--( )	// prefix
    {
        --QuadPart;
        return(*this);
    }

    TXLargeIntegerWrapper operator--(int)	// postfix
    {
		TQuadType QuadPartReturn = QuadPart--;
        return(QuadPartReturn);
    }

public:

    TXLargeIntegerWrapper& operator*( TXLargeIntegerWrapper xli )
    {
        TXLargeIntegerWrapper ret;
        ret.QuadPart = QuadPart * xli.QuadPart;
        return(ret);
    }

    TXLargeIntegerWrapper& operator*=( TXLargeIntegerWrapper xli )
    {
        QuadPart *= xli.QuadPart;
        return( *this );
    }


public:

    TXLargeInteger* operator&()
    {
        return( reinterpret_cast<TXLargeInteger*>(this) );
    }

public:

    operator ULARGE_INTEGER() const
    {
        ULARGE_INTEGER uli;
        uli.HighPart = HighPart;
        uli.LowPart = LowPart;
        return( uli );
    }

    operator LARGE_INTEGER() const
    {
        LARGE_INTEGER li;
        li.HighPart = HighPart;
        li.LowPart = LowPart;
        return( li );
    }


public:

    typedef DWORD          typeLowPart;
    typedef TSubType       typeHighPart;
    typedef TQuadType      typeQuadPart;
    typedef TXLargeInteger typeWholePart;

    union
    {
        struct
        {
            typeLowPart LowPart;
            typeHighPart HighPart;
        };
        typeQuadPart QuadPart;
    };
};


typedef TXLargeIntegerWrapper<LARGE_INTEGER, LONG, LONGLONG>   CLargeInteger;
typedef TXLargeIntegerWrapper<ULARGE_INTEGER, ULONG, ULONGLONG> CULargeInteger;

#endif // #ifndef _LARGEINT_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\metafile.hpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   MetaFile.hpp
*
* Abstract:
*
*   Metafile definitions
*
* Created:
*
*   4/14/1999 DCurtis
*
\**************************************************************************/

#ifndef _METAFILE_HPP
#define _METAFILE_HPP

#define EMFPLUS_SIGNATURE           0x2B464D45
#define EMFPLUS_DUAL                0x4C415544      // EMF+ with down-level GDI records
#define EMFPLUS_ONLY                0x594C4E4F      // EMF+ only -- no down-level

/* The following are defined in Object.hpp:
#define EMFPLUS_VERSION
#define EMFPLUS_MAJORVERSION_BITS
#define EMFPLUS_MINORVERSION_BITS
*/


// Constants for MFCOMMENT Escape

#define MFCOMMENT_IDENTIFIER           0x43464D57
#define MFCOMMENT_ENHANCED_METAFILE    1

// When serializing an object, we need to leave room for the record header
// and possibly a dependent object id.  Also, an image can be part of a
// texture brush, so leave room for the texture brush data.
// Subtract 480 for good measure.
#define GDIP_MAX_OBJECT_SIZE          (GDIP_MAX_COMMENT_SIZE - 480)
#define GDIP_METAFILE_BUFFERSIZE      2048
#define GDIP_MAX_OBJECTS              64      // max num cached objects
#define GDIP_SAVE_STACK_SIZE          16      // for save/restores
#define GDIP_LIST_NIL                 0xFFFFFFFF
#define GDIP_OBJECTID_NONE            GDIP_LIST_NIL  // no object present

#define GDIP_REAL_SIZE                4
#define GDIP_RECTF_SIZE               (4 * GDIP_REAL_SIZE)
#define GDIP_POINTF_SIZE              (2 * GDIP_REAL_SIZE)
#define GDIP_MATRIX_SIZE              (6 * GDIP_REAL_SIZE)

// Set in Flags in EMF+ record header
// Flags Used in Object Records
#define GDIP_EPRFLAGS_CONTINUEOBJECT  0x8000  // more data for previous object
#define GDIP_EPRFLAGS_OBJECTTYPE      0x7F00

// Used in Object records and "Fill..." and "Draw..." and many other records
#define GDIP_EPRFLAGS_METAOBJECTID    0x00FF
#define GDIP_BACKUP_OBJECTID          255   // the object is a "backup object"

// Used in "Fill..." records
#define GDIP_EPRFLAGS_SOLIDCOLOR      0x8000

// Used in "Fill..." and "Draw..." records
#define GDIP_EPRFLAGS_COMPRESSED      0x4000  // point data is compressed

// Used in some "Fill..." records
#define GDIP_EPRFLAGS_WINDINGFILL     0x2000

// Used in DrawLines record
#define GDIP_EPRFLAGS_CLOSED          0x2000

// Used in matrix operations
#define GDIP_EPRFLAGS_APPEND          0x2000

// Used in SetAntiAliasMode record
#define GDIP_EPRFLAGS_ANTIALIAS       0x0001

// Used in SetTextRenderingHint record
#define GDIP_EPRFLAGS_TEXTRENDERINGHINT 0x00FF

// Used in SetTextContrast record (1000~2200)
#define GDIP_EPRFLAGS_CONTRAST        0x0FFF

// Used in EndOfFile record
#define GDIP_EPRFLAGS_DIDGETDC        0x2000

// Used in BeginContainer and SetPageTransform records
#define GDIP_EPRFLAGS_PAGEUNIT        0x00FF  // can't be mixed with Ids

// Used in SetInterpolationMode record
#define GDIP_EPRFLAGS_INTERPOLATIONMODE 0x00FF

// Used in SetPixelOffsetMode record
#define GDIP_EPRFLAGS_PIXELOFFSETMODE 0x00FF

// Used in SetCompositingMode record
#define GDIP_EPRFLAGS_COMPOSITINGMODE 0x00FF

// Used in SetCompositingQuality record
#define GDIP_EPRFLAGS_COMPOSITINGQUALITY 0x00FF

// Used in SetClipRect, SetClipPath, and SetClipRegion records
#define GDIP_EPRFLAGS_COMBINEMODE     0x0F00

// Used in SetClipPath record
#define GDIP_EPRFLAGS_ISDEVICEPATH    0x2000

// Used in Header record
#define GDIP_EPRFLAGS_EMFPLUSDUAL     0x0001

inline ObjectType
GetObjectType(
    INT     flags
    )
{
    return static_cast<ObjectType>((flags & GDIP_EPRFLAGS_OBJECTTYPE) >> 8);
}

inline GpFillMode
GetFillMode(
    INT     flags
    )
{
    return ((flags & GDIP_EPRFLAGS_WINDINGFILL) == 0) ?
                FillModeAlternate : FillModeWinding;
}

inline BOOL
IsClosed(
    INT     flags
    )
{
    return ((flags & GDIP_EPRFLAGS_CLOSED) != 0);
}

inline BOOL
DidGetDC(
    INT     flags
    )
{
    return ((flags & GDIP_EPRFLAGS_DIDGETDC) != 0);
}

inline GpMatrixOrder
GetMatrixOrder(
    INT     flags
    )
{
    return ((flags & GDIP_EPRFLAGS_APPEND) == 0) ? MatrixOrderPrepend : MatrixOrderAppend;
}

inline BOOL
GetAntiAliasMode(
    INT     flags
    )
{
    return ((flags & GDIP_EPRFLAGS_ANTIALIAS) != 0);
}

inline TextRenderingHint
GetTextRenderingHint(
    INT     flags
    )
{
    return static_cast<TextRenderingHint>
        (flags & GDIP_EPRFLAGS_TEXTRENDERINGHINT);
}

inline UINT
GetTextContrast(
    INT     flags
    )
{
    return static_cast<UINT>
        (flags & GDIP_EPRFLAGS_CONTRAST);
}

inline InterpolationMode
GetInterpolationMode(
    INT     flags
    )
{
    return static_cast<InterpolationMode>
        (flags & GDIP_EPRFLAGS_INTERPOLATIONMODE);
}

inline PixelOffsetMode
GetPixelOffsetMode(
    INT     flags
    )
{
    return static_cast<PixelOffsetMode>
        (flags & GDIP_EPRFLAGS_PIXELOFFSETMODE);
}

inline GpCompositingMode
GetCompositingMode(
    INT     flags
    )
{
    return static_cast<GpCompositingMode>
        (flags & GDIP_EPRFLAGS_COMPOSITINGMODE);
}

inline GpCompositingQuality
GetCompositingQuality(
    INT     flags
    )
{
    return static_cast<GpCompositingQuality>
        (flags & GDIP_EPRFLAGS_COMPOSITINGQUALITY);
}

inline UINT
GetMetaObjectId(
    INT     flags
    )
{
    return flags & GDIP_EPRFLAGS_METAOBJECTID;
}

inline GpPageUnit
GetPageUnit(
    INT     flags
    )
{
    return static_cast<GpPageUnit>(flags & GDIP_EPRFLAGS_PAGEUNIT);
}

inline CombineMode
GetCombineMode(
    INT     flags
    )
{
    return static_cast<CombineMode>((flags & GDIP_EPRFLAGS_COMBINEMODE) >> 8);
}

inline BOOL
GetIsDevicePath(
    INT     flags
    )
{
    return ((flags & GDIP_EPRFLAGS_ISDEVICEPATH) != 0);
}

inline BOOL
GetIsEmfPlusDual(
    INT     flags
    )
{
    return ((flags & GDIP_EPRFLAGS_EMFPLUSDUAL) != 0);
}

class MetafileRecorder;
class MetafilePlayer;

class EmfPlusRecord
{
public:
    INT16           Type;
    UINT16          Flags;      // This has to be unsigned or the code breaks!
    UINT32          Size;       // Record size in bytes (including size field)
    UINT32          DataSize;   // Record size in bytes, excluding header size.
};

class EmfPlusContinueObjectRecord : public EmfPlusRecord
{
public:
    UINT32          TotalObjectSize;
};

class EmfPlusRecordPlay
{
public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        return;
    }
};

class EmfPlusHeaderRecord : public EmfPlusRecordPlay
{
public:
    INT32       Version;        // Version of the file
    INT32       EmfPlusFlags;   // flags (display and non-dual)
    INT32       LogicalDpiX;    // DpiX of referenceHdc
    INT32       LogicalDpiY;    // DpiY of referenceHdc

    EmfPlusHeaderRecord() { /* no initialization */ }
    EmfPlusHeaderRecord(INT emfPlusFlags, INT logicalDpiX, INT logicalDpiY)
    {
        Version      = EMFPLUS_VERSION;
        EmfPlusFlags = emfPlusFlags;
        LogicalDpiX  = logicalDpiX;
        LogicalDpiY  = logicalDpiY;
    }
};

#ifdef GDIP_RECORD_DEVICEBOUNDS
class EmfPlusBoundsRecord : public EmfPlusRecordPlay
{
public:
    GpRectF         DeviceBounds;
};
#else
#define EmfPlusBoundsRecord     EmfPlusRecordPlay
#endif

// When recording, we convert REAL data to INT16 data if we can without
// losing precision.
typedef struct
{
    INT16   X;
    INT16   Y;
} GpPoint16;

typedef struct
{
    INT16   X;
    INT16   Y;
    INT16   Width;
    INT16   Height;
} GpRect16;

inline BOOL
EmfHeaderIsValid(
    ENHMETAHEADER3 &        emfHeader
    )
{
    return ((emfHeader.iType == EMR_HEADER) &&
            (emfHeader.dSignature == ENHMETA_SIGNATURE) &&
            (emfHeader.nSize >= sizeof(ENHMETAHEADER3)) &&
            (emfHeader.nHandles > 0) &&
            (emfHeader.nRecords >= 2) &&    // must have at least header and EOF record
            ((emfHeader.nBytes & 3) == 0) &&
            (emfHeader.szlDevice.cx > 0) &&
            (emfHeader.szlDevice.cy > 0) &&
            (emfHeader.szlMillimeters.cx > 0) &&
            (emfHeader.szlMillimeters.cy > 0));
}

GpStatus
GetMetafileHeader(
    HMETAFILE                        hWmf,
    const WmfPlaceableFileHeader *   wmfPlaceableFileHeader,
    MetafileHeader &                 header
    );

GpStatus
GetMetafileHeader(
    HENHMETAFILE        hEmf,
    MetafileHeader &    header,
    BOOL *              isCorrupted = NULL
    );

GpStatus
GetMetafileHeader(
    IStream *           stream,
    MetafileHeader &    header,
    BOOL                tryWmfOnly = FALSE
    );

GpStatus
GetMetafileHeader(
    const WCHAR *       filename,
    MetafileHeader &    header
    );

///////////////////////////////////////////////////////////////////////////
// Stream helper methods

IStream *
CreateStreamOnFile(
    const OLECHAR * pwcsName,
    UINT            access = GENERIC_WRITE  // GENERIC_READ and/or GENERIC_WRITE
    );

inline INT
HResultSuccess(
    HRESULT     hResult
    )
{
    return (!FAILED(hResult)) ? 1 : 0;
}

inline INT
GetStreamPosition(
    IStream *               stream,
    LONGLONG &              position
    )
{
    HRESULT         hResult;
    ULARGE_INTEGER  curPosition;
    LARGE_INTEGER   zeroOffset;

    zeroOffset.QuadPart = 0;
    hResult = stream->Seek(zeroOffset, STREAM_SEEK_CUR, &curPosition);
    position = curPosition.QuadPart;
    return HResultSuccess(hResult);
}

inline INT
SeekFromHere(
    IStream *               stream,
    const LONGLONG &        offsetFromHere
    )
{
    HRESULT         hResult;
    LARGE_INTEGER   offset;

    offset.QuadPart = offsetFromHere;
    hResult = stream->Seek(offset, STREAM_SEEK_CUR, NULL);
    return HResultSuccess(hResult);
}

inline INT
SeekFromStart(
    IStream *               stream,
    const LONGLONG &        offsetFromStart
    )
{
    HRESULT         hResult;
    LARGE_INTEGER   offset;

    offset.QuadPart = offsetFromStart;
    hResult = stream->Seek(offset, STREAM_SEEK_SET, NULL);
    return HResultSuccess(hResult);
}

inline INT
CopyStream(
    IStream *               srcStream,
    IStream *               destStream,
    const LONGLONG &        bytesToCopy
    )
{
    HRESULT                 hResult;
    ULARGE_INTEGER          numBytes;
    ULARGE_INTEGER          bytesWritten;

    ASSERT (bytesToCopy > 0);

    numBytes.QuadPart = bytesToCopy;
    hResult = srcStream->CopyTo(destStream, numBytes, NULL, &bytesWritten);
    return ((!FAILED(hResult)) &&
            (bytesWritten.QuadPart == numBytes.QuadPart)) ? 1 : 0;
}

///////////////////////////////////////////////////////////////////////////
// Read methods to read values from a stream

inline INT
ReadInt16(
    IStream *           stream,
    INT16 *             value
    )
{
    ASSERT(sizeof(INT16) == 2);

    HRESULT     hResult;
    hResult = stream->Read(value, sizeof(INT16), NULL);
    return HResultSuccess(hResult);
}

inline INT
ReadInt32(
    IStream *           stream,
    INT32 *             value
    )
{
    ASSERT(sizeof(INT32) == 4);

    HRESULT     hResult;
    hResult = stream->Read(value, sizeof(INT32), NULL);
    return HResultSuccess(hResult);
}

inline INT
ReadInt32(
    IStream *           stream,
    UINT32 *            value
    )
{
    ASSERT(sizeof(UINT32) == 4);

    HRESULT     hResult;
    hResult = stream->Read(value, sizeof(UINT32), NULL);
    return HResultSuccess(hResult);
}

inline INT
ReadReal(
    IStream *           stream,
    REAL *              value
    )
{
    ASSERT(sizeof(REAL) == 4);

    HRESULT     hResult;
    hResult = stream->Read(value, sizeof(REAL), NULL);
    return HResultSuccess(hResult);
}

inline INT
ReadRect(
    IStream *           stream,
    GpRectF *           value
    )
{
    ASSERT(sizeof(GpRectF) == GDIP_RECTF_SIZE);

    HRESULT     hResult;
    hResult = stream->Read(value, sizeof(GpRectF), NULL);
    return HResultSuccess(hResult);
}

inline INT
ReadMatrix(
    IStream *           stream,
    GpMatrix *          value
    )
{
    ASSERT(sizeof(REAL) == GDIP_REAL_SIZE);

    REAL        matrix[6];
    HRESULT     hResult;
    hResult = stream->Read(matrix, GDIP_MATRIX_SIZE, NULL);
    value->SetMatrix(matrix);
    return HResultSuccess(hResult);
}

inline INT
ReadBytes(
    IStream *           stream,
    VOID *              bytes,
    INT                 count
    )
{
    ASSERT(sizeof(BYTE) == 1);

    HRESULT     hResult;
    hResult = stream->Read(bytes, count, NULL);
    return HResultSuccess(hResult);
}

inline INT
ReadPoints(
    IStream *           stream,
    GpPointF *          points,
    INT                 count
    )
{
    ASSERT(sizeof(GpPointF) == GDIP_POINTF_SIZE);

    HRESULT     hResult;
    hResult = stream->Read(points, sizeof(GpPointF) * count, NULL);
    return HResultSuccess(hResult);
}

///////////////////////////////////////////////////////////////////////////
// Write methods to write values to a stream

inline INT
WriteByte(
    IStream *           stream,
    BYTE                value
    )
{
    ASSERT(sizeof(value) == 1);

    HRESULT     hResult;
    hResult = stream->Write(&value, sizeof(value), NULL);
    return HResultSuccess(hResult);
}

inline INT
WriteInt16(
    IStream *           stream,
    INT16               value
    )
{
    ASSERT(sizeof(value) == 2);

    HRESULT     hResult;
    hResult = stream->Write(&value, sizeof(value), NULL);
    return HResultSuccess(hResult);
}

inline INT
WriteInt32(
    IStream *           stream,
    INT32               value
    )
{
    ASSERT(sizeof(value) == 4);

    HRESULT     hResult;
    hResult = stream->Write(&value, sizeof(value), NULL);
    return HResultSuccess(hResult);
}

inline INT
WriteReal(
    IStream *           stream,
    REAL                value
    )
{
    ASSERT(sizeof(value) == GDIP_REAL_SIZE);

    HRESULT     hResult;
    hResult = stream->Write(&value, sizeof(value), NULL);
    return HResultSuccess(hResult);
}

inline INT
WriteColor64(
    IStream *           stream,
    const ARGB64 &      value
    )
{
    ASSERT(sizeof(value) == 8);

    HRESULT     hResult;
    hResult = stream->Write(&value, sizeof(value), NULL);
    return HResultSuccess(hResult);
}

inline INT
WriteRect(
    IStream *           stream,
    const GpRectF &     value
    )
{
    ASSERT(sizeof(value) == GDIP_RECTF_SIZE);

    HRESULT     hResult;
    hResult = stream->Write(&value, sizeof(value), NULL);
    return HResultSuccess(hResult);
}

inline INT
WriteMatrix(
    IStream *           stream,
    const GpMatrix &    value
    )
{
    ASSERT(sizeof(REAL) == GDIP_REAL_SIZE);

    REAL        matrix[6];
    value.GetMatrix(matrix);
    HRESULT     hResult;
    hResult = stream->Write(matrix, GDIP_MATRIX_SIZE, NULL);
    return HResultSuccess(hResult);
}

inline INT
WriteBytes(
    IStream *           stream,
    const VOID *        bytes,
    INT                 count       // number of bytes
    )
{
    ASSERT(sizeof(BYTE) == 1);

    HRESULT     hResult;
    hResult = stream->Write(bytes, count, NULL);
    return HResultSuccess(hResult);
}

inline INT
WritePoints(
    IStream *           stream,
    const GpPointF *    points,
    INT                 count
    )
{
    ASSERT(sizeof(GpPointF) == GDIP_POINTF_SIZE);

    HRESULT     hResult;
    hResult = stream->Write(points, sizeof(GpPointF) * count, NULL);
    return HResultSuccess(hResult);
}

inline INT
WriteRects(
    IStream *           stream,
    const GpRectF *     rects,
    INT                 count
    )
{
    ASSERT(sizeof(GpRectF) == GDIP_RECTF_SIZE);

    HRESULT     hResult;
    hResult = stream->Write(rects, sizeof(GpRectF) * count, NULL);
    return HResultSuccess(hResult);
}

GpPointF *
GetPointsForPlayback(
    const BYTE *            pointData,
    UINT                    pointDataSize,
    INT                     count,
    INT                     flags,
    UINT                    bufferSize,
    BYTE *                  buffer,
    BYTE * &                allocedBuffer
    );

GpRectF *
GetRectsForPlayback(
    BYTE *                  rectData,
    UINT                    rectDataSize,
    INT                     count,
    INT                     flags,
    UINT                    bufferSize,
    BYTE *                  buffer,
    BYTE * &                allocedBuffer
    );

#define GDIP_POINTDATA_BUFFERSIZE   64  // Number of points for the PointBuffer
class MetafilePointData
{
public:
    MetafilePointData(const GpPointF * points, INT count);
    ~MetafilePointData() { delete [] AllocedPoints; }
    INT WriteData(IStream * stream) const { return WriteBytes(stream, PointData, PointDataSize); }
    BYTE * GetData() const { return PointData; }
    INT GetDataSize() const { return PointDataSize; }
    INT GetFlags() const { return Flags; }

protected:
    /**************************************************************************\
    *
    * Function Description:
    *
    *   Determine if a GpPointF is equal to a GpPoint16 (within the tolerance).
    *
    * Arguments:
    *
    *   [IN]  point16 - the 16-bit integer point
    *   [IN]  point   - the REAL point
    *
    * Return Value:
    *
    *   BOOL - whether or not the points are equal
    *
    * Created:
    *
    *   6/15/1999 DCurtis
    *
    \**************************************************************************/
    BOOL
    IsPoint16Equal(
        const GpPoint16 *   point16,
        const GpPointF *    point
        )
    {
        REAL    dx = point->X - (REAL)(point16->X);
        REAL    dy = point->Y - (REAL)(point16->Y);

        return ((dx > -REAL_TOLERANCE) && (dx < REAL_TOLERANCE) &&
                (dy > -REAL_TOLERANCE) && (dy < REAL_TOLERANCE));
    }

protected:
    GpPoint16       PointBuffer[GDIP_POINTDATA_BUFFERSIZE];
    BYTE *          PointData;
    GpPoint16 *     AllocedPoints;
    INT             PointDataSize;
    INT             Flags;
};

#define GDIP_RECTDATA_BUFFERSIZE    16  // Number of rects for the RectBuffer
class MetafileRectData
{
public:
    MetafileRectData(const GpRectF * rects, INT count);
    ~MetafileRectData() { delete [] AllocedRects; }
    INT WriteData(IStream * stream) const { return WriteBytes(stream, RectData, RectDataSize); }
    BYTE * GetData() const { return RectData; }
    INT GetDataSize() const { return RectDataSize; }
    INT GetFlags() const { return Flags; }

protected:
    /**************************************************************************\
    *
    * Function Description:
    *
    *   Determine if a GpRectF is equal to a GpRect16 (within the toleranc).
    *
    * Arguments:
    *
    *   [IN]  rect16 - the 16-bit integer rect
    *   [IN]  rect   - the REAL rect
    *
    * Return Value:
    *
    *   BOOL - whether or not the rects are equal
    *
    * Created:
    *
    *   6/15/1999 DCurtis
    *
    \**************************************************************************/
    BOOL
    IsRect16Equal(
        const GpRect16 *    rect16,
        const GpRectF *     rect
        )
    {
        REAL    dx = rect->X      - static_cast<REAL>(rect16->X);
        REAL    dy = rect->Y      - static_cast<REAL>(rect16->Y);
        REAL    dw = rect->Width  - static_cast<REAL>(rect16->Width);
        REAL    dh = rect->Height - static_cast<REAL>(rect16->Height);

        return ((dx > -REAL_TOLERANCE) && (dx < REAL_TOLERANCE) &&
                (dy > -REAL_TOLERANCE) && (dy < REAL_TOLERANCE) &&
                (dw > -REAL_TOLERANCE) && (dw < REAL_TOLERANCE) &&
                (dh > -REAL_TOLERANCE) && (dh < REAL_TOLERANCE));
    }

protected:
    GpRect16        RectBuffer[GDIP_RECTDATA_BUFFERSIZE];
    BYTE *          RectData;
    GpRect16 *      AllocedRects;
    INT             RectDataSize;
    INT             Flags;
};

class IMetafileRecord
{
public:
    virtual ~IMetafileRecord() {}

    virtual VOID GetMetafileBounds(GpRect & metafileBounds) const = 0;

    // Record methods to be called only from API classes

    // This is for backward compatiblity.  If we are using a new object
    // (such as a new kind of brush), then we can record a backup object
    // for down-level apps to use when they see a new object that they
    // don't know how to deal with.
    virtual GpStatus
    RecordBackupObject(
        const GpObject *            object
        ) = 0;

    virtual GpStatus
    RecordClear(
        const GpRectF *             deviceBounds,
        GpColor                     color
        ) = 0;
    virtual GpStatus
    RecordFillRects(
        const GpRectF *             deviceBounds,
        GpBrush *                   brush,
        const GpRectF *             rects,
        INT                         count
        ) = 0;
    virtual GpStatus
    RecordDrawRects(
        const GpRectF *             deviceBounds,
        GpPen *                     pen,
        const GpRectF *             rects,
        INT                         count
        ) = 0;
    virtual GpStatus
    RecordFillPolygon(
        const GpRectF *             deviceBounds,
        GpBrush*                    brush,
        const GpPointF *            points,
        INT                         count,
        GpFillMode                  fillMode
        ) = 0;
    virtual GpStatus
    RecordDrawLines(
        const GpRectF *             deviceBounds,
        GpPen *                     pen,
        const GpPointF *            points,
        INT                         count,
        BOOL                        closed
        ) = 0;
    virtual GpStatus
    RecordFillEllipse(
        const GpRectF *             deviceBounds,
        GpBrush *                   brush,
        const GpRectF &             rect
        ) = 0;
    virtual GpStatus
    RecordDrawEllipse(
        const GpRectF *             deviceBounds,
        GpPen *                     pen,
        const GpRectF &             rect
        ) = 0;
    virtual GpStatus
    RecordFillPie(
        const GpRectF *             deviceBounds,
        GpBrush *                   brush,
        const GpRectF &             rect,
        REAL                        startAngle,
        REAL                        sweepAngle
        ) = 0;
    virtual GpStatus
    RecordDrawPie(
        const GpRectF *             deviceBounds,
        GpPen *                     pen,
        const GpRectF &             rect,
        REAL                        startAngle,
        REAL                        sweepAngle
        ) = 0;
    virtual GpStatus
    RecordDrawArc(
        const GpRectF *             deviceBounds,
        GpPen *                     pen,
        const GpRectF &             rect,
        REAL                        startAngle,
        REAL                        sweepAngle
        ) = 0;
    virtual GpStatus
    RecordFillRegion(
        const GpRectF *             deviceBounds,
        GpBrush *                   brush,
        GpRegion *                  region
        ) = 0;
    virtual GpStatus
    RecordFillPath(
        const GpRectF *             deviceBounds,
        const GpBrush *             brush,
        GpPath *                    path
        ) = 0;
    virtual GpStatus
    RecordDrawPath(
        const GpRectF *             deviceBounds,
        GpPen *                     pen,
        GpPath *                    path
        ) = 0;
    virtual GpStatus
    RecordFillClosedCurve(
        const GpRectF *             deviceBounds,
        GpBrush *                   brush,
        const GpPointF *            points,
        INT                         count,
        REAL                        tension,
        GpFillMode                  fillMode
        ) = 0;
    virtual GpStatus
    RecordDrawClosedCurve(
        const GpRectF *             deviceBounds,
        GpPen *                     pen,
        const GpPointF *            points,
        INT                         count,
        REAL                        tension
        ) = 0;
    virtual GpStatus
    RecordDrawCurve(
        const GpRectF *             deviceBounds,
        GpPen *                     pen,
        const GpPointF *            points,
        INT                         count,
        REAL                        tension,
        INT                         offset,
        INT                         numberOfSegments
        ) = 0;
    virtual GpStatus
    RecordDrawBeziers(
        const GpRectF *             deviceBounds,
        GpPen *                     pen,
        const GpPointF *            points,
        INT                         count
        ) = 0;
    virtual GpStatus
    RecordDrawImage(
        const GpRectF *             deviceBounds,
        const GpImage *             image,
        const GpRectF &             destRect,
        const GpRectF &             srcRect,
        GpPageUnit                  srcUnit,
        const GpImageAttributes *         imageAttributes
        ) = 0;
    virtual GpStatus
    RecordDrawImage(
        const GpRectF *             deviceBounds,
        const GpImage *             image,
        const GpPointF *            destPoints,
        INT                         count,
        const GpRectF &             srcRect,
        GpPageUnit                  srcUnit,
        const GpImageAttributes *         imageAttributes
        ) = 0;
    virtual GpStatus
    RecordDrawString(
        const GpRectF *             deviceBounds,
        const WCHAR                *string,
        INT                         length,
        const GpFont               *font,
        const RectF                *layoutRect,
        const GpStringFormat       *format,
        const GpBrush              *brush
        ) = 0;
    virtual GpStatus
    RecordDrawDriverString(
        const GpRectF               *deviceBounds,
        const UINT16                *text,
        INT                         glyphCount,
        const GpFont                *font,
        const GpBrush               *brush,
        const PointF                *positions,
        INT                         flags,
        const GpMatrix              *matrix
        ) = 0;

    virtual GpStatus
    RecordSave(
        INT                         gstate
        ) = 0;
    virtual GpStatus
    RecordRestore(
        INT                         gstate
        ) = 0;
    virtual GpStatus
    RecordBeginContainer(
        const GpRectF &             destRect,
        const GpRectF &             srcRect,
        GpPageUnit                  srcUnit,
        INT                         containerState
        ) = 0;
    virtual GpStatus
    RecordBeginContainer(
        INT                         containerState
        ) = 0;
    virtual GpStatus
    RecordEndContainer(
        INT                         containerState
        ) = 0;
    virtual GpStatus
    RecordSetWorldTransform(
        const GpMatrix &            matrix
        ) = 0;
    virtual GpStatus
    RecordResetWorldTransform() = 0;
    virtual GpStatus
    RecordMultiplyWorldTransform(
        const GpMatrix &            matrix,
        GpMatrixOrder               order
        ) = 0;
    virtual GpStatus
    RecordTranslateWorldTransform(
        REAL                        dx,
        REAL                        dy,
        GpMatrixOrder               order
        ) = 0;
    virtual GpStatus
    RecordScaleWorldTransform(
        REAL                        sx,
        REAL                        sy,
        GpMatrixOrder               order
        ) = 0;
    virtual GpStatus
    RecordRotateWorldTransform(
        REAL                        angle,
        GpMatrixOrder               order
        ) = 0;
    virtual GpStatus
    RecordSetPageTransform(
        GpPageUnit                  unit,
        REAL                        scale
        ) = 0;
    virtual GpStatus
    RecordResetClip() = 0;
    virtual GpStatus
    RecordSetClip(
        const GpRectF &             rect,
        CombineMode                 combineMode
        ) = 0;
    virtual GpStatus
    RecordSetClip(
        GpRegion *                  region,
        CombineMode                 combineMode
        ) = 0;
    virtual GpStatus
    RecordSetClip(
        GpPath *                    path,
        CombineMode                 combineMode,
        BOOL                        isDevicePath
        ) = 0;
    virtual GpStatus
    RecordOffsetClip(
        REAL                        dx,
        REAL                        dy
        ) = 0;
    virtual GpStatus
    RecordGetDC() = 0;
    virtual GpStatus
    RecordSetAntiAliasMode(
        BOOL                        newMode
        ) = 0;
    virtual GpStatus
    RecordSetTextRenderingHint(
        TextRenderingHint           newMode
        ) = 0;
    virtual GpStatus
    RecordSetTextContrast(
        UINT                        gammaValue
        ) = 0;
    virtual GpStatus
    RecordSetInterpolationMode(
        InterpolationMode           newMode
        ) = 0;
    virtual GpStatus
    RecordSetPixelOffsetMode(
        PixelOffsetMode             newMode
        ) = 0;
    virtual GpStatus
    RecordSetCompositingMode(
        GpCompositingMode           newMode
        ) = 0;
    virtual GpStatus
    RecordSetCompositingQuality(
        GpCompositingQuality        newQuality
        ) = 0;

    virtual GpStatus
    RecordSetRenderingOrigin(
        INT x,
        INT y
    ) = 0;

    virtual GpStatus
    RecordComment(
        UINT            sizeData,
        const BYTE *    data
        ) = 0;
    virtual VOID EndRecording() = 0;
};

class GpMetafile : public GpImage
{
friend class GpGraphics;            // so graphics can call Play
friend class MetafileRecorder;      // to write Header when recording
friend class MetafilePlayer;
friend class GpObject;              // for empty constructor
public:
    // Constructors for playback only
    GpMetafile(HMETAFILE hWmf, 
               const WmfPlaceableFileHeader * wmfPlaceableFileHeader,
               BOOL deleteWmf);
    GpMetafile(HENHMETAFILE hEmf, BOOL deleteEmf);
    GpMetafile(const WCHAR* filename,
               const WmfPlaceableFileHeader * wmfPlaceableFileHeader = NULL);
    GpMetafile(IStream* stream);    // this requires an extra copy

    // Constructors for recording followed (optionally) by playback
    GpMetafile(
        HDC                 referenceHdc,
        EmfType             type        = EmfTypeEmfPlusDual,
        const GpRectF *     frameRect   = NULL,
        MetafileFrameUnit   frameUnit   = MetafileFrameUnitGdi,
        const WCHAR *       description = NULL
        );
    GpMetafile(
        const WCHAR*        fileName,
        HDC                 referenceHdc,
        EmfType             type        = EmfTypeEmfPlusDual,
        const GpRectF *     frameRect   = NULL,
        MetafileFrameUnit   frameUnit   = MetafileFrameUnitGdi,
        const WCHAR *       description = NULL
        );
    GpMetafile(                     // this requires an extra copy
        IStream*            stream,
        HDC                 referenceHdc,
        EmfType             type        = EmfTypeEmfPlusDual,
        const GpRectF *     frameRect   = NULL,
        MetafileFrameUnit   frameUnit   = MetafileFrameUnitGdi,
        const WCHAR *       description = NULL
        );

    // Make a copy of the image object
    virtual GpImage* Clone() const;

    virtual GpImage* CloneColorAdjusted(
        GpRecolor *             recolor,
        ColorAdjustType         adjustType = ColorAdjustTypeDefault
        ) const;

    // Dispose of the image object
    virtual VOID Dispose();

    // Derive a graphics context to draw into the GpImage object
    virtual GpGraphics* GetGraphicsContext();

    // When deleting the metafile, we have to lock the graphics, so
    // no one can use the graphics while the metafile is being deleted --
    // so we need a private method to get the graphics just for that purpose.

    // Also, when setting the down-level rasterization limit, we have to
    // make sure the graphics is locked as well as the metafile, so we
    // use this method for that too.
    GpGraphics* PrivateAPIForGettingMetafileGraphicsContext() const
    {
        // If they haven't requested the graphics, then we don't need
        // to worry about locking it.
        return (RequestedMetaGraphics) ? MetaGraphics : NULL;
    }

    // Check if the GpImage object is valid
    virtual BOOL IsValid() const
    {
        // If the metafile came from a different version of GDI+, its tag
        // will not match, and it won't be considered valid.
        return ((State >= RecordingMetafileState) &&
                (State <= PlayingMetafileState) &&
                GpImage::IsValid());
    }

    virtual BOOL IsCorrupted() const
    {
        return (State == CorruptedMetafileState);
    }

    VOID
    GetHeader(
        MetafileHeader &    header
        ) const
    {
        ASSERT(IsValid());
        header = Header;
    }

    // Is this an EMF or EMF+ file?
    BOOL IsEmfOrEmfPlus() const { return Header.IsEmfOrEmfPlus(); }

    GpStatus GetHemf(HENHMETAFILE *  hEmf) const;

    GpStatus PlayRecord(
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize,
        const BYTE *            data
        ) const;

    VOID SetThreadId(DWORD threadId) const { ThreadId = threadId; }
    DWORD GetThreadId() const { return ThreadId; }

    // Create a bitmap and play the metafile into it.
    GpBitmap *
    GetBitmap(
        INT                 width           = 0,    // 0 means figure use default size
        INT                 height          = 0,
        const GpImageAttributes * imageAttributes = NULL
        );

    ////////////////////////////////////////////////////////////
    // GpObject virtual methods
    ////////////////////////////////////////////////////////////

    virtual UINT GetDataSize() const;
    virtual GpStatus GetData(IStream * stream) const;
    virtual GpStatus SetData(const BYTE * dataBuffer, UINT size);

    virtual GpStatus ColorAdjust(
        GpRecolor *             recolor,
        ColorAdjustType         adjustType
        );

    ////////////////////////////////////////////////////////////
    // GpImage virtual methods
    ////////////////////////////////////////////////////////////


    // Get metafile resolution

    virtual GpStatus
    GetResolution(
        REAL* xdpi,
        REAL* ydpi
    ) const
    {
        ASSERT(IsValid());

        *xdpi = Header.GetDpiX();
        *ydpi = Header.GetDpiY();

        return Ok;
    }

    // Get metafile physical dimension in 0.01mm units
    virtual GpStatus
    GetPhysicalDimension(
        REAL* width,
        REAL* height
    ) const
    {
        ASSERT(IsValid());

        const MetafileHeader *      header = &Header;

        if (header->IsEmfOrEmfPlus())
        {
            // Don't forget to add one Device Unit
            *width  = (REAL)(header->EmfHeader.rclFrame.right -
                             header->EmfHeader.rclFrame.left) + 
                             2540.0f / (header->GetDpiX());
            *height = (REAL)(header->EmfHeader.rclFrame.bottom -
                             header->EmfHeader.rclFrame.top) +
                             2540.0f / (header->GetDpiY());
        }
        else
        {
            *width  = ((REAL)(header->Width)  / (header->GetDpiX())) * 2540.0f;
            *height = ((REAL)(header->Height) / (header->GetDpiY())) * 2540.0f;
        }

        return Ok;
    }

    // Get metafile bounding rectangle in pixels
    virtual GpStatus
    GetBounds(
        GpRectF* rect,
        GpPageUnit* unit
    ) const
    {
        ASSERT(IsValid());

        const MetafileHeader *      header = &Header;

#if 0
        if (header->IsEmfOrEmfPlus())
        {
            rect->X      = (REAL)(header->EmfHeader.rclFrame.left) / 2540.0f;
            rect->Y      = (REAL)(header->EmfHeader.rclFrame.top)  / 2540.0f;
            rect->Width  = (REAL)(header->EmfHeader.rclFrame.right -
                                  header->EmfHeader.rclFrame.left) / 2540.0f;
            rect->Height = (REAL)(header->EmfHeader.rclFrame.bottom -
                                  header->EmfHeader.rclFrame.top)  / 2540.0f;
        }
        else
        {
            rect->X      = header->X      / header->GetDpiX();
            rect->Width  = header->Width  / header->GetDpiX();
            rect->Y      = header->Y      / header->GetDpiY();
            rect->Height = header->Height / header->GetDpiY();
        }
        *unit = UnitInch;
#else
        rect->X      = (REAL)header->X;
        rect->Width  = (REAL)header->Width;
        rect->Y      = (REAL)header->Y;
        rect->Height = (REAL)header->Height;
        *unit = UnitPixel;
#endif

        return Ok;
    }

    virtual GpStatus GetImageInfo(ImageInfo* imageInfo) const;

    virtual GpImage* GetThumbnail(UINT thumbWidth, UINT thumbHeight,
                         GetThumbnailImageAbort callback, VOID *callbackData)
    {
        if ((thumbWidth == 0) && (thumbHeight == 0))
        {
            thumbWidth = thumbHeight = DEFAULT_THUMBNAIL_SIZE;
        }
        if ((thumbWidth > 0) && (thumbHeight > 0))
        {
            return this->GetBitmap(thumbWidth, thumbHeight);
        }
        return NULL;
    }

    virtual GpStatus GetPalette(ColorPalette *palette, INT size)
    {
        return NotImplemented;  // There is no palette support for metafiles
    }

    virtual GpStatus SetPalette(ColorPalette *palette)
    {
        return NotImplemented;
    }

    virtual INT GetPaletteSize() { return 0; }

    // Save images
    // !!!TODO: save functionality?

    virtual GpStatus
    GetEncoderParameterListSize(
        CLSID* clsidEncoder,
        UINT* size
        )
    {
        // Create a new temp bitmap to query
        GpStatus status = OutOfMemory;
        GpBitmap *bitmap = new GpBitmap(1, 1, PixelFormat32bppARGB);
        if (bitmap != NULL)
        {
            if (bitmap->IsValid())
            {
                status = bitmap->GetEncoderParameterListSize(clsidEncoder, size);
            }
            bitmap->Dispose();
        }
        return status;
    }

    virtual GpStatus
    GetEncoderParameterList(
        CLSID* clsidEncoder,
        UINT size,
        EncoderParameters* pBuffer
        )
    {
        GpStatus status = OutOfMemory;
        GpBitmap *bitmap = new GpBitmap(1, 1, PixelFormat32bppARGB);
        if (bitmap != NULL)
        {
            if (bitmap->IsValid())
            {
                status = bitmap->GetEncoderParameterList(clsidEncoder, size, pBuffer);
            }
            bitmap->Dispose();
        }
        return status;
    }

    virtual GpStatus
    SaveToStream(
        IStream* stream,
        CLSID* clsidEncoder,
        EncoderParameters* encoderParams
        )
    {
        GpStatus status = GenericError;
        GpBitmap *bitmap = GetBitmap();
        if (bitmap != NULL)
        {
            status = bitmap->SaveToStream(stream, clsidEncoder, encoderParams);
            bitmap->Dispose();
        }
        return status;
    }

    virtual GpStatus
    SaveToFile(
        const WCHAR* filename,
        CLSID* clsidEncoder,
        EncoderParameters* encoderParams
        )
    {
        GpStatus status = GenericError;
        GpBitmap *bitmap = GetBitmap();
        if (bitmap != NULL)
        {
            status = bitmap->SaveToFile(filename, clsidEncoder, encoderParams);
            bitmap->Dispose();
        }
        return status;
    }

    GpStatus
    SaveAdd(
        const EncoderParameters* encoderParams
        )
    {
        return NotImplemented;
    }

    GpStatus
    SaveAdd(
        GpImage* newBits,
        const EncoderParameters* encoderParams
        )
    {
        return NotImplemented;
    }

    // !!!TODO: what do I do with the dimensionID?
    virtual GpStatus GetFrameCount(const GUID* dimensionID, UINT* count) const
    {
        if (count != NULL)
        {
            *count = 1;
            return Ok;
        }
        return InvalidParameter;
    }

    virtual GpStatus GetFrameDimensionsCount(OUT UINT* count) const
    {
        if (count != NULL)
        {
            *count = 1;
            return Ok;
        }
        return InvalidParameter;
    }

    virtual GpStatus GetFrameDimensionsList(OUT GUID* dimensionIDs,
                                            IN UINT count) const
    {
        // Note: the "count" has to be 1
        if ((count == 1) && (dimensionIDs != NULL))
        {
            dimensionIDs[0] = FRAMEDIM_PAGE;
            return Ok;
        }
        return InvalidParameter;
    }

    virtual GpStatus SelectActiveFrame(const GUID* dimensionID, UINT index)
    {
        // There is only 1 frame in a metafile, so we always succeed
        return Ok;
    }

    virtual GpStatus RotateFlip(RotateFlipType rfType)
    {
        return NotImplemented;
    }

    virtual GpStatus GetPropertyCount(UINT* numOfProperty)
    {
        if (numOfProperty != NULL)
        {
            *numOfProperty = 0;
            return Ok;
        }
        return InvalidParameter;
    }

    virtual GpStatus GetPropertyIdList(UINT numOfProperty, PROPID* list)
    {
        if (list != NULL)
        {
            return NotImplemented;
        }
        return InvalidParameter;
    }

    virtual GpStatus GetPropertyItemSize(PROPID propId, UINT* size)
    {
        if (size != NULL)
        {
            return NotImplemented;
        }
        return InvalidParameter;
    }

    virtual GpStatus GetPropertyItem(PROPID propId,UINT propSize, PropertyItem* buffer)
    {
        if (buffer != NULL)
        {
            return NotImplemented;
        }
        return InvalidParameter;
    }

    virtual GpStatus GetPropertySize(UINT* totalBufferSize, UINT* numProperties)
    {
        if ((totalBufferSize != NULL) && (numProperties != NULL))
        {
            return NotImplemented;
        }
        return InvalidParameter;
    }

    virtual GpStatus GetAllPropertyItems(UINT totalBufferSize, UINT numProperties,
                                 PropertyItem* allItems)
    {
        if (allItems != NULL)
        {
            return NotImplemented;
        }
        return InvalidParameter;
    }

    virtual GpStatus RemovePropertyItem(PROPID propId)
    {
        return NotImplemented;
    }

    virtual GpStatus SetPropertyItem(PropertyItem* item)
    {
        return NotImplemented;
    }

    GpStatus
    SetDownLevelRasterizationLimit(
        UINT                    metafileRasterizationLimitDpi
        );

    GpStatus
    GetDownLevelRasterizationLimit(
        UINT *                  metafileRasterizationLimitDpi
        ) const;

protected:
    enum MetafileState
    {
        InvalidMetafileState,
        CorruptedMetafileState,
        RecordingMetafileState,
        DoneRecordingMetafileState,
        ReadyToPlayMetafileState,
        PlayingMetafileState,
    };
    MetafileHeader              Header;
    mutable DWORD               ThreadId;       // for syncing enumeration
    mutable MetafileState       State;
    mutable HENHMETAFILE        Hemf;           // for playing metafiles
    WCHAR *                     Filename;
    IStream *                   Stream;
    GpGraphics *                MetaGraphics;   // for recording to metafile
    mutable MetafilePlayer *    Player;         // for playing the metafile
    INT                         MaxStackSize;
    BOOL                        DeleteHemf;
    BOOL                        RequestedMetaGraphics;

    // Dummy constructors and destructors to prevent
    // apps from directly using new and delete operators
    // on GpImage objects.

    GpMetafile() : GpImage(ImageTypeMetafile) { /* used by object factory */ InitDefaults(); }
    ~GpMetafile();

    VOID InitDefaults();
    VOID CleanUp();

    BOOL
    InitForRecording(
        HDC                 referenceHdc,
        EmfType             type,
        const GpRectF *     frameRect,      // can be NULL
        MetafileFrameUnit   frameUnit,      // if NULL frameRect, doesn't matter
        const WCHAR *       description     // can be NULL
        );

    GpStatus
    PrepareToPlay(
        GpGraphics *            g,
        GpRecolor *             recolor,
        ColorAdjustType         adjustType,
        EnumerateMetafileProc   enumerateCallback,
        VOID *                  callbackData,
        DrawImageAbort          drawImageCallback,
        VOID*                   drawImageCallbackData
        ) const;

    GpStatus
    EnumerateForPlayback(
        const RectF &           destRect,
        const RectF &           srcRect,
        Unit                    srcUnit,
        GpGraphics *            g,
        EnumerateMetafileProc   callback,   // if null, just play the metafile
        VOID *                  callbackData,
        GpRecolor *             recolor               = NULL,
        ColorAdjustType         adjustType            = ColorAdjustTypeDefault,
        DrawImageAbort          drawImageCallback     = NULL,
        VOID*                   drawImageCallbackData = NULL
        ) const;

    // Play is only to be called by GpGraphics::DrawImage()
    GpStatus
    Play(
        const GpRectF&          destRect,
        const GpRectF&          srcRect,
        GpPageUnit              srcUnit,
        GpGraphics *            graphics,
        GpRecolor *             recolor               = NULL,
        ColorAdjustType         adjustType            = ColorAdjustTypeDefault,
        DrawImageAbort          drawImageCallback     = NULL,
        VOID*                   drawImageCallbackData = NULL
        ) const
    {
        return EnumerateForPlayback(
                    destRect,
                    srcRect,
                    srcUnit,
                    graphics,
                    NULL,
                    NULL,
                    recolor,
                    adjustType,
                    drawImageCallback,
                    drawImageCallbackData
                    );
    }

    VOID
    InitWmf(
        HMETAFILE                        hWmf,
        const WmfPlaceableFileHeader *   wmfPlaceableFileHeader,
        BOOL                             deleteWmf
        );

    VOID
    InitEmf(
        HENHMETAFILE                     hEmf,
        BOOL                             deleteEmf
        );                      
                                
    VOID                        
    InitStream(                 
        IStream*                         stream,
        BOOL                             tryWmfOnly = FALSE
        );
};




HENHMETAFILE
GetEmf(
    const WCHAR *       fileName,
    MetafileType        type
    );


// GillesK 05/12/2000
// Data types needed for WMF to EMF conversion.
#pragma pack(2)

typedef struct _META_ESCAPE_ENHANCED_METAFILE {
    DWORD       rdSize;             // Size of the record in words
    WORD        rdFunction;         // META_ESCAPE
    WORD        wEscape;            // MFCOMMENT
    WORD        wCount;             // Size of the following data + emf in bytes
    DWORD       ident;              // MFCOMMENT_IDENTIFIER
    DWORD       iComment;           // MFCOMMENT_ENHANCED_METAFILE
    DWORD       nVersion;           // Enhanced metafile version 0x10000
    WORD        wChecksum;          // Checksum - used by 1st record only
    DWORD       fFlags;             // Compression etc - used by 1st record only
    DWORD       nCommentRecords;    // Number of records making up the emf
    DWORD       cbCurrent;          // Size of emf data in this record in bytes
    DWORD       cbRemainder;        // Size of remainder in following records
    DWORD       cbEnhMetaFile;      // Size of enhanced metafile in bytes
                                    // The enhanced metafile data follows here
} META_ESCAPE_ENHANCED_METAFILE;
typedef META_ESCAPE_ENHANCED_METAFILE UNALIGNED *PMETA_ESCAPE_ENHANCED_METAFILE;
#pragma pack()

// Macro to check that it is a meta_escape embedded enhanced metafile record.

inline BOOL IsMetaEscapeEnhancedMetafile(
    PMETA_ESCAPE_ENHANCED_METAFILE pmfeEnhMF
    )
{
        return ((pmfeEnhMF)->rdFunction == META_ESCAPE
      && (pmfeEnhMF)->rdSize     >  sizeof(META_ESCAPE_ENHANCED_METAFILE) / 2
      && (pmfeEnhMF)->wEscape    == MFCOMMENT
      && (pmfeEnhMF)->ident      == MFCOMMENT_IDENTIFIER
      && (pmfeEnhMF)->iComment   == MFCOMMENT_ENHANCED_METAFILE) ;
}

// Macro to check the checksum of an EMF file

inline WORD GetWordCheckSum(UINT cbData, PWORD pwData)
{
    WORD   wCheckSum = 0;
    UINT   cwData = cbData / sizeof(WORD);

    ASSERTMSG(!(cbData%sizeof(WORD)), ("GetWordCheckSum data not WORD multiple"));
    ASSERTMSG(!((ULONG_PTR)pwData%sizeof(WORD)), ("GetWordCheckSum data not WORD aligned"));

    while (cwData--)
        wCheckSum += *pwData++;

    return(wCheckSum);
}

extern "C"
UINT ConvertEmfToPlaceableWmf
(   HENHMETAFILE hemf,
    UINT         cbData16,
    LPBYTE       pData16,
    INT          iMapMode,
    INT          eFlags );





#endif // !_METAFILE_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\iterator.hpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Iterator definitions.
*
* Abstract:
*
*   Describes a general iterator interface.
*
* Created:
*
*   09/01/2000 asecchia
*      Created it.
*
**************************************************************************/

#ifndef _ITERATOR_HPP
#define _ITERATOR_HPP

/**************************************************************************\
*
* Class Description:
*
*    This is an interface for a general list iterator.
*    See Design Patterns (Erich Gamma, et al) pp 257 ITERATOR pattern.
*
* Interface:
*    SeekFirst()     - set the current pointer (CP) to the beginning of the list
*    SeekLast()      - set CP to the end of the list.
*    CurrentItem()   - return a pointer to the current item.
*    CurrentIndex()  - return the value of CP (index into the array)
*    Next()          - advance CP by one element
*    Prev()          - rewind CP by one element
*    IsDone()        - are we beyond either end of the list.
*
* History:
*
*   09/01/2000 asecchia   created it
*
\**************************************************************************/

template<class T>
class GpIterator
{
public:
    virtual void SeekFirst() = 0;         
    virtual void SeekLast() = 0;
    virtual T *CurrentItem() const = 0;
    virtual INT CurrentIndex() const = 0;
    virtual void Next() = 0;
    virtual void Prev() = 0;
    virtual BOOL IsDone() = 0;
    
    // Used for our debug tracking. Make all GpIterator objects allocated using
    // the default new operator have an appropriate tag.
    // Most often, however, iterators will be stack allocations.
    
    void *(operator new)(size_t in_size)
    {
       return ::operator new (in_size, GpIteratorTag, FALSE);
    }
    
    void *(operator new[])(size_t in_size)
    {
       return ::operator new[] (in_size, GpIteratorTag, FALSE);
    }

};

/**************************************************************************\
*
* Class Description:
*
*    This is a PROXY iterator that adds the behaviour of 
*    wrapping the list when the end is encountered.
* 
*    See Design Patterns (Erich Gamma, et al) pp 207 for the 
*    definition of a PROXY 
*
* Interface:
*    ... see GpIterator ...
*    IsDone()        - private - unimplemented. Not meaningful for 
*                      circular lists
*
* History:
*
*   09/01/2000 asecchia   created it
*
\**************************************************************************/

template<class T>
class GpCircularIterator : public GpIterator<T>
{
    GpIterator<T> *iterator;
public:
    GpCircularIterator(GpIterator<T> *_iterator)
    {
        iterator = _iterator;
    }
    
    virtual void SeekFirst()
    {
        iterator->SeekFirst();
    }
    
    virtual void SeekLast()
    {
        iterator->SeekLast();
    }
    
    virtual void Next()
    {
        ASSERT(!iterator->IsDone());
        
        iterator->Next();
        if(iterator->IsDone())
        {
            iterator->SeekFirst();
        }
    }
    
    virtual void Prev()
    {
        ASSERT(!iterator->IsDone());
        
        iterator->Prev();
        if(iterator->IsDone())
        {
            iterator->SeekLast();
        }
    }
    virtual T *CurrentItem() const
    {
        return iterator->CurrentItem();
    }
    
    virtual INT CurrentIndex() const
    {
        return iterator->CurrentIndex();
    }
    
private:

    // It's not meaningful to call IsDone on a circular iterator.
    
    virtual BOOL IsDone() {
        ASSERT(FALSE);
        return FALSE;
    }
};

/**************************************************************************\
*
* Class Description:
*
*    This is a PROXY iterator that modifies the behaviour of the 
*    underlying iterator by making it traverse the list backwards.
*
* Interface:
*    ... see GpIterator ...
*
*    Note the sense of the following interfaces is reversed.
*
*    SeekFirst()     - Call proxy SeekLast()
*    SeekLast()      - Call proxy SeekFirst()
*    Next()          - Call proxy Prev()
*    Prev()          - Call proxy Next()
*
* History:
*
*   09/01/2000 asecchia   created it
*
\**************************************************************************/

template<class T>
class GpReverseIterator : public GpIterator<T>
{
    GpIterator<T> *iterator;
    
public:
    GpReverseIterator(GpIterator<T> *_iterator)
    {
        iterator = _iterator;
    }
    
    virtual GpIterator<T> *GetIterator()
    {
        return iterator;
    }
    
    virtual void SeekFirst()
    {
        iterator->SeekLast();
    }
    
    virtual void SeekLast()
    {
        iterator->SeekFirst();
    }
    
    virtual void Next()
    {
        iterator->Prev();
    }
    
    virtual void Prev()
    {
        iterator->Next();
    }
    
    virtual T *CurrentItem() const
    {
        return iterator->CurrentItem();
    }
    
    virtual INT CurrentIndex() const
    {
        return iterator->CurrentIndex();
    }
    
    virtual BOOL IsDone() 
    {
        return iterator->IsDone();
    }
};

/**************************************************************************\
*
* Class Description:
*
*    This is a concrete iterator for an arbitrary C array of objects
*    The constructor takes the array pointer and the number of elements
*    and the iterator is constructed to traverse the elements in the
*    standard (forward) direction.
*
* Interface:
*    ... see GpIterator ...
*
* History:
*
*   09/01/2000 asecchia   created it
*
\**************************************************************************/

template<class T>
class GpArrayIterator : public GpIterator<T>
{
public:
    GpArrayIterator(T *array, INT count)
    {
        Array = array;
        Count = count;
        SeekFirst();
    }
    
    virtual void SeekFirst() 
    { 
        CurrentItemPosition = 0; 
    }
    
    virtual void SeekLast() 
    { 
        CurrentItemPosition = Count-1; 
    }
    
    virtual T *CurrentItem() const
    {
        ASSERT(CurrentItemPosition >= 0);
        ASSERT(CurrentItemPosition < Count);
        
        return Array+CurrentItemPosition;
    }
    
    virtual INT CurrentIndex() const
    {
        return CurrentItemPosition;
    }
    
    virtual void Next()
    {
        CurrentItemPosition++;
    }
    
    virtual void Prev()
    {
        CurrentItemPosition--;
    }
    
    virtual BOOL IsDone()
    {
        return (CurrentItemPosition < 0 || 
                CurrentItemPosition >= Count);
    }
    
private:
    T *Array;
    INT Count;
    
    // Internal State
    INT CurrentItemPosition;
};


/**************************************************************************\
*
* Class Description:
*
*    This is a concrete iterator for a set of path points.
*    Path points are defined by an array of GpPointFs and an array
*    of BYTEs representing the point types. Both arrays are of size
*    count and have to be kept in step with each other.
*
* Interface:
*    ... see GpIterator ...
*
*    We extend the interface with this class by defining the 
*    point array to be the primary sub iterator and providing
*    a CurrentType() method to return the current item in the 
*    type array.
*
* History:
*
*   09/03/2000 asecchia   created it
*
\**************************************************************************/

class GpPathPointIterator : public GpIterator<GpPointF>
{
public:
    GpPathPointIterator(GpPointF *points, BYTE *types, INT count) : 
        _points(points, count),
        _types(types, count)
    {
        SeekFirst();
    }
    virtual void SeekFirst() 
    { 
        _points.SeekFirst();
        _types.SeekFirst();
    }
    
    virtual void SeekLast() 
    { 
        _points.SeekLast();
        _types.SeekLast();
    }
    
    virtual GpPointF *CurrentItem() const
    {
        return _points.CurrentItem();
    }
    
    virtual BYTE *CurrentType() const
    {
        return _types.CurrentItem();
    }
    
    virtual INT CurrentIndex() const
    {
        return _points.CurrentIndex();
    }
    
    virtual void Next()
    {
        _points.Next();
        _types.Next();   
    }
    
    virtual void Prev()
    {
        _points.Prev();
        _types.Prev();
    }
    
    virtual BOOL IsDone()
    {
        return _points.IsDone();
    }
    
private:
    GpArrayIterator<GpPointF> _points;
    GpArrayIterator<BYTE> _types;
};

/**************************************************************************\
*
* Class Description:
*
*    This is a PROXY iterator for a GpPathPointIterator that advances
*    the base GpPathPointIterator to the next subpath defined by the 
*    start marker in the types array.
*
* Interface:
*    ... see GpIterator ...
*
* History:
*
*   09/03/2000 asecchia   created it
*
\**************************************************************************/

class GpSubpathIterator : public GpIterator<GpPointF>
{
public:
    GpSubpathIterator(GpPathPointIterator *iterator)
    {
        _iterator = iterator;
    }
    
    virtual void SeekFirst() 
    {
        _iterator->SeekFirst(); 
    }
    
    virtual void SeekLast()
    { 
        _iterator->SeekLast(); 
    }
    
    virtual GpPointF *CurrentItem() const { return _iterator->CurrentItem(); }
    virtual BYTE *CurrentType() const { return _iterator->CurrentType(); }
    virtual INT CurrentIndex() const { return _iterator->CurrentIndex(); }
    
    virtual void Next() 
    {
        // Call the base _iterator Next() method till either we run out of
        // path or we encounter another PathPointTypeStart marker.
        
        do {
            _iterator->Next(); 
        } while (
            !_iterator->IsDone() && 
            ((*_iterator->CurrentType() & PathPointTypePathTypeMask) != 
                PathPointTypeStart)
        );
    }
    
    virtual void Prev() 
    { 
        // Call the base _iterator Prev() method till either we run out of
        // path or we encounter another PathPointTypeStart marker.
        
        do {
            _iterator->Prev(); 
        } while (
            !_iterator->IsDone() && 
            ((*_iterator->CurrentType() & PathPointTypePathTypeMask) != 
                PathPointTypeStart)
        );
    }
    
    virtual BOOL IsDone() { return _iterator->IsDone(); }
    
private:
    GpPathPointIterator *_iterator;
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\metaplay.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   MetaFile.cpp
*
* Abstract:
*
*   Metafile object handling
*
* Created:
*
*   4/14/1999 DCurtis
*
\**************************************************************************/

#include "precomp.hpp"
#include "MetaWmf.hpp"

#define GDIP_TRANSPARENT_COLOR_KEY  0xAA0D0B0C
#define GDIP_WMF_PLACEABLEKEY       0x9AC6CDD7      // for Placeable WMFs
#define GDIP_DO_CALLBACK_MASK       0x00000003      // when to do callback

// Metafile constants not in Windows.h
#define METAVERSION300              0x0300
#define METAVERSION100              0x0100
#define MEMORYMETAFILE              1
#define DISKMETAFILE                2


typedef VOID (EmfPlusRecordPlay::*PLAYRECORDFUNC)(MetafilePlayer * player, EmfPlusRecordType recordType, UINT flags, UINT dataSize) const;
PLAYRECORDFUNC RecordPlayFuncs[];

/**************************************************************************\
*
* Function Description:
*
*   If the points were stored as 16-bit points, then convert them back to
*   REAL points.  Otherwise, just return convert the point data pointer
*   to a REAL point pointer and return.
*
* Arguments:
*
*   [IN]     pointData     - the point data that was recorded
*   [IN]     count         - the number of points
*   [IN]     flags         - says if the point data is 16-bit points or not
*   [IN]     bufferSize    - the size of the buffer
*   [IN/OUT] buffer        - for converting back to REAL points
*   [IN/OUT] allocedBuffer - if buffer not big enough, alloc new one here
*
* Return Value:
*
*   GpPointF * - the REAL points to play back
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpPointF *
GetPointsForPlayback(
    const BYTE *            pointData,
    UINT                    pointDataSize,
    INT                     count,
    INT                     flags,
    UINT                    bufferSize,
    BYTE *                  buffer,
    BYTE * &                allocedBuffer
    )
{
    GpPointF *      points = NULL;

    if (count > 0)
    {
        if ((flags & GDIP_EPRFLAGS_COMPRESSED) != 0)
        {
            if (pointDataSize >= (sizeof(GpPoint16) * count))
            {
                UINT    sizePoints = count * sizeof(GpPointF);

                if (sizePoints <= bufferSize)
                {
                    points = reinterpret_cast<GpPointF *>(buffer);
                }
                else
                {
                    if ((allocedBuffer = new BYTE[sizePoints]) == NULL)
                    {
                        return NULL;
                    }
                    points = reinterpret_cast<GpPointF *>(allocedBuffer);
                }
                const GpPoint16 *  points16 =
                                    reinterpret_cast<const GpPoint16 *>(pointData);
                do
                {

                    count--;
                    points[count].X = points16[count].X;
                    points[count].Y = points16[count].Y;
                } while (count > 0);
            }
            else
            {
                WARNING(("pointDataSize is too small"));
            }
        }
        else if (pointDataSize >= (sizeof(GpPointF) * count))
        {
            points = (GpPointF *)(pointData);
        }
        else
        {
            WARNING(("pointDataSize is too small"));
        }
    }
    return points;
}

/**************************************************************************\
*
* Function Description:
*
*   If the rects were stored as 16-bit rects, then convert them back to
*   REAL rects.  Otherwise, just return convert the rect data pointer
*   to a REAL rect pointer and return.
*
* Arguments:
*
*   [IN]     rectData      - the rect data that was recorded
*   [IN]     count         - the number of rects
*   [IN]     flags         - says if the point data is 16-bit rects or not
*   [IN]     bufferSize    - the size of the buffer
*   [IN/OUT] buffer        - for converting back to REAL rects
*   [IN/OUT] allocedBuffer - if buffer not big enough, alloc new one here
*
* Return Value:
*
*   GpPointF * - the REAL points to play back
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpRectF *
GetRectsForPlayback(
    const BYTE *            rectData,
    UINT                    rectDataSize,
    INT                     count,
    INT                     flags,
    UINT                    bufferSize,
    BYTE *                  buffer,
    BYTE * &                allocedBuffer
    )
{
    GpRectF *   rects = NULL;

    if (count > 0)
    {
        if ((flags & GDIP_EPRFLAGS_COMPRESSED) != 0)
        {
            if (rectDataSize >= (sizeof(GpRect16) * count))
            {
                UINT    sizeRects = count * sizeof(GpRectF);

                if (sizeRects <= bufferSize)
                {
                    rects = reinterpret_cast<GpRectF *>(buffer);
                }
                else
                {
                    if ((allocedBuffer = new BYTE[sizeRects]) == NULL)
                    {
                        return NULL;
                    }
                    rects = reinterpret_cast<GpRectF *>(allocedBuffer);
                }
                const GpRect16 *  rects16 =
                                    reinterpret_cast<const GpRect16 *>(rectData);
                do
                {

                    count--;
                    rects[count].X      = rects16[count].X;
                    rects[count].Y      = rects16[count].Y;
                    rects[count].Width  = rects16[count].Width;
                    rects[count].Height = rects16[count].Height;
                } while (count > 0);
            }
            else
            {
                WARNING(("rectDataSize is too small"));
            }
        }
        else if (rectDataSize >= (sizeof(GpRectF) * count))
        {
            rects = (GpRectF *)(rectData);
        }
        else
        {
            WARNING(("rectDataSize is too small"));
        }
    }
    return rects;
}

inline INT16
GetWmfPlaceableCheckSum(
    const WmfPlaceableFileHeader *     wmfPlaceableFileHeader
    )
{
    const INT16 * headerWords = (const INT16 *)wmfPlaceableFileHeader;
    INT16         checkSum = *headerWords++;

    for (INT i = 9; i > 0; i--)
    {
        checkSum ^= *headerWords++;
    }
    return checkSum;
}

inline BOOL
WmfPlaceableHeaderIsValid(
    const WmfPlaceableFileHeader *   wmfPlaceableFileHeader
    )
{
    ASSERT(wmfPlaceableFileHeader != NULL);

    return ((wmfPlaceableFileHeader->Key == GDIP_WMF_PLACEABLEKEY) &&
            (wmfPlaceableFileHeader->Checksum == GetWmfPlaceableCheckSum(wmfPlaceableFileHeader)) &&
            (wmfPlaceableFileHeader->BoundingBox.Left !=
             wmfPlaceableFileHeader->BoundingBox.Right) &&
            (wmfPlaceableFileHeader->BoundingBox.Top !=
             wmfPlaceableFileHeader->BoundingBox.Bottom));
}

inline BOOL
WmfHeaderIsValid(
    const METAHEADER *      wmfHeader
    )
{
    return  (((wmfHeader->mtType == MEMORYMETAFILE) ||
              (wmfHeader->mtType == DISKMETAFILE)) &&
             (wmfHeader->mtHeaderSize == (sizeof(METAHEADER)/sizeof(WORD))) &&
             ((wmfHeader->mtVersion == METAVERSION300) ||
              (wmfHeader->mtVersion ==METAVERSION100)));
}

VOID
Init32BppDibToTransparent(
    UINT32 *                bits,
    UINT                    numPixels
    );

GpStatus
Draw32BppDib(
    GpGraphics *            g,
    UINT32 *                bits,
    INT                     width,
    INT                     height,
    const GpRectF &         destRect,
    REAL                    dpi,
    BOOL                    compareAlpha
    );

extern "C"
BOOL CALLBACK
GdipPlayMetafileRecordCallback(
    EmfPlusRecordType       recordType,
    UINT                    recordFlags,
    UINT                    recordDataSize,
    const BYTE *            recordData,
    VOID *                  callbackData    // player
    );

// This method (defined below) enumerates/plays EMF+ comment records and also
// plays down-level GDI records, when appropriate.
extern "C"
int CALLBACK
EnumEmfWithDownLevel(
    HDC                     hdc,
    HANDLETABLE FAR *       gdiHandleTable,
    CONST ENHMETARECORD *   emfRecord,
    int                     numHandles,
    LPARAM                  play
    );

extern "C"
int CALLBACK
EnumEmfDownLevel(
    HDC                     hdc,
    HANDLETABLE FAR *       gdiHandleTable,
    CONST ENHMETARECORD *   emfRecord,
    int                     numHandles,
    LPARAM                  play
    );

extern "C"
int CALLBACK
EnumEmfToStream(
    HDC                     hdc,
    HANDLETABLE FAR *       gdiHandleTable,
    CONST ENHMETARECORD *   emfRecord,
    int                     numHandles,
    LPARAM                  stream
    );

// Separate this out so we can initialize it to 0 all at once
class MetafilePlayerBuffers
{
protected:
    BYTE                RecordBuffer  [GDIP_METAFILE_BUFFERSIZE];
    BYTE                PointsBuffer  [GDIP_METAFILE_BUFFERSIZE];
    GpObject *          ObjectList    [GDIP_MAX_OBJECTS];
    INT                 MemberStack   [GDIP_SAVE_STACK_SIZE];
    GpObject *          BackupObject  [ObjectTypeMax - ObjectTypeMin + 1];
};

class MetafilePlayer : public MetafilePlayerBuffers
{
protected:
    BOOL                    Valid;
    UINT32                  MaxStackSize;
    INT *                   Stack;
    IStream *               Stream;
    BYTE *                  RecordAllocedBuffer;
    BYTE *                  PointsAllocedBuffer;
    GpSolidFill             SolidBrush;
    BYTE *                  ConcatRecordBuffer;
    INT                     ConcatRecordBufferSize;
    BYTE *                  ConcatRecord;
    INT                     ConcatRecordTotalSize;
    INT                     ConcatRecordSize;
    UINT                    ConcatRecordFlags;
    InterpolationMode       Interpolation;

public:
    GpGraphics *            Graphics;           // The graphics we're playing to
    BOOL                    PlayEMFRecords;     // TRUE when we see GetDC record
    HDC                     Hdc;                // For playing downlevel records
    GpMatrix                PreContainerMatrix; // Xform to use for down-level
    UINT32 *                BitmapBits;
    INT                     BitmapWidth;
    INT                     BitmapHeight;
    GpRectF                 BitmapDestRect;
    REAL                    BitmapDpi;
    GpRecolor *             Recolor;
    MfEnumState *           MfState;
    ColorAdjustType         AdjustType;
    UINT                    MultiFormatSection;
    UINT                    CurFormatSection;
    BOOL                    PlayMultiFormatSection;
    EnumerateMetafileProc   EnumerateCallback;  // for metafile enumeration
    VOID *                  CallbackData;       // for metafile enumeration
    BOOL                    EnumerateAborted;
    DrawImageAbort          DrawImageCallback;
    VOID*                   DrawImageCallbackData;
    INT                     DrawImageCallbackCount;
    BOOL                    RopUsed;

public:
    // stream is NULL if using GDI to enumerate the hEmf.
    MetafilePlayer(
        GpGraphics *            g,
        UINT                    maxStackSize,
        GpRecolor *             recolor,
        ColorAdjustType         adjustType,
        EnumerateMetafileProc   enumerateCallback,
        VOID *                  callbackData,
        DrawImageAbort          drawImageCallback,
        VOID*                   drawImageCallbackData
        );

    ~MetafilePlayer();

    BOOL IsValid() const { return Valid; }

    VOID
    PrepareToPlay(
        GpGraphics *            g,
        GpRecolor *             recolor,
        ColorAdjustType         adjustType,
        EnumerateMetafileProc   enumerateCallback,
        VOID *                  callbackData,
        DrawImageAbort          drawImageCallback,
        VOID*                   drawImageCallbackData
    );

    VOID DonePlaying();

    VOID InitForDownLevel()
    {
        if (Hdc == NULL)
        {
            Hdc = Graphics->GetHdc();
            ASSERT(Hdc != NULL);

            if (BitmapBits != NULL)
            {
                Init32BppDibToTransparent(BitmapBits, BitmapWidth*BitmapHeight);
                MfState->ResetRopUsed();
            }
        }
    }

    VOID DoneWithDownLevel()
    {
        PlayEMFRecords = FALSE;
        if (Hdc != NULL)
        {
            Graphics->ReleaseHdc(Hdc);
            Hdc = NULL;

            if (BitmapBits != NULL)
            {
                // This is a hack to get around the problem that we are
                // inside a container, but we don't want to be in the
                // container for drawing the down-level records.  We also
                // don't want any transforms inside the EMF+ to affect the
                // down-level records.
                // We should probably do something about the clipping too,
                // but for now, we won't worry about it.
                GpMatrix saveWorldToDevice = Graphics->Context->WorldToDevice;
                Graphics->Context->WorldToDevice = PreContainerMatrix;

                // Don't use NearestNeighbor to draw the rotated metafile --
                // it looks bad, and doesn't really save any time.

                InterpolationMode   saveInterpolationMode = Graphics->Context->FilterType;

                if (saveInterpolationMode == InterpolationModeNearestNeighbor)
                {
                    Graphics->Context->FilterType = InterpolationModeBilinear;
                }

                Graphics->Context->InverseOk = FALSE;
                Draw32BppDib(Graphics, BitmapBits, BitmapWidth, BitmapHeight,
                             BitmapDestRect, BitmapDpi, !RopUsed);

                // restore the interpolation mode (in case we changed it).
                Graphics->Context->FilterType    = saveInterpolationMode;
                Graphics->Context->WorldToDevice = saveWorldToDevice;
                Graphics->Context->InverseOk = FALSE;
            }
        }
    }

    // returns 0 to abort playback, 1 to continue
    INT
    ProcessDrawImageCallback(
        BOOL    forceCallback
        )
    {
        if (DrawImageCallback)
        {
            // A DrawImage record could have already been aborted, so
            // we should immediately return.
            if (EnumerateAborted)
            {
                return 0;   // abort
            }
            if (forceCallback)
            {
                DrawImageCallbackCount = 0;
            }
            if ((DrawImageCallbackCount++ & GDIP_DO_CALLBACK_MASK) == 0)
            {
                // The callback returns TRUE to abort, FALSE to continue.
                return ((*DrawImageCallback)(DrawImageCallbackData)) ? 0 : 1;
            }
        }
        return 1;
    }

    GpPointF *
    GetPoints(
        const BYTE *        pointData,
        UINT                pointDataSize,
        INT                 count,
        INT                 flags
        )
    {
        return GetPointsForPlayback(pointData, pointDataSize, count, flags,
                                    GDIP_METAFILE_BUFFERSIZE,
                                    PointsBuffer, PointsAllocedBuffer);
    }

    GpRectF *
    GetRects(
        const BYTE *        rectData,
        UINT                rectDataSize,
        INT                 count,
        INT                 flags
        )
    {
        return GetRectsForPlayback(rectData, rectDataSize, count, flags,
                                   GDIP_METAFILE_BUFFERSIZE,
                                   PointsBuffer, PointsAllocedBuffer);
    }

    GpObject *
    GetObject(
        UINT                metaObjectId,
        ObjectType          objectType
        );

    GpBrush *
    GetBrush(
        UINT                brushValue,
        INT                 flags
        );

    GpString *
    GetString(
        const BYTE *    stringData,
        INT             len,
        INT             flags
        )
    {
        // !!! convert back from 8-bit to 16-bit chars if necessary
        return new GpString((const WCHAR *)stringData, len);
    }

    VOID
    AddObject(
        INT                 flags,
        const BYTE *        data,
        UINT                dataSize
        );

    VOID
    NewSave(
        UINT        stackIndex,
        INT         saveID
        );

    INT
    GetSaveID(
        UINT        stackIndex
        );

    VOID FreePointsBuffer()
    {
        if (PointsAllocedBuffer != NULL)
        {
            delete [] PointsAllocedBuffer;
            PointsAllocedBuffer = NULL;
        }
    }

    GpStatus
    ConcatenateRecords(
        UINT                recordFlags,
        INT                 recordDataSize,
        const BYTE *        recordData
        );

    GpStatus
    EnumerateEmfPlusRecords(
        UINT                dataSize,   // size of EMF+ record data
        const BYTE *        data        // pointer to the EMF+ record data
        );

    GpStatus
    EnumerateEmfRecords(
        HDC                 hdc,
        HENHMETAFILE        hEmf,
        const RECT *        dest,
        const RECT *        deviceRect,
        ENHMFENUMPROC       enumProc
        );

    GpStatus
    EnumerateWmfRecords(
        HDC                 hdc,
        HMETAFILE           hWmf,
        const RECT *        dstRect,
        const RECT *        deviceRect
        );
};

VOID
MetafilePlayer::PrepareToPlay(
    GpGraphics *            g,
    GpRecolor *             recolor,
    ColorAdjustType         adjustType,
    EnumerateMetafileProc   enumerateCallback,
    VOID *                  callbackData,
    DrawImageAbort          drawImageCallback,
    VOID*                   drawImageCallbackData
    )
{
    ASSERT(g != NULL);

    GpMemset(Stack, 0, MaxStackSize * sizeof (INT));

    // Initialize all the buffers to 0
    MetafilePlayerBuffers *     buffers = this;
    GpMemset(buffers, 0, sizeof(MetafilePlayerBuffers));

    PlayEMFRecords         = FALSE;
    Hdc                    = NULL;
    Graphics               = g;
    BitmapBits             = NULL;
    BitmapWidth            = 0;
    BitmapHeight           = 0;
    Interpolation          = g->GetInterpolationMode();
    Recolor                = recolor;
    AdjustType             = adjustType;
    MultiFormatSection     = 0;
    CurFormatSection       = 0;
    PlayMultiFormatSection = TRUE;
    EnumerateAborted       = FALSE;
    RopUsed                = FALSE;
    if (enumerateCallback == NULL)
    {
        EnumerateCallback  = GdipPlayMetafileRecordCallback;
        CallbackData       = this;
    }
    else
    {
        EnumerateCallback  = enumerateCallback;
        CallbackData       = callbackData;
    }
    DrawImageCallback      = drawImageCallback;
    DrawImageCallbackData  = drawImageCallbackData;
    DrawImageCallbackCount = 0;
    ConcatRecord           = NULL;
    ConcatRecordTotalSize  = 0;
    ConcatRecordSize       = 0;
    ConcatRecordFlags      = 0;

    // We need this for rendering GDI records within a GDI+ file.
    // We have to do it before starting the container.
    g->GetWorldToDeviceTransform(&(this->PreContainerMatrix));
}

MetafilePlayer::MetafilePlayer(
    GpGraphics *            g,
    UINT                    maxStackSize,
    GpRecolor *             recolor,
    ColorAdjustType         adjustType,
    EnumerateMetafileProc   enumerateCallback,
    VOID *                  callbackData,
    DrawImageAbort          drawImageCallback,
    VOID*                   drawImageCallbackData
    )
{
    Valid        = FALSE;
    MaxStackSize = GDIP_SAVE_STACK_SIZE;
    Stack        = MemberStack;
    if (maxStackSize > GDIP_SAVE_STACK_SIZE)
    {
        Stack = new INT[maxStackSize];
        if (Stack == NULL)
        {
            return; // Valid is FALSE
        }
        MaxStackSize = maxStackSize;
    }

    RecordAllocedBuffer    = NULL;
    PointsAllocedBuffer    = NULL;
    Recolor                = NULL;
    MfState                = NULL;
    ConcatRecordBuffer     = NULL;
    ConcatRecordBufferSize = 0;
    PrepareToPlay(g, recolor, adjustType, enumerateCallback, callbackData,
                  drawImageCallback, drawImageCallbackData
                  );
    Valid                  = TRUE;
}

MetafilePlayer::~MetafilePlayer()
{
    if (Stack != MemberStack)
    {
        delete [] Stack;
    }
    if (ConcatRecordBuffer)
    {
        GpFree(ConcatRecordBuffer);
    }
}

inline bool
ObjectTypeIsText(ObjectType type)
{
    return type == ObjectTypeFont
        || type == ObjectTypeStringFormat;
}


VOID
MetafilePlayer::DonePlaying()
{
    INT i;

    i = 0;
    do
    {
        GpObject* pObject = ObjectList[i];
        if (pObject)
        {
            GlobalTextLockConditional(ObjectTypeIsText(pObject->GetObjectType()));
            delete pObject;
        }
    } while ((++i) < GDIP_MAX_OBJECTS);
}

GpObject *
MetafilePlayer::GetObject(
    UINT                metaObjectId,
    ObjectType          objectType
    )
{
    GpObject *          object = NULL;

    // If the object was an unused optional parameter of some kind
    // it knows how to handle a NULL object, so we return that.

    if(metaObjectId == GDIP_OBJECTID_NONE)
    {
        return NULL;
    }

    ASSERT(metaObjectId < GDIP_MAX_OBJECTS);

    if (metaObjectId < GDIP_MAX_OBJECTS)
    {
        object = ObjectList[metaObjectId];
        ASSERT (object != NULL);
        if (object != NULL)
        {
            ASSERT(object->GetObjectType() == objectType);
            if (object->GetObjectType() == objectType)
            {
                return object;
            }
        }
    }
    if (ObjectTypeIsValid(objectType))
    {
        return BackupObject[objectType - ObjectTypeMin];
    }
    return NULL;
}

GpBrush *
MetafilePlayer::GetBrush(
    UINT                brushValue,
    INT                 flags
    )
{
    GpBrush *   brush;

    if ((flags & GDIP_EPRFLAGS_SOLIDCOLOR) != 0)
    {
        brush = &SolidBrush;
        (reinterpret_cast<GpSolidFill *>(brush))->SetColor(GpColor(brushValue));
        if (Recolor != NULL)
        {
            brush->ColorAdjust(Recolor, AdjustType);
        }
    }
    else
    {
        brush = (GpBrush *)this->GetObject(brushValue, ObjectTypeBrush);
    }
    return brush;
}

VOID
MetafilePlayer::AddObject(
    INT                 flags,
    const BYTE *        data,
    UINT                dataSize
    )
{
    ObjectType  objectType = GetObjectType(flags);
    UINT        objectId   = GetMetaObjectId(flags);
    GpObject ** objectList = ObjectList;

    ASSERT((objectId < GDIP_MAX_OBJECTS) || (objectId == GDIP_BACKUP_OBJECTID));


    GlobalTextLockConditional(ObjectTypeIsText(objectType));

    // First see if this is a backup object
    if ((objectId == GDIP_BACKUP_OBJECTID) &&
         ObjectTypeIsValid(objectType))
    {
        objectList = BackupObject;
        objectId   = objectType - ObjectTypeMin;
    }
    if (objectId < GDIP_MAX_OBJECTS)
    {
        GpObject *  object = objectList[objectId];

        if (object != NULL)
        {
            object->Dispose();
        }

        object = GpObject::Factory(objectType, (const ObjectData *)data, dataSize);

        if (object)
        {
            if (object->SetData(data, dataSize) == Ok)
            {
                if (Recolor != NULL)
                {
                    object->ColorAdjust(Recolor, AdjustType);
                }
                if (!object->IsValid())
                {
                    WARNING(("Object is not valid"));
                    object->Dispose();
                    object = NULL;
                }
            }
            else
            {
                WARNING(("Object Set Data failed"));
                object->Dispose();
                object = NULL;
            }
        }
        else
        {
            WARNING(("Object Factory failed to create object"));
        }
        objectList[objectId] = object;
    }
}

VOID
MetafilePlayer::NewSave(
    UINT        stackIndex,
    INT         saveID
    )
{
    if (stackIndex >= MaxStackSize)
    {
        UINT    maxStackSize = MaxStackSize + GDIP_SAVE_STACK_SIZE;

        if (stackIndex >= maxStackSize)
        {
            ASSERT (0);
            return;
        }
        INT *       newStack = new INT[maxStackSize];

        if (newStack == NULL)
        {
            return;
        }

        GpMemcpy(newStack, Stack, MaxStackSize * sizeof(INT));
        GpMemset(newStack + MaxStackSize, 0,
                 GDIP_SAVE_STACK_SIZE * sizeof (INT));
        MaxStackSize = maxStackSize;
        if (Stack != MemberStack)
        {
            delete [] Stack;
        }
        Stack = newStack;
    }

    Stack[stackIndex] = saveID;
}

INT
MetafilePlayer::GetSaveID(
    UINT        stackIndex
    )
{
    ASSERT(stackIndex < MaxStackSize);

    INT     saveID = 0;

    if (stackIndex < MaxStackSize)
    {
        saveID = Stack[stackIndex];
        Stack[stackIndex] = 0;
    }
    return saveID;
}

GpStatus
MetafilePlayer::ConcatenateRecords(
    UINT                recordFlags,
    INT                 recordDataSize,
    const BYTE *        recordData
    )
{
    ASSERT((recordData != NULL) && (recordDataSize > sizeof(INT32)));

    GpStatus    status = Ok;

    if ((recordFlags & GDIP_EPRFLAGS_CONTINUEOBJECT) != 0)
    {
        INT     dataSizeLeft = ((const INT32 *)recordData)[0];
        recordData     += sizeof(INT32);
        recordDataSize -= sizeof(INT32);

        if (dataSizeLeft <= recordDataSize)
        {
            WARNING(("Total Data Size incorrect"));
            status = InvalidParameter;
            goto DoneWithRecord;
        }

        recordFlags &= ~GDIP_EPRFLAGS_CONTINUEOBJECT;

        if (ConcatRecord == NULL)
        {
            if ((ConcatRecordBuffer == NULL) ||
                (ConcatRecordBufferSize < dataSizeLeft))
            {
                GpFree(ConcatRecordBuffer);
                ConcatRecordBuffer = (BYTE *)GpMalloc(dataSizeLeft);
                if (ConcatRecordBuffer == NULL)
                {
                    ConcatRecordBufferSize = 0;
                    return OutOfMemory;
                }
                ConcatRecordBufferSize = dataSizeLeft;
            }
            ConcatRecord          = ConcatRecordBuffer;
            ConcatRecordTotalSize = dataSizeLeft;
            ConcatRecordSize      = 0;
            ConcatRecordFlags     = recordFlags;
            goto SkipContinueChecks;
        }
    }
    if (recordFlags != ConcatRecordFlags)
    {
        WARNING(("Record headers do not match"));
        status = InvalidParameter;
        goto DoneWithRecord;
    }

SkipContinueChecks:
    if (recordDataSize + ConcatRecordSize > ConcatRecordTotalSize)
    {
        WARNING(("sizes do not match"));
        recordDataSize = ConcatRecordTotalSize - ConcatRecordSize;
    }

    GpMemcpy(ConcatRecord + ConcatRecordSize, recordData, recordDataSize);
    ConcatRecordSize += recordDataSize;

    // see if we're done concatenating this record
    if (ConcatRecordSize >= ConcatRecordTotalSize)
    {
        if (EnumerateCallback(EmfPlusRecordTypeObject, recordFlags,
                              ConcatRecordTotalSize, ConcatRecord,
                              CallbackData) == 0)
        {
            status = Aborted;
        }
DoneWithRecord:
        ConcatRecord          = NULL;
        ConcatRecordTotalSize = 0;
        ConcatRecordSize      = 0;
        ConcatRecordFlags     = 0;
    }
    return status;
}

// Enumerate a set of EMF+ record contained inside an EMF comment record
// which has been enumerated from an EMF file.
//
// NOTE that we can't change the metafile data.  If we need to change it,
// we must change a copy of it.
GpStatus
MetafilePlayer::EnumerateEmfPlusRecords(
    UINT                dataSize,   // size of EMF+ record data
    const BYTE *        data        // pointer to the EMF+ record data
    )
{
    ASSERT((dataSize > 0) && (data != NULL));

    UINT                curSize = 0;
    UINT                recordSize;
    EmfPlusRecordType   recordType;
    UINT                recordFlags;
    UINT                recordDataSize;
    const BYTE *        recordData;

    // while there is at least one record header size left
    while (curSize <= (dataSize - sizeof(EmfPlusRecord)))
    {
        recordSize = ((const EmfPlusRecord *)data)->Size;
        recordDataSize = recordSize - sizeof(EmfPlusRecord);

        // Make sure we don't read past the end of the buffer
        // and make sure the size field is valid.
        if ((recordSize >= sizeof(EmfPlusRecord)) &&
            ((curSize + recordSize) <= dataSize)  &&
            (recordDataSize == ((const EmfPlusRecord *)data)->DataSize))
        {
            recordType = (EmfPlusRecordType)(((const EmfPlusRecord *)data)->Type);

            // make sure the recordType is in some reasonable range
            // before we enumerate this record
            if ((recordType >= EmfPlusRecordTypeMin) &&
                (recordType < (EmfPlusRecordTypeMax + 1000)))
            {
                recordFlags = ((const EmfPlusRecord *)data)->Flags;

                if (recordDataSize == 0)
                {
                    recordData = NULL;
                }
                else
                {
                    recordData = data + sizeof(EmfPlusRecord);

                    // if this object record is spread over several GDI comment
                    // records, then we need to concatenate them together before
                    // giving it to the callback

                    // The GDIP_EPRFLAGS_CONTINUEOBJECT flag is only valid
                    // with object records (since that bit is reused for other
                    // flags with other record types).

                    if ((recordType == EmfPlusRecordTypeObject) &&
                        (((recordFlags & GDIP_EPRFLAGS_CONTINUEOBJECT) != 0) ||
                         (ConcatRecord != NULL)))
                    {
                        if (this->ConcatenateRecords(recordFlags,
                                                     recordDataSize,
                                                     recordData) == Aborted)
                        {
                            return Aborted;
                        }
                        goto Increment;
                    }
                }

                if (EnumerateCallback(recordType, recordFlags, recordDataSize,
                                      recordData, CallbackData) == 0)
                {
                    return Aborted;
                }
            }
            else
            {
                WARNING1("Bad EMF+ record type");
            }

Increment:
            data += recordSize;
            curSize += recordSize;

            // We have to set this here, because if we are just enumerating
            // for an application (not playing), then the GetDCEPR::Play
            // method will never be hit, so it will never get set!
            if (recordType == EmfPlusRecordTypeGetDC)
            {
                // Flag that the next down-level records should be played.
                PlayEMFRecords = TRUE;
            }
        }
        else
        {
            WARNING1("Bad EMF+ record size");
            return InvalidParameter;
        }
    }
    return Ok;
}

// Callback for EnumerateMetafile methods.  The parameters are:

//      recordType      (if >= EmfPlusRecordTypeMin, it's an EMF+ record)
//      flags           (always 0 for EMF records)
//      dataSize        size of the data, or 0 if no data
//      data            pointer to the data, or NULL if no data (UINT32 aligned)
//      callbackData    pointer to callbackData, if any

// This method can then call Metafile::PlayRecord to play the
// record that was just enumerated.  If this method  returns
// FALSE, the enumeration process is aborted.  Otherwise, it continues.

extern "C"
BOOL CALLBACK
GdipPlayMetafileRecordCallback(
    EmfPlusRecordType   recordType,
    UINT                recordFlags,
    UINT                recordDataSize,
    const BYTE *        recordData,
    VOID *              callbackData    // player
    )
{
    MetafilePlayer *    player = (MetafilePlayer *)callbackData;

    // See if it is an EMF+ record
    if ((recordType >= EmfPlusRecordTypeMin) && (recordType <= EmfPlusRecordTypeMax))
    {
        if (player->PlayMultiFormatSection)
        {
            (((const EmfPlusRecordPlay *)recordData)->*RecordPlayFuncs[recordType-EmfPlusRecordTypeMin])(player, recordType, recordFlags, recordDataSize);
            return player->ProcessDrawImageCallback(FALSE);
        }
        return 1;
    }

    // See if we should play the WMF or EMF record
    // Always play the header and EOF EMF records
    if (player->PlayEMFRecords ||
        (recordType == EmfRecordTypeHeader) ||
        (recordType == EmfRecordTypeEOF))
    {
        ASSERT(player->MfState != NULL);

        BOOL    forceCallback = player->MfState->ProcessRecord(
                                    recordType,
                                    recordDataSize,
                                    recordData);
        return player->ProcessDrawImageCallback(forceCallback);
    }

    ASSERT (0); // shouldn't get here unless caller is doing something strange

    return 1;   // Keep playing
}

GpStatus
GpMetafile::PlayRecord(
    EmfPlusRecordType       recordType,
    UINT                    recordFlags,
    UINT                    recordDataSize, // must be multiple of 4 for EMF
    const BYTE *            recordData
    ) const
{
    if ((State != PlayingMetafileState) ||
        (((recordDataSize & 0x03) != 0) &&
         (!GDIP_IS_WMF_RECORDTYPE(recordType))))
    {
        return InvalidParameter;
    }

    ASSERT(Player != NULL);

    GdipPlayMetafileRecordCallback(
        recordType,
        recordFlags,
        recordDataSize,
        recordData,
        Player
        );

    return Ok;
}

inline BOOL
IsEmfPlusRecord(
    CONST ENHMETARECORD *   emfRecord
    )
{
    // dParm[0] is the comment data size
    return ((emfRecord->iType == EMR_GDICOMMENT) &&
            (emfRecord->nSize >= (sizeof(EMR) + (2 * sizeof(DWORD)))) &&
            (emfRecord->dParm[1] == EMFPLUS_SIGNATURE));
}

// This method enumerates/plays EMF+ comment records and also
// plays down-level GDI records, when appropriate.
extern "C"
int CALLBACK
EnumEmfWithDownLevel(
    HDC                     hdc,    // should be non-NULL
    HANDLETABLE FAR *       gdiHandleTable,
    CONST ENHMETARECORD *   emfRecord,
    int                     numHandles,
    LPARAM                  play
    )
{
    if ((emfRecord != NULL) && (emfRecord->nSize >= sizeof(EMR)) &&
        (play != NULL))
    {
        MetafilePlayer *    player = (MetafilePlayer *)play;

        if (IsEmfPlusRecord(emfRecord))
        {
            // We're done displaying GDI down-level records
            player->DoneWithDownLevel();

            // NOTE: cbData is the size of the comment data, not including
            //       the record header and not including itself.
            //
            //       Must subtract out the Signature

            INT     dataSize = ((CONST EMRGDICOMMENT *)emfRecord)->cbData;

            // subtract out signature
            dataSize -= sizeof(INT32);

            if (dataSize > 0)
            {
                if (player->EnumerateEmfPlusRecords(
                            dataSize,
                            ((CONST EMRGDICOMMENT *)emfRecord)->Data + sizeof(INT32))
                            == Aborted)
                {
                    player->EnumerateAborted = TRUE;
                    return 0;
                }
            }
        }
        else
        {
            EmfPlusRecordType   recordType = (EmfPlusRecordType)(emfRecord->iType);

            if (player->PlayEMFRecords ||
                (recordType == EmfRecordTypeHeader) ||
                (recordType == EmfRecordTypeEOF))
            {
                if ((recordType != EmfRecordTypeHeader) &&
                    (recordType != EmfRecordTypeEOF))
                {
                    player->InitForDownLevel();
                }

                INT                 recordDataSize = emfRecord->nSize - sizeof(EMR);
                const BYTE *        recordData = (const BYTE *)emfRecord->dParm;

                if (recordDataSize <= 0)
                {
                    recordDataSize = 0;
                    recordData     = NULL;
                }

                player->MfState->StartRecord(hdc, gdiHandleTable, numHandles, emfRecord,
                                             recordType, recordDataSize, recordData);

                if (player->EnumerateCallback(recordType, 0, recordDataSize,
                                              recordData,
                                              player->CallbackData) == 0)
                {
                    player->EnumerateAborted = TRUE;
                    return 0;
                }
            }
        }
    }
    else
    {
        WARNING(("Bad Enumeration Parameter"));
    }
    return 1;
}

#define GDIP_MAX_DIBSECTION_SIZE   1024
#define GDIP_MINSCALED_DIBSECTION_SIZE   (GDIP_MAX_DIBSECTION_SIZE / 2)

inline VOID
AdjustForMaximumSize(
    LONG &      bigSide,
    LONG &      smallSide
    )
{
    // Try to keep the aspect ratio the same,
    // but don't let the smaller side get too small.
    REAL    scaleFactor = GDIP_MAX_DIBSECTION_SIZE / (REAL)bigSide;

    bigSide   = GDIP_MAX_DIBSECTION_SIZE;
    if (smallSide > GDIP_MINSCALED_DIBSECTION_SIZE)
    {
        smallSide = GpRound(scaleFactor * smallSide);

        if (smallSide < GDIP_MINSCALED_DIBSECTION_SIZE)
        {
            smallSide = GDIP_MINSCALED_DIBSECTION_SIZE;
        }
   }
}

// !!! If the hdc is a EMF, we really should take the rasterization limit
// into account when deciding the size of the dest bitmap.
static HBITMAP
CreateDibSection32Bpp(
    HDC                     hdc,
    const GpRectF &         destRect,
    RECT &                  dest,       // actual dest
    UINT32 **               bits,
    REAL *                  dpi,        // must init dpi before calling this method
    GpMatrix *              matrix
    )
{
    GpPointF    destPoints[3];
    REAL        width;
    REAL        height;


    // When we rasterize a WMF or EMF into a Dib Section, we limit the size
    // so that we don't use huge amounts of memory when printing or when
    // drawing the rotated metafile into another metafile.

    *bits = NULL;

    // the capped dpi keeps the image from getting too large

    destPoints[0].X = destRect.X;
    destPoints[0].Y = destRect.Y;
    destPoints[1].X = destRect.GetRight();
    destPoints[1].Y = destRect.Y;
    destPoints[2].X = destRect.X;
    destPoints[2].Y = destRect.GetBottom();

    matrix->Transform(destPoints, 3);

    // determine the size of the image by getting the distance
    // between the transformed device points

    width  = ::GetDistance(destPoints[0], destPoints[1]);
    height = ::GetDistance(destPoints[0], destPoints[2]);

    dest.left   = 0;
    dest.top    = 0;
    dest.right  = GpRound(width);
    dest.bottom = GpRound(height);

    // make sure we don't transform down to 0 size

    if ((dest.right == 0) || (dest.bottom == 0))
    {
        return NULL;
    }

    if ((dest.right  > GDIP_MAX_DIBSECTION_SIZE) ||
        (dest.bottom > GDIP_MAX_DIBSECTION_SIZE))
    {
        REAL area = (REAL) dest.right * dest.bottom;

        if (dest.right >= dest.bottom)
        {
            AdjustForMaximumSize(dest.right, dest.bottom);
        }
        else
        {
            AdjustForMaximumSize(dest.bottom, dest.right);
        }

        REAL newArea = (REAL) dest.right * dest.bottom;

        ASSERT(newArea > 0.0f && newArea <= area);

        // Adjust the effective DPI of the bitmap based on how much smaller it is.
        *dpi = (*dpi)*newArea/area;
    }

    BITMAPINFO      bmi;

    // Create a 32-bpp dib section so we can add alpha to it

    GpMemset(&bmi, 0, sizeof(bmi));

    bmi.bmiHeader.biSize        = sizeof(bmi.bmiHeader);
    bmi.bmiHeader.biWidth       = dest.right;
    bmi.bmiHeader.biHeight      = dest.bottom;
    bmi.bmiHeader.biPlanes      = 1;
    bmi.bmiHeader.biBitCount    = 32;
    bmi.bmiHeader.biCompression = BI_RGB;
    bmi.bmiHeader.biSizeImage   = dest.right * dest.bottom * 4;

    return CreateDIBSection(hdc, &bmi, DIB_RGB_COLORS, (VOID**)(bits), NULL, 0);
}

VOID
Init32BppDibToTransparent(
    UINT32 *                bits,
    UINT                    numPixels
    )
{
    ASSERT((bits != NULL) && (numPixels > 0));

    // initialize the image to a "transparent" color

    while (numPixels--)
    {
        *bits++ = GDIP_TRANSPARENT_COLOR_KEY;
    }
}

GpStatus
Draw32BppDib(
    GpGraphics *            g,
    UINT32 *                bits,
    INT                     width,
    INT                     height,
    const GpRectF &         destRect,
    REAL                    dpi,
    BOOL                    compareAlpha
    )
{
    // Make sure Gdi is done drawing to the dib section
    ::GdiFlush();

    // Set the alpha value to 0 whereever the transparent
    // color is still in the image and to FF everywhere else

    UINT32 *    bitmapBits = bits;
    UINT        numPixels  = width * height;

    if (compareAlpha)
    {
        while (numPixels--)
        {
            if (*bitmapBits != GDIP_TRANSPARENT_COLOR_KEY)
            {
                *bitmapBits |= 0xFF000000;
            }
            else
            {
                *bitmapBits = 0;
            }
            bitmapBits++;
        }
    }
    else
    {
        while (numPixels--)
        {
            if ((*bitmapBits & 0x00FFFFFF) != (GDIP_TRANSPARENT_COLOR_KEY & 0x00FFFFFF))
            {
                *bitmapBits |= 0xFF000000;
            }
            else
            {
                *bitmapBits = 0;
            }
            bitmapBits++;
        }
    }

    // Create a bitamp from the dib section memory (which
    // we've added alpha to).  This constructor uses the
    // memory we give it without doing a copy.

    GpStatus    status = GenericError;

    GpBitmap *  bitmap = new GpBitmap(width, height, -(width * 4),
                                      PIXFMT_32BPP_PARGB,
                                      (BYTE *)(bits + (width * (height - 1))));

    if (bitmap != NULL)
    {
        if (bitmap->IsValid())
        {
            bitmap->SetResolution(dpi, dpi);

            // If we want the outside edges to look smooth, then we have
            // to outcrop both the src and dest rects (by at least a pixel).

            GpRectF     srcRect(-1.0f, -1.0f, width + 2.0f, height + 2.0f);
            GpRectF     outCroppedDestRect;
            REAL        xSize;
            REAL        ySize;

            g->GetWorldPixelSize(xSize, ySize);

            if (destRect.Width < 0.0f)
            {
                xSize = -xSize;
            }
            if (destRect.Height < 0.0f)
            {
                ySize = -ySize;
            }

            outCroppedDestRect.X      = destRect.X      - xSize;
            outCroppedDestRect.Width  = destRect.Width  + (xSize * 2.0f);
            outCroppedDestRect.Y      = destRect.Y      - ySize;
            outCroppedDestRect.Height = destRect.Height + (ySize * 2.0f);

            if (g->IsPrinter())
            {
                // If the resulting transform (and source rect/dest rect) is
                // a rotation by 90, 180, or 270 degrees.  Then flip the bitmap
                // appropriately.  Fix up source rect, dest rect, and world to
                // device appropriately.  Restore W2D afterwards.

                GpMatrix worldToDevice;
                g->GetWorldToDeviceTransform(&worldToDevice);

                // Create the entire image source to device mapping to determine
                // the entire rotation.

                GpMatrix transform;
                transform.InferAffineMatrix(destRect, srcRect);
                GpMatrix::MultiplyMatrix(transform, transform, worldToDevice);

                MatrixRotate rotation = transform.GetRotation();

                if (rotation == MatrixRotateBy90 ||
                    rotation == MatrixRotateBy180 ||
                    rotation == MatrixRotateBy270)
                {
                    // Normalize the destination rectangle
                    TransformBounds(NULL,
                                    outCroppedDestRect.GetLeft(),
                                    outCroppedDestRect.GetTop(),
                                    outCroppedDestRect.GetRight(),
                                    outCroppedDestRect.GetBottom(),
                                    &outCroppedDestRect);
                    // Compute the destination rectangle in device space.  Transform
                    // to device space and normalize.
                    // We know the world transform can have a 90 degree rotation
                    // so we need to do a point transform. We can do a 2 point
                    // transform and get the min and the max to make the bounding
                    // box

                    GpRectF deviceDestRect;
                    TransformBounds(&worldToDevice,
                                    outCroppedDestRect.GetLeft(),
                                    outCroppedDestRect.GetTop(),
                                    outCroppedDestRect.GetRight(),
                                    outCroppedDestRect.GetBottom(),
                                    &deviceDestRect);

                    // Construct new world to page transform.  Infers from the
                    // normalized outCroppedDestRect to normalized deviceDestRect.
                    //
                    //  The World To Device is ordinarily computed as:
                    //
                    //          World-To-Page * Scale(PageMultipliers) *
                    //          Translate-By-Pixel-Offset * ContainerTransform
                    //
                    // The SetWorldTransform API only sets the World-To-Page.
                    //
                    //  So we set the new World Transform as:
                    //
                    //    World-To-Page * Inverse(World-To-Device)*
                    //    Transform-CroppedDestRect-To-DeviceDestRect
                    //
                    //    The result, as you can see from substitution is just
                    //    Transform-CroppedDestRect-To-DeviceDestRect


                    GpMatrix newTransform;
                    newTransform.InferAffineMatrix(deviceDestRect, outCroppedDestRect);
                    g->GetDeviceToWorldTransform(&transform);
                    GpMatrix::MultiplyMatrix(newTransform, newTransform, transform);
                    g->GetWorldTransform(transform);   // really World To Page XForm
                    GpMatrix::MultiplyMatrix(newTransform, newTransform, transform);

                    ASSERT(newTransform.IsTranslateScale());

                    // We are free to rotate in place because we know this is a
                    // throw away bitmap.

                    switch (rotation)
                    {
                    case MatrixRotateBy90:
                        status = bitmap->RotateFlip(Rotate90FlipNone);
                        break;

                    case MatrixRotateBy180:
                        status = bitmap->RotateFlip(Rotate180FlipNone);
                        break;

                    case MatrixRotateBy270:
                        status = bitmap->RotateFlip(Rotate270FlipNone);
                        break;

                    default:
                        status = GenericError;
                        ASSERT(FALSE);
                        break;
                    }

                    if (status == Ok)
                    {
                        g->SetWorldTransform(newTransform);

                        // Get new size (in case Height & Width were flipped.
                        Size bitmapSize;
                        bitmap->GetSize(&bitmapSize);

                        srcRect.Width = bitmapSize.Width + 2.0f;
                        srcRect.Height = bitmapSize.Height + 2.0f;

                        // Because the bitmap is already at device resolution
                        // (in most cases), nearest neighbor best preserves
                        // the image when printing.
                        InterpolationMode interpolationMode= g->GetInterpolationMode();
                        if (interpolationMode != InterpolationModeNearestNeighbor)
                        {
                            g->SetInterpolationMode(InterpolationModeNearestNeighbor);
                        }

                        // Draw the new image with the rotation/shear
                        status = g->DrawImage(bitmap, outCroppedDestRect, srcRect, UnitPixel);

                        if (interpolationMode != InterpolationModeNearestNeighbor)
                        {
                            g->SetInterpolationMode(interpolationMode);
                        }

                        g->SetWorldTransform(worldToDevice);
                    }

                    goto cleanupBitmap;
                }
            }

            // Draw the new image with the rotation/shear
            status = g->DrawImage(bitmap, outCroppedDestRect, srcRect, UnitPixel);
        }

cleanupBitmap:
        // Now clean up everything
        bitmap->Dispose();
    }
    return status;
}

// Get multipliers to convert to pixel units
VOID
GetPixelMultipliers(
    GpPageUnit                  srcUnit,
    REAL                        srcDpiX,
    REAL                        srcDpiY,
    REAL *                      pixelMultiplierX,
    REAL *                      pixelMultiplierY
    )
{
    REAL    multiplierX;
    REAL    multiplierY;

    // UnitDisplay is device-dependent and cannot be used for a source unit
    ASSERT(srcUnit != UnitDisplay);

    switch (srcUnit)
    {
    default:
        ASSERT(0);
        // FALLTHRU

    case UnitPixel:             // Each unit represents one device pixel.
        multiplierX = 1.0f;
        multiplierY = 1.0f;
        break;

    case UnitPoint:             // Each unit represents a 1/72 inch.
        multiplierX = srcDpiX / 72.0f;
        multiplierY = srcDpiY / 72.0f;
        break;

      case UnitInch:            // Each unit represents 1 inch.
        multiplierX = srcDpiX;
        multiplierY = srcDpiY;
        break;

      case UnitDocument:        // Each unit represents 1/300 inch.
        multiplierX = srcDpiX / 300.0f;
        multiplierY = srcDpiY / 300.0f;
        break;

      case UnitMillimeter:      // Each unit represents 1 millimeter.
                                // One Millimeter is 0.03937 inches
                                // One Inch is 25.4 millimeters
        multiplierX = srcDpiX / 25.4f;
        multiplierY = srcDpiY / 25.4f;
        break;
    }
    *pixelMultiplierX = multiplierX;
    *pixelMultiplierY = multiplierY;
}

extern "C"
int CALLBACK
EnumEmfDownLevel(
    HDC                     hdc,            // handle to device context
    HANDLETABLE FAR *       gdiHandleTable, // pointer to metafile handle table
    CONST ENHMETARECORD *   emfRecord,      // pointer to metafile record
    int                     numHandles,     // count of objects
    LPARAM                  play            // pointer to optional data
    )
{
    if ((emfRecord != NULL) && (emfRecord->nSize >= sizeof(EMR)) &&
        (play != NULL))
    {
        // If we're in this method, we don't want to play any EMF+ records,
        // so skip them, so we don't record them into another metafile.
        if (!IsEmfPlusRecord(emfRecord))
        {
            EmfPlusRecordType   recordType = (EmfPlusRecordType)(emfRecord->iType);
            const BYTE *        recordData = (const BYTE *)emfRecord->dParm;
            INT                 recordDataSize = emfRecord->nSize - sizeof(EMR);

            if (recordDataSize <= 0)
            {
                recordDataSize = 0;
                recordData     = NULL;
            }

            MetafilePlayer *    player = (MetafilePlayer *)play;

            player->MfState->StartRecord(hdc, gdiHandleTable, numHandles, emfRecord,
                                         recordType, recordDataSize, recordData);

            if (player->EnumerateCallback(recordType, 0, recordDataSize,
                                          recordData,
                                          player->CallbackData) == 0)
            {
                player->EnumerateAborted = TRUE;
                return 0;
            }
        }
    }
    else
    {
        WARNING(("Bad Enumeration Parameter"));
    }
    return 1;
}

// Assumes the hdc has already been set up with the correct transform and
// clipping for displaying the metafile.
GpStatus
MetafilePlayer::EnumerateEmfRecords(
    HDC                 hdc,
    HENHMETAFILE        hEmf,
    const RECT *        dest,
    const RECT *        deviceRect,
    ENHMFENUMPROC       enumProc
    )
{
    ASSERT(hdc != NULL);
    ASSERT(hEmf != NULL);
    ASSERT(dest->bottom > dest->top && dest->right > dest->left);

    // GDI uses an Inclusive-Inclusive bound for Metafile Playback
    RECT destRect = *dest;
    destRect.bottom--;
    destRect.right--;

    GpStatus    status = GenericError;
    BOOL        externalEnumeration =
                    (EnumerateCallback != GdipPlayMetafileRecordCallback);

    EmfEnumState    emfState(hdc, hEmf, &destRect, deviceRect, externalEnumeration,
                             Interpolation, Graphics->Context, Recolor, AdjustType);

    if (emfState.IsValid())
    {
        MfState = &emfState;

        // If the metafile is empty the following fails.
        status = ::EnumEnhMetaFile(hdc, hEmf, enumProc, this, &destRect) ?
                        Ok : GenericError;
        RopUsed = MfState->GetRopUsed();
        MfState = NULL;
        if (EnumerateAborted)
        {
            status = Aborted;
        }
    }
    return status;
}

extern "C"
int CALLBACK
EnumWmfDownLevel(
    HDC                     hdc,
    HANDLETABLE FAR *       gdiHandleTable,
    METARECORD FAR *        wmfRecord,
    int                     numHandles,
    LPARAM                  play
    )
{
    if ((wmfRecord != NULL) &&
        (((UNALIGNED METARECORD *)wmfRecord)->rdSize >= 3) &&
        (play != NULL))
    {
        EmfPlusRecordType   recordType     = (EmfPlusRecordType)(GDIP_WMF_RECORD_TO_EMFPLUS(wmfRecord->rdFunction));
        const BYTE *        recordData     = (const BYTE *)((UNALIGNED METARECORD *)wmfRecord)->rdParm;
        INT                 recordDataSize = (((UNALIGNED METARECORD *)wmfRecord)->rdSize * 2) - SIZEOF_METARECORDHEADER;

        if (recordDataSize <= 0)
        {
            recordDataSize = 0;
            recordData     = NULL;
        }

        MetafilePlayer *    player = (MetafilePlayer *)play;

        player->MfState->StartRecord(hdc, gdiHandleTable, numHandles, wmfRecord,
                                         recordType, recordDataSize, recordData);

        if (player->EnumerateCallback(recordType, 0, recordDataSize,
                                      recordData,
                                      player->CallbackData) == 0)
        {
            player->EnumerateAborted = TRUE;
            return 0;
        }
    }
    else
    {
        WARNING(("Bad Enumeration Parameter"));
    }
    return 1;
}

// Assumes the hdc has already been set up with the correct transform and
// clipping for displaying the metafile.
GpStatus
MetafilePlayer::EnumerateWmfRecords(
    HDC                 hdc,
    HMETAFILE           hWmf,
    const RECT *        dstRect,
    const RECT *        deviceRect
    )
{
    ASSERT(hdc != NULL);
    ASSERT(hWmf != NULL);

    GpStatus    status = GenericError;
    BOOL        externalEnumeration =
                    (EnumerateCallback != GdipPlayMetafileRecordCallback);

    WmfEnumState    wmfState(hdc, hWmf, externalEnumeration, Interpolation,
                             dstRect, deviceRect, Graphics->Context, Recolor, AdjustType);

    if (wmfState.IsValid())
    {
        MfState = &wmfState;

        // If the metafile is empty the following fails.
        status = ::EnumMetaFile(hdc, hWmf, EnumWmfDownLevel, (LPARAM)this) ?
                        Ok : GenericError;
        RopUsed = MfState->GetRopUsed();
        MfState = NULL;
        if (EnumerateAborted)
        {
            status = Aborted;
        }
    }
    return status;
}

inline BOOL
IsMetafileHdc(
    HDC     hdc
    )
{
    DWORD   hdcType = GetDCType(hdc);
    return ((hdcType == OBJ_ENHMETADC) || (hdcType == OBJ_METADC));
}

class SetupClippingForMetafilePlayback
{
public:

    SetupClippingForMetafilePlayback(
        HDC                     hdc,
        DpDriver *              driver,
        DpContext *             context,
        BOOL                    forEMFPlus = FALSE
        )
    {
        Hdc = hdc;
        Driver = driver;
        IsClip = FALSE;
        ClippedOut = FALSE;
        ReenableClipEscapes = FALSE;

        if (!context->VisibleClip.IsInfinite())
        {
            // Use GDI path clipping for playback to metafile only
            UsePathClipping = IsMetafileHdc(hdc) && !context->IsPrinter;

            // NT4 has a postscript driver bug where embedded EPS corrupt the
            // current postscript clipping stack.  To get around this, we resort to
            // using GDI to clip for us.

            // The problem is not limited to NT4 drivers alooe.  There seems to
            // be a family of injected EPS which doesn't interop with embedded
            // postscript clipping escapes. The reason may have to do with the
            // fact that many implementations don't reset the current path after
            // sending the escape.  See Office bugs 284388, 316074

            if (context->IsPrinter)
            {
                if ((!forEMFPlus && !Globals::IsNt) ||
                    (Globals::IsNt &&
                     Globals::VersionInfoInitialized &&
                    ((Globals::OsVer.dwMajorVersion <= 4) ||
                     ((Globals::OsVer.dwMajorVersion >= 5) &&
                      (context->VisibleClip.IsSimple())) )))
                {
                    DriverPrint *pdriver = (DriverPrint*) Driver;

                    pdriver->DisableClipEscapes();
                    ReenableClipEscapes = TRUE;
                }
            }

            // The trick here is we want to force the driver to clip, even if
            // totally visible because cropping requires this. We pass in the flag
            // to force clipping

            GpRect drawBounds;
            context->VisibleClip.GetBounds(&drawBounds);
            if (drawBounds.IsEmpty())
            {
                ClippedOut = TRUE;
                return;
            }

            // Use appropriate driver clipping on playback
            Driver->SetupClipping(Hdc,
                                  context,
                                  &drawBounds,
                                  IsClip,
                                  UsePathClipping,
                                  TRUE);

            // Prevent metafile from drawing outside of the DestRect
            // Can only do it for NT because Win9x doesn't restore the
            // MetaRgn properly
            // We handle this in the Metafile Player for Win9x
            if (Globals::IsNt)
            {
                ::SetMetaRgn(hdc);
            }
        }
    }

    ~SetupClippingForMetafilePlayback()
    {
        if (IsClip)
        {
            Driver->RestoreClipping(Hdc,
                                    IsClip,
                                    UsePathClipping);

            if (ReenableClipEscapes)
            {
                DriverPrint *pdriver = (DriverPrint*) Driver;
                pdriver->EnableClipEscapes();
            }
        }
    }

    BOOL IsClippedOut()
    {
        return ClippedOut;
    }

private:
    DpDriver *  Driver;
    HDC         Hdc;
    BOOL        IsClip;
    BOOL        UsePathClipping;
    BOOL        ClippedOut;
    BOOL        ReenableClipEscapes;
};

// We already set up the transform to handle the srcRect and also to
// handle any flipping in the srcRect and destRect, so the 2 rects
// should have positive widths and heights at this point.
GpStatus
GpGraphics::EnumEmf(
    MetafilePlayer *        player,
    HENHMETAFILE            hEmf,
    const GpRectF &         destRect,
    const GpRectF &         srcRect,    // in pixel units
    const GpRectF &         deviceDestRect, // The destRect in Device Units
    MetafileType            type,
    BOOL                    isTranslateScale,
    BOOL                    renderToBitmap,
    const GpMatrix &        flipAndCropTransform
    )
{
    ASSERT(hEmf != NULL);

    HDC     hdc  = Context->GetHdc(Surface);

    if (hdc == NULL)
    {
        return GenericError;
    }

    INT saveDC;
    if ((saveDC = ::SaveDC(hdc)) == 0)
    {
        Context->ReleaseHdc(hdc, Surface);
        return GenericError;
    }

    // Since we might have an HDC from a GpBitmap that's not clean, clean the
    // HDC for now....
    Context->CleanTheHdc(hdc);

    player->PlayEMFRecords = TRUE;  // play all EMF records

    GpStatus    status = Ok;

    // the srcRect is already in pixel units
    GpRect      deviceSrcRect;
    deviceSrcRect.X      = GpRound(srcRect.X);
    deviceSrcRect.Y      = GpRound(srcRect.Y);
    deviceSrcRect.Width  = GpRound(srcRect.Width);
    deviceSrcRect.Height = GpRound(srcRect.Height);

    RECT        deviceClipRect;
    deviceClipRect.left   = RasterizerCeiling(deviceDestRect.X);
    deviceClipRect.top    = RasterizerCeiling(deviceDestRect.Y);
    deviceClipRect.right  = RasterizerCeiling(deviceDestRect.GetRight());
    deviceClipRect.bottom = RasterizerCeiling(deviceDestRect.GetBottom());

    // If it's a translate/scale matrix, do the transform ourselves,
    // even on NT, so that we can control how the rounding is done
    // to avoid cases where we round the metafile dest differently
    // than the clipping rect, resulting in clipped out edges.
    if (isTranslateScale)
    {
        SetupClippingForMetafilePlayback clipPlayback(hdc, Driver, Context);
        if (!clipPlayback.IsClippedOut())
        {
            RECT        deviceRect;
            GpPointF    points[2];

            points[0] = GpPointF(destRect.X, destRect.Y);
            points[1] = GpPointF(destRect.GetRight(), destRect.GetBottom());
            player->PreContainerMatrix.Transform(points, 2);
            
            // We have to use the same method to convert REAL -> INT
            // that we do when we set up the clipping.  Otherwise, some
            // of the points get rounded differently, causing a
            // portion of the metafile to get clipped out.
            deviceRect.left   = RasterizerCeiling(points[0].X);
            deviceRect.top    = RasterizerCeiling(points[0].Y);
            deviceRect.right  = RasterizerCeiling(points[1].X);
            deviceRect.bottom = RasterizerCeiling(points[1].Y);

            if (deviceRect.left < deviceRect.right &&
                deviceRect.top < deviceRect.bottom)
            {
                if ((type == MetafileTypeWmf) || (type == MetafileTypeWmfPlaceable))
                {
                    // map the source rect to the dest rect to play the metafile
                    ::SetMapMode(hdc, MM_ANISOTROPIC);
                    ::SetWindowOrgEx(hdc, deviceSrcRect.X, deviceSrcRect.Y, NULL);
                    ::SetWindowExtEx(hdc, deviceSrcRect.Width, deviceSrcRect.Height,
                                     NULL);
                    ::SetViewportOrgEx(hdc, deviceRect.left, deviceRect.top, NULL);
                    ::SetViewportExtEx(hdc, deviceRect.right - deviceRect.left,
                                       deviceRect.bottom - deviceRect.top, NULL);

                    status = player->EnumerateWmfRecords(hdc, (HMETAFILE)hEmf,
                                                         &deviceRect, &deviceClipRect);
                }
                else    // play as down-level EMF
                {
                    ASSERT((type == MetafileTypeEmf) || (type == MetafileTypeEmfPlusDual));
                    
                    status = player->EnumerateEmfRecords(hdc, hEmf, &deviceRect,
                                                         &deviceClipRect, EnumEmfDownLevel);
                }

            }
            // else empty rect, nothing to draw
        }
        // else it's all clipped out
    }
    else    // flip and/or rotate and/or shear
    {
        RECT        dest;

        // Can't play a WMF with any rotate or skew transformation.
        // If we're on NT but we're drawing to a metafile hdc, then we
        // can't rely on the transforms working for that case.
        if (!renderToBitmap)
        {
            dest.left   = GpRound(destRect.X);
            dest.top    = GpRound(destRect.Y);
            dest.right  = GpRound(destRect.GetRight());
            dest.bottom = GpRound(destRect.GetBottom());

            if ((dest.bottom > dest.top) && (dest.right > dest.left))
            {
                // If NT, then set the transform in GDI, and play the metafile

                SetupClippingForMetafilePlayback clipPlayback(hdc, Driver, Context);
                if (!clipPlayback.IsClippedOut())
                {
                    ASSERT(Globals::IsNt);

                    SetGraphicsMode(hdc, GM_ADVANCED);

                    ASSERT(sizeof(XFORM) == sizeof(REAL)*6);

                    XFORM   xform;
                    player->PreContainerMatrix.GetMatrix((REAL*) &xform);
                    ::SetWorldTransform(hdc, &xform);

                    RECT    dummyRect = {0,0,0,0};
                    
                    status = player->EnumerateEmfRecords(hdc, hEmf, &dest,
                                                         &dummyRect, EnumEmfDownLevel);
                }
            }
        }
        else // Win9x with rotation or shear
             // WinNT WMF with Rotate or shear
        {
            // 1 - Draw into a 32-bit DIB Section
            // 2 - Create an image from the DIB Section
            // 3 - Call g->DrawImage

            status = GenericError;

            UINT32 *    bits;
            HBITMAP     hBitmap;

            player->BitmapDpi = Context->ContainerDpiX;
            hBitmap = CreateDibSection32Bpp(hdc, destRect, dest, &bits, &player->BitmapDpi, &player->PreContainerMatrix);
            if (hBitmap != NULL)
            {
                Init32BppDibToTransparent(bits, dest.right * dest.bottom);

                HDC     hdcDib = CreateCompatibleDC(NULL);

                if (hdcDib != NULL)
                {
                    ::SelectObject(hdcDib, hBitmap);

                    if ((type == MetafileTypeWmf) || (type == MetafileTypeWmfPlaceable))
                    {
                        // map the source rect to the dest rect to play the metafile
                        ::SetMapMode(hdcDib, MM_ANISOTROPIC);
                        ::SetWindowOrgEx(hdcDib, deviceSrcRect.X, deviceSrcRect.Y, NULL);
                        ::SetWindowExtEx(hdcDib, deviceSrcRect.Width, deviceSrcRect.Height,
                                         NULL);
                        ::SetViewportOrgEx(hdcDib, 0, 0, NULL);
                        ::SetViewportExtEx(hdcDib, dest.right, dest.bottom, NULL);

                        status = player->EnumerateWmfRecords(hdcDib, (HMETAFILE)hEmf,
                                                             &dest, &dest);
                    }
                    else    // play as down-level EMF
                    {
                        ASSERT((type == MetafileTypeEmf) || (type == MetafileTypeEmfPlusDual));


                        status = player->EnumerateEmfRecords(hdcDib, hEmf, &dest,
                                                             &dest, EnumEmfDownLevel);
                    }
                    ::DeleteDC(hdcDib);

                    if (status != Aborted)
                    {
                        // Don't use NearestNeighbor to draw the rotated metafile --
                        // it looks bad, and doesn't really save any time.

                        InterpolationMode   saveInterpolationMode = Context->FilterType;

                        if (saveInterpolationMode == InterpolationModeNearestNeighbor)
                        {
                            Context->FilterType = InterpolationModeBilinear;
                        }

                        // Apply the flip/crop transform.  Now the worldToDevice transform
                        // should be equivalent to the PreContainerMatrix.
                        this->SetWorldTransform(flipAndCropTransform);

                        status = Draw32BppDib(this, bits, dest.right,
                                              dest.bottom, destRect,
                                              player->BitmapDpi, !player->RopUsed);

                        // restore the interpolation mode (in case we changed it).
                        Context->FilterType = saveInterpolationMode;
                    }
                }
                DeleteObject(hBitmap);
            }
            else if ((dest.right == 0) || (dest.bottom == 0))
            {
                status = Ok;
            }
        }
    }

    ::RestoreDC(hdc, saveDC);
    Context->ReleaseHdc(hdc, Surface);
    return status;
}

// We already set up the transform to handle the srcRect and also to
// handle any flipping in the srcRect and destRect, so the 2 rects
// should have positive widths and heights at this point.
GpStatus
GpGraphics::EnumEmfPlusDual(
    MetafilePlayer *        player,
    HENHMETAFILE            hEmf,
    const GpRectF&          destRect,        // inclusive, exclusive
    const GpRectF&          deviceDestRect,  // inclusive, exclusive
    BOOL                    isTranslateScale,
    BOOL                    renderToBitmap
    )
{
    GpStatus    status = Ok;
    HDC         hdc;
    HWND        hwnd   = Context->Hwnd;
    INT         saveDC = -1;
    BOOL        needToReleaseHdc = FALSE;

    // We are going to take the role of the application and set up the HDC
    // like we want it and then let GDI+ change it from there.  This is so
    // that when we play back the GDI records, the HDC will already be set
    // up correctly so those records get played back in the right place.
    // In other words, I'm doing my own version of Context->GetHdc().

    Surface->Flush(FlushIntentionFlush);

    if (hwnd != NULL)
    {
        // We have to guarantee that we use the same HDC throughout the
        // enumeration/playing of the metafile -- so change how the HDC is
        // set up in the graphics context (if we need to).

        ASSERT(Context->Hdc == NULL);
        ASSERT(Context->SaveDc == 0);

        hdc = ::GetCleanHdc(hwnd);
        if (hdc == NULL)
        {
            WARNING(("GetCleanHdc failed"));
            return Win32Error;
        }

        Context->Hwnd = NULL;
        Context->Hdc  = hdc;
    }
    else
    {
        if ((hdc = Context->Hdc) != NULL)
        {
            // Restore the HDC back to the state the application had it in.
            Context->ResetHdc();
        }
        else    // might be a bitmap surface
        {
            hdc = Context->GetHdc(Surface);

            // Still have to call CleanTheHdc to fix bug #121666.
            // It seems like the hdc should have come back clean
            // from the context.

            if (hdc == NULL)
            {
                WARNING(("Could not get an hdc"));
                return InvalidParameter;
            }
            needToReleaseHdc = TRUE;
        }
        // Now save the state of the HDC so we can get back to it later.
        saveDC = SaveDC(hdc);

        // Get the hdc into a clean state before we start.
        Context->CleanTheHdc(hdc);
    }

    // This block needs to be within braces so that SetupClippingForMetafile
    // will have it's destructor called before the cleanup code.
    {
        // set the clipping for the down-level records
        SetupClippingForMetafilePlayback clipPlayback(hdc, Driver, Context, TRUE);
        if (!clipPlayback.IsClippedOut())
        {
            RECT        deviceClipRect;
            deviceClipRect.left   = RasterizerCeiling(deviceDestRect.X);
            deviceClipRect.top    = RasterizerCeiling(deviceDestRect.Y);
            deviceClipRect.right  = RasterizerCeiling(deviceDestRect.GetRight());
            deviceClipRect.bottom = RasterizerCeiling(deviceDestRect.GetBottom());


            // If it's a translate/scale matrix, do the transform ourselves,
            // even on NT, so that we can control how the rounding is done
            // to avoid cases where we round the metafile dest differently
            // than the clipping rect, resulting in clipped out edges.
            if (isTranslateScale)
            {
                RECT        deviceRect;
                GpPointF    points[2];

                points[0] = GpPointF(destRect.X, destRect.Y);
                points[1] = GpPointF(destRect.GetRight(), destRect.GetBottom());
                player->PreContainerMatrix.Transform(points, 2);

                // We have to use the same method to convert REAL -> INT
                // that we do when we set up the clipping.  Otherwise, some
                // of the points get rounded differently, causing a
                // portion of the metafile to get clipped out.
                deviceRect.left   = RasterizerCeiling(points[0].X);
                deviceRect.top    = RasterizerCeiling(points[0].Y);
                deviceRect.right  = RasterizerCeiling(points[1].X);
                deviceRect.bottom = RasterizerCeiling(points[1].Y);

                 // If we don't have a destrect then we are done
                if (deviceRect.left < deviceRect.right &&
                    deviceRect.top < deviceRect.bottom)
                {
                    status = player->EnumerateEmfRecords(hdc, hEmf, &deviceRect,
                                                         &deviceClipRect, EnumEmfWithDownLevel);
                }
            }
            else    // flip and/or rotate and/or shear
            {
                RECT        dest;

                dest.left   = GpRound(destRect.X);
                dest.top    = GpRound(destRect.Y);
                dest.right  = GpRound(destRect.GetRight());
                dest.bottom = GpRound(destRect.GetBottom());

                if ((dest.bottom > dest.top) && (dest.right > dest.left))
                {
                    // If we're on NT but we're drawing to a metafile hdc, then we
                    // can't rely on the transforms working for that case.
                    if (!renderToBitmap)
                    {
                        ASSERT(Globals::IsNt);

                        // set the transform for the down-level records
                        SetGraphicsMode(hdc, GM_ADVANCED);

                        ASSERT(sizeof(XFORM) == sizeof(REAL)*6);

                        // We want to set the transform in the HDC to the Pre-container matrix,
                        // so that it will be used to render the down-level records.
                        XFORM   xform;
                        player->PreContainerMatrix.GetMatrix((REAL*)(&xform));
                        ::SetWorldTransform(hdc, &xform);

                        RECT    dummyRect = {0,0,0,0};

                        status = player->EnumerateEmfRecords(hdc, hEmf, &dest,
                                                             &dummyRect, EnumEmfWithDownLevel);
                    }
                    else
                    {
                        UINT32 *    bits;
                        HBITMAP     hBitmap;

                        // The down-level records will get drawn into a dib section HDC
                        // which will then be drawn to the real hdc by g->DrawImage.
                        // !!! I should probably save the visible clip region at this
                        // point so that clipping in the EMF+ doesn't affect the down-level
                        // records.

                        // Set the World Tranform to be the PreContainer Transform
                        // And restore it after we're transformed the dest

                        player->BitmapDpi = Context->ContainerDpiX;
                        hBitmap = CreateDibSection32Bpp(hdc, destRect, dest, &bits, &player->BitmapDpi, &player->PreContainerMatrix);

                        status = GenericError;

                        if (hBitmap != NULL)
                        {
                            HDC     hdcDib = CreateCompatibleDC(NULL);

                            if (hdcDib != NULL)
                            {
                                // set up the player data
                                player->BitmapBits     = bits;
                                player->BitmapWidth    = dest.right;
                                player->BitmapHeight   = dest.bottom;
                                player->BitmapDestRect = destRect;

                                ::SelectObject(hdcDib, hBitmap);

                                status = player->EnumerateEmfRecords(hdcDib, hEmf, &dest,
                                                                     &dest, EnumEmfWithDownLevel);

                                ::DeleteDC(hdcDib);

                                // so DoneWithDownLevel call below works right
                                player->BitmapBits = NULL;
                            }
                            DeleteObject(hBitmap);
                        }
                        else if ((dest.right == 0) || (dest.bottom == 0))
                        {
                            status = Ok;
                        }
                    }
                }
            }
        }
        // else Nothing to play Everything is clipped out
    }

    // The Hdc should get set back to null when we reach the EMF+ EOF record
    // But clean up anyway, just in case something went wrong.
    player->DoneWithDownLevel();

    // Restore the HDC back to the state we initially set up.
    Context->ResetHdc();

    if (hwnd != NULL)
    {
        ReleaseDC(hwnd, hdc);

        // Now, restore the hwnd in the graphics context.
        Context->Hwnd = hwnd;
        Context->Hdc  = NULL;
    }
    else
    {
        // Now restore the HDC back to the real application state.
        RestoreDC(hdc, saveDC);

        if (needToReleaseHdc)
        {
            Context->ReleaseHdc(hdc);
        }
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   GpMetafile destructor
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpMetafile::~GpMetafile()
{
    CleanUp();
}

VOID
GpMetafile::CleanUp()
{
    if ((MetaGraphics != NULL) && (!RequestedMetaGraphics))
    {
        // If for some reason the app never requsted the MetaGraphics,
        // then we'd better delete it.
        delete MetaGraphics;
    }

    if (State == RecordingMetafileState)
    {
        // EndRecording was never called, which means that the MetaGraphics
        // was never deleted.  So clean things up and invalidate the
        // MetaGraphics.
        ASSERT(MetaGraphics->Metafile != NULL);
        MetaGraphics->Metafile->EndRecording(); // deletes the recorder
        // Endrecording sets the MetaGraphics to NULL so don't touch it anymore
        WARNING(("Deleted Metafile before deleting MetaGraphics"));
    }

    if ((Hemf != NULL) && DeleteHemf)
    {
        if (Header.IsEmfOrEmfPlus())
        {
            DeleteEnhMetaFile(Hemf);
        }
        else
        {
            DeleteMetaFile((HMETAFILE)Hemf);
        }
    }
    if (Filename != NULL)
    {
        GpFree(Filename);
    }
    else if (Stream != NULL)    // only for recording
    {
        // the stream position should already be at the end
        // of the metafile.
        Stream->Release();
    }

    delete Player;
}

extern "C"
int CALLBACK
EnumGetEmfPlusHeader(
    HDC                     hdc,    // should be NULL
    HANDLETABLE FAR *       gdiHandleTable,
    CONST ENHMETARECORD *   emfRecord,
    int                     numHandles,
    LPARAM                  emfPlusHeader
    )
{
    if ((emfRecord != NULL) && (emfRecord->nSize >= sizeof(EMR)) &&
        (emfPlusHeader != NULL))
    {
        if (emfRecord->iType == EMR_HEADER)
        {
            return 1;       // skip the header and keep enumerating
        }
        if (IsEmfPlusRecord(emfRecord) &&
            (emfRecord->nSize >= (sizeof(EMR) + sizeof(DWORD) + // comment data size
                                  sizeof(INT32) + // signature
                                  sizeof(EmfPlusRecord) +
                                  sizeof(EmfPlusHeaderRecord))))
        {
            GpMemcpy((VOID*)emfPlusHeader,
                     ((CONST EMRGDICOMMENT *)emfRecord)->Data + sizeof(INT32),
                     sizeof(EmfPlusRecord) + sizeof(EmfPlusHeaderRecord));
        }
    }
    else
    {
        WARNING(("Bad Enumeration Parameter"));
    }
    return 0;   // don't enumerate any more records
}


HENHMETAFILE
GetEmfFromWmfData(
    HMETAFILE hWmf,
    BYTE *    wmfData,
    UINT      size
    )
{
    if (wmfData == NULL ||
        hWmf == NULL ||
        size < (sizeof(METAHEADER)+sizeof(META_ESCAPE_ENHANCED_METAFILE)))
    {
        ASSERTMSG(FALSE, ("GetEmfFromWmfData: Someone passed an invalid argument"));
        return NULL;
    }

    HENHMETAFILE hemf32 = NULL;
    HDC hMFDC = NULL;
    PMETA_ESCAPE_ENHANCED_METAFILE pmfeEnhMF;
    PBYTE   pMetaData32 = (PBYTE) NULL;

    pmfeEnhMF = (PMETA_ESCAPE_ENHANCED_METAFILE) &wmfData[sizeof(METAHEADER)];
    if (IsMetaEscapeEnhancedMetafile(pmfeEnhMF))
    {
        UINT    i;
        UINT    cbMetaData32;

        if (pmfeEnhMF->fFlags != 0)
        {
            ASSERTMSG(FALSE, ("GetEmfFromWmfData: Unrecognized Windows metafile\n"));
            goto SWMFB_UseConverter;
        }

        // Validate checksum

        if (GetWordCheckSum(size, (PWORD) wmfData))
        {
            ASSERTMSG(FALSE, ("GetEmfFromWmfData: Metafile has been modified\n"));
            goto SWMFB_UseConverter;
        }

        // Unpack the data from the small chunks of metafile comment records
        // Windows 3.0 chokes on Comment Record > 8K?
        // We probably could probably just error out if out of memory but
        // lets try to convert just because the embedded comment might be bad.

        TERSE(("GetEmfFromWmfData: Using embedded enhanced metafile\n"));

        cbMetaData32 = (UINT) pmfeEnhMF->cbEnhMetaFile;
        if (!(pMetaData32 = (PBYTE) GpMalloc(cbMetaData32)))
        {
            ASSERTMSG(FALSE, ("GetEmfFromWmfData: LocalAlloc Failed"));
            goto SWMFB_UseConverter;
        }

        i = 0;
        do
        {
            if (i + pmfeEnhMF->cbCurrent > cbMetaData32)
            {
                ASSERTMSG(FALSE, ("GetEmfFromWmfData: Bad metafile comment"));
                goto SWMFB_UseConverter;
            }

            GpMemcpy(&pMetaData32[i], (PBYTE) &pmfeEnhMF[1], pmfeEnhMF->cbCurrent);
            i += (UINT) pmfeEnhMF->cbCurrent;
            pmfeEnhMF = (PMETA_ESCAPE_ENHANCED_METAFILE)
                ((PWORD) pmfeEnhMF + pmfeEnhMF->rdSize);
        } while (IsMetaEscapeEnhancedMetafile(pmfeEnhMF));

        if (i != cbMetaData32)
        {
            ASSERTMSG(FALSE, ("GetEmfFromWmfData: Insufficient metafile data"));
            goto SWMFB_UseConverter;
        }

        // Set the memory directly into the enhanced metafile and return the
        // metafile.

        hemf32 = SetEnhMetaFileBits(cbMetaData32, pMetaData32);
    }
SWMFB_UseConverter:
    if( hemf32 == NULL)
    {
        hMFDC = CreateEnhMetaFileA(NULL, NULL, NULL, NULL);
        if (hMFDC != NULL)
        {
            // Set the MapMode and Extent to
            INT iMapMode = MM_ANISOTROPIC;

            HDC hdcRef = ::GetDC(NULL);

            INT xExtPels = ::GetDeviceCaps(hdcRef, HORZRES);
            INT yExtPels = ::GetDeviceCaps(hdcRef, VERTRES);

            ::ReleaseDC(NULL, hdcRef);

            BOOL success = (::SetMapMode(hMFDC, iMapMode) &&
                            ::SetViewportExtEx(hMFDC, xExtPels, yExtPels, NULL) &&
                            ::SetWindowExtEx(hMFDC, xExtPels, yExtPels, NULL) &&
                            ::PlayMetaFile(hMFDC, hWmf));
            hemf32 = CloseEnhMetaFile(hMFDC);
            if ((!success) && (hemf32 != NULL))
            {
                DeleteEnhMetaFile(hemf32);
                hemf32 = NULL;
            }
        }
    }
    if (pMetaData32 != NULL)
    {
        GpFree(pMetaData32);
    }

    return hemf32 ;
}

GpStatus
GetEmfHeader(
    MetafileHeader &        header,
    ENHMETAHEADER3 &        emfHeader,
    EmfPlusRecord *         record,
    INT                     signature
    )
{
    GpStatus        status = Ok;

    // !!! how to handle versioning for shipping?
    // !!! allow different minor versions, but not major versions?

    EmfPlusHeaderRecord *   emfPlusHeader = (EmfPlusHeaderRecord *)(record + 1);

    // See if this is an EMF+ file
    if ((signature == EMFPLUS_SIGNATURE) &&
        (record->Size >= (sizeof(EmfPlusRecord) + sizeof(EmfPlusHeaderRecord))) &&
        (record->Type == EmfPlusRecordTypeHeader) &&
        (record->DataSize == (record->Size - sizeof(EmfPlusRecord))) &&
        (ObjectData::MajorVersionMatches(emfPlusHeader->Version)) &&
        (emfPlusHeader->LogicalDpiX > 0) &&
        (emfPlusHeader->LogicalDpiY > 0))
    {
        if (GetIsEmfPlusDual(record->Flags))
        {
            header.Type = MetafileTypeEmfPlusDual;
        }
        else
        {
            header.Type = MetafileTypeEmfPlusOnly;
        }
        header.EmfPlusHeaderSize = record->Size;
        header.Version           = emfPlusHeader->Version;
        header.EmfPlusFlags      = emfPlusHeader->EmfPlusFlags;
        header.LogicalDpiX       = emfPlusHeader->LogicalDpiX;
        header.LogicalDpiY       = emfPlusHeader->LogicalDpiY;
    }
    else
    {
        header.Type    = MetafileTypeEmf;
        header.Version = emfHeader.nVersion;
    }

    header.Size = emfHeader.nBytes;

    // EmfHeaderIsValid() verifies that these are all > 0
    REAL    dpmmX = ((REAL)(emfHeader.szlDevice.cx) /
                     (REAL)(emfHeader.szlMillimeters.cx));
    REAL    dpmmY = ((REAL)(emfHeader.szlDevice.cy) /
                     (REAL)(emfHeader.szlMillimeters.cy));

    header.DpiX = dpmmX * 25.4f;
    header.DpiY = dpmmY * 25.4f;

    INT     top;
    INT     left;
    INT     right;
    INT     bottom;

    // Make sure we have a normalized frameRect
    if (emfHeader.rclFrame.left <= emfHeader.rclFrame.right)
    {
        left  = emfHeader.rclFrame.left;
        right = emfHeader.rclFrame.right;
    }
    else
    {
        left  = emfHeader.rclFrame.right;
        right = emfHeader.rclFrame.left;
    }

    if (emfHeader.rclFrame.top <= emfHeader.rclFrame.bottom)
    {
        top    = emfHeader.rclFrame.top;
        bottom = emfHeader.rclFrame.bottom;
    }
    else
    {
        top    = emfHeader.rclFrame.bottom;
        bottom = emfHeader.rclFrame.top;
    }

    // Make the device bounds reflect the frameRect,
    // not the actual size of the drawing.
    dpmmX *= 0.01f;
    dpmmY *= 0.01f;

    // The frameRect is inclusive-inclusive, but the bounds in
    // the header is inclusive-exclusive.
    REAL    x = (REAL)(left) * dpmmX;
    REAL    y = (REAL)(top)  * dpmmY;
    REAL    w = ((REAL)(right  - left) * dpmmX) + 1.0f;
    REAL    h = ((REAL)(bottom - top)  * dpmmY) + 1.0f;

    header.X         = GpRound(x);
    header.Y         = GpRound(y);
    header.Width     = GpRound(w);
    header.Height    = GpRound(h);
    header.EmfHeader = emfHeader;

    if ((header.Width == 0) || (header.Height == 0))
    {
        status = InvalidParameter;
    }
    return status;
}

HENHMETAFILE
GetEmf(
    IStream *       stream,
    BOOL            isWmf,
    UINT            size
    )
{
    HENHMETAFILE    hEmf = NULL;
#if PROFILE_MEMORY_USAGE
    MC_LogAllocation(size);
#endif
    HGLOBAL         hGlobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_NODISCARD, size);

    if (hGlobal != NULL)
    {
        HRESULT     hResult;
        IStream *   memoryStream = NULL;

        hResult = CreateStreamOnHGlobal(hGlobal, TRUE, &memoryStream);
        if (HResultSuccess(hResult) && (memoryStream != NULL))
        {
            if (CopyStream(stream, memoryStream, size))
            {
                BYTE *  metaData = (BYTE *)GlobalLock(hGlobal);

                if (metaData != NULL)
                {
                    if (isWmf)
                    {
                        hEmf = (HENHMETAFILE)SetMetaFileBitsEx(size, metaData);
                    }
                    else
                    {
                        hEmf = SetEnhMetaFileBits(size, metaData);
                    }
                }
                GlobalUnlock(hGlobal);
            }
            memoryStream->Release();    // frees the memory
        }
        else
        {
            GlobalFree(hGlobal);
        }
    }
    return hEmf;
}


static VOID
GetWmfHeader(
    MetafileHeader &                header,
    METAHEADER &                    wmfHeader,
    const WmfPlaceableFileHeader *  wmfPlaceableFileHeader
    )
{
    ASSERT(WmfPlaceableHeaderIsValid(wmfPlaceableFileHeader));
    ASSERT(WmfHeaderIsValid(&wmfHeader));

    header.Type      = MetafileTypeWmfPlaceable;
    header.Size      = wmfHeader.mtSize * 2L;
    header.Version   = wmfHeader.mtVersion;
    header.WmfHeader = wmfHeader;

    if (wmfPlaceableFileHeader->Inch > 0)
    {
        header.DpiX = wmfPlaceableFileHeader->Inch;
        header.DpiY = wmfPlaceableFileHeader->Inch;
    }
    else    // guess at the Dpi
    {
        header.DpiX = 1440.0f;
        header.DpiY = 1440.0f;
        // Something wrong but continue
    }

    // already verified the checksum

    // Unlike the EMF header the Placeable header is Inclusive-Exclusive
    // So don't add 1 device unit
    if (wmfPlaceableFileHeader->BoundingBox.Left <
        wmfPlaceableFileHeader->BoundingBox.Right)
    {
        header.X      = wmfPlaceableFileHeader->BoundingBox.Left;
        header.Width  = wmfPlaceableFileHeader->BoundingBox.Right -
                        wmfPlaceableFileHeader->BoundingBox.Left;
    }
    else
    {
        header.X      = wmfPlaceableFileHeader->BoundingBox.Right;
        header.Width  = wmfPlaceableFileHeader->BoundingBox.Left -
                        wmfPlaceableFileHeader->BoundingBox.Right;
    }
    if (wmfPlaceableFileHeader->BoundingBox.Top <
        wmfPlaceableFileHeader->BoundingBox.Bottom)
    {
        header.Y      = wmfPlaceableFileHeader->BoundingBox.Top;
        header.Height = wmfPlaceableFileHeader->BoundingBox.Bottom -
                        wmfPlaceableFileHeader->BoundingBox.Top;
    }
    else
    {
        header.Y      = wmfPlaceableFileHeader->BoundingBox.Bottom;
        header.Height = wmfPlaceableFileHeader->BoundingBox.Top -
                        wmfPlaceableFileHeader->BoundingBox.Bottom;
    }
}

extern "C"
int CALLBACK
EnumWmfToGetHeader(
    HDC                     hdc,    // should be NULL
    HANDLETABLE FAR *       gdiHandleTable,
    METARECORD FAR *        wmfRecord,
    int                     numHandles,
    LPARAM                  wmfHeader
    )
{
    ASSERT(wmfHeader != NULL);

    if ((wmfRecord != NULL) &&
        (((UNALIGNED METARECORD *)wmfRecord)->rdSize >= 3))
    {
        // The first record that it gives us is the first one past the header,
        // not the header itself, so we have to back up on the pointer.
        GpMemcpy((VOID *)wmfHeader, ((BYTE *)wmfRecord) - sizeof(METAHEADER),
                 sizeof(METAHEADER));
    }
    else
    {
        WARNING(("Bad Enumeration Parameter"));
    }
    return 0;   // Don't enumerate any more records
}

GpStatus
GetMetafileHeader(
    HMETAFILE               hWmf,
    const WmfPlaceableFileHeader *   wmfPlaceableFileHeader,
    MetafileHeader &        header
    )
{
    ASSERT((hWmf != NULL) && (wmfPlaceableFileHeader != NULL));

    GpMemset(&header, 0, sizeof(header));

    if (WmfPlaceableHeaderIsValid(wmfPlaceableFileHeader))
    {
        METAHEADER      wmfHeader;

        GpMemset(&wmfHeader, 0, sizeof(wmfHeader));
        ::EnumMetaFile(NULL, hWmf, EnumWmfToGetHeader, (LPARAM)&wmfHeader);

        if (!WmfHeaderIsValid(&wmfHeader))
        {
            //ASSERT(WmfHeaderIsValid(&wmfHeader));
            WARNING(("GetMetafileHeader: WmfHeaderIsValid FAILED!"));
            wmfHeader.mtType         = MEMORYMETAFILE;
            wmfHeader.mtHeaderSize   = sizeof(METAHEADER) / sizeof(WORD);
            wmfHeader.mtVersion      = METAVERSION300;
            wmfHeader.mtSize         = GetMetaFileBitsEx(hWmf, 0, NULL) / 2;
            wmfHeader.mtNoObjects    = 0;
            wmfHeader.mtMaxRecord    = 0;
            wmfHeader.mtNoParameters = 0;
        }

        GetWmfHeader(header, wmfHeader, wmfPlaceableFileHeader);
        return Ok;
    }
    return InvalidParameter;
}

GpStatus
GetMetafileHeader(
    HENHMETAFILE        hEmf,
    MetafileHeader &    header,
    BOOL *              isCorrupted
    )
{
    ASSERT(hEmf != NULL);

    GpMemset(&header, 0, sizeof(header));

    ENHMETAHEADER3      emfHeader;

    if ((GetEnhMetaFileHeader(hEmf, sizeof(emfHeader),
                              (ENHMETAHEADER*)(&emfHeader)) <= 0) ||
        !EmfHeaderIsValid(emfHeader))
    {
        if (isCorrupted != NULL)
        {
            *isCorrupted = FALSE;
        }
        return InvalidParameter;
    }

    // Now we know it is an EMF

    BYTE    buffer[sizeof(EmfPlusRecord) + sizeof(EmfPlusHeaderRecord)];

    GpMemset(buffer, 0, sizeof(EmfPlusRecord) + sizeof(EmfPlusHeaderRecord));

    // No reason to enumerate the metafile if there are only
    // header and EOF records.
    if (emfHeader.nRecords > 2)
    {
        ::EnumEnhMetaFile(NULL, hEmf, EnumGetEmfPlusHeader, buffer, NULL);
    }

    GpStatus status;
    status = GetEmfHeader(header, emfHeader, (EmfPlusRecord *)buffer,
                          (((EmfPlusRecord *)buffer)->Size != 0) ? EMFPLUS_SIGNATURE : 0);

    if (isCorrupted != NULL)
    {
        *isCorrupted = (status != Ok);
    }
    return status;
}

GpStatus
GetEmfFromWmf(
    IStream        * stream,
    UINT             streamSize,
    MetafileHeader & header,
    HENHMETAFILE   * hEMF
    )
{
    if (stream == NULL || hEMF == NULL)
    {
        ASSERT(FALSE);
        return InvalidParameter;
    }

    GpStatus    status = Win32Error;
    IStream *   memStream;

    ASSERT(hEMF != NULL);
    *hEMF = NULL ;

    HMETAFILE hWMF = (HMETAFILE) GetEmf(stream, TRUE, streamSize);
    if (hWMF != NULL)
    {
        BYTE * wmfData = (BYTE*)GpMalloc(streamSize);
        if (wmfData != NULL)
        {
            GetMetaFileBitsEx(hWMF, streamSize, wmfData);
            *hEMF = GetEmfFromWmfData(hWMF, wmfData, streamSize);
            if (*hEMF != NULL)
            {
                status = GetMetafileHeader(*hEMF, header);
            }
            GpFree(wmfData);
        }
    }
    if (hWMF != NULL)
    {
        DeleteMetaFile(hWMF);
    }
    return status;
}

// If we fail, the stream position will be right where it started.
// If we succeed, the stream position will be at the end of the WMF/EMF
static GpStatus
GetHeaderAndMetafile(
    IStream *           stream,
    MetafileHeader &    header,
    HENHMETAFILE *      hEMF,   // We can have a NULL hEMF, then we just want the header.
    BOOL *              isCorrupted,
    BOOL                tryWmfOnly = FALSE
    )
{
    GpMemset(&header, 0, sizeof(header));
    if (stream == NULL || isCorrupted == NULL)
    {
        WARNING(("IN Parameter Stream or Corruption flag is NULL"));
        return InvalidParameter;
    }

    GpStatus            status = InvalidParameter;
    LONGLONG            startPosition;
    LONGLONG            streamSize;
    STATSTG             statstg;
    BOOL                corrupted = FALSE;

    // Save the start position of the metafile in case we have to try
    // more than once.
    if (!GetStreamPosition(stream, startPosition))
    {
        return Win32Error;
    }

    // We don't want to read past the end of the steam so make sure
    // that we don't exceed it. If we succeed the set the streamSize
    if(SUCCEEDED(stream->Stat(&statstg, STATFLAG_NONAME)))
    {
        streamSize = statstg.cbSize.QuadPart;
    }
    else
    {
        WARNING1("Couldn't get size of Stream");
        streamSize = INT_MAX;
    }

    if (!tryWmfOnly)
    {
        ENHMETAHEADER3      emfHeader;
        BOOL                isEmf;

        // Read the EMF header and make sure it's valid
        isEmf = (ReadBytes(stream, &emfHeader, sizeof(emfHeader)) &&
                 EmfHeaderIsValid(emfHeader));

        if (isEmf)
        {
            struct EmfPlusSecondMetafileRecord {
                EMR                 emr;
                DWORD               commentDataSize;
                INT32               signature;
                EmfPlusRecord       record;
                EmfPlusHeaderRecord emfPlusHeader;
            } secondRecord;

            GpMemset(&secondRecord, 0, sizeof(secondRecord));

            // No reason to read the metafile if there are only
            // header and EOF records.
            if ((emfHeader.nRecords > 2) &&
                (emfHeader.nBytes >= (emfHeader.nSize + sizeof(secondRecord))))
            {
                if (SeekFromStart(stream, startPosition + emfHeader.nSize))
                {
                    ReadBytes(stream, &secondRecord, sizeof(secondRecord));
                    if (!IsEmfPlusRecord((ENHMETARECORD *)&secondRecord))
                    {
                        // make sure that whatever data was there isn't
                        // interpreted as a EMF+ header
                        secondRecord.signature = 0;
                    }
                }
            }

            status = GetEmfHeader(header, emfHeader, &secondRecord.record, secondRecord.signature);

            // Seek back to the start of the metafile.
            if ((hEMF != NULL) && (status == Ok))
            {
                if (!SeekFromStart(stream, startPosition))
                {
                    *isCorrupted = TRUE;
                    return Win32Error;
                }

                
                *hEMF = GetEmf(stream, FALSE /*isWMF*/,
                               (UINT)min(header.GetMetafileSize(), streamSize - startPosition));
                if (*hEMF == NULL)
                {
                    status = GenericError;
                }
            }

            corrupted = (status != Ok);
            goto Exit;
        }

        // Seek back to the start of the metafile so we can try WMF
        if (!SeekFromStart(stream, startPosition))
        {
            *isCorrupted = FALSE;
            return Win32Error;
        }
    }

    // It's not an EMF, try a WMF
    {
        WmfPlaceableFileHeader  wmfPlaceableFileHeader;
        METAHEADER              wmfHeader;
        BOOL                    isPlaceable;
        BOOL                    isWMF;

        isPlaceable = (ReadBytes(stream, &wmfPlaceableFileHeader, sizeof(wmfPlaceableFileHeader)) &&
                   WmfPlaceableHeaderIsValid(&wmfPlaceableFileHeader) &&
                   ReadBytes(stream, &wmfHeader, sizeof(wmfHeader)) &&
                   WmfHeaderIsValid(&wmfHeader));

        if (isPlaceable)
        {
            GetWmfHeader(header, wmfHeader, &wmfPlaceableFileHeader);

            status = Ok;
            corrupted = FALSE;

            if (hEMF != NULL)
            {
                if (!SeekFromStart(stream, startPosition + sizeof(wmfPlaceableFileHeader)))
                {
                    *isCorrupted = TRUE;
                    return Win32Error;
                }

                *hEMF = GetEmf(stream, TRUE /* isWMF */,
                               (UINT)min(header.GetMetafileSize(), streamSize - (startPosition + sizeof(wmfPlaceableFileHeader))));
                if (*hEMF == NULL)
                {
                    status = GenericError;
                    corrupted = TRUE;
                }
            }
            goto Exit;
        }

        // We could have an placeableWmf header with bad data in it, so skip
        // the placeable header for subsequent access to the WMF.
        INT     wmfOffset = (wmfPlaceableFileHeader.Key == GDIP_WMF_PLACEABLEKEY) ?
                             sizeof(WmfPlaceableFileHeader) : 0;

        if (!SeekFromStart(stream, startPosition + wmfOffset))
        {
            *isCorrupted = FALSE;
            return Win32Error;
        }

        isWMF = (ReadBytes(stream, &wmfHeader, sizeof(wmfHeader)) &&
                 WmfHeaderIsValid(&wmfHeader));

        if (isWMF)
        {
            // Seek to the start of the WMF metafile.
            if (!SeekFromStart(stream, startPosition + wmfOffset))
            {
                *isCorrupted = TRUE;
                return Win32Error;
            }

            UINT    wmfSize = min((wmfHeader.mtSize * 2L),
                                  (UINT)(streamSize - (startPosition + wmfOffset)));

            if (hEMF != NULL)
            {
                status = GetEmfFromWmf(stream, wmfSize, header, hEMF);
            }
            else
            {
                HENHMETAFILE    tmpEMF = NULL;

                status = GetEmfFromWmf(stream, wmfSize, header, &tmpEMF);
                if (tmpEMF != NULL)
                {
                    DeleteEnhMetaFile(tmpEMF);
                }
            }
            corrupted = (status != Ok);
        }
    }

Exit:
    *isCorrupted = corrupted;
    if (status == Ok)
    {
        // set the stream position to the end of the metafile
        SeekFromStart(stream, startPosition + header.GetMetafileSize());
        return Ok;
    }

    // set the stream position to the start of the metafile
    SeekFromStart(stream, startPosition);
    return status;
}

VOID
GpMetafile::InitStream(
    IStream*                stream,
    BOOL                    tryWmfOnly
    )
{
    BOOL        isCorrupted = FALSE;

    // We just use the stream long enough to create an hEMF
    stream->AddRef();
    if ((GetHeaderAndMetafile(stream, Header, &Hemf, &isCorrupted, tryWmfOnly) == Ok) &&
        (Hemf != NULL))
    {
        State = DoneRecordingMetafileState;
    }
    else if (isCorrupted)
    {
        State = CorruptedMetafileState;
    }
    stream->Release();
}

GpStatus
GetMetafileHeader(
    IStream *           stream,
    MetafileHeader &    header,
    BOOL                tryWmfOnly
    )
{
    BOOL isCorrupted = FALSE;
    return GetHeaderAndMetafile(stream, header, NULL, &isCorrupted, tryWmfOnly);
}

GpStatus
GetMetafileHeader(
    const WCHAR *       filename,
    MetafileHeader &    header
    )
{
    GpStatus status = InvalidParameter;

    ASSERT(filename != NULL);

    if (filename != NULL)
    {
        const WCHAR* ext = UnicodeStringReverseSearch(filename, L'.');

        // Get a stream only long enough to validate the metafile
        IStream *   metaStream = CreateStreamOnFile(filename, GENERIC_READ);
        if (metaStream != NULL)
        {
            // apm is for a Placeable Metafile
            BOOL tryWmf = (ext &&
                           (UnicodeStringCompareCI(ext, L".WMF") ||
                            UnicodeStringCompareCI(ext, L".APM")));
            BOOL isCorrupted = FALSE;

            status = GetHeaderAndMetafile(metaStream, header, NULL, &isCorrupted, tryWmf);

            // if we tried a WMF, but it's not a WMF, then try an EMF
            if ((status != Ok) && tryWmf && !isCorrupted)
            {
                status = GetHeaderAndMetafile(metaStream, header, NULL, &isCorrupted, FALSE);
            }
            metaStream->Release();
        }
    }
    return status;
}

VOID
GpMetafile::InitWmf(
    HMETAFILE               hWmf,
    const WmfPlaceableFileHeader *   wmfPlaceableFileHeader,
    BOOL                    deleteWmf
    )
{
    // See if there is an wmfPlaceableFileHeader we can use
    if ((wmfPlaceableFileHeader != NULL) && (WmfPlaceableHeaderIsValid(wmfPlaceableFileHeader)))
    {
        if (GetMetafileHeader(hWmf, wmfPlaceableFileHeader, Header) == Ok)
        {
            DeleteHemf = (deleteWmf != 0);
            Hemf       = (HENHMETAFILE)hWmf;
            State      = DoneRecordingMetafileState;
            return;
        }
        else
        {
            // we know it's a WMF, but we couldn't get the header from it
            State = CorruptedMetafileState;
        }
    }
    else    // no valid wmfPlaceableFileHeader
    {
        // We can have a null or invalid header since we accept WMF files
        // (by turning them into EMFs).
        UINT size = GetMetaFileBitsEx(hWmf, 0, NULL);
        if (size > 0)
        {
            BYTE * wmfData = (BYTE*) GpMalloc(size);
            if (wmfData != NULL)
            {
                if (GetMetaFileBitsEx(hWmf, size, wmfData) > 0)
                {
                    HENHMETAFILE hEmf = GetEmfFromWmfData(hWmf, wmfData, size);
                    if (hEmf != NULL)
                    {
                        BOOL    isCorrupted;

                        if (GetMetafileHeader(hEmf, Header, &isCorrupted) == Ok)
                        {
                            // Since we created this EMF we need to delete it afterwards
                            DeleteHemf = TRUE;
                            Hemf       = hEmf;
                            State      = DoneRecordingMetafileState;
                        }
                        else
                        {
                            if (isCorrupted)
                            {
                                // we know it's a metafile, but we couldn't get the header
                                State = CorruptedMetafileState;
                            }
                            DeleteEnhMetaFile(hEmf);
                        }
                    }
                }
                GpFree(wmfData);
            }
        }
    }
    if (deleteWmf)
    {
        DeleteMetaFile(hWmf);
    }
}

VOID
GpMetafile::InitEmf(
    HENHMETAFILE            hEmf,
    BOOL                    deleteEmf
    )
{
    BOOL    isCorrupted;

    if (GetMetafileHeader(hEmf, Header, &isCorrupted) == Ok)
    {
        DeleteHemf = (deleteEmf != 0);
        Hemf       = hEmf;
        State      = DoneRecordingMetafileState;
        return;
    }
    if (deleteEmf)
    {
        DeleteEnhMetaFile(hEmf);
    }
    if (isCorrupted)
    {
        State = CorruptedMetafileState;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   GpMetafile constructor for read-only access to a metafile.
*
* Arguments:
*
*   [IN]  hWmf          - the handle to the metafile to open for playback
*   [IN]  wmfPlaceableFileHeader - the Placeable header to give size info about the WMF
*
* Return Value:
*
*   NONE
*
* Created:
*
*   10/06/1999 DCurtis
*
\**************************************************************************/
GpMetafile::GpMetafile(
    HMETAFILE               hWmf,
    const WmfPlaceableFileHeader *   wmfPlaceableFileHeader,
    BOOL                    deleteWmf
    ) : GpImage(ImageTypeMetafile)
{
    ASSERT(hWmf != NULL);

    InitDefaults();
    if (IsValidMetaFile(hWmf))
    {
        InitWmf(hWmf, wmfPlaceableFileHeader, deleteWmf);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   GpMetafile constructor for read-only access to a metafile.
*
* Arguments:
*
*   [IN]  hEmf - the handle to the metafile to open for playback
*
* Return Value:
*
*   NONE
*
* Created:
*
*   10/06/1999 DCurtis
*
\**************************************************************************/
GpMetafile::GpMetafile(
    HENHMETAFILE        hEmf,
    BOOL                deleteEmf
    ) : GpImage(ImageTypeMetafile)
{
    ASSERT(hEmf != NULL);

    InitDefaults();
    if (GetObjectTypeInternal(hEmf) == OBJ_ENHMETAFILE)
    {
        InitEmf(hEmf, deleteEmf);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   GpMetafile constructor for read-only access to a metafile.
*
* Arguments:
*
*   [IN]  filename - the metafile to open for playback
*
* Return Value:
*
*   NONE
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpMetafile::GpMetafile(
    const WCHAR*            filename,
    const WmfPlaceableFileHeader *   wmfPlaceableFileHeader
    ) : GpImage(ImageTypeMetafile)
{
    ASSERT(filename != NULL);

    InitDefaults();

    if ((Filename = UnicodeStringDuplicate(filename)) != NULL)
    {
        const WCHAR* ext = UnicodeStringReverseSearch(filename, L'.');

        // apm is for a Placeable Metafile
        BOOL    tryWmf = ((wmfPlaceableFileHeader != NULL) ||
                          (ext &&
                           (!UnicodeStringCompareCI(ext, L".WMF") ||
                            !UnicodeStringCompareCI(ext, L".APM"))));

        BOOL    triedEmf = FALSE;

        AnsiStrFromUnicode nameStr(filename);

        // If possible, use the filename to create the metafile handle
        // so that we don't have to load the metafile into memory
        // (GDI uses memory mapped files to access the metafile data).
        if (Globals::IsNt || nameStr.IsValid())
        {
TryWmf:
            if (tryWmf)
            {
                HMETAFILE   hWmf;

                if (Globals::IsNt)
                {
                    hWmf = ::GetMetaFileW(filename);
                }
                else
                {
                    hWmf = ::GetMetaFileA(nameStr);
                }

                if (hWmf != NULL)
                {
                    InitWmf(hWmf, wmfPlaceableFileHeader, TRUE);
                    if (IsValid() || IsCorrupted())
                    {
                        return;
                    }
                }
                else // might be a Placeable WMF file
                {
                    IStream *   metaStream = CreateStreamOnFile(filename, GENERIC_READ);
                    if (metaStream != NULL)
                    {
                        InitStream(metaStream, TRUE /* tryWmfOnly */);
                        metaStream->Release();
                        if (IsValid() || IsCorrupted())
                        {
                            return;
                        }
                    }
                }
            }
            if (!triedEmf)
            {
                triedEmf = TRUE;

                HENHMETAFILE    hEmf;

                if (Globals::IsNt)
                {
                    hEmf = ::GetEnhMetaFileW(filename);
                }
                else
                {
                    hEmf = ::GetEnhMetaFileA(nameStr);
                }

                if (hEmf != NULL)
                {
                    InitEmf(hEmf, TRUE);
                    if (IsValid() || IsCorrupted())
                    {
                        return;
                    }
                }
                if (!tryWmf)
                {
                    tryWmf = TRUE;
                    goto TryWmf;
                }
            }
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*   GpMetafile constructor for read-only access to a metafile.
*
* Arguments:
*
*   [IN]  stream - the metafile to read for playback
*
* Return Value:
*
*   NONE
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpMetafile::GpMetafile(
    IStream*        stream
    ) : GpImage(ImageTypeMetafile)
{
    ASSERT(stream != NULL);

    InitDefaults();
    InitStream(stream);
}

GpStatus
GpMetafile::GetHemf(
    HENHMETAFILE *      hEmf
    ) const
{
    if ((State == DoneRecordingMetafileState) ||
        (State == ReadyToPlayMetafileState))
    {
        ASSERT(Hemf != NULL);
        *hEmf = Hemf;
        Hemf = NULL;
        State = InvalidMetafileState;
        return Ok;
    }
    *hEmf = NULL;
    return InvalidParameter;
}

GpStatus
GpMetafile::PrepareToPlay(
    GpGraphics *            g,
    GpRecolor *             recolor,
    ColorAdjustType         adjustType,
    EnumerateMetafileProc   enumerateCallback,
    VOID *                  callbackData,
    DrawImageAbort          drawImageCallback,
    VOID*                   drawImageCallbackData
    ) const
{
    if (State == DoneRecordingMetafileState)
    {
        ASSERT(Hemf != NULL);
        if (Player == NULL)
        {
            // Create a Player object
            Player = new MetafilePlayer(g, MaxStackSize, recolor, adjustType,
                                        enumerateCallback, callbackData,
                                        drawImageCallback,
                                        drawImageCallbackData
                                        );
            if (!CheckValid(Player))
            {
                return GenericError;
            }
        }
        State = ReadyToPlayMetafileState;
        return Ok;
    }
    if (State == ReadyToPlayMetafileState)
    {
        ASSERT(Hemf != NULL);
        ASSERT(Player != NULL);
        Player->PrepareToPlay(g, recolor, adjustType, enumerateCallback,
                              callbackData,
                              drawImageCallback,
                              drawImageCallbackData
                              );
        return Ok;
    }
    return InvalidParameter;
}

GpStatus
GpMetafile::EnumerateForPlayback(
    const RectF &           destRect,
    const RectF &           srcRect,
    Unit                    srcUnit,
    GpGraphics *            g,
    EnumerateMetafileProc   callback,       // if null, just play the metafile
    VOID *                  callbackData,
    GpRecolor *             recolor,
    ColorAdjustType         adjustType,
    DrawImageAbort          drawImageCallback,
    VOID*                   drawImageCallbackData
    ) const
{
    ASSERT (IsValid());

    if ((destRect.Width == 0) || (destRect.Height == 0) ||
        (srcRect.Width  == 0) || (srcRect.Height  == 0) ||
        (Header.IsEmf() && (Header.EmfHeader.nRecords <= 2)))
    {
        return Ok;  // nothing to play
    }

    GpRectF     metaSrcRect  = srcRect;
    GpRectF     metaDestRect = destRect;

    // The metafile player does not handle negative width/height
    // in srcRect and destRect, so handle any negative values
    // by setting up a flipping transform.

    GpMatrix    flipMatrix; // starts as identity

    BOOL    posWidths;
    BOOL    posHeights;

    posWidths  = ((metaSrcRect.Width  >= 0) && (metaDestRect.Width  >= 0));
    posHeights = ((metaSrcRect.Height >= 0) && (metaDestRect.Height >= 0));

    if (!posWidths || !posHeights)
    {
        if (!posWidths)
        {
            if (metaSrcRect.Width < 0)
            {
                if (metaDestRect.Width < 0)
                {
                    posWidths = TRUE;
                    metaSrcRect.X      = metaSrcRect.GetRight();
                    metaSrcRect.Width  = -(metaSrcRect.Width);
                    metaDestRect.X     = metaDestRect.GetRight();
                    metaDestRect.Width = -(metaDestRect.Width);
                }
                else
                {
                    metaSrcRect.X      = metaSrcRect.GetRight();
                    metaSrcRect.Width  = -(metaSrcRect.Width);
                }
            }
            else    // metaDestRect.Width < 0
            {
                metaDestRect.X     = metaDestRect.GetRight();
                metaDestRect.Width = -(metaDestRect.Width);
            }
        }
        if (!posHeights)
        {
            if (metaSrcRect.Height < 0)
            {
                if (metaDestRect.Height < 0)
                {
                    posHeights = TRUE;
                    metaSrcRect.Y       = metaSrcRect.GetBottom();
                    metaSrcRect.Height  = -(metaSrcRect.Height);
                    metaDestRect.Y      = metaDestRect.GetBottom();
                    metaDestRect.Height = -(metaDestRect.Height);
                }
                else
                {
                    metaSrcRect.Y      = metaSrcRect.GetBottom();
                    metaSrcRect.Height = -(metaSrcRect.Height);
                }
            }
            else    // metaDestRect.Height < 0
            {
                metaDestRect.Y      = metaDestRect.GetBottom();
                metaDestRect.Height = -(metaDestRect.Height);
            }
        }
        REAL    scaleX = 1.0f;
        REAL    scaleY = 1.0f;
        REAL    dX     = 0.0f;
        REAL    dY     = 0.0f;

        // Create a matrix that is the equivalent of:
        //      1) translate to the origin
        //      2) do the flip
        //      3) translate back
        if (!posWidths)
        {
            scaleX = -1.0f;
            dX     = metaDestRect.X + metaDestRect.GetRight();
        }
        if (!posHeights)
        {
            scaleY = -1.0f;
            dY     = metaDestRect.Y + metaDestRect.GetBottom();
        }

        flipMatrix.Translate(dX, dY, MatrixOrderPrepend);
        flipMatrix.Scale(scaleX, scaleY, MatrixOrderPrepend);
    }

    // Note that even though the visibility of the destRect might be
    // fully visible, we should still setup the clipping because:
    //    (1) we might do cropping based on the srcRect
    //    (2) the frameRect of the metafile might not include all
    //        the actual drawing within the metafile.

    GpStatus            status = GenericError;

    // Must convert the source rect into UnitPixels (if not already
    // in pixel units), to account for the dpi of the source metafile.
    REAL    multiplierX;
    REAL    multiplierY;

    GetPixelMultipliers(srcUnit, Header.GetDpiX(), Header.GetDpiY(),
                        &multiplierX, &multiplierY);

    GpRectF     pixelsSrcRect;

    pixelsSrcRect.X      = metaSrcRect.X * multiplierX;
    pixelsSrcRect.Y      = metaSrcRect.Y * multiplierY;
    pixelsSrcRect.Width  = metaSrcRect.Width  * multiplierX;
    pixelsSrcRect.Height = metaSrcRect.Height * multiplierY;

    INT     saveId = g->Save();

    if (saveId != 0)
    {
        // We need to take into account the region from the source that we
        // are drawing in order to do that we need to re-translate and
        // rescale and the transform. The clipping will take care of only
        // drawing the region that we are interested in.
        // In order to acheive this we need to translate the dest rect back
        // to the origin. Scale it by the same factor as the scale of the
        // src rect and then translate it back to when it should be which
        // is the scaled version of the left cropping of the src image.
        GpMatrix    preFlipPreCropTransform;
        g->GetWorldTransform(preFlipPreCropTransform);

        // apply the flipping transform
        g->MultiplyWorldTransform(flipMatrix, MatrixOrderPrepend);

        BOOL    widthsDifferent  = (Header.Width  != pixelsSrcRect.Width);
        BOOL    heightsDifferent = (Header.Height != pixelsSrcRect.Height);
        BOOL    cropOrOffset     = ((Header.X != pixelsSrcRect.X) ||
                                    (Header.Y != pixelsSrcRect.Y) ||
                                    widthsDifferent || heightsDifferent);

        if (cropOrOffset)
        {
            g->TranslateWorldTransform(((((REAL)(Header.X - pixelsSrcRect.X))
                                         *metaDestRect.Width) /pixelsSrcRect.Width)
                                        + metaDestRect.X,
                                       ((((REAL)(Header.Y - pixelsSrcRect.Y))
                                         *metaDestRect.Height)/pixelsSrcRect.Height)
                                        + metaDestRect.Y);

            REAL    xScale       = 1.0f;
            REAL    yScale       = 1.0f;

            if (widthsDifferent)
            {
                xScale = (REAL) Header.Width / pixelsSrcRect.Width;
            }
            if (heightsDifferent)
            {
                yScale = (REAL) Header.Height / pixelsSrcRect.Height;
            }
            g->ScaleWorldTransform(xScale, yScale);

            g->TranslateWorldTransform(-metaDestRect.X, -metaDestRect.Y);
        }

        // We don't use the deviceRect if we're rendering to a bitmap.
        GpMatrix    flipAndCropTransform;
        GpRectF     deviceRect = metaDestRect;

        // sets the PreContainerMatrix to the WorldToDevice Transform, which
        // includes the flipping and cropping transforms.
        if ((status = this->PrepareToPlay(g, recolor, adjustType,
                                          callback, callbackData,
                                          drawImageCallback,
                                          drawImageCallbackData)) != Ok)
        {
            goto CleanUp;
        }

        ASSERT(Player != NULL);

        State = PlayingMetafileState;

        BOOL        renderToBitmap   = FALSE;
        GpMatrix *  playMatrix       = &(Player->PreContainerMatrix);
        BOOL        isTranslateScale = playMatrix->IsTranslateScale();

        // On Win9x and WinNT (except Whistler and beyond), stretchblt calls
        // don't work if there is any flipping.

        // On Win9x text does not work if there is any flipping.
        // On WinNT, bitmap fonts don't work for 90,180,270 degree rotation
        // (but we map all bitmap fonts to true-type fonts anyway).

        if (isTranslateScale)
        {
            // if there is any flipping, render to a bitmap
            if ((playMatrix->GetM11() < 0.0f) ||
                (playMatrix->GetM22() < 0.0f))
            {
                isTranslateScale = FALSE;
                renderToBitmap   = TRUE;
            }
        }
        else
        {
            // It's okay to render rotated directly to the HDC on NT,
            // unless the dest is a metafile or the src is a WMF.
            renderToBitmap = (!Globals::IsNt ||
                              (g->Type == GpGraphics::GraphicsMetafile) ||
                              Header.IsWmf());
        }

        // Save what we have done into flipAndCropTransform. We will prepare the
        // container with this world transform since the precontainerMatrix
        // is only for the Downlevel and it needs that modified transform
        g->GetWorldTransform(flipAndCropTransform);

        // Restore the world transform to it's original self
        // (w/o flipping and cropping transform applied).
        g->SetWorldTransform(preFlipPreCropTransform);

        // When we render to a bitmap, we render the entire metafile to
        // the entire bitmap and then we clip out the cropped part of the
        // metafile from the bitmap.  So we have to set the clipping
        // when we render to a bitmap if there is any cropping.

        // It would be nice as an enhancement to just draw to a pre-cropped
        // bitmap instead of clipping out part of the bitmap, but the math
        // for that is tricky.
        if ((!renderToBitmap) || cropOrOffset)
        {
            GpMatrix    worldToDeviceTransform;
            g->GetWorldToDeviceTransform(&worldToDeviceTransform);
            if (isTranslateScale)
            {
                worldToDeviceTransform.TransformRect(deviceRect);
            }

            // Don't set the clipping if we're rendering to a bitmap,
            // because the rendering into the bitmap will do the clipping
            // automatically, and if we also clip against the graphics, we
            // sometimes clip too much, which can cause jagged edges on
            // rotated metafiles.

            // Clipping into a metafile causes problems.  For example, if
            // we're drawing outside the bounds of the referenece HDC, it
            // works fine, but then when we add clipping into the HDC, it doesn't
            // work anymore -- nothing gets drawn into the metafile, even though
            // everything is within the clipping rect (but the clipping rect is
            // outside the bounds of the reference HDC).

            if (g->Type != GpGraphics::GraphicsMetafile)
            {
                if ((!(renderToBitmap && cropOrOffset)) && isTranslateScale)
                {
                    g->SetClip(metaDestRect, CombineModeIntersect);
                }
                else    // rendering to a bitmap with cropping or
                        // rotating to the screen 
                {
                    // Since we want the filtered (smooth) edges on the
                    // bitmap, we have to add in a little extra room on
                    // the edges of our clip rect.

                    // On rotations we need to inflate by one pixel also
                    // because it seems that GDI doesn't rasterize clipregions
                    // the same we that it rasterized rects. Do rects on the
                    // edges can have pixels missing. We might be introducing
                    // more pixels that should have been clipped out but we
                    // can live with that for now.

                    GpRectF     tmpClipRect = metaDestRect;
                    REAL        xSize;
                    REAL        ySize;

                    g->GetWorldPixelSize(xSize, ySize);

                    // add 1 pixel all the way around
                    tmpClipRect.Inflate(xSize, ySize);

                    g->SetClip(tmpClipRect, CombineModeIntersect);
                }

                if (isTranslateScale)
                {
                    // We need to intersect the destRect with the Visible Clip
                    // in order to make sure that we don't draw outside the bounds
                    // in Win9x since we can't use a MetaRgn
                    GpRectF clipBounds;
                    g->GetVisibleClipBounds(clipBounds);
                    worldToDeviceTransform.TransformRect(clipBounds);
                    GpRectF::Intersect(deviceRect, deviceRect, clipBounds);
                }
            }
        }

        // If we're playing an EMF+ into another metafile, we have to be
        // careful not to double-transform points.  The HDC will have
        // the srcRect to destRect transform in it, and the graphics might
        // have a transform too, so we can end up double-transforming the
        // points of any GDI+ records that are in an EMF+ file.

        // One easy way to get around that is that if we are playing an
        // EMF+ dual, we could just play the down-level records (i.e. play it
        // as an EMF, not an EMF+), so that all the records get transformed
        // the same way.  But of course, that doesn't work if it's an
        // EMF+ only file.  A solution that works for both EMF+ dual and
        // EMF+ only is to force the GDI+ transform to be the identity so that
        // the down-level records that are generated by DriverMeta are in
        // the original coordinate system of the metafile, not in the
        // destination coordinate system (which then get transformed again
        // erroneously).
        if (Header.IsWmf() || Header.IsEmf())
        {
            status = g->EnumEmf(Player, Hemf, metaDestRect, pixelsSrcRect,
                                deviceRect, Header.GetType(),
                                isTranslateScale, renderToBitmap,
                                flipAndCropTransform);
        }
        else
        {
            ASSERT(Header.IsEmfPlus());

            // When playing from a metafile into a metafile, Win9x does NOT
            // allow you to override (reset) the srcRect->destRect metafile
            // transform.  So to keep from double transforming the records,
            // we have to set the GDI+ transform to identity, instead of
            // setting the HDC transform to identity as we would typically do.

            // When rendering to a bitmap, we don't have to worry about
            // double-transforming, because we play the metafile to the
            // bitmap HDC, not to the dest metafile hdc, so there won't
            // be a transform on the metafile hdc to mess us up.

            INT containerId;

            if ((g->Type != GpGraphics::GraphicsMetafile) || renderToBitmap)
            {
                // Now apply the flipping matrix.
                // The g->Restore call below will reset the transform.
                g->MultiplyWorldTransform(flipMatrix, MatrixOrderPrepend);

                GpRectF gdiDestRect = metaDestRect;

                // We need to calculate our transform so that the last point in the
                // src maps to the last point in the destination. This is how GDI does
                // it and we also need to do it so that we can play metafile properly
                if (pixelsSrcRect.Width >= 2.0f)
                {
                    pixelsSrcRect.Width -= 1.0f;
                }
                if (pixelsSrcRect.Height >= 2.0f)
                {
                    pixelsSrcRect.Height -= 1.0f;
                }

                if (gdiDestRect.Width >= 2.0f)
                {
                    gdiDestRect.Width -= 1.0f;
                }
                if (gdiDestRect.Height >= 2.0f)
                {
                    gdiDestRect.Height -= 1.0f;
                }

                containerId = g->BeginContainer(
                                        gdiDestRect,
                                        pixelsSrcRect,
                                        UnitPixel,
                                        (REAL)Header.LogicalDpiX,
                                        (REAL)Header.LogicalDpiY,
                                        Header.IsDisplay());
            }
            else    // we're drawing into a metafile
            {
                containerId = g->BeginContainer(
                                        TRUE,   // force xform to identity
                                        (REAL)Header.LogicalDpiX,
                                        (REAL)Header.LogicalDpiY,
                                        Header.IsDisplay());
            }

            if (containerId != 0)
            {
                // There may be GDI records that we need to play!
                status = g->EnumEmfPlusDual(Player, Hemf, metaDestRect,
                                            deviceRect, isTranslateScale, 
                                            renderToBitmap);
                g->EndContainer(containerId);
                Player->DonePlaying();  // free up objects created by Player
            }
            // make sure the status reflect the abort state of the player
            ASSERT(!Player->EnumerateAborted || (status == Aborted));
        }
CleanUp:
        g->Restore(saveId);
    }

    // Don't change the state unless we were playing the metafile
    if (State == PlayingMetafileState)
    {
        State = ReadyToPlayMetafileState;
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Initialize the metafile object members to their default values.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
VOID
GpMetafile::InitDefaults()
{
    ThreadId                = 0;
    State                   = InvalidMetafileState;
    Filename                = NULL;
    Stream                  = NULL;
    Hemf                    = NULL;
    MetaGraphics            = NULL;
    Player                  = NULL;
    MaxStackSize            = GDIP_SAVE_STACK_SIZE;
    DeleteHemf              = TRUE;
    RequestedMetaGraphics   = FALSE;

    GpMemset(&Header, 0, sizeof(Header));

    // Set the version for recording.  If we're plyaing back,
    // this will get overwritten later.
    Header.Version          = EMFPLUS_VERSION;
}

GpStatus
GpMetafile::GetImageInfo(
    ImageInfo *     imageInfo
    ) const
{
    ASSERT(imageInfo != NULL);
    ASSERT(IsValid());

    if ((State == DoneRecordingMetafileState) ||
        (State == ReadyToPlayMetafileState))
    {
        if (Header.IsEmfOrEmfPlus())
        {
            imageInfo->RawDataFormat = IMGFMT_EMF;
        }
        else    // Wmf
        {
            imageInfo->RawDataFormat = IMGFMT_WMF;
        }

        imageInfo->PixelFormat = PIXFMT_32BPP_RGB;
        imageInfo->Width       = Header.Width;
        imageInfo->Height      = Header.Height;
        imageInfo->TileWidth   = Header.Width;
        imageInfo->TileHeight  = 1;
        imageInfo->Xdpi        = Header.DpiX;
        imageInfo->Ydpi        = Header.DpiY;
        imageInfo->Flags       = SinkFlagsTopDown |
                                 SinkFlagsFullWidth |
                                 SinkFlagsScalable |
                                 SinkFlagsHasAlpha;

        return Ok;
    }
    return InvalidParameter;
}

GpImage *
GpMetafile::Clone() const
{
    GpMetafile *    clonedMetafile = NULL;

    if ((State == DoneRecordingMetafileState) ||
        (State == ReadyToPlayMetafileState))
    {
        if (Header.IsEmfOrEmfPlus())
        {
            HENHMETAFILE    hEmf = CopyEnhMetaFileA(Hemf, NULL);

            if (hEmf != NULL)
            {
                clonedMetafile = new GpMetafile(hEmf, TRUE);
                if (clonedMetafile != NULL)
                {
                    if (!clonedMetafile->IsValid())
                    {
                        DeleteEnhMetaFile(hEmf);
                        clonedMetafile->Hemf = NULL;
                        clonedMetafile->Dispose();
                        clonedMetafile = NULL;
                    }
                }
            }
        }
        else    // Wmf
        {
            HMETAFILE       hWmf = CopyMetaFileA((HMETAFILE)Hemf, NULL);

            if (hWmf != NULL)
            {
                WmfPlaceableFileHeader   wmfPlaceableFileHeader;

                wmfPlaceableFileHeader.Key                = GDIP_WMF_PLACEABLEKEY;
                wmfPlaceableFileHeader.Hmf                = 0;
                wmfPlaceableFileHeader.BoundingBox.Left   = static_cast<INT16>(Header.X);
                wmfPlaceableFileHeader.BoundingBox.Right  = static_cast<INT16>(Header.X + Header.Width);
                wmfPlaceableFileHeader.BoundingBox.Top    = static_cast<INT16>(Header.Y);
                wmfPlaceableFileHeader.BoundingBox.Bottom = static_cast<INT16>(Header.Y + Header.Height);
                wmfPlaceableFileHeader.Inch               = static_cast<INT16>(GpRound(Header.DpiX));
                wmfPlaceableFileHeader.Reserved           = 0;
                wmfPlaceableFileHeader.Checksum           = GetWmfPlaceableCheckSum(&wmfPlaceableFileHeader);

                clonedMetafile = new GpMetafile(hWmf, &wmfPlaceableFileHeader, TRUE);
                if (clonedMetafile != NULL)
                {
                    if (!clonedMetafile->IsValid())
                    {
                        DeleteMetaFile(hWmf);
                        clonedMetafile->Hemf = NULL;
                        clonedMetafile->Dispose();
                        clonedMetafile = NULL;
                    }
                }
            }
        }
    }
    return clonedMetafile;
}

GpImage*
GpMetafile::CloneColorAdjusted(
    GpRecolor *             recolor,
    ColorAdjustType         adjustType
    ) const
{
    ASSERT(recolor != NULL);

    if ((State == DoneRecordingMetafileState) ||
        (State == ReadyToPlayMetafileState))
    {
        GpMetafile* clonedMetafile;

        // FrameRect is Inclusive-Inclusive so subtrace 1 device unit
        GpRectF     frameRect((REAL)Header.X, (REAL)Header.Y,
                              (REAL)(Header.Width - 1), (REAL)(Header.Height - 1));
        EmfType     type;

        if (Header.Type <= MetafileTypeEmf)
        {
            type = EmfTypeEmfOnly;
        }
        else
        {
            // we don't need the down-level dual sections for embedded files
            type = EmfTypeEmfPlusOnly;
        }

        // It doesn't matter if we lose the description string, since this
        // metafile is just being embedded inside another one anyway.
        clonedMetafile = new GpMetafile(Globals::DesktopIc, type,
                                        &frameRect,MetafileFrameUnitPixel,NULL);

        if ((clonedMetafile != NULL) &&
            (clonedMetafile->IsValid()))
        {
            GpStatus    status;
            GpPageUnit  srcUnit;
            GpRectF     srcRect;
            GpGraphics *    g = clonedMetafile->GetGraphicsContext();
            ASSERT (g != NULL);

            this->GetBounds(&srcRect, &srcUnit);

            // We pass Inclusive-Exclusive bounds to play so add 1 device
            // unit to the framerect
            frameRect.Width++;
            frameRect.Height++;
            status = this->Play(frameRect, srcRect, srcUnit, g, recolor, adjustType);

            delete g;

            if ((status == Ok) &&
                (clonedMetafile->State == DoneRecordingMetafileState))
            {
                return clonedMetafile;
            }
        }
        delete clonedMetafile;
    }
    return NULL;
}

GpStatus
GpMetafile::ColorAdjust(
    GpRecolor *             recolor,
    ColorAdjustType         adjustType
    )
{
    ASSERT(recolor != NULL);

    GpMetafile *    clone;

    if (DeleteHemf &&
        ((clone = (GpMetafile *)CloneColorAdjusted(recolor, adjustType)) != NULL))
    {
        CleanUp();
        InitDefaults();

        if (GetMetafileHeader(clone->Hemf, Header) == Ok)
        {
            Hemf       = clone->Hemf;
            DeleteHemf = TRUE;
            State      = DoneRecordingMetafileState;
            clone->DeleteHemf = FALSE;
            delete clone;
            return Ok;
        }
    }
    return GenericError;
}

VOID
GpMetafile::Dispose()
{
    delete this;
}

class RemoveDualRecords
{
public:
    BYTE *      MetaData;
    INT         Size;
    INT         NumRecords;
    BOOL        GetGdiRecords;

    RemoveDualRecords()
    {
        Init();
    }

    VOID Init()
    {
        MetaData      = NULL;
        Size          = 0;
        NumRecords    = 0;
        GetGdiRecords = TRUE;   // so we write the EMR_HEADER record
    }

    VOID GetRecord(CONST ENHMETARECORD * emfRecord)
    {
        UINT    recordSize = emfRecord->nSize;

        if (MetaData != NULL)
        {
            GpMemcpy(MetaData, emfRecord, recordSize);
            MetaData += recordSize;
        }
        Size += recordSize;
        NumRecords++;
    }
};

extern "C"
int CALLBACK
EnumEmfRemoveDualRecords(
    HDC                     hdc,    // should be NULL
    HANDLETABLE FAR *       gdiHandleTable,
    CONST ENHMETARECORD *   emfRecord,
    int                     numHandles,
    LPARAM                  removeDualRecords
    )
{
    if ((emfRecord != NULL) && (emfRecord->nSize >= sizeof(EMR)) &&
        (removeDualRecords != NULL))
    {
        if (IsEmfPlusRecord(emfRecord))
        {
            // See if the last record of this set of EMF+ records is a GetDC
            // record.  If it is, then we know to play the next set of
            // GDI records that we encounter.

            // I prefer not to have to parse through all these records,
            // but there is always the slight possibility that this will
            // result in a false positive.  But the worst thing that can
            // happen is that we write a little too much data to the stream.

            EmfPlusRecord *     lastRecord;

            lastRecord = (EmfPlusRecord *)(((BYTE *)emfRecord) + emfRecord->nSize -
                                           sizeof(EmfPlusRecord));

            ((RemoveDualRecords *)removeDualRecords)->GetGdiRecords =
                ((lastRecord->Type == EmfPlusRecordTypeGetDC) &&
                 (lastRecord->Size == sizeof(EmfPlusRecord)) &&
                 (lastRecord->DataSize == 0));
        }
        else if ((emfRecord->iType != EMR_EOF) &&   // Write EOF record
                 (!(((RemoveDualRecords *)removeDualRecords)->GetGdiRecords)))
        {
            return 1;   // skip this GDI record
        }
        ((RemoveDualRecords *)removeDualRecords)->GetRecord(emfRecord);
    }
    else
    {
        WARNING(("Bad Enumeration Parameter"));
    }
    return 1;
}

extern "C"
int CALLBACK
EnumEmfToStream(
    HDC                     hdc,            // handle to device context
    HANDLETABLE FAR *       gdiHandleTable, // pointer to metafile handle table
    CONST ENHMETARECORD *   emfRecord,      // pointer to metafile record
    int                     numHandles,     // count of objects
    LPARAM                  stream          // pointer to optional data
    )
{
    if ((emfRecord != NULL) && (emfRecord->nSize >= sizeof(EMR)) &&
        (stream != NULL))
    {
        ((IStream *)stream)->Write(emfRecord, emfRecord->nSize, NULL);
    }
    else
    {
        WARNING(("Bad Enumeration Parameter"));
    }
    return 1;
}

class MetafileData : public ObjectTypeData
{
public:
    INT32       MetaType;
    INT32       MetaDataSize;
};

/**************************************************************************\
*
* Function Description:
*
*   Get the metafile data.
*
* Arguments:
*
*   [IN] dataBuffer - fill this buffer with the data
*   [IN/OUT] size   - IN - size of buffer; OUT - number bytes written
*
* Return Value:
*
*   GpStatus - Ok or error code
*
* Created:
*
*   9/13/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpMetafile::GetData(
    IStream *   stream
    ) const
{
    ASSERT (stream != NULL);

    if ((State != DoneRecordingMetafileState) &&
        (State != ReadyToPlayMetafileState))
    {
        WARNING(("Wrong State To GetData"));
        return WrongState;
    }

    ASSERT(Hemf != NULL);

    MetafileData    metafileData;
    metafileData.Type = ImageTypeMetafile;

    if (Header.IsWmf())
    {
        INT     wmfDataSize = GetMetaFileBitsEx((HMETAFILE)Hemf, 0, NULL);

        if (wmfDataSize <= 0)
        {
            WARNING(("Empty WMF"));
            return Win32Error;
        }

        BYTE *  wmfData = (BYTE *)GpMalloc(wmfDataSize);
        if (wmfData == NULL)
        {
            return OutOfMemory;
        }

        if (GetMetaFileBitsEx((HMETAFILE)Hemf, wmfDataSize, wmfData) == 0)
        {
            WARNING(("Problem retrieving WMF Data"));
            GpFree(wmfData);
            return Win32Error;
        }

        // We don't save MetafileTypeWmf -- we convert it to the Placeable type
        metafileData.MetaType     = MetafileTypeWmfPlaceable;
        metafileData.MetaDataSize = wmfDataSize;
        stream->Write(&metafileData, sizeof(metafileData), NULL);

        ASSERT(sizeof(WmfPlaceableFileHeader) == 22);
#define PLACEABLE_BUFFER_SIZE     (sizeof(WmfPlaceableFileHeader) + 2)
        BYTE                      placeableBuffer[PLACEABLE_BUFFER_SIZE];
        WmfPlaceableFileHeader *  wmfPlaceableFileHeader = (WmfPlaceableFileHeader *)placeableBuffer;
        REAL                      aveDpi;

        // set pad word to 0
        *((INT16 *)(placeableBuffer + sizeof(WmfPlaceableFileHeader))) = 0;

        aveDpi = (Header.GetDpiX() + Header.GetDpiY()) / 2.0f;

        wmfPlaceableFileHeader->Key                = GDIP_WMF_PLACEABLEKEY;
        wmfPlaceableFileHeader->Hmf                = 0;
        wmfPlaceableFileHeader->BoundingBox.Left   = static_cast<INT16>(Header.X);
        wmfPlaceableFileHeader->BoundingBox.Top    = static_cast<INT16>(Header.Y);
        wmfPlaceableFileHeader->BoundingBox.Right  = static_cast<INT16>(Header.X + Header.Width);
        wmfPlaceableFileHeader->BoundingBox.Bottom = static_cast<INT16>(Header.Y + Header.Height);
        wmfPlaceableFileHeader->Inch               = static_cast<INT16>(GpRound(aveDpi));
        wmfPlaceableFileHeader->Reserved           = 0;
        wmfPlaceableFileHeader->Checksum           = GetWmfPlaceableCheckSum(wmfPlaceableFileHeader);
        stream->Write(placeableBuffer, PLACEABLE_BUFFER_SIZE, NULL);
        stream->Write(wmfData, wmfDataSize, NULL);
        GpFree(wmfData);

        // align
        if ((wmfDataSize & 0x03) != 0)
        {
            INT     pad = 0;
            stream->Write(&pad, 4 - (wmfDataSize & 0x03), NULL);
        }
    }
    else if (!Header.IsEmfPlusDual())
    {
        INT     emfDataSize = GetEnhMetaFileBits(Hemf, 0, NULL);

        if (emfDataSize <= 0)
        {
            WARNING(("Empty EMF"));
            return Win32Error;
        }

        metafileData.MetaType     = Header.GetType();
        metafileData.MetaDataSize = emfDataSize;
        stream->Write(&metafileData, sizeof(metafileData), NULL);

        if (!::EnumEnhMetaFile(NULL, Hemf, EnumEmfToStream, stream, NULL))
        {
            WARNING(("Problem retrieving EMF Data"));
            return Win32Error;
        }
    }
    else    // it is EMF+ Dual.  Remove the dual records for embedding.
    {
        RemoveDualRecords   removeDualRecords;

        // First, figure out how big a buffer we need to allocate
        if (!::EnumEnhMetaFile(NULL, Hemf, EnumEmfRemoveDualRecords,
                               &removeDualRecords, NULL))
        {
            WARNING(("Problem retrieving EMF Data"));
            return Win32Error;
        }

        INT     emfDataSize = removeDualRecords.Size;

        BYTE *  emfData = (BYTE *)GpMalloc(emfDataSize);
        if (emfData == NULL)
        {
            return OutOfMemory;
        }

        removeDualRecords.Init();
        removeDualRecords.MetaData = emfData;

        if (!::EnumEnhMetaFile(NULL, Hemf, EnumEmfRemoveDualRecords,
                               &removeDualRecords, NULL))
        {
            WARNING(("Problem retrieving EMF Data"));
            GpFree(emfData);
            return Win32Error;
        }

        // make sure we get the same value back the 2nd time
        ASSERT(emfDataSize == removeDualRecords.Size);

        // We convert MetafileTypeEmfPlusDual into MetafileTypeEmfPlusOnly
        metafileData.MetaType     = MetafileTypeEmfPlusOnly;
        metafileData.MetaDataSize = removeDualRecords.Size;
        stream->Write(&metafileData, sizeof(metafileData), NULL);

        ((ENHMETAHEADER3 *)emfData)->nBytes   = removeDualRecords.Size;
        ((ENHMETAHEADER3 *)emfData)->nRecords = removeDualRecords.NumRecords;
        stream->Write(emfData, removeDualRecords.Size, NULL);
        GpFree(emfData);
    }

    return Ok;
}

UINT
GpMetafile::GetDataSize() const
{
    if ((State != DoneRecordingMetafileState) &&
        (State != ReadyToPlayMetafileState))
    {
        WARNING(("Wrong State To GetDataSize"));
        return 0;
    }

    ASSERT(Hemf != NULL);

    UINT        dataSize  = sizeof(MetafileData);

    if (Header.IsWmf())
    {
        INT     wmfDataSize = GetMetaFileBitsEx((HMETAFILE)Hemf, 0, NULL);

        if (wmfDataSize <= 0)
        {
            WARNING(("Empty WMF"));
            return 0;
        }
        // add aligned size of the placeable header and aligned wmf size
        dataSize += 24 + ((wmfDataSize + 3) & ~3);
    }
    else if (!Header.IsEmfPlusDual())
    {
        INT     emfDataSize = GetEnhMetaFileBits(Hemf, 0, NULL);

        if (emfDataSize <= 0)
        {
            WARNING(("Empty EMF"));
            return 0;
        }
        dataSize += emfDataSize;
    }
    else    // it is EMF+ Dual.  Remove the dual records for embedding.
    {
        RemoveDualRecords   removeDualRecords;

        if (!::EnumEnhMetaFile(NULL, Hemf, EnumEmfRemoveDualRecords,
                               &removeDualRecords, NULL))
        {
            WARNING(("Problem retrieving EMF Data"));
            return 0;
        }

        dataSize += removeDualRecords.Size;
    }

    return dataSize;
}

/**************************************************************************\
*
* Function Description:
*
*   Read the metafile object from memory.
*
* Arguments:
*
*   [IN] data - the data to set the metafile with
*   [IN] size - the size of the data
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   4/26/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpMetafile::SetData(
    const BYTE *        dataBuffer,
    UINT                size
    )
{
    ASSERT ((GpImageType)(((MetafileData *)dataBuffer)->Type) == ImageTypeMetafile);

    InitDefaults();

    if (dataBuffer == NULL)
    {
        WARNING(("dataBuffer is NULL"));
        return InvalidParameter;
    }

    if (size < sizeof(MetafileData))
    {
        WARNING(("size too small"));
        return InvalidParameter;
    }

    const MetafileData *    metaData;

    metaData = reinterpret_cast<const MetafileData *>(dataBuffer);

    if (!metaData->MajorVersionMatches())
    {
        WARNING(("Version number mismatch"));
        return InvalidParameter;
    }

    dataBuffer += sizeof(MetafileData);
    size -= sizeof(MetafileData);

    MetafileType    type         = (MetafileType)metaData->MetaType;
    UINT            metaDataSize = metaData->MetaDataSize;

    if (type == MetafileTypeWmfPlaceable)
    {
        HMETAFILE   hWmf;

        if (size < (metaDataSize + 24))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        hWmf = SetMetaFileBitsEx(metaDataSize, dataBuffer + 24);
        if (hWmf != NULL)
        {
            if (GetMetafileHeader(hWmf, (WmfPlaceableFileHeader*)dataBuffer, Header) == Ok)
            {
                Hemf  = (HENHMETAFILE)hWmf;
                State = DoneRecordingMetafileState;
                return Ok;
            }
            DeleteMetaFile(hWmf);
        }
    }
    else
    {
        // We'll let the object think it's dual, even if we've removed
        // all the dual records.  It shouldn't hurt anything.
        HENHMETAFILE    hEmf;

        if (size < metaDataSize)
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        hEmf = SetEnhMetaFileBits(metaDataSize, dataBuffer);

        if (hEmf != NULL)
        {
            BOOL    isCorrupted;

            if (GetMetafileHeader(hEmf, Header, &isCorrupted) == Ok)
            {
                Hemf  = hEmf;
                State = DoneRecordingMetafileState;
                return Ok;
            }
            if (isCorrupted)
            {
                State = CorruptedMetafileState;
            }
            DeleteEnhMetaFile(hEmf);
        }
    }
    return GenericError;
}

class CommentEPR : public EmfPlusRecordPlay
{
public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeComment);

        return;
    }
};

class GetDCEPR : public EmfPlusRecordPlay
{
public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeGetDC);

        // Flag that the next down-level records should be played.
#if 0
        // This is now done in the enumerator, so that it will happen
        // for enumeration as well as playback.
        player->PlayEMFRecords = TRUE;
#endif
    }
};

#define EMFPLUS_MAJORVERSION(v)             ((v) & 0xFFFF0000)
#define EMFPLUS_MINORVERSION(v)             ((v) & 0x0000FFFF)
#define EMF_SKIP_ALL_MULTIFORMAT_SECTIONS   0x7FFFFFFF

#define MULTIFORMATSTARTEPR_MINSIZE    (sizeof(UINT32) + sizeof(UINT32))

// Note: nesting multiformat records does NOT work.
class MultiFormatStartEPR : public EmfPlusRecordPlay
{
protected:
    UINT32          NumSections;
    UINT32          Version[1];

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeMultiFormatStart);

        if (dataSize < MULTIFORMATSTARTEPR_MINSIZE)
        {
            WARNING(("MultiFormatStartEPR::Play dataSize is too small"));
            return;
        }

        UINT    sectionToPlay = EMF_SKIP_ALL_MULTIFORMAT_SECTIONS;

        if (NumSections > 0)
        {
            if (dataSize < MULTIFORMATSTARTEPR_MINSIZE + ((NumSections - 1) * sizeof(UINT32)))
            {
                WARNING(("MultiFormatStartEPR::Play dataSize is too small"));
                return;
            }

            if ((Version[0] == EMFPLUS_VERSION) || (NumSections == 1))
            {
                sectionToPlay = 1;  // start counting from 1, not 0
            }
            else
            {
                UINT    playVersion = 0;
                UINT    curVersion;

                // The multiformat section must match the major version.
                // The first format whose minor version <= the current
                // minor version is the one we play.  If we don't find
                // one of those, then we play the one whose minor version
                // is closest to the current minor version.
                for (UINT i = 0; i < NumSections; i++)
                {
                    curVersion = Version[i];
                    if (EMFPLUS_MAJORVERSION(curVersion) ==
                        EMFPLUS_MAJORVERSION(EMFPLUS_VERSION))
                    {
                        if (EMFPLUS_MINORVERSION(curVersion) <=
                            EMFPLUS_MINORVERSION(EMFPLUS_VERSION))
                        {
                            sectionToPlay = i + 1;
                            break;
                        }
                        else if ((playVersion == 0) ||
                                 (EMFPLUS_MINORVERSION(curVersion) <
                                  EMFPLUS_MINORVERSION(playVersion)))
                        {
                            playVersion = curVersion;
                            sectionToPlay = i + 1;
                        }
                    }
                }
            }
        }
        player->MultiFormatSection     = sectionToPlay;
        player->CurFormatSection       = 0;
        player->PlayMultiFormatSection = FALSE;
    }
};

class MultiFormatSectionEPR : public EmfPlusRecordPlay
{
public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeMultiFormatSection);

        if (player->MultiFormatSection != 0)
        {
            player->PlayMultiFormatSection =
                (++(player->CurFormatSection) == player->MultiFormatSection);
        }
    }
};

class MultiFormatEndEPR : public EmfPlusRecordPlay
{
public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeMultiFormatEnd);

        player->MultiFormatSection     = 0;
        player->CurFormatSection       = 0;
        player->PlayMultiFormatSection = TRUE;
    }
};

class SetAntiAliasModeEPR : public EmfPlusRecordPlay
{
public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeSetAntiAliasMode);

        player->Graphics->SetAntiAliasMode(GetAntiAliasMode(flags));
    }
};

class SetTextRenderingHintEPR : public EmfPlusRecordPlay
{
public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeSetTextRenderingHint);

        player->Graphics->SetTextRenderingHint(GetTextRenderingHint(flags));
    }
};

class SetTextContrastEPR : public EmfPlusRecordPlay
{
public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeSetTextContrast);

        player->Graphics->SetTextContrast(GetTextContrast(flags));
    }
};

class SetInterpolationModeEPR : public EmfPlusRecordPlay
{
public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeSetInterpolationMode);

        player->Graphics->SetInterpolationMode(GetInterpolationMode(flags));
    }
};

class SetPixelOffsetModeEPR : public EmfPlusRecordPlay
{
public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeSetPixelOffsetMode);

        player->Graphics->SetPixelOffsetMode(GetPixelOffsetMode(flags));
    }
};

class SetCompositingModeEPR : public EmfPlusRecordPlay
{
public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeSetCompositingMode);

        player->Graphics->SetCompositingMode(GetCompositingMode(flags));
    }
};

class SetCompositingQualityEPR : public EmfPlusRecordPlay
{
public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeSetCompositingQuality);

        player->Graphics->SetCompositingQuality(GetCompositingQuality(flags));
    }
};

class SetRenderingOriginEPR : public EmfPlusRecordPlay
{
    INT x;
    INT y;
public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeSetRenderingOrigin);

        player->Graphics->SetRenderingOrigin(x, y);
    }
};

#define SAVEEPR_MINSIZE    (sizeof(UINT32))

class SaveEPR : public EmfPlusRecordPlay
{
protected:
    UINT32          StackIndex;

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeSave);

        if (dataSize < SAVEEPR_MINSIZE)
        {
            WARNING(("SaveEPR::Play dataSize is too small"));
            return;
        }

        player->NewSave(StackIndex, player->Graphics->Save());
    }
};

#define RESTOREEPR_MINSIZE    (sizeof(UINT32))

class RestoreEPR : public EmfPlusRecordPlay
{
protected:
    UINT32          StackIndex;

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeRestore);

        if (dataSize < RESTOREEPR_MINSIZE)
        {
            WARNING(("RestoreEPR::Play dataSize is too small"));
            return;
        }

        player->Graphics->Restore(player->GetSaveID(StackIndex));
    }
};

#define BEGINCONTAINEREPR_MINSIZE    (sizeof(GpRectF) + sizeof(GpRectF) + sizeof(UINT32))

class BeginContainerEPR : public EmfPlusRecordPlay
{
protected:
    GpRectF         DestRect;
    GpRectF         SrcRect;
    UINT32          StackIndex;

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeBeginContainer);

        if (dataSize < BEGINCONTAINEREPR_MINSIZE)
        {
            WARNING(("BeginContainerEPR::Play dataSize is too small"));
            return;
        }

        player->NewSave(StackIndex,
                        player->Graphics->BeginContainer(DestRect, SrcRect, GetPageUnit(flags)));
    }
};

#define BEGINCONTAINERNOPARAMSEPR_MINSIZE    (sizeof(UINT32))

class BeginContainerNoParamsEPR : public EmfPlusRecordPlay
{
protected:
    UINT32          StackIndex;

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeBeginContainerNoParams);

        if (dataSize < BEGINCONTAINERNOPARAMSEPR_MINSIZE)
        {
            WARNING(("BeginContainerNoParamsEPR::Play dataSize is too small"));
            return;
        }

        player->NewSave(StackIndex, player->Graphics->BeginContainer());
    }
};

#define ENDCONTAINEREPR_MINSIZE    (sizeof(UINT32))

class EndContainerEPR : public EmfPlusRecordPlay
{
protected:
    UINT32          StackIndex;

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeEndContainer);

        if (dataSize < ENDCONTAINEREPR_MINSIZE)
        {
            WARNING(("EndContainerEPR::Play dataSize is too small"));
            return;
        }

        player->Graphics->EndContainer(player->GetSaveID(StackIndex));
    }
};

#define SETWORLDTRANSFORMEPR_MINSIZE    GDIP_MATRIX_SIZE

class SetWorldTransformEPR : public EmfPlusRecordPlay
{
protected:
    REAL        MatrixData[6];

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeSetWorldTransform);

        if (dataSize < SETWORLDTRANSFORMEPR_MINSIZE)
        {
            WARNING(("SetWorldTransformEPR::Play dataSize is too small"));
            return;
        }

        GpMatrix    matrix(MatrixData[0], MatrixData[1],
                           MatrixData[2], MatrixData[3],
                           MatrixData[4], MatrixData[5]);
        player->Graphics->SetWorldTransform(matrix);
    }
};

class ResetWorldTransformEPR : public EmfPlusRecordPlay
{
public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeResetWorldTransform);

        player->Graphics->ResetWorldTransform();
    }
};

#define MULTIPLYWORLDTRANSFORMEPR_MINSIZE    GDIP_MATRIX_SIZE

class MultiplyWorldTransformEPR : public EmfPlusRecordPlay
{
protected:
    REAL        MatrixData[6];

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeMultiplyWorldTransform);

        if (dataSize < MULTIPLYWORLDTRANSFORMEPR_MINSIZE)
        {
            WARNING(("MultiplyWorldTransformEPR::Play dataSize is too small"));
            return;
        }

        GpMatrix    matrix(MatrixData[0], MatrixData[1],
                           MatrixData[2], MatrixData[3],
                           MatrixData[4], MatrixData[5]);
        player->Graphics->MultiplyWorldTransform(matrix, GetMatrixOrder(flags));
    }
};

#define TRANSLATEWORLDTRANSFORMEPR_MINSIZE    (sizeof(REAL) + sizeof(REAL))

class TranslateWorldTransformEPR : public EmfPlusRecordPlay
{
protected:
    REAL            Dx;
    REAL            Dy;

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeTranslateWorldTransform);

        if (dataSize < TRANSLATEWORLDTRANSFORMEPR_MINSIZE)
        {
            WARNING(("TranslateWorldTransformEPR::Play dataSize is too small"));
            return;
        }

        player->Graphics->TranslateWorldTransform(Dx, Dy, GetMatrixOrder(flags));
    }
};

#define SCALEWORLDTRANSFORMEPR_MINSIZE    (sizeof(REAL) + sizeof(REAL))

class ScaleWorldTransformEPR : public EmfPlusRecordPlay
{
protected:
    REAL            Sx;
    REAL            Sy;

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeScaleWorldTransform);

        if (dataSize < SCALEWORLDTRANSFORMEPR_MINSIZE)
        {
            WARNING(("ScaleWorldTransformEPR::Play dataSize is too small"));
            return;
        }

        player->Graphics->ScaleWorldTransform(Sx, Sy, GetMatrixOrder(flags));
    }
};

#define ROTATEWORLDTRANSFORMEPR_MINSIZE    (sizeof(REAL))

class RotateWorldTransformEPR : public EmfPlusRecordPlay
{
protected:
    REAL            Angle;

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeRotateWorldTransform);

        if (dataSize < ROTATEWORLDTRANSFORMEPR_MINSIZE)
        {
            WARNING(("RotateWorldTransformEPR::Play dataSize is too small"));
            return;
        }

        player->Graphics->RotateWorldTransform(Angle, GetMatrixOrder(flags));
    }
};

#define SETPAGETRANSFORMEPR_MINSIZE    (sizeof(REAL))

class SetPageTransformEPR : public EmfPlusRecordPlay
{
protected:
    REAL            Scale;

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeSetPageTransform);

        if (dataSize < SETPAGETRANSFORMEPR_MINSIZE)
        {
            WARNING(("SetPageTransformEPR::Play dataSize is too small"));
            return;
        }

        player->Graphics->SetPageTransform(GetPageUnit(flags), Scale);
    }
};

class ResetClipEPR : public EmfPlusRecordPlay
{
public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeResetClip);

        player->Graphics->ResetClip();
    }
};

#define SETCLIPRECTEPR_MINSIZE    (sizeof(GpRectF))

class SetClipRectEPR : public EmfPlusRecordPlay
{
protected:
    GpRectF     ClipRect;   // !!! Handle 16-bit rect

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeSetClipRect);

        if (dataSize < SETCLIPRECTEPR_MINSIZE)
        {
            WARNING(("SetClipRectEPR::Play dataSize is too small"));
            return;
        }

        player->Graphics->SetClip(ClipRect, GetCombineMode(flags));
    }
};

class SetClipPathEPR : public EmfPlusRecordPlay
{
public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeSetClipPath);

        GpPath *path = (GpPath *)player->GetObject(GetMetaObjectId(flags), ObjectTypePath);
        if (path != NULL)
        {
            player->Graphics->SetClip(path, GetCombineMode(flags), GetIsDevicePath(flags));
        }

    }
};

class SetClipRegionEPR : public EmfPlusRecordPlay
{
public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeSetClipRegion);

        GpRegion *region = (GpRegion *)player->GetObject(GetMetaObjectId(flags), ObjectTypeRegion);
        if (region != NULL)
        {
            player->Graphics->SetClip(region, GetCombineMode(flags));            
        }


    }
};

#define OFFSETCLIPEPR_MINSIZE    (sizeof(REAL) + sizeof(REAL))

class OffsetClipEPR : public EmfPlusRecordPlay
{
protected:
    REAL        Dx;
    REAL        Dy;

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeOffsetClip);

        if (dataSize < OFFSETCLIPEPR_MINSIZE)
        {
            WARNING(("OffsetClipEPR::Play dataSize is too small"));
            return;
        }

        player->Graphics->OffsetClip(Dx, Dy);
    }
};

#define OBJECTEPR_MINSIZE    (sizeof(UINT32))

class ObjectEPR : public EmfPlusRecordPlay
{
protected:
    BYTE        ObjectData[1];

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        if (dataSize < OBJECTEPR_MINSIZE)
        {
            WARNING(("ObjectEPR::Play dataSize is too small"));
            return;
        }

        player->AddObject(flags, ObjectData, dataSize);
    }
};

#define CLEAREPR_MINSIZE    (sizeof(UINT32))

class ClearEPR : public EmfPlusBoundsRecord
{
protected:
    ARGB      Color;

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeClear);

        if (dataSize < CLEAREPR_MINSIZE)
        {
            WARNING(("ClearEPR::Play dataSize is too small"));
            return;
        }

        GpColor color;

        color.SetColor(Color);

        player->Graphics->Clear(color);
    }
};

#define FILLRECTSEPR_MINSIZE    (sizeof(UINT32) + sizeof(UINT32))

class FillRectsEPR : public EmfPlusBoundsRecord
{
protected:
    UINT32      BrushValue;
    UINT32      Count;
    BYTE        RectData[1];    // GpRect16 or GpRectF

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeFillRects);

        if (dataSize < FILLRECTSEPR_MINSIZE)
        {
            WARNING(("FillRectsEPR::Play dataSize is too small"));
            return;
        }

        GpBrush *       brush = player->GetBrush(BrushValue, flags);
        GpRectF *       rects = player->GetRects(RectData, dataSize - FILLRECTSEPR_MINSIZE, Count, flags);

        if (rects != NULL)
        {
            if (brush != NULL)
            {
                player->Graphics->FillRects(brush, rects, Count);
            }
            player->FreePointsBuffer();
        }
    }
};

#define DRAWRECTSEPR_MINSIZE    (sizeof(UINT32))

class DrawRectsEPR : public EmfPlusBoundsRecord
{
protected:
    UINT32      Count;
    BYTE        RectData[1];    // GpRect16 or GpRectF

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeDrawRects);

        if (dataSize < DRAWRECTSEPR_MINSIZE)
        {
            WARNING(("DrawRectsEPR::Play dataSize is too small"));
            return;
        }

        GpPen *         pen   = (GpPen *)player->GetObject(GetMetaObjectId(flags), ObjectTypePen);
        GpRectF *       rects = player->GetRects(RectData, dataSize - DRAWRECTSEPR_MINSIZE, Count, flags);

        if (rects != NULL)
        {
            if (pen != NULL)
            {
                player->Graphics->DrawRects(pen, rects, Count);
            }
            player->FreePointsBuffer();
        }
    }
};

#define FILLPOLYGONEPR_MINSIZE    (sizeof(UINT32) + sizeof(UINT32))

class FillPolygonEPR : public EmfPlusBoundsRecord
{
protected:
    UINT32      BrushValue;
    UINT32      Count;
    BYTE        PointData[1];   // GpPoint16 or GpPointF

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeFillPolygon);

        if (dataSize < FILLPOLYGONEPR_MINSIZE)
        {
            WARNING(("FillPolygonEPR::Play dataSize is too small"));
            return;
        }

        GpBrush *       brush  = player->GetBrush(BrushValue, flags);
        GpPointF *      points = player->GetPoints(PointData, dataSize - FILLPOLYGONEPR_MINSIZE, Count, flags);

        if (points != NULL)
        {
            if (brush != NULL)
            {
                player->Graphics->FillPolygon(brush, points, Count, GetFillMode(flags));
            }
            player->FreePointsBuffer();
        }
    }
};

#define DRAWLINESEPR_MINSIZE    (sizeof(UINT32))

class DrawLinesEPR : public EmfPlusBoundsRecord
{
protected:
    UINT32      Count;
    BYTE        PointData[1];   // GpPoint16 or GpPointF

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeDrawLines);

        if (dataSize < DRAWLINESEPR_MINSIZE)
        {
            WARNING(("DrawLinesEPR::Play dataSize is too small"));
            return;
        }

        GpPen *         pen   = (GpPen *)player->GetObject(GetMetaObjectId(flags), ObjectTypePen);
        GpPointF *      points = player->GetPoints(PointData, dataSize - DRAWLINESEPR_MINSIZE, Count, flags);

        if (points != NULL)
        {
            if (pen != NULL)
            {
                player->Graphics->DrawLines(pen, points, Count, IsClosed(flags));
            }
            player->FreePointsBuffer();
        }
    }
};

#define FILLELLIPSEEPR_MINSIZE    (sizeof(UINT32))

class FillEllipseEPR : public EmfPlusBoundsRecord
{
protected:
    UINT32      BrushValue;
    BYTE        RectData[1];    // GpRect16 or GpRectF

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeFillEllipse);

        if (dataSize < FILLELLIPSEEPR_MINSIZE)
        {
            WARNING(("FillEllipseEPR::Play dataSize is too small"));
            return;
        }

        GpBrush *       brush = player->GetBrush(BrushValue, flags);
        GpRectF *       rect  = player->GetRects(RectData, dataSize - FILLELLIPSEEPR_MINSIZE, 1, flags);

        if (rect != NULL)
        {
            if (brush != NULL)
            {
                player->Graphics->FillEllipse(brush, *rect);
            }
            player->FreePointsBuffer();
        }
    }
};

class DrawEllipseEPR : public EmfPlusBoundsRecord
{
protected:
    BYTE        RectData[1];    // GpRect16 or GpRectF

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeDrawEllipse);

        GpPen *         pen   = (GpPen *)player->GetObject(GetMetaObjectId(flags), ObjectTypePen);
        GpRectF *       rect  = player->GetRects(RectData, dataSize, 1, flags);

        if (rect != NULL)
        {
            if (pen != NULL)
            {
                player->Graphics->DrawEllipse(pen, *rect);
            }
            player->FreePointsBuffer();
        }
    }
};

#define FILLPIEEPR_MINSIZE    (sizeof(UINT32) + sizeof(REAL) + sizeof(REAL))

class FillPieEPR : public EmfPlusBoundsRecord
{
protected:
    UINT32      BrushValue;
    REAL        StartAngle;
    REAL        SweepAngle;
    BYTE        RectData[1];    // GpRect16 or GpRectF

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeFillPie);

        if (dataSize < FILLPIEEPR_MINSIZE)
        {
            WARNING(("FillPieEPR::Play dataSize is too small"));
            return;
        }

        GpBrush *       brush = player->GetBrush(BrushValue, flags);
        GpRectF *       rect  = player->GetRects(RectData, dataSize - FILLPIEEPR_MINSIZE, 1, flags);

        if (rect != NULL)
        {
            if (brush != NULL)
            {
                player->Graphics->FillPie(brush, *rect, StartAngle, SweepAngle);
            }
            player->FreePointsBuffer();
        }
    }
};

#define DRAWPIEEPR_MINSIZE    (sizeof(REAL) + sizeof(REAL))

class DrawPieEPR : public EmfPlusBoundsRecord
{
protected:
    REAL        StartAngle;
    REAL        SweepAngle;
    BYTE        RectData[1];    // GpRect16 or GpRectF

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeDrawPie);

        if (dataSize < DRAWPIEEPR_MINSIZE)
        {
            WARNING(("DrawPieEPR::Play dataSize is too small"));
            return;
        }

        GpPen *         pen   = (GpPen *)player->GetObject(GetMetaObjectId(flags), ObjectTypePen);
        GpRectF *       rect  = player->GetRects(RectData, dataSize - DRAWPIEEPR_MINSIZE, 1, flags);

        if (rect != NULL)
        {
            if (pen != NULL)
            {
                player->Graphics->DrawPie(pen, *rect, StartAngle, SweepAngle);
            }
            player->FreePointsBuffer();
        }
    }
};

#define DRAWARCEPR_MINSIZE    (sizeof(REAL) + sizeof(REAL))

class DrawArcEPR : public EmfPlusBoundsRecord
{
protected:
    REAL        StartAngle;
    REAL        SweepAngle;
    BYTE        RectData[1];    // GpRect16 or GpRectF

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeDrawArc);

        if (dataSize < DRAWARCEPR_MINSIZE)
        {
            WARNING(("DrawArcEPR::Play dataSize is too small"));
            return;
        }

        GpPen *         pen   = (GpPen *)player->GetObject(GetMetaObjectId(flags), ObjectTypePen);
        GpRectF *       rect  = player->GetRects(RectData, dataSize - DRAWARCEPR_MINSIZE, 1, flags);

        if (rect != NULL)
        {
            if (pen != NULL)
            {
                player->Graphics->DrawArc(pen, *rect, StartAngle, SweepAngle);
            }
            player->FreePointsBuffer();
        }
    }
};

#define FILLREGIONEPR_MINSIZE    (sizeof(UINT32))

class FillRegionEPR : public EmfPlusBoundsRecord
{
protected:
    UINT32      BrushValue;

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeFillRegion);

        if (dataSize < FILLREGIONEPR_MINSIZE)
        {
            WARNING(("FillRegionEPR::Play dataSize is too small"));
            return;
        }

        GpBrush *       brush  = player->GetBrush(BrushValue, flags);
        GpRegion *      region = (GpRegion *)player->GetObject(GetMetaObjectId(flags), ObjectTypeRegion);

        if ((brush != NULL) && (region != NULL))
        {
            player->Graphics->FillRegion(brush, region);
        }
    }
};

#define FILLPATHEPR_MINSIZE    (sizeof(UINT32))

class FillPathEPR : public EmfPlusBoundsRecord
{
protected:
    UINT32      BrushValue;

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeFillPath);

        if (dataSize < FILLPATHEPR_MINSIZE)
        {
            WARNING(("FillPathEPR::Play dataSize is too small"));
            return;
        }

        GpBrush *       brush = player->GetBrush(BrushValue, flags);
        GpPath *        path  = (GpPath *)player->GetObject(GetMetaObjectId(flags), ObjectTypePath);

        if ((brush != NULL) && (path != NULL))
        {
            player->Graphics->FillPath(brush, path);
        }
    }
};

#define DRAWPATHEPR_MINSIZE    (sizeof(UINT32))

class DrawPathEPR : public EmfPlusBoundsRecord
{
protected:
    UINT32      PenId;

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeDrawPath);

        if (dataSize < DRAWPATHEPR_MINSIZE)
        {
            WARNING(("DrawPathEPR::Play dataSize is too small"));
            return;
        }

        GpPen *         pen   = (GpPen *)player->GetObject(PenId, ObjectTypePen);
        GpPath *        path  = (GpPath *)player->GetObject(GetMetaObjectId(flags), ObjectTypePath);

        if ((pen != NULL) && (path != NULL))
        {
            player->Graphics->DrawPath(pen, path);
        }
    }
};

#define FILLCLOSEDCURVEEPR_MINSIZE    (sizeof(UINT32) + sizeof(REAL) + sizeof(UINT32))

class FillClosedCurveEPR : public EmfPlusBoundsRecord
{
protected:
    UINT32      BrushValue;
    REAL        Tension;
    UINT32      Count;
    BYTE        PointData[1];   // GpPoint16 or GpPointF

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeFillClosedCurve);

        if (dataSize < FILLCLOSEDCURVEEPR_MINSIZE)
        {
            WARNING(("FillClosedCurveEPR::Play dataSize is too small"));
            return;
        }

        GpBrush *       brush  = player->GetBrush(BrushValue, flags);
        GpPointF *      points = player->GetPoints(PointData, dataSize - FILLCLOSEDCURVEEPR_MINSIZE, Count, flags);

        if (points != NULL)
        {
            if (brush != NULL)
            {
                player->Graphics->FillClosedCurve(brush, points, Count,Tension,GetFillMode(flags));
            }
            player->FreePointsBuffer();
        }
    }
};

#define DRAWCLOSEDCURVEEPR_MINSIZE    (sizeof(REAL) + sizeof(UINT32))

class DrawClosedCurveEPR : public EmfPlusBoundsRecord
{
protected:
    REAL        Tension;
    UINT32      Count;
    BYTE        PointData[1];   // GpPoint16 or GpPointF

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeDrawClosedCurve);

        if (dataSize < DRAWCLOSEDCURVEEPR_MINSIZE)
        {
            WARNING(("DrawClosedCurveEPR::Play dataSize is too small"));
            return;
        }

        GpPen *         pen   = (GpPen *)player->GetObject(GetMetaObjectId(flags), ObjectTypePen);
        GpPointF *      points = player->GetPoints(PointData, dataSize - DRAWCLOSEDCURVEEPR_MINSIZE, Count, flags);

        if (points != NULL)
        {
            if (pen != NULL)
            {
                player->Graphics->DrawClosedCurve(pen, points, Count, Tension);
            }
            player->FreePointsBuffer();
        }
    }
};

#define DRAWCURVEEPR_MINSIZE    (sizeof(REAL) + sizeof(INT32) + sizeof(UINT32) + sizeof(UINT32))

class DrawCurveEPR : public EmfPlusBoundsRecord
{
protected:
    REAL        Tension;
    INT32       Offset;
    UINT32      NumSegments;
    UINT32      Count;
    BYTE        PointData[1];   // GpPoint16 or GpPointF

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeDrawCurve);

        if (dataSize < DRAWCURVEEPR_MINSIZE)
        {
            WARNING(("DrawCurveEPR::Play dataSize is too small"));
            return;
        }

        GpPen *         pen   = (GpPen *)player->GetObject(GetMetaObjectId(flags), ObjectTypePen);
        GpPointF *      points = player->GetPoints(PointData, dataSize - DRAWCURVEEPR_MINSIZE, Count, flags);

        if (points != NULL)
        {
            if (pen != NULL)
            {
                player->Graphics->DrawCurve(pen, points, Count, Tension, Offset, NumSegments);
            }
            player->FreePointsBuffer();
        }
    }
};

#define DRAWBEZIERSEPR_MINSIZE    (sizeof(UINT32))

class DrawBeziersEPR : public EmfPlusBoundsRecord
{
protected:
    UINT32      Count;
    BYTE        PointData[1];   // GpPoint16 or GpPointF

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeDrawBeziers);

        if (dataSize < DRAWBEZIERSEPR_MINSIZE)
        {
            WARNING(("DrawBeziersEPR::Play dataSize is too small"));
            return;
        }

        GpPen *         pen   = (GpPen *)player->GetObject(GetMetaObjectId(flags), ObjectTypePen);
        GpPointF *      points = player->GetPoints(PointData, dataSize - DRAWBEZIERSEPR_MINSIZE, Count, flags);

        if (points != NULL)
        {
            if (pen != NULL)
            {
                player->Graphics->DrawBeziers(pen, points, Count);
            }
            player->FreePointsBuffer();
        }
    }
};

#define DRAWIMAGEEPR_MINSIZE    (sizeof(INT32) + sizeof(GpRectF))

class DrawImageEPR : public EmfPlusBoundsRecord
{
protected:
    UINT32      ImageAttributesId;
    INT32       SrcUnit;
    GpRectF     SrcRect;
    BYTE        RectData[1];    // GpRect16 or GpRectF

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeDrawImage);

        if (dataSize < DRAWIMAGEEPR_MINSIZE)
        {
            WARNING(("DrawImageEPR::Play dataSize is too small"));
            return;
        }

        GpImage *image    = (GpImage *)player->GetObject(GetMetaObjectId(flags), ObjectTypeImage);
        GpRectF *destRect = player->GetRects(RectData, dataSize - DRAWIMAGEEPR_MINSIZE, 1, flags);
        GpImageAttributes *imageAttributes =
            (GpImageAttributes *)player->GetObject(
                ImageAttributesId,
                ObjectTypeImageAttributes
            );

        if ( (image != NULL) && (NULL != destRect) )
        {
            GpStatus status = player->Graphics->DrawImage(
                image,
                *destRect,
                SrcRect,
                static_cast<GpPageUnit>(SrcUnit),
                imageAttributes,
                player->DrawImageCallback,
                player->DrawImageCallbackData
                );
            if (status == Aborted)
            {
                // stop enumerating records
                player->EnumerateAborted = TRUE;
            }
        }
    }
};

#define DRAWIMAGEPOINTSEPR_MINSIZE    (sizeof(INT32) + sizeof(GpRectF) + sizeof(UINT32))

class DrawImagePointsEPR : public EmfPlusBoundsRecord
{
protected:
    UINT32      ImageAttributesId;
    INT32       SrcUnit;
    GpRectF     SrcRect;
    UINT32      Count;
    BYTE        PointData[1];   // GpPoint16 or GpPointF

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeDrawImagePoints);

        if (dataSize < DRAWIMAGEPOINTSEPR_MINSIZE)
        {
            WARNING(("DrawImagePointsEPR::Play dataSize is too small"));
            return;
        }

        GpImage *image      = (GpImage *)player->GetObject(GetMetaObjectId(flags), ObjectTypeImage);
        GpPointF *destPoints = player->GetPoints(PointData, dataSize - DRAWIMAGEPOINTSEPR_MINSIZE, Count, flags);
        GpImageAttributes *imageAttributes =
            (GpImageAttributes *)player->GetObject(
                ImageAttributesId,
                ObjectTypeImageAttributes
            );

        if (destPoints != NULL)
        {
            if (image != NULL)
            {
                GpStatus status = player->Graphics->DrawImage(
                    image,
                    destPoints,
                    Count,
                    SrcRect,
                    static_cast<GpPageUnit>(SrcUnit),
                    imageAttributes,
                    player->DrawImageCallback,
                    player->DrawImageCallbackData
                    );
                if (status == Aborted)
                {
                    // stop enumerating records
                    player->EnumerateAborted = TRUE;
                }
            }
            player->FreePointsBuffer();
        }
    }
};

#define DRAWSTRINGEPR_MINSIZE    (sizeof(UINT32) + sizeof(UINT32) + sizeof(UINT32) + sizeof(GpRectF))

class DrawStringEPR : public EmfPlusBoundsRecord
{
protected:
    UINT32      BrushValue;
    UINT32      FormatId;
    UINT32      Length;
    GpRectF     LayoutRect;
    BYTE        StringData[1];

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeDrawString);

        if (dataSize < DRAWSTRINGEPR_MINSIZE)
        {
            WARNING(("DrawStringEPR::Play dataSize is too small"));
            return;
        }

        GlobalTextLock lock;

        GpBrush *       brush  = player->GetBrush(BrushValue, flags);
        GpFont *        font   = (GpFont *)player->GetObject(GetMetaObjectId(flags), ObjectTypeFont);

        // Optional parameter - can return NULL.

        GpStringFormat *format = (GpStringFormat *)player->GetObject(
            FormatId,
            ObjectTypeStringFormat
        );

        if (Length > 0)
        {
            if (dataSize >= (DRAWSTRINGEPR_MINSIZE + (Length * sizeof(WCHAR))))
            {
                if ((brush != NULL) && (font != NULL))
                {
                    // !!! TODO:
                    // Determine whether the string is compressed or not.
                    // If so, decompress it.

                    player->Graphics->DrawString(
                        (WCHAR *)StringData,
                        Length,
                        font,
                        &LayoutRect,
                        format,
                        brush
                    );
                }
            }
            else
            {
                WARNING(("DrawStringEPR::Play dataSize is too small"));
                return;
            }

            player->FreePointsBuffer();
        }
    }
};


#define DRAWDRIVERSTRINGEPR_MINSIZE    (sizeof(UINT32) + sizeof(INT) + sizeof(UINT32) + sizeof(UINT32))

class DrawDriverStringEPR : public EmfPlusBoundsRecord
{
protected:
    UINT32      BrushValue;
    INT         ApiFlags;
    UINT32      MatrixPresent;
    UINT32      GlyphCount;
    BYTE        Data[1];

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeDrawDriverString);

        if (dataSize < DRAWDRIVERSTRINGEPR_MINSIZE)
        {
            WARNING(("DrawDriverStringEPR::Play dataSize is too small"));
            return;
        }

        GlobalTextLock lock;
        GpBrush *       brush  = player->GetBrush(BrushValue, flags);
        GpFont *        font   = (GpFont *)player->GetObject(GetMetaObjectId(flags), ObjectTypeFont);

        if (GlyphCount > 0)
        {
            UINT requiredSize = DRAWDRIVERSTRINGEPR_MINSIZE  +
                                (GlyphCount * sizeof(WCHAR)) +
                                (GlyphCount * sizeof(PointF));
            if (dataSize >= requiredSize)
            {
                if ((brush != NULL) && (font != NULL))
                {
                    WCHAR  *text      = (WCHAR *) Data;
                    PointF *positions = (PointF *) (Data + (GlyphCount * sizeof(WCHAR)));

                    if (MatrixPresent > 0)
                    {
                        if (dataSize < requiredSize + GDIP_MATRIX_SIZE)
                        {
                            WARNING(("DrawDriverStringEPR::Play dataSize is too small"));
                            return;
                        }

                        REAL *matrixData = (REAL *)((BYTE *) ((BYTE *)positions) +
                                           (GlyphCount * sizeof(PointF)));

                        GpMatrix matrix(matrixData);

                        player->Graphics->DrawDriverString(
                            (unsigned short *)text,
                            GlyphCount,
                            font,
                            brush,
                            positions,
                            ApiFlags | DriverStringOptionsMetaPlay,
                            &matrix);
                    }
                    else
                    {
                        player->Graphics->DrawDriverString(
                            (unsigned short *)text,
                            GlyphCount,
                            font,
                            brush,
                            positions,
                            ApiFlags,
                            NULL);
                    }
                }
            }
            else
            {
                WARNING(("DrawDriverStringEPR::Play dataSize is too small"));
                return;
            }

            player->FreePointsBuffer();
        }
    }
};



// The order of these methods must exactly match
// the order of the enums of the record numbers.
PLAYRECORDFUNC RecordPlayFuncs[EmfPlusRecordTypeMax - EmfPlusRecordTypeMin + 1] = {
    (PLAYRECORDFUNC)&EmfPlusHeaderRecord::Play, // Header
    (PLAYRECORDFUNC)&EmfPlusRecordPlay::Play,   // EndOfFile

    (PLAYRECORDFUNC)&CommentEPR::Play,

    (PLAYRECORDFUNC)&GetDCEPR::Play,

    (PLAYRECORDFUNC)&MultiFormatStartEPR::Play,
    (PLAYRECORDFUNC)&MultiFormatSectionEPR::Play,
    (PLAYRECORDFUNC)&MultiFormatEndEPR::Play,

    // For all persistent objects
    (PLAYRECORDFUNC)&ObjectEPR::Play,

    // Drawing Records
    (PLAYRECORDFUNC)&ClearEPR::Play,
    (PLAYRECORDFUNC)&FillRectsEPR::Play,
    (PLAYRECORDFUNC)&DrawRectsEPR::Play,
    (PLAYRECORDFUNC)&FillPolygonEPR::Play,
    (PLAYRECORDFUNC)&DrawLinesEPR::Play,
    (PLAYRECORDFUNC)&FillEllipseEPR::Play,
    (PLAYRECORDFUNC)&DrawEllipseEPR::Play,
    (PLAYRECORDFUNC)&FillPieEPR::Play,
    (PLAYRECORDFUNC)&DrawPieEPR::Play,
    (PLAYRECORDFUNC)&DrawArcEPR::Play,
    (PLAYRECORDFUNC)&FillRegionEPR::Play,
    (PLAYRECORDFUNC)&FillPathEPR::Play,
    (PLAYRECORDFUNC)&DrawPathEPR::Play,
    (PLAYRECORDFUNC)&FillClosedCurveEPR::Play,
    (PLAYRECORDFUNC)&DrawClosedCurveEPR::Play,
    (PLAYRECORDFUNC)&DrawCurveEPR::Play,
    (PLAYRECORDFUNC)&DrawBeziersEPR::Play,
    (PLAYRECORDFUNC)&DrawImageEPR::Play,
    (PLAYRECORDFUNC)&DrawImagePointsEPR::Play,
    (PLAYRECORDFUNC)&DrawStringEPR::Play,

    // Graphics State Records
    (PLAYRECORDFUNC)&SetRenderingOriginEPR::Play,
    (PLAYRECORDFUNC)&SetAntiAliasModeEPR::Play,
    (PLAYRECORDFUNC)&SetTextRenderingHintEPR::Play,
    (PLAYRECORDFUNC)&SetTextContrastEPR::Play,
    (PLAYRECORDFUNC)&SetInterpolationModeEPR::Play,
    (PLAYRECORDFUNC)&SetPixelOffsetModeEPR::Play,
    (PLAYRECORDFUNC)&SetCompositingModeEPR::Play,
    (PLAYRECORDFUNC)&SetCompositingQualityEPR::Play,
    (PLAYRECORDFUNC)&SaveEPR::Play,
    (PLAYRECORDFUNC)&RestoreEPR::Play,
    (PLAYRECORDFUNC)&BeginContainerEPR::Play,
    (PLAYRECORDFUNC)&BeginContainerNoParamsEPR::Play,
    (PLAYRECORDFUNC)&EndContainerEPR::Play,
    (PLAYRECORDFUNC)&SetWorldTransformEPR::Play,
    (PLAYRECORDFUNC)&ResetWorldTransformEPR::Play,
    (PLAYRECORDFUNC)&MultiplyWorldTransformEPR::Play,
    (PLAYRECORDFUNC)&TranslateWorldTransformEPR::Play,
    (PLAYRECORDFUNC)&ScaleWorldTransformEPR::Play,
    (PLAYRECORDFUNC)&RotateWorldTransformEPR::Play,
    (PLAYRECORDFUNC)&SetPageTransformEPR::Play,
    (PLAYRECORDFUNC)&ResetClipEPR::Play,
    (PLAYRECORDFUNC)&SetClipRectEPR::Play,
    (PLAYRECORDFUNC)&SetClipPathEPR::Play,
    (PLAYRECORDFUNC)&SetClipRegionEPR::Play,
    (PLAYRECORDFUNC)&OffsetClipEPR::Play,
    (PLAYRECORDFUNC)&DrawDriverStringEPR::Play,

    // New record types must be added here (at the end) -- do not add above,
    // since that will invalidate previous metafiles!
};

HENHMETAFILE
GetEmf(
    const WCHAR *               fileName,
    MetafileType                type
    )
{
    HENHMETAFILE    hEmf = NULL;

    if (type == MetafileTypeWmfPlaceable)
    {
        IStream *       wmfStream;
        IStream *       memStream;

        wmfStream = CreateStreamOnFile(fileName, GENERIC_READ);
        if (wmfStream != NULL)
        {
            STATSTG     statstg;
            HRESULT     hResult;

            hResult = wmfStream->Stat(&statstg, STATFLAG_NONAME);
            if (!HResultSuccess(hResult))
            {
                wmfStream->Release();
                return hEmf;
            }
            INT size = (INT)(statstg.cbSize.QuadPart - sizeof(WmfPlaceableFileHeader));

            if (SeekFromStart(wmfStream, sizeof(WmfPlaceableFileHeader)))
            {
                HGLOBAL     hGlobal;

                hGlobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_NODISCARD, size);
                if (hGlobal != NULL)
                {
                    hResult = CreateStreamOnHGlobal(hGlobal, TRUE, &memStream);
                    if (HResultSuccess(hResult) && (memStream != NULL))
                    {
                        if (CopyStream(wmfStream, memStream, size))
                        {
                            BYTE *  wmfData = (BYTE *)GlobalLock(hGlobal);

                            if (wmfData != NULL)
                            {
                                hEmf = (HENHMETAFILE)
                                            SetMetaFileBitsEx(size, wmfData);
                                GlobalUnlock(hGlobal);
                            }
                        }
                        memStream->Release();
                    }
                    else
                    {
                        GlobalFree(hGlobal);
                    }
                }
            }
            wmfStream->Release();
        }
    }
    else
    {
        if (Globals::IsNt)
        {
            hEmf = GetEnhMetaFileW(fileName);
        }
        else // Windows 9x - non-Unicode
        {
            AnsiStrFromUnicode nameStr(fileName);

            if (nameStr.IsValid())
            {
                hEmf = GetEnhMetaFileA(nameStr);
            }
        }
    }

    return hEmf;
}

#if 0   // don't need this right now
WCHAR *
GetTemporaryFilename()
{
    if (Globals::IsNt)
    {
        WCHAR   pathBuffer[MAX_PATH + 1];
        WCHAR   fileBuffer[MAX_PATH + 12 + 1];  // 12 for filename itself
        UINT    len = GetTempPathW(MAX_PATH, pathBuffer);

        if ((len == 0) || (len > MAX_PATH))
        {
            pathBuffer[0] = L'.';
            pathBuffer[1] = L'\0';
        }
        if (GetTempFileNameW(pathBuffer, L"Emp", 0, fileBuffer) == 0)
        {
            return NULL;
        }
        return UnicodeStringDuplicate(fileBuffer);
    }
    else // Windows 9x - non-Unicode
    {
        CHAR    pathBuffer[MAX_PATH + 1];
        CHAR    fileBuffer[MAX_PATH + 12 + 1];  // 12 for filename itself
        UINT    len = GetTempPathA(MAX_PATH, pathBuffer);

        if ((len == 0) || (len > MAX_PATH))
        {
            pathBuffer[0] = '.';
            pathBuffer[1] = '\0';
        }
        if (GetTempFileNameA(pathBuffer, "Emp", 0, fileBuffer) == 0)
        {
            return NULL;
        }
        len = (strlen(fileBuffer) + 1) * sizeof(WCHAR);
        WCHAR * filename = (WCHAR *)GpMalloc(len);
        if (filename != NULL)
        {
            if (AnsiToUnicodeStr(fileBuffer, filename, len))
            {
                return filename;
            }
            GpFree(filename);
        }
        return NULL;
    }
}
#endif

// For now, don't handle a source rect
GpBitmap *
GpMetafile::GetBitmap(
    INT                 width,
    INT                 height,
    const GpImageAttributes * imageAttributes
    )
{
    GpRectF         srcRect;
    GpPageUnit      srcUnit;

    this->GetBounds(&srcRect, &srcUnit);

    ASSERT(srcUnit == UnitPixel);

    // Determine what size to make the bitmap.

    if ((width <= 0) || (height <= 0))
    {
        if (this->IsEmfOrEmfPlus())
        {
            width  = GpRound(srcRect.Width);
            height = GpRound(srcRect.Height);
        }
        else    // must be a WMF
        {
            // Convert size to use the dpi of this display.
            // This is somewhat of a hack, but what else could I do,
            // since I don't know where this brush will be used?
            REAL        srcDpiX;
            REAL        srcDpiY;
            REAL        destDpiX = Globals::DesktopDpiX;    // guess
            REAL        destDpiY = Globals::DesktopDpiY;

            this->GetResolution(&srcDpiX, &srcDpiY);

            if ((srcDpiX <= 0) || (srcDpiY <= 0))
            {
                WARNING(("bad dpi for WMF"));
                return NULL;
            }

            width  = GpRound((srcRect.Width  / srcDpiX) * destDpiX);
            height = GpRound((srcRect.Height / srcDpiY) * destDpiY);
        }
        if ((width <= 0) || (height <= 0))
        {
            WARNING(("bad size for metafile"));
            return NULL;
        }
    }

    GpBitmap *  bitmapImage = new GpBitmap(width, height, PIXFMT_32BPP_ARGB);

    if (bitmapImage != NULL)
    {
        if (bitmapImage->IsValid())
        {
            GpGraphics *    graphics = bitmapImage->GetGraphicsContext();

            if (graphics != NULL)
            {
                if (graphics->IsValid())
                {
                    // we have to lock the graphics so the driver doesn't assert
                    GpLock * lockGraphics = new GpLock(graphics->GetObjectLock());

                    if (lockGraphics != NULL)
                    {
                        ASSERT(lockGraphics->IsValid());

                        // now draw the metafile into the bitmap image
                        GpRectF     destRect(0.0f, 0.0f, (REAL)width, (REAL)height);

                        // We don't want to interpolate the bitmaps in WMFs
                        // and EMFs when converting them to a texture.
                        graphics->SetInterpolationMode(InterpolationModeNearestNeighbor);

                        GpStatus status;

                        status = graphics->DrawImage(
                                        this,
                                        destRect,
                                        srcRect,
                                        srcUnit,
                                        imageAttributes);

                        // have to delete the lock before deleting the graphics
                        delete lockGraphics;

                        if (status == Ok)
                        {
                            delete graphics;
                            return bitmapImage;
                        }
                        WARNING(("DrawImage failed"));
                    }
                    else
                    {
                        WARNING(("Could not create graphics lock"));
                    }
                }
                else
                {
                    WARNING(("graphics from bitmap image not valid"));
                }
                delete graphics;
            }
            else
            {
                WARNING(("could not create graphics from bitmap image"));
            }
        }
        else
        {
            WARNING(("bitmap image is not valid"));
        }
        bitmapImage->Dispose();
    }
    else
    {
        WARNING(("could not create bitmap image"));
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\metaemf.cpp ===
/**************************************************************************\
*
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   MetaEmf.cpp
*
* Abstract:
*
*   Methods for playing and recoloring an EMF.
*
* Created:
*
*   1/6/2000 DCurtis
*
\**************************************************************************/

#include "Precomp.hpp"
#include "MetaWmf.hpp"

//----------------------------------------------------------------------------
//  File format signatures for Office Art data.
//------------------------------------------------------------------- JohnBo
#define msoszOfficeSignature "MSOFFICE"
#define msocbOfficeSignature 8
#define msoszOfficeAuthentication "9.0"
#define msocbOfficeAuthentication 3
#define msoszOfficeIdent msoszOfficeSignature msoszOfficeAuthentication
#define msocbOfficeIdent (msocbOfficeSignature+msocbOfficeAuthentication)

#define msoszOAPNGChunk "msOA"
#define msocbOAPNGChunk 4
#define msoszOADataHeader msoszOAPNGChunk msoszOfficeIdent
#define msocbOADataHeader (msocbOAPNGChunk+msocbOfficeIdent)

#define msoszOAKind "OA"
#define msocbOAKind 2

/* This defines an OZ chunk, like OA but Zlib compressed. */
#define msoszOZPNGChunk "msOZ"
#define msocbOZPNGChunk 4
#define msoszOZDataHeader msoszOZPNGChunk msoszOfficeIdent
#define msocbOZDataHeader (msocbOZPNGChunk+msocbOfficeIdent)

// These are needed for IA64 compatibility with X86
// Since we are reading this record from a stream, on IA64
// The EXTLOGPEN structure has a ULONG_PTR member which is not the same size
// on IA64 and X86. Since all output to files will keep the X86 format we need
// to make sure that we can read this format in IA64, so we make it compatible
// by changing the ULONG_PTR to a ULONG (32bit). The packing of the structure
// will them be the same and the members will be at the same offset

typedef struct tagEXTLOGPEN32 {
    DWORD       elpPenStyle;
    DWORD       elpWidth;
    UINT        elpBrushStyle;
    COLORREF    elpColor;
    ULONG       elpHatch;
    DWORD       elpNumEntries;
    DWORD       elpStyleEntry[1];
} EXTLOGPEN32, *PEXTLOGPEN32;

typedef struct tagEMREXTCREATEPEN32
{
    EMR     emr;
    DWORD   ihPen;              // Pen handle index
    DWORD   offBmi;             // Offset to the BITMAPINFO structure if any
    DWORD   cbBmi;              // Size of the BITMAPINFO structure if any
                                // The bitmap info is followed by the bitmap
                                // bits to form a packed DIB.
    DWORD   offBits;            // Offset to the brush bitmap bits if any
    DWORD   cbBits;             // Size of the brush bitmap bits if any
    EXTLOGPEN32 elp;              // The extended pen with the style array.
} EMREXTCREATEPEN32, *PEMREXTCREATEPEN32;

typedef struct tagEMRRCLBOUNDS
{
    EMR     emr;
    RECTL   rclBounds;
} EMRRCLBOUNDS, *PEMRRCLBOUNDS;

typedef struct EMROFFICECOMMENT
{
    EMR     emr;
    DWORD   cbData;             // Size of following fields and data
    DWORD   ident;              // GDICOMMENT_IDENTIFIER
    DWORD   iComment;           // Comment type e.g. GDICOMMENT_WINDOWS_METAFILE
} EMROFFICECOMMENT, *PEMROFFICECOMMENT;

RecolorStockObject RecolorStockObjectList[NUM_STOCK_RECOLOR_OBJS] =
{
    { WHITE_BRUSH,    (COLORREF)RGB(0xFF, 0xFF, 0xFF),   TRUE  },
    { LTGRAY_BRUSH,   (COLORREF)RGB(0xC0, 0xC0, 0xC0),   TRUE  },
    { GRAY_BRUSH,     (COLORREF)RGB(0x80, 0x80, 0x80),   TRUE  },
    { DKGRAY_BRUSH,   (COLORREF)RGB(0x40, 0x40 ,0x40),   TRUE  },
    { BLACK_BRUSH,    (COLORREF)RGB(0, 0, 0),            TRUE  },
    { WHITE_PEN,      (COLORREF)RGB(0xFF, 0xFF, 0xFF),   FALSE },
    { BLACK_PEN,      (COLORREF)RGB(0, 0 ,0),            FALSE }
};

inline static RGBQUAD *
GetDibColorTable(
    BITMAPINFOHEADER *      dibInfo
    )
{
    return ( RGBQUAD *)(((BYTE *)dibInfo) + dibInfo->biSize);
}

BOOL
EmfEnumState::CreateCopyOfCurrentRecord()
{
    if (ModifiedRecordSize > 0)
    {
        // We already made a modified record.  Don't do it again.
        ASSERT(ModifiedRecord != NULL);
        return TRUE;
    }

    INT     size = this->GetCurrentRecordSize();

    if (CreateRecordToModify(size))
    {
        ENHMETARECORD * modifiedRecord = (ENHMETARECORD *)ModifiedRecord;

        modifiedRecord->iType = RecordType;
        modifiedRecord->nSize = size;

        if (RecordDataSize > 0)
        {
            GpMemcpy(modifiedRecord->dParm, RecordData, RecordDataSize);
        }
        return TRUE;
    }

    WARNING(("Failed to create copy of current record"));
    return FALSE;
}

BOOL
EmfEnumState::CreateAndPlayOutputDIBRecord(
    HDC                           hdc,
    const RECTL *                 bounds,
    INT                           dstX,
    INT                           dstY,
    INT                           dstWidth,
    INT                           dstHeight,
    INT                           srcX,
    INT                           srcY,
    INT                           srcWidth,
    INT                           srcHeight,
    UNALIGNED BITMAPINFOHEADER *  dibInfo,
    BYTE *                        bits,   // if NULL, this is a packed DIB
    UINT                          usage,
    DWORD                         rop
    )
{
    ASSERT(!Globals::IsNt);

    INT  bitsSize = GetDibBitsSize(dibInfo);
    UINT sizePalEntries;

    if (GetDibNumPalEntries(FALSE,
                            dibInfo->biSize,
                            dibInfo->biBitCount,
                            dibInfo->biCompression,
                            dibInfo->biClrUsed,
                            &sizePalEntries))
    {
        // We need to get the palette size that corresponds to the type
        // If we have a DIB_PAL_COLORS then each entry is 16bits
        sizePalEntries *= ((usage == DIB_PAL_COLORS)?2:sizeof(RGBQUAD));
    }
    else
    {
        sizePalEntries = 0 ;
    }

    // We need at least a BITMAPINFO structure in there, but if there is a
    // palette, calculate the full size of the structure including the
    // palette

    INT bitmapHeaderSize = sizeof(BITMAPINFOHEADER) + sizePalEntries;
    INT size = sizeof(EMRSTRETCHDIBITS) + bitmapHeaderSize + bitsSize ;

    // We cannot use the CreateRecordToModify because the record has already
    // been modified
    size = (size + 3) & ~3;
    EMRSTRETCHDIBITS* emrStretchDIBits = (EMRSTRETCHDIBITS*) GpMalloc(size);
    if (emrStretchDIBits != NULL)
    {
        emrStretchDIBits->emr.iType = EmfRecordTypeStretchDIBits;
        emrStretchDIBits->emr.nSize = size;
        emrStretchDIBits->rclBounds = *bounds;
        emrStretchDIBits->xDest = dstX;
        emrStretchDIBits->yDest = dstY;
        emrStretchDIBits->xSrc = srcX;
        emrStretchDIBits->ySrc = srcY;
        emrStretchDIBits->cxSrc = srcWidth;
        emrStretchDIBits->cySrc = srcHeight;
        emrStretchDIBits->offBmiSrc = sizeof(EMRSTRETCHDIBITS);
        emrStretchDIBits->cbBmiSrc = bitmapHeaderSize;
        emrStretchDIBits->offBitsSrc = emrStretchDIBits->offBmiSrc + emrStretchDIBits->cbBmiSrc;
        emrStretchDIBits->cbBitsSrc = bitsSize;
        emrStretchDIBits->iUsageSrc = usage;
        emrStretchDIBits->dwRop = rop;
        emrStretchDIBits->cxDest = dstWidth;
        emrStretchDIBits->cyDest = dstHeight;
        GpMemcpy((BYTE*)emrStretchDIBits + emrStretchDIBits->offBmiSrc, dibInfo, emrStretchDIBits->cbBmiSrc);
        GpMemcpy((BYTE*)emrStretchDIBits + emrStretchDIBits->offBitsSrc, bits, emrStretchDIBits->cbBitsSrc);

        ::PlayEnhMetaFileRecord(hdc, HandleTable, (ENHMETARECORD *)emrStretchDIBits, NumObjects);
        GpFree(emrStretchDIBits);
        return TRUE;
    }
    return FALSE;
}

BITMAPINFOHEADER *
EmfEnumState::CreateModifiedDib(
    BITMAPINFOHEADER *  srcDibInfo,
    BYTE *              srcBits,
    UINT &              usage,
    DWORD               rop
    )
{
    BITMAPINFOHEADER *  dstDibInfo = NULL;
    UINT                numPalEntries;
    UINT                dibBitsSize;

    if ((srcDibInfo->biSize >= sizeof(BITMAPINFOHEADER)) &&
        GetDibNumPalEntries(FALSE,
                            srcDibInfo->biSize,
                            srcDibInfo->biBitCount,
                            srcDibInfo->biCompression,
                            srcDibInfo->biClrUsed,
                            &numPalEntries) &&
        ((dibBitsSize = GetDibBitsSize(srcDibInfo)) > 0))
    {
        if (numPalEntries == 2 && rop != SRCCOPY)
        {
            DWORD  *rgb = (DWORD*) GetDibColorTable(srcDibInfo);
            if (rgb[0] == 0x00000000 && rgb[1] == 0x00FFFFFF)
            {
                return dstDibInfo;
            }
        }

        // We need to pass in to ModifyDib the old Usage value because we haven't modified
        // the bitmap yet. Once we do then we will return the new usage of the palette.
        UINT oldUsage = usage;
        INT dstDibSize = GetModifiedDibSize(srcDibInfo, numPalEntries, dibBitsSize, usage);

        if ((dstDibSize > 0) && CreateRecordToModify(dstDibSize))
        {
            dstDibInfo = (BITMAPINFOHEADER *)ModifiedRecord;
            ModifyDib(oldUsage, srcDibInfo, srcBits, dstDibInfo,
                      numPalEntries, dibBitsSize, ColorAdjustTypeBitmap);
        }
    }
    return dstDibInfo;
}

VOID
EmfEnumState::BitBlt(
    )
{
    const EMRBITBLT *  bitBltRecord = (const EMRBITBLT *)GetPartialRecord();

    DWORD rop = bitBltRecord->dwRop;

    // If No-Op ROP, do nothing; just return
    if ((rop & 0xFFFF0000) == (GDIP_NOOP_ROP3 & 0xFFFF0000))
    {
        return;
    }

    // On NT4, PATCOPYs fail to draw correctly if there is a skew/rotate
    // in the matrix.  So use a rectangle call instead.
    if ((rop == PATCOPY) && Globals::IsNt && (Globals::OsVer.dwMajorVersion <= 4))
    {
        XFORM   xform;
        if (::GetWorldTransform(Hdc, &xform) &&
            ((xform.eM12 != 0.0f) || (xform.eM21 != 0.0f)))
        {
            HPEN    hPenOld = (HPEN)::SelectObject(Hdc, ::GetStockObject(NULL_PEN));
            DWORD   dcRop = ::GetROP2(Hdc);

            if (dcRop != R2_COPYPEN)
            {
                ::SetROP2(Hdc, R2_COPYPEN);
            }
            ::Rectangle(Hdc, bitBltRecord->xDest, bitBltRecord->yDest,
                        bitBltRecord->xDest + bitBltRecord->cxDest,
                        bitBltRecord->yDest + bitBltRecord->cyDest);
            ::SelectObject(Hdc, hPenOld);
            if (dcRop != R2_COPYPEN)
            {
                ::SetROP2(Hdc, dcRop);
            }
            return;
        }
    }

    if (rop != SRCCOPY &&
        rop != NOTSRCCOPY &&
        rop != PATCOPY &&
        rop != BLACKNESS &&
        rop != WHITENESS)
    {
        RopUsed = TRUE;
    }

    if ((bitBltRecord->cbBitsSrc > 0) &&
        (bitBltRecord->cbBmiSrc > 0)  &&
        IsSourceInRop3(rop))
    {
        // Should we modify the dib if it is monochrome?
        // What if there is a non-identity transform for the src DC?

        UINT                usage      = bitBltRecord->iUsageSrc;
        BITMAPINFOHEADER *  srcDibInfo = (BITMAPINFOHEADER *)(((BYTE *)bitBltRecord) + bitBltRecord->offBmiSrc);
        BYTE *              srcBits    = ((BYTE *)bitBltRecord) + bitBltRecord->offBitsSrc;
        BITMAPINFOHEADER *  dstDibInfo = CreateModifiedDib(srcDibInfo, srcBits, usage, rop);

        if (dstDibInfo != NULL)
        {
            srcDibInfo = dstDibInfo;
            srcBits = NULL;
        }

        if (SrcCopyOnly && rop != SRCCOPY)
        {
            rop = SRCCOPY;
        }

        OutputDIB(Hdc,
                  &bitBltRecord->rclBounds,
                  bitBltRecord->xDest,  bitBltRecord->yDest,
                  bitBltRecord->cxDest, bitBltRecord->cyDest,
                  bitBltRecord->xSrc,   bitBltRecord->ySrc,
                  bitBltRecord->cxDest, bitBltRecord->cyDest,
                  srcDibInfo, srcBits, usage, rop, FALSE);
    }
    else
    {
        if (SrcCopyOnly && rop != PATCOPY && !IsSourceInRop3(rop) && CreateCopyOfCurrentRecord())
        {
            EMRBITBLT *  newBitBltRecord = (EMRBITBLT *) ModifiedEmfRecord;
            newBitBltRecord->dwRop = PATCOPY;
        }
        ResetRecordBounds();
        this->PlayRecord();
    }
}

VOID
EmfEnumState::StretchBlt(
    )
{
    const EMRSTRETCHBLT *  stretchBltRecord = (const EMRSTRETCHBLT *)GetPartialRecord();

    DWORD rop = stretchBltRecord->dwRop;

    // If No-Op ROP, do nothing; just return
    if ((rop & 0xFFFF0000) == (GDIP_NOOP_ROP3 & 0xFFFF0000))
    {
        return;
    }

    if (rop != SRCCOPY &&
        rop != NOTSRCCOPY &&
        rop != PATCOPY &&
        rop != BLACKNESS &&
        rop != WHITENESS)
    {
        RopUsed = TRUE;
    }

    if ((stretchBltRecord->cbBitsSrc > 0) &&
        (stretchBltRecord->cbBmiSrc > 0)  &&
        IsSourceInRop3(rop))
    {
        // Should we modify the dib if it is monochrome?
        // What if there is a non-identity transform for the src DC?

        UINT                usage      = stretchBltRecord->iUsageSrc;
        BITMAPINFOHEADER *  srcDibInfo = (BITMAPINFOHEADER *)(((BYTE *)stretchBltRecord) + stretchBltRecord->offBmiSrc);
        BYTE *              srcBits    = ((BYTE *)stretchBltRecord) + stretchBltRecord->offBitsSrc;
        BITMAPINFOHEADER *  dstDibInfo = CreateModifiedDib(srcDibInfo, srcBits, usage, rop);

        if (SrcCopyOnly && rop != SRCCOPY)
        {
            rop = SRCCOPY;
        }

        ASSERT(sizeof(XFORM) == sizeof(REAL)*6);

        GpMatrix xForm((REAL*) &(stretchBltRecord->xformSrc));

        if (dstDibInfo != NULL)
        {
            srcDibInfo = dstDibInfo;
            srcBits = NULL;
        }

        GpRectF  srcRect((REAL)stretchBltRecord->xSrc,
                         (REAL)stretchBltRecord->ySrc,
                         (REAL)stretchBltRecord->cxSrc,
                         (REAL)stretchBltRecord->cySrc);

        if (!xForm.IsIdentity())
        {
            // We cannot use TransformRect, because the output rect will always
            // have a positive Width and Height which we don't want
            GpPointF points[2];
            points[0] = GpPointF(srcRect.X, srcRect.Y);
            points[1] = GpPointF(srcRect.GetRight(), srcRect.GetBottom());
            xForm.Transform(points, 2);
            srcRect.X = points[0].X;
            srcRect.Y = points[0].Y;
            srcRect.Width = points[1].X - points[0].X;
            srcRect.Height = points[1].Y - points[0].Y;
        }

        // StretchBlt takes as parameters the top left corner of the dest
        // whereas StretchDIBits takes the offset in the source image.
        // For bottom up dibs those are not the same and we need to offset
        // the srcrect's Y coodinate by the difference
        if (srcDibInfo->biHeight > 0 &&
            srcRect.Height < srcDibInfo->biHeight)
        {
            srcRect.Y = srcDibInfo->biHeight - srcRect.Height - srcRect.Y;
        }

        OutputDIB(Hdc,
                  &stretchBltRecord->rclBounds,
                  stretchBltRecord->xDest,  stretchBltRecord->yDest,
                  stretchBltRecord->cxDest, stretchBltRecord->cyDest,
                  GpRound(srcRect.X),   GpRound(srcRect.Y),
                  GpRound(srcRect.Width), GpRound(srcRect.Height),
                  srcDibInfo, srcBits, usage, rop, FALSE);
    }
    else
    {
        if (SrcCopyOnly && rop != PATCOPY && !IsSourceInRop3(rop) && CreateCopyOfCurrentRecord())
        {
            EMRSTRETCHBLT *  stretchBltRecord = (EMRSTRETCHBLT *)ModifiedEmfRecord;
            stretchBltRecord->dwRop = PATCOPY;
        }
        ResetRecordBounds();
        this->PlayRecord();
    }
}

VOID
EmfEnumState::StretchDIBits(
    )
{
    const EMRSTRETCHDIBITS *  stretchDIBitsRecord = (const EMRSTRETCHDIBITS *)GetPartialRecord();

    DWORD rop = stretchDIBitsRecord->dwRop;

    // If No-Op ROP, do nothing; just return
    if ((rop & 0xFFFF0000) == (GDIP_NOOP_ROP3 & 0xFFFF0000))
    {
        return;
    }

    if (rop != SRCCOPY &&
        rop != NOTSRCCOPY &&
        rop != PATCOPY &&
        rop != BLACKNESS &&
        rop != WHITENESS)
    {
        RopUsed = TRUE;
    }

    if ((stretchDIBitsRecord->cbBitsSrc > 0) &&
        (stretchDIBitsRecord->cbBmiSrc > 0)  &&
        IsSourceInRop3(rop))
    {
        UINT                usage      = stretchDIBitsRecord->iUsageSrc;
        BITMAPINFOHEADER *  srcDibInfo = (BITMAPINFOHEADER *)(((BYTE *)stretchDIBitsRecord) + stretchDIBitsRecord->offBmiSrc);
        BYTE *              srcBits    = ((BYTE *)stretchDIBitsRecord) + stretchDIBitsRecord->offBitsSrc;
        BITMAPINFOHEADER *  dstDibInfo = CreateModifiedDib(srcDibInfo, srcBits, usage, rop);

        if (dstDibInfo != NULL)
        {
            srcDibInfo = dstDibInfo;
            srcBits = NULL;
        }

        if (SrcCopyOnly && rop != SRCCOPY)
        {
            rop = SRCCOPY;
        }

        OutputDIB(Hdc,
                  &stretchDIBitsRecord->rclBounds,
                  stretchDIBitsRecord->xDest,  stretchDIBitsRecord->yDest,
                  stretchDIBitsRecord->cxDest, stretchDIBitsRecord->cyDest,
                  stretchDIBitsRecord->xSrc,   stretchDIBitsRecord->ySrc,
                  stretchDIBitsRecord->cxSrc,  stretchDIBitsRecord->cySrc,
                  srcDibInfo, srcBits, usage,  rop, FALSE);
    }
    else
    {
        if (SrcCopyOnly && rop != PATCOPY && !IsSourceInRop3(rop) && CreateCopyOfCurrentRecord())
        {
            EMRSTRETCHDIBITS*  stretchDIBitsRecord = (EMRSTRETCHDIBITS *)ModifiedEmfRecord;
            stretchDIBitsRecord->dwRop = PATCOPY;
        }
        ResetRecordBounds();
        this->PlayRecord();
    }
}

VOID
EmfEnumState::SetDIBitsToDevice(
    )
{
    // !!! to do

    // In SetDIBitsToDevice, the destination width and height
    // are in device units but in StretchDIBits, they are in world units.
    // Plus, the DIB header is for the entire DIB, but only part of the
    // DIB may be here (based on the number of scans).
    // So this record requires special handling if we are to process it.

    ResetRecordBounds();
    this->PlayRecord();
}

VOID
EmfEnumState::CreateDibPatternBrushPt(
    )
{
    const EMRCREATEDIBPATTERNBRUSHPT *  brushRecord = (const EMRCREATEDIBPATTERNBRUSHPT *)GetPartialRecord();
    INT     objectIndex = brushRecord->ihBrush;

    if (ValidObjectIndex(objectIndex) && (HandleTable != NULL))
    {
        UINT                usage      = brushRecord->iUsage;
        BITMAPINFOHEADER *  srcDibInfo = (BITMAPINFOHEADER *)(((UNALIGNED BYTE *)brushRecord) + brushRecord->offBmi);
        BITMAPINFOHEADER *  dstDibInfo = CreateModifiedDib(srcDibInfo, NULL, usage, SRCCOPY);

        if (dstDibInfo != NULL)
        {
            HandleTable->objectHandle[objectIndex] =
                    CreateDIBPatternBrushPt((BITMAPINFO *)dstDibInfo, usage);
            return;
        }
    }

    this->PlayRecord();
}

inline static BOOL
IsOfficeArtData(
    UINT                    recordSize,
    const EMRGDICOMMENT *   commentRecord
    )
{
    return ((recordSize >= (12 + 4 + msocbOADataHeader)) &&
            (commentRecord->cbData >= (msocbOADataHeader + 4)) &&
            ((GpMemcmp(commentRecord->Data, msoszOADataHeader, msocbOADataHeader) == 0) ||
             (GpMemcmp(commentRecord->Data, msoszOZDataHeader, msocbOZDataHeader) == 0)));
}

inline static const EMROFFICECOMMENT *
GetEmfComment(
    const BYTE *        emfRecord,
    ULONG               signature,
    UINT                kind
    )
{
    const EMROFFICECOMMENT *  emfComment = (const EMROFFICECOMMENT*)(emfRecord);
    if ((emfComment->ident == signature) && (emfComment->iComment == kind))
    {
        return emfComment;
    }
    return NULL;
}



VOID
EmfEnumState::GdiComment(
    )
{
    // Skip Office Art data when playing into another metafile
    if (IsMetafile() &&
        IsOfficeArtData(
            GetCurrentRecordSize(),
            (const EMRGDICOMMENT *)GetPartialRecord()))
    {
        return;
    }

    if (IsPostscript())
    {
        if (GetEmfComment((BYTE*)CurrentEmfRecord, msosignature, msocommentBeginSrcCopy))
        {
            SrcCopyOnly = TRUE;
            return;
        }
        if (GetEmfComment((BYTE*)CurrentEmfRecord, msosignature, msocommentEndSrcCopy))
        {
            SrcCopyOnly = FALSE;
            return;
        }
    }

    this->PlayRecord();
}

BOOL
IsPenCosmetic(
    HDC     hdc,
    int     penWidth
    )
{
    penWidth <<= 7;

    INT     newPenWidth = penWidth;
    POINT   points[2];

    points[0].x = 0;
    points[0].y = 0;
    points[1].x = 1 << 7;
    points[1].y = 0;

    if (::DPtoLP(hdc, points, 2))
    {
        newPenWidth = points[1].x - points[0].x;
        if (newPenWidth < 0)
        {
            newPenWidth = -newPenWidth;
        }
    }
    return (penWidth <= newPenWidth);
}

VOID
EmfEnumState::CreatePen(
    )
{
    const EMRCREATEPEN *    penRecord = (const EMRCREATEPEN *)GetPartialRecord();
    DWORD                   oldStyle  = penRecord->lopn.lopnStyle;

    if (oldStyle == PS_NULL)
    {
        this->PlayRecord();
    }
    else if (IsMetafile())
    {
        ModifyRecordColor(4, ColorAdjustTypePen);
        this->PlayRecord();
    }
    else
    {
        INT     objectIndex = penRecord->ihPen;

        if (ValidObjectIndex(objectIndex) && (HandleTable != NULL))
        {
            LOGBRUSH    logBrush;

            logBrush.lbStyle = PS_SOLID;
            logBrush.lbColor = ModifyColor(penRecord->lopn.lopnColor, ColorAdjustTypePen);
            logBrush.lbHatch = 0;

            INT         penWidth = penRecord->lopn.lopnWidth.x;
            DWORD       style;

            if (!Globals::IsNt && !IsMetafile())
            {
                //IsPenCosmetic is gonna call DPtoLP... Make sure to invalidate
                //the transform before
                CreateAndPlayCommentRecord();
            }

            if (IsPenCosmetic(Hdc, penWidth))
            {
                switch (oldStyle)
                {
                case PS_SOLID:
                case PS_DASH:           // on Win9x, cosmetic only
                case PS_DOT:            // on Win9x, cosmetic only
                case PS_DASHDOT:        // on Win9x, cosmetic only
                case PS_DASHDOTDOT:     // on Win9x, cosmetic only
                    break;

                case PS_ALTERNATE:      // cosmetic only, NT only
                    if (Globals::IsNt)
                    {
                        break;
                    }
                    // FALLTHRU

                case PS_USERSTYLE:      // NT only
                case PS_INSIDEFRAME:    // geometric only
                default:
                    oldStyle = PS_SOLID;
                    break;
                }
                penWidth = 1;
                style = PS_COSMETIC | oldStyle;
            }
            else
            {
                switch (oldStyle)
                {
                case PS_SOLID:
                case PS_INSIDEFRAME:    // geometric only
                    break;

                case PS_DASH:           // on Win9x, cosmetic only
                case PS_DOT:            // on Win9x, cosmetic only
                case PS_DASHDOT:        // on Win9x, cosmetic only
                case PS_DASHDOTDOT:     // on Win9x, cosmetic only
                    if (Globals::IsNt)
                    {
                        break;
                    }
                    // FALLTHRU

                case PS_ALTERNATE:      // cosmetic only, NT only
                case PS_USERSTYLE:      // NT only
                default:
                    oldStyle = PS_SOLID;
                    break;
                }
                style = PS_GEOMETRIC | oldStyle | PS_ENDCAP_ROUND | PS_JOIN_ROUND;
            }

            HandleTable->objectHandle[objectIndex] = ::ExtCreatePen(style, penWidth, &logBrush, 0, NULL);
        }
    }
}

HFONT CreateTrueTypeFont(
    HFONT   hFont
    )
{
    if (hFont)
    {
        if (Globals::IsNt)
        {
            LOGFONT  logFont;
            
            if (GetObject(hFont, sizeof(logFont), &logFont) > 0)
            {
                logFont.lfOutPrecision = OUT_TT_ONLY_PRECIS;
                return CreateFontIndirect(&logFont);
            }
            else
            {
                WARNING1("GetObject for hFont failed");
            }

        }
        else
        {
            LOGFONTA  logFont;

            if (GetObjectA(hFont, sizeof(logFont), &logFont) > 0)
            {
                logFont.lfOutPrecision = OUT_TT_ONLY_PRECIS;
                // We have a bug in Win9x that the OUT_TT_ONLY_PRECIS flag is
                // not always respected so if the font name is MS SANS SERIF
                // change it to Times New Roman
                if (lstrcmpiA(logFont.lfFaceName, "MS SANS SERIF") == 0)
                {
                    GpMemcpy(logFont.lfFaceName, "Times New Roman", sizeof("Times New Roman"));
                }
                return CreateFontIndirectA(&logFont);
            }
            else
            {
                WARNING1("GetObject for hFont failed");
            }
        }            
    }
    else
    {
        WARNING1("NULL hFont");
    }
    return NULL;
}

VOID
EmfEnumState::ExtCreateFontIndirect(
    )
{
    const EMREXTCREATEFONTINDIRECTW *    fontRecord = (const EMREXTCREATEFONTINDIRECTW *)GetPartialRecord();
    BOOL recordCopied = FALSE;
    if (!Globals::IsNt)
    {
        // We have a bug in Win9x that the OUT_TT_ONLY_PRECIS flag is
        // not always respected so if the font name is MS SANS SERIF
        // change it to Times New Roman
        if (UnicodeStringCompareCI(fontRecord->elfw.elfFullName, L"MS SANS SERIF") == 0)
        {
            if (CreateCopyOfCurrentRecord())
            {
                GpMemcpy(((EMREXTCREATEFONTINDIRECTW *)ModifiedEmfRecord)->elfw.elfFullName,
                         L"Times New Roman", sizeof(L"Times New Roman"));
                recordCopied = TRUE;
            }
        }
    }


    if (fontRecord->elfw.elfLogFont.lfOutPrecision != OUT_TT_ONLY_PRECIS)
    {
        if (recordCopied || CreateCopyOfCurrentRecord())
        // Instruct GDI to use only True Type fonts, since bitmap fonts
        // are not scalable.
        {
            ((EMREXTCREATEFONTINDIRECTW *)ModifiedEmfRecord)->elfw.elfLogFont.lfOutPrecision = OUT_TT_ONLY_PRECIS;
        }
    }
    this->PlayRecord();
}

VOID
EmfEnumState::SelectObject(
    )
{
    const EMRSELECTOBJECT *     selectRecord = (const EMRSELECTOBJECT *)GetPartialRecord();
    DWORD                       handleIndex  = selectRecord->ihObject;

    // See if we're selecting in a stock font
    if ((handleIndex & ENHMETA_STOCK_OBJECT) != 0)
    {
        handleIndex &= (~ENHMETA_STOCK_OBJECT);

        // handleIndex >= (WHITE_BRUSH==0) && <= BLACK_PEN
        if ((handleIndex <= BLACK_PEN) && (Recolor != NULL))
        {
            union {
                LOGBRUSH lb;
                LOGPEN lp;
            };

            RecolorStockObject* stockObj;
            int i;

            for (stockObj = &RecolorStockObjectList[0],
                 i = 0;
                 i < NUM_STOCK_RECOLOR_OBJS;
                 i++,
                 stockObj++)
            {
                if (stockObj->Handle == handleIndex)
                {
                    // Already have a cached recolored handle lying around.
                    HGDIOBJ stockHandle = RecoloredStockHandle[i];

                    if (stockHandle == NULL)
                    {
                        // No cached recolored stock object handle, recreate
                        // one here.
                        COLORREF newColor;

                        if (stockObj->Brush)
                        {
                            newColor = ModifyColor(stockObj->Color, ColorAdjustTypeBrush);

                            lb.lbStyle = BS_SOLID;
                            lb.lbColor = newColor;
                            lb.lbHatch = 0;

                            stockHandle = ::CreateBrushIndirect(&lb);

                            RecoloredStockHandle[i] = stockHandle;
                        }
                        else
                        {
                            newColor = ModifyColor(stockObj->Color, ColorAdjustTypePen);

                            lp.lopnStyle = PS_SOLID;
                            lp.lopnWidth.x = 1;
                            lp.lopnWidth.y = 0;
                            lb.lbColor = newColor;

                            stockHandle = ::CreatePenIndirect(&lp);

                            RecoloredStockHandle[i] = stockHandle;
                        }
                    }

                    if (stockHandle != NULL)
                    {
                        ::SelectObject(Hdc, stockHandle);
                        return;
                    }
                }
            }
        }
        else if ((handleIndex >= OEM_FIXED_FONT) &&
                 (handleIndex <= DEFAULT_GUI_FONT))
        {
            // It is a stock font -- create a true type font, instead of
            // using the stock font directly to guarantee that we don't
            // use bitmap fonts which don't scale well.

            HFONT   hFont = StockFonts[handleIndex - OEM_FIXED_FONT];

            if (hFont == NULL)
            {
                hFont = CreateTrueTypeFont((HFONT)GetStockObject(handleIndex));
                StockFonts[handleIndex - OEM_FIXED_FONT] = hFont;
            }

            if (hFont != NULL)
            {
                ::SelectObject(Hdc, hFont);
                return;
            }
        }
    }
    this->PlayRecord();

    // In case we select a region, intersect with the destrect
    if (!Globals::IsNt)
    {
        if (((handleIndex & ENHMETA_STOCK_OBJECT) == 0) &&
            (GetObjectTypeInternal((*HandleTable).objectHandle[handleIndex]) == OBJ_REGION))
        {
            this->IntersectDestRect();
        }
    }
}

VOID
EmfEnumState::ExtCreatePen(
    )
{
    const EMREXTCREATEPEN32 *  penRecord = (const EMREXTCREATEPEN32 *)GetPartialRecord();
    UINT    brushStyle = penRecord->elp.elpBrushStyle;

    if (brushStyle != BS_HOLLOW)
    {
        if (IsMetafile())
        {
            if ((brushStyle == BS_SOLID) || (brushStyle == BS_HATCHED))
            {
                ModifyRecordColor(8, ColorAdjustTypePen);
            }
            // else don't worry about recoloring pattern brushes for now

            this->PlayRecord();
            return;
        }

        INT     objectIndex = penRecord->ihPen;

        if (ValidObjectIndex(objectIndex) && (HandleTable != NULL))
        {
            if (!Globals::IsNt && !IsMetafile())
            {
                //IsPenCosmetic is gonna call DPtoLP... Make sure to invalidate
                //the transform before
                CreateAndPlayCommentRecord();
            }

            DWORD       penWidth   = penRecord->elp.elpWidth;
            BOOL        isCosmetic = IsPenCosmetic(Hdc, penWidth);
            DWORD       oldStyle   = penRecord->elp.elpPenStyle;

            if (!Globals::IsNt)
            {
                DWORD       style;

                if (isCosmetic)
                {
                    oldStyle &= PS_STYLE_MASK;

                    switch (oldStyle)
                    {
                    case PS_SOLID:
                    case PS_DASH:           // on Win9x, cosmetic only
                    case PS_DOT:            // on Win9x, cosmetic only
                    case PS_DASHDOT:        // on Win9x, cosmetic only
                    case PS_DASHDOTDOT:     // on Win9x, cosmetic only
                        break;

                    case PS_ALTERNATE:      // cosmetic only, NT only
                    case PS_USERSTYLE:      // NT only
                    case PS_INSIDEFRAME:    // geometric only
                    default:
                        oldStyle = PS_SOLID;
                        break;
                    }
                    penWidth = 1;
                    style = PS_COSMETIC | oldStyle;
                }
                else
                {
                    oldStyle &= (~PS_TYPE_MASK);

                    switch (oldStyle & PS_STYLE_MASK)
                    {
                    case PS_SOLID:
                    case PS_INSIDEFRAME:    // geometric only
                        break;

                    case PS_DASH:           // on Win9x, cosmetic only
                    case PS_DOT:            // on Win9x, cosmetic only
                    case PS_DASHDOT:        // on Win9x, cosmetic only
                    case PS_DASHDOTDOT:     // on Win9x, cosmetic only
                    case PS_ALTERNATE:      // cosmetic only, NT only
                    case PS_USERSTYLE:      // NT only
                    default:
                        oldStyle = (oldStyle & (~PS_STYLE_MASK)) | PS_SOLID;
                        break;
                    }
                    style = PS_GEOMETRIC | oldStyle;
                }

                COLORREF    color = RGB(0,0,0);

                if ((brushStyle == BS_SOLID) || (brushStyle == BS_HATCHED))
                {
                    color = penRecord->elp.elpColor;
                }

                color = ModifyColor(color, ColorAdjustTypePen);

                // Only solid brushes are supported on Win9x
                LOGBRUSH    logBrush;
                logBrush.lbStyle = PS_SOLID;
                logBrush.lbColor = color;
                logBrush.lbHatch = 0;

                HandleTable->objectHandle[objectIndex] = ::ExtCreatePen(style, penWidth, &logBrush, 0, NULL);
                return;
            }

            // else it is NT
            if ((brushStyle == BS_SOLID) || (brushStyle == BS_HATCHED))
            {
                ModifyRecordColor(8, ColorAdjustTypePen);
            }
            // else don't worry about recoloring pattern brushes for now

            if (isCosmetic && CreateCopyOfCurrentRecord())
            {
                oldStyle &= PS_STYLE_MASK;
                if (oldStyle == PS_INSIDEFRAME) // geometric only
                {
                    oldStyle = PS_SOLID;
                }
                ((EMREXTCREATEPEN32 *)ModifiedEmfRecord)->elp.elpPenStyle = PS_COSMETIC | oldStyle;
                ((EMREXTCREATEPEN32 *)ModifiedEmfRecord)->elp.elpWidth    = 1;
            }
        }
    }
    this->PlayRecord();
}

VOID
EmfEnumState::CreateBrushIndirect(
    )
{
    const EMRCREATEBRUSHINDIRECT *  brushRecord = (const EMRCREATEBRUSHINDIRECT *)GetPartialRecord();

    if (brushRecord->lb.lbStyle != BS_HOLLOW)
    {
        ModifyRecordColor(2, ColorAdjustTypeBrush);

        if (ModifiedEmfRecord != NULL)
        {
            brushRecord = (const EMRCREATEBRUSHINDIRECT *)ModifiedEmfRecord;
        }

        // See if we need to halftone the color.  We do if it is a solid
        // color, and we have a halftone palette, and the color is not
        // an exact match in the palette.

        COLORREF    color;

        if (IsHalftonePalette && (brushRecord->lb.lbStyle == BS_SOLID) &&
            (((color = brushRecord->lb.lbColor) & 0x02000000) == 0))
        {
            // create a halftone brush, instead of a solid brush

            INT     objectIndex = brushRecord->ihBrush;

            if (ValidObjectIndex(objectIndex) && (HandleTable != NULL))
            {
                BYTE dib[sizeof(BITMAPINFOHEADER) + // DIB 8 bpp header
                         (8 * sizeof(RGBQUAD)) +    // DIB 8 colors
                         (8* 8)];                   // DIB 8x8 pixels

                HalftoneColorRef_216(color, dib);

                HandleTable->objectHandle[objectIndex] =
                        CreateDIBPatternBrushPt(dib, DIB_RGB_COLORS);
                return;
            }
        }
    }
    this->PlayRecord();
}

BOOL
EmfEnumState::PlayRecord(
    )
{
    const ENHMETARECORD *  recordToPlay = ModifiedEmfRecord;

    // See if we've modified the record
    if (recordToPlay == NULL)
    {
        // We haven't.  See if we have a valid current record
        if (CurrentEmfRecord != NULL)
        {
            recordToPlay = CurrentEmfRecord;
        }
        else
        {
            // we don't so we have to create one
            if (!CreateCopyOfCurrentRecord())
            {
                return FALSE;
            }
            recordToPlay = ModifiedEmfRecord;
        }
    }
    return PlayEnhMetaFileRecord(Hdc, HandleTable, recordToPlay, NumObjects);
}

VOID
EmfEnumState::RestoreHdc(
    )
{
    LONG    relativeCount = ((const EMRRESTOREDC *)GetPartialRecord())->iRelative;

    if (SaveDcCount < 0)
    {
        if (relativeCount >= SaveDcCount)
        {
            if (relativeCount >= 0)
            {
                // Modify the record
                CreateCopyOfCurrentRecord();    // guaranteed to succeed
                relativeCount = -1;
                ((EMRRESTOREDC *)ModifiedEmfRecord)->iRelative = -1;
            }
        }
        else
        {
            // Modify the record
            CreateCopyOfCurrentRecord();    // guaranteed to succeed
            relativeCount = SaveDcCount;
            ((EMRRESTOREDC *)ModifiedEmfRecord)->iRelative = relativeCount;
        }
        SaveDcCount -= relativeCount;
        this->PlayRecord();
    }
    else
    {
        WARNING(("RestoreDC not matched to a SaveDC"));
    }
}

VOID
EmfEnumState::ModifyRecordColor(
    INT             paramIndex,
    ColorAdjustType adjustType
    )
{
    COLORREF    origColor = ((COLORREF *)RecordData)[paramIndex];
    COLORREF    modifiedColor = ModifyColor(origColor, adjustType);

    if (modifiedColor != origColor)
    {
        if (CreateCopyOfCurrentRecord())
        {
            *((COLORREF*)&(ModifiedEmfRecord->dParm[paramIndex])) = modifiedColor;
        }
    }
}

VOID
EmfEnumState::ExtEscape(
    )
{
    if (IsPostscriptPrinter())
    {
        // Bug #98743 (Windows Bugs) Gdiplus must overcome GDI limitation
        // with POSTSCRIPT_INJECTION.  Comments from Rammanohar Arumugam:
        //
        // Being in xx-centric mode means POSTSCRIPT_DATA won't work. I
        // take that to mean that PlayMetaFileRecord only works in
        // compatibility mode.
        //
        // GdiPlus will check for the printer mode. In GDI-centric and
        // Postscript-centric mode, it will not do PlayMetaFileRecord for
        // any record that has POSTSCRIPT_DATA. Instead, it will output
        // the postscript data through a PASSTHRU (for GDI-centric mode)
        // or a POSTSCRIPT_PASSTHRU (for Postscript-Centric mode).
        //
        // You can find out the mode by querying the escape support.
        // 1. Query for POSTSCRIPT_INJECTION support. If not supported,
        // it's compat mode. If supported, find out the mode by doing step 2/3
        // 2. Query for PASSTHROUGH support. If supported, it's GDI-centric.
        // 3. Query for POSTSCRIPT_PASSTHROUGH support. If supported, it's PS-centric.

        PEMREXTESCAPE escRecord = (PEMREXTESCAPE) RecordData;

        //    EMR     emr;
        //    INT     iEscape;            // Escape code
        //    INT     cbEscData;          // Size of escape data
        //    BYTE    EscData[1];         // Escape data

        if (escRecord->iEscape == POSTSCRIPT_DATA)
        {
            if (Globals::IsNt)
            {
                DWORD EscapeValue = POSTSCRIPT_IDENTIFY;

                if (::ExtEscape(Hdc,
                              QUERYESCSUPPORT,
                              sizeof(DWORD),
                              (LPSTR)&EscapeValue,
                              0,
                              NULL) <= 0)
                {
                    // POSTSCRIPT_IDENTITY is not supported if the mode has
                    // been set because it can only be set once.

                    EscapeValue = POSTSCRIPT_PASSTHROUGH;
                    if (::ExtEscape(Hdc,
                                  QUERYESCSUPPORT,
                                  sizeof(DWORD),
                                  (LPSTR)&EscapeValue,
                                  0,
                                  NULL) <= 0)
                    {
                        // GDI-centric mode
                        if (CreateCopyOfCurrentRecord())
                        {
                            ((EMREXTESCAPE *)ModifiedEmfRecord)->iEscape = PASSTHROUGH;
                        }
                    }
                    else
                    {
                        // PS-centric mode
                        if (CreateCopyOfCurrentRecord())
                        {
                            ((EMREXTESCAPE *)ModifiedEmfRecord)->iEscape = POSTSCRIPT_PASSTHROUGH;
                        }
                    }

                    this->PlayRecord();
                    return;
                }
                else
                {
                    // compatibility mode uses POSTSCRIPT_DATA
                }
            }
            else
            {
                // Win98 doesn't distinguish between GDI & compatibility mode
                if (CreateCopyOfCurrentRecord())
                {
                    ((EMREXTESCAPE *)ModifiedEmfRecord)->iEscape = PASSTHROUGH;
                }
            }
        }
    }

    this->PlayRecord();
}

EmfEnumState::EmfEnumState(
    HDC                 hdc,
    HENHMETAFILE        hEmf,
    const RECT *        dest,
    const RECT *        deviceRect,
    BOOL                externalEnumeration,
    InterpolationMode   interpolation,
    DpContext *         context,
    GpRecolor *         recolor,
    ColorAdjustType     adjustType
    )
    : MfEnumState(hdc, externalEnumeration, interpolation,
                  recolor, adjustType, deviceRect, context)
{
    if (IsValid())
    {
        ClipRgn    = NULL;
        Palette    = NULL;
        BrushOrg.x = 0;
        BrushOrg.y = 0;

        // Bug 166280 from Office:
        // PROBLEM: If the DC has any clipping region in it, EnumEnhMetaFile
        //          will create a region before calling the EnumProc for the
        //          first time.  And, this region is not deleted and cannot be
        //          recovered through RestoreDC. (Only on Win9x)
        // FIX:     Before calling EnumEnhMetafile, save the clipping region
        //          and set the Clipping region to NULL.  Select the saved
        //          clipping region in the CallBack at EMR_HEADER.
        //          We will not do this on Metafile DC.  Put clipping region
        //          records in Metafile may cause other rendering problems.

        if (!Globals::IsNt && !IsMetafile())
        {
            HRGN    clipRgn = ::CreateRectRgn(0,0,0,0);

            if (clipRgn != NULL)
            {
                switch (::GetClipRgn(hdc, clipRgn))
                {
                case -1:        // error
                case 0:         // no initial clip region
                    ::DeleteObject(clipRgn);
                    break;
                case 1:         // has initial clip region
                    ::SelectClipRgn(hdc, NULL);
                    ClipRgn = clipRgn;
                    break;
                }
            }
        }

        // Bug 160932 from Office:  Redraw problems with EMFs
        // The fix is to make the drawing independent of where
        // the EMF is drawn - this can be done easily by setting the
        // brush origin before the first record is played (in the
        // record callback proc) to a value which is the top left of the
        // output rectangle of the EMF in device coordinates (i.e. LPtoDP of
        // the logical coordinate top left).

        BrushOrg.x = dest->left;
        BrushOrg.y = dest->top;
        LPtoDP(hdc, &BrushOrg, 1);

        // EnumEnhMetafile selects in the DEFAULT_PALETTE, but we may need
        // another palette to remain selected in (for halftoning, etc.)
        // so save the current palette and select it back in when the
        // header record is received.

        HPALETTE    hpal = (HPALETTE)GetCurrentObject(hdc, OBJ_PAL);
        if (hpal != (HPALETTE)GetStockObject(DEFAULT_PALETTE))
        {
            Palette = hpal;
        }
        BkColor   = ::GetBkColor(hdc);
        TextColor = ::GetTextColor(hdc);
    }
}

VOID
EmfEnumState::Header(
    )
{
    ::SetBrushOrgEx(Hdc, BrushOrg.x, BrushOrg.y, NULL);
    if (ClipRgn != (HRGN)0)
    {
        ::SelectClipRgn(Hdc, ClipRgn);
        ::DeleteObject(ClipRgn);
        ClipRgn = NULL;
    }
    if (Palette != NULL)
    {
        ::SelectPalette(Hdc, Palette, TRUE);
    }

    // Bitmap fonts are not good for playing metafiles because they
    // don't scale well, so use a true type font instead as the default font.

    HFONT hFont = CreateTrueTypeFont((HFONT)GetCurrentObject(Hdc, OBJ_FONT));

    if (hFont != NULL)
    {
        DefaultFont = hFont;
        ::SelectObject(Hdc, hFont);
    }

    this->PlayRecord();
}

VOID
EmfEnumState::SelectPalette(INT objectIndex)
{
    if (objectIndex == (ENHMETA_STOCK_OBJECT | DEFAULT_PALETTE))
    {
        CurrentPalette = (HPALETTE)::GetStockObject(DEFAULT_PALETTE);
    }
    else
    {
        MfEnumState::SelectPalette(objectIndex);
    }
}

VOID
EmfEnumState::IntersectDestRect()
{
    if (!IsMetafile())
    {
        // Make the transform the identity
        POINT windowOrg;
        SIZE  windowExt;
        POINT viewportOrg;
        SIZE  viewportExt;
        ::SetViewportOrgEx(Hdc, 0, 0, &viewportOrg);
        ::SetViewportExtEx(Hdc, 1, 1, &viewportExt);
        ::SetWindowOrgEx(Hdc, 0, 0, &windowOrg);
        ::SetWindowExtEx(Hdc, 1, 1, &windowExt);

        // We are always in device units
        ::IntersectClipRect(Hdc, DestRectDevice.left, DestRectDevice.top,
                            DestRectDevice.right, DestRectDevice.bottom);

        // Restore the transform
        ::SetViewportOrgEx(Hdc, viewportOrg.x, viewportOrg.y, NULL);
        ::SetViewportExtEx(Hdc, viewportExt.cx, viewportExt.cy, NULL);
        ::SetWindowOrgEx(Hdc, windowOrg.x, windowOrg.y, NULL);
        ::SetWindowExtEx(Hdc, windowExt.cx, windowExt.cy, NULL);
    }
}

VOID EmfEnumState::SetROP2()
{
    DWORD    dwROP = ((const EMRSETROP2 *)GetPartialRecord())->iMode;

    if (dwROP != R2_BLACK &&
        dwROP != R2_COPYPEN &&
        dwROP != R2_NOTCOPYPEN &&
        dwROP != R2_WHITE )
    {
        RopUsed = TRUE;
    }
    this->PlayRecord();
}

VOID EmfEnumState::ExtTextOutW()
{
    if (!this->PlayRecord())
    {
        BYTE* emrTextOut = (BYTE*) GetPartialRecord();
        if(CreateCopyOfCurrentRecord())
        {
            // !!! Shouldn't this use the offset in the record?

            BYTE * ptr = emrTextOut + sizeof(EMREXTTEXTOUTW);
            AnsiStrFromUnicode ansistr((WCHAR*)ptr);
            INT len = strlen(ansistr);
            // Don't forget to copy the NULL byte
            GpMemcpy((BYTE*)ModifiedEmfRecord + sizeof(EMREXTTEXTOUTW), (char*)ansistr, len+1);
            EMREXTTEXTOUTA *record = (EMREXTTEXTOUTA*) ModifiedEmfRecord;
            record->emr.iType = EmfRecordTypeExtTextOutA;

            // Keep the size of the record intact because of the spacing vector
            this->PlayRecord();
        }
    }
}

VOID EmfEnumState::Rectangle()
{
    // On NT convert the rectangle call to a polygon call because rectangle
    // seem to have a special case that can draw outside of the metafile
    // bounds. GDI seems to Ceil the coordinates instead of rounding them for
    // rectangles.

    if (!Globals::IsNt || IsMetafile())
    {
        this->PlayRecord();
        return;
    }
    const EMRRECTANGLE *emrRect = (const EMRRECTANGLE*) GetPartialRecord();
    
    POINT points[4] = {emrRect->rclBox.left,  emrRect->rclBox.top,
                       emrRect->rclBox.right, emrRect->rclBox.top,
                       emrRect->rclBox.right, emrRect->rclBox.bottom,
                       emrRect->rclBox.left,  emrRect->rclBox.bottom};

    ::Polygon(Hdc, points, 4);
    return;
}

BOOL
EmfEnumState::ProcessRecord(
    EmfPlusRecordType       recordType,
    UINT                    recordDataSize,
    const BYTE *            recordData
    )
{
    BOOL        forceCallback = FALSE;

    // See if we're doing enumeration for an external app
    if (ExternalEnumeration)
    {
        if (recordData == NULL)
        {
            recordDataSize = 0;
        }
        else if (recordDataSize == 0)
        {
            recordData = NULL;
        }

        // See if the app changed the record at all.
        if ((recordType != RecordType) ||
            (recordDataSize != RecordDataSize) ||
            ((recordDataSize > 0) &&
             ((CurrentEmfRecord == NULL) ||
              (recordData != (const BYTE *)(const BYTE *)CurrentEmfRecord->dParm))))
        {
            // Yes, we need to override what happened in StartRecord
            CurrentEmfRecord  = NULL;
            RecordType        = recordType;
            RecordData        = recordData;
            RecordDataSize    = recordDataSize;
        }
    }

    GDIP_TRY

    switch (recordType)
    {
    case EmfRecordTypeHeader:
        this->Header();
        break;

#if 0
    // Do we really need to do anything for PolyPolygon records?
    // If so, why not for PolyPolyline too?
    case EmfRecordTypePolyPolygon:
        this->PolyPolygon();
        break;

    case EmfRecordTypePolyPolygon16:
        this->PolyPolygon16();
        break;
#endif

    case EmfRecordTypeExtEscape:
        this->ExtEscape();
        break;

    case EmfRecordTypeSetPixelV:
        this->SetPixelV();
        break;

    case EmfRecordTypeSetTextColor:
        this->SetTextColor();
        break;

    case EmfRecordTypeSetBkColor:
        this->SetBkColor();
        break;

    case EmfRecordTypeSetMetaRgn:
        // Office Bug 154881.  Win9x doesn't handle MetaRgn correctly.
        if (Globals::IsNt)
        {
            this->PlayRecord();
        }
        break;

    case EmfRecordTypeSaveDC:
        this->SaveHdc();
        break;

    case EmfRecordTypeRestoreDC:
        this->RestoreHdc();
        break;

    case EmfRecordTypeCreatePen:
        this->CreatePen();
        break;

   case EmfRecordTypeCreateBrushIndirect:
        this->CreateBrushIndirect();
        break;

    case EmfRecordTypeSelectPalette:
        // We don't select in any palettes when playing the metafile,
        // because we don't want to invalidate our halftoning palette.
        // Keep track of the palette so we can map from PALETTEINDEXes
        // to RGB values.
        this->SelectPalette(((UINT32 *)recordData)[0]);
        break;

    case EmfRecordTypeRealizePalette:
        // We don't want to invalidate our halftoning palette by realizing one
        // from a metafile.
        break;

    case EmfRecordTypeExtFloodFill:
        this->ExtFloodFill();
        break;

    case EmfRecordTypeGdiComment:
        this->GdiComment();
        break;

    case EmfRecordTypeBitBlt:
        this->BitBlt();
        forceCallback = TRUE;
        break;

    case EmfRecordTypeStretchBlt:
        this->StretchBlt();
        forceCallback = TRUE;
        break;

    case EmfRecordTypeMaskBlt:
        this->MaskBlt();
        forceCallback = TRUE;
        break;

    case EmfRecordTypePlgBlt:
        this->PlgBlt();
        forceCallback = TRUE;
        break;

    case EmfRecordTypeSetDIBitsToDevice:
        this->SetDIBitsToDevice();
        forceCallback = TRUE;
        break;

    case EmfRecordTypeStretchDIBits:
        this->StretchDIBits();
        forceCallback = TRUE;
        break;

   // case EMR_CREATEMONOBRUSH:
   // A monochrome brush uses the text color and the background color,
   // so we shouldn't need to make any changes to the brush itself.

   case EmfRecordTypeCreateDIBPatternBrushPt:
        this->CreateDibPatternBrushPt();
        break;

    case EmfRecordTypeExtCreatePen:
        this->ExtCreatePen();
        break;

    case EmfRecordTypeSetICMMode:
    case EmfRecordTypeCreateColorSpace:
    case EmfRecordTypeSetColorSpace:
    case EmfRecordTypeDeleteColorSpace:
    case EmfRecordTypeSetICMProfileA:
    case EmfRecordTypeSetICMProfileW:
    case EmfRecordTypeCreateColorSpaceW:
        if (Globals::IsNt ||
            (!this->IsScreen() && !this->IsBitmap()))
        {
            this->PlayRecord();
        }
        // else skip the record
        break;

    case EmfRecordTypeAlphaBlend:
        this->AlphaBlend();
        forceCallback = TRUE;
        break;

    case EmfRecordTypeTransparentBlt:
        this->TransparentBlt();
        forceCallback = TRUE;
        break;

    case EmfRecordTypeGradientFill:
        this->GradientFill();
        forceCallback = TRUE;
        break;

    case EmfRecordTypeExtCreateFontIndirect:
        this->ExtCreateFontIndirect();
        break;

    case EmfRecordTypeSelectObject:
        this->SelectObject();
        break;

    case EmfRecordTypeSelectClipPath:
    case EmfRecordTypeExtSelectClipRgn:
    case EmfRecordTypeOffsetClipRgn:
        this->PlayRecord();
        if (!Globals::IsNt)
        {
            this->IntersectDestRect();
        }
        break;

    case EmfRecordTypeSetROP2:
        this->SetROP2();
        break;

    case EmfRecordTypeFillRgn:
    case EmfRecordTypeFrameRgn:
    case EmfRecordTypeInvertRgn:
    case EmfRecordTypePaintRgn:
        this->ResetRecordBounds();
        this->PlayRecord();
        break;

    case EmfRecordTypeExtTextOutW:
        this->ExtTextOutW();
        break;

    case EmfRecordTypeRectangle:
        this->Rectangle();
        break;

    case EmfRecordTypeSetMapMode:
    case EmfRecordTypeSetViewportExtEx:
    case EmfRecordTypeSetViewportOrgEx:
    case EmfRecordTypeSetWindowExtEx:
    case EmfRecordTypeSetWindowOrgEx:
    case EmfRecordTypePolyBezier:
    case EmfRecordTypePolygon:
    case EmfRecordTypePolyline:
    case EmfRecordTypePolyBezierTo:
    case EmfRecordTypePolyLineTo:
    case EmfRecordTypePolyPolyline:
    case EmfRecordTypePolyPolygon:
    case EmfRecordTypeSetBrushOrgEx:
    case EmfRecordTypeEOF:
    case EmfRecordTypeSetMapperFlags:
    case EmfRecordTypeSetBkMode:
    case EmfRecordTypeSetPolyFillMode:
    case EmfRecordTypeSetStretchBltMode:
    case EmfRecordTypeSetTextAlign:
    case EmfRecordTypeSetColorAdjustment:
    case EmfRecordTypeMoveToEx:
    case EmfRecordTypeExcludeClipRect:
    case EmfRecordTypeIntersectClipRect:
    case EmfRecordTypeScaleViewportExtEx:
    case EmfRecordTypeScaleWindowExtEx:
    case EmfRecordTypeSetWorldTransform:
    case EmfRecordTypeModifyWorldTransform:
    case EmfRecordTypeDeleteObject:
    case EmfRecordTypeAngleArc:
    case EmfRecordTypeEllipse:
    case EmfRecordTypeRoundRect:
    case EmfRecordTypeArc:
    case EmfRecordTypeChord:
    case EmfRecordTypePie:
    case EmfRecordTypeCreatePalette:
    case EmfRecordTypeSetPaletteEntries:
    case EmfRecordTypeResizePalette:
    case EmfRecordTypeLineTo:
    case EmfRecordTypeArcTo:
    case EmfRecordTypePolyDraw:
    case EmfRecordTypeSetArcDirection:
    case EmfRecordTypeSetMiterLimit:
    case EmfRecordTypeBeginPath:
    case EmfRecordTypeEndPath:
    case EmfRecordTypeCloseFigure:
    case EmfRecordTypeFillPath:
    case EmfRecordTypeStrokeAndFillPath:
    case EmfRecordTypeStrokePath:
    case EmfRecordTypeFlattenPath:
    case EmfRecordTypeWidenPath:
    case EmfRecordTypeAbortPath:
    case EmfRecordTypeReserved_069:
    case EmfRecordTypeExtTextOutA:
    case EmfRecordTypePolyBezier16:
    case EmfRecordTypePolygon16:
    case EmfRecordTypePolyline16:
    case EmfRecordTypePolyBezierTo16:
    case EmfRecordTypePolylineTo16:
    case EmfRecordTypePolyPolyline16:
    case EmfRecordTypePolyPolygon16:
    case EmfRecordTypePolyDraw16:
    case EmfRecordTypeCreateMonoBrush:
    case EmfRecordTypePolyTextOutA:
    case EmfRecordTypePolyTextOutW:
    case EmfRecordTypeGLSRecord:
    case EmfRecordTypeGLSBoundedRecord:
    case EmfRecordTypePixelFormat:
    case EmfRecordTypeDrawEscape:
    case EmfRecordTypeStartDoc:
    case EmfRecordTypeSmallTextOut:
    case EmfRecordTypeForceUFIMapping:
    case EmfRecordTypeNamedEscape:
    case EmfRecordTypeColorCorrectPalette:
    case EmfRecordTypeSetLayout:
    case EmfRecordTypeReserved_117:
    case EmfRecordTypeSetLinkedUFIs:
    case EmfRecordTypeSetTextJustification:
    case EmfRecordTypeColorMatchToTargetW:
        // Play the current record.
        // Even if it fails, we keep playing the rest of the metafile.
        this->PlayRecord();
        break;

    default:
        // unknown record -- ignore it
        WARNING1("Unknown EMF Record");
        break;
    }

    GDIP_CATCH
        forceCallback = TRUE;
    GDIP_ENDCATCH

    return forceCallback;
}

VOID EmfEnumState::ResetRecordBounds()
{
    if (Globals::IsNt && IsMetafile())
    {
        if (ModifiedEmfRecord == NULL)
        {
            CreateCopyOfCurrentRecord();
        }
        // In case the previous call failed
        if (ModifiedEmfRecord != NULL)
        {
            RECTL rect = {INT_MIN, INT_MIN, INT_MAX, INT_MAX};
            EMRRCLBOUNDS *record = (EMRRCLBOUNDS*) ModifiedEmfRecord;
            record->rclBounds = rect;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\metawmf.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   MetaWmf.cpp
*
* Abstract:
*
*   Methods for playing and recoloring a WMF.
*
* Created:
*
*   12/13/1999 DCurtis
*
\**************************************************************************/

#include "Precomp.hpp"
#include "MetaWmf.hpp"

#ifndef BI_CMYK     // from wingdip.h
#define BI_CMYK         10L
#define BI_CMYKRLE8     11L
#define BI_CMYKRLE4     12L
#endif

inline static BOOL
IsDwordAligned(
    VOID *      pointer
    )
{
    return (((ULONG_PTR)pointer & (sizeof(DWORD) - 1)) == 0);
}

inline static BOOL
IsPostscriptPrinter(
    HDC     hdc
    )
{
    // It is a PostScript printer if POSTSCRIPT_PASSTHROUGH or
    // POSTSCRIPT_IGNORE is available

    int iWant1 = POSTSCRIPT_PASSTHROUGH;
    int iWant2 = POSTSCRIPT_IGNORE;

    return ((Escape(hdc, QUERYESCSUPPORT, sizeof(iWant1), (LPCSTR)&iWant1, NULL) != 0) ||
            (Escape(hdc, QUERYESCSUPPORT, sizeof(iWant2), (LPCSTR)&iWant2, NULL) != 0));
}

// Some escapes apparently cause NT 3.51 to crash, so skip them
inline static BOOL
SkipEscape(
    INT     escapeCode
    )
{
    switch (escapeCode)
    {
    case GETPHYSPAGESIZE:       // 12
    case GETPRINTINGOFFSET:     // 13
    case GETSCALINGFACTOR:      // 14
    case BEGIN_PATH:            // 4096
    case CLIP_TO_PATH:          // 4097
    case END_PATH:              // 4098
        return TRUE;
    default:
        return FALSE;
    }
}

inline static BOOL
IsOfficeArtData(
    UINT                recordSize,
    const WORD *        recordData
    )
{
    return (recordData[0] == MFCOMMENT) &&
           (recordSize > 16) &&
           ((INT)recordSize >= (recordData[1] + 10)) &&
           (GpMemcmp(recordData + 2, "TNPPOA", 6) == 0);
}

// The structure which defines the contents of a comment for a WMF or PICT,
// for an EMF use GdiComment() and the "approved" format (see the Win32
// documentation) - this basically is the same except that it has a 4 byte
// kind field.  For a PICT this is the format of an ApplicationComment (kind
// 100).
#pragma pack(push, GDIP_pack, 2)
typedef struct
{
    ULONG       Signature;   // Identifes the comment writer.
    USHORT      Kind;        // Type of comment (writer specific)
    // Comment data follows here.

} WmfComment;

typedef struct
{
    WORD     lbStyle;
    COLORREF lbColor;
    SHORT    lbHatch;
} LOGBRUSH16;

typedef struct
{
    WORD     lopnStyle;
    POINTS   lopnWidth;
    COLORREF lopnColor;
} LOGPEN16;

typedef struct
{
    SHORT   bmType;
    SHORT   bmWidth;
    SHORT   bmHeight;
    SHORT   bmWidthBytes;
    BYTE    bmPlanes;
    BYTE    bmBitsPixel;
    LPBYTE  bmBits;
} BITMAP16;

typedef struct tagLOGFONT16
{
    SHORT     lfHeight;
    SHORT     lfWidth;
    SHORT     lfEscapement;
    SHORT     lfOrientation;
    SHORT     lfWeight;
    BYTE      lfItalic;
    BYTE      lfUnderline;
    BYTE      lfStrikeOut;
    BYTE      lfCharSet;
    BYTE      lfOutPrecision;
    BYTE      lfClipPrecision;
    BYTE      lfQuality;
    BYTE      lfPitchAndFamily;
    BYTE      lfFaceName[LF_FACESIZE];
} LOGFONT16;

#pragma pack(pop, GDIP_pack)

inline static const WmfComment UNALIGNED *
GetWmfComment(
    const WORD *        recordData,
    ULONG               signature,
    UINT                kind
    )
{
    // Assumes you've already checked that
    //     (wmfCommentRecord->rdFunction == META_ESCAPE &&
    //      wmfCommentRecord->rdParm[0] == MFCOMMENT)

    const WmfComment UNALIGNED * wmfComment = (const WmfComment UNALIGNED *)&(recordData[2]);
    if ((wmfComment->Signature == signature) && (wmfComment->Kind == kind))
    {
        return wmfComment;
    }
    return NULL;
}

inline static INT
GetDibByteWidth(
    INT     biWidth,
    INT     biPlanes,
    INT     biBitCount
    )
{
    return (((biWidth * biPlanes * biBitCount) + 31) & ~31) / 8;
}

inline static RGBQUAD UNALIGNED *
GetDibColorTable(
    BITMAPINFOHEADER UNALIGNED * dibInfo
    )
{
    return (RGBQUAD UNALIGNED *)(((BYTE *)dibInfo) + dibInfo->biSize);
}

static BYTE *
GetDibBits(
    BITMAPINFOHEADER UNALIGNED * dibInfo,
    UINT                         numPalEntries,
    UINT                         usage
    )
{
    ASSERT(dibInfo->biSize >= sizeof(BITMAPINFOHEADER));

    INT         colorSize = 0;

    if (numPalEntries > 0)
    {
        if ((usage == DIB_PAL_COLORS) &&
            (dibInfo->biCompression != BI_BITFIELDS) &&
            (dibInfo->biCompression != BI_CMYK))
        {
            // Make sure it is aligned
            colorSize = ((numPalEntries * sizeof(INT16)) + 3) & ~3;
        }
        else
        {
            colorSize = numPalEntries * sizeof(RGBQUAD);
        }
    }

    return ((BYTE *)GetDibColorTable(dibInfo)) + colorSize;
}

UINT
GetDibBitsSize(
    BITMAPINFOHEADER UNALIGNED *  dibInfo
    )
{
    // Check for PM-style DIB
    if (dibInfo->biSize >= sizeof(BITMAPINFOHEADER))
    {
        // not a core header

        if (dibInfo->biWidth > 0)   // can't handle negative width
        {
            if ((dibInfo->biCompression == BI_RGB) ||
                (dibInfo->biCompression == BI_BITFIELDS) ||
                (dibInfo->biCompression == BI_CMYK))
            {
                INT     posHeight = dibInfo->biHeight;

                if (posHeight < 0)
                {
                    posHeight = -posHeight;
                }
                return posHeight *
                       GetDibByteWidth(dibInfo->biWidth, dibInfo->biPlanes,
                                       dibInfo->biBitCount);
            }
            return dibInfo->biSizeImage;
        }
        WARNING(("0 or negative DIB width"));
        return 0;
    }
    else    // it is a PM-style DIB
    {
        BITMAPCOREHEADER UNALIGNED * coreDibInfo = (BITMAPCOREHEADER UNALIGNED *)dibInfo;

        // width and height must be > 0 for COREINFO dibs
        if ((coreDibInfo->bcWidth  > 0) &&
            (coreDibInfo->bcHeight > 0))
        {
            return coreDibInfo->bcHeight *
                   GetDibByteWidth(coreDibInfo->bcWidth,coreDibInfo->bcPlanes,
                                   coreDibInfo->bcBitCount);
        }
        WARNING(("0 or negative DIB width or height"));
        return 0;
    }
}

BOOL
GetDibNumPalEntries(
    BOOL        isWmfDib,
    UINT        biSize,
    UINT        biBitCount,
    UINT        biCompression,
    UINT        biClrUsed,
    UINT *      numPalEntries
    )
{
    UINT        maxPalEntries = 0;

    // Dibs in a WMF always have the bitfields for 16 and 32-bpp dibs.
    if (((biBitCount == 16) || (biBitCount == 32)) && isWmfDib)
    {
        biCompression = BI_BITFIELDS;
    }

    switch (biCompression)
    {
    case BI_BITFIELDS:
        //
        // Handle 16 and 32 bit per pel bitmaps.
        //

        switch (biBitCount)
        {
        case 16:
        case 32:
            break;
        default:
            WARNING(("BI_BITFIELDS not Valid for this biBitCount"));
            return FALSE;
        }

        if (biSize <= sizeof(BITMAPINFOHEADER))
        {
            biClrUsed = maxPalEntries = 3;
        }
        else
        {
            //
            // masks are part of BITMAPV4 and greater
            //

            biClrUsed = maxPalEntries = 0;
        }
        break;

    case BI_RGB:
        switch (biBitCount)
        {
        case 1:
        case 4:
        case 8:
            maxPalEntries = 1 << biBitCount;
            break;
        default:
            maxPalEntries = 0;

            switch (biBitCount)
            {
            case 16:
            case 24:
            case 32:
                break;
            default:
                WARNING(("Invalid biBitCount in BI_RGB"));
                return FALSE;
            }
        }
        break;

    case BI_CMYK:
        switch (biBitCount)
        {
        case 1:
        case 4:
        case 8:
            maxPalEntries = 1 << biBitCount;
            break;
        case 32:
            maxPalEntries = 0;
            break;
        default:
            WARNING(("Invalid biBitCount in BI_CMYK"));
            return FALSE;
        }
        break;

    case BI_RLE4:
    case BI_CMYKRLE4:
        if (biBitCount != 4)
        {
            WARNING(("Invalid biBitCount in BI_RLE4"));
            return FALSE;
        }

        maxPalEntries = 16;
        break;

    case BI_RLE8:
    case BI_CMYKRLE8:
        if (biBitCount != 8)
        {
            WARNING(("Invalid biBitCount in BI_RLE8"));
            return FALSE;
        }

        maxPalEntries = 256;
        break;

    case BI_JPEG:
    case BI_PNG:
        maxPalEntries = 0;
        break;

    default:
        WARNING(("Invalid biCompression"));
        return FALSE;
    }

    if (biClrUsed != 0)
    {
        if (biClrUsed <= maxPalEntries)
        {
            maxPalEntries = biClrUsed;
        }
    }

    *numPalEntries = maxPalEntries;
    return TRUE;
}

GdipHdcType
GetHdcType(
    HDC     hdc
    )
{
    GdipHdcType     hdcType = UnknownHdc;
    UINT            dcType  = GetDCType(hdc);

    switch (dcType)
    {
    case OBJ_DC:
        {
            INT technology = GetDeviceCaps(hdc, TECHNOLOGY);

            if (technology == DT_RASDISPLAY)
            {
                hdcType = ScreenHdc;
            }
            else if (technology == DT_RASPRINTER)
            {
                if (IsPostscriptPrinter(hdc))
                {
                    hdcType = PostscriptPrinterHdc;
                }
                else
                {
                    hdcType = PrinterHdc;
                }
            }
            else
            {
                WARNING(("Unknown HDC technology!"));
            }
        }
        break;

    case OBJ_MEMDC:
        hdcType = BitmapHdc;
        break;

    case OBJ_ENHMETADC:
        // When metafile spooling, the printer DC will be of type
        // OBJ_ENHMETADC on Win9x and NT4 (but not NT5 due to a fix
        // to NT bug 98810).  We need to do some more work to figure
        // out whether it's really a printer DC or a true metafile
        // DC:

        if (Globals::GdiIsMetaPrintDCFunction(hdc))
        {
            if (IsPostscriptPrinter(hdc))
            {
                hdcType = PostscriptPrinterHdc;
            }
            else
            {
                hdcType = PrinterHdc;
            }
        }
        else
        {
            hdcType = EmfHdc;
        }
        break;

    case OBJ_METADC:
        hdcType = WmfHdc;
        break;

    default:
        WARNING(("Unknown HDC type!"));
        break;
    }

    return hdcType;
}

DWORD
GetHdcBitmapBitsPixel(
    HDC hdc
    )
{
    // This function returns the number of bits per pixel for a bitmap DC.
    // On error, 0 is returned.

    ASSERT(GetDCType(hdc) == OBJ_MEMDC);

    HBITMAP hbm = (HBITMAP) GetCurrentObject(hdc, OBJ_BITMAP);

    if (hbm)
    {
        BITMAP bm;

        if (GetObjectA(hbm, sizeof(bm), &bm) >= sizeof(BITMAP))
        {
            return bm.bmBitsPixel;
        }
    }
    
    return 0;
}

MfEnumState::MfEnumState(
    HDC                 hdc,
    BOOL                externalEnumeration,
    InterpolationMode   interpolation,
    GpRecolor *         recolor,
    ColorAdjustType     adjustType,
    const RECT *        deviceRect,
    DpContext *         context
    )
{
    HdcType             = GetHdcType(hdc);
    Hdc                 = hdc;
    HandleTable         = NULL;
    NumObjects          = 0;
    CurrentPalette      = (HPALETTE)::GetStockObject(DEFAULT_PALETTE);
    SizeAllocedRecord   = 0;
    ModifiedRecordSize  = 0;
    SaveDcCount         = 0;
    BytesEnumerated     = 0;
    ExternalEnumeration = externalEnumeration;
    Recolor             = recolor;
    AdjustType          = adjustType;
    CurrentRecord       = NULL;
    ModifiedRecord      = NULL;
    AllocedRecord       = NULL;
    Interpolation       = interpolation;
    SaveDcVal           = SaveDC(hdc);
    FsmState            = MfFsmStart;
    GdiCentricMode      = FALSE;
    SoftekFilter        = FALSE;
    DefaultFont         = NULL;
    RopUsed             = FALSE;
    Context             = context;
    SrcCopyOnly         = FALSE;
    GpMemset(StockFonts, 0, sizeof(StockFonts[0]) * NUM_STOCK_FONTS);
    GpMemset(RecoloredStockHandle, 0, sizeof(HGDIOBJ) * NUM_STOCK_RECOLOR_OBJS);

    // See if we should halftone solid colors
    if ((IsScreen() && (::GetDeviceCaps(hdc, BITSPIXEL) == 8)) ||
        (IsBitmap() && (GetHdcBitmapBitsPixel(hdc) == 8)))
    {
        Is8Bpp = TRUE;
        EpPaletteMap    paletteMap(hdc);
        IsHalftonePalette = (paletteMap.IsValid() && (!paletteMap.IsVGAOnly()));
    }
    else
    {
        Is8Bpp = FALSE;
        IsHalftonePalette = FALSE;
    }

    // Since the transform can change as we are playing the metafile
    // convert the destrect into DeviceUnits. We will make sure to have an
    // identity matrix when we apply it.
    DestRectDevice = *deviceRect;
}

MfEnumState::~MfEnumState()
{
    // Delete all the true type fonts we created (first make sure they
    // are not selected into the Hdc.

    ::SelectObject(Hdc, GetStockObject(SYSTEM_FONT));

    if (DefaultFont)
    {
        DeleteObject(DefaultFont);
    }
    for (int i = 0; i < NUM_STOCK_FONTS; i++)
    {
        if (StockFonts[i] != NULL)
        {
            DeleteObject(StockFonts[i]);
        }
    }

    // Not necessary to delete NULL_BRUSH, NULL_PEN into HDC.  The subclasses
    // restore DC state which should dissolve any selections of these pen/brushes.
    for (int i = 0; i < NUM_STOCK_RECOLOR_OBJS; i++)
    {
        if (RecoloredStockHandle[i] != NULL)
        {
            DeleteObject(RecoloredStockHandle[i]);
        }
    }
}

WmfEnumState::WmfEnumState(
    HDC                 hdc,
    HMETAFILE           hWmf,
    BOOL                externalEnumeration,
    InterpolationMode   interpolation,
    const RECT *        dstRect,
    const RECT *        deviceRect,
    DpContext *         context,
    GpRecolor *         recolor,
    ColorAdjustType     adjustType
    )
    : MfEnumState(hdc, externalEnumeration, interpolation,
                  recolor, adjustType, deviceRect, context)
{
    if (IsValid())
    {
        IgnorePostscript = FALSE;
        BytesEnumerated  = sizeof(METAHEADER); // in WMF enumeration, we don't get header
        MetafileSize     = GetMetaFileBitsEx(hWmf, 0, NULL);
        FirstViewportExt = TRUE;
        FirstViewportOrg = TRUE;
        IsFirstRecord    = TRUE;

        // The bad thing about this is that if the metafile is being recolored,
        // the default pen, brush, text color, and background colors have NOT
        // been recolored.  So let's hope they're not really used.
        HpenSave   = (HPEN)  ::SelectObject(hdc, GetStockObject(BLACK_PEN));
        HbrushSave = (HBRUSH)::SelectObject(hdc, GetStockObject(WHITE_BRUSH));

        if (!Globals::IsNt)
        {
            HpaletteSave    = (HPALETTE)GetCurrentObject(hdc, OBJ_PAL);
            HfontSave       = (HFONT)   GetCurrentObject(hdc, OBJ_FONT);
            HbitmapSave     = (HBITMAP) GetCurrentObject(hdc, OBJ_BITMAP);
            HregionSave     = (HRGN)    GetCurrentObject(hdc, OBJ_REGION);
        }
        else
        {
            HpaletteSave    = NULL;
            HfontSave       = NULL;
            HbitmapSave     = NULL;
            HregionSave     = NULL;
        }

        // Make sure a few default values are set in the hdc
        ::SetTextAlign(hdc, 0);
        ::SetTextJustification(hdc, 0, 0);
        ::SetTextColor(hdc, RGB(0,0,0));
        TextColor = RGB(0,0,0);
        ::SetBkColor(hdc, RGB(255,255,255));
        BkColor = RGB(255,255,255);
        ::SetROP2(hdc, R2_COPYPEN);

        DstViewportOrg.x  = dstRect->left;
        DstViewportOrg.y  = dstRect->top;
        DstViewportExt.cx = dstRect->right - DstViewportOrg.x;
        DstViewportExt.cy = dstRect->bottom - DstViewportOrg.y;
    }
}

WmfEnumState::~WmfEnumState()
{
    // Turn POSTSCRIPT_IGNORE back off if we need to.
    if (IsPostscriptPrinter() && IgnorePostscript)
    {
        WORD    wOn = FALSE;
        ::Escape(Hdc, POSTSCRIPT_IGNORE, sizeof(wOn), (LPCSTR)&wOn, NULL);
    }

    // According to Office GEL, SaveDC/RestoreDC doesn't always restore
    // the brush and the pen correctly, so we have to do that ourselves.
    ::SelectObject(Hdc, HbrushSave);
    ::SelectObject(Hdc, HpenSave);

    GpFree(AllocedRecord);

    if (IsMetafile())
    {
        // Account for unbalanced SaveDC/RestoreDC pairs and
        // restore to the saveDC state
        ::RestoreDC(Hdc, SaveDcCount - 1);
    }
    else
    {
        ::RestoreDC(Hdc, SaveDcVal);
    }
}

VOID
WmfEnumState::EndRecord(
    )
{
    // We rely on the number of bytes enumerated to determine if
    // this is the last record of the WMF.
    if ((MetafileSize - BytesEnumerated) < SIZEOF_METARECORDHEADER)
    {
        if (!Globals::IsNt)
        {
            // GDI won't delete objects that are still selected, so
            // select out all WMF objects before proceeding.
            ::SelectObject(Hdc, HpenSave);
            ::SelectObject(Hdc, HbrushSave);
            ::SelectObject(Hdc, HpaletteSave);
            ::SelectObject(Hdc, HfontSave);
            ::SelectObject(Hdc, HbitmapSave);
            ::SelectObject(Hdc, HregionSave);

            INT     i;
            HANDLE  handle;

            if (HandleTable != NULL)
            {
                for (i = 0; i < NumObjects; i++)
                {
                    if ((handle = HandleTable->objectHandle[i]) != NULL)
                    {
                        ::DeleteObject(handle);
                        HandleTable->objectHandle[i] = NULL;
                    }
                }
            }
        }
    }
}

BOOL
WmfEnumState::PlayRecord(
    )
{
    const METARECORD *  recordToPlay = ModifiedWmfRecord;

    // See if we've modified the record
    if (recordToPlay == NULL)
    {
        // We haven't.  See if we have a valid current record
        if (CurrentWmfRecord != NULL)
        {
            recordToPlay = CurrentWmfRecord;
        }
        else
        {
            // we don't so we have to create one
            if (!CreateCopyOfCurrentRecord())
            {
                return FALSE;
            }
            recordToPlay = ModifiedWmfRecord;
        }
    }
    return PlayMetaFileRecord(Hdc, HandleTable, (METARECORD *)recordToPlay, NumObjects);
}

INT
MfEnumState::GetModifiedDibSize(
    BITMAPINFOHEADER UNALIGNED * dibInfo,
    UINT                         numPalEntries,
    UINT                         dibBitsSize,
    UINT &                       usage
    )
{
    ASSERT(dibInfo->biSize >= sizeof(BITMAPINFOHEADER));

    INT     byteWidth;
    INT     bitCount = dibInfo->biBitCount;

    if ((usage == DIB_PAL_COLORS) &&
        ((bitCount > 8) || (dibInfo->biCompression == BI_BITFIELDS)))
    {
        usage = DIB_RGB_COLORS;
    }

    if ((Recolor != NULL) || (usage == DIB_PAL_COLORS))
    {
        INT     biSize = dibInfo->biSize;

        if (bitCount > 8)
        {
            if ((dibInfo->biCompression != BI_RGB) &&
                (dibInfo->biCompression != BI_BITFIELDS))
            {
                return 0;    // don't handle compressed images
            }

            ASSERT((bitCount == 16) || (bitCount == 24) || (bitCount == 32));

            INT posHeight = dibInfo->biHeight;
            if (posHeight < 0)
            {
                posHeight = -posHeight;
            }

            // We have to recolor the object, so we will convert it to a
            // 24 bit image and send it down.
            // Even if we have less then 256 pixels, it's not worth palettizing
            // anymore because the palette will be the size of the image anyway
            // make sure that the bitmap is width is aligned
            // PERF: We could create a GpBitmap from the bitmap and recolor the
            // GpBitmap
            dibBitsSize = posHeight * (((dibInfo->biWidth * 3) + 3) & ~3);
            numPalEntries = 0;
            biSize = sizeof(BITMAPINFOHEADER);
        }
        else if ((numPalEntries == 0) ||
                 (dibInfo->biCompression == BI_CMYK) ||
                 (dibInfo->biCompression == BI_CMYKRLE4) ||
                 (dibInfo->biCompression == BI_CMYKRLE8))
        {
            return 0;    // don't handle CMYK images
        }
        usage = DIB_RGB_COLORS;
        return biSize + (numPalEntries * sizeof(RGBQUAD)) + dibBitsSize;
    }

    return 0;       // no modifications needed
}

inline static INT
GetMaskShift(
    INT     maskValue
    )
{
    ASSERT (maskValue != 0);

    INT     shift = 0;

    while (((maskValue & 1) == 0) && (shift < 24))
    {
        shift++;
        maskValue >>= 1;
    }
    return shift;
}

inline static INT
GetNumMaskBits(
    INT     maskValue
    )
{
    ASSERT ((maskValue & 1) != 0);

    INT     numBits = 0;

    while ((maskValue & 1) != 0)
    {
        numBits++;
        maskValue >>= 1;
    }
    return numBits;
}

VOID
MfEnumState::Modify16BppDib(
    INT               width,
    INT               posHeight,
    BYTE *            srcPixels,
    DWORD UNALIGNED * bitFields,
    BYTE *            dstPixels,
    ColorAdjustType   adjustType
    )
{
    INT     rMask       = 0x00007C00;   // same as GDI default
    INT     gMask       = 0x000003E0;
    INT     bMask       = 0x0000001F;
    INT     rMaskShift  = 10;
    INT     gMaskShift  = 5;
    INT     bMaskShift  = 0;
    INT     rNumBits    = 5;
    INT     gNumBits    = 5;
    INT     bNumBits    = 5;
    INT     rRightShift = 2;
    INT     gRightShift = 2;
    INT     bRightShift = 2;

    if (bitFields != NULL)
    {
        rMask       = (INT)((WORD)(*bitFields++));
        gMask       = (INT)((WORD)(*bitFields++));
        bMask       = (INT)((WORD)(*bitFields));
        rMaskShift  = GetMaskShift(rMask);
        gMaskShift  = GetMaskShift(gMask);
        bMaskShift  = GetMaskShift(bMask);
        rNumBits    = GetNumMaskBits(rMask >> rMaskShift);
        gNumBits    = GetNumMaskBits(gMask >> gMaskShift);
        bNumBits    = GetNumMaskBits(bMask >> bMaskShift);
        rRightShift = (rNumBits << 1) - 8;
        gRightShift = (gNumBits << 1) - 8;
        bRightShift = (bNumBits << 1) - 8;
    }

    INT         palIndex = 0;
    INT         pixel;
    INT         r, g, b;
    COLORREF    color;
    INT         w, h;
    INT         srcByteWidth = ((width * 2) + 3) & (~3);
    INT         dstByteWidth = ((width * 3) + 3) & (~3);

    for (h = 0; h < posHeight; h++)
    {
        for (w = 0; w < width; w++)
        {
            pixel = (INT)(((INT16 *)srcPixels)[w]);

            r = (pixel & rMask) >> rMaskShift;
            r = (r | (r << rNumBits)) >> rRightShift;

            g = (pixel & gMask) >> gMaskShift;
            g = (g | (g << gNumBits)) >> gRightShift;

            b = (pixel & bMask) >> bMaskShift;
            b = (b | (b << bNumBits)) >> bRightShift;

            color = ModifyColor(RGB(r, g, b), adjustType);

            dstPixels[3*w + 2] = GetRValue(color);
            dstPixels[3*w + 1] = GetGValue(color);
            dstPixels[3*w]     = GetBValue(color);
        }
        srcPixels += srcByteWidth;
        dstPixels += dstByteWidth;
    }
}

inline static INT
Get24BppColorIndex(
    INT     maskValue
    )
{
    switch(GetMaskShift(maskValue))
    {
    default:
        WARNING(("Invalid BitFields Mask"));
        // FALLTHRU

    case 0:
        return 0;
    case 8:
        return 1;
    case 16:
        return 2;
    }
}

VOID
MfEnumState::Modify24BppDib(
    INT               width,
    INT               posHeight,
    BYTE *            srcPixels,
    DWORD UNALIGNED * bitFields,
    BYTE *            dstPixels,
    ColorAdjustType   adjustType
    )
{
    INT     rIndex = 2;
    INT     gIndex = 1;
    INT     bIndex = 0;

    if (bitFields != NULL)
    {
        INT     rMask = (INT)((*bitFields++));
        INT     gMask = (INT)((*bitFields++));
        INT     bMask = (INT)((*bitFields));

        rIndex = Get24BppColorIndex(rMask);
        gIndex = Get24BppColorIndex(gMask);
        bIndex = Get24BppColorIndex(bMask);
    }

    INT         palIndex = 0;
    INT         r, g, b;
    COLORREF    color;
    INT         w, h;
    INT         srcByteWidth = ((width * 3) + 3) & (~3);
    INT         dstByteWidth = ((width * 3) + 3) & (~3);
    BYTE *      srcRaster = srcPixels;

    for (h = 0; h < posHeight; h++)
    {
        srcPixels = srcRaster;
        for (w = 0; w < width; w++)
        {
            r = srcPixels[rIndex];
            g = srcPixels[gIndex];
            b = srcPixels[bIndex];
            srcPixels += 3;

            color = ModifyColor(RGB(r, g, b), adjustType);

            dstPixels[3*w + 2] = GetRValue(color);
            dstPixels[3*w + 1] = GetGValue(color);
            dstPixels[3*w]     = GetBValue(color);
        }
        srcRaster += srcByteWidth;
        dstPixels += dstByteWidth;
    }
}

inline static INT
Get32BppColorIndex(
    INT     maskValue
    )
{
    switch(GetMaskShift(maskValue))
    {
    default:
        WARNING(("Invalid BitFields Mask"));
        // FALLTHRU

    case 0:
        return 0;
    case 8:
        return 1;
    case 16:
        return 2;
    case 24:
        return 3;
    }
}

VOID
MfEnumState::Modify32BppDib(
    INT               width,
    INT               posHeight,
    BYTE *            srcPixels,
    DWORD UNALIGNED * bitFields,
    BYTE *            dstPixels,
    ColorAdjustType   adjustType
    )
{
    INT     rIndex = 2;
    INT     gIndex = 1;
    INT     bIndex = 0;

    if (bitFields != NULL)
    {
        INT     rMask = (INT)((*bitFields++));
        INT     gMask = (INT)((*bitFields++));
        INT     bMask = (INT)((*bitFields));

        rIndex = Get32BppColorIndex(rMask);
        gIndex = Get32BppColorIndex(gMask);
        bIndex = Get32BppColorIndex(bMask);
    }

    INT         palIndex = 0;
    INT         r, g, b;
    COLORREF    color;
    INT         w, h;
    INT         dstByteWidth = ((width * 3) + 3) & (~3);

    for (h = 0; h < posHeight; h++)
    {
        for (w = 0; w < width; w++)
        {
            r = srcPixels[rIndex];
            g = srcPixels[gIndex];
            b = srcPixels[bIndex];
            srcPixels += 4;

            color = ModifyColor(RGB(r, g, b), adjustType);

            dstPixels[3*w + 2] = GetRValue(color);
            dstPixels[3*w + 1] = GetGValue(color);
            dstPixels[3*w]     = GetBValue(color);
        }
        dstPixels += dstByteWidth;
    }
}

VOID
MfEnumState::ModifyDib(
    UINT                          usage,
    BITMAPINFOHEADER UNALIGNED *  srcDibInfo,
    BYTE *                        srcBits,    // if NULL, it's a packed DIB
    BITMAPINFOHEADER UNALIGNED *  dstDibInfo,
    UINT                          numPalEntries,
    UINT                          srcDibBitsSize,
    ColorAdjustType               adjustType
    )
{
    INT      srcBitCount = srcDibInfo->biBitCount;
    BYTE *   srcPixels   = srcBits;
    COLORREF color;

    if (srcBitCount <= 8)
    {
        GpMemcpy(dstDibInfo, srcDibInfo, srcDibInfo->biSize);

        RGBQUAD UNALIGNED * srcRgb = GetDibColorTable(srcDibInfo);
        RGBQUAD UNALIGNED * dstRgb = GetDibColorTable(dstDibInfo);

        dstDibInfo->biClrUsed = numPalEntries;

        if ((usage == DIB_PAL_COLORS) &&
            (dstDibInfo->biCompression != BI_BITFIELDS))
        {
            WORD *      srcPal = (WORD *)srcRgb;

            if (srcPixels == NULL)
            {
                srcPixels = (BYTE *)(srcPal + ((numPalEntries + 1) & ~1)); // align
            }

            // Copy the Dib pixel data
            GpMemcpy(dstRgb + numPalEntries, srcPixels, srcDibBitsSize);

            // Modify the palette colors
            while (numPalEntries--)
            {
                color = ModifyColor(*srcPal++ | 0x01000000, adjustType);
                dstRgb->rgbRed      = GetRValue(color);
                dstRgb->rgbGreen    = GetGValue(color);
                dstRgb->rgbBlue     = GetBValue(color);
                dstRgb->rgbReserved = 0;
                dstRgb++;
            }
        }
        else
        {
            if (srcPixels == NULL)
            {
                srcPixels = (BYTE *)(srcRgb + numPalEntries);
            }

            // Copy the Dib pixel data
            GpMemcpy(dstRgb + numPalEntries, srcPixels, srcDibBitsSize);

            // Modify the palette colors
            while (numPalEntries--)
            {
                color = ModifyColor(RGB(srcRgb->rgbRed, srcRgb->rgbGreen, srcRgb->rgbBlue), adjustType);
                dstRgb->rgbRed      = GetRValue(color);
                dstRgb->rgbGreen    = GetGValue(color);
                dstRgb->rgbBlue     = GetBValue(color);
                dstRgb->rgbReserved = 0;
                dstRgb++;
                srcRgb++;
            }
        }
    }
    else    // Recolor the bitmap. There is no need to palettize the image since
            // the palette will be as big as the image
    {
        INT posHeight = srcDibInfo->biHeight;

        if (posHeight < 0)
        {
            posHeight = -posHeight;
        }

        ASSERT((srcDibInfo->biCompression == BI_RGB) ||
               (srcDibInfo->biCompression == BI_BITFIELDS));

        GpMemset(dstDibInfo, 0, sizeof(BITMAPINFOHEADER));

        dstDibInfo->biSize     = sizeof(BITMAPINFOHEADER);
        dstDibInfo->biWidth    = srcDibInfo->biWidth;
        dstDibInfo->biHeight   = srcDibInfo->biHeight;
        dstDibInfo->biPlanes   = 1;
        dstDibInfo->biBitCount = 24;

        BYTE *                dstPixels = GetDibBits(dstDibInfo,0,0);
        DWORD UNALIGNED *     bitFields = NULL;

        if (srcPixels == NULL)
        {
            srcPixels = (BYTE *)GetDibBits(srcDibInfo, numPalEntries, usage);
        }

        dstDibInfo->biClrUsed = 0;
        dstDibInfo->biClrImportant = 0;

        if (numPalEntries == 3)
        {
            ASSERT((srcBitCount == 16) || (srcBitCount == 32));
            bitFields = (DWORD*) GetDibColorTable(srcDibInfo);
            if ((bitFields[0] == 0) ||
                (bitFields[1] == 0) ||
                (bitFields[2] == 0))
            {
                bitFields = NULL;
            }
        }
        else if (srcDibInfo->biSize >= sizeof(BITMAPV4HEADER))
        {
            BITMAPV4HEADER *    srcHeaderV4 = (BITMAPV4HEADER *)srcDibInfo;

            if ((srcHeaderV4->bV4RedMask != 0) &&
                (srcHeaderV4->bV4GreenMask != 0) &&
                (srcHeaderV4->bV4BlueMask != 0))
            {
                bitFields = &(srcHeaderV4->bV4RedMask);
            }
        }

        switch (srcBitCount)
        {
        case 16:
            Modify16BppDib(srcDibInfo->biWidth, posHeight, srcPixels,
                           bitFields, dstPixels, adjustType);
            break;
        case 24:
            Modify24BppDib(srcDibInfo->biWidth, posHeight, srcPixels,
                           bitFields, dstPixels, adjustType);
            break;
        case 32:
            Modify32BppDib(srcDibInfo->biWidth, posHeight, srcPixels,
                           bitFields, dstPixels, adjustType);
            break;
        }
    }
}

VOID
WmfEnumState::DibCreatePatternBrush(
    )
{
    INT                           style      = (INT)((INT16)(((WORD *)RecordData)[0]));
    UINT                          usage      = (UINT)((UINT16)(((WORD *)RecordData)[1]));
    BITMAPINFOHEADER UNALIGNED *  srcDibInfo = (BITMAPINFOHEADER UNALIGNED *)(&(((WORD *)RecordData)[2]));
    UINT                          numPalEntries;

    // Pattern brush should mean that it is a monochrome DIB
    if (style == BS_PATTERN)
    {
        if (Recolor != NULL)
        {
            DWORD UNALIGNED *   rgb = (DWORD UNALIGNED *)GetDibColorTable(srcDibInfo);

            // See if it is a monochrome pattern brush.  If it is, then
            // the text color will be used for 0 bits and the background
            // color will be used for 1 bits.  These colors are already
            // modified by their respective records, so there is no need
            // to do anything here.

            // If it is not a monochrome pattern brush, just create a
            // solid black brush.
            if ((usage != DIB_RGB_COLORS) ||
                (srcDibInfo->biSize < sizeof(BITMAPINFOHEADER)) ||
                !GetDibNumPalEntries(TRUE,
                                     srcDibInfo->biSize,
                                     srcDibInfo->biBitCount,
                                     srcDibInfo->biCompression,
                                     srcDibInfo->biClrUsed,
                                     &numPalEntries) ||
                (numPalEntries != 2) ||
                (srcDibInfo->biBitCount != 1) || (srcDibInfo->biPlanes != 1) ||
                (rgb[0] != 0x00000000) || (rgb[1] != 0x00FFFFFF))
            {
                // This shouldn't happen, at least not if recorded on NT
                WARNING(("Non-monochrome pattern brush"));
                MakeSolidBlackBrush();
            }
        }
    }
    else
    {
        UINT    dibBitsSize;

        if ((srcDibInfo->biSize >= sizeof(BITMAPINFOHEADER)) &&
            GetDibNumPalEntries(TRUE,
                                srcDibInfo->biSize,
                                srcDibInfo->biBitCount,
                                srcDibInfo->biCompression,
                                srcDibInfo->biClrUsed,
                                &numPalEntries) &&
            ((dibBitsSize = GetDibBitsSize(srcDibInfo)) > 0))
        {
            UINT    oldUsage = usage;
            INT     dstDibSize = GetModifiedDibSize(srcDibInfo, numPalEntries, dibBitsSize, usage);

            if (dstDibSize > 0)
            {
                INT     size = SIZEOF_METARECORDHEADER + (2 * sizeof(WORD)) + dstDibSize;

                CreateRecordToModify(size);
                ModifiedWmfRecord->rdSize      = size / 2;
                ModifiedWmfRecord->rdFunction  = META_DIBCREATEPATTERNBRUSH;
                ModifiedWmfRecord->rdParm[0]   = BS_DIBPATTERN;
                ModifiedWmfRecord->rdParm[1]   = DIB_RGB_COLORS;
                ModifyDib(oldUsage, srcDibInfo, NULL,
                          (BITMAPINFOHEADER UNALIGNED *)(&(ModifiedWmfRecord->rdParm[2])),
                          numPalEntries, dibBitsSize, ColorAdjustTypeBrush);
            }
        }
    }

    this->PlayRecord();
}

// This record is obsolete, because it uses a compatible bitmap
// instead of a DIB.  It has a BITMAP16 structure that is
// used to call CreateBitmapIndirect.  That HBITMAP is, in turn,
// used to call CreatePatternBrush.  If this record is present,
// it is likely that the bitmap is monochrome, in which case
// the TextColor and the BkColor will be used, and these colors
// already get modified by their respective records.
VOID
WmfEnumState::CreatePatternBrush(
    )
{
    WARNING(("Obsolete META_CREATEPATTERNBRUSH record"));

    BITMAP16 UNALIGNED *  bitmap = (BITMAP16 UNALIGNED *)RecordData;

    if (bitmap->bmBitsPixel != 1)
    {
        WARNING(("Non-monochrome pattern brush"));
        MakeSolidBlackBrush();
    }

    this->PlayRecord();
}

VOID
WmfEnumState::CreatePenIndirect(
    )
{
    LOGPEN16 UNALIGNED * logPen = (LOGPEN16 UNALIGNED *)RecordData;

    switch (logPen->lopnStyle)
    {
    default:
        WARNING(("Unrecognized Pen Style"));
    case PS_NULL:
        break;      // leave the pen alone

    case PS_SOLID:
    case PS_INSIDEFRAME:
    case PS_DASH:
    case PS_DOT:
    case PS_DASHDOT:
    case PS_DASHDOTDOT:
        ModifyRecordColor(3, ColorAdjustTypePen);
        break;
    }

    this->PlayRecord();
}

VOID
WmfEnumState::CreateBrushIndirect(
    )
{
    LOGBRUSH16 UNALIGNED * logBrush = (LOGBRUSH16 UNALIGNED *)RecordData;

    switch (logBrush->lbStyle)
    {
    case BS_SOLID:
    case BS_HATCHED:
        {
            ModifyRecordColor(1, ColorAdjustTypeBrush);
            if (ModifiedWmfRecord != NULL)
            {
                logBrush = (LOGBRUSH16 UNALIGNED *)(ModifiedWmfRecord->rdParm);
            }
            // See if we need to halftone the color.  We do if it is a solid
            // color, and we have a halftone palette, and the color is not
            // an exact match in the palette.

            COLORREF    color;

            if (IsHalftonePalette && (logBrush->lbStyle == BS_SOLID) &&
                (((color = logBrush->lbColor) & 0x02000000) == 0))
            {
                // create a halftone brush, instead of a solid brush

                INT     size = SIZEOF_METARECORDHEADER + (2 * sizeof(WORD)) +
                               sizeof(BITMAPINFOHEADER) + // DIB 8 bpp header
                               (8 * sizeof(RGBQUAD)) +    // DIB 8 colors
                               (8 * 8);                   // DIB 8x8 pixels

                ModifiedRecordSize = 0; // in case we already modified the record
                CreateRecordToModify(size);
                ModifiedWmfRecord->rdSize      = size / 2;
                ModifiedWmfRecord->rdFunction  = META_DIBCREATEPATTERNBRUSH;
                ModifiedWmfRecord->rdParm[0]   = BS_DIBPATTERN;
                ModifiedWmfRecord->rdParm[1]   = DIB_RGB_COLORS;

                HalftoneColorRef_216(color, &(ModifiedWmfRecord->rdParm[2]));
            }
        }
        break;

    case BS_HOLLOW:
        break;  // leave the record alone

    default:
        // Looking at the NT source code, there shouldn't be any
        // other brush styles for an indirect brush.
        WARNING(("Brush Style Not Valid"));
        MakeSolidBlackBrush();
        break;
    }

    this->PlayRecord();
}

// Also handles StretchBlt.
// These records are obsolete (when there is a source bitmap) because they
// have a compatible bitmap instead of a DIB.  For that reason, we don't
// recolor them.
VOID
WmfEnumState::BitBlt(
    )
{
    DWORD   rop = *((UNALIGNED DWORD *)RecordData);

    // If No-Op ROP, do nothing; just return
    if ((rop & 0xFFFF0000) == (GDIP_NOOP_ROP3 & 0xFFFF0000))
    {
        return;
    }

    if (!IsMetafile())
    {
        if (IsSourceInRop3(rop))
        {
            WARNING(("Obsolete META_BITBLT/META_STRETCHBLT record"));

            if ((rop != SRCCOPY) && SrcCopyOnly &&
                CreateCopyOfCurrentRecord())
            {
                *((DWORD UNALIGNED *)ModifiedWmfRecord->rdParm) = SRCCOPY;
            }
        }
        else
        {
            if ((rop != PATCOPY) && SrcCopyOnly &&
                CreateCopyOfCurrentRecord())
            {
                *((DWORD UNALIGNED *)ModifiedWmfRecord->rdParm) = PATCOPY;
            }
        }
    }

    this->PlayRecord();
}

VOID
WmfEnumState::Escape(
    )
{
    INT     escapeCode = (INT)((INT16)(((WORD *)RecordData)[0]));

    if (!IsPostscript())
    {
        if (SkipEscape(escapeCode))
        {
            return;
        }

        // Skip Office Art data when playing into another metafile
        if (IsMetafile() &&
            IsOfficeArtData(GetCurrentRecordSize(), (WORD *)RecordData))
        {
            return;
        }
    }
    else // it is postscript
    {
        if (escapeCode == MFCOMMENT)
        {
            if (GetWmfComment((WORD *)RecordData, msosignature, msocommentBeginSrcCopy))
            {
                SrcCopyOnly = TRUE;
                return;
            }
            if (GetWmfComment((WORD *)RecordData, msosignature, msocommentEndSrcCopy))
            {
                SrcCopyOnly = FALSE;
                return;
            }
        }

        if (escapeCode == POSTSCRIPT_DATA)
        {
            // Bug #98743 (Windows Bugs) Gdiplus must overcome GDI limitation
            // with POSTSCRIPT_INJECTION.  Comments from Rammanohar Arumugam:
            //
            // Being in xx-centric mode means POSTSCRIPT_DATA won't work. I
            // take that to mean that PlayMetaFileRecord only works in
            // compatibility mode.
            //
            // GdiPlus will check for the printer mode. In GDI-centric and
            // Postscript-centric mode, it will not do PlayMetaFileRecord for
            // any record that has POSTSCRIPT_DATA. Instead, it will output
            // the postscript data through a PASSTHRU (for GDI-centric mode)
            // or a POSTSCRIPT_PASSTHRU (for Postscript-Centric mode).
            //
            // You can find out the mode by querying the escape support.
            // 1. Query for POSTSCRIPT_INJECTION support. If not supported,
            // it's compat mode. If supported, find out the mode by doing step 2/3
            // 2. Query for PASSTHROUGH support. If supported, it's GDI-centric.
            // 3. Query for POSTSCRIPT_PASSTHROUGH support. If supported, it's
            // PS-centric.

            if (Globals::IsNt)
            {
                if (!SoftekFilter)
                {
                    // Determine presence of Softek Filter EPS, if so, then
                    // we apply workaround patches.

                    WORD size = *((WORD*)RecordData);
                    LPSTR escape = (LPSTR)(&RecordData[6]);
                    const LPSTR softekString = "%MSEPS Preamble [Softek";

                    INT softekLen = strlen(softekString);

                    if (size >= softekLen)
                    {
                        SoftekFilter = !GpMemcmp(softekString, escape, softekLen);
                    }
                }

                DWORD EscapeValue = POSTSCRIPT_IDENTIFY;

                if (::ExtEscape(Hdc,
                              QUERYESCSUPPORT,
                              sizeof(DWORD),
                              (LPSTR)&EscapeValue,
                              0,
                              NULL) <= 0)
                {
                    // POSTSCRIPT_IDENTITY is not supported if the mode has
                    // been set because it can only be set once.

                    EscapeValue = POSTSCRIPT_PASSTHROUGH;
                    if (::ExtEscape(Hdc,
                                  QUERYESCSUPPORT,
                                  sizeof(DWORD),
                                  (LPSTR)&EscapeValue,
                                  0,
                                  NULL) <= 0)
                    {
                        // GDI-centric mode
                        if (CreateCopyOfCurrentRecord())
                        {
                            *((WORD *)ModifiedWmfRecord->rdParm) = PASSTHROUGH;
                        }
                        GdiCentricMode = TRUE;
                    }
                    else
                    {
                        // PS-centric mode
                        if (CreateCopyOfCurrentRecord())
                        {
                            *((WORD *)ModifiedWmfRecord->rdParm) = POSTSCRIPT_PASSTHROUGH;
                        }
                    }

                    this->PlayRecord();
                    return;
                }
                else
                {
                    // compatibility mode, uses POSTSCRIPT_DATA
                }
            }
            else
            {
                // Win98 doesn't distinguish between GDI & compatibility mode
                if (CreateCopyOfCurrentRecord())
                {
                    *((WORD *)ModifiedWmfRecord->rdParm) = PASSTHROUGH;
                }
            }
        }
    }

    // Keep track of the POSTSCRIPT_IGNORE state.  If it is still on at
    // the of the metafile, then turn it OFF
    if (escapeCode == POSTSCRIPT_IGNORE && IsPostscript())
    {
        IgnorePostscript = ((WORD *)RecordData)[2] ? TRUE : FALSE;
    }
    this->PlayRecord();
}

VOID
WmfEnumState::Rectangle(
    )
{
    if (FsmState == MfFsmSetROP)
    {
        // There is a bug using PlayMetaFileRecord on Win2K for this
        // type of escape, we must explicitly call ExtEscape.  See bug
        // #98743.

        WORD* rdParm = (WORD*)&(RecordData[0]);
        CHAR postscriptEscape[512];

        RECT rect;
        rect.left = (SHORT)rdParm[3];
        rect.top = (SHORT)rdParm[2];
        rect.right = (SHORT)rdParm[1];
        rect.bottom = (SHORT)rdParm[0];

        if (LPtoDP(Hdc, (POINT*)&rect, 2))
        {
            // Some injected postscript, strangely enough contains the equivalent
            // of a stroke which is erroroneously executed on the current path.  In
            // one case, bug #281856 it results in a border about the object.  To
            // get around this, we output a 'N' which is newpath operator if it's
            // defined (which should be always.)  This, incidently, is done when
            // calling GDI Rectangle() succeeds, it outputs "N x y w h B", so we
            // are doing the equivalent here.

            GpRect  clipRect;
            Context->VisibleClip.GetBounds(&clipRect);

            wsprintfA(&postscriptEscape[2],
                      "\r\n%d %d %d %d CB\r\n"
                      "%s"
                      "%d %d %d %d B\r\n",
                      clipRect.Width,
                      clipRect.Height,
                      clipRect.X,
                      clipRect.Y,
                      Globals::IsNt ? "newpath\r\n" : "",
                      rect.right - rect.left,
                      rect.bottom - rect.top,
                      rect.left,
                      rect.top);
            ASSERT(strlen(&postscriptEscape[2]) < 512);
            *(WORD*)(&postscriptEscape[0]) = (WORD)(strlen(&postscriptEscape[2]));

            ::ExtEscape(Hdc,
                        PASSTHROUGH,
                        *(WORD*)(&postscriptEscape[0]) + sizeof(WORD) + 1,
                        (CHAR*)&postscriptEscape[0],
                        0,
                        NULL);
            return;
        }
    }

    this->PlayRecord();
}

VOID
WmfEnumState::RestoreHdc(
    )
{
    INT     relativeCount = (INT)((INT16)(((WORD *)RecordData)[0]));

    if (SaveDcCount < 0)
    {
        if (relativeCount >= SaveDcCount)
        {
            if (relativeCount >= 0)
            {
                // Modify the record
                CreateCopyOfCurrentRecord();    // guaranteed to succeed
                relativeCount = -1;
                ModifiedWmfRecord->rdParm[0] = (INT16)(-1);
            }
        }
        else
        {
            // Modify the record
            CreateCopyOfCurrentRecord();    // guaranteed to succeed
            relativeCount = SaveDcCount;
            ModifiedWmfRecord->rdParm[0] = (INT16)(relativeCount);
        }

        SaveDcCount -= relativeCount;
        this->PlayRecord();
    }
    else
    {
        WARNING(("RestoreDC not matched to a SaveDC"));
    }
}

// The rop for this command is always SRCCOPY
VOID
WmfEnumState::SetDIBitsToDevice(
    )
{
    // !!!

    // Office doesn't do anything with this record.  For now, I don't think
    // I will either.  It's a tough one to deal with for a couple reasons:
    // 1st -    The xDest and yDest values are in world units, but the
    //          width and height values are in device units
    //          (unlike StretchDIBits).
    // 2nd -    The amount of bits data present may be different than
    //          what is in the DIB header (based on the cScanLines param).
    //          This makes it harder to deal with as a packed DIB.

    this->PlayRecord();
}

VOID
MfEnumState::SelectPalette(
    INT     objectIndex
    )
{
    // For EMF the check really should be > 0
    if ((objectIndex >= 0) && (objectIndex < NumObjects) && (HandleTable != NULL))
    {
        HGDIOBJ    hPal = HandleTable->objectHandle[objectIndex];
        if ((hPal != NULL) && (GetObjectTypeInternal(hPal) == OBJ_PAL))
        {
            CurrentPalette = (HPALETTE)hPal;
            return;
        }
    }
    WARNING(("SelectPalette Failure"));
}

inline static VOID
Point32FromPoint16(
    POINTL *    dstPoints,
    POINTS UNALIGNED * srcPoints,
    UINT        numPoints
    )
{
    for (UINT i = 0; i < numPoints; i++, dstPoints++, srcPoints++)
    {
        dstPoints->x = (INT)((INT16)(srcPoints->x));
        dstPoints->y = (INT)((INT16)(srcPoints->y));
    }
}

// Apparently there is a bug on Win9x with PolyPolygons, so we
// parse the record ourselves.
VOID
WmfEnumState::PolyPolygon(
    )
{
    UINT        numPolygons = ((WORD *)RecordData)[0];
    UINT        numPoints   = 0;
    UINT        i;

    for (i = 0; i < numPolygons; i++)
    {
        numPoints += ((LPWORD)&((WORD *)RecordData)[1])[i];
    }

    INT *       polyCounts;
    POINTL *    points;
    INT         size = (numPolygons * sizeof(INT)) +
                       (numPoints * sizeof(POINTL));

    if (CreateRecordToModify(size))
    {
        polyCounts = (INT *)ModifiedRecord;
        points = (POINTL *)(polyCounts + numPolygons);

        for (i = 0; i < numPolygons; i++)
        {
            polyCounts[i] = (INT)(UINT)((LPWORD)&((WORD *)RecordData)[1])[i];
        }
        Point32FromPoint16(points,
                           (POINTS UNALIGNED *)(((WORD *)RecordData) + numPolygons + 1),
                           numPoints);
        ::PolyPolygon(Hdc, (POINT *)points, polyCounts, numPolygons);
        return;
    }

    this->PlayRecord();
}

#ifdef NEED_TO_KNOW_IF_BITMAP
static INT
GetBppFromMemDC(
    HDC     hMemDC
    )
{
    HBITMAP     hBitmap = (HBITMAP)::GetCurrentObject(hMemDC, OBJ_BITMAP);
    BITMAP      bitmap;

    if ((hBitmap == NULL) ||
        (::GetObjectA(hBitmap, sizeof(bitmap), &bitmap) == 0))
    {
        WARNING(("Couldn't get Bitmap object"));
        return 0;   // error
    }

    if (bitmap.bmPlanes <= 0)
    {
        WARNING(("Bitmap with no planes"));
        bitmap.bmPlanes = 1;
    }

    INT     bpp = bitmap.bmPlanes * bitmap.bmBitsPixel;

    if (bpp > 32)
    {
        WARNING(("Bitmap with too many bits"));
        bpp = 32;
    }

    return bpp;
}
#endif

#define GDI_INTERPOLATION_MAX   (1 << 23)

VOID
MfEnumState::OutputDIB(
    HDC                          hdc,
    const RECTL *                bounds,
    INT                          dstX,
    INT                          dstY,
    INT                          dstWidth,
    INT                          dstHeight,
    INT                          srcX,
    INT                          srcY,
    INT                          srcWidth,
    INT                          srcHeight,
    BITMAPINFOHEADER UNALIGNED * dibInfo,
    BYTE *                       bits,   // if NULL, this is a packed DIB
    UINT                         usage,
    DWORD                        rop,
    BOOL                         isWmfDib
    )
{
    BITMAPINFO       dibHeaderBuffer[1]; // To be sure it's aligned for 64Bits

    BOOL             restoreColors = FALSE;
    COLORREF         oldBkColor;
    COLORREF         oldTextColor;

    ASSERT(dibInfo->biSize >= sizeof(BITMAPINFOHEADER));

    if (bits == NULL)
    {
        UINT        numPalEntries;

        if (GetDibNumPalEntries(isWmfDib,
                                dibInfo->biSize,
                                dibInfo->biBitCount,
                                dibInfo->biCompression,
                                dibInfo->biClrUsed,
                                &numPalEntries))
        {
            bits = GetDibBits(dibInfo, numPalEntries, usage);
        }
        else
        {
            WARNING(("GetDibNumPalEntries failure"));
            return;
        }
    }


    INT     posDstWidth = dstWidth;

    if (posDstWidth < 0)
    {
        posDstWidth = -posDstWidth;
    }

    INT     posDstHeight = dstHeight;

    if (posDstHeight < 0)
    {
        posDstHeight = -posDstHeight;
    }

    INT             stretchBltMode = HALFTONE;
    GpBitmap *      destBitmap     = NULL;
    POINT           destPoints[3];
    BitmapData      bmpData;
    BitmapData *    bmpDataPtr = NULL;
    HBITMAP         hBitmap = NULL;
    BYTE *          bmpBits = NULL;
    BITMAPINFO *    dibBmpInfo = NULL;
    BOOL            deleteDIBSection = FALSE;

    // Don't use GDI+ stretching for a mask
    // Make this the first thing so that we are sure that they are set
    if ((dibInfo->biBitCount == 1) && (rop != SRCCOPY))
    {
        oldBkColor = ::SetBkColor(hdc, BkColor);
        oldTextColor = ::SetTextColor(hdc, TextColor);
        restoreColors = TRUE;
        goto DoGdiStretch;
    }

    // On Win9x we need to create an play a comment record so that the transform
    // gets invalidated and recalculated
    if (!Globals::IsNt && !IsMetafile())
    {
        CreateAndPlayCommentRecord();
    }

    destPoints[0].x = dstX;
    destPoints[0].y = dstY;
    destPoints[1].x = dstX + posDstWidth;
    destPoints[1].y = dstY;
    destPoints[2].x = dstX;
    destPoints[2].y = dstY + posDstHeight;

    if (!::LPtoDP(hdc, destPoints, 3))
    {
        goto DoGdiStretch;
    }

    posDstWidth  = ::GetIntDistance(destPoints[0], destPoints[1]);
    posDstHeight = ::GetIntDistance(destPoints[0], destPoints[2]);

    if ((posDstWidth == 0) || (posDstHeight == 0))
    {
        return;
    }

    INT     posSrcWidth;
    INT     srcWidthSign;

    posSrcWidth  = srcWidth;
    srcWidthSign = 1;

    if (posSrcWidth < 0)
    {
        posSrcWidth  = -posSrcWidth;
        srcWidthSign = -1;
    }

    INT     posSrcHeight;
    INT     srcHeightSign;

    posSrcHeight  = srcHeight;
    srcHeightSign = 1;

    if (posSrcHeight < 0)
    {
        posSrcHeight  = -posSrcHeight;
        srcHeightSign = -1;
    }

    INT     posSrcDibWidth;

    posSrcDibWidth = dibInfo->biWidth;

    if (posSrcDibWidth <= 0)
    {
        WARNING(("Bad biWidth value"));
        return; // negative source dib width not allowed
    }

    INT     posSrcDibHeight;

    posSrcDibHeight = dibInfo->biHeight;

    if (posSrcDibHeight < 0)
    {
        posSrcDibHeight = -posSrcDibHeight;
    }

    // We can have a negative source Width or height
    // we need to verify that the two corners of the srcRect lie in the
    // bitmap bounds
    if (srcX < 0)
    {
        srcX = 0;
        WARNING(("srcX < 0"));
    }

    if (srcX > posSrcDibWidth)
    {
        WARNING(("Bad srcWidth or srcX value"));
        srcX = posSrcDibWidth;
    }

    if (srcY < 0)
    {
        srcY = 0;
        WARNING(("srcY < 0"));
    }

    if (srcY > posSrcDibHeight)
    {
        WARNING(("Bad srcWidth or srcX value"));
        srcY = posSrcDibHeight;
    }

    INT srcRight;
    srcRight     = srcX + srcWidth;
    if (srcRight < 0)
    {
        WARNING(("Bad srcWidth or srcX value"));
        srcWidth = -srcX;
    }

    if(srcRight > posSrcDibWidth)
    {
        WARNING(("Bad srcWidth or srcX value"));
        srcWidth = posSrcDibWidth - srcX;
    }

    INT srcBottom;
    srcBottom = srcY + srcHeight;
    if (srcBottom < 0)
    {
        WARNING(("Bad srcWidth or srcX value"));
        srcHeight = -srcY;
    }

    if (srcBottom > posSrcDibHeight)
    {
        WARNING(("Bad srcWidth or srcX value"));
        srcHeight = posSrcDibHeight - srcY;
    }
    // This also catches the case where
    // (posSrcDibWidth == 0) || (posSrcDibHeight == 0)
    if ((posSrcWidth <= 0) || (posSrcHeight <= 0))
    {
        return;
    }

    // If we are drawing into an 8Bpp surface and we have a different ROP then
    // srcCopy.
    if (Is8Bpp && rop != SRCCOPY)
    {
        BOOL         freeDibInfo    = FALSE;
        UINT         size;
        BITMAPINFO * alignedDibInfo = NULL;
        if (GetDibNumPalEntries(TRUE,
                                dibInfo->biSize,
                                dibInfo->biBitCount,
                                dibInfo->biCompression,
                                dibInfo->biClrUsed,
                                &size))
        {
            if (IsDwordAligned(dibInfo))
            {
                alignedDibInfo = (BITMAPINFO*) dibInfo;
            }
            else
            {
                // Mutliply the number of entries by the size of each entry
                size *= ((usage==DIB_RGB_COLORS)?sizeof(RGBQUAD):sizeof(WORD));
                // WMF's can't use System Palette
                alignedDibInfo = (BITMAPINFO*) GpMalloc(dibInfo->biSize + size);
                if (alignedDibInfo != NULL)
                {
                    memcpy((void*)&alignedDibInfo, dibInfo, dibInfo->biSize + size);
                    freeDibInfo = TRUE;
                }
            }
            if (alignedDibInfo != NULL)
            {
                if (GpBitmap::DrawAndHalftoneForStretchBlt(hdc, alignedDibInfo, bits, srcX, srcY,
                                                           posSrcWidth, posSrcHeight,
                                                           posDstWidth, posDstHeight,
                                                           &dibBmpInfo, &bmpBits, &hBitmap,
                                                           Interpolation) == Ok)
                {
                    deleteDIBSection = TRUE;
                    srcX = 0;
                    srcY = 0;
                    srcWidth = posDstWidth;
                    srcHeight = posDstHeight;
                    dibInfo = (BITMAPINFOHEADER*) dibBmpInfo;
                    bits = bmpBits;
                    if (freeDibInfo)
                    {
                        GpFree(alignedDibInfo);
                    }
                    goto DoGdiStretch;
                }
                if (freeDibInfo)
                {
                    GpFree(alignedDibInfo);
                }
            }
        }
    }

    // if not stretching, let GDI do the blt
    if ((posSrcWidth == posDstWidth) && (posSrcHeight == posDstHeight))
    {
        goto DoGdiStretch;
    }

    InterpolationMode interpolationMode;

    interpolationMode = Interpolation;

    // if not going to the screen or to a bitmap, use GDI to do the stretch
    // otherwise, use GDI+ to do the stretch (but let GDI do the blt)

    // if going to printer on Win98 and it is RLE8 compressed bitmap, then
    // always decode and blit from GDI+.  The reason is that print drivers
    // commonly don't support RLEx encoding and punt to GDI.  In this
    // context it creates a compatible printer dc and bitmap and then does a
    // StretchBlt, but it only does this at 1bpp, the result is black and white.

    if ((IsPrinter() && !Globals::IsNt &&
         dibInfo->biCompression == BI_RLE8) ||
        ((IsScreen() || IsBitmap()) &&
        (interpolationMode != InterpolationModeNearestNeighbor) &&
        (posSrcWidth > 1) && (posSrcHeight > 1) &&
        ((posDstWidth * posDstHeight) < GDI_INTERPOLATION_MAX)))
    {
        GpStatus status = GenericError;

        destBitmap = new GpBitmap(posDstWidth, posDstHeight, PIXFMT_24BPP_RGB);

        if (destBitmap != NULL)
        {
            if (destBitmap->IsValid())
            {
                BITMAPINFO * alignedDibInfo = NULL;
                UINT         size;
                BOOL         freeDibInfo = FALSE;
                if (GetDibNumPalEntries(TRUE,
                                        dibInfo->biSize,
                                        dibInfo->biBitCount,
                                        dibInfo->biCompression,
                                        dibInfo->biClrUsed,
                                        &size))
                {
                    if (IsDwordAligned(dibInfo))
                    {
                        alignedDibInfo = (BITMAPINFO*) dibInfo;
                    }
                    else
                    {
                        // Mutliply the number of entries by the size of each entry
                        size *= ((usage==DIB_RGB_COLORS)?sizeof(RGBQUAD):sizeof(WORD));
                        // WMF's can't use System Palette
                        alignedDibInfo = (BITMAPINFO*) GpMalloc(dibInfo->biSize + size);
                        if (alignedDibInfo != NULL)
                        {
                            memcpy((void*)&alignedDibInfo, dibInfo, dibInfo->biSize + size);
                            freeDibInfo = TRUE;
                        }
                    }
                    if (alignedDibInfo != NULL)
                    {
                        GpBitmap *  srcBitmap = new GpBitmap(alignedDibInfo,
                                                             bits, FALSE);
                        if (srcBitmap != NULL)
                        {
                            if (srcBitmap->IsValid())
                            {
                                GpGraphics *    destGraphics = destBitmap->GetGraphicsContext();

                                if (destGraphics != NULL)
                                {
                                    if (destGraphics->IsValid())
                                    {
                                        // we have to lock the graphics so the driver doesn't assert
                                        GpLock  lockGraphics(destGraphics->GetObjectLock());

                                        ASSERT(lockGraphics.IsValid());

                                        GpRectF     dstRect(0.0f, 0.0f, (REAL)posDstWidth, (REAL)posDstHeight);
                                        GpRectF     srcRect;

                                        // StretchDIBits takes a srcY parameter relative to the lower-left
                                        // (bottom) corner of the bitmap, not the top-left corner,
                                        // like DrawImage does
                                        srcRect.Y      = (REAL)(posSrcDibHeight - srcY - srcHeight);
                                        srcRect.X      = (REAL)srcX;

                                        // !!! We have to subtract one to keep the
                                        // filter from blending black into the image
                                        // on the right and bottom.
                                        srcRect.Width  = (REAL)(srcWidth - (srcWidthSign));
                                        srcRect.Height = (REAL)(srcHeight - (srcHeightSign));

                                        // don't do any blending as part of the stretch
                                        destGraphics->SetCompositingMode(CompositingModeSourceCopy);
                                        destGraphics->SetInterpolationMode(interpolationMode);

                                        // Set the image attributes to Wrap since we don't want to
                                        // use black pixels for the edges
                                        GpImageAttributes imgAttr;
                                        imgAttr.SetWrapMode(WrapModeTileFlipXY);

                                        // now draw the source into the dest bitmap
                                        status = destGraphics->DrawImage(srcBitmap,
                                                                         dstRect,
                                                                         srcRect,
                                                                         UnitPixel,
                                                                         &imgAttr);
                                    }
                                    else
                                    {
                                        WARNING(("destGraphics not valid"));
                                    }
                                    delete destGraphics;
                                }
                                else
                                {
                                    WARNING(("Could not construct destGraphics"));
                                }
                            }
                            else
                            {
                                WARNING(("srcGraphics not valid"));
                            }
                            srcBitmap->Dispose();   // doesn't delete the source data
                        }
                        else
                        {
                            WARNING(("Could not allocate a new BitmapInfoHeader"));
                        }
                        if (freeDibInfo)
                        {
                            GpFree(alignedDibInfo);
                        }
                    }
                    else
                    {
                        WARNING(("Could not construct srcGraphics"));
                    }
                }
                else
                {
                    WARNING(("Could not clone the bitmap header"));
                }

                if ((status == Ok) &&
                    (destBitmap->LockBits(NULL, IMGLOCK_READ, PIXFMT_24BPP_RGB,
                                          &bmpData) == Ok))
                {
                    ASSERT((bmpData.Stride & 3) == 0);

                    GpMemset(dibHeaderBuffer, 0, sizeof(BITMAPINFO));
                    bmpDataPtr = &bmpData;
                    bits       = (BYTE *)bmpData.Scan0;
                    srcX       = 0;
                    srcY       = 0;
                    srcWidth   = posDstWidth;
                    srcHeight  = posDstHeight;
                    usage      = DIB_RGB_COLORS;
                    dibInfo    = (BITMAPINFOHEADER *)dibHeaderBuffer;
                    dibInfo->biSize     = sizeof(BITMAPINFOHEADER);
                    dibInfo->biWidth    = posDstWidth;
                    dibInfo->biHeight   = -posDstHeight;
                    dibInfo->biPlanes   = 1;
                    dibInfo->biBitCount = 24;

                    // We don't want to set the StretchBltMode to COLORONCOLOR here
                    // because we might draw this into non 8Bpp surface and we still
                    // have to halftone in this case
                }
            }
            else
            {
                WARNING(("destBitmap not valid"));
            }
        }
        else
        {
            WARNING(("Could not construct destBitmap"));
        }
    }

DoGdiStretch:

    // Halftoning on NT4 with 8bpp does not work very well -- it gets
    // the wrong color hue.
    // We cannot halftone to metafile for that same reason
    if ((rop != SRCCOPY) ||
        (Is8Bpp && Globals::IsNt && (Globals::OsVer.dwMajorVersion <= 4)) ||
        IsMetafile())
    {
        // don't let halftoning mess up some kind of masking or other effect
        stretchBltMode = COLORONCOLOR;
    }
    ::SetStretchBltMode(hdc, stretchBltMode);

    // There is a bug in Win9x that some StretchDIBits calls don't work
    // so we need to create an actual StretchDIBits record to play.
    // Also, NT4 postscript printing can't handle anything but SRCCOPY,
    // so change any ROPs that are not source copy.
    BOOL processed = FALSE;
    if (!Globals::IsNt)
    {
        processed = CreateAndPlayOutputDIBRecord(hdc, bounds, dstX, dstY, dstWidth,
            dstHeight, srcX, srcY, srcWidth, srcHeight, dibInfo, bits, usage,
            rop);
    }
    else if (rop != SRCCOPY &&
             Globals::OsVer.dwMajorVersion <= 4 &&
             IsPostscript())
    {
        rop = SRCCOPY;
    }

    // In MSO, at this point they would check if this is NT running
    // on a non-true-color surface.  If so, they would set the
    // color adjustment gamma to be 20000.  The comment said that
    // this was needed for NT 3.5.  I'm assuming we don't need to
    // worry about that anymore.

    if (!processed)
    {
        ::StretchDIBits(hdc,
                        dstX, dstY, dstWidth, dstHeight,
                        srcX, srcY, srcWidth, srcHeight,
                        bits, (BITMAPINFO *)dibInfo, usage, rop);
    }

    if (destBitmap)
    {
        if (bmpDataPtr != NULL)
        {
            destBitmap->UnlockBits(bmpDataPtr);
        }
        destBitmap->Dispose();
    }
    if (restoreColors)
    {
        ::SetBkColor(hdc, oldBkColor);
        ::SetTextColor(hdc, oldTextColor);
    }
    if (deleteDIBSection)
    {
        // This will get rid of the Bitmap and it's bits
        ::DeleteObject(hBitmap);
        GpFree(dibBmpInfo);
    }
}

// Also handles META_DIBSTRETCHBLT
// There is not a usage parameter with these records -- the
// usage is always DIB_RGB_COLORS.
VOID
WmfEnumState::DIBBitBlt(
    )
{
    DWORD   rop = *((DWORD UNALIGNED *)RecordData);

    // If No-Op ROP, do nothing; just return
    if ((rop & 0xFFFF0000) == (GDIP_NOOP_ROP3 & 0xFFFF0000))
    {
        return;
    }

    if (rop != SRCCOPY &&
        rop != NOTSRCCOPY &&
        rop != PATCOPY &&
        rop != BLACKNESS &&
        rop != WHITENESS)
    {
        RopUsed = TRUE;
    }

    INT     paramIndex = 7;

    if (RecordType != WmfRecordTypeDIBBitBlt)
    {
        paramIndex = 9;      // META_DIBSTRETCHBLT
    }

    INT     dibIndex = paramIndex + 1;

    if (!IsSourceInRop3(rop))
    {
        if (((GetCurrentRecordSize() / 2) - 3) ==
            (GDIP_EMFPLUS_RECORD_TO_WMF(RecordType) >> 8))
        {
            paramIndex++;
        }

        INT dstX      = (INT)((INT16)((WORD *)RecordData)[paramIndex--]);
        INT dstY      = (INT)((INT16)((WORD *)RecordData)[paramIndex--]);
        INT dstWidth  = (INT)((INT16)((WORD *)RecordData)[paramIndex--]);
        INT dstHeight = (INT)((INT16)((WORD *)RecordData)[paramIndex]);


        // We know that this call will succeed because we have a 2K buffer
        // by default
        CreateRecordToModify(20);

        // For some strange reason we need to play the record on both
        // Win2K and Win9x. So create a WMF record for PatBlt and play it
        ModifiedWmfRecord->rdFunction = GDIP_EMFPLUS_RECORD_TO_WMF(WmfRecordTypePatBlt);
        ModifiedWmfRecord->rdSize     = 10;
        ModifiedWmfRecord->rdParm[5]  = (WORD) dstX;
        ModifiedWmfRecord->rdParm[4]  = (WORD) dstY;
        ModifiedWmfRecord->rdParm[3]  = (WORD) dstWidth;
        ModifiedWmfRecord->rdParm[2]  = (WORD) dstHeight;

        if (rop != PATCOPY && SrcCopyOnly)
        {
            *((DWORD*) ModifiedWmfRecord->rdParm) = PATCOPY;
        }
        else
        {
            *((DWORD*) ModifiedWmfRecord->rdParm) = rop;
        }

        // Now play the record (below)
    }
    else
    {
        BITMAPINFOHEADER UNALIGNED *  srcDibInfo = (BITMAPINFOHEADER UNALIGNED *)(((WORD *)RecordData) + dibIndex);
        UINT                          numPalEntries;
        UINT                          dibBitsSize;

        if ((srcDibInfo->biSize >= sizeof(BITMAPINFOHEADER)) &&
            GetDibNumPalEntries(TRUE,
                                srcDibInfo->biSize,
                                srcDibInfo->biBitCount,
                                srcDibInfo->biCompression,
                                srcDibInfo->biClrUsed,
                                &numPalEntries) &&
            ((dibBitsSize = GetDibBitsSize(srcDibInfo)) > 0))
        {
            if ((srcDibInfo->biBitCount == 1) && (srcDibInfo->biPlanes == 1))
            {
                DWORD UNALIGNED * rgb = (DWORD UNALIGNED *)GetDibColorTable(srcDibInfo);

                if ((rgb[0] == 0x00000000) &&
                    (rgb[1] == 0x00FFFFFF))
                {
                    if (SrcCopyOnly && (rop != SRCCOPY) && CreateCopyOfCurrentRecord())
                    {
                        *((DWORD UNALIGNED *)ModifiedWmfRecord->rdParm) = SRCCOPY;
                        goto PlayTheRecord;
                    }
                    else
                    {
                        // It is a compatible monochrome bitmap, which means it
                        // will use the TextColor and BkColor, so no recoloring
                        // is needed. Since we are not using SrcCopy that means
                        // that it's a mask
                        COLORREF oldBkColor = ::SetBkColor(Hdc, BkColor);
                        COLORREF oldTextColor = ::SetTextColor(Hdc, TextColor);
                        this->PlayRecord();
                        ::SetBkColor(Hdc, oldBkColor);
                        ::SetTextColor(Hdc, oldTextColor);
                        return;
                    }
                }
            }

            UINT    usage      = DIB_RGB_COLORS;
            INT     dstDibSize = GetModifiedDibSize(srcDibInfo, numPalEntries, dibBitsSize, usage);

            if (IsMetafile())
            {
                if (dstDibSize > 0)
                {
                    INT     size = SIZEOF_METARECORDHEADER + (dibIndex * sizeof(WORD)) + dstDibSize;

                    if (CreateRecordToModify(size))
                    {
                        ModifiedWmfRecord->rdFunction = GDIP_EMFPLUS_RECORD_TO_WMF(RecordType);
                        ModifiedWmfRecord->rdSize     = size / 2;
                        GpMemcpy(ModifiedWmfRecord->rdParm, RecordData, (dibIndex * sizeof(WORD)));
                        ModifyDib(DIB_RGB_COLORS, srcDibInfo, NULL,
                                  (BITMAPINFOHEADER UNALIGNED *)(ModifiedWmfRecord->rdParm + dibIndex),
                                  numPalEntries, dibBitsSize, ColorAdjustTypeBitmap);
                    }
                }
                goto PlayTheRecord;
            }
            // At this point, we are not going to play the record.  We're
            // going to call StretchDIBits.  One reason is because we want
            // to set the StretchBltMode, which is only used if a stretching
            // method is called.

            // Also, it avoids us doing an allocation/copy and then GDI doing
            // another allocation/copy (GDI has to do this to align the
            // DIB on a DWORD boundary).

            BITMAPINFOHEADER UNALIGNED * dstDibInfo = srcDibInfo;

            if (dstDibSize > 0)
            {
                if (CreateRecordToModify(dstDibSize))
                {
                    // ModifiedRecord is Aligned
                    dstDibInfo = (BITMAPINFOHEADER UNALIGNED *)ModifiedRecord;

                    ModifyDib(DIB_RGB_COLORS, srcDibInfo, NULL, dstDibInfo,
                              numPalEntries, dibBitsSize, ColorAdjustTypeBitmap);
                }
            }
            else if (!IsDwordAligned(dstDibInfo))
            {
                // The srcDibInfo may not aligned properly, so we make
                // a copy of it, so that it will be aligned.

                dstDibSize = GetCurrentRecordSize() - (SIZEOF_METARECORDHEADER + (dibIndex * sizeof(WORD)));
                if (CreateRecordToModify(dstDibSize))
                {
                    dstDibInfo = (BITMAPINFOHEADER *)ModifiedRecord;

                    GpMemcpy(dstDibInfo, srcDibInfo, dstDibSize);
                }
            }

            if (SrcCopyOnly)
            {
                rop = SRCCOPY;
            }

            INT srcX, srcY;
            INT dstX, dstY;
            INT srcWidth, srcHeight;
            INT dstWidth, dstHeight;

            dstX      = (INT)((INT16)((WORD *)RecordData)[paramIndex--]);
            dstY      = (INT)((INT16)((WORD *)RecordData)[paramIndex--]);
            dstWidth  = (INT)((INT16)((WORD *)RecordData)[paramIndex--]);
            dstHeight = (INT)((INT16)((WORD *)RecordData)[paramIndex--]);
            srcX      = (INT)((INT16)((WORD *)RecordData)[paramIndex--]);
            srcY      = (INT)((INT16)((WORD *)RecordData)[paramIndex--]);

            if (RecordType != WmfRecordTypeDIBBitBlt)
            {
                // META_DIBSTRETCHBLT
                srcWidth  = (INT)((INT16)((WORD *)RecordData)[paramIndex--]);
                srcHeight = (INT)((INT16)((WORD *)RecordData)[paramIndex--]);
            }
            else
            {
                srcWidth  = dstWidth;
                srcHeight = dstHeight;
            }

            // Need to flip the source y coordinate to call StretchDIBits.
            srcY = dstDibInfo->biHeight - srcY - srcHeight;

            OutputDIB(Hdc,
                      NULL,
                      dstX, dstY, dstWidth, dstHeight,
                      srcX, srcY, srcWidth, srcHeight,
                      dstDibInfo, NULL, DIB_RGB_COLORS, rop, TRUE);
            return;
        }
    }

PlayTheRecord:
    this->PlayRecord();
}

VOID
WmfEnumState::StretchDIBits(
    )
{
    DWORD   rop = *((DWORD UNALIGNED *)RecordData);

    // If No-Op ROP, do nothing; just return
    if ((rop & 0xFFFF0000) == (GDIP_NOOP_ROP3 & 0xFFFF0000))
    {
        return;
    }

    if (rop != SRCCOPY &&
        rop != NOTSRCCOPY &&
        rop != PATCOPY &&
        rop != BLACKNESS &&
        rop != WHITENESS)
    {
        RopUsed = TRUE;
    }

    if (IsSourceInRop3(rop))
    {
        if(((GetCurrentRecordSize() / 2) > (SIZEOF_METARECORDHEADER / sizeof(WORD)) + 11))
        {
            BITMAPINFOHEADER UNALIGNED *  srcDibInfo = (BITMAPINFOHEADER UNALIGNED *)(((WORD *)RecordData) + 11);
            UINT                          numPalEntries;
            UINT                          dibBitsSize;
    
            if ((srcDibInfo->biSize >= sizeof(BITMAPINFOHEADER)) &&
                GetDibNumPalEntries(TRUE,
                                    srcDibInfo->biSize,
                                    srcDibInfo->biBitCount,
                                    srcDibInfo->biCompression,
                                    srcDibInfo->biClrUsed,
                                    &numPalEntries) &&
                ((dibBitsSize = GetDibBitsSize(srcDibInfo)) > 0))
            {
                UINT                          usage      = ((WORD *)RecordData)[2];
                UINT                          oldUsage = usage;
                INT                           dstDibSize = GetModifiedDibSize(srcDibInfo, numPalEntries, dibBitsSize, usage);
                BITMAPINFOHEADER UNALIGNED *  dstDibInfo = srcDibInfo;
    
                if (dstDibSize > 0)
                {
                    if ((srcDibInfo->biBitCount == 1) && (srcDibInfo->biPlanes == 1))
                    {
                        DWORD UNALIGNED *     rgb = (DWORD UNALIGNED *)GetDibColorTable(srcDibInfo);
    
                        if ((rgb[0] == 0x00000000) &&
                            (rgb[1] == 0x00FFFFFF))
                        {
                            if (SrcCopyOnly && (rop != SRCCOPY) && CreateCopyOfCurrentRecord())
                            {
                                *((DWORD UNALIGNED *)ModifiedWmfRecord->rdParm) = SRCCOPY;
                                goto PlayTheRecord;
                            }
                            else
                            {
                                // It is a compatible monochrome bitmap, which means it
                                // will use the TextColor and BkColor, so no recoloring
                                // is needed. Since we are not using SrcCopy that means
                                // that it's a mask
                                COLORREF oldBkColor = ::SetBkColor(Hdc, BkColor);
                                COLORREF oldTextColor = ::SetTextColor(Hdc, TextColor);
                                this->PlayRecord();
                                ::SetBkColor(Hdc, oldBkColor);
                                ::SetTextColor(Hdc, oldTextColor);
                                return;
                            }
                        }
                    }
    
    
                    INT     size = SIZEOF_METARECORDHEADER + (11 * sizeof(WORD)) + dstDibSize;
    
                    if (CreateRecordToModify(size))
                    {
                        ModifiedWmfRecord->rdFunction = GDIP_EMFPLUS_RECORD_TO_WMF(RecordType);
                        ModifiedWmfRecord->rdSize     = size / 2;
                        GpMemcpy(ModifiedWmfRecord->rdParm, RecordData, (11 * sizeof(WORD)));
                        // This will be aligned.... Do we want to take a chance?
                        dstDibInfo = (BITMAPINFOHEADER UNALIGNED *)(ModifiedWmfRecord->rdParm + 11);
                        ModifyDib(oldUsage, srcDibInfo, NULL, dstDibInfo,
                                  numPalEntries, dibBitsSize, ColorAdjustTypeBitmap);
                    }
                }
    
                if (!IsMetafile())
                {
                    if ((dstDibInfo == srcDibInfo) && (!IsDwordAligned(dstDibInfo)))
                    {
                        // The srcDibInfo may not aligned properly, so we make
                        // a copy of it, so that it will be aligned.
    
                        dstDibSize = GetCurrentRecordSize() - (SIZEOF_METARECORDHEADER + (11 * sizeof(WORD)));
                        if (CreateRecordToModify(dstDibSize))
                        {
                            dstDibInfo = (BITMAPINFOHEADER UNALIGNED *)ModifiedRecord;
    
                            GpMemcpy(dstDibInfo, srcDibInfo, dstDibSize);
                        }
                    }
    
                    if (SrcCopyOnly)
                    {
                        rop = SRCCOPY;
                    }
    
                    INT dstX      = (INT)((INT16)((WORD *)RecordData)[10]);
                    INT dstY      = (INT)((INT16)((WORD *)RecordData)[9]);
                    INT dstWidth  = (INT)((INT16)((WORD *)RecordData)[8]);
                    INT dstHeight = (INT)((INT16)((WORD *)RecordData)[7]);
                    INT srcX      = (INT)((INT16)((WORD *)RecordData)[6]);
                    INT srcY      = (INT)((INT16)((WORD *)RecordData)[5]);
                    INT srcWidth  = (INT)((INT16)((WORD *)RecordData)[4]);
                    INT srcHeight = (INT)((INT16)((WORD *)RecordData)[3]);
    
                    OutputDIB(Hdc,
                              NULL,
                              dstX, dstY, dstWidth, dstHeight,
                              srcX, srcY, srcWidth, srcHeight,
                              dstDibInfo, NULL, usage, rop, TRUE);
                    return;
                }
            }
        }
    }
    else // !IsSourceRop3
    {
        if (rop != PATCOPY && SrcCopyOnly && CreateCopyOfCurrentRecord())
        {
            *((DWORD UNALIGNED *)ModifiedWmfRecord->rdParm) = PATCOPY;
        }
    }
PlayTheRecord:
    this->PlayRecord();
}

BOOL
WmfEnumState::CreateAndPlayOutputDIBRecord(
    HDC                           hdc,
    const RECTL *                 bounds,
    INT                           dstX,
    INT                           dstY,
    INT                           dstWidth,
    INT                           dstHeight,
    INT                           srcX,
    INT                           srcY,
    INT                           srcWidth,
    INT                           srcHeight,
    BITMAPINFOHEADER UNALIGNED *  dibInfo,
    BYTE *                        bits,   // if NULL, this is a packed DIB
    UINT                          usage,
    DWORD                         rop
    )
{
    INT  bitsSize = GetDibBitsSize(dibInfo);
    UINT sizePalEntries;

    if (GetDibNumPalEntries(TRUE,
                            dibInfo->biSize,
                            dibInfo->biBitCount,
                            dibInfo->biCompression,
                            dibInfo->biClrUsed,
                            &sizePalEntries))
    {
        // We need to get the palette size that corresponds to the type
        // If we have a DIB_PAL_COLORS then each entry is 16bits
        sizePalEntries *= ((usage == DIB_PAL_COLORS)?2:sizeof(RGBQUAD));
    }
    else
    {
        sizePalEntries = 0 ;
    }

    // We need at least a BITMAPINFO structure in there, but if there is a
    // palette, calculate the full size of the structure including the
    // palette

    INT bitmapHeaderSize = sizeof(BITMAPINFOHEADER) + sizePalEntries;
    INT size = SIZEOF_METARECORDHEADER + (11 * sizeof(WORD)) + bitmapHeaderSize + bitsSize ;

    // We cannot use the CreateRecordToModify because the record has already
    // been modified
    size = (size + 1) & ~1;
    METARECORD* metaRecord = (METARECORD*) GpMalloc(size);
    if (metaRecord != NULL)
    {
        metaRecord->rdFunction = GDIP_EMFPLUS_RECORD_TO_WMF(WmfRecordTypeStretchDIB);
        metaRecord->rdSize     = size / 2;
        metaRecord->rdParm[10] = (WORD) dstX;
        metaRecord->rdParm[9]  = (WORD) dstY;
        metaRecord->rdParm[8]  = (WORD) dstWidth;
        metaRecord->rdParm[7]  = (WORD) dstHeight;
        metaRecord->rdParm[6]  = (WORD) srcX;
        metaRecord->rdParm[5]  = (WORD) srcY;
        metaRecord->rdParm[4]  = (WORD) srcWidth;
        metaRecord->rdParm[3]  = (WORD) srcHeight;
        metaRecord->rdParm[2]  = (WORD) usage;
        *(DWORD UNALIGNED *)(&(metaRecord->rdParm[0])) = rop;

        GpMemcpy((BYTE*)(&(metaRecord->rdParm[11])), dibInfo, bitmapHeaderSize);
        GpMemcpy((BYTE*)(&(metaRecord->rdParm[11])) + bitmapHeaderSize, bits, bitsSize);

        ::PlayMetaFileRecord(hdc, HandleTable, metaRecord, NumObjects);
        GpFree(metaRecord);
        return TRUE;
    }
    return FALSE;
}

VOID
WmfEnumState::ModifyRecordColor(
    INT             paramIndex,
    ColorAdjustType adjustType
    )
{
    COLORREF    origColor = *((COLORREF UNALIGNED *)&(((WORD *)RecordData)[paramIndex]));
    COLORREF    modifiedColor = ModifyColor(origColor, adjustType);

    if (modifiedColor != origColor)
    {
        if (CreateCopyOfCurrentRecord())
        {
            *((COLORREF UNALIGNED *)&(ModifiedWmfRecord->rdParm[paramIndex])) = modifiedColor;
        }
    }
}

COLORREF
MfEnumState::ModifyColor(
    COLORREF        color,
    ColorAdjustType adjustType
    )
{
    if (AdjustType != ColorAdjustTypeDefault)
    {
        adjustType = AdjustType;
    }

    switch (color & 0xFF000000)
    {
    case 0x00000000:
        break;

    case 0x01000000:    // Palette Index
        {
            PALETTEENTRY    palEntry;

            if (::GetPaletteEntries(CurrentPalette, color & 0x000000FF, 1, &palEntry) == 1)
            {
                color = RGB(palEntry.peRed, palEntry.peGreen, palEntry.peBlue);
            }
            else
            {
                color = RGB(0, 0, 0);
                WARNING(("Failed to get palette entry"));
            }
        }
        break;

    case 0x02000000:    // Palette RGB
    default:
        color &= 0x00FFFFFF;
        break;
    }
    // Possible perfomance improvement: recolor the SelectedPalette so only
    // RGB values need to be recolored here.
    if (Recolor != NULL)
    {
        Recolor->ColorAdjustCOLORREF(&color, adjustType);
    }

    // Palette RGB values don't get dithered (at least not on NT), so we
    // only want to make it a PaletteRGB value if it is a solid color in
    // the palette.

    if (Is8Bpp)
    {
        COLORREF    matchingColor;

        matchingColor = (::GetNearestColor(Hdc, color | 0x02000000) & 0x00FFFFFF);

        // Pens and Text don't get Dithered so match them to the logical palette
        // the other adjustTypes do so they will get halftoned
        if ((matchingColor == color) ||
            (adjustType == ColorAdjustTypePen) ||
            (adjustType == ColorAdjustTypeText))
        {
            return color | 0x02000000;
        }
    }

    return color;
}

BOOL
MfEnumState::CreateRecordToModify(
    INT         size
    )
{
    if (size <= 0)
    {
        size = this->GetCurrentRecordSize();
    }

    // add a little padding to help insure we don't read past the end of the buffer
    size += 16;

    if (ModifiedRecordSize < size)
    {
        ASSERT(ModifiedRecordSize == 0);

        if (size <= GDIP_RECORDBUFFER_SIZE)
        {
            ModifiedRecord = RecordBuffer;
        }
        else if (size <= SizeAllocedRecord)
        {
            ModifiedRecord = AllocedRecord;
        }
        else
        {
            VOID *          newRecord;
            INT             allocSize;

            // alloc in increments of 1K
            allocSize = (size + 1023) & (~1023);

            ModifiedRecord = NULL;
            newRecord = GpRealloc(AllocedRecord, allocSize);
            if (newRecord != NULL)
            {
                ModifiedRecord    = newRecord;
                AllocedRecord     = newRecord;
                SizeAllocedRecord = allocSize;
            }
        }
    }
    else
    {
        ASSERT(ModifiedRecord != NULL);
        ASSERT(ModifiedRecordSize == size);
    }

    if (ModifiedRecord != NULL)
    {
        ModifiedRecordSize = size;
        return TRUE;
    }

    WARNING(("Failed to create ModifiedRecord"));
    return FALSE;
}

BOOL
WmfEnumState::CreateCopyOfCurrentRecord()
{
    if (ModifiedRecordSize > 0)
    {
        // We already made a modified record.  Don't do it again.
        ASSERT(ModifiedRecord != NULL);
        return TRUE;
    }

    INT     size = this->GetCurrentRecordSize();

    if (CreateRecordToModify(size))
    {
        METARECORD *    modifiedRecord = (METARECORD *)ModifiedRecord;

        modifiedRecord->rdFunction = GDIP_EMFPLUS_RECORD_TO_WMF(RecordType);
        modifiedRecord->rdSize     = size / 2;

        if (RecordDataSize > 0)
        {
            GpMemcpy(modifiedRecord->rdParm, RecordData, RecordDataSize);
        }
        return TRUE;
    }

    WARNING(("Failed to create copy of current record"));
    return FALSE;
}

VOID
WmfEnumState::MakeSolidBlackBrush()
{
    INT     size = SIZEOF_METARECORDHEADER + sizeof(LOGBRUSH16);

    CreateRecordToModify(size);
    ModifiedWmfRecord->rdSize = size / 2;
    ModifiedWmfRecord->rdFunction = META_CREATEBRUSHINDIRECT;

    LOGBRUSH16 *    logBrush = (LOGBRUSH16 *)(ModifiedWmfRecord->rdParm);

    logBrush->lbStyle = BS_SOLID;
    logBrush->lbColor = PALETTERGB(0,0,0);
    logBrush->lbHatch = 0;
}

VOID
WmfEnumState::CalculateViewportMatrix()
{
    GpRectF destViewport((REAL)DstViewportOrg.x, (REAL)DstViewportOrg.y,
                         (REAL)DstViewportExt.cx, (REAL)DstViewportExt.cy);
    GpRectF srcViewport((REAL)ImgViewportOrg.x, (REAL)ImgViewportOrg.y,
                        (REAL)ImgViewportExt.cx, (REAL)ImgViewportExt.cy);

    Status status = ViewportXForm.InferAffineMatrix(destViewport, srcViewport);
    if (status != Ok)
    {
        ViewportXForm.Reset();
    }
}

VOID
WmfEnumState::SetViewportOrg()
{
    // If this is the first SetViewportOrg then we need to save that value and
    // calculate a transform from out viewport to this viewport
    ImgViewportOrg.x = (INT)((INT16)((WORD *)RecordData)[1]);
    ImgViewportOrg.y = (INT)((INT16)((WORD *)RecordData)[0]);
    if (FirstViewportOrg || FirstViewportExt)
    {
        FirstViewportOrg = FALSE;
        // If we have processed the first ViewportExt call then we can calculate
        // the transform from our current viewport to the new viewport
        if (!FirstViewportExt)
        {
            CalculateViewportMatrix();
        }
    }
    else
    {
        // We need to keep the new Viewport origin to be able to calculate
        // the viewport bottom right corner before passing it through a
        // transform
        GpPointF newOrg((REAL) ImgViewportOrg.x,
                        (REAL) ImgViewportOrg.y);
        // Transform the new viewport with our viewport transformation
        ViewportXForm.Transform(&newOrg);
        DstViewportOrg.x = GpRound(newOrg.X);
        DstViewportOrg.y = GpRound(newOrg.Y);
        if(CreateRecordToModify())
        {
            ModifiedWmfRecord->rdFunction = CurrentWmfRecord->rdFunction;
            ModifiedWmfRecord->rdSize     = CurrentWmfRecord->rdSize;
            ModifiedWmfRecord->rdParm[0]  = (WORD)GpRound(newOrg.Y);
            ModifiedWmfRecord->rdParm[1]  = (WORD)GpRound(newOrg.X);
        }

        this->PlayRecord();
    }

}

VOID
WmfEnumState::SetViewportExt()
{
    // If this is the first SetViewportOrg then we need to save that value and
    // calculate a transform from out viewport to this viewport
    ImgViewportExt.cx = (INT)((INT16)((WORD *)RecordData)[1]);
    ImgViewportExt.cy = (INT)((INT16)((WORD *)RecordData)[0]);
    if (FirstViewportOrg || FirstViewportExt)
    {
        FirstViewportExt = FALSE;
        // If we have processed the first ViewportExt call then we can calculate
        // the transform from our current viewport to the new viewport
        if (!FirstViewportOrg)
        {
            CalculateViewportMatrix();
        }
    }
    else
    {
        // We need to transform the point, so add the current origin
        // of the Viewport
        GpPointF newExt((REAL) ImgViewportExt.cx,
                        (REAL) ImgViewportExt.cy);

        // Transform the new viewport with our viewport transformation
        ViewportXForm.VectorTransform(&newExt);
        if(CreateRecordToModify())
        {
            ModifiedWmfRecord->rdFunction = CurrentWmfRecord->rdFunction;
            ModifiedWmfRecord->rdSize     = CurrentWmfRecord->rdSize;
            ModifiedWmfRecord->rdParm[0]  = (WORD)GpRound(newExt.Y);
            ModifiedWmfRecord->rdParm[1]  = (WORD)GpRound(newExt.X);
        }

        this->PlayRecord();
    }
}

VOID
WmfEnumState::CreateRegion()
{
    // Check if the region it too big when mapped to device space.

    if (!Globals::IsNt)
    {

        // There is a bug in Win9x GDI where the code which plays METACREATEREGION doesn't copy the
        // entire region data, it is off by 8 bytes.  This seems to have been introduced to allow
        // for compatibility with an older header format, WIN2OBJECT.  We get around this by increasing
        // the size of the record by 8 bytes.  No other harm done.

        if (CreateCopyOfCurrentRecord())
        {
            // When we create a copy of the record, we add 16 bytes of padding so we know this
            // won't overflow into other memory.
            ModifiedWmfRecord->rdSize += 4;
        }
    }

    this->PlayRecord();
}

HFONT CreateTrueTypeFont(
    HFONT   hFont
    );

VOID
WmfEnumState::CreateFontIndirect(
    )
{
    LOGFONT16 *     logFont = (LOGFONT16 *)RecordData;
    BOOL            recordCopied = FALSE;

    if (!Globals::IsNt)
    {
        // We have a bug in Win9x that the OUT_TT_ONLY_PRECIS flag is
        // not always respected so if the font name is MS SANS SERIF
        // change it to Times New Roman
        // Since we don't have a string compare in ASCII do it in UNICODE
        WCHAR faceName[32];
        if (AnsiToUnicodeStr((char*)(logFont->lfFaceName), faceName, sizeof(faceName)/sizeof(WCHAR)) &&
            (UnicodeStringCompareCI(faceName, L"MS SANS SERIF") == 0))
        {
            if (CreateCopyOfCurrentRecord())
            {
                GpMemcpy(((LOGFONT16 *)(ModifiedWmfRecord->rdParm))->lfFaceName,
                         "Times New Roman", sizeof("Times New Roman"));
                recordCopied = TRUE;
            }
        }
    }
    if (logFont->lfOutPrecision != OUT_TT_ONLY_PRECIS)
    {
        // Instruct GDI to use only True Type fonts, since bitmap fonts
        // are not scalable.
        if (recordCopied || CreateCopyOfCurrentRecord())
        {
            ((LOGFONT16 *)(ModifiedWmfRecord->rdParm))->lfOutPrecision = OUT_TT_ONLY_PRECIS;
        }
    }
    this->PlayRecord();
}

VOID WmfEnumState::SelectObject()
{
    this->PlayRecord();

    // In case we selected a region on Win9x, we need to intersect
    if (!Globals::IsNt)
    {
        DWORD index = CurrentWmfRecord->rdParm[0];
        if (GetObjectTypeInternal((*HandleTable).objectHandle[index]) == OBJ_REGION)
        {
            this->IntersectDestRect();
        }
    }
}

VOID WmfEnumState::IntersectDestRect()
{
    if (!IsMetafile())
    {
        POINT windowOrg;
        SIZE  windowExt;
        ::SetWindowOrgEx(Hdc, DstViewportOrg.x, DstViewportOrg.y, &windowOrg);
        ::SetWindowExtEx(Hdc, DstViewportExt.cx, DstViewportExt.cy, &windowExt);

        // We are always in device units
        ::IntersectClipRect(Hdc, DestRectDevice.left, DestRectDevice.top,
                            DestRectDevice.right, DestRectDevice.bottom);

        ::SetWindowOrgEx(Hdc, windowOrg.x, windowOrg.y, NULL);
        ::SetWindowExtEx(Hdc, windowExt.cx, windowExt.cy, NULL);
    }
}

VOID WmfEnumState::SetROP2()
{
    INT rop = (INT)((INT16)(((WORD *)RecordData)[0]));

    if (rop != R2_BLACK &&
        rop != R2_COPYPEN &&
        rop != R2_NOTCOPYPEN &&
        rop != R2_WHITE )
    {
        RopUsed = TRUE;
    }
    this->PlayRecord();
}

BOOL
WmfEnumState::ProcessRecord(
    EmfPlusRecordType       recordType,
    UINT                    recordDataSize,
    const BYTE *            recordData
    )
{
    BOOL        forceCallback = FALSE;

    MfFsmState  nextState = MfFsmStart;

    if (IsFirstRecord)
    {
        // Bitmap fonts are not good for playing metafiles because they
        // don't scale well, so use a true type font instead as the default font.

        HFONT hFont = CreateTrueTypeFont((HFONT)GetCurrentObject(Hdc, OBJ_FONT));

        if (hFont != NULL)
        {
            DefaultFont = hFont;
            ::SelectObject(Hdc, hFont);
        }

        IsFirstRecord = FALSE;
    }

    // See if we're doing enumeration for an external app
    if (ExternalEnumeration)
    {
        if (recordData == NULL)
        {
            recordDataSize = 0;
        }
        else if (recordDataSize == 0)
        {
            recordData = NULL;
        }

        // make sure it's an EMF enum type
        recordType = GDIP_WMF_RECORD_TO_EMFPLUS(recordType);

        // See if the app changed the record at all.
        if ((recordType != RecordType) ||
            (recordDataSize != RecordDataSize) ||
            ((recordDataSize > 0) &&
             ((CurrentWmfRecord == NULL) ||
              (recordData != (const BYTE *)CurrentWmfRecord->rdParm))))
        {
            // Yes, we need to override what happened in StartRecord
            CurrentWmfRecord  = NULL;
            RecordType        = recordType;
            RecordData        = recordData;
            RecordDataSize    = recordDataSize;
        }
    }

    // Ignore all non-escape records if IgnorePostcript is TRUE
    if (recordType == WmfRecordTypeEscape || !IgnorePostscript)
    {
        GDIP_TRY

        switch (recordType)
        {
        // According to NT playback code, this is a EOF record, but it
        // is just skipped by the NT player.
        case GDIP_WMF_RECORD_TO_EMFPLUS(0x0000):  // End of metafile record
            break;

        // These records are not played back (at least in Win2000).
        // Apparently they haven't been supported since before Win3.1!
        case WmfRecordTypeSetRelAbs:
        case WmfRecordTypeDrawText:
        case WmfRecordTypeResetDC:
        case WmfRecordTypeStartDoc:
        case WmfRecordTypeStartPage:
        case WmfRecordTypeEndPage:
        case WmfRecordTypeAbortDoc:
        case WmfRecordTypeEndDoc:
        case WmfRecordTypeCreateBrush:
        case WmfRecordTypeCreateBitmapIndirect:
        case WmfRecordTypeCreateBitmap:
            ONCE(WARNING1("Unsupported WMF record"));
            break;

        default:
            // unknown record -- ignore it
            WARNING1("Unknown WMF Record");
            break;

        case WmfRecordTypeSetBkMode:
        case WmfRecordTypeSetMapMode:
        case WmfRecordTypeSetPolyFillMode:
        case WmfRecordTypeSetStretchBltMode:
        case WmfRecordTypeSetTextCharExtra:
        case WmfRecordTypeSetTextJustification:
        case WmfRecordTypeSetWindowOrg:
        case WmfRecordTypeSetWindowExt:
        case WmfRecordTypeOffsetWindowOrg:
        case WmfRecordTypeScaleWindowExt:
        case WmfRecordTypeOffsetViewportOrg:
        case WmfRecordTypeScaleViewportExt:
        case WmfRecordTypeLineTo:
        case WmfRecordTypeMoveTo:
        case WmfRecordTypeExcludeClipRect:
        case WmfRecordTypeIntersectClipRect:
        case WmfRecordTypeArc:
        case WmfRecordTypeEllipse:
        case WmfRecordTypePie:
        case WmfRecordTypeRoundRect:
        case WmfRecordTypePatBlt:
        case WmfRecordTypeTextOut:
        case WmfRecordTypePolygon:
        case WmfRecordTypePolyline:
        case WmfRecordTypeFillRegion:
        case WmfRecordTypeFrameRegion:
        case WmfRecordTypeInvertRegion:
        case WmfRecordTypePaintRegion:
        case WmfRecordTypeSetTextAlign:
        case WmfRecordTypeChord:
        case WmfRecordTypeSetMapperFlags:
        case WmfRecordTypeExtTextOut:
        case WmfRecordTypeAnimatePalette:
        case WmfRecordTypeSetPalEntries:
        case WmfRecordTypeResizePalette:
        case WmfRecordTypeSetLayout:
        case WmfRecordTypeDeleteObject:
        case WmfRecordTypeCreatePalette:
            // Play the current record.
            // Even if it fails, we keep playing the rest of the metafile.
            // There is a case that GdiComment with EPS may fail.
            this->PlayRecord();
            break;

        case WmfRecordTypeCreateRegion:
            this->CreateRegion();
            break;

        case WmfRecordTypeCreateFontIndirect:
            this->CreateFontIndirect();
            break;

        case WmfRecordTypeSetBkColor:
            this->SetBkColor();
            break;

        case WmfRecordTypeSetTextColor:
            this->SetTextColor();
            break;

        case WmfRecordTypeFloodFill:
            this->FloodFill();
            break;

        case WmfRecordTypeExtFloodFill:
            this->ExtFloodFill();
            break;

        case WmfRecordTypeSaveDC:
            this->SaveHdc();        // plays the record
            break;

        case WmfRecordTypeSetPixel:
            this->SetPixel();
            break;

        case WmfRecordTypeDIBCreatePatternBrush:
            this->DibCreatePatternBrush();
            break;

        case WmfRecordTypeCreatePatternBrush:   // Obsolete but still played back
            this->CreatePatternBrush();
            break;

        case WmfRecordTypeCreatePenIndirect:
            this->CreatePenIndirect();
            if (FsmState == MfFsmSelectBrush)
            {
                nextState = MfFsmCreatePenIndirect;
            }
            break;

        case WmfRecordTypeCreateBrushIndirect:
            this->CreateBrushIndirect();
            if (FsmState == MfFsmPSData)
            {
                nextState = MfFsmCreateBrushIndirect;
            }
            break;

        case WmfRecordTypeSelectObject:
            // What if we break out of the FSM, we do want to Create the appropriate
            // brush and pens right?!
            if (FsmState == MfFsmCreateBrushIndirect)
            {
                nextState = MfFsmSelectBrush;
                break;
            }
            else if (FsmState == MfFsmSelectBrush ||
                     FsmState == MfFsmCreatePenIndirect)
            {
                nextState = MfFsmSelectPen;
                break;
            }
            this->SelectObject();
            break;

        case WmfRecordTypeRectangle:
            this->Rectangle();
            break;

        case WmfRecordTypeSetROP2:
            {
                INT rdParm = (INT)((INT16)(((WORD *)RecordData)[0]));

                if (FsmState == MfFsmSelectPen &&
                    (INT)(rdParm == R2_NOP))
                {
                    nextState = MfFsmSetROP;
                }
                this->SetROP2();
            }
            break;

        case WmfRecordTypeBitBlt:       // Obsolete but still played back
            this->BitBlt();
            forceCallback = TRUE;
            break;

        case WmfRecordTypeStretchBlt:   // Obsolete but still played back
            this->StretchBlt();
            forceCallback = TRUE;
            break;

        case WmfRecordTypeEscape:
            {
                INT     escapeCode = (INT)((INT16)(((WORD *)RecordData)[0]));

                this->Escape();         // optionally plays the record

                if (FsmState == MfFsmStart && escapeCode == POSTSCRIPT_DATA &&
                    Globals::IsNt && IsPostscriptPrinter() &&
                    GdiCentricMode && SoftekFilter)
                {
                    nextState = MfFsmPSData;
                }

                // Comments do not change the current state
                if (escapeCode == MFCOMMENT)
                {
                    nextState = FsmState;
                }
            }
            break;

        case WmfRecordTypeRestoreDC:
            this->RestoreHdc();     // optionally plays the record
            break;

        case WmfRecordTypeSetDIBToDev:
            this->SetDIBitsToDevice();
            forceCallback = TRUE;
            break;

        case WmfRecordTypeSelectPalette:
            // We don't select in any palettes when playing the metafile,
            // because we don't want to invalidate our halftoning palette.
            // Keep track of the palette so we can map from PALETTEINDEXes
            // to RGB values.
            this->SelectPalette((INT)((INT16)(((WORD *)recordData)[0])));
            break;

        case WmfRecordTypeRealizePalette:
            // We don't want to invalidate our halftoning palette by realizing one
            // from a metafile.
            break;

        case WmfRecordTypePolyPolygon:
            this->PolyPolygon();
            break;

        case WmfRecordTypeDIBBitBlt:
            this->DIBBitBlt();
            forceCallback = TRUE;
            break;

        case WmfRecordTypeDIBStretchBlt:
            this->DIBStretchBlt();
            forceCallback = TRUE;
            break;

        case WmfRecordTypeStretchDIB:
            this->StretchDIBits();
            forceCallback = TRUE;
            break;

        case WmfRecordTypeSetViewportOrg:
            this->SetViewportOrg();
            break;

        case WmfRecordTypeSetViewportExt:
            this->SetViewportExt();
            break;

        case WmfRecordTypeSelectClipRegion:
        case WmfRecordTypeOffsetClipRgn:
            this->PlayRecord();
            if (!Globals::IsNt)
            {
                this->IntersectDestRect();
            }
            break;
        }

        GDIP_CATCH
            forceCallback = TRUE;
        GDIP_ENDCATCH

    }
    FsmState = nextState;
    this->EndRecord();

    return forceCallback;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\metawmf.hpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   MetaWmf.hpp
*
* Abstract:
*
*   Metafile definitions for WMF and EMF playback
*
* Created:
*
*   1/6/2000 DCurtis
*
\**************************************************************************/

#ifndef _METAWMF_HPP
#define _METAWMF_HPP

//#define GDIP_EXCEPTIONS 0
#define GDIP_TRY        __try {
#define GDIP_CATCH      } __except(EXCEPTION_EXECUTE_HANDLER) {
#define GDIP_ENDCATCH   }

#define GDIP_RECORDBUFFER_SIZE      2048    // >= 1138 so pattern brushes work

#define SIZEOF_METARECORDHEADER     (sizeof(DWORD) + sizeof(WORD))

#define NUM_STOCK_FONTS             (DEFAULT_GUI_FONT - OEM_FIXED_FONT + 1)

#define NUM_STOCK_RECOLOR_OBJS      7

/*****************************************************************************
    Commenting.

    These interfaces allow comments to be added to a metafile DC which describe
    grouping and other information useful for decoding metafiles, the
    interfaces which take an MSODC have no effect if the DC is not a picture
    (PICT, WMF or EMF) DC.

    For PICT files there are two levels of structure, the public comment
    "kind" which is a globally defined comment and the "private" comment kind,
    which is used for application-specific comments.  In a PICT the public
    comment kind is the kind argument to PicComment and the private kind is
    used if the public value is pictApplicationComment.

    In a WMF the signature indicates whether the comment is public or private,
    all comments look like the PICT private comment.

    In an EMF GdiComment() defines some "public" comments plus a format for
    "private" comments - see the Win32 API documentation.
******************************************************************* JohnBo **/

// Definition of the comment codes used in the various metafile formats.
const ULONG msosignaturePublic =0xFFFFFFFF; // WMF public signature.
const ULONG msosignaturePPOld  =0x5050FE54; // PowerPoint 2 signature
const ULONG msosignaturePP     =0x50504E54; // PowerPoint signature
const ULONG msosignature       =0x50504E54; // Office/Escher signature

// The following enumeration defines the ukind values in the above structure,
// note that these duplicate the PICT comment kinds for groups because in
// a WMF (but *NOT* a PICT or EMF) and MSOMFCOMMENT structure must be used,
// this enumeration contains all the valid kinds, including both the public
// and private kinds, these may overlap because they are distinguished by
// the "signature".
typedef enum
{
    // Public WMF comments - signature == msosignaturePublic.
    msocommentBeginGroup         = 0x0000,  // Public WMF begin group.
    msocommentEndGroup           = 0x0001,  // Public WMF end group.
    msocommentBeginHeader        = 0x0002,
    msocommentEndHeader          = 0x0003,
    msocommentCreator            = 0x0004,
    msocommentWinVersion         = 0x0005,

    // Private PICT and WMF comments - signature == msosignature.
    msocommentVersion            = 0x0000,
    msocommentBFileBlock         = 0x0001,  // UNUSED
    msocommentBeginPicture       = 0x0002,
    msocommentEndPicture         = 0x0003,
    msocommentDevInfo            = 0x0004,
    msocommentBeginHyperOpaque   = 0x0005,  // UNUSED
    msocommentEndHyperOpaque     = 0x0006,  // UNUSED
    msocommentBeginFade          = 0x0007,
    msocommentEndFade            = 0x0008,
    msocommentDitherDetect       = 0x0009,  // Not used now?

    // New values used in Office97.
    msocommentPictureDescription = 0x0101, // Description text.
    msocommentBeginGelEffect     = 0x0102,
    msocommentEndGelEffect       = 0x0103,
    msocommentBeginClipPath      = 0x0104,
    msocommentEndClipPath        = 0x0105,
    msocommentBeginSrcCopy       = 0x0106,
    msocommentEndSrcCopy         = 0x0107,

    // Reserved comments used internally by Mac PP4.
    msocommentPictUnmute         = 0x7FFE,
    msocommentPictMute           = 0x7FFF,

    // The following is a flag - what is it for?
    msocommentRegistered         = 0x8000
} MSOMFCOMMENTKIND;



typedef struct
{
    UINT Handle;
    COLORREF Color;
    BOOL Brush;
}
RecolorStockObject;

extern RecolorStockObject RecolorStockObjectList[NUM_STOCK_RECOLOR_OBJS];

enum GdipHdcType
{
    UnknownHdc           = 0x00000000,
    ScreenHdc            = 0x00000001,
    BitmapHdc            = 0x00000002,
    MetafileHdc          = 0x00000004,
    PrinterHdc           = 0x00000008,
    PostscriptHdc        = 0x00010000,
    PostscriptPrinterHdc = PrinterHdc | PostscriptHdc,
    EmfHdc               = 0x00100000 | MetafileHdc,
    WmfHdc               = 0x00200000 | MetafileHdc,
};

enum MfFsmState
{
    MfFsmStart,
    MfFsmPSData,
    MfFsmCreateBrushIndirect,
    MfFsmSelectBrush,
    MfFsmCreatePenIndirect,
    MfFsmSelectPen,
    MfFsmSetROP,
};

class MfEnumState
{
protected:
    GdipHdcType                 HdcType;
    HDC                         Hdc;
    INT                         SaveDcVal;
    INT                         SaveDcCount;
    INT                         NumObjects;     // num objects in handle table
    INT                         SizeAllocedRecord;
    INT                         ModifiedRecordSize;
    INT                         BytesEnumerated;
    BOOL                        ExternalEnumeration;
    HPALETTE                    CurrentPalette;
    HFONT                       DefaultFont;
    HFONT                       StockFonts[NUM_STOCK_FONTS];
    HANDLETABLE *               HandleTable;
    GpRecolor *                 Recolor;
    ColorAdjustType             AdjustType;
    const BYTE *                RecordData;
    UINT                        RecordDataSize;
    EmfPlusRecordType           RecordType;
    InterpolationMode           Interpolation;
    BOOL                        Is8Bpp;
    BOOL                        IsHalftonePalette;
    COLORREF                    BkColor;
    COLORREF                    TextColor;
    RECT                        DestRectDevice;
    BOOL                        RopUsed;
    DpContext *                 Context;
    union
    {
        const VOID *            CurrentRecord;
        const METARECORD *      CurrentWmfRecord;
        const ENHMETARECORD *   CurrentEmfRecord;
    };
    union
    {
        VOID *                  ModifiedRecord;
        METARECORD *            ModifiedWmfRecord;
        ENHMETARECORD *         ModifiedEmfRecord;
    };
    union
    {
        VOID *                  AllocedRecord;
        METARECORD *            AllocedWmfRecord;
        ENHMETARECORD *         AllocedEmfRecord;
    };
    BYTE                        RecordBuffer[GDIP_RECORDBUFFER_SIZE];
    MfFsmState                  FsmState;
    BOOL                        GdiCentricMode;
    BOOL                        SoftekFilter;
    HGDIOBJ                     RecoloredStockHandle[NUM_STOCK_RECOLOR_OBJS];
    BOOL                        SrcCopyOnly;

public:
    MfEnumState(
        HDC                 hdc,
        BOOL                externalEnumeration,
        InterpolationMode   interpolation,
        GpRecolor *         recolor,
        ColorAdjustType     adjustType,
        const RECT *        dest,
        DpContext *         context
        );
    ~MfEnumState();

    BOOL IsValid()      { return (SaveDcVal != 0); }
    BOOL IsMetafile()   { return ((HdcType & MetafileHdc) == MetafileHdc); }
    BOOL IsPostscript() { return ((HdcType & PostscriptHdc) == PostscriptHdc); }
    BOOL IsPrinter()    { return ((HdcType & PrinterHdc) == PrinterHdc);}
    BOOL IsPostscriptPrinter(){ return ((HdcType & PostscriptPrinterHdc) == PostscriptPrinterHdc);}
    BOOL IsBitmap()     { return ((HdcType & BitmapHdc) == BitmapHdc); }
    BOOL IsScreen()     { return ((HdcType & ScreenHdc) == ScreenHdc); }
    BOOL GetRopUsed()   { return RopUsed; }
    VOID ResetRopUsed() { RopUsed = FALSE; }

    VOID
    StartRecord(
        HDC                     hdc,
        HANDLETABLE *           handleTable,
        INT                     numObjects,
        const VOID *            currentRecord,
        EmfPlusRecordType       recordType,
        UINT                    recordDataSize,
        const BYTE *            recordData
        )
    {
        ASSERT(hdc != NULL);

        Hdc                = hdc;
        ModifiedRecord     = NULL;
        ModifiedRecordSize = 0;
        CurrentRecord      = currentRecord;
        RecordType         = recordType;
        RecordDataSize     = recordDataSize;
        RecordData         = recordData;
        BytesEnumerated   += GetCurrentRecordSize();

        if ((handleTable != NULL) && (numObjects > 0))
        {
            HandleTable    = handleTable;
            NumObjects     = numObjects;
        }
        else
        {
            WARNING(("NULL handle table and/or no objects"));
            HandleTable    = NULL;
            NumObjects     = 0;
        }
    }

    virtual BOOL
    ProcessRecord(
        EmfPlusRecordType       recordType,
        UINT                    recordDataSize,
        const BYTE *            recordData
        ) = 0;

    virtual BOOL PlayRecord() = 0;

    VOID SaveHdc()
    {
        SaveDcCount--;
        this->PlayRecord();
    }

    virtual VOID RestoreHdc() = 0;
    VOID SelectPalette(INT objectIndex);

protected:
    virtual INT GetCurrentRecordSize() const = 0;
    BOOL CreateRecordToModify(INT size = 0);
    COLORREF ModifyColor(
        COLORREF        color,
        ColorAdjustType adjustType
        );
    INT
    GetModifiedDibSize(
        BITMAPINFOHEADER UNALIGNED *  dibInfo,
        UINT                          numPalEntries,
        UINT                          dibBitsSize,
        UINT &                        usage
        );
    VOID
    ModifyDib(
        UINT                          usage,
        BITMAPINFOHEADER  UNALIGNED * srcDibInfo,
        BYTE *                        srcBits,
        BITMAPINFOHEADER UNALIGNED *  dstDibInfo,
        UINT                          numPalEntries,
        UINT                          srcDibBitsSize,
        ColorAdjustType               adjustType
        );
    VOID
    Modify16BppDib(
        INT               width,
        INT               posHeight,
        BYTE *            srcPixels,
        DWORD UNALIGNED * bitFields,
        BYTE *            dstPixels,
        ColorAdjustType   adjustType
        );
    VOID
    Modify24BppDib(
        INT               width,
        INT               posHeight,
        BYTE *            srcPixels,
        DWORD UNALIGNED * bitFields,
        BYTE *            dstPixels,
        ColorAdjustType   adjustType
        );
    VOID
    Modify32BppDib(
        INT               width,
        INT               posHeight,
        BYTE *            srcPixels,
        DWORD UNALIGNED * bitFields,
        BYTE *            dstPixels,
        ColorAdjustType   adjustType
        );
    VOID
    OutputDIB(
        HDC                 hdc,
        const RECTL *       bounds,
        INT                 dstX,
        INT                 dstY,
        INT                 dstWidth,
        INT                 dstHeight,
        INT                 srcX,
        INT                 srcY,
        INT                 srcWidth,
        INT                 srcHeight,
        BITMAPINFOHEADER UNALIGNED * dibInfo,
        BYTE *              bits,   // if NULL, this is a packed DIB
        UINT                usage,
        DWORD               rop,
        BOOL                isWmfDib
        );
    virtual BOOL CreateAndPlayOutputDIBRecord(
        HDC                           hdc,
        const RECTL *                 bounds,
        INT                           dstX,
        INT                           dstY,
        INT                           dstWidth,
        INT                           dstHeight,
        INT                           srcX,
        INT                           srcY,
        INT                           srcWidth,
        INT                           srcHeight,
        BITMAPINFOHEADER UNALIGNED *  dibInfo,
        BYTE *                        bits,   // if NULL, this is a packed DIB
        UINT                          usage,
        DWORD                         rop
        )=0;

    virtual BOOL CreateAndPlayCommentRecord()
    {
        return TRUE;
    }

    virtual VOID IntersectDestRect()=0;
};

class WmfEnumState : public MfEnumState
{
public:
    BOOL            IgnorePostscript;

protected:
    INT             MetafileSize;
    HPEN            HpenSave;
    HBRUSH          HbrushSave;
    HPALETTE        HpaletteSave;
    HFONT           HfontSave;
    HBITMAP         HbitmapSave;
    HRGN            HregionSave;
    BOOL            FirstViewportOrg;
    BOOL            FirstViewportExt;
    GpMatrix        ViewportXForm;
    POINT           ImgViewportOrg;
    SIZE            ImgViewportExt;
    POINT           DstViewportOrg;
    SIZE            DstViewportExt;
    BOOL            IsFirstRecord;

public:
    WmfEnumState(
        HDC                 hdc,
        HMETAFILE           hWmf,
        BOOL                externalEnumeration,
        InterpolationMode   interpolation,
        const RECT *        dstRect,
        const RECT *        deviceRect,
        DpContext *         context,
        GpRecolor *         recolor    = NULL,
        ColorAdjustType     adjustType = ColorAdjustTypeDefault
        );
    ~WmfEnumState();

    virtual BOOL
    ProcessRecord(
        EmfPlusRecordType       recordType,
        UINT                    recordDataSize,
        const BYTE *            recordData
        );

    virtual BOOL PlayRecord();
    virtual VOID RestoreHdc();

    VOID EndRecord();
    VOID SetBkColor()
    {
        BkColor  = *((COLORREF UNALIGNED *)&(((WORD UNALIGNED *)RecordData)[0]));
        ModifyRecordColor(0, ColorAdjustTypeBrush);
        this->PlayRecord();
    }
    VOID SetTextColor()
    {
        TextColor  = *((COLORREF UNALIGNED *)&(((WORD UNALIGNED *)RecordData)[0]));
        ModifyRecordColor(0, ColorAdjustTypeText);
        this->PlayRecord();
    }
    VOID FloodFill()
    {
        ModifyRecordColor(0, ColorAdjustTypeBrush);
        this->PlayRecord();
    }
    VOID ExtFloodFill()
    {
        ModifyRecordColor(1, ColorAdjustTypeBrush);
        this->PlayRecord();
    }
    VOID SetPixel()
    {
        ModifyRecordColor(0, ColorAdjustTypePen);
        this->PlayRecord();
    }
    VOID DibCreatePatternBrush();
    VOID CreatePatternBrush();
    VOID CreatePenIndirect();
    VOID CreateBrushIndirect();
    VOID BitBlt();
    VOID StretchBlt()
    {
        this->BitBlt();
    }
    VOID Escape();
    VOID SetDIBitsToDevice();
    VOID PolyPolygon();
    VOID DIBBitBlt();
    VOID DIBStretchBlt()
    {
        this->DIBBitBlt();
    }
    VOID StretchDIBits();
    VOID SetViewportOrg();
    VOID SetViewportExt();
    VOID Rectangle();
    VOID CreateFontIndirect();
    VOID SelectObject();
    VOID CreateRegion();
    VOID SetROP2();

protected:
    virtual INT GetCurrentRecordSize() const { return RecordDataSize + SIZEOF_METARECORDHEADER; }
    BOOL CreateCopyOfCurrentRecord();
    VOID ModifyRecordColor(
        INT             paramIndex,
        ColorAdjustType adjustType
        );
    VOID MakeSolidBlackBrush();
    VOID CalculateViewportMatrix();
    virtual BOOL CreateAndPlayOutputDIBRecord(
        HDC                           hdc,
        const RECTL *                 bounds,
        INT                           dstX,
        INT                           dstY,
        INT                           dstWidth,
        INT                           dstHeight,
        INT                           srcX,
        INT                           srcY,
        INT                           srcWidth,
        INT                           srcHeight,
        BITMAPINFOHEADER UNALIGNED *  dibInfo,
        BYTE *                        bits,   // if NULL, this is a packed DIB
        UINT                          usage,
        DWORD                         rop
        );

    virtual VOID IntersectDestRect();
};

class EmfEnumState : public MfEnumState
{
protected:
    HRGN                    ClipRgn;
    POINT                   BrushOrg;
    HPALETTE                Palette;

public:
    EmfEnumState(
        HDC                 hdc,
        HENHMETAFILE        hEmf,
        const RECT *        dest,
        const RECT *        deviceRect,
        BOOL                externalEnumeration,
        InterpolationMode   interpolation,
        DpContext *         context,
        GpRecolor *         recolor             = NULL,
        ColorAdjustType     adjustType          = ColorAdjustTypeDefault
        );
    ~EmfEnumState()
    {
        GpFree(AllocedRecord);

        if (IsMetafile())
        {
            // Bug 106406 from Office:  Missing RestoreDC in EMF
            // Account for unbalanced SaveDC/RestoreDC pairs and
            // restore to the saveDC state
            ::RestoreDC(Hdc, SaveDcCount - 1);
        }
        else
        {
            ::RestoreDC(Hdc, SaveDcVal);
        }
    }

    virtual BOOL
    ProcessRecord(
        EmfPlusRecordType       recordType,
        UINT                    recordDataSize,
        const BYTE *            recordData
        );

    // returns a pointer to the current record, but the header may
    // not actually be there -- just the data of the record.
    const ENHMETARECORD * GetPartialRecord()
    {
        if (CurrentEmfRecord != NULL)
        {
            return CurrentEmfRecord;
        }
        ASSERT(RecordData != NULL);
        return (const ENHMETARECORD *)(((const BYTE *)RecordData) - sizeof(EMR));
    }

    virtual BOOL PlayRecord();
    virtual VOID RestoreHdc();

    VOID Header();
    VOID SelectPalette(INT objectIndex);
    VOID SetPixelV()
    {
        ModifyRecordColor(2, ColorAdjustTypePen);
        this->PlayRecord();
    }
    VOID SetTextColor()
    {
        TextColor  = ((COLORREF *)RecordData)[0];
        ModifyRecordColor(0, ColorAdjustTypeText);
        this->PlayRecord();
    }
    VOID SetBkColor()
    {
        BkColor  = ((COLORREF *)RecordData)[0];
        ModifyRecordColor(0, ColorAdjustTypeBrush);
        this->PlayRecord();
    }
    VOID CreatePen();
    VOID CreateBrushIndirect();
    VOID ExtFloodFill()
    {
        ModifyRecordColor(2, ColorAdjustTypeBrush);
        this->PlayRecord();
    }
    VOID GdiComment();
    VOID BitBlt();
    VOID StretchBlt();
    VOID SetDIBitsToDevice();
    VOID StretchDIBits();
    VOID CreateDibPatternBrushPt();
    VOID ExtCreatePen();
    VOID MaskBlt()
    {
        // !!! to do
        ResetRecordBounds();
        this->PlayRecord();
    }
    VOID PlgBlt()
    {
        // !!! to do
        ResetRecordBounds();
        this->PlayRecord();
    }
    VOID GradientFill()
    {
        // !!! to do
        this->PlayRecord();
    }
    VOID TransparentBlt()
    {
        // !!! to do
        ResetRecordBounds();
        this->PlayRecord();
    }
    VOID AlphaBlend()
    {
        // !!! to do
        ResetRecordBounds();
        this->PlayRecord();
    }
    VOID ExtEscape();
    VOID ExtCreateFontIndirect();
    VOID SelectObject();
    VOID SetROP2();
    VOID ExtTextOutW();
    VOID Rectangle();

protected:
    virtual INT GetCurrentRecordSize() const { return RecordDataSize + sizeof(EMR); }
    BOOL CreateCopyOfCurrentRecord();
    VOID ModifyRecordColor(
        INT             paramIndex,
        ColorAdjustType adjustType
        );
    BOOL ValidObjectIndex(INT objectIndex)
    {
        return ((objectIndex > 0) && (objectIndex < NumObjects));
    }
    BITMAPINFOHEADER *
    CreateModifiedDib(
        BITMAPINFOHEADER *  srcDibInfo,
        BYTE *              srcBits,
        UINT &              usage,
        DWORD               rop
        );
    virtual BOOL CreateAndPlayOutputDIBRecord(
        HDC                           hdc,
        const RECTL *                 bounds,
        INT                           dstX,
        INT                           dstY,
        INT                           dstWidth,
        INT                           dstHeight,
        INT                           srcX,
        INT                           srcY,
        INT                           srcWidth,
        INT                           srcHeight,
        BITMAPINFOHEADER UNALIGNED *  dibInfo,
        BYTE *                        bits,   // if NULL, this is a packed DIB
        UINT                          usage,
        DWORD                         rop
        );
    virtual VOID IntersectDestRect();

    VOID ResetRecordBounds();
    virtual BOOL CreateAndPlayCommentRecord()
    {
        // This will create an Empty comment record and play it through GDI
        // This is necessary to invalidate the Transform cache that Win9x keeps
        // while playing metafiles. If we need to query the current transform
        // this makes sure that the result is the current one and not the 
        // previously cached transform

        // Allocate a comment buffer that has 1 DWORD in the Data field.
        BYTE buffer[(sizeof(EMRGDICOMMENT)+3) & ~3];
        EMRGDICOMMENT* comment = (EMRGDICOMMENT*) buffer;
        comment->emr.iType = EMR_GDICOMMENT;
        comment->emr.nSize = (sizeof(EMRGDICOMMENT)+3) & ~3;
        comment->cbData = 4;
        *(DWORD*)(comment->Data) = 0;

        return PlayEnhMetaFileRecord(Hdc, HandleTable, (ENHMETARECORD*)comment, NumObjects);
    }

};

BOOL
GetDibNumPalEntries(
    BOOL        isWmfDib,
    UINT        biSize,
    UINT        biBitCount,
    UINT        biCompression,
    UINT        biClrUsed,
    UINT *      numPalEntries
    );

UINT
GetDibBitsSize(
    BITMAPINFOHEADER UNALIGNED *  dibInfo
    );

inline static BOOL
IsSourceInRop3(
    DWORD       rop3
    )
{
    return (rop3 & 0xCCCC0000) != ((rop3 << 2) & 0xCCCC0000);
}

#endif // !_METAWMF_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\metarecord.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   MetaFile.cpp
*
* Abstract:
*
*   Metafile object handling
*
* Created:
*
*   4/14/1999 DCurtis
*
\**************************************************************************/

#include "precomp.hpp"
#include "..\imaging\api\comutils.hpp"

#define META_FORMAT_ENHANCED        0x10000         // Windows NT format

VOID
FrameToMM100(
    const GpRectF *         frameRect,
    GpPageUnit              frameUnit,
    GpRectF &               frameRectMM100,
    REAL                    dpiX,               // only used for pixel case
    REAL                    dpiY
    );

/**************************************************************************\
*
* Function Description:
*
*   Determine if the REAL points can be converted to GpPoint16 points without
*   losing accuracy.  If so, then do the conversion, and set the flags to say
*   we're using 16-bit points.
*
* Arguments:
*
*   [IN]      points        - the REAL points to try to convert
*   [IN]      count         - the number of points
*
* Return Value:
*
*   NONE
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
MetafilePointData::MetafilePointData(
    const GpPointF *    points,
    INT                 count
    )
{
    ASSERT((count > 0) && (points != NULL));

    // Assume that the conversion to GpPoint16 will fail
    PointData     = (BYTE *)points;
    PointDataSize = count * sizeof(points[0]);
    Flags         = 0;
    AllocedPoints = NULL;

    GpPoint16 *  points16 = PointBuffer;

    if (count > GDIP_POINTDATA_BUFFERSIZE)
    {
        AllocedPoints = new GpPoint16[count];
        if (AllocedPoints == NULL)
        {
            return; // live with REAL data
        }
        points16 = AllocedPoints;
    }

    GpPoint16 *     curPoint16 = points16;
    INT             i          = count;

    do
    {
        curPoint16->X = (INT16)GpRound(points->X);
        curPoint16->Y = (INT16)GpRound(points->Y);

        if (!IsPoint16Equal(curPoint16, points))
        {
            return; // the point data doesn't fit in 16 bits per value
        }
        curPoint16++;
        points++;
    } while (--i > 0);

    // We succeeded in converting the point data to 16 bits per value
    PointData     = (BYTE *)points16;
    PointDataSize = count * sizeof(points16[0]);
    Flags         = GDIP_EPRFLAGS_COMPRESSED;
}

/**************************************************************************\
*
* Function Description:
*
*   Determine if the REAL rects can be converted to GpRect16 points without
*   losing accuracy.  If so, then do the conversion, and set the flags to say
*   we're using 16-bit rects.
*
* Arguments:
*
*   [IN]      rects         - the REAL rects to try to convert
*   [IN]      count         - the number of rects
*
* Return Value:
*
*   NONE
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
MetafileRectData::MetafileRectData(
    const GpRectF *     rects,
    INT                 count
    )
{
    ASSERT((count > 0) && (rects != NULL));

    // Assume that the conversion to GpRect16 will fail
    RectData     = (BYTE *)rects;
    RectDataSize = count * sizeof(rects[0]);
    Flags        = 0;
    AllocedRects = NULL;

    GpRect16 *  rects16 = RectBuffer;

    if (count > GDIP_RECTDATA_BUFFERSIZE)
    {
        AllocedRects = new GpRect16[count];
        if (AllocedRects == NULL)
        {
            return; // live with REAL data
        }
        rects16 = AllocedRects;
    }

    GpRect16 *  curRect16 = rects16;
    INT         i         = count;

    do
    {
        curRect16->X      = (INT16)GpRound(rects->X);
        curRect16->Y      = (INT16)GpRound(rects->Y);
        curRect16->Width  = (INT16)GpRound(rects->Width);
        curRect16->Height = (INT16)GpRound(rects->Height);

        if (!IsRect16Equal(curRect16, rects))
        {
            return; // the rect data doesn't fit in 16 bits per value
        }
        curRect16++;
        rects++;
    } while (--i > 0);

    // We succeeded in converting the rect data to 16 bits per value
    RectData     = (BYTE *)rects16;
    RectDataSize = count * sizeof(rects16[0]);
    Flags        = GDIP_EPRFLAGS_COMPRESSED;
}

///////////////////////////////////////////////////////////////////////////
// classes for handling recording of objects within the metafile

class MetafileRecordObject
{
friend class MetafileRecordObjectList;
protected:
    const GpObject *    ObjectPointer;
    UINT                Uid;
    ObjectType          Type;
    UINT                Next;
    UINT                Prev;

public:
    MetafileRecordObject()
    {
        ObjectPointer     = NULL;
        Uid               = 0;
        Type              = ObjectTypeInvalid;
        Next              = GDIP_LIST_NIL;
        Prev              = GDIP_LIST_NIL;
    }

    const GpObject * GetObject() const
    {
        return ObjectPointer;
    }
    UINT GetUid() const
    {
        return Uid;
    }
    ObjectType GetType() const
    {
        return Type;
    }
};

class MetafileRecordObjectList
{
protected:
    INT                     Count;
    UINT                    LRU;
    UINT                    MRU;
    MetafileRecordObject    Objects[GDIP_MAX_OBJECTS];

public:
    MetafileRecordObjectList()
    {
        Count    = 0;
        LRU      = GDIP_LIST_NIL;
        MRU      = GDIP_LIST_NIL;
    }

    MetafileRecordObject * GetMetaObject(UINT metaObjectID)
    {
        ASSERT(metaObjectID < GDIP_MAX_OBJECTS);
        return Objects + metaObjectID;
    }

    // Search through the list, starting at the MRU entry, to see if we
    // can find the object.  If we do find it, return the index to the
    // object in metaObjectId (even if the Uid's don't match).  Return
    // TRUE only if we found the object and the Uid's match.
    BOOL
    IsInList(
        const GpObject *            object,
        ObjectType                  objectType,
        UINT32 *                    metaObjectId
        );

#if 0   // not used
    VOID
    RemoveAt(
        UINT32                      metaObjectId
        );
#endif

    // if metaObjectId is GDIP_LIST_NIL, use the next available slot
    VOID
    InsertAt(
        const GpObject *            object,
        UINT32 *                    metaObjectId
        );

    VOID
    UpdateMRU(
        UINT32                      metaObjectId
        );
};

// Search through the list, starting at the MRU entry, to see if we
// can find the object.  If we do find it, return the index to the
// object in metaObjectId (even if the Uid's don't match).  Return
// TRUE only if we found the object and the Uid's match.
BOOL
MetafileRecordObjectList::IsInList(
    const GpObject *            object,
    ObjectType                  objectType,
    UINT32 *                    metaObjectId
    )
{
    ASSERT(object != NULL);
    ASSERT(metaObjectId != NULL);

    BOOL        isInList = FALSE;

    isInList = FALSE;               // indicate object not found
    *metaObjectId = GDIP_LIST_NIL;  // indicate object not found

    if (Count != 0)
    {
        UINT    curIndex;
        UINT    uid;

        curIndex = MRU;
        uid      = object->GetUid();

        do
        {
            if (Objects[curIndex].ObjectPointer == object)
            {
                *metaObjectId = curIndex;
                isInList = ((Objects[curIndex].Uid  == uid) &&
                            (Objects[curIndex].Type == objectType));
                break;
            }
            curIndex = Objects[curIndex].Prev;
        } while (curIndex != GDIP_LIST_NIL);
    }

    return isInList;
}

#if 0   // not used
// We don't actually remove it from the list, we just put it at the
// front of the LRU so its spot gets used next.  So the count stays
// the same.
VOID
MetafileRecordObjectList::RemoveAt(
    UINT32                  metaObjectId
    )
{
    ASSERT(metaObjectId < GDIP_MAX_OBJECTS);

    MetafileRecordObject *      removeObject = Objects + metaObjectId;

    ASSERT(Count > 0);
    removeObject->ObjectPointer     = NULL;
    removeObject->Uid               = 0;
    removeObject->Type              = EmfPlusRecordTypeInvalid;

    INT     removeNext = removeObject->Next;
    INT     removePrev = removeObject->Prev;

    if (removeNext != GDIP_LIST_NIL)
    {
        Objects[removeNext].Prev = removePrev;
    }
    else
    {
        ASSERT(MRU == metaObjectId);
        if (removePrev != GDIP_LIST_NIL)
        {
            MRU = removePrev;
        }
    }

    if (removePrev != GDIP_LIST_NIL)
    {
        ASSERT(LRU != metaObjectId);
        Objects[removePrev].Next = removeNext;
        removeObject->Prev = GDIP_LIST_NIL;
        removeObject->Next = LRU;
        Objects[LRU].Prev = metaObjectId;
        LRU = metaObjectId;
    }
    else
    {
        ASSERT(LRU == metaObjectId);
    }
}
#endif

// Make the specified object the MRU object.
VOID
MetafileRecordObjectList::UpdateMRU(
    UINT32                      metaObjectId
    )
{
    if (MRU != metaObjectId)
    {
        // Now we know there are at least 2 objects
        MetafileRecordObject *      object = &Objects[metaObjectId];
        if (LRU != metaObjectId)
        {
            Objects[object->Prev].Next = object->Next;
        }
        else
        {
            LRU = object->Next;
        }
        Objects[object->Next].Prev = object->Prev;
        object->Prev = MRU;
        object->Next = GDIP_LIST_NIL;
        Objects[MRU].Next = metaObjectId;
        MRU = metaObjectId;
    }
}

// if metaObjectId is GDIP_LIST_NIL, use the next available slot
VOID
MetafileRecordObjectList::InsertAt(
    const GpObject *            object,
    UINT32 *                    metaObjectId
    )
{
    MetafileRecordObject *      newObject;
    UINT                        newIndex = *metaObjectId;

    if (newIndex == GDIP_LIST_NIL)
    {
        if (Count != 0)
        {
            // use freed object before adding new one
            if ((Objects[LRU].ObjectPointer == NULL) ||
                (Count == GDIP_MAX_OBJECTS))
            {
                newIndex = LRU;
UseLRU:
                LRU = Objects[newIndex].Next;
                Objects[LRU].Prev = GDIP_LIST_NIL;
            }
            else
            {
                newIndex = Count++;
            }
InsertObject:
            Objects[MRU].Next = newIndex;

SetupObject:
            *metaObjectId                = newIndex;
            newObject                    = &Objects[newIndex];
            newObject->Next              = GDIP_LIST_NIL;
            newObject->Prev              = MRU;
            MRU                          = newIndex;
UseMRU:
            newObject->ObjectPointer     = object;
            newObject->Uid               = object->GetUid();
            newObject->Type              = object->GetObjectType();
            return;
        }
        // else first object
        newIndex = 0;
        LRU      = 0;
        Count    = 1;
        goto SetupObject;
    }
    else    // we already know where to put the object
    {
        ASSERT(Count > 0);
        ASSERT(newIndex < GDIP_MAX_OBJECTS);

        if (newIndex == MRU)
        {
            // This covers the case where there is only 1 object
            newObject = &Objects[newIndex];
            goto UseMRU;
        }
        // else there must be at least 2 objects
        ASSERT(Count > 1);

        if (newIndex == LRU)
        {
            goto UseLRU;
        }
        // Move middle object to MRU
        newObject = &Objects[newIndex];
        Objects[newObject->Prev].Next = newObject->Next;
        Objects[newObject->Next].Prev = newObject->Prev;
        goto InsertObject;
    }
}

#define GDIP_MAX_COMMENT_SIZE         65020 // must be <= 65520 for Win9x bug

class EmfPlusCommentStream : public IUnknownBase<IStream>
{
private:
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagEmfPlusCommentStream : ObjectTagInvalid;
    }

public:
    EmfPlusCommentStream(HDC hdc)
    {
        ASSERT(hdc != NULL);

        MetafileHdc                 = hdc;
        Position                    = 0;   // starts after signature
        ((INT32 *)CommentBuffer)[0] = EMFPLUS_SIGNATURE;
        RecordDataStart             = CommentBuffer + sizeof(INT32);
        ContinuingObjectRecord      = FALSE;
        SetValid(TRUE);
    }

    ~EmfPlusCommentStream()
    {
        this->Flush();
    }

    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagEmfPlusCommentStream) || (Tag == ObjectTagInvalid));
        return (Tag == ObjectTagEmfPlusCommentStream);
    }

    ULONG SpaceLeft() const
    {
        return (GDIP_MAX_COMMENT_SIZE - Position);
    }

    VOID
    EndObjectRecord()
    {
        ASSERT ((Position & 0x03) == 0);    // records should be 4-byte aligned

        if (ContinuingObjectRecord)
        {
            ContinuingObjectRecord = FALSE;
            if (Position > sizeof(EmfPlusContinueObjectRecord))
            {
                // Fix up the size of the last chunck of this object record
                EmfPlusContinueObjectRecord *   recordData;
                recordData = (EmfPlusContinueObjectRecord *)RecordDataStart;
                recordData->Size     = Position;
                recordData->DataSize = Position - sizeof(EmfPlusRecord);
            }
            else
            {
                // The object record ended exacly at the end of the buffer
                // and has already been flushed.
                Position = 0;
            }
        }
    }

    VOID
    WriteRecordHeader(
        UINT32                      dataSize,       // size of data (w/o record header)
        EmfPlusRecordType           type,
        INT                         flags           // 16 bits of flags
        );

    VOID Flush();

    HRESULT STDMETHODCALLTYPE Write(
        VOID const HUGEP *pv,
        ULONG cb,
        ULONG *pcbWritten)
    {
        if (cb == 0)
        {
            if (pcbWritten != NULL)
            {
                *pcbWritten = cb;
            }
            return S_OK;
        }

        ASSERT (pv != NULL);

        if (IsValid())
        {
            // We've already written the record header; now we're writing
            // the record data.
            ASSERT(Position >= sizeof(EmfPlusRecord));

            ULONG   spaceLeft = SpaceLeft();
            BYTE *  recordData = RecordDataStart + Position;

            // We flush as soon as we reach the end.  We don't wait for
            // the next write call to flush.
            ASSERT(spaceLeft > 0);

            if (pcbWritten)
            {
                *pcbWritten = cb;
            }

            // see if there is enough room for the data
            if (cb <= spaceLeft)
            {
                GpMemcpy(recordData, pv, cb);
                Position += cb;

                if (Position < GDIP_MAX_COMMENT_SIZE)
                {
                    return S_OK;
                }
                this->Flush();
                if (IsValid())
                {
                    return S_OK;
                }
                if (pcbWritten)
                {
                    *pcbWritten = 0;
                }
                return E_FAIL;
            }

            ASSERT(ContinuingObjectRecord);

        LoopStart:
            GpMemcpy(recordData, pv, spaceLeft);
            Position += spaceLeft;
            if (Position == GDIP_MAX_COMMENT_SIZE)
            {
                this->Flush();
                if (!IsValid())
                {
                    if (pcbWritten)
                    {
                        *pcbWritten = 0;    // not accurate, but who cares!
                    }
                    return E_FAIL;
                }
            }
            cb -= spaceLeft;
            if (cb == 0)
            {
                return S_OK;
            }
            pv = ((BYTE *)pv) + spaceLeft;
            recordData = RecordDataStart + sizeof(EmfPlusContinueObjectRecord);
            spaceLeft  = GDIP_MAX_COMMENT_SIZE-sizeof(EmfPlusContinueObjectRecord);
            if (spaceLeft > cb)
            {
                spaceLeft = cb;
            }
            goto LoopStart;
        }
        return E_FAIL;
    }

    HRESULT STDMETHODCALLTYPE Read(
        VOID HUGEP *pv,
        ULONG cb,
        ULONG *pcbRead)
    {
        return E_NOTIMPL;
    }

    HRESULT STDMETHODCALLTYPE Seek(
        LARGE_INTEGER dlibMove,
        DWORD dwOrigin,
        ULARGE_INTEGER *plibNewPosition)
    {
        return E_NOTIMPL;
    }

    HRESULT STDMETHODCALLTYPE SetSize(
        ULARGE_INTEGER libNewSize)
    {
        return E_NOTIMPL;
    }

    HRESULT STDMETHODCALLTYPE CopyTo(
        IStream *pstm,
        ULARGE_INTEGER cb,
        ULARGE_INTEGER *pcbRead,
        ULARGE_INTEGER *pcbWritten)
    {
        return E_NOTIMPL;
    }

    HRESULT STDMETHODCALLTYPE Commit(
        DWORD grfCommitFlags)
    {
        return E_NOTIMPL;
    }

    HRESULT STDMETHODCALLTYPE Revert(VOID)
    {
        return E_NOTIMPL;
    }

    HRESULT STDMETHODCALLTYPE LockRegion(
        ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb,
        DWORD dwLockType)
    {
        return E_NOTIMPL;
    }

    HRESULT STDMETHODCALLTYPE UnlockRegion(
        ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb,
        DWORD dwLockType)
    {
        return E_NOTIMPL;
    }

    HRESULT STDMETHODCALLTYPE Stat(
        STATSTG *pstatstg,
        DWORD grfStatFlag)
    {
        return E_NOTIMPL;
    }

    HRESULT STDMETHODCALLTYPE Clone(
        IStream **ppstm)
    {
        return E_NOTIMPL;
    }

private:
    BYTE    CommentBuffer[GDIP_MAX_COMMENT_SIZE + sizeof(INT32)];
    BYTE *  RecordDataStart;
    ULONG   Position;
    HDC     MetafileHdc;
    BOOL    ContinuingObjectRecord;
};

VOID
EmfPlusCommentStream::Flush()
{
    ASSERT ((Position & 0x03) == 0);    // records should be 4-byte aligned

    if (IsValid() && (Position >= sizeof(EmfPlusRecord)))
    {
        // write the signature as well as the records
        SetValid(GdiComment(MetafileHdc, (INT)Position + sizeof(INT32),
                            CommentBuffer) != 0);

#if DBG
        if (!IsValid())
        {
            WARNING(("Failed to write GdiComment"));
        }
#endif

        if (!ContinuingObjectRecord)
        {
            Position = 0;
        }
        else
        {
            ASSERT(Position == GDIP_MAX_COMMENT_SIZE);

            // Leave the object record header intact for the rest of the
            // object data.
            Position = sizeof(EmfPlusContinueObjectRecord);
        }
    }
}

VOID
EmfPlusCommentStream::WriteRecordHeader(
    UINT32                      dataSize,       // size of data (w/o record header)
    EmfPlusRecordType           type,
    INT                         flags           // 16 bits of flags
    )
{
    ASSERT ((flags & 0xFFFF0000) == 0);
    ASSERT (ContinuingObjectRecord == FALSE);
    ASSERT ((Position & 0x03) == 0);    // records should be 4-byte aligned
    ASSERT ((dataSize & 0x03) == 0);    // records should be 4-byte aligned

    if (IsValid())
    {
        ULONG   spaceLeft  = SpaceLeft();
        ULONG   recordSize = sizeof(EmfPlusRecord) + dataSize;

        ASSERT(spaceLeft > 0);

        // see if the record fits in the space left
        if (recordSize <= spaceLeft)
        {
    RecordFits:
            EmfPlusRecord *     recordData;

            recordData = (EmfPlusRecord *)(RecordDataStart + Position);

            recordData->Type     = type;
            recordData->Flags    = (INT16)flags;
            recordData->Size     = recordSize;
            recordData->DataSize = dataSize;
            Position         += sizeof(EmfPlusRecord);
            if (Position < GDIP_MAX_COMMENT_SIZE)
            {
                return;
            }
            ASSERT((recordSize == sizeof(EmfPlusRecord)) && (dataSize == 0));
            this->Flush();
            return;
        }
        else // it doesn't fit in the space left
        {
            // maybe it will fit after flushing the current record buffer
            if (spaceLeft < GDIP_MAX_COMMENT_SIZE)
            {
                this->Flush();
                if (!IsValid())
                {
                    return;
                }
                if (recordSize <= GDIP_MAX_COMMENT_SIZE)
                {
                    goto RecordFits;
                }
            }

            // Now we know the record does not fit in a single comment.
            // This better be an object record!
            ASSERT(type == EmfPlusRecordTypeObject);

            flags |= GDIP_EPRFLAGS_CONTINUEOBJECT;
            ContinuingObjectRecord = TRUE;

            // We know that Position is 0
            EmfPlusContinueObjectRecord *   recordData;
            recordData = (EmfPlusContinueObjectRecord *)RecordDataStart;

            recordData->Type             = type;
            recordData->Flags            = (INT16)flags;
            recordData->Size             = GDIP_MAX_COMMENT_SIZE;
            recordData->DataSize         = GDIP_MAX_COMMENT_SIZE - sizeof(EmfPlusRecord);
            recordData->TotalObjectSize  = dataSize;    // size of object data (w/o header size)
            Position                     = sizeof(EmfPlusContinueObjectRecord);
        }
    }
}

class MetafileRecorder : public IMetafileRecord
{
friend class GpMetafile;

private:
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagMetafileRecorder : ObjectTagInvalid;
    }

public:
    BOOL                                    WroteFrameRect;
    SIZEL                                   Millimeters;

protected:
    EmfPlusCommentStream *                  EmfPlusStream; // memory buffer stream
    GpMetafile *                            Metafile;   // being recorded
    EmfType                                 Type;
    REAL                                    XMinDevice; // device bounds
    REAL                                    YMinDevice;
    REAL                                    XMaxDevice;
    REAL                                    YMaxDevice;
    BOOL                                    BoundsInit;
    INT                                     NumRecords; // for debugging only
    INT                                     MaxStackSize;
    HDC                                     MetafileHdc;
    DynArrayIA<INT,GDIP_SAVE_STACK_SIZE>    SaveRestoreStack;
    MetafileRecordObjectList                ObjectList;
    GpRectF                                 MetafileBounds;

public:
    MetafileRecorder(
        GpMetafile *    metafile,
        EmfType         type,
        HDC             metafileHdc,
        BOOL            wroteFrameRect,
        SIZEL &         effectiveMillimeters,
        GpRectF &       metafileBounds
        );

    ~MetafileRecorder() // called by EndRecording
    {
        // Release the memory stream for writing the GdiComments
        if (EmfPlusStream != NULL)
        {
            EmfPlusStream->Release();
        }
    }

    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagMetafileRecorder) || (Tag == ObjectTagInvalid));
        return (Tag == ObjectTagMetafileRecorder);
    }

    virtual VOID GetMetafileBounds(GpRect & metafileBounds) const
    {
        // Use Floor to make sure we don't miss any pixels
        metafileBounds.X      = GpFloor(MetafileBounds.X);
        metafileBounds.Y      = GpFloor(MetafileBounds.Y);
        metafileBounds.Width  = GpCeiling(MetafileBounds.GetRight())  - metafileBounds.X;
        metafileBounds.Height = GpCeiling(MetafileBounds.GetBottom()) - metafileBounds.Y;
    }

    virtual GpStatus
    RecordClear(
        const GpRectF *             deviceBounds,
        GpColor                     color
        );

    virtual GpStatus
    RecordFillRects(
        const GpRectF *             deviceBounds,
        GpBrush *                   brush,
        const GpRectF *             rects,
        INT                         count
        );

    virtual GpStatus
    RecordDrawRects(
        const GpRectF *             deviceBounds,
        GpPen *                     pen,
        const GpRectF *             rects,
        INT                         count
        );

    virtual GpStatus
    RecordFillPolygon(
        const GpRectF *             deviceBounds,
        GpBrush*                    brush,
        const GpPointF *            points,
        INT                         count,
        GpFillMode                  fillMode
        );

    virtual GpStatus
    RecordDrawLines(
        const GpRectF *             deviceBounds,
        GpPen *                     pen,
        const GpPointF *            points,
        INT                         count,
        BOOL                        closed
        );

    virtual GpStatus
    RecordFillEllipse(
        const GpRectF *             deviceBounds,
        GpBrush *                   brush,
        const GpRectF &             rect
        );

    virtual GpStatus
    RecordDrawEllipse(
        const GpRectF *             deviceBounds,
        GpPen *                     pen,
        const GpRectF &             rect
        );

    virtual GpStatus
    RecordFillPie(
        const GpRectF *             deviceBounds,
        GpBrush *                   brush,
        const GpRectF &             rect,
        REAL                        startAngle,
        REAL                        sweepAngle
        );

    virtual GpStatus
    RecordDrawPie(
        const GpRectF *             deviceBounds,
        GpPen *                     pen,
        const GpRectF &             rect,
        REAL                        startAngle,
        REAL                        sweepAngle
        );

    virtual GpStatus
    RecordDrawArc(
        const GpRectF *             deviceBounds,
        GpPen *                     pen,
        const GpRectF &             rect,
        REAL                        startAngle,
        REAL                        sweepAngle
        );

    virtual GpStatus
    RecordFillRegion(
        const GpRectF *             deviceBounds,
        GpBrush *                   brush,
        GpRegion *                  region
        );

    virtual GpStatus
    RecordFillPath(
        const GpRectF *             deviceBounds,
        const GpBrush *             brush,
        GpPath *                    path
        );

    virtual GpStatus
    RecordDrawPath(
        const GpRectF *             deviceBounds,
        GpPen *                     pen,
        GpPath *                    path
        );

    virtual GpStatus
    RecordFillClosedCurve(
        const GpRectF *             deviceBounds,
        GpBrush *                   brush,
        const GpPointF *            points,
        INT                         count,
        REAL                        tension,
        GpFillMode                  fillMode
        );

    virtual GpStatus
    RecordDrawClosedCurve(
        const GpRectF *             deviceBounds,
        GpPen *                     pen,
        const GpPointF *            points,
        INT                         count,
        REAL                        tension
        );

    virtual GpStatus
    RecordDrawCurve(
        const GpRectF *             deviceBounds,
        GpPen *                     pen,
        const GpPointF *            points,
        INT                         count,
        REAL                        tension,
        INT                         offset,
        INT                         numberOfSegments
        );

    virtual GpStatus
    RecordDrawBeziers(
        const GpRectF *             deviceBounds,
        GpPen *                     pen,
        const GpPointF *            points,
        INT                         count
        );

    virtual GpStatus
    RecordDrawImage(
        const GpRectF *             deviceBounds,
        const GpImage *             image,
        const GpRectF &             destRect,
        const GpRectF &             srcRect,
        GpPageUnit                  srcUnit,
        const GpImageAttributes *         imageAttributes
        );

    virtual GpStatus
    RecordDrawImage(
        const GpRectF *             deviceBounds,
        const GpImage *             image,
        const GpPointF *            destPoints,
        INT                         count,
        const GpRectF &             srcRect,
        GpPageUnit                  srcUnit,
        const GpImageAttributes *         imageAttributes
        );

    virtual GpStatus
    RecordDrawString(
        const GpRectF *             deviceBounds,
        const WCHAR                *string,
        INT                         length,
        const GpFont               *font,
        const RectF                *layoutRect,
        const GpStringFormat       *format,
        const GpBrush              *brush
        );

    virtual GpStatus
    RecordDrawDriverString(
        const GpRectF *             deviceBounds,
        const UINT16               *text,
        INT                         glyphCount,
        const GpFont               *font,
        const GpBrush              *brush,
        const PointF               *positions,
        INT                         flags,
        const GpMatrix             *matrix
        );

    virtual GpStatus
    RecordSave(
        INT         gstate
        );

    virtual GpStatus
    RecordRestore(
        INT         gstate
        );

    virtual GpStatus
    RecordBeginContainer(
        const GpRectF &             destRect,
        const GpRectF &             srcRect,
        GpPageUnit                  srcUnit,
        INT                         containerState
        );

    virtual GpStatus
    RecordBeginContainer(
        INT                         containerState
        );

    virtual GpStatus
    RecordEndContainer(
        INT                         containerState
        );

    virtual GpStatus
    RecordSetWorldTransform(
        const GpMatrix &            matrix
        );

    virtual GpStatus
    RecordResetWorldTransform();

    virtual GpStatus
    RecordMultiplyWorldTransform(
        const GpMatrix &            matrix,
        GpMatrixOrder               order
        );

    virtual GpStatus
    RecordTranslateWorldTransform(
        REAL                        dx,
        REAL                        dy,
        GpMatrixOrder               order
        );

    virtual GpStatus
    RecordScaleWorldTransform(
        REAL                        sx,
        REAL                        sy,
        GpMatrixOrder               order
        );

    virtual GpStatus
    RecordRotateWorldTransform(
        REAL                        angle,
        GpMatrixOrder               order
        );

    virtual GpStatus
    RecordSetPageTransform(
        GpPageUnit                  unit,
        REAL                        scale
        );

    virtual GpStatus
    RecordResetClip();

    virtual GpStatus
    RecordSetClip(
        const GpRectF &             rect,
        CombineMode                 combineMode
        );

    virtual GpStatus
    RecordSetClip(
        GpRegion *                  region,
        CombineMode                 combineMode
        );

    virtual GpStatus
    RecordSetClip(
        GpPath *                    path,
        CombineMode                 combineMode,
        BOOL                        isDevicePath
        );

    virtual GpStatus
    RecordOffsetClip(
        REAL                        dx,
        REAL                        dy
        );

    virtual GpStatus
    RecordGetDC();

    virtual GpStatus
    RecordSetAntiAliasMode(
        BOOL                        newMode
        );

    virtual GpStatus
    RecordSetTextRenderingHint(
        TextRenderingHint           newMode
        );

    virtual GpStatus
    RecordSetTextContrast(
        UINT                        gammaValue
        );

    virtual GpStatus
    RecordSetInterpolationMode(
        InterpolationMode           newMode
        );

    virtual GpStatus
    RecordSetPixelOffsetMode(
        PixelOffsetMode             newMode
        );

    virtual GpStatus
    RecordSetCompositingMode(
        GpCompositingMode           newMode
        );

    virtual GpStatus
    RecordSetCompositingQuality(
        GpCompositingQuality        newQuality
        );

    virtual GpStatus
    RecordSetRenderingOrigin(
        INT x,
        INT y
    );

    virtual GpStatus
    RecordComment(
        UINT            sizeData,
        const BYTE *    data
        );

    virtual VOID
    EndRecording();

    virtual GpStatus
    RecordBackupObject(
        const GpObject *            object
        );

protected:

    GpStatus
    RecordHeader(
        INT                 logicalDpiX,
        INT                 logicalDpiY,
        INT                 emfPlusFlags
        );
    VOID RecordEndOfFile();

    VOID
    WriteObject(
        ObjectType                  type,
        const GpObject *            object,
        UINT32                      metaObjectId
        );

    VOID
    RecordObject(
        const GpObject *            object,
        UINT32*                     metaObjectId
        );

    GpStatus
    RecordZeroDataRecord(
        EmfPlusRecordType           type,
        INT                         flags
        );

    VOID
    WriteRecordHeader(
        UINT32                      dataSize,
        EmfPlusRecordType           type,
        INT                         flags        = 0,   // 16 bits of flags
        const GpRectF *             deviceBounds = NULL
        );

    // To keep the number of comments low, this only needs to be called
    // when there is a down-level representation of the GDI+ record.
    VOID
    WriteGdiComment()
    {
        // If we're doing dual (which means we're about to write
        // down-level records) then write out the current list
        // of records in the EmfPlusStream buffer.
        if (Type == EmfTypeEmfPlusDual)
        {
            EmfPlusStream->Flush();
        }
    }

    VOID
    GetBrushValueForRecording(
        const GpBrush *brush,
        UINT32        &brushValue,
        INT           &flags
        );
};

/**************************************************************************\
*
* Function Description:
*
*   Construct a MetafileRecorder object and initialize it.
*
* Arguments:
*
*   [IN]  metafile    - pointer to the metafile object being recorded
*   [IN]  stream      - the stream being recorded into (if any)
*   [IN]  metafileHdc - handle to metafile DC being recorded into (if any)
*   [IN]  dpiX        - the horizontal DPI
*   [IN]  dpiY        - the vertical   DPI
*
* Return Value:
*
*   NONE
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
MetafileRecorder::MetafileRecorder(
    GpMetafile *    metafile,
    EmfType         emfType,
    HDC             metafileHdc,
    BOOL            wroteFrameRect,
    SIZEL &         effectiveMillimeters,
    GpRectF &       metafileBounds
    )
{
    SetValid(FALSE);
    Type                    = emfType;
    Metafile                = metafile;
    WroteFrameRect          = wroteFrameRect;
    NumRecords              = 0;        // currently for debugging only
    MaxStackSize            = 0;
    MetafileHdc             = metafileHdc;
    XMinDevice              = FLT_MAX;
    YMinDevice              = FLT_MAX;
    XMaxDevice              = -FLT_MAX;
    YMaxDevice              = -FLT_MAX;
    BoundsInit              = FALSE;
    EmfPlusStream           = NULL;
    Millimeters             = effectiveMillimeters;

    // The metafileBounds are used as the bounds for FillRegion
    // calls when the region has infinite bounds, to keep from
    // exploding the bounds of the metafile.
    MetafileBounds          = metafileBounds;

    if (emfType == EmfTypeEmfOnly)
    {
        Metafile->Header.Type = MetafileTypeEmf;
        SetValid(TRUE);
    }
    else
    {
        // gets freed in the destructor
        EmfPlusStream = new EmfPlusCommentStream(metafileHdc);

        if (EmfPlusStream == NULL)
        {
            return;
        }

        SetValid(TRUE);

        INT                 logicalDpiX  = GetDeviceCaps(metafileHdc, LOGPIXELSX);
        INT                 logicalDpiY  = GetDeviceCaps(metafileHdc, LOGPIXELSY);
        INT                 emfPlusFlags = 0;

        if (GetDeviceCaps(metafileHdc, TECHNOLOGY) == DT_RASDISPLAY)
        {
            emfPlusFlags |= GDIP_EMFPLUSFLAGS_DISPLAY;
        }

        MetafileHeader * header = &(metafile->Header);

        header->EmfPlusHeaderSize = sizeof(EmfPlusRecord) + sizeof(EmfPlusHeaderRecord);
        header->LogicalDpiX       = logicalDpiX;
        header->LogicalDpiY       = logicalDpiY;
        header->EmfPlusFlags      = emfPlusFlags;
        if (emfType == EmfTypeEmfPlusOnly)
        {
            header->Type          = MetafileTypeEmfPlusOnly;
        }
        else
        {
            ASSERT(emfType == EmfTypeEmfPlusDual);
            header->Type          = MetafileTypeEmfPlusDual;
        }

        if (RecordHeader(logicalDpiX, logicalDpiY, emfPlusFlags) != Ok)
        {
            SetValid(FALSE);
            EmfPlusStream->Release();
            EmfPlusStream = NULL;
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordClear.
*
* Arguments:
*
*   [IN]  deviceBounds - the bounding rect, in device units
*   [IN]  color        - the clear color
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*  04/28/2000 AGodfrey
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordClear(
    const GpRectF *             deviceBounds,
    GpColor                     color
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        if (IsValid())
        {
            ASSERT (deviceBounds != NULL);

            ARGB argbColor = color.GetValue();

            UINT32              dataSize = sizeof(argbColor);
            EmfPlusRecordType   type     = EmfPlusRecordTypeClear;
            INT                 flags    = 0;

            WriteRecordHeader(dataSize, type, flags, deviceBounds);
            WriteInt32(EmfPlusStream, argbColor);
            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write Clear record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordFillRects.
*
* Arguments:
*
*   [IN]  deviceBounds - the bounding rect, in device units
*   [IN]  brush        - brush to draw with
*   [IN]  rects        - rectangles to fill
*   [IN]  count        - number of rects
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordFillRects(
    const GpRectF *             deviceBounds,
    GpBrush *                   brush,
    const GpRectF *             rects,
    INT                         count
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        ASSERT ((deviceBounds != NULL) && (brush != NULL) &&
                (rects != NULL) && (count > 0));

        if (IsValid())
        {
            MetafileRectData    rectData(rects, count);
            UINT32              brushValue; // Metafile Brush Id or ARGB value
            UINT32              dataSize = sizeof(brushValue) +
                                           sizeof(UINT32/* count */) +
                                           rectData.GetDataSize();
            EmfPlusRecordType   type     = EmfPlusRecordTypeFillRects;
            INT                 flags    = rectData.GetFlags();

            GetBrushValueForRecording(brush, brushValue, flags);

            WriteRecordHeader(dataSize, type, flags, deviceBounds);
            WriteInt32(EmfPlusStream, brushValue);
            WriteInt32(EmfPlusStream, count);
            rectData.WriteData(EmfPlusStream);
            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write FillRects record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordDrawRects.
*
* Arguments:
*
*   [IN]  deviceBounds - the bounding rect, in device units
*   [IN]  pen          - pen to draw with
*   [IN]  rects        - rectangles to draw
*   [IN]  count        - number of rects
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordDrawRects(
    const GpRectF *             deviceBounds,
    GpPen *                     pen,
    const GpRectF *             rects,
    INT                         count
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        ASSERT ((deviceBounds != NULL) && (pen != NULL) &&
                (rects != NULL) && (count > 0));

        if (IsValid())
        {
            MetafileRectData    rectData(rects, count);
            UINT32              metaPenId;
            UINT32              dataSize = sizeof(UINT32/* count */) +
                                           rectData.GetDataSize();
            EmfPlusRecordType   type     = EmfPlusRecordTypeDrawRects;
            INT                 flags    = rectData.GetFlags();

            RecordObject(pen, &metaPenId);
            ASSERT((metaPenId & (~GDIP_EPRFLAGS_METAOBJECTID)) == 0);
            flags |= metaPenId;

            WriteRecordHeader(dataSize, type, flags, deviceBounds);
            WriteInt32(EmfPlusStream, count);
            rectData.WriteData(EmfPlusStream);
            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write DrawRects record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordFillPolygon.
*
* Arguments:
*
*   [IN]  deviceBounds - the bounding rect, in device units
*   [IN]  brush        - brush to draw with
*   [IN]  points       - polygon points
*   [IN]  count        - number of points
*   [IN]  fillMode     - Alternate or Winding
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordFillPolygon(
    const GpRectF *             deviceBounds,
    GpBrush*                    brush,
    const GpPointF *            points,
    INT                         count,
    GpFillMode                  fillMode
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        ASSERT ((deviceBounds != NULL) && (brush != NULL) &&
                (points != NULL) && (count > 0));

        if (IsValid())
        {
            MetafilePointData   pointData(points, count);
            UINT32              brushValue; // Metafile Brush Id or ARGB value
            UINT32              dataSize = sizeof(brushValue) +
                                           sizeof(UINT32/* count */) +
                                           pointData.GetDataSize();
            EmfPlusRecordType   type     = EmfPlusRecordTypeFillPolygon;
            INT                 flags    = pointData.GetFlags();

            GetBrushValueForRecording(brush, brushValue, flags);

            if (fillMode == FillModeWinding)
            {
                flags |= GDIP_EPRFLAGS_WINDINGFILL;
            }

            WriteRecordHeader(dataSize, type, flags, deviceBounds);
            WriteInt32(EmfPlusStream, brushValue);
            WriteInt32(EmfPlusStream, count);
            pointData.WriteData(EmfPlusStream);
            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write FillPolygon record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordDrawLines.
*
* Arguments:
*
*   [IN]  deviceBounds - the bounding rect, in device units
*   [IN]  pen          - pen to draw with
*   [IN]  points       - polyline points
*   [IN]  count        - number of points
*   [IN]  closed       - TRUE if closed
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordDrawLines(
    const GpRectF *             deviceBounds,
    GpPen *                     pen,
    const GpPointF *            points,
    INT                         count,
    BOOL                        closed
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        ASSERT ((deviceBounds != NULL) && (pen != NULL) &&
                (points != NULL) && (count > 0));

        if (IsValid())
        {
            MetafilePointData   pointData(points, count);
            UINT32              metaPenId;
            UINT32              dataSize = sizeof(UINT32/* count */) +
                                           pointData.GetDataSize();
            EmfPlusRecordType   type     = EmfPlusRecordTypeDrawLines;
            INT                 flags    = pointData.GetFlags();

            RecordObject(pen, &metaPenId);
            ASSERT((metaPenId & (~GDIP_EPRFLAGS_METAOBJECTID)) == 0);
            flags |= metaPenId;

            if (closed)
            {
                flags |= GDIP_EPRFLAGS_CLOSED;
            }

            WriteRecordHeader(dataSize, type, flags, deviceBounds);
            WriteInt32(EmfPlusStream, count);
            pointData.WriteData(EmfPlusStream);
            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write DrawLines record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordFillEllipse.
*
* Arguments:
*
*   [IN]  deviceBounds - the bounding rect, in device units
*   [IN]  brush        - brush to draw with
*   [IN]  rect         - bounding rect of ellipse
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordFillEllipse(
    const GpRectF *             deviceBounds,
    GpBrush *                   brush,
    const GpRectF &             rect
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        ASSERT ((deviceBounds != NULL) && (brush != NULL));

        if (IsValid())
        {
            MetafileRectData    rectData(&rect, 1);
            UINT32              brushValue; // Metafile Brush Id or ARGB value
            UINT32              dataSize = sizeof(brushValue) +
                                           rectData.GetDataSize();
            EmfPlusRecordType   type     = EmfPlusRecordTypeFillEllipse;
            INT                 flags    = rectData.GetFlags();

            GetBrushValueForRecording(brush, brushValue, flags);

            WriteRecordHeader(dataSize, type, flags, deviceBounds);
            WriteInt32(EmfPlusStream, brushValue);
            rectData.WriteData(EmfPlusStream);
            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write FillEllipse record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordDrawEllipse.
*
* Arguments:
*
*   [IN]  deviceBounds - the bounding rect, in device units
*   [IN]  pen          - pen to draw with
*   [IN]  rect         - bounding rect of ellipse
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordDrawEllipse(
    const GpRectF *             deviceBounds,
    GpPen *                     pen,
    const GpRectF &             rect
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        ASSERT ((deviceBounds != NULL) && (pen != NULL));

        if (IsValid())
        {
            MetafileRectData    rectData(&rect, 1);
            UINT32              metaPenId;
            UINT32              dataSize = rectData.GetDataSize();
            EmfPlusRecordType   type     = EmfPlusRecordTypeDrawEllipse;
            INT                 flags    = rectData.GetFlags();

            RecordObject(pen, &metaPenId);
            ASSERT((metaPenId & (~GDIP_EPRFLAGS_METAOBJECTID)) == 0);
            flags |= metaPenId;

            WriteRecordHeader(dataSize, type, flags, deviceBounds);
            rectData.WriteData(EmfPlusStream);
            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write DrawEllipse record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordFillPie.
*
* Arguments:
*
*   [IN]  deviceBounds - the bounding rect, in device units
*   [IN]  brush        - brush to draw with
*   [IN]  rect         - bounding rect of ellipse
*   [IN]  startAngle   - starting angle of pie
*   [IN]  sweepAngle   - sweep angle of pie
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordFillPie(
    const GpRectF *             deviceBounds,
    GpBrush *                   brush,
    const GpRectF &             rect,
    REAL                        startAngle,
    REAL                        sweepAngle
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        ASSERT ((deviceBounds != NULL) && (brush != NULL));

        if (IsValid())
        {
            MetafileRectData    rectData(&rect, 1);
            UINT32              brushValue; // Metafile Brush Id or ARGB value
            UINT32              dataSize = sizeof(brushValue) +
                                           sizeof(startAngle) +
                                           sizeof(sweepAngle) +
                                           rectData.GetDataSize();
            EmfPlusRecordType   type     = EmfPlusRecordTypeFillPie;
            INT                 flags    = rectData.GetFlags();

            GetBrushValueForRecording(brush, brushValue, flags);

            WriteRecordHeader(dataSize, type, flags, deviceBounds);
            WriteInt32(EmfPlusStream, brushValue);
            WriteReal (EmfPlusStream, startAngle);
            WriteReal (EmfPlusStream, sweepAngle);
            rectData.WriteData(EmfPlusStream);
            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write FillPie record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordDrawPie.
*
* Arguments:
*
*   [IN]  deviceBounds - the bounding rect, in device units
*   [IN]  pen          - pen to draw with
*   [IN]  rect         - bounding rect of ellipse
*   [IN]  startAngle   - starting angle of pie
*   [IN]  sweepAngle   - sweep angle of pie
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordDrawPie(
    const GpRectF *             deviceBounds,
    GpPen *                     pen,
    const GpRectF &             rect,
    REAL                        startAngle,
    REAL                        sweepAngle
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        ASSERT ((deviceBounds != NULL) && (pen != NULL));

        if (IsValid())
        {
            MetafileRectData    rectData(&rect, 1);
            UINT32              metaPenId;
            UINT32              dataSize = sizeof(startAngle) +
                                           sizeof(sweepAngle) +
                                           rectData.GetDataSize();
            EmfPlusRecordType   type     = EmfPlusRecordTypeDrawPie;
            INT                 flags    = rectData.GetFlags();

            RecordObject(pen, &metaPenId);
            ASSERT((metaPenId & (~GDIP_EPRFLAGS_METAOBJECTID)) == 0);
            flags  |= metaPenId;

            WriteRecordHeader(dataSize, type, flags, deviceBounds);
            WriteReal (EmfPlusStream, startAngle);
            WriteReal (EmfPlusStream, sweepAngle);
            rectData.WriteData(EmfPlusStream);
            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write DrawPie record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordDrawArc.
*
* Arguments:
*
*   [IN]  deviceBounds - the bounding rect, in device units
*   [IN]  pen          - pen to draw with
*   [IN]  rect         - bounding rect of ellipse
*   [IN]  startAngle   - starting angle of arc
*   [IN]  sweepAngle   - sweep angle of arc
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordDrawArc(
    const GpRectF *             deviceBounds,
    GpPen *                     pen,
    const GpRectF &             rect,
    REAL                        startAngle,
    REAL                        sweepAngle
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        ASSERT ((deviceBounds != NULL) && (pen != NULL));

        if (IsValid())
        {
            MetafileRectData    rectData(&rect, 1);
            UINT32              metaPenId;
            UINT32              dataSize = sizeof(startAngle) +
                                           sizeof(sweepAngle) +
                                           rectData.GetDataSize();
            EmfPlusRecordType   type     = EmfPlusRecordTypeDrawArc;
            INT                 flags    = rectData.GetFlags();

            RecordObject(pen, &metaPenId);
            ASSERT((metaPenId & (~GDIP_EPRFLAGS_METAOBJECTID)) == 0);
            flags  |= metaPenId;

            WriteRecordHeader(dataSize, type, flags, deviceBounds);
            WriteReal (EmfPlusStream, startAngle);
            WriteReal (EmfPlusStream, sweepAngle);
            rectData.WriteData(EmfPlusStream);
            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write DrawArc record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordFillRegion.
*
* Arguments:
*
*   [IN]  deviceBounds - the bounding rect, in device units
*   [IN]  brush        - brush to draw with
*   [IN]  region       - region to fill
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordFillRegion(
    const GpRectF *             deviceBounds,
    GpBrush *                   brush,
    GpRegion *                  region
    )
{
    // The deviceBounds should never be infinite, because they are
    // intersected with the metafileBounds before being passed in.

    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        ASSERT ((deviceBounds != NULL) && (brush != NULL) && (region != NULL));

        if (IsValid())
        {
            UINT32              metaRegionId;
            UINT32              brushValue; // Metafile Brush Id or ARGB value
            UINT32              dataSize = sizeof(brushValue);
            EmfPlusRecordType   type     = EmfPlusRecordTypeFillRegion;
            INT                 flags    = 0;

            GetBrushValueForRecording(brush, brushValue, flags);

            RecordObject(region, &metaRegionId);
            ASSERT((metaRegionId & (~GDIP_EPRFLAGS_METAOBJECTID)) == 0);
            flags |= metaRegionId;

            WriteRecordHeader(dataSize, type, flags, deviceBounds);
            WriteInt32(EmfPlusStream, brushValue);
            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write FillRegion record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordFillPath.
*
* Arguments:
*
*   [IN]  deviceBounds - the bounding rect, in device units
*   [IN]  brush        - brush to draw with
*   [IN]  path         - path to fill
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordFillPath(
    const GpRectF *             deviceBounds,
    const GpBrush *                   brush,
    GpPath *                    path
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        ASSERT ((deviceBounds != NULL) && (brush != NULL) && (path != NULL));

        if (IsValid())
        {
            UINT32              metaPathId;
            UINT32              brushValue; // Metafile Brush Id or ARGB value
            UINT32              dataSize = sizeof(brushValue);
            EmfPlusRecordType   type     = EmfPlusRecordTypeFillPath;
            INT                 flags    = 0;

            GetBrushValueForRecording(brush, brushValue, flags);

            RecordObject(path, &metaPathId);
            ASSERT((metaPathId & (~GDIP_EPRFLAGS_METAOBJECTID)) == 0);
            flags |= metaPathId;

            WriteRecordHeader(dataSize, type, flags, deviceBounds);
            WriteInt32(EmfPlusStream, brushValue);
            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write FillPath record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordDrawPath.
*
* Arguments:
*
*   [IN]  deviceBounds - the bounding rect, in device units
*   [IN]  pen          - pen to draw with
*   [IN]  path         - path to draw
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordDrawPath(
    const GpRectF *             deviceBounds,
    GpPen *                     pen,
    GpPath *                    path
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        ASSERT ((deviceBounds != NULL) && (pen != NULL) && (path != NULL));

        if (IsValid())
        {
            UINT32              metaPathId;
            UINT32              metaPenId;
            UINT32              dataSize = sizeof(metaPenId);
            EmfPlusRecordType   type     = EmfPlusRecordTypeDrawPath;
            INT                 flags    = 0;

            RecordObject(pen, &metaPenId);

            RecordObject(path, &metaPathId);
            ASSERT((metaPathId & (~GDIP_EPRFLAGS_METAOBJECTID)) == 0);
            flags  |= metaPathId;

            WriteRecordHeader(dataSize, type, flags, deviceBounds);
            WriteInt32(EmfPlusStream, metaPenId);
            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write DrawPath record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordFillClosedCurve.
*
* Arguments:
*
*   [IN]  deviceBounds - the bounding rect, in device units
*   [IN]  brush        - brush to draw with
*   [IN]  points       - curve points
*   [IN]  count        - number of points
*   [IN]  tension      - how tight to make curve
*   [IN]  fillMode     - Alternate or Winding
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordFillClosedCurve(
    const GpRectF *             deviceBounds,
    GpBrush *                   brush,
    const GpPointF *            points,
    INT                         count,
    REAL                        tension,
    GpFillMode                  fillMode
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        ASSERT ((deviceBounds != NULL) && (brush != NULL) &&
                (points != NULL) && (count > 0));

        if (IsValid())
        {
            MetafilePointData   pointData(points, count);
            UINT32              brushValue; // Metafile Brush Id or ARGB value
            UINT32              dataSize = sizeof(brushValue) +
                                           sizeof(tension) +
                                           sizeof(UINT32 /* count */) +
                                           pointData.GetDataSize();
            EmfPlusRecordType   type     = EmfPlusRecordTypeFillClosedCurve;
            INT                 flags    = pointData.GetFlags();

            GetBrushValueForRecording(brush, brushValue, flags);

            if (fillMode == FillModeWinding)
            {
                flags |= GDIP_EPRFLAGS_WINDINGFILL;
            }

            WriteRecordHeader(dataSize, type, flags, deviceBounds);
            WriteInt32(EmfPlusStream, brushValue);
            WriteReal (EmfPlusStream, tension);
            WriteInt32(EmfPlusStream, count);
            pointData.WriteData(EmfPlusStream);
            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write FillClosedCurve record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordDrawClosedCurve.
*
* Arguments:
*
*   [IN]  deviceBounds - the bounding rect, in device units
*   [IN]  pen          - pen to draw with
*   [IN]  points       - curve points
*   [IN]  count        - number of points
*   [IN]  tension      - how tight to make curve
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordDrawClosedCurve(
    const GpRectF *             deviceBounds,
    GpPen *                     pen,
    const GpPointF *            points,
    INT                         count,
    REAL                        tension
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        ASSERT ((deviceBounds != NULL) && (pen != NULL) &&
                (points != NULL) && (count > 0));

        if (IsValid())
        {
            MetafilePointData   pointData(points, count);
            UINT32              metaPenId;
            UINT32              dataSize = sizeof(tension) +
                                           sizeof(UINT32/* count */) +
                                           pointData.GetDataSize();
            EmfPlusRecordType   type     = EmfPlusRecordTypeDrawClosedCurve;
            INT                 flags    = pointData.GetFlags();

            RecordObject(pen, &metaPenId);
            ASSERT((metaPenId & (~GDIP_EPRFLAGS_METAOBJECTID)) == 0);
            flags  |= metaPenId;

            WriteRecordHeader(dataSize, type, flags, deviceBounds);
            WriteReal (EmfPlusStream, tension);
            WriteInt32(EmfPlusStream, count);
            pointData.WriteData(EmfPlusStream);
            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write DrawClosedCurve record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordDrawCurve.
*
* Arguments:
*
*   [IN]  deviceBounds     - the bounding rect, in device units
*   [IN]  pen              - pen to draw with
*   [IN]  points           - curve points
*   [IN]  count            - number of points
*   [IN]  tension          - how tight to make curve
*   [IN]  offset           - offset
*   [IN]  numberOfSegments - number of segments
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordDrawCurve(
    const GpRectF *             deviceBounds,
    GpPen *                     pen,
    const GpPointF *            points,
    INT                         count,
    REAL                        tension,
    INT                         offset,
    INT                         numberOfSegments
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        ASSERT ((deviceBounds != NULL) && (pen != NULL) &&
                (points != NULL) && (count > 0));

        if (IsValid())
        {
            MetafilePointData   pointData(points, count);
            UINT32              metaPenId;
            UINT32              dataSize = sizeof(tension) +
                                           sizeof(INT32 /* offset */) +
                                           sizeof(UINT32/* numberOfSegments */) +
                                           sizeof(UINT32/* count */) +
                                           pointData.GetDataSize();
            EmfPlusRecordType   type     = EmfPlusRecordTypeDrawCurve;
            INT                 flags    = pointData.GetFlags();

            RecordObject(pen, &metaPenId);
            ASSERT((metaPenId & (~GDIP_EPRFLAGS_METAOBJECTID)) == 0);
            flags  |= metaPenId;

            WriteRecordHeader(dataSize, type, flags, deviceBounds);
            WriteReal (EmfPlusStream, tension);
            WriteInt32(EmfPlusStream, offset);
            WriteInt32(EmfPlusStream, numberOfSegments);
            WriteInt32(EmfPlusStream, count);
            pointData.WriteData(EmfPlusStream);
            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write DrawCurve record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordDrawBeziers.
*
* Arguments:
*
*   [IN]  deviceBounds     - the bounding rect, in device units
*   [IN]  pen              - pen to draw with
*   [IN]  points           - curve points
*   [IN]  count            - number of points
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordDrawBeziers(
    const GpRectF *             deviceBounds,
    GpPen *                     pen,
    const GpPointF *            points,
    INT                         count
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        ASSERT ((deviceBounds != NULL) && (pen != NULL) &&
                (points != NULL) && (count > 0));

        if (IsValid())
        {
            MetafilePointData   pointData(points, count);
            UINT32              metaPenId;
            UINT32              dataSize = sizeof(UINT32/* count */) +
                                           pointData.GetDataSize();
            EmfPlusRecordType   type     = EmfPlusRecordTypeDrawBeziers;
            INT                 flags    = pointData.GetFlags();

            RecordObject(pen, &metaPenId);
            ASSERT((metaPenId & (~GDIP_EPRFLAGS_METAOBJECTID)) == 0);
            flags  |= metaPenId;

            WriteRecordHeader(dataSize, type, flags, deviceBounds);
            WriteInt32(EmfPlusStream, count);
            pointData.WriteData(EmfPlusStream);
            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write DrawBeziers record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordDrawImage.
*
* Arguments:
*
*   [IN]  deviceBounds     - the bounding rect, in device units
*   [IN]  image            - image to draw
*   [IN]  destRect         - where to draw image
*   [IN]  srcRect          - portion of image to draw
*   [IN]  srcUnit          - units of srcRect
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordDrawImage(
    const GpRectF *             deviceBounds,
    const GpImage *             image,
    const GpRectF &             destRect,
    const GpRectF &             srcRect,
    GpPageUnit                  srcUnit,
    const GpImageAttributes *         imageAttributes
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        ASSERT ((deviceBounds != NULL) && (image != NULL));

        if (IsValid())
        {
            MetafileRectData    rectData(&destRect, 1);
            UINT32              metaImageId;
            UINT32              metaImageAttributesId;

            UINT32              dataSize = sizeof(INT32) +   /* metaImageAttributesId*/
                                           sizeof(INT32) +   /* srcUnit */
                                           sizeof(srcRect) +
                                           rectData.GetDataSize();
            EmfPlusRecordType   type     = EmfPlusRecordTypeDrawImage;
            INT                 flags    = rectData.GetFlags();

            RecordObject(image, &metaImageId);
            ASSERT((metaImageId & (~GDIP_EPRFLAGS_METAOBJECTID)) == 0);
            flags  |= metaImageId;

            // Record the imageAttributes;
            // imageAttributes can be NULL

            RecordObject(imageAttributes, &metaImageAttributesId);

            WriteRecordHeader(dataSize, type, flags, deviceBounds);
            WriteInt32(EmfPlusStream, metaImageAttributesId);
            WriteInt32(EmfPlusStream, srcUnit);
            WriteRect (EmfPlusStream, srcRect);
            rectData.WriteData(EmfPlusStream);
            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write DrawImage record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordDrawImage.
*
* Arguments:
*
*   [IN]  deviceBounds     - the bounding rect, in device units
*   [IN]  image            - image to draw
*   [IN]  destPoints       - where to draw image
*   [IN]  count            - number of destPoints
*   [IN]  srcRect          - portion of image to draw
*   [IN]  srcUnit          - units of srcRect
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordDrawImage(
    const GpRectF *             deviceBounds,
    const GpImage *             image,
    const GpPointF *            destPoints,
    INT                         count,
    const GpRectF &             srcRect,
    GpPageUnit                  srcUnit,
    const GpImageAttributes *         imageAttributes
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        ASSERT ((deviceBounds != NULL) && (image != NULL) &&
                (destPoints != NULL) && (count > 0));

        if (IsValid())
        {
            MetafilePointData   pointData(destPoints, count);
            UINT32              metaImageId;
            UINT32              metaImageAttributesId;

            UINT32              dataSize = sizeof(INT32) +   /* metaImageAttributesId*/
                                           sizeof(INT32) +   /* srcUnit */
                                           sizeof(srcRect) +
                                           sizeof(UINT32) +  /* count */
                                           pointData.GetDataSize();
            EmfPlusRecordType   type     = EmfPlusRecordTypeDrawImagePoints;
            INT                 flags    = pointData.GetFlags();

            RecordObject(image, &metaImageId);
            ASSERT((metaImageId & (~GDIP_EPRFLAGS_METAOBJECTID)) == 0);
            flags |= metaImageId;

            // Record the imageAttributes;
            // imageAttributes can be NULL

            RecordObject(imageAttributes, &metaImageAttributesId);

            WriteRecordHeader(dataSize, type, flags, deviceBounds);
            WriteInt32(EmfPlusStream, metaImageAttributesId);
            WriteInt32(EmfPlusStream, srcUnit);
            WriteRect (EmfPlusStream, srcRect);
            WriteInt32(EmfPlusStream, count);
            pointData.WriteData(EmfPlusStream);
            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write DrawImagePoints record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordDrawString.
*
* Arguments:
*
*   [IN]  string           - string to draw
*   [IN]  length           - length of string
*   [IN]  font             - font to use when drawing string
*   [IN]  layoutRect       - where to draw the string
*   [IN]  format           - format
*   [IN]  brush            - brush to draw with
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordDrawString(
    const GpRectF *             deviceBounds,
    const WCHAR                *string,
    INT                         length,
    const GpFont               *font,
    const RectF                *layoutRect,
    const GpStringFormat       *format,
    const GpBrush              *brush
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        ASSERT (string && font && brush && layoutRect);

        if (length < 0)
        {
            if (length == -1)
            {
                length = 0;
                while (string[length] && (length < INT_MAX))
                {
                    length++;
                }
            }
            else
            {
                return InvalidParameter;
            }
        }

        ASSERT (length > 0);

        if (IsValid())
        {
            const BYTE *        strData    = (BYTE *)string;    // BYTE or WCHAR
            INT                 sizeString = length * sizeof(WCHAR);
            INT                 flags      = 0;

            // !!! TODO:
            // Compress the Unicode string.
            // Use the GDIP_EPRFLAGS_COMPRESSED to indicate that
            // the string has been compressed to ANSI.

            UINT32              metaFontId;
            UINT32              metaFormatId;
            UINT32              brushValue; // Metafile Brush Id or ARGB value
            UINT32              dataSize = sizeof(brushValue) +
                                           sizeof(metaFormatId) +
                                           sizeof(INT32 /* len */) +
                                           sizeof(*layoutRect) +
                                           sizeString;
            EmfPlusRecordType   type     = EmfPlusRecordTypeDrawString;

            dataSize = (dataSize + 3) & (~3);    // align

            RecordObject(font, &metaFontId);
            ASSERT((metaFontId & (~GDIP_EPRFLAGS_METAOBJECTID)) == 0);
            flags |= metaFontId;

            // the format can be NULL
            RecordObject(format, &metaFormatId);

            GetBrushValueForRecording(brush, brushValue, flags);
            WriteRecordHeader(dataSize, type, flags, deviceBounds);
            WriteInt32(EmfPlusStream, brushValue);
            WriteInt32(EmfPlusStream, metaFormatId);
            WriteInt32(EmfPlusStream, length);
            WriteRect (EmfPlusStream, *layoutRect);
            WriteBytes(EmfPlusStream, strData, sizeString);

            // align
            if ((length & 0x01) != 0)
            {
                length = 0;
                EmfPlusStream->Write(&length, sizeof(WCHAR), NULL);
            }

            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write DrawString record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordDrawdriverString.
*
* Arguments:
*
*   [IN]  text              - string/glyphs
*   [IN]  glyphCount        - string length
*   [IN]  font              - font to use when drawing string
*   [IN]  brush             - brush to draw with
*   [IN]  positions         - character/glyphs origins
*   [IN]  flags             - API flags
*   [IN]  matrix            - transofrmation matrix
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   7/11/2000 Tarekms
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordDrawDriverString(
    const GpRectF       *deviceBounds,
    const UINT16        *text,
    INT                  glyphCount,
    const GpFont        *font,
    const GpBrush       *brush,
    const PointF        *positions,
    INT                  flags,
    const GpMatrix      *matrix
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        ASSERT (text && font && brush && positions);

        if (glyphCount <= 0)
        {
            return InvalidParameter;
        }

        if (IsValid())
        {
            const BYTE *        textData      = (BYTE *)text;
            const BYTE *        positionData  = (BYTE *)positions;
            INT                 sizeText      = glyphCount * sizeof(UINT16);
            INT                 sizePositions = glyphCount * sizeof(PointF);
            INT                 metaFlags     = 0;

            UINT32              metaFontId;
            UINT32              brushValue; // Metafile Brush Id or ARGB value
            UINT32              matrixPresent;
            UINT32              dataSize = sizeof(brushValue)   + // brush value
                                           sizeof(flags)        + // API flags
                                           sizeof(matrixPresent)+ // matix prensences
                                           sizeof(UINT32)       + // glyphCoumt
                                           sizeText             + // Text
                                           sizePositions;         // Positions
            if (matrix == NULL)
            {
                matrixPresent = 0;
            }
            else
            {
                matrixPresent = 1;
                dataSize += GDIP_MATRIX_SIZE;
            }

            EmfPlusRecordType   type     = EmfPlusRecordTypeDrawDriverString;

            dataSize = (dataSize + 3) & (~3);    // align

            RecordObject(font, &metaFontId);
            ASSERT((metaFontId & (~GDIP_EPRFLAGS_METAOBJECTID)) == 0);
            metaFlags |= metaFontId;

            GetBrushValueForRecording(brush, brushValue, metaFlags);
            WriteRecordHeader(dataSize, type, metaFlags, deviceBounds);
            WriteInt32(EmfPlusStream, brushValue);
            W