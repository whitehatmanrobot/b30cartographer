ill be -128 >= value >= 127), so we
    // just need to make sure that we have the right high bit set.
    //
    // But this must be the case for a 16-bit equivalent of an 8-bit
    // number.  No problems - just take the truncated integer.
    //
    //
    // Make sure that the destination field length is larger or equal to
    // the source field length.  If it isn't, something has gone wrong.
    //
    if (srcFieldLength < destFieldLength)
    {
        ERROR_OUT(( "Source field length %d is smaller than destination %d",
                     srcFieldLength,
                     destFieldLength));
        DC_QUIT;
    }

    //
    // If the source and destination field lengths are the same, we can
    // just do a copy (no type conversion required).
    //
    if (srcFieldLength == destFieldLength)
    {
        memcpy(*ppDest, pSrc, destFieldLength * numElements);
    }
    else
    {
        //
        // We know that srcFieldLength must be greater than destFieldLength
        // because of our checks above.  So there are only three
        // conversions to consider:
        //
        //   16 bit ->  8 bit
        //   32 bit ->  8 bit
        //   32 bit -> 16 bit
        //
        // We can ignore the sign as all we are ever doing is truncating
        // the integer.
        //
        if ((srcFieldLength == 4) && (destFieldLength == 1))
        {
            CONVERT_ARRAY(pDest8Signed,
                          pSrc32Signed,
                          TSHR_INT8,
                          numElements);
        }
        else if ((srcFieldLength == 4) && (destFieldLength == 2))
        {
            CONVERT_ARRAY(pDest16Signed,
                          pSrc32Signed,
                          TSHR_INT16,
                          numElements);
        }
        else if ((srcFieldLength == 2) && (destFieldLength == 1))
        {
            CONVERT_ARRAY(pDest8Signed,
                          pSrc16Signed,
                          TSHR_INT8,
                          numElements);
        }
        else
        {
            ERROR_OUT(( "Bad conversion, dest length = %d, src length = %d",
                         destFieldLength,
                         srcFieldLength));
        }
    }

DC_EXIT_POINT:
    *ppDest += destFieldLength * numElements;
    DebugExitVOID(OE2EncodeField);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\pm.cpp ===
#include "precomp.h"


//
// PM.CPP
// Palette Manager
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE

//
//
// PALETTE MANAGER (PM) OVERVIEW
//
// Palette Manager is responsible for sending palette packets.  A palette
// packet:
//
// (1) indicates the colors being used on the host machine - and therefore
// specifies which colors the remote machine should use if it can choose
// (e.g.  by selecting and realizing the given colors into the display
// hardware).  [A palette packet may not contain the exact colors being
// used on the host if the protocol bpp is different from the host bpp].
//
// (2) specifies the colors which correspond to the values in bitmap
// (screen) data i.e.  the values in 4bpp and 8bpp bitmap data are indices
// into the table of colors sent in the palette packet.
//
//
// (1) affects order replay and (2) affects screen data replay, so a
// correct palette packet must be sent (by calling
// PM_MaybeSendPalettePacket) before a batch of updates are sent.
//
// Palette Manager also handles incoming palette packets from other parties
// in the conference and creates corresponding local palettes which the
// Update Receiver can query and use when processing updates.
//
// When a new palette packet is sent (e.g.  due to the System Palette
// changing), all shared areas of the screen will be retransmitted in due
// course.  A receiving Palette Manager therefore does not have to (and
// should not attempt to) convert any updates/bitmaps that have been
// received prior to the arrival of the new palette packet.
//
//

//
// PM strategy when network packets cannot be allocated.
//
// PM_MaybeSendPalettePacket returns a boolean indicating whether it has
// succesfully sent a palette packet.  The USR will only send updates if
// the corresponding palette packet is successfully sent.
//
//


const COLORREF s_apmGreyRGB[PM_GREY_COUNT] =
{
    PM_GREY1,
    PM_GREY2,
    PM_GREY3,
    PM_GREY4,
    PM_GREY5
};



//
// PM_PartyLeftShare()
//
void  ASShare::PM_PartyLeftShare(ASPerson * pasPerson)
{
    DebugEntry(ASShare::PM_PartyLeftShare);

    ValidatePerson(pasPerson);

    if (pasPerson->cpcCaps.general.version >= CAPS_VERSION_30)
    {
        // This should be cleared already!
        ASSERT(!pasPerson->pmcColorTable);
        ASSERT(!pasPerson->apmColorTable);
        ASSERT(!pasPerson->pmPalette);
    }
    else
    {
        TRACE_OUT(("PM_PartyLeftShare:  Freeing pm data for 2.x node [%d]",
            pasPerson->mcsID));
        PMFreeIncoming(pasPerson);
    }

    //
    // NOTE:  In 2.1, we didn't renegotiate the outgoing cache size when
    // somebody left.  So we don't now either (this is all 2.x compat stuff
    // anyway).
    //

    DebugExitVOID(ASShare::PM_PartyLeftShare);
}



//
// PM_RecalcCaps()
//
// This calculates the PM hosting caps when
//      * we start to host
//      * we're hosting and somebody joins the share
//      * we're hosting and somebody leaves the share
//
// This can GO AWAY WHEN 2.x COMPAT IS GONE -- no more min() of cache size
//
void  ASShare::PM_RecalcCaps(BOOL fJoiner)
{
    ASPerson *  pasT;

    DebugEntry(ASShare::PM_RecalcCaps);

    if (!m_pHost || !fJoiner)
    {
        //
        // Nothing to do if we're not hosting.  And also, if somebody has
        // left, no recalculation -- 2.x didn't.
        //
        DC_QUIT;
    }

    ValidatePerson(m_pasLocal);

    //
    // NOTE:
    // The default size is 6 palettes cached.  The result is going to be
    // <= that number.  There's no point in recreating the cache, it's
    // so small.
    //
    m_pHost->m_pmNumTxCacheEntries = m_pasLocal->cpcCaps.palette.capsColorTableCacheSize;

    if (m_scShareVersion < CAPS_VERSION_30)
    {
        TRACE_OUT(("In share with 2.x nodes, must recalc PM caps"));

        for (pasT = m_pasLocal->pasNext; pasT != NULL; pasT = pasT->pasNext)
        {
            m_pHost->m_pmNumTxCacheEntries = min(m_pHost->m_pmNumTxCacheEntries,
                pasT->cpcCaps.palette.capsColorTableCacheSize);
        }

        TRACE_OUT(("Recalced PM caps:  Tx Cache size %d",
            m_pHost->m_pmNumTxCacheEntries));
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::PM_Recalccaps);
}


//
// PM_HostStarting()
//
// Called when we start to host; sets up color palette stuff and creates
// outgoing palette cache
//
BOOL  ASHost::PM_HostStarting(void)
{
    BOOL    rc = FALSE;
    TSHR_COLOR  localPalColors[PM_NUM_8BPP_PAL_ENTRIES];

    DebugEntry(ASHost::PM_HostStarting);

    //
    // Get palette caps.  NOTE PM_RecalcCaps must be called AFTER
    // USR_RecalcCaps(), because that updates m_usrSendingBPP.
    //
    if (g_usrPalettized)
    {
        ASSERT(g_usrScreenBPP <= 8);

        ZeroMemory(localPalColors, sizeof(localPalColors));

        //
        // Now create the Local Palette.
        //
        if (!m_pShare->PM_CreatePalette(COLORS_FOR_BPP(g_usrScreenBPP),
                localPalColors, &m_pmTxPalette))
        {
            ERROR_OUT(( "Failed to create Local Palette"));
            DC_QUIT;
        }
    }
    else
    {
        m_pmTxPalette = (HPALETTE)GetStockObject(DEFAULT_PALETTE);
        PMGetGrays();
    }

    //
    // With NM 3.0, why not just create a receive cache the size that
    // the host specifies in his caps?
    //
    // So I did that.  For back compat, OUTGOING caches use the min size.
    // When we only have to be compatible with NM 3.0 and up, we won't
    // have to do this min stuff.
    //
    // Note similar code in CM, SSI, and SBC
    //

    // Figure out how many outgoing entries we can actually use
    m_pShare->PM_RecalcCaps(TRUE);

    //
    // Create the PM color table cache with a single eviction
    // category.
    //
    if (!CH_CreateCache(&m_pmTxCacheHandle, TSHR_PM_CACHE_ENTRIES,
            1, 0, PMCacheCallback))
    {
        ERROR_OUT(("Could not create PM cache"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASHost::PM_HostStarting, rc);
    return(rc);
}



//
// PM_HostEnded()
//
// We free resources created when we started to host
//
void  ASHost::PM_HostEnded(void)
{
    DebugEntry(ASHost::PM_HostEnded);

    if (m_pmTxPalette)
    {
        m_pShare->PM_DeletePalette(m_pmTxPalette);
        m_pmTxPalette = NULL;
    }

    if (m_pmTxCacheHandle)
    {
        CH_DestroyCache(m_pmTxCacheHandle);
        m_pmTxCacheHandle = 0;
        m_pmNumTxCacheEntries = 0;
    }

    DebugExitVOID(ASHost::PM_HostEnded);
}



//
// PM_ViewStarting()
//
// For 3.0 nodes, we create the PM cache each time they start hosting
// For 2.x nodes, we create the PM cache once and use it until they leave
//      the share.
//
BOOL  ASShare::PM_ViewStarting(ASPerson * pasPerson)
{
    BOOL    rc = FALSE;

    DebugEntry(ASShare::PM_ViewStarting);

    ValidatePerson(pasPerson);

    if (pasPerson->pmcColorTable != 0)
    {
        ASSERT(pasPerson->apmColorTable != NULL);
        ASSERT(pasPerson->pmPalette != NULL);

        ASSERT(pasPerson->cpcCaps.general.version < CAPS_VERSION_30);

        TRACE_OUT(("PM_ViewStarting  Reusing pm data for 2.x node [%d]",
            pasPerson->mcsID));
        rc = TRUE;
        DC_QUIT;
    }

    //
    // In normal operation, we will receive a palette packet from the host
    // before any updates, which we use to create the correct palette for
    // this host.
    //
    // However, in some back-level calls we may not receive a palette
    // packet before the first updates, so we initialize this host's
    // palette to the default palette to allow us to generate some sort
    // of output.
    //
    pasPerson->pmPalette = (HPALETTE)GetStockObject(DEFAULT_PALETTE);

    //
    // Allocate color table cache memory based on the negotiated options
    // Space needed is (n)x256xRGBQUAD where n is the number of color
    // tables the conference supports.
    //
    pasPerson->pmcColorTable = pasPerson->cpcCaps.palette.capsColorTableCacheSize;

    if (!pasPerson->pmcColorTable)
    {
        WARNING_OUT(("PM_ViewStarting: person [%d] has no palette cache size",
            pasPerson->cpcCaps.palette.capsColorTableCacheSize));
        rc = TRUE;
        DC_QUIT;
    }

    pasPerson->apmColorTable = new COLORTABLECACHE[pasPerson->pmcColorTable];
    if (!pasPerson->apmColorTable)
    {
        ERROR_OUT(( "Failed to get memory for PM color table cache"));
        DC_QUIT;
    }

    ZeroMemory(pasPerson->apmColorTable, pasPerson->pmcColorTable * sizeof(COLORTABLECACHE));

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::PM_ViewStarting, rc);
    return(rc);
}



//
// PM_ViewEnded()
//
void  ASShare::PM_ViewEnded(ASPerson * pasPerson)
{
    DebugEntry(ASShare::PM_ViewEnded);

    ValidatePerson(pasPerson);

    //
    // For 3.0 nodes, we can free the palette cache; 3.0 senders clear theirs
    //      every time they host.
    // For 2.x nodes, we must keep it around while they are in the share since
    //      they use it across sharing/unsharing/sharing again.
    //
    if (pasPerson->cpcCaps.general.version >= CAPS_VERSION_30)
    {
        PMFreeIncoming(pasPerson);
    }
    else
    {
        TRACE_OUT(("PM_PartyViewEnded:  Keeping pm data for 2.x node [%d]",
            pasPerson->mcsID));
    }

    DebugExitVOID(ASShare::PM_PartyViewEnded);
}



//
// PMFreeIncoming()
//
void ASShare::PMFreeIncoming(ASPerson * pasPerson)
{
    DebugEntry(ASShare::PMFreeIncoming);

    //
    // Free the color table cache
    //
    pasPerson->pmcColorTable = 0;
    if (pasPerson->apmColorTable)
    {
        delete[] pasPerson->apmColorTable;
        pasPerson->apmColorTable = NULL;
    }

    if (pasPerson->pmPalette != NULL)
    {
        //
        // Free this host's palette.  and set it to NULL so that we can tell
        // that this host has left the share.
        //
        PM_DeletePalette(pasPerson->pmPalette);
        pasPerson->pmPalette = NULL;
    }

    DebugExitVOID(ASShare::PMFreeIncoming);
}

//
// PM_MaybeSendPalettePacket()
//
BOOL  ASHost::PM_MaybeSendPalettePacket(void)
{
    BOOL  rc = TRUE;

    DebugEntry(ASHost::PM_MaybeSendPalettePacket);

    if (m_pmMustSendPalette)
    {
        ASSERT(m_usrSendingBPP <= 8);

        //
        // Ensure that our palette colors are up to date before we send the
        // palette packet.
        //
        if (g_usrPalettized)
        {
            PMUpdateSystemPaletteColors();
        }

        PMUpdateTxPaletteColors();
    }
    else if (g_usrPalettized)
    {
        ASSERT(m_usrSendingBPP <= 8);

        //
        // If the System Palette has changed then we may need to send
        // another palette packet.
        //
        if (PMUpdateSystemPaletteColors())
        {
            //
            // The System Palette has changed, but we only need to send
            // another palette packet if the palette colors have changed.
            //
            TRACE_OUT(( "System Palette changed"));

            if (PMUpdateTxPaletteColors())
            {
                TRACE_OUT(( "Tx Palette changed"));
                m_pmMustSendPalette = TRUE;
            }
        }
    }

    if (m_pmMustSendPalette)
    {
        ASSERT(m_usrSendingBPP <= 8);

        TRACE_OUT(( "Send palette packet"));

        rc = PMSendPalettePacket(m_apmTxPaletteColors, COLORS_FOR_BPP(m_usrSendingBPP));

        if (rc)
        {
            m_pmMustSendPalette = FALSE;
        }
    }

    DebugExitBOOL(ASHost::PM_MaybeSendPalettePacket, rc);
    return(rc);
}


//
// PM_ReceivedPacket
//
void  ASShare::PM_ReceivedPacket
(
    ASPerson *      pasPerson,
    PS20DATAPACKET  pPacket
)
{
    PPMPACKET       pPMPacket;
    HPALETTE        newPalette    = NULL;

    DebugEntry(ASShare::PM_ReceivedPacket);

    ValidateView(pasPerson);

    pPMPacket = (PPMPACKET)pPacket;

    //
    // Create a new palette from the received packet.
    //
    // We cannot just update the current palette colors (using
    // SetPaletteEntries) because Windows does not handle the repainting
    // of other local Palette Manager apps correctly (it does not
    // broadcast the WM_PALETTE.. messages as the palette mapping does
    // not change).
    //
    if (PM_CreatePalette(pPMPacket->numColors, pPMPacket->aColors,
            &newPalette))
    {
        PM_DeletePalette(pasPerson->pmPalette);
        pasPerson->pmPalette = newPalette;

        TRACE_OUT(( "Created new palette 0x%08x from packet", newPalette));
    }
    else
    {
        WARNING_OUT(( "Failed to create palette. person(%u) numColors(%u)",
            pasPerson, pPMPacket->numColors));
    }


    DebugExitVOID(ASShare::PM_ReceivedPacket);
}


//
// PM_SyncOutgoing()
//
void  ASHost::PM_SyncOutgoing(void)
{
    DebugEntry(ASHost::PM_SyncOutgoing);

    //
    //  Ensure we send a palette to the remote PM next time we are called.
    //
    if (m_usrSendingBPP <= 8)
    {
        m_pmMustSendPalette = TRUE;

        //
        // The sync discards any as-yet-unsent accumulated orders. Since these
        // orders may include color table cache orders, clear the cache.
        //
        ASSERT(m_pmTxCacheHandle);
        CH_ClearCache(m_pmTxCacheHandle);
    }

    DebugExitVOID(ASHost::PM_SyncOutgoing);
}


//
// PM_CacheTxColorTable
//
BOOL  ASHost::PM_CacheTxColorTable
(
    LPUINT          pIndex,
    LPBOOL          pCacheChanged,
    UINT            cColors,
    LPTSHR_RGBQUAD  pColors
)
{
    BOOL                rc             = FALSE;
    UINT                cacheIndex     = 0;
    UINT                i              = 0;
    PCOLORTABLECACHE    pEntry         = NULL;
    COLORTABLECACHE     newEntry       = { 0 };

    DebugEntry(ASHost::PM_CacheTxColorTable);

    ASSERT(m_usrSendingBPP <= 8);
    ASSERT(m_pmTxCacheHandle);

    TRACE_OUT(( "Caching table of %u colors", cColors));

    //
    // Create the data we want to cache.  It may be that there is already
    // an entry in the cache for this set of colors, but we still need to
    // create a cache entry in local memory so we can search the cache to
    // find out.
    //
    ZeroMemory(&newEntry, sizeof(COLORTABLECACHE));

    newEntry.inUse = TRUE;
    newEntry.cColors = cColors;
    memcpy(&newEntry.colors, pColors, cColors * sizeof(TSHR_RGBQUAD));

    //
    // Check to see if the table is already cached. (No hint or eviction
    // category.)
    //
    if (CH_SearchCache(m_pmTxCacheHandle, (LPBYTE)(&newEntry),
            sizeof(COLORTABLECACHE), 0, &cacheIndex ))
    {
        TRACE_OUT(( "Found existing entry at %u",cacheIndex));
        *pIndex = cacheIndex;
        *pCacheChanged = FALSE;
        rc = TRUE;
        DC_QUIT;
    }

    //
    // Find a free cache entry
    //
    // We arrange that our transmit cache is always one greater than the
    // negotiated cache size so that we should never fail to find a free
    // array entry.  Once we have fully populated our Tx cache we will
    // always find the free entry as the one last given back to us by CH.
    // Note the scan to <= m_pmNumTxCacheEntries is NOT a mistake.
    //
    if (m_pmNextTxCacheEntry != NULL)
    {
        pEntry = m_pmNextTxCacheEntry;
        m_pmNextTxCacheEntry = NULL;
    }
    else
    {
        for (i = 0; i <= m_pmNumTxCacheEntries; i++)
        {
            if (!m_apmTxCache[i].inUse)
            {
                break;
            }
        }

        //
        // We should never run out of free entries, but cope with it
        //
        if (i > m_pmNumTxCacheEntries)
        {
            ERROR_OUT(( "All PM cache entries in use"));
            rc = FALSE;
            DC_QUIT;
        }
        pEntry = m_apmTxCache + i;
    }


    //
    // Set up the color table in the free entry we just found
    //
    memcpy(pEntry, &newEntry, sizeof(COLORTABLECACHE));

    //
    // Add the new entry to the cache
    // We do not use hints or eviction so set to 0
    //
    cacheIndex = CH_CacheData(m_pmTxCacheHandle, (LPBYTE)pEntry,
        sizeof(COLORTABLECACHE), 0 );
    TRACE_OUT(( "Color table 0x%08x cached at index %u", pEntry, cacheIndex));
    *pIndex = cacheIndex;
    *pCacheChanged = TRUE;
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(ASHost::PM_CacheTxColorTable, rc);
    return(rc);
}


//
// PM_CacheRxColorTable
//
BOOL  ASShare::PM_CacheRxColorTable
(
    ASPerson *          pasPerson,
    UINT                index,
    UINT                cColors,
    LPTSHR_RGBQUAD      pColors
)
{
    BOOL                rc             = FALSE;
    PCOLORTABLECACHE    pColorTable;

    DebugEntry(ASShare::PM_CacheRxColorTable);

    ValidatePerson(pasPerson);

    pColorTable = pasPerson->apmColorTable;
    TRACE_OUT(( "Person [%d] color table rx cache 0x%08x cache %u, %u colors",
         pasPerson->mcsID, pColorTable, index, cColors));

    if (pColorTable == NULL)
    {
        ERROR_OUT(( "Asked to cache when no cache allocated"));
        DC_QUIT;
    }

    //
    // The index must be within the currently negotiated cache limits
    //
    if (index > pasPerson->pmcColorTable)
    {
        ERROR_OUT(( "Invalid color table index %u",index));
        DC_QUIT;
    }

    //
    // Set up the color table entry
    //
    pColorTable[index].inUse = TRUE;
    pColorTable[index].cColors = cColors;
    memcpy(pColorTable[index].colors, pColors, cColors * sizeof(TSHR_RGBQUAD));

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(ASShare::PM_CacheRxColorTable, rc);
    return(rc);
}



//
// PMSendPalettePacket
//
// DESCRIPTION:
//
// Sends a palette packet containing the given colors.
//
// PARAMETERS:
//
// pColorTable - pointer to an array of TSHR_RGBQUAD colors to be sent in the
// palette packet.
//
// numColors - the number of entries in the TSHR_RGBQUAD array
//
// RETURNS: TRUE if the palette packet is sent, FALSE otherwise
//
//
BOOL  ASHost::PMSendPalettePacket
(
    LPTSHR_RGBQUAD  pColorTable,
    UINT            numColors
)
{
    PPMPACKET       pPMPacket;
    UINT            sizePkt;
    UINT            i;
    BOOL            rc = FALSE;
#ifdef _DEBUG
    UINT            sentSize;
#endif // _DEBUG

    DebugEntry(ASHost::PMSendPalettePacket);

    //
    // Send a palette packet.
    //
    // First calculate the packet size.
    //
    sizePkt = sizeof(PMPACKET) + (numColors - 1) * sizeof(TSHR_COLOR);
    pPMPacket = (PPMPACKET)m_pShare->SC_AllocPkt(PROT_STR_UPDATES, g_s20BroadcastID, sizePkt);
    if (!pPMPacket)
    {
        WARNING_OUT(("Failed to alloc PM packet, size %u", sizePkt));
        DC_QUIT;
    }

    //
    // Fill in the packet contents.
    //
    pPMPacket->header.header.data.dataType  = DT_UP;
    pPMPacket->header.updateType            = UPD_PALETTE;

    //
    // Convert the TSHR_RGBQUADs in the color table to TSHR_COLORs as we copy
    // them into the packet.
    //
    pPMPacket->numColors = numColors;
    for (i = 0; i < numColors; i++)
    {
        //
        // Convert each RGBQuad entry in the color table to a DCColor.
        //
        TSHR_RGBQUAD_TO_TSHR_COLOR(pColorTable[i],
            pPMPacket->aColors[i]);
    }

    //
    // Now send the packet to the remote application.
    //
    if (m_pShare->m_scfViewSelf)
        m_pShare->PM_ReceivedPacket(m_pShare->m_pasLocal, &(pPMPacket->header.header));

#ifdef _DEBUG
    sentSize =
#endif // _DEBUG
    m_pShare->DCS_CompressAndSendPacket(PROT_STR_UPDATES, g_s20BroadcastID,
        &(pPMPacket->header.header), sizePkt);

    TRACE_OUT(("PM packet size: %08d, sent %08d", sizePkt, sentSize));

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(ASHost::PMSendPalettePacket, rc);
    return(rc);
}





//
// FUNCTION: PMCacheCallback
//
// DESCRIPTION:
//
// Cursor Manager's Cache Manager callback function.  Called whenever an
// entry is removed from the cache to allow us to free up the object.
//
// PARAMETERS:
//
// hCache - cache handle
//
// event - the cache event that has occured
//
// iCacheEntry - index of the cache entry that the event is affecting
//
// pData - pointer to the cache data associated with the given cache entry
//
// cbDataSize - size in bytes of the cached data
//
// RETURNS: Nothing
//
//
void  PMCacheCallback
(
    ASHost *    pHost,
    PCHCACHE    pCache,
    UINT        iCacheEntry,
    LPBYTE      pData
)
{
    DebugEntry(PMCacheCallback);


    //
    // Release the cache entry for reuse
    //
    TRACE_OUT(( "Releasing cache entry %d at 0x%08x",
            iCacheEntry, pData));
    pHost->m_pmNextTxCacheEntry = (PCOLORTABLECACHE)pData;
    pHost->m_pmNextTxCacheEntry->inUse = FALSE;

    //
    // Let SBC know that the cache entry has been released
    //
    pHost->SBC_PMCacheEntryRemoved(iCacheEntry);

    DebugExitVOID(PMCacheCallback);
}




//
// PM_GetSystemPaletteEntries
//
void  ASHost::PM_GetSystemPaletteEntries(LPTSHR_RGBQUAD pColors)
{
    UINT i;

    DebugEntry(ASHost::PM_GetSystemPaletteEntries);

    PMUpdateSystemPaletteColors();

    for (i = 0; i < PM_NUM_8BPP_PAL_ENTRIES; i++)
    {
        pColors[i].rgbRed       = m_apmCurrentSystemPaletteEntries[i].peRed;
        pColors[i].rgbGreen     = m_apmCurrentSystemPaletteEntries[i].peGreen;
        pColors[i].rgbBlue      = m_apmCurrentSystemPaletteEntries[i].peBlue;
        pColors[i].rgbReserved  = 0;
    }

    //
    // This function in its current form always returns TRUE - it is always
    // able to obtain the system colors.
    //
    DebugExitVOID(ASHost::PM_GetSystemPaletteEntries);
}


//
// PM_GetLocalPalette()
//
HPALETTE  ASHost::PM_GetLocalPalette(void)
{
    //
    // Ensure the palette is up to date
    //
    if (g_usrPalettized)
    {
        PMUpdateSystemPaletteColors();
    }

    //
    // Return the handle to the Local Palette.
    //
    return(m_pmTxPalette);
}



//
// PM_GetColorTable
//
void ASShare::PM_GetColorTable
(
    ASPerson *      pasPerson,
    UINT            index,
    LPUINT          pcColors,
    LPTSHR_RGBQUAD  pColors
)
{
    PCOLORTABLECACHE pColorTable;

    DebugEntry(ASShare::PM_GetColorTable);

    ValidatePerson(pasPerson);

    ASSERT(pasPerson->apmColorTable);

    pColorTable = &(pasPerson->apmColorTable[index]);
    TRACE_OUT(( "Color table requested for [%d], table ptr 0x%08x index %d",
            pasPerson->mcsID, pColorTable,index));

    if (!pColorTable->inUse)
    {
        ERROR_OUT(( "Asked for PM cache entry %hu when cache not yet in use",
                    index));
        DC_QUIT;
    }

    //
    // Copy the colors into the structure we have been passed
    //
    *pcColors = pColorTable->cColors;

    memcpy( pColors,
               pColorTable->colors,
               sizeof(TSHR_RGBQUAD) * pColorTable->cColors );

    TRACE_OUT(( "Returning %u colors",*pcColors));

DC_EXIT_POINT:
    DebugExitVOID(ASShare::PM_GetColorTable);
}





//
// PMADJUSTBUGGEDCOLOR()
//
// Macro used to tweak an 8 bit palette entry that the Win95 16 bit
// driver returns incorrectly
//
#define PMADJUSTBUGGEDCOLOR(pColor)                                          \
    if ( ((pColor)->rgbBlue != 0x00) &&                                      \
         ((pColor)->rgbBlue != 0xFF) )                                       \
    {                                                                        \
        (pColor)->rgbBlue += 0x40;                                           \
    }                                                                        \
                                                                             \
    if ( ((pColor)->rgbGreen != 0x00) &&                                     \
         ((pColor)->rgbGreen != 0xFF) )                                      \
    {                                                                        \
        (pColor)->rgbGreen += 0x20;                                          \
    }                                                                        \
                                                                             \
    if ( ((pColor)->rgbRed != 0x00) &&                                       \
         ((pColor)->rgbRed != 0xFF) )                                        \
    {                                                                        \
        (pColor)->rgbRed += 0x20;                                            \
    }

//
// PMGetGrays()
//
// Gets display driver specific versions of gray RGBs
//
void  ASHost::PMGetGrays(void)
{
    HBITMAP          hOldBitmap = NULL;
    BITMAPINFO_ours  bitmapInfo;
    BYTE          bitmapBuffer[16];
    UINT           i;

    DebugEntry(ASHost::PMGetGrays);

    //
    // Initialise the bitmapinfo local structure header contents.  This
    // structure will be used in the GetDIBits calls.
    //
    m_pShare->USR_InitDIBitmapHeader((BITMAPINFOHEADER *)&bitmapInfo, 8);

    bitmapInfo.bmiHeader.biWidth   = 16;
    bitmapInfo.bmiHeader.biHeight  = 1;

    //
    // Select the bitmap into the work DC
    //
    hOldBitmap = SelectBitmap(m_usrWorkDC, m_pShare->m_usrBmp16);
    if (hOldBitmap == NULL)
    {
        ERROR_OUT(( "Failed to select bitmap. hp(%08lX) hbmp(%08lX)",
            m_usrWorkDC, m_pShare->m_usrBmp16 ));
        DC_QUIT;
    }

    //
    // Use the real GDI to set each bit to each supplied color.
    //
    for (i = PM_GREY_COUNT; i-- != 0; )
    {
        SetPixel(m_usrWorkDC, i, 0, s_apmGreyRGB[i]);
    }

    //
    // Because this function is only used for true color scenarios we do
    // not need to select a palette into our compatible DC.  We just need
    // to get the bits.
    //
    if (!GetDIBits(m_usrWorkDC, m_pShare->m_usrBmp16, 0, 1, bitmapBuffer,
            (BITMAPINFO *)&bitmapInfo, DIB_RGB_COLORS ))
    {
        ERROR_OUT(( "GetDIBits failed. hp(%x) hbmp(%x)",
                m_usrWorkDC, m_pShare->m_usrBmp16));
        DC_QUIT;
    }

    //
    // Check if we need to adjust the palette colors for the 16 bit driver
    // bug.
    //
    m_pmBuggedDriver = ((g_usrScreenBPP > 8) &&
                        (bitmapInfo.bmiColors[1].rgbRed == 0) &&
                        (bitmapInfo.bmiColors[1].rgbGreen == 0) &&
                        (bitmapInfo.bmiColors[1].rgbBlue == 0x40));

    //
    // Extract the RGBs returned by the display driver with the sending bpp
    // DIB.
    //
    for (i = PM_GREY_COUNT; i-- != 0; )
    {
        //
        // Extract the RGB from the color table
        //
        m_apmDDGreyRGB[i] = *((LPTSHR_RGBQUAD)(&bitmapInfo.bmiColors[bitmapBuffer[i]]));

        //
        // Adjust the palette colors for the 16 bit driver bug, if needed.
        //
        if (m_pmBuggedDriver)
        {
            TRACE_OUT(( "Adjusting for bugged driver"));
            PMADJUSTBUGGEDCOLOR(&m_apmDDGreyRGB[i]);
        }
    }

DC_EXIT_POINT:
    //
    // clean up
    //
    if (hOldBitmap != NULL)
    {
        SelectBitmap(m_usrWorkDC, hOldBitmap);

    }

    DebugExitVOID(ASHost::PMGetGrays);
}






//
// FUNCTION: PMUpdateSystemPaletteColors
//
// DESCRIPTION:
//
// Determines whether the colors in the System Palette have changed since
// the last time this function was called and if so, updates the supplied
// palette so that it contains the same colors as the System Palette.
//
// The first time that this function is called after PM_Init the System
// Palette colors will be returned and the function will return TRUE.
//
// PARAMETERS:
//
// shadowSystemPalette - handle of the palette to be updated with the
// current System Palette colors
//
// RETURNS: TRUE if the System Palette has changed since the last call,
// FALSE otherwise.
//
//
BOOL  ASHost::PMUpdateSystemPaletteColors(void)
{
    BOOL            rc = FALSE;
    PALETTEENTRY    systemPaletteEntries[PM_NUM_8BPP_PAL_ENTRIES];
    HDC             hdcScreen = NULL;
    UINT            cbSystemPaletteEntries;
    int             irgb, crgb, crgbFixed;

    DebugEntry(ASHost::PMUpdateSystemPaletteColors);

    ASSERT(g_usrPalettized);
    ASSERT(g_usrScreenBPP <= 8);
    ASSERT(m_usrSendingBPP <= 8);

    //
    // Don't bother with all this stuff if the system palette has not
    // changed at all.  We track notifications to our UI to detect
    // palette changes.
    //
    if (!g_asSharedMemory->pmPaletteChanged)
    {
        DC_QUIT;
    }

    hdcScreen = GetDC(NULL);
    if (!hdcScreen)
    {
        WARNING_OUT(( "GetDC failed"));
        DC_QUIT;
    }

    if (GetSystemPaletteEntries(hdcScreen, 0, COLORS_FOR_BPP(g_usrScreenBPP),
        systemPaletteEntries) != (UINT)COLORS_FOR_BPP(g_usrScreenBPP))
    {
        WARNING_OUT(( "GetSystemPaletteEntries failed"));
        DC_QUIT;
    }

    //
    // Now that we have succesfully queried the system palette, we can
    // reset our flag.
    //
    g_asSharedMemory->pmPaletteChanged = FALSE;

    cbSystemPaletteEntries = COLORS_FOR_BPP(g_usrScreenBPP) * sizeof(PALETTEENTRY);

    //
    // See if the System Palette has changed from the last time we queried.
    //
    if (!memcmp(systemPaletteEntries, m_apmCurrentSystemPaletteEntries,
            cbSystemPaletteEntries ))
    {
        //
        // The System Palette has not changed
        //
        TRACE_OUT(( "System palette has NOT changed"));
        rc = TRUE;
        DC_QUIT;
    }

    //
    // Take a copy of the new System Palette.
    //
    memcpy(m_apmCurrentSystemPaletteEntries, systemPaletteEntries, cbSystemPaletteEntries );

    //
    // Update the current local paleete.
    //
    // NOTE FOR WIN95:
    // We need to add PC_NOCOLLAPSE to non-system palette entries.
    //
    if (g_asWin95)
    {
        if (GetSystemPaletteUse(hdcScreen) == SYSPAL_STATIC)
            crgbFixed = GetDeviceCaps(hdcScreen, NUMRESERVED) / 2;
        else
            crgbFixed = 1;

        crgb = COLORS_FOR_BPP(g_usrScreenBPP) - crgbFixed;

        for (irgb = crgbFixed; irgb < crgb; irgb++)
        {
            systemPaletteEntries[irgb].peFlags = PC_NOCOLLAPSE;
        }
    }

    SetPaletteEntries(m_pmTxPalette, 0, COLORS_FOR_BPP(g_usrScreenBPP),
                       systemPaletteEntries );

    m_pmMustSendPalette = TRUE;

    //
    // SFR0407: The system palette has changed so re-fetch our set of RGBs
    // which the driver returns on an 8-bit GetDIBits for greys.
    //
    PMGetGrays();

    rc = TRUE;

DC_EXIT_POINT:
    if (hdcScreen)
    {
        ReleaseDC(NULL, hdcScreen);
    }

    DebugExitBOOL(ASHost::PMUpdateSystemPaletteColors, rc);
    return(rc);
}


//
// FUNCTION: PMUpdateTxPaletteColors
//
// DESCRIPTION:
//
// Returns the colors that make up the current Tx Palette (the palette that
// is SENT from the local machine).  These are not necessarily the colors
// in the local machine's palette, because the local machine's bpp and the
// protocol bpp may be different (e.g.  on an 8bpp machine talking at 4bpp
// the Tx Palette has 16 entries).
//
// PARAMETERS:
//
// pColorTable - pointer to an array of RGBQUADs which is filled with the
// colors that make up the current Tx Palette.
//
// RETURNS: TRUE if successful, FALSE otherwise.
//
//
BOOL  ASHost::PMUpdateTxPaletteColors(void)
{
    UINT            i;
    UINT            j;
    BOOL            rc = FALSE;
    HDC             hdcMem = NULL;
    HBITMAP         hbmpDummy = NULL;
    HPALETTE        hpalOld = NULL;
    BITMAPINFO_ours pmBitmapInfo;

    DebugEntry(ASHost::PMUpdateTxPaletteColors);

    //
    // Returns the values returned by a GetDIBits call with the
    // m_pmTxPalette selected.
    //
    ASSERT(m_usrSendingBPP <= 8);

    //
    // If we are at 8bpp locally, and sending at 8bpp, then the TxPalette
    // is simply the system palette.
    //
    if ((g_usrScreenBPP == 8) && (m_usrSendingBPP == 8))
    {
        PM_GetSystemPaletteEntries(pmBitmapInfo.bmiColors);
    }
    else
    {
        hdcMem = CreateCompatibleDC(NULL);
        if (!hdcMem)
        {
            ERROR_OUT(("PMUpdateTxPaletteColors: couldn't create memory DC"));
            DC_QUIT;
        }

        hpalOld = SelectPalette(hdcMem, m_pmTxPalette, TRUE);
        RealizePalette(hdcMem);

        #define DUMMY_WIDTH  8
        #define DUMMY_HEIGHT 8

        hbmpDummy = CreateBitmap(DUMMY_WIDTH, DUMMY_HEIGHT, 1,
            g_usrScreenBPP, NULL);
        if (hbmpDummy == NULL)
        {
            ERROR_OUT(( "Failed to create bitmap"));
            DC_QUIT;
        }


        //
        // Set up the structure required by GetDIBits.
        //
        pmBitmapInfo.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
        pmBitmapInfo.bmiHeader.biWidth  = DUMMY_WIDTH;
        pmBitmapInfo.bmiHeader.biHeight = DUMMY_HEIGHT;
        pmBitmapInfo.bmiHeader.biPlanes = 1;
        pmBitmapInfo.bmiHeader.biBitCount = (WORD)m_usrSendingBPP;
        pmBitmapInfo.bmiHeader.biCompression = BI_RGB;
        pmBitmapInfo.bmiHeader.biSizeImage = 0;
        pmBitmapInfo.bmiHeader.biXPelsPerMeter = 10000;
        pmBitmapInfo.bmiHeader.biYPelsPerMeter = 10000;
        pmBitmapInfo.bmiHeader.biClrUsed = 0;
        pmBitmapInfo.bmiHeader.biClrImportant = 0;

        if (0 == GetDIBits( hdcMem,
                            hbmpDummy,
                            0,
                            DUMMY_HEIGHT,
                            NULL,
                            (LPBITMAPINFO)&pmBitmapInfo.bmiHeader,
                            DIB_RGB_COLORS ))
        {
            WARNING_OUT(( "GetDIBits failed hdc(%x) hbmp(%x)",
                                                        HandleToUlong(hdcMem),
                                                        HandleToUlong(hbmpDummy)));
            DC_QUIT;
        }

        SelectPalette(hdcMem, hpalOld, TRUE);

        PM_AdjustColorsForBuggedDisplayDrivers(
            (LPTSHR_RGBQUAD)pmBitmapInfo.bmiColors,
            COLORS_FOR_BPP(m_usrSendingBPP));

        //
        // This doesn't work for VGA.
        //
        if (g_usrScreenBPP > 4)
        {
            //
            // Check the new color table for any occurrences of the dodgy-grey
            // RGBs which the display driver returns (getDIBits at 8bpp can
            // return RGBs with unequal R, G and B for a supplied RGB with
            // equal components, causing poor quality output).
            //
            for (i = COLORS_FOR_BPP(m_usrSendingBPP); i-- != 0;)
            {
                for ( j = 0; j < PM_GREY_COUNT; j++ )
                {
                    if (!memcmp(&pmBitmapInfo.bmiColors[i],
                            &m_apmDDGreyRGB[j],
                            sizeof(pmBitmapInfo.bmiColors[i])) )
                    {
                        //
                        // Found a dodgy grey in the color table, so replace
                        // with a "good" grey, ie one with equal R, G and B.
                        //
                        pmBitmapInfo.bmiColors[i].rgbRed =
                                                   GetRValue(s_apmGreyRGB[j]);
                        pmBitmapInfo.bmiColors[i].rgbGreen =
                                                   GetGValue(s_apmGreyRGB[j]);
                        pmBitmapInfo.bmiColors[i].rgbBlue =
                                                   GetBValue(s_apmGreyRGB[j]);
                        TRACE_OUT(( "match our grey %#x", s_apmGreyRGB[j]));
                        break;
                    }
                }
            }
        }
    }

    //
    // If the colors have changed then return TRUE and copy the new color
    // table back, else return FALSE.
    //
    if (!memcmp(m_apmTxPaletteColors, pmBitmapInfo.bmiColors,
                COLORS_FOR_BPP(m_usrSendingBPP) * sizeof(RGBQUAD) ))
    {
        rc = FALSE;
    }
    else
    {
        memcpy(m_apmTxPaletteColors, pmBitmapInfo.bmiColors,
               COLORS_FOR_BPP(m_usrSendingBPP) * sizeof(RGBQUAD) );

        rc = TRUE;
    }

DC_EXIT_POINT:
    if (hbmpDummy != NULL)
    {
        DeleteBitmap(hbmpDummy);
    }

    if (hdcMem != NULL)
    {
        DeleteDC(hdcMem);
    }

    DebugExitDWORD(ASHost::PMUpdateTxPaletteColors, rc);
    return(rc);
}

//
// FUNCTION: PMCreatePalette
//
// DESCRIPTION:
//
// Creates a new palette using the given colors.
//
// PARAMETERS:
//
// cEntries - number of entries in the pNewEntries array
//
// pNewEntries - pointer to a TSHR_COLOR array containing the new palette
// entries
//
// phPal - pointer to a HPALETTE variable that receives the new palette
// handle.
//
//
// RETURNS - TRUE if successful, FALSE otherwise.
//
//
BOOL  ASShare::PM_CreatePalette
(
    UINT            cEntries,
    LPTSHR_COLOR    pNewEntries,
    HPALETTE *      phPal
)
{
    UINT            i;
    BYTE            pmLogPaletteBuffer[sizeof(LOGPALETTE) + (PM_NUM_8BPP_PAL_ENTRIES-1)*sizeof(PALETTEENTRY)];
    LPLOGPALETTE    pLogPalette;
    BOOL            rc = FALSE;

    DebugEntry(ASShare::PM_CreatePalette);

    ASSERT(cEntries <= PM_NUM_8BPP_PAL_ENTRIES);

    //
    // Set up a palette structure.
    //
    pLogPalette = (LPLOGPALETTE)pmLogPaletteBuffer;

    // This is a random windows constant
    pLogPalette->palVersion    = 0x300;
    pLogPalette->palNumEntries = (WORD)cEntries;

    //
    // This palette packet contains an array of TSHR_COLOR structures which
    // contains 3 fields (RGB).  We have to convert each of these
    // structures to a PALETTEENTRY structure which has the same 3 fields
    // (RGB) plus some flags.
    //
    for (i = 0; i < cEntries; i++)
    {
        TSHR_COLOR_TO_PALETTEENTRY( pNewEntries[i],
                                 pLogPalette->palPalEntry[i] );
    }

    //
    // Create the palette.
    //
    *phPal = CreatePalette(pLogPalette);

    //
    // Return TRUE if the palette was created.
    //
    rc = (*phPal != NULL);

    DebugExitDWORD(ASShare::PM_CreatePalette, rc);
    return(rc);
}





//
// FUNCTION: PM_AdjustColorsForBuggedDisplayDrivers
//
// DESCRIPTION:
//
// Adjusts the supplied color table if necessary to take account of display
// driver bugs.
//
// PARAMETERS:
//
// pColors - pointer to the color table (an array of RGBQUADs)
//
// cColors - number of colors in the supplied color table
//
// RETURNS: Nothing.
//
//
// NOTE: There is similar code in NormalizeRGB below (although not similar
// enough to macro it.)  If you change this code you should probably do
// the same there.)
//
void  ASHost::PM_AdjustColorsForBuggedDisplayDrivers
(
    LPTSHR_RGBQUAD  pColors,
    UINT            cColors
)
{
    LPTSHR_RGBQUAD  pColor;
    UINT      i;

    DebugEntry(ASHost::PM_AdjustColorsForBuggedDisplayDrivers);

    //
    // The Win95 16bpp display drivers return wrong colors when querying at
    // 8bpp.  The palette depends on the driver itself (5-6-5, 6-5-5, 5-6-5,
    // or 5-5-5).  Only when R, G, and B have the same # of bits are we
    // going to end up with an even distribution.
    //
    // Detect this case and try to adjust the colors.
    //
    m_pmBuggedDriver = ((g_usrScreenBPP > 8) &&
                        (pColors[1].rgbRed == 0) &&
                        (pColors[1].rgbGreen == 0) &&
                        (pColors[1].rgbBlue == 0x40));

    if (m_pmBuggedDriver)
    {
        TRACE_OUT(( "Adjusting for bugged driver"));
        pColor = pColors;

        for (i = 0; i < cColors; i++)
        {
            PMADJUSTBUGGEDCOLOR(pColor);
            pColor++;
        }
    }

    DebugExitVOID(ASHost::PM_AdjustColorsForBuggedDisplayDrivers);
}



//
// FUNCTION: PM_DeletePalette
//
// DESCRIPTION:
//
// Deletes the given palette, if it is not the default palette.
//
// PARAMETERS:
//
// palette - palette to be deleted
//
// RETURNS: Nothing.
//
//
void  ASShare::PM_DeletePalette(HPALETTE palette)
{
    DebugEntry(ASShare::PM_DeletePalette);

    if ((palette != NULL) &&
        (palette != (HPALETTE)GetStockObject(DEFAULT_PALETTE)))
    {
        DeletePalette(palette);
    }

    DebugExitVOID(ASShare::PM_DeletePalette);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\precomp.h ===
#include <dcg.h>
#include <ut.h>
#include <dcs.h>
#include <globals.h>
#include <nmutil.h>
#include <dllutil.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\rbc.cpp ===
#include "precomp.h"


//
// RBC.CPP
// Received Bitmap Cache
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE



//
// RBC_ViewStarting()
//
// For 3.0 nodes, we create the cache each time they start hosting.
// For 2.x nodes, we create the cache once and use it until they leave the
//      share.
//
BOOL  ASShare::RBC_ViewStarting(ASPerson * pasPerson)
{
    BOOL                  rc = FALSE;

    DebugEntry(ASShare::RBC_ViewStarting);

    ValidatePerson(pasPerson);

    if (pasPerson->prbcHost != NULL)
    {
        ASSERT(pasPerson->cpcCaps.general.version < CAPS_VERSION_30);

        TRACE_OUT(("RBC_ViewStarting:  Reusing rbc cache for 2.x node [%d]",
            pasPerson->mcsID));
        rc = TRUE;
        DC_QUIT;
    }

    //
    // Allocate the INCOMING cache data for this host.
    //
    pasPerson->prbcHost = new RBC_HOST_INFO;
    if (!pasPerson->prbcHost)
    {
        ERROR_OUT(( "Failed to get memory for prbcHost info"));
        DC_QUIT;
    }
    ZeroMemory(pasPerson->prbcHost, sizeof(*(pasPerson->prbcHost)));
    SET_STAMP(pasPerson->prbcHost, RBCHOST);

    TRACE_OUT(( "Allocated RBC root for host [%d] at 0x%08x",
        pasPerson->mcsID, pasPerson->prbcHost));

    //
    // Create the bitmap caches for the sender
    //

    // SMALL
    if (!BMCAllocateCacheData(pasPerson->cpcCaps.bitmaps.sender.capsSmallCacheNumEntries,
            pasPerson->cpcCaps.bitmaps.sender.capsSmallCacheCellSize,
            ID_SMALL_BMP_CACHE,
            &(pasPerson->prbcHost->bitmapCache[ID_SMALL_BMP_CACHE])))
    {
        DC_QUIT;
    }

    // MEDIUM
    if (!BMCAllocateCacheData(pasPerson->cpcCaps.bitmaps.sender.capsMediumCacheNumEntries,
            pasPerson->cpcCaps.bitmaps.sender.capsMediumCacheCellSize,
            ID_MEDIUM_BMP_CACHE,
            &(pasPerson->prbcHost->bitmapCache[ID_MEDIUM_BMP_CACHE])))
    {
        DC_QUIT;
    }

    // LARGE
    if (!BMCAllocateCacheData(pasPerson->cpcCaps.bitmaps.sender.capsLargeCacheNumEntries,
            pasPerson->cpcCaps.bitmaps.sender.capsLargeCacheCellSize,
            ID_LARGE_BMP_CACHE,
            &(pasPerson->prbcHost->bitmapCache[ID_LARGE_BMP_CACHE])))
    {
        DC_QUIT;
    }

    //
    // The host can join the share.
    //
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::RBC_ViewStarting, rc);
    return(rc);
}


//
// RBC_ViewEnded()
//
void  ASShare::RBC_ViewEnded(ASPerson * pasPerson)
{
    DebugEntry(ASShare::RBC_ViewEnded);

    ValidatePerson(pasPerson);

    //
    // For 3.0 NODES, we can free the cache; 3.0 senders clear theirs
    //      every time they host.
    // For 2.x NODES, we must keep it around while they are in the share.
    //
    if (pasPerson->cpcCaps.general.version >= CAPS_VERSION_30)
    {
        RBCFreeIncoming(pasPerson);
    }
    else
    {
        TRACE_OUT(("RBC_ViewEnded:  Keeping rbc cache for 2.x node [%d]",
            pasPerson->mcsID));
    }

    DebugExitVOID(ASShare::RBC_ViewEnded);
}


//
// RBC_PartyLeftShare()
// For 2.x nodes, frees the incoming RBC data
//
void ASShare::RBC_PartyLeftShare(ASPerson * pasPerson)
{
    DebugEntry(ASShare::RBC_PartyLeftShare);

    ValidatePerson(pasPerson);

    if (pasPerson->cpcCaps.general.version >= CAPS_VERSION_30)
    {
        // This should be gone!
        ASSERT(pasPerson->prbcHost == NULL);
    }
    else
    {
        TRACE_OUT(("RBC_PartyLeftShare:  Freeing rbc cache for 2.x node [%d]",
            pasPerson->mcsID));
        RBCFreeIncoming(pasPerson);
    }

    DebugExitVOID(ASShare::RBC_PartyLeftShare);
}


//
// RBCFreeIncoming()
// Frees the party RBC incoming structures.  This happens
//      * For 3.0 nodes when they stop hosting
//      * For 2.x nodes when leave the share
//
void ASShare::RBCFreeIncoming(ASPerson * pasPerson)
{
    DebugEntry(ASShare::RBCFreeIncoming);

    //
    // Free this host's cache bitmaps.
    //
    if (pasPerson->prbcHost != NULL)
    {
        UINT  i;

        //
        // Delete all of this host's cache bitmaps.
        //
        for (i = 0; i < NUM_BMP_CACHES; i++)
        {
            BMCFreeCacheData(&(pasPerson->prbcHost->bitmapCache[i]));
        }

        delete pasPerson->prbcHost;
        pasPerson->prbcHost = NULL;
    }

    DebugExitVOID(ASShare::RBCFreeIncoming);
}


//
// RBC_ProcessCacheOrder(..)
//
void  ASShare::RBC_ProcessCacheOrder
(
    ASPerson *              pasPerson,
    LPCOM_ORDER_UA          pOrder
)
{
    PBMC_ORDER_HDR               pBmcOrderHdr;
    PBMC_COLOR_TABLE_ORDER_UA    pColorOrder;
    PBMC_BITMAP_BITS_ORDER_R2_UA pBitsOrderR2;
    BOOL                    fCompressed = FALSE;
    UINT                    cxFixedBitmapWidth;
    UINT                    iCacheEntry;
    LPBYTE                  pBitmapBits;
    UINT                    cbBitmapBits;

    DebugEntry(ASShare::RBC_ProcessCacheOrder);

    ValidatePerson(pasPerson);

    //
    // The rectangle is not included in the header for private order data
    // (see SBC_CopyPrivateOrderData) so we must take this into account
    // when working out the address of the order data.
    //
    pBmcOrderHdr = (PBMC_ORDER_HDR)
                   (pOrder->abOrderData - sizeof(pOrder->OrderHeader.rcsDst));

    switch (pBmcOrderHdr->bmcPacketType)
    {
        case BMC_PT_COLOR_TABLE:
            //
            // This is a new color table.  Simply cache the RGB values for
            // use when we come to process a memblt order
            // For backlevel calls the color table is always stored at
            // index 0 because the index field in the order reuses a
            // zero initialized "padding" field in the old structure.
            //
            TRACE_OUT(("Person [%d] Caching color table", pasPerson->mcsID));
            pColorOrder = (PBMC_COLOR_TABLE_ORDER_UA)pBmcOrderHdr;

            PM_CacheRxColorTable(pasPerson, pColorOrder->index,
                EXTRACT_TSHR_UINT16_UA(&(pColorOrder->colorTableSize)),
                                 (LPTSHR_RGBQUAD)&pColorOrder->data[0]);
            break;

        case BMC_PT_BITMAP_BITS_COMPRESSED:
            fCompressed = TRUE;
            TRACE_OUT(( "Compressed BMP"));
        case BMC_PT_BITMAP_BITS_UNCOMPRESSED:
            //
            // This is some cached bitmap data.  We have to store it in the
            // specified slot in the specified cache.
            //

            //
            // The width of the bitmaps we use are actually fixed as
            // multiples of 16 pels wide.  Work out the width that
            // corresponds to the sub-bitmap width of data we are caching.
            //
            pBitsOrderR2 = (PBMC_BITMAP_BITS_ORDER_R2_UA)pBmcOrderHdr;

            cbBitmapBits = EXTRACT_TSHR_UINT16_UA(
                                        &(pBitsOrderR2->header.cbBitmapBits));

            cxFixedBitmapWidth =
                          ((pBitsOrderR2->header.cxSubBitmapWidth +15)/16)*16;

            //
            // The location of cache entry field depends on the R1/R2
            // protocol
            //
            iCacheEntry = EXTRACT_TSHR_UINT16_UA(&(pBitsOrderR2->iCacheEntryR2));
            pBitmapBits = pBitsOrderR2->data;

            TRACE_OUT(("Person [%d] Rx bmp: id(%d) entry(%d) size(%dx%d) " \
                        "fixed(%d) bpp(%d) bytes(%d) compressed(%d)",
                    pasPerson->mcsID,
                    pBitsOrderR2->header.cacheID,
                    iCacheEntry,
                    pBitsOrderR2->header.cxSubBitmapWidth,
                    pBitsOrderR2->header.cySubBitmapHeight,
                    cxFixedBitmapWidth,
                    pBitsOrderR2->header.bpp,
                    cbBitmapBits,
                    fCompressed));

            //
            // Pass the BMC data to the caching code.  When calculating the
            // pointer to the bitmap bits remember that we did not send the
            // pBitmapBits field of the BMC_BITMAP_BITS_ORDER_Rx structure
            // (see SBC_CopyPrivateOrderData).
            //
            RBCStoreBitsInCacheBitmap(pasPerson,
                             pBitsOrderR2->header.cacheID,
                             iCacheEntry,
                             pBitsOrderR2->header.cxSubBitmapWidth,
                             cxFixedBitmapWidth,
                             pBitsOrderR2->header.cySubBitmapHeight,
                             pBitsOrderR2->header.bpp,
                             pBitmapBits,
                             cbBitmapBits,
                             fCompressed);
            break;

        default:
            ERROR_OUT(( "[%u]Invalid packet type(%d)",
                       pasPerson,
                       (UINT)pBmcOrderHdr->bmcPacketType));
            break;
    }

    DebugExitVOID(ASShare::RBC_ProcessCacheOrder);
}


//
// RBC_MapCacheIDToBitmapHandle(..)
//
HBITMAP  ASShare::RBC_MapCacheIDToBitmapHandle
(
    ASPerson *          pasPerson,
    UINT                cache,
    UINT                cacheEntry,
    UINT                colorIndex
)
{
    PBMC_DIB_CACHE      pDIBCache;
    PBMC_DIB_ENTRY      pDIBEntry;
    BITMAPINFO_ours     bitmapInfo;
    UINT                cColors;
    HBITMAP             hWorkBitmap = NULL;
    HPALETTE            hpalOldDIB = NULL;
    LPBYTE              pBits;
    UINT                cacheOffset;

    DebugEntry(ASShare::RBC_MapCacheIDToBitmapHandle);

    ValidateView(pasPerson);

    //
    // Check that the supplied cache ID is valid.
    //
    if (cache >= NUM_BMP_CACHES)
    {
        ERROR_OUT(( "[%u]Invalid cache ID (%d)", pasPerson, cache));
        cache = 0;
    }

    //
    // Get a pointer to the bitmap data
    //
    // Note that there are two indexes floating around.  From the host's
    // perspective this index is a Cache Handler token and it must be
    // translated in order to address the associated data.  However we
    // use it as the direct index into our receive cache and so the
    // slots used on host and remote will be diferent.
    //
    // There is no reason why the slots should be the same.  This is just
    // to warn you that if you try correlating cache offsets between
    // host and remote you will get confused as soon as the cache fills
    // up and entries are reallocated in different positions.
    //
    //
    pDIBCache = &(pasPerson->prbcHost->bitmapCache[cache]);
    TRACE_OUT(( "Local person [%d] cache id %d pointer %lx",
        pasPerson->mcsID, cache, pDIBCache));
    cacheOffset = cacheEntry * pDIBCache->cSize;
    pDIBEntry = (PBMC_DIB_ENTRY)(pDIBCache->data + cacheOffset);

    TRACE_OUT(( "Bits for index %u are at offset %ld, pointer 0x%08x",
        cacheEntry, (cacheEntry * pDIBCache->cSize), pDIBEntry));

    //
    // Set up the BitmapInfo structure.
    //
    USR_InitDIBitmapHeader((BITMAPINFOHEADER *)&bitmapInfo, pDIBEntry->bpp);
    bitmapInfo.bmiHeader.biWidth  = pDIBEntry->cxFixed;
    bitmapInfo.bmiHeader.biHeight = pDIBEntry->cy;

    //
    // Copy the Rx color table into the bitmap header.
    //
    if ( (pDIBEntry->bpp == 1) ||
         (pDIBEntry->bpp == 4) ||
         (pDIBEntry->bpp == 8) )
    {
        cColors = COLORS_FOR_BPP(pDIBEntry->bpp);

        PM_GetColorTable( pasPerson,
                          colorIndex,
                          &cColors,
                          (LPTSHR_RGBQUAD)(&bitmapInfo.bmiColors) );
        TRACE_OUT(( "Got %u colors from table",cColors));
        bitmapInfo.bmiHeader.biClrUsed = cColors;
    }
    else if (pDIBEntry->bpp == 24)
    {
        ASSERT(colorIndex == COLORCACHEINDEX_NONE);
    }
    else
    {
        ERROR_OUT(("RBC: Unexpected bpp %d from [%d]", pDIBEntry->bpp, pasPerson->mcsID));
        DC_QUIT;
    }

    //
    // Select which fixed width bitmap we are going to use to store the
    // incoming DIB bits.
    //
    switch (pDIBEntry->cxFixed)
    {
        case 16:
            hWorkBitmap = m_usrBmp16;
            break;

        case 32:
            hWorkBitmap = m_usrBmp32;
            break;

        case 48:
            hWorkBitmap = m_usrBmp48;
            break;

        case 64:
            hWorkBitmap = m_usrBmp64;
            break;

        case 80:
            hWorkBitmap = m_usrBmp80;
            break;

        case 96:
            hWorkBitmap = m_usrBmp96;
            break;

        case 112:
            hWorkBitmap = m_usrBmp112;
            break;

        case 128:
            hWorkBitmap = m_usrBmp128;
            break;

        case 256:
            hWorkBitmap = m_usrBmp256;
            break;

        default:
            ERROR_OUT(("RBC_MapCacheIDToBitmapHandle: invalid size from [%d]",
                pDIBEntry->cxFixed, pasPerson->mcsID));
            hWorkBitmap = m_usrBmp256;
            break;
    }

    ASSERT(hWorkBitmap != NULL);


    //
    // If the cached bitmap bits are compressed, we first have to
    // decompress them.
    //
    if (pDIBEntry->bCompressed)
    {
        ASSERT(pDIBEntry->bpp <= 8);

        //
        // Use the decompression buffer to decompress the bitmap data.
        //
        if (!BD_DecompressBitmap(pDIBEntry->bits, m_usrPBitmapBuffer,
                                 pDIBEntry->cCompressed,
                                 pDIBEntry->cxFixed,
                                 pDIBEntry->cy,
                                 pDIBEntry->bpp))
        {
             ERROR_OUT((
                      "Failed to decompress bitmap pBits(%lx)"
                      " pBuf(%lx) cb(%x) cx(%d) cy(%d) bpp(%d)",
                      pDIBEntry->bits,
                      m_usrPBitmapBuffer,
                      pDIBEntry->cCompressed,
                      pDIBEntry->cxFixed,
                      pDIBEntry->cy,
                      pDIBEntry->bpp));
             DC_QUIT;
        }

        pBits = m_usrPBitmapBuffer;
    }
    else
    {
        //
        // For uncompressed data just use direct from the cache
        //
        TRACE_OUT(( "Bitmap bits are uncompressed"));
        pBits = pDIBEntry->bits;
    }


    //
    // Set the bits into the bitmap we are about to return to the caller
    //
    hpalOldDIB = SelectPalette(pasPerson->m_pView->m_usrWorkDC,
        pasPerson->pmPalette, FALSE);
    RealizePalette(pasPerson->m_pView->m_usrWorkDC);

    if (!SetDIBits(pasPerson->m_pView->m_usrWorkDC,
                      hWorkBitmap,
                      0,
                      pDIBEntry->cy,
                      pBits,
                      (BITMAPINFO *)&bitmapInfo,
                      DIB_RGB_COLORS))
    {
        ERROR_OUT(("SetDIBits failed in RBC_MapCacheIDToBitmapHandle"));
    }

    SelectPalette(pasPerson->m_pView->m_usrWorkDC, hpalOldDIB, FALSE );

    TRACE_OUT(( "Returning bitmap for person [%d] cache %u index %u color %u",
        pasPerson->mcsID, cache, cacheEntry, colorIndex));


DC_EXIT_POINT:
    DebugExitVOID(ASShare::RBC_MapCacheIDToBitmapHandle);
    return(hWorkBitmap);
}






//
// FUNCTION: RBCStoreBitsInCacheBitmap(..)
//
// DESCRIPTION:
//
// Stores received bitmap bits into one of the receiver's cache bitmaps.
//
// PARAMETERS:
//
// pasPerson - pasPerson of host the bits came from.
//
// cache - the id of the cache bitmap to store the bits in.
//
// iCacheEntry - the cache entry number (index).
//
// cxSubBitmapWidth - the width in pels of the actual sub-bitmap (ie.
// excluding padding)
//
// cxFixedWidth - the fixed width in pels of the supplied bits (ie.
// including padding)
//
// cySubBitmapHeight - the height in pels of the sub-bitmap.
//
// pBitmapBits - a pointer to the actual bitmap bits. These may or may
// not be compressed (determined by the value of the fCompressed
// flag).
//
// cbBitmapBits - the size of the bitmap bits pointed to by pBitmapBits.
//
// fCompressed - a flag specifying whether the supplied bitmap
// bits are compressed.
//
// RETURNS:
//
// Nothing.
//
//
void  ASShare::RBCStoreBitsInCacheBitmap
(
    ASPerson *          pasPerson,
    UINT                cache,
    UINT                iCacheEntry,
    UINT                cxSubBitmapWidth,
    UINT                cxFixedWidth,
    UINT                cySubBitmapHeight,
    UINT                bpp,
    LPBYTE              pBitmapBits,
    UINT                cbBitmapBits,
    BOOL                fCompressed
)
{
    PBMC_DIB_ENTRY      pDIBEntry;

    DebugEntry(ASShare::RBCStoreBitsInCacheBitmap);

    ValidatePerson(pasPerson);

    //
    // Do some error checking.
    //
    if (cache >= NUM_BMP_CACHES)
    {
        ERROR_OUT(("Invalid cache ID %d from [%d]", cache, pasPerson->mcsID));
        DC_QUIT;
    }

    //
    // Now store the bits in the cache
    // The cache is a huge chunk of memory comprising cache slots of cSize
    // bytes each.  cSize is rounded to a power of 2 to ensure the array
    // spans segment boundaries cleanly for segmented architecture OSs.
    //
    pDIBEntry = (PBMC_DIB_ENTRY)
        (((LPBYTE)(pasPerson->prbcHost->bitmapCache[cache].data) +
         (iCacheEntry * pasPerson->prbcHost->bitmapCache[cache].cSize)));
    TRACE_OUT(( "Selected cache entry 0x%08x",pDIBEntry));

    pDIBEntry->inUse       = TRUE;
    pDIBEntry->cx          = (TSHR_UINT16)cxSubBitmapWidth;
    pDIBEntry->cxFixed     = (TSHR_UINT16)cxFixedWidth;
    pDIBEntry->cy          = (TSHR_UINT16)cySubBitmapHeight;
    pDIBEntry->bpp         = (TSHR_UINT16)bpp;
    pDIBEntry->bCompressed = (fCompressed != FALSE);
    pDIBEntry->cCompressed = cbBitmapBits;

    //
    // Now copy the bits into the cache entry
    //
    memcpy(pDIBEntry->bits, pBitmapBits, cbBitmapBits);

    //
    // THIS FIELD IS NEVER ACCESSED.
    //
    pDIBEntry->cBits = BYTES_IN_BITMAP(cxFixedWidth, cySubBitmapHeight,
        pDIBEntry->bpp);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::RBCStoreBitsInCacheBitmap);
}




//
// BMCAllocateCacheData()
//
// DESCRIPTION:
//
// Allocates memory for a bitmap cache
//
// PARAMETERS:
//
// cellSize
//
// RETURNS:
//
// Area needed
//
//
BOOL  BMCAllocateCacheData
(
    UINT            numEntries,
    UINT            cellSize,
    UINT            cacheID,
    PBMC_DIB_CACHE  pCache
)
{
    BOOL            rc = TRUE;
    UINT            memoryNeeded;
    UINT            workSize;
    PBMC_DIB_ENTRY  pCacheEntry;
    UINT            i;

    DebugEntry(BMCAllocateCacheData);

    //
    // First we must free up any data, if it has been allocated
    //
    BMCFreeCacheData(pCache);

    //
    // For 2.x compat, we have SEND caps of 1 entry, 1 byte since 2.x
    // remotes fail for zero entries.  But we don't want a small cache
    // at all, and for W95 nodes that don't have a cache at all, we don't
    // want viewers to alloc memory which will never be used.
    //
    if ((cellSize > 1) && (numEntries > 1))
    {
        //
        // Calculate the cell area
        //
        workSize        = cellSize + sizeof(BMC_DIB_ENTRY) - 1;
        memoryNeeded    = numEntries * workSize;

        TRACE_OUT(("Need 0x%08x bytes for cache %d, %d cells of size 0x%08x",
            memoryNeeded, cacheID, numEntries, cellSize));

        //
        // Malloc the huge space
        //
        pCache->data = new BYTE[memoryNeeded];
        if (pCache->data == NULL)
        {
            ERROR_OUT(( "Failed to alloc bitmap cache %d", cacheID));
            rc = FALSE;
            DC_QUIT;
        }

        pCache->cCellSize   = cellSize;
        pCache->cEntries    = numEntries;
        pCache->cSize       = workSize;
        pCache->freeEntry   = NULL;
        pCacheEntry         = (PBMC_DIB_ENTRY)(pCache->data);

        for (i = 0; i < numEntries; i++)
        {
            pCacheEntry->inUse = FALSE;
            pCacheEntry = (PBMC_DIB_ENTRY)(((LPBYTE)pCacheEntry) + workSize);
        }

        TRACE_OUT(( "Allocated cache %d size %d, pointer 0x%08x stored at 0x%08x",
                     cacheID,
                     memoryNeeded,
                     pCache->data,
                     &pCache->data));
    }

DC_EXIT_POINT:
    DebugExitBOOL(BMCAllocateCacheData, rc);
    return(rc);
}



//
// FUNCTION: BMCFreeCacheData()
//
// DESCRIPTION:
//
// Deletes selected cache's memory
//
// PARAMETERS:
//
// cacheID - id of cache for free
// pCache  - pointer to memory to be freed
//
//
// RETURNS:
//
// Nothing.
//
//
void  BMCFreeCacheData(PBMC_DIB_CACHE pCache)
{
    DebugEntry(BMCFreeCacheData);

    if (pCache->data)
    {
        delete[] pCache->data;
        pCache->data = NULL;
    }

    pCache->cCellSize   = 0;
    pCache->cEntries    = 0;

    DebugExitVOID(BMCFreeCacheData);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\s20.cpp ===
#include "precomp.h"


//
// S20.CPP
// T.128 Protocol
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_NET

BOOL S20AcceptNewCorrelator(PS20CREATEPACKET  pS20Packet);

void PrintS20State(void)
{

	switch(g_s20State)
	{
		case	S20_TERM:
			WARNING_OUT(("g_s20State is S20_TERM"));
			break;
		case	S20_INIT:
			WARNING_OUT(("g_s20State is S20_INIT"));
			break;
		case	S20_ATTACH_PEND:
			WARNING_OUT(("g_s20State is S20_ATTACH_PEND"));
			break;
		case	S20_JOIN_PEND:
			WARNING_OUT(("g_s20State is S20_JOIN_PEND"));
			break;
		case	S20_NO_SHARE:
			WARNING_OUT(("g_s20State is S20_NO_SHARE"));
			break;
		case	S20_SHARE_PEND:
			WARNING_OUT(("g_s20State is S20_SHARE_PEND"));
			break;
		case	S20_SHARE_STARTING:
			WARNING_OUT(("g_s20State is S20_SHARE_STARTING"));
			break;
		case	S20_IN_SHARE:
			WARNING_OUT(("g_s20State is S20_IN_SHARE"));
			break;
		case	S20_NUM_STATES:
			WARNING_OUT(("g_s20State is S20_NUM_STATES"));
			break;
	}
}


#ifdef _DEBUG
#define	PRINTS20STATE  PrintS20State();
#else
#define	PRINTS20STATE
#endif

void SetS20State(UINT newState)
{
	PRINTS20STATE;
	g_s20State = newState;
	PRINTS20STATE;
}

//
// S20_Init()
// Initializes the T.128 protocol layer
//
BOOL  S20_Init(void)
{
    BOOL    rc = FALSE;

    DebugEntry(S20_Init);

    ASSERT(g_s20State == S20_TERM);

    //
    // Register with the network layer.                            
    //
    if (!MG_Register(MGTASK_DCS, &g_s20pmgClient, g_putAS))
    {
        ERROR_OUT(("Failed to register MG layer"));
        DC_QUIT;
    }

    SetS20State(S20_INIT);

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(S20_Init, rc);
    return(rc);
}



//
// S20_Term()
// This cleans up the T.128 protocol layer.
//
void S20_Term(void)
{
    DebugEntry(S20_Term);

    //
    // Note that this case statement is unusual in that it falls through   
    // from each condition.  This happens to suit the termination          
    // processing rather well.                                             
    //
    switch (g_s20State)
    {
        case S20_IN_SHARE:
        case S20_SHARE_PEND:
            //
            // Notify share ended
            //
            SC_End();

            // 
            // FALL THROUGH
            //

        case S20_NO_SHARE:
        case S20_JOIN_PEND:
            //
            // Leave our channels                                          
            //
            if (g_s20BroadcastID != 0)
            {
                MG_ChannelLeave(g_s20pmgClient, g_s20BroadcastID);
                g_s20BroadcastID = 0;
            }
            if (g_s20JoinedLocal)
            {
                MG_ChannelLeave(g_s20pmgClient, g_s20LocalID);
                g_s20JoinedLocal = FALSE;
            }

            //
            // FALL THROUGH
            //

        case S20_ATTACH_PEND:
            //
            // Detach from the domain.                                     
            //
            MG_Detach(g_s20pmgClient);

        case S20_INIT:
            // 
            // We may end up here with g_s20BroadcastID & g_s20JoinedLocal 
            // non-zero if Term was called in the middle of a share.  Clear these
            // variables so when we start back up again via Init, it
            // works the same way as first initialization.
            //
            // Note we do not need to leave the channels.
            //
            g_s20BroadcastID = 0;
            g_s20JoinedLocal = FALSE;

            //
            // Deregister.                                                 
            //
            MG_Deregister(&g_s20pmgClient);
			SetS20State(S20_TERM);

        case S20_TERM:
           WARNING_OUT(("g_s20LocalID  was %x", g_s20LocalID));
           g_s20LocalID = 0;
           WARNING_OUT(("g_s20LocalID  is 0"));

            //
            // Finally we break out.                                       
            //
            break;

        default:
            ERROR_OUT(("invalid state %d", g_s20State));
            break;
    }

    DebugExitVOID(S20_Term);
}



//         
// S20_AllocPkt
// Allocates a SEND packet for either the S20 protocol, syncs, or data
//
PS20DATAPACKET S20_AllocDataPkt
(
    UINT            streamID,
    UINT_PTR            nodeID,                 // One person or broadcast
    UINT_PTR            cbSizePacket
)
{
    PS20DATAPACKET  pS20Packet = NULL;
    NET_PRIORITY    priority;
    BOOL            rc = FALSE;

//    DebugEntry(S20_AllocDataPkt);

    ASSERT(g_s20State == S20_IN_SHARE);

    //
    // Try to send queued control packets first.                           
    //
    if (S20SendQueuedControlPackets() != 0)
    {
        //
        // If there are still queued control packets then don't allow any  
        // allocation.                                                     
        //
        DC_QUIT;
    }

    priority = S20StreamToS20Priority(streamID);

    //
    // Note:
    // Sends to an individual node are NOT flow-controlled.  Only the 
    // global app sharing channel is.
    //
    if (MG_GetBuffer(g_s20pmgClient, (UINT)cbSizePacket, priority,
                        (NET_CHANNEL_ID)nodeID, (void **)&pS20Packet) != 0)
    {
        TRACE_OUT(("MG_GetBuffer failed; can't allocate S20 packet"));
    }
    else
    {
        pS20Packet->header.packetType   = S20_DATA | S20_ALL_VERSIONS;
        pS20Packet->header.user         = g_s20LocalID;

        pS20Packet->correlator  = g_s20ShareCorrelator;
        pS20Packet->stream      = 0;
        pS20Packet->dataLength  = (USHORT)cbSizePacket - sizeof(S20DATAPACKET) + sizeof(DATAPACKETHEADER);

        rc = TRUE;
    }

DC_EXIT_POINT:
//    DebugExitPVOID(S20_AllocDataPkt, pS20Packet);
    return(pS20Packet);
}


//
// S20_FreeDataPkt - see s20.h                                             
//
void  S20_FreeDataPkt(PS20DATAPACKET pS20Packet)
{
    DebugEntry(S20_FreeDataPkt);

    MG_FreeBuffer(g_s20pmgClient, (void **)&pS20Packet);

    DebugExitVOID(S20_FreeDataPkt);
}

//
// S20_SendDataPkt - see s20.h                                             
//
void  S20_SendDataPkt
(
    UINT            streamID,
    UINT_PTR        nodeID,
    PS20DATAPACKET  pS20Packet
)
{
    UINT            rc;
    NET_PRIORITY    priority;

    DebugEntry(S20_SendDataPkt);

    priority = S20StreamToS20Priority(streamID);

    //
    // Note:
    // Sends to an individual are not flow-controlled.  Only sends to
    // everybody on the global app sharing channel are.
    //

    //
    // Try to send queued control packets first.                           
    //
    rc = S20SendQueuedControlPackets();
    if (rc == 0)
    {
        //
        // Fill in the stream, length and correlator before sending.       
        //
        pS20Packet->stream      = (BYTE)streamID;
        pS20Packet->correlator  = g_s20ShareCorrelator;

        //
        // dataLength includes the DATAPACKETHEADER part of the S20DATAPACKET
        // structure
        //
        TRACE_OUT(("S20_SendPkt: sending data packet size %d",
            pS20Packet->dataLength + sizeof(S20DATAPACKET) - sizeof(DATAPACKETHEADER)));

        rc = MG_SendData(g_s20pmgClient, priority, (NET_CHANNEL_ID)nodeID,
            pS20Packet->dataLength + sizeof(S20DATAPACKET) - sizeof(DATAPACKETHEADER),
            (void **)&pS20Packet);
    }

    // lonchanc: it is ok for MG_SendData returns 0 and NET_CHANNEL_EMPTY

    if (rc == NET_RC_MGC_NOT_CONNECTED)
    {
    	WARNING_OUT(("S20_SenddataPacket could not MG_SendData"));
        S20LeaveOrEndShare();
    }
    else
    {
        if (rc != 0)
        {
            ERROR_OUT(("SendData rc=%lx - expecting share termination soon", rc));
        }
    }

    DebugExitVOID(S20_SendDataPkt);
}


//
// S20_UTEventProc()
//
BOOL CALLBACK  S20_UTEventProc
(
    LPVOID      userData,
    UINT        event,
    UINT_PTR    data1,
    UINT_PTR    data2
)
{
    BOOL        processed;

    DebugEntry(S20_UTEventProc);

    processed = TRUE;

    switch (event)
    {
        case NET_EVENT_USER_ATTACH:
            S20AttachConfirm(LOWORD(data1), HIWORD(data1), (UINT)data2);
            break;

        case NET_EVENT_USER_DETACH:
            S20DetachIndication(LOWORD(data1), (UINT)data2);
            break;

        case NET_EVENT_CHANNEL_JOIN:
            S20JoinConfirm((PNET_JOIN_CNF_EVENT)data2);
            MG_FreeBuffer(g_s20pmgClient, (void **)&data2);
            break;

        case NET_EVENT_CHANNEL_LEAVE:
            S20LeaveIndication(LOWORD(data1),(UINT)data2);
            break;

        case NET_EVENT_DATA_RECEIVED:
            S20SendIndication((PNET_SEND_IND_EVENT)data2);
            break;

        case NET_FLOW:
            //
            // Handle the feedback event.                                  
            //
            S20Flow((UINT)data1, (UINT)data2);
            break;

        case CMS_NEW_CALL:
            if (g_asSession.scState == SCS_INIT)
            {
                //
                // This happens when (a) a new real call is started
                // (b) creating a new share in a call fails, so we want to
                // then try to join an existing share.
                //
                SCCheckForCMCall();
            }
            break;

        case CMS_END_CALL:
            if (g_asSession.callID)
            {
                //
                // AS lock protects g_asSession global fields
                //
                TRACE_OUT(("AS LOCK:  CMS_END_CALL"));
                UT_Lock(UTLOCK_AS);

                g_asSession.gccID  = 0;
                g_asSession.callID = 0;
                g_asSession.attendeePermissions = NM_PERMIT_ALL;

                UT_Unlock(UTLOCK_AS);
                TRACE_OUT(("AS UNLOCK:  CMS_END_CALL"));

                if (g_asSession.scState > SCS_SHAREENDING)
                {
                    SC_EndShare();
                }

                if (g_asSession.hwndHostUI)
                {
                    SendMessage(g_asSession.hwndHostUI, HOST_MSG_CALL, FALSE, 0);
                }

                DCS_NotifyUI(SH_EVT_APPSHARE_READY, FALSE, 0);

                g_s20BroadcastID = 0;
                g_s20JoinedLocal = FALSE;
                SetS20State(S20_INIT);
				g_s20LocalID = 0;
		  	
            }
            break;

        default:
            processed = FALSE;
            break;
    }

    DebugExitBOOL(S20_UTEventProc, processed);
    return(processed);
}



//
// FUNCTION: S20AttachUser                                                 
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Called when we want to attach this sets up the various parameters for   
// MG_Attach, calls it and handles the return codes from NET.         
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// callID - the callID provided by the SC user                            
//                                                                         
//                                                                         
//
const NET_FLOW_CONTROL c_S20FlowControl =
    {
        // latency
        {
            S20_LATENCY_TOP_PRIORITY,
            S20_LATENCY_HIGH_PRIORITY,
            S20_LATENCY_MEDIUM_PRIORITY,
            S20_LATENCY_LOW_PRIORITY
        },
        // stream size
        {
            S20_SIZE_TOP_PRIORITY,
            S20_SIZE_HIGH_PRIORITY,
            S20_SIZE_MEDIUM_PRIORITY,
            S20_SIZE_LOW_PRIORITY
        }
    };


//
// S20CreateOrJoinShare()
// Creates a share for the first time or joins an existing one
//
// Normally, creating a share requires
//      * registration
//      * broadcast of S20_CREATE packet
//      * reception of one S20_RESPOND packet
// for the share to be created.  However, if we're the top provider, we
// assume it's created without waiting for an S20_RESPOND.  If something 
// goes wrong later, it will clean itself up anyway.  Then that allows us
// to host a conference, share an app, and have it be shared through the
// life of the conference, even if remotes call/hang up repeatedly.
//
BOOL S20CreateOrJoinShare
(
    UINT    what,
    UINT_PTR callID
)
{
    UINT    rc = 0;
    BOOL    noFlowControl;
    NET_FLOW_CONTROL    flowControl;

    DebugEntry(S20CreateOrJoinShare);

    ASSERT((what == S20_CREATE) || (what == S20_JOIN));

    WARNING_OUT(("S20CreateOrJoinShare: s20 state = %x  what is %s g_s20correlator = %x",
		g_s20State, what == S20_CREATE ? "S20_CREATE" : "S20_JOIN", g_s20ShareCorrelator));
	
    switch (g_s20State)
    {
        case S20_INIT:
            //
            // Remember what to do when we have attached and joined.       
            //
            g_s20Pend = what;

            //
            // ATTACH the S20 MCS USER
            //

            COM_ReadProfInt(DBG_INI_SECTION_NAME, S20_INI_NOFLOWCONTROL,
                FALSE, &noFlowControl);
            if (noFlowControl)
            {
                WARNING_OUT(("S20 Flow Control is OFF"));
                ZeroMemory(&flowControl, sizeof(flowControl));
            }
            else
            {
                // Set up our target latencies and stream sizes                        
                flowControl = c_S20FlowControl;
            }

            //
            // Initiate an attach - the domain equals the callID.                  
            //
            rc = MG_Attach(g_s20pmgClient, callID, &flowControl);
            if (rc == 0)
            {
                //
                // Make the state change if we succeeded                   
                //
				SetS20State(S20_ATTACH_PEND);
            }
            else
            {
                //
                // End the share immediately and no state change.          
                //
                WARNING_OUT(("MG_Attach of S20 User failed, rc = %u", rc));

                g_s20Pend = 0;
                SC_End();
            }
            break;

        case S20_ATTACH_PEND:
        case S20_JOIN_PEND:
            //
            // We just need to set the flag in these cases - we will try   
            // to create a share when we have attached and joined our      
            // channel.                                                    
            //
            g_s20Pend = what;
            break;

        case S20_SHARE_PEND:
            //
            // If a share is pending but the SC user wants to create      
            // or join again we let them.  Multiple outstanding joins are  
            // benign and another create will have a new correlator so the 
            // previous one (and any responses to it) will be obsolete.    
            //                                                             
            // NOTE DELIBERATE FALL THROUGH                                
            //                                                             
            //

        case S20_NO_SHARE:
            TRACE_OUT(("S20_NO_SHARE"));
            //
            // Broadcast a S20CREATE packet.                               
            //
            if (what == S20_CREATE)
            {
   		WARNING_OUT(("S20CreateOrJoinShare g_s20ShareCorrelator%x g_s20LocalID %x", 
			g_s20ShareCorrelator, g_s20LocalID));

                g_s20ShareCorrelator = S20NewCorrelator();
  		 WARNING_OUT(("S20CreateOrJoinShare g_s20ShareCorrelator%x g_s20LocalID %x", 
		 	g_s20ShareCorrelator, g_s20LocalID));
				
                WARNING_OUT(("CP CREATE %lu %d", g_s20ShareCorrelator, 0));
                rc = S20FlushAndSendControlPacket(what,
                                                  g_s20ShareCorrelator,
                                                  0,
                                                  NET_TOP_PRIORITY);
            }
            else
            {
                g_s20ShareCorrelator = 0;
	         WARNING_OUT(("S20CreateOrJoinShare: S20_JOIN g_s20ShareCorrelator is set to 0  state is S20_NO_SHARE g_s20LocalID %x",
			 	g_s20LocalID));
                TRACE_OUT(("CP JOIN %lu %d", 0, 0));
                rc = S20FlushAndSendControlPacket(what, 0, 0,
                                                  NET_TOP_PRIORITY);
            }
            WARNING_OUT(("S20FlushAndSendControlPacket %u, what %s", rc, what == S20_CREATE ? "s20_create":"s20_join"));

            if (rc == 0)
            {
                //
                // Switch state.                                           
                //
				SetS20State(S20_SHARE_PEND);

                //
                // Assume success right away when creating the share.  We'll
                // hear back in a bit if there's a problem.
                //
                if (what == S20_CREATE)
                {
                    // Don't check for top provider, assume success always.
                    WARNING_OUT(("S20: Creating share, assume success"));

                    // 
                    // LAURABU -- IF THIS CAUSES PROBLEMS, fall back to
                    // checking for one person only in call.
                    //
			WARNING_OUT(("S20CreateOrJoinShare SC_Start"));                    
                    if (!SC_Start(g_s20LocalID))
                    {
                        WARNING_OUT(("S20CreateOrJoin: couldn't start share"));
                        SC_End();
                    }
                    else
                    {
						SetS20State(S20_IN_SHARE);
                    }
                }
            }
            else
            {
                //
                // Something failed so we will just forget about the share.
                //
                WARNING_OUT(("Failed to create share"));
                if (what == S20_CREATE)
                {
                    SC_End();
                }
            }
            break;

        default:
            ERROR_OUT(("Invalid state %u for %u", g_s20State, what));
    }

    DebugExitBOOL(S20CreateOrJoinShare, (rc == 0));
    return(rc == 0);
}

//
// FUNCTION: S20LeaveOrEndShare                                            
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Handles processing a S20_LeaveShare or a S20_EndShare call.             
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// what - what to do (the protocol packet type corresponding to the        
// action).                                                                
//                                                                         
// RETURNS: NONE                                                           
//                                                                         
//
void S20LeaveOrEndShare(void)
{
    UINT    what;
    UINT    rc = 0;

    DebugEntry(S20LeaveOrEndShare);

    //
    // The share is destroyed whenever the creator leaves.  Nobody else
    // can end it.
    //
    if (S20_GET_CREATOR(g_s20ShareCorrelator) == g_s20LocalID)
    {
        what = S20_END;
    }
    else
    {
        what = S20_LEAVE;
    }

    ASSERT(what == S20_LEAVE || what == S20_END);
    WARNING_OUT((" S20LeaveOrEndShare: g_s20LocalID %x,  g_s20State %x what %s",
		g_s20LocalID, g_s20State, S20_END == what ? "S20_END" : "S20_LEAVE")); 	

    switch (g_s20State)
    {
        case S20_ATTACH_PEND:
        case S20_JOIN_PEND:
            //
            // We just need to reset the pending flags here - no state     
            // change required.                                            
            //
            g_s20Pend = 0;
            break;

        case S20_IN_SHARE:
        case S20_SHARE_PEND:
            TRACE_OUT(("S20_SHARE_PEND"));
            //
            // Now try and make and send the appropriate control packet.   
            //
            TRACE_OUT(("CP %u %u %d", what, g_s20ShareCorrelator, 0));
            rc = S20FlushSendOrQueueControlPacket(what,
                                             g_s20ShareCorrelator,
                                             0,
                                             NET_TOP_PRIORITY);


	     if(rc != 0)
	     	{
	     		WARNING_OUT(("S20LeaveOrEndShare could not flushqueue"));

	     	}
            //
            // Make the SHARE_ENDED callback.                              
            //
            SC_End();
            break;

        default:
            WARNING_OUT(("invalid state %d for %d", g_s20State, what));
            break;
    }

    DebugExitVOID(S20LeaveOrEndShare);
}

//
// FUNCTION: S20MakeControlPacket                                          
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Attempts to allocate and construct a S20 control packet.                
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// what - which type of packet                                             
//                                                                         
// correlator - the correlator to place in the packet                      
//                                                                         
// who - the target party (if what is a S20_DELETE) or the originator (if  
// what is S20_RESPOND)                                                    
//                                                                         
// ppPacket - where to return a pointer to the packet.                     
//                                                                         
// pLength - where to return the length of the packet.                     
//                                                                         
// priority - priority of packet to make                                   
//                                                                         
// RETURNS:                                                                
//                                                                         
//
UINT S20MakeControlPacket
(
    UINT            what,
    UINT            correlator,
    UINT            who,
    PS20PACKETHEADER * ppPacket,
    LPUINT          pcbPacketSize,
    UINT            priority
)
{
    UINT      rc;
    BOOL      fPutNameAndCaps;
    UINT      cbPacketSize;
    UINT      personNameLength;
    PS20PACKETHEADER  pS20Packet = NULL;
    LPBYTE    pData;

    DebugEntry(S20MakeControlPacket);

    //
    // Assume success                                                      
    //
    rc = 0;

    //
    // Work out how big the packet needs to be.  Start with the fixed      
    // length then add in capabilities and our name (if they are required).
    //
    switch (what)
    {
        case S20_CREATE:
            cbPacketSize = sizeof(S20CREATEPACKET) - 1;
            fPutNameAndCaps = TRUE;
            break;

        case S20_JOIN:
            cbPacketSize = sizeof(S20JOINPACKET) - 1;
            fPutNameAndCaps = TRUE;
            break;

        case S20_RESPOND:
            cbPacketSize = sizeof(S20RESPONDPACKET) - 1;
            fPutNameAndCaps = TRUE;
            break;

        case S20_DELETE:
            cbPacketSize = sizeof(S20DELETEPACKET) - 1;
            fPutNameAndCaps = FALSE;
            break;

        case S20_LEAVE:
            cbPacketSize = sizeof(S20LEAVEPACKET);
            fPutNameAndCaps = FALSE;
            break;

        case S20_END:
            cbPacketSize = sizeof(S20ENDPACKET) - 1;
            fPutNameAndCaps = FALSE;
            break;

        case S20_COLLISION:
            cbPacketSize = sizeof(S20COLLISIONPACKET);
            fPutNameAndCaps = FALSE;
            break;

        default:
            ERROR_OUT(("BOGUS S20 packet %u", what));
            break;
    }

    if (fPutNameAndCaps)
    {
        ASSERT(g_asSession.gccID);
        ASSERT(g_asSession.cchLocalName);

        //
        // The name data is always dword aligned (including the NULL)
        //
        personNameLength = DC_ROUND_UP_4(g_asSession.cchLocalName+1);
        cbPacketSize += personNameLength + sizeof(g_cpcLocalCaps);
    }

    //
    // Now try to allocate a buffer for this.                              
    //
    rc = MG_GetBuffer( g_s20pmgClient,
                       cbPacketSize,
                           (NET_PRIORITY)priority,
                           g_s20BroadcastID,
                           (void **)&pS20Packet );

    if (rc != 0)
    {
        WARNING_OUT(("MG_GetBuffer failed; can't send S20 control packet"));
        DC_QUIT;
    }

    pS20Packet->packetType  = (TSHR_UINT16)what | S20_ALL_VERSIONS;
    pS20Packet->user        = g_s20LocalID;

    //
    // This will point to where we need to stuff the name and/or           
    // capabilities.                                                       
    //
    pData = NULL;

    //
    // Now do the packet dependant fields.                                 
    //
    switch (what)
    {
        case S20_CREATE:
        {
            ASSERT(fPutNameAndCaps);
            ((PS20CREATEPACKET)pS20Packet)->correlator  = correlator;
            ((PS20CREATEPACKET)pS20Packet)->lenName     = (TSHR_UINT16)personNameLength;
            ((PS20CREATEPACKET)pS20Packet)->lenCaps     = (TSHR_UINT16)sizeof(g_cpcLocalCaps);
            pData = ((PS20CREATEPACKET)pS20Packet)->data;
        }
        break;

        case S20_JOIN:
        {
            ASSERT(fPutNameAndCaps);
            ((PS20JOINPACKET)pS20Packet)->lenName       = (TSHR_UINT16)personNameLength;
            ((PS20JOINPACKET)pS20Packet)->lenCaps       = (TSHR_UINT16)sizeof(g_cpcLocalCaps);
            pData = ((PS20JOINPACKET)pS20Packet)->data;
        }
        break;

        case S20_RESPOND:
        {
            ASSERT(fPutNameAndCaps);
            ((PS20RESPONDPACKET)pS20Packet)->correlator = correlator;
            ((PS20RESPONDPACKET)pS20Packet)->originator = (TSHR_UINT16)who;
            ((PS20RESPONDPACKET)pS20Packet)->lenName    = (TSHR_UINT16)personNameLength;
            ((PS20RESPONDPACKET)pS20Packet)->lenCaps    = (TSHR_UINT16)sizeof(g_cpcLocalCaps);
            pData = ((PS20RESPONDPACKET)pS20Packet)->data;
        }
        break;

        case S20_DELETE:
        {
            ASSERT(!fPutNameAndCaps);
            ((PS20DELETEPACKET)pS20Packet)->correlator = correlator;
            ((PS20DELETEPACKET)pS20Packet)->target = (TSHR_UINT16)who;
            ((PS20DELETEPACKET)pS20Packet)->lenName = 0;
        }
        break;

        case S20_LEAVE:
        {
            ASSERT(!fPutNameAndCaps);
            ((PS20LEAVEPACKET)pS20Packet)->correlator = correlator;
        }
        break;

        case S20_END:
        {
            ASSERT(!fPutNameAndCaps);
            ((PS20ENDPACKET)pS20Packet)->correlator = correlator;
            ((PS20ENDPACKET)pS20Packet)->lenName    = 0;
        }
        break;

        case S20_COLLISION:
        {
            ASSERT(!fPutNameAndCaps);
            ((PS20COLLISIONPACKET)pS20Packet)->correlator = correlator;
        }
        break;

        default:
        {
            ERROR_OUT(("Invalid type %u", what));
            rc = NET_RC_S20_FAIL;
            DC_QUIT;
        }
        break;
    }

    //
    // Now we can copy in the name and capabilities.                    
    //
    if (fPutNameAndCaps)
    {
        lstrcpy((LPSTR)pData, g_asSession.achLocalName);

        // The local name is always null-terminated (truncated to fit in 48 bytes inc. null)
        pData += personNameLength;

        memcpy(pData, &g_cpcLocalCaps, sizeof(g_cpcLocalCaps));

        //
        // FILL IN GCC-ID HERE; the local caps are shared but the local
        // person entity in the share doesn't exist yet.
        //
        ((CPCALLCAPS *)pData)->share.gccID = g_asSession.gccID;
    }

    //
    // Return the packet and length.                                       
    //
    *ppPacket       = pS20Packet;
    *pcbPacketSize  = cbPacketSize;

DC_EXIT_POINT:
    DebugExitDWORD(S20MakeControlPacket, rc);
    return(rc);
}

//
// FUNCTION: S20FlushSendOrQueueControlPacket                              
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Attempts to flush any queued S20 control packets and then attempte to   
// send a S20 control packet.  If this fails the queue the packet (the     
// actual packet is freed.                                                 
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// what - which type of packet                                             
//                                                                         
// correlator - the correlator to place in the packet                      
//                                                                         
// who - the target party (if what is a S20_DELETE) or the originator (if  
// what is S20_RESPOND)                                                    
//                                                                         
// priority - priority to send packet at                                   
//                                                                         
// RETURNS: NONE                                                           
//                                                                         
//
UINT S20FlushSendOrQueueControlPacket(
    UINT      what,
    UINT      correlator,
    UINT      who,
    UINT      priority)
{
    UINT rc;

    DebugEntry(S20FlushSendOrQueueControlPacket);

    rc = S20FlushAndSendControlPacket(what, correlator, who, priority);
    if (rc != 0)
    {
        // Let's queue this packet
        if (((g_s20ControlPacketQTail + 1) % S20_MAX_QUEUED_CONTROL_PACKETS) ==
                                                            g_s20ControlPacketQHead)
        {
            //
            // There is no more space in the control packet queue.  We will    
            // discard everything from it and say the share ended because of   
            // a network error (if we're in a share).                          
            //
            ERROR_OUT(("No more space in control packet queue"));
        }
        else
        {
            S20CONTROLPACKETQENTRY *p = &(g_s20ControlPacketQ[g_s20ControlPacketQTail]);

            p->who        = who;
            p->correlator = correlator;
            p->what       = what;
            p->priority   = priority;

            g_s20ControlPacketQTail = (g_s20ControlPacketQTail + 1) %
                                                   S20_MAX_QUEUED_CONTROL_PACKETS;
            rc = 0;
        }
    }

    DebugExitDWORD(S20FlushSendOrQueueControlPacket, rc);
    return rc;
}


//
// FUNCTION: S20FlushAndSendControlPacket                                  
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Attempts to flush any queued S20 control packets and then send a S20    
// control packet.  If sending fails then free the packet.                 
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// what - which type of packet                                             
//                                                                         
// correlator - the correlator to place in the packet                      
//                                                                         
// who - the target party (if what is a S20_DELETE) or the originator (if  
// what is S20_RESPOND)                                                    
//                                                                         
// priority - priority to send packet at                                   
//                                                                         
// RETURNS:                                                                
//                                                                         
//
UINT S20FlushAndSendControlPacket
(
    UINT        what,
    UINT        correlator,
    UINT        who,
    UINT        priority
)
{
    UINT        rc;
    PS20PACKETHEADER  pS20Packet;
    UINT      length;

    DebugEntry(S20FlushAndSendControlPacket);

    //
    // First try to flush.                                                 
    //
    rc = S20SendQueuedControlPackets();
    if (rc != 0)
    {
        WARNING_OUT(("S20SendQueuedControlPackets %u", rc));
        DC_QUIT;
    }

    rc = S20MakeControlPacket(what, correlator, who, &pS20Packet, &length, priority);
    if (rc != 0)
    {
        WARNING_OUT(("S20MakeControlPacket %u", rc));
        DC_QUIT;
    }

    TRACE_OUT(("CP %u %lu %u sent", what, correlator, who));

    rc = S20SendControlPacket(pS20Packet, length, priority);
    if (rc != 0)
    {
        WARNING_OUT(("S20SendControlPacket %u", rc));
        DC_QUIT;
    }

DC_EXIT_POINT:
    DebugExitDWORD(S20FlushAndSendControlPacket, rc);
    return(rc);
}

//
// FUNCTION: S20SendControlPacket                                          
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Attempts to send a S20 control packet.  If sending fails then free the  
// packet.                                                                 
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// pPacket - pointer to the control packet to send.  These are always      
// broadcast.                                                              
//                                                                         
// length - length of aforementioned packet.                               
//                                                                         
// priority - priority to send packet at                                   
//                                                                         
// RETURNS:                                                                
//                                                                         
//
UINT S20SendControlPacket
(
    PS20PACKETHEADER    pS20Packet,
    UINT                length,
    UINT                priority
)
{
    UINT rc;

    DebugEntry(S20SendControlPacket);

    TRACE_OUT(("S20SendControlPacket: sending packet type %x, size %d",
        pS20Packet->packetType, length));

    rc = MG_SendData( g_s20pmgClient,
                          (NET_PRIORITY)priority,
                          g_s20BroadcastID,
                          length,
                          (void **)&pS20Packet );
    if (rc != 0)
    {
        ERROR_OUT(("MG_SendData FAILED !!! %lx", rc));
    }

    if (pS20Packet != NULL)
    {
        //
        // The packet was not freed by the NL - we will do it instead.     
        //
        MG_FreeBuffer(g_s20pmgClient, (void **)&pS20Packet);
    }

    DebugExitDWORD(S20SendControlPacket, rc);
    return(rc);
}


//
// FUNCTION: S20SendQueuedControlPackets                                   
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Sends as many queued packets as possible                                
//                                                                         
// PARAMETERS:                                                             
//                                                                         
//                                                                         
// RETURNS:                                                                
//                                                                         
//  0 - all queued packets have been sent.                         
//                                                                         
//
UINT S20SendQueuedControlPackets(void)
{
    PS20PACKETHEADER    pS20Packet;
    UINT                length;
    UINT                rc;
    UINT                priority;

    DebugEntry(S20SendQueuedControlPackets);

    //
    // Assume success until something fails.                               
    //
    rc = 0;

    //
    // While there are packets to send - try to send them                  
    //
    while (g_s20ControlPacketQTail != g_s20ControlPacketQHead)
    {
        S20CONTROLPACKETQENTRY *p = &(g_s20ControlPacketQ[g_s20ControlPacketQHead]);
        priority = p->priority;

        rc = S20MakeControlPacket(p->what, p->correlator, p->who,
                                      &pS20Packet, &length, priority);
        if (rc != 0)
        {
            //
            // Failed to make the packet - give up.                        
            //
            WARNING_OUT(("S20MakeControlPacket failed error %u", rc));
            break;
        }

        rc = S20SendControlPacket(pS20Packet, length, priority);
        if (rc != 0)
        {
           ERROR_OUT(("MG_SendData FAILED !!! %lx", rc));
        
            //
            // Failed to send the packet - give up.                        
            //
            break;
        }

        //
        // Succesfully sent the queue packet - move the head of the queue  
        // along one.                                                      
        //
        g_s20ControlPacketQHead = (g_s20ControlPacketQHead + 1) %
                                               S20_MAX_QUEUED_CONTROL_PACKETS;
    }

    DebugExitDWORD(S20SendQueuedControlPackets, rc);
    return(rc);
}


//
// S20AttachConfirm()
//
// Handles the MCS attach confirmation
//
void S20AttachConfirm
(
    NET_UID         userId,
    NET_RESULT      result,
    UINT            callID
)
{
    NET_CHANNEL_ID  correlator;
    UINT            rc;

    DebugEntry(S20AttachConfirm);

    if (g_s20State == S20_ATTACH_PEND)
    {
        //
        // Assume we need to clear up.                                 
        //
        rc = NET_RC_S20_FAIL;

        if (result == NET_RESULT_OK)
        {
			//
			// We're in.  Now try to join our channel and remember our
			// userID.                                                 
			//
			g_s20LocalID = userId;

            //
            // We must join our single member channel for flow control 
            //
            rc = MG_ChannelJoin(g_s20pmgClient,
                                    &correlator,
                                    g_s20LocalID);
            if (rc == 0)
            {
                //
                // Now join the broadcast channel                      
                //
                rc = MG_ChannelJoinByKey(g_s20pmgClient,
                                             &correlator,
                                             GCC_AS_CHANNEL_KEY);
                if (rc != 0)
                {
                    MG_ChannelLeave(g_s20pmgClient, g_s20LocalID);
                }

            }

            if (rc == 0)
            {
                //
                // It worked - make the state change.                  
                //
				SetS20State(S20_JOIN_PEND);
            }
            else
            {
                //
                // Everything else is some sort of logic error (we will
                // follow our recovery path).                          
                //
                ERROR_OUT(("ChannelJoin unexpected error %u", rc));
            }
        }

        if (rc != 0)
        {
            //
            // Something didn't work work out - clear up with a        
            // SHARE_ENDED if a create or join was pending.            
            //

            if (result == NET_RESULT_OK)
            {
                //
                // The attach succeeded so detach because the join     
                // failed and we want to go back to initialised state. 
                //
                MG_Detach(g_s20pmgClient);
                g_s20LocalID = 0;
            }

            //
            // Now make the state change and generate event if         
            // necessary.                                              
            //
			SetS20State(S20_INIT);

            if (g_s20Pend)
            {
                g_s20Pend = 0;
                SC_End();
            }

        }
    }

    DebugExitVOID(S20AttachConfirm);
}



//
// S20DetachIndication()
//
// Handles NET_EVENT_DETACH notification for a user
//
void  S20DetachIndication
(
    NET_UID     userId,
    UINT        callID
)
{
    DebugEntry(S20DetachIndication);

    //
    // There are three possibilities here                                  
    //                                                                     
    //  1.  We have been forced out.                                       
    //  2.  All remote users have detached.                                
    //  3.  A remote user has detached.                                    
    //                                                                     
    // 2 is effectively a 3 for each current remote user.  We report 1 as a
    // network error.                                                      
    //
    if (userId == g_s20LocalID)
    {
        //
        // We have been forced out.                                        
        //
        switch (g_s20State)
        {
            case S20_IN_SHARE:
            case S20_SHARE_PEND:
            case S20_SHARE_STARTING:
                //
                // Generate a share ended event.                           
                //
                SC_End();

                // FALL THROUGH
            case S20_NO_SHARE:
                //
                // Just revert to init state.                              
                //
				SetS20State(S20_INIT);
                break;

            case S20_JOIN_PEND:
            case S20_ATTACH_PEND:
                //
                // Check the join or create pending flags here and if      
                // either one is set then generate a share ended           
                //
                if (g_s20Pend)
                {
                    g_s20Pend = 0;
                    SC_End();
                }
				SetS20State(S20_INIT);
                break;

            case S20_TERM:
            case S20_INIT:
                //
                // Unusual but not impossible.                             
                //
                TRACE_OUT(("Ignored in state %u", g_s20State));
                break;

            default:
                ERROR_OUT(("Invalid state %u", g_s20State));
                break;
        }

	WARNING_OUT(("S20DetachIndication <MAKING LOCALID = 0"));
	g_s20LocalID = 0;

    }
    else
    {
        ASSERT(userId != NET_ALL_REMOTES);

        //
        // A single remote user has left.                                  
        //
        switch (g_s20State)
        {
            case S20_IN_SHARE:
            {
                //
                // If we are in a share then issue a PARTY_DELETED event   
                // for the appropriate party if they have been added.      
                // S20MaybeIssuePersonDelete will only issue deletes for   
                // parties which have been added succesfully.              
                //
                S20MaybeIssuePersonDelete(userId);
            }
            break;

            default:
            {
                //
                // In any other state this makes no difference to us.      
                //
                TRACE_OUT(("ignored in state %u", g_s20State));
            }
            break;
        }
    }

    DebugExitVOID(S20DetachIndication);
}


//
// FUNCTION: S20JoinConfirm                                                
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Handles the NET_EVENT_CHANNEL_JOIN message from the NL              
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// pNetEventHeader - pointer to the event                                  
//                                                                         
// RETURNS: NONE                                                           
//                                                                         
//
void  S20JoinConfirm(PNET_JOIN_CNF_EVENT pJoinConfirm)
{
    UINT             rc;

    DebugEntry(S20JoinConfirm);

    if (g_s20State == S20_JOIN_PEND)
    {
        //
        // Handle the join completing                                  
        //
        if (pJoinConfirm->result == NET_RESULT_OK)
        {
            //
            // We have sucessfully joined, either our single user      
            // channel or our broadcast channel                        
            // We detect that both are successful when the g_s20BroadcastID
            // field is filled in and g_s20JoinedLocal is TRUE          
            //
            if (pJoinConfirm->channel == g_s20LocalID)
            {
                g_s20JoinedLocal = TRUE;
                TRACE_OUT(("Joined user channel"));
            }
            else
            {
                //
                // Store the assigned channel.                         
                //
                g_s20BroadcastID = pJoinConfirm->channel;
                TRACE_OUT(("Joined channel %u", (UINT)g_s20BroadcastID));
            }

            //
            // If we have joined both channels then let it rip         
            //
            if (g_s20JoinedLocal && g_s20BroadcastID)
            {
				SetS20State(S20_NO_SHARE);

                if (g_asSession.hwndHostUI &&
                    (g_asSession.attendeePermissions & NM_PERMIT_SHARE))
                {
                    SendMessage(g_asSession.hwndHostUI, HOST_MSG_CALL, TRUE, 0);
                }

                DCS_NotifyUI(SH_EVT_APPSHARE_READY, TRUE, 0);

                //
                // Issue create or join if they are pending.           
                //
                if (g_s20Pend != 0)
                {
                    ASSERT(g_s20Pend == S20_JOIN);

                    UINT sPend;

                    sPend = g_s20Pend;
                    g_s20Pend = 0;
                    S20CreateOrJoinShare(sPend, pJoinConfirm->callID);
                }
            }
        }
        else
        {
            ERROR_OUT(("Channel join failed"));

            //
            // Clear up by reverting to initialised state.             
            //
            MG_Detach(g_s20pmgClient);

            g_s20LocalID  = 0;
            g_s20BroadcastID = 0;
            g_s20JoinedLocal = FALSE;

            //
            // Now make the state change and generate event if         
            // necessary.                                              
            //
			SetS20State(S20_INIT);

            if (g_s20Pend)
            {
                g_s20Pend = 0;
                SC_End();
            }
        }
    }
    DebugExitVOID(S20JoinConfirm);
}

//
// FUNCTION: S20LeaveIndication                                            
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Handles the NET_EV_LEAVE_INDICATION message from the NL                 
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// pNetEventHeader - pointer to the event                                  
//                                                                         
// RETURNS: NONE                                                           
//                                                                         
//
void  S20LeaveIndication
(
    NET_CHANNEL_ID  channelID,
    UINT            callID
)
{
    UINT rc;

    DebugEntry(S20LeaveIndication);

    //
    // A leave indication means we were forced out of a channel.  As we    
    // only use one channel this is bound to be terminal and we will       
    // generate appropriate share ending type events and detach (this will 
    // hopefully tell the remote systems we have gone - also we have no    
    // state which is attached but not trying to join so the alternatives  
    // would be to 1) add a new state or 2) try and re-join a channel      
    // immediately we get chucked out.  Neither appeals.                   
    //
    switch (g_s20State)
    {
        case S20_IN_SHARE:
        case S20_SHARE_PEND:
        case S20_SHARE_STARTING:
            //
            // Generate a share ended event.                               
            //
            SC_End();

            // FALL THROUGH

        case S20_NO_SHARE:
        case S20_JOIN_PEND:
        case S20_ATTACH_PEND:
            //
            // Detach from the domain.                                     
            //
            MG_Detach(g_s20pmgClient);
            g_s20LocalID = 0;

            //
            // Check the join or create pending flags here and if either   
            // one is set then generate a share ended                      
            //
            if (g_s20Pend)
            {
                g_s20Pend = 0;
                SC_End();
            }

			SetS20State(S20_INIT);
            break;

        case S20_TERM:
        case S20_INIT:
            //
            // Unusual but not impossible.                                 
            //
            TRACE_OUT(("Ignored in state %u", g_s20State));
            break;

        default:
            ERROR_OUT(("Invalid state %u", g_s20State));
            break;
    }

    DebugExitVOID(S20LeaveIndication);
}


//
// S20SendIndication()
//
// Handles received data notification
//
void  S20SendIndication(PNET_SEND_IND_EVENT pSendIndication)
{
    PS20PACKETHEADER        pS20Packet;

    DebugEntry(S20SendIndication);

    pS20Packet = (PS20PACKETHEADER)(pSendIndication->data_ptr);

	//
	// If App Sharing detaches from the T.120 conference, it will free up
	// all data indication buffers.  We need to check for this condition.
	//
    if (NULL != pS20Packet)
    {
	    if (!(pS20Packet->packetType & S20_ALL_VERSIONS))
	    {
	        ERROR_OUT(("User is trying to connect from %#hx system",
	                 pS20Packet->packetType & 0xF0));

	        //
	        // This should never happen, but if it does then we assert in the  
	        // debug build and quietly fail in the retail build.               
	        //
	        ERROR_OUT(("An unsupported version of app sharing joined the conference"));
	        DC_QUIT;
	    }

	    //
	    // Mask out the protocol version                                       
	    //
	    switch (pS20Packet->packetType & S20_PACKET_TYPE_MASK)
	    {
	        case S20_CREATE:
	            S20CreateMsg((PS20CREATEPACKET)pS20Packet);
	            break;

	        case S20_JOIN:
	            S20JoinMsg((PS20JOINPACKET)pS20Packet);
	            break;

	        case S20_RESPOND:
	            S20RespondMsg((PS20RESPONDPACKET)pS20Packet);
	            break;

	        case S20_DELETE:
	            S20DeleteMsg((PS20DELETEPACKET)pS20Packet);
	            break;

	        case S20_LEAVE:
	            S20LeaveMsg((PS20LEAVEPACKET)pS20Packet);
	            break;

	        case S20_END:
	            S20EndMsg((PS20ENDPACKET)pS20Packet);
	            break;

            case S20_COLLISION:
                S20CollisionMsg((PS20COLLISIONPACKET)pS20Packet);
                break;

	        case S20_DATA:
	            S20DataMsg((PS20DATAPACKET)pS20Packet);
	            break;

	        default:
	            ERROR_OUT(("invalid packet %hu", pS20Packet->packetType));
	            break;
	    }
    }

DC_EXIT_POINT:
    MG_FreeBuffer(g_s20pmgClient, (void **)&pSendIndication);

    DebugExitVOID(S20SendIndication);
}


//
// FUNCTION: S20Flow                                                       
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Handles the NET_FLOW event                                              
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// data1, data2 - the data from the UT event handler                       
//                                                                         
// RETURNS: NONE                                                           
//                                                                         
//
void S20Flow
(
    UINT    priority,
    UINT    newBufferSize
)
{
    DebugEntry(S20Flow);

    //
    // We know this is our data channel (it is the only one we flow        
    // control) but if this is not the UPDATE stream, then ignore it.
    // UPDATEs are low priority.
    //
    ASSERT(priority == NET_LOW_PRIORITY);

    if (g_asSession.pShare != NULL)
    {
        TRACE_OUT(("Received flow control notification, new size %lu",
               newBufferSize));

        if (g_asSession.pShare->m_pHost != NULL)
        {
            //
            // First try and improve the LAN performance by sending orders in  
            // large buffers, if we find that the throughput can handle it.    
            //
            g_asSession.pShare->m_pHost->UP_FlowControl(newBufferSize);

            //
            // Adjust the depth which we try to spoil orders to based on       
            // feedback.                                                       
            //
            g_asSession.pShare->m_pHost->OA_FlowControl(newBufferSize);
        }

        //
        // Tell DCS so that we can skip GDC compression.                       
        // This improves responsiveness over high bandwidth links because it   
        // reduces the CPU loading on the sender                               
        //
        g_asSession.pShare->DCS_FlowControl(newBufferSize);
    }

    DebugExitVOID(S20Flow);
}

//
// FUNCTION: S20CreateMsg                                                  
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Handles an incoming create message.                                     
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// pS20Packet - pointer to the create message itself                       
//                                                                         
// RETURNS: NONE                                                           
//
void  S20CreateMsg
(
    PS20CREATEPACKET  pS20Packet
)
{
    BOOL    rc;

    DebugEntry(S20CreateMsg);

    WARNING_OUT(("S20_CREATE from [%d - %s], correlator %x",
        pS20Packet->header.user, (LPSTR)pS20Packet->data,
        pS20Packet->correlator));

    //
    // First of all check if the correlator on this CREATE is the same as  
    // our current view of the correlator.  This may happen if a sweep     
    // RESPOND overtakes a CREATE - in this case we will create the share  
    // on the RESPOND and this is simply the delayed CREATE arriving now so
    // we don't need to do anything here.                                  
    //
    if (g_s20ShareCorrelator == pS20Packet->correlator)
    {
        WARNING_OUT(("Received S20_CREATE from [%d] with bogus correlator %x",
            pS20Packet->header.user, pS20Packet->correlator));
        DC_QUIT;
    }

    if ((g_s20State == S20_NO_SHARE) ||
        ((g_s20State == S20_SHARE_PEND) &&
         (g_s20ShareCorrelator == 0)))
    {
		rc = S20AcceptNewCorrelator(pS20Packet);
    }
    else if ((g_s20State == S20_SHARE_PEND) ||
             (g_s20State == S20_SHARE_STARTING) ||
             (g_s20State == S20_IN_SHARE))
    {
        //
        // Only current share creator should tell other dude there's an
        // error.
        //
        if (S20_GET_CREATOR(g_s20ShareCorrelator) == g_s20LocalID)
        {
            //
            // If we know about a share already then ignore this one.
            //
            WARNING_OUT(("Received S20_CREATE from [%d] with correlator %x, share colllision",
                pS20Packet->header.user, pS20Packet->correlator));

            S20FlushSendOrQueueControlPacket(S20_END,
                pS20Packet->correlator, 0, NET_TOP_PRIORITY);
            S20FlushSendOrQueueControlPacket(S20_COLLISION,
                pS20Packet->correlator, 0, NET_TOP_PRIORITY);
        }
	}
	else
	{
		SC_End();
		SetS20State(S20_NO_SHARE);

		rc = S20AcceptNewCorrelator(pS20Packet);
    }

DC_EXIT_POINT:
    DebugExitVOID(S20CreateMsg);
}

//
// FUNCTION: S20JoinMsg                                                    
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Handles an incoming join message.                                       
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// pS20Packet - pointer to the join message itself                         
//                                                                         
// RETURNS: NONE                                                           
//
void  S20JoinMsg
(
    PS20JOINPACKET  pS20Packet
)
{
    DebugEntry(S20JoinMsg);

    WARNING_OUT(("S20_JOIN from [%d - %s]",
        pS20Packet->header.user, (LPSTR)pS20Packet->data));

    switch (g_s20State)
    {
        case S20_SHARE_PEND:
            //
            // If we receive a join when a share is pending which we are   
            // creating then we will try to add the party.  If it succeeds 
            // then we will respond to the join as we would if we were in a
            // share (and we will indeed then be in a share).  If it fails 
            // we will delete the joiner.                                  
            //                                                             
            // If we receive a join when a share is pending because we are 
            // trying to join (ie simultaneous joiners) then we can just   
            // ignore it because a party which is joining a share will send
            // a respond as soon as they know the correlator for the share 
            // they have succesfully joined.  This respond will be ignored 
            // by any parties which saw and added the new party but it will
            // be seen by any simultaneous joiners and they will then get a
            // chance to try and add the other joiner.  If this fails they 
            // will then do the normal processing for a failure handling a 
            // respond message when we joined a share (ie delete           
            // themselves).                                                
            //                                                             
            // This will potentially mean that simultaneous joiners will   
            // cause each other to delete themselves when there was room   
            // for one of them in the share - we accept this.              
            //

            //
            // Why is the share pending?  If the correlator is non-zero    
            // then we are creating a share.                               
            //
            if (g_s20ShareCorrelator != 0)
            {
                //
                // We are creating a share - treat this like a respond.    
                //
                WARNING_OUT(("S20JoinMsg SC_Start"));
                if (!SC_Start(g_s20LocalID))
                {
                    WARNING_OUT(("S20Join: couldn't create share, clean up"));
                    SC_End();
                }
                else
                {
					SetS20State(S20_SHARE_STARTING);

                    S20MaybeAddNewParty(pS20Packet->header.user,
                        pS20Packet->lenCaps, pS20Packet->lenName,
                        pS20Packet->data);
                }
            }
            else
            {
                //
                // We are joining a share - simultaneous joiners.          
                //
                WARNING_OUT(("Simultaneous joiner - ignored for now, expect a respond"));
            }
            break;

        case S20_IN_SHARE:
        case S20_SHARE_STARTING:
        {
            //
            // When we are in a share we will try and add this person then 
            // give them a respond or a delete depending on what we did.   
            //
            S20MaybeAddNewParty(pS20Packet->header.user,
                pS20Packet->lenCaps, pS20Packet->lenName,
                pS20Packet->data);
            break;
        }

        default:
            break;
    }

    DebugExitVOID(S20JoinMsg);
}


//
// FUNCTION: S20RespondMsg                                                 
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Handles an incoming respond message.                                    
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// pS20Packet - pointer to the respond message itself                      
//                                                                         
// RETURNS: NONE                                                           
//
void  S20RespondMsg
(
    PS20RESPONDPACKET  pS20Packet
)
{
    BOOL        rc;

    DebugEntry(S20RespondMsg);

    TRACE_OUT(("S20_RESPOND from [%d - %s], for [%d], correlator %x",
        pS20Packet->header.user, pS20Packet->data, pS20Packet->originator,
        pS20Packet->correlator));

    //
    // First filter the incoming respond messages as follows.              
    //                                                                     
    // If we know what share we are in and this does not have the same     
    // correlator then respond with a delete and don't process any further.
    //                                                                     
    // If the respond is not a response for us (ie we are not the          
    // originator and it is not a sweep-up response (the originator equals 
    // zero) then ignore it.                                               
    //
    if ((g_s20ShareCorrelator != 0) &&
        (pS20Packet->correlator != g_s20ShareCorrelator))
    {
        //
        // Make sure sender knows we're not in this share.
        //
        WARNING_OUT(("S20_RESPOND from [%d] with unknown correlator %x",
            pS20Packet->header.user, pS20Packet->correlator));
        S20FlushSendOrQueueControlPacket(S20_LEAVE,
            pS20Packet->correlator, 0, NET_TOP_PRIORITY);
        DC_QUIT;
    }

    //
    // Now handle incoming message according to state.                     
    //
    switch (g_s20State)
    {
        case S20_SHARE_PEND:
            if ((pS20Packet->originator == g_s20LocalID) ||
                (pS20Packet->originator == 0))
            {
                //
                // A respond in share pending and it is for us.  First,    
                // start a share.                                          
                //
		WARNING_OUT(("S20RespondMsg SC_Start"));                
                rc = SC_Start(g_s20LocalID);
                if (!rc)
                {
                    SC_End();
                }
                else
                {
					SetS20State(S20_SHARE_STARTING);

                    //
                    // Why is the share pending?  If the correlator is non-zero
                    // then we are creating a share.                           
                    //
                    if (g_s20ShareCorrelator == 0)
                    {
						//
						// We are joining a share so do nothing if we fail (we 
						// will move back to NO_SHARE state if this happens).  
						//
				   		WARNING_OUT(("g_s20ShareCorrelator %x = pS20Packet->correlator %x", g_s20ShareCorrelator , pS20Packet->correlator));
						g_s20ShareCorrelator = pS20Packet->correlator;
                    }

                    //
                    // Now try and add this new party.                         
                    //
                    rc = S20MaybeAddNewParty(pS20Packet->header.user,
                        pS20Packet->lenCaps, pS20Packet->lenName,
                        pS20Packet->data);

                    if (!rc)
                    {

                        //
                        // The responding party has been rejected by us.  What 
                        // happens next depends on whether we are creating the 
                        // share or not.                                       
                        //
                        if (S20_GET_CREATOR(g_s20ShareCorrelator) != g_s20LocalID)
                        {
                            //
                            // We are not creating (ie we are joining) and we  
                            // have failed to add a party so end the share     
                            // (indicating that we are rejecting the remote    
                            // party).                                         
                            //
				WARNING_OUT(("S20Respond we are going to end"));
                            
                            SC_End();
                        }

                        //
                        // If we were creating the share then there is nothing 
                        // to do - just stay in SHARE_STARTING waiting for the 
                        // next response.                                      
                        //
                    }
                }
            }
            break;

        case S20_IN_SHARE:
        case S20_SHARE_STARTING:
            //
            // Who created this share.  If it was us then we want to       
            // delete people we reject, otherwise we want to leave if we   
            // reject people.                                              
            //

            //
            // Now try and add this new party.  Of course it is entirely   
            // possible that we've already added them at this stage - but  
            // S20MaybeAddNewParty will just pretend to add them and return
            // if that's the case.                                         
            //
            rc = S20MaybeAddNewParty(pS20Packet->header.user,
                pS20Packet->lenCaps, pS20Packet->lenName,
                pS20Packet->data);

            if (!rc)
            {
                WARNING_OUT(("Couldn't add [%d] to our share party list",
                    pS20Packet->header.user));
            }
            break;

        default:
            break;
    }

DC_EXIT_POINT:
    DebugExitVOID(S20RespondMsg);
}

//
// FUNCTION: S20DeleteMsg                                                  
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Handles an incoming delete message.                                     
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// pS20Packet - pointer to the delete message itself                       
//                                                                         
// RETURNS: NONE                                                           
//
void  S20DeleteMsg
(
    PS20DELETEPACKET  pS20Packet
)
{
    DebugEntry(S20DeleteMsg);

    TRACE_OUT(("S20_DELETE from [%d], for [%d], correlator %x",
        pS20Packet->header.user, pS20Packet->target, pS20Packet->correlator));

    //
    // ONLY SHARE CREATOR can delete people from share
    //

    if (!g_s20ShareCorrelator)
    {
        WARNING_OUT(("S20_DELETE, ignoring we're not in a share"));
        DC_QUIT;
    }

    if (pS20Packet->target != g_s20LocalID)
    {
        //
        // Not for us, ignore.
        //
        DC_QUIT;
    }

    if (g_s20ShareCorrelator != pS20Packet->correlator)
    {
        WARNING_OUT(("Received S20_DELETE from [%d] with unknown correlator %x",
            pS20Packet->header.user, pS20Packet->correlator));
        S20FlushSendOrQueueControlPacket(S20_LEAVE, pS20Packet->correlator,
            0, NET_TOP_PRIORITY);
        DC_QUIT;
    }

    if (S20_GET_CREATOR(g_s20ShareCorrelator) != pS20Packet->header.user)
    {
        WARNING_OUT(("Received S20_DELETE from [%d] who did not create share, ignore",
            pS20Packet->header.user));
        DC_QUIT;
    }

    //
    // Now handle incoming messages according to state.                    
    //
    switch (g_s20State)
    {
        case S20_SHARE_PEND:
        case S20_SHARE_STARTING:
            //
            // Just tell everyone else we're leaving and then issue a      
            // SHARE_ENDED event.                                          
            //
            TRACE_OUT(("CP LEAVE %lu %d", g_s20ShareCorrelator, 0));
            S20FlushSendOrQueueControlPacket(S20_LEAVE,
                                             g_s20ShareCorrelator,
                                             0,
                                             NET_TOP_PRIORITY);
            // FALL THROUGH

        case S20_IN_SHARE:
            SC_End();
			SetS20State(S20_NO_SHARE);
            break;

        default:
            break;
    }

DC_EXIT_POINT:
    DebugExitVOID(S20DeleteMsg);
}


//
// FUNCTION: S20LeaveMsg                                                   
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Handles an incoming leave message.                                      
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// pS20Packet - pointer to the leave message itself                        
//                                                                         
// RETURNS: NONE                                                           
//
void  S20LeaveMsg(PS20LEAVEPACKET  pS20Packet)
{
    DebugEntry(S20LeaveMsg);

    TRACE_OUT(("S20_LEAVE from [%d], correlator %x",
        pS20Packet->header.user, pS20Packet->correlator));

    if (!g_s20ShareCorrelator)
    {
        WARNING_OUT(("S20_LEAVE, ignoring we're not in a share"));
        DC_QUIT;
    }

    if (g_s20ShareCorrelator != pS20Packet->correlator)
    {
        WARNING_OUT(("S20LeaveMsg Received S20_LEAVE from [%d] for unknown correlator %x",
            pS20Packet->header.user, pS20Packet->correlator));
        DC_QUIT;
    }

    switch (g_s20State)
    {
        case S20_IN_SHARE:
            //
            // We only need to handle this when we are in a share.         
            //
            S20MaybeIssuePersonDelete(pS20Packet->header.user);
            break;

        default:
            break;
    }

DC_EXIT_POINT:
    DebugExitVOID(S20LeaveMsg);
}


//
// FUNCTION: S20EndMsg                                                     
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Handles an incoming end message.                                        
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// pS20Packet - pointer to the end message itself                          
//                                                                         
// RETURNS: NONE                                                           
//
void  S20EndMsg(PS20ENDPACKET  pS20Packet)
{
    DebugEntry(S20EndMsg);

    WARNING_OUT(("S20EndMsg S20_END from [%d], correlator %x",
        pS20Packet->header.user, pS20Packet->correlator));

    if (!g_s20ShareCorrelator)
    {
        // We don't care
        WARNING_OUT(("S20EndMsg S20_END ignored, not in share and state is %x", g_s20State));
        DC_QUIT;
    }

    //
    // Only the share creator can end the share.
    //
    if (S20_GET_CREATOR(g_s20ShareCorrelator) != pS20Packet->header.user)
    {
        WARNING_OUT(("S20EndMsg Received S20_END from [%d] who did not create share, simply remove from user list.",
            pS20Packet->header.user));
        if (g_s20State == S20_IN_SHARE)
        {
            S20MaybeIssuePersonDelete(pS20Packet->header.user);
        }
        DC_QUIT;
    }

    switch (g_s20State)
    {
        case S20_IN_SHARE:
        case S20_SHARE_PEND:
        case S20_SHARE_STARTING:
            //
            // We just need to generate a share ended event.               
            //
            SC_End();
			SetS20State(S20_NO_SHARE);
            break;

        default:
		WARNING_OUT(("S20EndMsg Unhandled case g_s20State %x",g_s20State));
            break;
    }

DC_EXIT_POINT:
    DebugExitVOID(S20EndMsg);
}



//
// S20CollisionMsg()
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Handles an incoming collision message.                                        
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// pS20Packet - pointer to the collision message itself                          
//                                                                         
// RETURNS: NONE                                                           
//
void  S20CollisionMsg(PS20COLLISIONPACKET pS20Packet)
{
    DebugEntry(S20CollisionMsg);

    WARNING_OUT(("S20_COLLISION from [%d], correlator %x",
        pS20Packet->header.user, pS20Packet->correlator));

    if (!g_s20ShareCorrelator)
    {
        // We don't care
        WARNING_OUT(("S20_COLLISION ignored, not in share"));
        DC_QUIT;

    }

    if (g_s20ShareCorrelator != pS20Packet->correlator)
    {
        //
        // Just discard this.                                              
        //
        WARNING_OUT(("Received S20_COLLISION from [%d] with unknown correlator %x",
            pS20Packet->header.user, pS20Packet->correlator));
        DC_QUIT;
    }

    //
    // If we created our own share, but got a collision from the remote, 
    // then kill our share.
    //
    if (S20_GET_CREATOR(g_s20ShareCorrelator) != g_s20LocalID)
    {
        TRACE_OUT(("S20_COLLISION ignored, we didn't create share"));
        DC_QUIT;
    }

    switch (g_s20State)
    {
        case S20_IN_SHARE:
        case S20_SHARE_PEND:
        case S20_SHARE_STARTING:
            //
            // We just need to generate a share ended event.               
            //
            SC_End();
			SetS20State(S20_NO_SHARE);
            break;

        default:
			WARNING_OUT(("S20ColisionMsg Unhandled case g_s20State %x",g_s20State));
            break;
    }

DC_EXIT_POINT:
    DebugExitVOID(S20CollisionMsg);
}


//
// FUNCTION: S20DataMsg                                                    
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Handles an incoming data message.                                       
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// pS20Packet - pointer to the data message itself                         
//                                                                         
// RETURNS: TRUE - free the event, FALSE - do not free the event           
//
void S20DataMsg(PS20DATAPACKET  pS20Packet)
{
    DebugEntry(S20DataMsg);

    ASSERT(!IsBadWritePtr(pS20Packet, sizeof(S20DATAPACKET)));
    ASSERT(!IsBadWritePtr(pS20Packet, sizeof(S20DATAPACKET) - sizeof(DATAPACKETHEADER) +
        pS20Packet->dataLength));

    //
    // Check if we're interseted in this data.                             
    //
    if ((pS20Packet->correlator == g_s20ShareCorrelator) &&
        (g_s20State == S20_IN_SHARE) &&
        g_asSession.pShare)
    {
        //
        // Return it.
        //
        g_asSession.pShare->SC_ReceivedPacket(pS20Packet);
    }

    DebugExitVOID(S20DataMsg);
}


//
// FUNCTION: S20MaybeAddNewParty                                           
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// If the specified party has not already been added then try to add them  
// now.                                                                    
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// userID     - the new party's network user ID.                           
// lenCaps    - the length of the new party's capabilities.                
// lenName    - the length of the new party's name.                        
// pData      - a pointer to the new party's data which contains the name  
//               followed by the capabilities data.                        
//                                                                         
// RETURNS: 
// BOOL for success
//
BOOL  S20MaybeAddNewParty
(
    MCSID   mcsID,
    UINT    lenCaps,
    UINT    lenName,
    LPBYTE  pData
)
{
    BOOL    rc = FALSE;
    UINT    oldState;
    LPBYTE  pCaps        = NULL;
    BOOL    memAllocated = FALSE;

    DebugEntry(S20MaybeAddNewParty);

    //
    // If we don't have a share, fail.
    //
    if (!g_asSession.pShare)
    {
        WARNING_OUT(("No ASShare; ignoring add party for [%d]", mcsID));
        DC_QUIT;
    }

    //
    // Check if this party has already been added.            
    //
    if (g_asSession.pShare->SC_ValidateNetID(mcsID, NULL))
    {
        TRACE_OUT(("S20MaybeAddNewParty: already added %u", mcsID));
        rc = TRUE;
        DC_QUIT;
    }

    //
    // We need the caps structure to be 4-byte aligned.  It currently      
    // follows a variable-length name string and may therefore not be      
    // aligned.  If it is not aligned, we allocate an aligned buffer and   
    // copy it there.                                                      
    //
    if (0 != (((UINT_PTR)pData + lenName) % 4))
    {
        TRACE_OUT(("Capabilities data is unaligned - realigning"));

        //
        // Get a 4-byte aligned buffer for the capabilities data.          
        //
        pCaps = new BYTE[lenCaps];
        if (!pCaps)
        {
            ERROR_OUT(("Could not allocate %u bytes for aligned caps.",
                     lenCaps));
            DC_QUIT;
        }

        //
        // Flag so we know to free the memory later.                       
        //
        memAllocated = TRUE;

        //
        // Copy the caps data into our 4-byte aligned memory block.        
        //
        memcpy(pCaps, (pData + lenName), lenCaps);
    }
    else
    {
        //
        // The capabilities data is already aligned so we don't need to    
        // move it.                                                        
        //
        pCaps = pData + lenName;
    }

    //
    // Make sure we are in a share before we issue person add events.      
    //
    oldState = g_s20State;
	SetS20State(S20_IN_SHARE);

    //
    // Attempt to add the new party.                                       
    //
    rc = g_asSession.pShare->SC_PartyAdded(mcsID, (LPSTR)pData, lenCaps, pCaps);
    if (rc)
    {
        //
        // The new party has been accepted so send a response packet.  Do
        // this at ALL priorities, so it gets there before any type of data
        // at one particular priority.
        //
        WARNING_OUT(("CP RESPOND %lu %d", g_s20ShareCorrelator, 0));
        S20FlushSendOrQueueControlPacket(S20_RESPOND, g_s20ShareCorrelator,
                mcsID, NET_TOP_PRIORITY | NET_SEND_ALL_PRIORITIES);
    }
    else
    {
        g_asSession.pShare->SC_PartyDeleted(mcsID);

        //
        // Reset the state back to what it was if we failed.               
        //
		SetS20State(oldState);
        WARNING_OUT(("S20MaybeAddNewParty g_s20State is %x because we could not add the party", g_s20State));

        if (S20_GET_CREATOR(g_s20ShareCorrelator) == g_s20LocalID)
        {
             //
             // The new party has been rejected so send a delete packet.   
             //
             WARNING_OUT(("S20MaybeAddNewParty CP DELETE %lu %u", g_s20ShareCorrelator, mcsID));
             S20FlushSendOrQueueControlPacket(S20_DELETE, g_s20ShareCorrelator,
                    mcsID, NET_TOP_PRIORITY);
        }
    }

DC_EXIT_POINT:
    //
    // Free memory used to store aligned caps.                             
    //
    if (memAllocated)
    {
        delete[] pCaps;
    }

    DebugExitBOOL(S20MaybeAddNewParty, rc);
    return(rc);
}


//
// FUNCTION: S20NewCorrelator                                              
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Returns a new correlator for us to use when we are creating a share.    
// This is a combination of our mcsID (low 16 bits in Intel format) and   
// a generation count (high 16 bits in Intel format).                      
//                                                                         
// PARAMETERS: NONE                                                        
//                                                                         
// RETURNS: the new correlator                                             
//                                                                         
//
UINT  S20NewCorrelator(void)
{
    UINT    correlator;

    DebugEntry(S20NewCorrelator);

    g_s20Generation++;

    correlator = g_s20LocalID | (((UINT)(g_s20Generation & 0xFFFF)) << 16);
WARNING_OUT(("Getting a new correlator %x local id = %x",correlator, g_s20LocalID));

    DebugExitDWORD(S20NewCorrelator, correlator);
    return(correlator);
}




//
// FUNCTION: S20MaybeIssuePersonDelete                                     
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// If the supplied person is in the share then issue a PARTY_DELETED event 
// for them.                                                               
//                                                                         
// PARAMTERS:                                                              
//                                                                         
// mcsID - a network personID                                               
//                                                                         
// reason - the reason code to use                                         
//                                                                         
// RETURNS: NONE                                                           
//                                                                         
//
void  S20MaybeIssuePersonDelete(MCSID mcsID)
{
    DebugEntry(S20MaybeIssuePersonDelete);

    if (g_asSession.pShare)
    {
        g_asSession.pShare->SC_PartyDeleted(mcsID);
    }

    //
    // HET will kill the share if there aren't any hosts left.  So we 
    // don't need to do anything here.
    //

    DebugExitVOID(S20MaybeIssuePersonDelete);
}

//
// FUNCTION: S20StreamToS20Priority                                     
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Converts a stream ID into a NET priority                                
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// streamID - the stream ID.                                               
//                                                                         
// RETURNS: the priority                                                   
//                                                                         
//
const NET_PRIORITY c_StreamS20Priority[NUM_PROT_STR - 1] =
{
    NET_LOW_PRIORITY,       // PROT_STR_UPDATES
    NET_MEDIUM_PRIORITY,    // PROT_STR_MISC
    NET_MEDIUM_PRIORITY,    // PROT_STR_UNUSED
    NET_MEDIUM_PRIORITY,    // PROT_STR_INPUT
};

NET_PRIORITY S20StreamToS20Priority(UINT  streamID)
{
    NET_PRIORITY priority;

    DebugEntry(S20StreamToS20Priority);

    ASSERT(streamID > PROT_STR_INVALID);
    ASSERT(streamID < NUM_PROT_STR);
    ASSERT(streamID != PROT_STR_UNUSED);

    priority = c_StreamS20Priority[streamID - 1];

    DebugExitDWORD(S20StreamToS20Priority, priority);
    return(priority);
}

BOOL S20AcceptNewCorrelator(PS20CREATEPACKET  pS20Packet)
{
	BOOL rc = FALSE;
    //
    // Either there is no share or we have issued a join.  In these    
    // curcumstances we want to try to accept the create message.      
    //

    //
    // Remember the share correlator.                                  
    //
    g_s20ShareCorrelator = pS20Packet->correlator;

    //
    // Start the share
    // CHECK FOR FAILURE FOR THE FIRST ONE.
    //
	WARNING_OUT(("S20CreateMsg SC_Start"));
    rc = SC_Start(g_s20LocalID);
    if (rc)
    {
		SetS20State(S20_SHARE_STARTING);

        rc = S20MaybeAddNewParty(pS20Packet->header.user,
            pS20Packet->lenCaps, pS20Packet->lenName,
            pS20Packet->data);
    }

    if (!rc)
    {
        //
        // Something went wrong.  Kill the share, this will clean up
        // everything.
        //
        SC_End();
    }
	WARNING_OUT(("S20CreateMsg not hadled case g_state %x correlator %x", g_s20State, g_s20ShareCorrelator));
	return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\om.cpp ===
#include "precomp.h"


//
// OM.CPP
// Object Manager
//
// Copyright(c) Microsoft 1997-
//


#define MLZ_FILE_ZONE   ZONE_OM


//
// Function profile ID <--> name mapping
//

typedef struct tagOMFP_MAP
{
    char    szName[16];
}
OMFP_MAP;


const OMFP_MAP c_aFpMap[OMFP_MAX] =
{
    { AL_FP_NAME },
    { OM_FP_NAME },
    { WB_FP_NAME }
};


//
// Workset Group ID <--> name mapping
//

typedef struct tagOMWSG_MAP
{
    char    szName[16];
}
OMWSG_MAP;


const OMWSG_MAP c_aWsgMap[OMWSG_MAX] =
{
    { OMC_WSG_NAME },
    { AL_WSG_NAME },
    { WB_WSG_NAME }
};




//
// OMP_Init()
//
BOOL OMP_Init(BOOL * pfCleanup)
{
    BOOL            fInit = FALSE;

    DebugEntry(OMP_Init);

    UT_Lock(UTLOCK_OM);

    //
    // Register the OM service
    //
    if (g_putOM || g_pomPrimary)
    {
        *pfCleanup = FALSE;
        ERROR_OUT(("Can't start OM primary task; already running"));
        DC_QUIT;
    }

    *pfCleanup = TRUE;

    if (!UT_InitTask(UTTASK_OM, &g_putOM))
    {
        ERROR_OUT(("Failed to start OM task"));
        DC_QUIT;
    }

    g_pomPrimary = (POM_PRIMARY)UT_MallocRefCount(sizeof(OM_PRIMARY), TRUE);
    if (!g_pomPrimary)
    {
        ERROR_OUT(("Failed to allocate OM memory block"));
        DC_QUIT;
    }

    SET_STAMP(g_pomPrimary, OPRIMARY);
    g_pomPrimary->putTask       = g_putOM;
    g_pomPrimary->correlator    = 1;

    COM_BasedListInit(&(g_pomPrimary->domains));

    UT_RegisterExit(g_putOM, OMPExitProc, g_pomPrimary);
    g_pomPrimary->exitProcReg = TRUE;

    UT_RegisterEvent(g_putOM, OMPEventsHandler, g_pomPrimary, UT_PRIORITY_NORMAL);
    g_pomPrimary->eventProcReg = TRUE;

    if (!MG_Register(MGTASK_OM, &(g_pomPrimary->pmgClient), g_putOM))
    {
        ERROR_OUT(("Couldn't register OM with the MG layer"));
        DC_QUIT;
    }

    if (!CMS_Register(g_putOM, CMTASK_OM, &(g_pomPrimary->pcmClient)))
    {
        ERROR_OUT(("Couldn't register OM as call secondary"));
        DC_QUIT;
    }

    //
    // Allocate our GDC buffer.
    //
    g_pomPrimary->pgdcWorkBuf = new BYTE[GDC_WORKBUF_SIZE];
    if (!g_pomPrimary->pgdcWorkBuf)
    {
        ERROR_OUT(("SendMessagePkt: can't allocate GDC work buf, not compressing"));
        DC_QUIT;
    }

    fInit = TRUE;

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_OM);

    DebugExitBOOL(OMP_Init, fInit);
    return(fInit);
}



//
// OMP_Term()
//
void OMP_Term(void)
{
    DebugEntry(OMP_Term);

    UT_Lock(UTLOCK_OM);

    if (g_pomPrimary)
    {
        ValidateOMP(g_pomPrimary);

        //
        // Deregister from Call Manager
        //
        if (g_pomPrimary->pcmClient)
        {
            CMS_Deregister(&g_pomPrimary->pcmClient);
        }

        //
        // Deregister from MG
        //
        if (g_pomPrimary->pmgClient)
        {
            MG_Deregister(&g_pomPrimary->pmgClient);
        }

        OMPExitProc(g_pomPrimary);
    }

    UT_TermTask(&g_putOM);

    UT_Unlock(UTLOCK_OM);

    DebugExitVOID(OMP_Term);
}



//
// OMPExitProc()
//
void CALLBACK OMPExitProc(LPVOID uData)
{
    POM_PRIMARY     pomPrimary = (POM_PRIMARY)uData;
    POM_DOMAIN      pDomain;
    POM_WSGROUP     pWSGroup;
    POM_CLIENT_LIST pClient;

    DebugEntry(OMPExitProc);

    UT_Lock(UTLOCK_OM);

    ValidateOMP(pomPrimary);
    ASSERT(pomPrimary == g_pomPrimary);

    if (pomPrimary->exitProcReg)
    {
        UT_DeregisterExit(pomPrimary->putTask, OMPExitProc, pomPrimary);
        pomPrimary->exitProcReg = FALSE;
    }

    if (pomPrimary->eventProcReg)
    {
        UT_DeregisterEvent(pomPrimary->putTask, OMPEventsHandler, pomPrimary);
        pomPrimary->eventProcReg = FALSE;
    }

    //
    // Free domains
    //
    while (pDomain = (POM_DOMAIN)COM_BasedListFirst(&(pomPrimary->domains),
        FIELD_OFFSET(OM_DOMAIN, chain)))
    {
        TRACE_OUT(("OMPExitProc:  Freeing domain 0x%08x call ID 0x%08x",
            pDomain, pDomain->callID));

        //
        // Free workset groups
        // NOTE:
        // WSGDiscard() may destroy the domain, hence the weird
        // loop
        //
        if (pWSGroup = (POM_WSGROUP)COM_BasedListFirst(&(pDomain->wsGroups),
            FIELD_OFFSET(OM_WSGROUP, chain)))
        {
            TRACE_OUT(("OMPExitProc:  Freeing wsg 0x%08x domain 0x%08x",
                pWSGroup, pDomain));

            //
            // Free clients
            //
            while (pClient = (POM_CLIENT_LIST)COM_BasedListFirst(&(pWSGroup->clients),
                FIELD_OFFSET(OM_CLIENT_LIST, chain)))
            {
                TRACE_OUT(("OMPExitProc:  Freeing client 0x%08x wsg 0x%08x",
                    pClient, pWSGroup));

                COM_BasedListRemove(&(pClient->chain));
                UT_FreeRefCount((void**)&pClient, FALSE);
            }

            WSGDiscard(pomPrimary, pDomain, pWSGroup, TRUE);
        }
        else
        {
            FreeDomainRecord(&pDomain);
        }
    }

    if (pomPrimary->pgdcWorkBuf)
    {
        delete[] pomPrimary->pgdcWorkBuf;
        pomPrimary->pgdcWorkBuf = NULL;
    }

    UT_FreeRefCount((void**)&g_pomPrimary, TRUE);

    UT_Unlock(UTLOCK_OM);

    DebugExitVOID(OMPExitProc);
}




//
// OMPEventsHandler(...)
//
BOOL CALLBACK OMPEventsHandler
(
    LPVOID          uData,
    UINT            event,
    UINT_PTR        param1,
    UINT_PTR        param2
)
{
    POM_PRIMARY     pomPrimary = (POM_PRIMARY)uData;
    POM_DOMAIN      pDomain = NULL;
    BOOL            fProcessed = TRUE;

    DebugEntry(OMPEventsHandler);

    UT_Lock(UTLOCK_OM);

    ValidateOMP(pomPrimary);

    //
    // Check event is in the range we deal with:
    //
    if ((event < CM_BASE_EVENT) || (event > CM_LAST_EVENT))
    {
        goto CHECK_OM_EVENTS;
    }

    switch (event)
    {
        case CMS_NEW_CALL:
        {

            TRACE_OUT(( "CMS_NEW_CALL"));

            //
            // We ignore the return code - it will have been handled lower
            // down.
            //
            DomainRecordFindOrCreate(pomPrimary, (UINT)param2, &pDomain);
        }
        break;

        case CMS_END_CALL:
        {
            TRACE_OUT(( "CMS_END_CALL"));

            COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pomPrimary->domains),
                (void**)&pDomain, FIELD_OFFSET(OM_DOMAIN, chain),
                FIELD_OFFSET(OM_DOMAIN, callID), (DWORD)param2,
                FIELD_SIZE(OM_DOMAIN, callID));

            if (pDomain == NULL)
            {
                //
                // We don't have a record for this Domain so either we
                // never attached or we've already detached.  Do nothing.
                //
                TRACE_OUT(( "No record for Domain %u found", param2));
            }
            else
            {
                ProcessOwnDetach(pomPrimary, pDomain);
            }
        }
        break;

        case CMS_TOKEN_ASSIGN_CONFIRM:
        {
            TRACE_OUT(( "CMS_TOKEN_ASSIGN_CONFIRM"));
            //
            // There is a flaw in the CMS_ASSIGN_TOKEN_CONFIRM API in that
            // it does not tell us which domain it refers to.  So, we
            // operate under the assumption that this event relates to the
            // most recent domain we created i.e.  the first one in the
            // list (they go in at the beginning).
            //
            pDomain = (POM_DOMAIN)COM_BasedListFirst(&(pomPrimary->domains),
                FIELD_OFFSET(OM_DOMAIN, chain));

            if (pDomain != NULL)
            {
                ProcessCMSTokenAssign(pomPrimary,
                                      pDomain,
                                      (param1 != 0),
                                      LOWORD(param2));
            }
            else
            {
                WARNING_OUT(( "No domain found for CMS_TOKEN_ASSIGN_CONFIRM"));
            }
        }
        break;
    }

    TRACE_OUT(( "Processed Call Manager event %#x", event));
    DC_QUIT;

CHECK_OM_EVENTS:

    //
    // Check event is in the range we deal with:
    //
    if ((event < OM_BASE_EVENT) || (event > OM_LAST_EVENT))
    {
        goto CHECK_NET_EVENTS;
    }

    switch (event)
    {
        case OMINT_EVENT_LOCK_TIMEOUT:
        {
            ProcessLockTimeout(pomPrimary, (UINT)param1, (UINT)param2);
        }
        break;

        case OMINT_EVENT_SEND_QUEUE:
        {
            //
            // Param2 is the domain record.
            //
            pDomain = (POM_DOMAIN)param2;
            ProcessSendQueue(pomPrimary, pDomain, TRUE);
        }
        break;

        case OMINT_EVENT_PROCESS_MESSAGE:
        {
            ProcessBouncedMessages(pomPrimary, (POM_DOMAIN) param2);
        }
        break;

        case OMINT_EVENT_WSGROUP_DISCARD:
        {
            ProcessWSGDiscard(pomPrimary, (POM_WSGROUP)param2);
        }
        break;

        case OMINT_EVENT_WSGROUP_MOVE:
        case OMINT_EVENT_WSGROUP_REGISTER:
        {
            ProcessWSGRegister(pomPrimary, (POM_WSGROUP_REG_CB)param2);
        }
        break;

        case OMINT_EVENT_WSGROUP_REGISTER_CONT:
        {
            WSGRegisterStage1(pomPrimary, (POM_WSGROUP_REG_CB) param2);
        }
        break;

        //
        // The remaining events are ones we get by virtue of being
        // considered as a client of the ObManControl workset group
        //

        case OM_WORKSET_LOCK_CON:
        {
            switch (((POM_EVENT_DATA16)&param1)->worksetID)
            {
                case OM_INFO_WORKSET:
                    ProcessOMCLockConfirm(pomPrimary,
                               ((POM_EVENT_DATA32) &param2)->correlator,
                               ((POM_EVENT_DATA32) &param2)->result);
                    break;

                case OM_CHECKPOINT_WORKSET:
                    ProcessCheckpoint(pomPrimary,
                               ((POM_EVENT_DATA32) &param2)->correlator,
                               ((POM_EVENT_DATA32) &param2)->result);
                    break;
            }
        }
        break;

        case OM_WORKSET_NEW_IND:
        {
            ProcessOMCWorksetNew(pomPrimary,
                                 ((POM_EVENT_DATA16) &param1)->hWSGroup,
                                 ((POM_EVENT_DATA16) &param1)->worksetID);
        }
        break;

        case OM_PERSON_JOINED_IND:
        case OM_PERSON_LEFT_IND:
        case OM_PERSON_DATA_CHANGED_IND:
        case OM_WSGROUP_MOVE_IND:
        case OM_WORKSET_UNLOCK_IND:
        {
            //
            // We ignore these events.
            //
        }
        break;

        case OM_OBJECT_ADD_IND:
        case OM_OBJECT_REPLACED_IND:
        case OM_OBJECT_UPDATED_IND:
        case OM_OBJECT_DELETED_IND:
        {
            ProcessOMCObjectEvents(pomPrimary,
                                   event,
                                   ((POM_EVENT_DATA16) &param1)->hWSGroup,
                                   ((POM_EVENT_DATA16) &param1)->worksetID,
                                   (POM_OBJECT) param2);
        }
        break;

        default:
        {
            ERROR_OUT(( "Unexpected ObMan event 0x%08x", event));
        }
    }

    TRACE_OUT(( "Processed ObMan event %x", event));
    DC_QUIT;

CHECK_NET_EVENTS:

    //
    // This function is only for network layer events so we quit if we've
    // got something else:
    //
    if ((event < NET_BASE_EVENT) || (event > NET_LAST_EVENT))
    {
        fProcessed = FALSE;
        DC_QUIT;
    }

    //
    // Now switch on the event type:
    //
    switch (event)
    {
        case NET_EVENT_USER_ATTACH:
        {
            //
            // Find the domain data for this call
            //
            COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pomPrimary->domains),
                    (void**)&pDomain, FIELD_OFFSET(OM_DOMAIN, chain),
                    FIELD_OFFSET(OM_DOMAIN, callID),
                    param2,  FIELD_SIZE(OM_DOMAIN, callID));
            if (pDomain)
            {
                ProcessNetAttachUser(pomPrimary, pDomain, LOWORD(param1),
                    HIWORD(param1));
            }
            break;
        }

        case NET_EVENT_USER_DETACH:
        {
            //
            // Find the domain data for this call
            //
            COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pomPrimary->domains),
                    (void**)&pDomain, FIELD_OFFSET(OM_DOMAIN, chain),
                    FIELD_OFFSET(OM_DOMAIN, callID),
                    param2,  FIELD_SIZE(OM_DOMAIN, callID));
            if (pDomain)
            {
                ProcessNetDetachUser(pomPrimary, pDomain, LOWORD(param1));
            }
            break;
        }

        case NET_EVENT_CHANNEL_LEAVE:
        {
            //
            // Find the domain data for this call
            //
            COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pomPrimary->domains),
                    (void**)&pDomain, FIELD_OFFSET(OM_DOMAIN, chain),
                    FIELD_OFFSET(OM_DOMAIN, callID),
                    param2,  FIELD_SIZE(OM_DOMAIN, callID));
            if (pDomain)
            {
                ProcessNetLeaveChannel(pomPrimary, pDomain, LOWORD(param1));
            }
            break;
        }

        case NET_EVENT_TOKEN_GRAB:
        {
            //
            // Find the domain data for this call
            //
            COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pomPrimary->domains),
                    (void**)&pDomain, FIELD_OFFSET(OM_DOMAIN, chain),
                    FIELD_OFFSET(OM_DOMAIN, callID),
                    param2,  FIELD_SIZE(OM_DOMAIN, callID));
            if (pDomain)
            {
                ProcessNetTokenGrab(pomPrimary, pDomain, LOWORD(param1));
            }
            break;
        }

        case NET_EVENT_TOKEN_INHIBIT:
        {
            //
            // Find the domain data for this call
            //
            COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pomPrimary->domains),
                    (void**)&pDomain, FIELD_OFFSET(OM_DOMAIN, chain),
                    FIELD_OFFSET(OM_DOMAIN, callID),
                    param2,  FIELD_SIZE(OM_DOMAIN, callID));
            if (pDomain)
            {
                ProcessNetTokenInhibit(pomPrimary, pDomain, LOWORD(param1));
            }
            break;
        }

        case NET_EVENT_CHANNEL_JOIN:
        {
            PNET_JOIN_CNF_EVENT pEvent = (PNET_JOIN_CNF_EVENT)param2;

            //
            // Find the domain data for this call
            //
            COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pomPrimary->domains),
                    (void**)&pDomain, FIELD_OFFSET(OM_DOMAIN, chain),
                    FIELD_OFFSET(OM_DOMAIN, callID),
                    pEvent->callID,  FIELD_SIZE(OM_DOMAIN, callID));
            if (pDomain)
            {
                ProcessNetJoinChannel(pomPrimary, pDomain, pEvent);
            }

            MG_FreeBuffer(pomPrimary->pmgClient, (void **)&pEvent);
            break;
        }

        case NET_EVENT_DATA_RECEIVED:
        {
            PNET_SEND_IND_EVENT pEvent = (PNET_SEND_IND_EVENT)param2;

            COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pomPrimary->domains),
                    (void**)&pDomain, FIELD_OFFSET(OM_DOMAIN, chain),
                    FIELD_OFFSET(OM_DOMAIN, callID),
                    pEvent->callID, FIELD_SIZE(OM_DOMAIN, callID));
            if (pDomain)
            {
                ProcessNetData(pomPrimary, pDomain, pEvent);
            }

            MG_FreeBuffer(pomPrimary->pmgClient, (void**)&pEvent);
            break;
        }

        case NET_FEEDBACK:
        {
             //
             // A NET_FEEDBACK event includes the pmgUser which identifies
             // the send pool from which the buffer has been freed.  We use
             // it to find the Domain:
             //
             COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pomPrimary->domains),
                    (void**)&pDomain, FIELD_OFFSET(OM_DOMAIN, chain),
                    FIELD_OFFSET(OM_DOMAIN, callID), (DWORD)param2,
                    FIELD_SIZE(OM_DOMAIN, callID));
            if (pDomain)
            {
                //
                // Generating a FEEDBACK event doesn't cause the use count
                // of the Domain record to be bumped, so set the
                // <domainRecBumped> flag to FALSE on the call to
                // ProcessSendQueue:
                //
                ProcessSendQueue(pomPrimary, pDomain, FALSE);
            }

            break;
        }

        case NET_FLOW:
        {
            ERROR_OUT(("OMPEventsHandler received NET_FLOW; shouldn't have"));
            break;
        }
    }

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_OM);

    DebugExitBOOL(OMPEventsHandler, fProcessed);
    return(fProcessed);
}



//
// DomainRecordFindOrCreate(...)
//
UINT DomainRecordFindOrCreate
(
    POM_PRIMARY         pomPrimary,
    UINT                callID,
    POM_DOMAIN *        ppDomain
)
{
    POM_DOMAIN          pDomain;
    UINT                rc = 0;

    DebugEntry(DomainRecordFindOrCreate);

    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pomPrimary->domains),
            (void**)&pDomain, FIELD_OFFSET(OM_DOMAIN, chain),
            FIELD_OFFSET(OM_DOMAIN, callID),
            (DWORD)callID, FIELD_SIZE(OM_DOMAIN, callID));
    if (pDomain == NULL)
    {
        //
        // We don't have a record for this Domain so create one:
        //
        rc = DomainAttach(pomPrimary, callID, &pDomain);
        if (rc != 0)
        {
            DC_QUIT;
        }
    }

    *ppDomain = pDomain;

DC_EXIT_POINT:
    DebugExitDWORD(DomainRecordFindOrCreate, rc);
    return(rc);

}



//
// DomainAttach(...)
//
UINT DomainAttach
(
    POM_PRIMARY         pomPrimary,
    UINT                callID,
    POM_DOMAIN *        ppDomain
)
{
    POM_DOMAIN          pDomain     =    NULL;
    NET_FLOW_CONTROL    netFlow;
    UINT                rc          = 0;

    DebugEntry(DomainAttach);

    TRACE_OUT(( "Attaching to Domain 0x%08x...", callID));

    if (callID != OM_NO_CALL)
    {
        CM_STATUS       status;

        CMS_GetStatus(&status);
        if (!(status.attendeePermissions & NM_PERMIT_USEOLDWBATALL))
        {
            WARNING_OUT(("Joining Meeting with no OLDWB OM at all"));
            rc = NET_RC_MGC_NOT_CONNECTED;
            DC_QUIT;
        }
    }

    //
    // This function does the following:
    //
    // - create a new Domain record
    //
    // - if the Domain is our local Domain (OM_NO_CALL) call
    //   ObManControlInit
    //
    // - else call MG_AttachUser to start attaching to the Domain.
    //
    rc = NewDomainRecord(pomPrimary,
                         callID,
                         &pDomain);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // What we do now depends on whether this is our "local" Domain (i.e.
    // callID == OM_NO_CALL):
    //
    if (callID == OM_NO_CALL)
    {
       TRACE_OUT(( "Is local domain - skipping forward"));

       //
       // This is our "local" Domain, so don't call MG_AttachUser.
       // Instead, we fake up a successful token grab event and rejoin the
       // domain attach processing there:
       //
       TRACE_OUT(( "Faking successful token grab for local domain"));
       pDomain->state = PENDING_TOKEN_GRAB;
       rc = ProcessNetTokenGrab(pomPrimary, pDomain, NET_RESULT_OK);
       if (rc != 0)
       {
          DC_QUIT;
       }
    }
    else
    {
       TRACE_OUT(( "Is real domain - attaching"));

       //
       // Set up our target latencies.  Don't bother restricting the max
       // stream sizes.
       //
       ZeroMemory(&netFlow, sizeof(netFlow));

       netFlow.latency[NET_TOP_PRIORITY]    = 0;
       netFlow.latency[NET_HIGH_PRIORITY]   = 2000L;
       netFlow.latency[NET_MEDIUM_PRIORITY] = 5000L;
       netFlow.latency[NET_LOW_PRIORITY]    = 10000L;

       rc = MG_Attach(pomPrimary->pmgClient, callID, &netFlow);
       if (rc != 0)
       {
           DC_QUIT;
       }

       //
       // Set up the remaining fields of the Domain record:
       //
       pDomain->state   = PENDING_ATTACH;

       //
       // The <userID> field is set when the NET_ATTACH event arrives.
       //

       //
       // The next stage in the Domain attach process is when the
       // NET_ATTACH event arrives.  This will cause the
       // ProcessNetAttachUser function to be called.
       //
    }

    //
    // Finally, set caller's pointer:
    //
    *ppDomain = pDomain;

DC_EXIT_POINT:

    if (rc != 0)
    {
        //
        // Do not trace an error if we get NOT_CONNECTED - it is a valid
        // race condition (but we still must do the cleanup below).
        //
        if (rc != NET_RC_MGC_NOT_CONNECTED)
        {
            // lonchanc: rc=0x706 can happen here, bug #942.
            // this was ERROR_OUT
            WARNING_OUT(( "Error %d attaching to Domain %u", rc, callID));
        }

        if (pDomain != NULL)
        {
            ProcessOwnDetach(pomPrimary, pDomain);
        }
    }

    DebugExitDWORD(DomainAttach, rc);
    return(rc);

}


//
// DomainDetach(...)
//
void DomainDetach
(
    POM_PRIMARY     pomPrimary,
    POM_DOMAIN *    ppDomain,
    BOOL            fExit
)
{
    POM_DOMAIN      pDomain;

    DebugEntry(DomainDetach);

    ASSERT(ppDomain != NULL);

    pDomain = *ppDomain;

    //
    // This function does all the network cleanup required, then calls on
    // to discard the ObMan memory etc associated with the domain.  Note
    // that we don't bother releasing tokens, leaving channels, etc since
    // the network layer will do this for us automatically.
    //
    if (!fExit  &&
        (pDomain->callID != OM_NO_CALL)  &&
        (pDomain->state >= PENDING_ATTACH))
    {
        MG_Detach(pomPrimary->pmgClient);
    }

    TRACE_OUT(( "Detached from Domain %u", pDomain->callID));

    FreeDomainRecord(ppDomain);

    DebugExitVOID(DomainDetach);
}



//
// NewDomainRecord(...)
//
UINT NewDomainRecord
(
    POM_PRIMARY     pomPrimary,
    UINT            callID,
    POM_DOMAIN*     ppDomain
)
{
    POM_WSGROUP     pOMCWSGroup = NULL;
    POM_DOMAIN      pDomain;
    BOOL            noCompression;
    BOOL            inserted = FALSE;
    UINT            rc = 0;

    DebugEntry(NewDomainRecord);

    //
    // Allocate Domain record:
    //
    pDomain = (POM_DOMAIN)UT_MallocRefCount(sizeof(OM_DOMAIN), TRUE);
    if (!pDomain)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }
    SET_STAMP(pDomain, DOMAIN);

    //
    // Fill in the fields:
    //
    pDomain->callID = callID;
    pDomain->valid   = TRUE;

    //
    // Set up our maximum compression caps.  They are subsequently
    // negotiated as follows:
    //
    // - if there are any other nodes out there, we will negotiate down
    // when we receive a WELCOME message from one of them
    //
    // - if any other nodes join subsequently, we will negotiate down when
    // we receive their HELLO message.
    //
    COM_ReadProfInt(DBG_INI_SECTION_NAME, OM_INI_NOCOMPRESSION, FALSE,
        &noCompression);
    if (noCompression)
    {
        WARNING_OUT(("NewDomainRecord:  compression off"));
        pDomain->compressionCaps = OM_CAPS_NO_COMPRESSION;
    }
    else
    {
        pDomain->compressionCaps = OM_CAPS_PKW_COMPRESSION;
    }

    //
    // This will be ObMan's workset group handle for the ObManControl
    // workset group in this domain.  Since we know that domain handles are
    // only ever -1 or 0, we just cast the domain handle down to 8 bits to
    // give the hWSGroup.  If the way domain handles are allocated changes,
    // will need to do something cleverer here.
    //
    pDomain->omchWSGroup = (BYTE) callID;

    COM_BasedListInit(&(pDomain->wsGroups));
    COM_BasedListInit(&(pDomain->pendingRegs));
    COM_BasedListInit(&(pDomain->pendingLocks));
    COM_BasedListInit(&(pDomain->receiveList));
    COM_BasedListInit(&(pDomain->bounceList));
    COM_BasedListInit(&(pDomain->helperCBs));
    COM_BasedListInit(&(pDomain->sendQueue[ NET_TOP_PRIORITY    ]));
    COM_BasedListInit(&(pDomain->sendQueue[ NET_HIGH_PRIORITY   ]));
    COM_BasedListInit(&(pDomain->sendQueue[ NET_MEDIUM_PRIORITY ]));
    COM_BasedListInit(&(pDomain->sendQueue[ NET_LOW_PRIORITY    ]));

    //
    // Insert the record for this new Domain in the list hung off the root
    // data structure:
    //
    TRACE_OUT((" Inserting record for Domain %u in global list", callID));

    COM_BasedListInsertAfter(&(pomPrimary->domains), &(pDomain->chain));
    inserted = TRUE;

    //
    // Here we create a record for the ObManControl workset group and cause
    // it to be inserted in the list hung off the Domain record:
    //
    // Note that this does not involve sending any data; it merely creates
    // the record locally.
    //
    rc = WSGRecordCreate(pomPrimary,
                         pDomain,
                         OMWSG_OM,
                         OMFP_OM,
                         &pOMCWSGroup);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // Create a single, empty workset (this function broadcasts the
    // creation throughout the Domain):
    //
    rc = WorksetCreate(pomPrimary->putTask,
                       pOMCWSGroup,
                       OM_INFO_WORKSET,
                       FALSE,
                       NET_TOP_PRIORITY);
    if (rc != 0)
    {
       DC_QUIT;
    }

    //
    // Fill in the fixed workset group ID (normally, we would call
    // WSGGetNewID to allocate an unused one).
    //
    pOMCWSGroup->wsGroupID = WSGROUPID_OMC;

    //
    // We fill in the channel ID when we get the result from JoinByKey
    //

    //
    // Add ObMan's putTask to the workset group's client list, so it will
    // get events posted to it.
    //
    rc = AddClientToWSGList(pomPrimary->putTask,
                            pOMCWSGroup,
                            pDomain->omchWSGroup,
                            PRIMARY);
    if (rc != 0)
    {
        DC_QUIT;
    }

    *ppDomain = pDomain;

DC_EXIT_POINT:

    if (rc != 0)
    {
        ERROR_OUT(( "Error %d creating record for domain %u", callID));
        if (pOMCWSGroup != NULL)
        {
            COM_BasedListRemove(&(pOMCWSGroup->chain));
            UT_FreeRefCount((void**)&pOMCWSGroup, FALSE);
        }

        if (inserted)
        {
            COM_BasedListRemove(&(pDomain->chain));
        }

        if (pDomain != NULL)
        {
            UT_FreeRefCount((void**)&pDomain, FALSE);
        }
    }

    DebugExitDWORD(NewDomainRecord, rc);
    return(rc);
}


//
// FreeDomainRecord(...)
//
void FreeDomainRecord
(
    POM_DOMAIN    * ppDomain
)
{
    POM_DOMAIN      pDomain;
    NET_PRIORITY    priority;
    POM_SEND_INST   pSendInst;

    DebugEntry(FreeDomainRecord);

    //
    // This function
    //
    // - frees any outstanding send requests (and their associated CBs)
    //
    // - invalidates, removes from the global list and frees the Domain
    //   record.
    //
    pDomain = *ppDomain;

    //
    // Free all the send instructions queued in the domain:
    //
    for (priority = NET_TOP_PRIORITY;priority <= NET_LOW_PRIORITY;priority++)
    {
        for (; ; )
        {
            pSendInst = (POM_SEND_INST)COM_BasedListFirst(&(pDomain->sendQueue[priority]),
                FIELD_OFFSET(OM_SEND_INST, chain));

            if (pSendInst == NULL)
            {
               break;
            }

            TRACE_OUT(( "Freeing send instruction at priority %u", priority));
            FreeSendInst(pSendInst);
        }
    }

    pDomain->valid = FALSE;

    COM_BasedListRemove(&(pDomain->chain));
    UT_FreeRefCount((void**)ppDomain, FALSE);

    DebugExitVOID(FreeDomainRecord);
}



//
// ProcessNetAttachUser(...)
//
void ProcessNetAttachUser
(
    POM_PRIMARY             pomPrimary,
    POM_DOMAIN              pDomain,
    NET_UID                 userId,
    NET_RESULT              result
)
{
    NET_CHANNEL_ID          channelCorrelator;
    UINT                    rc = 0;

    DebugEntry(ProcessNetAttachUser);

    TRACE_OUT(( "Got NET_ATTACH for Domain %u (userID: %hu, result: %hu)",
        pDomain->callID, userId, result));

    //
    // Check that this Domain is in the pending attach state:
    //
    if (pDomain->state != PENDING_ATTACH)
    {
        WARNING_OUT(( "Unexpected NET_ATTACH - Domain %u is in state %hu)",
            pDomain->callID, pDomain->state));
        DC_QUIT;
    }

    //
    // If we failed to attach, set the retCode so we tidy up below:
    //
    if (result != NET_RESULT_OK)
    {
        ERROR_OUT(( "Failed to attach to Domain %u; cleaning up...",
            pDomain->callID));

        rc = result;
        DC_QUIT;
    }

    //
    // Otherwise, record our user ID for this Domain and then join our user
    // ID channel:
    //
    pDomain->userID = userId;

    TRACE_OUT(("Asking to join own channel %hu", pDomain->userID));

    rc = MG_ChannelJoin(pomPrimary->pmgClient,
                         &channelCorrelator,
                         pDomain->userID);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // Set the Domain <state>:
    //
    pDomain->state = PENDING_JOIN_OWN;

    //
    // The next step in the Domain attach process happens when the NET_JOIN
    // event arrives for the channel we've just joined.  This event causes
    // the ProcessNetJoinChannel function to be called.
    //

DC_EXIT_POINT:

    if (rc != 0)
    {
        WARNING_OUT(("Error %d joining own user channel %hu",
            rc, pDomain->userID));

        ProcessOwnDetach(pomPrimary, pDomain);
    }

    DebugExitVOID(ProcessNetAttachUser);

}



//
// ProcessNetJoinChannel(...)
//
void ProcessNetJoinChannel
(
    POM_PRIMARY         pomPrimary,
    POM_DOMAIN          pDomain,
    PNET_JOIN_CNF_EVENT pNetJoinCnf
)
{
    POM_WSGROUP         pOMCWSGroup;
    NET_CHANNEL_ID      channelCorrelator;
    POM_WSGROUP_REG_CB  pRegistrationCB =   NULL;
    BOOL                success = TRUE;

    DebugEntry(ProcessNetJoinChannel);

    TRACE_OUT(( "JOIN_CON - channel %hu - result %hu",
        pNetJoinCnf->channel, pNetJoinCnf->result));

    switch (pDomain->state)
    {
        case PENDING_JOIN_OWN:
        {
            //
            // This event is in response to us trying to join our own user
            // channel, as part of the mutli-stage Domain attach process.
            // The next step is to join the ObManControl channel.
            //

            //
            // First check that the join was successful:
            //
            if (pNetJoinCnf->result != NET_RESULT_OK)
            {
                ERROR_OUT(("Failed to join own user ID channel (reason: %hu)",
                           pNetJoinCnf->result));
                success = FALSE;
                DC_QUIT;
            }

            //
            // Verify that this is a join event for the correct channel
            //
            ASSERT(pNetJoinCnf->channel == pDomain->userID);

            //
            // The next step in the process of attaching to a Domain is to
            // join the ObManControl channel; we set the state accordingly:
            //
            TRACE_OUT(( "Asking to join ObManControl channel using key"));

            if (MG_ChannelJoinByKey(pomPrimary->pmgClient,
                                      &channelCorrelator,
                                      GCC_OBMAN_CHANNEL_KEY) != 0)
            {
                success = FALSE;
                DC_QUIT;
            }

            pDomain->state = PENDING_JOIN_OMC;

            //
            // The next stage in the Domain attach process happens when the
            // NET_JOIN event arrives for the ObManControl channel.  This
            // will cause this function to be executed again, but this time
            // the next case statement will be executed.
            //
        }
        break;

        case PENDING_JOIN_OMC:
        {
            //
            // This event is in response to us trying to join the
            // ObManControl workset group channel, as part of the
            // multi-stage Domain attach process.
            //

            //
            // Check that the join was successful:
            //
            if (pNetJoinCnf->result != NET_RESULT_OK)
            {
                WARNING_OUT(( "Bad result %#hx joining ObManControl channel",
                    pNetJoinCnf->result));
                success = FALSE;
                DC_QUIT;
            }

            //
            // If so, store the value returned in the domain record:
            //
            pDomain->omcChannel     = pNetJoinCnf->channel;
            pOMCWSGroup             = GetOMCWsgroup(pDomain);

            if( NULL == pOMCWSGroup )
            {
                TRACE_OUT(( "NULL pOMCWSGroup" ));
                success = FALSE;
                DC_QUIT;
            }

            pOMCWSGroup->channelID  = pDomain->omcChannel;

            //
            // We need a token to determine which ObMan is going to
            // initialise the ObManControl workset group.  Get GCC to
            // assign us one (this returns a static value for R1.1 calls).
            //
            if (!CMS_AssignTokenId(pomPrimary->pcmClient, GCC_OBMAN_TOKEN_KEY))
            {
                success = FALSE;
                DC_QUIT;
            }

            pDomain->state = PENDING_TOKEN_ASSIGN;
        }
        break;

        case DOMAIN_READY:
        {
            //
            // This should be a join event for a regular workset group
            // channel.  We check that we have indeed set up a workset
            // group registration CB containing the channel correlator
            // associated with this event:
            //
            COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pDomain->pendingRegs),
                    (void**)&pRegistrationCB, FIELD_OFFSET(OM_WSGROUP_REG_CB, chain),
                    FIELD_OFFSET(OM_WSGROUP_REG_CB, channelCorrelator),
                    pNetJoinCnf->correlator,
                    FIELD_SIZE(OM_WSGROUP_REG_CB, channelCorrelator));

            if (pRegistrationCB == NULL)
            {
                ERROR_OUT((
                    "Unexpected JOIN for channel %hu - no reg CB found",
                    pNetJoinCnf->channel));
                DC_QUIT;
            }

            //
            // Check that the join was successful:
            //
            if (pNetJoinCnf->result != NET_RESULT_OK)
            {
                //
                // If not, trace then try again:
                //
                WARNING_OUT(("Failure 0x%08x joining channel %hu for WSG %d, trying again",
                    pNetJoinCnf->result,
                    pNetJoinCnf->channel,
                    pRegistrationCB->wsg));

                pRegistrationCB->pWSGroup->state = INITIAL;
                WSGRegisterRetry(pomPrimary, pRegistrationCB);
                DC_QUIT;
            }

            //
            // Otherwise, call WSGRegisterStage3 to continue the
            // registration process:
            //
            WSGRegisterStage3(pomPrimary,
                              pDomain,
                              pRegistrationCB,
                              pNetJoinCnf->channel);
        }
        break;

        case PENDING_ATTACH:
        case PENDING_WELCOME:
        case GETTING_OMC:
        {
            //
            // Shouldn't get any join indications in these states.
            //
            ERROR_OUT(( "Unexpected JOIN in domain state %hu",
                pDomain->state));
        }
        break;

        default:
        {
            //
            // This is also an error:
            //
            ERROR_OUT(( "Invalid state %hu for domain %u",
                pDomain->state, pDomain->callID));
        }
    }

DC_EXIT_POINT:

    if (!success)
    {
        //
        // For any error here, we react as if we've been kicked out of the
        // domain:
        //
        ProcessOwnDetach(pomPrimary, pDomain);
    }

    DebugExitVOID(ProcessNetJoinChannel);
}


//
//
//
// ProcessCMSTokenAssign(...)
//
//
//

void ProcessCMSTokenAssign
(
    POM_PRIMARY         pomPrimary,
    POM_DOMAIN          pDomain,
    BOOL                success,
    NET_TOKEN_ID        tokenID
)
{
    DebugEntry(ProcessCMSTokenAssign);

    TRACE_OUT(( "TOKEN_ASSIGN_CONFIRM: result %hu, token ID %#hx",
        success, tokenID));

    if (pDomain->state != PENDING_TOKEN_ASSIGN)
    {
        WARNING_OUT(("Got TOKEN_ASSIGN_CONFIRM in state %hu",
            pDomain->state));
        DC_QUIT;
    }

    if (!success)
    {
        //
        // Nothing to do - the domain attach process will time out.
        //
        ERROR_OUT(( "Failed to get token assigned"));
        DC_QUIT;
    }

    pDomain->tokenID = tokenID;

    //
    // Now that we know what the token ID is, try to grab it:
    //
    if (MG_TokenGrab(pomPrimary->pmgClient,
                       pDomain->tokenID) != 0)
    {
        ERROR_OUT(( "Failed to grab token"));
        DC_QUIT;
    }

    pDomain->state = PENDING_TOKEN_GRAB;

DC_EXIT_POINT:
    DebugExitVOID(ProcessCMSTokenAssign);
}



//
// ProcessNetTokenGrab(...)
//
UINT ProcessNetTokenGrab
(
    POM_PRIMARY           pomPrimary,
    POM_DOMAIN          pDomain,
    NET_RESULT              result
)
{
    POM_WSGROUP         pOMCWSGroup =   NULL;

    UINT            rc =            0;

    DebugEntry(ProcessNetTokenGrab);

    TRACE_OUT(( "Got token grab confirm - result = %hu", result));

    if (pDomain->state != PENDING_TOKEN_GRAB)
    {
        ERROR_OUT(( "Got TOKEN_GRAB_CONFIRM in state %hu",
                                                         pDomain->state));
        rc = OM_RC_NETWORK_ERROR;
        DC_QUIT;
    }

    //
    // What to do here depends on whether we've succeeded in grabbing the
    // token:
    //
    if (result == NET_RESULT_OK)
    {
        //
        // We're the "top ObMan" in the Domain, so it's up to us to
        // initialise the ObManControl workset group and welcome any others
        // into the Domain (the Welcome message is broadcast on the
        // ObManControl channel):
        //
        rc = ObManControlInit(pomPrimary, pDomain);
        if (rc != 0)
        {
            DC_QUIT;
        }

        //
        // If we get here, then the Domain attach process has finished.
        // Phew!  Any workset group registration attempts in progress will
        // be processed shortly, next time the bouncing
        // OMINT_EVENT_WSG_REGISTER_CONT event is processed
        //
    }
    else
    {
        //
        // Someone else is in charge, so we need to get a copy of
        // ObManControl from them (or anyone else who's prepared to give it
        // to us).  So, we need to discover the user ID of one of them so
        // we can send our request there (if we just broadcasted our
        // request, then each node would reply, flooding the Domain)
        //
        rc = SayHello(pomPrimary, pDomain);
        if (rc != 0)
        {
            DC_QUIT;
        }

        //
        // The next step in the Domain attach process happens when one of
        // the other nodes out there replies to our HELLO with a WELCOME
        // message.  Execution continues in the ProcessWelcome function.
        //
    }

DC_EXIT_POINT:

    if (rc != 0)
    {
        if (pOMCWSGroup != NULL)
        {
            //
            // This will remove the ObManControl workset group from the
            // Domain and subsequently call DomainDetach to detach from the
            // Domain and free the Domain record:
            //
            DeregisterLocalClient(pomPrimary, &pDomain, pOMCWSGroup, FALSE);

            UT_FreeRefCount((void**)&pOMCWSGroup, FALSE);

            ASSERT((pDomain == NULL));
        }
    }

    DebugExitDWORD(ProcessNetTokenGrab, rc);
    return(rc);
}


//
//
//
// ProcessNetTokenInhibit(...)
//
//
//

UINT ProcessNetTokenInhibit(POM_PRIMARY          pomPrimary,
                                           POM_DOMAIN         pDomain,
                                           NET_RESULT             result)
{
    UINT        rc =        0;

    DebugEntry(ProcessNetTokenInhibit);

    TRACE_OUT(( "Got token inhibit confirm - result = %hu", result));
    if (result == NET_RESULT_OK)
    {
        //
        // Now send a Welcome message on the ObManControl channel.  It is
        // crucial that this happens at the same time as we set the Domain
        // state to READY, because if another node is joining the call at
        // the same time it will send a Hello message:
        //
        // - if the message has already arrived, we will have thrown it
        // away
        //   because the Domain state was not READY, so we must send it now
        //
        // - if it has yet to arrive, then setting the Domain state to
        // READY
        //   now means we'll respond with another Welcome when it does
        // arrive.
        //
        pDomain->state = DOMAIN_READY;
        rc = SayWelcome(pomPrimary, pDomain, pDomain->omcChannel);
        if (rc != 0)
        {
           DC_QUIT;
        }

        //
        // OK, the domain attach process has finished.  We need to take no
        // further action other than setting the state.  Any pending
        // workset group registrations will continue back at the
        // WSGRegisterStage1 function, where hopefully the bounced
        // OMINT_EVENT_WSGROUP_REGISTER event is just about to arrive...
        //
    }
    else
    {
        //
        // Again, no action.  We cannot join the domain, but the workset
        // group registrations will time out in due course.
        //
        WARNING_OUT(( "Token inhibit failed!"));
    }

DC_EXIT_POINT:
    DebugExitDWORD(ProcessNetTokenInhibit, rc);
    return(rc);

}


//
//
//
// ObManControlInit(...)
//
//
//

UINT ObManControlInit(POM_PRIMARY    pomPrimary,
                                     POM_DOMAIN   pDomain)
{
    POM_WSGROUP          pOMCWSGroup;
    UINT    rc = 0;

    DebugEntry(ObManControlInit);

    //
    // First, set up a pointer to the ObManControl workset group, which
    // should already have been put in the Domain record:
    //
    pOMCWSGroup = GetOMCWsgroup(pDomain);

    //
    // Initialising the ObManControl workset group involves
    //
    // - adding a WSGROUP_INFO object to it, which identifies ObManControl
    //   itself.
    //
    TRACE_OUT(( "Initialising ObManControl in Domain %u",
                                                        pDomain->callID));

    //
    // Now we must add a workset group identification object, identifying
    // ObManControl, to workset #0 in ObManControl.
    //
    // Slightly circular, but we try to treat ObManControl as a regular
    // workset group as much as possible; if we didn't add this
    // identification object then when a Client (e.g.  AppLoader) tries to
    // register with ObManControl, we would look in workset #0 for a
    // reference to it, not find one and then create it again!
    //
    rc = CreateAnnounce(pomPrimary, pDomain, pOMCWSGroup);
    if (rc != 0)
    {
       DC_QUIT;
    }

    //
    // In addition, we add our registration object to ObManControl workset
    // #0 and update it immediately to status READY_TO_SEND:
    //
    rc = RegAnnounceBegin(pomPrimary,
                          pDomain,
                          pOMCWSGroup,
                          pDomain->userID,
                          &(pOMCWSGroup->pObjReg));
    if (rc != 0)
    {
       DC_QUIT;
    }

    rc = RegAnnounceComplete(pomPrimary, pDomain, pOMCWSGroup);
    if (rc != 0)
    {
       DC_QUIT;
    }

    //
    // OK, we've initialised ObManControl for this call - inhibit the token
    // so that no one else can do the same (if this is the local domain,
    // just fake up an inhibit confirm):
    //
    if (pDomain->callID == OM_NO_CALL)
    {
        TRACE_OUT(( "Faking successful token inhibit for local domain"));
        rc = ProcessNetTokenInhibit(pomPrimary, pDomain, NET_RESULT_OK);
        if (rc != 0)
        {
            DC_QUIT;
        }
    }
    else
    {
        rc = MG_TokenInhibit(pomPrimary->pmgClient,
                              pDomain->tokenID);
        if (rc != 0)
        {
            DC_QUIT;
        }

        pDomain->state = PENDING_TOKEN_INHIBIT;
    }

DC_EXIT_POINT:

    if (rc != 0)
    {
        WARNING_OUT(("Error %d initialising ObManControl WSG for Domain %u",
                rc, pDomain->callID));
    }

    DebugExitDWORD(ObManControlInit, rc);
    return(rc);

}


//
//
//
// SayHello(...)
//
//
//

UINT SayHello(POM_PRIMARY   pomPrimary,
                             POM_DOMAIN  pDomain)

{
    POMNET_JOINER_PKT      pHelloPkt;
    UINT rc         = 0;

    DebugEntry(SayHello);

    //
    // Generate and queue an OMNET_HELLO message:
    //

    TRACE_OUT(( "Saying hello in Domain %u", pDomain->callID));

    pHelloPkt = (POMNET_JOINER_PKT)UT_MallocRefCount(sizeof(OMNET_JOINER_PKT), TRUE);
    if (!pHelloPkt)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    pHelloPkt->header.sender      = pDomain->userID;
    pHelloPkt->header.messageType = OMNET_HELLO;

    //
    // All fields in the joiner packet after <capsLen> are capabilities.  To
    // calculate the size of these capabilities, we use the offset and size
    // of the caps len field itself to determine the amount of data after
    // it.
    //
    pHelloPkt->capsLen = sizeof(OMNET_JOINER_PKT) -
        (offsetof(OMNET_JOINER_PKT, capsLen) + sizeof(pHelloPkt->capsLen));

    TRACE_OUT(( "Our caps len is 0x%08x", pHelloPkt->capsLen));

    //
    // Take our compression caps from the domain record:
    //
    pHelloPkt->compressionCaps = pDomain->compressionCaps;

    TRACE_OUT(( "Broadcasting compression caps 0x%08x in HELLO",
            pHelloPkt->compressionCaps));

    rc = QueueMessage(pomPrimary->putTask,
                     pDomain,
                     pDomain->omcChannel,
                     NET_TOP_PRIORITY,
                     NULL,                                    // no wsgroup
                     NULL,                                    // no workset
                     NULL,                                    // no object
                     (POMNET_PKT_HEADER) pHelloPkt,
                     NULL,                     // no associated object data
                     FALSE);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // When the associated response (OMNET_WELCOME) is received from another
    // node, we will ask that node for a copy of the ObManControl workset
    // group.  In the meantime, there's nothing else to do.
    //

    pDomain->state = PENDING_WELCOME;

DC_EXIT_POINT:

    if (rc != 0)
    {
        ERROR_OUT(( "Error %d saying hello in Domain %u", rc, pDomain->callID));
    }

    DebugExitDWORD(SayHello, rc);
    return(rc);

}


//
//
//
// ProcessHello(...)
//
//
//

UINT ProcessHello(POM_PRIMARY        pomPrimary,
                                 POM_DOMAIN       pDomain,
                                 POMNET_JOINER_PKT    pHelloPkt,
                                 UINT             lengthOfPkt)
{
    NET_CHANNEL_ID         lateJoiner;

    UINT rc          = 0;

    DebugEntry(ProcessHello);

    lateJoiner = pHelloPkt->header.sender;

    //
    // A late joiner has said hello.  If we are not fully attached yet, we
    // trace and quit:
    //
    if (pDomain->state != DOMAIN_READY)
    {
      WARNING_OUT(( "Can't process HELLO on channel %#hx - domain state %hu",
               lateJoiner, pDomain->state));
      DC_QUIT;
    }

    //
    // Merge in the late joiner's capabilities with our view of the
    // domain-wide caps.
    //
    MergeCaps(pDomain, pHelloPkt, lengthOfPkt);

    //
    // Now send a welcome message to the late joiner.
    //
    rc = SayWelcome(pomPrimary, pDomain, lateJoiner);
    if (rc != 0)
    {
      DC_QUIT;
    }

DC_EXIT_POINT:

    if (rc != 0)
    {
      ERROR_OUT(( "Error %d processing hello from node %#hx in Domain %u",
               rc, lateJoiner, pDomain->callID));
    }

    DebugExitDWORD(ProcessHello, rc);
    return(rc);

} // ProcessHello


//
//
//
// MergeCaps(...)
//
//
//

void MergeCaps(POM_DOMAIN       pDomain,
                            POMNET_JOINER_PKT    pJoinerPkt,
                            UINT             lengthOfPkt)
{
    NET_CHANNEL_ID       sender;
    UINT             compressionCaps;

    DebugEntry(MergeCaps);

    sender          = pJoinerPkt->header.sender;
    compressionCaps = 0;

    //
    // We have received a HELLO or WELCOME packet from another node.
    //
    // - For a HELLO packet, these caps will be the caps of a late joiner.
    //
    // - For a WELCOME packet, these caps will be the domain-wide caps as
    // viewed by our helper node.
    //
    // Either way, we need to merge in the capabilities from the packet into
    // our view of the domain-wide capabilities.
    //
    // Note that in some backlevel calls, the joiner packet will not contain
    // capabilities - so check the length of the packet first
    //
    if (lengthOfPkt >= (offsetof(OMNET_JOINER_PKT, capsLen) +
                       sizeof(pJoinerPkt->capsLen)))
    {
       //
       // OK, this packet contains a capsLen field.  See if it contains
       // compression capabilities (these immediately follow the capsLen
       // field and are four bytes long).
       //
       TRACE_OUT(( "Caps len from node 0x%08x is 0x%08x",
                sender, pJoinerPkt->capsLen));

       if (pJoinerPkt->capsLen >= 4)
       {
           //
           // Packet contains compression caps - record them:
           //
           compressionCaps = pJoinerPkt->compressionCaps;
           TRACE_OUT(( "Compression caps in joiner packet from 0x%08x: 0x%08x",
                    sender, compressionCaps));
       }
       else
       {
           //
           // If not specified, assume NO compression is supported.  This
           // should never happen in practice, because if someone supports
           // any capabilities at all, they should support compression
           // capabilities.
           //
           compressionCaps = OM_CAPS_NO_COMPRESSION;
           ERROR_OUT(( "Party 0x%08x supports caps but not compression caps",
                    sender));
       }
    }
    else
    {
       //
       // If no capabilities specified at all, assume PKW compression plus
       // no compression (since that is how LSP20 behaves).
       //
       compressionCaps = (OM_CAPS_PKW_COMPRESSION | OM_CAPS_NO_COMPRESSION);
       TRACE_OUT(( "No caps in joiner pkt - assume PKW + NO compress (0x%08x)",
                compressionCaps));
    }

    //
    // OK, we've determined the capabilities from the packet.  Now merge
    // them into our view of the domain-wide caps:
    //
    pDomain->compressionCaps &= compressionCaps;

    TRACE_OUT(( "Domain-wide compression caps now 0x%08x",
            pDomain->compressionCaps));


    DebugExitVOID(MergeCaps);
} // MergeCaps


//
//
//
// SayWelcome(...)
//
//
//

UINT SayWelcome(POM_PRIMARY        pomPrimary,
                               POM_DOMAIN       pDomain,
                               NET_CHANNEL_ID       channel)
{
    POMNET_JOINER_PKT      pWelcomePkt;

    UINT rc          = 0;

    DebugEntry(SayWelcome);

    //
    // The <channel> passed in is one of the following:
    //
    // - the channel of a late-joiner which just sent us a HELLO message, or
    //
    // - the broadcast ObManControl channel, in the case where this is a
    //   Welcome we're sending at start of day.
    //
    TRACE_OUT(( "Sending welcome on channel %hu ", channel));

    pWelcomePkt = (POMNET_JOINER_PKT)UT_MallocRefCount(sizeof(OMNET_JOINER_PKT), TRUE);
    if (!pWelcomePkt)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    pWelcomePkt->header.sender      = pDomain->userID;     // own user ID
    pWelcomePkt->header.messageType = OMNET_WELCOME;

    //
    // All fields in the joiner packet after <capsLen> are capabilities.  To
    // calculate the size of these capabilities, we use the offset and size
    // of the <capsLen> field itself to determine the amount of data after
    // it.
    //
    pWelcomePkt->capsLen = sizeof(OMNET_JOINER_PKT) -
         (offsetof(OMNET_JOINER_PKT, capsLen) + sizeof(pWelcomePkt->capsLen));

    //
    // The value we use for the compressionCaps is our current view of the
    // domain-wide compression capabilities.
    //
    pWelcomePkt->compressionCaps    = pDomain->compressionCaps;

    TRACE_OUT(( "Sending caps 0x%08x in WELCOME on channel 0x%08x",
            pWelcomePkt->compressionCaps, channel));

    rc = QueueMessage(pomPrimary->putTask,
                     pDomain,
                     channel,
                     NET_TOP_PRIORITY,
                     NULL,                                    // no wsgroup
                     NULL,                                    // no workset
                     NULL,                                    // no object
                     (POMNET_PKT_HEADER) pWelcomePkt,
                     NULL,                               // no object data
                    FALSE);
    if (rc != 0)
    {
      DC_QUIT;
    }

    //
    // When this WELCOME message is received at the other end, the
    // ProcessWelcome function is invoked.
    //

DC_EXIT_POINT:

    if (rc != 0)
    {
      ERROR_OUT(( "Error %d sending welcome on channel 0x%08x in Domain %u",
               rc, channel, pDomain->callID));
    }

    DebugExitDWORD(SayWelcome, rc);
    return(rc);
} // SayWelcome


//
//
//
// ProcessWelcome(...)
//
//
//

UINT ProcessWelcome(POM_PRIMARY        pomPrimary,
                                   POM_DOMAIN       pDomain,
                                   POMNET_JOINER_PKT    pWelcomePkt,
                                   UINT             lengthOfPkt)
{
    POM_WSGROUP         pOMCWSGroup;
    UINT            rc =            0;

    DebugEntry(ProcessWelcome);

    //
    // This function is called when a remote instance of ObMan has replied
    // to an OMNET_HELLO message which we sent.
    //
    // We sent the HELLO message as part of the procedure to get a copy of
    // the ObManControl workset group; now we know someone who has it, we
    // send them an OMNET_WSGROUP_SEND_REQ on their single-user channel,
    // enclosing our own single-user channel ID for the response.
    //
    // However, every node in the Domain will respond to our initial HELLO,
    // but we only need to ask the first respondent for the workset group.
    // So, we check the Domain state and then change it so we will ignore
    // future WELCOMES for this Domain:
    //
    // (No mutex required for this test-and-set since only ever executed in
    // ObMan task).
    //
    if (pDomain->state == PENDING_WELCOME)
    {
        //
        // OK, this is the first WELCOME we've got since we broadcast the
        // HELLO.  So, we reply to it with a SEND_REQUEST for ObManControl.
        //
        TRACE_OUT((
                   "Got first WELCOME message in Domain %u, from node 0x%08x",
                   pDomain->callID, pWelcomePkt->header.sender));

        //
        // Merge in the capabilities which our helper node has told us
        // about:
        //
        MergeCaps(pDomain, pWelcomePkt, lengthOfPkt);

        pOMCWSGroup = GetOMCWsgroup(pDomain);
        if( pOMCWSGroup == NULL)
        {
            TRACE_OUT(("pOMCWSGroup not found"));
            DC_QUIT;
        }


        //
        // ...and call the IssueSendReq function specifying the sender of
        // the WELCOME message as the node to get the workset group from:
        //
        rc = IssueSendReq(pomPrimary,
                          pDomain,
                          pOMCWSGroup,
                          pWelcomePkt->header.sender);
        if (rc != 0)
        {
            ERROR_OUT(( "Error %d requesting OMC from 0x%08x in Domain %u",
                rc, pWelcomePkt->header.sender, pDomain->callID));
            DC_QUIT;
        }

        pDomain->state = GETTING_OMC;

        //
        // Next, the remote node which welcomed us will send us the
        // contents of the ObManControl workset group.  When it has
        // finished, it will send an OMNET_WSGROUP_SEND_COMPLETE message,
        // which is where we take up the next step of the multi-stage
        // Domain attach process.
        //
    }
    else
    {
        //
        // OK, we're in some other state i.e.  not waiting for a WELCOME
        // message - so just ignore it.
        //
        TRACE_OUT(( "Ignoring WELCOME from 0x%08x - in state %hu",
            pWelcomePkt->header.sender, pDomain->state));
    }

    TRACE_OUT(( "Processed WELCOME message from node 0x%08x in Domain %u",
       pWelcomePkt->header.sender, pDomain->callID));

DC_EXIT_POINT:

    if (rc != 0)
    {
       ERROR_OUT(( "Error %d processing WELCOME message from "
                     "node 0x%08x in Domain %u",
                  rc, pWelcomePkt->header.sender, pDomain->callID));
    }

    DebugExitDWORD(ProcessWelcome, rc);
    return(rc);
}




//
// ProcessNetDetachUser()
//
void ProcessNetDetachUser
(
    POM_PRIMARY     pomPrimary,
    POM_DOMAIN      pDomain,
    NET_UID         detachedUserID
)
{
    DebugEntry(ProcessNetDetachUser);

    //
    // There are two cases here:
    //
    // 1.  this is a detach indication for ourselves i.e.  we have been
    //     booted off the network by MCS for some reason
    //
    // 2.  this is a detach indication for someone else i.e.  another user
    //     has left (or been booted off) the MCS Domain.
    //
    // We differentiate the two cases by checking the ID of the detached
    // user against our own.
    //
    if (detachedUserID == pDomain->userID)
    {
        //
        // It's for us, so call the ProcessOwnDetach function:
        //
        ProcessOwnDetach(pomPrimary, pDomain);
    }
    else
    {
        //
        // It's someone else, so we call the ProcessOtherDetach function:
        //
        ProcessOtherDetach(pomPrimary, pDomain, detachedUserID);
    }

    DebugExitVOID(ProcessNetDetachUser);
}



//
// ProcessOtherDetach(...)
//
UINT ProcessOtherDetach
(
    POM_PRIMARY     pomPrimary,
    POM_DOMAIN      pDomain,
    NET_UID         detachedUserID
)
{
    POM_WSGROUP     pOMCWSGroup;
    POM_WORKSET     pOMCWorkset;
    OM_WORKSET_ID   worksetID;
    UINT            rc =        0;

    DebugEntry(ProcessOtherDetach);

    TRACE_OUT(( "DETACH_IND for user 0x%08x in domain %u",
        detachedUserID, pDomain->callID));

    //
    // Someone else has left the Domain.  What this means is that we must
    //
    // - release any locks they may have acquired for worksets/objects in
    //   this Domain
    //
    // - remove any registration objects they might have added to worksets
    //   in ObManControl
    //
    // - remove any objects they have added to non-persistent worksets
    //
    // - if we are catching up from them then select another node to catch
    //   up from or stop catch up if no one else is left.
    //

    //
    // The processing is as follows:
    //
    // FOR each registration workset in ObManControl which is in use
    //
    //     FOR each object in the workset
    //
    //         IF it relates to the node which has just/has just been
    //            detached, then that node was registered with the
    //            workset group, so
    //
    //            - delete the object and post a DELETE_IND to
    //              any local Clients which have the workset open
    //            - search this workset group for any locks held by this
    //              node and release them.
    //

    //
    // OK, to work: first we derive a pointer to the ObManControl workset
    // group:
    //
    pOMCWSGroup = GetOMCWsgroup(pDomain);
    if( pOMCWSGroup == NULL)
    {
        TRACE_OUT(("pOMCWSGroup not found"));
        DC_QUIT;
    }


    //
    // Now begin the outer FOR loop:
    //
    for (worksetID = 0;
         worksetID < OM_MAX_WORKSETS_PER_WSGROUP;
         worksetID++)
    {
        //
        // Get a pointer to the workset:
        //
        pOMCWorkset = pOMCWSGroup->apWorksets[worksetID];
        if (pOMCWorkset == NULL)
        {
            //
            // There is no workset with this ID so we skip to the next one:
            //
            continue;
        }

        ValidateWorkset(pOMCWorkset);

        //
        // OK, worksetID corresponds to the ID of an actual workset group
        // in the domain.  These functions will do any clearup on behalf of
        // the detached node.
        //
        RemovePersonObject(pomPrimary,
                           pDomain,
                           (OM_WSGROUP_ID) worksetID,
                           detachedUserID);

        ReleaseAllNetLocks(pomPrimary,
                           pDomain,
                           (OM_WSGROUP_ID) worksetID,
                           detachedUserID);

        PurgeNonPersistent(pomPrimary,
                           pDomain,
                           (OM_WSGROUP_ID) worksetID,
                           detachedUserID);

        //
        // Finished this workset so go on to the next.
        //
    }

    //
    // Well, that's it:
    //
    TRACE_OUT(( "Cleaned up after node 0x%08x detached from Domain %u",
         detachedUserID, pDomain->callID));


DC_EXIT_POINT:
    DebugExitDWORD(ProcessOtherDetach, rc);
    return(rc);
}



//
// ProcessOwnDetach(..)
//
UINT ProcessOwnDetach
(
    POM_PRIMARY         pomPrimary,
    POM_DOMAIN          pDomain
)
{
    POM_DOMAIN          pLocalDomainRec;
    POM_WSGROUP         pWSGroup;
    POM_LOCK_REQ        pLockReq;
    POM_LOCK_REQ        pTempLockReq;
    POM_WSGROUP         pTempWSGroup;
    POM_WSGROUP_REG_CB  pRegistrationCB;
    POM_WSGROUP_REG_CB  pTempRegCB;
    UINT                callID;
    UINT                rc  = 0;

    DebugEntry(ProcessOwnDetach);

    //
    // First of all, remove all traces of everybody else (because the call
    // may have ended already, we may not get explicit DETACH_INDICATIONs
    // for them):
    //
    ProcessOtherDetach(pomPrimary, pDomain, NET_ALL_REMOTES);

    //
    // We proceed as follows:
    //
    // - get a pointer to the record for the "local" Domain (or create it
    //   if it doesn't exist)
    //
    // - move all the pending lock requests, registrations and workset
    //   groups in this Domain into the local Domain.
    //

    callID = pDomain->callID;

    if (callID == OM_NO_CALL)
    {
       WARNING_OUT(( "Detach for local domain - avoiding recursive cleanup"));
       FreeDomainRecord(&pDomain);
       DC_QUIT;
    }

    TRACE_OUT(( "Processing own detach/end call etc. for Domain %u",
                                                                   callID));
    rc = DomainRecordFindOrCreate(pomPrimary, OM_NO_CALL, &pLocalDomainRec);
    if (rc != 0)
    {
      DC_QUIT;
    }

    //
    // Move the pending lock requests (need the pTemp...  variables since we
    // need to chain from the old position):
    //

    pLockReq = (POM_LOCK_REQ)COM_BasedListFirst(&(pDomain->pendingLocks), FIELD_OFFSET(OM_LOCK_REQ, chain));

    while (pLockReq != NULL)
    {
        TRACE_OUT((" Moving lock for workset %hu in WSG ID %hu",
            pLockReq->worksetID, pLockReq->wsGroupID));

        pTempLockReq = (POM_LOCK_REQ)COM_BasedListNext(&(pDomain->pendingLocks), pLockReq,
            FIELD_OFFSET(OM_LOCK_REQ, chain));

        COM_BasedListRemove(&(pLockReq->chain));
        COM_BasedListInsertBefore(&(pLocalDomainRec->pendingLocks),
                           &(pLockReq->chain));

        pLockReq = pTempLockReq;
    }

    //
    // Now cancel any outstanding registrations:
    //

    pRegistrationCB = (POM_WSGROUP_REG_CB)COM_BasedListFirst(&(pDomain->pendingRegs),
        FIELD_OFFSET(OM_WSGROUP_REG_CB, chain));
    while (pRegistrationCB != NULL)
    {
        TRACE_OUT(("Aborting registration for WSG %d", pRegistrationCB->wsg));

        pTempRegCB = (POM_WSGROUP_REG_CB)COM_BasedListNext(&(pDomain->pendingRegs),
            pRegistrationCB, FIELD_OFFSET(OM_WSGROUP_REG_CB, chain));

        WSGRegisterResult(pomPrimary, pRegistrationCB, OM_RC_NETWORK_ERROR);

        pRegistrationCB = pTempRegCB;
    }

    //
    // Move the workset groups.
    //
    // Note that we will move the ObManControl workset group for the Domain
    // we've detached from into the local Domain as well; it does not
    // replace the OMC workset group for the local Domain, but we can't just
    // throw it away since the Application Loader Primary and Secondaries
    // still have valid workset group handles for it.  They will eventually
    // deregister from it and it will be thrown away.
    //
    // Since WSGMove relies on the fact that there is an OMC workset group
    // in the Domain out of which workset groups are being moved, we must
    // move the OMC workset group last.
    //
    // So, start at the end and work backwards:
    //

    pWSGroup = (POM_WSGROUP)COM_BasedListLast(&(pDomain->wsGroups), FIELD_OFFSET(OM_WSGROUP, chain));
    while (pWSGroup != NULL)
    {
        //
        // Move each one into the local Domain.  We need pTempWSGroup
        // since we have to do the chaining before calling WSGroupMove.
        // That function removes the workset group from the list.
        //
        pTempWSGroup = (POM_WSGROUP)COM_BasedListPrev(&(pDomain->wsGroups), pWSGroup,
            FIELD_OFFSET(OM_WSGROUP, chain));

        WSGMove(pomPrimary, pLocalDomainRec, pWSGroup);

        pWSGroup = pTempWSGroup;
    }

DC_EXIT_POINT:

    if (rc != 0)
    {
        ERROR_OUT(( "Error %d processing NET_DETACH for self in Domain %u",
            rc, callID));
    }

    DebugExitDWORD(ProcessOwnDetach, rc);
    return(rc);

}


//
//
//
// ProcessNetLeaveChannel(...)
//
//
//

UINT ProcessNetLeaveChannel
(
    POM_PRIMARY     pomPrimary,
    POM_DOMAIN      pDomain,
    NET_CHANNEL_ID  channel
)
{
    POM_DOMAIN  pLocalDomainRec;
    POM_WSGROUP     pWSGroup;
    UINT        callID;

    UINT        rc =                0;

    DebugEntry(ProcessNetLeaveChannel);

    callID = pDomain->callID;

    //
    // We've been forced out of the channel by MCS.  We don't try to rejoin
    // as this usually indicates a serious error.  Instead, we treat this
    // as a move of the associated workset group into the local Domain
    // (unless it's our own user ID channel or the ObManControl channel, in
    // which case we can't really do anything useful in this Domain, so we
    // detach completely).
    //
    if ((channel == pDomain->userID) ||
        (channel == pDomain->omcChannel))
    {
        //
        // This is our own user ID channel, so we behave as if we were
        // booted out by MCS:
        //
        rc = ProcessOwnDetach(pomPrimary, pDomain);
        if (rc != 0)
        {
           DC_QUIT;
        }
    }
    else
    {
        //
        // Not our own single-user channel or the ObManControl channel, so
        // we don't need to take such drastic action.  Instead, we process
        // it as if it's a regular move of a workset group into the "local"
        // Domain (i.e.  NET_INVALID_DOMAIN_ID).
        //
        // SFR ?    { Purge our list of outstanding receives for channel
        PurgeReceiveCBs(pDomain, channel);

        //
        // So, find the workset group which is involved...
        //
        COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pDomain->wsGroups),
                (void**)&pWSGroup, FIELD_OFFSET(OM_WSGROUP, chain),
                FIELD_OFFSET(OM_WSGROUP, channelID), (DWORD)channel,
                FIELD_SIZE(OM_WSGROUP, channelID));
        if (pWSGroup == NULL)
        {
            ERROR_OUT((
                       "Got NET_LEAVE for channel %hu but no workset group!",
                       channel));
            DC_QUIT;
        }

        //
        // ...and move it into the local Domain:
        //
        rc = DomainRecordFindOrCreate(pomPrimary,
                                      OM_NO_CALL,
                                      &pLocalDomainRec);
        if (rc != 0)
        {
            DC_QUIT;
        }

        WSGMove(pomPrimary, pLocalDomainRec, pWSGroup);
    }

    TRACE_OUT(( "Processed NET_LEAVE for channel %hu in Domain %u",
        channel, callID));

DC_EXIT_POINT:

    if (rc != 0)
    {
        ERROR_OUT(( "Error %d processing NET_LEAVE for %hu in Domain %u",
            rc, channel, callID));
    }

    DebugExitDWORD(ProcessNetLeaveChannel, rc);
    return(rc);

}



//
//
// LOCKING - OVERVIEW
//
// Workset locking operates on a request/reply protocol, which means that
// when we want a lock, we ask everyone else on the channel if we can have
// it.  If they all say yes, we get it; otherwise we don't.
//
// This is non-trivial.  Some nodes might disappear before they send us
// their reply, while some might disappear after they've send their reply.
// Others might just be far away and take a long time to reply.  In
// addition, new nodes can join the channel at any time.
//
// To cope with all this, to lock a workset we build up a list of the
// remote nodes in the call which are using the workset group (the
// "expected respondents" list) and if the list is non-empty, we broadcast
// an OMNET_LOCK_REQ message on the channel for the workset group which
// contains the workset
//
// As each reply comes in, we check it off against the list of expected
// respondents.  If we weren't expecting a reply from that node we ignore
// it.  Otherwise, if the reply is a GRANT, we remove that node from the
// list and continue waiting for the others.  If the reply is a DENY, we
// give up, discard all the memory allocated for the lock request and its
// associated CBs and post a failure event to the client.
//
// If the list of expected respondents becomes empty because everyone has
// replied with a GRANT, we again free up any memory used and post an event
// to the client.
//
// While all this is going on, we have a timer running in the background.
// It ticks every second for ten seconds (both configurable via .INI file)
// and when it does, we re-examine our list of expected respondents to see
// if any of them have deregistered from the workset group (or detached
// from the domain, which implies the former).  If they have, we fake up a
// GRANT message from them, thus potentially triggering the success event
// to our local client.
//
// If anyone ever requests a lock while we have the lock, we DENY them the
// lock.  If anyone ever requests a lock while we are also requesting the
// lock, we compare their MCS user IDs.  If the other node has a higher
// numerical value, we abort our attempt in favour of them and send back a
// GRANT; otherwise we DENY the lock.
//
// If ever a node detaches when it has a lock, we trap this in
// ReleaseAllNetLocks, which compares the ID of the lock owner against the
// ID of the detached node and unlocks the workset if they match.  For this
// reason, it is vital that we always know exactly who has the lock.  We
// achieve this by, whenever we grant the lock to someone, we record their
// user ID.
//
// So, if we ever abort the locking of a workset in favour of someone else,
// we must broadcast this info to everyone else (since they must be told
// who really has the lock, and they will think that we have the lock if we
// don't tell them otherwise).  We use a LOCK_NOTIFY message for this.
//
//


//
// ProcessLockRequest(...)
//
void ProcessLockRequest
(
    POM_PRIMARY         pomPrimary,
    POM_DOMAIN          pDomain,
    POMNET_LOCK_PKT     pLockReqPkt
)
{
    POM_WSGROUP         pWSGroup;
    POM_WORKSET         pWorkset;
    NET_UID             sender;
    OM_WORKSET_ID       worksetID;
    OMNET_MESSAGE_TYPE  reply = OMNET_LOCK_DENY;
    UINT                rc = 0;

    DebugEntry(ProcessLockRequest);

    sender    = pLockReqPkt->header.sender;
    worksetID = pLockReqPkt->worksetID;

    //
    // Find the workset group and workset this lock request relates to:
    //
    rc = PreProcessMessage(pDomain,
                           pLockReqPkt->wsGroupID,
                           worksetID,
                           NULL,
                           pLockReqPkt->header.messageType,
                           &pWSGroup,
                           &pWorkset,
                           NULL);
    switch (rc)
    {
        case 0:
        {
            //
            // Fine, this is what we want.
            //
        }
        break;

        case OM_RC_WSGROUP_NOT_FOUND:
        {
            //
            // We shouldn't be getting network events for this workset
            // group if we don't have a workset group record for it!
            //
            WARNING_OUT(( "Got LOCK_REQUEST for unknown workset group %hu",
                pLockReqPkt->wsGroupID));

            //
            // Grant the lock anyway:
            //
            reply = OMNET_LOCK_GRANT;
            DC_QUIT;
        }
        break;

        case OM_RC_WORKSET_NOT_FOUND:
        {
            //
            // If we don't have this workset, that means that the lock
            // request has got here before the WORKSET_NEW event for the
            // workset.  This means that we're in the early stages of
            // registering with the workset group, and somebody else is
            // trying to lock the workset.  So, we create the workset now
            // and continue as normal.
            //
            // In the DC_ABSence of any other information, we create the
            // workset with TOP_PRIORITY and PERSISTENT - it will be set to
            // the correct priority when the WORKSET_CATCHUP/NEW arrives.
            //
            WARNING_OUT(( "Lock req for unknown WSG %d workset %d - creating",
                pWSGroup->wsg, worksetID));
            rc = WorksetCreate(pomPrimary->putTask,
                               pWSGroup,
                               worksetID,
                               FALSE,
                               NET_TOP_PRIORITY);
            if (rc != 0)
            {
                reply = OMNET_LOCK_DENY;
                DC_QUIT;
            }

            pWorkset = pWSGroup->apWorksets[worksetID];
        }
        break;

        default:
        {
            ERROR_OUT(( "Error %d from PreProcessMessage", rc));
            reply = OMNET_LOCK_DENY;
            DC_QUIT;
        }
    }

    //
    // Whether we grant this lock to the remote node depends on whether
    // we're trying to lock it for ourselves, so switch according to the
    // workset's lock state:
    //
    ValidateWorkset(pWorkset);

    switch (pWorkset->lockState)
    {
        case LOCKING:
        {
            //
            // We're trying to lock it ourselves, so compare MCS user IDs
            // to resolve the conflict:
            //
            if (pDomain->userID > sender)
            {
                //
                // We win, so deny the lock:
                //
                reply = OMNET_LOCK_DENY;
            }
            else
            {
                //
                // The other node wins, so grant the lock to the node which
                // requested it (marking it as granted to that node) and
                // cancel our own attempt to get it:
                //
                WARNING_OUT(( "Aborting attempt to lock workset %u in WSG %d "
                    "in favour of node 0x%08x",
                    pWorkset->worksetID, pWSGroup->wsg, sender));

                reply = OMNET_LOCK_GRANT;

                //
                // To cancel our own attempt, we must find the lock request
                // CBs which we set up when we sent out our own
                // OMNET_LOCK_REQ.
                //
                // To do this, call HandleMultLockReq which will find and
                // deal with all the pending requests for this workset:
                //
                pWorkset->lockState = LOCK_GRANTED;
                pWorkset->lockCount = 0;
                pWorkset->lockedBy  = sender;

                HandleMultLockReq(pomPrimary,
                                  pDomain,
                                  pWSGroup,
                                  pWorkset,
                                  OM_RC_WORKSET_LOCK_GRANTED);

                //
                // Since we are aborting in favour of another node, need to
                // broadcast a LOCK_NOTIFY so that evryone else stays in
                // sync with who's got the lock.
                //
                // Note: we do not do this in R1.1 calls since this message
                //       is not part of the ObMan R1.1 protocol.
                //
                QueueLockNotify(pomPrimary,
                                pDomain,
                                pWSGroup,
                                pWorkset,
                                sender);
            }
        }
        break;

        case LOCKED:
        {
            //
            // We already have the workset locked so we deny the lock:
            //
            reply = OMNET_LOCK_DENY;
        }
        break;

        case LOCK_GRANTED:
        {
            //
            // If the state is LOCK_GRANTED, we allow this node to have the
            // lock - the other node to which it was previously granted may
            // refuse, but that's not our problem.  We don't change the
            // <lockedBy> field - if the node we think has the lock grants
            // it to the other one, we will receive a LOCK_NOTIFY in due
            // course.
            //
            reply = OMNET_LOCK_GRANT;
        }
        break;

        case UNLOCKED:
        {
            //
            // If the state is UNLOCKED, the other node can have the lock;
            // we don't care, but make sure to record the ID of the node
            // we're granting the lock to:
            //
            reply = OMNET_LOCK_GRANT;

            //
            // SFR5900: Only change the internal state if this is not a
            // check point workset.
            //
            if (pWorkset->worksetID != OM_CHECKPOINT_WORKSET)
            {
                pWorkset->lockState = LOCK_GRANTED;
                pWorkset->lockCount = 0;
                pWorkset->lockedBy  = sender;
            }
        }
        break;

        default:
        {
            //
            // We should have covered all the options so if we get here
            // there's something wrong.
            //
            ERROR_OUT(("Reached default case in workset lock switch (state: %hu)",
                pWorkset->lockState));
        }
    }

DC_EXIT_POINT:

    QueueLockReply(pomPrimary, pDomain, reply, sender, pLockReqPkt);

    DebugExitVOID(ProcessLockRequest);
}


//
// QueueLockReply(...)
//
void QueueLockReply
(
    POM_PRIMARY         pomPrimary,
    POM_DOMAIN          pDomain,
    OMNET_MESSAGE_TYPE  message,
    NET_CHANNEL_ID      channel,
    POMNET_LOCK_PKT     pLockReqPkt
)
{
    POMNET_LOCK_PKT     pLockReplyPkt;
    NET_PRIORITY        priority;

    DebugEntry(QueueLockReply);

    //
    // The reply is identical to the request with the exception of the
    // <messageType> and <sender> fields.  However, we can't just queue the
    // same chunk of memory to be sent, because pLockReqPkt points to a NET
    // buffer which will be freed soon.  So, we allocate some new memory,
    // copy the data across and set the fields:
    //
    pLockReplyPkt = (POMNET_LOCK_PKT)UT_MallocRefCount(sizeof(OMNET_LOCK_PKT), TRUE);
    if (!pLockReplyPkt)
    {
        ERROR_OUT(("Out of memory for QueueLockReply"));
        DC_QUIT;
    }

    pLockReplyPkt->header.sender      = pDomain->userID;
    pLockReplyPkt->header.messageType = message;

    pLockReplyPkt->wsGroupID   = pLockReqPkt->wsGroupID;
    pLockReplyPkt->worksetID   = pLockReqPkt->worksetID;

    //
    // The <data1> field of the lock packet is the correlator the requester
    // put in the original LOCK_REQUEST packet.
    //
    pLockReplyPkt->data1       = pLockReqPkt->data1;

    //
    // Lock replies normally go LOW_PRIORITY (with NET_SEND_ALL_PRIORITIES)
    // so that they do not overtake any data queued at this node.
    //
    // However, if they're for ObManControl we send them TOP_PRIORITY
    // (WITHOUT NET_SEND_ALL_PRIORITIES).  This is safe because _all_
    // ObManControl data is sent TOP_PRIORITY so there's no fear of a lock
    // reply overtaking a data packet.
    //
    // Correspondingly, when we request a lock, we expect one reply at each
    // priority unless it is for ObManControl.
    //
    if (pLockReqPkt->wsGroupID == WSGROUPID_OMC)
    {
        priority = NET_TOP_PRIORITY;
    }
    else
    {
        priority = NET_LOW_PRIORITY | NET_SEND_ALL_PRIORITIES;
    }

    if (QueueMessage(pomPrimary->putTask,
                      pDomain,
                      channel,
                      priority,
                      NULL,
                      NULL,
                      NULL,
                      (POMNET_PKT_HEADER) pLockReplyPkt,
                      NULL,
                        TRUE) != 0)
    {
        ERROR_OUT(("Error queueing lock reply for workset %hu, WSG %hu",
                 pLockReqPkt->worksetID, pLockReqPkt->wsGroupID));

        UT_FreeRefCount((void**)&pLockReplyPkt, FALSE);
    }

DC_EXIT_POINT:
    DebugExitVOID(QueueLockReply);
}



//
// QueueLockNotify(...)
//
void QueueLockNotify
(
    POM_PRIMARY         pomPrimary,
    POM_DOMAIN          pDomain,
    POM_WSGROUP         pWSGroup,
    POM_WORKSET         pWorkset,
    NET_UID             sender
)
{
    POMNET_LOCK_PKT     pLockNotifyPkt;
    NET_PRIORITY        priority;

    DebugEntry(QueueLockNotify);

    ValidateWorkset(pWorkset);

    pLockNotifyPkt = (POMNET_LOCK_PKT)UT_MallocRefCount(sizeof(OMNET_LOCK_PKT), TRUE);
    if (!pLockNotifyPkt)
    {
        ERROR_OUT(("Out of memory for QueueLockNotify"));
        DC_QUIT;
    }

    //
    // For a LOCK_NOTIFY, the <data1> field is the user ID of the node
    // we've granted the lock to.
    //
    pLockNotifyPkt->header.sender      = pDomain->userID;
    pLockNotifyPkt->header.messageType = OMNET_LOCK_NOTIFY;

    pLockNotifyPkt->wsGroupID          = pWSGroup->wsGroupID;
    pLockNotifyPkt->worksetID          = pWorkset->worksetID;
    pLockNotifyPkt->data1              = sender;

    //
    // LOCK_NOTIFY messages go at the priority of the workset involved.  If
    // this is OBMAN_CHOOSES_PRIORITY, then all bets are off and we send
    // them TOP_PRIORITY.
    //
    priority = pWorkset->priority;
    if (priority == OM_OBMAN_CHOOSES_PRIORITY)
    {
        priority = NET_TOP_PRIORITY;
    }

    if (QueueMessage(pomPrimary->putTask,
                      pDomain,
                      pWSGroup->channelID,
                      priority,
                      NULL,
                      NULL,
                      NULL,
                      (POMNET_PKT_HEADER) pLockNotifyPkt,
                      NULL,
                    TRUE) != 0)
    {
        ERROR_OUT(("Error queueing lock notify for workset %hu in WSG %hu",
                 pWorkset->worksetID, pWSGroup->wsGroupID));

        UT_FreeRefCount((void**)&pLockNotifyPkt, FALSE);
    }

DC_EXIT_POINT:
    DebugExitVOID(QueueLockNotify);
}


//
// ProcessLockNotify(...)
//
void ProcessLockNotify
(
    POM_PRIMARY     pomPrimary,
    POM_DOMAIN      pDomain,
    POM_WSGROUP     pWSGroup,
    POM_WORKSET     pWorkset,
    NET_UID         owner
)
{
    POM_WORKSET     pOMCWorkset;
    POM_OBJECT      pObjPerson;

    DebugEntry(ProcessLockNotify);

    ValidateWSGroup(pWSGroup);
    ValidateWorkset(pWorkset);
    //
    // This message is sent when one remote node has granted the lock to
    // another.  We use it to update our view of who has got the lock.
    //
    TRACE_OUT(("Got LOCK_NOTIFY for workset %u in WSG %d - node 0x%08x has the lock",
        pWorkset->worksetID, pWSGroup->wsg, owner));

    //
    // Check the lock state for the workset:
    //
    switch (pWorkset->lockState)
    {
        case LOCKED:
        {
            //
            // A remote node has just told us that another remote node has
            // got this workset lock - but we think we've got it!
            //
            ERROR_OUT(( "Bad LOCK_NOTIFY for WSG %d workset %d, owner 0x%08x",
                pWSGroup->wsg, pWorkset->worksetID, owner));
            DC_QUIT;
        }
        break;

        case LOCKING:
        {
            //
            // We should get a LOCK_DENY or a LOCK_GRANT later - do nothing
            // now.
            //
            DC_QUIT;
        }
        break;

        case LOCK_GRANTED:
        case UNLOCKED:
        {
            //
            // One remote node has granted the lock to another.  Check the
            // latter is still attached, by looking in the control workset:
            //
            pOMCWorkset = GetOMCWorkset(pDomain, pWSGroup->wsGroupID);

            FindPersonObject(pOMCWorkset,
                             owner,
                             FIND_THIS,
                             &pObjPerson);

            if (pObjPerson != NULL)
            {
                ValidateObject(pObjPerson);

                //
                // If our internal state is LOCK_GRANTED and we have just
                // received a LOCK_NOTIFY from another node then we can
                // just ignore it - it is for a lock request that we have
                // just abandoned.
                //
                if ( (pWorkset->lockState == LOCK_GRANTED) &&
                     (owner == pDomain->userID) )
                {
                    TRACE_OUT(( "Ignoring LOCK_NOTIFY for ourselves"));
                    DC_QUIT;
                }

                //
                // Only store the new ID it is greater than the last ID we
                // were notified of - it is possible for LOCK_NOTIFIES to
                // get crossed on the wire.  Consider the following
                // scenario:
                //
                // Machines 1, 2, 3 and 4 are all in a call and all try and
                // lock at the same time.
                //
                // - 2 grants to 3 and sends a LOCK_NOTIFY saying that 3
                //   has the lock.
                //
                // - 3 grants to 4 and sends a LOCK_NOTIFY saying that 4
                //   has the lock
                //
                // 4 actually has the lock at this point.
                //
                // Machine 1 gets the lock notification from 3 and sets its
                // 'lockedBy' field to 4.
                // Machine 1 then gets the lock notification from 2 and
                // resets the 'lockedBy' field to 3.
                //
                // 4 then unlocks and sends the unlock notification.  When
                // 1 gets the unlock, it does not recognise the ID of the
                // unlocking machine (it thinks 3 has the lock) so doesnt
                // bother to reset the local locked state.  Any subsequent
                // attempts to lock the workset on 1 fail because it still
                // still thinks 3 has the lock.
                //
                if (owner > pWorkset->lockedBy)
                {
                    pWorkset->lockedBy = owner;
                    TRACE_OUT(( "Node ID 0x%08x has the lock (?)",
                                        pWorkset->lockedBy));
                }
            }
            else
            {
                //
                // If not, we assume that this node was granted the lock
                // but then went away.  If we did think the workset was
                // locked, mark it as unlocked and post an unlock event.
                //
                if (pWorkset->lockState == LOCK_GRANTED)
                {
                    TRACE_OUT(("node 0x%08x had lock on workset %d in WSG %d but has left",
                        owner, pWorkset->worksetID, pWSGroup->wsg));

                    WorksetUnlockLocal(pomPrimary->putTask, pWorkset);
                }
            }
        }
        break;

        default:
        {
            //
            // We should have covered all the options so if we get here
            // there's something wrong.
            //
            ERROR_OUT(("Reached deafult case in workset lock switch (state: %hu)",
                pWorkset->lockState));
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(ProcessLockNotify);
}



//
// ProcessLockReply(...)
//
void ProcessLockReply
(
    POM_PRIMARY         pomPrimary,
    POM_DOMAIN          pDomain,
    NET_UID             sender,
    OM_CORRELATOR       correlator,
    OMNET_MESSAGE_TYPE  replyType)
{
    POM_WSGROUP         pWSGroup =      NULL;
    POM_WORKSET         pWorkset;
    POM_LOCK_REQ        pLockReq;
    POM_NODE_LIST       pNodeEntry;

    DebugEntry(ProcessLockReply);

    //
    // Search the domain's list of pending locks for one which matches the
    // correlator (we do it this way rather than using the workset group ID
    // and workset ID to ensure that we don't get confused between
    // successive lock requests for the same workset).
    //
    TRACE_OUT(( "Searching domain %u's list for lock corr %hu",
        pDomain->callID, correlator));

    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pDomain->pendingLocks),
            (void**)&pLockReq, FIELD_OFFSET(OM_LOCK_REQ, chain),
            FIELD_OFFSET(OM_LOCK_REQ, correlator), (DWORD)correlator,
            FIELD_SIZE(OM_LOCK_REQ, correlator));
    if (pLockReq == NULL)
    {
        //
        // Could be any of the following:
        //
        // - This reply is from a node we were never expecting a lock
        //   request from in the first place, and we've got all the other
        //   replies so we've thrown away the lock request.
        //
        // - Someone else has denied us the lock so we've given up.
        //
        // - The node was too slow to reply and we've given up on the lock
        //   request.
        //
        // - We've left the domain and so moved all the pending lock
        //   requests into the local domain.
        //
        // - A logic error.
        //
        // The only thing we can do here is quit.
        //
        WARNING_OUT(( "Unexpected lock correlator 0x%08x (domain %u)",
            correlator, pDomain->callID));
        DC_QUIT;
    }

    //
    // Otherwise, we search the list of expected respondents looking for
    // the node which has just replied:
    //
    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pLockReq->nodes),
        (void**)&pNodeEntry, FIELD_OFFSET(OM_NODE_LIST, chain),
        FIELD_OFFSET(OM_NODE_LIST, userID), (DWORD)sender,
        FIELD_SIZE(OM_NODE_LIST, userID));
    if (pNodeEntry == NULL)
    {
        //
        // Could be any of the following:
        //
        // - We removed the node from the list because it had deregistered
        //   when the timeout expired (will only happen when delete of
        //   person object overtakes lock reply and timeout expires locally
        //   betweem the two).
        //
        // - The node joined since we compiled the list.
        //
        // - A logic error.
        //
        TRACE_OUT(("Recd unexpected lock reply from node 0x%08x in Domain %u",
           sender, pDomain->callID));
        DC_QUIT;
    }

    //
    // Otherwise, this is a normal lock reply so we just remove the node
    // from the list and free up its chunk of memory.
    //
    COM_BasedListRemove(&(pNodeEntry->chain));
    UT_FreeRefCount((void**)&pNodeEntry, FALSE);

    pWSGroup = pLockReq->pWSGroup;

    //
    // If the client has just deregistered from the workset group, we'll
    // be throwing it away soon, so don't do any more processing:
    //
    if (!pWSGroup->valid)
    {
        WARNING_OUT(("Ignoring lock reply for discarded WSG %d", pWSGroup->wsg));
        DC_QUIT;
    }

    pWorkset = pWSGroup->apWorksets[pLockReq->worksetID];
    ASSERT((pWorkset != NULL));

    //
    // Now check the workset's lock state: if we're not/no longer trying to
    // lock it, quit.
    //
    // Note, however, that checkpointing worksets are never marked as
    // LOCKING, even when we're locking them, so exclude them from the
    // test:
    //
    if ((pWorkset->lockState != LOCKING) &&
        (pWorkset->worksetID != OM_CHECKPOINT_WORKSET))
    {
        WARNING_OUT(( "Recd unwanted lock reply from %hu for workset %d WSG %d",
           sender, pWorkset->worksetID, pWSGroup->wsg));
        DC_QUIT;
    }

    //
    // If this is a negative reply, then we have failed to get the lock so
    // inform our local client and then quit:
    //
    if (replyType == OMNET_LOCK_DENY)
    {
        //
        // We do not expect this for a CHECKPOINT_WORKSET:
        //
        ASSERT((pWorkset->worksetID != OM_CHECKPOINT_WORKSET));

        WARNING_OUT(( "node 0x%08x has denied the lock for workset %u in WSG %d",
           sender, pWorkset->worksetID, pWSGroup->wsg));

        pWorkset->lockState = UNLOCKED;
        pWorkset->lockCount = 0;

        HandleMultLockReq(pomPrimary,
                          pDomain,
                          pWSGroup,
                          pWorkset,
                          OM_RC_WORKSET_LOCK_GRANTED);

        //
        // Since we have given up our lock request in favour of another
        // node, need to broadcast a LOCK_NOTIFY so that everyone else
        // stays in sync with who's got the lock.
        //
        QueueLockNotify(pomPrimary, pDomain, pWSGroup, pWorkset, sender);

        DC_QUIT;
    }

    TRACE_OUT(( "Affirmative lock reply received from node 0x%08x", sender));

    //
    // Check if the list of expected respondents is now empty:
    //
    if (COM_BasedListIsEmpty(&(pLockReq->nodes)))
    {
        //
        // List is now empty, so all nodes have replied to the request,
        // therefore lock has succeeded:
        //
        TRACE_OUT(( "Got all LOCK_GRANT replies for workset %u in WSG %d",
            pWorkset->worksetID, pWSGroup->wsg));

        if (pWorkset->worksetID == OM_CHECKPOINT_WORKSET)
        {
            //
            // This is a checkpointing workset.  We do not set the state to
            // LOCKED (we never do for these worksets) and we only process
            // the particular pending lock request which this packet came
            // in reply to - otherwise we couldn't guarantee an end-to-end
            // ping on each checkpoint:
            //
            WorksetLockResult(pomPrimary->putTask, &pLockReq, 0);
        }
        else
        {
            //
            // This is not a checkpointing workset, so set the state to
            // LOCKED and process ALL pending locks for this workset:
            //
            pWorkset->lockState = LOCKED;

            HandleMultLockReq(pomPrimary, pDomain, pWSGroup, pWorkset, 0);
        }
    }
    else
    {
        //
        // Otherwise, still awaiting some replies, so we do nothing more
        // for the moment except trace.
        //
        TRACE_OUT(( "Still need lock replies for workset %u in WSG %d",
            pLockReq->worksetID, pWSGroup->wsg));
    }

DC_EXIT_POINT:
    DebugExitVOID(ProcessLockReply);
}



//
// PurgeLockRequests(...)
//
void PurgeLockRequests
(
    POM_DOMAIN      pDomain,
    POM_WSGROUP     pWSGroup
)
{
    POM_LOCK_REQ    pLockReq;
    POM_LOCK_REQ    pNextLockReq;
    POM_NODE_LIST   pNodeEntry;

    DebugEntry(PurgeLockRequests);

    //
    // Search this domain's list of lock requests looking for a match on
    // workset group ID:
    //
    pLockReq = (POM_LOCK_REQ)COM_BasedListFirst(&(pDomain->pendingLocks), FIELD_OFFSET(OM_LOCK_REQ, chain));
    while (pLockReq != NULL)
    {
        //
        // This loop might remove pLockReq from the list, so chain first:
        //
        pNextLockReq = (POM_LOCK_REQ)COM_BasedListNext(&(pDomain->pendingLocks), pLockReq,
            FIELD_OFFSET(OM_LOCK_REQ, chain));

        //
        // For each match...
        //
        if (pLockReq->wsGroupID == pWSGroup->wsGroupID)
        {
            TRACE_OUT(( "'%s' still has lock req oustanding - discarding"));

            //
            // Discard any node list entries remaining...
            //
            pNodeEntry = (POM_NODE_LIST)COM_BasedListFirst(&(pLockReq->nodes), FIELD_OFFSET(OM_NODE_LIST, chain));
            while (pNodeEntry != NULL)
            {
                COM_BasedListRemove(&(pNodeEntry->chain));
                UT_FreeRefCount((void**)&pNodeEntry, FALSE);

                pNodeEntry = (POM_NODE_LIST)COM_BasedListFirst(&(pLockReq->nodes), FIELD_OFFSET(OM_NODE_LIST, chain));
            }

            //
            // ...and discard the lock request itself:
            //
            COM_BasedListRemove(&(pLockReq->chain));
            UT_FreeRefCount((void**)&pLockReq, FALSE);
        }

        pLockReq = pNextLockReq;
    }

    DebugExitVOID(PurgeLockRequests);
}



//
// ProcessLockTimeout(...)
//
void ProcessLockTimeout
(
    POM_PRIMARY     pomPrimary,
    UINT            retriesToGo,
    UINT            callID
)
{
    POM_DOMAIN      pDomain;
    POM_WSGROUP     pWSGroup;
    POM_WORKSET     pWorkset;
    POM_LOCK_REQ    pLockReq = NULL;
    POM_WORKSET     pOMCWorkset;
    POM_OBJECT      pObj;
    POM_NODE_LIST   pNodeEntry;
    POM_NODE_LIST   pNextNodeEntry;

    DebugEntry(ProcessLockTimeout);

    //
    // When we broadcast a lock request, we start a timer going so that we
    // don't hang around for ever waiting for replies from nodes which have
    // gone away.  This timer has now popped, so we validate our list of
    // expected respondents by checking that each entry relates to a node
    // still in the domain.
    //

    //
    // First, find the lock request CB by looking in each domain and then
    // at the correlators of each pending lock request:
    //
    pDomain = (POM_DOMAIN)COM_BasedListFirst(&(pomPrimary->domains), FIELD_OFFSET(OM_DOMAIN, chain));

    while (pDomain != NULL)
    {
        COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pDomain->pendingLocks),
                (void**)&pLockReq, FIELD_OFFSET(OM_LOCK_REQ, chain),
                FIELD_OFFSET(OM_LOCK_REQ, retriesToGo), (DWORD)retriesToGo,
                FIELD_SIZE(OM_LOCK_REQ, retriesToGo));
        if (pLockReq != NULL)
        {
           TRACE_OUT(( "Found correlated lock request"));
           break;
        }

        //
        // Didn't find anything in this domain - go on to the next:
        //
        pDomain = (POM_DOMAIN)COM_BasedListNext(&(pomPrimary->domains), pDomain,
            FIELD_OFFSET(OM_DOMAIN, chain));
    }

    if (pLockReq == NULL)
    {
        TRACE_OUT(( "Lock timeout expired after lock granted/refused"));
        DC_QUIT;
    }

    pWSGroup = pLockReq->pWSGroup;

    //
    // If the client has just deregistered from the workset group, we'll
    // be throwing it away soon, so don't do any more processing:
    //
    if (!pWSGroup->valid)
    {
        WARNING_OUT(( "Ignoring lock timeout for discarded WSG %d",
            pWSGroup->wsg));
        DC_QUIT;
    }

    //
    // We know the workset must still exist because worksets don't get
    // discarded unless the whole workset group is being discarded.
    //
    pWorkset = pWSGroup->apWorksets[pLockReq->worksetID];
    ASSERT((pWorkset != NULL));

    //
    // The workset must be in the LOCKING state because if it is LOCKED or
    // UNLOCKED, then we shouldn't have found a lock request CB for it
    // (unless of course it's a checkpointing workset):
    //
    if (pWorkset->lockState != LOCKING)
    {
        if (pWorkset->worksetID != OM_CHECKPOINT_WORKSET)
        {
            WARNING_OUT((
                "Got lock timeout for workset %u in WSG %d but state is %u",
                pWorkset->worksetID, pWSGroup->wsg,
                pWorkset->lockState));
            DC_QUIT;
        }
    }

    //
    // Go through the relevant control workset to see if any of the
    // expected respondents have disappeared.
    //
    pOMCWorkset = GetOMCWorkset(pDomain, pLockReq->wsGroupID);

    ASSERT((pOMCWorkset != NULL));

    //
    // Chain through each of the objects in our expected respondents list
    // as follows:
    //
    //   FOR each object in the expected respondents list
    //
    //       FOR each person object in the relevant ObManControl workset
    //
    //           IF they match on user ID, this node is still around so
    //              don't delete it
    //
    //       IF no match found then node has gone away so remove it from
    //          expected respondents list.
    //
    //
    pNodeEntry = (POM_NODE_LIST)COM_BasedListFirst(&(pLockReq->nodes), FIELD_OFFSET(OM_NODE_LIST, chain));
    while (pNodeEntry != NULL)
    {
        //
        // We might free up pNodeEntry on a pass through the loop (in
        // ProcessLockReply), but we will need to be able to chain from it
        // all the same.  So, we chain at the START of the loop, putting a
        // pointer to the next item in pTempNodeEntry; at the end of the
        // loop, we assign this value to pNodeEntry:
        //
        pNextNodeEntry = (POM_NODE_LIST)COM_BasedListNext(&(pLockReq->nodes), pNodeEntry,
            FIELD_OFFSET(OM_NODE_LIST, chain));

        //
        // Now, search for this user's person object:
        //
        FindPersonObject(pOMCWorkset,
                      pNodeEntry->userID,
                      FIND_THIS,
                      &pObj);

        if (pObj == NULL)
        {
            //
            // We didn't find this node in the workset, so it must have
            // disappeared.  Therefore, we fake a LOCK_GRANT message from
            // it.  ProcessLockReply will duplicate some of the processing
            // we've done but it saves duplicating code.
            //
            WARNING_OUT((
                    "node 0x%08x has disappeared - faking LOCK_GRANT message",
                    pNodeEntry->userID));

            ProcessLockReply(pomPrimary,
                             pDomain,
                             pNodeEntry->userID,
                             pLockReq->correlator,
                             OMNET_LOCK_GRANT);
        }

        //
        // Now, go on to the next item in the expected respondents list:
        //
        pNodeEntry = pNextNodeEntry;
    }

    //
    // ProcessLockReply may have determined, with the faked messages we
    // gave it, that the lock attempt has succeeded completely.  If so, the
    // workset's lock state will now be LOCKED.  If it isn't, we'll need to
    // post another timeout event.
    //
    if (pWorkset->lockState == LOCKING)
    {
        TRACE_OUT(( "Replies to lock request still expected"));

        if (pLockReq->retriesToGo == 0)
        {
            //
            // We've run out of retries so give up now:
            //
            WARNING_OUT(( "Timed out trying to lock workset %u in WSG %d",
               pLockReq->worksetID, pWSGroup->wsg));

            pWorkset->lockState = UNLOCKED;
            pWorkset->lockedBy  = 0;
            pWorkset->lockCount = 0;

            HandleMultLockReq(pomPrimary,
                              pDomain,
                              pWSGroup,
                              pWorkset,
                              OM_RC_OUT_OF_RESOURCES);

            //
            // Now send an unlock message to all nodes, so that they don't
            // think we still have it locked.
            //
            if (QueueUnlock(pomPrimary->putTask,
                             pDomain,
                             pWSGroup->wsGroupID,
                             pWorkset->worksetID,
                             pWSGroup->channelID,
                             pWorkset->priority) != 0)
            {
                DC_QUIT;
            }
        }
        else // retriesToGo == 0
        {
            pLockReq->retriesToGo--;


            UT_PostEvent(pomPrimary->putTask,
                         pomPrimary->putTask,
                         OM_LOCK_RETRY_DELAY_DFLT,
                         OMINT_EVENT_LOCK_TIMEOUT,
                         retriesToGo,
                         callID);
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(ProcessLockTimeout);
}



//
// HandleMultLockReq
//
void HandleMultLockReq
(
    POM_PRIMARY     pomPrimary,
    POM_DOMAIN      pDomain,
    POM_WSGROUP     pWSGroup,
    POM_WORKSET     pWorkset,
    UINT            result
)
{
    POM_LOCK_REQ   pLockReq;

    DebugEntry(HandleMultLockReq);

    //
    // We need to search this Domain's list of lock requests for every one
    // which matches the workset group and workset specified in the
    // parameter list.  Find the primary record first as a sanity check:
    //
    FindLockReq(pDomain, pWSGroup, pWorkset, &pLockReq, LOCK_PRIMARY);

    if (pLockReq == NULL)
    {
        ERROR_OUT(( "No primary lock request CB found for workset %u!",
            pWorkset->worksetID));
        DC_QUIT;
    }

    while (pLockReq != NULL)
    {
        WorksetLockResult(pomPrimary->putTask, &pLockReq, result);
        FindLockReq(pDomain, pWSGroup, pWorkset,
                    &pLockReq, LOCK_SECONDARY);
    }

DC_EXIT_POINT:
    DebugExitVOID(HandleMultLockReq);
}


//
//
//
// FindLockReq
//
//
//

void FindLockReq(POM_DOMAIN         pDomain,
                              POM_WSGROUP            pWSGroup,
                              POM_WORKSET           pWorkset,
                              POM_LOCK_REQ *     ppLockReq,
                              BYTE                lockType)
{
    POM_LOCK_REQ   pLockReq;

    DebugEntry(FindLockReq);

    //
    // We need to search this Domain's list of lock requests for every one
    // which matches the workset group, workset and lock type specified in
    // the parameter list.
    //
    // So, we search the list to find a match on workset group ID, then
    // compare the workset ID.  If that doesn't match, we continue down the
    // list:
    //
    pLockReq = (POM_LOCK_REQ)COM_BasedListFirst(&(pDomain->pendingLocks), FIELD_OFFSET(OM_LOCK_REQ, chain));
    while (pLockReq != NULL)
    {
        if ((pLockReq->wsGroupID == pWSGroup->wsGroupID) &&
            (pLockReq->worksetID == pWorkset->worksetID) &&
            (pLockReq->type      == lockType))
        {
            break;
        }

        pLockReq = (POM_LOCK_REQ)COM_BasedListNext(&(pDomain->pendingLocks), pLockReq,
            FIELD_OFFSET(OM_LOCK_REQ, chain));
    }

    *ppLockReq = pLockReq;

    DebugExitVOID(FindLockReq);
}



//
// ProcessUnlock(...)
//
void ProcessUnlock
(
    POM_PRIMARY      pomPrimary,
    POM_WORKSET     pWorkset,
    NET_UID         sender
)
{
    DebugEntry(ProcessUnlock);

    //
    // Check the workset was locked by the node that's now unlocking it:
    //
    if (pWorkset->lockedBy != sender)
    {
        WARNING_OUT(( "Unexpected UNLOCK from node 0x%08x for %hu!",
            sender, pWorkset->worksetID));
    }
    else
    {
        TRACE_OUT(( "Unlocking:%hu for node 0x%08x",
            pWorkset->worksetID, sender));

        WorksetUnlockLocal(pomPrimary->putTask, pWorkset);
    }

    DebugExitVOID(ProcessUnlock);
}




//
// ReleaseAllNetLocks(...)
//
void ReleaseAllNetLocks
(
    POM_PRIMARY          pomPrimary,
    POM_DOMAIN      pDomain,
    OM_WSGROUP_ID       wsGroupID,
    NET_UID             userID
)
{
    POM_WSGROUP         pWSGroup;
    POM_WORKSET         pWorkset;
    OM_WORKSET_ID       worksetID;

    DebugEntry(ReleaseAllNetLocks);

    //
    // Find the workset group:
    //
    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pDomain->wsGroups),
            (void**)&pWSGroup, FIELD_OFFSET(OM_WSGROUP, chain),
            FIELD_OFFSET(OM_WSGROUP, wsGroupID), (DWORD)wsGroupID,
            FIELD_SIZE(OM_WSGROUP, wsGroupID));
    if (pWSGroup == NULL)
    {
       //
       // This will happen for a workset group which the other node is
       // registered with but we're not, so just trace and quit:
       //
       TRACE_OUT(("No record found for WSG ID %hu", wsGroupID));
       DC_QUIT;
    }

    TRACE_OUT(( "Releasing all locks held by node 0x%08x in WSG %d",
       userID, pWSGroup->wsg));

    //
    // For each workset in it, if the lock has been granted to the detached
    // node, unlock it:
    //
    for (worksetID = 0;
         worksetID < OM_MAX_WORKSETS_PER_WSGROUP;
         worksetID++)
    {
        pWorkset = pWSGroup->apWorksets[worksetID];
        if (pWorkset == NULL)
        {
            continue;
        }

        //
        // If this workset is locked by someone other than us...
        //
        if (pWorkset->lockState == LOCK_GRANTED)
        {
            //
            // ...and if it is locked by the departed node (or if everyone
            // has been detached)...
            //
            if ((userID == pWorkset->lockedBy) ||
                (userID == NET_ALL_REMOTES))
            {
                //
                // ...unlock it.
                //
                TRACE_OUT((
                      "Unlocking workset %u in WSG %d for detached node 0x%08x",
                       worksetID, pWSGroup->wsg, userID));

                WorksetUnlockLocal(pomPrimary->putTask, pWorkset);
            }
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(ReleaseAllNetLocks);
}



//
// ProcessWSGRegister(...)
//
void ProcessWSGRegister
(
    POM_PRIMARY         pomPrimary,
    POM_WSGROUP_REG_CB  pRegistrationCB
)
{
    POM_DOMAIN          pDomain;
    POM_WSGROUP         pWSGroup;
    POM_USAGE_REC       pUsageRec         = NULL;
    POM_CLIENT_LIST     pClientListEntry;
    UINT                mode;
    UINT                type;
    UINT                rc = 0;

    DebugEntry(ProcessWSGRegister);

    //
    // Check if this registration has been aborted already:
    //
    if (!pRegistrationCB->valid)
    {
        WARNING_OUT(( "Reg CB for WSG %d no longer valid - aborting registration",
            pRegistrationCB->wsg));
        UT_FreeRefCount((void**)&pRegistrationCB, FALSE);
        DC_QUIT;
    }

    //
    // Determine whether we're doing a REGISTER or a MOVE (we use the
    // string values for tracing):
    //
    mode    = pRegistrationCB->mode;
    type    = pRegistrationCB->type;

    TRACE_OUT(( "Processing %d request (pre-Stage1) for WSG %d",
       pRegistrationCB->wsg));

    //
    // Find the Domain record (in the case of a MOVE, this will be the
    // record for the Domain INTO WHICH the Client wants to move the WSG).
    //
    // Note that this process will cause us to attach to the Domain if
    // we're not already attached.
    //
    rc = DomainRecordFindOrCreate(pomPrimary,
                                  pRegistrationCB->callID,
                                  &pDomain);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // Save the pointer to the Domain record because we'll need it later:
    //
    pRegistrationCB->pDomain = pDomain;

    //
    // Put the registration CB in the list hung off the Domain record:
    //
    COM_BasedListInsertAfter(&(pDomain->pendingRegs),
                        &(pRegistrationCB->chain));

    //
    // OK, now we need to look for the workset group.
    //
    // If this is a MOVE, we can find the workset group record immediately
    // using the offset stored in the request CB.
    //
    // If this is a REGISTER, we need to look for the record in the list
    // hung off the Domain record, and, if none is found, create one:
    //
    if (type == WSGROUP_REGISTER)
    {
        WSGRecordFind(pDomain, pRegistrationCB->wsg, pRegistrationCB->fpHandler,
                      &pWSGroup);

        if (pWSGroup == NULL)
        {
            //
            // The workset group was not found in the list hung off the
            // Domain record, which means that there is no workset group
            // with this name/FP combination present ON THIS MACHINE for
            // this Domain.
            //
            rc = WSGRecordCreate(pomPrimary,
                                 pDomain,
                                 pRegistrationCB->wsg,
                                 pRegistrationCB->fpHandler,
                                 &pWSGroup);
            if (rc != 0)
            {
                DC_QUIT;
            }
        }

        //
        // Now that we've got a pointer to the workset group, we put a
        // Client pointer to it into the usage record.
        //
        // We use the <clientPRootData> field of the registration CB as the
        // base and to it we add the offset of the workset group we've just
        // found/created.
        //
        // First, however, to get access to the usage record we need to
        // generate an ObMan pointer to it:
        //
        pUsageRec = pRegistrationCB->pUsageRec;

        //
        // ...and add it to the Client pointer to the root of OMGLOBAL,
        // putting the result in the relevant field in the usage record:
        //
        pUsageRec->pWSGroup = pWSGroup;
        pUsageRec->flags &= ~PWSGROUP_IS_PREGCB;

        //
        // Now add this Client to the workset group's client list (as a
        // PRIMARY):
        //
        rc = AddClientToWSGList(pRegistrationCB->putTask,
                                pWSGroup,
                                pRegistrationCB->hWSGroup,
                                PRIMARY);
        if (rc != 0)
        {
            DC_QUIT;
        }

        pUsageRec->flags |= ADDED_TO_WSGROUP_LIST;
    }
    else  // type == WSGROUP_MOVE
    {
        //
        // Get pointer to WSGroup from the offset stored in the
        // Registration CB:
        //
        pWSGroup = pRegistrationCB->pWSGroup;

        //
        // If it has become invalid, then all local Clients must have
        // deregistered from it in the time it took for this event to to be
        // processed.  This is unusual, but not wrong, so we alert:
        //
        if (!pWSGroup->valid)
        {
            WARNING_OUT(( "Aborting Move req for WSG %d - record is invalid",
               pWSGroup->wsg));
            DC_QUIT;
        }
    }

    //
    // So, whatever just happened above, we should now have a valid pointer
    // to a valid workset group record which is the one the Client wanted
    // to move/register with in the first place.
    //

    //
    // This workset group might be marked TO_BE_DISCARDED, if the last
    // local Client deregistered from it a while ago but it hasn't actually
    // been discarded.  We don't want it discardable any more:
    //
    if (pWSGroup->toBeDiscarded)
    {
        WARNING_OUT(("WSG %d marked TO_BE_DISCARDED - clearing flag for new registration",
            pWSGroup->wsg));
        pWSGroup->toBeDiscarded = FALSE;
    }

    //
    // We'll need the ObMan-context pointer to the workset group later, so
    // store it in the CB:
    //
    pRegistrationCB->pWSGroup = pWSGroup;

    //
    // OK, now we've set up the various records and put the necessary
    // pointers in the registration CB, so start the workset group
    // registration/move process in earnest.  To do this, we post another
    // event to the ObMan task which will result in WSGRegisterStage1 being
    // called.
    //
    // The reason we don't call the function directly is that this event
    // may have to be bounced, and if so, we want to restart the
    // registration process at the beginning of WSGRegisterStage1 (rather
    // than the beginning of this function).
    //
    // Before we post the event, bump up the use counts of the Domain
    // record and workset group, since the CB holds references to them and
    // they may be freed by something else before we process the event.
    //
    // In addition, bump up the use count of the registration CB because if
    // the call goes down before the event is processed, the reg CB will
    // have been freed.
    //
    UT_BumpUpRefCount(pDomain);
    UT_BumpUpRefCount(pWSGroup);
    UT_BumpUpRefCount(pRegistrationCB);

    pRegistrationCB->flags |= BUMPED_CBS;

    UT_PostEvent(pomPrimary->putTask,
                 pomPrimary->putTask,
                 0,                                    // no delay
                 OMINT_EVENT_WSGROUP_REGISTER_CONT,
                 0,                                    // no param1
                 (UINT_PTR) pRegistrationCB);

    TRACE_OUT(( "Processed initial request for WSG %d TASK 0x%08x",
        pRegistrationCB->wsg, pRegistrationCB->putTask));

DC_EXIT_POINT:

    if (rc != 0)
    {
        //
        // We hit an error, so let the Client know:
        //
        WSGRegisterResult(pomPrimary, pRegistrationCB, rc);

        // lonchanc: bug #942 happened here
        // this was ERROR_OUT
        WARNING_OUT(( "Error %d processing WSG %d",
                   rc, pRegistrationCB->wsg));

        //
        // Calling WSGRegisterResult above will have dealt with our bad
        // return code, so we don't need to return it to our caller.  So,
        // swallow:
        //
        rc = 0;
    }

    DebugExitVOID(ProcessWSGRegister);
}


//
//
//
// WSGRegisterAbort(...)
//
//
//

void WSGRegisterAbort(POM_PRIMARY      pomPrimary,
                                   POM_DOMAIN     pDomain,
                                   POM_WSGROUP_REG_CB pRegistrationCB)
{
    DebugEntry(WSGRegisterAbort);

    //
    // This function can be called at any stage of the workset group
    // registration process if for some reason the registration has to be
    // aborted.
    //

    //
    // Now remove this Client from the list of Clients registered with the
    // workset group and if there are none left, discard the workset group:
    //
    RemoveClientFromWSGList(pomPrimary->putTask,
                            pRegistrationCB->putTask,
                            pRegistrationCB->pWSGroup);

    //
    // Now post failure to the Client and finish up the cleanup:
    //
    WSGRegisterResult(pomPrimary, pRegistrationCB, OM_RC_OUT_OF_RESOURCES);

    DebugExitVOID(WSGRegisterAbort);
}



//
// WSGRecordCreate(...)
//
UINT WSGRecordCreate
(
    POM_PRIMARY     pomPrimary,
    POM_DOMAIN      pDomain,
    OMWSG           wsg,
    OMFP            fpHandler,
    POM_WSGROUP *   ppWSGroup
)
{
    POM_WSGROUP     pWSGroup;
    BOOL            opened =    FALSE;
    UINT            rc =        0;

    DebugEntry(WSGRecordCreate);

    pWSGroup = (POM_WSGROUP)UT_MallocRefCount(sizeof(OM_WSGROUP), TRUE);
    if (!pWSGroup)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    SET_STAMP(pWSGroup, WSGROUP);
    pWSGroup->pDomain       = pDomain;
    pWSGroup->valid         = TRUE;
    pWSGroup->wsg           = wsg;
    pWSGroup->fpHandler     = fpHandler;

    COM_BasedListInit(&(pWSGroup->clients));

    pWSGroup->state         = INITIAL;

    //
    // Finally insert the new WSG record into the domain's list.  We insert
    // at the end of the list so if we get forced out of a channel
    // (a LEAVE_IND event) and the channel happens to be reused by MCS
    // for another WSG before we have a chance to process the LEAVE_IND,
    // the record for the old WSG will be found first.
    //
    COM_BasedListInsertBefore(&(pDomain->wsGroups),
                         &(pWSGroup->chain));

    //
    // *** NEW FOR MULTI-PARTY ***
    //
    // The checkpointing process used when helping a late joiner catch up
    // uses a dummy workset (#255) in each workset group.  Create this now:
    //
    rc = WorksetCreate(pomPrimary->putTask,
                       pWSGroup,
                       OM_CHECKPOINT_WORKSET,
                       FALSE,
                       NET_TOP_PRIORITY);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // Set up caller's pointer:
    //
    *ppWSGroup = pWSGroup;

    TRACE_OUT(( "Created record for WSG %d FP %d in Domain %u",
        wsg, fpHandler, pDomain->callID));

DC_EXIT_POINT:

    //
    // Cleanup:
    //

    if (rc != 0)
    {
        ERROR_OUT(( "Error %d creating record for WSG %d FP %d in Domain %u",
            rc, wsg, fpHandler, pDomain->callID));

        if (pWSGroup != NULL)
        {
            COM_BasedListRemove(&(pWSGroup->chain));
            UT_FreeRefCount((void**)&pWSGroup, FALSE);
        }
    }

    DebugExitDWORD(WSGRecordCreate, rc);
    return(rc);
}


//
//
//
// WSGRegisterStage1(...)
//
//
//

void WSGRegisterStage1(POM_PRIMARY       pomPrimary,
                                    POM_WSGROUP_REG_CB  pRegistrationCB)
{
    POM_DOMAIN      pDomain;
    POM_WSGROUP     pWSGroup;

    UINT            type;

    DebugEntry(WSGRegisterStage1);

    //
    // If the registration CB has been marked invalid, then just quit
    // (don't have to do any abort processing since that will have been
    // done by whatever marked the CB invalid):
    //
    if (!pRegistrationCB->valid )
    {
        WARNING_OUT(( "Reg CB for WSG %d marked invalid, quitting",
            pRegistrationCB->wsg));
        DC_QUIT;
    }

    //
    // Determine whether we're doing a REGISTER or a MOVE (we use the
    // string values for tracing):
    //
    type    = pRegistrationCB->type;

    TRACE_OUT(( "Processing %d request (Stage1) for WSG %d",
           type, pRegistrationCB->wsg));

    //
    // Set up pointers
    //
    pDomain = pRegistrationCB->pDomain;
    pWSGroup   = pRegistrationCB->pWSGroup;


    //
    // Check they're still valid:
    //
    if (!pDomain->valid)
    {
        WARNING_OUT(( "Record for Domain %u not valid, aborting registration",
                    pDomain->callID));
        WSGRegisterAbort(pomPrimary, pDomain, pRegistrationCB);
        DC_QUIT;
    }

    ValidateWSGroup(pWSGroup);

    if (!pWSGroup->valid)
    {
        WARNING_OUT(( "Record for WSG %d in Domain %u not valid, aborting",
                    pWSGroup->wsg, pDomain->callID));
        WSGRegisterAbort(pomPrimary, pDomain, pRegistrationCB);
        DC_QUIT;
    }

    //
    // Now examine the Domain state.  If it is
    //
    // - READY, then this is a Domain that we are fully attached to
    //
    // - anything else, then we are some way through the process of
    //   attaching to the Domain (in some other part of the code).
    //
    // We react to each situation as follows:
    //
    // - continue with the workset group registration/move
    //
    // - repost the event with a delay to retry the registration/move in a
    //   short while.
    //
    if (pDomain->state != DOMAIN_READY)
    {
        //
        // Since we are in the process of attaching to the Domain, we can
        // do nothing else at the moment.  Therefore, we bounce this event
        // back to our event queue, with a delay.
        //
        TRACE_OUT(( "State for Domain %u is %hu",
           pDomain->callID, pDomain->state));
        WSGRegisterRetry(pomPrimary, pRegistrationCB);
        DC_QUIT;
    }

    //
    // OK, so the Domain is in the READY state.  What we do next depends on
    // two things:
    //
    // - whether this is a WSGMove or a WSGRegister
    //
    // - what state the workset group is in.
    //

    //
    // If this is a REGISTER, then if the workset group state is
    //
    // - READY, then there's another local Client registered with the
    //   workset, and everything is all set up so we just call
    //   WSGRegisterSuccess straight away.
    //
    // - INITIAL, then this is the first time we've been here for this
    //   workset group, so we start the process of locking
    //   ObManControl etc.  (see below)
    //
    // - anything else, then we're somewhere in between the two:
    //   another reqeust to register with the workset group is in
    //   progress so we repost the event with a delay; by the time it
    //   comes back to us the workset group should be in the READY
    //   state.
    //

    //
    // If this is a MOVE, then if the workset group state is
    //
    // - READY, then the workset group is fully set up in whatever
    //   Domain it's in at the moment so we allow the move to proceed
    //
    // - anything else, then we're somewhere in the middle of the
    //   registration process for the workset group.  We do not want
    //   to interfere with the registration by trying to do a move
    //   simultaneously (for the simple reason that it introduces far
    //   more complexity into the state machine) so we bounce the
    //   event (i.e.  we only process a MOVE when the workset group
    //   is fully set up).
    //

    TRACE_OUT(( "State for WSG %d is %u", pWSGroup->wsg, pWSGroup->state));

    switch (pWSGroup->state)
    {
        case INITIAL:
        {
            //
            // Workset group record has just been created, but nothing else
            // has been done.
            //

            //
            // OK, proceed with processing the Client's move/registration
            // attempt.  Whichever is involved, we start by locking the
            // ObManControl workset group; when that completes, we continue
            // in WSGRegisterStage2.
            //
            // Note: this function returns a lock correlator which it
            //       will be the same as the correlator returned in
            //       the WORKSET_LOCK_CON event.  We will use this
            //       correlator to look up the registration CB, so
            //       stuff the return value from the function in it
            //
            // Note: in the case of a move, we will only ever get
            //       here because we had to retry the move from the
            //       top after failing to lock ObManControl
            //
            LockObManControl(pomPrimary,
                             pDomain,
                             &(pRegistrationCB->lockCorrelator));

            pRegistrationCB->flags |= LOCKED_OMC;

            pWSGroup->state = LOCKING_OMC;
        }
        break;

        case LOCKING_OMC:
        case PENDING_JOIN:
        case PENDING_SEND_MIDWAY:
        {
            //
            // We're already in the process of either registering another
            // Client with this workset group, or moving the workset group
            // into a new Domain, so we delay this Client's
            // registration/move attempt for the moment:
            //

            // Don't expect to get here - remove if error not hit
            //
            // CMF 21/11/95

            ERROR_OUT(( "Should not be here"));
            WSGRegisterRetry(pomPrimary, pRegistrationCB);
            DC_QUIT;
        }
        break;

        case PENDING_SEND_COMPLETE:
        {
            //
            // WSG Already exists locally, and is fully set up.
            //
            if (type == WSGROUP_REGISTER)
            {
                //
                // If we're doing a REGISTER, this means that some other
                // Client must be registered with it.  If we've passed the
                // Clients-per-wsgroup check in ProcessWSGRegister, we must
                // be OK, so we post a result straight away (0 indicates
                // success):
                //
                WSGRegisterResult(pomPrimary, pRegistrationCB, 0);
            }
            else // type == WSGROUP_MOVE
            {
                //
                // We prohibit moves until we're fully caught up:
                //

                // Don't expect to get here - remove if error not hit
                //
                // CMF 21/11/95

                ERROR_OUT(( "Should not be here"));
                WSGRegisterRetry(pomPrimary, pRegistrationCB);
                DC_QUIT;
            }
        }
        break;

        case WSGROUP_READY:
        {
            if (type == WSGROUP_REGISTER)
            {
                //
                // As above:
                //
                WSGRegisterResult(pomPrimary, pRegistrationCB, 0);
            }
            else // type == WSGROUP_MOVE
            {
                //
                // If we're doing a MOVE, then we start by locking
                // ObManControl, just as above:
                //
                LockObManControl(pomPrimary,
                                 pDomain,
                                 &(pRegistrationCB->lockCorrelator));

                pRegistrationCB->flags |= LOCKED_OMC;
                pWSGroup->state = LOCKING_OMC;
            }
        }
        break;

        default:
        {
           ERROR_OUT(("Invalid state %u for WSG %d",
                pWSGroup->state, pWSGroup->wsg));
        }
    }

    TRACE_OUT(( "Completed Stage 1 of %d for WSG %d",
       type, pRegistrationCB->wsg));

DC_EXIT_POINT:

    //
    // We bumped up the use count of the registration CB when we posted the
    // REGISTER_CONT event which got us here, so now free the CB to
    // decrement the use count.  Unless it's already been freed (e.g.
    // because the call went down and the registration was cancelled) it
    // will still be around so future stages of the registration process
    // will be able to use it.
    //
    // NB: Although future stages of the registration process are
    //     asynchronous, they will abort if they cannot find the reg CB in
    //     the Domain list, so we don't have to worry about bumping it for
    //     them (since if it is finally freed, then it must have been
    //     removed from the Domain list).
    //

    UT_FreeRefCount((void**)&pRegistrationCB, FALSE);

    DebugExitVOID(WSGRegisterStage1);
}



//
// LockObManControl(...)
//
void LockObManControl(POM_PRIMARY         pomPrimary,
                                   POM_DOMAIN        pDomain,
                                   OM_CORRELATOR *  pLockCorrelator)
{
    POM_WSGROUP    pOMCWSGroup;
    POM_WORKSET   pOMCWorkset;
    UINT rc  = 0;

    DebugEntry(LockObManControl);

    //
    // Get pointers to the ObManControl workset group and workset #0 in it:
    //
    pOMCWSGroup = GetOMCWsgroup(pDomain);
    if( pOMCWSGroup == NULL)
    {
        TRACE_OUT(("pOMCWSGroup not found"));
        DC_QUIT;
    }

    pOMCWorkset = pOMCWSGroup->apWorksets[0];

    //
    // Start the lock procedure to lock the workset:
    //

    WorksetLockReq(pomPrimary->putTask,
                    pomPrimary,
                    pOMCWSGroup,
                    pOMCWorkset,
                    0,
                    pLockCorrelator);


    TRACE_OUT(( "Requested lock for ObManControl in Domain %u",
          pDomain->callID));

DC_EXIT_POINT:
    DebugExitVOID(LockObManControl);
}


//
//
//
// MaybeUnlockObManControl(...)
//
//
//
void MaybeUnlockObManControl(POM_PRIMARY      pomPrimary,
                                          POM_WSGROUP_REG_CB pRegistrationCB)
{
    POM_WSGROUP         pOMCWSGroup;
    POM_WORKSET        pOMCWorkset;

    DebugEntry(MaybeUnlockObManControl);

    //
    // If we've got ObManControl locked for THIS registration, unlock it
    //
    if (pRegistrationCB->flags & LOCKED_OMC)
    {
        pOMCWSGroup = GetOMCWsgroup(pRegistrationCB->pDomain);
        if( pOMCWSGroup == NULL)
        {
            TRACE_OUT(("pOMCWSGroup not found"));
            DC_QUIT;
        }

        pOMCWorkset = pOMCWSGroup->apWorksets[0];

        TRACE_OUT(( "Unlocking OMC for %d in WSG %d",
               pRegistrationCB->type,
               pRegistrationCB->wsg));

        WorksetUnlock(pomPrimary->putTask, pOMCWSGroup, pOMCWorkset);

        pRegistrationCB->flags &= ~LOCKED_OMC;
    }

DC_EXIT_POINT:
    DebugExitVOID(MaybeUnlockObManControl);
}



//
// ProcessOMCLockConfirm(...)
//
void ProcessOMCLockConfirm
(
    POM_PRIMARY              pomPrimary,
    OM_CORRELATOR           correlator,
    UINT                    result
)
{
    POM_WSGROUP_REG_CB      pRegistrationCB = NULL;
    POM_DOMAIN          pDomain;

    DebugEntry(ProcessOMCLockConfirm);

    TRACE_OUT(( "Got LOCK_CON with result = 0x%08x and correlator = %hu",
        result, correlator));

    //
    // Next step is to find the registration attempt this lock relates to.
    // It could be in any domain, so search through all of them:
    //
    pDomain = (POM_DOMAIN)COM_BasedListFirst(&(pomPrimary->domains), FIELD_OFFSET(OM_DOMAIN, chain));

    while (pDomain != NULL)
    {
        COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pDomain->pendingRegs),
                (void**)&pRegistrationCB, FIELD_OFFSET(OM_WSGROUP_REG_CB, chain),
                FIELD_OFFSET(OM_WSGROUP_REG_CB, lockCorrelator),
                (DWORD)correlator, FIELD_SIZE(OM_WSGROUP_REG_CB, lockCorrelator));

        if (pRegistrationCB != NULL)
        {
            TRACE_OUT(( "Found correlated reg CB in domain %u, for WSG %d",
                pDomain->callID, pRegistrationCB->wsg));
            break;
        }

        //
        // Didn't find anything in this domain - go on to the next:
        //
        pDomain = (POM_DOMAIN)COM_BasedListNext(&(pomPrimary->domains), pDomain,
            FIELD_OFFSET(OM_DOMAIN, chain));
    }

    //
    // If we didn't find it in any of the Domains, it's probably because
    // we've detached from the Domain and thrown away its pending
    // registrations CBs.  So trace and quit:
    //
    if (pRegistrationCB == NULL)
    {
        TRACE_OUT(( "Got LOCK_CON event (correlator: 0x%08x) but no reg CB found",
            correlator));
        DC_QUIT;
    }

    //
    // Now check whether the lock succeeded:
    //
    if (result != 0)
    {
       //
       // Failed to get the lock on ObManControl for some reason.  This
       // could be because of contention, or else a more general problem.
       // In any event, we call WSGRegisterRetry which will retry (or call
       // WSGRegisterResult if we've run out of retries).
       //
       // Note: since WSGRegisterRetry handles move requests as well, we
       // don't need to check here which type of request it is:
       //
       pRegistrationCB->flags &= ~LOCKED_OMC;
       WSGRegisterRetry(pomPrimary, pRegistrationCB);
    }
    else
    {
       //
       // We've got the lock on ObManControl workset #0, so now we proceed
       // to the next step of the registration process.
       //
       // As above, this function handles both MOVE and REGISTER attempts.
       //
       WSGRegisterStage2(pomPrimary, pRegistrationCB);
    }

DC_EXIT_POINT:
    DebugExitVOID(ProcessOMCLockConfirm);
}


//
// ProcessCheckpoint(...)
//
void ProcessCheckpoint
(
    POM_PRIMARY          pomPrimary,
    OM_CORRELATOR       correlator,
    UINT                result
)
{
    POM_DOMAIN      pDomain;
    POM_WSGROUP         pWSGroup;
    POM_HELPER_CB       pHelperCB    = NULL;

    DebugEntry(ProcessCheckpoint);

    //
    // Next step is to find the helper CB this lock relates to.  It could
    // be in any domain, so search through all of them:
    //
    pDomain = (POM_DOMAIN)COM_BasedListLast(&(pomPrimary->domains), FIELD_OFFSET(OM_DOMAIN, chain));
    while (pDomain != NULL)
    {
        COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pDomain->helperCBs),
                (void**)&pHelperCB, FIELD_OFFSET(OM_HELPER_CB, chain),
                FIELD_OFFSET(OM_HELPER_CB, lockCorrelator),
                (DWORD)correlator, FIELD_SIZE(OM_HELPER_CB, lockCorrelator));

        if (pHelperCB != NULL)
        {
           TRACE_OUT(( "Found correlated helper CB, for WSG %d",
                      pHelperCB->pWSGroup->wsg));
           break;
        }

        //
        // Didn't find anything in this domain - go on to the next:
        //
        pDomain = (POM_DOMAIN)COM_BasedListPrev(&(pomPrimary->domains), pDomain,
            FIELD_OFFSET(OM_DOMAIN, chain));
    }

    //
    // If we didn't find it in any of the Domains, it's probably because
    // we've detached from the Domain and thrown away its pending helper
    // CBs.  So trace and quit:
    //
    if (pHelperCB == NULL)
    {
        WARNING_OUT(( "No helper CB found with lock correlator 0x%08x!", correlator));
        DC_QUIT;
    }

    //
    // Set up local pointers:
    //
    pWSGroup = pHelperCB->pWSGroup;
    ValidateWSGroup(pWSGroup);

    //
    // If the "lock" failed, we send a SEND_DENY message to the late
    // joiner.
    //
    if (result != 0)
    {
        WARNING_OUT(( "Failed to checkpoint WSG %d for %u - giving up",
                    pWSGroup->wsg,
                    pHelperCB->lateJoiner));

        IssueSendDeny(pomPrimary,
                      pDomain,
                      pWSGroup->wsGroupID,
                      pHelperCB->lateJoiner,
                      pHelperCB->remoteCorrelator);
        DC_QUIT;
    }

    //
    // The lock succeeded, so check to see if the workset group pointer we
    // stored is still valid:
    //
    if (!pWSGroup->valid)
    {
        WARNING_OUT(("Discarded WSG %d while checkpointing it for %hu",
                    pWSGroup->wsg,
                    pHelperCB->lateJoiner));

        IssueSendDeny(pomPrimary,
                      pDomain,
                      pWSGroup->wsGroupID,
                      pHelperCB->lateJoiner,
                      pHelperCB->remoteCorrelator);
        DC_QUIT;
    }

    //
    // All is well - go ahead and send the workset group to the late
    // joiner:
    //
    TRACE_OUT(("Checkpoint succeeded for WSG %d - sending to late joiner %hu",
           pWSGroup->wsg, pHelperCB->lateJoiner));

    SendWSGToLateJoiner(pomPrimary,
                        pDomain,
                        pWSGroup,
                        pHelperCB->lateJoiner,
                        pHelperCB->remoteCorrelator);

DC_EXIT_POINT:

    //
    // If we found a helper CB, then we just discard it now:
    //
    if (pHelperCB != NULL)
    {
        FreeHelperCB(&pHelperCB);
    }

    DebugExitVOID(ProcessCheckpoint);
}


//
// NewHelperCB(...)
//
BOOL NewHelperCB
(
    POM_DOMAIN      pDomain,
    POM_WSGROUP     pWSGroup,
    NET_UID         lateJoiner,
    OM_CORRELATOR   remoteCorrelator,
    POM_HELPER_CB * ppHelperCB
)
{
    POM_HELPER_CB   pHelperCB;
    BOOL            rc = FALSE;

    DebugEntry(NewHelperCB);

    //
    // This function
    //
    // - allocates a new helper CB
    //
    // - fills in the fields
    //
    // - stores it in the domain's list of helper CBs
    //
    // - bumps the use count of the workset group referenced.
    //

    pHelperCB = (POM_HELPER_CB)UT_MallocRefCount(sizeof(OM_HELPER_CB), TRUE);
    if (!pHelperCB)
    {
        ERROR_OUT(("Out of memory in NewHelperCB"));
        DC_QUIT;
    }

    UT_BumpUpRefCount(pWSGroup);

    SET_STAMP(pHelperCB, HELPERCB);
    pHelperCB->pWSGroup         = pWSGroup;
    pHelperCB->lateJoiner       = lateJoiner;
    pHelperCB->remoteCorrelator = remoteCorrelator;

    //
    // The lock correlator field is filled in later.
    //

    COM_BasedListInsertBefore(&(pDomain->helperCBs), &(pHelperCB->chain));
    rc = TRUE;

DC_EXIT_POINT:

    *ppHelperCB = pHelperCB;

    DebugExitBOOL(NewHelperCB, rc);
    return(rc);
}


//
// FreeHelperCB(...)
//
void FreeHelperCB
(
    POM_HELPER_CB   * ppHelperCB
)
{

    DebugEntry(FreeHelperCB);

    //
    // This function
    //
    // - frees the workset group referenced in the helper CB
    //
    // - removes the helper CB from the domain's list
    //
    // - frees the helper CB.
    //

    UT_FreeRefCount((void**)&((*ppHelperCB)->pWSGroup), FALSE);

    COM_BasedListRemove(&((*ppHelperCB)->chain));
    UT_FreeRefCount((void**)ppHelperCB, FALSE);

    DebugExitVOID(FreeHelperCB);
}


//
// WSGRegisterStage2(...)
//
void WSGRegisterStage2
(
    POM_PRIMARY         pomPrimary,
    POM_WSGROUP_REG_CB  pRegistrationCB
)
{
    POM_DOMAIN          pDomain;
    POM_WSGROUP         pWSGroup;
    POM_OBJECT       pObjInfo;
    POM_WSGROUP_INFO    pInfoObject;
    NET_CHANNEL_ID      channelID;
    UINT                type;
    UINT                rc = 0;

    DebugEntry(WSGRegisterStage2);

    //
    // Determine whether we're doing a REGISTER or a MOVE (we use the string
    // value for tracing):
    //

    type    = pRegistrationCB->type;

    TRACE_OUT(( "Processing %d request (Stage2) for WSG %d",
        type, pRegistrationCB->wsg));

    //
    // We'll need these below:
    //

    pDomain = pRegistrationCB->pDomain;
    pWSGroup   = pRegistrationCB->pWSGroup;

    //
    // Check they're still valid:
    //

    if (!pDomain->valid)
    {
        WARNING_OUT(( "Record for Domain %u not valid, aborting registration",
            pDomain->callID));
        WSGRegisterAbort(pomPrimary, pDomain, pRegistrationCB);
        DC_QUIT;
    }

    if (!pWSGroup->valid)
    {
        WARNING_OUT(( "Record for WSG %d in Domain %u not valid, "
            "aborting registration",
            pWSGroup->wsg, pDomain->callID));
        WSGRegisterAbort(pomPrimary, pDomain, pRegistrationCB);
        DC_QUIT;
    }

    //
    // Sanity check:
    //
    ASSERT(pWSGroup->state == LOCKING_OMC);

    //
    // Now find the information object in workset #0 of ObManControl which
    // matches the WSG name/FP that the Client requested to register with:
    //

    FindInfoObject(pDomain,
                  0,                        // don't know the ID yet
                  pWSGroup->wsg,
                  pWSGroup->fpHandler,
                  &pObjInfo);

    if (pObjInfo == NULL)
    {
        //
        // The workset group doesn't already exist in the Domain.
        //
        // If this is a REGISTER, this means we must create it.  If this is a
        // MOVE, then we can move it into the Domain, which is essentially
        // creating it in the Domain with pre-existing contents.
        //
        // So, for both types of operation, our behaviour is the same at this
        // point; we've already created the workset group record so what we
        // do now is
        //
        // 1.  get the Network layer to allocate a new channel ID,
        //
        // 2.  allocate a new workset group ID and
        //
        // 3.  announce the new workset group to the rest of the Domain.
        //
        // However, the network layer will not assign us a new channel ID
        // synchronously, so steps 2 and 3 must be delayed until we receive
        // the Join event.
        //
        // So, now we set the channel to be joined to 0 (this tells the
        // Network layer to join us to a currently unused channel).
        //
        channelID = 0;
    }
    else
    {
        //
        // Otherwise, the workset group already exists.
        //
        ValidateObject(pObjInfo);

        if (type == WSGROUP_REGISTER)
        {
            //
            // We're registering the Client with an existing workset group, so
            // set the workset group ID to the existing value, and ditto for
            // the channel ID:
            //

            pInfoObject = (POM_WSGROUP_INFO) pObjInfo->pData;
            if (!pInfoObject)
            {
                ERROR_OUT(("WSGRegisterStage2 object 0x%08x has no data", pObjInfo));
                rc = OM_RC_OBJECT_DELETED;
                DC_QUIT;
            }

            ValidateObjectDataWSGINFO(pInfoObject);

            channelID = pInfoObject->channelID;
        }
        else // type == WSGROUP_MOVE
        {
            //
            // We can't move a workset group into a Domain where there already
            // exists a workest group with the same name/FP, so we abort our
            // move attempt at this point (we set the workset group sate back
            // to READY, since that is its state in the Domain it was
            // originally in):
            //

            WARNING_OUT(( "Cannot move WSG %d into Domain %u - WSG/FP clash",
                pWSGroup->wsg, pDomain->callID));

            pWSGroup->state = WSGROUP_READY;

            rc = OM_RC_CANNOT_MOVE_WSGROUP;
            DC_QUIT;
        }
    }

    //
    // Now join the relevant channel (possibly a new one, if <channel> was
    // set to 0 above) and stuff the correlator in the <channelCorrelator>
    // field of the registration CB (when the Join event arrives,
    // ProcessNetJoinChannel will search for the registration CB by channel
    // correlator)
    //
    // Note: if this is our "local" Domain, we skip this step.
    //

    if (pDomain->callID != NET_INVALID_DOMAIN_ID)
    {
        TRACE_OUT(( "Joining channel %hu, Domain %u",
            channelID, pDomain->callID));

        rc = MG_ChannelJoin(pomPrimary->pmgClient,
                           &(pRegistrationCB->channelCorrelator),
                           channelID);
        if (rc != 0)
        {
            DC_QUIT;
        }

        pWSGroup->state = PENDING_JOIN;

        //
        // OK, that's it for the moment.  The saga of workset group
        // move/registration will be picked up by the ProcessNetJoinChannel
        // function, which will invoke the WSGRegisterStage3 function.
        //
    }
    else
    {
        //
        // Since we didn't do a join just now, we won't be getting a JOIN
        // event from the Network layer, so we better call WSGRegisterStage3
        // directly:
        //
        pWSGroup->state = PENDING_JOIN;

        // channel ID not relevant here so use zero
        WSGRegisterStage3(pomPrimary, pDomain, pRegistrationCB, 0);
    }

    TRACE_OUT(( "Completed Register/Move Stage 2 for WSG %d", pWSGroup->wsg));

DC_EXIT_POINT:

    if (rc != 0)
    {
        //
        // Cleanup:
        //

        ERROR_OUT(( "Error %d at Stage 2 of %d for WSG %d",
            rc, pWSGroup->wsg));

        WSGRegisterResult(pomPrimary, pRegistrationCB, rc);
    }

    DebugExitVOID(WSGRegisterStage2);
}




//
// WSGRegisterStage3(...)
//
void WSGRegisterStage3
(
    POM_PRIMARY         pomPrimary,
    POM_DOMAIN          pDomain,
    POM_WSGROUP_REG_CB  pRegistrationCB,
    NET_CHANNEL_ID      channelID
)
{
    POM_WSGROUP         pWSGroup;
    POM_WSGROUP         pOMCWSGroup;
    POM_WORKSET         pOMCWorkset;
    POM_OBJECT       pObjInfo;
    POM_OBJECT       pObjReg;
    POM_WSGROUP_INFO    pInfoObject =       NULL;
    UINT                type;
    BOOL                catchUpReqd =       FALSE;
    BOOL                success =           FALSE;   // SFR 2744
    UINT                rc =                0;

    DebugEntry(WSGRegisterStage3);

    //
    // We get here when a Join event has been received containing a channel
    // correlator for a channel which is a regular workset group channel.
    //

    //
    // Determine whether we're doing a REGISTER or a MOVE (we use the
    // string values for tracing):
    //
    type    = pRegistrationCB->type;

    TRACE_OUT(( "Processing %d request (Stage3) for WSG %d",
       type, pRegistrationCB->wsg));

    //
    // Get a pointer to the workset group:
    //
    pWSGroup = pRegistrationCB->pWSGroup;

    //
    // Check it's still valid:
    //
    if (!pWSGroup->valid)
    {
        WARNING_OUT(("WSG %d' discarded from domain %u - aborting registration",
            pWSGroup->wsg, pDomain->callID));
        WSGRegisterAbort(pomPrimary, pDomain, pRegistrationCB);
        DC_QUIT;
    }

    //
    // Check that this workset group is pending join:
    //
    if (pWSGroup->state != PENDING_JOIN)
    {
        WARNING_OUT(( "Received unexpected Join indication for WSG (state: %hu)",
            pWSGroup->state));
        rc = OM_RC_NETWORK_ERROR;
        DC_QUIT;
    }

    //
    // Now set the channel ID value in the workset group record:
    //
    pWSGroup->channelID = channelID;

    TRACE_OUT(( "Channel ID for WSG %d in Domain %u is %hu",
        pWSGroup->wsg, pDomain->callID, channelID));

    //
    // We'll need this below:
    //
    pOMCWSGroup = GetOMCWsgroup(pDomain);

    //
    // What we do next depends on whether we just created the workset
    // group:
    //
    // - if it already existed, we need to catch up by asking another node
    //   for a copy
    //
    // - if we've just created it, we need to allocate a new workset group
    //   ID and add an INFO object to workset #0 in ObManControl.
    //
    // So, we search workset #0 for an INFO object to see if the workset
    // group exists.
    //
    // Note: we did a similar search in Stage2 to find out the channel to
    //       join for the workset group.  The reason we search again here
    //       is that the workset group could have been discarded by the
    //       other node in the time taken for the join to complete.
    //
    FindInfoObject(pDomain,
                   0,                       // don't know the ID yet
                   pWSGroup->wsg,
                   pWSGroup->fpHandler,
                   &pObjInfo);

    if (!pObjInfo || !pObjInfo->pData)
    {
        //
        // Doesn't already exist, so no catch-up required:
        //
        catchUpReqd = FALSE;
    }
    else
    {
        //
        // OK, so we found an INFO object, but there might not be any
        // registration record objects in the relevant registration
        // workset, so check:
        //
        ValidateObject(pObjInfo);
        pInfoObject = (POM_WSGROUP_INFO) pObjInfo->pData;
        ValidateObjectDataWSGINFO(pInfoObject);

        pOMCWorkset = pOMCWSGroup->apWorksets[pInfoObject->wsGroupID];
        if (pOMCWorkset == NULL)
        {
            catchUpReqd = TRUE;
        }
        else
        {
            FindPersonObject(pOMCWorkset,
                             pDomain->userID,
                             FIND_OTHERS,
                             &pObjReg);

            if (pObjReg == NULL)
            {
                //
                // This will happen when the remote node has deleted its
                // registration record object but hasn't yet deleted the
                // info object.  Because the reg rec object is gone, we
                // can't catch up from that node (or any node):
                //
                TRACE_OUT(( "INFO object found but no reg object - creating"));

                catchUpReqd = FALSE;
            }
            else
            {
                ValidateObject(pObjReg);
                catchUpReqd = TRUE;
            }
        }
    }

    //
    // We should never try to catch up in the local Domain:
    //
    if (catchUpReqd && (pDomain->callID == OM_NO_CALL))
    {
        ERROR_OUT(( "Nearly tried to catch up in local Domain!"));
        catchUpReqd = FALSE;
    }

    if (catchUpReqd)
    {
        //
        // The workset group already exists, so we need to
        //
        // - set the workset group ID to the value in the INFO object, and
        //
        // - start the catch up process.
        //
        // Note: this will only happen in the case of a REGISTER, so we
        //       assert
        //
        ASSERT((pRegistrationCB->type == WSGROUP_REGISTER));

        ASSERT((pInfoObject != NULL));

        pWSGroup->wsGroupID = pInfoObject->wsGroupID;

        rc = WSGCatchUp(pomPrimary, pDomain, pWSGroup);

        if (rc == OM_RC_NO_NODES_READY)
        {
            //
            // We get this return code when there are nodes out there with
            // a copy but none of them are ready to send us the workset
            // group.
            //
            // The correct thing to do is to give up for the moment and try
            // again:
            //
            WSGRegisterRetry(pomPrimary, pRegistrationCB);
            rc = 0;
            DC_QUIT;
        }

        //
        // Any other error is more serious:
        //
        if (rc != 0)
        {
            DC_QUIT;
        }

        //
        // We won't be ready to send the workset group to a late-joiner
        // node until we've caught up ourselves; when we have, the
        // ProcessSendComplete function will call RegAnnounceComplete to
        // update the reg object added for us by our helper node.
        //
    }
    else
    {
        if (type == WSGROUP_MOVE)
        {
            //
            // If this is a MOVE, pWSGroup refers to a workset group record
            // which currently belongs to its "old" Domain.  Since we're
            // just about to announce the workset group's presence in its
            // new Domain, this is the time to do the move:
            //
            WSGRecordMove(pomPrimary, pRegistrationCB->pDomain, pWSGroup);

            //
            // This will have reset the channel ID in the workset group
            // record so we set it again here (yeah, it's naff):
            //
            pWSGroup->channelID = channelID;
        }

        //
        // We've either just created a new workset group, or moved one into
        // a new Domain, so we need to create a new ID for it in this
        // Domain:
        //
        rc = WSGGetNewID(pomPrimary, pDomain, &(pWSGroup->wsGroupID));
        if (rc != 0)
        {
            DC_QUIT;
        }

        TRACE_OUT(( "Workset group ID for WSG %d in Domain %u is %hu",
            pWSGroup->wsg, pDomain->callID, pWSGroup->wsGroupID));

        //
        // Now call CreateAnnounce to add a WSG_INFO object to workset #0
        // in ObManControl.
        //
        rc = CreateAnnounce(pomPrimary, pDomain, pWSGroup);
        if (rc != 0)
        {
            DC_QUIT;
        }

        //
        // Since we have completed our registration with the workset group,
        // we announce to the world that we have a copy and will send it to
        // others on request:
        //
        rc = RegAnnounceBegin(pomPrimary,
                              pDomain,
                              pWSGroup,
                              pDomain->userID,
                              &(pWSGroup->pObjReg));
        if (rc != 0)
        {
            DC_QUIT;
        }

        rc = SetPersonData(pomPrimary, pDomain, pWSGroup);
        if (rc != 0)
        {
            DC_QUIT;
        }

        rc = RegAnnounceComplete(pomPrimary, pDomain, pWSGroup);
        if (rc != 0)
        {
            DC_QUIT;
        }

        //
        // If we're not catching up, we call Result immediately (if we are
        // catching up, Result will be called when we get the SEND_MIDWAY
        // message):
        //
        // SFR 2744 : Can't call result here because we refer to the reg
        //            CB below.  So, just set a flag and act on it below.
        //
        success = TRUE;
    }

    TRACE_OUT(( "Completed Register/Move Stage 3 for WSG %d",
        pWSGroup->wsg));

DC_EXIT_POINT:

    //
    // OK, the critical test-and-set on the ObManControl workset group is
    // finished, so we unlock workset #0 in ObManControl:
    //
    MaybeUnlockObManControl(pomPrimary, pRegistrationCB);

    // SFR 2744 { : Call WSGRegResult AFTER checks on the flags in reg CB
    if (success == TRUE)
    {
        WSGRegisterResult(pomPrimary, pRegistrationCB, 0);
    }
    // SFR 2744 }

    if (rc != 0)
    {
        WARNING_OUT(( "Error %d at Stage 3 of %d with WSG %d",
            rc, type, pWSGroup->wsg));

        WSGRegisterResult(pomPrimary, pRegistrationCB, rc);
        rc = 0;
    }

    DebugExitVOID(WSGRegisterStage2);
}



//
// WSGGetNewID(...)
//
UINT WSGGetNewID
(
    POM_PRIMARY         pomPrimary,
    POM_DOMAIN          pDomain,
    POM_WSGROUP_ID      pWSGroupID
)
{
    POM_WSGROUP         pOMCWSGroup;
    POM_WORKSET         pOMCWorkset;
    POM_OBJECT          pObj;
    POM_WSGROUP_INFO    pInfoObject;
    OM_WSGROUP_ID       wsGroupID;
    BOOL                found;
    BYTE                wsGroupIDsInUse[OM_MAX_WSGROUPS_PER_DOMAIN];
    UINT                rc = 0;

    DebugEntry(WSGGetNewID);

    TRACE_OUT(( "Searching for new WSG ID in Domain %u", pDomain->callID));

    ZeroMemory(wsGroupIDsInUse, sizeof(wsGroupIDsInUse));

    //
    // Need to pick a workset group ID so far unused in this Domain to
    // identify this new workset group.  So, we build up a list of the IDs
    // currently in use (by examining the INFO objects in workset #0) and
    // then choose one that's not in use.
    //

    pOMCWSGroup = GetOMCWsgroup(pDomain);
    if( pOMCWSGroup == NULL)
    {
        TRACE_OUT(("pOMCWSGroup not found"));
        DC_QUIT;
    }

    pOMCWorkset = pOMCWSGroup->apWorksets[0];

    pObj = (POM_OBJECT)COM_BasedListFirst(&(pOMCWorkset->objects), FIELD_OFFSET(OM_OBJECT, chain));

    while (pObj != NULL)
    {
        ValidateObject(pObj);

        if (pObj->flags & DELETED)
        {
            //
            // Do nothing
            //
        }
        else if (!pObj->pData)
        {
            //
            // Do nothing
            //
            ERROR_OUT(("WSGGetNewID:  object 0x%08x has no data", pObj));
        }
        else
        {
            ValidateObjectData(pObj->pData);
            pInfoObject = (POM_WSGROUP_INFO)pObj->pData;

            if (pInfoObject->idStamp != OM_WSGINFO_ID_STAMP)
            {
                //
                // Do nothing
                //
            }
            else
            {
                //
                // OK, we've found a WSGROUP_INFO object, so cross off the
                // workset group ID which its workset group is using:
                //
                wsGroupID = pInfoObject->wsGroupID;

                wsGroupIDsInUse[wsGroupID] = TRUE;
            }
        }

        pObj = (POM_OBJECT)COM_BasedListNext(&(pOMCWorkset->objects), pObj,
            FIELD_OFFSET(OM_OBJECT, chain));
    }

    //
    // Now go through the array to find an ID that wasn't marked as being in
    // use:
    //

    found = FALSE;

    for (wsGroupID = 0; wsGroupID < OM_MAX_WSGROUPS_PER_DOMAIN; wsGroupID++)
    {
        if (!wsGroupIDsInUse[wsGroupID])
        {
            TRACE_OUT(( "Workset group ID %hu is not in use, using", wsGroupID));
            found = TRUE;
            break;
        }
    }

    //
    // We checked earlier that the number of workset groups in the Domain
    // hadn't exceeded the maximum (in WSGRecordCreate).
    //
    // However, if the Domain has run out of workset groups in the period
    // since then, we won't have found any:
    //

    if (found == FALSE)
    {
        WARNING_OUT(( "No more workset group IDs for Domain %u!",
            pDomain->callID));
        rc = OM_RC_TOO_MANY_WSGROUPS;
        DC_QUIT;
    }

    //
    // If this is the first time that this ID has been used, then the
    // associated registration workset won't exist.  In this case, we create
    // it now.
    //
    // If the ID has been used before, it will exist but it should be empty.
    // In this case, we check that it really is empty.
    //

    pOMCWorkset = pOMCWSGroup->apWorksets[wsGroupID];

    if (pOMCWorkset == NULL)
    {
        TRACE_OUT(( "Registration workset %u not used yet, creating", wsGroupID));

        rc = WorksetCreate(pomPrimary->putTask,
                         pOMCWSGroup,
                         wsGroupID,
                         FALSE,
                         NET_TOP_PRIORITY);
      if (rc != 0)
      {
         DC_QUIT;
      }
    }
    else
    {
        ASSERT((pOMCWorkset->numObjects == 0));

        TRACE_OUT(( "Registration workset %u previously used, re-using",
            wsGroupID));
    }

    //
    // Set the caller's pointer:
    //

    *pWSGroupID = wsGroupID;

DC_EXIT_POINT:

    if (rc != 0)
    {
      //
      // Cleanup:
      //

      ERROR_OUT(( "Error %d allocating ID for new workset group", rc));
    }

    DebugExitDWORD(WSGGetNewID, rc);
    return(rc);
}



//
// CreateAnnounce(...)
//
UINT CreateAnnounce
(
    POM_PRIMARY         pomPrimary,
    POM_DOMAIN          pDomain,
    POM_WSGROUP         pWSGroup
)
{
    POM_WSGROUP         pOMCWSGroup;
    POM_WORKSET         pOMCWorkset;
    POM_WSGROUP_INFO    pInfoObject;
    POM_OBJECT       pObj;
    OM_OBJECT_ID        infoObjectID;
    UINT                rc = 0;

    DebugEntry(CreateAnnounce);

    TRACE_OUT(("Announcing creation of WSG %d in Domain %u",
        pWSGroup->wsg, pDomain->callID));

    //
    // Announcing a new workset group involves adding an object which
    // defines the workset group to workset #0 in ObManControl.
    //
    // So, we derive a pointer to the workset...
    //

    pOMCWSGroup = GetOMCWsgroup(pDomain);
    if( pOMCWSGroup == NULL)
    {
        TRACE_OUT(("pOMCWSGroup not found"));
        DC_QUIT;
    }

    pOMCWorkset = pOMCWSGroup->apWorksets[0];
    ASSERT((pOMCWorkset != NULL));

    //
    // ...create a definition object...
    //
    pInfoObject = (POM_WSGROUP_INFO)UT_MallocRefCount(sizeof(OM_WSGROUP_INFO), TRUE);
    if (!pInfoObject)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    //
    // ...fill in the fields...
    //
    // (length = sizeof - 4 since value of length field doesn't include the
    // size of the length field itself).
    //

    pInfoObject->length    = sizeof(OM_WSGROUP_INFO) -
                            sizeof(OM_MAX_OBJECT_SIZE);
    pInfoObject->idStamp   = OM_WSGINFO_ID_STAMP;
    pInfoObject->channelID = pWSGroup->channelID;
    pInfoObject->creator   = pDomain->userID;
    pInfoObject->wsGroupID = pWSGroup->wsGroupID;

    lstrcpy(pInfoObject->wsGroupName,     OMMapWSGToName(pWSGroup->wsg));
    lstrcpy(pInfoObject->functionProfile, OMMapFPToName(pWSGroup->fpHandler));

    //
    // ...and add the object to the workset...
    //

    rc = ObjectAdd(pomPrimary->putTask,
                  pomPrimary,
                  pOMCWSGroup,
                  pOMCWorkset,
                  (POM_OBJECTDATA) pInfoObject,
                  0,                               // update size == 0
                  LAST,
                  &infoObjectID,
                  &pObj);
    if (rc != 0)
    {
        DC_QUIT;
    }

    TRACE_OUT(( "Announced new WSG %d in Domain %u",
        pWSGroup->wsg, pDomain->callID));

DC_EXIT_POINT:

    if (rc != 0)
    {
        //
        // Cleanup:
        //
        ERROR_OUT(("Error %d announcing new WSG %d in Domain %u",
                 rc, pWSGroup->wsg, pDomain->callID));
    }

    DebugExitDWORD(CreateAnnounce, rc);
    return(rc);
}



//
// WSGCatchUp(...)
//
UINT WSGCatchUp
(
    POM_PRIMARY             pomPrimary,
    POM_DOMAIN              pDomain,
    POM_WSGROUP             pWSGroup)
{
    POM_WORKSET             pOMCWorkset;
    POM_OBJECT           pObj;
    POM_WSGROUP_REG_REC     pRegObject;
    NET_UID                 remoteUserID;
    UINT                    rc = 0;

    DebugEntry(WSGCatchUp);

    TRACE_OUT(( "Starting catch-up for WSG %d in Domain %u",
        pWSGroup->wsg, pDomain->callID));

    //
    // This should never be for the "local" Domain:
    //

    ASSERT((pDomain->callID != NET_INVALID_DOMAIN_ID));

    //
    // The catch-up procedure is as follows:
    //
    // - look in ObManControl workset group for the ID of an instance of
    //   ObMan which has a copy of this workset group
    //
    // - send it an OMNET_WSGROUP_SEND_REQ message
    //
    // So, start by getting a pointer to the relevant workset:
    //

    pOMCWorkset = GetOMCWorkset(pDomain, pWSGroup->wsGroupID);
    ValidateWorkset(pOMCWorkset);

    //
    // Now we chain through the workset looking for a reg object which has
    // status READY_TO_SEND:
    //

    pObj = (POM_OBJECT)COM_BasedListFirst(&(pOMCWorkset->objects), FIELD_OFFSET(OM_OBJECT, chain));

    remoteUserID = 0;

    while (pObj != NULL)
    {
        ValidateObject(pObj);

        if (pObj->flags & DELETED)
        {
            //
            // Skip this one
            //
        }
        else if (!pObj->pData)
        {
            //
            // Skip this one
            //
            ERROR_OUT(("WSGCatchUp: object 0x%08x has no data", pObj));
        }
        else
        {
            pRegObject = (POM_WSGROUP_REG_REC)pObj->pData;
            ValidateObjectDataWSGREGREC(pRegObject);

            if ((pRegObject->status == READY_TO_SEND) &&
                (pRegObject->userID != pDomain->userID))
            {
                //
                // OK, this node has a full copy, so we'll try to get it from
                // there:
                //
                remoteUserID = pRegObject->userID;
                break;
            }
        }

        pObj = (POM_OBJECT)COM_BasedListNext(&(pOMCWorkset->objects), pObj,
            FIELD_OFFSET(OM_OBJECT, chain));
    }

    //
    // ...check that we did actually find a node to get the data from:
    //
    if (remoteUserID == 0)
    {
        WARNING_OUT(( "No node in Domain %u is ready to send WSG %d - retrying",
            pDomain->callID, pWSGroup->wsg));
        rc = OM_RC_NO_NODES_READY;
        DC_QUIT;
    }

    //
    // ...then send that node a request to send us the workset group:
    //
    rc = IssueSendReq(pomPrimary,
                     pDomain,
                     pWSGroup,
                     remoteUserID);

DC_EXIT_POINT:

    if ((rc != 0) && (rc != OM_RC_NO_NODES_READY))
    {
        ERROR_OUT(( "Error %d starting catch-up for WSG %d in Domain %u",
            rc, pWSGroup->wsg, pDomain->callID));
    }

    DebugExitDWORD(WSGCatchUp, rc);
    return(rc);
}




//
// IssueSendDeny(...)
//
void IssueSendDeny
(
    POM_PRIMARY     pomPrimary,
    POM_DOMAIN      pDomain,
    OM_WSGROUP_ID   wsGroupID,
    NET_UID         sender,
    OM_CORRELATOR   remoteCorrelator
)
{
    POMNET_WSGROUP_SEND_PKT    pWSGSendPkt;

    DebugEntry(IssueSendDeny);

    //
    // Now issue the SEND_DENY.
    //
    TRACE_OUT(( "Sending SEND_DENY message to late joiner 0x%08x", sender));

    //
    // We start by allocating some memory:
    //
    pWSGSendPkt = (POMNET_WSGROUP_SEND_PKT)UT_MallocRefCount(sizeof(OMNET_WSGROUP_SEND_PKT), TRUE);
    if (!pWSGSendPkt)
    {
        ERROR_OUT(("Out of memory in IssueSendDeny"));
        DC_QUIT;
    }

    //
    // Now fill in the fields:
    //
    pWSGSendPkt->header.sender      = pDomain->userID;
    pWSGSendPkt->header.messageType = OMNET_WSGROUP_SEND_DENY;

    pWSGSendPkt->wsGroupID          = wsGroupID;


    //
    // SFR 7124.  Return the correlator for this catchup.
    //
    pWSGSendPkt->correlator = remoteCorrelator;

    //
    // Queue the message to be sent.
    //
    QueueMessage(pomPrimary->putTask,
                      pDomain,
                      sender,
                      NET_TOP_PRIORITY,
                      NULL,                         // no WSG
                      NULL,                         // no workset
                      NULL,                         // no object
                      (POMNET_PKT_HEADER) pWSGSendPkt,
                      NULL,                         // no object data
                    TRUE);

DC_EXIT_POINT:
    DebugExitVOID(IssueSendDeny);
}


//
//
//
// IssueSendReq(...)
//
//
//

UINT IssueSendReq(POM_PRIMARY      pomPrimary,
                                 POM_DOMAIN     pDomain,
                                 POM_WSGROUP        pWSGroup,
                                 NET_UID            helperNode)
{
    POMNET_WSGROUP_SEND_PKT    pWSGSendPkt;
    UINT rc              = 0;

    DebugEntry(IssueSendReq);

    //
    // We start by allocating some memory for the OMNET_SEND_REQ message:
    //
    pWSGSendPkt = (POMNET_WSGROUP_SEND_PKT)UT_MallocRefCount(sizeof(OMNET_WSGROUP_SEND_PKT), TRUE);
    if (!pWSGSendPkt)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    //
    // Now fill in the fields:
    //
    // SFR 7124.  Generate a correlator so we can match
    // SEND_MIDWAY,SEND_COMPLETE and SEND_DENY messages to this catchup.
    //
    pWSGSendPkt->header.sender      = pDomain->userID;
    pWSGSendPkt->header.messageType = OMNET_WSGROUP_SEND_REQ;

    pWSGSendPkt->wsGroupID          = pWSGroup->wsGroupID;
    pWSGroup->catchupCorrelator = NextCorrelator(pomPrimary);
    pWSGSendPkt->correlator = pWSGroup->catchupCorrelator;

    //
    // The <helperNode> parameter is the node which the calling function
    // has identified as a remote node which is capable of sending us the
    // workset group we want.  So, we send that instance of ObMan an
    // OMNET_WSGROUP_SEND_REQ on its single-user channel, enclosing our own
    // single-user channel ID for the response:
    //
    // Note: the SEND_REQ must not overtake any data on its way from us to
    //       the remote node (e.g.  if we've just added an object,
    //       deregistered and then reregistered).  Therefore, set the
    //       NET_SEND_ALL_PRIORITIES flag.
    //
    // SFR 6117: Don't believe this is a problem for R2.0, so just send at
    //           low priority.
    //
    rc = QueueMessage(pomPrimary->putTask,
                      pDomain,
                      helperNode,
                      NET_LOW_PRIORITY,
                      pWSGroup,
                      NULL,                                   // no workset
                      NULL,                                   // no object
                      (POMNET_PKT_HEADER) pWSGSendPkt,
                      NULL,                              // no object data
                    TRUE);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // Set the workset group state, and record the number of SEND_MIDWAY
    // and SEND_COMPLETE messages we're expecting (one for R11, one per
    // priority for R20).
    //
    // Note: we set the counts up here because we may get some of the
    // SEND_COMPLETEs before we get all the SEND_MIDWAYs, so to set the
    // count in ProcessSendMidway would be too late.
    //
    pWSGroup->state = PENDING_SEND_MIDWAY;

    pWSGroup->sendMidwCount = NET_NUM_PRIORITIES;
    pWSGroup->sendCompCount = NET_NUM_PRIORITIES;

    //
    // Store the helper node ID in the WSG structure.
    //
    pWSGroup->helperNode = helperNode;

DC_EXIT_POINT:

    if (rc != 0)
    {
        //
        // Cleanup:
        //
        ERROR_OUT(( "Error %d requesting send from node 0x%08x "
           "for WSG %d in Domain %u",
           rc, pWSGroup->wsg, helperNode, pDomain->callID));
    }
    else
    {
        //
        // Success:
        //
        TRACE_OUT(("Requested copy of WSG %d' from node 0x%08x (in Domain %u), correlator %hu",
            pWSGroup->wsg, helperNode, pDomain->callID,
                                              pWSGroup->catchupCorrelator));
    }

    DebugExitDWORD(IssueSendReq, rc);
    return(rc);

}



//
// ProcessSendReq(...)
//
void ProcessSendReq
(
    POM_PRIMARY              pomPrimary,
    POM_DOMAIN          pDomain,
    POMNET_WSGROUP_SEND_PKT pSendReqPkt
)
{
    POM_WSGROUP             pWSGroup;
    POM_WORKSET             pWorkset;
    POM_HELPER_CB           pHelperCB;
    NET_UID                 sender;
    BOOL                    sendDeny   = FALSE;

    DebugEntry(ProcessSendReq);

    //
    // This is the user ID of the late joiner:
    //
    sender = pSendReqPkt->header.sender;

    //
    // We start by finding our copy of the workset group:
    //
    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pDomain->wsGroups),
            (void**)&pWSGroup, FIELD_OFFSET(OM_WSGROUP, chain),
            FIELD_OFFSET(OM_WSGROUP, wsGroupID),
            (DWORD)pSendReqPkt->wsGroupID, FIELD_SIZE(OM_WSGROUP, wsGroupID));

    //
    // Quit and deny the send if workset group not found:
    //
    if (pWSGroup == NULL)
    {
        WARNING_OUT(( "Don't have workset group %hu to send to node 0x%08x",
            pSendReqPkt->wsGroupID, sender));

        sendDeny = TRUE;
        DC_QUIT;
    }

    //
    // Quit and deny the send if we don't have ALL the workset group:
    //
    if (pWSGroup->state != WSGROUP_READY)
    {
        WARNING_OUT(("WSG %d is in state %hu - can't send to node 0x%08x",
            pWSGroup->wsg, pWSGroup->state, sender));

        sendDeny = TRUE;
        DC_QUIT;
    }

    TRACE_OUT(( "Processing SEND_REQUEST from node 0x%08x for WSG %d, correlator %hu",
        sender, pWSGroup->wsg, pSendReqPkt->correlator));

    //
    // Right, we're fully registered with the workset group, so we will be
    // its helper node.  First, allocate a helper CB to keep track of the
    // process:
    //
    if (!NewHelperCB(pDomain,
                     pWSGroup,
                     sender,
                     pSendReqPkt->correlator,
                     &pHelperCB))
    {
        //
        // Deny the workset send request
        //
        sendDeny = TRUE;

        WARNING_OUT(( "Failed to allocate helper CB - issuing SEND_DENY"));
        DC_QUIT;
    }

    //
    // Before we can send the contents of the workset group to the late
    // joiner, we must ensure that our view of the contents is up to date.
    // We do this by checkpointing the workset group, which means locking
    // the dummy workset which exists in all workset groups.  Do this now:
    //
    pWorkset = pWSGroup->apWorksets[OM_CHECKPOINT_WORKSET];

    WorksetLockReq(pomPrimary->putTask, pomPrimary,
                    pWSGroup,
                    pWorkset,
                    0,
                    &(pHelperCB->lockCorrelator));

    //
    // We will shortly get a WORKSET_LOCK_CON event containing the
    // correlator just stored in the helper CB.  We will look this up and
    // continue the catch-up process then.
    //

DC_EXIT_POINT:

    //
    // If we set the sendDeny flag above then now send the SEND_DENY
    // message to the late joiner.
    //
    if (sendDeny)
    {
        IssueSendDeny(pomPrimary,
                      pDomain,
                      pSendReqPkt->wsGroupID,
                      sender,
                      pSendReqPkt->correlator);
    }

    DebugExitVOID(ProcessSendReq);
}



//
// SendWSGToLateJoiner(...)
//
void SendWSGToLateJoiner
(
    POM_PRIMARY                 pomPrimary,
    POM_DOMAIN                  pDomain,
    POM_WSGROUP                 pWSGroup,
    NET_UID                     lateJoiner,
    OM_CORRELATOR               remoteCorrelator
)
{
    POM_WORKSET                 pWorkset;
    POMNET_OPERATION_PKT        pPacket;
    POM_OBJECT               pObj;
    POMNET_WSGROUP_SEND_PKT     pSendMidwayPkt;
    POMNET_WSGROUP_SEND_PKT     pSendCompletePkt;
    POM_OBJECTDATA              pData;
    OM_WORKSET_ID               worksetID;
    UINT                        maxSeqUsed =      0;
    NET_PRIORITY                catchupPriority = 0;
    UINT                        rc = 0;

    DebugEntry(SendWSGToLateJoiner);

    //
    // The first thing to do is to announce that the remote node is
    // registering with the workset group:
    //
    rc = RegAnnounceBegin(pomPrimary,
                          pDomain,
                          pWSGroup,
                          lateJoiner,
                          &pObj);
    if (rc != 0)
    {
        DC_QUIT;
    }



    //
    // We then start flow control on the user channel of the node that we
    // are sending the data to.  We only start flow control on the low
    // priority channel and don't bother to restrict the maximum stream
    // size.  If flow control is already started on this stream then this
    // call will have no effect.  Note that flow control will automatically
    // be stopped when the call ends.
    //
    MG_FlowControlStart(pomPrimary->pmgClient,
                              lateJoiner,
                              NET_LOW_PRIORITY,
                              0,
                              8192);

    //
    // Now, cycle through each of the worksets and generate and send
    //
    // - WORKSET_NEW messages for each workset,
    //
    // - a WSG_SEND_MIDWAY message to indicate we've sent all the worksets
    //
    // - OBJECT_ADD messages for each of the objects in each of the
    //   worksets.
    //
    // - a WSG_SEND_COMPLETE message to indicate we've sent all the
    //   objects.
    //
    // NOTE: We do not send CHECKPOINT worksets, so the for loop should
    // stop before it gets 255.
    //
    for (worksetID = 0; worksetID < OM_MAX_WORKSETS_PER_WSGROUP; worksetID++)
    {
        pWorkset = pWSGroup->apWorksets[worksetID];
        if (!pWorkset)
        {
            continue;
        }

        TRACE_OUT(( "Sending WORKSET_CATCHUP for workset %u", worksetID));

        rc = GenerateOpMessage(pWSGroup,
                               worksetID,
                               NULL,                    // no object ID
                               NULL,                    // no object data
                               OMNET_WORKSET_CATCHUP,
                               &pPacket);
        if (rc != 0)
        {
            DC_QUIT;
        }

        rc = QueueMessage(pomPrimary->putTask,
                          pWSGroup->pDomain,
                          lateJoiner,
                          NET_TOP_PRIORITY,
                          pWSGroup,
                          pWorkset,
                          NULL,                         // no object
                          (POMNET_PKT_HEADER) pPacket,
                          NULL,                         // no object data
                        TRUE);
        if (rc != 0)
        {
            DC_QUIT;
        }
    }

    //
    // Now send the SEND_MIDWAY message to indicate that all the
    // WORKSET_NEW messages have been sent:
    //
    pSendMidwayPkt = (POMNET_WSGROUP_SEND_PKT)UT_MallocRefCount(sizeof(OMNET_WSGROUP_SEND_PKT), TRUE);
    if (!pSendMidwayPkt)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    pSendMidwayPkt->header.sender      = pDomain->userID;
    pSendMidwayPkt->header.messageType = OMNET_WSGROUP_SEND_MIDWAY;

    pSendMidwayPkt->wsGroupID   = pWSGroup->wsGroupID;
    pSendMidwayPkt->correlator  = remoteCorrelator;

    //
    // The next field is the ID of the reg object which we added above.
    // So, convert the handle of the reg object returned by RegAnnouncBegin
    // to a pointer to the object record and then copy the object ID into
    // the message packet:
    //
    memcpy(&(pSendMidwayPkt->objectID), &(pObj->objectID), sizeof(OM_OBJECT_ID));

    //
    // The last field, which is the highest object ID sequence number
    // previously used by the late joiner in this workset group, is not yet
    // know; it will be filled in below.  However (see note below), we
    // queue the message now to ensure it doesn't get stuck behind lots of
    // objects:
    //
    TRACE_OUT(("Queueing WSG_SEND_MIDWAY message to node 0x%08x for WSG %d, correlator %hu",
        lateJoiner, pWSGroup->wsg, remoteCorrelator));

    rc = QueueMessage(pomPrimary->putTask,
                      pWSGroup->pDomain,
                      lateJoiner,
                      NET_TOP_PRIORITY | NET_SEND_ALL_PRIORITIES,
                      pWSGroup,
                      NULL,                                   // no workset
                      NULL,                                   // no object
                      (POMNET_PKT_HEADER) pSendMidwayPkt,
                      NULL,                              // no object data
                    TRUE);
    if (rc != 0)
    {
        DC_QUIT;
    }


    //
    // If the workset group is ObMan control then we should send it at top
    // priority to ensure that it can overtake any slower pending sends to
    // other nodes.  Otherwise we send the send the data at the lowest
    // priority.
    //
    if (pWSGroup->wsGroupID == WSGROUPID_OMC)
    {
        catchupPriority = NET_TOP_PRIORITY;
    }
    else
    {
        catchupPriority = NET_LOW_PRIORITY;
    }
    TRACE_OUT(( "Sending catchup data at priority %hu for 0x%08x",
           catchupPriority,
           lateJoiner));


    //
    // Now start the loop which does the OBJECT_ADDs:
    //
    for (worksetID = 0; worksetID < OM_MAX_WORKSETS_PER_WSGROUP; worksetID++)
    {
        pWorkset = pWSGroup->apWorksets[worksetID];
        if (pWorkset == NULL)
        {
            continue;
        }

        TRACE_OUT(( "Sending OBJECT_CATCHUPs for workset %u", worksetID));


        //
        // Note that we must send deleted objects too, since late-joiners
        // have just as much need as we do to detect out of date
        // operations:
        //
        pObj = (POM_OBJECT)COM_BasedListFirst(&(pWorkset->objects), FIELD_OFFSET(OM_OBJECT, chain));
        while (pObj != NULL)
        {
            ValidateObject(pObj);

            //
            // The workset group that the late joiner is catching up with
            // may contain objects which it has added in a previous call
            // (with the same network user ID).  Since that call is over,
            // it may reuse IDs present in this workset group - to prevent
            // this, we must tell it the highest sequence count it used for
            // object IDs for this workset group, so while we're going
            // through the objects, keep a count:
            //
            if (pObj->objectID.creator == lateJoiner)
            {
                maxSeqUsed = max(maxSeqUsed, pObj->objectID.sequence);
            }

            if (pObj->flags & PENDING_DELETE)
            {
                //
                // If the object is pending delete at this node, we do not
                // send the object data.  The way to avoid this is to set
                // pData to NULL (must be done before call to
                // GenerateOpMessage):
                //
                pData = NULL;
            }
            else
            {
                pData = pObj->pData;

                if (pData)
                {
                    ValidateObjectData(pData);
                }
            }

            //
            // Now generate the message packet:
            //
            rc = GenerateOpMessage(pWSGroup,
                                   worksetID,
                                   &(pObj->objectID),
                                   pData,
                                   OMNET_OBJECT_CATCHUP,
                                   &pPacket);
            if (rc != 0)
            {
                DC_QUIT;
            }

            //
            // Now fill in the catchup-specific fields (note that the
            // <seqStamp> will already have been filled in, but with the
            // current sequence stamp for the workset; for a CatchUp
            // message, this should be the add stamp for the object):
            //
            pPacket->position   = pObj->position;
            pPacket->flags      = pObj->flags;
            pPacket->updateSize = pObj->updateSize;

            if (pObj->flags & PENDING_DELETE)
            {
                //
                // If the object is pending delete at this node, we send it
                // as if it has been delete-confirmed (since local
                // delete-confirms or their DC_ABSence should have no effect
                // outside this box).  To do this, we just set the DELETED
                // flag in the packet:
                //
                pPacket->flags &= ~PENDING_DELETE;
                pPacket->flags |= DELETED;
            }

            COPY_SEQ_STAMP(pPacket->seqStamp,      pObj->addStamp);
            COPY_SEQ_STAMP(pPacket->positionStamp, pObj->positionStamp);
            COPY_SEQ_STAMP(pPacket->updateStamp,   pObj->updateStamp);
            COPY_SEQ_STAMP(pPacket->replaceStamp,  pObj->replaceStamp);

            //
            // ...and queue the message:
            //
            rc = QueueMessage(pomPrimary->putTask,
                              pWSGroup->pDomain,
                              lateJoiner,
                              catchupPriority,
                              pWSGroup,
                              pWorkset,
                              NULL,                            // no object
                              (POMNET_PKT_HEADER) pPacket,
                              pData,
                            TRUE);
            if (rc != 0)
            {
                DC_QUIT;
            }

            //
            // Now go around the loop again:
            //
            pObj = (POM_OBJECT)COM_BasedListNext(&(pWorkset->objects), pObj,
                FIELD_OFFSET(OM_OBJECT, chain));
        }
    }

    //
    // Now that we know the max sequence number used by this user ID in
    // this workset group, we can set the field in the SEND_MIDWAY packet:
    //
    // NOTE: because the ObMan task is single threaded (in the DC_ABSence of
    //       assertion failure which cause a sort of multithreading while
    //       the assert box is up) it is safe to alter this value AFTER the
    //       message has been queued because we know that the queue will
    //       not have been serviced yet.
    //
    pSendMidwayPkt->maxObjIDSeqUsed = maxSeqUsed;

    //
    // Now we send the OMNET_SEND_COMPLETE message.  First, allocate some
    // memory...
    //
    pSendCompletePkt = (POMNET_WSGROUP_SEND_PKT)UT_MallocRefCount(sizeof(OMNET_WSGROUP_SEND_PKT), TRUE);
    if (!pSendCompletePkt)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    //
    // ...fill in the fields...
    //
    pSendCompletePkt->header.sender      = pDomain->userID;
    pSendCompletePkt->header.messageType = OMNET_WSGROUP_SEND_COMPLETE;

    pSendCompletePkt->wsGroupID   = pWSGroup->wsGroupID;
    pSendCompletePkt->correlator       = remoteCorrelator;

    //
    // ...and queue the message for sending (it musn't overtake any of the
    // data so send it at all priorities):
    //
    TRACE_OUT(( "Sending WSG_SEND_COMPLETE message, correlator %hu",
                                                          remoteCorrelator));

    rc = QueueMessage(pomPrimary->putTask,
                      pWSGroup->pDomain,
                      lateJoiner,
                      NET_LOW_PRIORITY | NET_SEND_ALL_PRIORITIES,
                      pWSGroup,
                      NULL,                                   // no workset
                      NULL,                                   // no object
                      (POMNET_PKT_HEADER) pSendCompletePkt,
                      NULL,                              // no object data
                    TRUE);
    if (rc != 0)
    {
        DC_QUIT;
    }

    TRACE_OUT(( "Processed send request from node 0x%08x for WSG %d",
       lateJoiner, pWSGroup->wsg));

DC_EXIT_POINT:

    if (rc != 0)
    {
        //
        // An error occurred.  We must issue a SEND_DENY message to the
        // remote node.
        //
        ERROR_OUT(( "Error %d sending WSG %d to node 0x%08x",
                   rc, pWSGroup->wsg, lateJoiner));

        IssueSendDeny(pomPrimary,
                      pDomain,
                      pWSGroup->wsGroupID,
                      lateJoiner,
                      remoteCorrelator);
    }

    DebugExitVOID(SendWSGToLateJoiner);
}




//
// ProcessSendMidway(...)
//
void ProcessSendMidway
(
    POM_PRIMARY             pomPrimary,
    POM_DOMAIN              pDomain,
    POMNET_WSGROUP_SEND_PKT pSendMidwayPkt
)
{
    POM_WORKSET             pOMCWorkset;
    POM_WSGROUP_REG_CB      pRegistrationCB = NULL;
    POM_WSGROUP             pWSGroup;
    BOOL                    fSetPersonData;
    NET_UID                 sender;
    POM_OBJECT           pObjReg;
    UINT                    rc = 0;

    DebugEntry(ProcessSendMidway);

    sender = pSendMidwayPkt->header.sender;

    //
    // OK, this is an message indicating that the helper node has sent us
    // all the WORKSET_CATCHUPs in the workset group we're catching up with
    // (but note that the objects haven't yet been sent).
    //
    // So, search the list of pending registrations using the correlator
    // value in the packet (we can't use the workset group ID since if it
    // is zero i.e.  ObManControl, we'll match on workset groups which
    // haven't yet had their IDs determined (since they are initially
    // zero).
    //
    if (pSendMidwayPkt->wsGroupID == WSGROUPID_OMC)
    {
        //
        // This is a SEND_MIDWAY message for ObManControl.
        //
        pWSGroup = GetOMCWsgroup(pDomain);
        fSetPersonData = FALSE;
    }
    else
    {
        //
        // Not for ObManControl so we search the list of pending
        // registrations.
        //
        pRegistrationCB = (POM_WSGROUP_REG_CB)COM_BasedListFirst(&(pDomain->pendingRegs),
            FIELD_OFFSET(OM_WSGROUP_REG_CB, chain));

        while ((pRegistrationCB != NULL) && (pRegistrationCB->pWSGroup->wsGroupID != pSendMidwayPkt->wsGroupID))
        {
            pRegistrationCB = (POM_WSGROUP_REG_CB)COM_BasedListNext(&(pDomain->pendingRegs),
                pRegistrationCB, FIELD_OFFSET(OM_WSGROUP_REG_CB, chain));
        }

        if (pRegistrationCB == NULL)
        {
            WARNING_OUT(( "Unexpected SEND_MIDWAY for WSG %hu from 0x%08x",
                pSendMidwayPkt->wsGroupID, sender));
            DC_QUIT;
        }

        pWSGroup = pRegistrationCB->pWSGroup;
        fSetPersonData = TRUE;
    }

    if (NULL == pWSGroup)
    {
        TRACE_OUT(( "NULL pWSGroup" ));
        DC_QUIT;
    }

    if (!pWSGroup->valid)
    {
        WARNING_OUT(( "Recd SEND_MIDWAY too late for WSG %d (marked invalid)",
            pWSGroup->wsg));
        DC_QUIT;
    }

    //
    // We should be in the PENDING_SEND_MIDWAY state:
    //
    if (pWSGroup->state != PENDING_SEND_MIDWAY)
    {
        WARNING_OUT(( "Recd SEND_MIDWAY with WSG %d in state %hu",
            pWSGroup->wsg, pWSGroup->state));
        DC_QUIT;
    }

    //
    // SFR 7124.  Check the correlator of this SEND_MIDWAY against the
    // correlator we generated locally when we sent the last SEND_REQUEST.
    // If they dont match, this is part of an out of date catchup which we
    // can ignore.
    //
    if (pSendMidwayPkt->correlator != pWSGroup->catchupCorrelator)
    {
        WARNING_OUT(("Ignoring SEND_MIDWAY with old correlator %hu (expecting %hu)",
            pSendMidwayPkt->correlator, pWSGroup->catchupCorrelator));
        DC_QUIT;
    }

    //
    // We should get four of these messages, one at each priority (except
    // in a backlevel call when we only get one).  Check how many are
    // outstanding:
    //
    pWSGroup->sendMidwCount--;
    if (pWSGroup->sendMidwCount != 0)
    {
        TRACE_OUT(( "Still need %hu SEND_MIDWAY(s) for WSG %d",
            pWSGroup->sendMidwCount, pWSGroup->wsg));
        DC_QUIT;
    }

    TRACE_OUT(( "Last SEND_MIDWAY for WSG %d, ID %hu, from 0x%08x",
        pWSGroup->wsg, pWSGroup->wsGroupID, sender));

    //
    // Set up pointers to the ObManControl workset which holds the reg
    // objects for the workset group we've just registered with:
    //
    pOMCWorkset = GetOMCWorkset(pDomain, pWSGroup->wsGroupID);

    //
    // If we don't have an associated OMC workset, something's wrong...
    //
    if (pOMCWorkset == NULL)
    {
        //
        // ...unless it's ObManControl itself that we're catching up with -
        // since we can get its SEND_MIDWAY before we've got any of the
        // WORKSET_CATCHUPs:
        //
        if (pWSGroup->wsGroupID != WSGROUPID_OMC)
        {
            ERROR_OUT(( "Got SEND_MIDWAY for unknown workset group %hu!",
                pWSGroup->wsGroupID));
        }
        DC_QUIT;
    }

    //
    // Convert the ID of our reg object (as sent by our helper who added it
    // in the first place) to an object handle:
    //
    rc = ObjectIDToPtr(pOMCWorkset, pSendMidwayPkt->objectID, &pObjReg);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // If we haven't yet stored a reg object handle for this workset
    // group...
    //
    if (pWSGroup->pObjReg == NULL)
    {
        //
        // ...store it now...
        //
        pWSGroup->pObjReg = pObjReg;
    }
    //
    // ...but if we have...
    //
    else // pWSGroup->pObjReg != NULL
    {
        //
        // ...and if it's a different one, something's wrong:
        //
        if (pWSGroup->pObjReg != pObjReg)
        {
            WARNING_OUT(( "Recd SEND_MIDWAY from node 0x%08x claiming our reg object "
               "for WSG %d is 0x%08x but we think it's 0x%08x",
               sender, pWSGroup->wsg, pObjReg,pWSGroup->pObjReg));
        }
    }

    //
    // OK, if we've passed all the above tests then everything is normal,
    // so proceed:
    //
    pWSGroup->state = PENDING_SEND_COMPLETE;

    if (pSendMidwayPkt->maxObjIDSeqUsed > pomPrimary->objectIDsequence)
    {
        TRACE_OUT(( "We've already used ID sequence numbers up to %u for "
            "this workset group - setting global sequence count to this value",
            pSendMidwayPkt->objectID.sequence));

        pomPrimary->objectIDsequence = pSendMidwayPkt->objectID.sequence;
    }

    //
    // Our registration object (added by the remote node) should have
    // arrived by now.  We need to add the FE/person data to it (unless
    // this is for ObManControl, in which case there won't be any):
    //
    if (fSetPersonData)
    {
        rc = SetPersonData(pomPrimary, pDomain, pWSGroup);
        if (rc != 0)
        {
            DC_QUIT;
        }
    }

    //
    // Now post the successful REGISTER_CON event back to the Client, if we
    // found a reg CB above:
    //
    if (pRegistrationCB != NULL)
    {
        WSGRegisterResult(pomPrimary, pRegistrationCB, 0);
    }

DC_EXIT_POINT:
    DebugExitVOID(ProcessSendMidway);
}



//
// ProcessSendComplete(...)
//
UINT ProcessSendComplete
(
    POM_PRIMARY             pomPrimary,
    POM_DOMAIN            pDomain,
    POMNET_WSGROUP_SEND_PKT   pSendCompletePkt
)
{
    POM_WSGROUP          pWSGroup;
    NET_UID              sender;
    UINT    rc = 0;

    DebugEntry(ProcessSendComplete);

    //
    // We are now "fully-caught-up" and so are eligible to be helpers
    // ourselves, i.e.  if someone wants to ask us for the workset group,
    // we will be able to send them a copy.
    //
    sender = pSendCompletePkt->header.sender;

    //
    // First, we find the workset group the message relates to:
    //
    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pDomain->wsGroups),
        (void**)&pWSGroup, FIELD_OFFSET(OM_WSGROUP, chain),
        FIELD_OFFSET(OM_WSGROUP, wsGroupID),
        (DWORD)pSendCompletePkt->wsGroupID,
        FIELD_SIZE(OM_WSGROUP, wsGroupID));

    if (pWSGroup == NULL)
    {
        //
        // This will happen just after we have deregistered from a WSGroup
        //
        WARNING_OUT(( "Unexpected SEND_COMPLETE (ID %hu) from node 0x%08x",
            pSendCompletePkt->wsGroupID, sender));
        DC_QUIT;
    }

    if (!pWSGroup->valid)
    {
        //
        // This will happen while we are in the process of deregistering
        // from a workset group.
        //
        WARNING_OUT(( "Recd SEND_COMPLETE too late for WSG %d (marked invalid)",
            pWSGroup->wsg));
        DC_QUIT;
    }

    //
    // Check it has come from the correct node and that we are in an
    // appropriate state to receive it.
    //
    // The correct state is either PENDING_SEND_COMPLETE or
    // PENDING_SEND_MIDWAY (we can receive SEND_COMPLETEs in
    // PENDING_SEND_MIDWAY state because of MCS packet reordering).
    //
    if (pSendCompletePkt->header.sender != pWSGroup->helperNode)
    {
        //
        // This will happen if we get a late SEND_COMPLETE after we have
        // decided to catch up from someone else - don't think this should
        // happen!
        //
        // lonchanc: this actually happened in bug #1554.
        // Changed ERROR_OUT to WARNING_OUT
        WARNING_OUT(( "Got SEND_COMPLETE from 0x%08x for WSG %d but helper is 0x%08x",
            sender, pWSGroup->wsg, pWSGroup->helperNode));
        DC_QUIT;
    }

    if ((pWSGroup->state != PENDING_SEND_MIDWAY)
        &&
        (pWSGroup->state != PENDING_SEND_COMPLETE))
    {
        WARNING_OUT(( "Got SEND_COMPLETE for WSG %d from 0x%08x in bad state %hu",
            pWSGroup->wsg, sender, pWSGroup->state));
        DC_QUIT;
    }

    //
    // SFR 7124.  Check the correlator of this SEND_COMPLETE against the
    // correlator we generated locally when we sent the last SEND_REQUEST.
    // If they dont match, this is part of an out of date catchup which we
    // can ignore.
    //
    if (pSendCompletePkt->correlator != pWSGroup->catchupCorrelator)
    {
        WARNING_OUT((
        "Ignoring SEND_COMPLETE with old correlator %hu (expecting %hu)",
           pSendCompletePkt->correlator, pWSGroup->catchupCorrelator));
        DC_QUIT;
    }

    //
    // We should get four of these messages, one at each priority (except
    // in a backlevel call when we only get one).  Check how many are
    // outstanding:
    //
    pWSGroup->sendCompCount--;
    if (pWSGroup->sendCompCount != 0)
    {
        TRACE_OUT(( "Still need %hu SEND_COMPLETE(s) for WSG %d obj 0x%08x",
                     pWSGroup->sendCompCount, pWSGroup->wsg,
                     pWSGroup->pObjReg));
        DC_QUIT;
    }

    //
    // If so, we announce that we are registered:
    //
    TRACE_OUT(( "Last SEND_COMPLETE for WSG %d, ID %hu, from 0x%08x obj 0x%08x",
                 pWSGroup->wsg, pWSGroup->wsGroupID, sender,
                 pWSGroup->pObjReg));

    rc = RegAnnounceComplete(pomPrimary, pDomain, pWSGroup);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // In addition to the above, if this send-completion message is for the
    // ObManControl workset group we must also set the Domain state:
    //
    if (pSendCompletePkt->wsGroupID == WSGROUPID_OMC)
    {
        //
        // If this message relates to the ObManControl workset group, its
        // arrival signifies that we have completed the Domain attach
        // process, and are now free to continue the processing of the
        // workset group registration attempt which prompted the attach in
        // the first place.
        //
        // The way we "continue" is to set the Domain state to
        // DOMAIN_READY, so that next time the delayed-and-retried
        // OMINT_EVENT_WSGROUP_REGISTER event arrives, it will actually be
        // processed rather than bounced again.
        //
        TRACE_OUT(( "ObManControl fully arrived for Domain %u - inhibiting token",
            pDomain->callID));

        rc = MG_TokenInhibit(pomPrimary->pmgClient,
                              pDomain->tokenID);
        if (rc != 0)
        {
            DC_QUIT;
        }
        pDomain->state = PENDING_TOKEN_INHIBIT;
    }

DC_EXIT_POINT:

    if (rc != 0)
    {
        ERROR_OUT(( "Error %d processing SEND_COMPLETE for WSG %u:%hu",
            rc, pDomain->callID, pSendCompletePkt->wsGroupID));
    }

    DebugExitDWORD(ProcessSendComplete, rc);
    return(rc);

}




//
// RegAnnounceBegin(...)
//

UINT RegAnnounceBegin
(
    POM_PRIMARY             pomPrimary,
    POM_DOMAIN              pDomain,
    POM_WSGROUP             pWSGroup,
    NET_UID                 nodeID,
    POM_OBJECT *         ppObjReg
)
{
    POM_WSGROUP             pOMCWSGroup;
    POM_WORKSET             pOMCWorkset;
    POM_WSGROUP_REG_REC     pRegObject  = NULL;
    OM_OBJECT_ID            regObjectID;
    UINT                    updateSize;
    UINT                    rc     = 0;

    DebugEntry(RegAnnounceBegin);

    //
    // Trace out who this reg object is for:
    //

    if (nodeID == pDomain->userID)
    {
        TRACE_OUT(("Announcing start of our reg with WSG %d in Domain %u",
            pWSGroup->wsg, pDomain->callID));
    }
    else
    {
        TRACE_OUT(( "Announcing start of reg with WSG %d in Domain %u for node 0x%08x",
            pWSGroup->wsg, pDomain->callID, nodeID));
    }

    //
    // To announce the fact that a node has registered with a workset group,
    // we add a registration object to the relevant workset in ObManControl.
    //

    //
    // The "relevant" ObManControl workset is that whose ID is the same as
    // the ID of the workset group.  To add an object to this workset, we
    // will need pointers to the workset itself and to the ObManControl
    // workset group:
    //

    pOMCWSGroup = GetOMCWsgroup(pDomain);

    if( pOMCWSGroup == NULL)
    {
        TRACE_OUT(("pOMCWSGroup not found"));
        DC_QUIT;
    }

    pOMCWorkset = pOMCWSGroup->apWorksets[pWSGroup->wsGroupID];

    //
    // If the ObManControl workset group is not transferred correctly, this
    // assertion may fail:
    //

    ASSERT((pOMCWorkset != NULL));

    //
    // Now, alloc some memory for the registration record object...
    //

    pRegObject = (POM_WSGROUP_REG_REC)UT_MallocRefCount(sizeof(OM_WSGROUP_REG_REC), TRUE);
    if (!pRegObject)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    //
    // ...set its fields...
    //

    pRegObject->length  = sizeof(OM_WSGROUP_REG_REC) -
                            sizeof(OM_MAX_OBJECT_SIZE);    // == 4
    pRegObject->idStamp = OM_WSGREGREC_ID_STAMP;
    pRegObject->userID  = nodeID;
    pRegObject->status  = CATCHING_UP;

    //
    // ...determine the update size, which is meant to be all fields in the
    // REG_REC object except the CPI stuff.  We also subtract the size of
    // the <length> field because of the way object update sizes are
    // defined.
    //

    updateSize = (sizeof(OM_WSGROUP_REG_REC) - sizeof(TSHR_PERSON_DATA))   -
                sizeof(OM_MAX_OBJECT_SIZE);

    //
    // ...and add it to the workset:
    //

    rc = ObjectAdd(pomPrimary->putTask,
                    pomPrimary,
                  pOMCWSGroup,
                  pOMCWorkset,
                  (POM_OBJECTDATA) pRegObject,
                  updateSize,
                  FIRST,
                  &regObjectID,
                  ppObjReg);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // Done!
    //

    TRACE_OUT(( "Added reg object for WSG %d to workset %u in OMC "
      "(handle: 0x%08x, ID: 0x%08x:0x%08x)",
      pWSGroup->wsg, pOMCWorkset->worksetID,
      *ppObjReg, regObjectID.creator, regObjectID.sequence));

DC_EXIT_POINT:

    if (rc != 0)
    {
        ERROR_OUT(( "Error %d adding registration object for WSG %d to "
            "workset %u in ObManControl",
            rc, pWSGroup->wsg, pOMCWorkset->worksetID));
    }

    DebugExitDWORD(RegAnnounceBegin, rc);
    return(rc);

}




//
// RegAnnounceComplete(...)
//
UINT RegAnnounceComplete
(
    POM_PRIMARY             pomPrimary,
    POM_DOMAIN              pDomain,
    POM_WSGROUP             pWSGroup
)
{
    POM_WSGROUP             pOMCWSGroup;
    POM_WORKSET             pOMCWorkset;
    POM_OBJECT              pObjReg;
    POM_WSGROUP_REG_REC     pRegObject;
    POM_WSGROUP_REG_REC     pNewRegObject;
    UINT                    updateSize;
    UINT                    rc = 0;

    DebugEntry(RegAnnounceComplete);

    TRACE_OUT(("Announcing completion of reg for WSG %d", pWSGroup->wsg));

    //
    // Set up pointers to the ObManControl workset group and the workset
    // within it which holds the reg objects for the workset group we've
    // just registered with:
    //
    pOMCWSGroup = GetOMCWsgroup(pDomain);

    if( pOMCWSGroup == NULL)
    {
        TRACE_OUT(("pOMCWSGroup not found"));
        DC_QUIT;
    }

    pOMCWorkset = pOMCWSGroup->apWorksets[pWSGroup->wsGroupID];

    //
    // Set up pointers to the object record and the object data itself:
    //
    pObjReg = pWSGroup->pObjReg;
    ValidateObject(pObjReg);

    if ((pObjReg->flags & DELETED) || !pObjReg->pData)
    {
        ERROR_OUT(("RegAnnounceComplete:  object 0x%08x is deleted or has no data", pObjReg));
        rc = OM_RC_OBJECT_DELETED;
        DC_QUIT;
    }

    pRegObject = (POM_WSGROUP_REG_REC)pObjReg->pData;
    ValidateObjectDataWSGREGREC(pRegObject);

    ASSERT(pRegObject->status == CATCHING_UP);

    //
    // Allocate some memory for the new object with which we are about to
    // replace the old one:
    //

    updateSize = sizeof(OM_WSGROUP_REG_REC) - sizeof(TSHR_PERSON_DATA);

    pNewRegObject = (POM_WSGROUP_REG_REC)UT_MallocRefCount(updateSize, FALSE);
    if (!pNewRegObject)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    //
    // Copy the start of the old object into the new one:
    //

    memcpy(pNewRegObject, pRegObject, updateSize);

    //
    // Update the status field and also set the length field to be the
    // length of the object we just allocated (since this is the number of
    // bytes we are updating):
    //

    pNewRegObject->length       = updateSize - sizeof(OM_MAX_OBJECT_SIZE);
    pNewRegObject->status       = READY_TO_SEND;

    //
    // Issue the update:
    //

    rc = ObjectDRU(pomPrimary->putTask,
                  pOMCWSGroup,
                  pOMCWorkset,
                  pObjReg,
                  (POM_OBJECTDATA) pNewRegObject,
                  OMNET_OBJECT_UPDATE);
    if (rc != 0)
    {
        DC_QUIT;
    }

    TRACE_OUT(( "Updated status in own reg object for WSG %d to READY_TO_SEND",
        pWSGroup->wsg));


    //
    // Set the workset group state, to ensure that the reg/info objects get
    // deleted when we deregister.
    //
    pWSGroup->state = WSGROUP_READY;

DC_EXIT_POINT:

    if (rc != 0)
    {
        ERROR_OUT(( "Error %d updating own reg object for WSG %d",
            rc, pWSGroup->wsg));
    }

    DebugExitDWORD(RegAnnounceComplete, rc);
    return(rc);

}



//
// MaybeRetryCatchUp(...)
//
void MaybeRetryCatchUp
(
    POM_PRIMARY          pomPrimary,
    POM_DOMAIN      pDomain,
    OM_WSGROUP_ID       wsGroupID,
    NET_UID             userID
)
{
    POM_WSGROUP         pWSGroup;
    POM_WSGROUP_REG_CB  pRegistrationCB;

    DebugEntry(MaybeRetryCatchUp);

    //
    // This function is called on receipt of a DETACH indication from MCS
    // or a SEND_DENY message from another node.  We check the workset
    // group identified and see if we were trying to catch up from the
    // departed node.
    //
    // If we do find a match (on the helperNode), then what we do depends
    // on the state of the workset group:
    //
    // - PENDING_SEND_MIDWAY : Retry the registration from the top.
    //
    // - PENDING_SEND_COMPLETE : Just repeat the catchup.
    //

    //
    // Find the workset group:
    //
    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pDomain->wsGroups),
            (void**)&pWSGroup, FIELD_OFFSET(OM_WSGROUP, chain),
            FIELD_OFFSET(OM_WSGROUP, wsGroupID), (DWORD)wsGroupID,
            FIELD_SIZE(OM_WSGROUP, wsGroupID));
    if (pWSGroup == NULL)
    {
        TRACE_OUT(( "No record found for WSG ID %hu", wsGroupID));
        DC_QUIT;
    }

    //
    // Compare the helperNode stored in the workset group and the userID of
    // the node who has either detached or sent us a SEND_DENY message.  If
    // they do not match then we have nothing further to do.
    //
    if (pWSGroup->helperNode != userID)
    {
        DC_QUIT;
    }

    TRACE_OUT(( "Node 0x%08x was our helper node for WSG %d, in state %hu",
        userID, pWSGroup->wsg, pWSGroup->state));

    //
    // We need to retry the registration - check the current state to find
    // out how much we need to do.
    //
    switch (pWSGroup->state)
    {
        case PENDING_SEND_MIDWAY:
        {
            //
            // First check if this is for ObManControl:
            //
            if (pWSGroup->wsGroupID == WSGROUPID_OMC)
            {
                //
                // It is, so we need to retry the domain attach process.
                // We do this by grabbing the ObMan token and resetting the
                // domain state; when the GRAB_CONFIRM event arrives, we
                // will rejoin the domain attach process at the correct
                // point.
                //
                if (MG_TokenGrab(pomPrimary->pmgClient,
                                   pDomain->tokenID) != 0)
                {
                    ERROR_OUT(( "Failed to grab token"));
                    DC_QUIT;
                }

                pDomain->state = PENDING_TOKEN_GRAB;
            }
            else
            {
                //
                // Not ObManControl, so there will be a registration CB -
                // find it...
                //
                COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pDomain->pendingRegs),
                    (void**)&pRegistrationCB, FIELD_OFFSET(OM_WSGROUP_REG_CB, chain),
                    FIELD_OFFSET(OM_WSGROUP_REG_CB, pWSGroup),
                    (DWORD_PTR)pWSGroup, FIELD_SIZE(OM_WSGROUP_REG_CB, pWSGroup));

                if (pRegistrationCB == NULL)
                {
                    ERROR_OUT(( "No reg CB found for WSG %d in state %hu!",
                        pWSGroup->wsg, PENDING_SEND_MIDWAY));
                    DC_QUIT;
                }

                //
                // ...and retry the registation:
                //
                WSGRegisterRetry(pomPrimary, pRegistrationCB);
            }
        }
        break;

        case PENDING_SEND_COMPLETE:
        {
            //
            // Retry the object catchup.  There is no point in trying to
            // find the registration CB as it will have been disposed of as
            // soon as we entered the PENDING_SEND_COMPLETE state.
            //
            if (WSGCatchUp(pomPrimary, pDomain, pWSGroup) != 0)

            //
            // If there are no nodes ready to provide us with the catchup
            // information then we are in a state where everyone either
            // does not have the workset group or is catching up the
            // workset group.
            //

            // MD 21/11/95
            //
            // For now pretend that all is well (it's not!) and go into the
            // READY_TO_SEND state - potentially causing ObMan to become
            // inconsistent.

            {
                RegAnnounceComplete(pomPrimary, pDomain, pWSGroup);
            }
        }
        break;
    }

DC_EXIT_POINT:
    DebugExitVOID(MaybeRetryCatchUp);
}


//
//
//
// WSGRegisterRetry(...)
//
//
//

void WSGRegisterRetry(POM_PRIMARY       pomPrimary,
                                   POM_WSGROUP_REG_CB  pRegistrationCB)
{
    POM_DOMAIN      pDomain;
    POM_WSGROUP     pWSGroup;
    UINT            rc        = 0;

    DebugEntry(WSGRegisterRetry);

    //
    // Set up pointers
    //
    pWSGroup   = pRegistrationCB->pWSGroup;
    pDomain = pRegistrationCB->pDomain;

    //
    // If we've got ObManControl locked for THIS registration, unlock it:
    //
    MaybeUnlockObManControl(pomPrimary, pRegistrationCB);

    //
    // If we have joined a channel (so the channelID is non-zero) then
    // leave it.
    //
    if (pWSGroup->channelID != 0)
    {
        TRACE_OUT(( "Leaving channel %hu", pWSGroup->channelID));

        MG_ChannelLeave(pomPrimary->pmgClient,
                         pWSGroup->channelID);

        PurgeReceiveCBs(pRegistrationCB->pDomain,
                        pWSGroup->channelID);

        //
        // Set the channelID to zero now that we have left it.
        //
        pWSGroup->channelID = 0;
    }

    //
    // Set the workset group state to INITIAL.
    //
    pWSGroup->state = INITIAL;

    //
    // We examine the retry count.  If it's zero, we call WSGRegisterResult
    // to indicate failure.  Otherwise, we repost the event with a delay
    // and a decremented retry value.
    //
    if (pRegistrationCB->retryCount == 0)
    {
        WARNING_OUT(( "Aborting registration for WSG %d",
            pRegistrationCB->wsg));

        WSGRegisterResult(pomPrimary, pRegistrationCB, OM_RC_TIMED_OUT);
    }
    else
    {
        //
        // Since we're about to post a message referencing the Reg CB, bump
        // the use count:
        //
        UT_BumpUpRefCount(pRegistrationCB);

        TRACE_OUT(( "Retrying %d for WSG %d; retries left: %u",
            pRegistrationCB->type,
            pRegistrationCB->wsg,
            pRegistrationCB->retryCount));

        pRegistrationCB->retryCount--;

        UT_PostEvent(pomPrimary->putTask,
                     pomPrimary->putTask,
                     OM_REGISTER_RETRY_DELAY_DFLT,
                     OMINT_EVENT_WSGROUP_REGISTER_CONT,
                     0,
                     (UINT_PTR) pRegistrationCB);
    }

    DebugExitVOID(WSGRegisterRetry);
}


//
//
//
// WSGRegisterResult(...)
//
//
//

void WSGRegisterResult(POM_PRIMARY        pomPrimary,
                                    POM_WSGROUP_REG_CB   pRegistrationCB,
                                    UINT             result)
{
    POM_WSGROUP       pWSGroup;
    POM_DOMAIN    pDomain;
    POM_WORKSET      pOMCWorkset;
    OM_EVENT_DATA16   eventData16;
    OM_EVENT_DATA32   eventData32;
    UINT          type;
    UINT           event       = 0;

    DebugEntry(WSGRegisterResult);

    //
    // Assert that this is a valid registration CB (which it DC_ABSolutely
    // MUST be, since this function gets called synchronously by some other
    // function which should have validated the CB):
    //
    ASSERT(pRegistrationCB->valid);

    //
    // If we've still got ObManControl locked for THIS registration, unlock
    // it:
    //
    MaybeUnlockObManControl(pomPrimary, pRegistrationCB);

    //
    // Determine whether we're doing a REGISTER or a MOVE (we use the
    // string values for tracing):
    //
    type    = pRegistrationCB->type;

    switch (type)
    {
        case WSGROUP_REGISTER:
           event = OM_WSGROUP_REGISTER_CON;
           break;

        case WSGROUP_MOVE:
           event = OM_WSGROUP_MOVE_CON;
           break;

        default:
           ERROR_OUT(("Reached default case in switch statement (value: %hu)", event));
    }

    //
    // Here, we set up pointer to workset group.
    //
    // NOTE: This field in the structure might be NULL, if we have had to
    //       abort the registration very early.  Therefore, do not use
    //       pWSGroup without checking it first!!!
    //
    pWSGroup = pRegistrationCB->pWSGroup;
    if (pWSGroup)
    {
        ValidateWSGroup(pWSGroup);
    }

    //
    // Trace if this registration has failed:
    //
    if (result != 0)
    {
        //
        // pWSGroup might be NULL if we aborted the registration before we
        // got around to creating it in ProcessWSGRegister (pre-Stage1).
        // So, do a quick check and use a -1 value for the state if it's
        // NULL.  In either case pick up the name from the reg CB:
        //
        WARNING_OUT(( "%d failed for WSG %d (reason: 0x%08x, WSG state: %u)",
           type, pRegistrationCB->wsg, result,
           pWSGroup == NULL ? -1 : (UINT)pWSGroup->state));

        //
        // If a MOVE fails, then the workset group continues to exist in
        // the old domain - so set the state back to WSGROUP_READY:
        //
        if ((type == WSGROUP_MOVE) && (pWSGroup != NULL))
        {
            pWSGroup->state = WSGROUP_READY;
        }
    }
    else
    {
        //
        // If the registration succeeded, pWSGroup must be OK:
        //
        ASSERT((pWSGroup != NULL));

        ASSERT(((pWSGroup->state == WSGROUP_READY) ||
                 (pWSGroup->state == PENDING_SEND_COMPLETE)));

        TRACE_OUT(( "%d succeeded for WSG %d (now in state %hu)",
           type, pRegistrationCB->wsg, pWSGroup->state));
    }

    //
    // Fill in the event parameters and post the result to the Client:
    //
    eventData16.hWSGroup    = pRegistrationCB->hWSGroup;
    eventData16.worksetID   = 0;
    eventData32.correlator  = pRegistrationCB->correlator;
    eventData32.result      = (WORD)result;

    UT_PostEvent(pomPrimary->putTask,
                 pRegistrationCB->putTask,
                 0,
                 event,
                 *(PUINT) &eventData16,
                 *(LPUINT) &eventData32);

    //
    // If the operation was successful, we also post some more events:
    //
    if (result == 0)
    {
        if (type == WSGROUP_REGISTER)
        {
            //
            // If this is a REGISTER, we post WORKSET_NEW events to the
            // Client for all existing worksets:
            //
            PostWorksetNewEvents(pomPrimary->putTask,
                                 pRegistrationCB->putTask,
                                 pWSGroup,
                                 pRegistrationCB->hWSGroup);

            //
            // We also need to generate PERSON_JOINED events - these are
            // generated automatically by the ObMan task on receipt of the
            // respective OBJECT_ADD events, but only once the registration
            // has completed.  So, fake ADD events for any objects that may
            // exist already:
            //
            pDomain = pWSGroup->pDomain;
            pOMCWorkset = GetOMCWorkset(pDomain, pWSGroup->wsGroupID);

            PostAddEvents(pomPrimary->putTask,
                          pOMCWorkset,
                          pDomain->omchWSGroup,
                          pomPrimary->putTask);
        }
    }

    //
    // If we mananged to bump up the use counts of the Domain record and
    // workset group, free them now:
    //
    if (pRegistrationCB->flags & BUMPED_CBS)
    {
        ASSERT((pWSGroup != NULL));

        UT_FreeRefCount((void**)&(pRegistrationCB->pWSGroup), FALSE);

        UT_FreeRefCount((void**)&(pRegistrationCB->pDomain), FALSE);
    }

    //
    // Dispose of the registration CB - it has served us well!
    //
    pRegistrationCB->valid = FALSE;

    TRACE_OUT(( "Finished %d attempt for WSG %d: result = 0x%08x",
       type, pRegistrationCB->wsg, result));

    COM_BasedListRemove(&(pRegistrationCB->chain));
    UT_FreeRefCount((void**)&pRegistrationCB, FALSE);

    DebugExitVOID(WSGRegisterResult);
}




//
// WSGMove(...)
//
UINT WSGMove
(
    POM_PRIMARY         pomPrimary,
    POM_DOMAIN          pDestDomainRec,
    POM_WSGROUP         pWSGroup
)
{
    UINT                rc = 0;

    DebugEntry(WSGMove);

    //
    // Now move the record into the new Domain record (this also removes
    // the workset group and its reg object from the old Domain)
    //
    WSGRecordMove(pomPrimary, pDestDomainRec, pWSGroup);

    //
    // There is a problem with the way we deal with moving workset groups
    // into the local Domain at call-end: if there is already a workset
    // group of the same name/FP in the local Domain, we get a name clash,
    // which the rest of the ObMan code does not expect.  This can cause
    // ObMan to get very confused when the workset group is eventually
    // discarded from the local Domain, since it tries to throw away the
    // wrong WSG_INFO object from workset #0 in ObManControl in the local
    // Domain.
    //
    // In R1.1, this name clash will only ever happen with the ObManControl
    // workset group itself, because of the way the apps use workset groups
    // (i.e.  they never register with one in a call AND one in the local
    // Domain simultaneously).  Therefore, we make our lives easier by NOT
    // fully moving the ObManControl workset group into the local Domain at
    // call end.
    //
    // Note however that it is OK (required, in fact) to move the workset
    // group record into the list for the local Domain - the problem arises
    // when we try to set it up in the local ObManControl (which we need to
    // do for application workset groups so that they can continue to use
    // person data objects etc.)
    //
    // So, if the workset group name matches ObManControl, skip the rest of
    // this function:
    //
    if (pWSGroup->wsg == OMWSG_OM)
    {
        TRACE_OUT(("Not registering ObManControl in Domain %u (to avoid clash)",
            pDestDomainRec->callID));
        DC_QUIT;
    }

    //
    // Reset the channel ID to zero:
    //
    pWSGroup->channelID = 0;

    //
    // Assign a new ID for this workset group:
    //
    rc = WSGGetNewID(pomPrimary, pDestDomainRec, &(pWSGroup->wsGroupID));
    if (rc != 0)
    {
        DC_QUIT;
    }

    TRACE_OUT(( "Workset group ID for WSG %d in Domain %u is %hu",
       pWSGroup->wsg, pDestDomainRec->callID, pWSGroup->wsGroupID));

    //
    // Now call CreateAnnounce to add a WSG_INFO object to workset #0 in
    // ObManControl.  There may be a name clash, but we don't mind in this
    // case because we've been forced to do the move because of a call end:
    //
    rc = CreateAnnounce(pomPrimary, pDestDomainRec, pWSGroup);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // Now add the reg object:
    //
    rc = RegAnnounceBegin(pomPrimary,
                          pDestDomainRec,
                          pWSGroup,
                          pDestDomainRec->userID,
                          &(pWSGroup->pObjReg));
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // Add the FE data back in:
    //
    rc = SetPersonData(pomPrimary, pDestDomainRec, pWSGroup);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // And update the object, just as if we were registering with it:
    //
    rc = RegAnnounceComplete(pomPrimary, pDestDomainRec, pWSGroup);
    if (rc != 0)
    {
        DC_QUIT;
    }

DC_EXIT_POINT:

    if (rc != 0)
    {
        ERROR_OUT(( "Error %d moving WSG %d into Domain %u",
            rc, pWSGroup->wsg, pDestDomainRec->callID));
    }

    DebugExitDWORD(WSGMove, rc);
    return(rc);

}



//
// WSGRecordMove(...)
//
void WSGRecordMove
(
    POM_PRIMARY         pomPrimary,
    POM_DOMAIN          pDestDomainRec,
    POM_WSGROUP         pWSGroup
)
{
    POM_DOMAIN          pOldDomainRec;

    DebugEntry(WSGRecordMove);

    //
    // Find the record for the Domain the workset group is currently in:
    //

    pOldDomainRec = pWSGroup->pDomain;
    ASSERT(pOldDomainRec->valid);

    DeregisterLocalClient(pomPrimary, &pOldDomainRec, pWSGroup, FALSE);

    //
    // Insert it into the destination Domain:
    //

    TRACE_OUT(("Inserting WSG %d' into list for Domain %u",
        pWSGroup->wsg, pDestDomainRec->callID));

    COM_BasedListInsertBefore(&(pDestDomainRec->wsGroups),
                        &(pWSGroup->chain));

    //
    // SFR : reset the pending data ack byte counts:
    //
    WSGResetBytesUnacked(pWSGroup);

    //
    // The workset group now belongs to this new Domain, so set it so.
    //
    pWSGroup->pDomain = pDestDomainRec;

    //
    // Finally, post the MOVE_IND event to all Clients registered with the
    // workset group:
    //

    WSGroupEventPost(pomPrimary->putTask,
                    pWSGroup,
                    PRIMARY | SECONDARY,
                    OM_WSGROUP_MOVE_IND,
                    0,                                        // no workset
                    pDestDomainRec->callID);

    DebugExitVOID(WSGRecordMove);
}




//
// WSGResetBytesUnacked(...)
//
void WSGResetBytesUnacked
(
    POM_WSGROUP     pWSGroup
)
{
    OM_WORKSET_ID   worksetID;
    POM_WORKSET     pWorkset;

    DebugEntry(WSGResetBytesUnacked);

    //
    // Reset workset group's unacked byte count:
    //
    pWSGroup->bytesUnacked = 0;

    //
    // Now do it for each workset in the workset group:
    //
    for (worksetID = 0;
         worksetID < OM_MAX_WORKSETS_PER_WSGROUP;
         worksetID++)
    {
        pWorkset = pWSGroup->apWorksets[worksetID];
        if (pWorkset != NULL)
        {
            pWorkset->bytesUnacked = 0;
        }
    }

    DebugExitVOID(WSGResetBytesUnacked);
}


//
//
//
// ProcessWSGDiscard(...)
//
//
//

void ProcessWSGDiscard
(
    POM_PRIMARY     pomPrimary,
    POM_WSGROUP     pWSGroup
)
{
    POM_DOMAIN      pDomain;

    DebugEntry(ProcessWSGDiscard);

    ASSERT(!pWSGroup->valid);

    //
    // Now get pointer to Domain record:
    //

    pDomain = pWSGroup->pDomain;

    //
    // If the TO_BE_DISCARDED flag has been cleared since the DISCARD event
    // was posted, we abort the discard process (this will happen when
    // someone local has registered with the workset since it was marked
    // TO_BE_DISCARDED).
    //

    if (!pWSGroup->toBeDiscarded)
    {
      WARNING_OUT(( "Throwing away DISCARD event since WSG %d no longer TO_BE_DISCARDED",
        pWSGroup->wsg));
      DC_QUIT;
    }

    //
    // Otherwise, we can go ahead and discard it:
    //

    WSGDiscard(pomPrimary, pDomain, pWSGroup, FALSE);

DC_EXIT_POINT:
    DebugExitVOID(ProcessWSGDiscard);
}



//
// WSGDiscard(...)
//
void WSGDiscard
(
    POM_PRIMARY         pomPrimary,
    POM_DOMAIN          pDomain,
    POM_WSGROUP         pWSGroup,
    BOOL                fExit
)
{
    POM_WORKSET         pWorkset;
    OM_WORKSET_ID       worksetID;

    DebugEntry(WSGDiscard);

    TRACE_OUT(( "Discarding WSG %d from Domain %u",
        pWSGroup->wsg, pDomain->callID));

    //
    // We only ever discard a workset group when nobody's registered with
    // it, so check:
    //
    ASSERT(COM_BasedListFirst(&(pWSGroup->clients), FIELD_OFFSET(OM_CLIENT_LIST, chain)) == NULL);

    //
    // "Discarding" a workset group involves
    //
    // - calling DeregisterLocalClient to remove our person object, leave
    //   the channel, remove the workset group from our domain list etc.
    //
    // - discarding each of the worksets in the workset group
    //
    // - freeing the workset group record (which will have been removed
    //   from the list hung off the Domain record by
    //   DeregisterLocalClient).
    //
    DeregisterLocalClient(pomPrimary, &pDomain, pWSGroup, fExit);

    //
    // Now discard each workset in use:
    //
    for (worksetID = 0;
         worksetID < OM_MAX_WORKSETS_PER_WSGROUP;
         worksetID++)
    {
        pWorkset = pWSGroup->apWorksets[worksetID];
        if (pWorkset != NULL)
        {
            WorksetDiscard(pWSGroup, &pWorkset, fExit);
        }
    }

    //
    // Discard the checkpointing dummy workset:
    //
    pWorkset = pWSGroup->apWorksets[OM_CHECKPOINT_WORKSET];
    ASSERT((pWorkset != NULL));

    WorksetDiscard(pWSGroup, &pWorkset, fExit);

    //
    // Free the workset group record (it will have been removed from the
    // domain's list by DeregisterLocalClient, above):
    //
    UT_FreeRefCount((void**)&pWSGroup, FALSE);

    DebugExitVOID(WSGDiscard);
}



//
// DeregisterLocalClient(...)
//
void DeregisterLocalClient
(
    POM_PRIMARY     pomPrimary,
    POM_DOMAIN*     ppDomain,
    POM_WSGROUP     pWSGroup,
    BOOL            fExit
)
{
    POM_DOMAIN      pDomain;
    UINT            callID;

    DebugEntry(DeregisterLocalClient);

    pDomain = *ppDomain;
    callID    = pDomain->callID;

    TRACE_OUT(("Removing WSG %d from Domain %u - state is currently %hu",
        pWSGroup->wsg, callID, pWSGroup->state));

    //
    // Removing a workset group from a Domain involves
    //
    // - deleting the registration object from the relevant registration
    //   workset in ObManControl, if we put one there earlier
    //
    // - calling WSGDiscard if there is no one left in the Domain who
    //   is registered with the workset group
    //
    // - leaving the relevant channel
    //
    // - removing the workset group from the list hung off the Domain
    //   record
    //
    // We will skip some of these unwinding stages, depending on how far we
    // got in the registration process.  We use a switch statement with NO
    // BREAKS to determine our "entry point" into the unwinding.
    //
    // When we've done all that, we check to see if we are now no longer
    // registered with any workset groups in this Domain.  If not, we
    // detach from the Domain.
    //
    switch (pWSGroup->state)
    {
        case WSGROUP_READY:
        case PENDING_SEND_COMPLETE:
        case PENDING_SEND_MIDWAY:
        {
            //
            // SFR 5913: Purge any outstanding lock requests for the
            //           workset group.
            //
            PurgeLockRequests(pDomain, pWSGroup);

            //
            // Search for and remove our person object, if we have one:
            //
            RemovePersonObject(pomPrimary,
                               pDomain,
                               pWSGroup->wsGroupID,
                               pDomain->userID);

            pWSGroup->pObjReg = NULL;

            //
            // If we joined a channel for this workset group, leave it:
            //
            if (pWSGroup->channelID != 0)
            {
                TRACE_OUT(( "Leaving channel %hu", pWSGroup->channelID));

                if (!fExit)
                {
                    MG_ChannelLeave(pomPrimary->pmgClient, pWSGroup->channelID);
                }

                //
                // Purge any outstanding receives on this channel:
                //
                PurgeReceiveCBs(pDomain, pWSGroup->channelID);
            }
        }
        // NO BREAK - fall through to next case

        case PENDING_JOIN:
        case LOCKING_OMC:
        case INITIAL:
        {
            //
            // If we didn't get as far as PENDING_SEND_MIDWAY then there's
            // very little unwinding to do.  This bit removes the workset
            // group from the Domain's list:
            //
            TRACE_OUT(( "Removing workset group record from list"));

            COM_BasedListRemove(&(pWSGroup->chain));

            //
            // We set the channel ID to zero here because even if we never
            // succeeded in joining the channel, the field will contain the
            // channel CORRELATOR returned to us by MG_ChannelJoin
            //
            pWSGroup->channelID    = 0;

            //
            // Since the workset group is no longer associated with any
            // Domain, NULL it out.
            //
            pWSGroup->pDomain = NULL;
        }
        break;

        default:
        {
            ERROR_OUT(( "Default case in switch (value: %hu)",
                pWSGroup->state));
        }
    }

    //
    // If this was the last workset group in the domain...
    //
    if (COM_BasedListIsEmpty(&(pDomain->wsGroups)))
    {
        //
        // ...we should detach:
        //
        // Note: this will only happen when the workset group we have just
        //       removed is the ObManControl workset group, so assert:
        //
        if (!fExit)
        {
            ASSERT(pWSGroup->wsg == OMWSG_OM);
        }

        //
        // Since ObMan no longer needs this workset group, we remove it
        // from the list of registered Clients:
        //
        RemoveClientFromWSGList(pomPrimary->putTask,
                                pomPrimary->putTask,
                                pWSGroup);

        TRACE_OUT(( "No longer using any wsGroups in domain %u - detaching",
            callID));

        //
        // This will NULL the caller's pointer:
        //
        DomainDetach(pomPrimary, ppDomain, fExit);
    }

    DebugExitVOID(DeregisterLocalClient);
}



//
// WorksetDiscard(...)
//
void WorksetDiscard
(
    POM_WSGROUP     pWSGroup,
    POM_WORKSET *   ppWorkset,
    BOOL            fExit
)
{
    POM_OBJECT      pObj;
    POM_OBJECT      pObjTemp;
    POM_WORKSET     pWorkset;
    POM_CLIENT_LIST pClient;

    DebugEntry(WorksetDiscard);

    //
    // Set up local pointer:
    //
    pWorkset = *ppWorkset;

    //
    // The code here is similar to that in WorksetDoClear, but in this case
    // we discard ALL objects, irrespective of the sequence stamps.
    //
    // In addition, WorksetDoClear doesn't cause the object records to be
    // freed - it only marks them as deleted - whereas we actually free them
    // up.
    //
    TRACE_OUT(( "Discarding all objects in workset %u in WSG %d",
        pWorkset->worksetID, pWSGroup->wsg));

    CheckObjectCount(pWSGroup, pWorkset);

    pObj = (POM_OBJECT)COM_BasedListFirst(&(pWorkset->objects), FIELD_OFFSET(OM_OBJECT, chain));
    while (pObj != NULL)
    {
        ValidateObject(pObj);

        pObjTemp = (POM_OBJECT)COM_BasedListNext(&(pWorkset->objects), pObj,
            FIELD_OFFSET(OM_OBJECT, chain));

        //
        // If the object (data) hasn't yet been deleted, do it now:
        //
        if (!(pObj->flags & DELETED))
        {
            if (!pObj->pData)
            {
                ERROR_OUT(("WorksetDiscard:  object 0x%08x has no data", pObj));
            }
            else
            {
                ValidateObjectData(pObj->pData);
                UT_FreeRefCount((void**)&pObj->pData, FALSE);
            }

            pWorkset->numObjects--;
        }

        //
        // Now remove the object record itself from the list and free it:
        //
        TRACE_OUT(( "Freeing pObj at 0x%08x", pObj));

        // NULL this out to catch stale references
        COM_BasedListRemove(&(pObj->chain));
        UT_FreeRefCount((void**)&pObj, FALSE);

        pObj = pObjTemp;
    }

    CheckObjectCount(pWSGroup, pWorkset);

    ASSERT(pWorkset->numObjects == 0);

    //
    // Mark the slot in workset offset array (hung off the workset group
    // record) as empty:
    //
    pWSGroup->apWorksets[pWorkset->worksetID] = NULL;

    //
    // Free the clients
    //
    while (pClient = (POM_CLIENT_LIST)COM_BasedListFirst(&(pWorkset->clients),
        FIELD_OFFSET(OM_CLIENT_LIST, chain)))
    {
        TRACE_OUT(("WorksetDiscard:  Freeing client 0x%08x workset 0x%08x",
                pClient, pWorkset));

        COM_BasedListRemove(&(pClient->chain));
        UT_FreeRefCount((void**)&pClient, FALSE);
    }

    //
    // Now discard the chunk holding the workset, setting the caller's
    // pointer to NULL:
    //
    TRACE_OUT(( "Discarded workset %u in WSG %d",
        pWorkset->worksetID, pWSGroup->wsg));

    UT_FreeRefCount((void**)ppWorkset, FALSE);

    DebugExitVOID(WorksetDiscard);
}



//
// ProcessOMCObjectEvents(...)
//
void ProcessOMCObjectEvents
(
    POM_PRIMARY         pomPrimary,
    UINT                event,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID,
    POM_OBJECT          pObj
)
{
    POM_DOMAIN          pDomain;
    POM_WSGROUP         pOMCWSGroup;
    POM_WORKSET         pOMCWorkset;
    POM_WSGROUP         pWSGroup;
    POM_OBJECT          pObjOld;
    POM_WSGROUP_REG_REC pPersonObject;

    DebugEntry(ProcessOMCObjectEvents);

    //
    // In this function, we do the following:
    //
    // - find the domain and workset group this event belongs to
    //
    // - if we have a local client to whom we might be interested in
    //   posting a person data event, call GeneratePersonEvents
    //
    // - if this is an object add for a person data object which has our
    //   user ID in it, store the handle in the workset group record unless
    //   we're not expecting the person object, in which case delete it
    //
    // - if this is an object deleted indication for a person data object
    //   then we count the number of remaining person objects for the
    //   workset group. If it is zero then we remove the info object.
    //

    //
    // To find the domain, we search the list of active domains, looking up
    // the hWSGroup parameter against the omchWSGroup field:
    //
    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pomPrimary->domains),
            (void**)&pDomain, FIELD_OFFSET(OM_DOMAIN, chain),
            FIELD_OFFSET(OM_DOMAIN, omchWSGroup), (DWORD)hWSGroup,
            FIELD_SIZE(OM_DOMAIN, omchWSGroup));
    if (pDomain == NULL)
    {
        //
        // This should only happen at call end time.
        //
        TRACE_OUT(( "No domain with omchWSGroup %u - has call just ended?", hWSGroup));
        DC_QUIT;
    }

    //
    // To find the workset group, we use the fact that the ID of the
    // control workset (for which we have just received the event) is the
    // same as the ID of the workset group to which it relates.  So, do a
    // lookup on this ID:
    //
    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pDomain->wsGroups),
        (void**)&pWSGroup, FIELD_OFFSET(OM_WSGROUP, chain),
        FIELD_OFFSET(OM_WSGROUP, wsGroupID), (DWORD)worksetID,
        FIELD_SIZE(OM_WSGROUP, wsGroupID));

    //
    // SFR 5593: Changed comparison to PENDING_SEND_MIDWAY from
    // WSGROUP_READY to ensure that late joiners get the person add events.
    //
    if ((pWSGroup != NULL) && (pWSGroup->state > PENDING_SEND_MIDWAY))
    {
        //
        // This means that a local client has fully registered with the
        // workset group, so we're in a position maybe translate the event
        // to a person event:
        //
        TRACE_OUT(( "Recd event 0x%08x for person object 0x%08x (for WSG %d in state %hu)",
            event, pObj, pWSGroup->wsg, pWSGroup->state));
        GeneratePersonEvents(pomPrimary, event, pWSGroup, pObj);
    }

    //
    // Now, if this event is an ADD event for an object which
    //
    // - has not been deleted
    // - is a person object (i.e.  has an OM_WSGREGREC_ID_STAMP stamp)
    // - contains our user ID (i.e.  is _our_ person object)
    //
    // then we do one of the following:
    //
    // - if the workset group exists get a handle to the old person object
    //   and delete it. Then store the handle of the new person object in
    //   the workset group record.
    // - if the workset group does not exist then delete the person object.
    //
    // This fixes SFRs 2745 and 2592 which are caused by person objects
    // getting left hanging around in some start/stop race scenarios.
    //
    ValidateObject(pObj);

    if ((event == OM_OBJECT_ADD_IND) && !(pObj->flags & DELETED))
    {
        pPersonObject = (POM_WSGROUP_REG_REC)pObj->pData;

        if (!pPersonObject)
        {
            ERROR_OUT(("ProcessOMCObjectEvents:  object 0x%08x has no data", pObj));
        }

        if (pPersonObject &&
            (pPersonObject->idStamp == OM_WSGREGREC_ID_STAMP) &&
            (pPersonObject->userID  == pDomain->userID))
        {
            ValidateObjectData(pObj->pData);

            pOMCWSGroup = GetOMCWsgroup(pDomain);
            if (pOMCWSGroup == NULL)
            {
                // lonchanc: ingore left-over events due to race condition
                DC_QUIT;
            }

            pOMCWorkset = pOMCWSGroup->apWorksets[worksetID];

            if (pWSGroup != NULL)
            {
                if ((pWSGroup->pObjReg != NULL) &&
                    (pWSGroup->pObjReg != pObj))
                {
                    //
                    // This object replaces an earlier one we had, so...
                    //
                    WARNING_OUT(( "Deleting old person object 0x%08x for WSG %d, "
                                "since person object 0x%08x has just arrived",
                                pWSGroup->pObjReg,
                                pWSGroup->wsg,
                                pObj));

                    //
                    // ...set up a pointer to the _old_ object record...
                    //
                    pObjOld = pWSGroup->pObjReg;

                    //
                    // ...and delete it:
                    //
                    ObjectDRU(pomPrimary->putTask,
                                   pOMCWSGroup,
                                   pOMCWorkset,
                                   pObjOld,
                                   NULL,
                                   OMNET_OBJECT_DELETE);
                }

                pWSGroup->pObjReg = pObj;
            }
            else
            {
                //
                // We've deregistered from the workset group - delete the
                // object:
                //
                TRACE_OUT(( "Deleting reg object 0x%08x since WSG ID %hu not found",
                    pObj, worksetID));

                ObjectDRU(pomPrimary->putTask,
                               pOMCWSGroup,
                               pOMCWorkset,
                               pObj,
                               NULL,
                               OMNET_OBJECT_DELETE);
            }
        }
        else
        {
            //
            // Not our person object - do nothing.
            //
        }

        //
        // Finished so quit out.
        //
        DC_QUIT;
    }

    //
    // Now, if this event is a DELETED event then we check to see if anyone
    // is still using the workset group.  If not then we remove the info
    // object.
    //
    if (event == OM_OBJECT_DELETED_IND)
    {
        //
        // We need to check the number of person objects left in this
        // ObMan control workset if it is not workset zero.  If there are
        // no person objects left then remove any orphaned INFO objects.
        //
        pOMCWSGroup = GetOMCWsgroup(pDomain);
        if (pOMCWSGroup == NULL)
        {
            // lonchanc: ingore left-over events due to race condition
            DC_QUIT;
        }

        pOMCWorkset = pOMCWSGroup->apWorksets[worksetID];
        if (pOMCWorkset == NULL)
        {
            // lonchanc: ingore left-over events due to race condition
            DC_QUIT;
        }

        if ((pOMCWorkset->numObjects == 0) &&
            (worksetID != 0))
        {
            TRACE_OUT(( "Workset %hu has no person objects - deleting INFO object",
                   worksetID));

            RemoveInfoObject(pomPrimary, pDomain, worksetID);
        }

        //
        // A person object has been removed and as we are potentially in
        // the middle of a workset group catchup from this person we may
        // need to retry the catchup.
        //
        // We search through all the workset groups looking for WSGs that
        // are in the PENDING_SEND_MIDWAY or PENDING_SEND_COMPLETE state
        // (i.e.  in catchup state).  If they are we then search to ensure
        // that the person object for them still exists.  If it doesn't
        // then we need to retry the catchup.
        //
        pOMCWSGroup = GetOMCWsgroup(pDomain);
        if (pOMCWSGroup == NULL)
        {
            // lonchanc: ingore left-over events due to race condition
            DC_QUIT;
        }

        pOMCWorkset = pOMCWSGroup->apWorksets[worksetID];
        if (pOMCWorkset == NULL)
        {
            // lonchanc: ingore left-over events due to race condition
            DC_QUIT;
        }

        pWSGroup = (POM_WSGROUP)COM_BasedListFirst(&(pDomain->wsGroups),
            FIELD_OFFSET(OM_WSGROUP, chain));
        while (pWSGroup != NULL)
        {
            //
            // Check the WSG state to see if we are in the middle of a
            // catchup.
            //
            if ((PENDING_SEND_MIDWAY == pWSGroup->state) ||
                (PENDING_SEND_COMPLETE == pWSGroup->state))
            {
                //
                // We are in the middle of a catchup so we need to check
                // to see that the person object for the person that we
                // are catching up from has not been deleted.
                //
                FindPersonObject(pOMCWorkset,
                                 pWSGroup->helperNode,
                                 FIND_THIS,
                                 &pObj);

                //
                // Check the person handle.
                //
                if (NULL == pObj)
                {
                    TRACE_OUT(("Person object removed for WSG %d - retrying"
                           " catchup",
                           pWSGroup->wsg));

                    //
                    // Force MaybeRetryCatchUp to retry the catchup by
                    // passing the helper node ID that is stored in the
                    // workset.
                    //
                    MaybeRetryCatchUp(pomPrimary,
                                      pDomain,
                                      pWSGroup->wsGroupID,
                                      pWSGroup->helperNode);
                }
                else
                {
                    UT_BumpUpRefCount(pObj);
                }
            }

            //
            // Get the next WSG.
            //
            pWSGroup = (POM_WSGROUP)COM_BasedListNext(&(pDomain->wsGroups), pWSGroup,
                FIELD_OFFSET(OM_WSGROUP, chain));
        }
    }

DC_EXIT_POINT:
    if (pObj)
    {
        UT_FreeRefCount((void**)&pObj, FALSE);
    }

    DebugExitVOID(ProcessOMCObjectEvents);
}



//
// GeneratePersonEvents(...)
//
void GeneratePersonEvents
(
    POM_PRIMARY             pomPrimary,
    UINT                    event,
    POM_WSGROUP             pWSGroup,
    POM_OBJECT              pObj
)
{
    POM_WSGROUP_REG_REC     pPersonObject;
    UINT                    newEvent    = 0;

    DebugEntry(GeneratePersonEvents);

    //
    // OK, to get here we must have determined that a local client has
    // registered with the workset group.  Now proceed to examine the event
    // and generate an appropriate person event for the client:
    //
    switch (event)
    {
        case OM_OBJECT_ADD_IND:
        case OM_OBJECT_UPDATED_IND:
        {
            ValidateObject(pObj);
            if (pObj->flags & DELETED)
            {
                //
                // The object has been deleted already!  We can't check its
                // state so just quit:
                //
                DC_QUIT;
            }
            if (!pObj->pData)
            {
                ERROR_OUT(("GeneratePersonEvents:  object 0x%08x has no data", pObj));
                DC_QUIT;
            }

            //
            // We're only interested in person objects, so if it's anything
            // else, quit:
            //
            ValidateObjectData(pObj->pData);
            pPersonObject = (POM_WSGROUP_REG_REC)pObj->pData;

            if (pPersonObject->idStamp != OM_WSGREGREC_ID_STAMP)
            {
                DC_QUIT;
            }

            //
            // Translate to a PERSON_JOINED event, provided the person data
            // has actually arrived.  We determine this by reading the
            // object and checking the <status> in it:
            //
            if (pPersonObject->status == READY_TO_SEND)
            {
                newEvent = OM_PERSON_JOINED_IND;
            }
        }
        break;

        case OM_OBJECT_DELETED_IND:
        {
            //
            // This means that someone has left the call
            //
            newEvent = OM_PERSON_LEFT_IND;
        }
        break;

        case OM_OBJECT_REPLACED_IND:
        {
            //
            // This means someone has done a SetPersonData:
            //
            newEvent = OM_PERSON_DATA_CHANGED_IND;
        }
        break;
    }

    //
    // If there is any translating to be done, newEvent will now be
    // non-zero:
    //
    if (newEvent != 0)
    {
        WSGroupEventPost(pomPrimary->putTask,
                         pWSGroup,
                         PRIMARY,
                         newEvent,
                         0,
                         (UINT_PTR)pObj);
    }

DC_EXIT_POINT:
    DebugExitVOID(GeneratePersonEvents);
}



//
// ProcessOMCWorksetNew(...)
//
void ProcessOMCWorksetNew
(
    POM_PRIMARY         pomPrimary,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID
)
{
    POM_DOMAIN          pDomain;
    POM_WORKSET         pOMCWorkset;
    POM_CLIENT_LIST     pClientListEntry;

    DebugEntry(ProcessOMCWorksetNew);

    //
    // The ObMan task generates person data events for its clients when the
    // contents of the relevant control workset changes.  We therefore add
    // ObMan to this new control workset's list of "clients" and post it
    // events for any objects already there:
    //
    // NOTE: We specify that ObMan should be considered a SECONDARY "client"
    //       of this workset so that it is not required to confirm delete
    //       events etc.
    //
    TRACE_OUT(( "Recd WORKSET_NEW for workset %u, WSG %u",
        worksetID, hWSGroup));

    //
    // Look up the domain record based on the workset group handle:
    //
    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pomPrimary->domains),
        (void**)&pDomain, FIELD_OFFSET(OM_DOMAIN, chain),
        FIELD_OFFSET(OM_DOMAIN, omchWSGroup), (DWORD)hWSGroup,
        FIELD_SIZE(OM_DOMAIN, omchWSGroup));

    if (pDomain == NULL)
    {
        WARNING_OUT(( "No domain record found with omchWSGroup %d",
            hWSGroup));
        DC_QUIT;
    }

    pOMCWorkset = GetOMCWorkset(pDomain, worksetID);

    ASSERT((pOMCWorkset != NULL));

    if (AddClientToWsetList(pomPrimary->putTask,
                             pOMCWorkset,
                             hWSGroup,
                             SECONDARY,
                             &pClientListEntry) != 0)
    {
        DC_QUIT;
    }
    TRACE_OUT(( "Added ObMan as secondary client for workset"));

    PostAddEvents(pomPrimary->putTask, pOMCWorkset, hWSGroup, pomPrimary->putTask);

DC_EXIT_POINT:
    DebugExitVOID(ProcessOMCWorksetNew);
}




//
// ProcessSendQueue()
//
void ProcessSendQueue
(
    POM_PRIMARY     pomPrimary,
    POM_DOMAIN      pDomain,
    BOOL            domainRecBumped
)
{
    POM_SEND_INST   pSendInst;
    NET_PRIORITY    priority;

    DebugEntry(ProcessSendQueue);

    //
    // Check the Domain record is still valid:
    //
    if (!pDomain->valid)
    {
        TRACE_OUT(( "Got OMINT_EVENT_SEND_QUEUE too late for discarded Domain %u",
            pDomain->callID));
        DC_QUIT;
    }

    //
    // Check that there is supposed to be a send event outstanding:
    //
    if (pDomain->sendEventOutstanding)
    {
        //
        // Although there might still be a send event outstanding (e.g.  a
        // FEEDBACK event) we can't be sure (unless we count them as we
        // generate them).  It's vital that we never leave the send queue
        // unprocessed, so to be safe we clear the flag so that QueueMessage
        // will post an event next time it's called:
        //
        pDomain->sendEventOutstanding = FALSE;
    }
    else
    {
        //
        // This will happen
        //
        // - when we get a FEEDBACK event after we've cleared the queue, OR
        //
        // - when we get a SEND_QUEUE event which was posted because there
        //   were none outstanding but a FEEDBACK event arrived in the
        //   meantime to clear the queue.
        //
        // NOTE: this flag means that there MIGHT not be a send EVENT
        //       outstanding (see above).  It does not mean that there's
        //       nothing on the send queue, so we go ahead and check the
        //       queue.
        //
    }

    //
    // The strategy for processing the send queue is to process the highest
    // priority operation first, whether or not a transfer is in progress
    // at another priority.
    //
    // So, for each priority, we check if there's anything in the queue:
    //
    TRACE_OUT(("Searching send queues for Domain %u",pDomain->callID));

    for (priority  = NET_TOP_PRIORITY; priority <= NET_LOW_PRIORITY; priority++)
    {
        TRACE_OUT(("Processing queue at priority %u", priority));

        while (pSendInst = (POM_SEND_INST)COM_BasedListFirst(&(pDomain->sendQueue[priority]), FIELD_OFFSET(OM_SEND_INST, chain)))
        {
            TRACE_OUT(("Found send instruction for priority %u", priority));

            if (SendMessagePkt(pomPrimary, pDomain, pSendInst) != 0)
            {
                DC_QUIT;
            }
        }
    }

DC_EXIT_POINT:

    if (domainRecBumped)
    {
        //
        // If our caller has told us that the use count of the Domain
        // record has been bumped, free it now:
        //
        UT_FreeRefCount((void**)&pDomain, FALSE);
    }

    DebugExitVOID(ProcessSendQueue);
}



//
// SendMessagePkt(...)
//
UINT SendMessagePkt
(
    POM_PRIMARY         pomPrimary,
    POM_DOMAIN          pDomain,
    POM_SEND_INST       pSendInst
)
{
    void *              pNetBuffer =        NULL;
    void *              pAnotherNetBuffer = NULL;
    UINT                transferSize;
    UINT                dataTransferSize;
    BOOL                compressed;
    BOOL                tryToCompress;
    BOOL                spoiled =           FALSE;
    BOOL                allSent =           FALSE;
    NET_PRIORITY        queuePriority;
    BOOL                fSendExtra;
    POMNET_PKT_HEADER   pMessage;
    POM_WSGROUP         pWSGroup;
    POM_WORKSET         pWorkset;
    UINT                rc = 0;

    DebugEntry(SendMessagePkt);

    //
    // We check here if we can spoil this message:
    //
    rc = TryToSpoilOp(pSendInst);

    //
    // If so, quit:
    //
    if (rc == OM_RC_SPOILED)
    {
        spoiled = TRUE;
        rc = 0;
        DC_QUIT;
    }

    //
    // Any other error is more serious:
    //
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // Now decide how many bytes we're going to ask the network layer for
    // this time and how many data bytes we're going to transfer:
    //
    DecideTransferSize(pSendInst, &transferSize, &dataTransferSize);

    ASSERT(dataTransferSize <= pSendInst->dataLeftToGo);

    //
    // Add 1 byte to the transfer size for the <compressionType> byte:
    //
    TRACE_OUT(("Asking MG_GetBuffer for 0x%08x bytes for operation type 0x%08x",
        transferSize + 1,  pSendInst->messageType));

    rc = MG_GetBuffer(pomPrimary->pmgClient,
                       transferSize + 1,
                       pSendInst->priority,
                       pSendInst->channel,
                       &pNetBuffer);
    if (rc != 0)
    {
        //
        // Possible errors include
        //  - NET_NOT_CONNECTED, when a backlevel call ends
        //  - NET_INVALID_USER_HANDLE, when an MCS call ends
        //  - NET_TOO_MUCH_IN_USE, when we hit back pressure (flow control)
        //
        // In all cases, just quit.
        //
        TRACE_OUT(("MG_GetBuffer failed; not sending OM message"));
        DC_QUIT;
    }

    //
    // OK so far, so now copy the header of the message into the first part
    // of the compress buffer:
    //
    pMessage = pSendInst->pMessage;
    ASSERT(pMessage);
    memcpy(pomPrimary->compressBuffer, pMessage, pSendInst->messageSize);

    //
    // ...and now copy the data into the rest of the buffer:
    //
    // This must be a HUGE copy because although the compress buffer is not
    // HUGE, the data is and the bit to be copied may span segments.
    //
    if (dataTransferSize != 0)
    {
        memcpy((LPBYTE)pomPrimary->compressBuffer + pSendInst->messageSize,
            pSendInst->pDataNext,  dataTransferSize);
    }

    //
    // Determine whether to compress:
    //
    compressed = FALSE;
    tryToCompress = FALSE;

    if ((pDomain->compressionCaps & OM_CAPS_PKW_COMPRESSION) &&
        (pSendInst->compressOrNot) &&
        (transferSize > DCS_MIN_COMPRESSABLE_PACKET) &&
        (pomPrimary->pgdcWorkBuf != NULL))
    {
        tryToCompress = TRUE;
    }

    //
    // If we passed those tests, compress the packet into the network
    // buffer.
    //
    // This will not use the whole network buffer we have allocated, but it
    // saves us having to have two buffers and doing a second data copy.
    // The network layer can handle a partially used buffer
    //

    if (tryToCompress)
    {
        TRACE_OUT(("OM Compressing %04d bytes", transferSize));
        compressed = GDC_Compress(NULL, GDCCO_MAXSPEED, pomPrimary->pgdcWorkBuf,
            pomPrimary->compressBuffer, transferSize, (LPBYTE)pNetBuffer + 1,
            &transferSize);
    }

    if (compressed)
    {
        TRACE_OUT(("OM Compressed to %04d bytes", transferSize));

        *((LPBYTE)pNetBuffer) = OM_PROT_PKW_COMPRESSED;
    }
    else
    {
        TRACE_OUT(("OM Uncompressed %04d bytes", transferSize));

        memcpy((LPBYTE)pNetBuffer + 1, pomPrimary->compressBuffer,
               transferSize);

        *((LPBYTE)pNetBuffer) = OM_PROT_NOT_COMPRESSED;
    }

    //
    // If we're in a T.120 call and sending on all priorities, we need to
    // do some work to ensure compatibility with NetMeeting 1.0.
    //
    fSendExtra = ((pSendInst->priority & NET_SEND_ALL_PRIORITIES) != 0);
    if ( fSendExtra )
    {
        //
        // T.120 reserves MCS Top Priority for use by GCC. Sending on all
        // priorities used to include Top, but no longer does, to ensure
        // compliance. However, ObMan expects to receive 4 responses when
        // sending on all priorities whereas the MCS glue now uses only
        // 3 priorities. To ensure backward compatibility, whenever ObMan
        // sends on all priorities, it has to add an extra send by making
        // an extra call to the network here.
        // First allocate another net buffer and copy the data to it (we
        // have to do before calling MG_SendData as the other buffer is
        // invalid after this).
        //
        TRACE_OUT(( "SEND_ALL: get extra NET buffer"));
        rc = MG_GetBuffer(pomPrimary->pmgClient,
                           transferSize + 1,
               (NET_PRIORITY)(pSendInst->priority & ~NET_SEND_ALL_PRIORITIES),
                           pSendInst->channel,
                           &pAnotherNetBuffer);
        if (rc != 0)
        {
            WARNING_OUT(("MG_GetBuffer failed; not sending OM packet"));
        }
        else
        {
            memcpy(pAnotherNetBuffer, pNetBuffer, transferSize + 1);
        }

    }

    //
    // Now send the packet, adding 1 byte to the length for the
    // <compressionType> byte:
    //
    TRACE_OUT(( "Sending 0x%08x bytes on channel 0x%08x at priority %hu",
      transferSize + 1, pSendInst->channel, pSendInst->priority));

    if (rc == 0)
    {
        TRACE_OUT(("SendMessagePkt: sending packet size %d",
            transferSize+1));

        rc = MG_SendData(pomPrimary->pmgClient,
                          pSendInst->priority,
                          pSendInst->channel,
                          (transferSize + 1),
                          &pNetBuffer);
    }

    if ( fSendExtra && (rc == 0) )
    {
        TRACE_OUT(("SendMessagePkt: sending extra packet size %d",
            transferSize+1));

        rc = MG_SendData(pomPrimary->pmgClient,
               (NET_PRIORITY)(pSendInst->priority & ~NET_SEND_ALL_PRIORITIES),
                          pSendInst->channel,
                          (transferSize + 1),
                          &pAnotherNetBuffer);
    }

    if (rc != 0)
    {
        //
        // Network API says free the buffer on error:
        //
        MG_FreeBuffer(pomPrimary->pmgClient, &pNetBuffer);
        if ( pAnotherNetBuffer != NULL )
        {
            MG_FreeBuffer(pomPrimary->pmgClient, &pAnotherNetBuffer);
        }

        switch (rc)
        {
        case NET_RC_MGC_NOT_CONNECTED:
        case NET_RC_MGC_INVALID_USER_HANDLE:
            //
            // These are the errors the Network layer returns when we're in
            // a singleton Domain or when an MCS domain has just
            // terminated.  We ignore them.
            //
            TRACE_OUT(("No data sent since call %u doesn't exist",
                pDomain->callID));
            rc = 0;
            break;

        default:
            //
            // Any other error is more serious, so quit and pass it back:
            //
            DC_QUIT;
        }
    }
    else
    {
        //
        // We've sent a message and will therefore get a FEEDBACK event
        // sometime later.  This qualifies as a SEND_EVENT since it will
        // prompt us to examine our send queue, so we set the
        // SEND_EVENT_OUTSTANDING flag:
        //
        TRACE_OUT(("Sent msg in Domain %u (type: 0x%08x) with %hu data bytes",
              pDomain->callID, pSendInst->messageType, dataTransferSize));

        pDomain->sendEventOutstanding = TRUE;
    }

    //
    // Here, we decrement the <bytesUnacked> fields for the workset and
    // workset group:
    //
    if (dataTransferSize != 0)
    {
        pWorkset = pSendInst->pWorkset;
        pWorkset->bytesUnacked -= dataTransferSize;

        pWSGroup = pSendInst->pWSGroup;
        pWSGroup->bytesUnacked -= dataTransferSize;
    }

    //
    // Now update the send instruction and decide whether we've sent all
    // the data for this operation:
    //
    pSendInst->dataLeftToGo     -= dataTransferSize;
    pSendInst->pDataNext        = (POM_OBJECTDATA)((LPBYTE)pSendInst->pDataNext + dataTransferSize);

    if (pSendInst->dataLeftToGo == 0)
    {
        //
        // If so, we
        //
        // - clear the transfer-in-progress flag for this queue -
        //   remember that the NET_SEND_ALL_PRIORITIES flag may be set so
        //   we need to clear it
        //
        // - free our copy of the message packet and the data, if any (we
        //   bumped up the use count of the data chunk when the message was
        //   put on the queue so we won't really be getting rid of it
        //   unless it's been freed elsewhere already, which is fine)
        //
        // - pop the instruction off the send queue and free it.
        //
        TRACE_OUT(( "Sent last packet for operation (type: 0x%08x)",
            pSendInst->messageType));

        queuePriority = pSendInst->priority;
        queuePriority &= ~NET_SEND_ALL_PRIORITIES;
        pDomain->sendInProgress[queuePriority] = FALSE;
        allSent = TRUE;
    }
    else
    {
        //
        // If not, we
        //
        // - set the transfer-in-progress flag for this queue -
        //   remember that the NET_SEND_ALL_PRIORITIES flag may be set so
        //   we need to clear it
        //
        // - set the <messageSize> field of the send instruction to the
        //   size of a MORE_DATA header, so that only that many bytes are
        //   picked out of the message next time
        //
        // - set the <messageType> field of the message to MORE_DATA
        //
        // - leave the operation on the queue.
        //
        TRACE_OUT(("Data left to transfer: %u bytes (starting at 0x%08x)",
            pSendInst->dataLeftToGo, pSendInst->pDataNext));

        queuePriority = pSendInst->priority;
        queuePriority &= ~NET_SEND_ALL_PRIORITIES;
        pDomain->sendInProgress[queuePriority] = TRUE;

        pSendInst->messageSize = OMNET_MORE_DATA_SIZE;

        pMessage->messageType = OMNET_MORE_DATA;
    }

DC_EXIT_POINT:

    //
    // If we're finished with the message (either because we've sent it all
    // or because it was spoiled) we free it (plus any associated data):
    //
    if (spoiled || allSent)
    {
        FreeSendInst(pSendInst);
    }

    DebugExitDWORD(SendMessagePkt, rc);
    return(rc);
}



//
// TryToSpoilOp
//
UINT TryToSpoilOp
(
    POM_SEND_INST           pSendInst
)
{
    POMNET_OPERATION_PKT    pMessage;
    POM_OBJECT              pObj;
    POM_WORKSET             pWorkset;
    POM_WSGROUP             pWSGroup;
    BOOL                    spoilable = FALSE;
    UINT                    rc = 0;

    DebugEntry(TryToSpoilOp);

    pMessage    = (POMNET_OPERATION_PKT)pSendInst->pMessage;
    pObj        = pSendInst->pObj;
    pWorkset    = pSendInst->pWorkset;
    pWSGroup    = pSendInst->pWSGroup;

    //
    // The rules for spoiling state that
    //
    // - any operation is spoiled by a later operation of the same type
    //
    // - in addition, an Update is spoiled by a later Replace.
    //
    // Since we never have two Adds or two Deletes for the same object,
    // these rules reduce to the following:
    //
    // - a Clear is spoiled by a later Clear
    //
    // - a Move is spoiled by a later Move
    //
    // - a Replace is spoiled by a later Replace
    //
    // - an Update is spoiled by a later Update or a later Replace.
    //
    // So, switch according to the operation type:
    //

    switch (pSendInst->messageType)
    {
        case OMNET_WORKSET_CLEAR:
            if (STAMP_IS_LOWER(pMessage->seqStamp, pWorkset->clearStamp))
            {
                spoilable = TRUE;
            }
            break;

        case OMNET_OBJECT_UPDATE:
            if ((STAMP_IS_LOWER(pMessage->seqStamp, pObj->replaceStamp))
             || (STAMP_IS_LOWER(pMessage->seqStamp, pObj->updateStamp)))
            {
                spoilable = TRUE;
            }
            break;

        case OMNET_OBJECT_REPLACE:
            if (STAMP_IS_LOWER(pMessage->seqStamp, pObj->replaceStamp))
            {
                spoilable = TRUE;
            }
            break;

        case OMNET_OBJECT_MOVE:
            if (STAMP_IS_LOWER(pMessage->seqStamp, pObj->positionStamp))
            {
                spoilable = TRUE;
            }
            break;

        case OMNET_HELLO:
        case OMNET_WELCOME:
        case OMNET_LOCK_REQ:
        case OMNET_LOCK_GRANT:
        case OMNET_LOCK_DENY:
        case OMNET_LOCK_NOTIFY:
        case OMNET_UNLOCK:
        case OMNET_WSGROUP_SEND_REQ:
        case OMNET_WSGROUP_SEND_MIDWAY:
        case OMNET_WSGROUP_SEND_COMPLETE:
        case OMNET_WSGROUP_SEND_DENY:
        case OMNET_WORKSET_NEW:
        case OMNET_WORKSET_CATCHUP:
        case OMNET_OBJECT_ADD:
        case OMNET_OBJECT_DELETE:
        case OMNET_OBJECT_CATCHUP:
            //
            // Do nothing
            //
            break;

        default:
            ERROR_OUT(("Reached default case in switch statement (value: %hu)",
                pSendInst->messageType));
            break;
    }

    if (spoilable)
    {
        //
        // To spoil the message, we remove it from the send queue and free
        // the memory (also NULL the caller's pointer):
        //

        //
        // However, if we spoil the message, the data (if any) will never be
        // acknowledged, so we must decrement the relevant <bytesUnacked>
        // fields now:
        //
        TRACE_OUT(( "Spoiling from send queue for workset %u",
            pWorkset->worksetID));

        if (pSendInst->dataLeftToGo != 0)
        {
            pWorkset->bytesUnacked -= pSendInst->dataLeftToGo;
            pWSGroup->bytesUnacked -= pSendInst->dataLeftToGo;
        }

        rc = OM_RC_SPOILED;
    }

    DebugExitDWORD(TryToSpoilOp, rc);
    return(rc);
}




//
// DecideTransferSize(...)
//
void DecideTransferSize
(
    POM_SEND_INST   pSendInst,
    UINT *          pTransferSize,
    UINT *          pDataTransferSize
)
{
    UINT            transferSize;

    DebugEntry(DecideTransferSize);

    //
    // Ideally, we'd like to transfer everything in one go, where
    // "everything" is the message header plus all the data to go with it
    // (if any):
    //

    transferSize = pSendInst->messageSize + pSendInst->dataLeftToGo;

    TRACE_OUT(("Desired transfer size for this portion: %u", transferSize));

    //
    // However, we never ask for more than half the send pool size, so take
    // the minimum of the two:
    //
    // (we subtract 1 byte to allow for the <compressionType> byte at the
    // start of the packet)
    //

    transferSize = min(transferSize, ((OM_NET_SEND_POOL_SIZE / 2) - 1));

    TRACE_OUT(("Feasible transfer size for this portion: %u",
                                                               transferSize));

    //
    // The logic of the send queue processing requires that the message
    // header is sent completely in the first packet, so assert:
    //

    ASSERT((transferSize >= pSendInst->messageSize));

    //
    // As a sanity check, we ensure we're not trying to transfer more than
    // the biggest buffer allowed:
    //

    ASSERT(transferSize <= OM_NET_MAX_TRANSFER_SIZE);

    //
    // The amount of data to be sent is the transfer size less the size of
    // the header we're sending:
    //

    *pDataTransferSize = ((UINT) transferSize) - pSendInst->messageSize;
    *pTransferSize     = (UINT) transferSize;

    TRACE_OUT(("Total transfer size for this packet: %u - data transfer size: %u",
         (UINT) *pTransferSize, (UINT) *pDataTransferSize));

    DebugExitVOID(DecideTransferSize);
}



//
// ProcessNetData(...)
//
void ProcessNetData
(
    POM_PRIMARY             pomPrimary,
    POM_DOMAIN              pDomain,
    PNET_SEND_IND_EVENT     pNetSendInd
)
{
    POMNET_PKT_HEADER       pHeader;
    UINT                    dataSize;
    OMNET_MESSAGE_TYPE      messageType = 0;
    UINT                    rc = 0;

    DebugEntry(ProcessNetData);

    //
    // Decompress the packet and set pHeader to point to the start of
    // wherever the data ends up:
    //
    ASSERT((pNetSendInd->lengthOfData < 0xFFFF));

    if (NULL != pNetSendInd->data_ptr) {
        switch (*(pNetSendInd->data_ptr))
        {
            case OM_PROT_NOT_COMPRESSED:
            {
                TRACE_OUT(("Buffer not compressed - taking it as it stands"));
                memcpy(pomPrimary->compressBuffer, pNetSendInd->data_ptr + 1,
                          pNetSendInd->lengthOfData--);
            }
            break;

            case OM_PROT_PKW_COMPRESSED:
            {
                TRACE_OUT(("Buffer was PKW compressed - size 0x%08x bytes",
                    pNetSendInd->lengthOfData));

                dataSize = sizeof(pomPrimary->compressBuffer);

                ASSERT(pomPrimary->pgdcWorkBuf != NULL);
                if (!GDC_Decompress(NULL, pomPrimary->pgdcWorkBuf,
                        pNetSendInd->data_ptr + 1,
                        (WORD) pNetSendInd->lengthOfData - 1,
                        pomPrimary->compressBuffer, &dataSize))
                {
                   ERROR_OUT(("Failed to decompress OM data!"));
                }

                pNetSendInd->lengthOfData = dataSize;

                TRACE_OUT(("Decompressed to 0x%08x bytes",
                    pNetSendInd->lengthOfData));
            }
            break;

            default:
            {
                ERROR_OUT(( "Ignoring packet with unknown compression (0x%08x)",
                         *(pNetSendInd->data_ptr)));
                DC_QUIT;
            }
        }
        pHeader = (POMNET_PKT_HEADER) pomPrimary->compressBuffer;

        //
        // Now switch accorindg to the message type:
        //
        messageType = pHeader->messageType;

        TRACE_OUT((" Packet contains OMNET message type 0x%08x", messageType));

        switch (messageType)
        {
            case OMNET_HELLO:
            {
                rc = ProcessHello(pomPrimary,
                                  pDomain,
                                  (POMNET_JOINER_PKT) pHeader,
                                  pNetSendInd->lengthOfData);

            }
            break;

            case OMNET_WELCOME:
            {
                rc = ProcessWelcome(pomPrimary,
                                    pDomain,
                                    (POMNET_JOINER_PKT) pHeader,
                                    pNetSendInd->lengthOfData);
            }
            break;

            case OMNET_LOCK_DENY:
            case OMNET_LOCK_GRANT:
            {
                ProcessLockReply(pomPrimary,
                                 pDomain,
                                 pHeader->sender,
                                 ((POMNET_LOCK_PKT) pHeader)->data1,
                                 pHeader->messageType);
            }
            break;


            case OMNET_LOCK_REQ:
            {
                ProcessLockRequest(pomPrimary, pDomain,
                                   (POMNET_LOCK_PKT) pHeader);
            }
            break;

            case OMNET_WSGROUP_SEND_REQ:
            {
                ProcessSendReq(pomPrimary,
                               pDomain,
                               (POMNET_WSGROUP_SEND_PKT) pHeader);
            }
            break;

            case OMNET_WSGROUP_SEND_MIDWAY:
            {
                ProcessSendMidway(pomPrimary,
                                  pDomain,
                                  (POMNET_WSGROUP_SEND_PKT) pHeader);
            }
            break;

            case OMNET_WSGROUP_SEND_COMPLETE:
            {
                rc = ProcessSendComplete(pomPrimary,
                                         pDomain,
                                         (POMNET_WSGROUP_SEND_PKT) pHeader);
            }
            break;

            case OMNET_WSGROUP_SEND_DENY:
            {
                MaybeRetryCatchUp(pomPrimary,
                                  pDomain,
                                  ((POMNET_WSGROUP_SEND_PKT) pHeader)->wsGroupID,
                                  pHeader->sender);
            }
            break;

            //
            // We use the special ReceiveData function for any messages which
            //
            // - might need to be bounced, or
            //
            // - might fill more than one packet.
            //
            case OMNET_LOCK_NOTIFY:
            case OMNET_UNLOCK:

            case OMNET_WORKSET_NEW:
            case OMNET_WORKSET_CLEAR:
            case OMNET_WORKSET_CATCHUP:

            case OMNET_OBJECT_ADD:
            case OMNET_OBJECT_MOVE:
            case OMNET_OBJECT_UPDATE:
            case OMNET_OBJECT_REPLACE:
            case OMNET_OBJECT_DELETE:
            case OMNET_OBJECT_CATCHUP:

            case OMNET_MORE_DATA:
            {
                rc = ReceiveData(pomPrimary,
                                 pDomain,
                                 pNetSendInd,
                                 (POMNET_OPERATION_PKT) pHeader);
            }
            break;

            default:
            {
                ERROR_OUT(( "Unexpected messageType 0x%08x", messageType));
            }
        }

    DC_EXIT_POINT:

        if (rc != 0)
        {
            ERROR_OUT(( "Error %d processing OMNET message 0x%08x",
                rc, messageType));
        }
    }

    DebugExitVOID(ProcessNetData);

}



//
// ReceiveData(...)
//
UINT ReceiveData
(
    POM_PRIMARY             pomPrimary,
    POM_DOMAIN              pDomain,
    PNET_SEND_IND_EVENT     pNetSendInd,
    POMNET_OPERATION_PKT    pNetMessage
)
{
    POM_RECEIVE_CB          pReceiveCB = NULL;
    UINT                    thisHeaderSize;
    UINT                    thisDataSize;
    OMNET_MESSAGE_TYPE      messageType;
    long                    bytesStillExpected =    0;
    UINT                    rc = 0;

    DebugEntry(ReceiveData);

    //
    // Set up some local variables:
    //
    messageType = pNetMessage->header.messageType;

    //
    // The amount of data included in this message is the size of the
    // network buffer less the size of our message header at the front of
    // it:
    //
    // Note: <thisHeaderSize> is the size of the header IN THIS PACKET,
    //       rather than the size of the header in the first packet of a
    //       multi-packet send.
    //
    thisHeaderSize = GetMessageSize(pNetMessage->header.messageType);
    thisDataSize = pNetSendInd->lengthOfData - thisHeaderSize;

    //
    // If this is a MORE_DATA packet, then there should already be a
    // receive CB set up for the transfer.  If not, we need to create one:
    //
    if (messageType == OMNET_MORE_DATA)
    {
        rc = FindReceiveCB(pDomain, pNetSendInd, pNetMessage, &pReceiveCB);

       //
       // If no receive CB, we swallow the return code and quit.  This will
       // happen when we join a channel midway through a large data
       // transfer.
       //
       if (rc == OM_RC_RECEIVE_CB_NOT_FOUND)
       {
           WARNING_OUT(("Discarding unexpected packet from 0x%08x",
                             pNetMessage->header.sender));
           rc = 0;
           DC_QUIT;
       }
    }
    else
    {
        // lonchanc: added the following block of code
        if (messageType == OMNET_OBJECT_REPLACE)
        {
            POM_RECEIVE_CB p;
            // lonchanc: This packet does not contain all the data.
            // More data will come in another packets; however,
            // in this case, bytesStillExpected will be greater than zero
            // after substracting from thisDataSize, as a result,
            // this receiveCB will be appended to the ReceiveList.
            // However, FindReceiveCB will find the first one matched.
            // As a result, the one we just appended to the ReceiveList will
            // not be found.
            // Even worse, if there is receiveCB (of same sender, priority, and
            // channel), the first-matched receiveCB will be totally confused
            // when more data come in. This is bug #578.
            TRACE_OUT(("Removing receiveCB {"));
            while (FindReceiveCB(pDomain, pNetSendInd, pNetMessage, &p) == 0)
            {
                //
                // Remove the message from the list it's in (either the pending
                // receives list if this message was never bounced or the bounce
                // list if it has been bounced):
                //
                COM_BasedListRemove(&(p->chain));

                //
                // Now free the message and the receive control block (NOT THE
                // DATA!  If there was any, it's just been used for an object
                // add/update etc.)
                //
                UT_FreeRefCount((void**)&(p->pHeader), FALSE);

                UT_FreeRefCount((void**)&p, FALSE);
            }
        }

        rc = CreateReceiveCB(pDomain, pNetSendInd, pNetMessage, &pReceiveCB);
    }

    if (rc != 0)
    {
        ERROR_OUT(("%s failed, rc=0x0x%08x",
            (messageType == OMNET_MORE_DATA) ? "FindReceiveCB" : "CreateReceiveCB",
            rc));
        DC_QUIT;
    }

    TRACE_OUT(("%s ok, pRecvCB=0x0x%p",
            (messageType == OMNET_MORE_DATA) ? "FindReceiveCB" : "CreateReceiveCB",
            pReceiveCB));
    //
    // Now we copy the data, if any, from the network buffer into the chunk
    // we allocated when we called CreateReceiveCB.
    //

    if (thisDataSize != 0)
    {
        //
        // We copy the data across using memcpy.
        //
        bytesStillExpected = ((long) (pReceiveCB->pHeader->totalSize) -
                              (long) (pReceiveCB->bytesRecd));

        TRACE_OUT(("thisDataSize=0x0x%08x, bytesStillExpected=0x0x%08x, totalSize=0x0x%08x, bytesRecd=0x0x%08x",
                        (long) thisDataSize,
                        (long) bytesStillExpected,
                        (long) pReceiveCB->pHeader->totalSize,
                        (long) pReceiveCB->bytesRecd));

        ASSERT((long) thisDataSize <= bytesStillExpected);

        memcpy(pReceiveCB->pCurrentPosition,
                  ((LPBYTE) pNetMessage) + thisHeaderSize,
                  thisDataSize);

        pReceiveCB->bytesRecd        += thisDataSize;
        pReceiveCB->pCurrentPosition += thisDataSize;
        bytesStillExpected           -= thisDataSize;

        TRACE_OUT((" Still expecting %u bytes", bytesStillExpected));
    }

    //
    // If we are expecting no more data for this transfer, process it:
    //
    if (bytesStillExpected <= 0)
    {
        rc = ProcessMessage(pomPrimary, pReceiveCB, OK_TO_RETRY_BOUNCE_LIST);
        if (rc == OM_RC_BOUNCED)
        {
            //
            // If ProcessMessage can't deal with the message immediately
            // (because e.g.  it's an update for an object we don't yet
            // have), it will have added it to the bounce list so it will
            // be tried again later.
            //
            // We special case this return code as it's not a problem for
            // us here (it exists because other parts of the code need it):
            //
            WARNING_OUT(("Bounced message type 0x%08x", messageType));
            rc = 0;
        }

        if (rc != 0)
        {
            //
            // Any other non-zero return code is more serious:
            //
            DC_QUIT;
        }
    }

DC_EXIT_POINT:

    if (rc != 0)
    {
        ERROR_OUT(("Error %d from message type 0x%08x", rc, messageType));

        if (rc == OM_RC_OUT_OF_RESOURCES)
        {
            //
            // If we couldn't allocate memory for the data to be recd, we
            // act as if we've been kicked out of the channel:
            //
            ERROR_OUT(( "Leaving chann 0x%08x, simulating expulsion", pNetSendInd->channel));

            MG_ChannelLeave(pomPrimary->pmgClient, pNetSendInd->channel);

            ProcessNetLeaveChannel(pomPrimary, pDomain, pNetSendInd->channel);
        }
    }

    DebugExitDWORD(ReceiveData, rc);
    return(rc);

}



//
// CreateReceiveCB(...)
//
UINT CreateReceiveCB
(
    POM_DOMAIN              pDomain,
    PNET_SEND_IND_EVENT     pNetSendInd,
    POMNET_OPERATION_PKT    pNetMessage,
    POM_RECEIVE_CB *        ppReceiveCB
)
{
    POM_RECEIVE_CB          pReceiveCB =    NULL;
    POMNET_OPERATION_PKT    pHeader =       NULL;
    UINT                    headerSize;
    UINT                    totalDataSize;
    UINT                    rc = 0;

    DebugEntry(CreateReceiveCB);

    //
    // We get here when the first packet of a message arrives .  What we
    // need to do is to set up a "receive" structure and add it to the list
    // of receives-in-progress for the Domain.  Then, when the ensuing data
    // packets (if any) arrive, they will be correlated and concatenated.
    // When all the data has arrived, the receive CB will be passed to
    // ProcessMessage.
    //

    //
    // Allocate some memory for the receive CB:
    //
    pReceiveCB = (POM_RECEIVE_CB)UT_MallocRefCount(sizeof(OM_RECEIVE_CB), TRUE);
    if (!pReceiveCB)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }
    SET_STAMP(pReceiveCB, RCVCB);

    pReceiveCB->pDomain     = pDomain;
    pReceiveCB->priority    = pNetSendInd->priority;
    pReceiveCB->channel     = pNetSendInd->channel;

    //
    // Allocate some memory for the message header and copy the packet into
    // it from the network buffer (note: we must copy the header since at
    // the moment it is in a network buffer which we can't hang on to for
    // the entire duration of the transfer):
    //
    headerSize = GetMessageSize(pNetMessage->header.messageType);

    pHeader = (POMNET_OPERATION_PKT)UT_MallocRefCount(sizeof(OMNET_OPERATION_PKT), TRUE);
    if (!pHeader)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    memcpy(pHeader, pNetMessage, headerSize);

    pReceiveCB->pHeader = pHeader;

    //
    // Not all messages sent over the network have a totalSize field, but
    // our subsequent processing requires one.  So, if the message we've
    // just received didn't have one, we set the value (our local copy of
    // the header has room since we alloacated enough memory for the
    // largest type of header):
    //

    if (headerSize >= (offsetof(OMNET_OPERATION_PKT, totalSize) +
                       (sizeof(pNetMessage->totalSize))))
    {
        TRACE_OUT(("Header contains <totalSize> field (value: %u)",
            pNetMessage->totalSize));
    }
    else
    {
        TRACE_OUT(("Header doesn't contain <totalSize> field"));

        pReceiveCB->pHeader->totalSize = headerSize;
    }

    //
    // Now determine the total number of data bytes involved in this
    // operation:
    //

    totalDataSize = pReceiveCB->pHeader->totalSize - ((UINT) headerSize);

    //
    // If there is any data, allocate some memory to receive it and set the
    // <pData> pointer to point to it (otherwise NULL it):
    //

    if (totalDataSize != 0)
    {
        TRACE_OUT(( "Allocating %u bytes for data for this transfer",
                                                              totalDataSize));

        pReceiveCB->pData = UT_MallocRefCount(totalDataSize, FALSE);
        if (!pReceiveCB->pData)
        {
            ERROR_OUT(( "Failed to allocate %u bytes for object to be recd "
                "from node 0x%08x - will remove WSG from Domain",
                totalDataSize, pNetMessage->header.sender));
            rc = OM_RC_OUT_OF_RESOURCES;
            DC_QUIT;
        }
    }
    else
    {
        pReceiveCB->pData = NULL;
    }

    pReceiveCB->pCurrentPosition = (LPBYTE)pReceiveCB->pData;

    //
    // Set <bytesRecd> to the size of the header.  We may have recd some
    // data bytes as well, but they'll be added to the header size in
    // ReceiveData.
    //

    pReceiveCB->bytesRecd        = headerSize;

    //
    // Now insert in the list hung off the Domain record:
    //

    COM_BasedListInsertBefore(&(pDomain->receiveList),
                         &(pReceiveCB->chain));

    //
    // Set caller's pointer:
    //

    *ppReceiveCB = pReceiveCB;

DC_EXIT_POINT:

    if (rc != 0)
    {
        if(pHeader != NULL)
        {
            ERROR_OUT(( "Error %d receiving first packet of message type %u from node 0x%08x",
                rc, pHeader->header.messageType, pHeader->header.sender));
        }

        if (pReceiveCB != NULL)
        {
            if (pReceiveCB->pData != NULL)
            {
                UT_FreeRefCount((void**)&(pReceiveCB->pData), FALSE);
            }

            UT_FreeRefCount((void**)&pReceiveCB, FALSE);
        }

        if (pHeader != NULL)
        {
            UT_FreeRefCount((void**)&pHeader, FALSE);
        }
    }

    DebugExitDWORD(CreateReceiveCB, rc);
    return(rc);

}


//
//
//
// FindReceiveCB(...)
//
//
//

UINT FindReceiveCB(POM_DOMAIN        pDomain,
                                  PNET_SEND_IND_EVENT   pNetSendInd,
                                  POMNET_OPERATION_PKT  pPacket,
                                  POM_RECEIVE_CB *  ppReceiveCB)
{
    POM_RECEIVE_CB       pReceiveCB;
    NET_PRIORITY         priority;
    NET_CHANNEL_ID       channel;
    NET_UID              sender;
    POMNET_OPERATION_PKT pHeader;

    UINT rc        = 0;

    DebugEntry(FindReceiveCB);

    //
    // First thing to do is to find the receive control block for the
    // transfer.  It should be in the list hung off the Domain record:
    //

    sender       = pPacket->header.sender;
    priority     = pNetSendInd->priority;
    channel      = pNetSendInd->channel;

    pReceiveCB = (POM_RECEIVE_CB)COM_BasedListFirst(&(pDomain->receiveList), FIELD_OFFSET(OM_RECEIVE_CB, chain));
    while (pReceiveCB != NULL)
    {
        //
        // We check for a match on sender's user ID, channel and priority.
        //
        // We assume that, for a given channel, MCS does not reorder packets
        // sent by the same user at the same priority.
        //
        pHeader = pReceiveCB->pHeader;

        if ((pHeader->header.sender == sender) &&
            (pReceiveCB->priority   == priority) &&
            (pReceiveCB->channel    == channel))
        {
            //
            // Found!
            //
            TRACE_OUT(("Found receive CB for user %hu, chann 0x%08x, pri %hu, at pRecvCB=0x0x%p",
                sender, channel, priority, pReceiveCB));
            break;
        }

        pReceiveCB = (POM_RECEIVE_CB)COM_BasedListNext(&(pDomain->receiveList), pReceiveCB,
            FIELD_OFFSET(OM_RECEIVE_CB, chain));
    }

    if (pReceiveCB == NULL)
    {
        rc = OM_RC_RECEIVE_CB_NOT_FOUND;
        DC_QUIT;
    }
    else
    {
        *ppReceiveCB = pReceiveCB;
    }

DC_EXIT_POINT:

    DebugExitDWORD(FindReceiveCB, rc);
    return(rc);
}



//
// PurgeReceiveCBs(...)
//
void PurgeReceiveCBs
(
    POM_DOMAIN      pDomain,
    NET_CHANNEL_ID  channel
)
{
    POM_RECEIVE_CB  pReceiveCB;
    POM_RECEIVE_CB  pNextReceiveCB;

    DebugEntry(PurgeReceiveCBs);

    pReceiveCB = (POM_RECEIVE_CB)COM_BasedListFirst(&(pDomain->receiveList), FIELD_OFFSET(OM_RECEIVE_CB, chain));
    while (pReceiveCB != NULL)
    {
        //
        // Need to chain here since we may remove pReceiveCB from the list:
        //
        pNextReceiveCB = (POM_RECEIVE_CB)COM_BasedListNext(&(pDomain->receiveList), pReceiveCB,
            FIELD_OFFSET(OM_RECEIVE_CB, chain));

        if (pReceiveCB->channel == channel)
        {
            //
            // This receive CB is for the channel being purged - remove it
            // from the list and free the memory.
            //
            WARNING_OUT(( "Purging receive CB from user %hu",
                pReceiveCB->pHeader->header.sender));

            COM_BasedListRemove(&(pReceiveCB->chain));

            //
            // Free the data memory.
            //
            if (pReceiveCB->pData != NULL)
            {
                UT_FreeRefCount(&pReceiveCB->pData, FALSE);
            }

            //
            // Free the header memory.
            //
            if (pReceiveCB->pHeader != NULL)
            {
                UT_FreeRefCount((void**)&pReceiveCB->pHeader, FALSE);
            }

            //
            // Finally free the control block.
            //
            UT_FreeRefCount((void**)&pReceiveCB, FALSE);
        }

        pReceiveCB = pNextReceiveCB;
     }

    DebugExitVOID(PurgeReceiveCBs);
}



//
// ProcessMessage(...)
//
UINT ProcessMessage
(
    POM_PRIMARY             pomPrimary,
    POM_RECEIVE_CB          pReceiveCB,
    UINT                    whatNext
)
{
    POM_DOMAIN              pDomain;
    POMNET_OPERATION_PKT    pHeader;
    void *                  pData;
    NET_PRIORITY            priority;
    OMNET_MESSAGE_TYPE      messageType;
    POM_WSGROUP             pWSGroup;
    POM_WORKSET             pWorkset;
    POM_OBJECT              pObj;
    BOOL                    bounced =           FALSE;
    BOOL                    retryBounceList =   FALSE;
    BOOL                    freeMemory =        FALSE;
    UINT                    rc =                0;

    DebugEntry(ProcessMessage);

    //
    // Set up local variables:
    //
    pDomain     = pReceiveCB->pDomain;
    pHeader     = pReceiveCB->pHeader;
    priority    = pReceiveCB->priority;
    pData       = pReceiveCB->pData;

    messageType = pHeader->header.messageType;

    //
    // Extract pointers to workset group, workset and object record from
    // the packet:
    //
    rc = PreProcessMessage(pDomain,
                           pHeader->wsGroupID,
                           pHeader->worksetID,
                           &pHeader->objectID,
                           pHeader->header.messageType,
                           &pWSGroup,
                           &pWorkset,
                           &pObj);

    //
    // PreProcess will have told us if it didn't find the relevant workset
    // group, workset or object.  Whether or not this is an error depends
    // on the operation in question.  We use a series of IF statements to
    // detect and handle the following conditions:
    //
    //
    // 1. Unknown workset group                     Discard the operation
    //
    // 2. Existing workset, WORKSET_NEW/CATCHUP     Discard the operation
    // 3. Unknown workset, any other operation      Bounce the operation
    //
    // 4. Deleted object, any operation             Discard the operation
    // 5. Existing object, OBJECT_ADD/CATCHUP       Discard the operation
    // 6. Unknown object, any other operation       Bounce the operation
    //
    //

    //
    // Test 1.:
    //
    if (rc == OM_RC_WSGROUP_NOT_FOUND)
    {
        //
        // If we didn't even find the workset group, we just quit:
        //
        WARNING_OUT(( "Message is for unknown WSG (ID: %hu) in Domain %u",
            pHeader->wsGroupID, pDomain->callID));
        rc = 0;

        //
        // Mark the data memory allocated for this object to be freed.
        //
        freeMemory = TRUE;

        DC_QUIT;
    }

    //
    // Test 2.:
    //
    if (rc != OM_RC_WORKSET_NOT_FOUND)            // i.e. existing workset
    {
        if ((messageType == OMNET_WORKSET_NEW) ||
            (messageType == OMNET_WORKSET_CATCHUP))
        {
           //
           // We've got a WORKSET_NEW or WORKSET_CATCHUP message, but the
           // workset already exists.  This is not a problem - we throw the
           // message away - but check the priority and persistence fields
           // are set to the right values.
           //
           // (They might be wrong if we created the workset on receipt of
           // a lock request for a workset we didn't already have).
           //
           TRACE_OUT((
                    "Recd WORKSET_NEW/CATCHUP for extant workset %u in WSG %d",
                    pWorkset->worksetID, pWSGroup->wsg));

           pWorkset->priority = *((NET_PRIORITY *) &(pHeader->position));
           pWorkset->fTemp   = *((BOOL  *) &(pHeader->objectID));

           rc = 0;
           DC_QUIT;
        }
    }

    //
    // Test 3.:
    //
    else // rc == OM_RC_WORKSET_NOT_FOUND
    {
        if ((messageType != OMNET_WORKSET_NEW) &&
            (messageType != OMNET_WORKSET_CATCHUP))
        {
            //
            // Packet is for unknown workset and it's not a
            // WORKSET_NEW/CATCHUP, so bounce it:
            //
            TRACE_OUT(( "Bouncing message for unknown workset %d WSG %d",
                pHeader->worksetID, pWSGroup->wsg));

            BounceMessage(pDomain, pReceiveCB);
            bounced = TRUE;
            rc = 0;
            DC_QUIT;
        }
    }

    //
    // Test 4:.
    //
    if ((rc == OM_RC_OBJECT_DELETED) || (rc == OM_RC_OBJECT_PENDING_DELETE))
    {
        //
        // Packet is for object which has been deleted, so we just throw it
        // away (done for us by our caller):
        //
        TRACE_OUT(("Message 0x%08x for deleted obj 0x%08x:0x%08x in WSG %d:%hu",
            messageType,
            pHeader->objectID.creator, pHeader->objectID.sequence,
            pWSGroup->wsg,     pWorkset->worksetID));
        rc = 0;

        //
        // Mark the data memory allocated for this object to be freed.
        //
        freeMemory = TRUE;

        DC_QUIT;
    }

    //
    // Test 5.:
    //
    if (rc != OM_RC_BAD_OBJECT_ID)                // i.e. existing object
    {
        if ((messageType == OMNET_OBJECT_ADD) ||
            (messageType == OMNET_OBJECT_CATCHUP))
        {
            //
            // In this case, we DO have an OBEJCT_ADD/CATCHUP, but the
            // object was found anyway!  This must be a duplicate Add, so
            // we just throw it away:
            //
            TRACE_OUT(( "Add for existing object 0x%08x:0x%08x in WSG %d:%hu",
                pHeader->objectID.creator, pHeader->objectID.sequence,
                pWSGroup->wsg,     pWorkset->worksetID));
            rc = 0;

            //
            // Mark the data memory allocated for this object to be freed.
            //
            freeMemory = TRUE;

            DC_QUIT;
        }
    }

    //
    // Test 6.:
    //
    else // rc == OM_RC_BAD_OBJECT_ID
    {
        if ((messageType != OMNET_OBJECT_ADD) &&
            (messageType != OMNET_OBJECT_CATCHUP))
        {
            //
            // Packet is for unknown object, but it's not an
            // OBJECT_ADD/CATCHUP, so bounce it:
            //
            TRACE_OUT(( "Message 0x%08x for unknown obj 0x%08x:0x%08x in WSG %d:%hu",
                messageType,
                pHeader->objectID.creator, pHeader->objectID.sequence,
                pWSGroup->wsg,     pWorkset->worksetID));

            BounceMessage(pDomain, pReceiveCB);
            bounced = TRUE;
            rc = 0;
            DC_QUIT;
        }
    }

    //
    // OK, we've passed all the tests above, so we must be in a position to
    // process the operation.  Switch on the message type and invoke the
    // appropriate function:
    //
    switch (messageType)
    {
        case OMNET_LOCK_NOTIFY:
        {
            ProcessLockNotify(pomPrimary,
                              pDomain,
                              pWSGroup,
                              pWorkset,
                              ((POMNET_LOCK_PKT)pHeader)->data1);
        }
        break;

        case OMNET_UNLOCK:
        {
            ProcessUnlock(pomPrimary,
                          pWorkset,
                          pHeader->header.sender);
        }
        break;

        case OMNET_WORKSET_CATCHUP:
        case OMNET_WORKSET_NEW:
        {
            rc = ProcessWorksetNew(pomPrimary->putTask, pHeader, pWSGroup);

            //
            // We will want to see if any bouncing messages can be
            // processed because of this new workset, so set the reprocess
            // flag:
            //
            retryBounceList = TRUE;
        }
        break;

        case OMNET_WORKSET_CLEAR:
        {
            rc = ProcessWorksetClear(pomPrimary->putTask,
                                     pomPrimary,
                                     pHeader,
                                     pWSGroup,
                                     pWorkset);
        }
        break;

        case OMNET_OBJECT_CATCHUP:
        case OMNET_OBJECT_ADD:
        {
            rc = ProcessObjectAdd(pomPrimary->putTask,
                                  pHeader,
                                  pWSGroup,
                                  pWorkset,
                                  (POM_OBJECTDATA) pData,
                                  &pObj);

            retryBounceList = TRUE;
        }
        break;

        case OMNET_OBJECT_MOVE:
        {
            ProcessObjectMove(pomPrimary->putTask,
                              pHeader,
                              pWorkset,
                              pObj);
        }
        break;

        case OMNET_OBJECT_DELETE:
        case OMNET_OBJECT_REPLACE:
        case OMNET_OBJECT_UPDATE:
        {
            rc = ProcessObjectDRU(pomPrimary->putTask,
                                  pHeader,
                                  pWSGroup,
                                  pWorkset,
                                  pObj,
                                  (POM_OBJECTDATA) pData);
        }
        break;

        default:
        {
            ERROR_OUT(( "Default case in switch (message type: 0x%08x)",
                messageType));
        }
    }

    if (rc != 0)
    {
        ERROR_OUT(( "Error %d processing operation (type: 0x%08x)",
            rc, messageType));
        DC_QUIT;
    }

    TRACE_OUT(("Processed message type 0x%08x", messageType));

DC_EXIT_POINT:

    //
    // Unless we bounced the message, do some cleanup:
    //
    // Note: This must be after DC_EXIT_POINT because we want to do it
    //       even if we didn't process the message (unless we bounced it).
    //
    //       If we haven't bounced the message then we may be able to free
    //       the data depending on the results of the above tests.
    //
    if (bounced == FALSE)
    {
        //
        // Remove the message from the list it's in (either the pending
        // receives list if this message was never bounced or the bounce
        // list if it has been bounced):
        //
        COM_BasedListRemove(&(pReceiveCB->chain));

        //
        // Now free the message and the receive control block (NOT THE
        // DATA!  If there was any, it's just been used for an object
        // add/update etc.)
        //
        UT_FreeRefCount((void**)&pHeader, FALSE);
        UT_FreeRefCount((void**)&pReceiveCB, FALSE);

        //
        // ...unless of course we indicated that we should free the data:
        //
        if (freeMemory)
        {
            if (pData != NULL)
            {
                TRACE_OUT(("Freeing object data at 0x%08x", pData));
                UT_FreeRefCount(&pData, FALSE);
            }
        }
    }
    else
    {
        rc = OM_RC_BOUNCED;
    }

    //
    // If we're not already processing bounced messages, and this message
    // is an "enabling" message (i.e.  a WORKSET_NEW or OBJECT_ADD), then
    // retry the bounce list:
    //
    if ((whatNext == OK_TO_RETRY_BOUNCE_LIST) &&
        (retryBounceList))
    {
        ProcessBouncedMessages(pomPrimary, pDomain);
    }

    DebugExitDWORD(ProcessMessage, rc);
    return(rc);

}




//
// BounceMessage()
//
void BounceMessage
(
    POM_DOMAIN      pDomain,
    POM_RECEIVE_CB  pReceiveCB
)
{
    UINT            count;

    DebugEntry(BounceMessage);

    TRACE_OUT(( "Bouncing message type 0x%08x (CB at 0x%08x)",
        pReceiveCB->pHeader->header.messageType, pReceiveCB));

    //
    // Remove this receive CB from whichever list its currently in (either
    // the list of pending receives if this is the first time it's been
    // bounced or the bounce list if not) and insert it at the START of the
    // bounce list for the Domain:
    //
    // Note: the reason why we insert at the start is because
    //       ProcessBouncedMessages may be chaining through the list and
    //       we don't want to put this one back in the list at a later
    //       point or else we might go infinite.
    //

    COM_BasedListRemove(&(pReceiveCB->chain));
    COM_BasedListInsertAfter(&(pDomain->bounceList), &(pReceiveCB->chain));

    DebugExitVOID(BounceMessage);
}


//
//
//
// ProcessBouncedMessages(...)
//
//
//

void ProcessBouncedMessages(POM_PRIMARY      pomPrimary,
                                         POM_DOMAIN     pDomain)
{
    UINT          count;
    POM_RECEIVE_CB    pReceiveCB;
    POM_RECEIVE_CB    pTempReceiveCB;
    BOOL            listGettingShorter;
    UINT          numPasses;
    UINT          rc;

    DebugEntry(ProcessBouncedMessages);

    TRACE_OUT(( "Processing bounced messages"));

    //
    // It is important that we process bounced messages as soon as we are
    // able.  Since processing one may enable others to be processed, we
    // must go through the list several times, until we can't do any more
    // work on it.  So, we keep track of whether the list is getting shorter
    // - if it is, we must have processed something so it's worth going
    // through again.
    //
    // Note: an alternative would be do do exactly three passes through the
    //       list: one to do all the WORKSET_NEWs, then one to do all the
    //       OBJECT_ADDs and then one to do any remaining operations.  This
    //       is slightly less generic code and is tied in to the current
    //       dependencies between operations so is not ideal but it may
    //       prove to be a good performance improvement if the average
    //       number of passes we do now exceeds three.
    //

    listGettingShorter = TRUE;
    numPasses = 0;

    pReceiveCB = (POM_RECEIVE_CB)COM_BasedListFirst(&(pDomain->bounceList), FIELD_OFFSET(OM_RECEIVE_CB, chain));
    while (listGettingShorter)
    {
        numPasses++;
        listGettingShorter = FALSE;

        while (pReceiveCB != NULL)
        {
         //
         // We want to chain through the list of bounced messages and try
         // to process each one.  However, trying to process a message
         // could cause it to be removed from the list (if processed) or
         // added back in at the start (if bounced again).
         //
         // So, we chain NOW to the next one in the list:
         //
         pTempReceiveCB = (POM_RECEIVE_CB)COM_BasedListNext(&(pDomain->bounceList), pReceiveCB,
            FIELD_OFFSET(OM_RECEIVE_CB, chain));

         TRACE_OUT(( "Retrying message type 0x%08x (CB at 0x%08x)",
            pReceiveCB->pHeader->header.messageType, pReceiveCB));

         rc = ProcessMessage(pomPrimary, pReceiveCB, DONT_RETRY_BOUNCE_LIST);
         if (rc != OM_RC_BOUNCED)
         {
            //
            // We processed a message, so set the flag for another run
            // through the list:
            //
            TRACE_OUT(( "Successfully processed bounced message"));

            listGettingShorter = TRUE;
         }

         //
         // Now "chain" on to the next one, using the link we've already
         // set up:
         //

         pReceiveCB = pTempReceiveCB;
      }
    }

    TRACE_OUT(( "Processed as much of bounce list as possible in %hu passes",
      numPasses));

    DebugExitVOID(ProcessBouncedMessages);
}



//
// FreeSendInst(...)
//
void FreeSendInst
(
    POM_SEND_INST   pSendInst
)
{
    DebugEntry(FreeSendInst);

    if (pSendInst->pMessage != NULL)
    {
        UT_FreeRefCount((void**)&(pSendInst->pMessage), FALSE);
    }

    if (pSendInst->pWSGroup != NULL)
    {
        UT_FreeRefCount((void**)&(pSendInst->pWSGroup), FALSE);
    }

    if (pSendInst->pWorkset != NULL)
    {
        UT_FreeRefCount((void**)&(pSendInst->pWorkset), FALSE);
    }

    if (pSendInst->pObj != NULL)
    {
        UT_FreeRefCount((void**)&(pSendInst->pObj), FALSE);
    }

    if (pSendInst->pDataStart != NULL)
    {
        UT_FreeRefCount((void**)&(pSendInst->pDataStart), FALSE);
    }

    //
    // Now free the send instruction itself:
    //
    COM_BasedListRemove(&(pSendInst->chain));
    UT_FreeRefCount((void**)&pSendInst, FALSE);

    DebugExitVOID(FreeSendInst);
}



//
// PreProcessMessage(...)
//
UINT PreProcessMessage
(
    POM_DOMAIN          pDomain,
    OM_WSGROUP_ID       wsGroupID,
    OM_WORKSET_ID       worksetID,
    POM_OBJECT_ID       pObjectID,
    OMNET_MESSAGE_TYPE  messageType,
    POM_WSGROUP       * ppWSGroup,
    POM_WORKSET       * ppWorkset,
    POM_OBJECT        * ppObj
)
{
    POM_WSGROUP         pWSGroup = NULL;
    POM_WORKSET         pWorkset = NULL;
    POM_OBJECT          pObj;
    UINT                rc = 0;

    DebugEntry(PreProcessMessage);

    //
    // OK, we've got some sort of operation message: let's find the workset
    // group it relates to:
    //
    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pDomain->wsGroups),
        (void**)&pWSGroup, FIELD_OFFSET(OM_WSGROUP, chain),
        FIELD_OFFSET(OM_WSGROUP, wsGroupID), (DWORD)wsGroupID,
        FIELD_SIZE(OM_WSGROUP, wsGroupID));

    if (pWSGroup == NULL)
    {
        //
        // This is a message for a workset group which we are not/no longer
        // registered with, so quit (our caller will throw it away):
        //
        rc = OM_RC_WSGROUP_NOT_FOUND;
        DC_QUIT;
    }

    ValidateWSGroup(pWSGroup);

    pWorkset = pWSGroup->apWorksets[worksetID];

    //
    // Check that this set up a valid workset pointer:
    //
    if (pWorkset == NULL)
    {
        rc = OM_RC_WORKSET_NOT_FOUND;
        DC_QUIT;
    }

    ValidateWorkset(pWorkset);

    //
    // Search for the object ID, locking workset group mutex while we do
    // so.
    //
    // Note: if the <pObjectID> parameter is NULL, it means that the caller
    //       doesn't want us to search for the object ID, so we skip this
    //       step
    //
    switch (messageType)
    {
        case OMNET_OBJECT_ADD:
        case OMNET_OBJECT_CATCHUP:
        case OMNET_OBJECT_REPLACE:
        case OMNET_OBJECT_UPDATE:
        case OMNET_OBJECT_DELETE:
        case OMNET_OBJECT_MOVE:
        {
            rc = ObjectIDToPtr(pWorkset, *pObjectID, &pObj);
            if (rc != 0)
            {
                //
                // No object found with this ID (rc is BAD_ID, DELETED or
                // PENDING_DELETE):
                //
                *ppObj = NULL;
            }
            else
            {
                ValidateObject(pObj);
                *ppObj = pObj;
            }
        }
        break;

        default:
        {
            //
            // Do nothing for other messages.
            //
        }
    }


DC_EXIT_POINT:
    *ppWorkset = pWorkset;
    *ppWSGroup = pWSGroup;
    TRACE_OUT(("Pre-processed message for Domain %u", pDomain->callID));

    DebugExitDWORD(PreProcessMessage, rc);
    return(rc);
}



//
// PurgeNonPersistent(...)
//
void PurgeNonPersistent
(
    POM_PRIMARY         pomPrimary,
    POM_DOMAIN          pDomain,
    OM_WSGROUP_ID       wsGroupID,
    NET_UID             userID
)
{
    POM_WSGROUP         pWSGroup;
    POM_WORKSET         pWorkset;
    OM_WORKSET_ID       worksetID;
    POM_OBJECT       pObj;

    DebugEntry(PurgeNonPersistent);

    //
    // Find the workset group which has the specified ID:
    //
    COM_BasedListFind(LIST_FIND_FROM_FIRST, &pDomain->wsGroups,
            (void**)&pWSGroup, FIELD_OFFSET(OM_WSGROUP, chain),
            FIELD_OFFSET(OM_WSGROUP, wsGroupID), (DWORD)wsGroupID,
            FIELD_SIZE(OM_WSGROUP, wsGroupID));

    if (pWSGroup == NULL)
    {
        //
        // SFR5794: Not an error if wsgroup not found - this just means
        // someone has detached who was using a workset group which we were
        // not using.
        //
        TRACE_OUT(("WSGroup %hu not found in domain %u",
            wsGroupID, pDomain->callID));
        DC_QUIT;
    }

    //
    // Chain through each workset in the group - for those that are
    // non-persistent, then chain through each object looking for a match
    // on the user ID of the departed node:
    //
    for (worksetID = 0; worksetID < OM_MAX_WORKSETS_PER_WSGROUP; worksetID++)
    {
        pWorkset = pWSGroup->apWorksets[worksetID];
        if (pWorkset == NULL)
        {
            //
            // Workset with this ID doesn't exist - continue
            //
            continue;
        }

        if (!pWorkset->fTemp)
        {
            //
            // A persistent workset - we don't need to purge it of objects
            //
            continue;
        }

        pObj = (POM_OBJECT)COM_BasedListFirst(&(pWorkset->objects), FIELD_OFFSET(OM_OBJECT, chain));
        while (pObj != NULL)
        {
            ValidateObject(pObj);

            //
            // SFR6353: Don't try to delete the object if it's already
            //          pending delete.
            //
            if (!(pObj->flags & DELETED) &&
                !(pObj->flags & PENDING_DELETE))
            {
                //
                // If this object was added by the departed node, OR if
                // ALL_REMOTES have gone and it was not added by us...
                //
                if ((pObj->objectID.creator == userID) ||
                    ((userID == NET_ALL_REMOTES) &&
                     (pObj->objectID.creator != pDomain->userID)))
                {
                    //
                    // ...delete it:
                    //
                    ObjectDRU(pomPrimary->putTask,
                                   pWSGroup,
                                   pWorkset,
                                   pObj,
                                   NULL,
                                   OMNET_OBJECT_DELETE);
                }
            }

            pObj = (POM_OBJECT)COM_BasedListNext(&(pWorkset->objects), pObj,
                FIELD_OFFSET(OM_OBJECT, chain));
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(PurgeNonPersistent);
}




//
// SetPersonData(...)
//
UINT SetPersonData
(
    POM_PRIMARY         pomPrimary,
    POM_DOMAIN          pDomain,
    POM_WSGROUP         pWSGroup
)
{
    POM_WSGROUP         pOMCWSGroup;
    POM_WORKSET         pOMCWorkset;
    POM_OBJECT          pObjReg;
    POM_WSGROUP_REG_REC pRegObject;
    POM_WSGROUP_REG_REC pNewRegObject;
    UINT                rc = 0;

    DebugEntry(SetPersonData);

    //
    // Set up pointers to the ObManControl workset group and the workset
    // which contains the object to be replaced:
    //
    pOMCWSGroup = GetOMCWsgroup(pDomain);

    if( pOMCWSGroup == NULL)
    {
        TRACE_OUT(("pOMCWSGroup not found"));
        DC_QUIT;
    }

    pOMCWorkset = pOMCWSGroup->apWorksets[pWSGroup->wsGroupID];

    //
    // Set up pointers to the object record and the object data itself:
    //
    pObjReg = pWSGroup->pObjReg;
    ValidateObject(pObjReg);

    pRegObject = (POM_WSGROUP_REG_REC)pObjReg->pData;
    if (!pRegObject)
    {
        ERROR_OUT(("SetPersonData: object 0x%08x has no data", pObjReg));
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }
    ValidateObjectDataWSGREGREC(pRegObject);

    //
    // Allocate some memory for the new object with which we are about to
    // replace the old one:
    //
    pNewRegObject = (POM_WSGROUP_REG_REC)UT_MallocRefCount(sizeof(OM_WSGROUP_REG_REC), TRUE);
    if (!pNewRegObject)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    //
    // Set the fields in the new object to have the same data as the old:
    //
    pNewRegObject->length  = pRegObject->length;
    pNewRegObject->idStamp = pRegObject->idStamp;
    pNewRegObject->userID  = pRegObject->userID;
    pNewRegObject->status  = pRegObject->status;

    //
    // Fill in the person data fields and issue the replace:
    //
    COM_GetSiteName(pNewRegObject->personData.personName,
        sizeof(pNewRegObject->personData.personName));

    rc = ObjectDRU(pomPrimary->putTask,
                  pOMCWSGroup,
                  pOMCWorkset,
                  pObjReg,
                  (POM_OBJECTDATA) pNewRegObject,
                  OMNET_OBJECT_REPLACE);
    if (rc != 0)
    {
        DC_QUIT;
    }

    TRACE_OUT((" Set person data for WSG %d", pWSGroup->wsg));


DC_EXIT_POINT:

    if (rc != 0)
    {
        ERROR_OUT(("Error %d updating own reg object for WSG %d",
            rc, pWSGroup->wsg));
    }

    DebugExitDWORD(SetPersonData, rc);
    return(rc);
}



//
// RemoveInfoObject(...)
//
void RemoveInfoObject
(
    POM_PRIMARY         pomPrimary,
    POM_DOMAIN          pDomain,
    OM_WSGROUP_ID       wsGroupID
)
{
    POM_WSGROUP         pOMCWSGroup;
    POM_WORKSET         pOMCWorkset;
    POM_OBJECT          pObj;

    DebugEntry(RemoveInfoObject);

    //
    // OK, we've got to delete the identification object in workset #0 in
    // ObManControl which identified the workset group.
    //
    pOMCWSGroup = GetOMCWsgroup(pDomain);
    pOMCWorkset = GetOMCWorkset(pDomain, 0);

    //
    // ...search for the WSGROUP_INFO object (by wsGroupID - we don't know
    // the name or function profile so leave them blank):
    //
    FindInfoObject(pDomain, wsGroupID, OMWSG_MAX, OMFP_MAX, &pObj);

    if (pObj == NULL)
    {
        //
        // This should happen only for the local Domain:
        //
        // SFR 2208   : No: This will also happen in a regular call when
        //              the call ends almost as soon as it has begun.  The
        //              sequence of events is as follows:
        //
        //              - on callee, ObMan sends WSG_SEND_REQ to caller
        //              - caller sends REG_REC object, then WORKSET_CATCHUP
        //                then the INFO object we can't find
        //              - callee receives REG_REC then WORKSET_CATHCUP
        //              - call ends and callee enters WSGRemoveFromDomain
        //                which finds the REG_REC then calls us here
        //
        //              Therefore the DC_ABSence of the INFO object is valid
        //              and we just trace an alert:
        //
        // NOTE:        It will also happen when we receive a DELETE from
        //              someone else who is doing the same purge process
        //              as us.
        //
        WARNING_OUT(("No INFO object found for wsGroup %hu", wsGroupID));
        DC_QUIT;
    }
    else
    {
        ValidateObject(pObj);
    }

    //
    // We found an object, so delete it from the workset:
    //
    TRACE_OUT(("Deleting INFO object for wsGroup %hu from domain %u",
        wsGroupID, pDomain->callID));

    ObjectDRU(pomPrimary->putTask,
                   pOMCWSGroup,
                   pOMCWorkset,
                   pObj,
                   NULL,
                   OMNET_OBJECT_DELETE);

DC_EXIT_POINT:
    DebugExitVOID(RemoveInfoObject);
}




//
// RemovePersonObject(...)
//
void RemovePersonObject
(
    POM_PRIMARY             pomPrimary,
    POM_DOMAIN              pDomain,
    OM_WSGROUP_ID           wsGroupID,
    NET_UID                 detachedUserID
)
{
    POM_WSGROUP             pOMCWSGroup;
    POM_WORKSET             pOMCWorkset;
    POM_OBJECT           pObjReg;
    NET_UID                 userIDRemoved;
    POM_WSGROUP_REG_REC     pRegObject;

    DebugEntry(RemovePersonObject);

    //
    // Set up pointers to the ObManControl workset group and the relevant
    // workset within it:
    //
    pOMCWSGroup = GetOMCWsgroup(pDomain);

    if( pOMCWSGroup == NULL)
    {
        TRACE_OUT(("OMC Workset Group not found - no person objects to remove"));
        DC_QUIT;
    }

    pOMCWorkset = pOMCWSGroup->apWorksets[wsGroupID];

    //
    // If there is no such workset, it could be because the workset group
    // has been moved into the local Domain on call end etc.  In this case,
    // just quit out.
    //
    if (pOMCWorkset == NULL)
    {
        TRACE_OUT(("OMC Workset not found - no person objects to remove"));
        DC_QUIT;
    }

    //
    // If detachedUserID is NET_ALL_REMOTES, we've a lot of work to do and
    // we'll do this loop many times - otherwise we'll just do it for a
    // single person object.
    //
    for (;;)
    {
        if (detachedUserID == NET_ALL_REMOTES)
        {
            //
            // This will find ANY person object that's NOT OURS:
            //
            FindPersonObject(pOMCWorkset,
                             pDomain->userID,
                             FIND_OTHERS,
                             &pObjReg);
        }
        else
        {
            //
            // This will find a specific node's person object:
            //
            FindPersonObject(pOMCWorkset,
                             detachedUserID,
                             FIND_THIS,
                             &pObjReg);
        }

        //
        // If we don't find one, get out of the loop:
        //
        if (pObjReg == NULL)
        {
            break;
        }

        ValidateObject(pObjReg);

        //
        // If detachedUserID was NET_ALL_REMOTES, the user ID in the object
        // we're deleting will obviously be different.  So, find out the
        // real user ID from the object we're deleting:
        //
        pRegObject = (POM_WSGROUP_REG_REC)pObjReg->pData;
        if (!pRegObject)
        {
            ERROR_OUT(("RemovePersonObject: object 0x%08x has no data", pObjReg));
        }
        else
        {
            ValidateObjectDataWSGREGREC(pRegObject);

            userIDRemoved = pRegObject->userID;

            //
            // Now delete the object.  If the return code is bad, don't quit -
            // we may still want to delete the info object.
            //
            TRACE_OUT(("Deleting person object for node 0x%08x, wsGroup %hu",
                userIDRemoved, wsGroupID));

            if (ObjectDRU(pomPrimary->putTask,
                       pOMCWSGroup,
                       pOMCWorkset,
                       pObjReg,
                       NULL,
                       OMNET_OBJECT_DELETE) != 0)
            {
                ERROR_OUT(("Error from ObjectDRU - leaving loop"));
                break;
            }
        }
    }


DC_EXIT_POINT:
    DebugExitVOID(RemovePersonObject);
}



//
// WSGRecordFind(...)
//
void WSGRecordFind
(
    POM_DOMAIN      pDomain,
    OMWSG           wsg,
    OMFP            fpHandler,
    POM_WSGROUP *   ppWSGroup
)
{
    POM_WSGROUP     pWSGroup    = NULL;

    DebugEntry(WSGRecordFind);

    //
    // Search for workset group record:
    //

    TRACE_OUT(("Searching WSG list for Domain %u for match on WSG %d FP %d",
      pDomain->callID, wsg, fpHandler));

    pWSGroup = (POM_WSGROUP)COM_BasedListFirst(&(pDomain->wsGroups), FIELD_OFFSET(OM_WSGROUP, chain));
    while (pWSGroup != NULL)
    {
        if ((pWSGroup->wsg == wsg) && (pWSGroup->fpHandler == fpHandler))
        {
            break;
        }

        pWSGroup = (POM_WSGROUP)COM_BasedListNext(&(pDomain->wsGroups), pWSGroup,
            FIELD_OFFSET(OM_WSGROUP, chain));
    }

    //
    // Set up caller's pointer:
    //

    *ppWSGroup = pWSGroup;

    DebugExitVOID(WSGRecordFind);
}



//
// AddClientToWSGList(...)
//
UINT AddClientToWSGList
(
    PUT_CLIENT          putTask,
    POM_WSGROUP         pWSGroup,
    OM_WSGROUP_HANDLE   hWSGroup,
    UINT                mode
)
{
    POM_CLIENT_LIST     pClientListEntry;
    UINT                count;
    UINT                rc     = 0;

    DebugEntry(AddClientToWSGList);

    //
    // Count the number of local primaries registered with the workset
    // group:
    //
    count = 0;

    pClientListEntry = (POM_CLIENT_LIST)COM_BasedListFirst(&(pWSGroup->clients), FIELD_OFFSET(OM_CLIENT_LIST, chain));
    while (pClientListEntry != NULL)
    {
        if (pClientListEntry->mode == PRIMARY)
        {
            count++;
        }

        pClientListEntry = (POM_CLIENT_LIST)COM_BasedListNext(&(pWSGroup->clients), pClientListEntry,
            FIELD_OFFSET(OM_CLIENT_LIST, chain));
    }

    //
    // What we do now depends on whether this is a primary or a secondary
    // registration:
    //

    if (mode == PRIMARY)
    {
        //
        // If a primary, check that no other primaries are present:
        //
        if (count > 0)
        {
            ERROR_OUT(("Can't register TASK 0x%08x with WSG %d as primary: "
                "another primary is already registered",
                putTask, pWSGroup->wsg));
            rc = OM_RC_TOO_MANY_CLIENTS;
            DC_QUIT;
        }
        else
        {
            TRACE_OUT(("%hu primary Clients already registered with WSG %d",
                count, pWSGroup->wsg));
        }
    }
    else // mode == SECONDARY
    {
        if (count == 0)
        {
            WARNING_OUT(("Can't register TASK 0x%08x with WSG %d as secondary: "
                "no primary registered",
                putTask, pWSGroup->wsg));
            rc = OM_RC_NO_PRIMARY;
            DC_QUIT;
        }
    }

    //
    // OK, allocate some memory for the Client's entry in the list:
    //
    pClientListEntry = (POM_CLIENT_LIST)UT_MallocRefCount(sizeof(OM_CLIENT_LIST), TRUE);
    if (!pClientListEntry)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }
    SET_STAMP(pClientListEntry, CLIENTLIST);

    pClientListEntry->putTask = putTask;
    pClientListEntry->hWSGroup = hWSGroup;
    pClientListEntry->mode     = (WORD)mode;

    COM_BasedListInsertBefore(&(pWSGroup->clients), &(pClientListEntry->chain));

    TRACE_OUT(("Added TASK 0x%08x to Client list for WSG %d as %s",
        putTask, pWSGroup->wsg,
        mode == PRIMARY ? "primary" : "secondary"));

DC_EXIT_POINT:
    DebugExitDWORD(AddClientToWSGList, rc);
    return(rc);
}



//
// FindPersonObject(...)
//
void FindPersonObject
(
    POM_WORKSET         pOMCWorkset,
    NET_UID             userID,
    UINT                searchType,
    POM_OBJECT *        ppObjReg
)
{
    BOOL                found =     FALSE;
    POM_OBJECT          pObj;
    POM_WSGROUP_REG_REC pRegObject;
    UINT                rc =        0;

    DebugEntry(FindPersonObject);

    TRACE_OUT(("Searching OMC workset %u for reg obj %sowned by node 0x%08x",
        pOMCWorkset->worksetID, searchType == FIND_THIS ? "" : "not ", userID));

    pObj = (POM_OBJECT)COM_BasedListFirst(&(pOMCWorkset->objects), FIELD_OFFSET(OM_OBJECT, chain));
    while (pObj != NULL)
    {
        ValidateObject(pObj);

        if (pObj->flags & DELETED)
        {
            // Do nothing
        }
        else if (!pObj->pData)
        {
            ERROR_OUT(("FindPersonObject:  object 0x%08x has no data", pObj));
        }
        else
        {
            ValidateObjectData(pObj->pData);
            pRegObject = (POM_WSGROUP_REG_REC)pObj->pData;

            if (pRegObject->idStamp == OM_WSGREGREC_ID_STAMP)
            {
                if (((searchType == FIND_THIS)  &&
                     (pRegObject->userID == userID)) ||
                  ((searchType == FIND_OTHERS) &&
                                              (pRegObject->userID != userID)))
                {
                    //
                    // Got it:
                    //
                    found = TRUE;
                    break;
                }
            }
        }

        pObj = (POM_OBJECT)COM_BasedListNext(&(pOMCWorkset->objects), pObj, FIELD_OFFSET(OM_OBJECT, chain));
    }

    if (found == TRUE)
    {
        *ppObjReg = pObj;
    }
    else
    {
        if (searchType == FIND_THIS)
        {
            TRACE_OUT(("No reg object found for node 0x%08x in workset %u",
                userID, pOMCWorkset->worksetID));
        }

        *ppObjReg = NULL;
    }

    DebugExitVOID(FindPersonObject);
}



//
// PostWorksetNewEvents(...)
//
UINT PostWorksetNewEvents
(
    PUT_CLIENT          putFrom,
    PUT_CLIENT          putTo,
    POM_WSGROUP         pWSGroup,
    OM_WSGROUP_HANDLE   hWSGroup
)
{
    OM_WORKSET_ID       worksetID;
    OM_EVENT_DATA16     eventData16;
    POM_WORKSET         pWorkset;
    UINT                count;
    UINT                rc = 0;

    DebugEntry(PostWorksetNewEvents);

    TRACE_OUT(("Posting WORKSET_NEW events to Client TASK 0x%08x for WSG %d",
        putTo, pWSGroup->wsg));

    count = 0;
    for (worksetID = 0; worksetID < OM_MAX_WORKSETS_PER_WSGROUP; worksetID++)
    {
        pWorkset = pWSGroup->apWorksets[worksetID];

        if (pWorkset != NULL)
        {
            eventData16.hWSGroup   = hWSGroup;
            eventData16.worksetID  = worksetID;

            UT_PostEvent(putFrom, putTo, 0,
                      OM_WORKSET_NEW_IND,
                      *(PUINT) &eventData16,
                      0);

            count++;
        }
    }

    TRACE_OUT(("Posted %hu WORKSET_NEW events (hWSGroup: %hu)", count,
                                                                 hWSGroup));

    DebugExitDWORD(PostWorksetNewEvents, rc);
    return(rc);
}



//
// OM_Register(...)
//
UINT OM_Register
(
    PUT_CLIENT      putTask,
    OMCLI           omType,
    POM_CLIENT *    ppomClient
)
{
    POM_CLIENT      pomClient = NULL;
    UINT            rc  = 0;

    DebugEntry(OM_Register);

    UT_Lock(UTLOCK_OM);

    if (!g_pomPrimary)
    {
        ERROR_OUT(("OM_Register failed; primary doesn't exist"));
        DC_QUIT;
    }

    ValidateOMP(g_pomPrimary);
    ASSERT(omType >= OMCLI_FIRST);
    ASSERT(omType < OMCLI_MAX);

    //
    // Make sure this task isn't registered as an OM client
    //
    pomClient = &(g_pomPrimary->clients[omType]);
    if (pomClient->putTask)
    {
        ERROR_OUT(("OM secondary %d already exists", omType));
        pomClient = NULL;
        rc = OM_RC_ALREADY_REGISTERED;
        DC_QUIT;
    }

    // Bump up ref count on OM primary
    UT_BumpUpRefCount(g_pomPrimary);

    //
    // Fill in the client info
    //
    ZeroMemory(pomClient, sizeof(*pomClient));

    SET_STAMP(pomClient, OCLIENT);
    pomClient->putTask      = putTask;

    COM_BasedListInit(&(pomClient->locks));

    //
    // Register an exit procedure for cleanup
    //
    UT_RegisterExit(putTask, OMSExitProc, pomClient);
    pomClient->exitProcReg = TRUE;

    //
    // Register our hidden event handler for the Client (the parameter to be
    // passed to the event handler is the pointer to the Client record):
    //
    UT_RegisterEvent(putTask, OMSEventHandler, pomClient, UT_PRIORITY_OBMAN);
    pomClient->hiddenHandlerReg = TRUE;

DC_EXIT_POINT:
    *ppomClient = pomClient;

    UT_Unlock(UTLOCK_OM);

    DebugExitDWORD(OM_Register, rc);
    return(rc);
}


//
// OM_Deregister()
//
void OM_Deregister(POM_CLIENT * ppomClient)
{
    DebugEntry(OM_Deregister);

    ASSERT(ppomClient);
    OMSExitProc(*ppomClient);
    *ppomClient = NULL;

    DebugExitVOID(OM_Deregister);
}


//
// OMSExitProc(...)
//
void CALLBACK OMSExitProc(LPVOID uData)
{
    POM_CLIENT          pomClient = (POM_CLIENT)uData;
    OM_WSGROUP_HANDLE   hWSGroup;
    OM_WSGROUP_HANDLE   hWSGroupTemp;

    DebugEntry(OMSecExitProc);

    UT_Lock(UTLOCK_OM);

    ValidateOMS(pomClient);

    // Deregister the event handler and exit procedure (we do this early and
    // clear the flags since we want to avoid recursive abends):
    //
    if (pomClient->hiddenHandlerReg)
    {
        UT_DeregisterEvent(pomClient->putTask, OMSEventHandler, pomClient);
        pomClient->hiddenHandlerReg = FALSE;
    }

    if (pomClient->exitProcReg)
    {
        UT_DeregisterExit(pomClient->putTask, OMSExitProc, pomClient);
        pomClient->exitProcReg = FALSE;
    }

    //
    // Deregister the Client from any workset groups with which it is still
    // registered.
    //
    // The code works as follows:
    //
    // FOR each record in the apUsageRecs array
    //     IF there is a valid offset there it refers to a registered
    //        workset group so deregister it.
    //
    TRACE_OUT(("Checking Client record for active workset group handles"));

    for (hWSGroup = 0; hWSGroup < OMWSG_MAXPERCLIENT; hWSGroup++)
    {
        if ((pomClient->apUsageRecs[hWSGroup] != NULL) &&
            (pomClient->apUsageRecs[hWSGroup] != (POM_USAGE_REC)-1))
        {
            //
            // Need to copy hWSGroup into a temporary variable, since
            // OM_WSGroupDeregister will set it to zero and that would
            // mess up our for-loop  otherwise:
            //
            hWSGroupTemp = hWSGroup;
            OM_WSGroupDeregister(pomClient, &hWSGroupTemp);
        }
    }

    //
    // NULL out the task; that's how the OM primary knows the task is
    // present or not.
    //
    pomClient->putTask = NULL;

    UT_FreeRefCount((void**)&g_pomPrimary, TRUE);

    UT_Unlock(UTLOCK_OM);

    DebugExitVOID(OMSExitProc);
}



//
// OMSEventHandler(...)
//
BOOL CALLBACK OMSEventHandler
(
    LPVOID              uData,
    UINT                event,
    UINT_PTR            eventParam1,
    UINT_PTR            eventParam2
)
{
    POM_CLIENT          pomClient = (POM_CLIENT)uData;
    OM_WSGROUP_HANDLE   hWSGroup;
    OM_WORKSET_ID       worksetID;
    POM_OBJECT          pObj;
    UINT                correlator;
    POM_PENDING_OP      pPendingOp =    NULL;
    POM_LOCK            pLock;
    POM_WORKSET         pWorkset;
    UINT                result;
    POM_USAGE_REC       pUsageRec;
    OM_OPERATION_TYPE   type =          NULL_OP;
    BOOL                ObjectEvent =  FALSE;
    BOOL                processed = FALSE;

    DebugEntry(OMSEventHandler);

    UT_Lock(UTLOCK_OM);

    ValidateOMS(pomClient);

    //
    // First check if this is an ObMan event:
    //
    if ((event < OM_BASE_EVENT) || (event > OM_LAST_EVENT))
    {
        DC_QUIT;
    }

    TRACE_OUT(("Processing ObMan event %d (param1: 0x%08x, param2: 0x%08x)",
       event, eventParam1, eventParam2));

    //
    // Extract the fields from the event parameters (some or all of these
    // will be unused, depending on which event this is):
    //
    hWSGroup  = (*(POM_EVENT_DATA16)&eventParam1).hWSGroup;
    worksetID  = (*(POM_EVENT_DATA16)&eventParam1).worksetID;

    correlator = (*(POM_EVENT_DATA32)&eventParam2).correlator;
    result     = (*(POM_EVENT_DATA32)&eventParam2).result;

    pObj    = (POM_OBJECT) eventParam2;

    //
    // ObMan guarantees not to deliver out of date events to client e.g.
    // workset open events for aworkset it has since closed, or object add
    // events for a workset group from which it has deregistered.
    //
    // Filtering these events is the main purpose of this hidden handler
    // function; we check each event and if the workset group handle or
    // object handle are invalid or if the workset is closed, we swallow the
    // event.
    //
    switch (event)
    {
        case OM_OUT_OF_RESOURCES_IND:
        {
            //
            // Do nothing.
            //
        }
        break;

        case OM_WSGROUP_REGISTER_CON:
        {
            //
            // Mark this workset group as valid for our client.
            //
            pomClient->wsgValid[hWSGroup] = TRUE;

            ASSERT(ValidWSGroupHandle(pomClient, hWSGroup));

            pUsageRec = pomClient->apUsageRecs[hWSGroup];

            TRACE_OUT(("REGISTER_CON arrived for wsg %d (result %u, hWSGroup %u)",
                pUsageRec->pWSGroup->wsg, result, hWSGroup));

            if (result != 0)
            {
                //
                // The registration has failed, so call WSGroupDeregister to
                // free up all the resources, then quit:
                //
                WARNING_OUT(("Registration failed for wsg %d, deregistering",
                    pUsageRec->pWSGroup->wsg));

                OM_WSGroupDeregister(pomClient, &hWSGroup);
                DC_QUIT;
            }
        }
        break;

        case OMINT_EVENT_WSGROUP_DEREGISTER:
        {
            //
            // This event is designed to flush the Client's message queue of
            // all events relating to a particular workset group handle.
            //
            // Because this event has arrived, we know there are no more
            // events containing this workset group handle in the queue, so
            // we can safely mark the handle for re-use:
            //
            // So, do a quick sanity check then reset the slot in the array
            // of usage record offsets:
            //
            ASSERT(!pomClient->wsgValid[hWSGroup]);

            TRACE_OUT(("Got WSGROUP_DEREGISTER back marker event for "
               "hWSGroup %u, marking handle as ready for re-use", hWSGroup));

            pomClient->apUsageRecs[hWSGroup] = NULL;

            //
            // ...and swallow the event:
            //
            processed = TRUE;
        }
        break;

        case OM_WSGROUP_MOVE_CON:
        case OM_WSGROUP_MOVE_IND:
        case OM_WORKSET_NEW_IND:
        {
            if (!ValidWSGroupHandle(pomClient, hWSGroup))
            {
                TRACE_OUT(("hWSGroup %d is not valid; ignoring event %d",
                    hWSGroup, event));
                processed = TRUE;
                DC_QUIT;
            }
        }
        break;

        case OM_WORKSET_OPEN_CON:
        {
            if (!ValidWSGroupHandle(pomClient, hWSGroup))
            {
                TRACE_OUT(("hWSGroup %d is not valid; ignoring event %d",
                    hWSGroup, event));
                processed = TRUE;
                DC_QUIT;
            }

            //
            // Else mark the workset as open:
            //
            pUsageRec = pomClient->apUsageRecs[hWSGroup];

            TRACE_OUT(("Marking workset %u in wsg %d open for Client 0x%08x",
                worksetID, pUsageRec->pWSGroup->wsg, pomClient));

            WORKSET_SET_OPEN(pUsageRec, worksetID);
        }
        break;

        case OM_WORKSET_UNLOCK_IND:
        {
            if (!ValidWSGroupHandle(pomClient, hWSGroup))
            {
                TRACE_OUT(("hWSGroup %d is not valid; ignoring event %d",
                    hWSGroup, event));
                processed = TRUE;
                DC_QUIT;
            }

            pUsageRec = pomClient->apUsageRecs[hWSGroup];
            if (!WORKSET_IS_OPEN(pUsageRec, worksetID))
            {
                TRACE_OUT(("Workset %u in wsg %d no longer open; ignoring event %d",
                    worksetID, pUsageRec->pWSGroup->wsg, event));
                processed = TRUE;
                DC_QUIT;
            }
        }
        break;

        case OM_WORKSET_CLEAR_IND:
        {
            if (!ValidWSGroupHandle(pomClient, hWSGroup))
            {
                TRACE_OUT(("hWSGroup %d is not valid; ignoring event %d",
                    hWSGroup, event));
                processed = TRUE;
                DC_QUIT;
            }

            pUsageRec = pomClient->apUsageRecs[hWSGroup];
            if (!WORKSET_IS_OPEN(pUsageRec, worksetID))
            {
                TRACE_OUT(("Workset %u in wsg %d no longer open; ignoring event %d",
                    worksetID, pUsageRec->pWSGroup->wsg, event));
                processed = TRUE;
                DC_QUIT;
            }

            //
            // Check if Clear still pending; quit if not:
            //
            pWorkset = pUsageRec->pWSGroup->apWorksets[worksetID];
            ASSERT((pWorkset != NULL));

            FindPendingOp(pWorkset, pObj, WORKSET_CLEAR, &pPendingOp);

            if (pPendingOp == NULL)
            {
                TRACE_OUT(("Clear already confirmed for workset %hu", worksetID));
                processed = TRUE;
                DC_QUIT;
            }
         }
         break;

         case OM_WORKSET_LOCK_CON:
         {
            if (!ValidWSGroupHandle(pomClient, hWSGroup))
            {
                TRACE_OUT(("hWSGroup %d is not valid; ignoring event %d",
                    hWSGroup, event));
                processed = TRUE;
                DC_QUIT;
            }

            pUsageRec = pomClient->apUsageRecs[hWSGroup];
            if (!WORKSET_IS_OPEN(pUsageRec, worksetID))
            {
                TRACE_OUT(("Workset %u in wsg %d no longer open; ignoring event %d",
                    worksetID, pUsageRec->pWSGroup->wsg, event));
                processed = TRUE;
                DC_QUIT;
            }

            //
            // Search for the lock on the lock stack:
            //
            COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pomClient->locks),
                (void**)&pLock, FIELD_OFFSET(OM_LOCK, chain),
                FIELD_OFFSET(OM_LOCK, worksetID), (DWORD)worksetID,
                FIELD_SIZE(OM_LOCK, worksetID));

            //
            // If the lock is not present on the lock stack, then the Client
            // must have called Unlock since it called LockReq.  So, we
            // swallow the event:
            //
            if (pLock == NULL)
            {
                TRACE_OUT(("Lock already cancelled for workset %hu", worksetID));
                processed = TRUE;
                DC_QUIT;
            }

            //
            // When object locking supported, the first lock which matches
            // on worksetID might not be the workset lock, so more code will
            // be needed here then.  In the meantime, just assert:
            //
            ASSERT((OBJECT_ID_IS_NULL(pLock->objectID)));

            //
            // If lock request failed, remove the lock from the Client's
            // lock stack:
            //
            if (result != 0)
            {
                TRACE_OUT(("Lock failed; removing lock from Client's lock stack"));

                COM_BasedListRemove(&pLock->chain);
                UT_FreeRefCount((void**)&pLock, FALSE);
            }
        }
        break;

        case OM_OBJECT_ADD_IND:
        case OM_OBJECT_MOVE_IND:
        {
            ObjectEvent = TRUE;

            if (!ValidWSGroupHandle(pomClient, hWSGroup))
            {
                TRACE_OUT(("hWSGroup %d is not valid; ignoring event %d",
                    hWSGroup, event));
                processed = TRUE;
                DC_QUIT;
            }

            pUsageRec = pomClient->apUsageRecs[hWSGroup];
            if (!WORKSET_IS_OPEN(pUsageRec, worksetID))
            {
                TRACE_OUT(("Workset %u in wsg %d no longer open; ignoring event %d",
                    worksetID, pUsageRec->pWSGroup->wsg, event));
                processed = TRUE;
                DC_QUIT;
            }

            if (!ValidObject(pObj) || (pObj->flags & DELETED))
            {
                processed = TRUE;
                DC_QUIT;
            }

            pUsageRec = pomClient->apUsageRecs[hWSGroup];
            pWorkset = pUsageRec->pWSGroup->apWorksets[worksetID];
            ASSERT((pWorkset != NULL));

            if (WorksetClearPending(pWorkset, pObj))
            {
                TRACE_OUT(("Event %hu for object 0x%08x will be swallowed since "
                   "object about to be cleared from the workset",
                   event, pObj));
                processed = TRUE;
                DC_QUIT;
            }
        }
        break;

        case OM_OBJECT_DELETE_IND:
        case OM_OBJECT_REPLACE_IND:
        case OM_OBJECT_UPDATE_IND:
        {
            ObjectEvent = TRUE;

            switch (event)
            {
                case OM_OBJECT_DELETE_IND:
                    type = OBJECT_DELETE;
                    break;

                case OM_OBJECT_REPLACE_IND:
                    type = OBJECT_REPLACE;
                    break;

                case OM_OBJECT_UPDATE_IND:
                    type = OBJECT_UPDATE;
                    break;

                default:
                    ERROR_OUT(("Reached default case in switch"));
            }

            //
            // Check workset group handle is still valid, workset is still
            // open and object handle is still valid; if not, swallow event:
            //
            if (!ValidWSGroupHandle(pomClient, hWSGroup))
            {
                TRACE_OUT(("hWSGroup %d is not valid; ignoring event %d",
                    hWSGroup, event));
                processed = TRUE;
                DC_QUIT;
            }

            pUsageRec = pomClient->apUsageRecs[hWSGroup];
            if (!WORKSET_IS_OPEN(pUsageRec, worksetID))
            {
                TRACE_OUT(("Workset %u in wsg %d no longer open; ignoring event %d",
                    worksetID, pUsageRec->pWSGroup->wsg, event));
                processed = TRUE;
                DC_QUIT;
            }

            //
            // We also want to quit if the object is no longer valid or if
            // there is a clear pending (just as for ADD/MOVE) but if we do
            // so, we will also need to remove the pending op from the list.
            // So, find the op now; if we quit and swallow the event, the
            // function exit code will do the remove (this saves having to
            // break up the QUIT_IF...  macros for this special case).
            //
            // So, check the pending op list:
            //
            pWorkset = pUsageRec->pWSGroup->apWorksets[worksetID];
            ASSERT((pWorkset != NULL));

            FindPendingOp(pWorkset, pObj, type, &pPendingOp);
            if (pPendingOp == NULL)
            {
                TRACE_OUT(("Operation type %hu already confirmed for object 0x%08x",
                    type, pObj));
                processed = TRUE;
                DC_QUIT;
            }

            if (!ValidObject(pObj) || (pObj->flags & DELETED))
            {
                processed = TRUE;
                DC_QUIT;
            }

            if (WorksetClearPending(pWorkset, pObj))
            {
                TRACE_OUT(("Event %hu for object 0x%08x will be swallowed since "
                   "object about to be cleared from the workset",
                   event, pObj));
                processed = TRUE;
                DC_QUIT;
            }
         }
         break;

         case OM_WORKSET_CLEARED_IND:
         case OM_OBJECT_DELETED_IND:
         case OM_OBJECT_UPDATED_IND:
         case OM_OBJECT_REPLACED_IND:
         {
            //
            // All of these except the CLEARED_IND are object events:
            //
            if (event != OM_WORKSET_CLEARED_IND)
            {
                ObjectEvent = TRUE;
            }

            //
            // These are secondary API events.  Swallow them if the workset
            // is closed, but DO NOT swallow if object handle invalid (since
            // we don't make guarantees about validity of handles passed in
            // these events):
            //
            if (!ValidWSGroupHandle(pomClient, hWSGroup))
            {
                TRACE_OUT(("hWSGroup %d is not valid; ignoring event %d",
                    hWSGroup, event));
                processed = TRUE;
                DC_QUIT;
            }

            pUsageRec = pomClient->apUsageRecs[hWSGroup];
            if (!WORKSET_IS_OPEN(pUsageRec, worksetID))
            {
                TRACE_OUT(("Workset %u in WSG %d no longer open; ignoring event %d",
                    worksetID, pUsageRec->pWSGroup->wsg, event));
                processed = TRUE;
                DC_QUIT;
            }
        }
        break;

        case OM_PERSON_JOINED_IND:
        case OM_PERSON_LEFT_IND:
        case OM_PERSON_DATA_CHANGED_IND:
        {
            if (!ValidWSGroupHandle(pomClient, hWSGroup))
            {
                TRACE_OUT(("hWSGroup %d is not valid; ignoring event %d",
                    hWSGroup, event));
                processed = TRUE;
                DC_QUIT;
            }
        }
        break;

        default:
        {
            ERROR_OUT(("Unrecognised ObMan event 0x%08x", event));
        }
    }

DC_EXIT_POINT:

    //
    // Whenever an event containing an object handle is posted, the use
    // count of the object record is bumped, so we free it now:
    //
    if (ObjectEvent)
    {
        ValidateObject(pObj);
        UT_FreeRefCount((void**)&pObj, FALSE);
    }

    UT_Unlock(UTLOCK_OM);

    DebugExitBOOL(OMSEventHandler, processed);
    return(processed);
}


//
// OM_WSGroupRegisterS(...)
//
UINT OM_WSGroupRegisterS
(
    POM_CLIENT          pomClient,
    UINT                callID,
    OMFP                fpHandler,
    OMWSG               wsg,
    OM_WSGROUP_HANDLE * phWSGroup
)
{
    POM_DOMAIN          pDomain;
    POM_WSGROUP         pWSGroup;
    POM_USAGE_REC       pUsageRec;
    POM_CLIENT_LIST     pClientListEntry;
    BOOL                setUpUsageRec   = FALSE;
    UINT                rc = 0;

    DebugEntry(OM_WSGroupRegisterS);

    UT_Lock(UTLOCK_OM);

    //
    // Validate params:
    //
    ValidateOMS(pomClient);

    //
    // Search for this Domain and workset group:
    //
    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(g_pomPrimary->domains),
        (void**)&pDomain, FIELD_OFFSET(OM_DOMAIN, chain),
        FIELD_OFFSET(OM_DOMAIN, callID), (DWORD)callID,
        FIELD_SIZE(OM_DOMAIN, callID));

    if (pDomain == NULL)
    {
        //
        // We don't have a record for this Domain so there can be no primary
        // registered with the workset group:
        //
        TRACE_OUT(("Not attached to Domain %u", callID));
        rc = OM_RC_NO_PRIMARY;
        DC_QUIT;
    }

    WSGRecordFind(pDomain, wsg, fpHandler, &pWSGroup);
    if (pWSGroup == NULL)
    {
        rc = OM_RC_NO_PRIMARY;
        DC_QUIT;
    }

    //
    // If we get here, then the workset group exists locally so see if the
    // Client is already registered with it:
    //
    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pWSGroup->clients),
            (void**)&pClientListEntry, FIELD_OFFSET(OM_CLIENT_LIST, chain),
            FIELD_OFFSET(OM_CLIENT_LIST, putTask), (DWORD_PTR)pomClient->putTask,
            FIELD_SIZE(OM_CLIENT_LIST, putTask));

    if (pClientListEntry != NULL)
    {
        rc = OM_RC_ALREADY_REGISTERED;
        ERROR_OUT(("Can't register Client 0x%08x with WSG %d - already registered",
            pomClient, wsg));
        DC_QUIT;
    }

    //
    // OK, Client is not already registered so register it now:
    //
    rc = SetUpUsageRecord(pomClient, SECONDARY, &pUsageRec, phWSGroup);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // SetUpUsageRecord doesn't put the workset group pointer in the CB
    // (since it's not known yet in the case of a PRIMARY registration), so
    // we do this now ourselves:
    //
    pUsageRec->pWSGroup = pWSGroup;

    setUpUsageRec = TRUE;

    //
    // add this Client to the workset group's Client list:
    //
    rc = AddClientToWSGList(pomClient->putTask,
                            pWSGroup,
                            *phWSGroup,
                            SECONDARY);
    if (rc != 0)
    {
        DC_QUIT;
    }

    pUsageRec->flags |= ADDED_TO_WSGROUP_LIST;

    pomClient->wsgValid[*phWSGroup] = TRUE;

    //
    // Post WORKSET_NEW events to the Client for the worksets in the group,
    // if any:
    //
    PostWorksetNewEvents(pomClient->putTask, pomClient->putTask,
            pWSGroup, *phWSGroup);

    TRACE_OUT(("Registered 0x%08x as secondary Client for WSG %d (hWSGroup: %hu)",
       pomClient, wsg, *phWSGroup));

DC_EXIT_POINT:

    if (rc != 0)
    {
        if (rc == OM_RC_NO_PRIMARY)
        {
            //
            // We do a regular trace here rather than an error because this
            // happens normally:
            //

            TRACE_OUT(("No primary Client for WSG %d in Domain %u "
                "- can't register secondary", wsg, callID));
        }
        else
        {
            ERROR_OUT(("Error %d registering Client 0x%08x as secondary"
                "for WSG %d in Domain %u",
             rc, pomClient, wsg, callID));
        }

        if (setUpUsageRec == TRUE)
        {
            pomClient->apUsageRecs[*phWSGroup] = NULL;

            if (pUsageRec->flags & ADDED_TO_WSGROUP_LIST)
            {
                RemoveClientFromWSGList(pomClient->putTask, pomClient->putTask, pWSGroup);
            }

            UT_FreeRefCount((void**)&pUsageRec, FALSE);
        }

        pomClient->wsgValid[*phWSGroup] = FALSE;
    }

    UT_Unlock(UTLOCK_OM);

    DebugExitDWORD(OM_WSGroupRegisterS, rc);
    return(rc);
}



//
// OM_WorksetOpenS(...)
//
UINT OM_WorksetOpenS
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID
)
{
    POM_WSGROUP          pWSGroup;
    POM_WORKSET          pWorkset;
    POM_USAGE_REC        pUsageRec;
    POM_CLIENT_LIST      pClientListEntry   = NULL;
    UINT                 rc = 0;

    DebugEntry(OM_WorksetOpenS);

    UT_Lock(UTLOCK_OM);

    //
    // Validate params:
    //
    ValidateParams2(pomClient, hWSGroup, SECONDARY, &pUsageRec, &pWSGroup);

    TRACE_OUT(("Secondary Client 0x%08x requesting to open workset %u in WSG %d",
      pomClient, worksetID, pWSGroup->wsg));

    //
    // If the Client already has this workset open then return a (non-error)
    // return code:
    //

    if (WORKSET_IS_OPEN(pUsageRec, worksetID) == TRUE)
    {
        TRACE_OUT(("Client 0x%08x already has workset %u in WSG %d open",
            pomClient, worksetID, pWSGroup->wsg));
        rc = OM_RC_WORKSET_ALREADY_OPEN;
        DC_QUIT;
    }

    //
    // Check workset group record to see if workset exists:
    //

    if (pWSGroup->apWorksets[worksetID] == NULL)
    {
        //
        // Workset doesn't exist so return bad rc:
        //
        WARNING_OUT(("Workset %hu doesn't exist in WSG %d",
            worksetID, pWSGroup->wsg));
        rc = OM_RC_WORKSET_DOESNT_EXIST;
        DC_QUIT;
    }
    else
    {
        //
        // Workset already exists, so we don't need to do anything.
        //
        TRACE_OUT((" Workset %hu in WSG %d already exists",
            worksetID, pWSGroup->wsg));
    }

    //
    // If the workset didn't already exist, queueing the send instruction
    // will have caused the workset to be created syncrhonously.  So, either
    // way the workset exists at this point.
    //

    //
    // Get a pointer to the workset:
    //

    pWorkset = pWSGroup->apWorksets[worksetID];

    ASSERT((pWorkset != NULL));

    //
    // Mark this workset as open in the Client's usage record:
    //

    WORKSET_SET_OPEN(pUsageRec, worksetID);

    //
    // Add this Client to the list kept in the workset record:
    //

    rc = AddClientToWsetList(pomClient->putTask,
                            pWorkset,
                            hWSGroup,
                            pUsageRec->mode,
                            &pClientListEntry);
    if (rc != 0)
    {
      DC_QUIT;
    }

    rc = PostAddEvents(pomClient->putTask, pWorkset, hWSGroup, pomClient->putTask);
    if (rc != 0)
    {
      DC_QUIT;
    }

    TRACE_OUT(("Opened workset %u in WSG %d for secondary Client 0x%08x",
      worksetID, pWSGroup->wsg, pomClient));

DC_EXIT_POINT:

    if ((rc != 0) && (rc != OM_RC_WORKSET_ALREADY_OPEN))
    {
        //
        // Cleanup:
        //
        ERROR_OUT(("Error %d opening workset %u in WSG %d for Client 0x%08x",
            rc, worksetID, pWSGroup->wsg, pomClient));

        WORKSET_SET_CLOSED(pUsageRec, worksetID);

        if (pClientListEntry != NULL)
        {
            COM_BasedListRemove(&(pClientListEntry->chain));
            UT_FreeRefCount((void**)&pClientListEntry, FALSE);
        }
    }

    UT_Unlock(UTLOCK_OM);

    DebugExitDWORD(OM_WorksetOpenS, rc);
    return(rc);
}



//
// OM_WSGroupRegisterPReq(...)
//
UINT OM_WSGroupRegisterPReq
(
    POM_CLIENT          pomClient,
    UINT                callID,
    OMFP                fpHandler,
    OMWSG               wsg,
    OM_CORRELATOR *     pCorrelator
)
{
    POM_WSGROUP_REG_CB  pRegistrationCB = NULL;
    POM_USAGE_REC       pUsageRec;
    OM_WSGROUP_HANDLE   hWSGroup;
    BOOL                setUpUsageRec   = FALSE;
    UINT                rc = 0;

    DebugEntry(OM_WSGroupRegisterPReq);

    UT_Lock(UTLOCK_OM);

    ValidateOMS(pomClient);

    //
    // Set up a usage record and workset group handle for the Client:
    //

    rc = SetUpUsageRecord(pomClient, PRIMARY, &pUsageRec, &hWSGroup);
    if (rc != 0)
    {
       DC_QUIT;
    }
    setUpUsageRec = TRUE;

    //
    // Create a new correlator for the Client and put it in the Client's
    // variable:
    //

    *pCorrelator = NextCorrelator(g_pomPrimary);

    //
    // Sub alloc a chunk of memory for the registration control block, in
    // which we will pass the registration request parameters to the ObMan
    // task:
    //
    pRegistrationCB = (POM_WSGROUP_REG_CB)UT_MallocRefCount(sizeof(OM_WSGROUP_REG_CB), TRUE);
    if (!pRegistrationCB)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }
    SET_STAMP(pRegistrationCB, REGCB);

    //
    // Fill in the fields, but note that we don't yet know the Domain record
    // or workset group, so we leave those ones blank:
    //
    pRegistrationCB->putTask        = pomClient->putTask;
    pRegistrationCB->callID          = callID;
    pRegistrationCB->correlator      = *pCorrelator;
    pRegistrationCB->hWSGroup        = hWSGroup;
    pRegistrationCB->wsg             = wsg;
    pRegistrationCB->fpHandler       = fpHandler;
    pRegistrationCB->retryCount      = OM_REGISTER_RETRY_COUNT_DFLT;
    pRegistrationCB->valid           = TRUE;
    pRegistrationCB->type            = WSGROUP_REGISTER;
    pRegistrationCB->mode            = PRIMARY;
    pRegistrationCB->pUsageRec       = pUsageRec;

    //
    // Now put a pointer to the registration CB in the usage record, as
    // described above, and set a flag so we know what we've done:
    //

    pUsageRec->pWSGroup = (POM_WSGROUP) pRegistrationCB;
    pUsageRec->flags |= PWSGROUP_IS_PREGCB;

    //
    // Post an event to the ObMan task telling it to process this CB.
    //
    // The first parameter is the retry value for the event.
    //
    // The second parameter is the offset of the control block in the OMMISC
    // memory block.
    //

    UT_PostEvent(pomClient->putTask,        // Client's putTask
                 g_pomPrimary->putTask,        // ObMan's putTask
                 0,
                 OMINT_EVENT_WSGROUP_REGISTER,
                 0,
                 (UINT_PTR)pRegistrationCB);

    TRACE_OUT(("Requested to register Client 0x%08x with WSG %d",
       pomClient, wsg));

DC_EXIT_POINT:

    if (rc != 0)
    {
        ERROR_OUT(("Error 0x%08x registering Client 0x%08x with WSG %d",
            rc, pomClient, wsg));

        if (pRegistrationCB != NULL)
        {
            //
            // We can free the reg CB safely since we know that if we hit an
            // error, we never got around to inserting the item in the list or
            // posting its offset to the ObMan task:
            //
            UT_FreeRefCount((void**)&pRegistrationCB, FALSE);
        }

        if (setUpUsageRec)
        {
            UT_FreeRefCount((void**)&pUsageRec, FALSE);
            pomClient->apUsageRecs[hWSGroup] = NULL;
        }
    }

    UT_Unlock(UTLOCK_OM);

    DebugExitDWORD(OM_WSGroupRegisterPReq, rc);
    return(rc);
}



//
// OM_WSGroupMoveReq(...)
//
UINT OM_WSGroupMoveReq
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    UINT                callID,
    OM_CORRELATOR *     pCorrelator
)
{
    POM_USAGE_REC       pUsageRec;
    POM_WSGROUP         pWSGroup;
    POM_DOMAIN          pDomain;
    POM_WSGROUP_REG_CB  pRegistrationCB    = NULL;
    UINT                rc = 0;

    DebugEntry(OM_WSGroupMoveReq);

    UT_Lock(UTLOCK_OM);

    ValidateParams2(pomClient, hWSGroup, PRIMARY, &pUsageRec, &pWSGroup);

    TRACE_OUT(("Client 0x%08x requesting to move WSG %d into Domain %u",
        pomClient, hWSGroup, callID));

    //
    // Check workset group is not already in a Call: (this may be relaxed)
    //
    pDomain = pWSGroup->pDomain;

    if (pDomain->callID != OM_NO_CALL)
    {
        ERROR_OUT(("Client 0x%08x attempted to move WSG %d out of a call "
            "(Domain %u)",
            pomClient, hWSGroup, pDomain->callID));
        rc = OM_RC_ALREADY_IN_CALL;
        DC_QUIT;
    }

    //
    // Create a correlator, to correlate the MOVE_CON event:
    //
    *pCorrelator = NextCorrelator(g_pomPrimary);

    //
    // Create a control block to pass the relevant info to ObMan:
    //
    pRegistrationCB = (POM_WSGROUP_REG_CB)UT_MallocRefCount(sizeof(OM_WSGROUP_REG_CB), TRUE);
    if (!pRegistrationCB)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }
    SET_STAMP(pRegistrationCB, REGCB);

    //
    // Fill in the fields:
    //
    pRegistrationCB->putTask        = pomClient->putTask;
    pRegistrationCB->callID          = callID;        // DESTINATION Domain!
    pRegistrationCB->correlator      = *pCorrelator;
    pRegistrationCB->hWSGroup        = hWSGroup;
    pRegistrationCB->wsg             = pWSGroup->wsg;
    pRegistrationCB->fpHandler       = pWSGroup->fpHandler;
    pRegistrationCB->retryCount      = OM_REGISTER_RETRY_COUNT_DFLT;
    pRegistrationCB->valid           = TRUE;
    pRegistrationCB->type            = WSGROUP_MOVE;
    pRegistrationCB->mode            = pUsageRec->mode;
    pRegistrationCB->pWSGroup        = pWSGroup;

    //
    // Post an event to ObMan requesting it to process the CB:
    //
    UT_PostEvent(pomClient->putTask,
                g_pomPrimary->putTask,
                0,                                   // no delay
                OMINT_EVENT_WSGROUP_MOVE,
                0,
                (UINT_PTR)pRegistrationCB);

    TRACE_OUT(("Requested to move WSG %d into Domain %u for Client 0x%08x",
        hWSGroup, callID, pomClient));

DC_EXIT_POINT:

    if (rc != 0)
    {
        ERROR_OUT(("Error 0x%08x requesting to move WSG %d into Domain %u",
            rc, hWSGroup, callID));

        if (pRegistrationCB != NULL)
        {
            UT_FreeRefCount((void**)&pRegistrationCB, FALSE);
        }
    }

    UT_Unlock(UTLOCK_OM);

    DebugExitDWORD(OM_WSGroupMoveReq, rc);
    return(rc);
}



//
// OM_WSGroupDeregister(...)
//
void OM_WSGroupDeregister
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE * phWSGroup
)
{
    POM_WSGROUP         pWSGroup;
    POM_USAGE_REC       pUsageRec;
    OM_WORKSET_ID       worksetID;
    OM_EVENT_DATA16     eventData16;
    OM_WSGROUP_HANDLE   hWSGroup;

    DebugEntry(OM_WSGroupDeregister);

    UT_Lock(UTLOCK_OM);

    ValidateOMS(pomClient);

    hWSGroup = *phWSGroup;

    //
    // If this function has been called because of an abortive
    // WSGroupRegister, or from OM_Deregister, the wsg might not yet be
    // marked as VALID, so we check here and set it to VALID.
    //
    if (!pomClient->wsgValid[hWSGroup])
    {
        TRACE_OUT(("Deregistering Client before registration completed"));
        pomClient->wsgValid[hWSGroup] = TRUE;
    }

    // lonchanc: bug #1986, make sure we have a valid wsg.
    // pWSGroup can be invalid in a race condition that we hang up
    // before Whiteboard initializes.
    pUsageRec = NULL; // make sure this local is reset in case we bail out from here.

    if (!ValidWSGroupHandle(pomClient, hWSGroup) ||
        (pomClient->apUsageRecs[hWSGroup] == (POM_USAGE_REC)-1))
    {
        ERROR_OUT(("OM_WSGroupDeregister: Invalid wsg=0x0x%08x", hWSGroup));
        DC_QUIT;
    }

    //
    // Get a pointer to the associated usage record:
    //
    pUsageRec = pomClient->apUsageRecs[hWSGroup];

    //
    // Extract a Client pointer to the workset group from the usage record:
    //
    pWSGroup = pUsageRec->pWSGroup;

    //
    // Test the flag in the usage record to see whether the <pWSGroup> field
    // is actually pointing to the registration CB (which will be the case
    // if we are deregistering immediately after registering):
    //
    if (pUsageRec->flags & PWSGROUP_IS_PREGCB)
    {
        //
        // Mark the registration CB as invalid in order to abort the
        // registration (ObMan will test for this in ProcessWSGRegister):
        //
        // Note: the pWSGroup field of the usage record is actually a pointer
        //       to a registration CB in this case
        //
        TRACE_OUT(("Client deregistering before registration even started - aborting"));
        ((POM_WSGROUP_REG_CB)pUsageRec->pWSGroup)->valid = FALSE;
        DC_QUIT;
    }

    //
    // Check the workset group record is valid:
    //
    ValidateWSGroup(pWSGroup);

    //
    // If it is valid, we continue with the deregistration process:
    //
    TRACE_OUT(("Deregistering Client 0x%08x from WSG %d", pomClient, hWSGroup));

    //
    // Close all the worksets in the group that the Client has open:
    //
    for (worksetID = 0; worksetID < OM_MAX_WORKSETS_PER_WSGROUP; worksetID++)
    {
        if (WORKSET_IS_OPEN(pUsageRec, worksetID))
        {
            OM_WorksetClose(pomClient, hWSGroup, worksetID);
        }
    }

    //
    // If we added this Client to the workset group's Client list, find it
    // again and remove it:
    //
    if (pUsageRec->flags & ADDED_TO_WSGROUP_LIST)
    {
        TRACE_OUT(("Removing Client from workset group list"));
        RemoveClientFromWSGList(pomClient->putTask, pomClient->putTask, pWSGroup);
        pUsageRec->flags &= ~ADDED_TO_WSGROUP_LIST;
    }
    else
    {
        TRACE_OUT(("Client not added to wsGroup list, not removing"));
    }

    TRACE_OUT(("Deregistered Client 0x%08x from WSG %d",  pomClient, hWSGroup));

DC_EXIT_POINT:
    //
    // Free the usage record (we put this after the DC_QUIT since we want to
    // do this even if the workset group pointer was found to be invalid
    // above):
    //
    UT_FreeRefCount((void**)&pUsageRec, FALSE);

    //
    // Mark the workset group handle as invalid, so that any events which
    // the Client gets will be swallowed:
    //
    pomClient->wsgValid[hWSGroup] = FALSE;

    //
    // Note: we don't set the slot in the usage record offset array to zero,
    //       since we don't want the workset group handle to be reused yet.
    //       When the DEREGISTER events arrives (after flushing the Client's
    //       event queue), we will set the offset to zero.
    //
    //       However, if we leave the offset as it is, OM_Deregister might
    //       call us again because it thinks we haven't yet deregistered
    //       from the workset group.  So, we set it to -1, which ensures
    //       that
    //
    //       a) it is seen as in use by FindUnusedWSGHandle, since that
    //          function checks for 0
    //
    //       b) it is seen as not in use by OM_Deregister, since that
    //          function checks for 0 or -1.
    //
    pomClient->apUsageRecs[hWSGroup] = (POM_USAGE_REC)-1;

    //
    // Send an OMINT_EVENT_WSGROUP_DEREGISTER event to the hidden handler (which
    // will swallow it) to flush the Client's message queue:
    //

    TRACE_OUT(("Posting WSGROUP_DEREGISTER event to Client's hidden handler"));

    eventData16.hWSGroup    = hWSGroup;
    eventData16.worksetID = 0;

    UT_PostEvent(pomClient->putTask,
                pomClient->putTask,
                0,
                OMINT_EVENT_WSGROUP_DEREGISTER,
                *(PUINT) &eventData16,
                0);

    *phWSGroup = 0;

    UT_Unlock(UTLOCK_OM);

    DebugExitVOID(OM_WSGroupDeregister);
}




//
// OM_WorksetOpenPReq(...)
//
UINT OM_WorksetOpenPReq
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID,
    NET_PRIORITY        priority,
    BOOL                fTemp,
    OM_CORRELATOR *     pCorrelator
)
{
    POM_WSGROUP         pWSGroup;
    POM_WORKSET         pWorkset;
    POM_USAGE_REC       pUsageRec;
    OM_EVENT_DATA16     eventData16;
    OM_EVENT_DATA32     eventData32;
    POM_CLIENT_LIST     pClientListEntry = NULL;
    UINT                rc = 0;

    DebugEntry(OM_WorksetOpenPReq);

    UT_Lock(UTLOCK_OM);

    //
    // Validate params:
    //
    ValidateParams2(pomClient, hWSGroup, PRIMARY, &pUsageRec, &pWSGroup);

    TRACE_OUT(("Client 0x%08x opening workset %u in WSG %d at priority 0x%08x",
        pomClient, worksetID, hWSGroup, priority));

    //
    // If the Client already has this workset open then return a (non-error)
    // return code:
    //
    if (WORKSET_IS_OPEN(pUsageRec, worksetID) == TRUE)
    {
        TRACE_OUT(("Client 0x%08x already has workset %hu in WSG %d open",
            pomClient, worksetID, hWSGroup));
        rc = OM_RC_WORKSET_ALREADY_OPEN;
        DC_QUIT;
    }

    //
    // Check the Client has supplied a valid value for <priority>:
    //
    if ((priority < NET_HIGH_PRIORITY) || (priority > NET_LOW_PRIORITY))
    {
        ASSERT((priority == OM_OBMAN_CHOOSES_PRIORITY));
    }

    //
    // Check workset group record to see if workset exists:
    //
    // Note: this check looks to see if the offset to the workset is zero,
    // since workset records never reside at the start of the OMWORKSETS
    // block.
    //
    if (pWSGroup->apWorksets[worksetID] == NULL)
    {
        rc = WorksetCreate(pomClient->putTask, pWSGroup, worksetID, fTemp, priority);
        if (rc != 0)
        {
            DC_QUIT;
        }
    }
    else
    {
        //
        // Workset already exists, so we don't need to do anything.
        //
        TRACE_OUT((" Workset %hu in WSG %d already exists",
            worksetID, hWSGroup));
    }

    //
    // If the workset didn't already exist, queueing the send instruction
    // will have caused the workset to be created syncrhonously.  So, either
    // way the workset exists at this point.
    //

    //
    // Get a pointer to the workset:
    //
    pWorkset = pWSGroup->apWorksets[worksetID];

    ASSERT((pWorkset != NULL));

    //
    // Set the persistence field for the workset - we might not have done
    // this as part of the WorksetCreate above if someone else had created
    // the workset already.  However, we set our local copy to have the
    // appropriate persistence value.
    //
    pWorkset->fTemp = fTemp;

    //
    // We need to mark this workset as open in the Client's usage record.
    // However, we don't do this yet - we do it in our hidden handler when
    // the OPEN_CON event is received.
    //
    // The reason for this is that a Client shouldn't start using a workset
    // until it has received the event, so we want the workset to remain
    // closed until then.
    //
    // Note that whether we do it this way or mark the workset as open here
    // and now doesn't make much difference from ObMan's point of view but
    // it will help detect applications which are badly behaved.
    //

    //
    // Add this Client to the list kept in the workset record:
    //

    rc = AddClientToWsetList(pomClient->putTask,
                             pWorkset,
                             hWSGroup,
                             pUsageRec->mode,
                             &pClientListEntry);
    if (rc != 0)
    {
       pClientListEntry = NULL;
       DC_QUIT;
    }

    //
    // Create correlator:
    //

    *pCorrelator = NextCorrelator(g_pomPrimary);

    //
    // Post WORKSET_OPEN_CON event to Client:
    //

    eventData16.hWSGroup    = hWSGroup;
    eventData16.worksetID  = worksetID;

    eventData32.result     = 0;
    eventData32.correlator = *pCorrelator;

    TRACE_OUT((" Posting WORKSET_OPEN_CON to Client 0x%08x (task 0x%08x)"));

    UT_PostEvent(pomClient->putTask,
                 pomClient->putTask,
                 0,                              // no delay
                 OM_WORKSET_OPEN_CON,
                 *(UINT *) &eventData16,
                 *(UINT *) &eventData32);

    //
    // Now post OBJECT_ADD_IND events for each of the objects in the
    // workset:
    //

    rc = PostAddEvents(pomClient->putTask, pWorkset, hWSGroup, pomClient->putTask);
    if (rc != 0)
    {
        DC_QUIT;
    }

    TRACE_OUT(("Opened workset %hu in WSG %d for Client 0x%08x",
       worksetID, hWSGroup, pomClient));

DC_EXIT_POINT:

    if (rc != 0)
    {
        ERROR_OUT(("Error 0x%08x opening workset %u in WSG %d for Client 0x%08x",
          rc, worksetID, hWSGroup, pomClient));

        if (pClientListEntry != NULL)
        {
            COM_BasedListRemove(&(pClientListEntry->chain));
            UT_FreeRefCount((void**)&pClientListEntry, FALSE);
        }
    }

    UT_Unlock(UTLOCK_OM);

    DebugExitDWORD(OM_WorksetOpenPReq, rc);
    return(rc);
}




//
// OM_WorksetClose(...)
//
void OM_WorksetClose
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID
)
{
    POM_WORKSET         pWorkset;
    POM_USAGE_REC       pUsageRec;
    POM_CLIENT_LIST     pClientListEntry;

    DebugEntry(OM_WorksetClose);

    UT_Lock(UTLOCK_OM);

    ValidateParams3(pomClient, hWSGroup, worksetID, PRIMARY | SECONDARY,
                   &pUsageRec, &pWorkset);

    //
    // Mark the workset as closed in the Client's usage record:
    //
    TRACE_OUT(("Closing workset %u in WSG %d for Client 0x%08x",
        worksetID, hWSGroup, pomClient));

    WORKSET_SET_CLOSED(pUsageRec, worksetID);

    //
    // Now we release all the resources the Client is using which concern
    // this workset.  We
    //
    // - release all the locks the Client has for this workset
    //
    // - confirm any outstanding operations such as Deletes, etc.
    //
    // - release all the objects it is currently reading
    //
    // - discard any objects allocated but not yet used.
    //
    TRACE_OUT(("Releasing all resources in use by Client..."));

    ReleaseAllLocks(pomClient, pUsageRec, pWorkset);
    ReleaseAllObjects(pUsageRec, pWorkset);
    ConfirmAll(pomClient, pUsageRec, pWorkset);
    DiscardAllObjects(pUsageRec, pWorkset);

    //
    // Remove the Client from the list of Clients stored in the workset
    // record:
    //
    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pWorkset->clients),
        (void**)&pClientListEntry, FIELD_OFFSET(OM_CLIENT_LIST, chain),
        FIELD_OFFSET(OM_CLIENT_LIST, putTask), (DWORD_PTR)pomClient->putTask,
        FIELD_SIZE(OM_CLIENT_LIST, putTask));

    //
    // If we've got this far, the Client has the workset open, so it must be
    // listed in the workset's list of Clients:
    //
    ASSERT((pClientListEntry != NULL));

    COM_BasedListRemove(&(pClientListEntry->chain));
    UT_FreeRefCount((void**)&pClientListEntry, FALSE);

    TRACE_OUT(("Closed workset %u in WSG %d for Client 0x%08x",
        worksetID, hWSGroup, pomClient));

    UT_Unlock(UTLOCK_OM);

    DebugExitVOID(OM_WorksetClose);
}




//
// OM_WorksetLockReq(...)
//
UINT OM_WorksetLockReq
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID,
    OM_CORRELATOR *     pCorrelator
)
{
    POM_USAGE_REC       pUsageRec;
    POM_WSGROUP         pWSGroup;
    POM_WORKSET         pWorkset;
    POM_LOCK            pLastLock;
    POM_LOCK            pThisLock         = NULL;
    BOOL                inserted          = FALSE;
    UINT                rc      = 0;

    DebugEntry(OM_WorksetLockReq);

    UT_Lock(UTLOCK_OM);

    //
    // Validate params:
    //
    ValidateParams3(pomClient, hWSGroup, worksetID, PRIMARY,
                   &pUsageRec, &pWorkset);

    //
    // Set up workset group pointer:
    //
    pWSGroup = pUsageRec->pWSGroup;

    TRACE_OUT(("Client 0x%08x requesting to lock workset %u in WSG %d",
      pomClient, worksetID, hWSGroup));

    //
    // Create a lock record which we will (eventually) put in the Client's
    // lock stack:
    //
    pThisLock = (POM_LOCK)UT_MallocRefCount(sizeof(OM_LOCK), TRUE);
    if (!pThisLock)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }
    SET_STAMP(pThisLock, LOCK);

    //
    // Fill in the fields:
    //
    pThisLock->pWSGroup  = pWSGroup;
    pThisLock->worksetID = worksetID;
    ZeroMemory(&(pThisLock->objectID), sizeof(OM_OBJECT_ID));

    //
    // Check that granting this lock won't result in a lock order violation:
    // (it will if this lock is earlier than or equal to the last lock
    // acquired).
    //
    TRACE_OUT(("Checking for lock order violation..."));

    pLastLock = (POM_LOCK)COM_BasedListFirst(&(pomClient->locks), FIELD_OFFSET(OM_LOCK, chain));

    if (pLastLock != NULL)
    {
        ASSERT(CompareLocks(pLastLock, pThisLock) < 0);

        TRACE_OUT(("Last lock acquired by Client 0x%08x was workset %u in WSG %d",
            pomClient, pLastLock->worksetID, pLastLock->pWSGroup->wsg));
    }
    else
    {
        //
        // If there aren't any locks on the lock stack then there can't be
        // any lock violation, so do nothing.
        //
        TRACE_OUT(("No locks on Client's lock stack"));
    }

    //
    // Put a record of this lock in the Client's lock stack (we don't need
    // to surround this with a mutex since a Client's lock stack is only
    // accessed from that Client's task):
    //
    // Note: since this is a stack, we insert the item at the head of the
    // list.
    //
    COM_BasedListInsertAfter(&(pomClient->locks), &(pThisLock->chain));

    //
    // Now start the process of requesting the lock from the ObMan task:
    //
    WorksetLockReq(pomClient->putTask, g_pomPrimary,
        pWSGroup, pWorkset, hWSGroup, pCorrelator);

    TRACE_OUT(("Requested lock for workset %u in WSG %d for Client 0x%08x",
        worksetID, pWSGroup->wsg, pomClient));

DC_EXIT_POINT:

    UT_Unlock(UTLOCK_OM);

    DebugExitDWORD(OM_WorksetLockReq, rc);
    return(rc);
}




//
// OM_WorksetUnlock(...)
//
void OM_WorksetUnlock
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID
)
{
    POM_USAGE_REC       pUsageRec;
    POM_WSGROUP         pWSGroup;
    POM_WORKSET         pWorkset;
    POM_LOCK            pLastLock;
    OM_LOCK             thisLock;
    UINT                rc = 0;

    DebugEntry(OM_WorksetUnlock);

    UT_Lock(UTLOCK_OM);

    //
    // Validate params:
    //
    ValidateParams3(pomClient, hWSGroup, worksetID, PRIMARY,
                   &pUsageRec, &pWorkset);

    pWSGroup = pUsageRec->pWSGroup;

    TRACE_OUT(("Client 0x%08x requesting to unlock workset %u in WSG %d",
        pomClient, worksetID, hWSGroup));

    //
    // Find the lock uppermost on the Client's lock stack:
    //
    pLastLock = (POM_LOCK)COM_BasedListFirst(&(pomClient->locks), FIELD_OFFSET(OM_LOCK, chain));

    ASSERT((pLastLock != NULL));

    //
    // Assert that the lock uppermost on the lock stack is the one the
    // Client is trying to release (i.e.  that the workset IDs are the same
    // and that the object ID of the lock on the stack is NULL):
    //

    thisLock.pWSGroup  = pWSGroup;
    thisLock.worksetID = worksetID;
    ZeroMemory(&(thisLock.objectID), sizeof(OM_OBJECT_ID));

    ASSERT(CompareLocks(pLastLock, &thisLock) == 0);

    //
    // Now call the common function to do the unlock:
    //
    WorksetUnlock(pomClient->putTask, pWSGroup, pWorkset);

    //
    // Remove the lock from the lock stack and free the memory:
    //
    COM_BasedListRemove(&(pLastLock->chain));
    UT_FreeRefCount((void**)&pLastLock, FALSE);

    TRACE_OUT(("Unlocked workset %u in WSG %d for Client 0x%08x",
        worksetID, hWSGroup, pomClient));

    UT_Unlock(UTLOCK_OM);

    DebugExitVOID(OM_WorksetUnlock);
}




//
// OM_WorksetCountObjects(...)
//
void OM_WorksetCountObjects
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID,
    UINT *              pCount
)
{
    POM_USAGE_REC       pUsageRec;
    POM_WORKSET         pWorkset;

    DebugEntry(OM_WorksetCountObjects);

    UT_Lock(UTLOCK_OM);

    //
    // Validate params:
    //
    ValidateParams3(pomClient, hWSGroup, worksetID, PRIMARY | SECONDARY,
                   &pUsageRec, &pWorkset);

    //
    // Extract <numObjects> field and put in *pCount:
    //
    *pCount = pWorkset->numObjects;

    //
    // Debug-only check:
    //
    CheckObjectCount(pUsageRec->pWSGroup, pWorkset);


    TRACE_OUT(("Number of objects in workset %u in WSG %d = %u",
      worksetID, hWSGroup, *pCount));

    UT_Unlock(UTLOCK_OM);

    DebugExitVOID(OM_WorksetCountObjects);
}




//
// OM_WorksetClear(...)
//
UINT OM_WorksetClear
(
    POM_CLIENT              pomClient,
    OM_WSGROUP_HANDLE       hWSGroup,
    OM_WORKSET_ID           worksetID
)
{
    POM_USAGE_REC           pUsageRec;
    POM_WSGROUP             pWSGroup;
    POM_WORKSET             pWorkset;
    POMNET_OPERATION_PKT    pPacket;
    UINT                    rc = 0;

    DebugEntry(OM_WorksetClear);

    UT_Lock(UTLOCK_OM);

    ValidateParams3(pomClient, hWSGroup, worksetID, PRIMARY,
                   &pUsageRec, &pWorkset);

    pWSGroup = pUsageRec->pWSGroup;

    TRACE_OUT(("Client 0x%08x requesting to clear workset %u in WSG %d",
      pomClient, worksetID, hWSGroup));

    //
    // Check workset isn't locked by somebody else (OK if locked by us):
    //
    CHECK_WORKSET_NOT_LOCKED(pWorkset);

    //
    // Check workset is not exhausted:
    //
    CHECK_WORKSET_NOT_EXHAUSTED(pWorkset);

    //
    // Generate, process and queue the WORKSET_NEW message:
    //
    rc = GenerateOpMessage(pWSGroup,
                          worksetID,
                          NULL,                      // no object ID
                          NULL,                      // no object data
                          OMNET_WORKSET_CLEAR,
                          &pPacket);
    if (rc != 0)
    {
        DC_QUIT;
    }

    rc = ProcessWorksetClear(pomClient->putTask, g_pomPrimary,
            pPacket, pWSGroup, pWorkset);
    if (rc != 0)
    {
        DC_QUIT;
    }

    rc = QueueMessage(pomClient->putTask,
                     pWSGroup->pDomain,
                     pWSGroup->channelID,
                     NET_HIGH_PRIORITY,
                     pWSGroup,
                     pWorkset,
                     NULL,                        // no object record
                     (POMNET_PKT_HEADER) pPacket,
                     NULL,                        // no object data
                    TRUE);
    if (rc != 0)
    {
        DC_QUIT;
    }

    TRACE_OUT(("Issued WorksetClear for workset %u in WSG %d for Client 0x%08x",
        worksetID, hWSGroup, pomClient));

DC_EXIT_POINT:

    if (rc != 0)
    {
        ERROR_OUT(("Error 0x%08x clearing workset %u in WSG %d for Client 0x%08x",
            rc, worksetID, hWSGroup, pomClient));
    }

    UT_Unlock(UTLOCK_OM);

    DebugExitDWORD(OM_WorksetClear, rc);
    return(rc);
}



//
// OM_WorksetClearConfirm(...)
//
void OM_WorksetClearConfirm
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID
)
{
    POM_USAGE_REC       pUsageRec;
    POM_PENDING_OP      pPendingOp;
    POM_WORKSET         pWorkset;
    UINT                rc      = 0;

    DebugEntry(OM_WorksetClearConfirm);

    UT_Lock(UTLOCK_OM);

    ValidateParams3(pomClient, hWSGroup, worksetID, PRIMARY,
                    &pUsageRec, &pWorkset);

    TRACE_OUT(("Client 0x%08x confirming WorksetClear for workest %u in WSG %d",
        pomClient, worksetID, hWSGroup));

    //
    // Find the pending clear that we've been asked to confirm (assume it is
    // first clear we find in the pending operation queue):
    //
    FindPendingOp(pWorkset, 0, WORKSET_CLEAR, &pPendingOp);

    //
    // We assert that a relevant pending op was found:
    //
    ASSERT(pPendingOp != NULL);

    //
    // In versions which support object locking, we will need to unlock any
    // objects that are both
    //
    // - locked, and
    //
    // - deleted by this Clear (remember that a Clear doesn't delete ALL
    //   objects but only those that were added before the Clear was
    //   issued).
    //

    //
    // We also need to release any objects
    //
    // - that the Client was using and
    //
    // - which are to be deleted.
    //
    // Since it's rather a lot of effort to ensure both conditions, we just
    // release all the objects the Client was using i.e.  invoking
    // ClearConfirm invalidates ALL object pointers obtained via ObjectRead,
    // as specified in the API:
    //
    ReleaseAllObjects(pUsageRec, pWorkset);

    //
    // If an object which is to be deleted because of the clear has an
    // operation pending on it, the IND event will be swallowed by the
    // HiddenHandler.
    //
    // Note that we cannot call ConfirmAll (to confirm any pending
    // operations on objects in the workset) at this point for the following
    // reasons:
    //
    // - this Clear might not affect the objects on which we were confirming
    //   operations
    //
    // - the Client might have received the IND events and try to call a
    //   Confirm function in the future, which would cause an assertion
    //   failure
    //
    // - if the Client hasn't yet got the IND events it will never get them
    //   because the hidden handler will swallow them if this DoClear causes
    //   them to be deleted.
    //

    //
    // Here we actually perform the clear:
    //
    // (with multiple local access to workset groups as we may have in R2.0,
    // we can't necessarily clear a workset when just one Client has
    // confirmed; exactly what we will do depends on the design on R2.0).
    //
    WorksetDoClear(pomClient->putTask, pUsageRec->pWSGroup, pWorkset, pPendingOp);

    TRACE_OUT(("Confirmed Clear for workset %u in WSG %d for Client 0x%08x",
        worksetID, hWSGroup, pomClient));

    UT_Unlock(UTLOCK_OM);

    DebugExitVOID(OM_WorksetClearConfirm);
}



//
// OM_ObjectAdd()
//
UINT OM_ObjectAdd
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID,
    POM_OBJECTDATA *    ppData,
    UINT                updateSize,
    POM_OBJECT *        ppObj,
    OM_POSITION         position
)
{
    POM_USAGE_REC       pUsageRec;
    POM_WSGROUP         pWSGroup;
    POM_WORKSET         pWorkset;
    POM_OBJECTDATA      pData;
    OM_OBJECT_ID        newObjectID;
    UINT                rc = 0;

    DebugEntry(OM_ObjectAdd);

    UT_Lock(UTLOCK_OM);

    ValidateParams3(pomClient, hWSGroup, worksetID, PRIMARY,
                   &pUsageRec, &pWorkset);

    pData = *ppData;
    ValidateObjectData(pData);

    TRACE_OUT(("Client 0x%08x adding object to workset %u in WSG %d",
        pomClient, worksetID, hWSGroup));

    TRACE_OUT((" object data is at 0x%08x - size: %u",
        pData, pData->length));

    ASSERT((updateSize < OM_MAX_UPDATE_SIZE));

    //
    // Set up workset group pointer:
    //

    pWSGroup = pUsageRec->pWSGroup;

    //
    // Check workset isn't locked by somebody else (OK if locked by us):
    //

    CHECK_WORKSET_NOT_LOCKED(pWorkset);

    //
    // Check workset is not exhausted:
    //

    CHECK_WORKSET_NOT_EXHAUSTED(pWorkset);

    //
    // Call the internal function to add the object:
    //
    rc = ObjectAdd(pomClient->putTask, g_pomPrimary,
            pWSGroup, pWorkset, pData, updateSize,
        position, &newObjectID, ppObj);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // Remove the object from the unused objects list:
    //
    RemoveFromUnusedList(pUsageRec, pData);

    //
    // If all has gone well, we NULL the Client's pointer to the object
    // data, since we now own the object and the Client is not supposed to
    // refer to it again (unless, of course, it does an OM_ObjectRead).
    //

    *ppData = NULL;

DC_EXIT_POINT:

    if (rc != 0)
    {
        ERROR_OUT(("ERROR %d adding object to workset %u in WSG %d for Client 0x%08x",
            rc, pWorkset->worksetID, hWSGroup, pomClient));
    }

    UT_Unlock(UTLOCK_OM);

    DebugExitDWORD(OM_ObjectAdd, rc);
    return(rc);
}



//
// OM_ObjectMove()
//
UINT OM_ObjectMove
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID,
    POM_OBJECT          pObj,
    OM_POSITION         position
)
{
    POM_USAGE_REC           pUsageRec;
    POM_WSGROUP             pWSGroup;
    POM_WORKSET             pWorkset;
    POMNET_OPERATION_PKT    pPacket = NULL;
    UINT                    rc = 0;

    DebugEntry(OM_ObjectMove);

    UT_Lock(UTLOCK_OM);

    ValidateParams4(pomClient, hWSGroup, worksetID, pObj, PRIMARY,
                   &pUsageRec, &pWorkset);

    TRACE_OUT(("Client 0x%08x moving object 0x%08x in workset %u in WSG %d (position: %s)...",
          pomClient, pObj, worksetID, hWSGroup,
          position == LAST ? "LAST" : "FIRST"));

    //
    // Set up workset group pointer:
    //
    pWSGroup = pUsageRec->pWSGroup;

    //
    // Check workset isn't locked by somebody else (OK if locked by us):
    //

    CHECK_WORKSET_NOT_LOCKED(pWorkset);

    //
    // Check workset is not exhausted:
    //

    CHECK_WORKSET_NOT_EXHAUSTED(pWorkset);

    //
    // Here we generate, process and queue an OBJECT_MOVE message:
    //

    rc = GenerateOpMessage(pWSGroup,
                          pWorkset->worksetID,
                          &(pObj->objectID),
                          NULL,                          // no object data
                          OMNET_OBJECT_MOVE,
                          &pPacket);
    if (rc != 0)
    {
        pPacket = NULL;
        DC_QUIT;
    }

    //
    // Generate message doesn't put the position in the <misc1> field, so we
    // do it here:
    //

    pPacket->position = position;

    //
    // QueueMessage may free the packet (if we're not in a call) but we need
    // to process it in a minute so bump the use count:
    //
    UT_BumpUpRefCount(pPacket);

    rc = QueueMessage(pomClient->putTask,
                     pWSGroup->pDomain,
                     pWSGroup->channelID,
                     NET_HIGH_PRIORITY,
                     pWSGroup,
                     pWorkset,
                     pObj,
                     (POMNET_PKT_HEADER) pPacket,
                     NULL,                // no object data for a MOVE
                    TRUE);
    if (rc != 0)
    {
        DC_QUIT;
    }

    ProcessObjectMove(pomClient->putTask, pPacket, pWorkset, pObj);

DC_EXIT_POINT:

    if (pPacket != NULL)
    {
        //
        // Do this on success OR error since we bumped up the ref count above.
        //
        UT_FreeRefCount((void**)&pPacket, FALSE);
    }

    if (rc != 0)
    {
        ERROR_OUT(("ERROR %d moving object 0x%08x in workset %u in WSG %d",
             rc, pObj, worksetID, hWSGroup));
    }

    UT_Unlock(UTLOCK_OM);

    DebugExitDWORD(OM_ObjectMove, rc);
    return(rc);
}



//
// OM_ObjectDelete(...)
//
UINT OM_ObjectDelete
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID,
    POM_OBJECT          pObj
)
{
    POM_USAGE_REC       pUsageRec;
    POM_WORKSET         pWorkset;
    UINT                rc = 0;

    DebugEntry(OM_ObjectDelete);

    UT_Lock(UTLOCK_OM);

    ValidateParams4(pomClient, hWSGroup, worksetID, pObj, PRIMARY,
                   &pUsageRec, &pWorkset);

    TRACE_OUT(("Client 0x%08x requesting to delete object 0x%08x from workset %u in WSG %d",
          pomClient, pObj, worksetID, hWSGroup));

    //
    // Check workset isn't locked by somebody else (OK if locked by us):
    //

    CHECK_WORKSET_NOT_LOCKED(pWorkset);

    //
    // Check workset is not exhausted:
    //

    CHECK_WORKSET_NOT_EXHAUSTED(pWorkset);

    //
    // If there is already a Delete pending for the object, we return an
    // error and do not post the delete indication event.
    //
    // If we returned success, we would then have to post another event,
    // since the Client may wait for it.  If we post the event, the Client
    // will probably invoke DeleteConfirm a second time when it is
    // unexpected, thereby causing an assertion failure.
    //
    // Note that we cannot rely on the hidden handler to get us out of this
    // one, since the Client might receive the second event before
    // processing the first one, so the handler would have no way of knowing
    // to trap the event.
    //

    //
    // So, to find out if there's a delete pending, check the flag in the
    // object record:
    //

    if (pObj->flags & PENDING_DELETE)
    {
        TRACE_OUT(("Client tried to delete object already being deleted (0x%08x)",
             pObj));
        rc = OM_RC_OBJECT_DELETED;
        DC_QUIT;
    }

    //
    // Here we call the ObjectDelete function to generate, process and queue
    // an OBJECT_DELETE message:
    //
    rc = ObjectDRU(pomClient->putTask,
                  pUsageRec->pWSGroup,
                  pWorkset,
                  pObj,
                  NULL,
                  OMNET_OBJECT_DELETE);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // Remember, the delete doesn't actually happen until the local
    // Client(s) have invoked DeleteConfirm().
    //

DC_EXIT_POINT:

    //
    // SFR5843: Don't trace an error if the object has been deleted - this
    //          is just safe race condition.
    //
    if ((rc != 0) && (rc != OM_RC_OBJECT_DELETED))
    {
        ERROR_OUT(("ERROR %d issuing delete for object 0x%08x in WSG %d:%hu",
            rc, pObj, hWSGroup, worksetID));
    }

    UT_Unlock(UTLOCK_OM);

    DebugExitDWORD(OM_ObjectDelete, rc);
    return(rc);
}



//
// OM_ObjectDeleteConfirm
//
void OM_ObjectDeleteConfirm
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID,
    POM_OBJECT          pObj
)
{
    POM_WORKSET         pWorkset;
    POM_USAGE_REC       pUsageRec;
    POM_PENDING_OP      pPendingOp;
    POM_PENDING_OP      pOtherPendingOp;
    UINT                rc = 0;

    DebugEntry(OM_ObjectDeleteConfirm);

    UT_Lock(UTLOCK_OM);

    ValidateParams4(pomClient, hWSGroup, worksetID, pObj, PRIMARY,
                   &pUsageRec, &pWorkset);

    //
    // To check that there is indeed a Delete pending for the object, we
    // look in the workset's pending operation list.
    //
    FindPendingOp(pWorkset, pObj, OBJECT_DELETE, &pPendingOp);

    //
    // We assert that a relevant pending op was found:
    //
    ASSERT((pPendingOp != NULL));

    //
    // Call ObjectRelease, to release the object (will be a no-op and return
    // NOT_FOUND if the Client hasn't done a Read on it):
    //

    rc = ObjectRelease(pUsageRec, worksetID, pObj);

    ASSERT(((rc == 0) || (rc == OM_RC_OBJECT_NOT_FOUND)));

    //
    // If we are going to confirm the delete, then we must ensure that any
    // pending update or replace is carried out too.  There can be only one
    // of each, so check as follows (ther order we do them in is not
    // relevant):
    //

    FindPendingOp(pWorkset, pObj, OBJECT_REPLACE, &pOtherPendingOp);
    if (pOtherPendingOp != NULL)
    {
        ObjectDoReplace(pomClient->putTask,
            pUsageRec->pWSGroup, pWorkset, pObj, pOtherPendingOp);
    }

    FindPendingOp(pWorkset, pObj, OBJECT_UPDATE, &pOtherPendingOp);
    if (pOtherPendingOp != NULL)
    {
        ObjectDoUpdate(pomClient->putTask,
            pUsageRec->pWSGroup, pWorkset, pObj, pOtherPendingOp);
    }

    //
    // Perform the Delete:
    //
    ObjectDoDelete(pomClient->putTask, pUsageRec->pWSGroup, pWorkset, pObj, pPendingOp);

    UT_Unlock(UTLOCK_OM);

    DebugExitVOID(OM_ObjectDeleteConfirm);
}



//
// OM_ObjectReplace(...)
//
UINT OM_ObjectReplace
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID,
    POM_OBJECT          pObj,
    POM_OBJECTDATA *    ppData
)
{
    POM_USAGE_REC       pUsageRec;
    POM_WORKSET         pWorkset;
    POM_OBJECTDATA      pData;
    UINT                rc = 0;

    DebugEntry(OM_ObjectReplace);

    UT_Lock(UTLOCK_OM);

    ValidateParams4(pomClient, hWSGroup, worksetID, pObj, PRIMARY,
                   &pUsageRec, &pWorkset);

    pData = *ppData;
    ValidateObjectData(pData);

    //
    // Check that the Client is not attempting to replace the object with
    // one smaller that the object's update size (which is the minimum size
    // for a replace):
    //

    ASSERT((pData->length >= pObj->updateSize));

    //
    // Check workset isn't locked by somebody else (OK if locked by us):
    //

    CHECK_WORKSET_NOT_LOCKED(pWorkset);

    //
    // Check workset is not exhausted:
    //

    CHECK_WORKSET_NOT_EXHAUSTED(pWorkset);

    //
    // If the object is in the process of being deleted, we prevent the
    // Replace.  This is because if we don't, the Client will get a
    // REPLACE_IND event after it has got (and processed) a DELETE event for
    // the object.
    //

    if (pObj->flags & PENDING_DELETE)
    {
        TRACE_OUT(("Client 0x%08x tried to replace object being deleted (0x%08x)",
             pomClient, pObj));
        rc = OM_RC_OBJECT_DELETED;
        DC_QUIT;
    }

    //
    // When object locking supported, need to prevent object replace when
    // object is locked.
    //

    //
    // Generate, process and queue an OBJECT_REPLACE message:
    //

    rc = ObjectDRU(pomClient->putTask,
                  pUsageRec->pWSGroup,
                  pWorkset,
                  pObj,
                  pData,
                  OMNET_OBJECT_REPLACE);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // Remove the object from the unused objects list:
    //

    RemoveFromUnusedList(pUsageRec, pData);

    //
    // NULL the Client's pointer to the object:
    //

    *ppData = NULL;

    TRACE_OUT(("Queued replace for object 0x%08x in workset %u for Client 0x%08x",
        pObj, worksetID, pomClient));

DC_EXIT_POINT:

    //
    // SFR5843: Don't trace an error if the object has been deleted - this
    //          is just safe race condition.
    //
    if ((rc != 0) && (rc != OM_RC_OBJECT_DELETED))
    {
        ERROR_OUT(("ERROR %d issuing replace for object 0x%08x in WSG %d:%hu",
            rc, pObj, hWSGroup, worksetID));
    }

    UT_Unlock(UTLOCK_OM);

    DebugExitDWORD(OM_ObjectReplace, rc);
    return(rc);
}




//
// OM_ObjectUpdate
//
UINT OM_ObjectUpdate
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID,
    POM_OBJECT          pObj,
    POM_OBJECTDATA *    ppData
)
{
    POM_USAGE_REC       pUsageRec;
    POM_WORKSET         pWorkset;
    POM_OBJECTDATA      pData;
    UINT                rc = 0;

    DebugEntry(OM_ObjectUpdate);

    UT_Lock(UTLOCK_OM);

    ValidateParams4(pomClient, hWSGroup, worksetID, pObj, PRIMARY,
                   &pUsageRec, &pWorkset);

    pData = *ppData;
    ValidateObjectData(pData);

    //
    // Check size of update equals the update size for the object:
    //

    ASSERT((pData->length == pObj->updateSize));

    TRACE_OUT(("Update request is for first 0x%08x bytes, starting at 0x%08x",
        pData->length, pData->data));

    //
    // Check workset isn't locked by somebody else (OK if locked by us):
    //

    CHECK_WORKSET_NOT_LOCKED(pWorkset);

    //
    // Check workset is not exhausted:
    //

    CHECK_WORKSET_NOT_EXHAUSTED(pWorkset);

    //
    // If the object is in the process of being deleted, we prevent the
    // Update.  This is because if we don't, the Client will get a
    // UPDATE_IND event after it has got (and processed) a DELETE event for
    // the object.
    //

    if (pObj->flags & PENDING_DELETE)
    {
        TRACE_OUT(("Client 0x%08x tried to update object being deleted (0x%08x)",
            pomClient, pObj));
        rc = OM_RC_OBJECT_DELETED;
        DC_QUIT;
    }

    //
    // When object locking supported, need to prevent object update/replace
    // when object is locked.
    //

    //
    // Generate, process and queue an OBJECT_UPDATE message:
    //

    rc = ObjectDRU(pomClient->putTask,
                  pUsageRec->pWSGroup,
                  pWorkset,
                  pObj,
                  pData,
                  OMNET_OBJECT_UPDATE);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // Remove the object from the unused objects list:
    //
    RemoveFromUnusedList(pUsageRec, pData);

    //
    // NULL the Client's pointer to the object:
    //

    *ppData = NULL;

    TRACE_OUT(("Queued update for object 0x%08x in workset %u for Client 0x%08x",
        pObj, worksetID, pomClient));

DC_EXIT_POINT:

    //
    // SFR5843: Don't trace an error if the object has been deleted - this
    //          is just safe race condition.
    //
    if ((rc != 0) && (rc != OM_RC_OBJECT_DELETED))
    {
        ERROR_OUT(("ERROR %d issuing update for object 0x%08x in WSG %d:%hu",
            rc, pObj, hWSGroup, worksetID));
    }

    UT_Unlock(UTLOCK_OM);

    DebugExitDWORD(OM_ObjectUpdate, rc);
    return(rc);
}



//
// OM_ObjectReplaceConfirm(...)
//
void OM_ObjectReplaceConfirm
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID,
    POM_OBJECT       pObj
)
{
    POM_WORKSET         pWorkset;
    POM_USAGE_REC       pUsageRec;
    POM_PENDING_OP      pPendingOp;
    UINT                rc = 0;

    DebugEntry(OM_ObjectReplaceConfirm);

    UT_Lock(UTLOCK_OM);

    //
    // Here, we do our usual parameter validation, but we don't want to
    // assert if the object has been delete-confirmed already, so we modify
    // the code from ValidateParams4 a bit:
    //

    ValidateParams4(pomClient, hWSGroup, worksetID, pObj, PRIMARY,
                   &pUsageRec, &pWorkset);

    //
    // Retrieve the Replace operation from the object's pending op queue (we
    // want the first REPLACE operation on the queue, so we start from the
    // head):
    //

    FindPendingOp(pWorkset, pObj, OBJECT_REPLACE, &pPendingOp);

    ASSERT((pPendingOp != NULL));

    //
    // Call ObjectRelease, to release the object (will be a no-op if the
    // Client hasn't done a Read on it):
    //

    rc = ObjectRelease(pUsageRec, worksetID, pObj);
    ASSERT(((rc == 0) || (rc == OM_RC_OBJECT_NOT_FOUND)));

    //
    // Call the internal function to perform the actual Replace:
    //

    ObjectDoReplace(pomClient->putTask, pUsageRec->pWSGroup, pWorkset, pObj, pPendingOp);

    TRACE_OUT(("Confirmed Replace for object 0x%08x in workset %u for Client 0x%08x",
          pObj, worksetID, pomClient));

    UT_Unlock(UTLOCK_OM);

    DebugExitVOID(OM_ObjectReplaceConfirm);
}



//
// OM_ObjectUpdateConfirm(...)
//
void OM_ObjectUpdateConfirm
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID,
    POM_OBJECT       pObj
)
{
    POM_USAGE_REC       pUsageRec;
    POM_WORKSET         pWorkset;
    POM_PENDING_OP      pPendingOp;
    UINT                rc = 0;

    DebugEntry(OM_ObjectUpdateConfirm);

    UT_Lock(UTLOCK_OM);

    ValidateParams4(pomClient, hWSGroup, worksetID, pObj, PRIMARY,
                   &pUsageRec, &pWorkset);

    //
    // Retrieve the Update operation from the object's pending op queue (we
    // want the first UPDATE operation on the queue, so we start from the
    // head):
    //

    FindPendingOp(pWorkset, pObj, OBJECT_UPDATE, &pPendingOp);

    ASSERT((pPendingOp != NULL));

    //
    // Call ObjectRelease, to release the object (will be a no-op if the
    // Client hasn't done a Read on it):
    //

    rc = ObjectRelease(pUsageRec, worksetID, pObj);
    ASSERT(((rc == 0) || (rc == OM_RC_OBJECT_NOT_FOUND)));

    //
    // Call the internal function to perform the actual Update:
    //

    ObjectDoUpdate(pomClient->putTask, pUsageRec->pWSGroup, pWorkset, pObj, pPendingOp);

    TRACE_OUT(("Confirmed Update for object 0x%08x in workset %u for Client 0x%08x",
          pObj, worksetID, pomClient));

    UT_Unlock(UTLOCK_OM);

    DebugExitVOID(OM_ObjectUpdateConfirm);
}




//
// OM_ObjectH()
// Gets a ptr to the first/next/previous/last object
//
UINT OM_ObjectH
(
    POM_CLIENT              pomClient,
    OM_WSGROUP_HANDLE       hWSGroup,
    OM_WORKSET_ID           worksetID,
    POM_OBJECT              pObjOther,
    POM_OBJECT *            ppObj,
    OM_POSITION             omPos
)
{
    POM_USAGE_REC           pUsageRec;
    POM_WORKSET             pWorkset;
    UINT                    rc = 0;

    DebugEntry(OM_ObjectH);

    UT_Lock(UTLOCK_OM);

    //
    // Validate params.  If no hOtherObject (like in first/last), don't validate hOtherObject
    //
    if ((omPos == FIRST) || (omPos == LAST))
    {
        ASSERT(pObjOther == NULL);

        ValidateParams3(pomClient, hWSGroup, worksetID, PRIMARY | SECONDARY,
            &pUsageRec, &pWorkset);

        if (omPos == FIRST)
            omPos = AFTER;
        else
            omPos = BEFORE;
    }
    else
    {
        ValidateParams4(pomClient, hWSGroup, worksetID, pObjOther,
            PRIMARY | SECONDARY, &pUsageRec, &pWorkset);
    }

    //
    // Get the object pointer
    //

    //
    // Here we derive a pointer to what is "probably" the object record
    // we're looking for:
    //
    if (pObjOther == NULL)
    {
        //
        // Remember, if *ppObj == 0, then we're looking for the first or
        // last object in the workset:
        //

        if (omPos == AFTER)
        {
            TRACE_OUT(("Getting first object in workset %u", worksetID));
            *ppObj = (POM_OBJECT)COM_BasedListFirst(&(pWorkset->objects), FIELD_OFFSET(OM_OBJECT, chain));
        }
        else
        {
            TRACE_OUT(("Getting last object in workset %u", worksetID));
            *ppObj = (POM_OBJECT)COM_BasedListLast(&(pWorkset->objects), FIELD_OFFSET(OM_OBJECT, chain));
        }
    }
    else
    {
        *ppObj = pObjOther;

        if (omPos == AFTER)
        {
            TRACE_OUT(("Getting object after 0x%08x in workset %u",
               pObjOther, worksetID));
            *ppObj = (POM_OBJECT)COM_BasedListNext(&(pWorkset->objects), pObjOther, FIELD_OFFSET(OM_OBJECT, chain));
        }
        else
        {
            TRACE_OUT(("Getting object before 0x%08x in workset %u",
               pObjOther, worksetID));
            *ppObj = (POM_OBJECT)COM_BasedListPrev(&(pWorkset->objects), pObjOther, FIELD_OFFSET(OM_OBJECT, chain));
        }
    }

    //
    // ppObj now has "probably" a pointer to the object we're looking for,
    // but now we need to skip deleted objects.
    //

    while ((*ppObj != NULL) && ((*ppObj)->flags & DELETED))
    {
        ValidateObject(*ppObj);

        if (omPos == AFTER)
        {
            *ppObj = (POM_OBJECT)COM_BasedListNext(&(pWorkset->objects), *ppObj, FIELD_OFFSET(OM_OBJECT, chain));
        }
        else
        {
            *ppObj = (POM_OBJECT)COM_BasedListPrev(&(pWorkset->objects), *ppObj, FIELD_OFFSET(OM_OBJECT, chain));
        }
    }

    if (*ppObj == NULL)
    {
        rc = OM_RC_NO_SUCH_OBJECT;
    }

    UT_Unlock(UTLOCK_OM);

    DebugExitDWORD(OM_ObjectH, rc);
    return(rc);
}



//
// OM_ObjectIDToPtr(...)
//
UINT OM_ObjectIDToPtr
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID,
    OM_OBJECT_ID        objectID,
    POM_OBJECT *        ppObj
)
{
    POM_USAGE_REC       pUsageRec;
    POM_WORKSET         pWorkset;
    UINT                rc = 0;

    DebugEntry(OM_ObjectIDToPtr);

    UT_Lock(UTLOCK_OM);

    ValidateParams3(pomClient, hWSGroup, worksetID, PRIMARY | SECONDARY,
                   &pUsageRec, &pWorkset);

    //
    // Now call the internal function to do the search for the ID:
    //

    rc = ObjectIDToPtr(pWorkset, objectID, ppObj);

    if (rc == OM_RC_OBJECT_DELETED)
    {
        //
        // This internal function returns OBJECT_DELETED if the object record
        // was found but is marked as deleted.  We map this to BAD_OBJECT_ID
        // since that's all we externalise to Clients:
        //
        rc = OM_RC_BAD_OBJECT_ID;
    }
    else if (rc == OM_RC_OBJECT_PENDING_DELETE)
    {
        //
        // If we get back PENDING_DELETE, then we map this to OK, since as
        // far as the Client is concerned, the object still exists:
        //
        rc = 0;
    }

    if (rc == OM_RC_BAD_OBJECT_ID)
    {
        WARNING_OUT(("No object found in workset with ID 0x%08x:0x%08x",
            objectID.creator, objectID.sequence));
    }
    else if (rc != 0)
    {
        ERROR_OUT(("ERROR %d converting object ID (0x%08x:0x%08x) to handle",
            rc, objectID.creator, objectID.sequence));
    }
    else
    {
        TRACE_OUT(("Converted object ID (0x%08x:0x%08x) to handle (0x%08x)",
            objectID.creator, objectID.sequence, *ppObj));
    }

    UT_Unlock(UTLOCK_OM);

    DebugExitDWORD(OM_ObjectIDToPtr, rc);
    return(rc);
}




//
// OM_ObjectPtrToID(...)
//
void OM_ObjectPtrToID
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID,
    POM_OBJECT       pObj,
    POM_OBJECT_ID       pObjectID
)
{
    POM_USAGE_REC       pUsageRec;
    POM_WORKSET         pWorkset;
    UINT                rc = 0;

    DebugEntry(OM_ObjectPtrToID);

    UT_Lock(UTLOCK_OM);

    ValidateParams4(pomClient, hWSGroup, worksetID, pObj, PRIMARY | SECONDARY,
                   &pUsageRec, &pWorkset);

    //
    // Extract ID from object record:
    //
    memcpy(pObjectID, &pObj->objectID, sizeof(OM_OBJECT_ID));

    TRACE_OUT(("Retrieved object ID 0x%08x:0x%08x for object 0x%08x in workset %u",
          pObjectID->creator, pObjectID->sequence, pObj, worksetID));

    UT_Unlock(UTLOCK_OM);

    DebugExitVOID(OM_ObjectHandleToID);
}




//
// OM_ObjectRead(...)
//
UINT OM_ObjectRead
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID,
    POM_OBJECT          pObj,
    POM_OBJECTDATA *    ppData
)
{
    POM_USAGE_REC       pUsageRec;
    POM_WORKSET         pWorkset;
    POM_OBJECT_LIST     pListEntry;
    UINT                rc = 0;

    DebugEntry(OM_ObjectRead);

    UT_Lock(UTLOCK_OM);

    ValidateParams4(pomClient, hWSGroup, worksetID, pObj, PRIMARY | SECONDARY,
                   &pUsageRec, &pWorkset);

    //
    // Check the Client hasn't already read this object without releasing
    // it:
    //

    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pUsageRec->objectsInUse),
        (void**)&pListEntry, FIELD_OFFSET(OM_OBJECT_LIST, chain),
        FIELD_OFFSET(OM_OBJECT_LIST, pObj), (DWORD_PTR)pObj,
        FIELD_SIZE(OM_OBJECT_LIST, pObj));
    ASSERT(pListEntry == NULL);

    //
    // Convert object handle to a pointer to the object data:
    //

    *ppData = pObj->pData;
    if (!*ppData)
    {
        ERROR_OUT(("OM_ObjectRead: Object 0x%08x has no data", pObj));
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    //
    // Bump up the use count of the chunk so it won't be freed until the
    // Client calls OM_ObjectRelease (explicitly or implicitly via e.g
    // DeleteConfirm)
    //
    UT_BumpUpRefCount(*ppData);

    //
    // We need to add this object's handle to the Client's list of
    // objects-in-use, so allocate some memory for the object...
    //
    pListEntry = (POM_OBJECT_LIST)UT_MallocRefCount(sizeof(OM_OBJECT_LIST), TRUE);
    if (!pListEntry)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    SET_STAMP(pListEntry, OLIST);

    //
    // ...fill in the fields...
    //
    pListEntry->pObj        = pObj;
    pListEntry->worksetID   = worksetID;

    //
    // ...and insert into the list:
    //

    COM_BasedListInsertBefore(&(pUsageRec->objectsInUse),
                        &(pListEntry->chain));

    TRACE_OUT(("Read object at 0x%08x (handle: 0x%08x) for Client 0x%08x",
        *ppData, pObj, pomClient));

DC_EXIT_POINT:

    if (rc != 0)
    {
        //
        // Cleanup:
        //
        ERROR_OUT(("ERROR %d reading object 0x%08x in workset %u in WSG %d",
            rc, pObj, worksetID, hWSGroup));

        if (pListEntry != NULL)
        {
            UT_FreeRefCount((void**)&pListEntry, FALSE);
        }

        if (*ppData)
            UT_FreeRefCount((void**)ppData, FALSE);
    }

    UT_Unlock(UTLOCK_OM);

    DebugExitDWORD(OM_ObjectRead, rc);
    return(rc);
}




//
// OM_ObjectRelease()
//
void OM_ObjectRelease
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID,
    POM_OBJECT          pObj,
    POM_OBJECTDATA *    ppData
)
{
    POM_USAGE_REC       pUsageRec;
    POM_WORKSET         pWorkset;
    UINT                rc = 0;

    DebugEntry(OM_ObjectRelease);

    UT_Lock(UTLOCK_OM);

    ValidateParams4(pomClient, hWSGroup, worksetID, pObj, PRIMARY | SECONDARY,
                   &pUsageRec, &pWorkset);

    //
    // Check that the object pointer and object handle match:
    //

    ASSERT(pObj->pData == *ppData);

    //
    // Now try to release the object from the objects-in-use list:
    //

    rc = ObjectRelease(pUsageRec, worksetID, pObj);

    //
    // ObjectRelease will return an error if the object handle wasn't found
    // in the objects-in-use list.  As far as we're concerned, this is an
    // assert-level error:
    //

    ASSERT((rc == 0));

    //
    // NULL the Client's pointer:
    //

    *ppData = NULL;

    TRACE_OUT(("Released Client 0x%08x's hold on object 0x%08x in workset %u in WSG %d",
          pomClient, pObj, worksetID, hWSGroup));

    UT_Unlock(UTLOCK_OM);

    DebugExitVOID(OM_ObjectRelease);
}



//
// OM_ObjectAlloc(...)
//
UINT OM_ObjectAlloc
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID,
    UINT                size,
    POM_OBJECTDATA *    ppData
)
{
    POM_USAGE_REC       pUsageRec;
    POM_WORKSET         pWorkset;
    POM_OBJECTDATA_LIST pListEntry     = NULL;
    UINT                rc = 0;

    DebugEntry(OM_ObjectAlloc);

    UT_Lock(UTLOCK_OM);

    ValidateParams3(pomClient, hWSGroup, worksetID, PRIMARY,
                   &pUsageRec, &pWorkset);

    TRACE_OUT(("Client 0x%08x requesting to allocate 0x%08x bytes "
          "for object for workset %u in WSG %d",
          pomClient, size, worksetID, hWSGroup));

    //
    // Check request not too big:
    //
    ASSERT((size < OM_MAX_OBJECT_SIZE - sizeof(OM_MAX_OBJECT_SIZE)));

    //
    // Check request not too small:
    //
    ASSERT((size > 0));

    //
    // Allocate a chunk of memory for the object (note that we add 4 bytes
    // to the size the Client asked for (i.e.  the <size> parameter) since
    // the API stipulates that this does not include the <size> field which
    // is at the start of the object.
    //
    *ppData = (POM_OBJECTDATA)UT_MallocRefCount(size + sizeof(OM_MAX_OBJECT_SIZE), FALSE);
    if (! *ppData)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    ZeroMemory(*ppData, min(size, OM_ZERO_OBJECT_SIZE));

    //
    // Now insert a reference to this chunk in the Client's unused-objects
    // list (will be removed by Add, Replace, Update or Discard functions).
    //
    pListEntry = (POM_OBJECTDATA_LIST)UT_MallocRefCount(sizeof(OM_OBJECTDATA_LIST), TRUE);
    if (!pListEntry)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    SET_STAMP(pListEntry, ODLIST);

    pListEntry->pData       = *ppData;
    pListEntry->size        = size;
    pListEntry->worksetID   = worksetID;

    COM_BasedListInsertBefore(&(pUsageRec->unusedObjects),
                        &(pListEntry->chain));

    TRACE_OUT(("Allocated object starting at 0x%08x", *ppData));

DC_EXIT_POINT:

    if (rc != 0)
    {
        //
        // Cleanup:
        //

        ERROR_OUT(("ERROR %d allocating object (size: 0x%08x) for Client 0x%08x",
            rc, size + sizeof(OM_MAX_OBJECT_SIZE), pomClient));

        if (pListEntry != NULL)
        {
            UT_FreeRefCount((void**)&pListEntry, FALSE);
        }

        if (*ppData != NULL)
        {
            UT_FreeRefCount((void**)ppData, FALSE);
        }
    }

    UT_Unlock(UTLOCK_OM);

    DebugExitDWORD(OM_ObjectAlloc, rc);
    return(rc);
}




//
// OM_ObjectDiscard(...)
//
void OM_ObjectDiscard
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID,
    POM_OBJECTDATA *    ppData
)
{
    POM_USAGE_REC       pUsageRec;
    POM_WORKSET         pWorkset;
    POM_OBJECTDATA      pData;
    UINT                rc = 0;

    DebugEntry(OM_ObjectDiscard);

    UT_Lock(UTLOCK_OM);

    ValidateParams3(pomClient, hWSGroup, worksetID, PRIMARY,
                   &pUsageRec, &pWorkset);

    pData = *ppData;

    //
    // Remove the object from the unused objects list:
    //

    RemoveFromUnusedList(pUsageRec, pData);

    //
    // Free the chunk containing the object, NULLing the caller's pointer at
    // the same time:
    //

    UT_FreeRefCount((void**)ppData, FALSE);

    TRACE_OUT(("Discarded object at 0x%08x in workset %u in WSG %d for Client 0x%08x",
        pData, worksetID, hWSGroup, pomClient));

    UT_Unlock(UTLOCK_OM);

    DebugExitVOID(OM_ObjectDiscard);
}




//
// OM_GetNetworkUserID
//
UINT OM_GetNetworkUserID
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    NET_UID *           pNetUserID
)
{
    POM_DOMAIN          pDomain;
    POM_USAGE_REC       pUsageRec;
    POM_WSGROUP         pWSGroup;
    UINT                rc = 0;

    DebugEntry(OM_GetNetworkUserID);

    UT_Lock(UTLOCK_OM);

    ValidateParams2(pomClient, hWSGroup, PRIMARY | SECONDARY,
                   &pUsageRec, &pWSGroup);

    //
    // Get a pointer to the relevant Domain:
    //
    pDomain = pWSGroup->pDomain;

    if (pDomain->callID == OM_NO_CALL)
    {
        rc = OM_RC_LOCAL_WSGROUP;
        DC_QUIT;
    }

    //
    // Otherwise, everything's OK, so we fill in the caller's pointer and
    // return:
    //

    if (pDomain->userID == 0)
    {
        WARNING_OUT(("Client requesting userID for Domain %u before we've attached",
            pDomain->callID));
        rc = OM_RC_NOT_ATTACHED;
        DC_QUIT;
    }

    *pNetUserID = pDomain->userID;

    TRACE_OUT(("Returned Network user ID (0x%08x) to Client 0x%08x for '0x%08x'",
        *pNetUserID, pomClient, hWSGroup));

DC_EXIT_POINT:

    UT_Unlock(UTLOCK_OM);

    DebugExitDWORD(OM_GetNetworkUserID, rc);
    return(rc);
}



//
// SetUpUsageRecord(...)
//
UINT SetUpUsageRecord
(
    POM_CLIENT          pomClient,
    UINT                mode,
    POM_USAGE_REC  *    ppUsageRec,
    OM_WSGROUP_HANDLE * phWSGroup
)
{
    UINT                rc = 0;

    DebugEntry(SetUpUsageRecord);

    ValidateOMS(pomClient);

    //
    // Find an unused workset group handle for the Client:
    //
    rc = FindUnusedWSGHandle(pomClient, phWSGroup);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // Client has a spare handle so create a new usage record for this
    // Client's use of the workset group:
    //
    *ppUsageRec = (POM_USAGE_REC)UT_MallocRefCount(sizeof(OM_USAGE_REC), TRUE);
    if (! *ppUsageRec)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }
    SET_STAMP((*ppUsageRec), USAGEREC);

    //
    // Next, fill in the fields, but note that:
    //
    // - until the registration gets to pre-Stage1, the only way to abort it
    //   from the Client context is to mark the registration CB as invalid.
    //   To do this (e.g.  in WSGroupDeregister) we need access to the
    //   registration CB, so we will put a pointer to it in the usage record
    //   below.
    //
    // - the <worksetOpenFlags> field is zero initially (it will be changed
    //   when the Client does a WorksetOpen), so we do nothing
    //
    // - the <wsGroupMutex> field also needs to be zero initially (the
    //   correct value is inserted by the hidden handler), so we leave this
    //   blank too.
    //
    (*ppUsageRec)->mode     = (BYTE)mode;

    COM_BasedListInit(&((*ppUsageRec)->unusedObjects));
    COM_BasedListInit(&((*ppUsageRec)->objectsInUse));

    //
    // Put the offset to the usage record in the array of offsets:
    //
    pomClient->apUsageRecs[*phWSGroup] = *ppUsageRec;

    TRACE_OUT(("Set up usage record for Client 0x%08x at 0x%08x (hWSGroup: %hu)",
        pomClient, *ppUsageRec, *phWSGroup));

DC_EXIT_POINT:
    DebugExitDWORD(SetUpUsageRecord, rc);
    return(rc);
}



//
// FindUnusedWSGHandle(...)
//
UINT FindUnusedWSGHandle
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE * phWSGroup
)
{
    BOOL                found;
    OM_WSGROUP_HANDLE   hWSGroup;
    UINT                rc = 0;

    DebugEntry(FindUnusedWSGHandle);

    ValidateOMS(pomClient);

    //
    // Workset group handles are indexes into an array of offsets to usage
    // records.  When one of these offsets is 0, the slot is available for
    // use.
    //
    // We start our loop at 1 because 0 is never used as a workset group
    // handle.  Because we start at 1, we end at MAX + 1 to ensure that we
    // use MAX handles.
    //

    found = FALSE;

    for (hWSGroup = 1; hWSGroup < OMWSG_MAXPERCLIENT; hWSGroup++)
    {
        if (pomClient->apUsageRecs[hWSGroup] == NULL)
        {
            found = TRUE;
            TRACE_OUT(("Found unused workset group handle %hu for Client 0x%08x",
                hWSGroup, pomClient));

            ASSERT(!pomClient->wsgValid[hWSGroup]);

            break;
        }
    }

    //
    // If there aren't any, quit with an error:
    //
    if (!found)
    {
        WARNING_OUT(("Client 0x%08x has no more workset group handles", pomClient));
        rc = OM_RC_NO_MORE_HANDLES;
        DC_QUIT;
    }
    else
    {
        *phWSGroup = hWSGroup;
    }

DC_EXIT_POINT:
    DebugExitDWORD(FindUnusedWSGHandle, rc);
    return(rc);
}



//
// RemoveFromUnusedList()
//
void RemoveFromUnusedList
(
    POM_USAGE_REC       pUsageRec,
    POM_OBJECTDATA      pData
)
{
    POM_OBJECTDATA_LIST pListEntry;

    DebugEntry(RemoveFromUnusedList);

    //
    // Search in the unused-objects list hung off the usage record for an
    // entry whose field is the same as the offset of this object:
    //
    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pUsageRec->unusedObjects),
        (void**)&pListEntry, FIELD_OFFSET(OM_OBJECTDATA_LIST, chain),
        FIELD_OFFSET(OM_OBJECTDATA_LIST, pData), (DWORD_PTR)pData,
        FIELD_SIZE(OM_OBJECTDATA_LIST, pData));

    //
    // This object must have been previously allocated, so it must be in the
    // list.  Assert failure if not:
    //
    ASSERT((pListEntry != NULL));


    //
    // Also, we check to make sure the Client hasn't set the <size> field to
    // more memory than we originally allocated for the object:
    //
    if (pData->length != pListEntry->size)
    {
        ASSERT((pData->length < pListEntry->size));

        TRACE_OUT(("Client has shrunk object from %u to %u bytes",
            pListEntry->size, pData->length));
    }

    COM_BasedListRemove(&(pListEntry->chain));
    UT_FreeRefCount((void**)&pListEntry, FALSE);

    DebugExitVOID(RemoveFromUnusedList);
}




//
// ReleaseAllObjects(...)
//
void ReleaseAllObjects
(
    POM_USAGE_REC   pUsageRec,
    POM_WORKSET     pWorkset
)
{
    DebugEntry(ReleaseAllObjects);

    while (ObjectRelease(pUsageRec, pWorkset->worksetID, 0) == 0)
    {
        //
        // Calling ObjectRelease with pObj set to NULL will cause the
        // first object in the objects-in-use list which is in this workset
        // to be released.  When there are no more, rc will be set to
        // OM_RC_OBJECT_NOT_FOUND and we will break out of our loop:
        //
    }

    DebugExitVOID(ReleaseAllObjects);
}




//
// ReleaseAllLocks(...)
//
void ReleaseAllLocks
(
    POM_CLIENT          pomClient,
    POM_USAGE_REC       pUsageRec,
    POM_WORKSET         pWorkset
)
{
    POM_LOCK            pThisLock;
    POM_LOCK            pTempLock;

    DebugEntry(ReleaseAllLocks);

    ValidateOMS(pomClient);

    //
    // Here we chain through the Client's lock stack and unlock any locks
    // that relate to this workset.
    //
    // Note that, since object locking is not currently supported, the if
    // statement in the loop will succeed at most once (i.e.  if the workset
    // itself is locked).  The code is nonetheless implemented as a loop for
    // forward compatibility.  If this is deemed to be performance critical,
    // we could put a break statement in.
    //

    pThisLock = (POM_LOCK)COM_BasedListFirst(&(pomClient->locks), FIELD_OFFSET(OM_LOCK, chain));

    while (pThisLock != NULL)
    {
        //
        // Since we will remove and free the entry in the lock stack if we
        // find a match, we must chain to the next item beforehand:
        //
        pTempLock = (POM_LOCK)COM_BasedListNext(&(pomClient->locks), pThisLock, FIELD_OFFSET(OM_LOCK, chain));

        if ((pThisLock->pWSGroup  == pUsageRec->pWSGroup) &&
            (pThisLock->worksetID == pWorkset->worksetID))
        {
            if (OBJECT_ID_IS_NULL(pThisLock->objectID)) // always TRUE in R1.1
            {
                //
                // ...we're dealing with a workset lock:
                //
                WorksetUnlock(pomClient->putTask, pUsageRec->pWSGroup, pWorkset);
            }
            else
            {
                //
                // ...this is an object lock, so call ObjectUnlock (when it's
                // supported!).  In the meantime, assert:
                //
                ERROR_OUT(("Object locking not supported in R1.1!!"));
            }

            COM_BasedListRemove(&(pThisLock->chain));
            UT_FreeRefCount((void**)&pThisLock, FALSE);

            //
            // Could put the break in here for performance improvement.
            //
        }

        pThisLock = pTempLock;
    }

    DebugExitVOID(ReleaseAllLocks);
}



//
// ConfirmAll(...)
//
void ConfirmAll
(
    POM_CLIENT      pomClient,
    POM_USAGE_REC   pUsageRec,
    POM_WORKSET     pWorkset
)
{
    POM_PENDING_OP  pThisPendingOp;
    POM_OBJECT      pObj;
    UINT            rc        = 0;

    DebugEntry(ConfirmAll);

    ValidateOMS(pomClient);

    //
    // To confirm all outstanding operations for this workset, we search
    // the list of pending ops stored off the workset record:
    //

    //
    // Chain through the workset's list of pending operations and confirm
    // them one by one:
    //

    pThisPendingOp = (POM_PENDING_OP)COM_BasedListFirst(&(pWorkset->pendingOps), FIELD_OFFSET(OM_PENDING_OP, chain));
    while (pThisPendingOp != NULL)
    {
        pObj = pThisPendingOp->pObj;

        switch (pThisPendingOp->type)
        {
            case WORKSET_CLEAR:
            {
                WorksetDoClear(pomClient->putTask,
                    pUsageRec->pWSGroup, pWorkset, pThisPendingOp);
                break;
            }

            case OBJECT_DELETE:
            {
                ObjectDoDelete(pomClient->putTask,
                    pUsageRec->pWSGroup, pWorkset, pObj, pThisPendingOp);
                break;
            }

            case OBJECT_UPDATE:
            {
                ObjectDoUpdate(pomClient->putTask,
                    pUsageRec->pWSGroup, pWorkset, pObj, pThisPendingOp);
                break;
            }

            case OBJECT_REPLACE:
            {
                ObjectDoReplace(pomClient->putTask,
                    pUsageRec->pWSGroup, pWorkset, pObj, pThisPendingOp);
                break;
            }

            default:
            {
                ERROR_OUT(("Reached default case in switch statement (value: %hu)",
                    pThisPendingOp->type));
                break;
            }
        }

        //
        // The above functions all remove the pending op from the list, so get
        // the new first item
        //
        pThisPendingOp = (POM_PENDING_OP)COM_BasedListFirst(&(pWorkset->pendingOps), FIELD_OFFSET(OM_PENDING_OP, chain));
    }

    DebugExitVOID(ConfirmAll);
}




//
// DiscardAllObjects()
//
void DiscardAllObjects
(
    POM_USAGE_REC       pUsageRec,
    POM_WORKSET         pWorkset
)
{
    POM_OBJECTDATA_LIST pThisEntry;
    POM_OBJECTDATA_LIST pTempEntry;
    POM_OBJECTDATA      pData;

    DebugEntry(DiscardAllObjects);

    //
    // Chain through the Client's list of unused objects for this workset
    // group, free any unused objects which were allocated for this workset
    // and remove the entry from the list:
    //
    pThisEntry = (POM_OBJECTDATA_LIST)COM_BasedListFirst(&(pUsageRec->unusedObjects), FIELD_OFFSET(OM_OBJECTDATA_LIST, chain));

    while (pThisEntry != NULL)
    {
        //
        // Since we may be removing and freeing items from the list, we must
        // set up a pointer to the next link in the chain before proceeding:
        //
        pTempEntry = (POM_OBJECTDATA_LIST)COM_BasedListNext(&(pUsageRec->unusedObjects), pThisEntry, FIELD_OFFSET(OM_OBJECTDATA_LIST, chain));

        if (pThisEntry->worksetID == pWorkset->worksetID)
        {
            //
            // OK, this entry in the list is for an object allocated for this
            // workset, so find the object...
            //
            pData = pThisEntry->pData;
            if (!pData)
            {
                ERROR_OUT(("DiscardAllObjects:  object 0x%08x has no data", pThisEntry));
            }
            else
            {
                ValidateObjectData(pData);

                //
                // ...free it...
                //
                TRACE_OUT(("Discarding object at 0x%08x", pData));
                UT_FreeRefCount((void**)&pData, FALSE);
            }

            //
            // ...and remove the entry from the list:
            //
            COM_BasedListRemove(&(pThisEntry->chain));
            UT_FreeRefCount((void**)&pThisEntry, FALSE);
        }

        pThisEntry = pTempEntry;
    }

    DebugExitVOID(DiscardAllObjects);
}



//
// ObjectRelease(...)
//
UINT ObjectRelease
(
    POM_USAGE_REC       pUsageRec,
    OM_WORKSET_ID       worksetID,
    POM_OBJECT          pObj
)
{
    POM_OBJECT_LIST     pListEntry;
    POM_OBJECTDATA      pData;
    UINT                rc = 0;

    DebugEntry(ObjectRelease);

    if (pObj == NULL)
    {
        //
        // If <pObj> is NULL, our caller wants us to release the first
        // object in the objects-in-use list which is in the specified
        // workset:
        //

        COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pUsageRec->objectsInUse),
                (void**)&pListEntry, FIELD_OFFSET(OM_OBJECT_LIST, chain),
                FIELD_OFFSET(OM_OBJECT_LIST, worksetID), (DWORD)worksetID,
                FIELD_SIZE(OM_OBJECT_LIST, worksetID));
    }
    else
    {
        //
        // Otherwise, we do the lookup based on the object handle passed in:
        //
        // Note: since object handles are unique across worksets, we can just
        // do a match on the handle.  If the implementation of object handles
        // changes and they become specific to a workset and not globally
        // valid within a machine, we will need to do a double match here.
        //
        COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pUsageRec->objectsInUse),
                (void**)&pListEntry, FIELD_OFFSET(OM_OBJECT_LIST, chain),
                FIELD_OFFSET(OM_OBJECT_LIST, pObj), (DWORD_PTR)pObj,
                FIELD_SIZE(OM_OBJECT_LIST, pObj));
    }

    //
    // If we didn't find a relevant list entry, set rc and quit:
    //
    if (pListEntry == NULL)
    {
        rc = OM_RC_OBJECT_NOT_FOUND;
        DC_QUIT;
    }

    //
    // Now set pObj (will be a no-op if it wasn't originally NULL):
    //
    ASSERT((pListEntry->worksetID == worksetID));

    pObj = pListEntry->pObj;
    ValidateObject(pObj);

    pData = pObj->pData;
    if (!pData)
    {
        ERROR_OUT(("ObjectRelease:  object 0x%08x has no data", pObj));
    }
    else
    {
        ValidateObjectData(pData);

        //
        // Decrement use count of memory chunk holding object:
        //
        UT_FreeRefCount((void**)&pData, FALSE);
    }

    //
    // Remove the entry for this object from the objects-in-use list:
    //
    COM_BasedListRemove(&(pListEntry->chain));
    UT_FreeRefCount((void**)&pListEntry, FALSE);

DC_EXIT_POINT:
    DebugExitDWORD(ObjectRelease, rc);
    return(rc);
}




//
// WorksetClearPending(...)
//
BOOL WorksetClearPending
(
    POM_WORKSET         pWorkset,
    POM_OBJECT          pObj
)
{
    POM_PENDING_OP      pPendingOp;
    BOOL                rc = FALSE;

    DebugEntry(WorksetClearPending);

    //
    // Try to find a pending workset clear for the given workset.
    //
    // N.B.  We can't use FindPendingOp because we may want to check more
    //       than just the first pending workset clear.
    //
    pPendingOp = (POM_PENDING_OP)COM_BasedListFirst(&(pWorkset->pendingOps), FIELD_OFFSET(OM_PENDING_OP, chain));
    while (pPendingOp != NULL)
    {
        if (pPendingOp->type == WORKSET_CLEAR)
        {
            ValidateObject(pObj);

            //
            // Check that this clear affects the given object
            //
            if (STAMP_IS_LOWER(pObj->addStamp, pPendingOp->seqStamp))
            {
                TRACE_OUT(("Clear pending which affects object 0x%08x", pObj));
                rc = TRUE;
                DC_QUIT;
            }
            else
            {
                TRACE_OUT(("Clear pending but doesn't affect object 0x%08x", pObj));
            }
        }

        //
        // On to the next pending op...
        //
        pPendingOp = (POM_PENDING_OP)COM_BasedListNext(&(pWorkset->pendingOps), pPendingOp, FIELD_OFFSET(OM_PENDING_OP, chain));
    }

DC_EXIT_POINT:
    DebugExitDWORD(WorksetClearPending, rc);
    return(rc);
}



//
// ProcessWorksetNew(...)
//
UINT ProcessWorksetNew
(
    PUT_CLIENT              putClient,
    POMNET_OPERATION_PKT    pPacket,
    POM_WSGROUP             pWSGroup
)
{
    POM_DOMAIN              pDomain;
    POM_WORKSET             pWorkset;
    OM_WORKSET_ID           worksetID;
    UINT                    rc  = 0;

    DebugEntry(ProcessWorksetNew);

    worksetID = pPacket->worksetID;

    TRACE_OUT(("Creating workset %u in WSG %d", worksetID, pWSGroup->wsg));

    //
    // Allocate some memory for the workset record:
    //
    pWorkset = (POM_WORKSET)UT_MallocRefCount(sizeof(OM_WORKSET), TRUE);
    if (!pWorkset)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    //
    // Fill in the fields (this chunk is taken from a huge block so we have
    // to set it to zero explicitly):
    //
    // Note: the <position> and <flags> fields of the packet hold a
    // two-byte quantity representing the network priority for the workset.
    //
    SET_STAMP(pWorkset, WORKSET);
    pWorkset->priority    = *((NET_PRIORITY *) &(pPacket->position));
    pWorkset->fTemp       = *((BOOL *) &(pPacket->objectID));
    pWorkset->worksetID   = worksetID;

    pWorkset->lockState   = UNLOCKED;
    pWorkset->lockedBy    = 0;
    pWorkset->lockCount   = 0;

    COM_BasedListInit(&(pWorkset->objects));
    COM_BasedListInit(&(pWorkset->clients));
    COM_BasedListInit(&(pWorkset->pendingOps));

    if (pPacket->header.messageType == OMNET_WORKSET_CATCHUP)
    {
        //
        // For a WORKSET_CATCHUP message, the <userID> field of the
        // <seqStamp> field in the message holds the user ID of the node
        // which holds the workset lock, if it is locked.
        //
        if (pPacket->seqStamp.userID != 0)
        {
            //
            // If the <userID> field is the same as our user ID, then the
            // remote node must think that we've got the workset locked -
            // but we're just catching up, so something is wrong:
            //
            pDomain = pWSGroup->pDomain;

            ASSERT((pPacket->seqStamp.userID != pDomain->userID));

            pWorkset->lockState = LOCK_GRANTED;
            pWorkset->lockedBy  = pPacket->seqStamp.userID;
            pWorkset->lockCount = 0;

            TRACE_OUT(("Catching up with workset %u in WSG %d while locked by %hu",
                worksetID, pWSGroup->wsg, pWorkset->lockedBy));
        }

        //
        // In addition, the current generation number for the workset is
        // held in the <genNumber> field of the <seqStamp> field in the
        // message:
        //
        pWorkset->genNumber = pPacket->seqStamp.genNumber;
    }

    //
    // Find the offset within OMWORKSETS of the workset record and put it
    // in the array of offsets in the workset group record:
    //
    pWSGroup->apWorksets[worksetID] = pWorkset;

    //
    // Post a WORKSET_NEW event to all Clients registered with the workset
    // group:
    //
    WSGroupEventPost(putClient,
                     pWSGroup,
                     PRIMARY | SECONDARY,
                     OM_WORKSET_NEW_IND,
                     worksetID,
                     0);

    TRACE_OUT(("Processed WORKSET_NEW for workset ID %hu in WSG %d",
        worksetID, pWSGroup->wsg));


DC_EXIT_POINT:
    if (rc != 0)
    {
        ERROR_OUT(("ERROR %d creating workset %u in workset group '%s'",
            rc, worksetID, pWSGroup->wsg));

        if (pWorkset != NULL)
        {
            UT_FreeRefCount((void**)&pWorkset, FALSE);
        }

        pWSGroup->apWorksets[worksetID] = NULL;
    }

    DebugExitDWORD(ProcessWorksetNew, rc);
    return(rc);
}



//
// ProcessWorksetClear(...)
//
UINT ProcessWorksetClear
(
    PUT_CLIENT              putClient,
    POM_PRIMARY             pomPrimary,
    POMNET_OPERATION_PKT    pPacket,
    POM_WSGROUP             pWSGroup,
    POM_WORKSET             pWorkset
)
{
    POM_PENDING_OP          pPendingOp    = NULL;
    UINT                    numPosts;
    UINT                    rc = 0;

    DebugEntry(ProcessWorksetClear);

    //
    // Update the workset generation number:
    //
    UpdateWorksetGeneration(pWorkset, pPacket);

    //
    // See if this Clear operation can be spoiled (it will be spoiled if
    // another Clear operation with a later sequence stamp has already been
    // issued):
    //

    if (STAMP_IS_LOWER(pPacket->seqStamp, pWorkset->clearStamp))
    {
        TRACE_OUT(("Spoiling Clear with stamp 0x%08x:0x%08x ('previous': 0x%08x:0x%08x)",
            pPacket->seqStamp.userID,     pPacket->seqStamp.genNumber,
            pWorkset->clearStamp.userID,  pWorkset->clearStamp.genNumber));
        DC_QUIT;
    }

    //
    // Update the workset clear stamp:
    //

    COPY_SEQ_STAMP(pWorkset->clearStamp, pPacket->seqStamp);

    //
    // Now create a pending op CB to add to the list:
    //
    // Note: even if there is another Clear outstanding for the workset,
    //       we go ahead and put this one in the list and post another event
    //       to the Client.  If we didn't, then we would expose ourselves
    //       to the following situation:
    //
    //       1.  Clear issued
    //       1a.  Clear indication recd
    //       2.  Object added
    //       3.  Delete issued
    //       3a.  Delete indication recd - not filtered because unaffected
    //                                     by pending clear
    //       4.  Clear issued again - "takes over" previous Clear
    //       5.  Clear confirmed - causes object added in 2 to be deleted
    //       6.  Delete confirmed - assert because the delete WAS affected
    //                 by the second clear which "took over" earlier one.
    //
    //       A Client can still cause an assert by juggling the events and
    //       confirms, but we don't care because youo're not supposed to
    //       reorder ObMan events in any case.
    //

    pPendingOp = (POM_PENDING_OP)UT_MallocRefCount(sizeof(OM_PENDING_OP), FALSE);
    if (!pPendingOp)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    SET_STAMP(pPendingOp, PENDINGOP);

    pPendingOp->pObj        = 0;
    pPendingOp->pData       = NULL;
    pPendingOp->type        = WORKSET_CLEAR;

    COPY_SEQ_STAMP(pPendingOp->seqStamp, pPacket->seqStamp);

    COM_BasedListInsertBefore(&(pWorkset->pendingOps), &(pPendingOp->chain));

    //
    // Post a workset clear indication event to the Client:
    //
    numPosts = WorksetEventPost(putClient,
                    pWorkset,
                    PRIMARY,
                    OM_WORKSET_CLEAR_IND,
                    0);

    //
    // If there are no primaries present, then we won't be getting any
    // ClearConfirms, so we do it now:
    //

    if (numPosts == 0)
    {
        TRACE_OUT(("No local primary Client has workset %u in WSG %d open - clearing",
            pWorkset->worksetID, pWSGroup->wsg));

        WorksetDoClear(putClient, pWSGroup, pWorkset, pPendingOp);
    }

    TRACE_OUT(("Processed WORKSET_CLEAR for workset %u in WSG %d",
        pWorkset->worksetID, pWSGroup->wsg));


DC_EXIT_POINT:
    if (rc != 0)
    {
        ERROR_OUT(("ERROR %d processing clear for workset %u in WSG %d",
            rc, pWorkset->worksetID, pWSGroup->wsg));

        if (pPendingOp != NULL)
        {
            UT_FreeRefCount((void**)&pPendingOp, FALSE);
        }
    }

    DebugExitDWORD(ProcessWorksetClear, rc);
    return(rc);
}




//
// ProcessObjectAdd(...)
//
UINT ProcessObjectAdd
(
    PUT_CLIENT              putTask,
    POMNET_OPERATION_PKT    pPacket,
    POM_WSGROUP             pWSGroup,
    POM_WORKSET             pWorkset,
    POM_OBJECTDATA          pData,
    POM_OBJECT *            ppObj
)
{
    POM_OBJECT              pObj;
    UINT                    rc = 0;

    DebugEntry(ProcessObjectAdd);

    //
    // Update the workset generation number:
    //
    UpdateWorksetGeneration(pWorkset, pPacket);

    //
    // Create a new record for the object:
    //

    //
    // Allocate memory for the object record:
    //
    *ppObj = (POM_OBJECT)UT_MallocRefCount(sizeof(OM_OBJECT), FALSE);
    if (! *ppObj)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    pObj = *ppObj;

    //
    // Fill in the fields (remember, pData will be NULL if this is a
    // catchup for a deleted object):
    //
    SET_STAMP(pObj, OBJECT);
    pObj->updateSize    = pPacket->updateSize;
    pObj->pData         = pData;

    memcpy(&(pObj->objectID), &(pPacket->objectID), sizeof(OM_OBJECT_ID));

    //
    // How to set to the <flags> field and the sequence stamps depends on
    // whether this is a CATCHUP:
    //
    if (pPacket->header.messageType == OMNET_OBJECT_CATCHUP)
    {
        COPY_SEQ_STAMP(pObj->addStamp,      pPacket->seqStamp);
        COPY_SEQ_STAMP(pObj->positionStamp, pPacket->positionStamp);
        COPY_SEQ_STAMP(pObj->updateStamp,   pPacket->updateStamp);
        COPY_SEQ_STAMP(pObj->replaceStamp,  pPacket->replaceStamp);

        pObj->flags = pPacket->flags;
    }
    else
    {
        COPY_SEQ_STAMP(pObj->addStamp,      pPacket->seqStamp);
        COPY_SEQ_STAMP(pObj->positionStamp, pPacket->seqStamp);
        COPY_SEQ_STAMP(pObj->updateStamp,   pPacket->seqStamp);
        COPY_SEQ_STAMP(pObj->replaceStamp,  pPacket->seqStamp);

        pObj->flags = 0;
    }

    //
    // The following fields are not filled in since they are handled
    // by ObjectInsert, when the object is actually inserted into the
    // workset:
    //
    //  - chain
    //  - position
    //

    //
    // Insert the object into the workset:
    //
    ObjectInsert(pWorkset, pObj, pPacket->position);

    //
    // If the object has been deleted (which will only happen for a Catchup
    // of a deleted object), we don't need to do anything else, so just
    // quit:

    if (pObj->flags & DELETED)
    {
        ASSERT((pPacket->header.messageType == OMNET_OBJECT_CATCHUP));

        TRACE_OUT(("Processing Catchup for deleted object (ID: 0x%08x:0x%08x)",
            pObj->objectID.creator, pObj->objectID.sequence));

        DC_QUIT;
    }

    //
    // Otherwise, we continue...
    //
    // Increment the numObjects field:
    //
    // (we don't do this inside ObjectInsert since that's called when moving
    // objects also)
    //
    pWorkset->numObjects++;

    TRACE_OUT(("Number of objects in workset %u in WSG %d is now %u",
        pWorkset->worksetID, pWSGroup->wsg, pWorkset->numObjects));

    //
    // See if this Add can be spoiled (it is spoilable if the workset has
    // been cleared since the Add was issued):
    //
    // Note: even if the Add is to be spoiled, we must create a record for
    // it and insert it in the workset, for the same reason that we keep
    // records of deleted objects in the workset (i.e.  to differentiate
    // between operations which are for deleted objects and those which are
    // for objects not yet arrived).
    //

    if (STAMP_IS_LOWER(pPacket->seqStamp, pWorkset->clearStamp))
    {
        TRACE_OUT(("Spoiling Add with stamp 0x%08x:0x%08x (workset cleared at 0x%08x:0x%08x)",
            pPacket->seqStamp.userID,     pPacket->seqStamp.genNumber,
            pWorkset->clearStamp.userID,  pWorkset->clearStamp.genNumber));

        //
        // We "spoil" an Add by simply deleting it:
        //
        ObjectDoDelete(putTask, pWSGroup, pWorkset, pObj, NULL);

        DC_QUIT;
    }

    //
    // Post an add indication to all local Clients with the workset open:
    //
    WorksetEventPost(putTask,
                    pWorkset,
                    PRIMARY | SECONDARY,
                    OM_OBJECT_ADD_IND,
                    pObj);

    TRACE_OUT(("Added object to workset %u in WSG %d (handle: 0x%08x - ID: 0x%08x:0x%08x)",
        pWorkset->worksetID, pWSGroup->wsg, pObj,
        pObj->objectID.creator, pObj->objectID.sequence));

    TRACE_OUT((" position: %s - data at 0x%08x - size: %u - update size: %u",
        pPacket->position == LAST ? "LAST" : "FIRST", pData,
        pData->length, pPacket->updateSize));


DC_EXIT_POINT:
    if (rc != 0)
    {
        ERROR_OUT(("Error 0x%08x processing Add message", rc));
    }

    DebugExitDWORD(ProcessObjectAdd, rc);
    return(rc);
}




//
// ProcessObjectMove(...)
//
void ProcessObjectMove
(
    PUT_CLIENT              putTask,
    POMNET_OPERATION_PKT    pPacket,
    POM_WORKSET             pWorkset,
    POM_OBJECT              pObj
)
{
    DebugEntry(ProcessObjectMove);

    //
    // Update the workset generation number:
    //
    UpdateWorksetGeneration(pWorkset, pPacket);

    //
    // See if we can spoil this move:
    //

    if (STAMP_IS_LOWER(pPacket->seqStamp, pObj->positionStamp))
    {
        TRACE_OUT(("Spoiling Move with stamp 0x%08x:0x%08x ('previous': 0x%08x:0x%08x)",
               pPacket->seqStamp.userID,
               pPacket->seqStamp.genNumber,
               pObj->positionStamp.userID,
               pObj->positionStamp.genNumber));
        DC_QUIT;
    }

    //
    // Moving an object in a workset involves
    //
    // 1.  removing the object from its current position in the workset,
    //
    // 2.  setting its position stamp to the new value
    //
    // 3.  inserting it at its new position.
    //

    COM_BasedListRemove(&(pObj->chain));

    COPY_SEQ_STAMP(pObj->positionStamp, pPacket->seqStamp);

    ObjectInsert(pWorkset, pObj, pPacket->position);

    //
    // Post an indication to all local Clients with the workset open:
    //

    WorksetEventPost(putTask,
                    pWorkset,
                    PRIMARY | SECONDARY,
                    OM_OBJECT_MOVE_IND,
                    pObj);

DC_EXIT_POINT:
    TRACE_OUT(("Moved object 0x%08x to %s of workset %u",
        pObj, (pPacket->position == LAST ? "end" : "start"),
        pWorkset->worksetID));

    DebugExitVOID(ProcessObjectMove);
}




//
// ProcessObjectDRU(...)
//
UINT ProcessObjectDRU
(
    PUT_CLIENT              putTask,
    POMNET_OPERATION_PKT    pPacket,
    POM_WSGROUP             pWSGroup,
    POM_WORKSET             pWorkset,
    POM_OBJECT              pObj,
    POM_OBJECTDATA          pData
)
{
    UINT                    numPosts;
    POM_PENDING_OP          pPendingOp    = NULL;
    POM_OBJECTDATA          pPrevData;
    UINT                    event     = 0;      // event to post to Client
    OM_OPERATION_TYPE       type      = 0;      // type for pendingOp struct
    POM_SEQUENCE_STAMP      pSeqStamp = NULL;   // sequence stamp to update
    void (* fnObjectDoAction)(PUT_CLIENT, POM_WSGROUP, POM_WORKSET,
                                        POM_OBJECT,
                                        POM_PENDING_OP)   = NULL;
    UINT                    rc = 0;

    DebugEntry(ProcessObjectDRU);

    //
    // Set up the type variables:
    //
    switch (pPacket->header.messageType)
    {
        case OMNET_OBJECT_DELETE:
            event          = OM_OBJECT_DELETE_IND;
            type           = OBJECT_DELETE;
            pSeqStamp      = NULL;
            fnObjectDoAction = ObjectDoDelete;
            break;

        case OMNET_OBJECT_REPLACE:
            event          = OM_OBJECT_REPLACE_IND;
            type           = OBJECT_REPLACE;
            pSeqStamp      = &(pObj->replaceStamp);
            fnObjectDoAction = ObjectDoReplace;
            break;

        case OMNET_OBJECT_UPDATE:
            event          = OM_OBJECT_UPDATE_IND;
            type           = OBJECT_UPDATE;
            pSeqStamp      = &(pObj->updateStamp);
            fnObjectDoAction = ObjectDoUpdate;
            break;

        default:
            ERROR_OUT(("Reached default case in switch statement (value: %hu)",
                pPacket->header.messageType));
            break;
    }

    //
    // Update the workset generation number:
    //
    UpdateWorksetGeneration(pWorkset, pPacket);

    //
    // Now do some spoiling checks, unless the object is a Delete (Deletes
    // can't be spoiled):
    //
    if (type != OBJECT_DELETE)
    {
        ASSERT(((pSeqStamp != NULL) && (pData != NULL)));

       //
       // The first check is to see if this operation can be spoiled.  It
       // will be spoilable if the object has been updated/replaced since
       // the operation took place.  Since this function is called
       // synchronously for a local Update/Replace, this will only event
       // happen when a remote Update/Replace arrives "too late".
       //
       // The way we check is to compare the current stamp for the object
       // with the stamp for the operation:
       //
        if (STAMP_IS_LOWER(pPacket->seqStamp, *pSeqStamp))
        {
            TRACE_OUT(("Spoiling with stamp 0x%08x:0x%08x ('previous': 0x%08x:0x%08x)",
               pPacket->seqStamp.userID, pPacket->seqStamp.genNumber,
               (*pSeqStamp).userID,      (*pSeqStamp).genNumber));

            UT_FreeRefCount((void**)&pData, FALSE);
            DC_QUIT;
        }

        //
        // Update whichever of the object's stamps is involved by copying
        // in the stamp from the packet:
        //
        COPY_SEQ_STAMP(*pSeqStamp, pPacket->seqStamp);

        //
        // The second check is to see if this operation spoils a previous
        // one.  This will happen when a Client does two updates or two
        // replaces in quick succession i.e.  does the second
        // update/replace before confirming the first.
        //
        // In this case, we "spoil" the previous operation by removing the
        // previous pending op from the pending op list and inserting this
        // one instead.  Note that we do NOT post another event, as to do
        // so without adding net a new pending op would cause the Client to
        // assert on its second call to Confirm().
        //
        // Note: although in general a Replace will spoil a previous
        //       Update, it cannot do so in this case because if there is
        //       an Update outstanding, the Client will call UpdateConfirm
        //       so we must leave the Update pending and post a Replace
        //       event also.
        //
        FindPendingOp(pWorkset, pObj, type, &pPendingOp);

        if (pPendingOp != NULL)
        {
            //
            // OK, there is an operation of this type already outstanding
            // for this object.  So, we change the entry in the pending op
            // list to refer to this operation instead.  Before doing so,
            // however, we must free up the chunk holding the previous
            // (superceded) update/replace:
            //
            pPrevData = pPendingOp->pData;
            if (pPrevData != NULL)
            {
                UT_FreeRefCount((void**)&pPrevData, FALSE);
            }

            //
            // Now put the reference to the new update/replace in the
            // pending op:
            //
            pPendingOp->pData = pData;

            COPY_SEQ_STAMP(pPendingOp->seqStamp, pPacket->seqStamp);

            //
            // The rest of this function inserts the pending op in the
            // list, posts an event to local Client and performs the op if
            // there are none.  We know that
            //
            // - the op is in the list
            //
            // - there is an event outstanding because we found a pending
            //   op in the list
            //
            // - there are local Clients, for the same reason.
            //
            // Therefore, just quit:
            //
            DC_QUIT;
        }
        else
        {
            //
            // No outstanding operation of this type for this object, so do
            // nothing here and fall through to the standard processing:
            //
        }
    }
    else
    {
        //
        // Sanity check:
        //
        ASSERT((pData == NULL));

        pObj->flags |= PENDING_DELETE;
    }

    //
    // Add this operation to the workset's pending operation list:
    //
    pPendingOp = (POM_PENDING_OP)UT_MallocRefCount(sizeof(OM_PENDING_OP), FALSE);
    if (!pPendingOp)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    SET_STAMP(pPendingOp, PENDINGOP);

    pPendingOp->type        = type;
    pPendingOp->pData       = pData;
    pPendingOp->pObj        = pObj;

    COPY_SEQ_STAMP(pPendingOp->seqStamp, pPacket->seqStamp);

    TRACE_OUT(("Inserting %d in pending op list for workset %u", type,
       pWorkset->worksetID));

    COM_BasedListInsertBefore(&(pWorkset->pendingOps), &(pPendingOp->chain));

    //
    // Post an indication to all local Clients with the workset open:
    //
    numPosts = WorksetEventPost(putTask,
                     pWorkset,
                     PRIMARY,
                     event,
                     pObj);

    //
    // If no one has the workset open, we won't be getting any
    // DeleteConfirms, so we'd better do the delete straight away:
    //
    if (numPosts == 0)
    {
        TRACE_OUT(("Workset %hu in WSG %d not open: performing %d immediately",
           pWorkset->worksetID, pWSGroup->wsg, type));

        fnObjectDoAction(putTask, pWSGroup, pWorkset, pObj, pPendingOp);
    }

    TRACE_OUT(("Processed %d message for object 0x%08x in workset %u in WSG %d",
        type, pObj, pWorkset->worksetID, pWSGroup->wsg));


DC_EXIT_POINT:
    if (rc != 0)
    {
        //
        // Cleanup:
        //
        ERROR_OUT(("ERROR %d processing WSG %d message", rc, pWSGroup->wsg));

        if (pPendingOp != NULL)
        {
            UT_FreeRefCount((void**)&pPendingOp, FALSE);
        }
    }

    DebugExitDWORD(ProcessObjectDRU, rc);
    return(rc);
}






//
// ObjectInsert(...)
//
void ObjectInsert
(
    POM_WORKSET     pWorkset,
    POM_OBJECT      pObj,
    OM_POSITION     position
)
{
    POM_OBJECT      pObjTemp;
    PBASEDLIST         pChain;

    DebugEntry(ObjectInsert);

    //
    // The algorithm for inserting an object at the start (end) of a workset
    // is as follows:
    //
    // - search forward (back) from the first (last) object until one of the
    //   following happens:
    //
    //   - we find an object which does not have FIRST (LAST) as a position
    //     stamp
    //
    //   - we find an object which has a lower (lower) position stamp.
    //
    //   - we reach the root of the list of objects in the workset
    //
    // - insert the new object before (after) this object.
    //

    switch (position)
    {
        case FIRST:
        {
            pObjTemp = (POM_OBJECT)COM_BasedListFirst(&(pWorkset->objects), FIELD_OFFSET(OM_OBJECT, chain));
            while (pObjTemp != NULL)
            {
                ValidateObject(pObjTemp);

                if ((pObjTemp->position != position) ||
                    (STAMP_IS_LOWER(pObjTemp->positionStamp,
                                pObj->positionStamp)))
                {
                    break;
                }

                pObjTemp = (POM_OBJECT)COM_BasedListNext(&(pWorkset->objects), pObjTemp, FIELD_OFFSET(OM_OBJECT, chain));
            }
            break;
        }

        case LAST:
        {
            pObjTemp = (POM_OBJECT)COM_BasedListLast(&(pWorkset->objects), FIELD_OFFSET(OM_OBJECT, chain));
            while (pObjTemp != NULL)
            {
                ValidateObject(pObjTemp);

                if ((pObjTemp->position != position) ||
                    (STAMP_IS_LOWER(pObjTemp->positionStamp,
                                pObj->positionStamp)))
                {
                    break;
                }

                pObjTemp = (POM_OBJECT)COM_BasedListPrev(&(pWorkset->objects), pObjTemp, FIELD_OFFSET(OM_OBJECT, chain));
            }

            break;
        }

        default:
        {
            ERROR_OUT(("Reached default case in switch (position: %hu)", position));
            break;
        }
    }

    //
    // OK, we've found the correct position for the object.  If we reached
    // the end (start) of the workset, then we want to insert the object
    // before (after) the root, so we set up pChain accordingly:
    //

    if (pObjTemp == NULL)
    {
        pChain = &(pWorkset->objects);

        TRACE_OUT(("Inserting object into workset %u as the %s object",
            pWorkset->worksetID, position == LAST ? "last" : "first"));
    }
    else
    {
        pChain = &(pObjTemp->chain);

        TRACE_OUT(("Inserting object into workset %u %s object "
            "with record at 0x%08x (position stamp: 0x%08x:0x%08x)",
            pWorkset->worksetID,
            (position == LAST ? "after" : "before"),
            pObjTemp,  pObjTemp->objectID.creator,
            pObjTemp->objectID.sequence));
    }

    //
    // Now insert the object, either before or after the position we
    // determined above:
    //

    if (position == FIRST)
    {
        COM_BasedListInsertBefore(pChain, &(pObj->chain));
    }
    else
    {
        COM_BasedListInsertAfter(pChain, &(pObj->chain));
    }

    pObj->position = position;

    //
    // Now do a debug-only check to ensure correct order of objects:
    //
    CheckObjectOrder(pWorkset);

    DebugExitVOID(ObjectInsert);
}




//
// ObjectDoDelete(...)
//
void ObjectDoDelete
(
    PUT_CLIENT          putTask,
    POM_WSGROUP         pWSGroup,
    POM_WORKSET         pWorkset,
    POM_OBJECT          pObj,
    POM_PENDING_OP      pPendingOp
)
{
    POM_DOMAIN          pDomain;

    DebugEntry(ObjectDoDelete);

    //
    // We should never be called for an object that's already been deleted:
    //
    ValidateObject(pObj);
    ASSERT(!(pObj->flags & DELETED));

    //
    // Derive a pointer to the object itself and then free it:
    //
    if (!pObj->pData)
    {
        ERROR_OUT(("ObjectDoDelete:  object 0x%08x has no data", pObj));
    }
    else
    {
        ValidateObjectData(pObj->pData);
        UT_FreeRefCount((void**)&pObj->pData, FALSE);
    }

    //
    // Set the deleted flag in the object record:
    //
    // (note that we don't delete the object record entirely as we need to
    // keep track of deleted objects so that when we get operations from the
    // network for objects not in the workset, we can differentiate between
    // operations on objects
    //
    // - that haven't yet been added at this node (we keep these operations
    //   and perform them later) and
    //
    // - that have been deleted (we throw these operations away).
    //
    // A slight space optimisation would be to store the IDs of deleted
    // objects in a separate list, since we don't need any of the other
    // fields in the record.
    //

    pObj->flags |= DELETED;
    pObj->flags &= ~PENDING_DELETE;

    //
    // Remove the pending op from the list, if the pointer passed in is
    // valid (it won't be if we're called from WorksetDoClear, since those
    // deletes have not been "pending").
    //
    // In addition, if pPendingOp is not NULL, we post the DELETED event to
    // registered secondaries:
    //

    if (pPendingOp != NULL)
    {
        COM_BasedListRemove(&(pPendingOp->chain));
        UT_FreeRefCount((void**)&pPendingOp, FALSE);

        WorksetEventPost(putTask,
                       pWorkset,
                       SECONDARY,
                       OM_OBJECT_DELETED_IND,
                       pObj);
    }

    //
    // If we are in the local domain, we can safely delete the object rec:
    //
    pDomain = pWSGroup->pDomain;
    if (pDomain->callID == OM_NO_CALL)
    {
        TRACE_OUT(("Freeing pObj at 0x%08x", pObj));

        ValidateObject(pObj);

        COM_BasedListRemove(&(pObj->chain));
        UT_FreeRefCount((void**)&pObj, FALSE);
    }

    //
    // Decrement the number of objects in the workset:
    //
    ASSERT(pWorkset->numObjects > 0);
    pWorkset->numObjects--;

    DebugExitVOID(ObjectDoDelete);
}



//
// ObjectDoReplace(...)
//
void ObjectDoReplace
(
    PUT_CLIENT          putTask,
    POM_WSGROUP         pWSGroup,
    POM_WORKSET         pWorkset,
    POM_OBJECT          pObj,
    POM_PENDING_OP      pPendingOp
)
{
    POM_OBJECTDATA      pDataNew;
    POM_OBJECTDATA      pDataOld;
    UINT                rc = 0;

    DebugEntry(ObjectDoReplace);

    ValidateObject(pObj);

    //
    // If the object has already been deleted for whatever reason, quit:
    //
    if (pObj->flags & DELETED)
    {
        WARNING_OUT(("Asked to do replace for deleted object 0x%08x!", pObj));
        DC_QUIT;
    }

    //
    // Set up some local variables:
    //
    pDataOld = pObj->pData;

    pDataNew = pPendingOp->pData;
    ValidateObjectData(pDataNew);

    pObj->pData = pDataNew;

    //
    // If this object has been updated since this replace was issued, we
    // must ensure that the replace doesn't overwrite the "later" update:
    //
    //    Initial object at t=1                  AAAAAA
    //    Object updated (two bytes) at t=3;
    //    Object becomes:                        CCAAAA
    //
    //    Object replaced at t=2:                BBBB
    //    Must now re-enact the update:          CCBB
    //
    // Therefore, if the update stamp for the object is later than the stamp
    // of the replace instruction, we copy the first N bytes back over the
    // new object, where N is the size of the last update:
    //

    if (STAMP_IS_LOWER(pPendingOp->seqStamp, pObj->updateStamp))
    {
        ASSERT((pDataNew->length >= pObj->updateSize));

        memcpy(&(pDataNew->data), &(pDataOld->data), pObj->updateSize);
    }

    TRACE_OUT(("Replacing object 0x%08x with data at 0x%08x (old data at 0x%08x)",
       pObj, pDataNew, pDataOld));

    //
    // We also need to free up the chunk holding the old object:
    //
    if (!pDataOld)
    {
        ERROR_OUT(("ObjectDoReplace:  object 0x%08x has no data", pObj));
    }
    else
    {
        UT_FreeRefCount((void**)&pDataOld, FALSE);
    }

    //
    // Now that we've replaced the object, post a REPLACED event to all
    // secondaries:
    //

    WorksetEventPost(putTask,
                     pWorkset,
                     SECONDARY,
                     OM_OBJECT_REPLACED_IND,
                     pObj);


DC_EXIT_POINT:
    //
    // We've either done the replace or abandoned it because the object has
    // been deleted; either way, free up the entry in the pending op list:
    //

    COM_BasedListRemove(&(pPendingOp->chain));
    UT_FreeRefCount((void**)&pPendingOp, FALSE);

    DebugExitVOID(ObjectDoReplace);
}




//
// ObjectDoUpdate(...)
//
void ObjectDoUpdate
(
    PUT_CLIENT          putTask,
    POM_WSGROUP         pWSGroup,
    POM_WORKSET         pWorkset,
    POM_OBJECT          pObj,
    POM_PENDING_OP      pPendingOp
)
{
    POM_OBJECTDATA      pDataNew;
    UINT                rc = 0;

    DebugEntry(ObjectDoUpdate);

    ValidateObject(pObj);

    //
    // If the object has already been deleted for whatever reason, quit:
    //
    if (pObj->flags & DELETED)
    {
        WARNING_OUT(("Asked to do update for deleted object 0x%08x!", pObj));
        DC_QUIT;
    }

    pDataNew = pPendingOp->pData;
    if (!pObj->pData)
    {
        ERROR_OUT(("ObjectDoUpdate:  object 0x%08x has no data", pObj));
    }
    else
    {
        ValidateObjectData(pObj->pData);

        //
        // Updating an object involves copying <length> bytes from the <data>
        // field of the update over the start of the <data> field of the
        // existing object:
        //
        memcpy(&(pObj->pData->data), &(pDataNew->data), pDataNew->length);
    }

    UT_FreeRefCount((void**)&pDataNew, FALSE);

    //
    // Now that we've updated the object, post an UPDATED event to all
    // secondaries:
    //

    WorksetEventPost(putTask,
                     pWorkset,
                     SECONDARY,
                     OM_OBJECT_UPDATED_IND,
                     pObj);


DC_EXIT_POINT:
    //
    // We've done the update, so free up the entry in the pending op list:
    //
    COM_BasedListRemove(&(pPendingOp->chain));
    UT_FreeRefCount((void**)&pPendingOp, FALSE);

    DebugExitVOID(ObjectDoUpdate);
}



//
// ObjectIDToPtr(...)
//
UINT ObjectIDToPtr
(
    POM_WORKSET         pWorkset,
    OM_OBJECT_ID        objectID,
    POM_OBJECT *        ppObj
)
{
    POM_OBJECT          pObj;
    UINT                rc = 0;

    DebugEntry(ObjectIDToPtr);

    //
    // To find the handle, we chain through each of the object records in
    // the workset and compare the id of each one with the required ID:
    //

    TRACE_OUT(("About to search object records looking for ID 0x%08x:0x%08x",
        objectID.creator, objectID.sequence));

    ValidateWorkset(pWorkset);

    pObj = (POM_OBJECT)COM_BasedListFirst(&(pWorkset->objects), FIELD_OFFSET(OM_OBJECT, chain));
    while (pObj != NULL)
    {
        ValidateObject(pObj);

        TRACE_OUT(("Comparing against object at 0x%08x (ID: 0x%08x:0x%08x)",
           pObj,
           pObj->objectID.creator,
           pObj->objectID.sequence));

        if (OBJECT_IDS_ARE_EQUAL(pObj->objectID, objectID))
        {
            break;
        }

        pObj = (POM_OBJECT)COM_BasedListNext(&(pWorkset->objects), pObj, FIELD_OFFSET(OM_OBJECT, chain));
    }

    //
    // If object record not found, warn:
    //

    if (pObj == NULL)
    {
        TRACE_OUT(("Object with ID 0x%08x:0x%08x not found",
           objectID.creator, objectID.sequence));

        rc = OM_RC_BAD_OBJECT_ID;
        DC_QUIT;
    }

    *ppObj = pObj;

    //
    // If object record found but object deleted or pending delete, warn:
    //

    if (pObj->flags & DELETED)
    {
        TRACE_OUT(("Object record found (handle: 0x%08x) for ID 0x%08x:0x%08x "
           "but object deleted",
           *ppObj, objectID.creator, objectID.sequence));
        rc = OM_RC_OBJECT_DELETED;
        DC_QUIT;
    }

    if (pObj->flags & PENDING_DELETE)
    {
        TRACE_OUT(("Object record found (handle: 0x%08x) for ID 0x%08x:0x%08x "
           "but object pending delete",
           *ppObj, objectID.creator, objectID.sequence));
        rc = OM_RC_OBJECT_PENDING_DELETE;
        DC_QUIT;
    }


DC_EXIT_POINT:
    DebugExitDWORD(ObjectIDToPtr, rc);
    return(rc);

}



//
// GenerateOpMessage(...)
//
UINT GenerateOpMessage
(
    POM_WSGROUP             pWSGroup,
    OM_WORKSET_ID           worksetID,
    POM_OBJECT_ID           pObjectID,
    POM_OBJECTDATA          pData,
    OMNET_MESSAGE_TYPE      messageType,
    POMNET_OPERATION_PKT *  ppPacket
)
{
    POMNET_OPERATION_PKT    pPacket;
    POM_DOMAIN              pDomain;
    POM_WORKSET             pWorkset       = NULL;
    UINT                    rc = 0;

    DebugEntry(GenerateOpMessage);

    //
    // Set up Domain record pointer:
    //
    pDomain = pWSGroup->pDomain;

    TRACE_OUT(("Generating message for operation type 0x%08x", messageType));

    //
    // Allocate some memory for the packet:
    //
    pPacket = (POMNET_OPERATION_PKT)UT_MallocRefCount(sizeof(OMNET_OPERATION_PKT), TRUE);
    if (!pPacket)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    //
    // Here, we fill in the fields common to all types of messages:
    //
    pPacket->header.sender      = pDomain->userID;
    pPacket->header.messageType = messageType;

    //
    // The <totalSize> field is the number of bytes in the header packet
    // plus the number of associated data bytes, if any.  For the moment, we
    // set it to the size of the header only; we'll add the size of the data
    // later:
    //
    pPacket->totalSize = GetMessageSize(messageType);

    pPacket->wsGroupID = pWSGroup->wsGroupID;
    pPacket->worksetID = worksetID;

    //
    // If this is a WorksetNew operation, there will be no workset yet and
    // thus no valid sequence stamp, so we use a null sequence stamp.
    // Otherwise, we take the value from the workset.
    //

    if (messageType == OMNET_WORKSET_NEW)
    {
        SET_NULL_SEQ_STAMP(pPacket->seqStamp);
    }
    else
    {
        pWorkset =  pWSGroup->apWorksets[worksetID];
        ASSERT((pWorkset != NULL));
        GET_CURR_SEQ_STAMP(pPacket->seqStamp, pDomain, pWorkset);
    }

    //
    // If this is a workset operation, <pObjectID> will be NULL, so we set
    // the object ID in the packet to NULL also:
    //
    if (pObjectID == NULL)
    {
        ZeroMemory(&(pPacket->objectID), sizeof(OM_OBJECT_ID));
    }
    else
    {
        memcpy(&(pPacket->objectID), pObjectID, sizeof(OM_OBJECT_ID));
    }

    //
    // If this message is associated with object data, we must add the size
    // of this data (including the size of the <length> field itself).  The
    // test for this is if the <pData> parameter is not NULL:
    //
    if (pData != NULL)
    {
        pPacket->totalSize += pData->length + sizeof(pData->length);
    }

    //
    // For a WORKSET_CATCHUP message, we need to let the other node know if
    // the workset is locked and if so, by whom:
    //

    if (messageType == OMNET_WORKSET_CATCHUP)
    {
        //
        // pWorkset should have been set up above:
        //
        ASSERT((pWorkset != NULL));

        //
        // Put the ID of the node which owns the workset lock in the <userID>
        // field of the <seqStamp> field of the packet:
        //
        pPacket->seqStamp.userID = pWorkset->lockedBy;

        TRACE_OUT(("Set <lockedBy> field in WORKSET_CATCHUP to %hu",
                 pWorkset->lockedBy));

        //
        // Now we put the current generation number for the workset in the
        // <genNumber> field of the <seqStamp> field of the packet:
        //
        pPacket->seqStamp.genNumber = pWorkset->genNumber;

        TRACE_OUT(("Set generation number field in WORKSET_CATCHUP to %u",
        pPacket->seqStamp.genNumber));

        //
        // Fill in the priority value for the workset, which goes in the two
        // bytes occupied by the <position> and <flags> fields:
        //
        *((NET_PRIORITY *) &(pPacket->position)) = pWorkset->priority;
        *((BOOL *) &(pPacket->objectID)) = pWorkset->fTemp;
    }

    //
    // We do not fill in the following fields:
    //
    //    position
    //    flags
    //    updateSize
    //
    // This is because these are used only in a minority of messages and to
    // add the extra parameters to the GenerateOpMessage function seemed
    // undesirable.  Messages where these fields are used should be filled
    // in by the calling function as appropriate.
    //

    //
    // Set the caller's pointer:
    //
    *ppPacket = pPacket;


DC_EXIT_POINT:
    if (rc != 0)
    {
        ERROR_OUT(("ERROR %d generating message of type 0x%08x",
                 rc, messageType));
    }

    DebugExitDWORD(GenerateOpMessage, rc);
    return(rc);
}



//
// QueueMessage(...)
//
UINT QueueMessage
(
    PUT_CLIENT          putTask,
    POM_DOMAIN          pDomain,
    NET_CHANNEL_ID      channelID,
    NET_PRIORITY        priority,
    POM_WSGROUP         pWSGroup,
    POM_WORKSET         pWorkset,
    POM_OBJECT          pObj,
    POMNET_PKT_HEADER   pMessage,
    POM_OBJECTDATA      pData,
    BOOL                compressOrNot
)
{
    POM_SEND_INST       pSendInst;
    NET_PRIORITY        queuePriority;
    BOOL                locked =            FALSE;
    BOOL                bumped =            FALSE;
    UINT                rc =                0;

    DebugEntry(QueueMessage);

    //
    // If this is the local Domain, we don't put the op on the send queue;
    // just free the packet and quit:
    //
    if (pDomain->callID == NET_INVALID_DOMAIN_ID)
    {
        TRACE_OUT(("Not queueing message (it's for the local Domain)"));
        UT_FreeRefCount((void**)&pMessage, FALSE);
        DC_QUIT;
    }

    //
    // Allocate some memory in OMGLOBAL for the send instruction:
    //
    pSendInst = (POM_SEND_INST)UT_MallocRefCount(sizeof(OM_SEND_INST), TRUE);
    if (!pSendInst)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }
    SET_STAMP(pSendInst, SENDINST);

    //
    // Fill in the fields of the send instruction:
    //
    pSendInst->messageSize = (WORD)GetMessageSize(pMessage->messageType);

    DeterminePriority(&priority, pData);

    pSendInst->priority      = priority;
    pSendInst->callID        = pDomain->callID;
    pSendInst->channel       = channelID;
    pSendInst->messageType   = pMessage->messageType;
    pSendInst->compressOrNot = compressOrNot;

    //
    // Now calculate the relevant offsets so we can add them to the ObMan
    // base pointers:
    //
    // SFR 2560 { : bump use counts of all non-zero pointers, not just pData
    //
    if (pMessage != NULL)
    {
        pSendInst->pMessage = pMessage;

        //
        // SFR 5488 { : No!  Don't bump use count of pMessage - we're the
        // only people using it now so we don't need to.  }
        //
    }

    if (pWSGroup != NULL)
    {
        UT_BumpUpRefCount(pWSGroup);
        pSendInst->pWSGroup = pWSGroup;
    }

    if (pWorkset != NULL)
    {
        UT_BumpUpRefCount(pWorkset);
        pSendInst->pWorkset = pWorkset;
    }

    if (pObj != NULL)
    {
        UT_BumpUpRefCount(pObj);
        pSendInst->pObj = pObj;
    }

    if (pData != NULL)
    {
        UT_BumpUpRefCount(pData);

        pSendInst->pDataStart   = pData;
        pSendInst->pDataNext    = pData;

        //
        // In addition, we set up some send instruction fields which are
        // specific to operations which involve object data:
        //
        pSendInst->dataLeftToGo = pData->length + sizeof(pData->length);

        //
        // Increment the <bytesUnacked> fields in the workset and workset
        // group:
        //
        pWorkset->bytesUnacked += pSendInst->dataLeftToGo;
        pWSGroup->bytesUnacked += pSendInst->dataLeftToGo;

        TRACE_OUT(("Bytes unacked for workset %u in WSG %d now %u "
            "(for wsGroup: %u)", pWorkset->worksetID, pWSGroup->wsg,
            pWorkset->bytesUnacked, pWSGroup->bytesUnacked));
    }

    //
    // Set a flag so we can clean up a bit better on error:
    //
    bumped = TRUE;

    //
    // Unless there's a send event outstanding, post an event to the ObMan
    // task prompting it to examine the send queue. Providing we have
    // received a Net Attach indication.
    //
    if ( !pDomain->sendEventOutstanding &&
        (pDomain->state > PENDING_ATTACH) )
    {
        TRACE_OUT(("No send event outstanding - posting SEND_QUEUE event"));

        //
        // Bump up the use count of the Domain record (since we're passing it
        // in an event):
        //
        UT_BumpUpRefCount(pDomain);

        //
        // NFC - we used to pass the pDomain pointer as param2 in this
        // event, but the event may get processed in a different process
        // where the pointer is no longer valid, so pass the offset instead.
        //
        ValidateOMP(g_pomPrimary);

        UT_PostEvent(putTask,
                   g_pomPrimary->putTask,
                   0,                                           // no delay
                   OMINT_EVENT_SEND_QUEUE,
                   0,
                   (UINT_PTR)pDomain);

        pDomain->sendEventOutstanding = TRUE;
    }
    else
    {
        TRACE_OUT(("Send event outstanding/state %u: not posting SEND_QUEUE event",
                   pDomain->state));
    }

    //
    // Place the event at the end of the relevant send queue.  This depends
    // on priority - but remember, the priority value passed in might have
    // the NET_SEND_ALL_PRIORITIES flag set - so clear it when determining
    // the queue.
    //
    // NB: Do this after any possible DC-QUIT so we're not left with a
    //     NULL entry in the list.
    //
    queuePriority = priority;
    queuePriority &= ~NET_SEND_ALL_PRIORITIES;
    COM_BasedListInsertBefore(&(pDomain->sendQueue[queuePriority]),
                        &(pSendInst->chain));

    TRACE_OUT((" Queued instruction (type: 0x%08x) at priority %hu "
        "on channel 0x%08x in Domain %u",
        pMessage->messageType, priority, channelID, pDomain->callID));


DC_EXIT_POINT:

    if (rc != 0)
    {
        //
        // Cleanup:
        //
        ERROR_OUT(("ERROR %d queueing send instruction (message type: %hu)",
            rc, pMessage->messageType));

        if (pSendInst != NULL)
        {
            UT_FreeRefCount((void**)&pSendInst, FALSE);
        }

        if (bumped == TRUE)
        {
            // SFR 2560 { : Free all non-zero pointers not just pData
            if (pMessage != NULL)
            {
                UT_FreeRefCount((void**)&pMessage, FALSE);
            }

            if (pWSGroup != NULL)
            {
                UT_FreeRefCount((void**)&pWSGroup, FALSE);
            }

            if (pWorkset != NULL)
            {
                UT_FreeRefCount((void**)&pWorkset, FALSE);
            }

            if (pObj != NULL)
            {
                UT_FreeRefCount((void**)&pObj, FALSE);
            }

            if (pData != NULL)
            {
                UT_FreeRefCount((void**)&pData, FALSE);
            }
        }
    }

    DebugExitDWORD(QueueMessage, rc);
    return(rc);
}



//
// DeterminePriority(...)
//
void DeterminePriority
(
    NET_PRIORITY *      pPriority,
    POM_OBJECTDATA      pData
)
{

    DebugEntry(DeterminePriority);

    if (OM_OBMAN_CHOOSES_PRIORITY == *pPriority)
    {
        if (pData != NULL)
        {
            if (pData->length < OM_NET_HIGH_PRI_THRESHOLD)
            {
                *pPriority = NET_HIGH_PRIORITY;
            }
            else if (pData->length < OM_NET_MED_PRI_THRESHOLD)
            {
                *pPriority = NET_MEDIUM_PRIORITY;
            }
            else
            {
                *pPriority = NET_LOW_PRIORITY;
            }

            TRACE_OUT(("Priority chosen: %hu (data size: %u)",
                *pPriority, pData->length));
        }
        else
        {
            *pPriority = NET_HIGH_PRIORITY;
        }
    }
    else
    {
        TRACE_OUT(("Priority specified is %hu - not changing", *pPriority));
    }

    DebugExitVOID(DeterminePriority);
}




//
// GetMessageSize(...)
//
UINT GetMessageSize
(
    OMNET_MESSAGE_TYPE  messageType
)
{
    UINT        size;

    DebugEntry(GetMessageSize);

    switch (messageType)
    {
        case OMNET_HELLO:
        case OMNET_WELCOME:
            size = sizeof(OMNET_JOINER_PKT);
            break;

        case OMNET_LOCK_REQ:
        case OMNET_LOCK_GRANT:
        case OMNET_LOCK_DENY:
        case OMNET_LOCK_NOTIFY:
        case OMNET_UNLOCK:
            size = sizeof(OMNET_LOCK_PKT);
            break;

        case OMNET_WSGROUP_SEND_REQ:
        case OMNET_WSGROUP_SEND_MIDWAY:
        case OMNET_WSGROUP_SEND_COMPLETE:
        case OMNET_WSGROUP_SEND_DENY:
            size = sizeof(OMNET_WSGROUP_SEND_PKT);
            break;

        //
        // The remaining messages all use OMNET_OPERATION_PKT packets, but
        // each uses different amounts of the generic packet.  Therefore, we
        // can't use sizeof so we've got some defined constants instead:
        //
        case OMNET_WORKSET_NEW:
            size = OMNET_WORKSET_NEW_SIZE;
            break;

        case OMNET_WORKSET_CATCHUP:
            size = OMNET_WORKSET_CATCHUP_SIZE;
            break;

        case OMNET_WORKSET_CLEAR:
            size = OMNET_WORKSET_CLEAR_SIZE;
            break;

        case OMNET_OBJECT_MOVE:
            size = OMNET_OBJECT_MOVE_SIZE;
            break;

        case OMNET_OBJECT_DELETE:
            size = OMNET_OBJECT_DELETE_SIZE;
            break;

        case OMNET_OBJECT_REPLACE:
            size = OMNET_OBJECT_REPLACE_SIZE;
            break;

        case OMNET_OBJECT_UPDATE:
            size = OMNET_OBJECT_UPDATE_SIZE;
            break;

        case OMNET_OBJECT_ADD:
            size = OMNET_OBJECT_ADD_SIZE;
            break;

        case OMNET_OBJECT_CATCHUP:
            size = OMNET_OBJECT_CATCHUP_SIZE;
            break;

        case OMNET_MORE_DATA:
            size = OMNET_MORE_DATA_SIZE;
            break;

        default:
            ERROR_OUT(("Reached default case in switch statement (type: %hu)",
                messageType));
            size = 0;
            break;
    }

    DebugExitDWORD(GetMessageSize, size);
    return(size);
}



//
// WorksetEventPost()
//
UINT WorksetEventPost
(
    PUT_CLIENT          putTask,
    POM_WORKSET         pWorkset,
    BYTE                target,
    UINT                event,
    POM_OBJECT          pObj
)
{
    POM_CLIENT_LIST     pClientListEntry;
    OM_EVENT_DATA16     eventData16;
    UINT                numPosts;

    DebugEntry(WorksetEventPost);

    //
    // Need to post the event to each Client which has the workset open, so
    // we chain through the list of Clients stored in the workset record:
    //
    numPosts = 0;

    pClientListEntry = (POM_CLIENT_LIST)COM_BasedListFirst(&(pWorkset->clients), FIELD_OFFSET(OM_CLIENT_LIST, chain));
    while (pClientListEntry != NULL)
    {
        //
        // <target> specifies which type of Client we are to post events to
        // and is PRIMARY and/or SECONDARY (ORed together if both).  Check
        // against this Client's registration mode:
        //
        if (target & pClientListEntry->mode)
        {
            //
            // If the pObj was not NULL, bump the use count for the object
            // record.  If this fails, give up:
            //
            if (pObj != NULL)
            {
                ValidateObject(pObj);
                UT_BumpUpRefCount(pObj);
            }

            //
            // Fill in the fields of the event parameter, using the workset
            // group handle as found in the Client list and the workset ID as
            // found in the workset record:
            //
            eventData16.hWSGroup  = pClientListEntry->hWSGroup;
            eventData16.worksetID = pWorkset->worksetID;

            UT_PostEvent(putTask,
                        pClientListEntry->putTask,
                      0,
                      event,
                      *(PUINT) &eventData16,
                      (UINT_PTR)pObj);

            numPosts++;
        }

        pClientListEntry = (POM_CLIENT_LIST)COM_BasedListNext(&(pWorkset->clients), pClientListEntry,
            FIELD_OFFSET(OM_CLIENT_LIST, chain));
    }


    TRACE_OUT(("Posted event 0x%08x to %hu Clients (those with workset %u open)",
        event, numPosts, pWorkset->worksetID));

    DebugExitDWORD(WorksetEventPost, numPosts);
    return(numPosts);
}


//
// WSGroupEventPost(...)
//
UINT WSGroupEventPost
(
    PUT_CLIENT          putFrom,
    POM_WSGROUP         pWSGroup,
    BYTE                target,
    UINT                event,
    OM_WORKSET_ID       worksetID,
    UINT_PTR            param2
)
{
    POM_CLIENT_LIST     pClientListEntry;
    OM_EVENT_DATA16     eventData16;
    UINT                numPosts;
    UINT                rc = 0;

    DebugEntry(WSGroupEventPost);

    //
    // Need to post the event to each Client which is registered with the
    // workset group, so we chain through the list of Clients stored in the
    // workset group record:
    //
    numPosts = 0;

    pClientListEntry = (POM_CLIENT_LIST)COM_BasedListFirst(&(pWSGroup->clients), FIELD_OFFSET(OM_CLIENT_LIST, chain));
    while (pClientListEntry != NULL)
    {
        //
        // <target> specifies which type of Client we are to post events to
        // and is PRIMARY and/or SECONDARY (ORed together if both).  Check
        // against this Client's registration mode:
        //
        if (target & pClientListEntry->mode)
        {
            //
            // Fill in the fields of the event parameter, using the workset
            // group handle as found in the Client list and the workset ID
            // passed in:
            //
            eventData16.hWSGroup  = pClientListEntry->hWSGroup;
            eventData16.worksetID = worksetID;

            TRACE_OUT(("Posting event 0x%08x to 0x%08x (hWSGroup: %hu - worksetID: %hu)",
                event, pClientListEntry->putTask, eventData16.hWSGroup,
                eventData16.worksetID));

            UT_PostEvent(putFrom,
                      pClientListEntry->putTask,
                      0,
                      event,
                      *(PUINT) &eventData16,
                      param2);

            numPosts++;
        }

        pClientListEntry = (POM_CLIENT_LIST)COM_BasedListNext(&(pWSGroup->clients), pClientListEntry, FIELD_OFFSET(OM_CLIENT_LIST, chain));
    }


    TRACE_OUT(("Posted event 0x%08x to %hu Clients (all registered with '0x%08x')",
        event, numPosts, pWSGroup->wsg));

    DebugExitDWORD(WSGroupEventPost, numPosts);
    return(numPosts);
}



//
// WorksetDoClear(...)
//
void WorksetDoClear
(
    PUT_CLIENT          putTask,
    POM_WSGROUP         pWSGroup,
    POM_WORKSET         pWorkset,
    POM_PENDING_OP      pPendingOp
)
{
    POM_OBJECT          pObj;
    POM_OBJECT          pObj2;
    BOOL                locked      = FALSE;

    DebugEntry(WorksetDoClear);

    //
    // To clear a workset, we chain through each object in the workset and
    // compare its addition stamp to the stamp of the clear operation we're
    // performing.  If the object was added before the workset clear was
    // issued, we delete the object.  Otherwise, we ignore it.
    //
    TRACE_OUT(("Clearing workset %u...", pWorkset->worksetID));

    pObj = (POM_OBJECT)COM_BasedListLast(&(pWorkset->objects), FIELD_OFFSET(OM_OBJECT, chain));

    while (pObj != NULL)
    {
        ValidateObject(pObj);

        pObj2 = (POM_OBJECT)COM_BasedListPrev(&(pWorkset->objects), pObj, FIELD_OFFSET(OM_OBJECT, chain));

        if (pObj->flags & DELETED)
        {
            //
            // Do nothing
            //
        }
        else
        {
            if (STAMP_IS_LOWER(pObj->addStamp, pPendingOp->seqStamp))
            {
                TRACE_OUT(("Object 0x%08x added before workset cleared, deleting",
                    pObj));

                PurgePendingOps(pWorkset, pObj);

                ObjectDoDelete(putTask, pWSGroup, pWorkset, pObj, NULL);
            }
        }

        // restore the previous one
        pObj = pObj2;
    }

    //
    // This operation isn't pending anymore, so we remove it from the
    // pending operation list and free the memory:
    //

    COM_BasedListRemove(&(pPendingOp->chain));
    UT_FreeRefCount((void**)&pPendingOp, FALSE);

    //
    // Now that we've cleared the workset, post a CLEARED event to all
    // secondaries:
    //

    WorksetEventPost(putTask,
                    pWorkset,
                    SECONDARY,
                    OM_WORKSET_CLEARED_IND,
                    0);


    TRACE_OUT(("Cleared workset %u", pWorkset->worksetID));

    DebugExitVOID(WorksetDoClear);
}



//
// WorksetCreate(...)
//
UINT WorksetCreate
(
    PUT_CLIENT              putTask,
    POM_WSGROUP             pWSGroup,
    OM_WORKSET_ID           worksetID,
    BOOL                    fTemp,
    NET_PRIORITY            priority
)
{
    POMNET_OPERATION_PKT    pPacket;
    UINT                    rc = 0;

    DebugEntry(WorksetCreate);

    //
    // Here we create the new workset by generating the message to be
    // broadcast, processing it as if it had just arrived, and then
    // queueing it to be sent:
    //
    rc = GenerateOpMessage(pWSGroup,
                           worksetID,
                           NULL,                       // no object ID
                           NULL,                       // no object
                           OMNET_WORKSET_NEW,
                           &pPacket);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // Fill in the priority value for the workset, which goes in the two
    // bytes occupied by the <position> and <flags> fields:
    //

    *((NET_PRIORITY *) &(pPacket->position)) = priority;
    *((BOOL     *) &(pPacket->objectID)) = fTemp;

    rc = ProcessWorksetNew(putTask, pPacket, pWSGroup);
    if (rc != 0)
    {
       DC_QUIT;
    }

    //
    // NEW FOR R2.0
    //
    // In R2.0, the checkpointing mechanism used by a helper to get up to
    // date before sending a workset group to a late joiner relies on
    // locking a "dummy" workset (#255) in the workset group in question.
    // So, if the workset ID is 255, this is the dummy workset.  We do not
    // broadcast the WORKSET_NEW for this dummy workset, for two reasons:
    //
    // - it will confuse R1.1 systems
    //
    // - all other R2.0 systems will create it locally just as we have, so
    //   there isn't any need.
    //
    // So, do a check and free up the send packet if necessary; otherwise
    // queue the message as normal:
    //
    if (worksetID == OM_CHECKPOINT_WORKSET)
    {
        TRACE_OUT(("WORKSET_NEW for checkpointing dummy workset - not queueing"));
        UT_FreeRefCount((void**)&pPacket, FALSE);
    }
    else
    {
        rc = QueueMessage(putTask,
                          pWSGroup->pDomain,
                          pWSGroup->channelID,
                          priority,
                          pWSGroup,
                          NULL,
                          NULL,                         // no object
                          (POMNET_PKT_HEADER) pPacket,
                          NULL,                         // no object data
                        TRUE);
        if (rc != 0)
        {
            DC_QUIT;
        }
    }

    TRACE_OUT(("Created workset ID %hu in WSG %d for TASK 0x%08x",
       worksetID, pWSGroup->wsg, putTask));

DC_EXIT_POINT:
    if (rc != 0)
    {
        //
        // Cleanup:
        //
        ERROR_OUT(("Error 0x%08x creating workset ID %hu in WSG %d for TASK 0x%08x",
            rc, worksetID, pWSGroup->wsg, putTask));
    }

    DebugExitDWORD(WorksetCreate, rc);
    return(rc);
}



//
// ObjectAdd(...)
//
UINT ObjectAdd
(
    PUT_CLIENT          putTask,
    POM_PRIMARY         pomPrimary,
    POM_WSGROUP         pWSGroup,
    POM_WORKSET         pWorkset,
    POM_OBJECTDATA      pData,
    UINT                updateSize,
    OM_POSITION         position,
    OM_OBJECT_ID  *     pObjectID,
    POM_OBJECT *        ppObj
)
{
    POM_OBJECT           pObj;
    POMNET_OPERATION_PKT    pPacket;
    POM_DOMAIN              pDomain;
    UINT                    rc = 0;

    DebugEntry(ObjectAdd);

    TRACE_OUT(("Adding object to workset %u in WSG %d",
        pWorkset->worksetID, pWSGroup->wsg));

    //
    // Allocate a new ID for this object:
    //
    pDomain = pWSGroup->pDomain;
    GET_NEXT_OBJECT_ID(*pObjectID, pDomain, pomPrimary);

    //
    // Generate the OMNET_OBJECT_ADD message:
    //

    rc = GenerateOpMessage(pWSGroup,
                          pWorkset->worksetID,
                          pObjectID,
                          pData,
                          OMNET_OBJECT_ADD,
                          &pPacket);
    if (rc != 0)
    {
        pPacket = NULL;
        DC_QUIT;
    }

    //
    // Generate message doesn't fill in the <updateSize> or <position>
    // fields (as they are specific to ObjectAdd) so we do them here:
    //

    pPacket->updateSize = updateSize;
    pPacket->position   = position;

    //
    // This processes the message, as if it has just been received from the
    // network (i.e.  allocates the record, sets up the object handle,
    // inserts the object in the workset, etc.)
    //

    rc = ProcessObjectAdd(putTask, pPacket, pWSGroup,
        pWorkset, pData, ppObj);
    if (rc != 0)
    {
        DC_QUIT;
    }

    pObj = *ppObj;

    //
    // This queues the OMNET_OBJECT_ADD message on the send queue for this
    // Domain and priority:
    //

    rc = QueueMessage(putTask,
                     pWSGroup->pDomain,
                     pWSGroup->channelID,
                     pWorkset->priority,
                     pWSGroup,
                     pWorkset,
                     pObj,
                     (POMNET_PKT_HEADER) pPacket,
                     pData,
                    TRUE);
    if (rc != 0)
    {
        ValidateObject(pObj);

        //
        // If we failed to queue the message, we must unwind by deleting the
        // object and its record from the workset (since otherwise it would
        // be present on this node and no another, which we want to avoid):
        //
        // We don't want to call ObjectDoDelete since that frees the object
        // data (which our caller will expect still to be valid if the
        // function fails).  We could, of course, bump the use count and then
        // call ObjectDoDelete but if we fail on the bump, what next?
        //
        // Instead, we
        //
        // - set the DELETED flag so the hidden handler will swallow the
        //   Add event
        //
        // - decrement the numObjects field in the workset
        //
        // - free the object record after removing it from the workset.
        //
        pObj->flags |= DELETED;
        pWorkset->numObjects--;

        TRACE_OUT(("Freeing object record at 0x%08x)", pObj));
        COM_BasedListRemove(&(pObj->chain));
        UT_FreeRefCount((void**)&pObj, FALSE);

        DC_QUIT;
    }

DC_EXIT_POINT:
    if (rc != 0)
    {
        ERROR_OUT(("ERROR %d adding object to workset %u in WSG %d for TASK 0x%08x",
            rc, pWorkset->worksetID, pWSGroup->wsg, putTask));

        if (pPacket != NULL)
        {
            UT_FreeRefCount((void**)&pPacket, FALSE);
        }
    }

    DebugExitDWORD(ObjectAdd, rc);
    return(rc);
}



//
// ObjectDRU(...)
//
UINT ObjectDRU
(
    PUT_CLIENT          putTask,
    POM_WSGROUP         pWSGroup,
    POM_WORKSET         pWorkset,
    POM_OBJECT          pObj,
    POM_OBJECTDATA      pData,
    OMNET_MESSAGE_TYPE  type
)
{
    POMNET_OPERATION_PKT pPacket;
    UINT                rc = 0;

    DebugEntry(ObjectDRU);

    TRACE_OUT(("Issuing operation type 0x%08x for object 0x%08x in workset %u in WSG %d",
        type, pData, pWorkset->worksetID, pWSGroup->wsg));

    rc = GenerateOpMessage(pWSGroup,
                          pWorkset->worksetID,
                          &(pObj->objectID),
                          pData,
                          type,
                          &pPacket);
    if (rc != 0)
    {
        pPacket = NULL;
        DC_QUIT;
    }

    //
    // QueueMessage may free the packet (if we're not in a call) but we need
    // to process it in a minute so bump the use count:
    //
    UT_BumpUpRefCount(pPacket);

    rc = QueueMessage(putTask,
                     pWSGroup->pDomain,
                     pWSGroup->channelID,
                     pWorkset->priority,
                     pWSGroup,
                     pWorkset,
                     pObj,
                     (POMNET_PKT_HEADER) pPacket,
                     pData,
                    TRUE);
    if (rc != 0)
    {
        DC_QUIT;
    }

    rc = ProcessObjectDRU(putTask,
                         pPacket,
                         pWSGroup,
                         pWorkset,
                         pObj,
                         pData);

DC_EXIT_POINT:

    //
    // Now free the packet since we bumped its use count above:
    //
    if (pPacket != NULL)
    {
        UT_FreeRefCount((void**)&pPacket, FALSE);
    }

    if (rc != 0)
    {
        ERROR_OUT(("ERROR %d issuing D/R/U (type %hu) for object 0x%08x "
            "in workset %u in WSG %d",
            rc, type, pData, pWorkset->worksetID, pWSGroup->wsg));
    }

    DebugExitDWORD(ObjectDRU, rc);
    return(rc);
}



//
// FindPendingOp(...)
//
void FindPendingOp
(
    POM_WORKSET         pWorkset,
    POM_OBJECT       pObj,
    OM_OPERATION_TYPE   type,
    POM_PENDING_OP *    ppPendingOp
)
{
    POM_PENDING_OP      pPendingOp;

    DebugEntry(FindPendingOp);

    pPendingOp = (POM_PENDING_OP)COM_BasedListFirst(&(pWorkset->pendingOps), FIELD_OFFSET(OM_PENDING_OP, chain));
    while (pPendingOp != NULL)
    {
        if ((pPendingOp->type == type) && (pPendingOp->pObj == pObj))
        {
            break;
        }

        pPendingOp = (POM_PENDING_OP)COM_BasedListNext(&(pWorkset->pendingOps), pPendingOp, FIELD_OFFSET(OM_PENDING_OP, chain));
    }

    if (pPendingOp == NULL)
    {
        TRACE_OUT(("No pending op of type %hu found for object 0x%08x",
                                                              type, pObj));
    }

    *ppPendingOp = pPendingOp;

    DebugExitVOID(FindPendingOp);
}



//
// AddClientToWsetList(...)
//
UINT AddClientToWsetList
(
    PUT_CLIENT          putTask,
    POM_WORKSET         pWorkset,
    OM_WSGROUP_HANDLE   hWSGroup,
    UINT                mode,
    POM_CLIENT_LIST *   ppClientListEntry
)
{
    UINT                rc = 0;

    DebugEntry(AddClientToWsetList);

    //
    // Adding a task to a workset's client list means that that task will
    // get events relating to that workset.
    //
    TRACE_OUT((" Adding TASK 0x%08x to workset's client list"));

    *ppClientListEntry = (POM_CLIENT_LIST)UT_MallocRefCount(sizeof(OM_CLIENT_LIST), FALSE);
    if (! *ppClientListEntry)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }
    SET_STAMP((*ppClientListEntry), CLIENTLIST);

    (*ppClientListEntry)->putTask = putTask;
    (*ppClientListEntry)->hWSGroup = hWSGroup;
    (*ppClientListEntry)->mode     = (WORD)mode;

    //
    // Now insert the entry into the list:
    //

    COM_BasedListInsertBefore(&(pWorkset->clients),
                        &((*ppClientListEntry)->chain));

    TRACE_OUT((" Inserted Client list item into workset's Client list"));


DC_EXIT_POINT:
    DebugExitDWORD(AddClientToWsetList, rc);
    return(rc);

}



//
// RemoveClientFromWSGList(...)
//
void RemoveClientFromWSGList
(
    PUT_CLIENT      putUs,
    PUT_CLIENT      putTask,
    POM_WSGROUP     pWSGroup
)
{
    POM_CLIENT_LIST pClientListEntry;
    BOOL            locked            = FALSE;

    DebugEntry(RemoveClientFromWSGList);

    TRACE_OUT(("Searching for Client TASK 0x%08x in WSG %d",
        putTask, pWSGroup->wsg));

    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pWSGroup->clients),
            (void**)&pClientListEntry, FIELD_OFFSET(OM_CLIENT_LIST, chain),
            FIELD_OFFSET(OM_CLIENT_LIST, putTask), (DWORD_PTR)putTask,
            FIELD_SIZE(OM_CLIENT_LIST, putTask));

    //
    // If it's not there, the Client may have already deregistered itself:
    //

    if (pClientListEntry == NULL)
    {
        WARNING_OUT(("Client TASK 0x%08x not found in list for WSG %d",
            putTask, pWSGroup->wsg));
        DC_QUIT;
    }

    //
    // Remove the Client from the list and free the memory:
    //
    COM_BasedListRemove(&(pClientListEntry->chain));
    UT_FreeRefCount((void**)&pClientListEntry, FALSE);

    //
    // If there are now no local Clients registered with the workset group,
    // post an event to ObMan so it can discard the workset group (unless
    // the workset group is marked non-discardable e.g the ObManControl
    // workset group)
    //
    // The event parameter is the offset of the workset group record.
    //
    // Note: this discard is done asynchronously since it may involve
    //       allocating resources (broadcasting to other nodes that
    //       we've deregistered), and we want this function to always
    //       succeed.
    //
    //       However, we clear the <valid> flag synchronously so that
    //       ObMan will not try to process events etc.  which arrive
    //       for it.
    //

    if (COM_BasedListIsEmpty(&(pWSGroup->clients)))
    {
        pWSGroup->toBeDiscarded = TRUE;
        pWSGroup->valid = FALSE;

        TRACE_OUT(("Last local Client deregistered from WSG %d, "
            "marking invalid and posting DISCARD event", pWSGroup->wsg));

        ValidateOMP(g_pomPrimary);

        UT_PostEvent(putUs,
                   g_pomPrimary->putTask,
                   0,                           // no delay
                   OMINT_EVENT_WSGROUP_DISCARD,
                   0,
                   (UINT_PTR)pWSGroup);
    }
    else
    {
        TRACE_OUT(("Clients still registered with WSG %d",  pWSGroup->wsg));
    }


DC_EXIT_POINT:
    DebugExitVOID(RemoveClientFromWSGList);
}



//
// FindInfoObject(...)
//
void FindInfoObject
(
    POM_DOMAIN          pDomain,
    OM_WSGROUP_ID       wsGroupID,
    OMWSG               wsg,
    OMFP                fpHandler,
    POM_OBJECT *        ppObjInfo
)
{
    POM_WORKSET         pOMCWorkset;
    POM_OBJECT          pObj;
    POM_WSGROUP_INFO    pInfoObject;

    DebugEntry(FindInfoObject);

    TRACE_OUT(("FindInfoObject: FP %d WSG %d ID %d, domain %u",
        fpHandler, wsg, wsGroupID, pDomain->callID));

    //
    // In this function, we search workset #0 in ObManControl for a
    // Function Profile/workset group name combination which matches the
    // ones specified
    //
    // So, we need to start with a pointer to this workset:
    //
    pOMCWorkset = GetOMCWorkset(pDomain, OM_INFO_WORKSET);

    //
    // Now chain through each of the objects in the workset to look for a
    // match.
    //
    pObj = (POM_OBJECT)COM_BasedListLast(&(pOMCWorkset->objects), FIELD_OFFSET(OM_OBJECT, chain));
    while (pObj != NULL)
    {
        ValidateObject(pObj);

        //
        // If the object has not been deleted...
        //
        if (pObj->flags & DELETED)
        {

        }
        else if (!pObj->pData)
        {
            ERROR_OUT(("FindInfoObject:  object 0x%08x has no data", pObj));
        }
        else
        {
            ValidateObjectData(pObj->pData);
            pInfoObject = (POM_WSGROUP_INFO)pObj->pData;

            //
            // ...and if it is an INFO object...
            //
            if (pInfoObject->idStamp == OM_WSGINFO_ID_STAMP)
            {
                // If no FP provided, check the group IDs match
                if (fpHandler == OMFP_MAX)
                {
                    //
                    // ...and the ID matches, we've got what we want:
                    //
                    if (wsGroupID == pInfoObject->wsGroupID)
                    {
                        break;
                    }
                }
                //
                // ...but otherwise, try match on functionProfile...
                //
                else
                {
                    if (!lstrcmp(pInfoObject->functionProfile,
                            OMMapFPToName(fpHandler)))
                    {
                        //
                        // ...and also on WSG unless it is not provided
                        //
                        if ((wsg == OMWSG_MAX) ||
                            (!lstrcmp(pInfoObject->wsGroupName,
                                    OMMapWSGToName(wsg))))
                        {
                            break;
                        }
                    }
                }
            }
        }

        pObj = (POM_OBJECT)COM_BasedListPrev(&(pOMCWorkset->objects), pObj, FIELD_OFFSET(OM_OBJECT, chain));
    }

    TRACE_OUT(("%s info object in Domain %u",
        pObj == NULL ? "Didn't find" : "Found", pDomain->callID));

    //
    // Set up the caller's pointer:
    //
    *ppObjInfo = pObj;

    DebugExitVOID(FindInfoObject);
}


//
// PostAddEvents(...)
//
UINT PostAddEvents
(
    PUT_CLIENT          putFrom,
    POM_WORKSET         pWorkset,
    OM_WSGROUP_HANDLE   hWSGroup,
    PUT_CLIENT          putTo
)
{
    OM_EVENT_DATA16     eventData16;
    POM_OBJECT          pObj;
    UINT                rc = 0;

    DebugEntry(PostAddEvents);

    eventData16.hWSGroup   = hWSGroup;
    eventData16.worksetID  = pWorkset->worksetID;

    if (pWorkset->numObjects != 0)
    {
        TRACE_OUT(("Workset has %u objects - posting OBJECT_ADD events",
            pWorkset->numObjects));

        pObj = (POM_OBJECT)COM_BasedListFirst(&(pWorkset->objects), FIELD_OFFSET(OM_OBJECT, chain));

        while (pObj != NULL)
        {
            ValidateObject(pObj);

            //
            // Don't post events for DELETED objects:
            //
            if (!(pObj->flags & DELETED))
            {
                //
                // We're posting an event with an pObj in it, so bump the
                // use count of the object record it refers to:
                //
                UT_BumpUpRefCount(pObj);

                UT_PostEvent(putFrom, putTo,
                         0,                                    // no delay
                         OM_OBJECT_ADD_IND,
                         *(PUINT) &eventData16,
                         (UINT_PTR)pObj);
            }

            pObj = (POM_OBJECT)COM_BasedListNext(&(pWorkset->objects), pObj, FIELD_OFFSET(OM_OBJECT, chain));
        }
    }
    else
    {
        TRACE_OUT(("No objects in workset"));
    }

    DebugExitDWORD(PostAddEvents, rc);
    return(rc);
}




//
// PurgePendingOps(...)
//
void PurgePendingOps
(
    POM_WORKSET         pWorkset,
    POM_OBJECT          pObj
)
{
    POM_PENDING_OP      pPendingOp;
    POM_PENDING_OP      pTempPendingOp;

    DebugEntry(PurgePendingOps);

    //
    // Chain through the workset's list of pending operations and confirm
    // them one by one:
    //
    pPendingOp = (POM_PENDING_OP)COM_BasedListFirst(&(pWorkset->pendingOps), FIELD_OFFSET(OM_PENDING_OP, chain));
    while (pPendingOp != NULL)
    {
        pTempPendingOp = (POM_PENDING_OP)COM_BasedListNext(&(pWorkset->pendingOps), pPendingOp, FIELD_OFFSET(OM_PENDING_OP, chain));

        if (pPendingOp->pObj == pObj)
        {
            TRACE_OUT(("Purging operation type %hd", pPendingOp->type));
            COM_BasedListRemove(&(pPendingOp->chain));
            UT_FreeRefCount((void**)&pPendingOp, FALSE);
        }

        pPendingOp = pTempPendingOp;
    }

    DebugExitVOID(PurgePendingOps);
}




//
// WorksetLockReq(...)
//
void WorksetLockReq
(
    PUT_CLIENT          putTask,
    POM_PRIMARY         pomPrimary,
    POM_WSGROUP         pWSGroup,
    POM_WORKSET         pWorkset,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_CORRELATOR    *  pCorrelator
)
{
    POM_DOMAIN          pDomain;
    POM_LOCK_REQ        pLockReq =      NULL;
    POMNET_LOCK_PKT     pLockReqPkt =   NULL;
    UINT                rc =            0;

    DebugEntry(WorksetLockReq);

    TRACE_OUT(("TASK 0x%08x requesting to lock workset %u in WSG %d",
        putTask, pWorkset->worksetID, hWSGroup));

    //
    // The caller will need a correlator value to correlate the eventual
    // lock success/failure event:
    //
    *pCorrelator = NextCorrelator(pomPrimary);

    //
    // Set up a pointer to the Domain record:
    //
    pDomain = pWSGroup->pDomain;

    //
    // Allocate some memory for the lock request control block:
    //
    pLockReq = (POM_LOCK_REQ)UT_MallocRefCount(sizeof(OM_LOCK_REQ), TRUE);
    if (!pLockReq)
    {
        rc = OM_RC_OUT_OF_RESOURCES;
        DC_QUIT;
    }
    SET_STAMP(pLockReq, LREQ);

    //
    // Set up the fields:
    //
    pLockReq->putTask      = putTask;
    pLockReq->correlator    = *pCorrelator;
    pLockReq->wsGroupID     = pWSGroup->wsGroupID;
    pLockReq->worksetID     = pWorkset->worksetID;
    pLockReq->hWSGroup           = hWSGroup;
    pLockReq->type          = LOCK_PRIMARY;
    pLockReq->retriesToGo   = OM_LOCK_RETRY_COUNT_DFLT;

    pLockReq->pWSGroup      = pWSGroup;

    COM_BasedListInit(&(pLockReq->nodes));

    //
    // Insert this lock request in the Domain's list of pending lock
    // requests:
    //
    COM_BasedListInsertBefore(&(pDomain->pendingLocks), &(pLockReq->chain));

    //
    // Now examine the workset lock state to see if we can grant the lock
    // immediately:
    //
    TRACE_OUT(("Lock state for workset %u in WSG %d is %hu",
        pWorkset->worksetID, hWSGroup, pWorkset->lockState));

    switch (pWorkset->lockState)
    {
        case LOCKING:
        case LOCKED:
        {
            TRACE_OUT((
                "Workset %hu in WSG %d already locked/locking - bumping count",
                pWorkset->worksetID, hWSGroup));

            pLockReq->type = LOCK_SECONDARY;
            pWorkset->lockCount++;

            if (pWorkset->lockState == LOCKED)
            {
                //
                // If we've already got the lock, post success immediately:
                //
                WorksetLockResult(putTask, &pLockReq, 0);
            }
            else
            {
                //
                // Otherwise, this request will be handled when the primary
                // request completes, so do nothing for now.
                //
            }
        }
        break;

        case LOCK_GRANTED:
        {
            //
            // We've already granted the lock to another node so we fail
            // our local client's request for it:
            //
            WorksetLockResult(putTask, &pLockReq, OM_RC_WORKSET_LOCK_GRANTED);

        }
        break;

        case UNLOCKED:
        {
            //
            // Build up a list of other nodes using the workset group:
            //
            rc = BuildNodeList(pDomain, pLockReq);
            if (rc != 0)
            {
                DC_QUIT;
            }

            pWorkset->lockState = LOCKING;
            pWorkset->lockCount++;
            pWorkset->lockedBy = pDomain->userID;

            //
            // If the list is empty, we have got the lock:
            //
            if (COM_BasedListIsEmpty(&pLockReq->nodes))
            {
                TRACE_OUT(("No remote nodes, granting lock immediately"));

                pWorkset->lockState = LOCKED;
                WorksetLockResult(putTask, &pLockReq, 0);
            }
            //
            // Otherwise, we need to broadcast a lock request CB:
            //
            else
            {
                pLockReqPkt = (POMNET_LOCK_PKT)UT_MallocRefCount(sizeof(OMNET_LOCK_PKT), TRUE);
                if (!pLockReqPkt)
                {
                    rc = UT_RC_NO_MEM;
                    DC_QUIT;
                }

                pLockReqPkt->header.messageType   = OMNET_LOCK_REQ;
                pLockReqPkt->header.sender        = pDomain->userID;

                pLockReqPkt->data1         = pLockReq->correlator;
                pLockReqPkt->wsGroupID     = pLockReq->wsGroupID;
                pLockReqPkt->worksetID     = pLockReq->worksetID;

                //
                // Lock messages go at the priority of the workset
                // involved.  If this is OBMAN_CHOOSES_PRIORITY, then
                // all bets are off and we send them TOP_PRIORITY.
                //

                rc = QueueMessage(putTask,
                      pDomain,
                      pWSGroup->channelID,
                      (NET_PRIORITY)((pWorkset->priority == OM_OBMAN_CHOOSES_PRIORITY) ?
                            NET_TOP_PRIORITY : pWorkset->priority),
                      NULL,
                      NULL,
                      NULL,
                      (POMNET_PKT_HEADER) pLockReqPkt,
                      NULL,
                    TRUE);
                if (rc != 0)
                {
                    DC_QUIT;
                }

                //
                // Post a timeout event to the ObMan task so that we don't hang around
                // forever waiting for the lock replies:
                //
                UT_PostEvent(putTask,
                    pomPrimary->putTask,    // ObMan's utH
                    OM_LOCK_RETRY_DELAY_DFLT,
                    OMINT_EVENT_LOCK_TIMEOUT,
                    pLockReq->correlator,
                    pDomain->callID);
            }
        }
        break;
    }


DC_EXIT_POINT:
    //
    // For the checkpointing dummy workset, we always "forget" our lock
    // state so that subsequent requests to lock it will result in the
    // required end-to-end ping:
    //
    if (pWorkset->worksetID == OM_CHECKPOINT_WORKSET)
    {
        TRACE_OUT(("Resetting lock state of checkpoint workset in WSG %d",
             hWSGroup));

        pWorkset->lockState = UNLOCKED;
        pWorkset->lockCount = 0;
        pWorkset->lockedBy  = 0;
    }

    if (rc != 0)
    {
        if (pLockReqPkt != NULL)
        {
            UT_FreeRefCount((void**)&pLockReqPkt, FALSE);
        }

        //
        // This function never returns an error to its caller directly;
        // instead, we call WorksetLockResult which will post a failure
        // event to the calling task (this means the caller doesn't have to
        // have two error processing paths)
        //
        if (pLockReq != NULL)
        {
            WorksetLockResult(putTask, &pLockReq, rc);
        }
        else
        {
           WARNING_OUT(("ERROR %d requesting lock for workset %u in WSG %d ",
              rc, pWorkset->worksetID, hWSGroup));
        }
    }

    DebugExitVOID(WorksetLockReq);
}



//
// BuildNodeList(...)
//
UINT BuildNodeList
(
    POM_DOMAIN          pDomain,
    POM_LOCK_REQ        pLockReq
)
{
    NET_PRIORITY        priority;
    POM_WORKSET         pOMCWorkset;
    POM_OBJECT          pObj;
    POM_WSGROUP_REG_REC pPersonObject;
    POM_NODE_LIST       pNodeEntry;
    NET_UID             ownUserID;
    BOOL                foundOurRegObject;
    UINT                rc =                0;

    DebugEntry(BuildNodeList);

    //
    // OK, we're about to broadcast a lock request throughout this Domain
    // on this workset group's channel.  Before we do so, however, we build
    // up a list of the nodes we expect to respond to the request.  As the
    // replies come in we tick them off against this list; when all of them
    // have been received, the lock is granted.
    //
    // SFR 6117: Since the lock replies will come back on all priorities
    // (to correctly flush the channel), we add 4 items for each remote
    // node - one for each priority.
    //
    // So, we examine the control workset for this workset group, adding
    // items to our list for each person object we find in it (except our
    // own, of course).
    //

    //
    // First, get a pointer to the relevant control workset:
    //
    pOMCWorkset = GetOMCWorkset(pDomain, pLockReq->wsGroupID);
    ASSERT((pOMCWorkset != NULL));

    //
    // We want to ignore our own registration object, so make a note of our
    // user ID:
    //
    ownUserID = pDomain->userID;

    //
    // Now chain through the workset:
    //
    foundOurRegObject  = FALSE;

    pObj = (POM_OBJECT)COM_BasedListFirst(&(pOMCWorkset->objects), FIELD_OFFSET(OM_OBJECT, chain));
    while (pObj != NULL)
    {
        ValidateObject(pObj);

        if (pObj->flags & DELETED)
        {
            //
            // Do nothing
            //
        }
        else if (!pObj->pData)
        {
            ERROR_OUT(("BuildNodeList:  object 0x%08x has no data", pObj));
        }
        else
        {
            ValidateObjectData(pObj->pData);
            pPersonObject = (POM_WSGROUP_REG_REC)pObj->pData;

            if (pPersonObject->idStamp != OM_WSGREGREC_ID_STAMP)
            {
                TRACE_OUT(("Not a person object, skipping"));
            }
            else
            {
                if (pPersonObject->userID == ownUserID)
                {
                    if (foundOurRegObject)
                    {
                        ERROR_OUT(("Duplicate person object in workset %u",
                            pOMCWorkset->worksetID));
                    }
                    else
                    {
                        TRACE_OUT(("Found own person object, skipping"));
                        foundOurRegObject = TRUE;
                    }
                }
                else
                {
                    //
                    // Add an item to our expected respondents list (this
                    // memory is freed in each case when the remote node
                    // replies, or the timer expires and we notice that the
                    // node has disappeared).
                    //
                    // SFR 6117: We add one item for each priority value, since
                    // the lock replies will come back on all priorities.
                    //
                    for (priority =  NET_TOP_PRIORITY;
                        priority <= NET_LOW_PRIORITY;
                        priority++)
                    {
                        TRACE_OUT(("Adding node 0x%08x to node list at priority %hu",
                            pPersonObject->userID, priority));

                        pNodeEntry = (POM_NODE_LIST)UT_MallocRefCount(sizeof(OM_NODE_LIST), TRUE);
                        if (!pNodeEntry)
                        {
                            rc = UT_RC_NO_MEM;
                            DC_QUIT;
                        }
                        SET_STAMP(pNodeEntry, NODELIST);

                        pNodeEntry->userID = pPersonObject->userID;

                        COM_BasedListInsertAfter(&(pLockReq->nodes),
                                        &(pNodeEntry->chain));

                        //
                        // BUT!  We only do this for R20 and later (i.e.
                        // anything over real MCS).  For R11 calls, just put
                        // one entry on the list.
                        //
                        // ALSO!  For ObManControl worksets, we only expect one
                        // lock reply (at TOP_PRIORITY) - this is to speed up
                        // processing of registration attempts.  So, if this is
                        // for ObManControl, don't go around this loop again -
                        // just get out.
                        //
                        if (pLockReq->wsGroupID == WSGROUPID_OMC)
                        {
                            break;
                        }
                    }
                }
            }
        }

        pObj = (POM_OBJECT)COM_BasedListNext(&(pOMCWorkset->objects), pObj, FIELD_OFFSET(OM_OBJECT, chain));
    }


DC_EXIT_POINT:
    if (rc != 0)
    {
        ERROR_OUT(("ERROR %d trying to build node list", rc));
    }

    DebugExitDWORD(BuildNodeList, rc);
    return(rc);

}




//
// WorksetLockResult(...)
//
void WorksetLockResult
(
    PUT_CLIENT          putTask,
    POM_LOCK_REQ *      ppLockReq,
    UINT                result
)
{
    POM_LOCK_REQ        pLockReq;
    POM_WSGROUP         pWSGroup;
    POM_WORKSET         pWorkset;
    OM_EVENT_DATA16     eventData16;
    OM_EVENT_DATA32     eventData32;
    POM_NODE_LIST       pNodeEntry;

    DebugEntry(WorksetLockResult);

    //
    // First some sanity checks:
    //
    ASSERT((ppLockReq != NULL));
    ASSERT((*ppLockReq != NULL));

    pLockReq = *ppLockReq;

    //
    // Set up a local pointer to the workset:
    //
    pWSGroup = pLockReq->pWSGroup;

    pWorkset = pWSGroup->apWorksets[pLockReq->worksetID];
    ASSERT((pWorkset != NULL));

    TRACE_OUT(("Lock %s: lock state: %hu - locked by: 0x%08x - lock count: %hu",
        (result == 0) ? "succeded" : "failed",
        pWorkset->lockState, pWorkset->lockedBy, pWorkset->lockCount));

    //
    // We merge the LOCKED and LOCK_GRANTED return codes at the API level:
    //
    if (result == OM_RC_WORKSET_LOCK_GRANTED)
    {
        result = OM_RC_WORKSET_LOCKED;
    }

    //
    // Fill in fields of event parameter and post the result:
    //
    eventData16.hWSGroup         = pLockReq->hWSGroup;
    eventData16.worksetID   = pLockReq->worksetID;

    eventData32.correlator  = pLockReq->correlator;
    eventData32.result      = (WORD)result;

    UT_PostEvent(putTask,
                 pLockReq->putTask,           // task that wants the lock
                 0,                            //    i.e. ObMan or Client
                 OM_WORKSET_LOCK_CON,
                 *((PUINT) &eventData16),
                 *((LPUINT) &eventData32));

    //
    // Remove any node entries left hanging off the lockReqCB:
    //
    pNodeEntry = (POM_NODE_LIST)COM_BasedListFirst(&(pLockReq->nodes), FIELD_OFFSET(OM_NODE_LIST, chain));
    while (pNodeEntry != NULL)
    {
        COM_BasedListRemove(&pNodeEntry->chain);
        UT_FreeRefCount((void**)&pNodeEntry, FALSE);

        pNodeEntry = (POM_NODE_LIST)COM_BasedListFirst(&(pLockReq->nodes), FIELD_OFFSET(OM_NODE_LIST, chain));
    }

    //
    // Remove the lock request itself from the list and free the memory:
    //
    COM_BasedListRemove(&pLockReq->chain);
    UT_FreeRefCount((void**)&pLockReq, FALSE);

    *ppLockReq = NULL;

    DebugExitVOID(WorksetLockResult);
}



//
// WorksetUnlock(...)
//
void WorksetUnlock
(
    PUT_CLIENT      putTask,
    POM_WSGROUP     pWSGroup,
    POM_WORKSET     pWorkset
)
{
    DebugEntry(WorksetUnlock);

    TRACE_OUT(("Unlocking workset %u in WSG %d for TASK 0x%08x",
        pWorkset->worksetID, pWSGroup->wsg, putTask));

    TRACE_OUT((" lock state: %hu - locked by: 0x%08x - lock count: %hu",
        pWorkset->lockState, pWorkset->lockedBy, pWorkset->lockCount));

    //
    // Check the workset lock state
    //
    if ((pWorkset->lockState != LOCKED) &&
        (pWorkset->lockState != LOCKING))
    {
        ERROR_OUT(("Unlock error for workset %u in WSG %d - not locked",
            pWorkset->worksetID, pWSGroup->wsg));
        DC_QUIT;
    }

    //
    // If this workset is "multiply locked" (i.e.  locked more than one
    // time by the same task), then all we want to do is decrement the lock
    // count.  Otherwise, we want to release the lock.
    //
    pWorkset->lockCount--;

    if (pWorkset->lockCount == 0)
    {
        TRACE_OUT(("Lock count now 0 - really unlocking"));

        WorksetUnlockLocal(putTask, pWorkset);

        QueueUnlock(putTask, pWSGroup->pDomain,
                         pWSGroup->wsGroupID,
                         pWorkset->worksetID,
                         pWSGroup->channelID,
                         pWorkset->priority);
    }

DC_EXIT_POINT:
    DebugExitVOID(WorksetUnlock);
}



//
// WorksetUnlockLocal(...)
//
void WorksetUnlockLocal
(
    PUT_CLIENT      putTask,
    POM_WORKSET     pWorkset
)
{
    DebugEntry(WorksetUnlockLocal);

    //
    // To unlock a workset, we
    //
    // - check that it's not already unlocked
    //
    // - check that the lock count is zero, so we can now unlock it
    //
    // - set the lock fields in the workset record
    //
    // - post an OM_WORKSET_UNLOCK_IND to all Clients with the workset
    //   open.
    //
    if (pWorkset->lockState == UNLOCKED)
    {
        WARNING_OUT(("Workset %hu is already UNLOCKED!", pWorkset->worksetID));
        DC_QUIT;
    }

    ASSERT((pWorkset->lockCount == 0));

    pWorkset->lockedBy  = 0;
    pWorkset->lockState = UNLOCKED;

    WorksetEventPost(putTask,
                     pWorkset,
                     PRIMARY | SECONDARY,
                     OM_WORKSET_UNLOCK_IND,
                     0);

DC_EXIT_POINT:
    DebugExitVOID(WorksetUnlockLocal);
}




//
// QueueUnlock(...)
//
UINT QueueUnlock
(
    PUT_CLIENT          putTask,
    POM_DOMAIN          pDomain,
    OM_WSGROUP_ID       wsGroupID,
    OM_WORKSET_ID       worksetID,
    NET_UID             destination,
    NET_PRIORITY        priority
)
{
    POMNET_LOCK_PKT     pUnlockPkt;
    UINT                rc = 0;

    DebugEntry(QueueUnlock);

    //
    // Allocate memory for the message, fill in the fields and queue it:
    //
    pUnlockPkt = (POMNET_LOCK_PKT)UT_MallocRefCount(sizeof(OMNET_LOCK_PKT), TRUE);
    if (!pUnlockPkt)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    pUnlockPkt->header.messageType = OMNET_UNLOCK;
    pUnlockPkt->header.sender      = pDomain->userID;

    pUnlockPkt->wsGroupID   = wsGroupID;
    pUnlockPkt->worksetID   = worksetID;

    //
    // Unlock messages go at the priority of the workset involved.  If this
    // is OBMAN_CHOOSES_PRIORITY, then all bets are off and we send them
    // TOP_PRIORITY.
    //
    if (priority == OM_OBMAN_CHOOSES_PRIORITY)
    {
        priority = NET_TOP_PRIORITY;
    }

    rc = QueueMessage(putTask,
                      pDomain,
                      destination,
                      priority,
                      NULL,
                      NULL,
                      NULL,                              // no object
                      (POMNET_PKT_HEADER) pUnlockPkt,
                      NULL,                              // no object data
                    TRUE);
    if (rc != 0)
    {
        DC_QUIT;
    }

DC_EXIT_POINT:
    if (rc != 0)
    {
        ERROR_OUT(("ERROR %d in FindInfoObject"));

        if (pUnlockPkt != NULL)
        {
            UT_FreeRefCount((void**)&pUnlockPkt, FALSE);
        }
    }

    DebugExitDWORD(QueueUnlock, rc);
    return(rc);
}



//
//
// DEBUG ONLY FUNCTIONS
//
// These functions are debug code only - for normal compilations, they are
// #defined to nothing.
//

#ifdef _DEBUG

//
// CheckObjectCount(...)
//
void CheckObjectCount
(
    POM_WSGROUP     pWSGroup,
    POM_WORKSET     pWorkset
)
{
    POM_OBJECT      pObj;
    UINT            count;

    DebugEntry(CheckObjectCount);

    count = 0;

    pObj = (POM_OBJECT)COM_BasedListFirst(&(pWorkset->objects), FIELD_OFFSET(OM_OBJECT, chain));

    while (pObj != NULL)
    {
        ValidateObject(pObj);

        if (!(pObj->flags & DELETED))
        {
            count++;
        }

        pObj = (POM_OBJECT)COM_BasedListNext(&(pWorkset->objects), pObj, FIELD_OFFSET(OM_OBJECT, chain));
    }

    ASSERT((count == pWorkset->numObjects));

    TRACE_OUT(("Counted %u items in workset %u in WSG %d, agrees with numObjects",
        count, pWorkset->worksetID, pWSGroup->wsg));

    DebugExitVOID(CheckObjectCount);
}



//
// CheckObjectOrder(...)
//
void CheckObjectOrder
(
    POM_WORKSET     pWorkset
)
{
    POM_OBJECT      pObjThis;
    POM_OBJECT      pObjNext;
    BOOL            orderIsGood       = TRUE;

    DebugEntry(CheckObjectOrder);

    //
    // This function checks that objects in the specified workset have been
    // correctly positioned.  The correct order of objects is one where
    //
    // - all FIRST objects are before all LAST objects
    //
    // - the position stamps of the FIRST objects decrease monotonically
    //   from the start of the workset onwards
    //
    // - the position stamps of the LAST objects decrease monotonically
    //   from the end of the workset backwards.
    //
    //
    //
    // This can be represented grahpically as follows:
    //
    //              *                     *
    //              * *                 * *
    //              * * *             * * *
    //              * * * *         * * * *
    //              * * * * *     * * * * *
    //              * * * * * * * * * * * *
    //
    //              F F F F F F L L L L L L
    //
    // ...where taller columns indicate later sequence stamps and 'F' and
    // 'L' indicate the FIRST or LAST objects.
    //
    //
    //
    // The way we test for correct order is to compare each adjacent pair of
    // objects.  If the overall order is correct, the for each pair of
    // objects where A immediately precedes B, one of the following is true:
    //
    // - both are FIRST and B has a lower sequence stamp than A
    //
    // - A is FIRST and B is LAST
    //
    // - both are LAST and A has a lower sequence stamp than B.
    //

    pObjThis = (POM_OBJECT)COM_BasedListFirst(&(pWorkset->objects), FIELD_OFFSET(OM_OBJECT, chain));
    if (!pObjThis)
    {
        //
        // Hitting the end of the workset at any stage means order is
        // correct, so quit:
        //
        DC_QUIT;
    }
    pObjNext = pObjThis;

    orderIsGood = TRUE;

    while (orderIsGood)
    {
        pObjNext = (POM_OBJECT)COM_BasedListNext(&(pWorkset->objects), pObjNext, FIELD_OFFSET(OM_OBJECT, chain));
        if (!pObjNext)
        {
            DC_QUIT;
        }

        switch (pObjThis->position)
        {
            case FIRST: // condition 3 has failed
                if (pObjNext->position == FIRST) // condition 2 has failed
                {
                    if (!STAMP_IS_LOWER(pObjNext->positionStamp,
                                  pObjThis->positionStamp))
                    {
                        ERROR_OUT(("Object order check failed (1)"));
                        orderIsGood = FALSE;   // final condition (1) has failed
                        DC_QUIT;
                    }
                }
                break;

            case LAST: // conditions 1 and 2 have failed
                if ((pObjNext->position != LAST) ||
                    (!STAMP_IS_LOWER(pObjThis->positionStamp,
                                pObjNext->positionStamp)))
                {
                    ERROR_OUT(("Object order check failed (2)"));
                    orderIsGood = FALSE; // final condition (3) has failed
                    DC_QUIT;
                }
                break;

            default:
                ERROR_OUT(("Reached default case in switch statement (value: %hu)",
                    pObjThis->position));
                break;
        }

        pObjThis = pObjNext;
    }

DC_EXIT_POINT:
    if (!orderIsGood)
    {
        ERROR_OUT(("This object (handle: 0x%08x - ID: 0x%08x:0x%08x) "
             "has position stamp 0x%08x:0x%08x (position %s)",
             pObjThis,
            pObjThis->objectID.creator, pObjThis->objectID.sequence,
         pObjThis->positionStamp.userID,
         pObjThis->positionStamp.genNumber,
         (pObjThis->position == LAST) ? "LAST" : "FIRST"));

      ERROR_OUT(("This object (handle: 0x%08x - ID: 0x%08x:0x%08x) "
         "has position stamp 0x%08x:0x%08x (position %s)",
        pObjNext,
         pObjNext->objectID.creator, pObjNext->objectID.sequence,
         pObjNext->positionStamp.userID,
         pObjNext->positionStamp.genNumber,
         (pObjNext->position == LAST) ? "LAST" : "FIRST"));

      ERROR_OUT(("Object order check failed for workset %u.  "
         "See trace for more details",
         pWorkset->worksetID));
    }

    TRACE_OUT(("Object order in workset %u is correct",
        pWorkset->worksetID));

    DebugExitVOID(CheckObjectOrder);
}


#endif // _DEBUG



//
// OMMapNameToFP()
//
OMFP OMMapNameToFP(LPCSTR szFunctionProfile)
{
    int    fp;

    DebugEntry(OMMapNameToFP);

    for (fp = OMFP_FIRST; fp < OMFP_MAX; fp++)
    {
        if (!lstrcmp(szFunctionProfile, c_aFpMap[fp].szName))
        {
            // Found it
            break;
        }
    }

    //
    // Note that OMFP_MAX means "not found"
    //

    DebugExitDWORD(OMMapNameToFP, fp);
    return((OMFP)fp);
}



//
// OMMapFPToName()
//
// This returns a data pointer of the FP name to the caller.  The caller
// can only copy it or compare it; it may not write into or otherwise
// modify/hang on to the pointer.
//
LPCSTR OMMapFPToName(OMFP fp)
{
    LPCSTR  szFunctionProfile;

    DebugEntry(OMMapFPToName);

    ASSERT(fp >= OMFP_FIRST);
    ASSERT(fp < OMFP_MAX);

    szFunctionProfile = c_aFpMap[fp].szName;

    DebugExitPVOID(OMMapFPToName, (PVOID)szFunctionProfile);
    return(szFunctionProfile);
}


//
// OMMapNameToWSG()
//
OMWSG   OMMapNameToWSG(LPCSTR szWSGName)
{
    int   wsg;

    DebugEntry(OMMapNameToWSG);

    for (wsg = OMWSG_FIRST; wsg < OMWSG_MAX; wsg++)
    {
        if (!lstrcmp(szWSGName, c_aWsgMap[wsg].szName))
        {
            // Found it
            break;
        }
    }

    //
    // Note that OMWSG_MAX means "not found"
    //

    DebugExitDWORD(OMMapNameToWSG, wsg);
    return((OMWSG)wsg);
}



//
// OMMapWSGToName()
//
LPCSTR OMMapWSGToName(OMWSG wsg)
{
    LPCSTR  szWSGName;

    DebugEntry(OMMapWSGToName);

    ASSERT(wsg >= OMWSG_FIRST);
    ASSERT(wsg < OMWSG_MAX);

    szWSGName = c_aWsgMap[wsg].szName;

    DebugExitPVOID(OMMapWSGToName, (PVOID)szWSGName);
    return(szWSGName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\sbc.cpp ===
#include "precomp.h"


//
// SBC.CPP
// Send Bitmap Cache
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE






//
// SBC_HostStarting()
//
BOOL ASHost::SBC_HostStarting(void)
{
    BITMAPINFO_ours bitmapInfo;
    int             i;
    BOOL            rc = FALSE;

    DebugEntry(ASHost::SBC_HostStarting);

    if (g_sbcEnabled)
    {
        //
        // We create a DIB section for each tile size which we use during the
        // conversion of a bitmap from the native (device) bpp to the protocol
        // bpp.  We create the DIB sections at the device bpp.
        //
        ZeroMemory(&bitmapInfo, sizeof(bitmapInfo));
        m_pShare->USR_InitDIBitmapHeader((BITMAPINFOHEADER *)&bitmapInfo, g_usrCaptureBPP);

        // We only capture at 8 or 24 for NT 5.0, otherwise the screen depth
        if ((g_usrCaptureBPP > 8) && (g_usrCaptureBPP != 24))
        {
            //
            // If the device bpp is > 8 (but not 24), we have to set up the DIB
            // section to use the same bitmasks as the device.  This means
            // setting the compression type to BI_BITFIELDS and setting the
            // first 3 DWORDS of the bitmap info color table to be the bitmasks
            // for R, G and B respectively.
            //
            // 24bpp does not use bitmasks - it must use
            // regular BI_RGB format with 8 bits for each colour.
            //
            bitmapInfo.bmiHeader.biCompression = BI_BITFIELDS;

            ASSERT(g_asbcBitMasks[0]);
            ASSERT(g_asbcBitMasks[1]);
            ASSERT(g_asbcBitMasks[2]);

            bitmapInfo.bmiColors[0] = ((LPTSHR_RGBQUAD)g_asbcBitMasks)[0];
            bitmapInfo.bmiColors[1] = ((LPTSHR_RGBQUAD)g_asbcBitMasks)[1];
            bitmapInfo.bmiColors[2] = ((LPTSHR_RGBQUAD)g_asbcBitMasks)[2];
        }

        //
        // Initialize m_asbcWorkInfo array which holds the info we use to
        // convert from native bpp to protocol bpp.
        //

        //
        // First, intialize all the fields to default values
        //
        for (i = 0; i < SBC_NUM_TILE_SIZES ; i++)
        {
            ASSERT(!m_asbcWorkInfo[i].pShuntBuffer);
            ASSERT(g_asbcShuntBuffers[i]);

            m_asbcWorkInfo[i].pShuntBuffer = g_asbcShuntBuffers[i];

            ASSERT(m_asbcWorkInfo[i].mruIndex       == 0);
            ASSERT(m_asbcWorkInfo[i].workBitmap     == 0);
            ASSERT(m_asbcWorkInfo[i].pWorkBitmapBits == NULL);

            if (i == SBC_MEDIUM_TILE_INDEX)
            {
                m_asbcWorkInfo[i].tileWidth    = MP_MEDIUM_TILE_WIDTH;
                m_asbcWorkInfo[i].tileHeight   = MP_MEDIUM_TILE_HEIGHT;
            }
            else
            {
                m_asbcWorkInfo[i].tileWidth    = MP_LARGE_TILE_WIDTH;
                m_asbcWorkInfo[i].tileHeight   = MP_LARGE_TILE_HEIGHT;
            }

            bitmapInfo.bmiHeader.biWidth  = m_asbcWorkInfo[i].tileWidth;
            bitmapInfo.bmiHeader.biHeight = m_asbcWorkInfo[i].tileHeight;

            m_asbcWorkInfo[i].workBitmap = CreateDIBSection(NULL,
                                  (BITMAPINFO*)&bitmapInfo,
                                  DIB_RGB_COLORS,
                                  (void **)&(m_asbcWorkInfo[i].pWorkBitmapBits),
                                  NULL,             // File mapping object
                                  0);               // Offset into file
                                                    //   mapping object
            if (!m_asbcWorkInfo[i].workBitmap)
            {
                ERROR_OUT(("Failed to create SBC DIB section %d", i));
                DC_QUIT;
            }

            ASSERT(m_asbcWorkInfo[i].pWorkBitmapBits);
            TRACE_OUT(( "Created work DIB section %d, pBits = 0x%08x",
                     i, m_asbcWorkInfo[i].pWorkBitmapBits));
        }

        //
        // Initialize the fastpath
        //
        if (!SBCInitFastPath())
        {
            TRACE_OUT(( "Failed to init fastpath"));
            DC_QUIT;
        }

        if (!SBCInitInternalOrders())
        {
            ERROR_OUT(( "Failed to init SBC internal order struct"));
            DC_QUIT;
        }

        m_pShare->SBC_RecalcCaps(TRUE);
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASHost::SBC_HostStarting, rc);
    return(rc);
}



//
// ASShare::SBC_HostEnded()
//
void ASHost::SBC_HostEnded(void)
{
    int     i;

    DebugEntry(ASHost::SBC_HostEnded);

    if (g_sbcEnabled)
    {
        //
        // Free up the memory associated with sbcOrderInfo.
        //
        SBCFreeInternalOrders();

        SBCInitCacheStructures();

        //
        // Free our fast path info
        //
        if (m_sbcFastPath)
        {
            delete m_sbcFastPath;
            m_sbcFastPath = NULL;
        }

        //
        // Clear our cache handles.
        //
        for (i = 0; i < NUM_BMP_CACHES; i++)
        {
            if (m_asbcBmpCaches[i].handle != 0)
            {
                TRACE_OUT(( "Clear cache %d", i));
                CH_DestroyCache(m_asbcBmpCaches[i].handle);
                BMCFreeCacheData(&m_asbcBmpCaches[i]);
            }
        }

        //
        // Free our work DIB sections
        //

        //
        // We just have to delete the DIB sections and reset our variables.
        //
        for (i = 0 ; i < SBC_NUM_TILE_SIZES ; i++)
        {
            m_asbcWorkInfo[i].pShuntBuffer = NULL;

            if (m_asbcWorkInfo[i].workBitmap != NULL)
            {
                DeleteBitmap(m_asbcWorkInfo[i].workBitmap);
                m_asbcWorkInfo[i].workBitmap      = NULL;
                m_asbcWorkInfo[i].pWorkBitmapBits = NULL;
            }
        }
    }

    DebugExitVOID(ASHost::SBC_HostEnded);
}



//
// SBC_SyncOutgoing()
// Called when we're already hosting and someone new joins the share.
// Resets the OUTGOING bitmap cache for bitblt orders.
//
void  ASHost::SBC_SyncOutgoing(void)
{
    int   i;

    DebugEntry(ASHost::SBC_SyncOutgoing);

    //
    // Only do anything if SBC is enabled
    //
    if (g_sbcEnabled)
    {
        //
        // Discard all currently cached bitmaps and set the colour table to
        // zero so that the next bitmap order which arrives will trigger the
        // sending of a new colour table first.  Note that if the colour table
        // is then full of zeros(!) it will still be OK because the RBC zeros
        // out its copy of the colour table when a new host joins the share.
        //
        TRACE_OUT(( "Clearing all send caches"));
        SBCInitCacheStructures();

        //
        // All we have to do here is to reset our MRU indices for each of the
        // shunt buffers.  Each of the entries in the shunt buffer will be
        // marked as free down in the driver.
        //
        for (i = 0; i < SBC_NUM_TILE_SIZES; i++)
        {
            m_asbcWorkInfo[i].mruIndex = 0;
        }
    }

    DebugExitVOID(ASHost::SBC_SyncOutgoing);
}



//
//
// SBC_CopyPrivateOrderData()
//
//
UINT  ASHost::SBC_CopyPrivateOrderData
(
    LPBYTE          pDst,
    LPCOM_ORDER     pOrder,
    UINT            freeBytesInBuffer
)
{
    UINT      orderSize;
    LPBYTE    pBitmapBits;

    DebugEntry(ASHost::SBC_CopyPrivateOrderData);

    //
    // Copy the order header without the rectangle structure (which we
    // do not use).
    //
    orderSize = sizeof(pOrder->OrderHeader)
              - sizeof(pOrder->OrderHeader.rcsDst);
    memcpy(pDst, pOrder, orderSize);

    //
    // Copy the basic order data.
    //
    memcpy(pDst + orderSize,
              pOrder->abOrderData,
              pOrder->OrderHeader.cbOrderDataLength);
    orderSize += pOrder->OrderHeader.cbOrderDataLength;

    if (orderSize > freeBytesInBuffer)
    {
        ERROR_OUT(( "Overwritten end of buffer. (%u) > (%u)",
                      orderSize,
                      freeBytesInBuffer));
    }

    //
    // Set the length field in the order header to be the total amount of
    // data we have copied (including the partial header) minus the
    // size of a full header. This is horrible! - but is needed because
    // the OD2 code looks at the header (which it really should not know
    // about) and uses the length field to calculate the total length of
    // the order. The OD2 code does not know that we have omitted some
    // of the header.
    //
    ((LPCOM_ORDER)pDst)->OrderHeader.cbOrderDataLength =
        (WORD)(orderSize - sizeof(COM_ORDER_HEADER));

    //
    // Return the total number of bytes that we have copied.
    //
    DebugExitDWORD(ASHost::SBC_CopyPrivateOrderData, orderSize);
    return(orderSize);
}



//
// Name:      SBCInitCacheStructures()
//
// Purpose:
//
// Returns:
//
// Params:
//
// Operation:
//
//
void  ASHost::SBCInitCacheStructures(void)
{
    UINT  i;

    DebugEntry(ASHost::SBCInitCacheStructures);

    ASSERT(g_sbcEnabled);

    //
    // Reset caches
    //
    for (i = 0; i < NUM_BMP_CACHES; i++)
    {
        if (m_asbcBmpCaches[i].handle)
        {
            CH_ClearCache(m_asbcBmpCaches[i].handle);
        }
    }

    //
    // Do any OS specific processing
    //
    SBC_CacheCleared();

    DebugExitVOID(ASHost::SBCInitCacheStructures);
}



//
// SBC_CacheCleared()
//
void  ASHost::SBC_CacheCleared(void)
{
    int   i;

    DebugEntry(ASHost::SBC_CacheCleared);

    ASSERT(g_sbcEnabled);
    ASSERT(m_sbcFastPath);

    //
    // The cache has been cleared.  Reset our fast path.
    //
    COM_BasedListInit(&m_sbcFastPath->usedList);
    COM_BasedListInit(&m_sbcFastPath->freeList);

    for (i = 0; i < SBC_FASTPATH_ENTRIES; i++)
    {
        m_sbcFastPath->entry[i].list.next = 0;
        m_sbcFastPath->entry[i].list.prev = 0;
        COM_BasedListInsertBefore(&m_sbcFastPath->freeList,
                             &m_sbcFastPath->entry[i].list);
    }

    DebugExitVOID(ASHost::SBC_CacheCleared);
}


//
//
// SBCSelectCache(..)
//
// Decides which cache a sub-bitmap from a source bitmap of the specified
// size should go in.
//
// To be cached, the sub-bitmap must:
// have a size, in compressed bytes, which fits in the cache
//
// The R1.1 cache selection is irrespective of the actual memory
// requirement for the cached data.  This is wasteful of space, but is
// necessary for R1.1 compatibility.  (The R1.1 cache paremeters mean that
// the total cache will be below about 128K in any case)
//
// For R2.0 the cache is selected by this function by comparing the
// post-compress size with the cell area of each of the caches.  This gives
// us a much better space usage on both server and client.
//
// Returns:
//   TRUE if the sub-bitmap can be cached.
//   *pCache is updated with the index of the selected cache.
//
//   FALSE if the sub-bitmap cannot be cached.
//   *pCache is not updated.
//
//
BOOL  ASHost::SBCSelectCache
(
    UINT            cSize,
    UINT *          pCache
)
{
    BOOL    fCacheSelected;
    BOOL    fSelectedCacheIsFull;
    UINT    i;

    DebugEntry(ASHost::SBCSelectCache);

    fCacheSelected       = FALSE;
    fSelectedCacheIsFull = FALSE;

    //
    // This loop makes the assumption that cache 0 is the smallest.  If
    // abmcint.h changes this assumption it will need rewriting.
    //
    for (i = 0; i < NUM_BMP_CACHES; i++)
    {
        if (m_asbcBmpCaches[i].cEntries <= 0)
        {
            //
            // No entries in this cache, so skip to the next one
            //
            continue;
        }

        //
        // R2 bitmap cache - only consider total cell size.
        //
        // Only consider this cache if
        //  - we haven't yet found a cache
        // OR
        //  - we have found a cache, but it is full (i.e.  will
        //    require an entry to be ejected) AND this one is not
        //    full
        //
        // (Note that a cache is full if freeEntry != NULL)
        //
        if (!fCacheSelected ||
            (fSelectedCacheIsFull &&
             ((m_asbcBmpCaches[i].freeEntry == NULL)
                     || !m_asbcBmpCaches[i].freeEntry->inUse)))
        {
            if (cSize <= m_asbcBmpCaches[i].cSize)
            {
                if (fSelectedCacheIsFull)
                {
                    TRACE_OUT(("Using cache %u because cache %u is full",
                                 *pCache, i));
                }

                *pCache        = i;
                fCacheSelected = TRUE;

                fSelectedCacheIsFull =
                                  ((m_asbcBmpCaches[i].freeEntry != NULL) &&
                                   m_asbcBmpCaches[i].freeEntry->inUse);

                if (!fSelectedCacheIsFull)
                {
                    break;
                }
            }
        }
    }

    DebugExitDWORD(ASHost::SBCSelectCache, fCacheSelected);
    return(fCacheSelected);
}


//
// FUNCTION: SBC_RecreateSendCache
//
// DESCRIPTION:
//
// (Re)creates the send bitmap cache with a size suitable for the current
// capabilities.
//
// PARAMETERS:
// cache - index to the cache being recreated
// cOldEntries - the previous max number of entries in the cache
// oldCellSize - the previous cell size
//
// RETURNS: NONE
//
//
void  ASHost::SBC_RecreateSendCache
(
    UINT    cache,
    UINT    newNumEntries,
    UINT    newCellSize
)
{
    PBMC_DIB_CACHE pCache = &(m_asbcBmpCaches[cache]);

    DebugEntry(ASHost::SBC_RecreateSendCache);

    //
    // Allocate the memory for the new send cache
    //
    ASSERT((newCellSize != pCache->cCellSize) ||
           (newNumEntries != pCache->cEntries));

    //
    // If the cache already exists then destroy it first
    //
    if (pCache->handle != 0)
    {
        TRACE_OUT(( "Destroy SBC cache %d", cache));

        CH_DestroyCache(pCache->handle);
        pCache->handle = 0;
    }

    //
    // Now reallocate the cache data.  This will free any memory previously
    // allocated.  If the entries/cellsize is zero, it will return success.
    //
    if (!BMCAllocateCacheData(newNumEntries, newCellSize, cache, pCache))
    {
        ERROR_OUT(( "Bitmap caching disabled for cache %u", cache));
    }

    if (pCache->cEntries > 0)
    {
        //
        // Allocate cache handler cache.  Note that we force the cache
        // handler to leave us with one entry in our hand at all times by
        // decrementing its count of entries.
        //
        if (!CH_CreateCache(&(pCache->handle),
                            pCache->cEntries - 1,
                            SBC_NUM_CATEGORIES,
                            BMC_DIB_NOT_HASHED,
                            SBCCacheCallback ))
        {
            ERROR_OUT(( "Could not allocate SBC cache of (%u)",
                         pCache->cEntries));
            pCache->cEntries = 0;
        }
    }

    TRACE_OUT(( "Created new cache: 0x%08x, size %u",
                 pCache->handle,
                 pCache->cEntries));

    //
    // Copy the relevant cache information into the shared memory buffer
    //
    m_asbcCacheInfo[cache].cEntries  = (WORD)pCache->cEntries;
    m_asbcCacheInfo[cache].cCellSize = (WORD)pCache->cCellSize;

    TRACE_OUT(("SBC cache %d: %d entries of size %d",
        cache, m_asbcCacheInfo[cache].cEntries, m_asbcCacheInfo[cache].cCellSize));

    DebugExitVOID(ASHost::SBC_RecreateSendCache);
}



//
// SBC_RecalcCaps()
//
// Enumerates all the people in the share and redetermines the size of the
// bitmap cache depending on their and the local receive capabilities.
//
//
// THIS CAN GO AWAY WHEN 2.X COMPAT DOES
//
void  ASShare::SBC_RecalcCaps(BOOL fJoiner)
{
    SBC_NEW_CAPABILITIES newCapabilities;
    UINT                newSmallCellSize;
    UINT                newSmallMaxEntries;
    UINT                newMediumCellSize;
    UINT                newMediumMaxEntries;
    UINT                newLargeCellSize;
    UINT                newLargeMaxEntries;
    PBMC_DIB_CACHE      pSmall;
    PBMC_DIB_CACHE      pMedium;
    PBMC_DIB_CACHE      pLarge;
    BOOL                cacheChanged = FALSE;
    ASPerson *          pasT;

    DebugEntry(ASShare::SBC_RecalcCaps);

    if (!m_pHost || !g_sbcEnabled)
    {
        //
        // Nothing to do -- we're not hosting, or there is no SBC.  Note that
        // 2.x always recalculated this stuff when somebody joined AND
        // somebody left.
        //
        DC_QUIT;
    }

    ValidatePerson(m_pasLocal);

    pSmall = &(m_pHost->m_asbcBmpCaches[ID_SMALL_BMP_CACHE]);
    pMedium= &(m_pHost->m_asbcBmpCaches[ID_MEDIUM_BMP_CACHE]);
    pLarge = &(m_pHost->m_asbcBmpCaches[ID_LARGE_BMP_CACHE]);

    //
    // Enumerate all the bitmap cache receive capabilities of the parties
    // in the share.  The usable size of the send bitmap cache is then the
    // minimum of all the remote receive caches and the local send cache
    // size.
    //

    //
    // Start by setting the size of the local send bitmap cache to the
    // local default values.
    //
    newSmallCellSize    = m_pasLocal->cpcCaps.bitmaps.sender.capsSmallCacheCellSize;
    newSmallMaxEntries  = m_pasLocal->cpcCaps.bitmaps.sender.capsSmallCacheNumEntries;

    newMediumCellSize   = m_pasLocal->cpcCaps.bitmaps.sender.capsMediumCacheCellSize;
    newMediumMaxEntries = m_pasLocal->cpcCaps.bitmaps.sender.capsMediumCacheNumEntries;

    newLargeCellSize    = m_pasLocal->cpcCaps.bitmaps.sender.capsLargeCacheCellSize;
    newLargeMaxEntries  = m_pasLocal->cpcCaps.bitmaps.sender.capsLargeCacheNumEntries;

    if (m_scShareVersion < CAPS_VERSION_30)
    {
        TRACE_OUT(("In share with 2.x nodes, must recalc SBC caps"));

        //
        // Now enumerate all the REMOTE parties in the share and set our send bitmap
        // size appropriately.
        //
        for (pasT = m_pasLocal->pasNext; pasT != NULL; pasT = pasT->pasNext)
        {
            //
            // Set the size of the local send bitmap cache to the minimum of its
            // current size and this party's receive bitmap cache size.
            //
            newSmallCellSize    = min(newSmallCellSize,
                pasT->cpcCaps.bitmaps.receiver.capsSmallCacheCellSize);
            newSmallMaxEntries  = min(newSmallMaxEntries,
                pasT->cpcCaps.bitmaps.receiver.capsSmallCacheNumEntries);

            newMediumCellSize   = min(newMediumCellSize,
                pasT->cpcCaps.bitmaps.receiver.capsMediumCacheCellSize);
            newMediumMaxEntries = min(newMediumMaxEntries,
                pasT->cpcCaps.bitmaps.receiver.capsMediumCacheNumEntries);

            newLargeCellSize    = min(newLargeCellSize,
                pasT->cpcCaps.bitmaps.receiver.capsLargeCacheCellSize);
            newLargeMaxEntries  = min(newLargeMaxEntries,
                pasT->cpcCaps.bitmaps.receiver.capsLargeCacheNumEntries);
        }
    }

    TRACE_OUT(("Recalced SBC caps:  Small {%d of %d}, Medium {%d of %d}, Large {%d of %d}",
            newSmallMaxEntries, newSmallCellSize,
            newMediumMaxEntries, newMediumCellSize,
            newLargeMaxEntries, newLargeCellSize));


    //
    // If we've changed the size, reset the cache before continuing.
    //
    if ((pSmall->cCellSize != newSmallCellSize) ||
        (pSmall->cEntries != newSmallMaxEntries))
    {
        m_pHost->SBC_RecreateSendCache(ID_SMALL_BMP_CACHE,
                             newSmallMaxEntries,
                             newSmallCellSize);
        cacheChanged = TRUE;
    }

    if ((pMedium->cCellSize != newMediumCellSize) ||
        (pMedium->cEntries != newMediumMaxEntries))
    {
        m_pHost->SBC_RecreateSendCache(ID_MEDIUM_BMP_CACHE,
                             newMediumMaxEntries,
                             newMediumCellSize);
        cacheChanged = TRUE;
    }

    if ((pLarge->cCellSize != newLargeCellSize) ||
        (pLarge->cEntries != newLargeMaxEntries))
    {
        m_pHost->SBC_RecreateSendCache(ID_LARGE_BMP_CACHE,
                             newLargeMaxEntries,
                             newLargeCellSize);
        cacheChanged = TRUE;
    }

    //
    // If we had to recreate any of the send caches, make sure that we
    // clear the fast path.
    //
    if (cacheChanged)
    {
        m_pHost->SBC_CacheCleared();
    }

    //
    // Handle new capabilities
    //

    //
    // Set up the new capabilities structure...
    //
    newCapabilities.sendingBpp     = m_pHost->m_usrSendingBPP;

    newCapabilities.cacheInfo      = m_pHost->m_asbcCacheInfo;

    //
    // ... and pass it through to the driver.
    //
    if (! OSI_FunctionRequest(SBC_ESC_NEW_CAPABILITIES,
                            (LPOSI_ESCAPE_HEADER)&newCapabilities,
                            sizeof(newCapabilities)))
    {
        ERROR_OUT(("SBC_ESC_NEW_CAPABILITIES failed"));
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::SBC_RecalcCaps);
}



//
// FUNCTION: SBCCacheCallback
//
// DESCRIPTION:
//
// Send BMC Cache Manager callback function.  Called whenever an entry is
// removed from the cache to allow us to free up the object.
//
// PARAMETERS:
//
// hCache - cache handle
//
// event - the cache event that has occured
//
// iCacheEntry - index of the cache entry that the event is affecting
//
// pData - pointer to the cache data associated with the given cache entry
//
// cbDataSize - size in bytes of the cached data
//
// RETURNS: Nothing
//
//
void  SBCCacheCallback
(
    ASHost *    pHost,
    PCHCACHE    pCache,
    UINT        iCacheEntry,
    LPBYTE      pData
)
{
    UINT cache;

    DebugEntry(SBCCacheCallback);

    //
    // Simply release the cache entry for reuse.  We must scan for
    // the correct cache root
    //
    for (cache = 0; cache < NUM_BMP_CACHES; cache++)
    {
        if (pHost->m_asbcBmpCaches[cache].handle == pCache)
        {
            pHost->m_asbcBmpCaches[cache].freeEntry = (PBMC_DIB_ENTRY)pData;
            pHost->m_asbcBmpCaches[cache].freeEntry->inUse = FALSE;

            TRACE_OUT(("0x%08x SBC cache entry 0x%08x now free", pCache, pData));

            pHost->SBC_CacheEntryRemoved(cache, iCacheEntry);
            break;
        }
    }

    DebugExitVOID(SBCCacheCallback);
}



//
//
// SBC_ProcessMemBltOrder()
//
//
BOOL  ASHost::SBC_ProcessMemBltOrder
(
    LPINT_ORDER         pOrder,
    LPINT_ORDER *       ppNextOrder
)
{
    BOOL                rc = FALSE;
    UINT                orderType;
    UINT                tileId;
    UINT                tileType;
    LPSBC_TILE_DATA     pTileData = NULL;
    UINT                bitmapWidth;
    int                 bitmapHeight;
    LPINT_ORDER         pBMCOrder = NULL;
    UINT                colorCacheIndex;
    UINT                bitsCache;
    UINT                bitsCacheIndex;
    UINT                numColors;
    LPLONG              pXSrc;
    LPLONG              pYSrc;
    BOOL                isNewColorTableEntry;
    BOOL                isNewBitsEntry;
    BOOL                canFastPath  = TRUE;
    LPMEMBLT_ORDER      pMemBltOrder = (LPMEMBLT_ORDER)&(pOrder->abOrderData);
    LPMEM3BLT_ORDER     pMem3BltOrder   = (LPMEM3BLT_ORDER)pMemBltOrder;
    LPMEMBLT_R2_ORDER   pMemBltR2Order  = (LPMEMBLT_R2_ORDER)pMemBltOrder;
    LPMEM3BLT_R2_ORDER  pMem3BltR2Order = (LPMEM3BLT_R2_ORDER)pMemBltOrder;
    BITMAPINFO_ours     sbcBitmapInfo;

    DebugEntry(ASHost::SBC_ProcessMemBltOrder);

    *ppNextOrder = NULL;

    //
    // We may already have processed this MEMBLT order and have the color
    // table and bitmap bits for it, ready to go across the wire.  This
    // would happen if the update packager called this function to process
    // the MEMBLT, but then didn't have enough room in its current network
    // packet to send the color table or the bitmap bits.
    //
    // So, if we've already processed this order, bail out now.
    //
    if (m_sbcOrderInfo.pOrder == pOrder)
    {
        //
        // We've got a match !  Do we have valid data for it ?  If we don't
        // we must have failed last time, so we'll probably fail again (we
        // don't do any memory allocation, so it's unlikely that the error
        // condition has cleared up).  In any case, we should not have been
        // called again if we failed last time...
        //
        if (m_sbcOrderInfo.validData)
        {
            TRACE_OUT(( "Already have valid data for this MEMBLT"));
            rc = TRUE;
        }
        else
        {
            WARNING_OUT(( "Have invalid data for this MEMBLT"));
        }
        DC_QUIT;
    }

    //
    // Re-initialise m_sbcOrderInfo
    //
    m_sbcOrderInfo.pOrder         = pOrder;
    m_sbcOrderInfo.validData      = FALSE;
    m_sbcOrderInfo.sentColorTable = FALSE;
    m_sbcOrderInfo.sentBitmapBits = FALSE;
    m_sbcOrderInfo.sentMemBlt     = FALSE;

    //
    // Here's on overview of what we do here...
    //
    // We've been given a MEMBLT order which references an entry in a shunt
    // buffer containing the bits for the MEMBLT at the native bpp (the bpp
    // of the display).  We want to cache the bits and a color table at the
    // protocol bpp.  So, we
    //
    // - copy the bits from the shunt buffer into a work DIB section
    // - call GetDIBits to get the data from the work DIB section at the
    //   protocol bpp
    // - cache the bits and the color table
    // - if we add new cache entries for the bits and / or the color table,
    //   we fill in m_sbcOrderInfo.pBitmapBits order and / or
    //   m_sbcOrderInfo.pColorTableInfo to hold the orders to be sent before
    //   the MEMBLT order.
    //

    //
    // Make sure that we've been given the correct order type.  Note that
    // we will never be given the R2 versions of the MEMBLT orders.
    //
    orderType = pMemBltOrder->type;
    ASSERT(((orderType == ORD_MEMBLT_TYPE) ||
                (orderType == ORD_MEM3BLT_TYPE)));

    //
    // Get a pointer to the entry in one of the shunt buffers which matches
    // this order.
    //
    if (orderType == ORD_MEMBLT_TYPE)
    {
        tileId = pMemBltOrder->cacheId;
    }
    else
    {
        tileId = pMem3BltOrder->cacheId;
    }

    if (!SBCGetTileData(tileId, &pTileData, &tileType))
    {
        ERROR_OUT(( "Failed to find entry for tile %hx in shunt buffer",
                     tileId));
        DC_QUIT;
    }

    bitmapWidth  = pTileData->width;
    bitmapHeight = pTileData->height;

    //
    // Check if we should do any fast path operations on this bitmap
    //
    if (pTileData->majorCacheInfo == SBC_DONT_FASTPATH)
    {
        TRACE_OUT(( "Tile %x should not be fastpathed", tileId));
        canFastPath = FALSE;
    }
    //
    // Try to find an entry for this bitmap in the fast path (unless the
    // bitmap is marked as being non-fastpathable).
    //
    if (canFastPath && SBCFindInFastPath(pTileData->majorCacheInfo,
                                         pTileData->minorCacheInfo,
                                         pTileData->majorPalette,
                                         pTileData->minorPalette,
                                         pTileData->srcX,
                                         pTileData->srcY,
                                         pTileData->tilingWidth,
                                         pTileData->tilingHeight,
                                         &bitsCache,
                                         &bitsCacheIndex,
                                         &colorCacheIndex))
    {
        isNewBitsEntry       = FALSE;
        isNewColorTableEntry = FALSE;

        //
        // Call the cache handler to get it to update its MRU entry for
        // this cache entry
        //
        CH_TouchCacheEntry(m_asbcBmpCaches[bitsCache].handle, bitsCacheIndex);
    }
    else
    {
        //
        // There is no entry in the fast path...
        //
        // Copy the data from the tile in the shunt buffer into the work
        // DIB section.  Note that this only works correctly because both
        // our work DIB and the tile data are "top down" rather than the
        // default of "bottom up".  i.e the data for the first scanline is
        // stored first in memory.  If this wasn't the case, we'd have to
        // work out an offset into the work DIB to start copying to.
        //
        memcpy(m_asbcWorkInfo[tileType].pWorkBitmapBits,
                  pTileData->bitData,
                  pTileData->bytesUsed);

        //
        // Now set up the destination for the GetDIBits call.  First set up
        // a bitmap info header to pass to GetDIBits.  Only the header part
        // of the structure will be sent across the network - the color
        // table is sent via the palette packets.
        //
        // Note that we set the height in the bitmap info header to be
        // negative.  This forces a convertion from our "top down" DIB
        // format to the default "bottom up" format which we want to cache
        // and send over the wire.
        //
        ZeroMemory(&sbcBitmapInfo, sizeof(sbcBitmapInfo));
        m_pShare->USR_InitDIBitmapHeader((BITMAPINFOHEADER *)&sbcBitmapInfo,
            m_usrSendingBPP);
        sbcBitmapInfo.bmiHeader.biWidth  = m_asbcWorkInfo[tileType].tileWidth;
        sbcBitmapInfo.bmiHeader.biHeight = -(int)m_asbcWorkInfo[tileType].tileHeight;

        //
        // OK, we've set up the source and the destination, so now get the
        // data at the protocol bpp.  We get the bits into the usr general
        // bitmap work buffer.
        //
        if (GetDIBits(m_usrWorkDC,
                         m_asbcWorkInfo[tileType].workBitmap,
                         0,
                         bitmapHeight,
                         m_pShare->m_usrPBitmapBuffer,
                         (BITMAPINFO *)&sbcBitmapInfo,
                         DIB_RGB_COLORS) != (int)bitmapHeight)
        {
            ERROR_OUT(( "GetDIBits failed"));
            DC_QUIT;
        }

        TRACE_OUT(( "%d x %d, (fixed %d) -> (%d, %d)",
                     bitmapWidth,
                     bitmapHeight,
                     m_asbcWorkInfo[tileType].tileWidth,
                     pMemBltOrder->nLeftRect,
                     pMemBltOrder->nTopRect));

        numColors = COLORS_FOR_BPP(m_usrSendingBPP);

        //
        // There is no color table to cache if there is no color table at
        // all, which is the case when sending at 24BPP
        //
        if (numColors)
        {
            //
            // Cache the color table.  If this succeeds, colorCacheIndex will
            // be set up to contain the details of the cache entry which the
            // data is cached in.  In addition, if isNewColorTableEntry is TRUE
            // on return, psbcOrders.colorTableOrder will be fully initialized
            // and ready to go across the wire.
            //
            if (!SBCCacheColorTable(m_sbcOrderInfo.pColorTableOrder,
                                sbcBitmapInfo.bmiColors,
                                numColors,
                                &colorCacheIndex,
                                &isNewColorTableEntry))
            {
                TRACE_OUT(( "Failed to cache color table"));
                DC_QUIT;
            }

            ASSERT(colorCacheIndex != COLORCACHEINDEX_NONE);
        }
        else
        {
            colorCacheIndex = COLORCACHEINDEX_NONE;
            isNewColorTableEntry = FALSE;
        }


        //
        // Cache the bits.  If this succeeds, bitsCache and bitsCacheIndex
        // will be set up to contain the details of the cache entry which
        // the data is cached in.  In addition, if isNewBitsEntry is TRUE
        // on return, psbcOrders.bitmapBitsOrder will be fully initialized
        // and ready to go across the wire.
        //
        // If this fails, the above values will be undefined.
        //
        if (!SBCCacheBits(m_sbcOrderInfo.pBitmapBitsOrder,
                          m_sbcOrderInfo.bitmapBitsDataSize,
                          m_pShare->m_usrPBitmapBuffer,
                          bitmapWidth,
                          m_asbcWorkInfo[tileType].tileWidth,
                          bitmapHeight,
                          BYTES_IN_BITMAP(m_asbcWorkInfo[tileType].tileWidth,
                                          bitmapHeight,
                                          sbcBitmapInfo.bmiHeader.biBitCount),
                          &bitsCache,
                          &bitsCacheIndex,
                          &isNewBitsEntry))
        {
            TRACE_OUT(( "Failed to cache bits"));
            DC_QUIT;
        }

        //
        // Add the newly cached item to the fast path (unless the bitmap is
        // marked as being non-fastpathable).
        //
        if (canFastPath)
        {
            SBCAddToFastPath(pTileData->majorCacheInfo,
                             pTileData->minorCacheInfo,
                             pTileData->majorPalette,
                             pTileData->minorPalette,
                             pTileData->srcX,
                             pTileData->srcY,
                             pTileData->tilingWidth,
                             pTileData->tilingHeight,
                             bitsCache,
                             bitsCacheIndex,
                             colorCacheIndex);
        }
    }

    //
    // We've now got valid cache entries for the DIB bits and the color
    // table, so we should now fill them into the MEMBLT order.
    //
    // Set up the source co-ordinates. For R1 protocols, the x-coordinate
    // includes the offset which is required to get the right cell within
    // the receive bitmap cache. For R2, we set up the cache entry in a
    // separate field.
    //
    if (orderType == ORD_MEMBLT_TYPE)
    {
        pXSrc = &pMemBltOrder->nXSrc;
        pYSrc = &pMemBltOrder->nYSrc;
    }
    else
    {
        pXSrc = &pMem3BltOrder->nXSrc;
        pYSrc = &pMem3BltOrder->nYSrc;
    }

    *pXSrc = *pXSrc % pTileData->tilingWidth;
    *pYSrc = *pYSrc % pTileData->tilingHeight;

    //
    // The sub-bitmap and color table are in the cache.  Store a cache
    // handle and color handle.  Also store the cache index for R2
    // protocols (see above).
    //
    if (orderType == ORD_MEMBLT_TYPE)
    {
        pMemBltOrder->cacheId = MEMBLT_COMBINEHANDLES(colorCacheIndex,
                                                      bitsCache);

        pMemBltR2Order->type       = (TSHR_UINT16)ORD_MEMBLT_R2_TYPE;
        pMemBltR2Order->cacheIndex = (TSHR_UINT16)bitsCacheIndex;

        TRACE_OUT(( "MEMBLT color %u bitmap %u:%u",
                     colorCacheIndex,
                     bitsCache,
                     bitsCacheIndex));
    }
    else
    {
        pMem3BltOrder->cacheId = MEMBLT_COMBINEHANDLES(colorCacheIndex,
                                                       bitsCache);

        pMem3BltR2Order->type       = ORD_MEM3BLT_R2_TYPE;
        pMem3BltR2Order->cacheIndex = (TSHR_UINT16)bitsCacheIndex;

        TRACE_OUT(( "MEM3BLT color %u bitmap %u:%u",
                     colorCacheIndex,
                     bitsCache,
                     bitsCacheIndex));
    }

    //
    // Must have successfully completed processing the order to get to
    // here.  Fill in the appropriate info in the m_sbcOrderInfo structure.
    // If we got a cache hit on the color table or the bitmap bits then
    // we've already sent the data for them.
    //
    m_sbcOrderInfo.validData        = TRUE;
    m_sbcOrderInfo.sentColorTable   = !isNewColorTableEntry;
    m_sbcOrderInfo.sentBitmapBits   = !isNewBitsEntry;
    rc                              = TRUE;

DC_EXIT_POINT:
    if (rc)
    {
        //
        // We've successfully processed the MEMBLT, so set up a pointer to
        // the next order which should be sent by the caller.
        //
        // Note that if we have already sent these orders, then we return
        // a NULL order.
        //
        if (!m_sbcOrderInfo.sentColorTable)
        {
            TRACE_OUT(( "Returning color table order"));
            *ppNextOrder = m_sbcOrderInfo.pColorTableOrder;
        }
        else if (!m_sbcOrderInfo.sentBitmapBits)
        {
            TRACE_OUT(( "Returning bitmap bits order"));
            *ppNextOrder = m_sbcOrderInfo.pBitmapBitsOrder;
        }
        else if (!m_sbcOrderInfo.sentMemBlt)
        {
            TRACE_OUT(( "Returning MemBlt order"));
            *ppNextOrder = pOrder;
        }
        else
        {
            TRACE_OUT(( "No order to return"));
            rc = FALSE;
        }
    }

    //
    // We've finished with the entry in the shunt buffer, so reset the
    // inUse flag to allow the driver to re-use it.
    //
    if (pTileData != NULL)
    {
        pTileData->inUse = FALSE;
    }

    DebugExitBOOL(ASHost::SBC_ProcessMemBltOrder, rc);
    return(rc);
}


//
//
// SBC_OrderSentNotification()
//
//
void  ASHost::SBC_OrderSentNotification(LPINT_ORDER pOrder)
{
    DebugEntry(ASHost::SBC_OrderSentNotification);

    //
    // pOrder should be a pointer to either our internal bitmap bits order,
    // or our color table order.
    //
    if (pOrder == m_sbcOrderInfo.pBitmapBitsOrder)
    {
        TRACE_OUT(( "Bitmap bits order has been sent"));
        m_sbcOrderInfo.sentBitmapBits = TRUE;
    }
    else if (pOrder == m_sbcOrderInfo.pColorTableOrder)
    {
        TRACE_OUT(( "Color table order has been sent"));
        m_sbcOrderInfo.sentColorTable = TRUE;
    }
    else if (pOrder == m_sbcOrderInfo.pOrder)
    {
        TRACE_OUT(( "Memblt order has been sent"));
        m_sbcOrderInfo.sentMemBlt = TRUE;

        //
        // All parts of the Memblt have been sent now, so reset our pointer
        // to the order.  This avoids a problem where
        // SBC_ProcessMemBltOrder is called twice in a row with the same
        // pOrder, but with different data (i.e.  consecutive MemBlts
        // ending up in the same point in the order heap).  It can happen...
        //
        m_sbcOrderInfo.pOrder = NULL;
    }
    else
    {
        ERROR_OUT(( "Notification for unknown order %#.8lx", pOrder));
    }

    DebugExitVOID(ASHost::SBC_OrderSentNotification);
}


//
//
// SBC_ProcessInternalOrder()
//
//
void  ASHost::SBC_ProcessInternalOrder(LPINT_ORDER pOrder)
{
    UINT                            orderType;
    LPINT_COLORTABLE_ORDER_1BPP     pColorTableOrder;
    HBITMAP                         oldBitmap = 0;
    UINT                            numEntries;
    int                             i;

    DebugEntry(ASHost::SBC_ProcessInternalOrder);

    //
    // Make sure that we've been given an order type which we recognise.
    // Currently, the only internal order we support is a color table
    // order.
    //
    pColorTableOrder = (LPINT_COLORTABLE_ORDER_1BPP)&(pOrder->abOrderData);
    orderType        = pColorTableOrder->header.type;

    ASSERT(orderType == INTORD_COLORTABLE_TYPE);

    //
    // Make sure that the color table order is the same bpp as the work DIB
    // sections.
    //
    ASSERT(pColorTableOrder->header.bpp == g_usrCaptureBPP);

    //
    // All we have to do is to copy the color table from the order into our
    // two work DIB sections.  To do that, we have to select the DIB
    // sections into a DC then set the color table for the DC - this sets
    // the color table in the DIB section.
    //
    numEntries = COLORS_FOR_BPP(g_usrCaptureBPP);
    ASSERT(numEntries);

    for (i = 0 ; i < SBC_NUM_TILE_SIZES; i++)
    {
        oldBitmap = SelectBitmap(m_usrWorkDC, m_asbcWorkInfo[i].workBitmap);

        SetDIBColorTable(m_usrWorkDC,
                         0,                     // First index
                         numEntries,            // Number of entries
                         (RGBQUAD*)pColorTableOrder->colorData);
    }

    if (oldBitmap != NULL)
    {
        SelectBitmap(m_usrWorkDC, oldBitmap);
    }

    DebugExitVOID(ASHost::SBC_ProcessInternalOrder);
}


//
//
// SBC_PMCacheEntryRemoved()
//
//
void  ASHost::SBC_PMCacheEntryRemoved(UINT cacheIndex)
{
    LPSBC_FASTPATH_ENTRY pEntry;
    LPSBC_FASTPATH_ENTRY pNextEntry;

    DebugEntry(ASHost::SBC_PMCacheEntryRemoved);

    ASSERT(m_sbcFastPath);

    //
    // An entry has been removed from the color cache.  We have to remove
    // all entries from the fast path which reference this color table.
    //
    TRACE_OUT(( "Color table cache entry %d removed - removing references",
                 cacheIndex));

    pEntry = (LPSBC_FASTPATH_ENTRY)COM_BasedListFirst(&m_sbcFastPath->usedList, FIELD_OFFSET(SBC_FASTPATH_ENTRY, list));
    while (pEntry != NULL)
    {
        pNextEntry = (LPSBC_FASTPATH_ENTRY)COM_BasedListNext(&m_sbcFastPath->usedList, pEntry,
            FIELD_OFFSET(SBC_FASTPATH_ENTRY, list));

        if (pEntry->colorIndex == cacheIndex)
        {
            COM_BasedListRemove(&pEntry->list);
            COM_BasedListInsertAfter(&m_sbcFastPath->freeList, &pEntry->list);
        }

        pEntry = pNextEntry;
    }

    DebugExitVOID(ASHost::SBC_PMCacheEntryRemoved);
}




//
//
// Name:      SBCInitInternalOrders
//
// Purpose:   Allocate memory for the internal orders used during MEMBLT
//            order processing.
//
// Returns:   TRUE if initialized OK, FALSE otherwise.
//
// Params:    None
//
// Operation: If successful, this function initializes the following
//
//              g_Share->sbcOrderInfo
//
//
BOOL  ASHost::SBCInitInternalOrders(void)
{
    BOOL                initOK = FALSE;
    UINT                orderSize;
    LPINT_ORDER_HEADER  pOrderHeader;

    DebugEntry(ASHost::SBCInitInternalOrders);

    //
    // Start with the bitmap bits order.  Calculate the number of bytes
    // required to store the bits for the largest bitmap bits order we will
    // ever send.  This includes room for the compression header which gets
    // added before the bits if the data is compressed.
    //
    if (g_usrCaptureBPP >= 24)
    {
        // Can possibly send 24bpp TRUE COLOR data
        m_sbcOrderInfo.bitmapBitsDataSize =
            BYTES_IN_BITMAP(MP_LARGE_TILE_WIDTH, MP_LARGE_TILE_HEIGHT, 24)
            + sizeof(CD_HEADER);
    }
    else
    {
        // Can't send 24bpp TRUE color data
        m_sbcOrderInfo.bitmapBitsDataSize =
            BYTES_IN_BITMAP(MP_LARGE_TILE_WIDTH, MP_LARGE_TILE_WIDTH, 8)
            + sizeof(CD_HEADER);
    }

    //
    // Now allocate memory for the bitmap bits order.  The size required
    // is:
    //   The size of an INT_ORDER_HEADER (this is added in by OA when you
    //   call OA_AllocOrderMem)
    //   + the size of the largest BMC_BITMAP_BITS_ORDER structure
    //   + the number of bytes required for the bitmap bits
    //   + contingency for RLE compression overruns !
    //
    orderSize = sizeof(INT_ORDER_HEADER)
              + sizeof(BMC_BITMAP_BITS_ORDER_R2)
              + m_sbcOrderInfo.bitmapBitsDataSize
              + 4;

    TRACE_OUT(( "Allocating %d bytes for SBC bitmap bits order (bits %d)",
                 orderSize,
                 m_sbcOrderInfo.bitmapBitsDataSize));

    m_sbcOrderInfo.pBitmapBitsOrder = (LPINT_ORDER)new BYTE[orderSize];
    if (!m_sbcOrderInfo.pBitmapBitsOrder)
    {
        ERROR_OUT((
               "Failed to alloc %d bytes for SBC bitmap bits order (bits %d)",
               orderSize,
               m_sbcOrderInfo.bitmapBitsDataSize));
        DC_QUIT;
    }

    //
    // Initialize the INT_ORDER_HEADER - this is normally done in
    // OA_AllocOrderMem().  For the bitmap bits order, we can't fill in the
    // orderLength because it is not a fixed size - this has to be done
    // later when we fill in the bitmap bits.  Note that the order length
    // excludes the size of the INT_ORDER_HEADER.
    //
    pOrderHeader = &m_sbcOrderInfo.pBitmapBitsOrder->OrderHeader;
    pOrderHeader->additionalOrderData         = 0;
    pOrderHeader->cbAdditionalOrderDataLength = 0;

    //
    // Now the color table order.  The size required is:
    //   The size of an INT_ORDER_HEADER (this is added in by OA when you
    //   call OA_AllocOrderMem)
    //   + the size of a BMC_COLOR_TABLE_ORDER structure
    //   + the number of bytes required for the color table entries (note
    //     that the BMC_COLOR_TABLE_ORDER structure contains the first
    //     color table entry, so adjust the number of extra bytes required)
    //

    // Color tables are only for 8bpp and less.
    orderSize = sizeof(INT_ORDER_HEADER)
              + sizeof(BMC_COLOR_TABLE_ORDER)
              + (COLORS_FOR_BPP(8) - 1) * sizeof(TSHR_RGBQUAD);

    TRACE_OUT(( "Allocating %d bytes for SBC color table order", orderSize));

    m_sbcOrderInfo.pColorTableOrder = (LPINT_ORDER)new BYTE[orderSize];
    if (!m_sbcOrderInfo.pColorTableOrder)
    {
        ERROR_OUT(( "Failed to alloc %d bytes for SBC color table order",
                     orderSize));
        DC_QUIT;
    }

    pOrderHeader = &m_sbcOrderInfo.pColorTableOrder->OrderHeader;
    pOrderHeader->additionalOrderData         = 0;
    pOrderHeader->cbAdditionalOrderDataLength = 0;
    pOrderHeader->Common.cbOrderDataLength    = (WORD)(orderSize - sizeof(INT_ORDER_HEADER));

    //
    // Fill in the remaining fields in m_sbcOrderInfo
    //
    m_sbcOrderInfo.pOrder         = NULL;
    m_sbcOrderInfo.validData      = FALSE;
    m_sbcOrderInfo.sentColorTable = FALSE;
    m_sbcOrderInfo.sentBitmapBits = FALSE;
    m_sbcOrderInfo.sentMemBlt     = FALSE;

    //
    // Must be OK to get to here
    //
    initOK = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(ASHost::SBCInitInternalOrders, initOK);
    return(initOK);
}


//
//
// Name:      SBCFreeInternalOrders
//
// Purpose:   Free up the internal orders used by SBC during MEMBLT order
//            processing.
//
// Returns:   Nothing
//
// Params:    None
//
//
void  ASHost::SBCFreeInternalOrders(void)
{
    DebugEntry(ASHost::SBCFreeInternalOrders);

    //
    // First free up the memory.
    //
    if (m_sbcOrderInfo.pBitmapBitsOrder)
    {
        delete m_sbcOrderInfo.pBitmapBitsOrder;
        m_sbcOrderInfo.pBitmapBitsOrder = NULL;
    }

    if (m_sbcOrderInfo.pColorTableOrder)
    {
        delete m_sbcOrderInfo.pColorTableOrder;
        m_sbcOrderInfo.pColorTableOrder = NULL;
    }

    //
    // Now reset the remaining fields in m_sbcOrderInfo
    //
    m_sbcOrderInfo.pOrder             = NULL;
    m_sbcOrderInfo.validData          = FALSE;
    m_sbcOrderInfo.sentColorTable     = FALSE;
    m_sbcOrderInfo.sentBitmapBits     = FALSE;
    m_sbcOrderInfo.bitmapBitsDataSize = 0;

    DebugExitVOID(ASHost::SBCFreeInternalOrders);
}





//
//
// Name:      SBCInitFastPath
//
// Purpose:   Initialize the SBC fast path
//
// Returns:   TRUE if successful, FALSE otherwise
//
// Params:    None
//
//
BOOL  ASHost::SBCInitFastPath(void)
{
    BOOL    rc = FALSE;

    DebugEntry(ASHost::SBCInitFastPath);

    m_sbcFastPath = new SBC_FASTPATH;
    if (!m_sbcFastPath)
    {
        ERROR_OUT(("Failed to alloc m_sbcFastPath"));
        DC_QUIT;
    }

    SET_STAMP(m_sbcFastPath, SBCFASTPATH);

    //
    // Initialize the structure.
    //
    SBC_CacheCleared();

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASHost::SBCInitFastPath, rc);
    return(rc);
}


//
//
// Name:      SBCGetTileData
//
// Purpose:   Given the ID of a tile data entry in one of the SBC shunt
//            buffers, return a pointer to the entry with that ID.
//
// Returns:   TRUE if the entry is found, FALSE otherwise
//
// Params:    IN  tileId     - The ID of the shunt buffer entry to be
//                             found.
//            OUT ppTileData - A pointer to the start of the shunt buffer
//                             entry (if found)
//            OUT pTileType  - The type of shunt buffer entry found.  One
//                             of:
//                                 SBC_MEDIUM_TILE
//                                 SBC_LARGE_TILE
//
//
BOOL  ASHost::SBCGetTileData
(
    UINT                tileId,
    LPSBC_TILE_DATA *   ppTileData,
    LPUINT              pTileType
)
{
    BOOL                gotTileData = FALSE;
    UINT                workTile;
    LPSBC_TILE_DATA     pWorkTile;

    DebugEntry(ASHost::SBCGetTileData);

    TRACE_OUT(( "Looking for tile Id %x", tileId));

    //
    // Find out which of the shunt buffers the entry should be in.
    //
    *pTileType = SBC_TILE_TYPE(tileId);

    //
    // We implement the shunt buffers as circular FIFO queues, so in
    // general, we are looking for the entry following the last one which
    // we found.  However, this wont always be the case because we do some
    // out of order processing when we do spoiling.
    //
    // So, get the index of the last tile we accessed.
    //
    workTile = m_asbcWorkInfo[*pTileType].mruIndex;

    //
    // OK, so lets go for it !  Start at the tile following the last one we
    // accessed, and loop through the circular buffer until we get a match,
    // or have circled back to the beginning.
    //
    // Note that this has been coded as a "do while" loop, rather than just
    // a "while" loop so that we don't miss mruTile.
    //
    do
    {
        //
        // On to the next tile
        //
        workTile++;
        if (workTile == m_asbcWorkInfo[*pTileType].pShuntBuffer->numEntries)
        {
            workTile = 0;
        }

        pWorkTile = SBCTilePtrFromIndex(m_asbcWorkInfo[*pTileType].pShuntBuffer,
                                        workTile);

        if (pWorkTile->inUse)
        {
            if (pWorkTile->tileId == tileId)
            {
                //
                // We've got a match.
                //
                TRACE_OUT(( "Matched tile Id %x at index %d",
                             tileId,
                             workTile));
                *ppTileData                      = pWorkTile;
                gotTileData                      = TRUE;
                m_asbcWorkInfo[*pTileType].mruIndex = workTile;
                DC_QUIT;
            }
        }
    }
    while (workTile != m_asbcWorkInfo[*pTileType].mruIndex);

    //
    // If we get to here, we've not found a match.
    //
    TRACE_OUT(( "No match for tile Id %x", tileId));

DC_EXIT_POINT:
    DebugExitBOOL(ASHost::SBCGetTileData, gotTileData);
    return(gotTileData);
}




//
//
// Name:      SBCCacheColorTable
//
// Purpose:   Ensure that the given color table is cached.
//
// Returns:   TRUE if the color table is cached successfully, FALSE
//            otherwise.
//
// Params:    IN  pOrder      - A pointer to a color table order to be
//                              filled in.
//            IN  pColorTable - A pointer to the start of the color table
//                              to be cached.
//            IN  numColors   - The number of colors in the color table.
//            OUT pCacheIndex - The index of the cached color table.
//            OUT pIsNewEntry - TRUE if we added a new cache entry,
//                              FALSE if we matched an existing entry.
//
// Operation: pOrder is only filled in if *pIsNewEntry is FALSE.
//
//
BOOL  ASHost::SBCCacheColorTable
(
    LPINT_ORDER     pOrder,
    LPTSHR_RGBQUAD  pColorTable,
    UINT            numColors,
    UINT *          pCacheIndex,
    LPBOOL          pIsNewEntry
)
{
    BOOL                  cachedOK = FALSE;
    UINT                  cacheIndex;
    PBMC_COLOR_TABLE_ORDER  pColorTableOrder;

    DebugEntry(ASHost::SBCCacheColorTable);

    //
    // Call PM to do the caching.
    //
    if (!PM_CacheTxColorTable(&cacheIndex,
                              pIsNewEntry,
                              numColors,
                              pColorTable))
    {
        ERROR_OUT(( "Failed to cache color table"));
        DC_QUIT;
    }

    //
    // If the cache operation resulted in a cache update then we have to
    // fill in the color table order.
    //
    if (*pIsNewEntry)
    {
        //
        // The color table is new so we have to transmit it
        //
        TRACE_OUT(( "New color table"));

        pOrder->OrderHeader.Common.fOrderFlags = OF_PRIVATE;
        pColorTableOrder = (PBMC_COLOR_TABLE_ORDER)(pOrder->abOrderData);
        pColorTableOrder->bmcPacketType  = BMC_PT_COLOR_TABLE;
        pColorTableOrder->colorTableSize = (TSHR_UINT16)numColors;
        pColorTableOrder->index          = (BYTE)cacheIndex;

        //
        // Copy the new color table into the Order Packet.
        //
        memcpy(pColorTableOrder->data, pColorTable,
                  numColors * sizeof(TSHR_RGBQUAD));
    }
    else
    {
        TRACE_OUT(( "Existing color table"));
    }

    //
    // Return the color table index to the caller
    //
    *pCacheIndex = cacheIndex;
    cachedOK     = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASHost::SBCCacheColorTable, cachedOK);
    return(cachedOK);
}


//
//
// Name:      SBCCacheBits
//
// Purpose:   This function adds the supplied bitmap bits to a bitmap
//            cache.  The cache selected depends on the bitmap size, but
//            may be different for R1 and R2.  SBCSelectCache handles the
//            determination of the correct cache.
//
// Returns:   TRUE if the bits have been cached OK, FALSE otherwise
//
// Params:    IN  pOrder           - A pointer to a BMC order.
//            IN  destBitsSize     - The number of bytes available in
//                                   pOrder to store the bitmap data.
//            IN  pDIBits          - A pointer to the bits to be cached.
//            IN  bitmapWidth      - The "in use" width of the bitmap
//            IN  fixedBitmapWidth - The actual width of the bitmap
//            IN  bitmapHeight     - The height of the bitmap
//            IN  numBytes         - The number of bytes in the bitmap.
//            OUT pCache           - The cache that we put the bits into.
//            OUT pCacheIndex      - The cache index within *pCache at
//                                   which we cached the data.
//            OUT pIsNewEntry      - TRUE if we added a new cache entry,
//                                   FALSE if we matched an existing entry.
//
// Operation: pOrder is only filled in if *pIsNewEntry is FALSE.
//
//
BOOL  ASHost::SBCCacheBits
(
    LPINT_ORDER     pOrder,
    UINT            destBitsSize,
    LPBYTE          pDIBits,
    UINT            bitmapWidth,
    UINT            fixedBitmapWidth,
    UINT            bitmapHeight,
    UINT            numBytes,
    UINT *          pCache,
    UINT *          pCacheIndex,
    LPBOOL          pIsNewEntry
)
{
    BOOL                        cachedOK = FALSE;
    UINT                        cacheIndex;
    UINT                        i;
    LPBYTE                      pCompressed;
    UINT                        compressedSize;
    BOOL                        compressed;
    PBMC_DIB_ENTRY              pEntry;
    PBMC_DIB_CACHE              pCacheHdr;
    PBMC_BITMAP_BITS_ORDER_R2   pBitsOrderR2;
    PBMC_BITMAP_BITS_DATA       pBmcData;
    LPBYTE                      pDestBits;

    DebugEntry(ASHost::SBCCacheBits);

    pBmcData     = (PBMC_BITMAP_BITS_DATA)(pOrder->abOrderData);
    pBitsOrderR2 = (PBMC_BITMAP_BITS_ORDER_R2)pBmcData;

    //
    // Get a pointer to where the bitmap data starts in the order.  This
    // depends on whether it is an R1 or an R2 bitmap bits order.
    //
    pDestBits = pBitsOrderR2->data;

    //
    // Before we can select a cache entry we need to compress the bits.
    // This therefore mandates a memcpy into the cache entry when we come
    // to add it.  The saving in memory by storing the bits compressed
    // makes it all worthwhile.
    //
    // Compress the bitmap data.  At this stage we don't know whether the
    // bitmap will compress well or not, so allow cells that are larger
    // than our maximum cell size.  The largest we expect to see is 120*120*
    // 24.
    //
    compressedSize = destBitsSize;
    if (m_pShare->BC_CompressBitmap(pDIBits, pDestBits, &compressedSize,
            fixedBitmapWidth, bitmapHeight, m_usrSendingBPP,
            NULL ) &&
        (compressedSize < numBytes))

    {
        TRACE_OUT(( "Compressed bmp data from %u bytes to %u bytes",
                     numBytes,
                     compressedSize));
        compressed  = TRUE;
        pCompressed = pDestBits;
    }
    else
    {
        //
        // The bitmap could not be compressed, or bitmap compression is not
        // enabled.  Send the bitmap uncompressed.
        //
        compressed     = FALSE;
        compressedSize = numBytes;
        pCompressed    = pDIBits;
    }

    //
    // Make sure that the data will fit into the order.  Do this after
    // compression since it is possible that the uncompressed data will not
    // fit, but the compressed version will.
    //
    if (compressedSize > destBitsSize)
    {
        WARNING_OUT(( "Data (%d bytes) does not fit into order (%d bytes)",
                     compressedSize,
                     destBitsSize));
        DC_QUIT;
    }

    //
    // Select the cache based on the compressed size - we pass in the
    // sub-bitmap dimensions for R1 caching; R2 caching just uses the
    // total size of the bits.
    //
    if (!SBCSelectCache(compressedSize + sizeof(BMC_DIB_ENTRY) - 1, pCache))
    {
        TRACE_OUT(( "No cache selected"));
        DC_QUIT;
    }
    else
    {
        TRACE_OUT(( "Selected cache %d", *pCache));
    }

    //
    // Find a free cache entry in our selected cache
    //
    // We arrange that our transmit cache is always one greater than the
    // negotiated cache size so that we should never fail to find a free
    // array entry.  Once we have fully populated our Tx cache we will
    // always find the free entry as the one last given back to us by CH.
    // Note the scan to <= sbcTxCache[pmNumTxCacheEntries is NOT a mistake.
    //
    pCacheHdr = &(m_asbcBmpCaches[*pCache]);
    if (pCacheHdr->data == NULL)
    {
        ERROR_OUT(( "Asked to cache when no cache allocated"));
        DC_QUIT;
    }

    //
    // If the cache has returned an entry to us then use that without
    // having to scan.  This will be the default mode for adding entries
    // to a fully populated cache.
    //
    if (pCacheHdr->freeEntry != NULL)
    {
        pEntry               = pCacheHdr->freeEntry;
        pCacheHdr->freeEntry = NULL;
        TRACE_OUT(( "Cache fully populated - using entry 0x%08x", pEntry));
    }
    else
    {
        //
        // We are in the process of feeding the cache so we need to search
        // for a free entry
        //
        pEntry = (PBMC_DIB_ENTRY)(pCacheHdr->data);
        for (i=0 ; i < pCacheHdr->cEntries ; i++)
        {
            if (!pEntry->inUse)
            {
                break;
            }
            pEntry = (PBMC_DIB_ENTRY)(((LPBYTE)pEntry) + pCacheHdr->cSize);
        }

        //
        // We should never run out of free entries, but cope with it
        //
        if (i == pCacheHdr->cEntries)
        {
            ERROR_OUT(( "All Tx DIB cache entries in use"));
            DC_QUIT;
        }
    }

    //
    // Set up the DIB entry for caching
    //
    pEntry->inUse       = TRUE;
    pEntry->cx          = (TSHR_UINT16)bitmapWidth;
    pEntry->cxFixed     = (TSHR_UINT16)fixedBitmapWidth;
    pEntry->cy          = (TSHR_UINT16)bitmapHeight;
    pEntry->bpp         = (TSHR_UINT16)m_usrSendingBPP;
    pEntry->cBits       = numBytes;
    pEntry->bCompressed = (BYTE)compressed;
    pEntry->cCompressed = compressedSize;
    memcpy(pEntry->bits, pCompressed, compressedSize);

    //
    // Now cache the data
    //
    if (CH_SearchAndCacheData(pCacheHdr->handle,
                              (LPBYTE)pEntry,
                              sizeof(BMC_DIB_ENTRY) + compressedSize - 1,
                              0,
                              &cacheIndex))
    {
        //
        // The sub-bitmap is already in the cache
        //
        *pCacheIndex = cacheIndex;
        TRACE_OUT(( "Bitmap already cached %u:%u cx(%d) cy(%d)",
                     *pCache,
                     *pCacheIndex,
                     bitmapWidth,
                     bitmapHeight));
        *pIsNewEntry = FALSE;

        //
        // Free up the entry we just created
        //
        pEntry->inUse = FALSE;
    }
    else
    {
        *pCacheIndex = cacheIndex;
        TRACE_OUT(( "Cache entry at 0x%08x now in use", pEntry));
        TRACE_OUT(( "New cache entry %u:%u cx(%d) cy(%d)",
                     *pCache,
                     *pCacheIndex,
                     bitmapWidth,
                     bitmapHeight));
        *pIsNewEntry        = TRUE;
        pEntry->iCacheIndex = (TSHR_UINT16)*pCacheIndex;
    }

    //
    // We've got the bits into the cache.  If the cache attempt added a
    // cache entry we must fill in the bitmap cache order.
    //
    if (*pIsNewEntry)
    {
        //
        // Fill in the order details.
        //
        // Remember that we have to fill in the order size into the
        // INT_ORDER_HEADER as well as filling in the bitmap bits order
        // header.  When doing this, adjust for the number of bitmap bits
        // which are included in the bitmap bits order header.
        //
        pOrder->OrderHeader.Common.fOrderFlags = OF_PRIVATE;

        if (compressed)
        {
            pBmcData->bmcPacketType = BMC_PT_BITMAP_BITS_COMPRESSED;
        }
        else
        {
            pBmcData->bmcPacketType = BMC_PT_BITMAP_BITS_UNCOMPRESSED;

            //
            // The data is not compressed, so copy the uncompressed data
            // into the order.  In the case where we compressed the data
            // successfully, we did so directly into the order, so the
            // compressed bits are already there.
            //
            memcpy(pDestBits, pDIBits, compressedSize);
        }

        pBmcData->cacheID           = (BYTE)*pCache;
        pBmcData->cxSubBitmapWidth  = (TSHR_UINT8)fixedBitmapWidth;
        pBmcData->cySubBitmapHeight = (TSHR_UINT8)bitmapHeight;
        pBmcData->bpp               = (TSHR_UINT8)m_usrSendingBPP;
        pBmcData->cbBitmapBits      = (TSHR_UINT16)compressedSize;

        //
        // The iCacheEntryR1 field is unused for R2 - we use
        // iCacheEntryR2 instead.
        //
        pBmcData->iCacheEntryR1     = 0;
        pBitsOrderR2->iCacheEntryR2 = (TSHR_UINT16)*pCacheIndex;

        pOrder->OrderHeader.Common.cbOrderDataLength =
                                       (compressedSize
                                        + sizeof(BMC_BITMAP_BITS_ORDER_R2)
                                        - sizeof(pBitsOrderR2->data));
    }

    cachedOK = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASHost::SBCCacheBits, cachedOK);
    return(cachedOK);
}


//
//
// Name:      SBCAddToFastPath
//
// Purpose:   Add a bitmap to the fast path
//
// Returns:   Nothing
//
// Params:    IN majorInfo       - The major caching info passed up from
//                                 the driver (the bitmap ID)
//            IN minorInfo       - The minor caching info passed up from
//                                 the driver (the bitmap revision number)
//            IN majorPalette    - The major palette info passed up from
//                                 the driver (the XLATEOBJ)
//            IN minorPalette    - The minor palette info passed up from
//                                 the driver (the XLATEOBJ iUniq)
//            IN srcX            - The x coord of the source of the Blt
//            IN srcY            - The y coord of the source of the Blt
//            IN width           - The width of the area being Blted
//            IN height          - The height of the area being Blted
//            IN cache           - The cache the bits were placed in
//            IN cacheIndex      - The index at which the bits were placed
//                                 in the cache
//            IN colorCacheIndex - The index in the color table cache of
//                                 the color table associated with the bits
//
//
void  ASHost::SBCAddToFastPath
(
    UINT_PTR        majorInfo,
    UINT            minorInfo,
    UINT_PTR        majorPalette,
    UINT            minorPalette,
    int             srcX,
    int             srcY,
    UINT            width,
    UINT            height,
    UINT            cache,
    UINT            cacheIndex,
    UINT            colorCacheIndex
)
{
    LPSBC_FASTPATH_ENTRY pEntry;

    DebugEntry(ASHost::SBCAddToFastPath);

    //
    // First get a free entry
    //
    pEntry = (LPSBC_FASTPATH_ENTRY)COM_BasedListFirst(&m_sbcFastPath->freeList,
        FIELD_OFFSET(SBC_FASTPATH_ENTRY, list));
    if (pEntry == NULL)
    {
        //
        // There are no entries in the free list, so we have to use the
        // oldest entry in the used list.  The used list is stored in MRU
        // order, so we just have to get the last item in the list.
        //
        pEntry = (LPSBC_FASTPATH_ENTRY)COM_BasedListLast(&m_sbcFastPath->usedList,
            FIELD_OFFSET(SBC_FASTPATH_ENTRY, list));
        TRACE_OUT(( "Evicting fast path info for %x %x (%d, %d)",
                     pEntry->majorInfo,
                     pEntry->minorInfo,
                     pEntry->srcX,
                     pEntry->srcY));
    }

    //
    // Remove the entry from its current list
    //
    COM_BasedListRemove(&pEntry->list);

    //
    // Now fill in the details
    //
    pEntry->majorInfo    = majorInfo;
    pEntry->minorInfo    = minorInfo;
    pEntry->majorPalette = majorPalette;
    pEntry->minorPalette = minorPalette;
    pEntry->srcX         = srcX;
    pEntry->srcY         = srcY;
    pEntry->width        = width;
    pEntry->height       = height;
    pEntry->cache        = (WORD)cache;
    pEntry->cacheIndex   = (WORD)cacheIndex;
    pEntry->colorIndex   = (WORD)colorCacheIndex;

    //
    // Finally, add the entry to the front of the used list
    //
    TRACE_OUT(( "Adding fast path info for %x %x (%d, %d)",
                 pEntry->majorInfo,
                 pEntry->minorInfo,
                 pEntry->srcX,
                 pEntry->srcY));
    COM_BasedListInsertAfter(&m_sbcFastPath->usedList, &pEntry->list);

    DebugExitVOID(ASHost::SBCAddToFastPath);
}


//
//
// Name:      SBCFindInFastPath
//
// Purpose:   Check to see if a bitmap with the given attributes is in the
//            SBC fast path.  If so, return the cache info for the bitmap.
//
// Returns:   TRUE if the bitmap is in the fast path, FALSE if not.
//
// Params:    IN  majorInfo        - The major caching info passed up from
//                                   the driver (the bitmap ID)
//            IN  minorInfo        - The minor caching info passed up from
//                                   the driver (the bitmap revision
//                                   number)
//            IN  majorPalette     - The major palette info passed up from
//                                   the driver (the XLATEOBJ)
//            IN  minorPalette     - The minor palette info passed up from
//                                   the driver (the XLATEOBJ iUniq)
//            IN  srcX             - The x coord of the source of the Blt
//            IN  srcY             - The y coord of the source of the Blt
//            IN  width            - The width of the area being Blted
//            IN  height           - The height of the area being Blted
//            OUT pCache           - The cache the bits were placed in
//            OUT pCacheIndex      - The index at which the bits were
//                                   placed in the cache
//            OUT pColorCacheIndex - The index in the color table cache of
//                                   the color table associated with the
//                                   bits
//
// Operation: The contents of pCache, pCacheIndex and pColorCacheIndex
//            are only valid on return if the function returns TRUE.
//
//
BOOL  ASHost::SBCFindInFastPath
(
    UINT_PTR        majorInfo,
    UINT            minorInfo,
    UINT_PTR        majorPalette,
    UINT            minorPalette,
    int             srcX,
    int             srcY,
    UINT            width,
    UINT            height,
    UINT *          pCache,
    UINT *          pCacheIndex,
    UINT *          pColorCacheIndex
)
{
    BOOL              found = FALSE;
    LPSBC_FASTPATH_ENTRY pEntry;
    LPSBC_FASTPATH_ENTRY pNextEntry;

    DebugEntry(ASHost::SBCFindInFastPath);

    //
    // Traverse the in use list looking for a match on the parameters
    // passed in.
    //
    pEntry = (LPSBC_FASTPATH_ENTRY)COM_BasedListFirst(&m_sbcFastPath->usedList, FIELD_OFFSET(SBC_FASTPATH_ENTRY, list));
    while (pEntry != NULL)
    {
        if ((pEntry->majorInfo    == majorInfo)    &&
            (pEntry->minorInfo    == minorInfo)    &&
            (pEntry->majorPalette == majorPalette) &&
            (pEntry->minorPalette == minorPalette) &&
            (pEntry->srcX         == srcX)         &&
            (pEntry->srcY         == srcY)         &&
            (pEntry->width        == width)        &&
            (pEntry->height       == height))
        {
            //
            // We've found a match - hurrah !  Fill in the return info.
            //
            TRACE_OUT(( "Hit for %x %x (%d, %d) cache %d",
                         pEntry->majorInfo,
                         pEntry->minorInfo,
                         pEntry->srcX,
                         pEntry->srcY,
                         pEntry->cache,
                         pEntry->cacheIndex));

            found             = TRUE;
            *pCache           = pEntry->cache;
            *pCacheIndex      = pEntry->cacheIndex;
            *pColorCacheIndex = pEntry->colorIndex;

            //
            // We order the used list in MRU order, so remove the entry
            // from its current position and add it at the head of the used
            // list.
            //
            COM_BasedListRemove(&pEntry->list);
            COM_BasedListInsertAfter(&m_sbcFastPath->usedList, &pEntry->list);

            //
            // Got a match, so we can break out of the while loop
            //
            break;
        }
        else if ((pEntry->majorInfo == majorInfo) &&
                 (pEntry->minorInfo != minorInfo))
        {
            //
            // We have been given a bitmap which we have seen before, but
            // the revision number has changed i.e.  the bitmap has been
            // updated (majorInfo identifies the bitmap, and minorInfo
            // identifies the revision number of that bitmap - it is
            // incremented every time the bitmap is changed).
            //
            // We have to remove all entries from the used list which
            // reference this bitmap.  We can start from the current
            // position since we know that we can't have an entry for this
            // bitmap earlier in the list, but we have to be careful to get
            // the next entry in the list before removing an entry.
            //
            TRACE_OUT(( "Bitmap %x updated - removing references",
                         pEntry->majorInfo));
            pNextEntry = pEntry;

            while (pNextEntry != NULL)
            {
                pEntry = pNextEntry;

                pNextEntry = (LPSBC_FASTPATH_ENTRY)COM_BasedListNext(&m_sbcFastPath->usedList,
                    pNextEntry, FIELD_OFFSET(SBC_FASTPATH_ENTRY, list));

                if (pEntry->majorInfo == majorInfo)
                {
                    COM_BasedListRemove(&pEntry->list);
                    COM_BasedListInsertAfter(&m_sbcFastPath->freeList,
                                        &pEntry->list);
                }
            }

            //
            // We know we wont find a match, so we can break out of the
            // while loop
            //
            break;
        }

        pEntry = (LPSBC_FASTPATH_ENTRY)COM_BasedListNext(&m_sbcFastPath->usedList, pEntry,
            FIELD_OFFSET(SBC_FASTPATH_ENTRY, list));
    }

    DebugExitBOOL(ASShare::SBCFindInFastPath, found);
    return(found);
}





//
// SBC_CacheEntryRemoved()
//
void  ASHost::SBC_CacheEntryRemoved
(
    UINT    cache,
    UINT    cacheIndex
)
{
    LPSBC_FASTPATH_ENTRY pEntry;
    LPSBC_FASTPATH_ENTRY pNextEntry;

    DebugEntry(ASHost::SBC_CacheEntryRemoved);

    ASSERT(m_sbcFastPath);

    //
    // An entry has been removed from the cache.  If we have this entry in
    // our fast path, we have to remove it.
    //
    // Just traverse the used list looking for an entry with matching cache
    // and cacheIndex.  Note that there may be more than one entry - if the
    // source bitmap has a repeating image, we will get a match on the bits
    // when we cache different areas of the bitmap.
    //
    pNextEntry = (LPSBC_FASTPATH_ENTRY)COM_BasedListFirst(&m_sbcFastPath->usedList,
        FIELD_OFFSET(SBC_FASTPATH_ENTRY, list));
    while (pNextEntry != NULL)
    {
        pEntry = pNextEntry;

        pNextEntry = (LPSBC_FASTPATH_ENTRY)COM_BasedListNext(&m_sbcFastPath->usedList,
            pNextEntry, FIELD_OFFSET(SBC_FASTPATH_ENTRY, list));

        if ((pEntry->cache == cache) && (pEntry->cacheIndex == cacheIndex))
        {
            //
            // Move the entry to the free list
            //
            TRACE_OUT(("Fast path entry %x %x (%d, %d) evicted from cache",
                     pEntry->majorInfo,
                     pEntry->minorInfo,
                     pEntry->srcX,
                     pEntry->srcY));
            COM_BasedListRemove(&pEntry->list);
            COM_BasedListInsertAfter(&m_sbcFastPath->freeList,
                                &pEntry->list);
        }
    }

    DebugExitVOID(ASHost::SBC_CacheEntryRemoved);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\sdp.cpp ===
#include "precomp.h"


//
// SDP.CPP
// Screen Data Player
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE



//
// SDP_ReceivedPacket()
//
void  ASShare::SDP_ReceivedPacket
(
    ASPerson *      pasPerson,
    PS20DATAPACKET  pPacket
)
{
    PSDPACKET       pBitmap;
    LPBYTE          pBits;
    RECT            rectRDB;
    HRGN            regionRDB = NULL;

    DebugEntry(ASShare::SDP_ReceivedPacket);

    ValidateView(pasPerson);

    ASSERT(m_usrPBitmapBuffer);

    pBitmap = (PSDPACKET)pPacket;

    //
    // At some point, we'd like to be able to pass an ARRAY of screen
    // data blocks, if they'd fit in a packet of size TSHR_MAX_SEND_PKT
    //
    ASSERT(pBitmap->header.padding == 0);

    //
    // Now try to decompress the packet.
    //
    if (pBitmap->compressed)
    {
        if (!BD_DecompressBitmap(&(pBitmap->data[0]), m_usrPBitmapBuffer,
                pBitmap->dataSize, pBitmap->realWidth, pBitmap->realHeight,
                pBitmap->format))
        {
            //
            // Could not decompress.
            //
            ERROR_OUT(( "Could not decompress"));
            DC_QUIT;
        }
        else
        {
            pBits = m_usrPBitmapBuffer;
        }
    }
    else
    {
        pBits = pBitmap->data;
    }

    //
    // The position (like all protocol coordinates) is specified in virtual
    // desktop coordinates. Convert it to RDB coordinates.
    //
    RECT_FROM_TSHR_RECT16(&rectRDB, pBitmap->position);
    OffsetRect(&rectRDB, -pasPerson->m_pView->m_dsScreenOrigin.x,
        -pasPerson->m_pView->m_dsScreenOrigin.y);

    TRACE_OUT(("Received screen data rect {%d, %d, %d, %d}",
                 rectRDB.left,
                 rectRDB.top,
                 rectRDB.right,
                 rectRDB.bottom ));

    //
    // We must ensure that data written to the ScreenBitmap is not clipped
    // (any orders processed earlier will have used clipping).
    //
    OD_ResetRectRegion(pasPerson);

    //
    // Play screen data into the remote desktop bitmap.
    //
    SDPPlayScreenDataToRDB(pasPerson, pBitmap, pBits, &rectRDB);

    //
    // Construct a region equivalent to the update rectangle in RDB coords.
    // INCLUSIVE COORDS
    //
    regionRDB = CreateRectRgn(rectRDB.left, rectRDB.top,
        rectRDB.right + 1, rectRDB.bottom + 1);
    if (regionRDB == NULL)
    {
        ERROR_OUT(( "Failed to create region"));
        DC_QUIT;
    }

    //
    // Hatch the bitmap data area, if enabled.
    //
    if (m_usrHatchScreenData)
    {
        SDPDrawHatchedRegion(pasPerson->m_pView->m_usrDC, regionRDB, USR_HATCH_COLOR_RED );
    }

    //
    // Now pass the region we have updated to the SWP. (We must convert it
    // back to VD coordinates before we pass it
    //
    OffsetRgn(regionRDB, pasPerson->m_pView->m_dsScreenOrigin.x,
        pasPerson->m_pView->m_dsScreenOrigin.y);

    VIEW_InvalidateRgn(pasPerson, regionRDB);

DC_EXIT_POINT:
    if (regionRDB != NULL)
    {
        //
        // Free the region.
        //
        DeleteRgn(regionRDB);
    }

    DebugExitVOID(ASShare::SDP_ReceivedPacket);
}


//
// FUNCTION: SDPDrawHatchedRegion(...)
//
// DESCRIPTION:
//
// Draws a hatched region on the specified surface in the given color.
//
// PARAMETERS:
//
// surface - the surface to draw on
//
// region - the region to hatch
//
// hatchColor - the color to hatch in
//
// RETURNS: Nothing.
//
//
void  ASShare::SDPDrawHatchedRegion
(
    HDC         hdc,
    HRGN        region,
    UINT        hatchColor
)
{
    HBRUSH      hbrHatch;
    UINT        brushStyle;
    UINT        oldBkMode;
    UINT        oldRop2;
    POINT       oldOrigin;
    COLORREF    hatchColorRef    = 0;

    DebugEntry(ASShare::SDPDrawHatchedRegion);

    //
    // Set the brush style to the appropriate value.
    //
    switch (hatchColor)
    {
        case USR_HATCH_COLOR_RED:
        {
            brushStyle = HS_BDIAGONAL;
        }
        break;

        case USR_HATCH_COLOR_BLUE:
        {
            brushStyle = HS_FDIAGONAL;
        }
        break;

        default:
        {
            brushStyle = HS_BDIAGONAL;
        }
        break;
    }

    //
    // Cycle the color to use.  Note that the hatchColor parameter is now
    // in fact just used to set the hatching direction.
    //
    m_usrHatchColor++;
    m_usrHatchColor %= 7;
    switch (m_usrHatchColor)
    {
        case 0: hatchColorRef = RGB(0xff,0x00,0x00); break;
        case 1: hatchColorRef = RGB(0x00,0xff,0x00); break;
        case 2: hatchColorRef = RGB(0xff,0xff,0x00); break;
        case 3: hatchColorRef = RGB(0x00,0x00,0xff); break;
        case 4: hatchColorRef = RGB(0xff,0x00,0xff); break;
        case 5: hatchColorRef = RGB(0x00,0xff,0xff); break;
        case 6: hatchColorRef = RGB(0xff,0xff,0xff); break;
    }

    //
    // Create the brush, set the background mode etc.
    //
    hbrHatch = CreateHatchBrush(brushStyle, hatchColorRef);
    oldBkMode = SetBkMode(hdc, TRANSPARENT);
    oldRop2 = SetROP2(hdc, R2_COPYPEN);
    SetBrushOrgEx(hdc, 0, 0, &oldOrigin);

    //
    // Fill the region.
    //
    FillRgn(hdc, region, hbrHatch);

    //
    // Reset everything.
    //
    SetBrushOrgEx(hdc, oldOrigin.x, oldOrigin.y, NULL);
    SetROP2(hdc, oldRop2);
    SetBkMode(hdc, oldBkMode);
    DeleteBrush(hbrHatch);

    DebugExitVOID(ASShare::SDPDrawHatchedRegion);
}


//
//
// SDPPlayScreenDataToRDB()
//
// DESCRIPTION:
//
// Play the contents of a screen data packet into the specified person ID's
// remote desktop bitmap.
//
// PARAMETERS:
//
//  personID - ID of person whose RDB is the target for the screen data
//  pBitmapUpdate - pointer to protocol update packet
//  pBits - pointer to uncompressed screen data
//  pPosition - returns updated rectangle in RDB coordinates
//
// RETURNS:
//
//  None
//
//
void  ASShare::SDPPlayScreenDataToRDB
(
    ASPerson *      pasPerson,
    PSDPACKET       pBitmap,
    LPBYTE          pBits,
    LPRECT          pRectRDB
)
{
    UINT            width;
    UINT            height;
    HPALETTE        hOldPalette;
    LPTSHR_UINT16   pIndexTable;
    UINT            cColors;
    UINT            i;
    BITMAPINFO_ours bitmapInfo;
    UINT            dibFormat;

    DebugEntry(ASShare::SDPPlayScreenDataToRDB);

    ValidateView(pasPerson);

    //
    // Calculate the extent of the actual area to be updated.  This is an
    // area less than or equal to the stock DIB allocated to contain it and
    // is defined in the position field of the bitmap packet.
    //
    width  = pRectRDB->right - pRectRDB->left + 1;
    height = pRectRDB->bottom - pRectRDB->top + 1;

    //
    // Put the DIB data into a Device Dependent bitmap.
    //
    USR_InitDIBitmapHeader((BITMAPINFOHEADER *)&bitmapInfo, pBitmap->format);

    bitmapInfo.bmiHeader.biWidth = pBitmap->realWidth;
    bitmapInfo.bmiHeader.biHeight = pBitmap->realHeight;

    //
    // Select and realize the current remote palette into the device
    // context.
    //
    hOldPalette = SelectPalette(pasPerson->m_pView->m_usrDC, pasPerson->pmPalette, FALSE);
    RealizePalette(pasPerson->m_pView->m_usrDC);

    //
    // The DIB_PAL_COLORS option requires a table of indexes into the
    // currently selected palette to follow the bmi header (in place of the
    // color table).
    //
    if (pBitmap->format <= 8)
    {
        pIndexTable = (LPTSHR_UINT16)&(bitmapInfo.bmiColors[0]);
        cColors = (1 << pBitmap->format);
        for (i = 0; i < cColors; i++)
        {
            *pIndexTable++ = (TSHR_UINT16)i;
        }

        dibFormat = DIB_PAL_COLORS;
    }
    else
    {
        dibFormat = DIB_RGB_COLORS;
    }

    //
    // We go from the bitmap to the screen bitmap in one go.
    //
    if (!StretchDIBits(pasPerson->m_pView->m_usrDC,
                       pRectRDB->left,
                       pRectRDB->top,
                       width,
                       height,
                       0,
                       0,
                       width,
                       height,
                       pBits,
                       (BITMAPINFO *)&bitmapInfo,
                       dibFormat,
                       SRCCOPY))
    {
        ERROR_OUT(( "StretchDIBits failed"));
    }

    //
    // Reinstate the old palette.
    //
    SelectPalette(pasPerson->m_pView->m_usrDC, hOldPalette, FALSE);

    DebugExitVOID(ASShare::SDPPlayScreenDataToRDB);
}



//
// SDP_DrawHatchedRect(...)
//
void  ASShare::SDP_DrawHatchedRect
(
    HDC     surface,
    int     x,
    int     y,
    int     width,
    int     height,
    UINT    color
)
{
    HRGN hrgn;

    DebugEntry(ASShare::SDP_DrawHatchedRect);

    //
    // Create the exclusive region.
    //
    hrgn = CreateRectRgn(x, y, x + width, y + height);
    if (hrgn)
    {
        //
        // Now draw the hatched region.
        //
        SDPDrawHatchedRegion(surface, hrgn, color);

        //
        // Finally delete the region.
        //
        DeleteRgn(hrgn);
    }

    DebugExitVOID(ASShare::SDP_DrawHatchedRect);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\sch.cpp ===
#include "precomp.h"


//
// SCH.CPP
// Scheduler
//
// Copyright(c) Microsoft Corporation 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE

//
//
// SCH_Init - see sch.h
//
//
BOOL  SCH_Init(void)
{
    BOOL    rc = FALSE;

    DebugEntry(SCH_Init);

    ASSERT(!g_schEvent);
    ASSERT(!g_schThreadID);
    ASSERT(!g_schMessageOutstanding);

    //
    // Create g_schEvent with:
    // - default security descriptor
    // - auto-reset (resets when a thread is unblocked)
    // - initially signalled
    //
    g_schEvent = CreateEvent( NULL, FALSE, TRUE, SCH_EVENT_NAME );
    if (g_schEvent == NULL)
    {
        ERROR_OUT(( "Failed to create g_schEvent"));
        DC_QUIT;
    }

    InitializeCriticalSection(&g_schCriticalSection);

    g_schCurrentMode = SCH_MODE_ASLEEP;

    // lonchanc: do not start the scheduler as default
    // SCHSetMode(SCH_MODE_NORMAL);
    if (!DCS_StartThread(SCH_PacingProcessor))
    {
        ERROR_OUT(( "Failed to create SCH_PacingProcessor thread"));
        DC_QUIT;
    }

    ASSERT(g_schThreadID);
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(SCH_Init, rc);
    return(rc);
}


//
//
// SCH_Term - see sch.h
//
//
void  SCH_Term(void)
{
    DebugEntry(SCH_Term);

    //
    // This code needs to work even if SCH_Init hasn't been called or
    // failed in the middle.
    //
    if (g_schEvent)
    {
        if (g_schThreadID)
        {
            //
            // The scheduler thread exits its main loop when it spots that
            // g_schTerminating is TRUE.  So all we have to do is ensure
            // that it runs its loop at least once more...  It will clear g_schTerm-
            // inated just before exiting.
            //
            g_schTerminating = TRUE;
            SCH_ContinueScheduling(SCH_MODE_NORMAL);
            while (g_schTerminating)
            {
                Sleep(0);
            }

            ASSERT(!g_schThreadID);
            TRACE_OUT(("sch thread terminated"));

            //
            // Make sure we clear the message outstanding variable when
            // our thread exits.
            //
            g_schMessageOutstanding = FALSE;
        }

        DeleteCriticalSection(&g_schCriticalSection);

        CloseHandle(g_schEvent);
        g_schEvent = NULL;
    }

    DebugExitVOID(SCH_Term);
}


//
//
// SCH_ContinueScheduling - see sch.h
//
//
void  SCH_ContinueScheduling(UINT schedulingMode)
{
    DebugEntry(SCH_ContinueScheduling);

    ASSERT( ((schedulingMode == SCH_MODE_NORMAL) ||
                 (schedulingMode == SCH_MODE_TURBO)));

    EnterCriticalSection(&g_schCriticalSection); // lonchanc: need crit sect protection

    if (g_schCurrentMode == SCH_MODE_TURBO)
    {
        if (schedulingMode == SCH_MODE_TURBO)
        {
            SCHSetMode(schedulingMode);
        }
        DC_QUIT;
    }

    if (schedulingMode != g_schCurrentMode)
    {
        SCHSetMode(schedulingMode);
    }

DC_EXIT_POINT:
    g_schStayAwake = TRUE;

    LeaveCriticalSection(&g_schCriticalSection); // lonchanc: need crit sect protection

    DebugExitVOID(SCH_ContinueScheduling);
}


//
//
// SCH_SchedulingMessageProcessed - see sch.h
//
//
void  SCH_SchedulingMessageProcessed()
{
    DebugEntry(SCH_SchedulingMessageProcessed);

    g_schMessageOutstanding = FALSE;

    DebugExitVOID(SCH_SchedulingMessageProcessed);
}


//
// Name:      SCH_PacingProcessor
//
// Purpose:   The main function executed by the scheduling thread.
//
// Returns:   Zero.
//
// Params:    syncObject - object to pass back to SetEvent
//
// Operation: The thread enters a main loop which continues while the
//            scheduler is initialized.
//
//            The thread sets its priority to TIME_CRITICAL in order
//            that it runs as soon as possible when ready.
//
//            The thread waits on an event (g_schEvent) with a timeout that
//            is set according to the current scheduler mode.
//
//            The thread runs due to either:
//              - the timeout expiring, which is the normal periodic
//                scheduler behavior, or
//              - g_schEvent being signalled, which is how the scheduler is
//                woken from ASLEEP mode.
//
//            The thread then posts a scheduler message the the Share Core
//            (if there is not one already outstanding) and loops back
//            to wait on g_schEvent.
//
//            Changes in the scheduler mode are caused by calls to
//            SCH_ContinueScheduling updating variables accessed in this
//            routine, or by calculations made within the main loop of
//            this routine (e.g. TURBO mode timeout).
//
//
DWORD WINAPI SCH_PacingProcessor(LPVOID hEventWait)
{
    UINT        rc = 0;
    DWORD       rcWait;
    UINT        timeoutPeriod;

    DebugEntry(SCH_PacingProcessor);

    //
    // Give ourselves the highest possible priority (within our process
    // priority class) to ensure that we run regularly to keep the
    // scheduling messages flowing.
    //
    if (!SetThreadPriority( GetCurrentThread(),
                            THREAD_PRIORITY_TIME_CRITICAL ))
    {
        WARNING_OUT(( "SetThreadPriority failed"));
    }

    timeoutPeriod = g_schTimeoutPeriod;

    g_schThreadID = GetCurrentThreadId();

    //
    // Let the caller continue
    //
    SetEvent((HANDLE)hEventWait);

    //
    // Keep looping until the scheduler terminates.
    //
    while (!g_schTerminating)
    {
        //
        // Wait on g_schEvent with a timeout value that is set according
        // to the current scheduling mode.
        //
        // When we are active (NORMAL/TURBO scheduling) the timeout
        // period is a fraction of a second, so the normal behavior is
        // for this call to timeout, rather than be signalled.
        //
        rcWait = WaitForSingleObject(g_schEvent, timeoutPeriod);

        EnterCriticalSection(&g_schCriticalSection);

        if (g_schMessageOutstanding)
        {
            //
            // We must ensure that we post at least one scheduling message
            // before we can attempt to sleep - so force schStayAwake to
            // TRUE to keep us awake until we do post another message.
            //
            TRACE_OUT(( "Don't post message - one outstanding"));
            g_schStayAwake = TRUE;
        }

        //
        // If g_schEvent was signalled, then enter NORMAL scheduling mode.
        //
        if (rcWait == WAIT_OBJECT_0)
        {
            SCHSetMode(SCH_MODE_NORMAL);
        }
        else if (!g_schStayAwake)
        {
            TRACE_OUT(( "Sleep!"));
            SCHSetMode(SCH_MODE_ASLEEP);
        }
        else if ( (g_schCurrentMode == SCH_MODE_TURBO) &&
                  ((GetTickCount() - g_schLastTurboModeSwitch) >
                                                   SCH_TURBO_MODE_DURATION) )
        {
            //
            // Switch from turbo state back to normal state.
            //
            SCHSetMode(SCH_MODE_NORMAL);
        }

        //
        // Post the scheduling message - but only if there is not one
        // already outstanding.
        //
        if (!g_schMessageOutstanding && !g_schTerminating)
        {
            SCHPostSchedulingMessage();
            g_schStayAwake = FALSE;
        }

        timeoutPeriod = g_schTimeoutPeriod;

        LeaveCriticalSection(&g_schCriticalSection);
    }

    g_schThreadID = 0;
    g_schTerminating = FALSE;

    DebugExitDWORD(SCH_PacingProcessor, rc);
    return(rc);
}



//
// Name:      SCHPostSchedulingMessage
//
// Purpose:   Posts the scheduling message to the main Share Core window.
//
// Returns:   Nothing.
//
// Params:    None.
//
//
void  SCHPostSchedulingMessage(void)
{
    DebugEntry(SCHPostSchedulingMessage);

    if (PostMessage( g_asMainWindow, DCS_PERIODIC_SCHEDULE_MSG, 0, 0 ))
    {
        g_schMessageOutstanding = TRUE;
    }

    DebugExitVOID(SCHPostSchedulingMessage);
}


//
// Name:      SCHSetMode
//
// Purpose:   Sets the current scheduler mode - and wakes the scheduler
//            thread if necessary.
//
// Returns:   Nothing.
//
// Params:    newMode
//
//
void  SCHSetMode(UINT newMode)
{
    DebugEntry(SCHSetMode);

    ASSERT( ((newMode == SCH_MODE_ASLEEP) ||
                 (newMode == SCH_MODE_NORMAL) ||
                 (newMode == SCH_MODE_TURBO) ));

    EnterCriticalSection(&g_schCriticalSection);

    TRACE_OUT(( "Switching from state %u -> %u", g_schCurrentMode, newMode));

    if (newMode == SCH_MODE_TURBO)
    {
        g_schLastTurboModeSwitch = GetTickCount();
    }

    if (g_schCurrentMode == SCH_MODE_ASLEEP)
    {
        //
        // Wake up the scheduler.
        //
        TRACE_OUT(( "Waking up scheduler - SetEvent"));
        if (!SetEvent(g_schEvent))
        {
            ERROR_OUT(( "Failed SetEvent(%#x)", g_schEvent));
        }
    }

    g_schCurrentMode = newMode;
    g_schTimeoutPeriod = (newMode == SCH_MODE_ASLEEP) ? INFINITE :
                       ((newMode == SCH_MODE_NORMAL) ? SCH_PERIOD_NORMAL :
                                                            SCH_PERIOD_TURBO);

    LeaveCriticalSection(&g_schCriticalSection);

    DebugExitVOID(SCHSetMode);
}



//
// DCS_StartThread(...)
//
// See ut.h
//
// DESCRIPTION:
// ============
// Start a new thread.
//
// PARAMETERS:
// ===========
// entryFunction   : A pointer to the thread entry point.
// timeout         : timeout in milliseconds
//
// RETURNS:
// ========
// Nothing.
//
//
BOOL DCS_StartThread
(
    LPTHREAD_START_ROUTINE entryFunction
)
{
    BOOL            rc = FALSE;
    HANDLE          hndArray[2];
    DWORD           tid;
    DWORD           dwrc;

    DebugEntry(DCS_StartThread);
	
	//
	// The event handle ( hndArray[0] ) is initialized in the call to CreateEvent,
	// but in the case where that fails, we would try to CloseHandle on 
	// a garbage hndArray[1]. So we have to initialize the ThreadHandle
	//
	hndArray[1] = 0;

    //
    // Create event - initially non-signalled; manual control.
    //
    hndArray[0] = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (hndArray[0] == 0)
    {
        ERROR_OUT(("Failed to create event: sys rc %lu", GetLastError()));
        DC_QUIT;
    }
    TRACE_OUT(("Event 0x%08x created - now create thread", hndArray[0]));


    //
    // Start a new thread to run the DC-Share core task.
    // Use C runtime (which calls CreateThread) to avoid memory leaks.
    //
    hndArray[1] = CreateThread(NULL, 0, entryFunction, (LPVOID)hndArray[0],
        0, &tid);
    if (hndArray[1] == 0)
    {
        //
        // Failed!
        //
        ERROR_OUT(("Failed to create thread: sys rc %lu", GetLastError()));
        DC_QUIT;
    }
    TRACE_OUT(("Thread 0x%08x created - now wait signal", hndArray[1]));

    //
    // Wait for thread exit or event to be set.
    //
    dwrc = WaitForMultipleObjects(2, hndArray, FALSE, INFINITE);
    switch (dwrc)
    {
        case WAIT_OBJECT_0:
            //
            // Event triggered - thread initialised OK.
            //
            TRACE_OUT(("event signalled"));
            rc = TRUE;
            break;

        case WAIT_OBJECT_0 + 1:
            ERROR_OUT(("Thread exited with rc"));
            break;

        case WAIT_TIMEOUT:
            TRACE_OUT(("Wait timeout"));
            break;

        default:
            TRACE_OUT(("Wait returned %d", dwrc));
            break;
    }

DC_EXIT_POINT:
    //
    // Destroy event object.
    //
    if (hndArray[0] != 0)
    {
        TRACE_OUT(("Destroy event object"));
        CloseHandle(hndArray[0]);
    }

    //
    // Destroy thread handle object.
    //
    if (hndArray[1] != 0)
    {
        TRACE_OUT(("Destroy thread handle object"));
        CloseHandle(hndArray[1]);
    }

    DebugExitBOOL(DCS_StartThread, rc);
    return(rc);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\sdg.cpp ===
#include "precomp.h"


//
// SDG.CPP
// Screen Data Grabber
// Sends OUTGOING screen data when hosting
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE

//
// SDG_SendScreenDataArea()
//
void  ASHost::SDG_SendScreenDataArea(LPBOOL pBackPressure, UINT * pcPackets)
{
    UINT     i;
    BOOL     fBltOK = TRUE;
    RECT     sdaRect[BA_NUM_RECTS];
    UINT     cRects;
    BOOL     backPressure = FALSE;
    BOOL     secondaryTransmit = FALSE;

    DebugEntry(ASHost::SDG_SendScreenDataArea);

    //
    // Get the bounds of the screen data area.  At entry this is always    
    // our primary transmission area.  Even if we had already flushed      
    // the primary region and were in the middle of the secondary region   
    // we will switch back to the primary region if any more SD            
    // accumulates.  In this way we keep our spoiling of the secondary     
    // screendata maximized.                                               
    //
    BA_CopyBounds(sdaRect, &cRects, TRUE);

    //
    // If there is a pending rectangle that was unable to be sent on a     
    // previous transmission then try to send it first.                    
    //                                                                     
    // Leave the lossy flag as it was at the last pass                     
    //
    if (m_sdgRectIsPending)
    {
        TRACE_OUT(( "Sending pending rectangle"));
        m_sdgRectIsPending = FALSE;

        //
        // Try to send the pending rectangle.  SDGSplitBlt...  will remove 
        // any portions of it that are sent successfully.  We will add all 
        // the rest of the SDA back to the bounds in the loop below        
        //
        if (!SDGSplitBltToNetwork(&m_sdgPendingRect, pcPackets))
        {
            fBltOK           = FALSE;
            m_sdgRectIsPending = TRUE;
        }
        else
        {
            //
            // The pending rectangle was successfully sent.                
            //
            TRACE_OUT(( "Sent pending rect"));
        }

    }

    //
    // We have copied the primary transmit region so now move the secondary
    // transmit bounds into the screendata bounds because when we send data
    // in the primary transmission we want to accumulate any rectangles    
    // that need subsequent retransmission.  The retransmit bounds are     
    // generally different from the original SD bounds because the         
    // compression function is permitted to override our lossy request for 
    // any portion of the data if it finds that the data is pretty         
    // compressible anyway.  In this way we end up with retransmission of  
    // embedded photos etc, but the toolbars/buttons are only sent once.   
    //                                                                     
    // For the non-lossy case the secondary bounds will always be null,    
    // so there is no point in special casing here.                        
    //
    if (fBltOK)
    {
        for (i = 0; i < m_sdgcLossy; i++)
        {
            TRACE_OUT(("Setting up pseudo-primary bounds {%d, %d, %d, %d}",
                m_asdgLossyRect[i].left, m_asdgLossyRect[i].top,
                m_asdgLossyRect[i].right, m_asdgLossyRect[i].bottom ));

            //
            // Add the rectangle into the bounds.                          
            //
            BA_AddRect(&m_asdgLossyRect[i]);
        }

        //
        // If there is no primary bitmap data to send then send the        
        // secondary data.  If none of that either then just exit          
        //
        if (cRects == 0)
        {

            BA_CopyBounds(sdaRect, &cRects, TRUE);
            if (cRects == 0)
            {
                DC_QUIT;
            }
            else
            {
                TRACE_OUT(("Starting secondary transmission now"));
                secondaryTransmit = TRUE;
            }
        }
    }

    //
    // Process each of the supplied rectangles in turn.                    
    //
    TRACE_OUT(( "%d SDA rectangles", cRects));

    for (i = 0; i < cRects; i++)
    {
        TRACE_OUT(("Rect %d: {%d, %d, %d, %d}", i,
            sdaRect[i].left, sdaRect[i].top, sdaRect[i].right, sdaRect[i].bottom ));

        //
        // Clip the rectangle to the physical screen and reject totally    
        // any rectangle that refers to data that has now been scrolled off
        // the physical screen as a result of a desktop scroll between the 
        // time the rectangle was accumulated and now.                     
        //
        if (sdaRect[i].left < 0)
        {
            if (sdaRect[i].right < 0)
            {
                //
                // This was scrolled off the physical screen by a desktop  
                // scroll.                                                 
                //
                continue;
            }

            //
            // Partially off screen - just clip the left edge.             
            //
            sdaRect[i].left = 0;
        }

        if (sdaRect[i].top < 0)
        {
            if (sdaRect[i].bottom < 0)
            {
                //
                // This was scrolled off the physical screen by a desktop  
                // scroll.                                                 
                //
                continue;
            }

            //
            // Partially off screen - just clip the top edge.              
            //
            sdaRect[i].top = 0;
        }

        if (sdaRect[i].right >= m_pShare->m_pasLocal->cpcCaps.screen.capsScreenWidth)
        {
            if (sdaRect[i].left >= m_pShare->m_pasLocal->cpcCaps.screen.capsScreenWidth)
            {
                //
                // This was scrolled off the physical screen by a desktop  
                // scroll.                                                 
                //
                continue;
            }

            //
            // Partially off screen - just clip the right edge.            
            //
            sdaRect[i].right = m_pShare->m_pasLocal->cpcCaps.screen.capsScreenWidth-1;
        }

        if (sdaRect[i].bottom >= m_pShare->m_pasLocal->cpcCaps.screen.capsScreenHeight)
        {
            if (sdaRect[i].top >= m_pShare->m_pasLocal->cpcCaps.screen.capsScreenHeight)
            {
                //
                // This was scrolled off the physical screen by a desktop  
                // scroll.                                                 
                //
                continue;
            }

            //
            // Partially off screen - just clip the bottom edge.           
            //
            sdaRect[i].bottom = m_pShare->m_pasLocal->cpcCaps.screen.capsScreenHeight-1;
        }


        //
        // If all of the previous rectangles have been successfully sent   
        // then try to send this rectangle.                                
        // If a previous rectangle failed to be sent then we don't bother  
        // trying to send the rest of the rectangles in the same batch -   
        // they are added back into the SDA so that they will be sent later.
        //
        if (fBltOK)
        {
            fBltOK = SDGSplitBltToNetwork(&(sdaRect[i]), pcPackets);

            //
            // On the first blit failure we must transfer the posible      
            // secondary transmit bounds over to the save area for next    
            // time because down below we are going to add back any unsent 
            // transmit rectangles to the primary SD area.                 
            //                                                             
            // Dont worry if this was a secondary transmit because these   
            // bounds will be zero and will be overwritten when we copy    
            // the current SDA region to the secondary area for our next   
            // pass                                                        
            //
            if (!fBltOK && !secondaryTransmit)
            {
                TRACE_OUT(("Send failed so getting new secondary bounds"));
                BA_CopyBounds(m_asdgLossyRect, &m_sdgcLossy, TRUE);
            }
        }

        if (!fBltOK)
        {
            //
            // The blt to network failed - probably because a network      
            // packet could not be allocated.                              
            // We add the rectangle back into the SDA so that we will try  
            // to retransmit the area later.                               
            //

            TRACE_OUT(("Blt failed - add back rect {%d, %d, %d, %d}",
                                                         sdaRect[i].left,
                                                         sdaRect[i].top,
                                                         sdaRect[i].right,
                                                         sdaRect[i].bottom ));

            //
            // Add the rectangle into the bounds.                          
            //
            BA_AddRect(&(sdaRect[i]));

            backPressure = TRUE;

        }
    }

    //
    // If all went fine and we were sending primary transmit data then we  
    // should just go back and send secondary data, using the bounds which 
    // are located in the SD area at the moment.  We can do this by copying
    // these secondary bounds to the save area, where they will be used at 
    // the next schedule pass.  It is a good idea to yield, because we may 
    // be about to accumulate some more primary data.                      
    //
    if (fBltOK || secondaryTransmit)
    {
        TRACE_OUT(("Done with the primary bounds so getting pseudo-primary to secondary"));
        BA_CopyBounds(m_asdgLossyRect, &m_sdgcLossy, TRUE);
    }

DC_EXIT_POINT:
    *pBackPressure = backPressure;
    DebugExitVOID(ASHost::SDG_SendScreenDataArea);
}




//
// SDGSplitBltToNetwork(..)                                                
//                                                                         
// Sends the specified rectangle over the network.                         
//                                                                         
// The Screen Data rects that we can send over the network are limited     
// to certain sizes (determined by the sizes of the Transfer Bitmaps).     
// If necessary, this function splits the rect into smaller sub-rectangles 
// for transmission.                                                       
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// pRect - pointer to the rectangle to send.                               
//                                                                         
// RETURNS:                                                                
//                                                                         
// TRUE - rectangle was successfully sent. Supplied rectangle is updated   
// to be NULL.                                                             
//                                                                         
// FALSE - rectangle was not completely sent. Supplied rectangle is        
// updated to contain the area that was NOT sent.                          
//                                                                         
//
BOOL  ASHost::SDGSplitBltToNetwork(LPRECT pRect, UINT * pcPackets)
{
    RECT   smallRect;
    UINT   maxHeight;
    BOOL   rc;

    DebugEntry(ASHost::SDGSplitBltToNetwork);

    //
    // Loop processing strips.                                             
    //
    while (pRect->top <= pRect->bottom)
    {
        smallRect = *pRect;

        //
        // Split the given rectangles into multiple smaller rects if       
        // necessary.  If it is wider than our 256 byte work bitmap then   
        // switch to the mega 1024 byte one first.                         
        //

        // Note that the calculations don't work for VGA...
        maxHeight = max(8, m_usrSendingBPP);

        if ((smallRect.right-smallRect.left+1) > MEGA_X_SIZE)
        {
            maxHeight = MaxBitmapHeight(MEGA_WIDE_X_SIZE, maxHeight);
        }
        else
        {
            maxHeight = MaxBitmapHeight(MEGA_X_SIZE, maxHeight);
        }

        if ((unsigned)(smallRect.bottom - smallRect.top + 1) > maxHeight)
        {
            //
            // Split the rectangle to bring the height within the correct  
            // range.                                                      
            //
            TRACE_OUT(( "Split Y size(%d) by maxHeight(%d)",
                                         smallRect.bottom - smallRect.top,
                                         maxHeight));
            smallRect.bottom = smallRect.top + maxHeight - 1;
        }


        while ((pRect->right - smallRect.left + 1) > 0)
        {
            if (!SDGSmallBltToNetwork(&smallRect))
            {
                TRACE_OUT(( "Small blt failed"));
                rc = FALSE;
                DC_QUIT;
            }
            else
            {
                ++(*pcPackets);
            }
        }

        //
        // Move to the next strip.                                         
        //
        pRect->top = smallRect.bottom+1;

    }

    rc = TRUE;

DC_EXIT_POINT:
    if (!rc)
    {
        //
        // A small blt failed.  If we return FALSE then the supplied       
        // rectangle will be added back into the SDA bounds so that it will
        // be retransmitted later.                                         
        //                                                                 
        // However, we want to avoid the situation where we have sent the  
        // top left-hand corner of a rectangle and then add the remainder  
        // back into the SDA bounds, because this could cause the original 
        // bounding rectangle to be regenerated (because the bounds are    
        // stored in a fixed number of rectangles).                        
        //                                                                 
        // Therefore if we are not on the last strip of the rectangle then 
        // we keep the current strip as a "pending" rectangle.  The        
        // supplied rectangle is adjusted to remove the whole of this      
        // strip.  Next time this function is called the pending rectangle 
        // will be sent before anything else.                              
        //                                                                 
        // If we are on the last strip (which will be the normal case -    
        // there will usually only be one strip) then we update the        
        // supplied rectangle to be the area that has not been sent and    
        // return FALSE to indicate that it must be added back into the    
        // SDA.                                                            
        //
        if (m_sdgRectIsPending)
        {
            ERROR_OUT(( "Unexpected small blt failure with pending rect"));
        }
        else
        {
            if (smallRect.bottom == pRect->bottom)
            {
                //
                // This is the last strip.  Adjust the supplied rect to    
                // contain the area that has not been sent.                
                //
                pRect->top = smallRect.top;
                pRect->left = smallRect.left;
            }
            else
            {
                //
                // This is not the last strip Copy the remainder of the    
                // current strip into the pending rect.                    
                //
                smallRect.right = pRect->right;
                m_sdgPendingRect = smallRect;
                m_sdgRectIsPending = TRUE;

                //
                // Adjust the supplied rectangle to contain the remaining  
                // area that we have not sent and is not covered by the    
                // pending rect.                                           
                //
                pRect->top = smallRect.bottom+1;
            }
        }
    }

    DebugExitBOOL(ASHost::SDGSplitBltToNetwork, rc);
    return(rc);
}


//
// FUNCTION: SDGSmallBltToNetwork                                          
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Sends the screen data within the specified rectangle across the network.
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// pRect - pointer to the rectangle (in screen coords) to send as Screen   
// Data.                                                                   
//                                                                         
// RETURNS:                                                                
//                                                                         
// TRUE - screen data successfully sent                                    
//                                                                         
// FALSE - screen data could not be sent.  Caller should retry later.      
//                                                                         
//

//
// BOGUS BUGBUG LAURABU!
// This function affects the results on the screen!  If drawing happens
// between the time we realize the palette then unrealize it, it will look
// messed up.  You can easily see this in Visio 4.5 when it is in the 
// foreground (in the background, NM controls the colors so no effect).
//
BOOL  ASHost::SDGSmallBltToNetwork(LPRECT pRect)
{
    BOOL            fLossy = FALSE;
    HDC             hdcDesktop;
    HBITMAP         hBitmap = NULL;
    HBITMAP         hOldBitmap = NULL;
    UINT            width;
    UINT            height;
    UINT            fixedWidth;
    PSDPACKET       pSDPacket = NULL;
    BITMAPINFO_ours bitmapInfo;
    UINT            sizeBitmapPkt;
    UINT            sizeBitmap;
    HPALETTE        hpalOldDIB = NULL;
    HPALETTE        hpalOldDesktop = NULL;
    HPALETTE        hpalLocal;
    BOOL            fPacketSent = FALSE;
    RECT            smallRect;
    int             useWidth;
#ifdef _DEBUG
    UINT            sentSize;
#endif // _DEBUG

    DebugEntry(ASHost::SDGSmallBltToNetwork);

    hdcDesktop = GetDC(NULL);
    if (!hdcDesktop)
    {
        DC_QUIT;
    }
    width = pRect->right - pRect->left + 1;
    height = pRect->bottom - pRect->top + 1;

    //
    // Determine the width of the work buffer and the width that we        
    // will be sending this time                                           
    //
    fixedWidth = ((width + 15) / 16) * 16;
    useWidth = width;
    if (fixedWidth > MAX_X_SIZE)
    {
        if (fixedWidth > MEGA_X_SIZE)
        {
            fixedWidth = MEGA_WIDE_X_SIZE;
            if (width > MEGA_WIDE_X_SIZE)
            {
                useWidth = fixedWidth;
            }
        }
        else
        {
            fixedWidth = MEGA_X_SIZE;
            if (width > MEGA_X_SIZE)
            {
                useWidth = fixedWidth;
            }
        }
    }

    switch (fixedWidth)
    {
        case 16:
            hBitmap = m_pShare->m_usrBmp16;
            break;

        case 32:
            hBitmap = m_pShare->m_usrBmp32;
            break;

        case 48:
            hBitmap = m_pShare->m_usrBmp48;
            break;

        case 64:
            hBitmap = m_pShare->m_usrBmp64;
            break;

        case 80:
            hBitmap = m_pShare->m_usrBmp80;
            break;

        case 96:
            hBitmap = m_pShare->m_usrBmp96;
            break;

        case 112:
            hBitmap = m_pShare->m_usrBmp112;
            break;

        case 128:
            hBitmap = m_pShare->m_usrBmp128;
            break;

        case 256:
            hBitmap = m_pShare->m_usrBmp256;
            break;

        case 1024:
            hBitmap = m_pShare->m_usrBmp1024;
            break;

        default:
            ERROR_OUT(( "Invalid bitmap size(%d)", fixedWidth));
            break;
    }

    //
    // Initialise the BITMAPINFO_ours local structure header contents.     
    // This structure will be used in the GetDIBits calls but only the     
    // header part of the structure will be sent across the network, the   
    // color table is sent via the Palette Manager.                        
    //
    m_pShare->USR_InitDIBitmapHeader((BITMAPINFOHEADER *)&bitmapInfo, m_usrSendingBPP);

    bitmapInfo.bmiHeader.biWidth   = fixedWidth;
    bitmapInfo.bmiHeader.biHeight  = height;

    //
    // Calculate the size of the bitmap packet in BYTES.                   
    //
    sizeBitmap = BYTES_IN_BITMAP(fixedWidth, height, bitmapInfo.bmiHeader.biBitCount);

    sizeBitmapPkt = sizeof(SDPACKET) + sizeBitmap - 1;
    ASSERT(sizeBitmapPkt <= TSHR_MAX_SEND_PKT);

    //
    // Allocate a packet for the bitmap data.                              
    //                                                                     
    // *** NB. This assumes that this code is called ONLY when there   *** 
    // *** no unacknowledged bitmaps packets floating around the       *** 
    // *** network layer. This means, at the moment, if this code is   *** 
    // *** called due to anything other than a WM_TIMER                *** 
    // *** message we're in trouble.                                   *** 
    //                                                                     
    //
    pSDPacket = (PSDPACKET)m_pShare->SC_AllocPkt(PROT_STR_UPDATES, g_s20BroadcastID,
        sizeBitmapPkt);
    if (!pSDPacket)
    {
        //
        // Failed to allocate the bitmap packet - clear up and exit adding 
        // the rectangle back into the bounds.                             
        //
        TRACE_OUT(("Failed to alloc SDG packet, size %u", sizeBitmapPkt));
        DC_QUIT;
    }

    //
    // Since we are bltting off the screen, which by definition is using   
    // the system palette, we place the system palette in both DC's (so    
    // that the bitblt we are about to do will not do any color            
    // conversion).                                                        
    //

    //
    // This will determine if the palette changed since the last time we
    // sent one to the remote.
    //
    if (m_usrSendingBPP <= 8)
    {
        hpalLocal = PM_GetLocalPalette();
    }

    hOldBitmap = SelectBitmap(m_usrWorkDC, hBitmap);

    if (m_usrSendingBPP <= 8)
    {
        hpalOldDIB = SelectPalette(m_usrWorkDC, hpalLocal, FALSE);
        RealizePalette(m_usrWorkDC);
    }

    //
    // We can now do a bitblt from the screen (hpDesktop) to memory and the
    // bits are untranslated.                                              
    //                                                                     
    // We then do a GetDIBits using the local palette which returns us the 
    // bits at the correct bits per pel, (and with properly translated     
    // colors) in order to transmit the data.                              
    //
    BitBlt(m_usrWorkDC, 0, 0, useWidth, height, hdcDesktop,
        pRect->left, pRect->top, SRCCOPY);

    //
    // Zero any unused space on the right side to aid compression.
    //
    if (width < fixedWidth)
    {
        PatBlt(m_usrWorkDC, width, 0, fixedWidth - width, height, BLACKNESS);
    }

    //
    // Do a GetDIBits into our global stash of memory for now.  We will try
    // and compress this data into our packet after.                       
    //
    GetDIBits(m_usrWorkDC, hBitmap, 0, height, m_pShare->m_usrPBitmapBuffer,
        (PBITMAPINFO)&bitmapInfo, DIB_RGB_COLORS);

    //
    // Deselect the bitmap                                                 
    //
    SelectBitmap(m_usrWorkDC, hOldBitmap);

    //
    // Get the color table directly from the system since we can't trust
    // any palette realization color stuff via the messages at this stage.
    // We only need to do this on an 8bpp host sending 8bpp data.
    //
    if ((g_usrScreenBPP == 8) && (m_usrSendingBPP == 8))
    {
        PM_GetSystemPaletteEntries(bitmapInfo.bmiColors);
    }

    if (m_usrSendingBPP <= 8)
    {
        //
        // Whack old palettes back.
        //
        SelectPalette(m_usrWorkDC, hpalOldDIB, FALSE);
    }

    //
    // Fill in packet contents and send it.                                
    //
    pSDPacket->header.header.data.dataType   = DT_UP;
    pSDPacket->header.updateType        = UPD_SCREEN_DATA;

    //
    // Send Virtual desktop coordinates.                                   
    //
    pSDPacket->position.left    = (TSHR_INT16)(pRect->left);
    pSDPacket->position.right   = (TSHR_INT16)(pRect->left + useWidth - 1);

    pSDPacket->position.top     = (TSHR_INT16)(pRect->top);
    pSDPacket->position.bottom  = (TSHR_INT16)(pRect->bottom);

    pSDPacket->realWidth        = (TSHR_UINT16)fixedWidth;
    pSDPacket->realHeight       = (TSHR_UINT16)height;

    pSDPacket->format           = (TSHR_UINT16)m_usrSendingBPP;
    pSDPacket->compressed       = FALSE;

    //
    // Compress the bitmap data                                            
    //
    if (m_pShare->BC_CompressBitmap(m_pShare->m_usrPBitmapBuffer,
                           pSDPacket->data,
                           &sizeBitmap,
                           fixedWidth,
                           height,
                           bitmapInfo.bmiHeader.biBitCount,
                           &fLossy) )
    {
        //
        // We have successfully compressed the bitmap data into our packet 
        // data buffer.                                                    
        //
        pSDPacket->compressed = TRUE;

        //
        // Write the updated size of the data into the header.             
        //
        pSDPacket->dataSize = (TSHR_UINT16)sizeBitmap;

        //
        // Now update the size of the total data (including header)
        //
        sizeBitmapPkt = sizeof(SDPACKET) + sizeBitmap - 1;
        pSDPacket->header.header.dataLength = sizeBitmapPkt - sizeof(S20DATAPACKET)
            + sizeof(DATAPACKETHEADER);
    }
    else
    {
        //
        // The compression failed so just copy the uncompressed data from  
        // the global buffer to the packet and send it uncompressed.       
        //
        TRACE_OUT(("Failed to compress bitmap of size %d cx(%d) cy(%d) bpp(%d)",
            sizeBitmap, fixedWidth, height, bitmapInfo.bmiHeader.biBitCount));

        memcpy(pSDPacket->data,
                  m_pShare->m_usrPBitmapBuffer,
                  sizeBitmap );

        //
        // Write the size of the data into the header.                     
        //
        pSDPacket->dataSize = (TSHR_UINT16)sizeBitmap;
    }

    TRACE_OUT(("Sending %d bytes of screen data", sizeBitmap));

    if (m_pShare->m_scfViewSelf)
        m_pShare->UP_ReceivedPacket(m_pShare->m_pasLocal, &(pSDPacket->header.header));

#ifdef _DEBUG
    sentSize =
#endif // _DEBUG
    m_pShare->DCS_CompressAndSendPacket(PROT_STR_UPDATES, g_s20BroadcastID,
        &(pSDPacket->header.header), sizeBitmapPkt);

    TRACE_OUT(("SDG packet size: %08d, sent: %08d", sizeBitmapPkt, sentSize));

    //
    // We have sent the packet.                                            
    //
    fPacketSent = TRUE;

    //
    // If it was lossy then we must accumulate the area for resend.  We    
    // accumulate it into the current SDA because we know this was cleared 
    // before the transmission started.  We will then move the accumulated 
    // non-lossy rectangles to a save area before we return.               
    //
    if (fLossy)
    {
        //
        // Convert the rect back into Virtual Desktop coords.              
        //
        smallRect = *pRect;
        smallRect.right = smallRect.left + useWidth - 1;
        WARNING_OUT(( "Lossy send so add non-lossy area (%d,%d)(%d,%d)",
                                              smallRect.left,
                                              smallRect.top,
                                              smallRect.right,
                                              smallRect.bottom ));

        //
        // Add the rectangle into the bounds.                              
        //
        BA_AddRect(&(smallRect));
    }

    //
    // Now we modify the supplied rectangle to exclude the area just sent  
    //
    pRect->left = pRect->left + useWidth;
    TRACE_OUT(("Rect now {%d, %d, %d, %d}", pRect->left, pRect->top,
                                            pRect->right,
                                            pRect->bottom ));

DC_EXIT_POINT:
    if (hdcDesktop != NULL)
    {
        ReleaseDC(NULL, hdcDesktop);
    }

    DebugExitBOOL(ASHost::SDGSmallBltToNetwork, fPacketSent);
    return(fPacketSent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\sc.cpp ===
#include "precomp.h"


//
// SC.CPP
// Share Controller
//
// NOTE:
// We must take the UTLOCK_AS every time we
//      * create/destroy the share object
//      * add/remove a person from the share
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE

//
// SC_Init()
// Initializes the share controller
//
BOOL  SC_Init(void)
{
    BOOL            rc = FALSE;

    DebugEntry(SC_Init);

    ASSERT(!g_asSession.callID);
    ASSERT(!g_asSession.gccID);
    ASSERT(g_asSession.scState == SCS_TERM);

    //
    // Register as a Call Manager Secondary task
    //
    if (!CMS_Register(g_putAS, CMTASK_DCS, &g_pcmClientSc))
    {
        ERROR_OUT(( "Failed to register with CMS"));
        DC_QUIT;
    }

    g_asSession.scState = SCS_INIT;
    TRACE_OUT(("g_asSession.scState is SCS_INIT"));

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(SC_Init, rc);
    return(rc);
}


//
// SC_Term()
//
// See sc.h for description.
//
//
void  SC_Term(void)
{
    DebugEntry(SC_Term);

    //
    // Clear up the core's state by generating appropriate PARTY_DELETED and
    // SHARE_ENDED events.
    //
    switch (g_asSession.scState)
    {
        case SCS_SHARING:
        case SCS_SHAREENDING:
        case SCS_SHAREPENDING:
            SC_End();
            break;
    }

    //
    // Deregister from the Call Manager
    //
    if (g_pcmClientSc)
    {
        CMS_Deregister(&g_pcmClientSc);
    }

    g_asSession.gccID = 0;
    g_asSession.callID = 0;
    g_asSession.attendeePermissions = NM_PERMIT_ALL;

    g_asSession.scState = SCS_TERM;
    TRACE_OUT(("g_asSession.scState is SCS_TERM"));

    DebugExitVOID(SC_Term);
}





//
// SC_CreateShare()
// Creates a new share or joins an existing one
//
BOOL SC_CreateShare(UINT s20CreateOrJoin)
{
    BOOL    rc = FALSE;

    DebugEntry(SC_CreateShare);

    //
    // If we are initialised but there is no Call Manager call, return the
    // race condition.
    //
    if ((g_asSession.scState != SCS_INIT) && (g_asSession.scState != SCS_SHAREPENDING))
    {
        TRACE_OUT(("Ignoring SC_CreateShare() request; in bad state %d",
            g_asSession.scState));
        DC_QUIT;
    }

    if (!g_asSession.callID)
    {
        WARNING_OUT(("Ignoring SC_CreateShare() request; not in T120 call"));
        DC_QUIT;
    }

    //
    // Remember that we created this share.
    //
    g_asSession.fShareCreator = (s20CreateOrJoin == S20_CREATE);
    TRACE_OUT(("CreatedShare is %s", (s20CreateOrJoin == S20_CREATE) ?
        "TRUE" : "FALSE"));

    g_asSession.scState               = SCS_SHAREPENDING;
    TRACE_OUT(("g_asSession.scState is SCS_SHAREPENDING"));

    rc = S20CreateOrJoinShare(s20CreateOrJoin, g_asSession.callID);
    if (!rc)
    {
        WARNING_OUT(("%s failed", (s20CreateOrJoin == S20_CREATE ? "S20_CREATE" : "S20_JOIN")));
    }

DC_EXIT_POINT:
    DebugExitBOOL(SC_CreateShare, rc);
    return(rc);
}


//
// SC_EndShare()
// This will end a share if we are in one or in the middle of establishing
// one, and clean up afterwards.
//
void  SC_EndShare(void)
{
    DebugEntry(SC_EndShare);

    if (g_asSession.scState <= SCS_SHAREENDING)
    {
        TRACE_OUT(("Ignoring SC_EndShare(); nothing to do in state %d", g_asSession.scState));
    }
    else
    {
        //
        // If we are in a share or in the middle of creating/joining one, stop
        // the process.
        //

        //
        // Kill the share
        // NOTE that this will call SC_End(), when we come back
        // from this function our g_asSession.scState() should be SCS_INIT.
        //
        g_asSession.scState = SCS_SHAREENDING;
        TRACE_OUT(("g_asSession.scState is SCS_SHAREENDING"));

        S20LeaveOrEndShare();

        g_asSession.scState = SCS_INIT;
    }

    DebugExitVOID(SC_EndShare);
}






//
// SC_PersonFromNetID()
//
ASPerson *  ASShare::SC_PersonFromNetID(UINT_PTR mcsID)
{
    ASPerson * pasPerson;

    DebugEntry(SC_PersonFromNetID);

    ASSERT(mcsID != MCSID_NULL);

    //
    // Search for the mcsID.
    //
    if (!SC_ValidateNetID(mcsID, &pasPerson))
    {
        ERROR_OUT(("Invalid [%u]", mcsID));
    }

    DebugExitPVOID(ASShare::SC_PersonFromNetID, pasPerson);
    return(pasPerson);
}



//
// SC_ValidateNetID()
//
BOOL  ASShare::SC_ValidateNetID
(
    UINT_PTR           mcsID,
    ASPerson * *    ppasPerson
)
{
    BOOL            rc = FALSE;
    ASPerson *      pasPerson;

    DebugEntry(ASShare::SC_ValidateNetID);


    // Init to empty
    pasPerson = NULL;

    //
    // MCSID_NULL matches no one.
    //
    if (mcsID == MCSID_NULL)
    {
        WARNING_OUT(("SC_ValidateNetID called with MCSID_NULL"));
        DC_QUIT;
    }

    //
    // Search for the mcsID.
    //
    for (pasPerson = m_pasLocal; pasPerson != NULL; pasPerson = pasPerson->pasNext)
    {
        ValidatePerson(pasPerson);

        if (pasPerson->mcsID == mcsID)
        {
            //
            // Found required person, set return values and quit
            //
            rc = TRUE;
            break;
        }
    }

DC_EXIT_POINT:
    if (ppasPerson)
    {
        *ppasPerson = pasPerson;
    }

    DebugExitBOOL(ASShare::SC_ValidateNetID, rc);
    return(rc);
}



//
// SC_PersonFromGccID()
//
ASPerson * ASShare::SC_PersonFromGccID(UINT gccID)
{
    ASPerson * pasPerson;

//    DebugEntry(ASShare::SC_PersonFromGccID);

    for (pasPerson = m_pasLocal; pasPerson != NULL; pasPerson = pasPerson->pasNext)
    {
        ValidatePerson(pasPerson);

        if (pasPerson->cpcCaps.share.gccID == gccID)
        {
            // Found it
            break;
        }
    }

//    DebugExitPVOID(ASShare::SC_PersonFromGccID, pasPerson);
    return(pasPerson);
}


//
// SC_Start()
// Inits the share (if all is OK), and adds local person to it.
//
BOOL SC_Start(UINT mcsID)
{
    BOOL        rc = FALSE;
    ASShare *   pShare;
    ASPerson *  pasPerson;

    DebugEntry(SC_Start);

    ASSERT(g_asSession.callID);
    ASSERT(g_asSession.gccID);

    if ((g_asSession.scState != SCS_INIT) && (g_asSession.scState != SCS_SHAREPENDING))
    {
        WARNING_OUT(("Ignoring SC_Start(); in bad state"));
        DC_QUIT;
    }
    if (g_asSession.pShare)
    {
        WARNING_OUT(("Ignoring SC_Start(); have ASShare object already"));
        DC_QUIT;
    }

    g_asSession.scState = SCS_SHARING;
    TRACE_OUT(("g_asSession.scState is SCS_SHARING"));

#ifdef _DEBUG
    //
    // Use this to calculate time between joining share and getting
    // first view
    //
    g_asSession.scShareTime = ::GetTickCount();
#endif // _DEBUG

    //
    // Allocate the share object and add the local dude to the share.
    //

    pShare = new ASShare;
    if (pShare)
    {
        ZeroMemory(pShare, sizeof(*(pShare)));
        SET_STAMP(pShare, SHARE);

        rc = pShare->SC_ShareStarting();
    }

    UT_Lock(UTLOCK_AS);
    g_asSession.pShare = pShare;
    UT_Unlock(UTLOCK_AS);

    if (!rc)
    {
        ERROR_OUT(("Can't create/init ASShare"));
        DC_QUIT;
    }

    DCS_NotifyUI(SH_EVT_SHARE_STARTED, 0, 0);


    //
    // Join local dude into share. If that fails, also bail out.
    //
    pasPerson = g_asSession.pShare->SC_PartyJoiningShare(mcsID, g_asSession.achLocalName, sizeof(g_cpcLocalCaps), &g_cpcLocalCaps);
    if (!pasPerson)
    {
        ERROR_OUT(("Local person not joined into share successfully"));
        DC_QUIT;
    }

    //
    // Okay!  We have a share, and it's set up.
    //

    //
    // Tell the UI that we're in the share.
    //
    DCS_NotifyUI(SH_EVT_PERSON_JOINED, pasPerson->cpcCaps.share.gccID, 0);


    //
    // Start periodic processing if ViewSelf or record/playback is on.
    //
    if (g_asSession.pShare->m_scfViewSelf)
    {
        SCH_ContinueScheduling(SCH_MODE_NORMAL);
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(SC_Start, rc);
    return(rc);
}



//
// SC_End()
// Removes any remotes from the share, removes the local person, and
// cleans up after the fact.
//
void SC_End(void)
{
    DebugEntry(SC_End);

    if (g_asSession.scState < SCS_SHAREENDING)
    {
        TRACE_OUT(("Ignoring SC_EVENT_SHAREENDED"));
    }
    else
    {
        if (g_asSession.pShare)
        {
            g_asSession.pShare->SC_ShareEnded();

            UT_Lock(UTLOCK_AS);

            delete g_asSession.pShare;
            g_asSession.pShare = NULL;

            UT_Unlock(UTLOCK_AS);

            DCS_NotifyUI(SH_EVT_SHARE_ENDED, 0, 0);
        }

        //
        // If the previous state was SCS_SHARE_PENDING then we
        // may have ended up here as the result of a 'back off' after
        // trying to create two shares.  Let's try to join again...
        //
        if (g_asSession.fShareCreator)
        {
            g_asSession.fShareCreator = FALSE;
            TRACE_OUT(("CreatedShare is FALSE"));

            if (g_asSession.scState == SCS_SHAREPENDING)
            {
                WARNING_OUT(("Got share end while share pending - retry join"));
                UT_PostEvent(g_putAS, g_putAS, 0, CMS_NEW_CALL, 0, 0);
            }
        }

        g_asSession.scState = SCS_INIT;
        TRACE_OUT(("g_asSession.scState is SCS_INIT"));
    }

    g_s20ShareCorrelator = 0;

    //
    // Reset the queued control packets.
    //
    g_s20ControlPacketQHead = 0;
    g_s20ControlPacketQTail = 0;

    g_s20State = S20_NO_SHARE;
    TRACE_OUT(("g_s20State is S20_NO_SHARE"));

    DebugExitVOID(SC_End);
}


//
// SC_PartyAdded()
//
BOOL ASShare::SC_PartyAdded
(
    UINT    mcsID,
    LPSTR   szName,
    UINT    cbCaps,
    LPVOID  pCaps
)
{
    BOOL        rc = FALSE;
    ASPerson *  pasPerson;

    if (g_asSession.scState != SCS_SHARING)
    {
        WARNING_OUT(("Ignoring SC_EVENT_PARTYADDED; not in share"));
        DC_QUIT;
    }

    ASSERT(g_asSession.callID);
    ASSERT(g_asSession.gccID);

    //
    // A remote party is joining the share
    //

    //
    // Notify everybody
    //
    pasPerson = SC_PartyJoiningShare(mcsID, szName, cbCaps, pCaps);
    if (!pasPerson)
    {
        WARNING_OUT(("SC_PartyJoiningShare failed for remote [%d]", mcsID));
        DC_QUIT;
    }

    //
    // SYNC now
    // We should NEVER SEND ANY PACKETS when syncing.  We aren't ready
    // because we haven't joined the person into the share. yet.
    // So we simply set variables for us to send data off the next
    // periodic schedule.
    //
#ifdef _DEBUG
    m_scfInSync = TRUE;
#endif // _DEBUG

    //
    // Stuff needed for being in the share, hosting or not
    //
    DCS_SyncOutgoing();
    OE_SyncOutgoing();

    if (m_pHost != NULL)
    {
        //
        // Common to both starting sharing and retransmitting sharing info
        //
        m_pHost->HET_SyncCommon();
        m_pHost->HET_SyncAlreadyHosting();
        m_pHost->CA_SyncAlreadyHosting();
    }

#ifdef _DEBUG
    m_scfInSync = FALSE;
#endif // _DEBUG


    //
    // DO THIS LAST -- tell the UI this person is in the share.
    //
    DCS_NotifyUI(SH_EVT_PERSON_JOINED, pasPerson->cpcCaps.share.gccID, 0);

    //
    // Start periodic processing
    //
    SCH_ContinueScheduling(SCH_MODE_NORMAL);

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::SC_PartyAdded, rc);
    return(rc);
}



//
// SC_PartyDeleted()
//
void ASShare::SC_PartyDeleted(UINT_PTR mcsID)
{
    if ((g_asSession.scState != SCS_SHARING) && (g_asSession.scState != SCS_SHAREENDING))
    {
        WARNING_OUT(("Ignoring SC_EVENT_PARTYDELETED; wrong state"));
        DC_QUIT;
    }

    SC_PartyLeftShare(mcsID);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::SC_PartyDeleted);
}


//
// SC_ReceivedPacket()
//
void ASShare::SC_ReceivedPacket(PS20DATAPACKET pPacket)
{
    ASPerson *      pasPerson;
    PSNIPACKET      pSNIPacket;

    DebugEntry(ASShare::SC_ReceivedPacket);

    if (g_asSession.scState != SCS_SHARING)
    {
        WARNING_OUT(("Ignoring received data because we're not in right state"));
        DC_QUIT;
    }

    //
    // Ignore packets on streams we don't know about.
    //
    if ((pPacket->stream < SC_STREAM_LOW) ||
        (pPacket->stream > SC_STREAM_HIGH))
    {
        TRACE_OUT(("Ignoring received data on unrecognized stream %d",
            pPacket->stream));
        DC_QUIT;
    }

    //
    // It is possible to get a packet from a person we do not know
    // about.
    //
    // This can happen if we join a conference that has an existing
    // share session.  All existing parties will be sending data on
    // the channels we have joined but we will not yet have
    // received the events to add them to our share session.
    //
    // Data packets from unknown people are ignored (ignoring this
    // data is OK as we will resync with them when they are added
    // to our share session)
    //
    if (!SC_ValidateNetID(pPacket->header.user, &pasPerson))
    {
        WARNING_OUT(("Ignoring data packet from unknown person [%d]",
            pPacket->header.user));
        DC_QUIT;
    }

    if (pPacket->data.dataType == DT_SNI)
    {
        //
        // This is an SNI packet - handle it here.
        //
        pSNIPacket = (PSNIPACKET)pPacket;

        switch(pSNIPacket->message)
        {
            case SNI_MSG_SYNC:
                //
                // This is a sync message.
                //
                if (pSNIPacket->destination == m_pasLocal->mcsID)
                {
                    //
                    // This sync message is for us.
                    //
                    pasPerson->scSyncRecStatus[pPacket->stream-1] = SC_SYNCED;
                }
                else
                {
                    TRACE_OUT(("Ignoring SYNC on stream %d for [%d] from [%d]",
                            pPacket->stream, pSNIPacket->destination,
                            pPacket->header.user));
                }
                break;

            default:
                ERROR_OUT(("Unknown SNI message %u", pSNIPacket->message));
                break;
        }
    }
    else if (pasPerson->scSyncRecStatus[pPacket->stream-1] == SC_SYNCED)
    {
        PS20DATAPACKET  pPacketUse;
        UINT            cbBufferSize;
        UINT            compression;
        BOOL            decompressed;
        UINT            dictionary;

        //
        // Decompress the packet if necessary
        //

        //
        // Use the temporary buffer.  This will never fail, so we don't
        // need to check the return value.  THIS MEANS THAT THE HANDLING OF
        // INCOMING PACKETS CAN NEVER IMMEDIATELY TURN AROUND AND SEND AN
        // OUTGOING PACKET.  Our scratch buffer is in use.
        //
        pPacketUse = (PS20DATAPACKET)m_ascTmpBuffer;

        TRACE_OUT(( "Got data pkt type %u from [%d], compression %u",
            pPacket->data.dataType, pasPerson->mcsID,
            pPacket->data.compressionType));

        //
        // If the packet has CT_OLD_COMPRESSED set, it has used simple PKZIP
        // compression
        //
        if (pPacket->data.compressionType & CT_OLD_COMPRESSED)
        {
            compression = CT_PKZIP;
        }
        else
        {
            //
            // If the packet has any other type of compression, the algorithm used
            // depends on the level of compression supported by the sender.
            // - If only level 1 (NM10) compression is supported, this packet is
            //   uncompressed.
            // - If level 2 (NM20) compression is supported, the packet is
            //   compressed, and the compression type is given in the packet header.
            //
            if (!pasPerson->cpcCaps.general.genCompressionLevel)
            {
                compression = 0;
            }
            else
            {
                compression = pPacket->data.compressionType;
            }
        }

        TRACE_OUT(( "packet compressed with algorithm %u", compression));

        //
        // If the packet is compressed, decompress it now
        //
        if (compression)
        {
            PGDC_DICTIONARY pgdcDict = NULL;

            //
            // Copy the uncompressed packet header into the buffer.
            //
            memcpy(pPacketUse, pPacket, sizeof(*pPacket));

            cbBufferSize = TSHR_MAX_SEND_PKT - sizeof(*pPacket);

            if (compression == CT_PERSIST_PKZIP)
            {
                //
                // Figure out what dictionary to use based on stream priority
                //
                switch (pPacket->stream)
                {
                    case PROT_STR_UPDATES:
                        dictionary = GDC_DICT_UPDATES;
                        break;

                    case PROT_STR_MISC:
                        dictionary = GDC_DICT_MISC;
                        break;

                    case PROT_STR_INPUT:
                        dictionary = GDC_DICT_INPUT;
                        break;

                    default:
                        ERROR_OUT(("Unrecognized stream ID"));
                        break;
                }

                pgdcDict = pasPerson->adcsDict + dictionary;
            }
            else if (compression != CT_PKZIP)
            {
                //
                // If this isn't PKZIP or PERSIST_PKZIP, we don't know what
                // it is (corrupted packet or incompatible T.128.  Bail
                // out now.
                //
                WARNING_OUT(("SC_ReceivedPacket: ignoring packet, don't recognize compression type"));
                DC_QUIT;
            }

            //
            // Decompress the data following the packet header.
            // This should never fail - if it does, the data has probably been
            // corrupted.
            //
            decompressed = GDC_Decompress(pgdcDict, m_agdcWorkBuf,
                (LPBYTE)(pPacket + 1),
                pPacket->data.compressedLength - sizeof(DATAPACKETHEADER),
                (LPBYTE)(pPacketUse + 1),
                &cbBufferSize);

            if (!decompressed)
            {
                ERROR_OUT(( "Failed to decompress packet from [%d]!", pasPerson->mcsID));
                DC_QUIT;
            }
        }
        else
        {
            // We have received an uncompressed buffer.  Since we may modify the
            // buffer's contents and what we have is an MCS buffer that may be
            // sent to other nodes, we copy the data.
            memcpy(pPacketUse, pPacket, pPacket->dataLength + sizeof(S20DATAPACKET)
                - sizeof(DATAPACKETHEADER));
        }

        // The packet (pPacketUse) is now decompressed

        //
        // ROUTE the packet
        //
        TRACE_OUT(("SC_ReceivedPacket:  Received packet type %04d size %04d from [%d]",
            pPacketUse->data.dataType, pPacketUse->data.compressedLength,
            pPacketUse->header.user));

        switch (pPacketUse->data.dataType)
        {
            case DT_CA:
                CA_ReceivedPacket(pasPerson, pPacketUse);
                break;

            case DT_CA30:
                CA30_ReceivedPacket(pasPerson, pPacketUse);
                break;

            case DT_IM:
                IM_ReceivedPacket(pasPerson, pPacketUse);
                break;

            case DT_SWL:
                SWL_ReceivedPacket(pasPerson, pPacketUse);
                break;

            case DT_HET:
            case DT_HET30:
                HET_ReceivedPacket(pasPerson, pPacketUse);
                break;

            case DT_UP:
                UP_ReceivedPacket(pasPerson, pPacketUse);
                break;

            case DT_FH:
                FH_ReceivedPacket(pasPerson, pPacketUse);
                break;

            case DT_CM:
                CM_ReceivedPacket(pasPerson, pPacketUse);
                break;

            case DT_CPC:
                CPC_ReceivedPacket(pasPerson, pPacketUse);
                break;

            case DT_AWC:
                AWC_ReceivedPacket(pasPerson, pPacketUse);
                break;

            case DT_UNUSED_DS:
                TRACE_OUT(("Ignoring DS packet received from NM 2.x node"));
                break;

            case DT_UNUSED_USR_FH_11:   // Old R.11 FH packets
            case DT_UNUSED_USR_FH_10:   // Old R.10 FH packets
            case DT_UNUSED_HCA:         // Old High-Level Control Arbiter
            case DT_UNUSED_SC:          // Old R.11 SC packets
            default:
                ERROR_OUT(( "Invalid packet received %u",
                           pPacketUse->data.dataType));
                break;
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::SC_ReceivedPacket);
}


//
// SC_ShareStarting()
// Share initialization
//
// This in turn calls other component share starting
//
BOOL ASShare::SC_ShareStarting(void)
{
    BOOL    rc = FALSE;
    BOOL    fViewSelf;

    DebugEntry(ASShare::SC_ShareStarting);

    //
    // SC specific init
    //

    // Find out whether to view own shared stuff (a handy debugging tool)
    COM_ReadProfInt(DBG_INI_SECTION_NAME, VIEW_INI_VIEWSELF, FALSE, &fViewSelf);
    m_scfViewSelf = (fViewSelf != FALSE);

    // Create scratch compression buffer for outgoing/incoming packets
    m_ascTmpBuffer = new BYTE[TSHR_MAX_SEND_PKT];
    if (!m_ascTmpBuffer)
    {
        ERROR_OUT(("SC_Init: couldn't allocate m_ascTmpBuffer"));
        DC_QUIT;
    }

    // Share version
    m_scShareVersion        = CAPS_VERSION_CURRENT;


    //
    // Component inits
    //

    if (!BCD_ShareStarting())
    {
        ERROR_OUT(("BCD_ShareStarting failed"));
        DC_QUIT;
    }

    if (!IM_ShareStarting())
    {
        ERROR_OUT(("IM_ShareStarting failed"));
        DC_QUIT;
    }

    if (!CM_ShareStarting())
    {
        ERROR_OUT(("CM_ShareStarting failed"));
        DC_QUIT;
    }

    if (!USR_ShareStarting())
    {
        ERROR_OUT(("USR_ShareStarting failed"));
        DC_QUIT;
    }

    if (!VIEW_ShareStarting())
    {
        ERROR_OUT(("VIEW_ShareStarting failed"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::SC_ShareStarting, rc);
    return(rc);
}



//
// SC_ShareEnded()
// Share cleanup
//
// This in turn calls other component share ended routines
//
void ASShare::SC_ShareEnded(void)
{
    DebugEntry(ASShare::SC_ShareEnded);

    //
    // Delete remotes from share
    //
    if (m_pasLocal)
    {
        while (m_pasLocal->pasNext)
        {
            SC_PartyDeleted(m_pasLocal->pasNext->mcsID);
        }

        //
        // Delete local self from share
        //
        SC_PartyDeleted(m_pasLocal->mcsID);
    }


    //
    // Component Notifications
    //

    VIEW_ShareEnded();

    USR_ShareEnded();

    CM_ShareEnded();

    IM_ShareEnded();

    BCD_ShareEnded();

    //
    // SC specific term
    //
    // Free scratch buffer
    if (m_ascTmpBuffer)
    {
        delete[] m_ascTmpBuffer;
        m_ascTmpBuffer = NULL;
    }

    DebugExitVOID(ASShare::SC_ShareEnded);
}





//
// SC_PartyJoiningShare()
//
// Called when a new party is joining the share.  This is an internal
// function because it is the SC which calls all these functions.  The
// processing done here relies on the capabilities - so it is in here as
// this is called after CPC_PartyJoiningShare.
//
// RETURNS:
//
// TRUE if the party can join the share.
//
// FALSE if the party can NOT join the share.
//
//
ASPerson * ASShare::SC_PartyJoiningShare
(
    UINT        mcsID,
    LPSTR       szName,
    UINT        cbCaps,
    LPVOID      pCaps
)
{
    BOOL        rc = FALSE;
    ASPerson *  pasPerson = NULL;

//    DebugEntry(ASShare::SC_PartyJoiningShare);

    //
    // Allocate an ASPerson for this dude.  If this is the local person,
    // it gets stuck at the front.  Otherwise it gets stuck just past
    // the front.
    //
    pasPerson = SC_PersonAllocate(mcsID, szName);
    if (!pasPerson)
    {
        ERROR_OUT(("SC_PartyAdded: can't allocate ASPerson for [%d]", mcsID));
        DC_QUIT;
    }

    //
    // DO THIS FIRST -- we need the person's caps set up
    //
    if (!CPC_PartyJoiningShare(pasPerson, cbCaps, pCaps))
    {
        ERROR_OUT(("CPC_PartyJoiningShare failed for [%d]", pasPerson->mcsID));
        DC_QUIT;
    }

    //
    // Call the component joined routines.
    //
    if (!DCS_PartyJoiningShare(pasPerson))
    {
        ERROR_OUT(("DCS_PartyJoiningShare failed for [%d]", pasPerson->mcsID));
        DC_QUIT;
    }

    if (!CM_PartyJoiningShare(pasPerson))
    {
        ERROR_OUT(("CM_PartyJoiningShare failed for [%d]", pasPerson->mcsID));
        DC_QUIT;
    }

    if (!HET_PartyJoiningShare(pasPerson))
    {
        ERROR_OUT(("HET_PartyJoiningShare failed for [%d]", pasPerson->mcsID));
        DC_QUIT;
    }


    //
    // NOW THE PERSON IS JOINED.
    // Recalculate capabilities of the share with this new person.
    //
    SC_RecalcCaps(TRUE);

    rc = TRUE;

DC_EXIT_POINT:
    if (!rc)
    {
        //
        // Don't worry, this person object will still be cleaned up,
        // code at a higher layer will free by using the MCSID.
        //
        pasPerson = NULL;
    }
//    DebugExitPVOID(ASShare::SC_PartyJoiningShare, pasPerson);
    return(pasPerson);
}



//
// SC_RecalcCaps()
//
// Recalculates share capabilities after somebody has joined or left the
// share.
//
void  ASShare::SC_RecalcCaps(BOOL fJoiner)
{
    ASPerson * pasT;

    DebugEntry(ASShare::SC_RecalcCaps);

    //
    // DO THIS FIRST -- recalculate the share version.
    //
    ValidatePerson(m_pasLocal);
    m_scShareVersion = m_pasLocal->cpcCaps.general.version;

    for (pasT = m_pasLocal->pasNext; pasT != NULL; pasT = pasT->pasNext)
    {
        ValidatePerson(pasT);
        m_scShareVersion = min(m_scShareVersion, pasT->cpcCaps.general.version);
    }

    //
    // Do viewing & hosting stuff first
    //
    DCS_RecalcCaps(fJoiner);
    OE_RecalcCaps(fJoiner);

    //
    // Do hosting stuff second
    //
    USR_RecalcCaps(fJoiner);
    CM_RecalcCaps(fJoiner);
    PM_RecalcCaps(fJoiner);
    SBC_RecalcCaps(fJoiner);
    SSI_RecalcCaps(fJoiner);

    DebugExitVOID(ASShare::SC_RecalcCaps);
}



//
// FUNCTION: SC_PartyLeftShare()
//
// DESCRIPTION:
//
// Called when a party has left the share.
//
//
void  ASShare::SC_PartyLeftShare(UINT_PTR mcsID)
{
    ASPerson *  pasPerson;
    ASPerson *  pasT;

    DebugEntry(SC_PartyLeftShare);

    if (!SC_ValidateNetID(mcsID, &pasPerson))
    {
        TRACE_OUT(("Couldn't find ASPerson for [%d]", mcsID));
        DC_QUIT;
    }

    // Tell the UI this dude is gone
    if (!pasPerson->cpcCaps.share.gccID)
    {
        WARNING_OUT(("Skipping PartyLeftShare for person [%d], no GCC id",
            pasPerson->mcsID));
        DC_QUIT;
    }

    DCS_NotifyUI(SH_EVT_PERSON_LEFT, pasPerson->cpcCaps.share.gccID, 0);

    //
    // Tell everybody this person is gone.
    //
    //
    // Notes on order of PartyLeftShare calls
    //
    // 1. HET must be called first, since that halts any sharing from this
    //    person, before we kick the person out of the share.
    //
    // 2. CA must be called before IM (as CA calls IM functions)
    //
    //

    // This will stop hosting early
    HET_PartyLeftShare(pasPerson);

    CA_PartyLeftShare(pasPerson);
    CM_PartyLeftShare(pasPerson);

    SWL_PartyLeftShare(pasPerson);
    VIEW_PartyLeftShare(pasPerson);

    PM_PartyLeftShare(pasPerson);
    RBC_PartyLeftShare(pasPerson);
    OD2_PartyLeftShare(pasPerson);

    OE_PartyLeftShare(pasPerson);
    DCS_PartyLeftShare(pasPerson);

    //
    // Free the person
    //
    SC_PersonFree(pasPerson);

    //
    // Recalculate the caps with him gone.  But there's no point in doing
    // this if it's the local dude, since the share will exit imminently.
    //
    if (m_pasLocal)
    {
        SC_RecalcCaps(FALSE);
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::SC_PartyLeftShare);
}


//
// FUNCTION: SCCheckForCMCall
//
// DESCRIPTION:
//
// This is called when we want to check if a CM call now exists (and do
// whatever is appropriate to join it etc).
//
// PARAMETERS: NONE
//
// RETURNS: TRUE if success; otherwise, FALSE.
//
//
void SCCheckForCMCall(void)
{
    CM_STATUS   cmStatus;

    DebugEntry(SCCheckForCMCall);

    ASSERT(g_asSession.scState == SCS_INIT);

    //
    // See if a call already exists
    //
    if (!g_asSession.callID)
    {
        if (CMS_GetStatus(&cmStatus))
        {
            //
            // The AS lock protects the g_asSession fields.
            //
            TRACE_OUT(("AS LOCK:  SCCheckForCMCall"));
            UT_Lock(UTLOCK_AS);

            g_asSession.callID = cmStatus.callID;

            g_asSession.attendeePermissions = cmStatus.attendeePermissions;
            WARNING_OUT(("Local mtg settings 0x%08lx", g_asSession.attendeePermissions));

            //
            // This is the time to update our local person name.  It's
            // on our thread, but before the control packets exchange it
            //
            lstrcpy(g_asSession.achLocalName, cmStatus.localName);
            g_asSession.cchLocalName = lstrlen(g_asSession.achLocalName);
            TRACE_OUT(("Local Name is %s", g_asSession.achLocalName));

            g_asSession.gccID = cmStatus.localHandle;

            UT_Unlock(UTLOCK_AS);
            TRACE_OUT(("AS UNLOCK:  SCCheckForCMCall"));
        }
    }

    if (g_asSession.callID)
    {
        SC_CreateShare(S20_JOIN);
    }

    DebugExitVOID(SCCheckForCMCall);
}



#ifdef _DEBUG
void ASShare::ValidatePerson(ASPerson * pasPerson)
{
    ASSERT(!IsBadWritePtr(pasPerson, sizeof(ASPerson)));
    ASSERT(!lstrcmp(pasPerson->stamp.idStamp, "ASPerso"));
    ASSERT(pasPerson->mcsID != MCSID_NULL);
}

void ASShare::ValidateView(ASPerson * pasPerson)
{
    ValidatePerson(pasPerson);
    ASSERT(!IsBadWritePtr(pasPerson->m_pView, sizeof(ASView)));
    ASSERT(!lstrcmp(pasPerson->m_pView->stamp.idStamp, "ASVIEW"));
}

#endif // _DEBUG


//
// SC_PersonAllocate()
// This allocates a new ASPerson structure, fills in the debug/mcsID fields,
// and links it into the people-in-the-conference list.
//
// Eventually, all the PartyJoiningShare routines that simply init a field
// should go away and that info put here.
//
ASPerson * ASShare::SC_PersonAllocate(UINT mcsID, LPSTR szName)
{
    ASPerson * pasNew;

//    DebugEntry(ASShare::SC_PersonAllocate);

    pasNew = new ASPerson;
    if (!pasNew)
    {
        ERROR_OUT(("Unable to allocate a new ASPerson"));
        DC_QUIT;
    }
    ZeroMemory(pasNew, sizeof(*pasNew));
    SET_STAMP(pasNew, Person);

    //
    // Set up mcsID and name
    //
    pasNew->mcsID = mcsID;
    lstrcpyn(pasNew->scName, szName, TSHR_MAX_PERSON_NAME_LEN);

    UT_Lock(UTLOCK_AS);

    //
    // Is this the local person?
    //
    if (!m_pasLocal)
    {
        m_pasLocal = pasNew;
    }
    else
    {
        UINT        streamID;

        //
        // This is a remote.  Set up the sync status right away in case
        // the join process fails in the middle.  Cleaning up will undo
        // this always.
        //

        //
        // Mark this person's streams as needing a sync from us before we
        //      can send data to him
        // And and that we need a sync from him on each stream before we'll
        //      receive data from him
        //
        for (streamID = SC_STREAM_LOW; streamID <= SC_STREAM_HIGH; streamID++ )
        {
            //
            // Set up the sync status.
            //
            ASSERT(pasNew->scSyncSendStatus[streamID-1] == SC_NOT_SYNCED);
            ASSERT(pasNew->scSyncRecStatus[streamID-1] == SC_NOT_SYNCED);
            m_ascSynced[streamID-1]++;
        }

        //
        // Link into list
        //
        pasNew->pasNext = m_pasLocal->pasNext;
        m_pasLocal->pasNext = pasNew;
    }

    UT_Unlock(UTLOCK_AS);

DC_EXIT_POINT:
//    DebugExitPVOID(ASShare::SC_PersonAllocate, pasNew);
    return(pasNew);
}



//
// SC_PersonFree()
// This gets a person out of the linked list and frees the memory for them.
//
void ASShare::SC_PersonFree(ASPerson * pasFree)
{
    ASPerson ** ppasPerson;
    UINT        streamID;


    DebugEntry(ASShare::SC_PersonFree);

    ValidatePerson(pasFree);

    for (ppasPerson = &m_pasLocal; *(ppasPerson) != NULL; ppasPerson = &((*ppasPerson)->pasNext))
    {
        if ((*ppasPerson) == pasFree)
        {
            //
            // Found it.
            //
            TRACE_OUT(("SC_PersonUnhook: unhooking person [%d]", pasFree->mcsID));

            if (pasFree == m_pasLocal)
            {
                ASSERT(pasFree->pasNext == NULL);
            }
            else
            {
                //
                // Clear syncs
                //
                // If this person was never synced, subtract them from the
                // global "needing sync" count on each stream
                //
                for (streamID = SC_STREAM_LOW; streamID <= SC_STREAM_HIGH; streamID++ )
                {
                    if (pasFree->scSyncSendStatus[streamID-1] == SC_NOT_SYNCED)
                    {
                        ASSERT(m_ascSynced[streamID-1] > 0);
                        m_ascSynced[streamID-1]--;
                    }
                }
            }

            UT_Lock(UTLOCK_AS);

            //
            // Fix up linked list.
            //
            (*ppasPerson) = pasFree->pasNext;

#ifdef _DEBUG
            ZeroMemory(pasFree, sizeof(ASPerson));
#endif // _DEBUG
            delete pasFree;

            UT_Unlock(UTLOCK_AS);
            DC_QUIT;
        }
    }

    //
    // We didn't find this guy in the list--this is very bad.
    //
    ERROR_OUT(("SC_PersonFree: didn't find person %d", pasFree));

DC_EXIT_POINT:
    DebugExitVOID(ASShare::SC_PersonFree);
}



//
// SC_AllocPkt()
// Allocates a SEND packet
//
PS20DATAPACKET ASShare::SC_AllocPkt
(
    UINT        streamID,
    UINT_PTR        nodeID,
    UINT_PTR        cbSizePkt
)
{
    PS20DATAPACKET  pPacket = NULL;

//    DebugEntry(ASShare::SC_AllocPkt);

    if (g_asSession.scState != SCS_SHARING)
    {
        TRACE_OUT(("SC_AllocPkt failed; share is ending"));
        DC_QUIT;
    }

    ASSERT((streamID >= SC_STREAM_LOW) && (streamID <= SC_STREAM_HIGH));
    ASSERT(cbSizePkt >= sizeof(S20DATAPACKET));

    //
    // We'd better not be in the middle of a sync!
    //
    ASSERT(!m_scfInSync);

    //
    // Try and send any outstanding syncs
    //
    if (!SCSyncStream(streamID))
    {
        //
        // If the stream is still not synced, don't allocate the packet
        //
        WARNING_OUT(("SC_AllocPkt failed; outstanding syncs are present"));
        DC_QUIT;
    }

    pPacket = S20_AllocDataPkt(streamID, nodeID, cbSizePkt);

DC_EXIT_POINT:
//    DebugExitPVOID(ASShare::SC_AllocPkt, pPacket);
    return(pPacket);
}




//
// SCSyncStream()
//
// This broadcasts a SNI sync packet intended for a new person who has just
// joined the share.  That person ignores all received data from us until
// they get the sync.  That's because data in transit before they are synced
// could refer to PKZIP data they don't have, second level order encoding
// info they can't decode, orders they can't process, etc.
//
// When we receive a SYNC from a remote, we then know that following
// data from that remote will make sense.  The remote has settled us into
// the share, and the data encorporates our capabilities and will not refer
// to prior state info from before we joined the share.
//
// NOTE that in 2.x, this was O(N^2) where N is the number of people now in
// the share!  Each person in the share would send SNI sync packets for each
// stream for each other person in the share, even for people who weren't new.
// But those people wouldn't reset received state, and would (could) continue
// processing data from us.  When they finally got their sync packet, it
// would do nothing!  Even worst, 2 of the 5 streams are never used,
// and one stream is only used when a person is hosting.  So 3 of these 5
// O(N^2) broadcasts were useless all or the majority of the time.
//
// So now we only send SNI sync packets for new joiners.  This makes joining
// an O(N) broadcast algorithm.
//
// LAURABU BOGUS
// Post Beta1, we can make this even better.  Each broadcast is itself O(N)
// packets.  So for beta1, joining/syncing is O(N^2) packets instead of
// O(N^3) packets.  With targeted sends (not broadcasts) whenever possible,
// we can drop this to O(N) total packets.
//
// NOTE also that no real app sharing packets are sent on a stream until
// we have fully synced everybody.  That means we've reduced a lot the
// lag between somebody dialing into a conference and their seeing a result,
// and everybody else being able to work again.
//
BOOL ASShare::SCSyncStream(UINT streamID)
{
    ASPerson *      pasPerson;
    PSNIPACKET      pSNIPacket;
    BOOL            rc = TRUE;

    DebugEntry(ASShare::SCSyncStream);

    //
    // Loop through each person in the call broadcasting sync packets as
    // necessary.
    //
    // LAURABU BOGUS
    // We can change this to a targeted send after Beta 1.
    //

    //
    // Note that new people are added to the front of the this.  So we will
    // bail out of this loop very quickly when sending syncs to newcomers.
    //
    ValidatePerson(m_pasLocal);

    pasPerson = m_pasLocal->pasNext;
    while ((m_ascSynced[streamID-1] > 0) && (pasPerson != NULL))
    {
        ValidatePerson(pasPerson);

        //
        // If this person is new, we need to send them a SYNC packet so
        // they know we are done processing their join and know they
        // are in the share.
        //
        if (pasPerson->scSyncSendStatus[streamID-1] != SC_SYNCED)
        {
            TRACE_OUT(("Syncing stream %d for person [%d] in broadcast way",
                streamID, pasPerson->mcsID));

            //
            // YES, syncs are broadcast even though they have the mcsID of
            // just one person, the person they are intended for.  Since we
            // broadcast all state data, we also broadcast syncs.  That's
            // the only way to make sure the packets arrive in the same
            // order, SYNC before data.
            //

            pSNIPacket = (PSNIPACKET)S20_AllocDataPkt(streamID,
                    g_s20BroadcastID, sizeof(SNIPACKET));
            if (!pSNIPacket)
            {
                TRACE_OUT(("Failed to alloc SNI sync packet"));
                rc = FALSE;
                break;
            }

            //
            // Set SNI packet fields
            //
            pSNIPacket->header.data.dataType = DT_SNI;
            pSNIPacket->message = SNI_MSG_SYNC;
            pSNIPacket->destination = (NET_UID)pasPerson->mcsID;

            S20_SendDataPkt(streamID, g_s20BroadcastID, &(pSNIPacket->header));

            pasPerson->scSyncSendStatus[streamID-1] = SC_SYNCED;

            ASSERT(m_ascSynced[streamID-1] > 0);
            m_ascSynced[streamID-1]--;
        }

        pasPerson = pasPerson->pasNext;
    }

    DebugExitBOOL(ASShare::SCSyncStream, rc);
    return(rc);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\shm.cpp ===
#include "precomp.h"


//
// SHM.CPP
// Shared Memory Access, cpi32 and display driver sides both
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE

//
// WAIT_FOR_BUFFER
//
// Wait until the display driver is accessing the new buffer.
//
// There are logically 8 states for a set of 3 boolean variables.  We can
// cut this down to 4 by some simple analysis:
//
//  - The overall busy flag overrides the other flags if it is clear.
//  - We can never have the display driver in both buffers (it's single
//    threaded).
//
// So the 4 states are as follows.
//
// STATE    BUSY FLAGS       DISPLAY DRIVER STATE
//          New Old Overall
//
// 1        0   0   0        Not using shared memory
// 2        0   0   1        Using shared memory (wait to see which)
// 3        1   0   1        Using the new buffer
// 4        0   1   1        Using the old buffer
//
// Obviously we wait while states 2 or 4 hold true....
//
#define WAIT_FOR_BUFFER(MEMORY, NEWBUFFER, OLDBUFFER)                        \
            while ( g_asSharedMemory->MEMORY.busyFlag &&                     \
                   ( g_asSharedMemory->MEMORY.bufferBusy[OLDBUFFER] ||       \
                    !g_asSharedMemory->MEMORY.bufferBusy[NEWBUFFER] )  )     \
            {                                                                \
                TRACE_OUT(("Waiting for SHM"));                            \
                Sleep(0);                                                    \
            }



//
// SHM_SwitchReadBuffer - see shm.h
//
void  SHM_SwitchReadBuffer(void)
{
    int     oldBuffer;
    int     newBuffer;

    DebugEntry(SHM_SwitchReadBuffer);

    //
    //
    // BUFFER SWITCHING FOR THE DISPLAY DRIVER -> SHARE CORE DATA
    //
    //
    // This is a forced switch.  The Share Core calls this function only
    // when it wants to force the switching of the buffers used to pass the
    // data back from the display driver.
    //
    //
    //      ͻ
    //       Kernel to Share Core data block                     
    //       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                     
    //        Ŀ               Ŀ  
    //                          BUSY FLAG1                   
    //         Share Core           1        Display Driver  
    //                                                       
    //         (read buffer)     SWITCH      (write buffer)  
    //                                                      
    //                       <>                 
    //         BUSY FLAG2                    BUSY FLAG2      
    //             0                             1           
    //                           IN USE                      
    //                                                      
    //                              >                 
    //                                                       
    //                                                       
    //                           COUNT                       
    //                              5                        
    //                         
    //                                                           
    //                                                           
    //      ͼ
    //
    //
    // On entry it is safe to clean out the current read buffer (to leave
    // it in a virgin state for the display driver once the buffers have
    // switched).
    //
    // The logic for the switch is as follows.
    //
    //  - Set the new value for the SWITCH pointer
    //
    //  - If the shared memory BUSY FLAG1 is clear we've finished and can
    //    exit now.
    //
    //  - We can exit as soon as either of the following are true.
    //
    //    - BUSY FLAG1 is clear                        DDI has finished
    //    - BUSY FLAG1 is set AND BUSY FLAG2 is set    DDI is in new memory
    //
    //

    //
    // Check for a valid pointer
    //
    ASSERT(g_asSharedMemory);

    //
    // Do that switch...The display driver may be in the middle of an
    // access at the moment, so we will test the state afterwards.
    //
    oldBuffer = g_asSharedMemory->displayToCore.newBuffer;
    newBuffer = 1 - oldBuffer;

    g_asSharedMemory->displayToCore.newBuffer = newBuffer;

    WAIT_FOR_BUFFER(displayToCore, newBuffer, oldBuffer);

    DebugExitVOID(SHM_SwitchReadBuffer);
}


//
// SHM_SwitchFastBuffer - see shm.h
//
void  SHM_SwitchFastBuffer(void)
{
    int oldBuffer;
    int newBuffer;

    DebugEntry(SHM_SwitchFastBuffer);

    //
    // Check for a valid pointer
    //
    ASSERT(g_asSharedMemory);

    //
    // Do that switch...The display driver may be in the middle of an
    // access at the moment, so we will test the state afterwards.
    //
    oldBuffer = g_asSharedMemory->fastPath.newBuffer;
    newBuffer = 1 - oldBuffer;

    g_asSharedMemory->fastPath.newBuffer = newBuffer;

    //
    // Wait for completion
    //
    WAIT_FOR_BUFFER(fastPath, newBuffer, oldBuffer);

    DebugExitVOID(SHM_SwitchFastBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32.95\cpi32dll.cpp ===
#include "precomp.h"


//
// CPI32DLL.CPP
// CPI32 dll entry point
//
// Copyright(c) Microsoft 1997-
//

#define INIT_DBG_ZONE_DATA
#include "dbgzones.h"


BOOL APIENTRY DllMain (HINSTANCE hInstance, DWORD reason, LPVOID plReserved)
{
    BOOL    rc = TRUE;

    switch (reason)
    {
        case DLL_PROCESS_ATTACH:
        {
#ifdef _DEBUG
            MLZ_DbgInit((PSTR *) &c_apszDbgZones[0],
                        (sizeof(c_apszDbgZones) / sizeof(c_apszDbgZones[0])) - 1);
#endif // _DEBUG

            DBG_INIT_MEMORY_TRACKING(hInstance);

            //
            // Utility stuff
            //
            if (!UT_HandleProcessStart(hInstance))
            {
                rc = FALSE;
                break;
            }

            //
            // Call platform specific init code
            //
            OSI_Load();

            //
            // Do common stuff
            //

            //
            // Init Persistent PKZIP -- this just calculates some values 
            // which are effectively constants, the tables are just too 
            // unwieldy to declare as such.
            //
            GDC_Init();

            break;
        }

        case DLL_PROCESS_DETACH:
        {
            //
            // Call platform specific cleanup code
            //
            OSI_Unload();


            //
            // Utility stuff
            //
            UT_HandleProcessEnd();

            DBG_CHECK_MEMORY_TRACKING(hInstance);

#ifdef _DEBUG
            MLZ_DbgDeInit();
#endif // _DEBUG

            break;
        }

        case DLL_THREAD_DETACH:
            UT_HandleThreadEnd();
            break;

        default:
            break;
    }

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\swl.cpp ===
#include "precomp.h"


//
// SWL.CPP
// Shared Window List
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE

//
// SWL strategy when network packets are not available
//
// The SWL only sends one type of message - the window structure message.
// When no network packets are available the SWL will drop its current
// packet and remember that the window structure has changed since it was
// last able to send a packet.  SWL_Periodic will also return FALSE when
// this happens so that the DCS will know not to send any updates if it
// failed to send a window structure.
//
// This pending of window structure messages is integrated with the
// ignore envelopes where the SWL wants to ignore changes caused by itself
// (or other components if they call the SWL_Begin/EndIgnoreWindowChanges
// functions).
//

//
// SWL strategy for backward compatibility.
//
// The differences between the R2.0 and 3.0 SWL protocol are:
// 1.  Tokenless packets.
// 2.  No shadows.
//




//
// SWL_PartyLeftShare()
//
void  ASShare::SWL_PartyLeftShare(ASPerson * pasPerson)
{
    DebugEntry(ASShare::SWL_PartyLeftShare);

    ValidatePerson(pasPerson);

    //
    // 2.x nodes will fake up a packet for a remote leaving with an empty
    // window list.  That's how they'd nuke shadows for that person, if he
    // had been hosting.  In so doing, they'd use a new token.  We need to
    // bump our token value up also so that the next window list we send
    // is not dropped.
    //
    m_swlLastTokenSeen = SWL_CalculateNextToken(m_swlLastTokenSeen);
    TRACE_OUT(("SWL_PartyLeftShare: bumped up token to 0x%08x", m_swlLastTokenSeen));

    DebugExitVOID(ASShare::SWL_PartyLeftShare);
}


//
// SWL_SyncOutgoing
//
void ASHost::SWL_SyncOutgoing(void)
{
    DebugEntry(ASHost::SWL_SyncOutgoing);

    //
    // Ensure that we send an SWL packet next time we need.
    //
    m_swlfForceSend = TRUE;
    m_swlfSyncing   = TRUE;

    DebugExitVOID(ASHost::SWL_SyncOutgoing);
}





//
// SWL_HostStarting()
//
BOOL ASHost::SWL_HostStarting(void)
{
    BOOL    rc = FALSE;

    DebugEntry(ASHost::SWL_HostStarting);

    //
    // Get an atom to use in getting and setting window properties (which
    // will give us SWL information about the window).
    //
    m_swlPropAtom = GlobalAddAtom(SWL_ATOM_NAME);
    if (!m_swlPropAtom)
    {
        ERROR_OUT(( "GlobalAddAtom error %#x", GetLastError()));
        DC_QUIT;
    }

    //
    // If this is NT, get the name of our startup desktop
    //
    if (!g_asWin95)
    {
        ASSERT(m_aswlOurDesktopName[0] == 0);
        GetUserObjectInformation(GetThreadDesktop(g_asMainThreadId),
                UOI_NAME, m_aswlOurDesktopName,
                sizeof(m_aswlOurDesktopName), NULL);

        TRACE_OUT(("Our desktop name is %s", m_aswlOurDesktopName));
    }

    if (!m_aswlOurDesktopName[0])
    {
        // Use default name
        TRACE_OUT(("Couldn't get desktop name; using %s",
                NAME_DESKTOP_DEFAULT));
        lstrcpy(m_aswlOurDesktopName, NAME_DESKTOP_DEFAULT);
    }

    //
    // Allocate memory for the window titles.  We fix the maximum size of
    // window title we will send - task list doesn't scroll horizontally so
    // we truncate window titles at MAX_WINDOW_TITLE_SEND.  However, we do
    // not pad the titles so we try to send as little data as possible.
    // Allocate all the segment but the rest of the code does not rely on
    // this so we split them into more segments later if need be.  The
    // memory pointed to by winNames[0] etc looks like this:
    //
    // For each entry in the corresponding WinStruct which is a window from
    // a shared task (and in the same order):
    //
    //  either -
    //  (char)0xFF - not a `task window' - give it a NULL title
    //  or -
    //  a null terminated string up to MAX_WINDOW_TITLE_SEND characters
    //
    // Note that we don't need full and compact versions because only
    // windows which will be in the compact WinStruct will have
    // corresponding entries in this structure.
    //
    m_aswlWinNames[0] =
            new char[2*SWL_MAX_WINDOWS*SWL_MAX_WINDOW_TITLE_SEND];
    if (!m_aswlWinNames[0])
    {
        ERROR_OUT(( "failed to get memory for window title lists"));
        DC_QUIT;
    }

    m_aswlWinNames[1] = m_aswlWinNames[0] +
            SWL_MAX_WINDOWS*SWL_MAX_WINDOW_TITLE_SEND;

    ASSERT(m_swlCurIndex == 0);

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASHost::SWL_HostStarting, rc);
    return(rc);
}



//
// SWL_HostEnded()
//
void  ASHost::SWL_HostEnded(void)
{
    DebugEntry(ASHost::SWL_HostEnded);

    //
    // For 2.x nodes, we must send out one last packet so they kill
    // their shadows.
    //

    //
    // Remove the SWL properties for all existing windows.
    //
    EnumWindows(SWLDestroyWindowProperty, 0);

    m_swlfSyncing = FALSE;

    if (m_pShare->m_scShareVersion < CAPS_VERSION_30)
    {
        //
        // SWL_Periodic() should NOT put properties on windows
        // when we're not hosting anymore.
        //
        ASSERT(m_pShare->m_pasLocal->hetCount == 0);
        TRACE_OUT(("SWL_HostEnded: Must send an empty window list for 2.x nodes"));
        m_swlfForceSend = TRUE;
        SWL_Periodic();
    }

    if (m_aswlNRInfo[0])
    {
        delete[] m_aswlNRInfo[0];
        m_aswlNRInfo[0] = NULL;
    }

    if (m_aswlNRInfo[1])
    {
        delete[] m_aswlNRInfo[1];
        m_aswlNRInfo[1] = NULL;
    }

    if (m_aswlWinNames[0])
    {
        delete[] m_aswlWinNames[0];
        m_aswlWinNames[0] = NULL;
    }

    if (m_swlPropAtom)
    {
        GlobalDeleteAtom(m_swlPropAtom);
        m_swlPropAtom = 0;
    }

    DebugExitVOID(ASHost::SWL_HostEnded);
}


//
// FUNCTION: SWL_GetSharedIDFromLocalID
//
// DESCRIPTION:
//
// Given a window ID from a shared application which is running locally
// this will return the top level parent.  If this parent is invisible,
// we return NULL.
//
// the parent window nearest the desktop. If this parent window is
// invisible NULL is returned.
//
// PARAMETERS:
//
// window - the window in question
//
// RETURNS:
//
// a HWND or NULL if the window is not from a shared application
//
//
HWND  ASHost::SWL_GetSharedIDFromLocalID(HWND window)
{
    HWND     hwnd;
    HWND     hwndParent;
    HWND     hwndDesktop;

    DebugEntry(ASHost::SWL_GetSharedIDFromLocalID);

    hwnd = window;
    if (!hwnd)
    {
        DC_QUIT;
    }

    hwndDesktop = GetDesktopWindow();

    //
    // Get the real top level ancestor
    //
    while (GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD)
    {
        hwndParent = GetParent(hwnd);
        if (hwndParent == hwndDesktop)
            break;

        hwnd = hwndParent;
    }

    //
    // Is this a hosted guy?
    //
    if (m_pShare->HET_WindowIsHosted(hwnd))
    {
        if (!(GetWindowLong(hwnd, GWL_STYLE) & WS_VISIBLE))
        {
            //
            // This window does not have the visible style. But it may just
            // be transiently invisible and SWL is still treating it as
            // visible. RAID3074 requires that a window which is not yet
            // believed to be invisible by SWL is treated as visible (since
            // the remote has not been informed that it is invisible). We
            // can determine whether SWL is traeting this window as visible
            // by looking at the SWL window property. If no property exists
            // then the window is new so the remote cannot know about it
            // and we can assume it is indeed invisible.
            //
            if (! ((UINT_PTR)GetProp(hwnd, MAKEINTATOM(m_swlPropAtom)) & SWL_PROP_COUNTDOWN_MASK))
            {
                //
                // SWL knows that the parent of a shared application is
                // invisible so we just return NULL.
                //
                hwnd = NULL;
            }
        }
    }
    else
    {
        hwnd = NULL;
    }

DC_EXIT_POINT:
    DebugExitDWORD(ASHost::SWL_GetSharedIDFromLocalID, HandleToUlong(hwnd));
    return(hwnd);
}


//
// SWL_UpdateCurrentDesktop()
//
// This checks what the current desktop is, and if it's changed, updates
// the NT input hooks for winlogon/screensaver for the service.  But normal
// SWL and AWC also make use of this info.
//
void  ASHost::SWL_UpdateCurrentDesktop(void)
{
    HDESK   hDeskCurrent = NULL;
    UINT    newCurrentDesktop;
    char    szName[SWL_DESKTOPNAME_MAX];

    DebugEntry(ASHost::SWL_UpdateCurrentDesktop);

    newCurrentDesktop = DESKTOP_OURS;

    if (g_asWin95)
    {
        // Nothing to do
        DC_QUIT;
    }

    //
    // Get the current desktop.  If we can't even get it, assume it's the
    // winlogon desktop.
    //
    hDeskCurrent = OpenInputDesktop(0, TRUE, DESKTOP_READOBJECTS);
    if (!hDeskCurrent)
    {
        TRACE_OUT(("OpenInputDesktop failed; must be WINLOGON"));
        newCurrentDesktop = DESKTOP_WINLOGON;
        DC_QUIT;
    }

    // Get the name of the current desktop
    szName[0] = 0;
    GetUserObjectInformation(hDeskCurrent, UOI_NAME, szName,
        sizeof(szName), NULL);
    TRACE_OUT(("GetUserObjectInformation returned %s for name", szName));

    if (!lstrcmpi(szName, m_aswlOurDesktopName))
    {
        newCurrentDesktop = DESKTOP_OURS;
    }
    else if (!lstrcmpi(szName, NAME_DESKTOP_SCREENSAVER))
    {
        newCurrentDesktop = DESKTOP_SCREENSAVER;
    }
    else if (!lstrcmpi(szName, NAME_DESKTOP_WINLOGON))
    {
        newCurrentDesktop = DESKTOP_WINLOGON;
    }
    else
    {
        newCurrentDesktop = DESKTOP_OTHER;
    }

DC_EXIT_POINT:
    if (newCurrentDesktop != m_swlCurrentDesktop)
    {
        //
        // If this is the service, adjust where we playback events
        // and/or block local input.
        //
        OSI_DesktopSwitch(m_swlCurrentDesktop, newCurrentDesktop);
        m_swlCurrentDesktop = newCurrentDesktop;
    }

    if (hDeskCurrent != NULL)
    {
        CloseDesktop(hDeskCurrent);
    }

    DebugExitVOID(ASHost::SWL_UpdateCurrentDesktop);
}


//
// SWL_IsOurDesktopActive()
//
BOOL ASHost::SWL_IsOurDesktopActive(void)
{
    return(!g_asSharedMemory->fullScreen && (m_swlCurrentDesktop == DESKTOP_OURS));
}



//
// FUNCTION: SWLInitHostFullWinListEntry
//
// DESCRIPTION:
//
// Initializes a hosted window entry in the full window list.
//
// PARAMETERS: hwnd - Window ID of the hosted window
//             windowProp - SWL window properties for hwnd
//             ownerID - Window ID of hwnd's owner
//             pFullWinEntry - pointer to the list entry to initialize
//
// RETURNS: Nothing
//
//
void  ASHost::SWLInitHostFullWinListEntry
(
    HWND    hwnd,
    UINT    windowProp,
    HWND    hwndOwner,
    PSWLWINATTRIBUTES pFullWinEntry
)
{
    DebugEntry(ASHost::SWLInitHostFullWinListEntry);

    //
    // The window is a shared application hosted locally.
    // These get the application id, the local window id and the owner
    // window id.
    //
    // Note that the real owner of the window may be a child of a shared
    // window, and therefore not known to the remote machine. We therefore
    // pass the real owner to SWL_GetSharedIDFromLocalID() which will
    // traverse up the owner's window tree until it finds a window that is
    // shared and store the returned window handle in the window structure.
    //
    pFullWinEntry->flags = SWL_FLAG_WINDOW_HOSTED;
    pFullWinEntry->winID = HandleToUlong(hwnd);
    pFullWinEntry->extra = GetWindowThreadProcessId(hwnd, NULL);

    // NOTE:  ownerWinID is ignored by NM 3.0 and up.
    pFullWinEntry->ownerWinID = HandleToUlong(SWL_GetSharedIDFromLocalID(hwndOwner));

    //
    // Check if the window is minimized.
    //
    if (IsIconic(hwnd))
    {
        pFullWinEntry->flags |= SWL_FLAG_WINDOW_MINIMIZED;
    }

    //
    // TAGGABLE is for 2.x nodes only; 3.0 and up don't look at this.
    //
    if (windowProp & SWL_PROP_TAGGABLE)
    {
        pFullWinEntry->flags |= SWL_FLAG_WINDOW_TAGGABLE;
    }

    if (windowProp & SWL_PROP_TRANSPARENT)
    {
        //
        // The window is transparent and (to have got this far) must be
        // shared or the desktop is shared, ie we will be sending the
        // window but need to fiddle the z-order. Flag the transparency so
        // we can do the z-order later.
        //
        pFullWinEntry->flags |= SWL_FLAG_WINDOW_TRANSPARENT;
    }
    else if (GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_TOPMOST)
    {
        //
        // The window is not transparent and is topmost, so set the topmost
        // flag.
        //
        pFullWinEntry->flags |= SWL_FLAG_WINDOW_TOPMOST;
    }

    //
    // If this window is on the task bar then pass this info on
    //
    if (windowProp & SWL_PROP_TASKBAR)
    {
        pFullWinEntry->flags |= SWL_FLAG_WINDOW_TASKBAR;
    }
    else
    {
        pFullWinEntry->flags |= SWL_FLAG_WINDOW_NOTASKBAR;
    }

    DebugExitVOID(ASHost::SWLInitHostFullWinListEntry);
}



//
// FUNCTION: SWLAddHostWindowTitle
//
// DESCRIPTION:
//
// Adds a hosted window title (or blank entry) to our window titles list.
//
// PARAMETERS: winid - Window ID of the hosted window
//             windowProp - SWL window properties for winid
//             ownerID - Window ID of winid's owner
//             ppWinNames - pointer to pointer to window names structure
//
// RETURNS: Nothing
//
//
void  ASHost::SWLAddHostWindowTitle
(
    HWND    hwnd,
    UINT    windowProp,
    HWND    hwndOwner,
    LPSTR   *ppWinNames
)
{
    int     lenTitle;

    DebugEntry(ASHost::SWLAddHostWindowTitle);

    //
    // This window gets an entry in our window titles data if it passes the
    // following tests
    //
    // for Windows: it has no owner, or its owner is invisible
    //
    //
    if ( (windowProp & SWL_PROP_TASKBAR) ||
         hwndOwner == NULL ||
         !IsWindowVisible(hwndOwner) )
    {
        //
        // LAURABU 2.x COMPAT:
        // 3.0 nodes only look at the text if TASKBAR is set.  When 2.x
        // compat is gone, don't send text in the other cases.
        //

        //
        // Get the title - truncated and null terminated for us.  First
        // look for the desktop, which may have a special, configurable
        // name.
        //
        lenTitle = GetWindowText(hwnd, *ppWinNames, SWL_MAX_WINDOW_TITLE_SEND);

        //
        // Check that the title has been null terminated.
        //
        (*ppWinNames)[lenTitle] = '\0';
        *ppWinNames += lenTitle;
    }
    else
    {
        //
        // This is not a task window - put a corresponding entry in the
        // title info.
        //
        **ppWinNames = '\xff';
    }

    *ppWinNames += 1;

    DebugExitVOID(ASHost::SWLAddHostWindowTitle);
}


//
// FUNCTION: SWL_InitFullWindowListEntry
//
// DESCRIPTION:
//
// Initialises an entry in the full window list.
//
// PARAMETERS: hwnd - Window ID of the window for which an entry is
//                     initialized
//             windowProp - SWL window properties for hwnd
//             ownerID - Window ID of hwnd's owner
//             pFullWinEntry - pointer to the list entry to initialize
//
// RETURNS: Nothing
//
//
void  ASHost::SWL_InitFullWindowListEntry
(
    HWND                hwnd,
    UINT                windowProp,
    LPSTR *             ppWinNames,
    PSWLWINATTRIBUTES   pFullWinEntry
)
{
    HWND                hwndOwner;
    RECT                rect;

    DebugEntry(ASHost::SWL_InitFullWindowListEntry);

    if (windowProp & SWL_PROP_HOSTED)
    {
        //
        // The window is a shared application hosted locally.
        // Set up an entry in our full window structure.
        //
        hwndOwner = GetWindow(hwnd, GW_OWNER);
        SWLInitHostFullWinListEntry(hwnd,
                                    windowProp,
                                    hwndOwner,
                                    pFullWinEntry);

        SWLAddHostWindowTitle(hwnd, windowProp, hwndOwner, ppWinNames);
    }
    else
    {
        //
        // The window is a local (non-shared) application
        //
        pFullWinEntry->flags = SWL_FLAG_WINDOW_LOCAL;

        //
        // We set the winID here because we may need this info
        // again later, but we will NULL it out before we send the
        // protocol packet out because it is not info that the
        // remote needs
        //
        pFullWinEntry->winID = HandleToUlong(hwnd);
        pFullWinEntry->extra = MCSID_NULL;
        pFullWinEntry->ownerWinID = 0;
    }

    //
    // Get the position and size of the window, in inclusive
    // Virtual Desktop coordinates.
    //
    GetWindowRect(hwnd, &rect);

    //
    // TAGGABLE is for 2.x nodes only
    //
    if (IsRectEmpty(&rect))
    {
        pFullWinEntry->flags &= ~SWL_FLAG_WINDOW_TAGGABLE;
    }
    else
    {
        if (windowProp & SWL_PROP_TAGGABLE)
        {
            if (!SWLWindowIsTaggable(hwnd))
                pFullWinEntry->flags &= ~SWL_FLAG_WINDOW_TAGGABLE;
        }
    }

    //
    // Make the rectangle inclusive.
    //
    rect.right      -= 1;
    rect.bottom     -= 1;
    TSHR_RECT16_FROM_RECT(&(pFullWinEntry->position), rect);

    DebugExitVOID(ASHost::SWL_InitFullWindowListEntry);
}


//
// FUNCTION: SWLCompactWindowList
//
// DESCRIPTION:
//
// Compacts the full window list into one containng only those windows SWL
// needs to send (hosts and any locals overlapping hosts)
//
// PARAMETERS: numFullListEntries - number of entries in the full window
//                                  list.
//             pFullWinList - pointer to the full window list
//             pCompactWinList - pointer to the compact window list
//
// RETURNS: Number of entries copied to the compact window list
//
//
UINT  ASHost::SWLCompactWindowList
(
    UINT                numFullListEntries,
    PSWLWINATTRIBUTES   pFullWinList,
    PSWLWINATTRIBUTES   pCompactWinList
)
{
    UINT              fullIndex;
    UINT              compactIndex = 0;
    UINT              i;

    DebugEntry(ASHost::SWLCompactWindowList);

    //
    // For each window in the full list...
    //
    for ( fullIndex = 0; fullIndex < numFullListEntries; fullIndex++ )
    {
        if (pFullWinList[fullIndex].flags & SWL_FLAG_WINDOW_LOCAL)
        {
            //
            // This is a local window so we need to track it only if it
            // overlaps a hosted window. Run through the remaining windows
            // until we either find an overlapped hosted window (meaning we
            // must track this local window) or reach the end of the list
            // (meaning we don't need to track this local window).
            //
            for ( i = fullIndex + 1; i < numFullListEntries; i++ )
            {
                //
                // If this window is hosted and intersects the local
                // window then we need to track the local window.
                //
                if ( (pFullWinList[i].flags & SWL_FLAG_WINDOW_HOSTED) &&
                     (COM_Rect16sIntersect(&pFullWinList[fullIndex].position,
                                           &pFullWinList[i].position)))
                {
                      //
                      // Copy the local window to the compact array and
                      // break out the inner loop.
                      //
                      TRACE_OUT(("Add local hwnd 0x%08x to list at %u",
                            pFullWinList[fullIndex].winID, compactIndex));
                      pCompactWinList[compactIndex++] =
                                                      pFullWinList[fullIndex];
                      break;
                }
            }
        }
        else
        {
            //
            // This is a shadow or hosted window so we must track it.
            //
            TRACE_OUT(("Add shared hwnd 0x%08x to list at %u",
                pFullWinList[fullIndex].winID, compactIndex));
            pCompactWinList[compactIndex++] = pFullWinList[fullIndex];
        }
    }

    DebugExitDWORD(ASHost::SWLCompactWindowList, compactIndex);
    return(compactIndex);
}




//
// FUNCTION: SWLAdjustZOrderForTransparency
//
// DESCRIPTION:
//
// Rearranges the window structure z-order to take account of a transparent
// window (winID). Must not be called if the transparent entry is the last
// in the compact list.
//
// PARAMETERS: pTransparentListEntry - pointer to the transparent entry
//             pLastListEntry - pointer to the last compact window list
//                              entry
//             winPosition - position of window in names array
//             pWinNames - hosted window names
//             sizeWinNames - number of bytes in winNames
//
// RETURNS: Nothing.
//
//
void  ASHost::SWLAdjustZOrderForTransparency
(
    PSWLWINATTRIBUTES   pTransparentListEntry,
    PSWLWINATTRIBUTES   pLastListEntry,
    UINT                winPosition,
    LPSTR               pWinNames,
    UINT                sizeWinNames
)
{
    SWLWINATTRIBUTES winCopyBuffer;
    LPSTR pEndNames = &pWinNames[sizeWinNames - 1];
    UINT nameLen;
    char windowText[TSHR_MAX_PERSON_NAME_LEN + SWL_MAX_WINDOW_TITLE_SEND];

    DebugEntry(ASHost::SWLAdjustZOrderForTransparency);

    //
    // - turn off the transparent flag (it's not part of the protocol)
    // - move the window to the end of the structure, ie bottom of the
    //   z-order (unless the desktop is at the bottom, in which case
    //   the window becomes next to bottom).
    //
    TRACE_OUT(("Adjust z-order for transparent hwnd 0x%08x position %u",
                                           pTransparentListEntry->winID,
                                           winPosition));
    pTransparentListEntry->flags &= ~SWL_FLAG_WINDOW_TRANSPARENT;
    winCopyBuffer = *pTransparentListEntry;

    //
    // Shuffle the windows after the transparent entry one place toward the
    // start of the list.
    //
    UT_MoveMemory(pTransparentListEntry,
               &pTransparentListEntry[1],
               (LPBYTE)pLastListEntry - (LPBYTE)pTransparentListEntry);

    *pLastListEntry = winCopyBuffer;

    //
    // Now rearrange the window names in the same way. First, find the name
    // for this window.
    //
    ASSERT((sizeWinNames != 0));
    for ( ;winPosition != 0; winPosition-- )
    {
        if ( *pWinNames == '\xff' )
        {
            //
            // No name exists for this window, so just advance past the
            // 0xff placeholder.
            //
            TRACE_OUT(("No name for %u", winPosition-1));
            pWinNames++;
        }
        else
        {
            //
            // A name exists for this window, so skip past all the
            // characters, including the NULL terminator.
            //
            TRACE_OUT(( "Ignore %s", pWinNames));
            while ( *pWinNames != '\0' )
            {
                pWinNames++;
            }
        }
    }

    //
    // winNames now points to the start of the name for the window being
    // reordered.
    //
    if ( *pWinNames == '\xff' )
    {
        //
        // This window has no name and simply has an 0xff placeholder in
        // the name list. Move all the remaining names down by one and add
        // the 0xff at the end.
        //
        TRACE_OUT(("Reorder nameless window"));
        UT_MoveMemory(pWinNames, pWinNames + 1, pEndNames - pWinNames);
        *pEndNames = (char)'\xff';
    }
    else
    {
        //
        // Move as many bytes as there are characters in the window name
        // then tack the name on the end.
        //
        TRACE_OUT(("Reorder %s", pWinNames));
        lstrcpy(windowText, pWinNames);
        nameLen = lstrlen(pWinNames);
        UT_MoveMemory(pWinNames, pWinNames + nameLen + 1, pEndNames - pWinNames -
                                                                     nameLen);
        lstrcpy(pEndNames - nameLen, windowText);
    }

    DebugExitVOID(ASHost::SWLAdjustZOrderForTransparency);
}

//
// SWL_Periodic()
//
// DESCRIPTION:
//
// Called periodically.  If the window structure has changed (such that it
// impacts remote systems) then send a new one if we can.
//
// PARAMETERS:
//
// fSend - TRUE if the caller really wants us to try to send the new
// structure.
//
// RETURNS: SWL_RC_ERROR    : An error occurred
//          SWL_RC_SENT     : Window structure sent successfully
//          SWL_RC_NOT_SENT : No need to send window structure
//
UINT  ASHost::SWL_Periodic(void)
{
    UINT                fRC = SWL_RC_NOT_SENT;
    UINT                newIndex;
    PSWLWINATTRIBUTES   newFullWinStruct;
    PSWLWINATTRIBUTES   curFullWinStruct;
    PSWLWINATTRIBUTES   newCompactWinStruct;
    PSWLWINATTRIBUTES   curCompactWinStruct;
    UINT                i;
    UINT                k;
    BOOL                fNoTitlesChanged;
    HWND                hwnd;
    SWLENUMSTRUCT       swlEnumStruct;
    int                 complexity;
    UINT                cNonRectData;
    UINT                size;
    UINT                ourSize;
    HRGN                hrgnNR;
    HRGN                hrgnRect;
    LPRGNDATA           pRgnData = NULL;
    LPTSHR_INT16        pOurRgnData = NULL;
    LPTSHR_INT16        pEndRgnData;
    LPTSHR_INT16        pAllocRgnData = NULL;
    BOOL                fNonRectangularInfoChanged;
    BOOL                rgnOK;
    RECT                rectBound;
    int                 left;
    int                 top;
    int                 right;
    int                 bottom;
    int                 lastleft;
    int                 lasttop;
    int                 lastright;
    int                 lastbottom;
    int                 deltaleft;
    int                 deltatop;
    int                 deltaright;
    int                 deltabottom;
    int                 lastdeltaleft;
    int                 lastdeltatop;
    int                 lastdeltaright;
    int                 lastdeltabottom;
    UINT                numCompactWins;
    UINT                lastTransparency;
    UINT                winFlags;
    UINT                iHosted;

    DebugEntry(ASSHost::SWL_Periodic);

    SWL_UpdateCurrentDesktop();

    //
    // If this party isn't hosting apps (and isn't faking up an empty
    // packet for 2.x nodes), there's nothing to do.
    //
    if (m_pShare->m_pasLocal->hetCount == HET_DESKTOPSHARED)
    {
        m_swlfForceSend     = FALSE;
        fRC                 = SWL_RC_NOT_SENT;
        DC_QUIT;
    }

    //
    // Get the window structure into the "new" array.
    //
    newIndex = (m_swlCurIndex+1)%2;
    curFullWinStruct = &(m_aswlFullWinStructs[m_swlCurIndex * SWL_MAX_WINDOWS]);
    newFullWinStruct = &(m_aswlFullWinStructs[newIndex * SWL_MAX_WINDOWS]);

    //
    // Free any previously allocated data.
    //
    if (m_aswlNRInfo[newIndex])
    {
        delete[] m_aswlNRInfo[newIndex];
        m_aswlNRInfo[newIndex] = NULL;
    }
    m_aswlNRSize[newIndex] = 0;

    //
    // Start from the first child of the desktop - should be the top
    // top-level window
    //
    ZeroMemory(&swlEnumStruct, sizeof(swlEnumStruct));
    swlEnumStruct.pHost             = this;
    swlEnumStruct.newWinNames       = m_aswlWinNames[newIndex];
    swlEnumStruct.newFullWinStruct  = newFullWinStruct;

    //
    // Before we consider the windows on the windows desktop we check for
    // an active full-screen session.  If there is one then we insert a
    // local window the size of the physical screen first so that all
    // applications which are hosted on this system will become obscured
    // on the remote system.
    //
    ASSERT(swlEnumStruct.count == 0);

    if (!SWL_IsOurDesktopActive())
    {
        newFullWinStruct[0].flags = SWL_FLAG_WINDOW_LOCAL;
        newFullWinStruct[0].winID = 0;
        newFullWinStruct[0].extra = MCSID_NULL;
        newFullWinStruct[0].ownerWinID = 0;
        newFullWinStruct[0].position.left = 0;
        newFullWinStruct[0].position.top = 0;
        newFullWinStruct[0].position.right = (TSHR_UINT16)(m_pShare->m_pasLocal->cpcCaps.screen.capsScreenWidth-1);
        newFullWinStruct[0].position.bottom = (TSHR_UINT16)(m_pShare->m_pasLocal->cpcCaps.screen.capsScreenHeight-1);

        swlEnumStruct.count++;
    }

    EnumWindows(SWLEnumProc, (LPARAM)&swlEnumStruct);

    //
    // Check if we should bail out because of visibility detection
    //
    if (swlEnumStruct.fBailOut)
    {
        TRACE_OUT(("SWL_MaybeSendWindowList: bailing out due to visibility detection"));
        fRC = SWL_RC_ERROR;
        DC_QUIT;
    }

    m_aswlWinNamesSize[newIndex] = (UINT)(swlEnumStruct.newWinNames - m_aswlWinNames[newIndex]);
    m_aswlNumFullWins[newIndex]  = swlEnumStruct.count;

    //
    // Check whether we found a transparent window.
    //
    lastTransparency = swlEnumStruct.count - 1;
    k = 0;
    iHosted = 0;
    while ( (swlEnumStruct.transparentCount > 0) && (k < lastTransparency) )
    {
        //
        // If the transparent flag is set then rearrange the z-order,
        // providing the transparent window is not already at the
        // bottom of the z-order.
        //
        if (newFullWinStruct[k].flags & SWL_FLAG_WINDOW_TRANSPARENT)
        {
            //
            // Now continue with the non-rectangular check - but this will
            // be on the window "shunted down" from what was the next
            // position in newCompactWinStruct, ie same value of i. We will
            // see the moved (transparent) window when we reach it
            // again at the end of this for-loop (when it will have the
            // transparent flag off, so we don't redo this bit).
            //
            SWLAdjustZOrderForTransparency(
                &newFullWinStruct[k],
                &newFullWinStruct[lastTransparency],
                iHosted,
                m_aswlWinNames[newIndex],
                m_aswlWinNamesSize[newIndex]);

            swlEnumStruct.transparentCount--;
        }
        else
        {
            if (newFullWinStruct[k].flags & SWL_FLAG_WINDOW_HOSTED)
            {
                iHosted++;
            }
            k++;
        }
    }

    //
    // Compare the current and new information - if they are identical then
    // we can quit now.
    //
    fNoTitlesChanged = ((m_aswlWinNamesSize[0] == m_aswlWinNamesSize[1]) &&
            (memcmp(m_aswlWinNames[0],
                     m_aswlWinNames[1],
                     m_aswlWinNamesSize[0]) == 0));

    if ( fNoTitlesChanged &&
         !m_swlfRegionalChanges &&
         (m_aswlNumFullWins[0] == m_aswlNumFullWins[1]) &&
         (memcmp(newFullWinStruct,
                 curFullWinStruct,
                 (m_aswlNumFullWins[0] * sizeof(SWLWINATTRIBUTES))) == 0) )
    {
        //
        // We don't need to send a window structure if nothing has changed
        // unless there has been a send override.
        //
        if (m_swlfForceSend)
        {
            //
            // This is a normal call AND there are pending changes.
            //
            TRACE_OUT(( "NORMAL, pending changes - send"));
            if (SWLSendPacket(&(m_aswlCompactWinStructs[m_swlCurIndex * SWL_MAX_WINDOWS]),
                                m_aswlNumCompactWins[m_swlCurIndex],
                                m_aswlWinNames[m_swlCurIndex],
                                m_aswlWinNamesSize[m_swlCurIndex],
                                m_aswlNRSize[m_swlCurIndex],
                                m_aswlNRInfo[m_swlCurIndex]) )
            {
                //
                // Successfully sent this so reset the m_swlfForceSend
                // flag.
                //
                m_swlfForceSend = FALSE;
                fRC = SWL_RC_SENT;
            }
            else
            {
                //
                // Failed to send this packet so don't reset
                // m_swlfForceSend so that we retry next time and return
                // an error.
                //
                fRC = SWL_RC_ERROR;
            }
        }
        else
        {
            //
            // This is a normal call and we don't have any changes pending
            // so don't send anything.
            //
            TRACE_OUT(( "No changes - SWL not sent"));
        }

        DC_QUIT;
    }

    //
    // We can reset the flag that alerted us to potential regional window
    // changes now that we have gone and actually checked all the windows.
    //
    m_swlfRegionalChanges = FALSE;

    //
    // Something in the window structure has changed. Determine which
    // windows in the full list are unnecessary (local ones not overlapping
    // any hosted ones) and create a compact array of windows we really
    // need.
    //
    curCompactWinStruct = &(m_aswlCompactWinStructs[m_swlCurIndex * SWL_MAX_WINDOWS]);
    newCompactWinStruct = &(m_aswlCompactWinStructs[newIndex * SWL_MAX_WINDOWS]);

    numCompactWins = SWLCompactWindowList(m_aswlNumFullWins[newIndex],
                                          newFullWinStruct,
                                          newCompactWinStruct);

    m_aswlNumCompactWins[newIndex] = numCompactWins;

    //
    // Run through the compact window list to check for regional windows
    //
    cNonRectData = 0;

    hrgnNR = CreateRectRgn(0, 0, 0, 0);

    for (i = 0; i < numCompactWins; i++)
    {
        winFlags = newCompactWinStruct[i].flags;
        hwnd     = (HWND)newCompactWinStruct[i].winID;

        //
        // There are some "fake" windows for which we do not provide a
        // winID - these will never be non-rectangular anyway.
        //
        if ( (hwnd != NULL) &&
             (winFlags & (SWL_FLAG_WINDOW_LOCAL | SWL_FLAG_WINDOW_HOSTED)) )
        {
            //
            // If any of the remote systems care, see if this window has a
            // non rectangular region selected into it.
            //
            if (GetWindowRgn(hwnd, hrgnNR) != ERROR)
            {
                TRACE_OUT(("Regional window 0x%08x", hwnd));

                //
                // There is a region selected in.
                //
                // This region is exactly as the application passed it to
                // Windows, and has not yet been clipped to the window
                // rectangle itself.
                // THE COORDS ARE INCLUSIVE, SO WE ADD ONE to BOTTOM-RIGHT
                //
                hrgnRect = CreateRectRgn(0, 0,
                    newCompactWinStruct[i].position.right -
                        newCompactWinStruct[i].position.left + 1,
                    newCompactWinStruct[i].position.bottom -
                        newCompactWinStruct[i].position.top + 1);

                complexity = IntersectRgn(hrgnNR, hrgnNR, hrgnRect);

                DeleteRgn(hrgnRect);

                if (complexity == COMPLEXREGION)
                {
                    //
                    // The intersection is still a non-rectangular region.
                    //
                    // See how big a buffer we need to get the data for
                    // this region.
                    //
                    size = GetRegionData(hrgnNR,
                                             0,
                                             NULL);

                    //
                    // The size we are returned is the size of a full
                    // RGNDATAHEADER plus the rectangles stored in DWORDS.
                    // We can get away with just a WORD as the count of the
                    // rectangles, plus using WORDs for each of the
                    // coordinates.
                    //
                    size = (size - sizeof(RGNDATAHEADER)) / 2 + 2;

                    // Max UINT16 check
                    if ((size <= SWL_MAX_NONRECT_SIZE) &&
                        (size + cNonRectData < 65535))
                    {
                        //
                        // We will be able to query this data later, so
                        // we can flag this as a non-rectangular window.
                        //
                        newCompactWinStruct[i].flags
                                             |= SWL_FLAG_WINDOW_NONRECTANGLE;

                        cNonRectData += size;

                        TRACE_OUT(("Regional window region is %d bytes", size));
                    }
                    else
                    {
                        //
                        // This region is far too complex for us, so we
                        // pretend it is simple so we just consider its
                        // bounding box.
                        //
                        TRACE_OUT(("Region too big %d - use bounds", size));
                        complexity = SIMPLEREGION;
                    }
                }

                if (complexity == SIMPLEREGION)
                {
                    //
                    // The resultant intersection region happens to be a
                    // rectangle so we can send this via the standard
                    // structure.
                    //
                    // Apply the virtual desktop adjustment, make it
                    // inclusive, and remember we were passed back window
                    // relative coords for the region.
                    //
                    TRACE_OUT(( "rectangular clipped regional window"));

                    // Since we are modifying the compact window struct here
                    // we need to call this so we don't falsely assume that
                    // there are no changes in the window struct based on
                    // comparisons of the old and new full window structs
                    m_swlfRegionalChanges = TRUE;

                    GetRgnBox(hrgnNR, &rectBound);

                    newCompactWinStruct[i].position.left   = (TSHR_INT16)
                          (newCompactWinStruct[i].position.left +
                            rectBound.left);
                    newCompactWinStruct[i].position.top    = (TSHR_INT16)
                          (newCompactWinStruct[i].position.top +
                           rectBound.top);

                    newCompactWinStruct[i].position.right  = (TSHR_INT16)
                          (newCompactWinStruct[i].position.left +
                           rectBound.right - rectBound.left - 1);
                    newCompactWinStruct[i].position.bottom = (TSHR_INT16)
                          (newCompactWinStruct[i].position.top +
                           rectBound.bottom - rectBound.top - 1);
                }
            }
        }
    }

    //
    // Get any non-rectangular areas we need.
    //
    if (cNonRectData)
    {
        //
        // There was some data needed - allocate some memory for it.
        //
        rgnOK = FALSE;
        pAllocRgnData = (LPTSHR_INT16) new BYTE[cNonRectData];
        if (pAllocRgnData)
        {
            pOurRgnData = pAllocRgnData;
            pEndRgnData = (LPTSHR_INT16)((LPBYTE)pAllocRgnData + cNonRectData);
            rgnOK = TRUE;

            //
            // Loop through the windows again, getting the data this time.
            //
            for ( i = 0; i < numCompactWins; i++ )
            {
                if (newCompactWinStruct[i].flags &
                                           SWL_FLAG_WINDOW_NONRECTANGLE)
                {
                    GetWindowRgn((HWND)newCompactWinStruct[i].winID, hrgnNR);

                    //
                    // Clip the region to the window once again.
                    // THE COORDS ARE INCLUSIVE, SO ADD ONE TO BOTTOM-RIGHT
                    //
                    hrgnRect = CreateRectRgn(0, 0,
                        newCompactWinStruct[i].position.right -
                            newCompactWinStruct[i].position.left + 1,
                        newCompactWinStruct[i].position.bottom -
                            newCompactWinStruct[i].position.top + 1);

                    IntersectRgn(hrgnNR, hrgnNR, hrgnRect);

                    DeleteRgn(hrgnRect);

                    //
                    // Get the clipped region data.
                    //
                    // We have already excluded windows above that will
                    // return too large a size here, so we know we are only
                    // working with reasonable sizes now.
                    //
                    size = GetRegionData(hrgnNR, 0, NULL);

                    //
                    // For the moment we allocate memory each time for the
                    // region.  Perhaps a better idea would be to save the
                    // max size from when we previously queried the region
                    // sizes, and allocate just that size one outside the
                    // loop.
                    //
                    pRgnData = (LPRGNDATA) new BYTE[size];

                    if (pRgnData)
                    {
                        GetRegionData(hrgnNR, size, pRgnData);

                        //
                        // There is a possibility that regions will have
                        // changed since we calculated the amount of data
                        // required.  Before updating our structure with
                        // this window's region, check
                        // - the window hasn't become normal (ie 0 rects)
                        // - there is still enough space for the rects.
                        //
                        //
                        // Make sure this window still has regions
                        //
                        if (pRgnData->rdh.nCount == 0)
                        {
                            WARNING_OUT(( "No rects for window %#x",
                                    newCompactWinStruct[i].winID));
                            newCompactWinStruct[i].flags &=
                                                ~SWL_FLAG_WINDOW_NONRECTANGLE;

                            delete[] pRgnData;

                            //
                            // Move on to next window.
                            //
                            continue;
                        }

                        //
                        // Check we have enough space for the rects:
                        // - ourSize is the number of int16s required.
                        // - GetRegionData returns the number of
                        //   rectangles.
                        //
                        // We need one extra int16 to contain the count of
                        // rectangles.
                        //
                        ourSize = (pRgnData->rdh.nCount * 4) + 1;
                        if ((pOurRgnData + ourSize) > pEndRgnData)
                        {
                            WARNING_OUT(( "Can't fit %d int16s of region data",
                                    ourSize));
                            rgnOK = FALSE;
                            delete[] pRgnData;

                            //
                            // Give up processing regional windows.
                            //
                            break;
                        }

                        //
                        // Copy the data across to our SWL area in a more
                        // compact form.
                        //
                        // We take care to produce a compressible form
                        // because the raw data is essentially
                        // uncompressible via sliding window techniques.
                        // (Basically boils down to trying hard to make
                        // most values 0, or else of small magnitude).
                        //
                        //
                        // First we write the count of the number of
                        // rectangles.
                        //
                        *pOurRgnData++ = LOWORD(pRgnData->rdh.nCount);

                        //
                        // Now store the encoded rectangles.
                        //
                        lastleft        = 0;
                        lasttop         = 0;
                        lastright       = 0;
                        lastbottom      = 0;

                        lastdeltaleft   = 0;
                        lastdeltatop    = 0;
                        lastdeltaright  = 0;
                        lastdeltabottom = 0;

                        for ( k = 0; k < (UINT)pRgnData->rdh.nCount; k++ )
                        {
                            //
                            // Extract 16bit quantities from the data we
                            // were returned.
                            //
                            // We also use inclusive coords whereas Windows
                            // gives us exclusive coords.
                            //
                            left   = LOWORD(((LPRECT)(pRgnData->
                                                      Buffer))[k].left);
                            top    = LOWORD(((LPRECT)(pRgnData->
                                                      Buffer))[k].top);
                            right  = LOWORD(((LPRECT)(pRgnData->
                                                      Buffer))[k].right)  - 1;
                            bottom = LOWORD(((LPRECT)(pRgnData->
                                                      Buffer))[k].bottom) - 1;

                            //
                            // The rectangles are ordered top to bottom,
                            // left to right, so the deltas are of smaller
                            // magnitude than the values themselves.
                            //
                            deltaleft    = left   - lastleft;
                            deltatop     = top    - lasttop;
                            deltaright   = right  - lastright;
                            deltabottom  = bottom - lastbottom;

                            //
                            // In general, the left and right edges are
                            // connected lines, and the rectangles are of
                            // equal height so top/bottom are regular.
                            //
                            // Thus the values form a series which we can
                            // exploit to give a more compressible form.
                            //
                            // We already have the delta in each component,
                            // and these values themselves also form a
                            // series.  For a straight line series all the
                            // deltas will be the same, so the "delta in
                            // the delta" will be zero.  For a curve,
                            // although not all the deltas are the same,
                            // the "delta in the delta" is probably very
                            // small.
                            //
                            // A set of lots of zeros and small magnitude
                            // numbers is very compressible.
                            //
                            // Thus we store the "delta in the delta" for
                            // all components, rather than the values
                            // themselves.  The receiver can undo all the
                            // deltaing to arive back at the original
                            // values.
                            //
                            *pOurRgnData++ =
                                 (TSHR_UINT16)(deltaleft   - lastdeltaleft);
                            *pOurRgnData++ =
                                 (TSHR_UINT16)(deltatop    - lastdeltatop);
                            *pOurRgnData++ =
                                 (TSHR_UINT16)(deltaright  - lastdeltaright);
                            *pOurRgnData++ =
                                 (TSHR_UINT16)(deltabottom - lastdeltabottom);

                            //
                            // Update our last values.
                            //
                            lastleft        = left;
                            lasttop         = top;
                            lastright       = right;
                            lastbottom      = bottom;
                            lastdeltaleft   = deltaleft;
                            lastdeltatop    = deltatop;
                            lastdeltaright  = deltaright;
                            lastdeltabottom = deltabottom;
                        }

                        //
                        // Free the data now we are finished with it.
                        //
                        delete[] pRgnData;
                    }
                    else
                    {
                        //
                        // Failed to get memory for the rectangles, so the
                        // best we can do is use the bounding rect
                        //
                        // Clear the nonrect flag.
                        //
                        TRACE_OUT(("Failed alloc %d - use bounds", i));

                        newCompactWinStruct[i].flags &=
                                              ~SWL_FLAG_WINDOW_NONRECTANGLE;
                    }

                    if (newCompactWinStruct[i].flags & SWL_FLAG_WINDOW_LOCAL)
                    {
                        //
                        // The protocol defines that we will send a NULL
                        // winID for local windows, so NULL it out, now
                        // that we have finished with it.
                        //
                        newCompactWinStruct[i].winID = 0;
                    }
                }
            }
        }
        if (!rgnOK)
        {
            //
            // Something went wrong, one of:
            // - we failed to allocate the memory we need to store the
            //   non-rectangular data
            // - we allocated the memory but it turned out not to be large
            //   enough.
            //
            // Either way, best to act as if there is no such data for us.
            //
            if (pAllocRgnData == NULL)
            {
                WARNING_OUT(( "Failed to alloc %d for NRInfo", cNonRectData));
            }
            else
            {
                delete[] pAllocRgnData;
                pAllocRgnData = NULL;
            }
            cNonRectData = 0;

            //
            // Clear all the nonrect flags since we will not be sending any
            // data.
            //
            for ( i = 0; i < numCompactWins; i++)
            {
                newCompactWinStruct[i].flags &= ~SWL_FLAG_WINDOW_NONRECTANGLE;
            }
        }
    }


    //
    // Store the NR information
    //
    m_aswlNRSize[newIndex] = cNonRectData;
    m_aswlNRInfo[newIndex] = (LPTSHR_UINT16)pAllocRgnData;

    //
    // We have finished with the region now.
    //
    DeleteRgn(hrgnNR);

    //
    // Did the data we stored change from the last time?
    //
    fNonRectangularInfoChanged = ((m_aswlNRSize[0] != m_aswlNRSize[1]) ||
                                  (memcmp(m_aswlNRInfo[0], m_aswlNRInfo[1],
                                          m_aswlNRSize[0])));

    TRACE_OUT(("Non-rectinfo changed %d", fNonRectangularInfoChanged));

    //
    // Check again for no changes - quit if we can.
    //
    if (fNoTitlesChanged &&
        !fNonRectangularInfoChanged &&
        (m_aswlNumCompactWins[0] == m_aswlNumCompactWins[1]) &&
        (!memcmp(newCompactWinStruct,
                 curCompactWinStruct,
                 (numCompactWins*sizeof(SWLWINATTRIBUTES)))))
    {
        if (!m_swlfForceSend)
        {
            //
            // This is a normal call and we don't have any changes pending
            // so don't send anything.
            //
            TRACE_OUT(("NORMAL no changes, not sent"));
        }
        else
        {
            //
            // This is a normal call AND there are pending changes.
            //
            TRACE_OUT(( "NORMAL pending changes, send"));
            if (SWLSendPacket(&(m_aswlCompactWinStructs[m_swlCurIndex * SWL_MAX_WINDOWS]),
                                m_aswlNumCompactWins[m_swlCurIndex],
                                m_aswlWinNames[m_swlCurIndex],
                                m_aswlWinNamesSize[m_swlCurIndex],
                                m_aswlNRSize[m_swlCurIndex],
                                m_aswlNRInfo[m_swlCurIndex]) )
            {
                //
                // Succesfully sent this so reset the m_swlfForceSend
                // flag.
                //
                m_swlfForceSend = FALSE;
                fRC = SWL_RC_SENT;
            }
            else
            {
                //
                // Failed to send this packet so don't reset
                // m_swlfForceSend so that we retry next time and return
                // an error.
                //
                fRC = SWL_RC_ERROR;
            }
        }

        //
        // We can exit here with a changed full window structure but an
        // unchanged compact window structure. By updating the current
        // index we avoid having to compact the window structure next time
        // if the full list doesn't change, ie we will exit on the full
        // list comparison. If the compact structure subsequently changes
        // then the full structure must also change, so we will detect this
        // change.
        //
        m_swlCurIndex = newIndex;

        DC_QUIT;
    }

    //
    // Now the window structure has changed so decide what to do.
    //
    m_swlCurIndex = newIndex;

    //
    // The window structure has changed so try to send it.
    //
    if (SWLSendPacket(&(m_aswlCompactWinStructs[m_swlCurIndex * SWL_MAX_WINDOWS]),
                        m_aswlNumCompactWins[m_swlCurIndex],
                        m_aswlWinNames[m_swlCurIndex],
                        m_aswlWinNamesSize[m_swlCurIndex],
                        m_aswlNRSize[m_swlCurIndex],
                        m_aswlNRInfo[m_swlCurIndex]) )

    {
        //
        // We have succesfully sent changes so reset the m_swlfForceSend
        // flag.
        //
        m_swlfForceSend = FALSE;
        fRC = SWL_RC_SENT;
    }
    else
    {
        //
        // There were changes but we have failed to send them - set the
        // m_swlfForceSend flag and return error.
        // We must tell DCS scheduling that we need a callback BEFORE any
        // more changes are sent out.
        //
        m_swlfForceSend = TRUE;
        fRC = SWL_RC_ERROR;
    }

DC_EXIT_POINT:

    DebugExitDWORD(ASHost::SWL_Periodic, fRC);
    return(fRC);
}



//
// SWLEnumProc()
// Callback for top level window enumeration
//
BOOL CALLBACK SWLEnumProc(HWND hwnd, LPARAM lParam)
{
    PSWLENUMSTRUCT  pswlEnum = (PSWLENUMSTRUCT)lParam;
    UINT_PTR        property;
    UINT            windowProp;
    UINT            storedWindowProp;
    UINT            visibleCount;
    BOOL            fVisible;
    BOOL            rc = TRUE;

    DebugEntry(SWLEnumProc);

    //
    // FIRST, WE DETERMINE THE PROPERTIES FOR THE WINDOW.
    // Get the SWL properties for this window.
    //
    windowProp = (UINT)pswlEnum->pHost->SWL_GetWindowProperty(hwnd);

    //
    // We'll modify windowProp as we go, so keep a copy of the original
    // value as stored in the window as we may need it later.
    //
    storedWindowProp = windowProp;

    //
    // HET tracks whether a window is hosted. Find out now and add this
    // info to our window properties for convenience.
    //
    if (pswlEnum->pHost->m_pShare->HET_WindowIsHosted(hwnd))
    {
        windowProp |= SWL_PROP_HOSTED;
    }

    //
    // Find out whether this window is transparent.
    // A transparent window overpaints the desktop only, ie it is
    // overpainted by all other windows. In other words, we can
    // forget about it (treat it as invisible) unless a toolbar itself
    // is shared. The MSOffice95
    // hidden toolbar is a topmost transparent window (SFR1083).
    // Add a property flag if transparent.
    //
    if (GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_TRANSPARENT)
    {
        windowProp |= SWL_PROP_TRANSPARENT;
    }

    //
    // If this window is one that we have identified as generating no
    // remote shadows, then treat it as being invisible.
    //
    fVisible = FALSE;
    if (IsWindowVisible(hwnd) &&
        !(windowProp & SWL_PROP_IGNORE)     &&
        (!(windowProp & SWL_PROP_TRANSPARENT) || (windowProp & SWL_PROP_HOSTED)))
    {
        //
        // SFR1083: if the window is transparent but it is hosted,
        // we need to send it. In such a case we drop into here to do
        // the normal visibility processing and will handle
        // z-order issues later.
        //
        // We have been informed that a top level window is visible.
        // Make sure its visible countdown value is reset.
        //
        if ((pswlEnum->pHost->m_pShare->m_pasLocal->hetCount != 0) &&
            ((windowProp & SWL_PROP_COUNTDOWN_MASK) != SWL_BELIEVE_INVISIBLE_COUNT))
        {
            //
            // We were doing an invisibility countdown for this window
            // but it has re-visibilized, so reset the counter.
            //
            TRACE_OUT(( "Reset visible countdown on hwnd 0x%08x", hwnd));
            property = storedWindowProp;
            property &= ~SWL_PROP_COUNTDOWN_MASK;
            property |= SWL_BELIEVE_INVISIBLE_COUNT;

            SetProp(hwnd, SWL_ATOM_NAME, (HANDLE)property);
        }

        //
        // This window is visible
        //
        fVisible = TRUE;
    }
    else
    {
        //
        // LAURABU BOGUS!
        // With NM 3.0, who cares?  It's only 2.x systems that will kill
        // then recreate the shadow, causing flicker.
        //

        //
        // We are told that this top level window is invisible.
        // Check whether we're going to believe it.
        // Some applications (ie WordPerfect, Freelance Graphics)
        // upset AS-Shares window structure handling by doing something
        // like this:
        //
        //  Make a window invisible
        //  Do some processing which would not normally yield
        //  Make the window visible again
        //
        // There is a chance that DC-Share will get scheduled whilst
        // the window is invisible (because of our cunning scheduling)
        // and we will think the window is invisible when it is not.
        //
        // Also, 32bit tasks that use similar methods (Eg Word95,
        // Freelance graphics and WM_SETREDRAW messages) may be
        // interrupted while the window is (temporarily) marked as
        // invisible.  When the CORE is scheduled we may, again, think
        // that the window is invisible when it is not.
        //
        // To overcome this the SWL window property contains a
        // visibility count, initially set to
        // SWL_BELIEVE_INVISIBLE_COUNT. Following a visible to
        // invisible switch, the counter is decremented and only when
        // it reaches zero does SWL believe that the window is
        // invisible. The counter is reset when a window is detected as
        // visible and the counter is not SWL_BELIEVE_INVISIBLE_COUNT.
        //
        // This would be fine but there are windows when we mistakenly
        // pretend that a window which really has become invisible
        // (rather than one which is transitionally invisible) is
        // visible.  This is exposed by menus and dialog boxes.  To
        // reduce this problem we will never pretend a window is
        // visible if its class has a CS_SAVEBITS style which should
        // be the case for windows which are transitionally
        // visible like menus and dialog boxes.
        //
        // SFR1083: always treat a transparent window as invisible
        //
        if ( !(windowProp & SWL_PROP_TRANSPARENT) &&
             !(windowProp & SWL_PROP_SAVEBITS) )
        {
            visibleCount = windowProp & SWL_PROP_COUNTDOWN_MASK;
            if ((visibleCount != 0) && (pswlEnum->pHost->m_pShare->m_pasLocal->hetCount > 0))
            {
                //
                // We are still treating this window as visible, ie we
                // are doing a visibilty countdown. Update the count in
                // the window property.
                //
                visibleCount--;
                property = ~SWL_PROP_COUNTDOWN_MASK & storedWindowProp;
                property |= visibleCount;

                TRACE_OUT(( "Decrement visible countdown on window 0x%08x to %d",
                    hwnd, visibleCount));

                SetProp(hwnd, SWL_ATOM_NAME, MAKEINTATOM(property));

                //
                // Delay sending of updates since the remote still
                // has a window structure which includes this window
                // but it is not on the local screen (so any updates
                // sent may be for the area where this window was and
                // the remote will not show them).
                //
                pswlEnum->fBailOut = TRUE;
                rc = FALSE;
                DC_QUIT;
            }
        }
    }

    //
    // Only concerned about visible windows.
    //
    if (fVisible)
    {
        pswlEnum->pHost->SWL_InitFullWindowListEntry(hwnd, windowProp,
            &(pswlEnum->newWinNames),
            &(pswlEnum->newFullWinStruct[pswlEnum->count]));

        //
        // If we've added a transparent window then remember this.
        //
        if (windowProp & SWL_PROP_TRANSPARENT)
        {
            pswlEnum->transparentCount++;
        }

        //
        // Update index
        //
        pswlEnum->count++;
        if (pswlEnum->count == SWL_MAX_WINDOWS)
        {
            //
            // We've reached our limit on # of top level windows, so bail
            // out.
            //
            WARNING_OUT(("SWL_MAX_WINDOWS exceeded"));
            rc = FALSE;
        }
    }

DC_EXIT_POINT:
    DebugExitBOOL(SWLEnumProc, rc);
    return(rc);
}


//
// SWLSendPacket()
//
// Called when the shared apps of this node have changed shape/text/position/
// zorder or there have been new windows created/old shared windows destroyed.
// We must send these updates out to the remote systems.
//
// RETURNS: TRUE or FALSE - success of failure.
//
//
BOOL  ASHost::SWLSendPacket
(
    PSWLWINATTRIBUTES   pWindows,
    UINT                numWindows,
    LPSTR               pTitles,
    UINT                lenTitles,
    UINT                NRInfoSize,
    LPTSHR_UINT16       pNRInfo
)
{
    PSWLPACKET      pSWLPacket;
    UINT            sizeWindowPkt;
    UINT            i;
    LPSTR           pString;
    LPBYTE          pCopyLocation;
    UINT            cCopySize;
    SWLPACKETCHUNK  chunk;
#ifdef _DEBUG
    UINT            sentSize;
#endif // _DEBUG

    DebugEntry(ASHost::SWLSendPacket);

    if (m_pShare->m_pasLocal->hetCount != 0)
    {
        //
        // This is a real packet, not an empty one
        //
        if (!UP_MaybeSendSyncToken())
        {
            //
            // We needed to send a sync token and couldn't so just return
            // failure immediately.
            //
            TRACE_OUT(( "couldn't send sync token"));
            return(FALSE);
        }
    }

    //
    // How big a packet do we need?
    //
    sizeWindowPkt = sizeof(SWLPACKET) + (numWindows - 1) * sizeof(SWLWINATTRIBUTES)
                    + lenTitles;

    //
    // Add in the size of the regional window information, plus the
    // size we need for the chunk header.
    //
    if (NRInfoSize)
    {
        if (lenTitles & 1)
        {
            //
            // We need an extra byte for correct alignment
            //
            sizeWindowPkt++;
        }

        sizeWindowPkt += NRInfoSize + sizeof(SWLPACKETCHUNK);
    }

    //
    // Allocate a packet for the windows data.
    //
    pSWLPacket = (PSWLPACKET)m_pShare->SC_AllocPkt(PROT_STR_UPDATES, g_s20BroadcastID,
        sizeWindowPkt);
    if (!pSWLPacket)
    {
        WARNING_OUT(("Failed to alloc SWL packet, size %u", sizeWindowPkt));
        return(FALSE);
    }

    //
    // Packet successfully allocated.  Fill in the data and send it.
    //
    pSWLPacket->header.data.dataType = DT_SWL;

    pSWLPacket->msg   = SWL_MSG_WINSTRUCT;
    pSWLPacket->flags = 0;
    if (m_swlfSyncing)
    {
        pSWLPacket->flags |= SWL_FLAG_STATE_SYNCING;
        m_swlfSyncing = FALSE;
    }

    pSWLPacket->numWindows = (TSHR_UINT16)numWindows;

    pCopyLocation = (LPBYTE)pSWLPacket->aWindows;
    cCopySize     = numWindows*sizeof(SWLWINATTRIBUTES);
    memcpy(pCopyLocation, pWindows, cCopySize);

    //
    // Copy the title information
    //
    pCopyLocation += cCopySize;
    cCopySize      = lenTitles;
    memcpy(pCopyLocation, pTitles, cCopySize);

    //
    // Copy any non-rectangular window information.
    //
    if (NRInfoSize)
    {
        pCopyLocation += cCopySize;

        //
        // The chunk must be word aligned in the packet
        //
        if (lenTitles & 1)
        {
            //
            // An odd number of bytes of window titles has misaligned us,
            // so write a 0 (compresses best!) to realign the pointer.
            //
            *pCopyLocation++ = 0;
        }

        //
        // Write the chunk header
        //
        chunk.size    = (TSHR_INT16)(NRInfoSize + sizeof(chunk));
        chunk.idChunk = SWL_PACKET_ID_NONRECT;
        cCopySize  = sizeof(chunk);
        memcpy(pCopyLocation, &chunk, cCopySize);

        //
        // Now write the variable info itself
        //
        pCopyLocation += cCopySize;
        cCopySize      = NRInfoSize;
        memcpy(pCopyLocation, pNRInfo, cCopySize);

        TRACE_OUT(("Non rect data length %d",NRInfoSize));
    }

    //
    // Backwards compatibility.
    //
    pSWLPacket->tick     = (TSHR_UINT16)GetTickCount();
    pSWLPacket->token    = m_pShare->SWL_CalculateNextToken(m_pShare->m_swlLastTokenSeen);

    TRACE_OUT(("Updating m_swlLastTokenSeen to 0x%08x for sent packet",
        pSWLPacket->token));
    m_pShare->m_swlLastTokenSeen   = pSWLPacket->token;

    pSWLPacket->reserved = 0;

#ifdef _DEBUG
    {
        int                 iWin;
        int                 cWins;
        PSWLWINATTRIBUTES   pSwl;

        // Trace out the entries
        pSwl = pSWLPacket->aWindows;
        cWins = pSWLPacket->numWindows;

        TRACE_OUT(("SWLSendPacket: Sending packet with %d windows", cWins));
        for (iWin = 0; iWin < cWins; iWin++, pSwl++)
        {
            TRACE_OUT(("SWLSendPacket: Entry %d", iWin));
            TRACE_OUT(("SWLSendPacket:    Flags  %08x", pSwl->flags));
            TRACE_OUT(("SWLSendPacket:    Window %08x", pSwl->winID));
            TRACE_OUT(("SWLSendPacket:    Position {%04d, %04d, %04d, %04d}",
                pSwl->position.left, pSwl->position.top,
                pSwl->position.right, pSwl->position.bottom));
        }
    }
#endif // _DEBUG

    //
    // Send the windows packet on the UPDATE stream.
    //
    if (m_pShare->m_scfViewSelf)
        m_pShare->SWL_ReceivedPacket(m_pShare->m_pasLocal, &pSWLPacket->header);

#ifdef _DEBUG
    sentSize =
#endif // _DEBUG
    m_pShare->DCS_CompressAndSendPacket(PROT_STR_UPDATES, g_s20BroadcastID,
        &(pSWLPacket->header), sizeWindowPkt);

    TRACE_OUT(("SWL packet size: %08d, sent %08d", sizeWindowPkt, sentSize));

    DebugExitBOOL(ASHost::SWLSendPacket, TRUE);
    return(TRUE);
}



//
// SWL_CalculateNextToken()
//
// This calculates the next token to put in an outgoing SWL packet.  This is
// only looked at by backlevel systems (<= NM 2.1) who treat all incoming
// SWL streams in one big messy global fashion.  So we need to put something
// there, something that won't scare them but ensure that our
// packets aren't ignored if at all possible.
//
TSHR_UINT16  ASShare::SWL_CalculateNextToken(TSHR_UINT16 currentToken)
{
    UINT        increment;
    TSHR_UINT16 newToken;

    DebugEntry(ASShare::SWL_CalculateNextToken);

    //
    // We use the highest priority increment to make sure our packets get
    // through.  But will this cause collisions with other 3.0 sharers?
    // Try lowest priority if necessary.
    //
    increment = SWL_NEW_ZORDER_FAKE_WINDOW_INC;

    //
    // Return the new token
    //
    newToken = SWL_MAKE_TOKEN(
        SWL_GET_INDEX(currentToken) + SWL_GET_INCREMENT(currentToken), increment);

    DebugExitDWORD(ASShare::SWL_CalculateNextToken, newToken);
    return(newToken);
}


//
// SWL_ReceivedPacket()
//
// DESCRIPTION:
//
// Processes a windows structure packet which has been received from the
// PR.  This defines the position of the shared windows hosted on the
// remote system, any obscured regions, and the Z-order relative to the
// shared windows hosted locally.
//
// NOTE:  We don't do any token stuff for _incoming_ packets; we never
// want to drop them since we aren't zordering anything locally.  We are
// simply applying the zorder/region/position info to the client area
// drawing.
//
void  ASShare::SWL_ReceivedPacket
(
    ASPerson *          pasFrom,
    PS20DATAPACKET      pPacket
)
{
    PSWLPACKET          pSWLPacket;
    UINT                i;
    UINT                j;
    PSWLWINATTRIBUTES   wins;
    UINT                numWins;
    HRGN                hrgnShared;
    HRGN                hrgnObscured;
    HRGN                hrgnThisWindow;
    HRGN                hrgnRect;
    LPTSHR_INT16        pOurRgnData;
    LPSTR               pOurRgnChunk;
    UINT                cNonRectWindows;
    BOOL                viewAnyChanges;

    DebugEntry(ASShare::SWL_ReceivedPacket);

    ValidatePerson(pasFrom);

    pSWLPacket = (PSWLPACKET)pPacket;
    switch (pSWLPacket->msg)
    {
        //
        // This is the only packet we currently recognize.
        //
        case SWL_MSG_WINSTRUCT:
            break;

        default:
            WARNING_OUT(("Unknown SWL packet msg %d from [%d]",
                pSWLPacket->msg, pasFrom->mcsID));
            DC_QUIT;
    }

    //
    // Update the last token we've seen, if it's greater than the last
    // one we know about.  Unlike 2.x, we don't drop this packet if it isn't.
    //
    if (pSWLPacket->token > m_swlLastTokenSeen)
    {
        TRACE_OUT(("Updating m_swlLastTokenSeen to 0x%08x, received packet from person [%d]",
            pSWLPacket->token, pasFrom->mcsID));
        m_swlLastTokenSeen = pSWLPacket->token;
    }
    else if (pasFrom->cpcCaps.general.version < CAPS_VERSION_30)
    {
        WARNING_OUT(("Received SWL packet from [%d] with stale token 0x%08x",
            pasFrom->mcsID, pSWLPacket->token));
    }

    //
    // Return immediately and ignore this baby if we aren't sharing.  Back
    // level systems may send us a SYNC packet with no windows before we've
    // shared, and may send us one final SWL packet after we're done
    // sharing.
    //
    if (!pasFrom->m_pView)
    {
        WARNING_OUT(("SWL_ReceivedPacket: Ignoring SWL packet from person [%d] not hosting",
                pasFrom->mcsID));
        DC_QUIT;
    }

    //
    // Set up local variables to access the data in the packet
    //
    wins = pSWLPacket->aWindows;
    numWins = pSWLPacket->numWindows;
    pOurRgnChunk = (LPSTR)wins + numWins*sizeof(SWLWINATTRIBUTES);

    TRACE_OUT(("SWL_ReceivedPacket: Received packet with %d windows from [%d]",
        numWins, pasFrom->mcsID));

    //
    // We can't handle more than SWL_MAX_WINDOWS in the packet
    // BOGUS:
    // LauraBu -- We should negotiate this (make it a cap) on how many
    // windows we can handle receiving.  Then we have an easy path to
    // increase this number.
    //
    if (numWins > SWL_MAX_WINDOWS)
    {
        ERROR_OUT(("SWL_ReceivedPacket: too many windows (%04d) in packet from [%08d]",
            numWins, pasFrom->mcsID));
        DC_QUIT;
    }

    cNonRectWindows = 0;

    //
    // The first pass over the arriving packet is to count the amount of
    // region data and to update the window tray.
    //
    viewAnyChanges = FALSE;

    //
    // This part we process front to back, since that's the order of the
    // strings and we use them for putting entries on the traybar.
    //
    for (i = 0; i < numWins; i++)
    {
        // Mask out bogus old bits that aren't OK to process
        wins[i].flags &= SWL_FLAGS_VALIDPACKET;

        TRACE_OUT(("SWL_ReceivedPacket: Entry %d", i));
        TRACE_OUT(("SWL_ReceivedPacket:     Flags  %08x", wins[i].flags));
        TRACE_OUT(("SWL_ReceivedPacket:     Window %08x", wins[i].winID));
        TRACE_OUT(("SWL_ReceivedPacket:     Position {%04d, %04d, %04d, %04d}",
            wins[i].position.left, wins[i].position.top,
            wins[i].position.right, wins[i].position.bottom));

        //
        // NOTE:
        // 2.x nodes may send us a packet with an entry for a shadow.
        // Go look up the REAL shadow rect from its host.
        //
        // And fix up the SWL packet then.
        //
        if (wins[i].flags & SWL_FLAG_WINDOW_SHADOW)
        {
            ASPerson *  pasRealHost;

            TRACE_OUT(("SWLReceivedPacket:    Entry is 2.x SHADOW for host [%d]",
                wins[i].extra));

            // This must be a back level dude, giving us an empty rect.
            ASSERT(wins[i].position.left == 0);
            ASSERT(wins[i].position.top == 0);
            ASSERT(wins[i].position.right == 0);
            ASSERT(wins[i].position.bottom == 0);

            // Find the real host of this window
            SC_ValidateNetID(wins[i].extra, &pasRealHost);
            if (pasRealHost != NULL)
            {
                int         cSwl = 0;
                PSWLWINATTRIBUTES pSwl = NULL;

                // Try to find this window's entry

                if (pasRealHost == m_pasLocal)
                {
                    //
                    // This was shared by US.  We can just use the scratch
                    // arrays we already have.  m_swlCurIndex has the last
                    // one we sent out to everybody in the share, so the
                    // info it has is most likely reflected on that 2x
                    // remote.
                    //
                    if (m_pHost != NULL)
                    {
                        cSwl = m_pHost->m_aswlNumCompactWins[m_pHost->m_swlCurIndex];
                        pSwl = &(m_pHost->m_aswlCompactWinStructs[m_pHost->m_swlCurIndex * SWL_MAX_WINDOWS]);
                    }
                }
                else
                {
                    //
                    // This was shared by somebody else, not us and not
                    // the person who sent this SWL packet.  So go use the
                    // last SWL info we received from them.
                    //
                    if (pasRealHost->m_pView)
                    {
                        cSwl = pasRealHost->m_pView->m_swlCount;
                        pSwl = pasRealHost->m_pView->m_aswlLast;
                    }
                }

                //
                // Loop through the window list for the real host to
                // find the entry--we'll use the last REAL rect we got
                // for this window.
                //
                while (cSwl > 0)
                {
                    if (wins[i].winID == pSwl->winID)
                    {
                        // Copy the _real_ position into the packet.
                        TRACE_OUT(("SWLReceivedPacket:    Using real rect {%04d, %04d, %04d, %04d}",
                            pSwl->position.left, pSwl->position.top,
                            pSwl->position.right, pSwl->position.bottom));

                        wins[i].position = pSwl->position;
                        break;
                    }

                    cSwl--;
                    pSwl++;
                }

                if (cSwl == 0)
                {
                    ERROR_OUT(("SWLReceivedPacket:  Couldn't find real window %08x from host [%d]",
                        wins[i].winID, wins[i].extra));
                }
            }
        }

        //
        // 2.x nodes send us VD coords, not screen coords.  But that's what
        // we display for them, so that's what we save away.  Note that this
        // works even in the 2.x shadow case above.  Hosted and shadowed
        // windows both get moved in a desktop scroll, so they stay in the
        // same place in the virtual desktop, meaning that the coords sent
        // from the host stay the same even if the windows move, meaning that
        // we can use the coords of the real host to get the real shadow
        // rect.
        //

        if (wins[i].flags & SWL_FLAG_WINDOW_HOSTED)
        {
            TRACE_OUT(("SWL_ReceivedPacket: Hosted Window 0x%08x", wins[i].winID));
            TRACE_OUT(("SWL_ReceivedPacket:     Text  %s", ((*pOurRgnChunk == '\xff') ? "" : pOurRgnChunk)));
            TRACE_OUT(("SWL_ReceivedPacket:     Flags %08x", wins[i].flags));
            TRACE_OUT(("SWL_ReceivedPacket:     Owner %08x", wins[i].ownerWinID));
            TRACE_OUT(("SWL_ReceivedPacket:     Position {%04d, %04d, %04d, %04d}",
                wins[i].position.left, wins[i].position.top,
                wins[i].position.right, wins[i].position.bottom));

            //
            // We are stepping through the titles (which get sent from
            // downlevel systems) which do not contain an
            // explicit length) so that we can get to the data that follows
            //
            if (*pOurRgnChunk == '\xff')
            {
                //
                // This is the title for a non-task window - there is just
                // a single byte to ignore
                //
                pOurRgnChunk++;
            }
            else
            {

                //
                // This is the title for a task window - there is a NULL
                // terminated string to ignore.
                //
                if (wins[i].flags & SWL_FLAG_WINDOW_TASKBAR)
                {
                    if (VIEW_WindowBarUpdateItem(pasFrom, &wins[i], pOurRgnChunk))
                    {
                        viewAnyChanges = TRUE;
                    }
                }
                pOurRgnChunk += lstrlen(pOurRgnChunk)+1;
            }
        }

        if (wins[i].flags & SWL_FLAG_WINDOW_NONRECTANGLE)
        {
            //
            // We need to know how many windows have non rectangular data
            // provided.
            //
            cNonRectWindows++;
        }
    }

    if (cNonRectWindows)
    {
        TRACE_OUT(( "%d non-rect windows", cNonRectWindows));

        //
        // The window title data is variable length bytes, so may end with
        // incorrect alignment.  Any data which follows (currently only
        // non-rectangular windows data) is word aligned.
        //
        // So check if offset from beginning of data is not aligned.  Note
        // that the packet may start on an ODD boundary because we get
        // a pointer to the data directly and don't allocate a copy.
        //
        if ((LOWORD(pSWLPacket) & 1) != (LOWORD(pOurRgnChunk) & 1))
        {
            TRACE_OUT(("SWL_ReceivedPacket:  Aligning region data"));
            pOurRgnChunk++;
        }

        //
        // Loop through the tagged chunks that follow until we find the
        // one we want.
        //
        while (((PSWLPACKETCHUNK)pOurRgnChunk)->idChunk != SWL_PACKET_ID_NONRECT)
        {
            ERROR_OUT(("SWL_ReceivedPacket:  unknown chunk 0x%04x",
                ((PSWLPACKETCHUNK)pOurRgnChunk)->idChunk));

            pOurRgnChunk += ((PSWLPACKETCHUNK)pOurRgnChunk)->size;
        }

        TRACE_OUT(("Total non rect data 0x%04x", ((PSWLPACKETCHUNK)pOurRgnChunk)->size));
    }

    //
    // Now scan the wins array backwards (ie furthest away to closest
    // window) to calculate the unshared region (obscured or nothing there).
    // and the shared region.
    //
    hrgnShared = CreateRectRgn(0, 0, 0, 0);
    hrgnObscured = CreateRectRgn(0, 0, 0, 0);

    //
    // Create a region we can make use of in the next bit of processing.
    //
    hrgnRect = CreateRectRgn(0, 0, 0, 0);
    hrgnThisWindow = CreateRectRgn(0, 0, 0, 0);

    //
    // While we are building the shared/obscured regions, also fill in
    // the host list.  Note that this may contain references to local
    // windows also if they obscure shared ones.  Since we don't reference
    // the list very often, it's easier to just copy the same stuff.
    //

    i = numWins;
    while (i != 0)
    {
        i--;

        //
        // Consider whether this is a non rectangular window
        //
        if (wins[i].flags & SWL_FLAG_WINDOW_NONRECTANGLE)
        {
            UINT      numRects;
            UINT      cStepOver;
            int       top;
            int       left;
            int       right;
            int       bottom;
            int       lasttop;
            int       lastleft;
            int       lastright;
            int       lastbottom;
            int       deltaleft;
            int       deltatop;
            int       deltaright;
            int       deltabottom;
            int       lastdeltaleft;
            int       lastdeltatop;
            int       lastdeltaright;
            int       lastdeltabottom;

            //
            // A non-rectangular region.  We go ahead and create the region
            // from the rectangles that describe it.
            //
            pOurRgnData = (LPTSHR_INT16)(pOurRgnChunk + sizeof(SWLPACKETCHUNK));

            //
            // We need to step through the non-rectangular data because we
            // are processing windows in reverse z-order.
            //
            cStepOver = --cNonRectWindows;
            while (cStepOver--)
            {
                //
                // The next word in the chain contains the number of
                // rectangles, so we multiply by 4 to get the number of
                // words to advance.
                //
                pOurRgnData += *pOurRgnData++ * 4;
            }

            //
            // Find the number of rectangles.
            //
            numRects  = *pOurRgnData++;

            //
            // The encoding is based on a series of deltas, based on some
            // initial assumptions
            //
            lastleft        = 0;
            lasttop         = 0;
            lastright       = 0;
            lastbottom      = 0;

            lastdeltaleft   = 0;
            lastdeltatop    = 0;
            lastdeltaright  = 0;
            lastdeltabottom = 0;

            //
            // Create the region from the first rectangle.
            //
            deltaleft   = lastdeltaleft   + *pOurRgnData++;
            deltatop    = lastdeltatop    + *pOurRgnData++;
            deltaright  = lastdeltaright  + *pOurRgnData++;
            deltabottom = lastdeltabottom + *pOurRgnData++;

            left       = lastleft   + deltaleft;
            top        = lasttop    + deltatop;
            right      = lastright  + deltaright;
            bottom     = lastbottom + deltabottom;

            // THESE COORDS ARE INCLUSIVE, SO ADD ONE
            SetRectRgn(hrgnThisWindow, left, top, right+1, bottom+1);

            while (--numRects > 0)
            {

                //
                // Move to the next rectangle.
                //
                lastleft        = left;
                lasttop         = top;
                lastright       = right;
                lastbottom      = bottom;
                lastdeltaleft   = deltaleft;
                lastdeltatop    = deltatop;
                lastdeltaright  = deltaright;
                lastdeltabottom = deltabottom;

                deltaleft   = lastdeltaleft   + *pOurRgnData++;
                deltatop    = lastdeltatop    + *pOurRgnData++;
                deltaright  = lastdeltaright  + *pOurRgnData++;
                deltabottom = lastdeltabottom + *pOurRgnData++;

                left       = lastleft   + deltaleft;
                top        = lasttop    + deltatop;
                right      = lastright  + deltaright;
                bottom     = lastbottom + deltabottom;

                //
                // Get the current rectangle into a region.
                // THESE COORDS ARE INCLUSIVE SO ADD ONE TO BOTTOM-RIGHT
                //
                SetRectRgn(hrgnRect, left, top, right+1, bottom+1);

                //
                // Add this region to the combined region.
                //
                UnionRgn(hrgnThisWindow, hrgnRect, hrgnThisWindow);
            }

            //
            // Switch from window coords to desktop coords.
            //
            OffsetRgn(hrgnThisWindow,
                          wins[i].position.left,
                          wins[i].position.top);
        }
        else
        {
            //
            // This window region is simply a rectangle.

            SetRectRgn(hrgnThisWindow,
                           wins[i].position.left,
                           wins[i].position.top,
                           wins[i].position.right+1,
                           wins[i].position.bottom+1);
        }

        //
        // Update the obscured region.  As we are working from the back to
        // the front of the Z-order we can simply add all local window
        // entries in the incoming structure and subtract all hosted
        // windows to arrive at the right answer.
        //
        if (wins[i].flags & SWL_FLAG_WINDOW_HOSTED)
        {
            //
            // This is a hosted window, sitting above the previous ones.
            // Add it to the shared region.
            // Remove it from the obscured region.
            //
            UnionRgn(hrgnShared, hrgnShared, hrgnThisWindow);
            SubtractRgn(hrgnObscured, hrgnObscured, hrgnThisWindow);
        }
        else
        {
            //
            // Local windows
            //
            TRACE_OUT(( "Adding window %d (%d,%d):(%d,%d) to obscured rgn",
                                      i,
                                      wins[i].position.left,
                                      wins[i].position.top,
                                      wins[i].position.right,
                                      wins[i].position.bottom ));

            //
            // This is a local window, sitting above the previous ones.
            // We only care about what part of it intersects the current
            // shared area of the windows behind it.  If it doesn't
            // intersect the shared area at all, it will add no new
            // obscured bits.
            //
            // So figure out what part of the current shared area is now
            // obscured.  Add that piece to the obscured region, and
            // subtract it from the shared region.
            //
            IntersectRgn(hrgnThisWindow, hrgnShared, hrgnThisWindow);
            UnionRgn(hrgnObscured, hrgnObscured, hrgnThisWindow);
            SubtractRgn(hrgnShared, hrgnShared, hrgnThisWindow);
        }
    }

    //
    // We can destroy the regions we created way back when.
    //
    DeleteRgn(hrgnRect);
    DeleteRgn(hrgnThisWindow);

    //
    // Save the new host regions.
    //
    // Pass the newly calculated regions to the Shadow Window Presenter.
    // The view code will take care of repainting the invalid parts.  And
    // will delete what was passed in if not kept.
    //
    VIEW_SetHostRegions(pasFrom, hrgnShared, hrgnObscured);

    //
    // Save the new window list as the current one.
    //
    pasFrom->m_pView->m_swlCount = numWins;
    memcpy(pasFrom->m_pView->m_aswlLast, wins, numWins * sizeof(SWLWINATTRIBUTES));

    //
    // Finish updating the window list.  This will repaint the tray bar.  We
    // do this now instead of earlier so that the visual changes and
    // window bar changes appear together.
    //
    VIEW_WindowBarEndUpdateItems(pasFrom, viewAnyChanges);

    if ((pSWLPacket->flags & SWL_FLAG_STATE_SYNCING) &&
        (m_scShareVersion < CAPS_VERSION_30))
    {
        //
        // With 2.x nodes in the picture, we need to do the old 2.x ping-
        // pongy nonsense.  We must force a packet if we're hosting when
        // we receive a SYNC packet.
        //
        if (m_pHost)
        {
            m_pHost->m_swlfForceSend = TRUE;
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::SWL_ReceivedPacket);
}



//
// Name:      SWLWindowIsTaggable
//
// Purpose:   Determine if a window would be taggable when hosted
//
// Returns:   TRUE if the window would be taggable
//            If the window is WS_EX_APPWINDOW or has a caption, it's tagged
//
// Params:    winid - ID of window
//
//
BOOL  ASHost::SWLWindowIsTaggable(HWND hwnd)
{
    BOOL    rc;

    DebugEntry(ASHost::SWLWindowIsTaggable);

    if (GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_APPWINDOW)
        rc = TRUE;
    else if ((GetWindowLong(hwnd, GWL_STYLE) & WS_CAPTION) == WS_CAPTION)
        rc = TRUE;
    else
        rc = FALSE;

    DebugExitBOOL(ASHost::SWLWindowIsTaggable, rc);
    return(rc);
}


//
// FUNCTION: SWLWindowIsOnTaskBar
//
// DESCRIPTION:
//
// Determines whether the given window is represented on the task bar
//
// PARAMETERS:
//
// hwnd - window to be queried
//
// RETURNS:
//
// TRUE - Window is represented on the task bar
//
// FALSE - Window is not represented on the task bar
//
//
BOOL  ASHost::SWLWindowIsOnTaskBar(HWND hwnd)
{
    BOOL    rc = FALSE;
    HWND    owner;
    RECT    rect;

    DebugEntry(ASHost::SWLWindowIsOnTaskBar);

    //
    // Our best understanding as to whether a window is on the task bar is
    // the following:
    //
    //      - it is a top level window (has no owner)
    //  AND - it does not have the WS_EX_TOOLWINDOW style
    //
    // Oprah1655: Visual Basic apps consist of a visible zero sized window
    // with no owner and a window owned by the zero sized window.  We do
    // not want the zero sized window to be on the task bar, we do want the
    // other window to be on the task bar.
    //
    //
    owner = GetWindow(hwnd, GW_OWNER);

    if (owner == NULL)
    {
        if (!(GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_TOOLWINDOW))
        {
            GetWindowRect(hwnd, &rect);

            if ((rect.left < rect.right) &&
                (rect.top  < rect.bottom))
            {
                TRACE_OUT(("window 0x%08x allowed on task bar", hwnd));
                rc = TRUE;
            }
            else
            {
                TRACE_OUT(( "window 0x%08x zero sized", hwnd));
            }
        }
    }
    else
    {
        //
        // Is the owner window a top-level window of zero size?
        //
        if (GetWindow(owner, GW_OWNER) == NULL)
        {
            GetWindowRect(owner, &rect);

            if (IsRectEmpty(&rect))
            {
                TRACE_OUT(("HWND 0x%08x has zero sized top-level owner",
                       hwnd));
                rc = TRUE;
            }
        }
    }

    DebugExitDWORD(ASHost::SWLWindowIsOnTaskBar, rc);
    return(rc);
}




//
// SWL_GetWindowProperty()
//
UINT_PTR ASHost::SWL_GetWindowProperty(HWND hwnd)
{
    UINT_PTR properties;
    char    className[HET_CLASS_NAME_SIZE];

    DebugEntry(ASHost::SWL_GetWindowProperty);

    properties = (UINT_PTR)GetProp(hwnd, MAKEINTATOM(m_swlPropAtom));
    if (properties != SWL_PROP_INVALID)
        DC_QUIT;

    //
    // No property for this window - it must be new, so create its
    // initial property state.
    //

    //
    // Assign an initial value to the property, so we never set a property
    // of zero (which we reserve to indicate invalid).
    //
    properties = SWL_PROP_INITIAL;

    //
    // TAGGABLE IS FOR < 3.0 nodes only.
    //
    if (SWLWindowIsTaggable(hwnd))
    {
        properties |= SWL_PROP_TAGGABLE;
    }

    //
    // Get all the SWL info which is stored as a window property.
    //
    if (SWLWindowIsOnTaskBar(hwnd))
    {
        //
        // This class of window gets tagged.
        //
        properties |= SWL_PROP_TASKBAR;
    }

    //
    // Find out if the window class has the CS_SAVEBITS style.
    //
    if (GetClassLong(hwnd, GCL_STYLE) & CS_SAVEBITS)
    {
        //
        // This window's class has the CS_SAVEBITS style.
        //
        properties |= SWL_PROP_SAVEBITS;
    }

    //
    // Set the visibility count. This is 0 if the window is currently
    // invisible, SWL_BELIEVE_INVISIBLE_COUNT if visible.
    //
    if (IsWindowVisible(hwnd))
    {
        properties |= SWL_BELIEVE_INVISIBLE_COUNT;
    }

    //
    // Set the window property, which we will retrieve when SWL determines
    // whether it needs to resend the window structure.
    //
    if (m_pShare->m_pasLocal->hetCount > 0)
    {
        SetProp(hwnd, SWL_ATOM_NAME, (HANDLE)properties);
    }

DC_EXIT_POINT:
    DebugExitDWORD(ASHost::SWL_GetWindowProperty, properties);
    return(properties);
}



//
// FUNCTION: SWLDestroyWindowProperty
//
// DESCRIPTION:
//
// Destroys the window property for the supplied window.
//
// PARMETERS: winID - the window ID of the window for which the property is
//                    destroyed.
//
// RETURNS: Zero
//
//
BOOL CALLBACK SWLDestroyWindowProperty(HWND hwnd, LPARAM lParam)
{
    //
    // NOTE LAURABU:
    // We set the property using a string, which bumps up the ref count,
    // to work around a Win95 bug.  We therefore want to remove it using a
    // string, which bumps down the ref count.  Otherwise we will quickly
    // get a ref count overflow.
    //
    RemoveProp(hwnd, SWL_ATOM_NAME);
    return(TRUE);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\ssi.cpp ===
#include "precomp.h"


//
// SSI.CPP
// Save Screenbits Interceptor
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE




//
// SSI_HostStarting()
//
// Called when we start to host, figures out the max save bitmap bits size
// etc.
//
BOOL ASHost::SSI_HostStarting(void)
{
    DebugEntry(ASHost::SSI_HostStarting);

    m_pShare->SSI_RecalcCaps(TRUE);

    DebugExitBOOL(ASHost::SSI_HostStarting, TRUE);
    return(TRUE);
}



//
// SSI_ViewStarted()
//
// Called when someone we are viewing has started to host.  Creates save bits
// bitmap for them.
//
BOOL  ASShare::SSI_ViewStarting(ASPerson * pasPerson)
{
    BOOL                rc = FALSE;
    HDC                 hdcScreen = NULL;

    DebugEntry(ASShare::SSI_ViewStarting);

    ValidateView(pasPerson);

    //
    // ASSERT that this persons' variables are clear.
    //
    ASSERT(pasPerson->m_pView->m_ssiBitmapHeight == 0);
    ASSERT(pasPerson->m_pView->m_ssiBitmap == NULL);
    ASSERT(pasPerson->m_pView->m_ssiOldBitmap == NULL);

    //
    // Does this person support savebits?
    //
    if (!pasPerson->cpcCaps.orders.capsSendSaveBitmapSize)
    {
        // No receive SSI capability, bail out now.
        rc = TRUE;
        DC_QUIT;
    }

    //
    // Store the height of this host's bitmap.                             
    //
    pasPerson->m_pView->m_ssiBitmapHeight = (int)
        (pasPerson->cpcCaps.orders.capsSendSaveBitmapSize / TSHR_SSI_BITMAP_WIDTH);

    //
    // If the calculated bitmap size is not exactly divisible by the bitmap
    // width increase the bitmap height to fit in the partial row.         
    //
    if (pasPerson->cpcCaps.orders.capsSendSaveBitmapSize % TSHR_SSI_BITMAP_WIDTH)
    {
        pasPerson->m_pView->m_ssiBitmapHeight += pasPerson->cpcCaps.orders.capsSaveBitmapYGranularity;
    }

    TRACE_OUT(("Person [%d] SSI Bitmap height %d",
            pasPerson->mcsID,
            pasPerson->m_pView->m_ssiBitmapHeight));

    //
    // Create this host's save screen bitmap.                              
    //
    hdcScreen = GetDC(NULL);
    if (hdcScreen == NULL)
    {
        ERROR_OUT(( "Failed to get screen surface"));
        DC_QUIT;
    }

    //
    // Create the save screen bitmap DC.                                   
    //
    ASSERT(pasPerson->m_pView->m_ssiDC == NULL);
    pasPerson->m_pView->m_ssiDC = CreateCompatibleDC(hdcScreen);
    if (!pasPerson->m_pView->m_ssiDC)
    {
        ERROR_OUT(("Failed to create SSI DC"));
        DC_QUIT;
    }

    //
    // Create the save screen bitmap.
    //
    ASSERT(pasPerson->m_pView->m_ssiBitmap == NULL);
    pasPerson->m_pView->m_ssiBitmap = CreateCompatibleBitmap(hdcScreen,
            TSHR_SSI_BITMAP_WIDTH, pasPerson->m_pView->m_ssiBitmapHeight);
    if (!pasPerson->m_pView->m_ssiBitmap)
    {
        ERROR_OUT(("SSI_ViewStarting: can't create bitmap for person %x",
            pasPerson->mcsID));
            DC_QUIT;
    }

    //
    // Select the save screen bitmap into the DC
    //
    ASSERT(pasPerson->m_pView->m_ssiOldBitmap == NULL);
    pasPerson->m_pView->m_ssiOldBitmap = SelectBitmap(pasPerson->m_pView->m_ssiDC,
            pasPerson->m_pView->m_ssiBitmap);

    rc = TRUE;

DC_EXIT_POINT:

    if (hdcScreen != NULL)
    {
        ReleaseDC(NULL, hdcScreen);
    }

    DebugExitBOOL(ASShare::SSI_ViewStarting, rc);
    return(rc);
}



//
// SSI_ViewEnded()
//
// Called when someone we are viewing has stopped hosting, so we can clean
// up our view data for them.
//
void  ASShare::SSI_ViewEnded(ASPerson * pasPerson)
{
    DebugEntry(ASShare::SSI_ViewEnded);

    ValidateView(pasPerson);

    //
    // Deselect the save screen bitmap if there is one
    //
    if (pasPerson->m_pView->m_ssiOldBitmap != NULL)
    {
        SelectBitmap(pasPerson->m_pView->m_ssiDC, pasPerson->m_pView->m_ssiOldBitmap);
        pasPerson->m_pView->m_ssiOldBitmap = NULL;
    }

    //
    // Delete the save screen bitmap
    //
    if (pasPerson->m_pView->m_ssiBitmap != NULL)
    {
        DeleteBitmap(pasPerson->m_pView->m_ssiBitmap);
        pasPerson->m_pView->m_ssiBitmap = NULL;
    }

    //
    // Delete the save screen DC
    //
    if (pasPerson->m_pView->m_ssiDC != NULL)
    {
        DeleteDC(pasPerson->m_pView->m_ssiDC);
        pasPerson->m_pView->m_ssiDC = NULL;
    }

    DebugExitVOID(ASShare::SSI_ViewEnded);
}



//
// SSI_SyncOutgoing()
// Called when NEW (3.0) dude starts to share, a share is created, or 
// someone new joins the share.
// Resets save state for OUTGOING save/restore orders.
//
void  ASHost::SSI_SyncOutgoing(void)
{
    OSI_ESCAPE_HEADER request;

    DebugEntry(ASHost::SSI_SyncOutgoing);

    //
    // Discard any saved bitmaps.  This ensures that the subsequent        
    // datastream will not refer to any previously sent data.              
    //
    //
    // Make sure the display driver resets the save level.  Note we don't  
    // really care what happens in the display driver, so don't bother with
    // a special request block - use a standard request header.            
    //
    OSI_FunctionRequest(SSI_ESC_RESET_LEVEL, &request, sizeof(request));

    DebugExitVOID(ASHost::SSI_SyncOutgoing);
}



//
// FUNCTION: SSI_SaveBitmap                                                
//
// DESCRIPTION:
// Replays a SaveBitmap order by saving or restoring a specified area of
// the user's desktop bitmap.
//                                                                         
//
void  ASShare::SSI_SaveBitmap
(
    ASPerson *          pasPerson,
    LPSAVEBITMAP_ORDER  pSaveBitmap
)
{
    RECT            screenBitmapRect;
    RECT            saveBitmapRect;
    int             xSaveBitmap;
    int             ySaveBitmap;
    int             xScreenBitmap;
    int             yScreenBitmap;
    int             cxTile;
    int             cyTile;

    DebugEntry(ASShare::SSI_SaveBitmap);

    ValidateView(pasPerson);

    if ((pSaveBitmap->Operation != SV_SAVEBITS) &&
        (pSaveBitmap->Operation != SV_RESTOREBITS))
    {
        ERROR_OUT(("SSI_SaveBitmap: unrecognized SV_ value %d",
            pSaveBitmap->Operation));
        DC_QUIT;
    }

    //
    // Calculate the (x,y) start position from the pel start position      
    // given in the order.                                                 
    //
    ySaveBitmap = (pSaveBitmap->SavedBitmapPosition /
                  (TSHR_SSI_BITMAP_WIDTH *
                    (UINT)pasPerson->cpcCaps.orders.capsSaveBitmapYGranularity)) *
                pasPerson->cpcCaps.orders.capsSaveBitmapYGranularity;

    xSaveBitmap =  (pSaveBitmap->SavedBitmapPosition -
                  (ySaveBitmap *
                   (UINT)TSHR_SSI_BITMAP_WIDTH)) /
                pasPerson->cpcCaps.orders.capsSaveBitmapYGranularity;


    screenBitmapRect.left   = pSaveBitmap->nLeftRect
                              - pasPerson->m_pView->m_dsScreenOrigin.x;
    screenBitmapRect.top    = pSaveBitmap->nTopRect
                              - pasPerson->m_pView->m_dsScreenOrigin.y;
    screenBitmapRect.right  = pSaveBitmap->nRightRect + 1
                              - pasPerson->m_pView->m_dsScreenOrigin.x;
    screenBitmapRect.bottom = pSaveBitmap->nBottomRect + 1
                              - pasPerson->m_pView->m_dsScreenOrigin.y;
    saveBitmapRect.left     = 0;
    saveBitmapRect.top      = 0;
    saveBitmapRect.right    = TSHR_SSI_BITMAP_WIDTH;
    saveBitmapRect.bottom   = pasPerson->m_pView->m_ssiBitmapHeight;

    //
    // Start tiling in the top left corner of the Screen Bitmap rectangle. 
    //
    xScreenBitmap = screenBitmapRect.left;
    yScreenBitmap = screenBitmapRect.top;

    //
    // The height of the tile is the vertical granularity (or less - if    
    // the Screen Bitmap rect is thinner than the granularity).            
    //
    cyTile = min(screenBitmapRect.bottom - yScreenBitmap,
                 (int)pasPerson->cpcCaps.orders.capsSaveBitmapYGranularity );

    //
    // Repeat while there are more tiles in the Screen Bitmap rect to      
    // process.                                                            
    //
    while (yScreenBitmap < screenBitmapRect.bottom)
    {
        //
        // The width of the tile is the minimum of:                        
        //                                                                 
        // - the width of the remaining rectangle in the current strip of  
        //   the Screen Bitmap rectangle                                   
        //                                                                 
        // - the width of the remaining empty space in the current strip of
        //   the Save Bitmap                                               
        //                                                                 
        //
        cxTile = min( saveBitmapRect.right - xSaveBitmap,
                      screenBitmapRect.right - xScreenBitmap );

        TRACE_OUT(( "screen(%d,%d) save(%d,%d) cx(%d) cy(%d)",
                    xScreenBitmap,
                    yScreenBitmap,
                    xSaveBitmap,
                    ySaveBitmap,
                    cxTile,
                    cyTile ));

        //
        // Save or Restore this tile
        //
        if (pSaveBitmap->Operation == SV_SAVEBITS)
        {
            //
            // Save user's desktop area to SSI bitmap
            //
            BitBlt(pasPerson->m_pView->m_ssiDC,
                xSaveBitmap, ySaveBitmap, cxTile, cyTile,
                pasPerson->m_pView->m_usrDC,
                xScreenBitmap, yScreenBitmap, SRCCOPY);
        }
        else
        {
            //
            // Restore user's desktop area from SSI bitmap
            //
            BitBlt(pasPerson->m_pView->m_usrDC,
                xScreenBitmap, yScreenBitmap, cxTile, cyTile,
                pasPerson->m_pView->m_ssiDC,
                xSaveBitmap, ySaveBitmap, SRCCOPY);
        }

        //
        // Move to the next tile in the Screen Bitmap rectangle.           
        //
        xScreenBitmap += cxTile;
        if (xScreenBitmap >= screenBitmapRect.right)
        {
            xScreenBitmap = screenBitmapRect.left;
            yScreenBitmap += cyTile;
            cyTile = min( screenBitmapRect.bottom - yScreenBitmap,
                             (int)pasPerson->cpcCaps.orders.capsSaveBitmapYGranularity );
        }

        //
        // Move to the next free space in the Save Bitmap.                 
        //
        xSaveBitmap += ROUNDUP(cxTile, pasPerson->cpcCaps.orders.capsSaveBitmapXGranularity);
        if (xSaveBitmap >= saveBitmapRect.right)
        {
            xSaveBitmap = saveBitmapRect.left;
            ySaveBitmap += ROUNDUP(cyTile, pasPerson->cpcCaps.orders.capsSaveBitmapYGranularity);
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::SSI_SaveBitmap);
}



//
// SSI_RecalcCaps()
//
// Called when we are hosting and someone joins/leaves the share.
//
// When 2.x COMPAT IS GONE, THIS IS OBSOLETE
//
void  ASShare::SSI_RecalcCaps(BOOL fJoiner)
{
    ASPerson *  pasT;
    SSI_NEW_CAPABILITIES newCapabilities;

    DebugEntry(ASShare::SSI_RecalcCaps);

    if (!m_pHost)
    {
        //
        // Nothing to do.  Note that we recalc when someone joins AND
        // when someone leaves, like SBC.
        //
        DC_QUIT;
    }

    ValidatePerson(m_pasLocal);

    //
    // Enumerate all the save screen bitmap receive capabilities of the    
    // parties in the share.  The usable size of the send save screen      
    // bitmap is then the minimum of all the remote receive sizes and the  
    // local send size.                                                    
    //

    //
    // Copy the locally registered send save screen bitmap size capability 
    // to our global variable used to communicate with the enumeration     
    // function SSIEnumBitmapCacheCaps().                                  
    //
    m_pHost->m_ssiSaveBitmapSize = m_pasLocal->cpcCaps.orders.capsReceiveSaveBitmapSize;

    //
    // Now enumerate all the parties in the share and set our send bitmap  
    // size appropriately.                                                 
    //
    if (m_scShareVersion < CAPS_VERSION_30)
    {
        TRACE_OUT(("In share with 2.x nodes; must recalc SSI caps"));

        for (pasT = m_pasLocal->pasNext; pasT != NULL; pasT = pasT->pasNext)
        {
            //
            // Set the size of the local send save screen bitmap to the minimum of 
            // its current size and this party's receive save screen bitmap size.  
            //
            m_pHost->m_ssiSaveBitmapSize = min(m_pHost->m_ssiSaveBitmapSize,
                pasT->cpcCaps.orders.capsReceiveSaveBitmapSize);
        }

        TRACE_OUT(("Recalced SSI caps:  SS bitmap size 0x%08x",
            m_pHost->m_ssiSaveBitmapSize));
    }

    //
    // Set up the new capabilities structure...                            
    //
    newCapabilities.sendSaveBitmapSize = m_pHost->m_ssiSaveBitmapSize;

    newCapabilities.xGranularity       = TSHR_SSI_BITMAP_X_GRANULARITY;

    newCapabilities.yGranularity       = TSHR_SSI_BITMAP_Y_GRANULARITY;

    //
    // ... and pass it through to the driver.                              
    //
    if (!OSI_FunctionRequest(SSI_ESC_NEW_CAPABILITIES, (LPOSI_ESCAPE_HEADER)&newCapabilities,
                sizeof(newCapabilities)))
    {
        ERROR_OUT(("SSI_ESC_NEW_CAPABILITIES failed"));
    }

DC_EXIT_POINT:
    DebugExitVOID(ASHost::SSI_RecalcCaps);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\up.cpp ===
#include "precomp.h"


//
// UP.CPP
// Update Packager
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_NET



//
// UP_FlowControl()
// Checks if we've switched between slow and fast throughput
//
void  ASHost::UP_FlowControl(UINT newBufferSize)
{
    DebugEntry(ASHost::UP_FlowControl);

    if (newBufferSize > (LARGE_ORDER_PACKET_SIZE / 2))
    {
        if (m_upfUseSmallPackets)
        {
            m_upfUseSmallPackets = FALSE;
            TRACE_OUT(("UP_FlowControl:  FAST; use large packets"));
        }
    }
    else
    {
        if (!m_upfUseSmallPackets)
        {
            m_upfUseSmallPackets = TRUE;
            TRACE_OUT(("UP_FlowControl:  SLOW; use small packets"));
        }
    }

    DebugExitVOID(ASHost::UP_FlowControl);
}



//
// UP_Periodic()
//
// Called periodically, to send graphical updates as orders and/or screen
// data.
//
void ASHost::UP_Periodic(UINT currentTime)
{
    BOOL    fSendSD     = FALSE;
    BOOL    fSendOrders = FALSE;
    UINT    tmpTime;
    UINT    timeSinceOrders;
    UINT    timeSinceSD;
    UINT    timeSinceTrying;

    DebugEntry(ASHost::UP_Periodic);

    //
    // This is a
    // performance critical part of the scheduling so we apply some
    // heuristics to try and keep the overheads down.
    //
    // 1.If there was no back pressure last time then we check the
    //   rate of accumulation of screendata over the last period.
    //   If it was high then we apply a time slice to the sending
    //   of screendata.
    //
    // 2.If the rate of order accumulation was also high then we
    //   apply a timeslice to the order accumulation as well, just
    //   to avoid too high a CPU overhead trying to send orders
    //   when we will eventually fail to keep up.  We keep this
    //   time period low because the objective is simply to avoid
    //   sending hundreds of packets containing few orders each.
    //   (On the other hand, we want to send the single textout
    //   following a keystoke ASAP so we must not timeslice all the
    //   time.)
    //
    // 3.If neither orders nor screendata is piling up quickly then
    //   we do a full send immediately.
    //
    // 4.If there was back pressure on the last send then we still
    //   send orders, but always on the time slice, independent of
    //   the order accumulation rate.
    //
    // Note that we cannot sample the accumulation rates for every
    // pass because the app doing the drawing may be interrupted by
    // us for a few hundred milliseconds.  Therefore we only sample
    // the bounds every VOLUME_SAMPLE milliseconds.
    //
    //
    timeSinceSD      = currentTime - m_upLastSDTime;
    timeSinceOrders  = currentTime - m_upLastOrdersTime;
    timeSinceTrying  = currentTime - m_upLastTrialTime;

    //
    // Sample the accumulation rates.
    //
    m_upSDAccum     += BA_QueryAccumulation();
    m_upOrdersAccum += OA_QueryOrderAccum();

    //
    // Sample the throughput over the last period to see whether we
    // can operate in rapid respose mode or whether we should
    // timeslice.
    //
    if (timeSinceTrying > DCS_VOLUME_SAMPLE)
    {
        //
        // Take the newly accumulated deltas.
        //
        m_upDeltaSD     = m_upSDAccum;
        m_upDeltaOrders = m_upOrdersAccum;

        //
        // Store time of last retrieval.
        //
        m_upLastTrialTime = currentTime;

        //
        // Reset the running totals.
        //
        m_upSDAccum     = 0;
        m_upOrdersAccum = 0;
    }

    //
    // If we are way out of line then send updates.  Not that this
    // will reset the update timer independent of whether the send
    // works or not, so that we don't enter this arm continually
    // when we time out but are in a back pressure situation
    //
    // The long stop timer is there to catch apps that keep a
    // continual flow of orders/SD at above the suppression rate.
    // We want to tune our heuristics to avoid this, but if it
    // happens than we must send the data eventually.  The problem
    // is that this objective clashes with the scenario of the user
    // paging down twenty times, where our most efficient approach
    // is to let him run and snapshot the SD at the end, rather
    // than every PERIOD_LONG milliseconds.  (A screen snapshot
    // will stop the host for a second!).
    //
    if (timeSinceSD > DCS_SD_UPDATE_LONG_PERIOD)
    {
        fSendSD = TRUE;
    }
    else
    {
        //
        // We only disregard our time slicing if the rate of orders
        // and screendata is low enough to warrant it.  If the rate
        // is too high then hold off so that we can do some packet
        // consolidation.  If we had no back pressure last time or
        // the screendata rate is now low enough then try sending
        // SD as well as orders.
        //
        // The order threshold is measured in number of orders over
        // the period.  Screendata is measured in the total area
        // accumulated (prior to any spoiling).
        //
        if (!m_upBackPressure)
        {
            if (m_upDeltaOrders < DCS_ORDERS_TURNOFF_FREQUENCY)
            {
                fSendOrders = TRUE;
                if (m_upDeltaSD < DCS_BOUNDS_TURNOFF_RATE)
                {
                    if ((timeSinceSD < DCS_SD_UPDATE_SHORT_PERIOD) &&
                        (m_upDeltaSD > DCS_BOUNDS_IMMEDIATE_RATE))
                    {
                        fSendSD = FALSE;
                    }
                    else
                    {
                        fSendSD = TRUE;
                    }
                }
            }
        }

        //
        // Even in a back pressure situation we try and send orders
        // periodically to keep current.  If we overflow the order
        // buffer then we will constrain the buffer size to prevent
        // sending too many non-productive orders.  (But we dont
        // turn orders off because we still want the user to see
        // things happening.) Generally we send orders immediately,
        // provided the rate of accumulation is within the limits.
        // This test is to time slice orders if they are being
        // generated at a high rate.  The constant must be
        // reasonably small otherwise we force the order buffer to
        // overflow and order processing will be turned off.
        //
        if (!fSendSD && !fSendOrders)
        {
            if (timeSinceOrders > DCS_ORDER_UPDATE_PERIOD)
            {
                fSendOrders = TRUE;
            }
        }
    }

    //
    // Now we can go ahead and try sending!  First look to see if
    // we can do both screendata and orders
    //
    if (fSendSD)
    {
        //
        // Indicate no back pressure (even if this send is
        // triggered by a timout our initial assumption is no back
        // pressure).  Back pressure will be reinstated by
        // SendUpdates if necessary.
        //
        m_upBackPressure = FALSE;
        UPSendUpdates();

        //
        // Sending screendata can take a long time.  It messes up
        // our heuristics unless we adjust for it.
        //
        tmpTime = GetTickCount();
        timeSinceTrying    -= (tmpTime - currentTime);
        m_pShare->m_dcsLastScheduleTime   = tmpTime;
        m_upLastSDTime          = tmpTime;
        m_upLastOrdersTime      = tmpTime;
    }
    else
    {
        if (fSendOrders)
        {
            //
            // Either the update rate is too high or we are
            // experiencing back pressure so just send the orders
            // and not the screendata.  This is because we want to
            // avoid entering screendata mode as a result of order
            // back pressure for as long as we can.  The screendata
            // will come later, when things have settled down a bit
            //
            m_upLastOrdersTime = currentTime;
            m_upBackPressure = TRUE;
            if (!UPSendUpdates())
            {
                //
                // This is the only real action so leave all the
                // tracing separate for cleanliness.  If there are
                // orders in transit then everything is fine.  If none
                // are sent for a while then we want to break out of
                // our SD back pressure wait.  This is because we are
                // only sampling the flow rates every DCS_VOLUME_SAMPLE msecs,
                // but we dont want to have to wait that long to flush the SD.
                // We cannot increase the flow sample rate because then
                // it becomes too erratic because of system scheduling.
                //
                m_upBackPressure = FALSE;
                UPSendUpdates();
                m_upLastSDTime   = currentTime;
            }
        }
    }

    DebugExitVOID(ASHost::UP_Periodic);
}




//
// UPSendUpdates()
// Actually tries to allocate and send orders + screen data.  What it does
// depends on
//      * Presence of back-pressure due to previous send failures
//      * How much screen data & orders there are
//      * Whether we're in serious spoiling mode and can't keep up
//      * What packet size to send
//
// Returns:
//      # of packets sent
//
UINT ASHost::UPSendUpdates(void)
{
    BOOL    synced;
    BOOL    ordersSent;
    UINT    numPackets = 0;

    DebugEntry(ASHost::UPSendUpdates);

    //
    // If we actually have updates to send then try to send a sync token.
    //
    if ((OA_GetTotalOrderListBytes() > 0) ||
        (m_sdgcLossy != 0) ||
        (m_baNumRects > 0))
    {
        synced = UP_MaybeSendSyncToken();

        //
        // Only send updates if we have sent the sync token succesfully.
        //
        if (synced)
        {
            //
            // There is no outstanding sync token waiting to be sent, so we
            // can send the orders and screen data updates.
            //
            //
            // Send accumulated orders.  If this call fails (probably out
            // of memory) then don't send any other updates - we'll try
            // sending the whole lot later.  The orders MUST be sent before
            // the screen data.
            //
            if (PM_MaybeSendPalettePacket())
            {
                ordersSent = UPSendOrders(&numPackets);
                if (!ordersSent)
                {
                    m_upBackPressure = TRUE;
                }
                else
                {
                    //
                    // Orders sent OK so go for the screendata, provided
                    // the caller wants us to.
                    //
                    if (!m_upBackPressure)
                    {
                        //
                        // We may now try and send screen data.  However,
                        // we need to be careful not to do this too
                        // frequently, because DC-Share is now being
                        // scheduled to send as soon as network buffers
                        // become available.  On the other hand, some
                        // apps respond to keystrokes with screendata so
                        // we cannot just slow it down!
                        //
                        // The approach is to have SendScreenDataArea
                        // return the amount of data sent, together with
                        // an indication as to whether we hit back pressure
                        //
                        // We return these to dcsapi which has control of
                        // when we are scheduled and passes the paramaters
                        // in again
                        //
                        //
                        TRACE_OUT(( "Sending SD"));
                        SDG_SendScreenDataArea(&m_upBackPressure, &numPackets);
                    }
                    else
                    {
                        //
                        // We sent the orders OK an so we must reset
                        // the back pressure indicator even though we
                        // were asked not to send screendata
                        //
                        TRACE_OUT(( "Orders sent and BP relieved"));
                        m_upBackPressure = FALSE;
                    }
                }
            }
        }
    }
    else
    {
        m_upBackPressure = FALSE;
    }

    DebugExitDWORD(ASHost::UPSendUpdates, numPackets);
    return(numPackets);
}



//
// UP_MaybeSendSyncToken()
//
BOOL  ASHost::UP_MaybeSendSyncToken(void)
{
    PUPSPACKET  pUPSPacket;
#ifdef _DEBUG
    UINT        sentSize;
#endif // _DEBUG

    DebugEntry(ASHost::UP_MaybeSendSyncToken);

    //
    // Check to see if we should send a sync token.
    //
    if (m_upfSyncTokenRequired)
    {
        //
        // The sync packet consists of an updates packets as far as the end
        // of the header.
        //
        pUPSPacket = (PUPSPACKET)m_pShare->SC_AllocPkt(PROT_STR_UPDATES,
            g_s20BroadcastID, sizeof(UPSPACKET));
        if (!pUPSPacket)
        {
            //
            // We will try again later.
            //
            TRACE_OUT(("Failed to alloc UP sync packet"));
        }
        else
        {
            //
            // Fill in the packet contents.
            //
            pUPSPacket->header.header.data.dataType = DT_UP;
            pUPSPacket->header.updateType = UPD_SYNC;

            //
            // Now send the packet to the remote application.
            //
            if (m_pShare->m_scfViewSelf)
                m_pShare->UP_ReceivedPacket(m_pShare->m_pasLocal,
                    &(pUPSPacket->header.header));

#ifdef _DEBUG
            sentSize =
#endif // _DEBUG
            m_pShare->DCS_CompressAndSendPacket(PROT_STR_UPDATES,
                g_s20BroadcastID, &(pUPSPacket->header.header),
                sizeof(*pUPSPacket));

            TRACE_OUT(("UP SYNC packet size: %08d, sent %08d",
                sizeof(*pUPSPacket), sentSize));

            //
            // The sync packet was successfully sent.
            //
            m_upfSyncTokenRequired = FALSE;
        }
    }

    DebugExitBOOL(ASHost::UP_MaybeSendSyncToken, (!m_upfSyncTokenRequired));
    return(!m_upfSyncTokenRequired);
}



//
// UPSendOrders(..)
//
// Sends all accumulated orders.
//
// Returns:
//   TRUE if all orders successfully sent
//   FALSE if send failed (e.g.  if unable to allocate network packet)
//
//
BOOL  ASHost::UPSendOrders(UINT * pcPackets)
{
    PORDPACKET      pPacket = NULL;
    UINT            cbOrderBytes;
    UINT            cbOrderBytesRemaining;
    UINT            cbPacketSize;
    BOOL            rc = TRUE;
#ifdef _DEBUG
    UINT            sentSize;
#endif // _DEBUG

    DebugEntry(ASHost::UPSendOrders);

    //
    // Find out how many bytes of orders there are in the Order List.
    //
    cbOrderBytesRemaining = UPFetchOrdersIntoBuffer(NULL, NULL, NULL);

    //
    // Process any orders on the list.
    //
    if (cbOrderBytesRemaining > 0)
    {
        TRACE_OUT(( "%u order bytes to fetch", cbOrderBytesRemaining));

        //
        // Keep sending packets while there are some orders to do.
        //
        while (cbOrderBytesRemaining > 0)
        {
            UINT    cbMax;
            //

            // Make sure the order size does not exceed the max packet
            // size.
            //
            cbMax = (m_upfUseSmallPackets) ? SMALL_ORDER_PACKET_SIZE :
                                             LARGE_ORDER_PACKET_SIZE;

            cbPacketSize = min(cbOrderBytesRemaining,
                (cbMax - sizeof(ORDPACKET) + 1));

            //
            // Allocate a packet to send the data in.
            //
            pPacket = (PORDPACKET)m_pShare->SC_AllocPkt(PROT_STR_UPDATES, g_s20BroadcastID,
                sizeof(ORDPACKET) + cbPacketSize - 1);
            if (!pPacket)
            {
                //
                // Failed to allocate a packet.  We skip out immediately -
                // we'll try again later.
                //
                TRACE_OUT(("Failed to alloc UP order packet, size %u",
                    sizeof(ORDPACKET) + cbPacketSize - 1));
                rc = FALSE;
                DC_QUIT;
            }

            //
            // Transfer as many orders into the packet as will fit.
            //
            cbOrderBytes = cbPacketSize;
            cbOrderBytesRemaining = UPFetchOrdersIntoBuffer(
                pPacket->data, &pPacket->cOrders, &cbOrderBytes);

            TRACE_OUT(( "%u bytes fetched into %u byte pkt. %u remain.",
                cbOrderBytes, cbPacketSize, cbOrderBytesRemaining));

            //
            // If no order bytes were transferred then try again with a
            // Large Order Packet.
            //
            if (cbOrderBytes == 0)
            {
                //
                // We need to use a larger packet to transfer the
                // orders into.  (The first order must be a very large
                // order such as a large bitmap cache update).
                //
                S20_FreeDataPkt(&(pPacket->header.header));

                //
                // cbOrderBytesRemaining may not accurate if there are
                // any MemBlt orders in the order heap.  This is
                // because we may have to insert a color table order
                // and / or a bitmap bits order before the MemBlt.
                //
                // To avoid getting into an infinite loop if there is
                // only a MemBlt remaining but we actually have to send
                // a color table and / or a bitmap bits order
                // (cbOrderBytesRemaining would never get set high
                // enough to allow us to send the color table / bitmap
                // bits order), make the buffer at least large enough
                // to hold the largest amount of data required for all
                // the parts of a MemBlt.
                //

                //
                // The maximum number of bytes required to send a MemBlt order.  This is
                //   The size of the largest possible color table order
                //   + the size of the largest possible bitmap bits order
                //   + the size of the largest MemBlt order.
                //
                cbPacketSize = sizeof(BMC_COLOR_TABLE_ORDER)    +
                        (256 * sizeof(TSHR_RGBQUAD))            +
                        sizeof(BMC_BITMAP_BITS_ORDER_R2)        +
                        sizeof(MEM3BLT_R2_ORDER)                +
                        MP_CACHE_CELLSIZE(MP_LARGE_TILE_WIDTH, MP_LARGE_TILE_HEIGHT,
                            m_usrSendingBPP);
                cbPacketSize = max(cbPacketSize, cbOrderBytesRemaining);

                if (cbPacketSize > (UINT)(LARGE_ORDER_PACKET_SIZE -
                        sizeof(ORDPACKET) + 1))
                {
                    TRACE_OUT(("Too many order bytes for large packet(%d)",
                                                      cbOrderBytesRemaining));
                    cbPacketSize = LARGE_ORDER_PACKET_SIZE -
                        sizeof(ORDPACKET) + 1;
                }

                pPacket = (PORDPACKET)m_pShare->SC_AllocPkt(PROT_STR_UPDATES,
                    g_s20BroadcastID, sizeof(ORDPACKET) + cbPacketSize - 1);
                if (!pPacket)
                {
                    TRACE_OUT(("Failed to alloc UP order packet, size %u",
                        sizeof(ORDPACKET) + cbPacketSize - 1));
                    rc = FALSE;
                    DC_QUIT;
                }

                //
                // Transfer as many orders into the packet as will
                // fit.
                //
                cbOrderBytes = cbPacketSize;
                cbOrderBytesRemaining = UPFetchOrdersIntoBuffer(
                    pPacket->data, &pPacket->cOrders, &cbOrderBytes );

                //
                // If no orders were transferred then something has
                // gone wrong.  Probably flow control kicked in or
                // a dekstop switch occurred.
                //      Return failure now!
                // Hopefully things will sort themselves out later
                // or we will resort to sending updates as screen
                // data once the order accumulation heap becomes
                // full.
                //
                if (cbOrderBytes == 0)
                {
                    WARNING_OUT(("No orders fetched into %u byte packet, %u bytes left",
                        cbPacketSize, cbOrderBytesRemaining));
                    S20_FreeDataPkt(&(pPacket->header.header));
                    rc = FALSE;
                    DC_QUIT;
                }
            }

            //
            // Fill in the packet header.
            //
            pPacket->header.header.data.dataType     = DT_UP;
            pPacket->header.updateType          = UPD_ORDERS;
            pPacket->sendBPP                    = (TSHR_UINT16)m_usrSendingBPP;

            //
            // If encoding is switched on, update the data size to reflect
            // it with encoded orders
            //
            if (m_pShare->m_oefOE2EncodingOn)
            {
                pPacket->header.header.dataLength = sizeof(ORDPACKET) + cbOrderBytes - 1
                    - sizeof(S20DATAPACKET) + sizeof(DATAPACKETHEADER);
            }

            //
            // Now send it.
            //
            if (m_pShare->m_scfViewSelf)
                m_pShare->UP_ReceivedPacket(m_pShare->m_pasLocal,
                        &(pPacket->header.header));

#ifdef _DEBUG
            sentSize =
#endif // _DEBUG
            m_pShare->DCS_CompressAndSendPacket(PROT_STR_UPDATES, g_s20BroadcastID,
                &(pPacket->header.header), sizeof(ORDPACKET) + cbOrderBytes - 1);

            TRACE_OUT(("UP ORDERS packet size: %08d, sent %08d",
                sizeof(ORDPACKET) + cbOrderBytes - 1, sentSize));

            ++(*pcPackets);
        }
    }

DC_EXIT_POINT:
    DebugExitBOOL(ASHost::UPSendOrders, rc);
    return(rc);
}

//
//
// UPFetchOrdersIntoBuffer(..)
//
// Encodes orders from the Order List and copies them into the supplied
// buffer, then frees up the memory of each order copied.
//
// Orders are copied until the buffer is full or there are no more orders.
//
// Returns:
//   The number of order bytes that were NOT returned.
//   i.e.  0 if all orders were returned.
//   A simple way to find out the total number of order bytes
//   in the Order List is to call the function with a buffer length
//   of zero.
//
//   *pcbBufferSize is updated to contain the total number of bytes
//   returned.
//
//
UINT  ASHost::UPFetchOrdersIntoBuffer
(
    LPBYTE          pBuffer,
    LPTSHR_UINT16   pcOrders,
    LPUINT          pcbBufferSize
)
{
    LPINT_ORDER     pListOrder;
    LPINT_ORDER     pCurrentOrder;
    UINT            cbFreeBytesInBuffer;
    UINT            cOrdersCopied;
    LPBYTE          pDst;
    UINT            cbOrderSize;
    UINT            ulRemainingOrderBytes;
    BOOL            processingMemBlt;

    DebugEntry(ASHost::UPFetchOrdersIntoBuffer);

    //
    // Make a quick exit if the Order List length is being queried.
    //
    if ( (pcbBufferSize == NULL) ||
         (*pcbBufferSize == 0) )
    {
        goto fetch_orders_exit;
    }

    //
    // Initialize the buffer pointer and size.
    //
    pDst = pBuffer;
    cbFreeBytesInBuffer = *pcbBufferSize;

    //
    // Keep a count of the number of orders we copy.
    //
    cOrdersCopied = 0;

    //
    // Return as many orders as possible.
    //
    pListOrder = OA_GetFirstListOrder();
    TRACE_OUT(( "First order: 0x%08x", pListOrder));
    while (pListOrder != NULL)
    {
        if (pListOrder->OrderHeader.Common.fOrderFlags & OF_INTERNAL)
        {
            //
            // This is an internal order.  Currently SBC is the only
            // component to use internal orders, so get SBC to process it.
            //
            SBC_ProcessInternalOrder(pListOrder);

            //
            // Internal order must not get sent over the wire, so skip on
            // to the next order
            //
            pListOrder = OA_RemoveListOrder(pListOrder);
            continue;
        }

        if (ORDER_IS_MEMBLT(pListOrder) || ORDER_IS_MEM3BLT(pListOrder))
        {
            //
            // This is a MEMBLT or a MEM3BLT so we have to do some extra
            // processing...  This function returns us a pointer to the
            // next order which should be sent - this will often not be the
            // MEMBLT, but a color table order or a bitmap bits order.
            //
            if (!SBC_ProcessMemBltOrder(pListOrder, &pCurrentOrder))
            {
                //
                // This can fail if
                //      * we're low on memory
                //      * we changed from 8BPP to 24BPP sending, because
                //          somebody left the share, and we have queued up
                //          SBC orders that we can no longer process.
                //
                TRACE_OUT(("Failed to process SBC order, fall back to SDG"));
                pListOrder = OA_RemoveListOrder(pListOrder);
                continue;
            }

            processingMemBlt = TRUE;
        }
        else
        {
            //
            // This isn't a MEMBLT or a MEM3BLT - just set pCurrentOrder to
            // be pListOrder
            //
            pCurrentOrder    = pListOrder;
            processingMemBlt = FALSE;
        }

        if (m_pShare->m_oefOE2EncodingOn)
        {
            //
            // Encoding is switched on.
            // Encode the order into the next free space in the buffer
            //
            cbOrderSize = OE2_EncodeOrder( pCurrentOrder,
                                           pDst,
                                           (TSHR_UINT16)cbFreeBytesInBuffer );
            TRACE_OUT(( "Encoded size, %u bytes", cbOrderSize));
        }
        else
        {
            //
            // Copy the order into the buffer.
            //
            cbOrderSize = COM_ORDER_SIZE(
                        ((LPCOM_ORDER)(&(pCurrentOrder->OrderHeader.Common))));

            if (cbOrderSize <= cbFreeBytesInBuffer)
            {
                memcpy(pDst,
                         (LPCOM_ORDER)(&(pCurrentOrder->OrderHeader.Common)),
                         cbOrderSize);
            }
            else
            {
                //
                // No room for this order in this packet.
                //
                cbOrderSize = 0;
            }
        }

        //
        // Check whether the order was copied into the buffer.
        //
        if (cbOrderSize == 0)
        {
            //
            // The order was too big to fit in this buffer.
            // Exit the loop - this order will go in the next packet.
            //
            break;
        }

        //
        // Update the buffer pointer past the encoded order.
        //
        pDst                += cbOrderSize;
        cbFreeBytesInBuffer -= cbOrderSize;
        cOrdersCopied++;

        if (processingMemBlt)
        {
            //
            // If we are processing a MEMBLT order, we have to notify SBC
            // that we've dealt with it successfully so that it returns us
            // a different order next time.
            //
            SBC_OrderSentNotification(pCurrentOrder);
        }

        if (pCurrentOrder == pListOrder)
        {
            //
            // We successfully copied the order into the buffer - on to the
            // next one UNLESS we haven't processed the last one we picked
            // out of the order list i.e.  pCurrentOrder is not the same as
            // pListOrder.  This will happen if we just processed a color
            // table order or a bitmap bits order returned from
            // SBC_ProcessMemBltOrder (if we processed the MEMBLT itself,
            // we can safely move on to the next order).
            //
            pListOrder = OA_RemoveListOrder(pListOrder);
        }
    }

    //
    // Fill in the packet header.
    //
    if (pcOrders != NULL)
    {
        *pcOrders = (TSHR_UINT16)cOrdersCopied;
    }

    //
    // Update the buffer size to indicate how much data we have
    // written.
    //
    *pcbBufferSize -= cbFreeBytesInBuffer;

    TRACE_OUT(( "Returned %d orders in %d bytes",
                 cOrdersCopied,
                 *pcbBufferSize));

fetch_orders_exit:
    //
    // Return the number of bytes still to be processed
    //
    ulRemainingOrderBytes = OA_GetTotalOrderListBytes();

    DebugExitDWORD(ASHost::UPFetchOrdersIntoBuffer, ulRemainingOrderBytes);
    return(ulRemainingOrderBytes);
}



//
// UP_ReceivePacket()
//
void  ASShare::UP_ReceivedPacket
(
    ASPerson *      pasPerson,
    PS20DATAPACKET  pPacket
)
{
    PUPPACKETHEADER pUPPacket;

    DebugEntry(ASShare::UP_ReceivedPacket);

    ValidatePerson(pasPerson);

    if (!pasPerson->m_pView)
    {
        //
        // Updates for parties which we don't recognise as hosts are just
        // discarded.
        //

        // NOTE:
        // 2.0 Win95 does not have HET, where we kick off sharing/unsharing.
        // But it did have TT, and the packet type/messages were defined
        // cleverly for HET so that 2.0 Win95 works the same.  When they
        // start to share, we get a PT_TT packet with a non-zero count.
        // The difference really is that the number is apps for Win95 2.0
        // and HWNDs for everybody else.
        //
        WARNING_OUT(("UP_ReceivedUpdates:  Ignoring updates from person [%d] not hosting",
            pasPerson->mcsID));

        DC_QUIT;
    }

    pUPPacket = (PUPPACKETHEADER)pPacket;
    switch (pUPPacket->updateType)
    {
        case UPD_SCREEN_DATA:
            SDP_ReceivedPacket(pasPerson, pPacket);
            break;

        case UPD_ORDERS:
            OD_ReceivedPacket(pasPerson, pPacket);
            break;

        case UPD_PALETTE:
            PM_ReceivedPacket(pasPerson, pPacket);
            break;

        case UPD_SYNC:
            //
            // We need to reset our INCOMING decoding info since the sender
            // resets his OUTGOING encoding info for a sync.
            //
            OD2_SyncIncoming(pasPerson);

            //
            // NOTE:
            // We do not need to reset INCOMING data for
            //      PM  -- the host won't send us old palette references
            //      RBC -- the host won't send us old bitmap references.
            //             Even though it would be nice to delete the existing
            //              bitmaps, recreating the cache is a hassle.
            //      CM  -- the host won't send us old cursor references
            //      SSI -- the host won't send us old savebits references
            //
            break;

        default:
            ERROR_OUT(("Unknown UP packet type %u from [%d]",
                    pUPPacket->updateType,
                    pasPerson->mcsID));
            break;
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::UP_ReceivedPacket);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\usr.cpp ===
#include "precomp.h"


//
// USR.CPP
// Update Sender/Receiver
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_NET

//
// USR strategy when network packets cannot be allocated.
//
// The USR sends three different types of packets:
//
//  - font negotiation packets
//  - order packets
//  - screen data packets
//
// Font negotiation packets are sent by the USR_Periodic function.  If the
// packet cannot be sent first time then the USR will retry (on each call
// to the USR_Periodic function) until it has succesfully sent the packet.
// The only dependency on font packets is that until the systems in a share
// have been able to exchange font negotiation packets they will not be
// able to send text output as orders - they will simply send text as
// screen data.
//
// The USR function UP_SendUpdates sends all update packets (both order
// packets and screen data packets).  Order packets must be sent first and
// screen data packets are only sent if all the orders have been
// succesfully sent.  When sending screen data packets they are only sent
// if the corresponding palette packets have been sent - otherwise they are
// re-absorbed into the screen data to be transmitted later.
//
//



//
// USR_ShareStarting()
// Creates share resources
//
BOOL ASShare::USR_ShareStarting(void)
{
    BOOL    rc = FALSE;
    BITMAPINFOHEADER    bitmapInfo;
    HDC                 hdcDesktop = NULL;

    DebugEntry(ASShare::USR_ShareStarting);

    //
    // Set the black bitmap data and hatch bitmap data flags which can be
    // used as an aid for debugging.  These are false unless there is an
    // entry in the ini file to override them.
    //
    COM_ReadProfInt(DBG_INI_SECTION_NAME, USR_INI_HATCHSCREENDATA, FALSE,
            &m_usrHatchScreenData);

    COM_ReadProfInt(DBG_INI_SECTION_NAME, USR_INI_HATCHBMPORDERS, FALSE,
            &m_usrHatchBitmaps);

    //
    // Double-check the order packet sizes are OK
    //
    ASSERT(SMALL_ORDER_PACKET_SIZE < LARGE_ORDER_PACKET_SIZE);
    ASSERT(LARGE_ORDER_PACKET_SIZE <= TSHR_MAX_SEND_PKT);

    //
    // Allocate a chunk of memory big enough to contain the largest packet
    // an application can receive from the network.  This is required to
    // store uncompressed bitmaps and repeated general use by the USR.
    //
    m_usrPBitmapBuffer = new BYTE[TSHR_MAX_SEND_PKT];
    if (!m_usrPBitmapBuffer)
    {
        ERROR_OUT(("USR_ShareStarted: failed to alloc memory m_usrPBitmapBuffer"));

        //
        // To continue the share would cause a GP fault as soon as anything
        // tries to use this buffer so delete this person from the share.
        // The reason is lack of resources.
        //
        DC_QUIT;
    }

    //
    // Create the transfer bitmaps for screen data and bitmap orders
    //

    USR_InitDIBitmapHeader(&bitmapInfo, g_usrScreenBPP);

    //
    // Create the transfer bitmaps.  These are used for both outgoing and
    // incoming data.
    //
    // To avoid having to recreate the bitmaps whenever the parties in the
    // share change, (and hence the various bpp may change) from r2.0 we
    // now use a fixed vertical size and if necessary can handle incoming
    // bitmaps in multiple bands.
    //
    // These are the resulting heights for 256 pixel wide segments.
    //
    // TSHR_MAX_SEND_PKT - sizeof(DATAPACKETHEADER) / bytes per scan line
    //
    //     4bpp -->    (32000 - 4)    /     128              = 249
    //     8bpp -->    (32000 - 4)    /     256              = 124
    //    24bpp -->    (32000 - 4)    /     768              =  41
    //
    //

    //
    // NOTE:
    // The VGA driver has a problem when the bitmap ends exactly on a 4K
    // (page) boundary.  So we create the bitmaps one pixel taller.
    //
    // BOGUS BUGBUG LAURABU
    // Is this really true anymore?  If not, save some memory and make these
    // the right size.
    //

    hdcDesktop = GetDC(NULL);
    if (!hdcDesktop)
    {
        ERROR_OUT(("USR_ShareStarting: can't get screen DC"));
        DC_QUIT;
    }

    // The large bitmap is short.  The rest are medium height.
    bitmapInfo.biWidth      = 1024;
    bitmapInfo.biHeight     = MaxBitmapHeight(MEGA_WIDE_X_SIZE, 8) + 1;
    m_usrBmp1024 = CreateDIBitmap(hdcDesktop, &bitmapInfo, 0,  NULL, NULL,
            DIB_RGB_COLORS);
    if (!m_usrBmp1024)
    {
        ERROR_OUT(("USR_ShareStarting: failed to reate m_usrBmp1024"));
        DC_QUIT;
    }

    bitmapInfo.biHeight     = MaxBitmapHeight(MEGA_X_SIZE, 8) + 1;

    bitmapInfo.biWidth      = 256;
    m_usrBmp256 = CreateDIBitmap(hdcDesktop, &bitmapInfo, 0, NULL, NULL,
            DIB_RGB_COLORS);
    if (!m_usrBmp256)
    {
        ERROR_OUT(("USR_ShareStarting: failed to create m_usrBmp256"));
        DC_QUIT;
    }

    bitmapInfo.biWidth      = 128;
    m_usrBmp128 = CreateDIBitmap(hdcDesktop, &bitmapInfo, 0, NULL, NULL,
            DIB_RGB_COLORS);
    if (!m_usrBmp128)
    {
        ERROR_OUT(("USR_ShareStarting: failed to create m_usrBmp128"));
        DC_QUIT;
    }

    bitmapInfo.biWidth      = 112;
    m_usrBmp112 = CreateDIBitmap(hdcDesktop, &bitmapInfo, 0, NULL, NULL,
            DIB_RGB_COLORS);
    if (!m_usrBmp112)
    {
        ERROR_OUT(("USR_ShareStarting: failed to create m_usrBmp112"));
        DC_QUIT;
    }

    bitmapInfo.biWidth      = 96;
    m_usrBmp96  = CreateDIBitmap(hdcDesktop, &bitmapInfo, 0, NULL, NULL,
            DIB_RGB_COLORS);
    if (!m_usrBmp96)
    {
        ERROR_OUT(("USR_ShareStarting: failed to create m_usrBmp96"));
        DC_QUIT;
    }

    bitmapInfo.biWidth      = 80;
    m_usrBmp80  = CreateDIBitmap(hdcDesktop, &bitmapInfo, 0, NULL, NULL,
            DIB_RGB_COLORS);
    if (!m_usrBmp80)
    {
        ERROR_OUT(("USR_ShareStarting: failed to create m_usrBmp80"));
        DC_QUIT;
    }

    bitmapInfo.biWidth      = 64;
    m_usrBmp64  = CreateDIBitmap(hdcDesktop, &bitmapInfo, 0, NULL, NULL,
            DIB_RGB_COLORS);
    if (!m_usrBmp64)
    {
        ERROR_OUT(("USR_ShareStarting: failed to create m_usrBmp64"));
        DC_QUIT;
    }

    bitmapInfo.biWidth      = 48;
    m_usrBmp48  = CreateDIBitmap(hdcDesktop, &bitmapInfo, 0, NULL, NULL,
            DIB_RGB_COLORS);
    if (!m_usrBmp48)
    {
        ERROR_OUT(("USR_ShareStarting: failed to create m_usrBmp48"));
        DC_QUIT;
    }

    bitmapInfo.biWidth      = 32;
    m_usrBmp32  = CreateDIBitmap(hdcDesktop, &bitmapInfo, 0, NULL, NULL,
            DIB_RGB_COLORS);
    if (!m_usrBmp32)
    {
        ERROR_OUT(("USR_ShareStarting: failed to create m_usrBmp32"));
        DC_QUIT;
    }

    bitmapInfo.biWidth      = 16;
    m_usrBmp16  = CreateDIBitmap(hdcDesktop, &bitmapInfo, 0, NULL, NULL,
            DIB_RGB_COLORS);
    if (!m_usrBmp16)
    {
        ERROR_OUT(("USR_ShareStarting: failed to create m_usrBmp16"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    if (hdcDesktop)
    {
        ReleaseDC(NULL, hdcDesktop);
    }

    DebugExitBOOL(ASShare::USR_ShareStarting, rc);
    return(rc);
}



//
// USR_ShareEnded()
// Cleans up share resources
//
void ASShare::USR_ShareEnded(void)
{
    DebugEntry(ASShare::USR_ShareEnded);

    //
    // Delete Transfer Bitmaps.
    //
    if (m_usrBmp1024)
    {
        DeleteBitmap(m_usrBmp1024);
        m_usrBmp1024= NULL;
    }

    if (m_usrBmp256)
    {
        DeleteBitmap(m_usrBmp256);
        m_usrBmp256 = NULL;
    }

    if (m_usrBmp128)
    {
        DeleteBitmap(m_usrBmp128);
        m_usrBmp128 = NULL;
    }

    if (m_usrBmp112)
    {
        DeleteBitmap(m_usrBmp112);
        m_usrBmp112 = NULL;
    }

    if (m_usrBmp96)
    {
        DeleteBitmap(m_usrBmp96);
        m_usrBmp96 = NULL;
    }

    if (m_usrBmp80)
    {
        DeleteBitmap(m_usrBmp80);
        m_usrBmp80 = NULL;
    }

    if (m_usrBmp64)
    {
        DeleteBitmap(m_usrBmp64);
        m_usrBmp64 = NULL;
    }

    if (m_usrBmp48)
    {
        DeleteBitmap(m_usrBmp48);
        m_usrBmp48 = NULL;
    }

    if (m_usrBmp32)
    {
        DeleteBitmap(m_usrBmp32);
        m_usrBmp32 = NULL;
    }

    if (m_usrBmp16)
    {
        DeleteBitmap(m_usrBmp16);
        m_usrBmp16 = NULL;
    }

    //
    // Free Bitmap Buffer.
    //
    if (m_usrPBitmapBuffer != NULL)
    {
        delete[] m_usrPBitmapBuffer;
        m_usrPBitmapBuffer = NULL;
    }

    DebugExitVOID(ASShare::USR_ShareEnded);
}




//
// USR_RecalcCaps()
//
// DESCRIPTION:
//
// Enumerates the bitmap capabilities of all parties currently in the
// share, and determines the common capabilities.
//
// PARAMETERS: None.
//
// RETURNS: TRUE if there are good common caps, or false on failure (which
// has the effect of rejecting a new party from joining the share).
//
//
void  ASShare::USR_RecalcCaps(BOOL fJoiner)
{
    ASPerson *  pasT;
    UINT        capsMaxBPP;
    UINT        capsMinBPP;
    UINT        capsSupports4BPP;
    UINT        capsSupports8BPP;
    UINT        capsSupports24BPP;
    UINT        capsOldBPP;

    DebugEntry(ASShare::USR_RecalcCaps);

    if (!m_pHost)
    {
        // Nothing to do
        DC_QUIT;
    }

    ValidatePerson(m_pasLocal);

    capsOldBPP = m_pHost->m_usrSendingBPP;

    //
    // Init the caps
    //
    capsSupports4BPP    = m_pasLocal->cpcCaps.screen.capsSupports4BPP;
    capsSupports8BPP    = m_pasLocal->cpcCaps.screen.capsSupports8BPP;
    capsSupports24BPP   = m_pasLocal->cpcCaps.screen.capsSupports24BPP;
    capsMaxBPP          = 0;
    capsMinBPP          = 0xFFFFFFFF;

    for (pasT = m_pasLocal->pasNext; pasT != NULL; pasT = pasT->pasNext)
    {
        //
        // Check the bpps supported.
        //
        if (pasT->cpcCaps.screen.capsSupports4BPP != CAPS_SUPPORTED)
        {
            capsSupports4BPP = CAPS_UNSUPPORTED;
        }
        if (pasT->cpcCaps.screen.capsSupports8BPP != CAPS_SUPPORTED)
        {
            capsSupports8BPP = CAPS_UNSUPPORTED;
        }
        if (pasT->cpcCaps.screen.capsSupports24BPP != CAPS_SUPPORTED)
        {
            capsSupports24BPP = CAPS_UNSUPPORTED;
        }

        //
        // Set the combined bpp to the maximum so far found.
        // (If we send data at this bpp then one of the remote systems can
        // usefully process this number of colors).
        //
        capsMaxBPP = max(capsMaxBPP, pasT->cpcCaps.screen.capsBPP);
        capsMinBPP = min(capsMinBPP, pasT->cpcCaps.screen.capsBPP);
    }

    //
    // Now figure out what BPP we will transmit at.
    //
    //
    // Limit the combined caps bpp (which is currently the maximum bpp that
    // any system in the share wants) to the local bpp, since there is no
    // point sending at higher bpp than the local machine has.
    //
    capsMaxBPP = min(capsMaxBPP, g_usrScreenBPP);
    if (!capsMaxBPP)
        capsMaxBPP = g_usrScreenBPP;

    capsMinBPP = min(capsMinBPP, g_usrScreenBPP);

    //
    // m_usrSendingBPP is most often going to be 8.  So it's easier to assume
    // it, then check for cases where it won't be.
    //
    m_pHost->m_usrSendingBPP = 8;

    if ((capsMaxBPP <= 4) && (capsSupports4BPP == CAPS_SUPPORTED))
    {
        m_pHost->m_usrSendingBPP = 4;
    }
    else if ((capsMinBPP >= 24) &&
             (g_asSettings & SHP_SETTING_TRUECOLOR) &&
             (capsSupports24BPP == CAPS_SUPPORTED))
    {
        m_pHost->m_usrSendingBPP = 24;
    }

    if (capsOldBPP != m_pHost->m_usrSendingBPP)
    {
        //
        // If switching to/from palettized, we need to update the
        // "need to send palette" flag.  Note that 4bpp is also a
        // palettized color depth.
        //
        if ((capsOldBPP <= 8) && (m_pHost->m_usrSendingBPP > 8))
            m_pHost->m_pmMustSendPalette = FALSE;
        else if ((capsOldBPP > 8) && (m_pHost->m_usrSendingBPP <= 8))
            m_pHost->m_pmMustSendPalette = TRUE;

#ifdef _DEBUG
        if (capsOldBPP == 24)
        {
            WARNING_OUT(("TRUE COLOR SHARING is now FINISHED"));
        }
        else if (m_pHost->m_usrSendingBPP == 24)
        {
            WARNING_OUT(("TRUE COLOR SHARING is now STARTING"));
        }
#endif

        if (!fJoiner)
        {
            //
            // Sending BPP changed.  Repaint all shared stuff.
            // NOTE:
            // We recalc the sendBPP at three points:
            //      * When we start to share
            //      * When a person joins
            //      * When a person leaves
            //
            // In the first two cases, shared stuff is repainted,
            // so everybody gets the new sendBPP data.  Only in the
            // leave case do we need to force this.
            //
            m_pHost->HET_RepaintAll();
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::USR_RecalcCaps);
}


//
// USR_HostStarting()
//
BOOL ASHost::USR_HostStarting(void)
{
    BOOL    rc = FALSE;
    HDC     hdc;

    DebugEntry(ASHost::USR_HostStarting);

    //
    // Create scratch DC
    //
    hdc = GetDC(NULL);
    if (!hdc)
    {
        ERROR_OUT(("USR_HostStarting: can't get screen DC"));
        DC_QUIT;
    }

    m_usrWorkDC = CreateCompatibleDC(hdc);
    ReleaseDC(NULL, hdc);

    if (!m_usrWorkDC)
    {
        ERROR_OUT(("USR_HostStarting: can't create m_usrWorkDC"));
        DC_QUIT;
    }

    m_pShare->USR_RecalcCaps(TRUE);

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASHost::USR_HostStarting, rc);
    return(rc);
}



//
// USR_HostEnded()
//
void ASHost::USR_HostEnded(void)
{
    DebugEntry(ASHost::USR_HostEnded);

    if (m_usrWorkDC != NULL)
    {
        DeleteDC(m_usrWorkDC);
        m_usrWorkDC = NULL;
    }

    DebugExitVOID(ASHost::USR_HostEnded);
}




//
// USR_ScrollDesktop
//
void  ASShare::USR_ScrollDesktop
(
    ASPerson *  pasPerson,
    int         xNew,
    int         yNew
)
{
    int         xOld;
    int         yOld;

    DebugEntry(ASShare::USR_ScrollDesktop);

    ValidateView(pasPerson);

    //
    // If the origin has changed then do the update.
    //
    xOld = pasPerson->m_pView->m_dsScreenOrigin.x;
    yOld = pasPerson->m_pView->m_dsScreenOrigin.y;

    if ((xOld != xNew) || (yOld != yNew))
    {
        pasPerson->m_pView->m_dsScreenOrigin.x = xNew;
        pasPerson->m_pView->m_dsScreenOrigin.y = yNew;

        //
        // We must ensure that data written to the ScreenBitmap is not
        // clipped
        //
        OD_ResetRectRegion(pasPerson);

        //
        // Offset the existing bitmap by the change in desktop origins.
        //

        BitBlt(pasPerson->m_pView->m_usrDC,
                          0,
                          0,
                          pasPerson->cpcCaps.screen.capsScreenWidth,
                          pasPerson->cpcCaps.screen.capsScreenHeight,
                          pasPerson->m_pView->m_usrDC,
                          xNew - xOld,
                          yNew - yOld,
                          SRCCOPY);

        //
        // Offset the shadow cursor pos -- same place on remote screen
        // but now different place in VD
        //
        pasPerson->cmPos.x += xNew - xOld;
        pasPerson->cmPos.y += yNew - yOld;

        //
        // Repaint the view
        //
        VIEW_InvalidateRgn(pasPerson, NULL);
    }

    DebugExitVOID(ASShare::USR_ScrollDesktop);
}



//
// FUNCTION: USR_InitDIBitmapHeader
//
// DESCRIPTION:
//
// Initialises a Device Independent bitmap header to be the given bits per
// pel.
//
// PARAMETERS:
//
// pbh - pointer to the bitmap header to be initialised.
// bpp - bpp to be used for the bitmap
//
// RETURNS: VOID
//
//
void  ASShare::USR_InitDIBitmapHeader
(
    BITMAPINFOHEADER *  pbh,
    UINT                bpp
)
{
    DebugEntry(ASShare::USR_InitDIBitmapHeader);

    pbh->biSize          = sizeof(BITMAPINFOHEADER);
    pbh->biPlanes        = 1;
    pbh->biBitCount      = (WORD)bpp;
    pbh->biCompression   = BI_RGB;
    pbh->biSizeImage     = 0;
    pbh->biXPelsPerMeter = 10000;
    pbh->biYPelsPerMeter = 10000;
    pbh->biClrUsed       = 0;
    pbh->biClrImportant  = 0;

    DebugExitVOID(ASShare::USR_InitDIBitmapHeader);
}



//
// USR_ViewStarting()
//
// Called when someone we're viewing starts to host.  We create the desktop
// bitmap for them plus scratch objects
//
BOOL  ASShare::USR_ViewStarting(ASPerson *  pasPerson)
{
    BOOL   rc;

    DebugEntry(ASShare::USR_ViewStarting);

    ValidateView(pasPerson);

    //
    // Create a bitmap for this new party
    //
    rc = USRCreateRemoteDesktop(pasPerson);

    DebugExitBOOL(ASShare::USR_ViewStarting, rc);
    return(rc);
}


//
// FUNCTION: USRCreateRemoteDesktop
//
// DESCRIPTION:
//
// Creates the shadow bitmap for a remote party.
//
// PARAMETERS:
//
// personID - person to create the shadow bitmap for.
//
// RETURNS: TRUE if successful, FALSE otherwise.
//
//
BOOL  ASShare::USRCreateRemoteDesktop(ASPerson * pasPerson)
{
    BOOL            rc = FALSE;
    HDC             hdcDesktop = NULL;
    RECT            desktopRect;

    DebugEntry(ASShare::USRCreateRemoteDesktop);

    ValidateView(pasPerson);

    ASSERT(pasPerson->m_pView->m_usrDC == NULL);
    ASSERT(pasPerson->m_pView->m_usrBitmap == NULL);
    ASSERT(pasPerson->m_pView->m_usrOldBitmap == NULL);

    hdcDesktop = GetDC(NULL);

    //
    // Create the scratch DC
    //
    pasPerson->m_pView->m_usrWorkDC = CreateCompatibleDC(hdcDesktop);
    if (!pasPerson->m_pView->m_usrWorkDC)
    {
        ERROR_OUT(("Couldn't create workDC for person [%d]", pasPerson->mcsID));
        DC_QUIT;
    }

    //
    // Create the DC that keeps the screen bitmap for this party
    //
    pasPerson->m_pView->m_usrDC = CreateCompatibleDC(hdcDesktop);
    if (!pasPerson->m_pView->m_usrDC)
    {
        ERROR_OUT(("Couldn't create usrDC for person [%d]", pasPerson->mcsID));
        DC_QUIT;
    }

    //
    // We can't use this person's usrDC, since that currently has a MONO
    // bitmap selected into it.
    //
    pasPerson->m_pView->m_usrBitmap = CreateCompatibleBitmap(hdcDesktop, pasPerson->cpcCaps.screen.capsScreenWidth, pasPerson->cpcCaps.screen.capsScreenHeight);
    if (pasPerson->m_pView->m_usrBitmap == NULL)
    {
        ERROR_OUT(("Couldn't create screen bitmap for [%d]", pasPerson->mcsID));
        DC_QUIT;
    }

    //
    // Select the screen bitmap into the person's DC, and save the previous
    // 1x1 bitmap away, so we can deselect it when done.
    //
    pasPerson->m_pView->m_usrOldBitmap = SelectBitmap(pasPerson->m_pView->m_usrDC, pasPerson->m_pView->m_usrBitmap);

    //
    // Fill the Screen Bitmap with grey.
    //
    // In practice the Shadow Window Presenter(SWP) should never display
    // any area of the Screen Bitmap that has not been updated with data
    // from a remote system.
    //
    // Therefore this operation is just "insurance" in case the SWP goes
    // wrong and momentarily displays a non-updated area - a flash of grey
    // is better than a flash of garbage.
    //
    desktopRect.left = 0;
    desktopRect.top = 0;
    desktopRect.right = pasPerson->cpcCaps.screen.capsScreenWidth;
    desktopRect.bottom = pasPerson->cpcCaps.screen.capsScreenHeight;

    FillRect(pasPerson->m_pView->m_usrDC, &desktopRect, GetSysColorBrush(COLOR_APPWORKSPACE));
    rc = TRUE;

DC_EXIT_POINT:

    if (hdcDesktop != NULL)
    {
        ReleaseDC(NULL, hdcDesktop);
    }

    DebugExitBOOL(ASShare::USRCreateRemoteDesktop, rc);
    return(rc);
}



//
// USR_ViewEnded()
//
// Called when person we're viewing stops hosting.  We get rid of their
// desktop bitmap.
//
void  ASShare::USR_ViewEnded(ASPerson *  pasPerson)
{
    ValidateView(pasPerson);

    //
    // Delete the desktop bitmap for the party that has left
    //
    USRDeleteRemoteDesktop(pasPerson);
}


//
// FUNCTION: USRDeleteRemoteDesktop
//
// DESCRIPTION:
//
// Deletes a remote party's shadow bitmap.
//
// PARAMETERS:
//
// personID - party whose shadow bitmap is to be deleted.
//
// RETURNS: Nothing.
//
//
void  ASShare::USRDeleteRemoteDesktop(ASPerson * pasPerson)
{
    DebugEntry(ASShare::USRDeleteRemoteDesktop);

    ValidateView(pasPerson);

    if (pasPerson->m_pView->m_usrOldBitmap != NULL)
    {
        // Deselect screen bitmap
        SelectBitmap(pasPerson->m_pView->m_usrDC, pasPerson->m_pView->m_usrOldBitmap);
        pasPerson->m_pView->m_usrOldBitmap = NULL;
    }

    if (pasPerson->m_pView->m_usrBitmap != NULL)
    {
        // Delete the screen bitmap
        DeleteBitmap(pasPerson->m_pView->m_usrBitmap);
        pasPerson->m_pView->m_usrBitmap = NULL;
    }

    if (pasPerson->m_pView->m_usrDC != NULL)
    {
        //
        // Delete the screen DC.  Created objects should have
        // been selected out of it before now.
        //
        DeleteDC(pasPerson->m_pView->m_usrDC);
        pasPerson->m_pView->m_usrDC = NULL;
    }

    if (pasPerson->m_pView->m_usrWorkDC != NULL)
    {
        DeleteDC(pasPerson->m_pView->m_usrWorkDC);
        pasPerson->m_pView->m_usrWorkDC = NULL;
    }

    DebugExitVOID(ASShare::USRDeleteRemoteDesktop);
}




//
// This function is a mess! First because it ought to be an FH API
// function, and secondly because it mixes portable code and Windows API
// calls. The details of what is to be done with it are deferred until the
// UNIX port of FH is designed, though. STOPPRESS! Function replaced by new
// FH_CreateAndSelectFont, which combines old USR_UseFont and
// FH_CreateAndSelectFont - you have to write an NT version.
//
//
// USR_UseFont()
//
BOOL  ASShare::USR_UseFont
(
    HDC             surface,
    HFONT*          pHFont,
    TEXTMETRIC*     pFontMetrics,
    LPSTR           pName,
    UINT            codePage,
    UINT            MaxHeight,
    UINT            Height,
    UINT            Width,
    UINT            Weight,
    UINT            flags
)
{
    BOOL      rc = FALSE;
    HFONT     hNewFont;
    HFONT     hOldFont;

    DebugEntry(ASShare::USR_UseFont);

    rc = FH_CreateAndSelectFont(surface,
                                &hNewFont,
                                &hOldFont,
                                pName,
                                codePage,
                                MaxHeight,
                                Height,
                                Width,
                                Weight,
                                flags);

    if (rc == FALSE)
    {
        //
        // Failed to create or select the font.
        //
        DC_QUIT;
    }

    //
    // Select in the new font which ensures that the old one is deselected.
    //
    // NB.  We do not delete the font we are deselecting, rather the old
    // one that was passed to us.  This is beacuse multiple components use
    // "surface", and so the deselected font may not be the current
    // component's last font at all - the important thing is that by
    // selecting in the new font we are ensuring that the old font is not
    // the selected one.
    //
    SelectFont(surface, hNewFont);
    if (*pHFont)
    {
        DeleteFont(*pHFont);
    }

    //
    // If a pointer to font metrics was passed in then we need to query
    // the metrics now.
    //
    if (pFontMetrics)
        GetTextMetrics(surface, pFontMetrics);

    //
    // Update the record of the last font we selected.
    //
    *pHFont = hNewFont;
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(ASShare::USR_UseFont, rc);
    return(rc);
}

//
// USR_ScreenChanged()
//
void  ASShare::USR_ScreenChanged(ASPerson * pasPerson)
{
    DebugEntry(ASShare::USR_ScreenChanged);

    ValidatePerson(pasPerson);

    pasPerson->cpcCaps.screen.capsScreenWidth = pasPerson->cpcCaps.screen.capsScreenWidth;
    pasPerson->cpcCaps.screen.capsScreenHeight = pasPerson->cpcCaps.screen.capsScreenHeight;

    if (pasPerson->m_pView)
    {
        //
        // Recreate screen bitmap
        //

        //
        // Discard the remote users current shadow bitmap
        //
        USRDeleteRemoteDesktop(pasPerson);

        //
        // Create a new shadow bitmap for remote user that is of the new size
        //
        USRCreateRemoteDesktop(pasPerson);
    }

    VIEW_ScreenChanged(pasPerson);

    DebugExitVOID(ASShare::USR_ScreenChanged);
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\ut.cpp ===
#include "precomp.h"


//
// UT.CPP
// Utility Functions
//
#include <limits.h>
#include <process.h>
#include <mmsystem.h>
#include <confreg.h>

#define MLZ_FILE_ZONE  ZONE_UT



//
//
// UT_InitTask(...)
//
//
BOOL UT_InitTask
(
    UT_TASK         task,
    PUT_CLIENT *    pputTask
)
{
    BOOL            fInit = FALSE;
    BOOL            locked    = FALSE;
    PUT_CLIENT      putTask = NULL;

    DebugEntry(UT_InitTask);

    UT_Lock(UTLOCK_UT);

    //
    // Initialise handle to NULL
    //
    *pputTask = NULL;

    ASSERT(task >= UTTASK_FIRST);
    ASSERT(task < UTTASK_MAX);

    //
    // The UT_TASK is an index into the tasks array.
    //
    putTask = &(g_autTasks[task]);

    if (putTask->dwThreadId)
    {
        ERROR_OUT(("Task %d already exists", task));
        putTask = NULL;
        DC_QUIT;
    }

    ZeroMemory(putTask, sizeof(UT_CLIENT));

    //
    // Call routine to set up the process id information in the task CB.
    //
    putTask->dwThreadId   =   GetCurrentThreadId();

    //
    // Create the window
    //
    putTask->utHwnd = CreateWindow(MAKEINTATOM(g_utWndClass),
                            NULL,               // name
                            0,                  // style
                            1,                  // x
                            1,                  // y
                            200,                // width
                            100,                // height
                            NULL,               // parent
                            NULL,               // menu
                            g_asInstance,
                            NULL);              // create struct
    if (!putTask->utHwnd)
    {
        ERROR_OUT(("Failed to create UT msg window"));
        DC_QUIT;
    }

    //
    // Now store the UT handle in the user data associated with the
    // window.  We will use this to get the UT handle when we are in
    // the event procedure.
    //

	SetWindowLongPtr(putTask->utHwnd, GWLP_USERDATA, (LPARAM)putTask);

    fInit = TRUE;

DC_EXIT_POINT:
    //
    // Callers will call UT_TermTask() on error, which will bump down
    // the shared memory count.  So we have no clean up on error here.
    //
    *pputTask = putTask;

    //
    // Release access to task stuff
    //
    UT_Unlock(UTLOCK_UT);

    DebugExitBOOL(UT_InitTask, fInit);
    return(fInit);
}



//
// UT_TermTask(...)
//
void UT_TermTask(PUT_CLIENT * pputTask)
{
    DebugEntry(UT_TermTask);

    //
    // Check that the putTask is valid
    //
    if (!*pputTask)
    {
        WARNING_OUT(("UT_TermTask: null task"));
        DC_QUIT;
    }

	UTTaskEnd(*pputTask);
    *pputTask = NULL;

DC_EXIT_POINT:

    DebugExitVOID(UT_TermTask);
}


//
//
// UTTaskEnd(...)
//
//
void UTTaskEnd(PUT_CLIENT putTask)
{
    int                 i;
    PUTEXIT_PROC_INFO   pExit;
    PUTEVENT_INFO       pEventInfo;

    DebugEntry(UTTaskEnd);

    UT_Lock(UTLOCK_UT);

    if (!putTask->dwThreadId)
    {
        // Nothing to do
        DC_QUIT;
    }

    ValidateUTClient(putTask);

    //
    // Call any registered exit procedures.  Since we guarantee to call
    // exit procs in the reverse order to the order they were registered,
    // we start at the end of the array and call each proc in turn back to
    // the first one registered:
    //
    TRACE_OUT(("Calling exit procedures..."));
    for (i = UTEXIT_PROCS_MAX-1 ; i >= 0; i--)
    {
        pExit = &(putTask->exitProcs[i]);

        if (pExit->exitProc != NULL)
        {
            pExit->exitProc(pExit->exitData);

            //
            // If any exit proc still exists in slot i, then this proc has
            // failed to deregister itself.  This is not mandatory but is
            // expected.
            //
            if (pExit->exitProc != NULL)
            {
               TRACE_OUT(("Exit proc 0x%08x failed to deregister itself when called",
                      pExit->exitProc));
            }
        }
    }

    //
    // Free delayed events
    //
    pEventInfo = (PUTEVENT_INFO)COM_BasedListFirst(&(putTask->delayedEvents),
        FIELD_OFFSET(UTEVENT_INFO, chain));
    while (pEventInfo != NULL)
    {
        COM_BasedListRemove(&(pEventInfo->chain));
        delete pEventInfo;

        pEventInfo = (PUTEVENT_INFO)COM_BasedListFirst(&(putTask->delayedEvents),
            FIELD_OFFSET(UTEVENT_INFO, chain));
    }

    //
    // Free pending events
    //
    pEventInfo = (PUTEVENT_INFO)COM_BasedListFirst(&(putTask->pendingEvents),
        FIELD_OFFSET(UTEVENT_INFO, chain));
    while (pEventInfo != NULL)
    {
        COM_BasedListRemove(&(pEventInfo->chain));
        delete pEventInfo;

        pEventInfo = (PUTEVENT_INFO)COM_BasedListFirst(&(putTask->pendingEvents),
            FIELD_OFFSET(UTEVENT_INFO, chain));
    }

    //
    // If we created a window to post UT events to for this task, then
    // destroy the window.  This will also kill all the timers which are
    // pending for this window.
    //
    if (putTask->utHwnd != NULL)
    {
        DestroyWindow(putTask->utHwnd);
        putTask->utHwnd = NULL;
    }

    //
    // Clear out the thread ID
    //
    putTask->dwThreadId = 0;


DC_EXIT_POINT:
    UT_Unlock(UTLOCK_UT);

    DebugExitVOID(UTTaskEnd);
}



//
//
// UT_RegisterEvent(...)
//
//
void WINAPI UT_RegisterEvent
(
    PUT_CLIENT      putTask,
    UTEVENT_PROC    eventProc,
    LPVOID          eventData,
    UT_PRIORITY     priority
)
{
    int             i;
    PUTEVENT_PROC_INFO  pEventProcData;

    DebugEntry(UT_RegisterEvent);

    ValidateUTClient(putTask);

    //
    // Check that the priority is valid
    //
    ASSERT(priority <= UT_PRIORITY_MAX);

    //
    // Check that we have room for this event handler
    //
    pEventProcData = putTask->eventHandlers;
    ASSERT(pEventProcData[UTEVENT_HANDLERS_MAX-1].eventProc == NULL);

    //
    // Find the place to insert this event handler
    //
    TRACE_OUT(("Looking for pos for event proc at priority %d", priority));

    for (i = 0; i < UTEVENT_HANDLERS_MAX; i++)
    {
        if (pEventProcData[i].eventProc == NULL)
        {
            TRACE_OUT(("Found NULL slot at position %d", i));
            break;
        }

        if (pEventProcData[i].priority <= priority)
        {
            TRACE_OUT(("Found event proc of priority %d at pos %d",
                        pEventProcData[i].priority, i));
            break;
        }
    }

    //
    // Shift all lower and equal priority event handlers down a slot
    //
    UT_MoveMemory(&pEventProcData[i+1], &pEventProcData[i],
        sizeof(UTEVENT_PROC_INFO) * (UTEVENT_HANDLERS_MAX - 1 - i));

    pEventProcData[i].eventProc    = eventProc;
    pEventProcData[i].eventData    = eventData;
    pEventProcData[i].priority     = priority;

    DebugExitVOID(UT_RegisterEvent);
}




//
//
// UT_DeregisterEvent(...)
//
//
void UT_DeregisterEvent
(
    PUT_CLIENT          putTask,
    UTEVENT_PROC        eventProc,
    LPVOID              eventData
)
{
    int                 i;
    BOOL                found = FALSE;

    DebugEntry(UT_DeregisterEvent);

    ValidateUTClient(putTask);

    //
    // Find the Event handler
    //
    for (i = 0; i < UTEVENT_HANDLERS_MAX; i++)
    {
        if ( (putTask->eventHandlers[i].eventProc == eventProc) &&
             (putTask->eventHandlers[i].eventData == eventData) )
        {
            //
            // Found handler - shuffle down stack on top of it
            //
            TRACE_OUT(("Deregistering event proc 0x%08x from position %d",
                     eventProc, i));
            found = TRUE;

            //
            // Slide all the other event procs up one
            //
            UT_MoveMemory(&putTask->eventHandlers[i],
                &putTask->eventHandlers[i+1],
                sizeof(UTEVENT_PROC_INFO) * (UTEVENT_HANDLERS_MAX - 1 - i));

            putTask->eventHandlers[UTEVENT_HANDLERS_MAX-1].eventProc = NULL;
            break;
        }
    }

    //
    // Check that we found the event handler
    //
    ASSERT(found);

    DebugExitVOID(UT_DeregisterEvent);
}


//
//
// UT_PostEvent(...)
//
//
void UT_PostEvent
(
    PUT_CLIENT  putFrom,
    PUT_CLIENT  putTo,
    UINT        delay,
    UINT        eventNo,
    UINT_PTR    param1,
    UINT_PTR    param2
)
{
    DebugEntry(UT_PostEvent);

    //
    // Get exclusive access to the UTM while we move event pool entries --
    // we are changing fields in a task, so we need to protect it.
    //
    UT_Lock(UTLOCK_UT);

    if (!putTo || (putTo->utHwnd == NULL))
    {
        TRACE_OUT(("NULL destination task %x in UT_PostEvent", putTo));
        DC_QUIT;
    }

    ValidateUTClient(putFrom);
    ValidateUTClient(putTo);

    if (delay != 0)
    {
        //
        // A delay was specified...
        //
        UTPostDelayedEvt(putFrom, putTo, delay, eventNo, param1, param2);
    }
    else
    {
        //
        // No delay specified - post the event now
        //
        UTPostImmediateEvt(putFrom, putTo, eventNo, param1, param2);
    }

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_UT);

    DebugExitVOID(UT_PostEvent);
}



//
// UTPostImmediateEvt(...)
//
void UTPostImmediateEvt
(
    PUT_CLIENT      putFrom,
    PUT_CLIENT      putTo,
    UINT            event,
    UINT_PTR        param1,
    UINT_PTR        param2
)
{
    PUTEVENT_INFO   pEventInfo;
    BOOL            destQueueEmpty;

    DebugEntry(UTPostImmediateEvt);

    TRACE_OUT(("Posting event %d (%#.4hx, %#.8lx) from 0x%08x to 0x%08x",
             event,
             param1,
             param2,
             putFrom, putTo));

    //
    // Allocate an event.
    //
    pEventInfo = new UTEVENT_INFO;
    if (!pEventInfo)
    {
        WARNING_OUT(("UTPostImmediateEvent failed; out of memory"));
        DC_QUIT;
    }
    ZeroMemory(pEventInfo, sizeof(*pEventInfo));
    SET_STAMP(pEventInfo, UTEVENT);

    //
    // Determine whether the target queue is empty
    //
    destQueueEmpty = COM_BasedListIsEmpty(&(putTo->pendingEvents));

    //
    // Copy the event into the memory
    //
    pEventInfo->putTo       = putTo;
    pEventInfo->popTime     = 0;
    pEventInfo->event       = event;
    pEventInfo->param1      = param1;
    pEventInfo->param2      = param2;

    //
    // Add to the end of the target queue
    //
    COM_BasedListInsertBefore(&(putTo->pendingEvents), &(pEventInfo->chain));

    //
    // If the target queue was empty, or the destination task is currently
    // waiting for an event (in UT_WaitEvent()), we have to post a trigger
    // event to get it to check its event queue.
    //
    if (destQueueEmpty)
    {
        UTTriggerEvt(putFrom, putTo);
    }

DC_EXIT_POINT:
    DebugExitVOID(UTPostImmediateEvt);
}


//
//
// UTPostDelayedEvt(...)
//
//
void UTPostDelayedEvt
(
    PUT_CLIENT          putFrom,
    PUT_CLIENT          putTo,
    UINT                delay,
    UINT                event,
    UINT_PTR            param1,
    UINT_PTR            param2
)
{
    PUTEVENT_INFO       pDelayedEventInfo;
    PUTEVENT_INFO       pTempEventInfo;
    BOOL                firstDelayed = TRUE;

    DebugEntry(UTPostDelayedEvt);

    TRACE_OUT(("Posting delayed event %d (%#.4hx, %#.8lx) " \
                 "from 0x%08x to 0x%08x, delay %u ms",
             event,
             param1,
             param2, putFrom, putTo, delay));

    //
    // Get an entry from the event pool of the destination
    //
    pDelayedEventInfo = new UTEVENT_INFO;
    if (!pDelayedEventInfo)
    {
        ERROR_OUT(("UTPostDelayedEvt failed; out of memory"));
        DC_QUIT;
    }
    ZeroMemory(pDelayedEventInfo, sizeof(*pDelayedEventInfo));
    SET_STAMP(pDelayedEventInfo, UTEVENT);

    //
    // Copy the event into the memory
    //
    pDelayedEventInfo->putTo   = putTo;
    pDelayedEventInfo->popTime = GetTickCount() + delay;
    pDelayedEventInfo->event   = event;
    pDelayedEventInfo->param1  = param1;
    pDelayedEventInfo->param2  = param2;
    TRACE_OUT(("This event set to pop at %x",
            pDelayedEventInfo->popTime));

    //
    // Insert the delayed event into the delayed queue at the sender.  The
    // list is ordered by the time the event needs to be scheduled.
    //
    pTempEventInfo = (PUTEVENT_INFO)COM_BasedListFirst(&(putFrom->delayedEvents),
        FIELD_OFFSET(UTEVENT_INFO, chain));

    while (pTempEventInfo != NULL)
    {
        ValidateEventInfo(pTempEventInfo);

        TRACE_OUT(("Check if before %d popTime %x",
                pTempEventInfo->event, pTempEventInfo->popTime));
        if (pTempEventInfo->popTime > pDelayedEventInfo->popTime)
        {
            //
            // we have found the first event in the list which pops after
            // this event so insert before it.
            //
            break;
        }

        pTempEventInfo = (PUTEVENT_INFO)COM_BasedListNext(&(putFrom->delayedEvents),
            pTempEventInfo, FIELD_OFFSET(UTEVENT_INFO, chain));
        //
        // Flag that we are not the first delayed event so we know not to
        // (re)start a timer.
        //
        firstDelayed = FALSE;
    }

    if (pTempEventInfo == NULL)
    {
        //
        // After all in queue so add to end
        //
        COM_BasedListInsertBefore(&(putFrom->delayedEvents),
                             &(pDelayedEventInfo->chain));
    }
    else
    {
        //
        // Delayed event pops before pTempEventInfo so insert before.
        //
        COM_BasedListInsertBefore(&(pTempEventInfo->chain),
                             &(pDelayedEventInfo->chain));
    }

    //
    // If we have inserted the delayed event at the front of the queue then
    // restart the timer with the time this event is set to pop.
    //
    if (firstDelayed)
    {
        UTStartDelayedEventTimer(putFrom, pDelayedEventInfo->popTime);
    }

DC_EXIT_POINT:
    DebugExitVOID(UTPostDelayedEvt);
}


//
//
// UTCheckDelayedEvents(...)
//
//
void UTCheckDelayedEvents
(
    PUT_CLIENT      putTask
)
{
    PUT_CLIENT      putTo;
    UINT            timeNow;
    PUTEVENT_INFO   pEventInfo;

    DebugEntry(UTCheckDelayedEvents);

    //
    // Get exclusive access to the UTM while we move event pool entries
    // (these are in shared memory)
    //
    UT_Lock(UTLOCK_UT);

    ValidateUTClient(putTask);

    //
    // Get time now to check against popTime.
    //
    timeNow = GetTickCount();
    TRACE_OUT(("time now is %x", timeNow));

    //
    // Move through the queue of delayed events to see if any have popped.
    // If so send them immediately.  When we get to the first one that
    // hasn't popped restart a timer to schedule it.
    //
    pEventInfo = (PUTEVENT_INFO)COM_BasedListFirst(&(putTask->delayedEvents),
        FIELD_OFFSET(UTEVENT_INFO, chain));
    while (pEventInfo != NULL)
    {
        ValidateEventInfo(pEventInfo);

        //
        // Got an event so check to see if it has popped
        //
        TRACE_OUT(("Event popTime is %x", pEventInfo->popTime));
        if (timeNow >= pEventInfo->popTime)
        {
            TRACE_OUT(("Event popped so post now"));
            //
            // Event has popped so remove from delayed queue and post as an
            // immediate event.
            //
            COM_BasedListRemove(&(pEventInfo->chain));

            //
            // The check on the destination handle should be less strict
            // than that on the source (we shouldn't assert).  This is
            // because the caller may be pre-empted before this check is
            // done, and the destination may shut down in this time.
            //
            ValidateUTClient(pEventInfo->putTo);

            UTPostImmediateEvt(putTask, pEventInfo->putTo,
                                   pEventInfo->event,
                                   pEventInfo->param1,
                                   pEventInfo->param2);

            //
            // Free the event
            //
            delete pEventInfo;

            //
            // Last one popped so move on to next to see if that has popped
            // too.
            //
            pEventInfo = (PUTEVENT_INFO)COM_BasedListFirst(&(putTask->delayedEvents),
                FIELD_OFFSET(UTEVENT_INFO, chain));
        }
        else
        {
            //
            // got to an event which hasn't popped yet.  Start timer to pop
            // for this one.  The OS specific code in UTStartDelayedEventTimer checks
            // to see if the new timer is required (not already running)
            // and will stop and restart if already running but has the
            // incorrect timeout.
            //
            TRACE_OUT(("Event not popped so restart timer and leave"));
            UTStartDelayedEventTimer(putTask, pEventInfo->popTime);
            break;
        }
    }

    UT_Unlock(UTLOCK_UT);

    DebugExitVOID(UTCheckDelayedEvents);
}



//
// UTProcessEvent(...)
//
void UTProcessEvent
(
    PUT_CLIENT          putTask,
    UINT                event,
    UINT_PTR            param1,
    UINT_PTR            param2
)
{
    int                 i;
    PUTEVENT_PROC_INFO  pEventHandler;

    DebugEntry(UTProcessEvent);

    ValidateUTClient(putTask);

    //
    // Call all registered event handlers until somebody returns TRUE, that
    // the event has been processed.
    //
    for (i = 0; i < UTEVENT_HANDLERS_MAX ; i++)
    {
        pEventHandler = &(putTask->eventHandlers[i]);

        if (pEventHandler->eventProc == NULL)
        {
            //
            // Nothing's here.
            //
            break;
        }

        //
        // Call the registered event handler
        //
        TRACE_OUT(("Call event proc 0x%08x priority %d from position %d",
                   pEventHandler->eventProc,
                   pEventHandler->priority,
                   i));
        if ((pEventHandler->eventProc)(pEventHandler->eventData, event,
                param1, param2))
        {
            //
            // Event handler processed event
            //
            break;
        }
    }

    DebugExitVOID(UTProcessEvent);
}


//
//
//
// EXIT PROCS
//
// Our strategy for registering/deregistering/calling exit procs is as
// follows:
//
// - we register procs in the first free slot in the array hung off the
//   task data
//
// - we deregister procs by shuffling down other procs after it in the
//   array
//
// - we call procs starting at the last entry in the array and working
//   backwards.
//
// The above ensures that
//
// - if a proc deregisters itself before task termination, no gaps are
//   left in the array
//
// - if a proc deregisters itself during task termination, all
//   remaining procs are called in the correct order
//
// - if a proc doesn't deregister itself during task termination, it is
//   left in the array but does not affect future processing as the task
//   end loop will call the previous one anyway.
//
//
//

//
//
// UT_RegisterExit(...)
//
//
void UT_RegisterExit
(
    PUT_CLIENT  putTask,
    UTEXIT_PROC exitProc,
    LPVOID      exitData
)
{
    int                 i;
    PUTEXIT_PROC_INFO   pExitProcs;

    DebugEntry(UT_RegisterExit);

    ValidateUTClient(putTask);

    pExitProcs = putTask->exitProcs;
    ASSERT(pExitProcs[UTEXIT_PROCS_MAX-1].exitProc == NULL);

    //
    // Now we look for the first free slot in the array, since we guarantee
    // to call exit procs in the order they were registered in:
    //
    for (i = 0; i < UTEXIT_PROCS_MAX; i++)
    {
        if (pExitProcs[i].exitProc == NULL)
        {
            TRACE_OUT(("Storing exit proc 0x%08x data 0x%08x at position %d",
                exitProc, exitData, i));

            pExitProcs[i].exitProc = exitProc;
            pExitProcs[i].exitData = exitData;
            break;
        }
    }

    ASSERT(i < UTEXIT_PROCS_MAX);


    DebugExitVOID(UT_RegisterExit);
}


//
//
// UT_DeregisterExit(...)
//
//
void UT_DeregisterExit
(
    PUT_CLIENT      putTask,
    UTEXIT_PROC     exitProc,
    LPVOID          exitData
)
{
    int                i;
    BOOL               found = FALSE;
    PUTEXIT_PROC_INFO  pExitProcs;

    DebugEntry(UT_DeregisterExit);

    ValidateUTClient(putTask);

    pExitProcs = putTask->exitProcs;

    //
    // Find this exit proc
    //
    for (i = 0 ; i < UTEXIT_PROCS_MAX; i++)
    {

        if ((pExitProcs[i].exitProc == exitProc) &&
            (pExitProcs[i].exitData == exitData))
        {
            //
            // Found exit proc.  Shuffle list down.
            //
            TRACE_OUT(("Deregistering exit proc 0x%08x from position %d",
                 exitProc, i));
            found = TRUE;

            UT_MoveMemory(&pExitProcs[i],
                &pExitProcs[i+1],
                sizeof(UTEXIT_PROC_INFO) * (UTEXIT_PROCS_MAX - 1 - i));

            pExitProcs[UTEXIT_PROCS_MAX-1].exitProc = NULL;
            break;
        }
    }

    //
    // Check that we found the exit procs
    //
    ASSERT(found);

    DebugExitVOID(UT_DeregisterExit);

}




//
// UTTriggerEvt()
//
void UTTriggerEvt
(
    PUT_CLIENT      putFrom,
    PUT_CLIENT      putTo
)
{
    DebugEntry(UTTriggerEvt);

    ValidateUTClient(putFrom);
    ValidateUTClient(putTo);

    if (putTo->utHwnd)
    {
        if (!PostMessage(putTo->utHwnd, WM_UTTRIGGER_MSG, 0, 0))
        {
            //
            // Failed to send event
            //
            WARNING_OUT(("Failed to post trigger message from %x to %x",
                putFrom, putTo));
        }
    }

    DebugExitVOID(UTTriggerEvt);
}


//
//
// UTStartDelayedEventTimer(...)
//
//
void UTStartDelayedEventTimer(PUT_CLIENT putTask, UINT popTime)
{
    UINT    currentTickCount;
    UINT    delay = 1;

    DebugEntry(UTStartDelayedEventTimer);

    //
    // Work out the delay from the current time to popTime (popTime is
    // given in terms of the system tick count).  Be careful in the case
    // where we have already passed popTime...
    //
    currentTickCount = GetTickCount();
    if (popTime > currentTickCount)
    {
        delay = popTime - currentTickCount;
    }

    //
    // Set the timer going.  Note that if the timer has already been
    // started, this call will reset it using the new delay.
    //
    if (!SetTimer(putTask->utHwnd, UT_DELAYED_TIMER_ID, delay, NULL))
    {
        ERROR_OUT(("Could not create timer for delayed event"));
    }

    DebugExitVOID(UTStartDelayedEventTimer);
}



//
// UT_HandleProcessStart()
//
BOOL UT_HandleProcessStart(HINSTANCE hInstance)
{
    BOOL        rc = FALSE;
    int         lock;
    WNDCLASS    windowClass;

    DebugEntry(UT_HandleProcessStart);

    //
    // Save our dll handle.
    //
    g_asInstance = hInstance;

    //
    // Init our critical sections
    //
    for (lock = UTLOCK_FIRST; lock < UTLOCK_MAX; lock++)
    {
        InitializeCriticalSection(&g_utLocks[lock]);
    }

    //
    // Register the UT window class
    //
    windowClass.style         = 0;
    windowClass.lpfnWndProc   = UT_WndProc;
    windowClass.cbClsExtra    = 0;
    windowClass.cbWndExtra    = 0;
    windowClass.hInstance     = g_asInstance;
    windowClass.hIcon         = NULL;
    windowClass.hCursor       = NULL;
    windowClass.hbrBackground = NULL;
    windowClass.lpszMenuName  = NULL;
    windowClass.lpszClassName = UT_WINDOW_CLASS;

    g_utWndClass = RegisterClass(&windowClass);
    if (!g_utWndClass)
    {
        ERROR_OUT(("Failed to register class"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(UT_HandleProcessStart, rc);
    return(rc);
}


//
// UT_HandleProcessEnd()
//
void UT_HandleProcessEnd(void)
{
    int                 lock;
    PUT_CLIENT          putTask;
    int                 task;

    DebugEntry(UT_HandleProcessEnd);

    TRACE_OUT(("Process is ending"));

    //
    // Loop through all the registered UT tasks looking for those on this
    // process.  Start at the end, and work up to the front.
    //
    putTask = &(g_autTasks[UTTASK_MAX - 1]);
    for (task = UTTASK_MAX - 1; task >= UTTASK_FIRST; task--, putTask--)
    {
        //
        // Is this entry in the UTM in use ?
        //
        if (putTask->dwThreadId)
        {
            //
            // Clean up after this UT task
            //
            TRACE_OUT(("Task %x ending without calling UT_TermTask", putTask));

            //
            // On ProcessEnd, the windows are no longer valid.  If it took
            // too long to shutdown, we might not have received a thread
            // detach notification.  In which case we wouldn't have cleaned
            // up the thread objects.
            //
            if (putTask->dwThreadId != GetCurrentThreadId())
            {
                putTask->utHwnd = NULL;
            }
            UTTaskEnd(putTask);
        }
    }

    if (g_utWndClass)
    {
        UnregisterClass(MAKEINTATOM(g_utWndClass), g_asInstance);
        g_utWndClass = 0;
    }

    //
    // Clean up the critical sections.  Do this last to first, in inverse
    // order that they are created.
    //
    for (lock = UTLOCK_MAX-1; lock >= UTLOCK_FIRST; lock--)
    {
        DeleteCriticalSection(&g_utLocks[lock]);
    }

    DebugExitVOID(UT_HandleProcessEnd);
}


//
// UT_HandleThreadEnd()
//
void UT_HandleThreadEnd(void)
{
    PUT_CLIENT      putTask;
    DWORD           dwThreadId;
    int             task;

    DebugEntry(UT_HandleThreadEnd);

    UT_Lock(UTLOCK_UT);

    //
    // Get the current thread ID
    //
    dwThreadId = GetCurrentThreadId();

    //
    // Loop through all the registered UT tasks looking for one on this
    // process and thread.  Note that there should only be one entry in the
    // UTM for each thread, so we can break out of the loop if we get a
    // match.
    //
    putTask = &(g_autTasks[UTTASK_MAX - 1]);
    for (task = UTTASK_MAX - 1; task >= UTTASK_FIRST; task--, putTask--)
    {
        //
        // Is there a task here that matches the current thread?
        // Tasks not present have 0 for the thread ID, which won't match
        //
        if (putTask->dwThreadId == dwThreadId)
        {
            //
            // Clean up after this UT task
            //
            WARNING_OUT(("Task %x ending without calling UT_TermTask", putTask));
            UTTaskEnd(putTask);
        }
    }

    UT_Unlock(UTLOCK_UT);

    DebugExitVOID(UT_HandleThreadEnd);
}


//
//
// UT_WndProc(...)
//
//
LRESULT CALLBACK UT_WndProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    LRESULT     retVal = 0;
    PUT_CLIENT  putTask;

    DebugEntry(UT_WndProc);

    //
    // This isn't a UT message, so we should handle it
    //
    switch (message)
    {
        case WM_TIMER:
            //
            // WM_TIMER is used for delayed events...
            //
            TRACE_OUT(("Timer Id is 0x%08x", wParam));

            if (wParam == UT_DELAYED_TIMER_ID) // defined as 0x10101010
            {
                //
                // Get our UT handle from the window data
                //
                putTask = (PUT_CLIENT)GetWindowLongPtr(hwnd, GWLP_USERDATA);
                ValidateUTClient(putTask);

                //
                // Stop the timer before it ticks again !
                //
                KillTimer(putTask->utHwnd, UT_DELAYED_TIMER_ID);

                //
                // Process the delayed event
                //
                UTCheckDelayedEvents(putTask);
            }
            break;

        case WM_UTTRIGGER_MSG:
            putTask = (PUT_CLIENT)GetWindowLongPtr(hwnd, GWLP_USERDATA);
            ValidateUTClient(putTask);

            //
            // Distribute pending events
            //
            UTCheckEvents(putTask);
            break;

        default:
            //
            // Call on to the default handler
            //
            retVal = DefWindowProc(hwnd, message, wParam, lParam);
            break;
    }

    DebugExitDWORD(UT_WndProc, retVal);
    return(retVal);
}


//
//
// UTCheckEvents()
// This delivers any normal pending events
//
//
void UTCheckEvents
(
    PUT_CLIENT          putTask
)
{
    PUTEVENT_INFO       pEventInfo;
    BOOL                eventsOnQueue     = TRUE;
    int                 eventsProcessed   = 0;
    UINT                event;
    UINT_PTR            param1, param2;

    DebugEntry(UTCheckEvents);

    UT_Lock(UTLOCK_UT);

    //
    // This while-loop picks any events off our queue and calls the
    // handers.  We only process a certain number, to be a well behaved
    // task.  Many event handlers in turn post other events...
    //
    while (eventsOnQueue && (eventsProcessed < MAX_EVENTS_TO_PROCESS))
    {
        //
        // Are there any events waiting on the queue?
        //
        pEventInfo = (PUTEVENT_INFO)COM_BasedListFirst(&(putTask->pendingEvents),
            FIELD_OFFSET(UTEVENT_INFO, chain));
        if (pEventInfo != NULL)
        {
            ValidateEventInfo(pEventInfo);

            TRACE_OUT(("Event(s) pending - returning first one in queue"));

            //
            // Return event from queue
            //
            event  = pEventInfo->event;
            param1 = pEventInfo->param1;
            param2 = pEventInfo->param2;

            //
            // Remove event from queue
            //
            COM_BasedListRemove(&(pEventInfo->chain));

            //
            // Free the event
            //
            delete pEventInfo;
        }
        else
        {
            //
            // No events on the queue - this can happen if we
            // process the event queue between the trigger event
            // being sent, amd the trigger event being received.
            //
            TRACE_OUT(("Got event trigger but no events on queue!"));
            DC_QUIT;
        }

        //
        // Check now if there are still events on the queue.
        //
        // NOTE:
        // We set up eventsOnQueue now, rather than after the call
        // to ProcessEvent - this means that if processing the last
        // event on the queue (say, event A) causes event B to be
        // posted back to ourselves, we will not process B until
        // later, when the event arrives for it.  This may seem
        // like an unnecessary delay but it is vital to prevent
        // yield nesting.
        //
        pEventInfo = (PUTEVENT_INFO)COM_BasedListFirst(&(putTask->pendingEvents),
            FIELD_OFFSET(UTEVENT_INFO, chain));
        if (pEventInfo == NULL)
        {
            eventsOnQueue = FALSE;
        }

        //
        // Unlock access to shared memory -- we're about to yield
        //
        UT_Unlock(UTLOCK_UT);
        UTProcessEvent(putTask, event, param1, param2);
        UT_Lock(UTLOCK_UT);

        if (!putTask->dwThreadId)
        {
            //
            // The task was terminated by the event.  bail out.
            //
            WARNING_OUT(("Task %x terminated in event handler", putTask));
            DC_QUIT;
        }

        //
        // Increment the number of events we've processed in this
        // loop.
        //
        eventsProcessed++;
    }

    //
    // There is an upper limit to the number of events we try to
    // process in one loop.  If we've reached this limit, post a
    // trigger event to ensure that we process the remaining events
    // later, then quit.
    //
    if (eventsProcessed >= MAX_EVENTS_TO_PROCESS)
    {
        TRACE_OUT(("Another trigger event required"));
        UTTriggerEvt(putTask, putTask);
    }

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_UT);

    DebugExitVOID(UTUtilitiesWndProc);
}



//
// UT_MallocRefCount()
//
// This allocates a ref-count block, one that doesn't go away until
// the ref-count reaches zero.
//
void * UT_MallocRefCount
(
    UINT    cbSizeMem,
    BOOL    fZeroMem
)
{
    PUTREFCOUNTHEADER   pHeader;
    void *              pMemory = NULL;

    DebugEntry(UT_MallocRefCount);

    //
    // Allocate a block the client's size + our header's size
    //
    pHeader = (PUTREFCOUNTHEADER)new BYTE[sizeof(UTREFCOUNTHEADER) + cbSizeMem];
    if (!pHeader)
    {
        ERROR_OUT(("UT_MallocRefCount failed; out of memory"));
        DC_QUIT;
    }

    if (fZeroMem)
    {
        ZeroMemory(pHeader, sizeof(UTREFCOUNTHEADER) + cbSizeMem);
    }

    SET_STAMP(pHeader, UTREFCOUNTHEADER);
    pHeader->refCount   = 1;

    pMemory = (pHeader + 1);

DC_EXIT_POINT:
    DebugExitPTR(UT_MallocRefCount, pMemory);
    return(pMemory);
}


//
// UT_BumpUpRefCount()
//
void UT_BumpUpRefCount
(
    void *  pMemory
)
{
    PUTREFCOUNTHEADER   pHeader;

    DebugEntry(UT_BumpUpRefCount);

    ASSERT(pMemory);

    pHeader = (PUTREFCOUNTHEADER)((LPBYTE)pMemory - sizeof(UTREFCOUNTHEADER));
    ASSERT(!IsBadWritePtr(pHeader, sizeof(UTREFCOUNTHEADER)));
    ASSERT(pHeader->stamp.idStamp[0] == 'A');
    ASSERT(pHeader->stamp.idStamp[1] == 'S');
    ASSERT(pHeader->refCount);

    pHeader->refCount++;
    TRACE_OUT(("Bumped up ref-counted memory block 0x%08x to %d", pHeader, pHeader->refCount));

    DebugExitVOID(UT_BumpUpRefCount);
}


//
// UT_FreeRefCount()
//
void UT_FreeRefCount
(
    void ** ppMemory,
    BOOL    fNullOnlyWhenFreed
)
{
    void *              pMemory;
    PUTREFCOUNTHEADER   pHeader;

    DebugEntry(UT_FreeRefCount);

    ASSERT(ppMemory);
    pMemory = *ppMemory;
    ASSERT(pMemory);

    pHeader = (PUTREFCOUNTHEADER)((LPBYTE)pMemory - sizeof(UTREFCOUNTHEADER));
    ASSERT(!IsBadWritePtr(pHeader, sizeof(UTREFCOUNTHEADER)));
    ASSERT(pHeader->stamp.idStamp[0] == 'A');
    ASSERT(pHeader->stamp.idStamp[1] == 'S');
    ASSERT(pHeader->refCount);

    if (--(pHeader->refCount) == 0)
    {
        TRACE_OUT(("Freeing ref-counted memory block 0x%08x", pHeader));
        delete[] pHeader;

        *ppMemory = NULL;
    }
    else
    {
        TRACE_OUT(("Bumped down ref-counted memory block 0x%08x to %d", pHeader, pHeader->refCount));
        if (!fNullOnlyWhenFreed)
            *ppMemory = NULL;
    }

    DebugExitVOID(UT_FreeRefCount);
}





//
// UT_MoveMemory - Copy source buffer to destination buffer
//
// Purpose:
//       UT_MoveMemory() copies a source memory buffer to a destination memory buffer.
//       This routine recognize overlapping buffers to avoid propogation.
//       For cases where propogation is not a problem, memcpy() can be used.
//
// Entry:
//       void *dst = pointer to destination buffer
//       const void *src = pointer to source buffer
//       size_t count = number of bytes to copy
//
// Exit:
//       Returns a pointer to the destination buffer
//
//Exceptions:
//

void *  UT_MoveMemory (
        void * dst,
        const void * src,
        size_t count
        )
{
        void * ret = dst;

        if (dst <= src || (char *)dst >= ((char *)src + count)) {
                //
                // Non-Overlapping Buffers
                // copy from lower addresses to higher addresses
                //
                while (count--) {
                        *(char *)dst = *(char *)src;
                        dst = (char *)dst + 1;
                        src = (char *)src + 1;
                }
        }
        else {
                //
                // Overlapping Buffers
                // copy from higher addresses to lower addresses
                //
                dst = (char *)dst + count - 1;
                src = (char *)src + count - 1;

                while (count--) {
                        *(char *)dst = *(char *)src;
                        dst = (char *)dst - 1;
                        src = (char *)src - 1;
                }
        }
        return(ret);
}




//
// COM_BasedListInsertBefore(...)
//
// See ut.h for description.
//
void COM_BasedListInsertBefore(PBASEDLIST pExisting, PBASEDLIST pNew)
{
    PBASEDLIST  pTemp;

    DebugEntry(COM_BasedListInsertBefore);

    //
    // Check for bad parameters.
    //
    ASSERT((pNew != NULL));
    ASSERT((pExisting != NULL));

    //
    // Find the item before pExisting:
    //
    pTemp = COM_BasedPrevListField(pExisting);
    ASSERT((pTemp != NULL));

    TRACE_OUT(("Inserting item at 0x%08x into list between 0x%08x and 0x%08x",
                 pNew, pTemp, pExisting));

    //
    // Set its <next> field to point to the new item
    //
    pTemp->next = PTRBASE_TO_OFFSET(pNew, pTemp);
    pNew->prev  = PTRBASE_TO_OFFSET(pTemp, pNew);

    //
    // Set <prev> field of pExisting to point to new item:
    //
    pExisting->prev = PTRBASE_TO_OFFSET(pNew, pExisting);
    pNew->next      = PTRBASE_TO_OFFSET(pExisting, pNew);

    DebugExitVOID(COM_BasedListInsertBefore);
} // COM_BasedListInsertBefore


//
// COM_BasedListInsertAfter(...)
//
// See ut.h for description.
//
void COM_BasedListInsertAfter(PBASEDLIST pExisting,
                                          PBASEDLIST pNew)
{
    PBASEDLIST  pTemp;

    DebugEntry(COM_BasedListInsertAfter);

    //
    // Check for bad parameters.
    //
    ASSERT((pNew != NULL));
    ASSERT((pExisting != NULL));

    //
    // Find the item after pExisting:
    //
    pTemp = COM_BasedNextListField(pExisting);
    ASSERT((pTemp != NULL));

    TRACE_OUT(("Inserting item at 0x%08x into list between 0x%08x and 0x%08x",
                 pNew, pExisting, pTemp));

    //
    // Set its <prev> field to point to the new item
    //
    pTemp->prev = PTRBASE_TO_OFFSET(pNew, pTemp);
    pNew->next  = PTRBASE_TO_OFFSET(pTemp, pNew);

    //
    // Set <next> field of pExisting to point to new item:
    //
    pExisting->next = PTRBASE_TO_OFFSET(pNew, pExisting);
    pNew->prev      = PTRBASE_TO_OFFSET(pExisting, pNew);

    DebugExitVOID(COM_BasedListInsertAfter);
} // COM_BasedListInsertAfter


//
// COM_BasedListRemove(...)
//
// See ut.h for description.
//
void COM_BasedListRemove(PBASEDLIST pListItem)
{
    PBASEDLIST pNext     = NULL;
    PBASEDLIST pPrev     = NULL;

    DebugEntry(COM_BasedListRemove);

    //
    // Check for bad parameters.
    //
    ASSERT((pListItem != NULL));

    pPrev = COM_BasedPrevListField(pListItem);
    pNext = COM_BasedNextListField(pListItem);

    ASSERT((pPrev != NULL));
    ASSERT((pNext != NULL));

    TRACE_OUT(("Removing item 0x%08x from list", pListItem));

    pPrev->next = PTRBASE_TO_OFFSET(pNext, pPrev);
    pNext->prev = PTRBASE_TO_OFFSET(pPrev, pNext);

    DebugExitVOID(COM_BasedListRemove);
}


void FAR * COM_BasedListNext ( PBASEDLIST pHead, void FAR * pEntry, UINT nOffset )
{
     PBASEDLIST p;

     ASSERT(pHead != NULL);
     ASSERT(pEntry != NULL);

     p = COM_BasedNextListField(COM_BasedStructToField(pEntry, nOffset));
     return ((p == pHead) ? NULL : COM_BasedFieldToStruct(p, nOffset));
}

void FAR * COM_BasedListPrev ( PBASEDLIST pHead, void FAR * pEntry, UINT nOffset )
{
     PBASEDLIST p;

     ASSERT(pHead != NULL);
     ASSERT(pEntry != NULL);

     p = COM_BasedPrevListField(COM_BasedStructToField(pEntry, nOffset));
     return ((p == pHead) ? NULL : COM_BasedFieldToStruct(p, nOffset));
}


void FAR * COM_BasedListFirst ( PBASEDLIST pHead, UINT nOffset )
{
    return (COM_BasedListIsEmpty(pHead) ?
            NULL :
            COM_BasedFieldToStruct(COM_BasedNextListField(pHead), nOffset));
}

void FAR * COM_BasedListLast ( PBASEDLIST pHead, UINT nOffset )
{
    return (COM_BasedListIsEmpty(pHead) ?
            NULL :
            COM_BasedFieldToStruct(COM_BasedPrevListField(pHead), nOffset));
}


void COM_BasedListFind ( LIST_FIND_TYPE   eType,
                           PBASEDLIST          pHead,
                           void FAR * FAR*  ppEntry,
                           UINT             nOffset,
                           int              nOffsetKey,
                           DWORD_PTR        Key,
                           int              cbKeySize )
{
    void *p = *ppEntry;
    DWORD val;

    switch (eType)
    {
        case LIST_FIND_FROM_FIRST:
	        p = COM_BasedListFirst(pHead, nOffset);
            break;

        case LIST_FIND_FROM_NEXT:
        	p = COM_BasedListNext(pHead, p, nOffset);
            break;

        default:
            ASSERT(FALSE);
    }

    // make sure the key size is no more than a dword
    ASSERT(cbKeySize <= sizeof(DWORD_PTR));

    while (p != NULL)
    {
        val = 0;
        CopyMemory(&val, (void *) ((DWORD_PTR) p + nOffsetKey), cbKeySize);
        if (val == Key)
        {
            break;
        }

        p = COM_BasedListNext(pHead, p, nOffset);
    }

    *ppEntry = p;
}



//
// COM_SimpleListAppend()
//
// For simple lists, such as hwnd list, app name list, proc id list
//

PSIMPLE_LIST COM_SimpleListAppend ( PBASEDLIST pHead, void FAR * pData )
{
    PSIMPLE_LIST p = new SIMPLE_LIST;
    if (p != NULL)
    {
        ZeroMemory(p, sizeof(*p));
        p->pData = pData;
        COM_BasedListInsertBefore(pHead, &(p->chain));
    }

    return p;
}

void FAR * COM_SimpleListRemoveHead ( PBASEDLIST pHead )
{
    void *pData = NULL;
    PBASEDLIST pdclist;
    PSIMPLE_LIST p;

    if (! COM_BasedListIsEmpty(pHead))
    {
        // get the first entry in the list
        pdclist = COM_BasedNextListField(pHead);
        p = (PSIMPLE_LIST) COM_BasedFieldToStruct(pdclist,
                                             offsetof(SIMPLE_LIST, chain));
        pData = p->pData;

        // remove the first entry in the list
        COM_BasedListRemove(pdclist);
        delete p;
    }

    return pData;
}


//
// COM_ReadProfInt(...)
//
// See ut.h for description.
//
void COM_ReadProfInt
(
    LPSTR   pSection,
    LPSTR   pEntry,
    int     defaultValue,
    int *   pValue
)
{
    int     localValue;

    DebugEntry(COM_ReadProfInt);

    //
    // Check for NULL parameters
    //
    ASSERT(pSection != NULL);
    ASSERT(pEntry != NULL);

    //
    // First try to read the value from the current user section.
    // Then try to read the value from the global local machine section.
    //
    if (COMReadEntry(HKEY_CURRENT_USER, pSection, pEntry, (LPSTR)&localValue,
            sizeof(int), REG_DWORD) ||
        COMReadEntry(HKEY_LOCAL_MACHINE, pSection, pEntry, (LPSTR)&localValue,
            sizeof(int), REG_DWORD))
    {
        *pValue = localValue;
    }
    else
    {
        *pValue = defaultValue;
    }

    DebugExitVOID(COM_ReadProfInt);
}



//
// FUNCTION: COMReadEntry(...)
//
// DESCRIPTION:
// ============
// Read an entry from the given section of the registry.  Allow type
// REG_BINARY (4 bytes) if REG_DWORD was requested.
//
//
// PARAMETERS:
// ===========
// topLevelKey      : one of:
//                      - HKEY_CURRENT_USER
//                      - HKEY_LOCAL_MACHINE
// pSection         : the section name to read from.  The DC_REG_PREFIX
//                    string is prepended to give the full name.
// pEntry           : the entry name to read.
// pBuffer          : a buffer to read the entry to.
// bufferSize       : the size of the buffer.
// expectedDataType : the type of data stored in the entry.
//
// RETURNS:
// ========
// Nothing.
//
//
BOOL COMReadEntry(HKEY    topLevelKey,
                                 LPSTR pSection,
                                 LPSTR pEntry,
                                 LPSTR pBuffer,
                                 int   bufferSize,
                                 ULONG expectedDataType)
{
    LONG        sysrc;
    HKEY        key;
    ULONG       dataType;
    ULONG       dataSize;
    char        subKey[COM_MAX_SUBKEY];
    BOOL        keyOpen = FALSE;
    BOOL        rc = FALSE;

    DebugEntry(COMReadEntry);

    //
    // Get a subkey for the value.
    //
    wsprintf(subKey, "%s%s", DC_REG_PREFIX, pSection);

    //
    // Try to open the key.  If the entry does not exist, RegOpenKeyEx will
    // fail.
    //
    sysrc = RegOpenKeyEx(topLevelKey,
                         subKey,
                         0,                   // reserved
                         KEY_ALL_ACCESS,
                         &key);

    if (sysrc != ERROR_SUCCESS)
    {
        //
        // Don't trace an error here since the subkey may not exist...
        //
        TRACE_OUT(("Failed to open key %s, rc = %d", subKey, sysrc));
        DC_QUIT;
    }
    keyOpen = TRUE;

    //
    // We successfully opened the key so now try to read the value.  Again
    // it may not exist.
    //
    dataSize = bufferSize;
    sysrc    = RegQueryValueEx(key,
                               pEntry,
                               0,          // reserved
                               &dataType,
                               (LPBYTE)pBuffer,
                               &dataSize);

    if (sysrc != ERROR_SUCCESS)
    {
        TRACE_OUT(("Failed to read value of [%s] %s, rc = %d",
                     pSection,
                     pEntry,
                     sysrc));
        DC_QUIT;
    }

    //
    // Check that the type is correct.  Special case: allow REG_BINARY
    // instead of REG_DWORD, as long as the length is 32 bits.
    //
    if ((dataType != expectedDataType) &&
        ((dataType != REG_BINARY) ||
         (expectedDataType != REG_DWORD) ||
         (dataSize != 4)))
    {
        WARNING_OUT(("Read value from [%s] %s, but type is %d - expected %d",
                     pSection,
                     pEntry,
                     dataType,
                     expectedDataType));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:

    //
    // Close the key (if required).
    //
    if (keyOpen)
    {
        sysrc = RegCloseKey(key);
        if (sysrc != ERROR_SUCCESS)
        {
            ERROR_OUT(("Failed to close key, rc = %d", sysrc));
        }
    }

    DebugExitBOOL(COMReadEntry, rc);
    return(rc);
}



//
// COM_GetSiteName()
//
void COM_GetSiteName(LPSTR siteName, UINT siteNameLen)
{
    LRESULT rc;
    HKEY    hkeyUserDetails;
    DWORD   cbData;
    TCHAR   szNameBuffer[MAX_PATH];

    DebugEntry(COM_GetSiteName);

    //
    // Get this site address from the registry
    //
    rc = RegOpenKey(HKEY_CURRENT_USER,
                    ISAPI_KEY TEXT("\\") REGKEY_USERDETAILS,
                    &hkeyUserDetails);

    if (rc == ERROR_SUCCESS)
    {
        //
        // We read the data into our own local buffer, rather than directly
        // into the passed buffer, because the passed buffer is normally 48
        // bytes long, but if the registry has been mis-setup it may be
        // longer than this.
        //
        // Unfortunately Windows stubbornly returns an error when the
        // buffer is smaller than is required, and has no way of returning
        // the truncated string.
        //
        // To avoid this we get the value into a good size buffer, then
        // copy just the bit we want.
        //
        cbData = sizeof(szNameBuffer);

	    rc = RegQueryValueEx(hkeyUserDetails,
	                             REGVAL_ULS_NAME,
	                             NULL,
	                             NULL,
	                             (LPBYTE)szNameBuffer,
	                             &cbData);

        RegCloseKey(hkeyUserDetails);
    }

    if (rc == ERROR_SUCCESS)
    {
        //
        // Copy from our local buffer into the passed buffer.
        // Ensure there is a NUL terminator at the end.
        //
        lstrcpyn(siteName, szNameBuffer, siteNameLen);
    }
    else
    {
        //
        // Failing to read the site name is not an error.
        // Use the computer name instead.
        //
     	DWORD dwComputerNameLength = siteNameLen;
  		GetComputerName(siteName, &dwComputerNameLength);
    }

    TRACE_OUT(("Site name is <%s>", siteName));

    DebugExitVOID(COM_GetSiteName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\view.cpp ===
#include "precomp.h"
#include <version.h>
#include <nmhelp.h>

//
// VIEW.CPP
// The frame, widgets, and client area that presents the shared apps/desktop
// for a remote host.
//
// Copyright(c) Microsoft 1997-
//

//
// NOTE:
// The client of the shared view frame represents the virtual desktop (VD)
// of the host.  For 3.0 hosts, the VD is the same as the screen.  But for
// 2.x hosts, the VD is the union of the screen size of all hosts.  Hence
// the recalculation every time someone starts sharing or changes screen
// size, and the extra fun this entails for existing shared 2.x views.
//

#define MLZ_FILE_ZONE  ZONE_CORE


// Help file
static const TCHAR s_cszHtmlHelpFile[] = TEXT("conf.chm");

//
// VIEW_Init()
//
BOOL  VIEW_Init(void)
{
    BOOL        rc = FALSE;
    WNDCLASSEX  wc;


    DebugEntry(VIEW_Init);

    //
    // Register the frame window class.
    // NOTE:  Change CS_NOCLOSE if/when we ever let you close the view
    // of a person's shared apps.
    //
    wc.cbSize           = sizeof(wc);
    wc.style            = CS_DBLCLKS | CS_NOCLOSE;
    wc.lpfnWndProc      = VIEWFrameWindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = g_asInstance;
    wc.hIcon            = NULL;
    wc.hCursor          = ::LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_3DFACE+1);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = VIEW_FRAME_CLASS_NAME;
    wc.hIconSm          = NULL;

    if (!RegisterClassEx(&wc))
    {
        ERROR_OUT(("Failed to register AS Frame class"));
        DC_QUIT;
    }

    //
    // Register the view window class.  This sits in the client area of
    // the frame along with the statusbar, tray, etc.  It displays
    // the remote host's shared contents.
    //
    wc.cbSize           = sizeof(wc);
    wc.style            = CS_DBLCLKS | CS_NOCLOSE;
    wc.lpfnWndProc      = VIEWClientWindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = g_asInstance;
    wc.hIcon            = NULL;
    wc.hCursor          = NULL;
    wc.hbrBackground    = NULL;
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = VIEW_CLIENT_CLASS_NAME;
    wc.hIconSm          = NULL;

    if (!RegisterClassEx(&wc))
    {
        ERROR_OUT(("Failed to register AS Client class"));
        DC_QUIT;
    }

    //
    // Register the window bar class.  This hugs the bottom of
    // frames for shared apps (not desktop) and acts like a tray
    // surrogate.  It allows controllers to minimize, restore, and
    // activate shared windows that may not be on screen currently
    // and therefore not in the view area.
    //
    // It also is handy reference for what top level windows are shared
    // currently.
    //
    wc.cbSize           = sizeof(wc);
    wc.style            = 0;
    wc.lpfnWndProc      = VIEWWindowBarProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = g_asInstance;
    wc.hIcon            = NULL;
    wc.hCursor          = ::LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_3DFACE+1);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = VIEW_WINDOWBAR_CLASS_NAME;
    wc.hIconSm          = NULL;

    if (!RegisterClassEx(&wc))
    {
        ERROR_OUT(("Failed to register AS WindowBar class"));
        DC_QUIT;
    }

    //
    // Register the window bar items class.  This is a child of the window
    // bar and contains the actual items.
    //
    wc.cbSize           = sizeof(wc);
    wc.style            = 0;
    wc.lpfnWndProc      = VIEWWindowBarItemsProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = g_asInstance;
    wc.hIcon            = NULL;
    wc.hCursor          = ::LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_3DFACE+1);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = VIEW_WINDOWBARITEMS_CLASS_NAME;
    wc.hIconSm          = NULL;

    if (!RegisterClassEx(&wc))
    {
        ERROR_OUT(("Failed to register AS WindowBarItems class"));
        DC_QUIT;
    }

    //
    // Register the full screen exit button class.  This is a child of the
    // the view client when present.
    //
    wc.cbSize           = sizeof(wc);
    wc.style            = 0;
    wc.lpfnWndProc      = VIEWFullScreenExitProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = g_asInstance;
    wc.hIcon            = NULL;
    wc.hCursor          = ::LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = NULL;
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = VIEW_FULLEXIT_CLASS_NAME;
    wc.hIconSm          = NULL;

    if (!RegisterClassEx(&wc))
    {
        ERROR_OUT(("Failed to register AS full screen exit class"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:

    DebugExitBOOL(VIEW_Init, rc);
    return(rc);
}


//
// VIEW_Term()
//
void  VIEW_Term(void)
{
    DebugEntry(VIEW_Term);

    //
    // Free all resources we created (or may have created in window class
    // case).
    //
    UnregisterClass(VIEW_FULLEXIT_CLASS_NAME, g_asInstance);
    UnregisterClass(VIEW_WINDOWBARITEMS_CLASS_NAME, g_asInstance);
    UnregisterClass(VIEW_WINDOWBAR_CLASS_NAME, g_asInstance);
    UnregisterClass(VIEW_CLIENT_CLASS_NAME, g_asInstance);
    UnregisterClass(VIEW_FRAME_CLASS_NAME, g_asInstance);

    DebugExitVOID(VIEW_Term);
}



//
// VIEW_ShareStarting()
// Creates share resources
//
BOOL ASShare::VIEW_ShareStarting(void)
{
    BOOL        rc = FALSE;
    HBITMAP     hbmpT;
    TEXTMETRIC  tm;
    HDC         hdc;
    HFONT       hfnOld;
    char        szRestore[256];
    SIZE        extent;

    DebugEntry(ASShare::VIEW_ShareStarting);

    ASSERT(m_viewVDSize.x == 0);
    ASSERT(m_viewVDSize.y == 0);

    //
    // Get NODROP cursor
    //
    m_viewNotInControl = ::LoadCursor(NULL, IDC_NO);

    //
    // Get MOUSEWHEEL lines metric
    //
    SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0,
        &m_viewMouseWheelScrollLines, 0);

    //
    // Create a pattern brush from the obscured bitmap
    //
    hbmpT = LoadBitmap(g_asInstance, MAKEINTRESOURCE(IDB_OBSCURED));
    m_viewObscuredBrush = CreatePatternBrush(hbmpT);
    DeleteBitmap(hbmpT);

    if (!m_viewObscuredBrush)
    {
        ERROR_OUT(( "Failed to create obscured bitmap brush"));
        DC_QUIT;
    }

    //
    // NOTE THAT since the icons are VGA colors, we don't need to recreate
    // our brush on a SYSCOLOR change.
    //

    // Get the full screen cancel icon
    m_viewFullScreenExitIcon = (HICON)LoadImage(g_asInstance,
        MAKEINTRESOURCE(IDI_CANCELFULLSCREEN), IMAGE_ICON,
        GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON),
        LR_DEFAULTCOLOR);

    m_viewEdgeCX    = ::GetSystemMetrics(SM_CXEDGE);
    m_viewEdgeCY    = ::GetSystemMetrics(SM_CYEDGE);

    //
    // Get metrics of GUI_FONT, the one we use in the window bar and
    // status bar.
    //
    LoadString(g_asInstance, IDS_RESTORE, szRestore, sizeof(szRestore));

    hdc = ::GetDC(NULL);
    hfnOld = (HFONT)::SelectObject(hdc, ::GetStockObject(DEFAULT_GUI_FONT));

    ::GetTextMetrics(hdc, &tm);

    ::GetTextExtentPoint(hdc, szRestore, lstrlen(szRestore), &extent);

    ::SelectObject(hdc, hfnOld);
    ::ReleaseDC(NULL, hdc);

    //
    // Calculate size of full screen button
    // Edge on left + margin on left + sm icon + margin + text + margin on
    //      right + edge on right == 5 edges + sm icon + text
    //
    m_viewFullScreenCX = extent.cx + 5*m_viewEdgeCX + GetSystemMetrics(SM_CXSMICON);
    m_viewFullScreenCY = max(GetSystemMetrics(SM_CYSMICON), extent.cy) + 4*m_viewEdgeCY;

    //
    // Calculate size of items on window bar
    //
    m_viewItemCX = 4*m_viewEdgeCX + ::GetSystemMetrics(SM_CXSMICON) +
        m_viewEdgeCX + VIEW_MAX_ITEM_CHARS * tm.tmAveCharWidth;
    m_viewItemCY = max(::GetSystemMetrics(SM_CYSMICON), tm.tmHeight) +
        2*m_viewEdgeCY + 2*m_viewEdgeCY;

    //
    // Calculate the width & height of the items scroll buttons.  We want
    // to make sure it fits, but isn't ungainly.
    //
    m_viewItemScrollCX = ::GetSystemMetrics(SM_CXHSCROLL);
    m_viewItemScrollCX = 2 * min(m_viewItemScrollCX, m_viewItemCY);

    m_viewItemScrollCY = ::GetSystemMetrics(SM_CYHSCROLL);
    m_viewItemScrollCY = min(m_viewItemScrollCY, m_viewItemCY);


    //
    // Calculate height of active window bar.  We leave a CYEDGE gap on the
    // top.  between it and the sunken border around the view client.
    //
    m_viewWindowBarCY = m_viewItemCY + m_viewEdgeCY;

    //
    // Calculate height of status bar.  It's height of GUIFONT plus edge
    // space.
    //

    m_viewStatusBarCY = tm.tmHeight + 4*m_viewEdgeCY;

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::VIEW_ShareStarting, rc);
    return(rc);
}



//
// VIEW_ShareEnded()
// Cleans up resources for share
//
void ASShare::VIEW_ShareEnded(void)
{
    DebugEntry(ASShare::VIEW_ShareEnded);

    //
    // Destroy the full screen cancel icon
    //
    if (m_viewFullScreenExitIcon != NULL)
    {
        DestroyIcon(m_viewFullScreenExitIcon);
        m_viewFullScreenExitIcon = NULL;
    }

    if (m_viewObscuredBrush != NULL)
    {
        DeleteBrush(m_viewObscuredBrush);
        m_viewObscuredBrush = NULL;
    }

    DebugExitVOID(ASShre::VIEW_ShareEnded);
}




//
// VIEW_PartyLeftShare()
//
// This is called when somebody leaves a share.  We need this to
// simulate what back-level systems did to calculate the virtual desktop
// size.  They didn't recalc when someone stopped shared, that person's
// screne size counted until they left the share.
//
void ASShare::VIEW_PartyLeftShare(ASPerson * pasPerson)
{
    DebugEntry(ASShare::VIEW_PartyLeftShare);

    ValidatePerson(pasPerson);

    // If this dude ever shared, now remove him from the VD total
    if (pasPerson->viewExtent.x != 0)
    {
        pasPerson->viewExtent.x            = 0;
        pasPerson->viewExtent.y            = 0;
        VIEW_RecalcVD();
    }

    DebugExitVOID(ASShare::VIEW_PartyLeftShare);
}




//
// VIEW_HostStarting()
//
// Called when we start to host.
//
BOOL ASHost::VIEW_HostStarting(void)
{
    DebugEntry(ASHost:VIEW_HostStarting);

    m_pShare->VIEW_RecalcExtent(m_pShare->m_pasLocal);
    m_pShare->VIEW_RecalcVD();

    DebugExitBOOL(ASHost::VIEW_HostStarting, TRUE);
    return(TRUE);
}


//
// VIEW_ViewStarting()
// Called when someone in the meeting starts to share.  For all in the
// conference, we keep a running tally of the VD, but use it only for
// 2.x views.  For remotes only, we create a view of their desktop.
//
BOOL ASShare::VIEW_ViewStarting(ASPerson * pasHost)
{
    BOOL    rc = FALSE;
    HWND    hwnd;
    RECT    rcSize;

    DebugEntry(ASShare::VIEW_ViewStarting);

    ValidateView(pasHost);

    //
    // First, calculate the extents, and the VD size.
    //
    VIEW_RecalcExtent(pasHost);
    VIEW_RecalcVD();

    //
    // Next, create scratch regions
    //
    pasHost->m_pView->m_viewExtentRgn = CreateRectRgn(0, 0, 0, 0);
    pasHost->m_pView->m_viewScreenRgn = CreateRectRgn(0, 0, 0, 0);
    pasHost->m_pView->m_viewPaintRgn  = CreateRectRgn(0, 0, 0, 0);
    pasHost->m_pView->m_viewScratchRgn = CreateRectRgn(0, 0, 0, 0);

    if (!pasHost->m_pView->m_viewExtentRgn || !pasHost->m_pView->m_viewScreenRgn || !pasHost->m_pView->m_viewPaintRgn || !pasHost->m_pView->m_viewScratchRgn)
    {
        ERROR_OUT(("ViewStarting: Couldn't create scratch regions"));
        DC_QUIT;
    }


    ASSERT(pasHost->m_pView->m_viewFrame == NULL);
    ASSERT(pasHost->m_pView->m_viewClient  == NULL);
    ASSERT(pasHost->m_pView->m_viewSharedRgn == NULL);
    ASSERT(pasHost->m_pView->m_viewObscuredRgn == NULL);
    ASSERT(pasHost->m_pView->m_viewPos.x == 0);
    ASSERT(pasHost->m_pView->m_viewPos.y == 0);
    ASSERT(pasHost->m_pView->m_viewPage.x == 0);
    ASSERT(pasHost->m_pView->m_viewPage.y == 0);

    ASSERT(!pasHost->m_pView->m_viewStatusBarOn);
    ASSERT(!pasHost->m_pView->m_viewWindowBarOn);
    ASSERT(!pasHost->m_pView->m_viewFullScreen);

    pasHost->m_pView->m_viewStatusBarOn = TRUE;
    if (pasHost->hetCount != HET_DESKTOPSHARED)
    {
        pasHost->m_pView->m_viewWindowBarOn = TRUE;
    }

    //
    // Calculate the ideal size for this window.
    //
    VIEWFrameGetSize(pasHost, &rcSize);

    //
    // Create the frame.  This will in turn create its children.
    //
    pasHost->m_pView->m_viewMenuBar = ::LoadMenu(g_asInstance,
        MAKEINTRESOURCE(IDM_FRAME));
    if (!pasHost->m_pView->m_viewMenuBar)
    {
        ERROR_OUT(("ViewStarting: couldn't load frame menu"));
        DC_QUIT;
    }

    //
    // Do once-only capabilities/menu stuff.
    //

    //
    // SEND CTRL+ALT+DEL:
    // Append Ctrl+Alt+Del after separator to control menu, if this
    // is a view of a service host on NT.
    //
    if (pasHost->hetCount == HET_DESKTOPSHARED)
    {
        //
        // Remove applications submenu
        //
        DeleteMenu(pasHost->m_pView->m_viewMenuBar, IDSM_WINDOW,
            MF_BYPOSITION);

        if ((pasHost->cpcCaps.general.typeFlags & AS_SERVICE) &&
            (pasHost->cpcCaps.general.OS == CAPS_WINDOWS)     &&
            (pasHost->cpcCaps.general.OSVersion == CAPS_WINDOWS_NT))
        {
            HMENU   hSubMenu;
            MENUITEMINFO mii;
            CHAR szMenu[32];

            hSubMenu = GetSubMenu(pasHost->m_pView->m_viewMenuBar, IDSM_CONTROL);

            ZeroMemory(&mii, sizeof(mii));

            // Separator
            mii.cbSize  = sizeof(mii);
            mii.fMask   = MIIM_TYPE;
            mii.fType   = MFT_SEPARATOR;
            InsertMenuItem(hSubMenu, -1, TRUE, &mii);

            // Send Ctrl-Alt-Del command
            mii.fMask   = MIIM_ID | MIIM_STATE | MIIM_TYPE;
            mii.fType   = MFT_STRING;
            mii.fState  = MFS_ENABLED;
            mii.wID     = CMD_CTRLALTDEL;

            LoadString(g_asInstance, IDS_CMD_CTRLALTDEL, szMenu,
                                                    sizeof(szMenu));
            mii.dwTypeData  = szMenu;
            mii.cch         = lstrlen(szMenu);

            InsertMenuItem(hSubMenu, -1, TRUE, &mii);
        }
    }

    //
    // FULL SCREEN:
    // We only enable Full Screen for 3.0 hosts (since with 2.x desktop
    // scrolling the view area can change) who have screen sizes identical
    // to ours.
    //
    if ((pasHost->cpcCaps.general.version >= CAPS_VERSION_30) &&
        (pasHost->cpcCaps.screen.capsScreenWidth ==
            m_pasLocal->cpcCaps.screen.capsScreenWidth) &&
        (pasHost->cpcCaps.screen.capsScreenHeight ==
            m_pasLocal->cpcCaps.screen.capsScreenHeight))
    {
        ::EnableMenuItem(pasHost->m_pView->m_viewMenuBar, CMD_VIEWFULLSCREEN,
            MF_ENABLED | MF_BYCOMMAND);
    }

    if (m_pasLocal->m_caControlledBy)
    {
        WARNING_OUT(("VIEWStarting: currently controlled, create view hidden"));
    }

    //
    // If we are currently controlled, create the frame invisible since
    // we hid all the visible ones when we started being this way.
    //
    hwnd = CreateWindowEx(
            WS_EX_WINDOWEDGE,
            VIEW_FRAME_CLASS_NAME,  // See RegisterClass() call.
            NULL,
            WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX |
                WS_MAXIMIZEBOX | WS_CLIPCHILDREN | (!m_pasLocal->m_caControlledBy ? WS_VISIBLE : 0),
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            pasHost->viewExtent.x >= m_pasLocal->cpcCaps.screen.capsScreenWidth ?
                CW_USEDEFAULT : rcSize.right - rcSize.left,

            pasHost->viewExtent.y >= m_pasLocal->cpcCaps.screen.capsScreenHeight ?
                CW_USEDEFAULT : rcSize.bottom - rcSize.top,
            NULL,
            pasHost->m_pView->m_viewMenuBar,
            g_asInstance,
            pasHost                       // Pass in person ptr
            );

    if (hwnd == NULL)
    {
        ERROR_OUT(("ViewStarting: couldn't create frame window"));
        DC_QUIT;
    }

    //
    // OK, now we've created this frame window.  Go through the sizing
    // process again to make sure the scrollbars are OK.
    //
    VIEWClientExtentChange(pasHost, FALSE);

    if (!m_pasLocal->m_caControlledBy)
    {
        SetForegroundWindow(hwnd);
        UpdateWindow(hwnd);
    }

#ifdef _DEBUG
    TRACE_OUT(("TIME TO SEE SOMETHING: %08d MS",
        ::GetTickCount() - g_asSession.scShareTime));
    g_asSession.scShareTime = 0;
#endif // DEBUG

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::VIEW_ViewStarting, rc);
    return(rc);
}


//
// VIEW_ViewEnded()
//
// Called when someone we are viewing stops hosting, so we can clean up.
//
void  ASShare::VIEW_ViewEnded(ASPerson * pasHost)
{
    DebugEntry(ASShare::VIEW_ViewEnded);

    ValidateView(pasHost);

    if (pasHost->m_pView->m_viewInformDlg != NULL)
    {
        SendMessage(pasHost->m_pView->m_viewInformDlg, WM_COMMAND, IDCANCEL, 0);
        ASSERT(!pasHost->m_pView->m_viewInformDlg);
        ASSERT(!pasHost->m_pView->m_viewInformMsg);
        ASSERT(IsWindowEnabled(pasHost->m_pView->m_viewFrame));
    }

    if (pasHost->m_pView->m_viewFrame != NULL)
    {
        //
        // The frame is the parent of the view, toolbar, etc.  Those
        // should all be NULL when we return.
        //
        DestroyWindow(pasHost->m_pView->m_viewFrame);
        ASSERT(pasHost->m_pView->m_viewFrame == NULL);
    }

    ASSERT(pasHost->m_pView->m_viewClient == NULL);

    if (pasHost->m_pView->m_viewMenuBar != NULL)
    {
        ::DestroyMenu(pasHost->m_pView->m_viewMenuBar);
        pasHost->m_pView->m_viewMenuBar = NULL;
    }

    if (pasHost->m_pView->m_viewSharedRgn != NULL)
    {
        DeleteRgn(pasHost->m_pView->m_viewSharedRgn);
        pasHost->m_pView->m_viewSharedRgn = NULL;
    }

    if (pasHost->m_pView->m_viewObscuredRgn != NULL)
    {
        DeleteRgn(pasHost->m_pView->m_viewObscuredRgn);
        pasHost->m_pView->m_viewObscuredRgn = NULL;
    }

    //
    // Destroy scratch regions
    //
    if (pasHost->m_pView->m_viewScratchRgn != NULL)
    {
        DeleteRgn(pasHost->m_pView->m_viewScratchRgn);
        pasHost->m_pView->m_viewScratchRgn = NULL;
    }

    if (pasHost->m_pView->m_viewPaintRgn != NULL)
    {
        DeleteRgn(pasHost->m_pView->m_viewPaintRgn);
        pasHost->m_pView->m_viewPaintRgn = NULL;
    }

    if (pasHost->m_pView->m_viewScreenRgn != NULL)
    {
        DeleteRgn(pasHost->m_pView->m_viewScreenRgn);
        pasHost->m_pView->m_viewScreenRgn = NULL;
    }

    if (pasHost->m_pView->m_viewExtentRgn != NULL)
    {
        DeleteRgn(pasHost->m_pView->m_viewExtentRgn);
        pasHost->m_pView->m_viewExtentRgn = NULL;
    }


    pasHost->m_pView->m_viewPos.x                = 0;
    pasHost->m_pView->m_viewPos.y                = 0;
    pasHost->m_pView->m_viewPage.x               = 0;
    pasHost->m_pView->m_viewPage.y               = 0;
    pasHost->m_pView->m_viewPgSize.x             = 0;
    pasHost->m_pView->m_viewPgSize.y             = 0;
    pasHost->m_pView->m_viewLnSize.x             = 0;
    pasHost->m_pView->m_viewLnSize.y             = 0;

    DebugExitVOID(ASShare::VIEW_ViewEnded);
}



//
// VIEW_InControl()
//
// Called when we start/stop controlling this host.  We enable the
// toolbar, statusbar, tray, etc., and change the cursor from being the
// nodrop.
//
void ASShare::VIEW_InControl
(
    ASPerson *  pasHost,
    BOOL        fStart
)
{
    POINT       ptCursor;

    DebugEntry(ASShare::VIEW_InControl);

    //
    // We're changing our state, and that affects the contents of our
    // menu bar.  So cancel out of menu mode, and spare problems/faults/
    // inapplicable commands.
    //
    if (pasHost->m_pView->m_viewInMenuMode)
    {
        SendMessage(pasHost->m_pView->m_viewFrame, WM_CANCELMODE, 0, 0);
        ASSERT(!pasHost->m_pView->m_viewInMenuMode);
    }

    //
    // If starting in control and a message is up, kill it.  Then bring our
    // window to the front.
    //
    if (fStart)
    {
        if (pasHost->m_pView->m_viewInformDlg != NULL)
        {
            SendMessage(pasHost->m_pView->m_viewInformDlg, WM_COMMAND, IDCANCEL, 0);
            ASSERT(!pasHost->m_pView->m_viewInformDlg);
            ASSERT(!pasHost->m_pView->m_viewInformMsg);
            ASSERT(IsWindowEnabled(pasHost->m_pView->m_viewFrame));
        }

        SetForegroundWindow(pasHost->m_pView->m_viewFrame);
    }

    //
    // App Sharing (not desktop sharing) stuff
    //
    if (pasHost->hetCount && (pasHost->hetCount != HET_DESKTOPSHARED))
    {
        //
        // Enable/disable window bar
        //
        ASSERT(IsWindow(pasHost->m_pView->m_viewWindowBar));
        ::EnableWindow(::GetDlgItem(pasHost->m_pView->m_viewWindowBar,
            IDVIEW_ITEMS), fStart);

        //
        // Enable/Disable Applications submenu
        //
        EnableMenuItem(pasHost->m_pView->m_viewMenuBar, IDSM_WINDOW,
            (fStart ? MF_ENABLED : MF_GRAYED) | MF_BYPOSITION);

        if (!pasHost->m_pView->m_viewFullScreen)
        {
            DrawMenuBar(pasHost->m_pView->m_viewFrame);
        }
    }

    //
    // Change title bar
    //
    VIEW_HostStateChange(pasHost);

    //
    // Turn off/on shadow cursors
    //
    CM_UpdateShadowCursor(pasHost, fStart, pasHost->cmPos.x, pasHost->cmPos.y,
        pasHost->cmHotSpot.x, pasHost->cmHotSpot.y);

    //
    // This will reset cursor image:
    //      * from nodrop to shared if in control
    //      * from shared to nodrop if not in control
    //
    // This will also, if in control, cause a mousemove to get sent to the
    // host we're controlling so his cursor pos is synced with ours, if the
    // mouse is over the frame client area.
    //
    GetCursorPos(&ptCursor);
    SetCursorPos(ptCursor.x, ptCursor.y);

    DebugExitVOID(ASShare::VIEW_InControl);
}



//
// VIEW_PausedInControl()
//
// Updates status bar etc. when control is paused.
//
void ASShare::VIEW_PausedInControl
(
    ASPerson *  pasHost,
    BOOL        fPaused
)
{
    DebugEntry(ASShare::VIEW_PausedInControl);

    ValidatePerson(pasHost);

    ASSERT(pasHost->m_caControlledBy == m_pasLocal);

    //
    // Update status bar
    //

    //
    // Disable/Enable window menu
    //

    //
    // Put shadow cursors on/off
    //

    //
    // Jiggle cursor
    //

    DebugExitVOID(ASShare::VIEW_PausedInControl);
}



//
// VIEW_HostStateChange()
//
// Called when a host's state has changed, via broadcast notification or
// local operations.
//
// We update the titlebar and commands.
//
void ASShare::VIEW_HostStateChange
(
    ASPerson *  pasHost
)
{
    char        szFormat[256];
    char        szTitleText[256];
    char        szOtherPart[128];

    DebugEntry(ASShare::VIEW_HostStateChange);

    ValidatePerson(pasHost);

    //
    // If this person isn't hosting anymore, don't do anything.  We're
    // cleaning up after him.
    //
    if (!pasHost->hetCount)
    {
        DC_QUIT;
    }

    //
    // Make up trailing string
    //
    if (pasHost->m_caControlledBy)
    {
        LoadString(g_asInstance, IDS_TITLE_INCONTROL, szFormat, sizeof(szFormat));
        wsprintf(szOtherPart, szFormat, pasHost->m_caControlledBy->scName);
    }
    else if (pasHost->m_caAllowControl)
    {
        LoadString(g_asInstance, IDS_TITLE_CONTROLLABLE, szOtherPart, sizeof(szOtherPart));
    }
    else
    {
        szOtherPart[0] = 0;
    }

    if (pasHost->hetCount == HET_DESKTOPSHARED)
    {
        LoadString(g_asInstance, IDS_TITLE_SHAREDDESKTOP, szFormat, sizeof(szFormat));
    }
    else
    {
        ASSERT(pasHost->hetCount);
        LoadString(g_asInstance, IDS_TITLE_SHAREDPROGRAMS, szFormat, sizeof(szFormat));
    }

    wsprintf(szTitleText, szFormat, pasHost->scName, szOtherPart);

    ::SetWindowText(pasHost->m_pView->m_viewFrame, szTitleText);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::VIEW_HostStateChange);
}



//
// VIEW_UpdateStatus()
//
// Updates the PERMANENT status of this frame.  When we go into menu mode,
// the strings shown are temporary only, not saved.  When we come out of
// menu mode, we put back the temporary status.
//
void ASShare::VIEW_UpdateStatus
(
    ASPerson *  pasHost,
    UINT        idsStatus
)
{
    DebugEntry(ASShare::VIEW_UpdateStatus);

    ValidatePerson(pasHost);

    pasHost->m_pView->m_viewStatus = idsStatus;
    VIEWFrameSetStatus(pasHost, idsStatus);

    DebugExitVOID(ASShare::VIEW_UpdateStatus);
}


void ASShare::VIEWFrameSetStatus
(
    ASPerson *  pasHost,
    UINT        idsStatus
)
{
    char szStatus[256];

    DebugEntry(ASShare::VIEWFrameSetStatus);

    if (idsStatus != IDS_STATUS_NONE)
    {
        LoadString(g_asInstance, idsStatus, szStatus, sizeof(szStatus));
    }
    else
    {
        szStatus[0] = 0;
    }
    ::SetWindowText(pasHost->m_pView->m_viewStatusBar, szStatus);

    DebugExitVOID(ASShare::VIEWFrameSetStatus);
}




//
// VIEW_Message()
//
// Puts up a message to inform the end user of something.
//
void ASShare::VIEW_Message
(
    ASPerson *  pasHost,
    UINT        ids
)
{
    DebugEntry(ASShare::VIEW_Message);

    ValidateView(pasHost);

    if (!pasHost->m_pView)
    {
        WARNING_OUT(("Can't show VIEW message; [%d] not hosting", pasHost->mcsID));
        DC_QUIT;
    }

    if (pasHost->m_pView->m_viewInformDlg)
    {
        // Kill the previous one
        TRACE_OUT(("Killing previous informational mesage for [%d]",
            pasHost->mcsID));
        SendMessage(pasHost->m_pView->m_viewInformDlg, WM_COMMAND, IDCANCEL, 0);
        ASSERT(!pasHost->m_pView->m_viewInformDlg);
        ASSERT(!pasHost->m_pView->m_viewInformMsg);
    }

    if (m_pasLocal->m_caControlledBy)
    {
        WARNING_OUT(("VIEW_Message:  ignoring, view is hidden since we're controlled"));
    }
    else
    {
        pasHost->m_pView->m_viewInformMsg = ids;
        pasHost->m_pView->m_viewInformDlg = CreateDialogParam(g_asInstance,
            ((ids != IDS_ABOUT) ? MAKEINTRESOURCE(IDD_INFORM) : MAKEINTRESOURCE(IDD_ABOUT)),
            pasHost->m_pView->m_viewFrame, VIEWDlgProc, (LPARAM)pasHost);
        if (!pasHost->m_pView->m_viewInformDlg)
        {
            ERROR_OUT(("Failed to create inform message box for [%d]",
                pasHost->mcsID));
            pasHost->m_pView->m_viewInformMsg = 0;
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::VIEW_Message);
}



//
// VIEWStartControlled()
//
// If we are about to start being controlled, we hide all the frames
// to get them out of the way AND prevent hangs caused by modal loop code
// in Win9x title bar dragging.
//
void ASShare::VIEWStartControlled(BOOL fStart)
{
    ASPerson *  pasT;

    DebugEntry(ASShare::VIEWStartControlled);

    for (pasT = m_pasLocal; pasT != NULL; pasT = pasT->pasNext)
    {
        if (pasT->m_pView)
        {
            if (fStart)
            {
                ASSERT(IsWindowVisible(pasT->m_pView->m_viewFrame));
                ShowOwnedPopups(pasT->m_pView->m_viewFrame, FALSE);
                SetWindowPos(pasT->m_pView->m_viewFrame, NULL, 0, 0, 0, 0,
                    SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER |
                    SWP_HIDEWINDOW);
            }
            else
            {
                ASSERT(!IsWindowVisible(pasT->m_pView->m_viewFrame));
                SetWindowPos(pasT->m_pView->m_viewFrame, NULL, 0, 0, 0, 0,
                    SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER |
                    SWP_SHOWWINDOW);
                ShowOwnedPopups(pasT->m_pView->m_viewFrame, TRUE);
            }
        }
    }

    DebugEntry(ASShare::VIEWStartControlled);
}


//
// VIEW_DlgProc()
//
// Handles informing user dialog
//
INT_PTR CALLBACK VIEWDlgProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    return(g_asSession.pShare->VIEW_DlgProc(hwnd, message, wParam, lParam));
}


BOOL ASShare::VIEW_DlgProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    BOOL        rc = TRUE;
    ASPerson *  pasHost;

    DebugEntry(VIEW_DlgProc);

    pasHost = (ASPerson *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if (pasHost)
    {
        ValidateView(pasHost);
    }

    switch (message)
    {
        case WM_INITDIALOG:
        {
            char szT[256];
            char szRes[512];
            RECT rcText;
            RECT rcOwner;

            pasHost = (ASPerson *)lParam;
            ValidateView(pasHost);
            pasHost->m_pView->m_viewInformDlg = hwnd;

            SetWindowLongPtr(hwnd, GWLP_USERDATA, lParam);

            ASSERT(pasHost->m_pView->m_viewInformMsg);

            if (pasHost->m_pView->m_viewInformMsg == IDS_ABOUT)
            {
                // About box
                GetDlgItemText(hwnd, CTRL_ABOUTVERSION, szT, sizeof(szT));
                wsprintf(szRes, szT, VER_PRODUCTRELEASE_STR,
                    VER_PRODUCTVERSION_STR);
                SetDlgItemText(hwnd, CTRL_ABOUTVERSION, szRes);
            }
            else
            {
                HDC     hdc;
                HFONT   hfn;

                // Set title.
                if ((pasHost->m_pView->m_viewInformMsg >= IDS_ERR_TAKECONTROL_FIRST) &&
                    (pasHost->m_pView->m_viewInformMsg <= IDS_ERR_TAKECONTROL_LAST))
                {
                    LoadString(g_asInstance, IDS_TITLE_TAKECONTROL_FAILED,
                        szT, sizeof(szT));
                    SetWindowText(hwnd, szT);
                }

                // Set message
                LoadString(g_asInstance, pasHost->m_pView->m_viewInformMsg,
                    szT, sizeof(szT));
                wsprintf(szRes, szT, pasHost->scName);
                SetDlgItemText(hwnd, CTRL_INFORM, szRes);

                // Center the message vertically
                GetWindowRect(GetDlgItem(hwnd, CTRL_INFORM), &rcOwner);
                MapWindowPoints(NULL, hwnd, (LPPOINT)&rcOwner, 2);

                rcText = rcOwner;

                hdc = GetDC(hwnd);
                hfn = (HFONT)SendDlgItemMessage(hwnd, CTRL_INFORM, WM_GETFONT, 0, 0);
                hfn = SelectFont(hdc, hfn);

                DrawText(hdc, szRes, -1, &rcText, DT_NOCLIP | DT_EXPANDTABS |
                    DT_NOPREFIX | DT_WORDBREAK | DT_CALCRECT);

                SelectFont(hdc, hfn);
                ReleaseDC(hwnd, hdc);

                ASSERT((rcText.bottom - rcText.top) <= (rcOwner.bottom - rcOwner.top));

                SetWindowPos(GetDlgItem(hwnd, CTRL_INFORM), NULL,
                    rcOwner.left,
                    ((rcOwner.top + rcOwner.bottom) - (rcText.bottom - rcText.top)) / 2,
                    (rcOwner.right - rcOwner.left),
                    rcText.bottom - rcText.top,
                    SWP_NOACTIVATE | SWP_NOZORDER);
            }

            // Disable owner
            EnableWindow(pasHost->m_pView->m_viewFrame, FALSE);

            // Show window, centered around owner midpoint
            GetWindowRect(pasHost->m_pView->m_viewFrame, &rcOwner);
            GetWindowRect(hwnd, &rcText);

            SetWindowPos(hwnd, NULL,
                ((rcOwner.left + rcOwner.right) - (rcText.right - rcText.left)) / 2,
                ((rcOwner.top + rcOwner.bottom) - (rcText.bottom - rcText.top)) / 2,
                0, 0, SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER);

            ShowWindow(hwnd, SW_SHOWNORMAL);
            UpdateWindow(hwnd);
            break;
        }

        case WM_COMMAND:
        {
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                case IDCANCEL:
                {
                    if(pasHost)
                    {
                        ASSERT(!IsWindowEnabled(pasHost->m_pView->m_viewFrame));
                        EnableWindow(pasHost->m_pView->m_viewFrame, TRUE);
                    }

                    DestroyWindow(hwnd);
                    break;
                }
            }
            break;
        }

        case WM_DESTROY:
        {
            if (pasHost)
            {
                pasHost->m_pView->m_viewInformDlg = NULL;
                pasHost->m_pView->m_viewInformMsg = 0;
            }

            SetWindowLongPtr(hwnd, GWLP_USERDATA, NULL);
            break;
        }

        default:
        {
            rc = FALSE;
            break;
        }
    }

    DebugExitBOOL(VIEW_DlgProc, rc);
    return(rc);
}



//
// VIEW_RecalcExtent()
//
// This recalculates the extent of the view of the host.
//
void ASShare::VIEW_RecalcExtent(ASPerson * pasHost)
{
    DebugEntry(ASShare::VIEW_RecalcExtent);

    TRACE_OUT(("VIEW_RecalcExtent:  New view extent (%04d, %04d) for [%d] version %x",
        pasHost->viewExtent.x, pasHost->viewExtent.y,
        pasHost->mcsID, pasHost->cpcCaps.general.version));

    //
    // Compute the extent of the view:
    //      For 2.x dudes, it's the VD size (union of all hosts)
    //      For 3.0 dudes, it's the host screen size
    //
    // REMOVE THIS WHEN 2.X COMPAT IS GONE
    //
    if (pasHost->cpcCaps.general.version >= CAPS_VERSION_30)
    {
        pasHost->viewExtent.x = pasHost->cpcCaps.screen.capsScreenWidth;
        pasHost->viewExtent.y = pasHost->cpcCaps.screen.capsScreenHeight;
    }
    else
    {
        //
        // We do this so that the window is created the right size in the
        // first place.  Then in VIEW_RecalcVD nothing will happen to it,
        // because the extent won't alter.
        //
        pasHost->viewExtent.x = max(m_viewVDSize.x, pasHost->cpcCaps.screen.capsScreenWidth);
        pasHost->viewExtent.y = max(m_viewVDSize.y, pasHost->cpcCaps.screen.capsScreenHeight);
    }

    DebugExitVOID(ASShare::VIEW_RecalcExtent);
}

//
// VIEW_RecalcVD()
// This recalculates the virtual desktop size when a remote starts/stops
// sharing, or if a host's screen changes size.  The VD is the union of
// all the screen sizes of those hosting.  2.x nodes work in a virtual
// desktop, and may scroll over.  For each 2.x view, we want the client to
// represent the VD, but with only the stuff on screen on the host to be
// interactable.
//
void ASShare::VIEW_RecalcVD(void)
{
    POINT       ptVDNew;
    ASPerson *  pas;

    DebugEntry(ASShare::VIEW_RecalcVD);

    //
    // First, loop through all the hosts and recompute the VD.
    //
    ptVDNew.x = 0;
    ptVDNew.y = 0;

    for (pas = m_pasLocal; pas != NULL; pas = pas->pasNext)
    {
        //
        // NOTE:
        // For local dudes, we won't have an HWND.  Use viewExtent, if
        // we don't think the person is sharing, it will be zero.
        //
        if (pas->viewExtent.x != 0)
        {
            TRACE_OUT(("VIEW_RecalcVD: Found host [%d], screen size (%04d, %04d)",
                pas->mcsID, pas->cpcCaps.screen.capsScreenWidth, pas->cpcCaps.screen.capsScreenHeight));

            ptVDNew.x = max(ptVDNew.x, pas->cpcCaps.screen.capsScreenWidth);
            ptVDNew.y = max(ptVDNew.y, pas->cpcCaps.screen.capsScreenHeight);

            TRACE_OUT(("VIEW_RecalcVD: Computed VD size now (%04d, %04d)",
                ptVDNew.x, ptVDNew.y));
        }
    }

    //
    // If the VD size didn't change, we're done.
    //
    if ((ptVDNew.x != m_viewVDSize.x) || (ptVDNew.y != m_viewVDSize.y))
    {
        TRACE_OUT(("VIEW_RecalcVD: VD size changed from (%04d, %04d) to (%04d, %04d)",
            m_viewVDSize.x, m_viewVDSize.y, ptVDNew.x, ptVDNew.y));

        m_viewVDSize = ptVDNew;

        //
        // Now loop through all the 2.x hosts, and update their extent, then
        // have them do the resize voodoo so the scrollbar pos isn't out of
        // range, etc.
        //
        // NOTE:  Since us, the local guy, is not 2.x we can skip ourselves.
        //
        ValidatePerson(m_pasLocal);

        for (pas = m_pasLocal->pasNext; pas != NULL; pas = pas->pasNext)
        {
            if ((pas->cpcCaps.general.version < CAPS_VERSION_30) && (pas->m_pView != NULL))
            {
                ASSERT(m_viewVDSize.x != 0);
                ASSERT(m_viewVDSize.y != 0);

                // Potential resize/range change
                if ((pas->viewExtent.x != m_viewVDSize.x) ||
                    (pas->viewExtent.y != m_viewVDSize.y))
                {
                    TRACE_OUT(("VIEW_RecalcVD: Found 2.x host [%d], must update old extent (%04d, %04d)",
                        pas->mcsID, pas->viewExtent.x, pas->viewExtent.y));

                    VIEW_RecalcExtent(pas);
                    VIEWClientExtentChange(pas, TRUE);
                }
            }
        }
    }

    DebugExitVOID(ASShare::VIEW_RecalcVD);
}


//
// VIEW_IsPointShared()
// This determines, given a point relative to the client of the view for
// the remote on this system, if it is in a shared area.
//
BOOL  ASShare::VIEW_IsPointShared
(
    ASPerson *  pasHost,
    POINT       ptLocal
)
{
    BOOL        rc = FALSE;
    RECT        rcClient;

    DebugEntry(ASShare::VIEW_IsPointShared);

    ValidateView(pasHost);

    //
    // Convert to client coords, and adjust for scrolling offset.  That
    // result is the equivalent point on the host desktop.
    //
    GetClientRect(pasHost->m_pView->m_viewClient, &rcClient);
    if (!PtInRect(&rcClient, ptLocal))
    {
        TRACE_OUT(("VIEW_IsPointShared: point not in client area"));
        return(FALSE);
    }

    //
    // The obscured and shared areas are saved in frame client coords,
    // so we don't need to account for the scroll position all the time.
    // When the scroll position changes the regions are updated.
    //

    //
    // NOTE that this order works for both desktop and app sharing
    //
    if ((pasHost->m_pView->m_viewObscuredRgn != NULL) &&
        PtInRegion(pasHost->m_pView->m_viewObscuredRgn, ptLocal.x, ptLocal.y))
    {
        rc = FALSE;
    }
    else if ((pasHost->m_pView->m_viewSharedRgn != NULL) &&
        !PtInRegion(pasHost->m_pView->m_viewSharedRgn, ptLocal.x, ptLocal.y))
    {
        rc = FALSE;
    }
    else
    {
        //
        // 2.x hosts may be scrolled over.  If so, shared stuff offscreen
        // is also considered to be obscured.
        //
        RECT    rcScreen;

        //
        // Compute what part of the VD, in local client coords, is visible
        // on the remote's screen.
        //
        SetRect(&rcScreen, 0, 0, pasHost->cpcCaps.screen.capsScreenWidth, pasHost->cpcCaps.screen.capsScreenHeight);

        OffsetRect(&rcScreen,
            pasHost->m_pView->m_dsScreenOrigin.x - pasHost->m_pView->m_viewPos.x,
            pasHost->m_pView->m_dsScreenOrigin.y - pasHost->m_pView->m_viewPos.y);
        if (!PtInRect(&rcScreen, ptLocal))
        {
            TRACE_OUT(("VIEW_IsPointShared: point is in shared stuff but not visible on remote screen"));
            rc = FALSE;
        }
        else
        {
            rc = TRUE;
        }
    }

    DebugExitBOOL(AShare::VIEW_IsPointShared, rc);
    return(rc);
}



//
// VIEW_ScreenChanged()
//
void  ASShare::VIEW_ScreenChanged(ASPerson * pasPerson)
{
    DebugEntry(ASShare::VIEW_ScreenChanged);

    ValidatePerson(pasPerson);

    //
    // Recompute the extent
    //
    VIEW_RecalcExtent(pasPerson);
    VIEWClientExtentChange(pasPerson, TRUE);

    VIEW_RecalcVD();

    DebugExitVOID(ASShare::VIEW_ScreenChanged);
}



//
// VIEW_SetHostRegions()
// This sets the new shared & obscured areas.
//
// Note that this routine takes responsibility for the regions pass in; it
// will delete them and/or the old ones if necessary.
//
void  ASShare::VIEW_SetHostRegions
(
    ASPerson *  pasHost,
    HRGN        rgnShared,
    HRGN        rgnObscured
)
{
    DebugEntry(ASShare::VIEW_SetHostRegions);

    ValidateView(pasHost);

    //
    // Return immediately if either region handle is bogus.  This can happen
    // when we are running low on memory.
    //
    if (!rgnShared || !rgnObscured)
    {
        ERROR_OUT(("Bad host regions for person [%u]", pasHost->mcsID));

        if (rgnShared != NULL)
        {
            DeleteRgn(rgnShared);
        }

        if (rgnObscured != NULL)
        {
            DeleteRgn(rgnObscured);
        }
    }
    else
    {
        HRGN    hrgnInvalid;
#ifdef _DEBUG
        RECT    rcT;

        ::GetRgnBox(rgnShared, &rcT);
        TRACE_OUT(("Shared region {%04d, %04d, %04d, %04d} for host [%d]",
            rcT.left, rcT.top, rcT.right, rcT.bottom, pasHost->mcsID));

        ::GetRgnBox(rgnObscured, &rcT);
        TRACE_OUT(("Obscured region {%04d, %04d, %04d, %04d} for host [%d]",
            rcT.left, rcT.top, rcT.right, rcT.bottom, pasHost->mcsID));
#endif // _DEBUG

        //
        // Update the current shared, obscured areas.  Adjust for the
        // scroll position so these are saved in client-relative coords.
        //
        OffsetRgn(rgnShared, -pasHost->m_pView->m_viewPos.x, -pasHost->m_pView->m_viewPos.y);
        OffsetRgn(rgnObscured, -pasHost->m_pView->m_viewPos.x, -pasHost->m_pView->m_viewPos.y);

        //
        // The invalid area is whatever changed in the obscured area and
        // the shared area.  In other words, the union - the intersection.
        //
        hrgnInvalid = NULL;

        if (pasHost->m_pView->m_viewSharedRgn != NULL)
        {
            HRGN    hrgnU;
            HRGN    hrgnI;

            ASSERT(pasHost->m_pView->m_viewObscuredRgn != NULL);

            //
            // If we're in a low memory situation, just invalidate everything
            // and hope it can be repainted.
            //
            hrgnU = CreateRectRgn(0, 0, 0, 0);
            hrgnI = CreateRectRgn(0, 0, 0, 0);
            if (!hrgnU || !hrgnI)
                goto SkipMinimalInvalidate;

            hrgnInvalid = CreateRectRgn(0, 0, 0, 0);
            if (!hrgnInvalid)
                goto SkipMinimalInvalidate;


            //
            // WE'RE GOING TO DO THE SAME THING FOR BOTH SHARED AND
            // OBSCURED REGIONS.
            //

            // Get the union of the old and new shared regions
            UnionRgn(hrgnU, pasHost->m_pView->m_viewSharedRgn, rgnShared);

            // Get the intersection of the old and new shared regions
            IntersectRgn(hrgnI, pasHost->m_pView->m_viewSharedRgn, rgnShared);

            //
            // The intersection is what used to be shared and is still shared.
            // The rest is changing, it needs to be repainted.  That's the
            // union minus the intersection.
            //
            SubtractRgn(hrgnU, hrgnU, hrgnI);
#ifdef _DEBUG
            GetRgnBox(hrgnU, &rcT);
            TRACE_OUT(("VIEW_SetHostRegions: Shared area change {%04d, %04d, %04d, %04d}",
                rcT.left, rcT.top, rcT.right, rcT.bottom));
#endif // _DEBUG

            // Add this to the invalidate total
            UnionRgn(hrgnInvalid, hrgnInvalid, hrgnU);

            //
            // REPEAT FOR THE OBSCURED REGION
            //
            UnionRgn(hrgnU, pasHost->m_pView->m_viewObscuredRgn, rgnObscured);
            IntersectRgn(hrgnI, pasHost->m_pView->m_viewObscuredRgn, rgnObscured);
            SubtractRgn(hrgnU, hrgnU, hrgnI);

#ifdef _DEBUG
            GetRgnBox(hrgnU, &rcT);
            TRACE_OUT(("VIEW_SetHostRegions: Obscured area change {%04d, %04d, %04d, %04d}",
                rcT.left, rcT.top, rcT.right, rcT.bottom));
#endif // _DEBUG
            UnionRgn(hrgnInvalid, hrgnInvalid, hrgnU);

SkipMinimalInvalidate:
            //
            // Clean up scratch regions
            //
            if (hrgnI != NULL)
                DeleteRgn(hrgnI);
            if (hrgnU != NULL)
                DeleteRgn(hrgnU);

            DeleteRgn(pasHost->m_pView->m_viewSharedRgn);
            pasHost->m_pView->m_viewSharedRgn = rgnShared;

            DeleteRgn(pasHost->m_pView->m_viewObscuredRgn);
            pasHost->m_pView->m_viewObscuredRgn = rgnObscured;

            //
            // DO NOT CALL VIEW_InvalidateRgn here, that expects a region in
            // screen coords of pasHost.  We have a region that is
            // client coords relative.  So just call InvalidateRgn() directly.
            //
            InvalidateRgn(pasHost->m_pView->m_viewClient, hrgnInvalid, FALSE);

            if (hrgnInvalid != NULL)
                DeleteRgn(hrgnInvalid);
        }
        else
        {
            RECT    rcBound;

            // The shared & obscured regions are both NULL or both non-NULL
            ASSERT(pasHost->m_pView->m_viewObscuredRgn == NULL);

            pasHost->m_pView->m_viewSharedRgn = rgnShared;
            pasHost->m_pView->m_viewObscuredRgn = rgnObscured;

            //
            // This is the first SWL packet we've received.  Snap the
            // scrollbars to the start of the total shared area.  This avoids
            // having the view come up, but look empty because the shared
            // apps are out of the range.  We do this even if the user
            // scrolled around in the window already.
            //
            // The total shared area is the union of the real shared +
            // obscured shared areas.  Convert back to remote VD coords!
            //
            UnionRgn(pasHost->m_pView->m_viewScratchRgn, rgnShared, rgnObscured);
            GetRgnBox(pasHost->m_pView->m_viewScratchRgn, &rcBound);
            OffsetRect(&rcBound, pasHost->m_pView->m_viewPos.x, pasHost->m_pView->m_viewPos.y);

            //
            // Is any part of what was shared within the extent of the view?
            // If not, we can't do anything--there's nothing to show.
            //
            if ((rcBound.right <= 0) ||
                (rcBound.left  >= pasHost->viewExtent.x) ||
                (rcBound.bottom <= 0) ||
                (rcBound.top >= pasHost->viewExtent.y))
            {
                TRACE_OUT(("VIEW_SetHostRegions:  Can't snap to shared area; none is visible"));
            }
            else
            {
                //
                // Use top left corner of bounds
                // VIEWClientScroll() will pin position w/in range
                //
                VIEWClientScroll(pasHost, rcBound.left, rcBound.top);
            }

            InvalidateRgn(pasHost->m_pView->m_viewClient, NULL, FALSE);
        }
    }

    DebugExitVOID(ASShare::VIEW_SetHostRegions);
}


//
// VIEW_InvalidateRect()
// Repaints the given rect.  This is for EXTERNAL code which passes in VD
// coords.  We convert to client coordinates by accounting for the scroll
// position.
//
void  ASShare::VIEW_InvalidateRect
(
    ASPerson *  pasPerson,
    LPRECT      lprc
)
{
    DebugEntry(ASShare::VIEW_InvalidateRect);

    ValidateView(pasPerson);

    //
    // Convert to client coords
    //
    if (lprc != NULL)
    {
        OffsetRect(lprc, -pasPerson->m_pView->m_viewPos.x, -pasPerson->m_pView->m_viewPos.y);
    }

    InvalidateRect(pasPerson->m_pView->m_viewClient, lprc, FALSE);

    //
    // Convert back so caller doesn't get a modified lprc
    //
    if (lprc != NULL)
    {
        OffsetRect(lprc, pasPerson->m_pView->m_viewPos.x, pasPerson->m_pView->m_viewPos.y);
    }

    DebugExitVOID(ASShare::VIEW_InvalidateRect);
}



//
// VIEW_InvalidateRgn()
// Repaints the given region.  This is for EXTERNAL code which passes in VD
// coords.  We convert to client coordinates by accounting fo the scroll
// position.
//
void  ASShare::VIEW_InvalidateRgn
(
    ASPerson *  pasHost,
    HRGN        rgnInvalid
)
{
#ifdef _DEBUG
    //
    // Make sure we the invalid region goes back to the caller unaltered,
    // even though we modify it temporarily here to avoid a copy.
    //
    RECT        rcBoundBefore;
    RECT        rcBoundAfter;
#endif // _DEBUG

    DebugEntry(ASShare::VIEW_InvalidateRgn);

    ValidatePerson(pasHost);

    //
    // Adjust the region if the frame view is scrolled over.
    //
    if (rgnInvalid != NULL)
    {
#ifdef _DEBUG
        GetRgnBox(rgnInvalid, &rcBoundBefore);
#endif // _DEBUG

        OffsetRgn(rgnInvalid, -pasHost->m_pView->m_viewPos.x, -pasHost->m_pView->m_viewPos.y);

#ifdef _DEBUG
        TRACE_OUT(("VIEW_InvalidateRgn: Invalidating area {%04d, %04d, %04d, %04d}",
            rcBoundBefore.left, rcBoundBefore.top, rcBoundBefore.right, rcBoundBefore.bottom));
#endif // _DEBUG
    }
    else
    {
        TRACE_OUT(("VIEW_InvalidateRgn: Invalidating entire client area"));
    }

    InvalidateRgn(pasHost->m_pView->m_viewClient, rgnInvalid, FALSE);

    if (rgnInvalid != NULL)
    {
        OffsetRgn(rgnInvalid, pasHost->m_pView->m_viewPos.x, pasHost->m_pView->m_viewPos.y);
#ifdef _DEBUG
        GetRgnBox(rgnInvalid, &rcBoundAfter);
        ASSERT(EqualRect(&rcBoundBefore, &rcBoundAfter));
#endif // _DEBUG
    }

    DebugExitVOID(ASShare::VIEW_InvalidateRgn);
}



//
// VIEWClientExtentChange()
//
void ASShare::VIEWClientExtentChange(ASPerson * pasHost, BOOL fRedraw)
{
    RECT    rcl;
    SCROLLINFO si;

    DebugEntry(ASShare::VIEWClientExtentChange);

    ValidatePerson(pasHost);
    if (!pasHost->m_pView)
        DC_QUIT;

#ifdef _DEBUG
    //
    // The client area (page size) shouldn't have changed.  Only the
    // extent has.
    //
    GetClientRect(pasHost->m_pView->m_viewClient, &rcl);
    ASSERT(pasHost->m_pView->m_viewPage.x == rcl.right - rcl.left);
    ASSERT(pasHost->m_pView->m_viewPage.y == rcl.bottom - rcl.top);
#endif // _DEBUG

    pasHost->m_pView->m_viewPgSize.x = pasHost->viewExtent.x / 8;
    pasHost->m_pView->m_viewPgSize.y = pasHost->viewExtent.y / 8;
    pasHost->m_pView->m_viewLnSize.x = pasHost->viewExtent.x / 64;
    pasHost->m_pView->m_viewLnSize.y = pasHost->viewExtent.y / 64;

    //
    // Move the scroll position to the origin.
    //

    //
    // Clip the current scroll pos if we need to, now that the extent
    // has changed size.
    //
    VIEWClientScroll(pasHost, pasHost->m_pView->m_viewPos.x, pasHost->m_pView->m_viewPos.y);

    si.cbSize = sizeof(SCROLLINFO);
    si.fMask = SIF_PAGE|SIF_POS|SIF_RANGE|SIF_DISABLENOSCROLL;

    // Set vertical info.  Is vert pos out of range now?
    si.nMin = 0;
    si.nMax = pasHost->viewExtent.y - 1;
    si.nPage = pasHost->m_pView->m_viewPage.y;
    si.nPos = pasHost->m_pView->m_viewPos.y;
    ASSERT(si.nPos <= si.nMax);

    TRACE_OUT(("VIEWClientExtentChange: Setting VERT scroll info:"));
    TRACE_OUT(("VIEWClientExtentChange:     nMin    %04d", si.nMin));
    TRACE_OUT(("VIEWClientExtentChange:     nMax    %04d", si.nMax));
    TRACE_OUT(("VIEWClientExtentChange:     nPage   %04d", si.nPage));
    TRACE_OUT(("VIEWClientExtentChange:     nPos    %04d", si.nPos));
    SetScrollInfo(pasHost->m_pView->m_viewClient, SB_VERT, &si, TRUE );

    // Set horizontal (x) information
    si.nMin = 0;
    si.nMax = pasHost->viewExtent.x - 1;
    si.nPage = pasHost->m_pView->m_viewPage.x;
    si.nPos = pasHost->m_pView->m_viewPos.x;
    ASSERT(si.nPos <= si.nMax);

    TRACE_OUT(("VIEWClientExtentChange: Setting HORZ scroll info:"));
    TRACE_OUT(("VIEWClientExtentChange:     nMin    %04d", si.nMin));
    TRACE_OUT(("VIEWClientExtentChange:     nMax    %04d", si.nMax));
    TRACE_OUT(("VIEWClientExtentChange:     nPage   %04d", si.nPage));
    TRACE_OUT(("VIEWClientExtentChange:     nPos    %04d", si.nPos));
    SetScrollInfo(pasHost->m_pView->m_viewClient, SB_HORZ, &si, TRUE );

    if (fRedraw)
    {
        // Is the frame window too big now?
        if ( (pasHost->m_pView->m_viewPage.x > pasHost->viewExtent.x) ||
             (pasHost->m_pView->m_viewPage.y > pasHost->viewExtent.y) )
        {
            TRACE_OUT(("VIEWClientExtentChange: client size (%04d, %04d) now bigger than view extent (%04d, %04d)",
                pasHost->m_pView->m_viewPage.x, pasHost->m_pView->m_viewPage.y,
                pasHost->viewExtent.x, pasHost->viewExtent.y));

            //
            // Calculate the ideal size for this window.
            //
            VIEWFrameGetSize(pasHost, &rcl);

            SetWindowPos( pasHost->m_pView->m_viewFrame,
                NULL, 0, 0, rcl.right - rcl.left, rcl.bottom - rcl.top,
                SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
        }

        TRACE_OUT(("VIEWClientExtentChange: Invalidating client area"));
        VIEW_InvalidateRgn(pasHost, NULL);
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::VIEWClientExtentChange);
}



//
// VIEWFrameWindowProc()
//
LRESULT CALLBACK VIEWFrameWindowProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    return(g_asSession.pShare->VIEW_FrameWindowProc(hwnd, message, wParam, lParam));
}


LRESULT ASShare::VIEW_FrameWindowProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    LRESULT     rc = 0;
    ASPerson *  pasHost;

    DebugEntry(VIEW_FrameWindowProc);

    pasHost = (ASPerson *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if (pasHost)
    {
        ValidateView(pasHost);
    }

    switch (message)
    {
        case WM_NCCREATE:
        {
            // Get the passed in host pointer, and set in our window long
            pasHost = (ASPerson *)((LPCREATESTRUCT)lParam)->lpCreateParams;
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pasHost);

            pasHost->m_pView->m_viewFrame = hwnd;

            //
            // Set the window icon
            //
            SendMessage(hwnd, WM_SETICON, ICON_BIG, (LPARAM)
                ((pasHost->hetCount == HET_DESKTOPSHARED) ?
                  g_hetDeskIcon : g_hetASIcon));
            goto DefWndProc;
            break;
        }

        case WM_NCDESTROY:
        {
            if (pasHost != NULL)
            {
                pasHost->m_pView->m_viewFrame = NULL;
            }

            goto DefWndProc;
            break;
        }

        case WM_CREATE:
        {
            // Set title
            VIEW_HostStateChange(pasHost);

            if (!VIEWFrameCreate(pasHost))
            {
                ERROR_OUT(("VIEWFrameWindowProc: errors in creation handling for [%d]", pasHost->mcsID));
                rc = -1;
            }

            break;
        }

        case WM_DESTROY:
        {
            //
            // Clear menu bar; we always destroy it ourself.
            //
            ::SetMenu(hwnd, NULL);
            break;
        }

        case WM_ACTIVATE:
        {
            //
            // If we're switching back to the view of the host we're in
            // control of, update the key states.
            //
            if (wParam)
            {
                SetFocus(pasHost->m_pView->m_viewClient);
            }
            else
            {
                //
                // If we're full screen but are deactivating, kick out of
                // full screenmode.
                //
                if (pasHost->m_pView->m_viewFullScreen)
                {
                    // Do this later, so title bar state isn't messed up
                    ::PostMessage(hwnd, WM_COMMAND, MAKELONG(CMD_VIEWFULLSCREEN, 0), 0);
                }
            }
            break;
        }

        case WM_ENTERMENULOOP:
        {
            pasHost->m_pView->m_viewInMenuMode = TRUE;
            break;
        }

        case WM_EXITMENULOOP:
        {
            pasHost->m_pView->m_viewInMenuMode = FALSE;
            break;
        }

        case WM_COMMAND:
        {
            VIEWFrameCommand(pasHost, wParam, lParam);
            break;
        }

        case WM_INITMENU:
        {
            if ((HMENU)wParam == pasHost->m_pView->m_viewMenuBar)
            {
                VIEWFrameInitMenuBar(pasHost);
            }
            break;
        }

        case WM_MENUSELECT:
        {
            VIEWFrameOnMenuSelect(pasHost, wParam, lParam);
            break;
        }

        case WM_PALETTECHANGED:
            //
            // The system palette has changed - repaint the window.
            //
            VIEW_InvalidateRgn(pasHost, NULL);

            //
            // The system palette has changed.  If we are not the
            // window that triggered this message then realize our
            // palette now to set up our new palette mapping.
            //
            if ((HWND)wParam == hwnd)
            {
                //
                // If this window caused the change return without
                // realizing our logical palette or we could end up in
                // an infinite loop.
                //
                break;
            }
            TRACE_OUT(("Palette changed - fall through to realize palette (%x)",
                                                           hwnd));

            //
            // Do not break here but FALL THROUGH to the code which
            // realizes the remote palette into this window.  This allows
            // the window to grab some color entries for itself in the new
            // system palette.
            //

        case WM_QUERYNEWPALETTE:
            rc = FALSE;

            if (message == WM_QUERYNEWPALETTE)
            {
                TRACE_OUT(( "WM_QUERYNEWPALETTE hwnd(%x)", hwnd));
            }

            if (g_usrPalettized)
            {
                HDC         hdc;
                HPALETTE    hPalOld;
                UINT        cChangedEntries;

                //
                // Realize this window's palette, and force a repaint
                // if necessary.
                //
                hdc = GetDC(hwnd);
                hPalOld = SelectPalette(hdc, pasHost->pmPalette, FALSE);
                cChangedEntries = RealizePalette(hdc);
                SelectPalette(hdc, hPalOld, FALSE);
                ReleaseDC(hwnd, hdc);

                rc = (cChangedEntries > 0);
                if (rc)
                {
                    // Have to repaint this window
                    VIEW_InvalidateRgn(pasHost, NULL);
                }
            }
            break;

        case WM_GETMINMAXINFO:
        {
            RECT rcFrame;
            LPMINMAXINFO lpmmi = (LPMINMAXINFO) lParam;
            int cx,cy;

            if (!pasHost)
            {
                // We're not created yet; bail.
                break;
            }

            //
            // Calculate the ideal maximized size for this window
            //
            VIEWFrameGetSize(pasHost, &rcFrame);

            //
            // If it's bigger than the local screen, clip it.
            //
            cx = min(rcFrame.right - rcFrame.left, m_pasLocal->cpcCaps.screen.capsScreenWidth);
            cy = min(rcFrame.bottom - rcFrame.top, m_pasLocal->cpcCaps.screen.capsScreenHeight);

            lpmmi->ptMaxSize.x = cx;
            lpmmi->ptMaxSize.y = cy;

            lpmmi->ptMaxTrackSize.x = cx;
            lpmmi->ptMaxTrackSize.y = cy;

            //
            // Make sure that we don't size this window too narrow.  Keep
            // space for borders and one window bar button + scroll ctl.
            //
            lpmmi->ptMinTrackSize.x = 2*::GetSystemMetrics(SM_CXSIZEFRAME) +
                (m_viewItemCX + m_viewEdgeCX) + m_viewItemScrollCX;

            //
            // And prevent sizing too short.  Keep space for borders, menu
            // bar, status bar, and window bar
            //
            lpmmi->ptMinTrackSize.y = 2*::GetSystemMetrics(SM_CYSIZEFRAME) +
                ::GetSystemMetrics(SM_CYCAPTION) + ::GetSystemMetrics(SM_CYMENU);

            if (pasHost->m_pView->m_viewWindowBarOn)
            {
                lpmmi->ptMinTrackSize.y += m_viewWindowBarCY + m_viewEdgeCY;
            }

            if (pasHost->m_pView->m_viewStatusBarOn)
            {
                lpmmi->ptMinTrackSize.y += m_viewStatusBarCY + m_viewEdgeCY;
            }
            break;
        }

        case WM_SIZE:
        {
            if (wParam != SIZE_MINIMIZED)
            {
                VIEWFrameResize(pasHost);
            }
            break;
        }

        default:
DefWndProc:
            rc = DefWindowProc(hwnd, message, wParam, lParam);
            break;

    }

    DebugExitDWORD(ASShare::VIEW_FrameWindowProc, rc);
    return(rc);
}



//
// VIEWFrameCreate()
//
BOOL ASShare::VIEWFrameCreate(ASPerson * pasPerson)
{
    RECT    rect;
    BOOL    rc = FALSE;

    DebugEntry(VIEWFrameCreate);

    ValidateView(pasPerson);

    //
    // Creates the children which lie in the frame's client:
    //      * the toolbar hugs the top
    //      * the statusbar hugs the bottom
    //      * the tray hugs the left underneath the toolbar and above the
    //          statusbar
    //      * the view fills in what's left
    //

    GetClientRect(pasPerson->m_pView->m_viewFrame, &rect);

    //
    // Create the statusbar (hugs bottom)
    //
    pasPerson->m_pView->m_viewStatusBar = ::CreateWindowEx(0, STATUSCLASSNAME,
        NULL, WS_CHILD | WS_VISIBLE | CCS_NOPARENTALIGN | CCS_NOMOVEY | CCS_NORESIZE |
        SBARS_SIZEGRIP,
        rect.left, rect.bottom - m_viewStatusBarCY, rect.right - rect.left,
        m_viewStatusBarCY, pasPerson->m_pView->m_viewFrame, NULL, g_asInstance,
        NULL);
    if (!pasPerson->m_pView->m_viewStatusBar)
    {
        ERROR_OUT(("Couldn't create statusbar for frame of person [%d]", pasPerson->mcsID));
        DC_QUIT;
    }

    rect.bottom -= m_viewStatusBarCY + m_viewEdgeCY;


    //
    // Create the tray (hugs top of status bar, bottom of view)
    // BUT NOT FOR DESKTOP SHARING
    //
    if (pasPerson->hetCount != HET_DESKTOPSHARED)
    {
        pasPerson->m_pView->m_viewWindowBar = ::CreateWindowEx(0,
            VIEW_WINDOWBAR_CLASS_NAME, NULL,
            WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_VISIBLE | WS_CHILD,
            rect.left, rect.bottom - m_viewWindowBarCY,
            rect.right - rect.left, m_viewWindowBarCY,
            pasPerson->m_pView->m_viewFrame, NULL, g_asInstance, pasPerson);
        if (!pasPerson->m_pView->m_viewWindowBar)
        {
            ERROR_OUT(("VIEWFrameCreate: Failed to create window bar"));
            DC_QUIT;
        }

        // Subtract tray space + an edge above it of margin
        rect.bottom -= m_viewWindowBarCY + m_viewEdgeCY;
    }

    //
    // Create the view (takes up rest of client)
    //
    if (!CreateWindowEx(WS_EX_CLIENTEDGE,
            VIEW_CLIENT_CLASS_NAME, NULL,
            WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_VISIBLE | WS_CHILD |
                WS_VSCROLL | WS_HSCROLL,
            rect.left, rect.top,
            rect.right - rect.left, rect.bottom - rect.top,
            pasPerson->m_pView->m_viewFrame,
            NULL, g_asInstance, pasPerson))
    {
        ERROR_OUT(("VIEWFrameCreate: Failed to create view"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::VIEWFrameCreate, rc);
    return(rc);
}



//
// VIEWFrameResize()
// Repositions the child windows when the frame is resized.
//
void ASShare::VIEWFrameResize(ASPerson * pasPerson)
{
    RECT    rect;

    DebugEntry(ASShare::VIEWFrameResize);

    ValidateView(pasPerson);

    GetClientRect(pasPerson->m_pView->m_viewFrame, &rect);

    //
    // Move the statusbar
    //
    if ((pasPerson->m_pView->m_viewStatusBar != NULL) &&
        (pasPerson->m_pView->m_viewStatusBarOn))
    {
        MoveWindow(pasPerson->m_pView->m_viewStatusBar, rect.left,
            rect.bottom - m_viewStatusBarCY, rect.right - rect.left,
            m_viewStatusBarCY, TRUE);
        rect.bottom -= m_viewStatusBarCY + m_viewEdgeCY;
    }

    //
    // Move the tray
    //
    if ((pasPerson->m_pView->m_viewWindowBar != NULL) &&
        (pasPerson->m_pView->m_viewWindowBarOn))
    {
        MoveWindow(pasPerson->m_pView->m_viewWindowBar, rect.left,
            rect.bottom - m_viewWindowBarCY, rect.right - rect.left,
            m_viewWindowBarCY, TRUE);
        rect.bottom -= m_viewWindowBarCY + m_viewEdgeCY;
    }

    //
    // Move the view
    //
    MoveWindow(pasPerson->m_pView->m_viewClient, rect.left, rect.top,
        rect.right - rect.left, rect.bottom - rect.top, TRUE);

    DebugExitVOID(ASShare::VIEWFrameResize);
}



//
// VIEWFrameResizeChanged()
//
// Called when the widgets of the frame (the status bar, the window bar, etc.)
// come or go.  We may need to shrink the window, if the view is going
// to end up being bigger than the host's desktop.
//
void ASShare::VIEWFrameResizeChanged(ASPerson * pasHost)
{
    RECT            rcView;

    DebugEntry(ASShare::VIEWFrameResizeChanged);

    // Get current view size
    GetClientRect(pasHost->m_pView->m_viewClient, &rcView);

    //
    // The view area can't be bigger than the remote's desktop area
    //
    if ((rcView.bottom - rcView.top)  >= pasHost->viewExtent.y)
    {
        RECT            rcWindowCur;
        RECT            rcWindowMax;

        // Get current frame size
        GetWindowRect(pasHost->m_pView->m_viewFrame, &rcWindowCur);

        // Get maximum frame size
        VIEWFrameGetSize(pasHost, &rcWindowMax);

        // Resize vertically to just hold everything
        SetWindowPos(pasHost->m_pView->m_viewFrame, NULL, 0, 0,
            rcWindowCur.right - rcWindowCur.left,
            rcWindowMax.bottom - rcWindowMax.top,
            SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOZORDER);
    }
    else
    {
        // We can stay the same size, and just shuffle the pieces around
        VIEWFrameResize(pasHost);
    }

    DebugExitVOID(ASShare::VIEWFrameResizeChanged);
}



//
// VIEWFrameCommand()
//
// Handles commands from menus/accelerators for frame views
//
void ASShare::VIEWFrameCommand
(
    ASPerson*   pasHost,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    UINT            cmd;
    MENUITEMINFO    mi;

    DebugEntry(ASShare::VIEWFrameCommand);

    ValidateView(pasHost);

    cmd = GET_WM_COMMAND_ID(wParam, lParam);
    switch (cmd)
    {
        case CMD_TAKECONTROL:
        {
            CA_TakeControl(pasHost);
            break;
        }

        case CMD_CANCELCONTROL:
        {
            CA_CancelTakeControl(pasHost, TRUE);
            break;
        }

        case CMD_RELEASECONTROL:
        {
            CA_ReleaseControl(pasHost, TRUE);
            break;
        }

        case CMD_CTRLALTDEL:
        {
            AWC_SendMsg(pasHost->mcsID, AWC_MSG_SAS, 0, 0);
            break;
        }

        case CMD_VIEWSTATUSBAR:
        {
            ASSERT(::IsWindow(pasHost->m_pView->m_viewStatusBar));

            // Toggle show/hide of status bar, then resize
            if (pasHost->m_pView->m_viewStatusBarOn)
            {
                pasHost->m_pView->m_viewStatusBarOn = FALSE;
                ::ShowWindow(pasHost->m_pView->m_viewStatusBar, SW_HIDE);
            }
            else
            {
                pasHost->m_pView->m_viewStatusBarOn = TRUE;
                ::ShowWindow(pasHost->m_pView->m_viewStatusBar, SW_SHOW);
            }

            VIEWFrameResizeChanged(pasHost);
            break;
        }

        case CMD_VIEWWINDOWBAR:
        {
            ASSERT(::IsWindow(pasHost->m_pView->m_viewWindowBar));

            // Toggle show/hide of window bar, then resize
            if (pasHost->m_pView->m_viewWindowBarOn)
            {
                pasHost->m_pView->m_viewWindowBarOn = FALSE;
                ::ShowWindow(pasHost->m_pView->m_viewWindowBar, SW_HIDE);
            }
            else
            {
                pasHost->m_pView->m_viewWindowBarOn = TRUE;
                ::ShowWindow(pasHost->m_pView->m_viewWindowBar, SW_SHOW);
            }

            VIEWFrameResizeChanged(pasHost);
            break;
        }

        case CMD_VIEWFULLSCREEN:
        {
            VIEWFrameFullScreen(pasHost, (pasHost->m_pView->m_viewFullScreen == 0));
            break;
        }

        case CMD_HELPTOPICS:
        {
            VIEWFrameHelp(pasHost);
            break;
        }

        case CMD_HELPABOUT:
        {
            VIEWFrameAbout(pasHost);
            break;
        }

        default:
        {
            if ((cmd >= CMD_APPSTART) && (cmd < CMD_APPMAX))
            {
                if ((pasHost->m_caControlledBy == m_pasLocal) &&
                    !pasHost->m_caControlPaused)
                {
                    //
                    // This is a request to activate a host window.
                    // Get the item data, the remote HWND, then look to see
                    // if it's still on the tray.
                    //
                    ZeroMemory(&mi, sizeof(mi));
                    mi.cbSize   = sizeof(mi);
                    mi.fMask    = MIIM_DATA;
                    GetMenuItemInfo(GetSubMenu(pasHost->m_pView->m_viewMenuBar,
                        IDSM_WINDOW), cmd, FALSE, &mi);
                    if (!mi.dwItemData)
                    {
                        ERROR_OUT(("No item data for command %d", cmd));
                    }
                    else
                    {
                        PWNDBAR_ITEM pItem;

                        COM_BasedListFind(LIST_FIND_FROM_FIRST,
                            &(pasHost->m_pView->m_viewWindowBarItems),
                            (void**)&pItem, FIELD_OFFSET(WNDBAR_ITEM, chain),
                            FIELD_OFFSET(WNDBAR_ITEM, winIDRemote),
                            mi.dwItemData, FIELD_SIZE(WNDBAR_ITEM, winIDRemote));
                        if (pItem)
                        {
                            VIEWWindowBarDoActivate(pasHost, pItem);
                        }
                    }
                }
            }
            else if ((cmd >= CMD_FORWARDCONTROLSTART) && (cmd < CMD_FORWARDCONTROLMAX))
            {
                if ((pasHost->m_caControlledBy == m_pasLocal) &&
                    !pasHost->m_caControlPaused)
                {
                    //
                    // This is a request to pass control.  Get the item data,
                    // the remote's MCS ID, then look to see if this person is
                    // still in the share.  If so, pass control to them.
                    //
                    ZeroMemory(&mi, sizeof(mi));
                    mi.cbSize   = sizeof(mi);
                    mi.fMask    = MIIM_DATA;
                    GetMenuItemInfo(GetSubMenu(GetSubMenu(pasHost->m_pView->m_viewMenuBar,
                        IDSM_CONTROL), POS_FORWARDCONTROLCMD), cmd, FALSE, &mi);
                    if (!mi.dwItemData)
                    {
                        ERROR_OUT(("No item data for command %d", cmd));
                    }
                    else
                    {
                        ASPerson * pasT;

                        if (SC_ValidateNetID((MCSID)mi.dwItemData, &pasT))
                        {
                            CA_PassControl(pasHost, pasT);
                        }
                    }
                }
            }
            else
            {
                ERROR_OUT(("Unrecognized WM_COMMAND id"));
            }
            break;
        }
    }

    DebugExitVOID(ASShare::VIEWFrameCommand);
}



//
// ASShare::VIEWFrameInitMenuBar()
//
void ASShare::VIEWFrameInitMenuBar(ASPerson*   pasHost)
{
    HMENU       hMenu;
    HMENU       hSubMenu;
    int         iItem;
    MENUITEMINFO    mi;
    UINT        cmd;
    UINT        ids;
    UINT        flags;
    char        szItem[256];

    DebugEntry(ASShare::VIEWFrameInitMenu);

    ValidateView(pasHost);
    hMenu = pasHost->m_pView->m_viewMenuBar;
    ASSERT(hMenu);

    //
    // CONTROL MENU
    //

    cmd = CMD_TAKECONTROL;
    ids = IDS_CMD_TAKECONTROL;
    flags = MF_ENABLED;

    if (pasHost->m_caControlledBy == m_pasLocal)
    {
        ASSERT(pasHost->m_caAllowControl);

        cmd = CMD_RELEASECONTROL;
        ids = IDS_CMD_RELEASECONTROL;

        //
        // If the remote is unattended and we're in control, no releasing.
        //
        if (pasHost->cpcCaps.general.typeFlags & AS_UNATTENDED)
            flags = MF_GRAYED;
    }
    else if ((m_caWaitingForReplyFrom == pasHost) &&
             (m_caWaitingForReplyMsg == CA_REPLY_REQUEST_TAKECONTROL))
    {
        ASSERT(pasHost->m_caAllowControl);

        cmd = CMD_CANCELCONTROL;
        ids = IDS_CMD_CANCELCONTROL;
    }
    else if (!pasHost->m_caAllowControl || pasHost->m_caControlledBy)
    {
        //
        // Host isn't allowing control, or somebody else is in control right
        // now.
        //
        flags = MF_GRAYED;
    }
    flags |= MF_STRING | MF_BYPOSITION;

    ::LoadString(g_asInstance, ids, szItem, sizeof(szItem));

    hSubMenu = GetSubMenu(hMenu, IDSM_CONTROL);
    ModifyMenu(hSubMenu, POS_CONTROLCMD, flags, cmd, szItem);

    //
    // If we're in control, and there's another 3.0 dude in the conference,
    // enable PassControl and build the popup.
    //
    EnableMenuItem(hSubMenu, POS_FORWARDCONTROLCMD, MF_GRAYED | MF_BYPOSITION);
    if ((pasHost->m_caControlledBy == m_pasLocal)   &&
        !pasHost->m_caControlPaused                 &&
        (pasHost->cpcCaps.general.version >= CAPS_VERSION_30))
    {
        ASPerson *  pasT;
        HMENU       hPassMenu;

        hPassMenu = GetSubMenu(hSubMenu, POS_FORWARDCONTROLCMD);
        ASSERT(IsMenu(hPassMenu));

        //
        // Delete existing items.
        //
        iItem = GetMenuItemCount(hPassMenu);
        while (iItem > 0)
        {
            iItem--;
            DeleteMenu(hPassMenu, iItem, MF_BYPOSITION);
        }

        //
        // Add items for the other 3.0 nodes besides us & the host.
        //
        iItem = CMD_FORWARDCONTROLSTART;
        pasT = m_pasLocal->pasNext;
        while (pasT != NULL)
        {
            if ((pasT != pasHost) &&
                (pasT->cpcCaps.general.version >= CAPS_VERSION_30))
            {
                //
                // This dude is a candidate.  We must store the MCS IDs since the
                // any person could go away while we're in menu mode.
                //
                ZeroMemory(&mi, sizeof(mi));
                mi.cbSize       = sizeof(mi);
                mi.fMask        = MIIM_ID | MIIM_STATE | MIIM_TYPE | MIIM_DATA;
                mi.fType        = MFT_STRING;
                mi.fState       = MFS_ENABLED;
                mi.wID          = iItem;
                mi.dwItemData   = pasT->mcsID;
                mi.dwTypeData   = pasT->scName;
                mi.cch          = lstrlen(pasT->scName);

                //
                // Append this to the menu
                //
                InsertMenuItem(hPassMenu, -1, TRUE, &mi);

                iItem++;
            }

            pasT = pasT->pasNext;
        }

        //
        // Enable the Pass Control submenu if there's somebody on the
        // menu.
        //
        if (iItem != CMD_FORWARDCONTROLSTART)
        {
            EnableMenuItem(hSubMenu, POS_FORWARDCONTROLCMD, MF_ENABLED | MF_BYPOSITION);
        }
    }


    //
    // APPLICATIONS MENU
    //
    if ((pasHost->hetCount != HET_DESKTOPSHARED)  &&
        (pasHost->m_caControlledBy == m_pasLocal) &&
        !pasHost->m_caControlPaused)
    {
        PWNDBAR_ITEM pItem;

        hSubMenu = GetSubMenu(hMenu, IDSM_WINDOW);

        //
        // Delete existing items.
        //
        iItem = GetMenuItemCount(hSubMenu);
        while (iItem > 0)
        {
            iItem--;
            DeleteMenu(hSubMenu, iItem, MF_BYPOSITION);
        }

        //
        // Add window bar items.
        //
        iItem = CMD_APPSTART;
        pItem = (PWNDBAR_ITEM)COM_BasedListFirst(&(pasHost->m_pView->m_viewWindowBarItems),
            FIELD_OFFSET(WNDBAR_ITEM, chain));
        while (pItem && (iItem < CMD_APPMAX))
        {
            ZeroMemory(&mi, sizeof(mi));
            mi.cbSize       = sizeof(mi);
            mi.fMask        = MIIM_ID | MIIM_STATE | MIIM_TYPE | MIIM_DATA;
            mi.fType        = MFT_STRING;

            mi.fState       = MFS_ENABLED;
            if (pItem == pasHost->m_pView->m_viewWindowBarActiveItem)
            {
                mi.fState |= MFS_CHECKED;
            }

            mi.wID          = iItem;
            mi.dwItemData   = pItem->winIDRemote;
            mi.dwTypeData   = pItem->szText;
            mi.cch          = lstrlen(pItem->szText);

            //
            // Append this to the menu
            //
            InsertMenuItem(hSubMenu, -1, TRUE, &mi);

            iItem++;
            pItem = (PWNDBAR_ITEM)COM_BasedListNext(&(pasHost->m_pView->m_viewWindowBarItems),
                pItem, FIELD_OFFSET(WNDBAR_ITEM, chain));
        }

        if (iItem == CMD_APPSTART)
        {
            char    szBlank[128];

            //
            // Append a disabled, blank item
            //
            ZeroMemory(&mi, sizeof(mi));
            mi.cbSize   = sizeof(mi);
            mi.fMask    = MIIM_ID | MIIM_STATE | MIIM_TYPE;
            mi.fType    = MFT_STRING;
            mi.fState   = MFS_DISABLED;
            mi.wID      = iItem;

            LoadString(g_asInstance, IDS_CMD_BLANKPROGRAM, szBlank, sizeof(szBlank));
            mi.dwTypeData   = szBlank;
            mi.cch          = lstrlen(szBlank);

            InsertMenuItem(hSubMenu, -1, TRUE, &mi);
        }
    }

    //
    // VIEW MENU
    //

    // Status bar
    ASSERT(::IsWindow(pasHost->m_pView->m_viewStatusBar));
    if (pasHost->m_pView->m_viewStatusBarOn)
    {
        ::CheckMenuItem(hMenu, CMD_VIEWSTATUSBAR, MF_CHECKED | MF_BYCOMMAND);
    }
    else
    {
        ::CheckMenuItem(hMenu, CMD_VIEWSTATUSBAR, MF_UNCHECKED | MF_BYCOMMAND);
    }

    // Window bar
    if (!pasHost->m_pView->m_viewWindowBar)
    {
        ::EnableMenuItem(hMenu, CMD_VIEWWINDOWBAR, MF_GRAYED | MF_BYCOMMAND);
    }
    else if (pasHost->m_pView->m_viewWindowBarOn)
    {
        ::CheckMenuItem(hMenu, CMD_VIEWWINDOWBAR, MF_CHECKED | MF_BYCOMMAND);
    }
    else
    {
        ::CheckMenuItem(hMenu, CMD_VIEWWINDOWBAR, MF_UNCHECKED | MF_BYCOMMAND);
    }

    DebugExitVOID(ASShare::VIEWFrameInitMenu);
}




//
// VIEWFrameOnMenuSelect()
//
void ASShare::VIEWFrameOnMenuSelect
(
    ASPerson *      pasHost,
    WPARAM          wParam,
    LPARAM          lParam
)
{
    HMENU           hMenu;
    int             uItem;
    UINT            flags;
    UINT            idsStatus = IDS_STATUS_NONE;

    DebugEntry(ASShare::VIEWFrameOnMenuSelect);

    //
    // Extract the params out (menuselect is messy)
    //
    hMenu   = (HMENU)lParam;
    uItem   = (int)LOWORD(wParam);
    if ((short)HIWORD(wParam) == -1)
    {
        flags = 0xFFFFFFFF;
    }
    else
    {
        flags = HIWORD(wParam);
    }

    if ((LOWORD(flags) == 0xFFFF) && !hMenu)
    {
        // Menu mode is ending.  Put back original status.
        idsStatus = pasHost->m_pView->m_viewStatus;
        DC_QUIT;
    }

    if (!(flags & MF_POPUP))
    {
        if (flags & MF_SEPARATOR)
        {
            // No status
        }
        else if (flags & MF_SYSMENU)
        {
            // No status
        }
        else if ((uItem >= CMD_APPSTART) && (uItem < CMD_APPMAX))
        {
            // One of an unbounded set of items in the Window popup
            idsStatus = IDS_STATUS_CMDS_APP;
        }
        else if ((uItem >= CMD_FORWARDCONTROLSTART) && (uItem < CMD_FORWARDCONTROLMAX))
        {
            // One of an unbounded set of items in the Forward Control popup
            idsStatus = IDS_STATUS_CMDS_FORWARD;
        }
        else
        {
            // A normal command, just add offset to CMD id
            idsStatus = uItem + IDS_STATUS_CMD_START;
        }
    }
    else
    {
        // This is a popup menu
        if (hMenu == pasHost->m_pView->m_viewMenuBar)
        {
            // It's a popup from the top level menu bar.  uItem is the index
            switch (uItem)
            {
                case IDSM_CONTROL:
                    idsStatus = IDS_STATUS_MENU_CONTROL;
                    break;

                case IDSM_VIEW:
                    idsStatus = IDS_STATUS_MENU_VIEW;
                    break;

                case IDSM_WINDOW:
                    idsStatus = IDS_STATUS_MENU_WINDOW;
                    break;

                case IDSM_HELP:
                    idsStatus = IDS_STATUS_MENU_HELP;
                    break;

                default:
                    ERROR_OUT(("AS: Unknown submenu index %d of frame", uItem));
                    break;
            }
        }
        else if (hMenu == GetSubMenu(pasHost->m_pView->m_viewMenuBar, IDSM_CONTROL))
        {
            // This is a popup off the Control menu.  The only one we have is Forward
            idsStatus = IDS_STATUS_MENU_FORWARDCONTROL;
        }
        else if (flags & MF_SYSMENU)
        {
            // System menu
        }
    }

DC_EXIT_POINT:
    VIEWFrameSetStatus(pasHost, idsStatus);

    DebugEntry(ASShare::VIEWFrameOnMenuSelect);
}


//
// VIEWFrameHelp()
//
void ASShare::VIEWFrameHelp(ASPerson * pasHost)
{
    DebugEntry(ASShare::VIEWFrameHelp);

    ShowNmHelp(s_cszHtmlHelpFile);

    DebugExitVOID(ASShare::VIEWFrameHelp);
}



//
// VIEWFrameAbout()
//
void ASShare::VIEWFrameAbout(ASPerson * pasHost)
{
    DebugEntry(ASShare::VIEWFrameAbout);

    //
    // We make use of the standard centered-disabled-goes-away properly
    // VIEW_Message() stuff.
    //
    VIEW_Message(pasHost, IDS_ABOUT);

    DebugExitVOID(ASShare::VIEWFrameAbout);
}




//
// VIEWFrameGetSize()
// This returns back a rectangle for the ideal size of the frame.  It will
// fit the view, menu, tools, tray, status, etc.
//
void ASShare::VIEWFrameGetSize(ASPerson * pasPerson, LPRECT lprc)
{
    DebugEntry(ASShare::VIEWFrameGetSize);

    ValidateView(pasPerson);

    VIEWClientGetSize(pasPerson, lprc);

    //
    // Add in space for tray.
    // NOTE that for DESKTOP SHARING we don't have a tray
    //
    if (pasPerson->m_pView->m_viewWindowBarOn)
    {
        lprc->bottom += m_viewWindowBarCY + m_viewEdgeCY;
    }

    //
    // Add in space for statusbar if it's on, etc.
    //
    if (pasPerson->m_pView->m_viewStatusBarOn)
    {
        lprc->bottom += m_viewStatusBarCY + m_viewEdgeCY;
    }

    if (!pasPerson->m_pView->m_viewFullScreen)
    {
        //
        // Adjust for frame styles including menu bar.
        //
        AdjustWindowRectEx(lprc, WS_OVERLAPPEDWINDOW, TRUE, WS_EX_WINDOWEDGE);
    }

    DebugExitVOID(ASShare::VIEWFrameGetSize);
}




//
// VIEWFrameFullScreen()
//
// This puts into or out of screen mode.  We remove all the frame goop
// including scrollbars, so that the view area is identical to the screen.
//
void ASShare::VIEWFrameFullScreen(ASPerson * pasPerson, BOOL fFull)
{
    LONG    lStyle;
    RECT    rcNew;

    DebugEntry(ASShare::VIEWFrameFullScreen);

    //
    // Turn redraw OFF
    //
    ::SendMessage(pasPerson->m_pView->m_viewFrame, WM_SETREDRAW, FALSE, 0);

    if (fFull)
    {
        //
        // We're going into full screen mode.
        //

        ASSERT(!pasPerson->m_pView->m_viewFullScreen);
        pasPerson->m_pView->m_viewFullScreen = TRUE;

        //
        // Save old window rect
        //
        ::GetWindowRect(pasPerson->m_pView->m_viewFrame,
            &pasPerson->m_pView->m_viewSavedWindowRect);

        //
        // Save old scroll pos and set to the origin.  Do this BEFORE
        // clearing style bits.
        //
        pasPerson->m_pView->m_viewSavedPos = pasPerson->m_pView->m_viewPos;
        VIEWClientScroll(pasPerson, 0, 0);

        //
        // Save current status bar state before turning it off temporarily.
        //
        if (pasPerson->m_pView->m_viewStatusBarOn)
        {
            pasPerson->m_pView->m_viewSavedStatusBarOn = TRUE;
            pasPerson->m_pView->m_viewStatusBarOn = FALSE;
            ::ShowWindow(pasPerson->m_pView->m_viewStatusBar, SW_HIDE);
        }
        else
        {
            pasPerson->m_pView->m_viewSavedStatusBarOn = FALSE;
        }

        //
        // Save current window bar state before turning it off temporarily.
        //
        if (pasPerson->m_pView->m_viewWindowBarOn)
        {
            pasPerson->m_pView->m_viewSavedWindowBarOn = TRUE;
            pasPerson->m_pView->m_viewWindowBarOn = FALSE;
            ::ShowWindow(pasPerson->m_pView->m_viewWindowBar, SW_HIDE);
        }
        else
        {
            pasPerson->m_pView->m_viewSavedWindowBarOn = FALSE;
        }

        //
        // Remove all frame and client bits.
        //
        lStyle = ::GetWindowLong(pasPerson->m_pView->m_viewFrame, GWL_EXSTYLE);
        lStyle &= ~WS_EX_WINDOWEDGE;
        ::SetWindowLong(pasPerson->m_pView->m_viewFrame, GWL_EXSTYLE, lStyle);

        lStyle = ::GetWindowLong(pasPerson->m_pView->m_viewFrame, GWL_STYLE);
        lStyle &= ~(WS_CAPTION | WS_THICKFRAME);
        lStyle |= WS_POPUP;
        ::SetWindowLong(pasPerson->m_pView->m_viewFrame, GWL_STYLE, lStyle);

        lStyle = ::GetWindowLong(pasPerson->m_pView->m_viewClient, GWL_EXSTYLE);
        lStyle &= ~WS_EX_CLIENTEDGE;
        ::SetWindowLong(pasPerson->m_pView->m_viewClient, GWL_EXSTYLE, lStyle);

        lStyle = ::GetWindowLong(pasPerson->m_pView->m_viewClient, GWL_STYLE);
        lStyle &= ~(WS_HSCROLL | WS_VSCROLL);
        ::SetWindowLong(pasPerson->m_pView->m_viewClient, GWL_STYLE, lStyle);

        //
        // Remove the menu bar
        //
        ::SetMenu(pasPerson->m_pView->m_viewFrame, NULL);

        //
        // Set up to size window the size of the screen.
        //
        rcNew.left      = 0;
        rcNew.top       = 0;
        rcNew.right     = m_pasLocal->cpcCaps.screen.capsScreenWidth;
        rcNew.bottom    = m_pasLocal->cpcCaps.screen.capsScreenHeight;

        //
        // Create the moveable escape-out button in the lower right corner.
        //
        ::CreateWindowEx(0, VIEW_FULLEXIT_CLASS_NAME, NULL,
            WS_CHILD | WS_VISIBLE,
            rcNew.right - m_viewFullScreenCX - 2*m_viewEdgeCX,
            rcNew.top +  2*m_viewEdgeCY,
            m_viewFullScreenCX, m_viewFullScreenCY,
            pasPerson->m_pView->m_viewClient,
            (HMENU)0,
            g_asInstance,
            pasPerson);
    }
    else
    {
        //
        // We're coming out of full screen mode.
        //

        //
        // Destroy the escape-out button
        //
        ::DestroyWindow(::GetDlgItem(pasPerson->m_pView->m_viewClient, 0));

        //
        // Put back the menu bar.  Do this BEFORE clearing the full screen bit
        //
        ::SetMenu(pasPerson->m_pView->m_viewFrame, pasPerson->m_pView->m_viewMenuBar);

        ASSERT(pasPerson->m_pView->m_viewFullScreen);
        pasPerson->m_pView->m_viewFullScreen = FALSE;


        //
        // Put back old status bar state.
        //
        if (pasPerson->m_pView->m_viewSavedStatusBarOn)
        {
            pasPerson->m_pView->m_viewStatusBarOn = TRUE;
            ::ShowWindow(pasPerson->m_pView->m_viewStatusBar, SW_SHOW);
        }

        //
        // Put back old window bar state.
        //
        if (pasPerson->m_pView->m_viewSavedWindowBarOn)
        {
            pasPerson->m_pView->m_viewWindowBarOn = TRUE;
            ::ShowWindow(pasPerson->m_pView->m_viewWindowBar, SW_SHOW);
        }

        //
        // Add back all frame and client bits.
        //
        lStyle = ::GetWindowLong(pasPerson->m_pView->m_viewFrame, GWL_EXSTYLE);
        lStyle |= WS_EX_WINDOWEDGE;
        ::SetWindowLong(pasPerson->m_pView->m_viewFrame, GWL_EXSTYLE, lStyle);

        lStyle = ::GetWindowLong(pasPerson->m_pView->m_viewFrame, GWL_STYLE);
        lStyle &= ~(WS_POPUP);
        lStyle |= (WS_CAPTION | WS_THICKFRAME);
        ::SetWindowLong(pasPerson->m_pView->m_viewFrame, GWL_STYLE, lStyle);

        lStyle = ::GetWindowLong(pasPerson->m_pView->m_viewClient, GWL_EXSTYLE);
        lStyle |= WS_EX_CLIENTEDGE;
        ::SetWindowLong(pasPerson->m_pView->m_viewClient, GWL_EXSTYLE, lStyle);

        lStyle = ::GetWindowLong(pasPerson->m_pView->m_viewClient, GWL_STYLE);
        lStyle |= (WS_HSCROLL | WS_VSCROLL);
        ::SetWindowLong(pasPerson->m_pView->m_viewClient, GWL_STYLE, lStyle);

        //
        // Put back old scroll pos AFTER style bits restore.
        //
        VIEWClientScroll(pasPerson, pasPerson->m_pView->m_viewSavedPos.x,
            pasPerson->m_pView->m_viewSavedPos.y);

        //
        // Restore the window back to where it started.
        //
        rcNew = pasPerson->m_pView->m_viewSavedWindowRect;
    }

    //
    // Resize, reframe, and repaint from scratch.
    //
    ::SendMessage(pasPerson->m_pView->m_viewFrame, WM_SETREDRAW, TRUE, 0);

    ::SetWindowPos(pasPerson->m_pView->m_viewFrame, NULL, rcNew.left,
        rcNew.top, rcNew.right - rcNew.left, rcNew.bottom - rcNew.top,
        SWP_NOZORDER | SWP_NOACTIVATE | SWP_FRAMECHANGED | SWP_NOCOPYBITS);

    DebugExitVOID(ASShare::VIEWFrameFullScreen);
}



//
// VIEWClientGetSize()
// This returns back a rectangle for the ideal size of the view part of the
// frame client.  It will fit the extent of what we're viewing on the remote
// plus scrollbars.
//
void ASShare::VIEWClientGetSize(ASPerson * pasPerson, LPRECT lprc)
{
    DebugEntry(ASShare::VIEWClientGetSize);

    ValidateView(pasPerson);

    lprc->left  = 0;
    lprc->top   = 0;
    lprc->right = pasPerson->viewExtent.x;
    lprc->bottom = pasPerson->viewExtent.y;

    if (!pasPerson->m_pView->m_viewFullScreen)
    {
        AdjustWindowRectEx(lprc, WS_CHILD, FALSE, WS_EX_CLIENTEDGE);

        lprc->right += GetSystemMetrics(SM_CXVSCROLL);
        lprc->bottom += GetSystemMetrics(SM_CYHSCROLL);
    }

    DebugExitVOID(ASShare::VIEWClientGetSize);
}


//
// VIEWClientWindowProc()
// Handles messages for the view window, a child in the client of the frame
// which displays the contents of the remote host's shared apps.
//
LRESULT CALLBACK VIEWClientWindowProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    return(g_asSession.pShare->VIEW_ViewWindowProc(hwnd, message, wParam, lParam));
}


LRESULT ASShare::VIEW_ViewWindowProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    LRESULT     rc = 0;
    RECT        rcl;
    POINT       mousePos;
    SCROLLINFO  si;
    ASPerson *  pasPerson;

    DebugEntry(ASShare::VIEW_ViewWindowProc);

    pasPerson = (ASPerson *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if (pasPerson)
    {
        ValidateView(pasPerson);
    }

    switch (message)
    {
        case WM_NCCREATE:
        {
            // Get the passed in host pointer, and set in our window long
            pasPerson = (ASPerson *)((LPCREATESTRUCT)lParam)->lpCreateParams;
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pasPerson);

            pasPerson->m_pView->m_viewClient = hwnd;
            goto DefWndProc;
            break;
        }

        case WM_NCDESTROY:
        {
            if (pasPerson != NULL)
            {
                pasPerson->m_pView->m_viewClient = NULL;
            }

            goto DefWndProc;
            break;
        }

        case WM_ERASEBKGND:
        {
            //
            // BOGUS LAURABU:  Paint on erase then validate for faster
            // response.

            //
            rc = TRUE;
            break;
        }

        case WM_PAINT:
        {
            VIEWClientPaint(pasPerson);
            break;
        }

        case WM_SETFOCUS:
        {
            pasPerson->m_pView->m_viewFocus = TRUE;
            pasPerson->m_pView->m_viewMouseWheelDelta = 0;
            break;
        }

        case WM_KILLFOCUS:
        {
            pasPerson->m_pView->m_viewFocus = FALSE;
            pasPerson->m_pView->m_viewMouseWheelDelta = 0;
            break;
        }

        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
        case WM_MBUTTONDOWN:
        {
            VIEWClientMouseDown(pasPerson, message, wParam, lParam);
            break;
        }

        case WM_LBUTTONUP:
        case WM_RBUTTONUP:
        case WM_MBUTTONUP:
        {
            VIEWClientMouseUp(pasPerson, message, wParam, lParam, TRUE);
            break;
        }

        case WM_MOUSEMOVE:
        {
            VIEWClientMouseMove(pasPerson, message, wParam, lParam);
            break;
        }

        case WM_MOUSEWHEEL:
        {
            //
            // We've handled it no matter what, don't pass it up the chain.
            //
            rc = TRUE;

            //
            // If we're not controlling this dude, try to use the mousewheel
            // to scroll.
            //
            if ((pasPerson->m_caControlledBy != m_pasLocal) ||
                pasPerson->m_caControlPaused)
            {
                VIEWClientMouseWheel(pasPerson, wParam, lParam);
                break;
            }

            //
            // FALL THROUGH
            // Otherwise, we send the MOUSEWHEEL message to the host.
            //
        }

        case WM_LBUTTONDBLCLK:
        case WM_RBUTTONDBLCLK:
        case WM_MBUTTONDBLCLK:
        {
            VIEWClientMouseMsg(pasPerson, message, wParam, lParam);
            break;
        }

        case WM_TIMER:
        {
            if (wParam == IDT_AUTOSCROLL)
            {
                VIEWClientAutoScroll(pasPerson);
            }
            break;
        }

        case WM_CAPTURECHANGED:
        {
            //
            // Check if capture got stolen away from us, if we think the
            // buttons are down fake a button up.
            //
            if (pasPerson->m_pView->m_viewMouseFlags != 0)
            {
                VIEWClientCaptureStolen(pasPerson);
            }
            break;
        }

        case WM_KEYDOWN:
        {
            WPARAM  wScrollNotify;
            UINT    uMsg;

            if ((pasPerson->m_caControlledBy == m_pasLocal) &&
                !pasPerson->m_caControlPaused)
            {
                goto KeyInput;
            }

            if (pasPerson->m_pView->m_viewFullScreen)
            {
                if (wParam == VK_ESCAPE)
                {
                    //
                    // Kick out of full screen mode.
                    //
                    VIEWFrameFullScreen(pasPerson, FALSE);
                }

                goto DefWndProc;
            }

            //
            // UP, DOWN, LEFT, and RIGHT are unambiguous about which
            // scrollbar is intended.
            //
            // For the others, unmodified is vertical and SHIFT is
            // horizontal.
            //
            if (::GetKeyState(VK_SHIFT) < 0)
            {
                uMsg = WM_HSCROLL;
            }
            else
            {
                uMsg = WM_VSCROLL;
            }

            switch (wParam)
            {
                //
                // These aren't ambiguous, we know which scrollbar is meant
                // by the direction.
                //
                case VK_UP:
                    wScrollNotify = SB_LINEUP;
                    uMsg = WM_VSCROLL;
                    break;

                case VK_DOWN:
                    wScrollNotify = SB_LINEDOWN;
                    uMsg = WM_VSCROLL;
                    break;

                case VK_LEFT:
                    wScrollNotify = SB_LINEUP;
                    uMsg = WM_HSCROLL;
                    break;

                case VK_RIGHT:
                    wScrollNotify = SB_LINEDOWN;
                    uMsg = WM_HSCROLL;
                    break;

                //
                // These are ambiguous, hence the SHIFT key as a
                // modifier.
                //
                case VK_PRIOR:
                    wScrollNotify = SB_PAGEUP;
                    break;

                case VK_NEXT:
                    wScrollNotify = SB_PAGEDOWN;
                    break;

                case VK_HOME:
                    wScrollNotify = SB_TOP;
                    break;

                case VK_END:
                    wScrollNotify = SB_BOTTOM;
                    break;

                default:
                    goto DefWndProc;
                    break;
            }

            SendMessage(hwnd, uMsg, MAKELONG(wScrollNotify, 0), 0L);
            break;
        }

        case WM_SYSKEYDOWN:
        {
            if ((pasPerson->m_caControlledBy == m_pasLocal) &&
                !pasPerson->m_caControlPaused)
            {
                goto KeyInput;
            }

            //
            // ALT-ENTER toggles full screen state, if it's available
            //
            if ((wParam == VK_RETURN) &&
                !(::GetMenuState(pasPerson->m_pView->m_viewMenuBar,
                CMD_VIEWFULLSCREEN, MF_BYCOMMAND) & MF_DISABLED))
            {
                VIEWFrameFullScreen(pasPerson,
                    (pasPerson->m_pView->m_viewFullScreen == 0));
            }
            goto DefWndProc;
            break;
        }


        case WM_KEYUP:
        case WM_SYSKEYUP:
        {
            //
            // If we're controlling this node, pass it along.  Otherwise,
            // call DefWindowProc() so key accels like Alt+Space for system
            // menu will kick in.
            //
            if ((pasPerson->m_caControlledBy == m_pasLocal) &&
                !pasPerson->m_caControlPaused)
            {
KeyInput:
                IM_OutgoingKeyboardInput(pasPerson, (UINT)wParam, (UINT)lParam);
            }
            else
            {
                goto DefWndProc;
            }
            break;
        }

        case WM_SETCURSOR:
        {
            if ((LOWORD(lParam) == HTCLIENT) && ((HWND)wParam == hwnd))
            {
                HCURSOR hCursor;
                POINT   cursorPoint;

                if ((pasPerson->m_caControlledBy == m_pasLocal) &&
                    !pasPerson->m_caControlPaused)
                {
                    hCursor = m_cmArrowCursor;

                    //
                    // Only set the remote cursor if we're over shared space.
                    //
                    if (pasPerson->m_pView->m_viewFocus)
                    {
                        GetCursorPos(&cursorPoint);
                        ScreenToClient(hwnd, &cursorPoint);

                        if (VIEW_IsPointShared(pasPerson, cursorPoint))
                        {
                            hCursor = pasPerson->cmhRemoteCursor;
                        }
                    }
                }
                else
                {
                    // NoDrop
                    hCursor = m_viewNotInControl;
                }

                SetCursor(hCursor);

                rc = TRUE;
            }
            else
            {
                // Let defwindowproc handle it
                goto DefWndProc;
            }
            break;
        }

        case WM_SIZE:
        {
            //
            // If we're in full screen mode, there are no scrollbars.
            //
            if (!pasPerson->m_pView->m_viewFullScreen)
            {
                int xNewPos;
                int yNewPos;

                xNewPos = pasPerson->m_pView->m_viewPos.x;
                yNewPos = pasPerson->m_pView->m_viewPos.y;

                GetClientRect(hwnd, &rcl);
                pasPerson->m_pView->m_viewPage.x = rcl.right - rcl.left;
                pasPerson->m_pView->m_viewPage.y = rcl.bottom - rcl.top;
                TRACE_OUT(("WM_SIZE: Set page size (%04d, %04d)",
                    pasPerson->m_pView->m_viewPage.x, pasPerson->m_pView->m_viewPage.y));

                //
                // Scroll window if necessary.
                //
                si.cbSize = sizeof(SCROLLINFO);
                si.fMask = SIF_PAGE|SIF_DISABLENOSCROLL;

                // Set new HORIZONTAL proportional scroll button size
                si.nPage = pasPerson->m_pView->m_viewPage.x;
                SetScrollInfo(hwnd, SB_HORZ, &si, TRUE );

                // Set new VERTICAL proportional scroll button size
                si.nPage = pasPerson->m_pView->m_viewPage.y;
                SetScrollInfo(hwnd, SB_VERT, &si, TRUE );

                //
                // This will make sure the scroll pos is pinned properly
                //
                VIEWClientScroll(pasPerson, pasPerson->m_pView->m_viewPos.x, pasPerson->m_pView->m_viewPos.y);
            }
            break;
        }

        case WM_HSCROLL:
        {
            int xNewPos;    // new position

            switch (GET_WM_HSCROLL_CODE(wParam, lParam))
            {
                case SB_PAGEUP:
                    xNewPos = pasPerson->m_pView->m_viewPos.x - pasPerson->m_pView->m_viewPgSize.x;
                    break;
                case SB_PAGEDOWN:
                    xNewPos = pasPerson->m_pView->m_viewPos.x + pasPerson->m_pView->m_viewPgSize.x;
                    break;
                case SB_LINEUP:
                    xNewPos = pasPerson->m_pView->m_viewPos.x - pasPerson->m_pView->m_viewLnSize.x;
                    break;
                case SB_LINEDOWN:
                    xNewPos = pasPerson->m_pView->m_viewPos.x + pasPerson->m_pView->m_viewLnSize.x;
                    break;
                case SB_TOP:
                    xNewPos = 0;
                    break;
                case SB_BOTTOM:
                    xNewPos = pasPerson->viewExtent.x;
                    break;

                case SB_THUMBTRACK:
                case SB_THUMBPOSITION:
                    xNewPos = GET_WM_HSCROLL_POS(wParam, lParam);
                    break;

                default:
                    xNewPos = pasPerson->m_pView->m_viewPos.x;
                    break;
            }

            //
            // This will pin the desired scroll pos in the range, and if
            // nothing has changed, won't scroll.
            //
            VIEWClientScroll(pasPerson, xNewPos, pasPerson->m_pView->m_viewPos.y);
            break;
        }

        case WM_VSCROLL:
        {
            int yNewPos;    // new position

            switch (GET_WM_VSCROLL_CODE(wParam, lParam))
            {
                case SB_PAGEUP:
                    yNewPos = pasPerson->m_pView->m_viewPos.y - pasPerson->m_pView->m_viewPgSize.y;
                    break;
                case SB_PAGEDOWN:
                    yNewPos = pasPerson->m_pView->m_viewPos.y + pasPerson->m_pView->m_viewPgSize.y;
                    break;
                case SB_LINEUP:
                    yNewPos = pasPerson->m_pView->m_viewPos.y - pasPerson->m_pView->m_viewLnSize.y;
                    break;
                case SB_LINEDOWN:
                    yNewPos = pasPerson->m_pView->m_viewPos.y + pasPerson->m_pView->m_viewLnSize.y;
                    break;
                case SB_TOP:
                    yNewPos = 0;
                    break;
                case SB_BOTTOM:
                    yNewPos = pasPerson->viewExtent.y;
                    break;

                case SB_THUMBTRACK:
                case SB_THUMBPOSITION:
                    yNewPos = GET_WM_VSCROLL_POS(wParam, lParam);
                    break;

                default:
                    yNewPos = pasPerson->m_pView->m_viewPos.y;
                    break;
            }

            //
            // This will pin the desired scroll pos in the range, and if
            // nothing has changed, won't scroll.
            //
            VIEWClientScroll(pasPerson, pasPerson->m_pView->m_viewPos.x, yNewPos);
            break;
        }

        default:
DefWndProc:
            rc = DefWindowProc(hwnd, message, wParam, lParam);
            break;
    }

    DebugExitDWORD(ASShare::VIEW_ViewWindowProc, rc);
    return(rc);
}




//
// VIEWClientPaint()
//
// This paints the client area of the view frame.  We paint
//      (1) The obscured area, in the obscured pattern
//          * parts of shared regions that are covered up
//          * parts of shared regions that are offscreen/off the VD
//      (2) The shared area, from the bitmap
//      (3) The deadspace, in COLOR_APPWORKSPACE
//
void  ASShare::VIEWClientPaint(ASPerson * pasPerson)
{
    PAINTSTRUCT     ps;
    HDC             hdcView;
    HPALETTE        hOldPal;
    HPALETTE        hOldPal2;
    RECT            rcT;

    DebugEntry(ASShare::VIEWClientPaint);

    ValidateView(pasPerson);

    hdcView = BeginPaint(pasPerson->m_pView->m_viewClient, &ps);
    if (hdcView == NULL)
    {
        WARNING_OUT(( "Failed to get hdc for frame window %08X", pasPerson->m_pView->m_viewClient));
        DC_QUIT;
    }

    if (IsRectEmpty(&ps.rcPaint))
    {
        TRACE_OUT(("Nothing to paint but got WM_PAINT message"));
        DC_QUIT;
    }

    TRACE_OUT(("VIEWClientPaint: Painting total client area {%04d, %04d, %04d, %04d}",
        ps.rcPaint.left, ps.rcPaint.top, ps.rcPaint.right, ps.rcPaint.bottom));


    //
    // In desktop sharing, viewSharedRgn is NULL
    //
    if (pasPerson->m_pView->m_viewSharedRgn != NULL)
    {
        POINT           ptOrigin;
        HBRUSH          hbrT;

        //
        // First, create paint area region
        //
        SetRectRgn(pasPerson->m_pView->m_viewPaintRgn, ps.rcPaint.left, ps.rcPaint.top,
            ps.rcPaint.right, ps.rcPaint.bottom);

        //
        // Second, compute the VD area not currently on screen.  Do this
        // in CLIENT coords.
        //
        SetRectRgn(pasPerson->m_pView->m_viewExtentRgn,
            -pasPerson->m_pView->m_viewPos.x,
            -pasPerson->m_pView->m_viewPos.y,
            -pasPerson->m_pView->m_viewPos.x + pasPerson->viewExtent.x,
            -pasPerson->m_pView->m_viewPos.y + pasPerson->viewExtent.y);

        SetRectRgn(pasPerson->m_pView->m_viewScreenRgn,
            -pasPerson->m_pView->m_viewPos.x + pasPerson->m_pView->m_dsScreenOrigin.x,
            -pasPerson->m_pView->m_viewPos.y + pasPerson->m_pView->m_dsScreenOrigin.y,
            -pasPerson->m_pView->m_viewPos.x + pasPerson->m_pView->m_dsScreenOrigin.x + pasPerson->cpcCaps.screen.capsScreenWidth,
            -pasPerson->m_pView->m_viewPos.y + pasPerson->m_pView->m_dsScreenOrigin.y + pasPerson->cpcCaps.screen.capsScreenHeight);

        SubtractRgn(pasPerson->m_pView->m_viewExtentRgn, pasPerson->m_pView->m_viewExtentRgn, pasPerson->m_pView->m_viewScreenRgn);

        //
        // pasPerson->m_pView->m_viewExtentRgn is now the offscreen parts of the VD, and therefore
        // any shared areas lying in them should be treated as obscured.
        //

        //
        // Now, compute the real obscured area.  It's the covered up bits
        // plus open parts of shared stuff not currently on screen.
        //
        IntersectRgn(pasPerson->m_pView->m_viewScratchRgn, pasPerson->m_pView->m_viewExtentRgn, pasPerson->m_pView->m_viewSharedRgn);
        UnionRgn(pasPerson->m_pView->m_viewScratchRgn, pasPerson->m_pView->m_viewScratchRgn, pasPerson->m_pView->m_viewObscuredRgn);

        // Calc what part of the obscured region to actually paint
        IntersectRgn(pasPerson->m_pView->m_viewScratchRgn, pasPerson->m_pView->m_viewScratchRgn, pasPerson->m_pView->m_viewPaintRgn);
        if (GetRgnBox(pasPerson->m_pView->m_viewScratchRgn, &rcT) > NULLREGION)
        {
            TRACE_OUT(("VIEWClientPaint:    Painting obscured client area {%04d, %04d, %04d, %04d}",
                rcT.left, rcT.top, rcT.right, rcT.bottom));

            //
            // Remove this area so we have what's left to paint.
            //
            SubtractRgn(pasPerson->m_pView->m_viewPaintRgn, pasPerson->m_pView->m_viewPaintRgn, pasPerson->m_pView->m_viewScratchRgn);

            //
            // We do NOT want to use FillRgn; it ignores the brush origin.
            // So we select this in as the clip region and PatBlt instead.
            //
            SelectClipRgn(hdcView, pasPerson->m_pView->m_viewScratchRgn);

#ifdef _DEBUG
            //
            // NOTE:  Do NOT move this--we're using ptOrigin for scratch.
            //
            GetDCOrgEx(hdcView, &ptOrigin);
            TRACE_OUT(("VIEWClientPaint:    Setting brush origin to {%04d, %04d}, screen {%04d, %04d}",
                -pasPerson->m_pView->m_viewPos.x, -pasPerson->m_pView->m_viewPos.y,
                ptOrigin.x - pasPerson->m_pView->m_viewPos.x,
                ptOrigin.y - pasPerson->m_pView->m_viewPos.y));
#endif

            //
            // Align the brush with where the view's real origin would be, in
            // client coords.  We do that by accounting for being scrolled over.
            //
            SetBrushOrgEx(hdcView, -pasPerson->m_pView->m_viewPos.x,
                -pasPerson->m_pView->m_viewPos.y, &ptOrigin);
            UnrealizeObject(m_viewObscuredBrush);
            hbrT = SelectBrush(hdcView, m_viewObscuredBrush);

            PatBlt(hdcView,
                rcT.left, rcT.top,
                rcT.right - rcT.left,
                rcT.bottom - rcT.top,
                PATCOPY);

            SelectBrush(hdcView, hbrT);
            SetBrushOrgEx(hdcView, ptOrigin.x, ptOrigin.y, NULL);

            SelectClipRgn(hdcView, NULL);
        }

        //
        // Paint the deadspace area, set up clipping for app sharing.
        // This also works for desktop sharing, where there are no obscured or
        // shared regions, the whole area paints.
        //

        //
        // The deadspace is whatever's left over in the paint region
        // (already subtracted the obscured region) after subtracting the
        // shared area
        //
        SubtractRgn(pasPerson->m_pView->m_viewScratchRgn, pasPerson->m_pView->m_viewPaintRgn, pasPerson->m_pView->m_viewSharedRgn);

        if (GetRgnBox(pasPerson->m_pView->m_viewScratchRgn, &rcT) > NULLREGION)
        {
            TRACE_OUT(("VIEWClientPaint:    Painting dead client area {%04d, %04d, %04d, %04d}",
                rcT.left, rcT.top, rcT.right, rcT.bottom));
            FillRgn(hdcView, pasPerson->m_pView->m_viewScratchRgn, GetSysColorBrush(COLOR_APPWORKSPACE));
        }

        //
        // Compute what part of the shared area needs painting (the part
        // that lies on the remote screen actually).
        //
        IntersectRgn(pasPerson->m_pView->m_viewScratchRgn, pasPerson->m_pView->m_viewSharedRgn, pasPerson->m_pView->m_viewScreenRgn);
        IntersectRgn(pasPerson->m_pView->m_viewScratchRgn, pasPerson->m_pView->m_viewScratchRgn, pasPerson->m_pView->m_viewPaintRgn);

        // Now select in the piece of what we're painting as the clip region
        SelectClipRgn(hdcView, pasPerson->m_pView->m_viewScratchRgn);
    }

    //
    // Blt the shared region
    //
    if (GetClipBox(hdcView, &rcT) > NULLREGION)
    {
        TRACE_OUT(("VIEWClientPaint:    Painting shared client area {%04x, %04x, %04x, %04x}",
            rcT.left, rcT.top, rcT.right, rcT.bottom));

        if (g_usrPalettized)
        {
            ASSERT(pasPerson->pmPalette != NULL);

            //
            // Select and realize the current remote palette into the
            // screen and shadow bitmap DCs.
            //
            hOldPal = SelectPalette(pasPerson->m_pView->m_usrDC, pasPerson->pmPalette, FALSE);
            RealizePalette(pasPerson->m_pView->m_usrDC);

            hOldPal2 = SelectPalette( hdcView, pasPerson->pmPalette, FALSE);
            RealizePalette(hdcView);
        }

        //
        // The host bitmap is in screen coords, not VD coords, so
        // adjust for being scrolled over...
        //
        BitBlt(hdcView,
            rcT.left, rcT.top, rcT.right - rcT.left, rcT.bottom - rcT.top,
            pasPerson->m_pView->m_usrDC,
            rcT.left + pasPerson->m_pView->m_viewPos.x - pasPerson->m_pView->m_dsScreenOrigin.x,
            rcT.top + pasPerson->m_pView->m_viewPos.y - pasPerson->m_pView->m_dsScreenOrigin.y,
            SRCCOPY);

        if (g_usrPalettized)
        {
            ASSERT(pasPerson->pmPalette != NULL);

            SelectPalette(pasPerson->m_pView->m_usrDC, hOldPal, FALSE);
            SelectPalette(hdcView, hOldPal2, FALSE);
        }
    }

    //
    // Deselect the clip region, or we won't be able to draw shadow cursors
    // that lie outside the shared area.
    //
    if (pasPerson->m_pView->m_viewSharedRgn != NULL)
    {
        SelectClipRgn(hdcView, NULL);
    }

    //
    // Draw the shadow cursor.
    //
    CM_DrawShadowCursor(pasPerson, hdcView);

DC_EXIT_POINT:

    if (hdcView != NULL)
        EndPaint(pasPerson->m_pView->m_viewClient, &ps);

    DebugExitVOID(ASShare::VIEWClientPaint);
}



//
// VIEWClientScroll()
//
// This is the common place where the scroll position is altered.  If
// necessary the contents are scrolled over, the regions (always in client
// coords) are adjusted, and new info about our origin is sent to remotes.
//
// We first make sure the scroll position is pinned properly within the
// range.
//
// The return value is whether scrolling happened or not.
//
BOOL ASShare::VIEWClientScroll
(
    ASPerson *  pasPerson,
    int         xNew,
    int         yNew
)
{
    int         dx;
    int         dy;

    DebugEntry(ASShare::VIEWClientScroll);

    //
    // First, pin the requested new position within the range
    //
    //
    // Pin x pos
    //
    if (xNew < 0)
        xNew = 0;

    if (xNew + pasPerson->m_pView->m_viewPage.x > pasPerson->viewExtent.x)
        xNew = pasPerson->viewExtent.x - pasPerson->m_pView->m_viewPage.x;

    //
    // Pin y pos
    //
    if (yNew < 0)
        yNew = 0;

    if (yNew + pasPerson->m_pView->m_viewPage.y > pasPerson->viewExtent.y)
        yNew = pasPerson->viewExtent.y - pasPerson->m_pView->m_viewPage.y;

    //
    // How much are we going to scroll by?
    //
    dx = pasPerson->m_pView->m_viewPos.x - xNew;
    dy = pasPerson->m_pView->m_viewPos.y - yNew;

    // Updates
    if (dx || dy)
    {
        //
        // Adjust regions
        //
        if (pasPerson->m_pView->m_viewObscuredRgn != NULL)
            OffsetRgn(pasPerson->m_pView->m_viewObscuredRgn, dx, dy);

        if (pasPerson->m_pView->m_viewSharedRgn != NULL)
            OffsetRgn(pasPerson->m_pView->m_viewSharedRgn, dx, dy);

        pasPerson->m_pView->m_viewPos.x = xNew;
        pasPerson->m_pView->m_viewPos.y = yNew;

        ScrollWindowEx(pasPerson->m_pView->m_viewClient,
                    dx,
                    dy,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    SW_SCROLLCHILDREN | SW_INVALIDATE);

        if (dx)
        {
            SetScrollPos(pasPerson->m_pView->m_viewClient, SB_HORZ, xNew, TRUE);
        }

        if (dy)
        {
            SetScrollPos(pasPerson->m_pView->m_viewClient, SB_VERT, yNew, TRUE);
        }
    }

    DebugExitBOOL(ASShare::VIEWClientScroll, (dx || dy));
    return(dx || dy);
}


//
// VIEWClientMouseDown()
//
void ASShare::VIEWClientMouseDown
(
    ASPerson *      pasPerson,
    UINT            message,
    WPARAM          wParam,
    LPARAM          lParam
)
{
    DebugEntry(ASShare::VIEWClientMouseDown);

    ValidateView(pasPerson);

    //
    // On the first button down, set capture so all mouse messages come
    // to us until capture is released or stolen.
    //
    if (!pasPerson->m_pView->m_viewMouseFlags)
    {
        //
        // If this is RBUTTONDOWN, track the Collaborate pop up...
        //
        ASSERT(!pasPerson->m_pView->m_viewMouseOutside);
        SetCapture(pasPerson->m_pView->m_viewClient);
    }

    //
    // Remember what button is down.
    //
    switch (message)
    {
        case WM_LBUTTONDOWN:
            pasPerson->m_pView->m_viewMouseFlags |= MK_LBUTTON;
            break;

        case WM_RBUTTONDOWN:
            pasPerson->m_pView->m_viewMouseFlags |= MK_RBUTTON;
            break;

        case WM_MBUTTONDOWN:
            pasPerson->m_pView->m_viewMouseFlags |= MK_MBUTTON;
            break;
    }

    //
    // Save the current mouse position
    //
    pasPerson->m_pView->m_viewMouse.x = GET_X_LPARAM(lParam);
    pasPerson->m_pView->m_viewMouse.y = GET_Y_LPARAM(lParam);

    VIEWClientMouseMsg(pasPerson, message, wParam, lParam);

    DebugExitVOID(ASShare::VIEWClientMouseDown);
}


//
// VIEWClientMouseUp()
//
void ASShare::VIEWClientMouseUp
(
    ASPerson *      pasPerson,
    UINT            message,
    WPARAM          wParam,
    LPARAM          lParam,
    BOOL            fReleaseCapture
)
{
    DebugEntry(ASShare::VIEWClientMouseUp);

    switch (message)
    {
        case WM_LBUTTONUP:
            if (pasPerson->m_pView->m_viewMouseFlags & MK_LBUTTON)
                pasPerson->m_pView->m_viewMouseFlags &= ~MK_LBUTTON;
            else
                fReleaseCapture = FALSE;        // From dbl-click
            break;

        case WM_RBUTTONUP:
            if (pasPerson->m_pView->m_viewMouseFlags & MK_RBUTTON)
                pasPerson->m_pView->m_viewMouseFlags &= ~MK_RBUTTON;
            else
                fReleaseCapture = FALSE;        // From dbl-click
            break;

        case WM_MBUTTONUP:
            if (pasPerson->m_pView->m_viewMouseFlags & MK_MBUTTON)
                pasPerson->m_pView->m_viewMouseFlags &= ~MK_MBUTTON;
            else
                fReleaseCapture = FALSE;        // From dbl-click
            break;
    }

    //
    // Should we release capture?
    // We don't just want to release capture on a button up.  The user may
    // press one button down then another; we don't want to release capture
    // until all buttons are up.
    //
    if (!pasPerson->m_pView->m_viewMouseFlags)
    {
        if (pasPerson->m_pView->m_viewMouseOutside)
        {
            pasPerson->m_pView->m_viewMouseOutside = FALSE;
            KillTimer(pasPerson->m_pView->m_viewClient, IDT_AUTOSCROLL);
        }

        if (fReleaseCapture)
            ReleaseCapture();
    }

    //
    // Save the current mouse position
    //
    pasPerson->m_pView->m_viewMouse.x = GET_X_LPARAM(lParam);
    pasPerson->m_pView->m_viewMouse.y = GET_Y_LPARAM(lParam);

    VIEWClientMouseMsg(pasPerson, message, wParam, lParam);

    DebugExitVOID(ASShare::VIEWClientMouseUp);
}



//
// VIEWClientCaptureStolen()
// Called when capture gets stolen away from us, like by Alt-Tab.
//
void ASShare::VIEWClientCaptureStolen(ASPerson * pasPerson)
{
    DebugEntry(ASShare::VIEWClientCaptureStolen);

    //
    // We need to fake a button up for each button we think is down.
    // Use the current cursor pos.
    //
    if (pasPerson->m_pView->m_viewMouseFlags & MK_MBUTTON)
    {
        VIEWClientMouseUp(pasPerson, WM_MBUTTONUP, pasPerson->m_pView->m_viewMouseFlags,
            MAKELPARAM(pasPerson->m_pView->m_viewMouse.x, pasPerson->m_pView->m_viewMouse.y),
            FALSE);
    }

    if (pasPerson->m_pView->m_viewMouseFlags & MK_RBUTTON)
    {
        VIEWClientMouseUp(pasPerson, WM_RBUTTONUP, pasPerson->m_pView->m_viewMouseFlags,
            MAKELPARAM(pasPerson->m_pView->m_viewMouse.x, pasPerson->m_pView->m_viewMouse.y),
            FALSE);
    }

    if (pasPerson->m_pView->m_viewMouseFlags & MK_LBUTTON)
    {
        VIEWClientMouseUp(pasPerson, WM_LBUTTONUP, pasPerson->m_pView->m_viewMouseFlags,
            MAKELPARAM(pasPerson->m_pView->m_viewMouse.x, pasPerson->m_pView->m_viewMouse.y),
            FALSE);
    }

    DebugExitVOID(ASShare::VIEWClientCaptureStolen);
}


//
// VIEWClientMouseMove()
//
void ASShare::VIEWClientMouseMove
(
    ASPerson *      pasPerson,
    UINT            message,
    WPARAM          wParam,
    LPARAM          lParam
)
{
    RECT            rcClient;

    DebugEntry(ASShare::VIEWClientMouseMove);

    if (!pasPerson->m_pView->m_viewFocus)
    {
        // Ignore mouse moves over windows that don't have the focus
        DC_QUIT;
    }

    //
    // Save the current mouse position
    //
    pasPerson->m_pView->m_viewMouse.x = GET_X_LPARAM(lParam);
    pasPerson->m_pView->m_viewMouse.y = GET_Y_LPARAM(lParam);

    GetClientRect(pasPerson->m_pView->m_viewClient, &rcClient);

    //
    // If any button is down, check whether we should kick in
    // autoscroll detection.
    //
    if (pasPerson->m_pView->m_viewMouseFlags)
    {
        // Is the mouse inside or outside the client for the first time?
        if (PtInRect(&rcClient, pasPerson->m_pView->m_viewMouse))
        {
            //
            // Was the mouse outside the client before?  If so, kill our
            // autoscroll timer, we're not dragging outside.
            //
            if (pasPerson->m_pView->m_viewMouseOutside)
            {
                pasPerson->m_pView->m_viewMouseOutside = FALSE;
                KillTimer(pasPerson->m_pView->m_viewClient, IDT_AUTOSCROLL);
            }
        }
        else
        {
            //
            // Is the first time the mouse is outside the client?  If so,
            // set our autoscroll timer to the default value.  When it goes
            // off, the autoscroll code will scroll by some multiple of
            // how far away the mouse is from the client.
            //
            if (!pasPerson->m_pView->m_viewMouseOutside)
            {
                //
                // The Windows scrollbar code uses 1/8 of the double-click
                // time, so we do also.
                //
                pasPerson->m_pView->m_viewMouseOutside = TRUE;
                SetTimer(pasPerson->m_pView->m_viewClient, IDT_AUTOSCROLL,
                    GetDoubleClickTime() / 8, NULL);
            }

            //
            // LAURABU BOGUS!
            // When IM_Periodic goop is gone for controlling, do NOT
            // pass along mouse outside messages.  Only the autoscroll
            // timer will fake a mouse move in this case.  Either that,
            // or clip the position to the nearest client area equivalent.
            //
        }
    }

    VIEWClientMouseMsg(pasPerson, message, wParam, lParam);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::VIEWClientMouseMove);
}



//
// VIEWClientMouseMsg()
//
void ASShare::VIEWClientMouseMsg
(
    ASPerson *      pasPerson,
    UINT            message,
    WPARAM          wParam,
    LPARAM          lParam
)
{
    POINT           mousePos;

    DebugEntry(ASShare::VIEWClientMouseMsg);

    //
    // Extract the mouse position from <lParam> and package it
    // in a POINT structure.  These coordinates are relative to our
    // client area.  So convert to remote's desktop by adjusting for
    // scroll position.
    //
    // Be careful when converting the LOWORD and HIWORD values
    // because the positions are signed values.
    //
    mousePos.x = GET_X_LPARAM(lParam) + pasPerson->m_pView->m_viewPos.x;
    mousePos.y = GET_Y_LPARAM(lParam) + pasPerson->m_pView->m_viewPos.y;

    //
    // These coords represent the SCREEN coords on the host.
    //
    if (pasPerson->m_caControlledBy == m_pasLocal)
    {
        if (!pasPerson->m_caControlPaused)
        {
            IM_OutgoingMouseInput(pasPerson, &mousePos, message, (UINT)wParam);
        }
    }
    else if (pasPerson->m_caAllowControl && !pasPerson->m_caControlledBy &&
        (message == WM_LBUTTONDBLCLK))
    {
        //
        // If we're already waiting for control of this person, don't bother
        // trying to take control again.
        //
        if ((m_caWaitingForReplyFrom != pasPerson) &&
            (m_caWaitingForReplyMsg  != CA_REPLY_REQUEST_TAKECONTROL))
        {
            CA_TakeControl(pasPerson);
        }
    }

    DebugExitVOID(ASShare::VIEWClientMouse);
}


//
// VIEWClientMouseWheel()
//
// Unbelievably complicated, messy, nonsensical Intellimouse wheel handling
// to scroll the client.  Since the Intellimouse makes no distinction for
// which direction to scroll in, we basically have to guess.  We don't want
// to be unpredictable and decide which direction to scroll based on how
// much is visible in each dimenion.
//
// So instead, we assume horizontal.  If the horizontal scrollbar is disabled,
// then we try vertical.  If that's disabled, we do nothing.
//
// We do NOT handle zoom and datazoom flavors.
//
// Note that this code comes from the listbox/sample source.
//
void ASShare::VIEWClientMouseWheel
(
    ASPerson *      pasHost,
    WPARAM          wParam,
    LPARAM          lParam
)
{
    int             cDetants;

    DebugEntry(ASShare::VIEWClientMouseWheel);

    //
    // The LOWORD of wParam has key state information.
    // The HIWORD of wParam is the number of mouse wheel clicks.
    //

    //
    // We don't do zoom/datazoom
    //
    if (wParam & (MK_SHIFT | MK_CONTROL))
    {
        DC_QUIT;
    }

    pasHost->m_pView->m_viewMouseWheelDelta -= (int)(short)HIWORD(wParam);
    cDetants = pasHost->m_pView->m_viewMouseWheelDelta / WHEEL_DELTA;

    if (cDetants && (m_viewMouseWheelScrollLines > 0))
    {
        POINT           ptPos;

        pasHost->m_pView->m_viewMouseWheelDelta %= WHEEL_DELTA;

        //
        // The basic idea is that we scroll some number of lines, the
        // number being cDetants.
        //
        ptPos = pasHost->m_pView->m_viewPos;

        //
        // To be consistent with other apps, and with our keyboard
        // accelerators, try the vertical direction first.
        //
        if (pasHost->m_pView->m_viewPage.y < pasHost->viewExtent.y)
        {
            ptPos.y += cDetants * pasHost->m_pView->m_viewLnSize.y;
        }
        else if (pasHost->m_pView->m_viewPage.x < pasHost->viewExtent.x)
        {
            ptPos.x += cDetants * pasHost->m_pView->m_viewLnSize.x;
        }
        else
        {
            // Nothing to scroll, the whole view fits in the client area.
        }

        VIEWClientScroll(pasHost, ptPos.x, ptPos.y);
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::VIEWClientMouseWheel);
}


//
// VIEWClientAutoScroll()
//
void ASShare::VIEWClientAutoScroll(ASPerson * pasPerson)
{
    int     dx;
    int     dy;
    RECT    rcClient;

    DebugEntry(ASShare::VIEWClientAutoScroll);

    ValidateView(pasPerson);
    ASSERT(pasPerson->m_pView->m_viewMouseOutside);

    //
    // Do scrolling.  The amount is dependent on how far outside the
    // client area we are.
    //
    GetClientRect(pasPerson->m_pView->m_viewClient, &rcClient);

    // Horizontal scrolling?
    if (pasPerson->m_pView->m_viewMouse.x < rcClient.left)
    {
        dx = pasPerson->m_pView->m_viewMouse.x - rcClient.left;
    }
    else if (pasPerson->m_pView->m_viewMouse.x >= rcClient.right)
    {
        dx = pasPerson->m_pView->m_viewMouse.x - rcClient.right + 1;
    }
    else
    {
        dx = 0;
    }


    // Vertical scrolling?
    if (pasPerson->m_pView->m_viewMouse.y < rcClient.top)
    {
        dy = pasPerson->m_pView->m_viewMouse.y - rcClient.top;
    }
    else if (pasPerson->m_pView->m_viewMouse.y >= rcClient.bottom)
    {
        dy = pasPerson->m_pView->m_viewMouse.y - rcClient.bottom + 1;
    }
    else
    {
        dy = 0;
    }

    // For every 32 pixel blocks outside the client, scroll one line amount
    if (dx)
        dx = MulDiv(pasPerson->m_pView->m_viewLnSize.x, dx, 32);
    if (dy)
        dy = MulDiv(pasPerson->m_pView->m_viewLnSize.y, dy, 32);

    // Do scrolling.
    if (VIEWClientScroll(pasPerson, pasPerson->m_pView->m_viewPos.x + dx,
            pasPerson->m_pView->m_viewPos.y + dy))
    {
        //
        // The scroll position actually changed.  So fake a mouse move
        // to the current location so that the remote's
        // cursor will be in the same spot as ours.  If our scroll pos has
        // changed, we're mapping to a different place on the remote.
        //
        VIEWClientMouseMsg(pasPerson, WM_MOUSEMOVE, pasPerson->m_pView->m_viewMouseFlags,
            MAKELPARAM(pasPerson->m_pView->m_viewMouse.x, pasPerson->m_pView->m_viewMouse.y));
    }

    DebugExitVOID(ASShare::VIEWClientAutoScroll);
}



//
// VIEW_SyncCursorPos()
//
// This is called when we see a CM_SYNC pos packet broadcasted from a
// host.  It means that we should sync our cursor to the corresponding
// position in our view.  This happens when the cursor is moved by
// an app, constrained by clipping, or we're too out of whack because it's
// taking too long.
//
// This will only do something if the frame is active and our cursor is
// currently over the client area.  If we need to, we will scroll the
// client over to make the corresponding point visible.
//
void ASShare::VIEW_SyncCursorPos
(
    ASPerson *      pasHost,
    int             xRemote,
    int             yRemote
)
{
    POINT           ptCursor;
    RECT            rcClient;
    int             xNewPos;
    int             yNewPos;
    int             xMargin;
    int             yMargin;

    DebugEntry(ASShare::VIEW_SyncCursorPos);

    ValidateView(pasHost);
    if (!pasHost->m_pView->m_viewFocus)
    {
        // The frame isn't active, do nothing
        DC_QUIT;
    }

    //
    // Is our mouse currently over the client area?
    //
    GetCursorPos(&ptCursor);
    ScreenToClient(pasHost->m_pView->m_viewClient, &ptCursor);
    GetClientRect(pasHost->m_pView->m_viewClient, &rcClient);

    if (!PtInRect(&rcClient, ptCursor))
    {
        // No sense in snapping cursor
        DC_QUIT;
    }

    //
    // Is the remote point in range of our view?  If not, we must scroll it.
    //

    // The margin is the page size if there's room, nothing if not
    xMargin = pasHost->m_pView->m_viewPgSize.x;
    if (xMargin >= rcClient.right - rcClient.left)
        xMargin = 0;

    xNewPos = pasHost->m_pView->m_viewPos.x;
    if ((xRemote < pasHost->m_pView->m_viewPos.x) ||
        (xRemote >= pasHost->m_pView->m_viewPos.x + (rcClient.right - rcClient.left)))
    {
        //
        // Scroll over more than just enough to pin the point on the left
        // side.
        //
        xNewPos = xRemote - xMargin;
    }

    yMargin = pasHost->m_pView->m_viewPgSize.y;
    if (yMargin >= rcClient.bottom - rcClient.top)
        yMargin = 0;

    yNewPos = pasHost->m_pView->m_viewPos.y;
    if ((yRemote < pasHost->m_pView->m_viewPos.y) ||
        (yRemote >= yNewPos + (rcClient.bottom - rcClient.top)))
    {
        //
        // Scroll over more than just enough to pin the point on the top
        // side.
        //
        yNewPos = yRemote - yMargin;
    }

    VIEWClientScroll(pasHost, xNewPos, yNewPos);

    ptCursor.x = xRemote - pasHost->m_pView->m_viewPos.x;
    ptCursor.y = yRemote - pasHost->m_pView->m_viewPos.y;
    ClientToScreen(pasHost->m_pView->m_viewClient, &ptCursor);

    SetCursorPos(ptCursor.x, ptCursor.y);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::VIEW_SyncCursorPos);
}



//
// VIEWWindowBarProc()
//
LRESULT CALLBACK VIEWWindowBarProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    return(g_asSession.pShare->VIEW_WindowBarProc(hwnd, message, wParam, lParam));
}



LRESULT ASShare::VIEW_WindowBarProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    LRESULT     rc = 0;
    ASPerson *  pasHost;

    DebugEntry(ASShare::VIEW_WindowBarProc);

    pasHost = (ASPerson *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if (pasHost)
    {
        ValidateView(pasHost);
    }

    switch (message)
    {
        case WM_NCCREATE:
        {
            // Get & save the person this view is for.
            pasHost = (ASPerson *)((LPCREATESTRUCT)lParam)->lpCreateParams;
            ValidateView(pasHost);
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pasHost);

            pasHost->m_pView->m_viewWindowBar = hwnd;
            goto DefWndProc;
            break;
        }

        case WM_NCDESTROY:
        {
            if (pasHost != NULL)
            {
                pasHost->m_pView->m_viewWindowBar = NULL;
            }

            goto DefWndProc;
            break;
        }

        case WM_CREATE:
        {
            if (!VIEWWindowBarCreate(pasHost, hwnd))
            {
                ERROR_OUT(("VIEWWndBarProc: couldn't create more item"));
                rc = -1;
            }
            break;
        }

        case WM_SIZE:
        {
            VIEWWindowBarResize(pasHost, hwnd);
            break;
        }

        case WM_HSCROLL:
        {
            VIEWWindowBarItemsScroll(pasHost, wParam, lParam);
            break;
        }

        default:
DefWndProc:
        {
            rc = DefWindowProc(hwnd, message, wParam, lParam);
            break;
        }
    }

    DebugExitDWORD(ASShare::VIEW_WindowBarProc, rc);
    return(rc);
}




//
// VIEWWindowBarCreate()
// Handles creation for the window bar.  We make the next/prev buttons on
// the right side, which stay there always.  They are disabled if all the
// window bar items fit, and one or both are enabled if not.
//
BOOL ASShare::VIEWWindowBarCreate
(
    ASPerson *  pasHost,
    HWND        hwndBar
)
{
    BOOL    rc = FALSE;
    RECT    rect;

    DebugEntry(ASShare::VIEWWindowBarCreate);

    ::GetClientRect(hwndBar, &rect);
    rect.top   += m_viewEdgeCY;
    rect.right -= m_viewItemScrollCX;

    //
    // Create the scrollbar, vertically centered, right-justified.
    //
    if (!::CreateWindowEx(0, "ScrollBar", NULL,
        WS_CHILD | WS_VISIBLE | SBS_HORZ | WS_CLIPSIBLINGS | WS_DISABLED,
        rect.right,
        (rect.top + rect.bottom - m_viewItemScrollCY) / 2,
        m_viewItemScrollCX, m_viewItemScrollCY,
        hwndBar, (HMENU)IDVIEW_SCROLL,
        g_asInstance, NULL))
    {
        ERROR_OUT(("VIEWWindowBarCreate:  Unable to create scroll ctrl"));
        DC_QUIT;
    }

    //
    // Create the windowbar, an integral number of items wide (including
    // trailing margin).
    //
    pasHost->m_pView->m_viewWindowBarItemFitCount =
        (rect.right - rect.left) / (m_viewItemCX + m_viewEdgeCX);

    if (!::CreateWindowEx(0, VIEW_WINDOWBARITEMS_CLASS_NAME, NULL,
        WS_CHILD | WS_VISIBLE | WS_DISABLED | WS_CLIPSIBLINGS,
        rect.left, rect.top,
        pasHost->m_pView->m_viewWindowBarItemFitCount * (m_viewItemCX + m_viewEdgeCX),
        m_viewItemCY,
        hwndBar, (HMENU)IDVIEW_ITEMS,
        g_asInstance, pasHost))
    {
        ERROR_OUT(("VIEWWindowBarCreate:  Unable to create window bar item list"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::VIEWWindowBarCreate, rc);
    return(rc);
}



//
// VIEWWindowBarResize()
//
// This is called when the window bar is resized, due to the frame being
// sized horizontally.
//
// It right-justifies the scroll control, then resizes the window list to
// hold however many integral items fit across.
//
void ASShare::VIEWWindowBarResize
(
    ASPerson *  pasHost,
    HWND        hwndBar
)
{
    RECT        rc;

    DebugEntry(ASShare::VIEWWindowBarResize);

    ValidateView(pasHost);

    //
    // Recalculate the page size, the # of items that fit across.
    // If it's different, invalidate the right side of the window bar client.
    // Move the scrollbar control, and update the scroll info.
    //

    // What might change is the number that fit across.
    ::GetClientRect(hwndBar, &rc);
    rc.top   += m_viewEdgeCY;
    rc.right -= m_viewItemScrollCX;

    // Move the scroll control, right justified.
    ::MoveWindow(::GetDlgItem(hwndBar, IDVIEW_SCROLL), rc.right,
        (rc.top + rc.bottom - m_viewItemScrollCY) / 2,
        m_viewItemScrollCX, m_viewItemScrollCY, TRUE);

    //
    // Resize the window items list to fit an integral # of items again.
    //
    pasHost->m_pView->m_viewWindowBarItemFitCount =
        (rc.right - rc.left) / (m_viewItemCX + m_viewEdgeCX);

    ::MoveWindow(::GetDlgItem(hwndBar, IDVIEW_ITEMS), rc.left, rc.top,
        pasHost->m_pView->m_viewWindowBarItemFitCount * (m_viewItemCX + m_viewEdgeCX),
        m_viewItemCY, TRUE);

    //
    // Update the scroll page and pos if necessary.
    //
    VIEWWindowBarItemsScroll(pasHost, GET_WM_HSCROLL_MPS(SB_ENDSCROLL, 0, NULL));

    DebugExitVOID(ASShare::VIEWWindowBarResize);
}




//
// VIEW_WindowBarUpdateItem()
//
// This is ONLY called for items, in the new SWL packet, that are window
// bar items.  We don't call it with non-windowbar items.  When done
// looping through the SWL entries, we can then remove the items on the
// window bar that were NOT seen in the new SWL packet.
//
// We will either create a new item on the window bar, or update an existing
// one.  In the first case, that is always a change.  In the latter, there's
// a change only if the item text changed.
//
BOOL ASShare::VIEW_WindowBarUpdateItem
(
    ASPerson *          pasHost,
    PSWLWINATTRIBUTES   pWinNew,
    LPSTR               pText
)
{
    PWNDBAR_ITEM        pItem;
    BOOL                viewAnyChanges = FALSE;

    DebugEntry(ASView::VIEW_WindowBarUpdateItem);

    ValidateView(pasHost);

    ASSERT(pWinNew->flags & SWL_FLAG_WINDOW_HOSTED);
    ASSERT(pWinNew->flags & SWL_FLAG_WINDOW_TASKBAR);

    //
    // NOTE:
    // aswlLast holds the _previous_ attributes for the windows, from
    // the previous SWL packet.  pWinNew holds the _new_ attributes for
    // the window, from the SWL packet being processed, and these
    // haven't taken effect yet.
    //

    // Does this new item already exist on the tray?
    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pasHost->m_pView->m_viewWindowBarItems),
        (void**)&pItem, FIELD_OFFSET(WNDBAR_ITEM, chain),
        FIELD_OFFSET(WNDBAR_ITEM, winIDRemote),
        pWinNew->winID, FIELD_SIZE(WNDBAR_ITEM, winIDRemote));

    if (pItem)
    {
        //
        // Update this item, and mark it as seen.
        //
        ASSERT(pItem->winIDRemote == pWinNew->winID);

        pItem->flags = pWinNew->flags | SWL_FLAG_INTERNAL_SEEN;

        //
        // Is anything going to result in a visual change?  That's only
        // the text currently.  And we only display VIEW_MAX_ITEM_CHARS at
        // most, an end ellipsis if there's too much.
        //

        //
        // NOTE that the items are always created with maximum space for
        // text, since we cannot realloc.
        //
        if (lstrcmp(pItem->szText, pText))
        {
            lstrcpyn(pItem->szText, pText, sizeof(pItem->szText));
            viewAnyChanges = TRUE;
        }
    }
    else
    {
        //
        // Create a new item.
        //
        //
        // A WNDBAR_ITEM also includes maximum space for text that we will
        // store.
        //
        pItem = (PWNDBAR_ITEM) new WNDBAR_ITEM;
        if (!pItem)
        {
            ERROR_OUT(("VIEW_WindowBarUpdateItem: no memory to create new item for remote hwnd 0x%08x",
               pWinNew->winID));
        }
        else
        {
            ::ZeroMemory(pItem, sizeof(*pItem));

            SET_STAMP(pItem, WNDITEM);

            pItem->winIDRemote  = pWinNew->winID;

            //
            // Add SEEN to the flags; when we're done we'll remove items we haven't
            // seen.
            //
            pItem->flags        = pWinNew->flags | SWL_FLAG_INTERNAL_SEEN;

            lstrcpyn(pItem->szText, pText, sizeof(pItem->szText));

            // Append to end of list
            COM_BasedListInsertBefore(&(pasHost->m_pView->m_viewWindowBarItems),
                &(pItem->chain));

            // Success!
            pasHost->m_pView->m_viewWindowBarItemCount++;

            viewAnyChanges = TRUE;
        }
    }

    DebugExitBOOL(ASShare::VIEW_UpdateWindowItem, viewAnyChanges);
    return(viewAnyChanges);
}


//
// VIEW_WindowBarEndUpdateItems()
//
// This turns redraw on and invalidates the window bar so it will repaint.
//
void ASShare::VIEW_WindowBarEndUpdateItems
(
    ASPerson *          pasHost,
    BOOL                viewAnyChanges
)
{
    PWNDBAR_ITEM        pItem;
    PWNDBAR_ITEM        pNext;

    DebugEntry(ASShare::VIEW_WindowBarEndUpdateItems);

    ValidateView(pasHost);

    //
    // Walk the window bar item list.  Keep the ones marked as seen, but
    // remove the ones we haven't seen.
    //
    pItem = (PWNDBAR_ITEM)COM_BasedListFirst(&(pasHost->m_pView->m_viewWindowBarItems),
        FIELD_OFFSET(WNDBAR_ITEM, chain));
    while (pItem)
    {
        pNext = (PWNDBAR_ITEM)COM_BasedListNext(&(pasHost->m_pView->m_viewWindowBarItems),
            pItem, FIELD_OFFSET(WNDBAR_ITEM, chain));

        //
        // If this item wasn't seen (existing & still existing, or new)
        // during processing, it's gone.  Delete it.
        //
        if (pItem->flags & SWL_FLAG_INTERNAL_SEEN)
        {
            //
            // This was just added or is still around, keep it.
            // But of course clear the flag, so we are clear for
            // processing the next SWL packet.
            //
            pItem->flags &= ~SWL_FLAG_INTERNAL_SEEN;
        }
        else
        {
            //
            // Remove it.
            //

            // We're killing the active item, clear it out.
            if (pItem == pasHost->m_pView->m_viewWindowBarActiveItem)
            {
                pasHost->m_pView->m_viewWindowBarActiveItem = NULL;
            }

            COM_BasedListRemove(&(pItem->chain));

            delete pItem;
            --pasHost->m_pView->m_viewWindowBarItemCount;
            ASSERT(pasHost->m_pView->m_viewWindowBarItemCount >= 0);

            //
            // Something changed in our list
            //
            viewAnyChanges = TRUE;
        }

        pItem = pNext;
    }

    //
    // No need to check for changes here--they would only occur if
    // an item was removed in the middle, caused by Destroy which we already
    // account for, or if items were appended to the end, which we account
    // for in Update.
    //
    if (viewAnyChanges)
    {
        // Turn off redraw on window list
        ::SendDlgItemMessage(pasHost->m_pView->m_viewWindowBar, IDVIEW_ITEMS,
                WM_SETREDRAW, FALSE, 0);

        // Adjust pos
        VIEWWindowBarItemsScroll(pasHost, GET_WM_HSCROLL_MPS(SB_ENDSCROLL, 0, NULL));

        // Figure out active window again.
        VIEW_WindowBarChangedActiveWindow(pasHost);

        // Turn back on redraw
        ::SendDlgItemMessage(pasHost->m_pView->m_viewWindowBar, IDVIEW_ITEMS,
                WM_SETREDRAW, TRUE, 0);

        // Repaint the items.
        ::InvalidateRect(::GetDlgItem(pasHost->m_pView->m_viewWindowBar, IDVIEW_ITEMS),
                NULL, TRUE);
    }
    else
    {
        //
        // ALWAYS do this -- our real SWL list has changed, regardless of whether
        // the window bar has.  And therefore we may have a different ancestor
        // relationship.
        //
        VIEW_WindowBarChangedActiveWindow(pasHost);
    }

    DebugExitVOID(ASShare::VIEW_EndUpdateWindowList);
}



//
// VIEW_WindowBarChangedActiveWindow()
//
// This is called when the active window has changed, as discovered via an
// AWC packet from the host, or when we get a new SWL packet and the shared
// list is different so the window bar items may have changed.
//
// It's quite common for the active window to be (a) nothing, meaning no
// shared app window is active or (b) not something relating to what's on
// the window bar currently.  The latter is a transitory condition, caused
// because SWL packets come before AWC packets.
//
void ASShare::VIEW_WindowBarChangedActiveWindow(ASPerson * pasHost)
{
    PWNDBAR_ITEM        pItem;
    PSWLWINATTRIBUTES   pWin;
    int                 iWin;
    UINT_PTR            activeWinID;
    TSHR_UINT32         ownerWinID;

    DebugEntry(ASShare::VIEW_WindowBarChangedActiveWindow);

    ValidateView(pasHost);

    //
    // Map this remote window to the closest window bar item in the
    // ancestor hierarchy.
    //

    pItem = NULL;
    activeWinID = pasHost->awcActiveWinID;

    while (activeWinID != 0)
    {
        //
        // Is this on the window bar?
        //
        COM_BasedListFind(LIST_FIND_FROM_FIRST,
            &(pasHost->m_pView->m_viewWindowBarItems),
            (void**)&pItem, FIELD_OFFSET(WNDBAR_ITEM, chain),
            FIELD_OFFSET(WNDBAR_ITEM, winIDRemote),
            activeWinID, FIELD_SIZE(WNDBAR_ITEM, winIDRemote));

        if (pItem)
        {
            // Yes.
            TRACE_OUT(("VIEW_UpdateActiveWindow:  Window 0x%08x found", activeWinID));
            break;
        }

        //
        // Try to go up the chain to this window's owner.  Find this item,
        // then grab the owner of it, and try again.
        //
        ownerWinID  = 0;

        for (iWin = 0, pWin = pasHost->m_pView->m_aswlLast;
             iWin < pasHost->m_pView->m_swlCount;
             iWin++, pWin++)
        {
            if (pWin->winID == activeWinID)
            {
                // Found it.
                ownerWinID = pWin->ownerWinID;
                break;
            }
        }

        activeWinID = ownerWinID;
    }

    //
    // Now see if the active item is different.
    //
    VIEWWindowBarChangeActiveItem(pasHost, pItem);

    DebugExitVOID(ASShare::VIEW_WindowBarChangedActiveWindow);
}


//
// VIEWWindowBarFirstVisibleItem()
//
// This returns a pointer to the first visible item.  We must loop through
// the invisible items first.  Since this doesn't happen with a lot of
// frequence, and the size of the list is rarely that big, this is fine.
//
// We return NULL if the list is empty.
//
PWNDBAR_ITEM ASShare::VIEWWindowBarFirstVisibleItem(ASPerson * pasHost)
{
    PWNDBAR_ITEM    pItem;
    int             iItem;

    ValidateView(pasHost);

    if (!pasHost->m_pView->m_viewWindowBarItemCount)
    {
        pItem = NULL;
        DC_QUIT;
    }

    ASSERT(pasHost->m_pView->m_viewWindowBarItemFirst < pasHost->m_pView->m_viewWindowBarItemCount);

    pItem = (PWNDBAR_ITEM)COM_BasedListFirst(&(pasHost->m_pView->m_viewWindowBarItems),
        FIELD_OFFSET(WNDBAR_ITEM, chain));
    for (iItem = 0; iItem < pasHost->m_pView->m_viewWindowBarItemFirst; iItem++)
    {
        ASSERT(pItem);

        pItem = (PWNDBAR_ITEM)COM_BasedListNext(&(pasHost->m_pView->m_viewWindowBarItems),
            pItem, FIELD_OFFSET(WNDBAR_ITEM, chain));
    }

    ASSERT(pItem);

DC_EXIT_POINT:
    DebugExitPVOID(ASShare::VIEWWindowBarFirstVisibleItem, pItem);
    return(pItem);
}




//
// VIEWWindowBarChangeActiveItem()
//
// Updates the active item on the window bar.  This happens when either
// we get a new AWC packet telling us there's a new active window on the host,
// or when we get a SWL packet, which may have added/removed items.  This
// also happens when one is clicked on and the user is in control of the host.
//
void ASShare::VIEWWindowBarChangeActiveItem
(
    ASPerson *      pasHost,
    PWNDBAR_ITEM    pItem
)
{
    DebugEntry(ASShare::VIEWWindowBarChangeActiveItem);


    //
    // If it's the active one already, nothing to do.
    //
    if (pItem == pasHost->m_pView->m_viewWindowBarActiveItem)
    {
        TRACE_OUT(("VIEWWindowBarChangeActiveItem: activating current item, nothing to do"));
        DC_QUIT;
    }

    //
    // Now make the visual change
    //
    if (pasHost->m_pView->m_viewWindowBarActiveItem)
    {
        VIEWWindowBarItemsInvalidate(pasHost, pasHost->m_pView->m_viewWindowBarActiveItem);
    }

    pasHost->m_pView->m_viewWindowBarActiveItem = pItem;

    if (pItem)
    {
        VIEWWindowBarItemsInvalidate(pasHost, pItem);
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::VIEWWindowBarChangeActiveItem);
}





//
// VIEWWindowBarItemsScroll()
//
// This is called when the end user presses a scroll button to shuffle over
// the visible window bar items.  And also when items are added/removed
// so that scroll stuff is adjusted.
//
void ASShare::VIEWWindowBarItemsScroll
(
    ASPerson *      pasHost,
    WPARAM          wParam,
    LPARAM          lParam
)
{
    int             oldPos;
    int             newPos;
    SCROLLINFO      si;

    DebugEntry(ASShare::VIEWWindowBarItemsScroll);

    ValidateView(pasHost);

    oldPos = pasHost->m_pView->m_viewWindowBarItemFirst;

    switch (GET_WM_HSCROLL_CODE(wParam, lParam))
    {
        case SB_LINEUP:
        case SB_PAGEUP:
            newPos = oldPos - 1;
            break;

        case SB_LINEDOWN:
        case SB_PAGEDOWN:
            newPos = oldPos + 1;
            break;

        case SB_TOP:
            newPos = 0;
            break;

        case SB_BOTTOM:
            newPos = pasHost->m_pView->m_viewWindowBarItemCount;
            break;

        case SB_THUMBTRACK:
        case SB_THUMBPOSITION:
            newPos = GET_WM_HSCROLL_POS(wParam, lParam);
            break;

        default:
            newPos = oldPos;
            break;

    }

    //
    // Pin position into range, taking care to show the maximum number
    // of items that will fit in the space.
    //
    if (newPos + pasHost->m_pView->m_viewWindowBarItemFitCount >
        pasHost->m_pView->m_viewWindowBarItemCount)
    {
        newPos = pasHost->m_pView->m_viewWindowBarItemCount -
            pasHost->m_pView->m_viewWindowBarItemFitCount;
    }

    if (newPos < 0)
        newPos = 0;

    //
    // Has the position changed?
    //
    if (newPos != oldPos)
    {
        pasHost->m_pView->m_viewWindowBarItemFirst = newPos;

        //
        // Scroll the item area over.  This will do nothing if redraw is off.
        // Conveniently!
        //
        ::ScrollWindowEx(::GetDlgItem(pasHost->m_pView->m_viewWindowBar, IDVIEW_ITEMS),
            (oldPos - newPos) * (m_viewItemCX + m_viewEdgeCX),
            0,
            NULL, NULL, NULL, NULL,
            SW_INVALIDATE | SW_ERASE);
    }

    //
    // If nothing's changed, no big deal.
    //
    ::ZeroMemory(&si, sizeof(si));

    si.cbSize = sizeof(SCROLLINFO);
    si.fMask = SIF_DISABLENOSCROLL | SIF_POS | SIF_PAGE | SIF_RANGE;

    si.nMin  = 0;
    si.nMax  = pasHost->m_pView->m_viewWindowBarItemCount - 1;
    si.nPage = pasHost->m_pView->m_viewWindowBarItemFitCount;
    si.nPos  = pasHost->m_pView->m_viewWindowBarItemFirst;

    ::SetScrollInfo(::GetDlgItem(pasHost->m_pView->m_viewWindowBar, IDVIEW_SCROLL),
        SB_CTL, &si, TRUE);

    DebugExitVOID(ASShare::VIEWWindowBarItemsScroll);
}





//
// VIEWWindowBarItemsProc()
//
LRESULT CALLBACK VIEWWindowBarItemsProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    return(g_asSession.pShare->VIEW_WindowBarItemsProc(hwnd, message, wParam, lParam));
}



LRESULT ASShare::VIEW_WindowBarItemsProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    LRESULT     rc = 0;
    ASPerson *  pasHost;

    DebugEntry(ASShare::VIEW_WindowBarItemsProc);

    pasHost = (ASPerson *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if (pasHost)
    {
        ValidateView(pasHost);
    }

    switch (message)
    {
        case WM_NCCREATE:
        {
            // Get & save the person this view is for.
            pasHost = (ASPerson *)((LPCREATESTRUCT)lParam)->lpCreateParams;
            ValidateView(pasHost);
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pasHost);

            COM_BasedListInit(&(pasHost->m_pView->m_viewWindowBarItems));
            goto DefWndProc;
            break;
        }

        case WM_NCDESTROY:
        {
            if (pasHost != NULL)
            {
                // Loop through the items, killing the head, until done.
                PWNDBAR_ITEM    pItem;

                while (pItem = (PWNDBAR_ITEM)COM_BasedListFirst(
                    &(pasHost->m_pView->m_viewWindowBarItems),
                    FIELD_OFFSET(WNDBAR_ITEM, chain)))
                {
                    COM_BasedListRemove(&(pItem->chain));

                    delete pItem;
                }

                //
                // Zero these out for safety.  Yes, we're about to free
                // m_pView altogether, so find out if we're referencing
                // stuff that's gone.
                //
                pasHost->m_pView->m_viewWindowBarItemCount = 0;
                pasHost->m_pView->m_viewWindowBarActiveItem = NULL;
            }

            goto DefWndProc;
            break;
        }

        case WM_ENABLE:
        {
            // Repaint the items, disabled or pressable.
            ::InvalidateRect(hwnd, NULL, FALSE);
            break;
        }

        case WM_PAINT:
        {
            VIEWWindowBarItemsPaint(pasHost, hwnd);
            break;
        }

        case WM_LBUTTONDOWN:
        {
            VIEWWindowBarItemsClick(pasHost, hwnd,
                GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
            break;
        }

        default:
DefWndProc:
        {
            rc = DefWindowProc(hwnd, message, wParam, lParam);
            break;
        }
    }

    DebugExitDWORD(ASShare::VIEW_WindowBarItemsProc, rc);
    return(rc);
}




//
// VIEWWindowBarItemsPaint()
//
void ASShare::VIEWWindowBarItemsPaint
(
    ASPerson *      pasHost,
    HWND            hwndItems
)
{
    HFONT           hfnT;
    COLORREF        clrText;
    int             bkMode;
    PWNDBAR_ITEM    pItem;
    PAINTSTRUCT     ps;
    int             xT;
    RECT            rcItem;

    DebugEntry(ASShare::VIEWWindowBarItemsPaint);

    ValidateView(pasHost);

    ::BeginPaint(hwndItems, &ps);

    //
    // Skip over the visible items to the left of the paint area.
    //
    xT = 0;
    pItem = VIEWWindowBarFirstVisibleItem(pasHost);
    while (pItem && (xT + m_viewItemCX < ps.rcPaint.left))
    {
        pItem = (PWNDBAR_ITEM)COM_BasedListNext(&(pasHost->m_pView->m_viewWindowBarItems),
            pItem, FIELD_OFFSET(WNDBAR_ITEM, chain));
        xT += m_viewItemCX + m_viewEdgeCX;
    }

    //
    // Setup painting objects, etc.
    //
    hfnT = SelectFont(ps.hdc, ::GetStockObject(DEFAULT_GUI_FONT));
    if ((pasHost->m_caControlledBy != m_pasLocal) || pasHost->m_caControlPaused)
    {
        clrText = ::GetSysColor(COLOR_GRAYTEXT);
    }
    else
    {
        clrText = ::GetSysColor(COLOR_BTNTEXT);
    }
    clrText = ::SetTextColor(ps.hdc, clrText);
    bkMode = ::SetBkMode(ps.hdc, TRANSPARENT);

    //
    // Now paint the visible items within the paint area.
    //
    while (pItem && (xT < ps.rcPaint.right))
    {
        rcItem.left     = xT;
        rcItem.top      = 0;
        rcItem.right    = rcItem.left + m_viewItemCX;
        rcItem.bottom   = rcItem.top + m_viewItemCY;

        //
        // Draw button area, pressed in & checked for current tray item.
        //
        DrawFrameControl(ps.hdc, &rcItem, DFC_BUTTON,
        DFCS_BUTTONPUSH | DFCS_ADJUSTRECT |
        ((pItem == pasHost->m_pView->m_viewWindowBarActiveItem) ? (DFCS_PUSHED | DFCS_CHECKED) : 0));

        // Subtract some margin.
        ::InflateRect(&rcItem, -m_viewEdgeCX, -m_viewEdgeCY);

        if (pItem == pasHost->m_pView->m_viewWindowBarActiveItem)
        {
            // Offset one for pushed effect
            ::OffsetRect(&rcItem, 1, 1);
        }

        //
        // Draw icon
        //
        ::DrawIconEx(ps.hdc, rcItem.left,
            (rcItem.top + rcItem.bottom - ::GetSystemMetrics(SM_CYSMICON)) / 2,
            g_hetASIconSmall,
            ::GetSystemMetrics(SM_CXSMICON),
            ::GetSystemMetrics(SM_CYSMICON),
            0, NULL, DI_NORMAL);

        rcItem.left += ::GetSystemMetrics(SM_CXSMICON) + m_viewEdgeCX;

        //
        // Draw item text
        //
        ::DrawText(ps.hdc, pItem->szText, -1, &rcItem, DT_NOCLIP | DT_EXPANDTABS |
            DT_NOPREFIX | DT_VCENTER | DT_SINGLELINE | DT_END_ELLIPSIS);

        pItem = (PWNDBAR_ITEM)COM_BasedListNext(&(pasHost->m_pView->m_viewWindowBarItems),
            pItem, FIELD_OFFSET(WNDBAR_ITEM, chain));
        xT += m_viewItemCX + m_viewEdgeCX;
    }

    ::SetBkMode(ps.hdc, bkMode);
    ::SetTextColor(ps.hdc, clrText);
    SelectFont(ps.hdc, hfnT);

    ::EndPaint(hwndItems, &ps);

    DebugExitVOID(ASShare::VIEWWindowBarItemsPaint);
}



//
// VIEWWindowBarItemsClick()
//
// Handles a left click on the window bar area.  When we are in control, this
// will try to activate/restore the remote window the clicked item represents.
//
void ASShare::VIEWWindowBarItemsClick
(
    ASPerson *  pasHost,
    HWND        hwndItems,
    int         x,
    int         y
)
{
    RECT            rc;
    PWNDBAR_ITEM    pItemT;

    DebugEntry(ASShare::VIEWWindowBarClick);

    ValidateView(pasHost);

    //
    // If we're not in control of this host, or there aren't any items, we're
    // done.
    //
    if ((pasHost->m_caControlledBy != m_pasLocal)   ||
        pasHost->m_caControlPaused                  ||
        (!pasHost->m_pView->m_viewWindowBarItemCount))
    {
        DC_QUIT;
    }

    ::GetClientRect(hwndItems, &rc);

    //
    // Start at first visible item.
    //
    pItemT = VIEWWindowBarFirstVisibleItem(pasHost);
    while (pItemT && (rc.left < rc.right))
    {
        // Is x in range?
        if ((x >= rc.left) && (x < rc.left + m_viewItemCX))
        {
            // YES!  We've found the item.  If it's different than the
            // current one, send a packet to the host.
            //
            // LAURABU BUGBUG:
            // Should we do this always?  Is it possible to have an active
            // item whose z-order would change if the active button was
            // pressed again?
            //
            // We're trying to avoid sending a ton of requests from somebody
            // who clicks repeatedly on the same button, when we haven't
            // received an AWC notification back.
            //
            VIEWWindowBarDoActivate(pasHost, pItemT);
            break;
        }

        pItemT = (PWNDBAR_ITEM)COM_BasedListNext(&(pasHost->m_pView->m_viewWindowBarItems),
            pItemT, FIELD_OFFSET(WNDBAR_ITEM, chain));
        rc.left += m_viewItemCX + m_viewEdgeCX;
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::VIEWWindowBarItemsClick);
}



//
// VIEWWindowBarDoActivate()
//
// Sends command to remote host requesting the window be activated and
// maybe unminimized.
//
// This is used when clicking on a button or choosing the window's item in
// the Applications menu.
//
void ASShare::VIEWWindowBarDoActivate
(
    ASPerson *      pasHost,
    PWNDBAR_ITEM    pItem
)
{
    DebugEntry(ASShare::VIEWWindowBarDoActivate);

    ValidateView(pasHost);
    if (pItem != pasHost->m_pView->m_viewWindowBarActiveItem)
    {
        // Activate  it.  If we can't send an activate request,
        // do not update the active item.
        //
        if (!AWC_SendMsg(pasHost->mcsID, AWC_MSG_ACTIVATE_WINDOW,
            pItem->winIDRemote, 0))
        {
            ERROR_OUT(("VIEWWindowBarDoActivate: can't send AWC packet so failing"));
        }
        else
        {
            VIEWWindowBarChangeActiveItem(pasHost, pItem);
        }
    }

    // Try to restore if minimized no matter what.
    if (pItem->flags & SWL_FLAG_WINDOW_MINIMIZED)
    {
        AWC_SendMsg(pasHost->mcsID, AWC_MSG_RESTORE_WINDOW, pItem->winIDRemote, 0);
    }

    DebugExitVOID(ASShare::VIEWWindowBarDoActivate);
}


//
// VIEWWindowBarItemsInvalidate()
//
// This invalidates the window bar item, if it's visible in the window bar
// list currently.
//
void ASShare::VIEWWindowBarItemsInvalidate
(
    ASPerson *      pasHost,
    PWNDBAR_ITEM    pItem
)
{
    PWNDBAR_ITEM    pItemT;
    RECT            rc;

    DebugEntry(ASShare::VIEWWindowBarItemsInvalidate);

    ValidateView(pasHost);

    ASSERT(pItem);

    ::GetClientRect(::GetDlgItem(pasHost->m_pView->m_viewWindowBar, IDVIEW_ITEMS),
        &rc);

    //
    // Start at the first visible item, and see if any in the visible range
    // are this one.  There will never be that many items visible across,
    // it's not heinous to do this.
    //
    pItemT = VIEWWindowBarFirstVisibleItem(pasHost);
    while (pItemT && (rc.left < rc.right))
    {
        if (pItemT == pItem)
        {
            // Found it, it's in the visible range.  Invalidate it.
            rc.right = rc.left + m_viewItemCX;
            ::InvalidateRect(::GetDlgItem(pasHost->m_pView->m_viewWindowBar,
                IDVIEW_ITEMS), &rc, TRUE);
            break;
        }

        pItemT = (PWNDBAR_ITEM)COM_BasedListNext(&(pasHost->m_pView->m_viewWindowBarItems),
            pItemT, FIELD_OFFSET(WNDBAR_ITEM, chain));
        rc.left += m_viewItemCX + m_viewEdgeCX;
    }

    DebugExitVOID(ASShare::VIEWWindowBarItemsInvalidate);
}




//
// VIEWFullScreenExitProc()
//
// Window handler for full screen exit button.
//
LRESULT CALLBACK VIEWFullScreenExitProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    return(g_asSession.pShare->VIEW_FullScreenExitProc(hwnd, message, wParam, lParam));
}



//
// VIEW_FullScreenExitProc()
//
LRESULT ASShare::VIEW_FullScreenExitProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    LRESULT     rc = 0;
    ASPerson *  pasHost;

    DebugEntry(VIEW_FullScreenExitProc);

    pasHost = (ASPerson *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if (pasHost)
    {
        ValidateView(pasHost);
    }

    switch (message)
    {
        case WM_NCCREATE:
        {
            // Get the passed in host pointer, and set in our window long
            pasHost = (ASPerson *)((LPCREATESTRUCT)lParam)->lpCreateParams;
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pasHost);

            goto DefWndProc;
            break;
        }

        case WM_NCDESTROY:
        {
            //
            // Make sure tracking is stopped.
            //
            pasHost->m_pView->m_viewFullScreenExitTrack = FALSE;
            break;
        }

        case WM_ERASEBKGND:
        {
            rc = TRUE;
            break;
        }

        case WM_PAINT:
        {
            VIEWFullScreenExitPaint(pasHost, hwnd);
            break;
        }

        case WM_LBUTTONDOWN:
        {
            //
            // Start tracking to move or click button.
            //
            pasHost->m_pView->m_viewFullScreenExitTrack = TRUE;
            pasHost->m_pView->m_viewFullScreenExitMove = FALSE;

            // Original click, relative to our client
            pasHost->m_pView->m_viewFullScreenExitStart.x =
                GET_X_LPARAM(lParam);
            pasHost->m_pView->m_viewFullScreenExitStart.y =
                GET_Y_LPARAM(lParam);

            // Set capture, and wait for moves/button up
            SetCapture(hwnd);
            break;
        }

        case WM_MOUSEMOVE:
        {
            if (pasHost->m_pView->m_viewFullScreenExitTrack)
            {
                POINT   ptMove;

                ptMove.x = GET_X_LPARAM(lParam);
                ptMove.y = GET_Y_LPARAM(lParam);

                //
                // If we're not in move mode, see if this has pushed us over
                // the tolerance.
                //
                if (!pasHost->m_pView->m_viewFullScreenExitMove)
                {
                    if ((abs(ptMove.x - pasHost->m_pView->m_viewFullScreenExitStart.x) >
                            GetSystemMetrics(SM_CXDRAG))    ||
                        (abs(ptMove.y - pasHost->m_pView->m_viewFullScreenExitStart.y) >
                            GetSystemMetrics(SM_CYDRAG)))
                    {
                        //
                        // User has moved out of tolerance zone, must be
                        // dragging to move the button out of the way.
                        //
                        pasHost->m_pView->m_viewFullScreenExitMove = TRUE;
                    }
                }

                if (pasHost->m_pView->m_viewFullScreenExitMove)
                {
                    RECT    rcWindow;

                    //
                    // Move the button so that the cursor is over the
                    // same point as originally clicked on.
                    //

                    // Get our current position, in parent coordsinates.
                    GetWindowRect(hwnd, &rcWindow);
                    MapWindowPoints(NULL, GetParent(hwnd), (LPPOINT)&rcWindow, 2);

                    // Offset it by the amount of the move.
                    OffsetRect(&rcWindow,
                        ptMove.x - pasHost->m_pView->m_viewFullScreenExitStart.x,
                        ptMove.y - pasHost->m_pView->m_viewFullScreenExitStart.y);
                    SetWindowPos(hwnd, NULL, rcWindow.left, rcWindow.top, 0, 0,
                        SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER);
                }
            }
            break;
        }

        case WM_LBUTTONUP:
        {
            if (pasHost->m_pView->m_viewFullScreenExitTrack)
            {
                //
                // This will send us CAPTURECHANGED, causing us to clear
                // the ExitTrack flag.
                //
                ReleaseCapture();

                //
                // If we never transitioned into move mode, then this was
                // a click on the button.
                //
                if (!pasHost->m_pView->m_viewFullScreenExitMove)
                {
                    //
                    // This was a click, send a command.
                    //
                    PostMessage(pasHost->m_pView->m_viewFrame, WM_COMMAND, CMD_VIEWFULLSCREEN, 0);
                }
            }
            break;
        }

        case WM_CAPTURECHANGED:
        {
            //
            // If we're tracking, something happened, so cancel out.
            //
            if (pasHost->m_pView->m_viewFullScreenExitTrack)
            {
                pasHost->m_pView->m_viewFullScreenExitTrack = FALSE;
            }
            break;
        }

        default:
DefWndProc:
            rc = DefWindowProc(hwnd, message, wParam, lParam);
            break;
    }

    DebugExitDWORD(VIEW_FullScreenExitProc, rc);
    return(rc);

}



//
// VIEWFullScreenExitPaint()
//
// Paints the full screen button.
//
void ASShare::VIEWFullScreenExitPaint
(
    ASPerson *  pasHost,
    HWND        hwnd
)
{
    RECT        rc;
    PAINTSTRUCT ps;
    char        szRestore[256];
    HFONT       hfnOld;
    COLORREF    txtColor;
    COLORREF    bkColor;

    DebugEntry(ASShare::VIEWFullScreenExitPaint);

    BeginPaint(hwnd, &ps);

    GetClientRect(hwnd, &rc);
    DrawFrameControl(ps.hdc, &rc, DFC_BUTTON, DFCS_BUTTONPUSH |
        DFCS_ADJUSTRECT);

    // Margin adjustments...
    InflateRect(&rc, -m_viewEdgeCX, -m_viewEdgeCY);

    DrawIconEx(ps.hdc, rc.left,
        (rc.top + rc.bottom - GetSystemMetrics(SM_CYSMICON)) / 2,
        m_viewFullScreenExitIcon,
        GetSystemMetrics(SM_CXSMICON),
        GetSystemMetrics(SM_CYSMICON),
        0, NULL, DI_NORMAL);
    rc.left += GetSystemMetrics(SM_CXSMICON) + m_viewEdgeCX;

    hfnOld = SelectFont(ps.hdc, GetStockObject(DEFAULT_GUI_FONT));
    txtColor = SetTextColor(ps.hdc, GetSysColor(COLOR_BTNTEXT));
    bkColor = SetBkColor(ps.hdc, GetSysColor(COLOR_BTNFACE));

    LoadString(g_asInstance, IDS_RESTORE, szRestore, sizeof(szRestore));
    DrawText(ps.hdc, szRestore, -1, &rc, DT_NOCLIP | DT_EXPANDTABS |
        DT_NOPREFIX | DT_VCENTER | DT_SINGLELINE);

    SetBkColor(ps.hdc, bkColor);
    SetTextColor(ps.hdc, txtColor);
    SelectFont(ps.hdc, hfnOld);
    EndPaint(hwnd, &ps);

    DebugExitVOID(ASShare::VIEWFullScreenExitPaint);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32.95\global95.cpp ===
#include "precomp.h"


//
// This file generates the storage for our Win95 specific global variables
//

#include <datainit.h>
#include <global95.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32.95\makefile.inc ===
!include $(ROOT)\as\common.inc

$(TARGET_DIRECTORY)\asthkls.asm: ..\thk\asthkls.thk
     $(DEVROOT)\bin\misc\i386\thunk -t thk -o $@ ..\thk\asthkls.thk
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32.nt\cpi32dll.cpp ===
#include "precomp.h"


//
// CPI32DLL.CPP
// CPI32 dll entry point
//
// Copyright(c) Microsoft 1997-
//

#define INIT_DBG_ZONE_DATA
#include "dbgzones.h"


BOOL APIENTRY DllMain (HINSTANCE hInstance, DWORD reason, LPVOID plReserved)
{
    BOOL    rc = TRUE;

    switch (reason)
    {
        case DLL_PROCESS_ATTACH:
        {
#ifdef _DEBUG
            MLZ_DbgInit((PSTR *) &c_apszDbgZones[0],
                        (sizeof(c_apszDbgZones) / sizeof(c_apszDbgZones[0])) - 1);
#endif // _DEBUG

            DBG_INIT_MEMORY_TRACKING(hInstance);

            //
            // Utility stuff
            //
            if (!UT_HandleProcessStart(hInstance))
            {
                rc = FALSE;
                break;
            }

            //
            // Call platform specific init code
            //
            OSI_Load();

            //
            // Do common stuff
            //

            //
            // Init Persistent PKZIP -- this just calculates some values 
            // which are effectively constants, the tables are just too 
            // unwieldy to declare as such.
            //
            GDC_Init();

            break;
        }

        case DLL_PROCESS_DETACH:
        {
            //
            // Call platform specific cleanup code
            //
            OSI_Unload();


            //
            // Utility stuff
            //
            UT_HandleProcessEnd();

            DBG_CHECK_MEMORY_TRACKING(hInstance);

#ifdef _DEBUG
            MLZ_DbgDeInit();
#endif // _DEBUG

            break;
        }

        case DLL_THREAD_DETACH:
            UT_HandleThreadEnd();
            break;

        default:
            break;
    }

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32.95\precomp.h ===
#include <dcg.h>
#include <ut.h>
#include <dcs.h>
#include <globals.h>
#include <global95.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\wb.cpp ===
#include "precomp.h"


//
// WB.CPP
// Whiteboard Services
//
// Copyright(c) Microsoft 1997-
//

#include <wb.hpp>

#define MLZ_FILE_ZONE  ZONE_WB


//
// Constructor
//
BOOL WbClient::WbInit(PUT_CLIENT putTask, UTEVENT_PROC eventProc)
{
    BOOL    rc = FALSE;

    DebugEntry(WbInit);

    //
    // Fill in the fields
    //
    m_state                = STATE_EMPTY;
    m_subState             = STATE_EMPTY;
    m_hLoadFile            = INVALID_HANDLE_VALUE;

    wbClientReset();

    //
    // Set the current state to the start of registration state.
    // Store the UT handle - we will need this in any calls to the UT API.
    // Set the ObMan handle to NULL to show that we have not registered.
    //
    m_state    = STATE_STARTING;
    m_subState = STATE_START_START;
    m_putTask  = putTask;
    m_pomClient = NULL;
    UT_RegisterEvent(putTask, eventProc, NULL, UT_PRIORITY_NORMAL);


    TRACE_OUT(("Initialized state to STATE_STARTING"));

    //
    // Register an event handler to trap events from ObMan.  The third
    // parameter is data that will be passed to the event handler.  We give
    // the client data pointer so that we can access the correct data for
    // each message.
    //
    UT_RegisterEvent(putTask, wbCoreEventHandler, this, UT_PRIORITY_NORMAL);

    //
    // Register as a Call Manager Secondary.  This is required to query the
    // Call Manager personID to insert into the WB_PERSON structure.
    //
    if (!CMS_Register(putTask, CMTASK_WB, &(m_pcmClient)))
    {
        ERROR_OUT(("CMS_Register failed"));
        DC_QUIT;
    }

    //
    // Update the state
    //
    m_subState = STATE_START_REGISTERED_EVENT;
    TRACE_OUT(("Moved to substate STATE_START_REGISTERED_EVENT"));

    //
    // Register with ObMan as a client
    //
    if (OM_Register(putTask, OMCLI_WB, &(m_pomClient)) != 0)
    {
        ERROR_OUT(("OM_Register failed"));
        DC_QUIT;
    }

    //
    // Update the state
    //
    m_subState = STATE_START_REGISTERED_OM;
    TRACE_OUT(("Moved to substate STATE_START_REGISTERED_OM"));

    //
    // Register an exit handler.  This has to be done after registering with
    // ObMan so that it gets called before the exit procedure registered by
    // ObMan.
    //
    UT_RegisterExit(putTask, wbCoreExitHandler, this);

    //
    // Update the state
    //
    m_state = STATE_STARTED;
    m_subState = STATE_STARTED_START;

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(WbInit, rc);
    return(rc);

}


//
// CreateWBObject()
//
BOOL WINAPI CreateWBObject
(
    UTEVENT_PROC    eventProc,
    IWbClient**      ppwbClient
)
{
    BOOL            rc = FALSE;
    WbClient*       pwbClient = NULL;
    PUT_CLIENT      putTask = NULL;

    DebugEntry(CreateWBObject);

    //
    // Initialize the WB task
    //
    if (!UT_InitTask(UTTASK_WB, &putTask))
    {
        ERROR_OUT(("Can't register WB task"));
        DC_QUIT;
    }

    //
    // Allocate the WB client object
    //
    pwbClient = new WbClient();
    if (!pwbClient)
    {
        ERROR_OUT(("Couldn't allocate WbClient object"));

        UT_TermTask(&putTask);
        DC_QUIT;
    }
    else
    {
        rc = pwbClient->WbInit(putTask, eventProc);
        if (!rc)
        {
            pwbClient->WBP_Stop(eventProc);
            pwbClient = NULL;
        }
    }

DC_EXIT_POINT:
    *ppwbClient = (IWbClient *)pwbClient;

    DebugExitBOOL(CreateWBObject, rc);
    return(rc);
}



//
// WBP_Stop()
//
STDMETHODIMP_(void) WbClient::WBP_Stop(UTEVENT_PROC eventProc)
{
    PUT_CLIENT  putTask;

    DebugEntry(WBP_Stop);

    //
    // UT_TermTask() will call our exit handler and cause cleanup.
    //

    putTask = m_putTask;
    UT_DeregisterEvent(putTask, eventProc, NULL);

    // NOTE:
    // UT_TermTask() will put NULL into the pointer you pass in after it
    // has finished.  But part of its job is to call your exit proc. Our
    // exit handler will call 'delete this' to kill us off. So when it
    // winds back to UT_TermTask(), the UT_CLIENT* pointer will be invalid.
    // That's why we use a temp. variable.
    //
    UT_TermTask(&putTask);

    DebugExitVOID(WBP_Stop);
}



//
// WBP_PostEvent()
//
// Post an event back to the WB applet after a delay
//
STDMETHODIMP_(void) WbClient::WBP_PostEvent
(
    UINT        delay,
    UINT        event,
    UINT_PTR    param1,
    UINT_PTR    param2
)
{
    DebugEntry(WBP_PostEvent);

    UT_PostEvent(m_putTask, m_putTask, delay, event, param1, param2);

    DebugExitVOID(WBP_PostEvent);
}



//
// WBP_JoinCall
//
STDMETHODIMP_(UINT) WbClient::WBP_JoinCall
(
    BOOL        bContentsKeep,
    UINT        callID
)
{
    UINT        result = 0;

    DebugEntry(WBP_JoinCall);

    TRACE_OUT(("Keep contents = %s", (bContentsKeep) ? "TRUE" : "FALSE"));
    TRACE_OUT(("Call ID = %d", callID));

    //
    // If we are to keep the existing contents, just move our workset group
    // into the specified call.
    //
    if (bContentsKeep)
    {
        result = OM_WSGroupMoveReq(m_pomClient, m_hWSGroup, callID,
            &(m_wsgroupCorrelator));
        if (result != 0)
        {
            ERROR_OUT(("OM_WSGroupMoveReq failed"));
            DC_QUIT;
        }

        //
        // The move request was successful, change the state to show that we
        // are waiting for a move request to complete.
        //
        m_state = STATE_REGISTERING;
        m_subState = STATE_REG_PENDING_WSGROUP_MOVE;

        TRACE_OUT(("Moved to substate STATE_REG_PENDING_WSGROUP_MOVE"));
        DC_QUIT;
    }

    //
    // Leave the current call.  This returns the client state to what it
    // should be after a wbStart call.
    //
    wbLeaveCall();

    //
    // Register with the workset group
    //
    result = OM_WSGroupRegisterPReq(m_pomClient, callID,
        OMFP_WB, OMWSG_WB, &(m_wsgroupCorrelator));
    if (result != 0)
    {
        ERROR_OUT(("OM_WSGroupRegisterReq failed, result = %d", result));
        DC_QUIT;
    }

    //
    // Update the state
    //
    m_state = STATE_REGISTERING;
    m_subState = STATE_REG_PENDING_WSGROUP_CON;
    TRACE_OUT(("Moved to state STATE_REGISTERING"));
    TRACE_OUT(("Moved to substate STATE_REG_PENDING_WSGROUP_CON"));

DC_EXIT_POINT:
    DebugExitDWORD(WBP_JoinCall, result);
    return(result);
}



//
// WBP_ContentsDelete
//
STDMETHODIMP_(UINT) WbClient::WBP_ContentsDelete(void)
{
    UINT result = 0;

    DebugEntry(WBP_ContentsDelete);

    //
    // Make sure that we have the Page Order Lock
    //
    QUIT_NOT_GOT_PAGE_ORDER_LOCK(result);

    //
    // Request the lock
    //
    wbContentsDelete(RESET_CHANGED_FLAG);

    //
    // Reset the flag indicating that the contents have changed
    //
    m_changed = FALSE;

DC_EXIT_POINT:
    DebugExitDWORD(WBP_ContentsDelete, result);
    return(result);
}



//
// WBP_ContentsLoad
//
STDMETHODIMP_(UINT) WbClient::WBP_ContentsLoad(LPCSTR pFileName)
{
    UINT        result = 0;
    HANDLE       hFile;

    DebugEntry(WBP_ContentsLoad);

    //
    // Check that we have the lock
    //
    QUIT_NOT_GOT_PAGE_ORDER_LOCK(result);

    //
    // Check the load state
    //
    if (m_loadState != LOAD_STATE_EMPTY)
    {
        result = WB_RC_ALREADY_LOADING;
        DC_QUIT;
    }

    //
    // Validate the file, and get a handle to it.
    // If there is an error, then no file handle is returned.
    //
    result = WBP_ValidateFile(pFileName, &hFile);
    if (result != 0)
    {
        ERROR_OUT(("Bad file header"));
        DC_QUIT;
    }

    //
    // Save the file handle for the rest of the load process
    //
    m_hLoadFile = hFile;

    //
    // We now need to make sure that the contents are deleted before we start
    // adding the new objects.
    //
    wbContentsDelete(DONT_RESET_CHANGED_FLAG);

    //
    // Update the load state to show that we are waiting for the contents
    // delete to complete.
    //
    m_loadState = LOAD_STATE_PENDING_CLEAR;
    TRACE_OUT(("Moved load state to LOAD_STATE_PENDING_CLEAR"));

DC_EXIT_POINT:
    DebugExitDWORD(WBP_ContentsLoad, result);
    return(result);
}



//
// WBP_ContentsSave
//
STDMETHODIMP_(UINT) WbClient::WBP_ContentsSave(LPCSTR pFileName)
{
    UINT            result = 0;
    UINT            index;
    HANDLE           hFile;
    PWB_PAGE_ORDER  pPageOrder = &(m_pageOrder);
    WB_FILE_HEADER  fileHeader;
    WB_END_OF_FILE  endOfFile;

    DebugEntry(WBP_ContentsSave);

    //
    // Open the file
    //
    hFile = CreateFile(pFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL, 0);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        result = WB_RC_CREATE_FAILED;
        ERROR_OUT(("Error creating file, win32 err=%d", GetLastError()));
        DC_QUIT;
    }

    //
    // Write the file header.  This contains the name of the function profile
    // that wrote the file and allows the file type to be tested when it is
    // loaded.
    //
    ZeroMemory(&fileHeader, sizeof(fileHeader));
    fileHeader.length = sizeof(fileHeader);
    fileHeader.type   = TYPE_FILE_HEADER;

    lstrcpy(fileHeader.functionProfile, WB_FP_NAME);

    result = wbObjectSave(hFile, (LPBYTE) &fileHeader, sizeof(fileHeader));
    if (result != 0)
    {
        ERROR_OUT(("Error writing end-of-page = %d", result));
        DC_QUIT;
    }

    //
    // Loop through the pages, saving each as we go
    //
    for (index = 0; index < pPageOrder->countPages; index++)
    {
        //
        // Save the page
        //
        result = wbPageSave((WB_PAGE_HANDLE)pPageOrder->pages[index], hFile);
        if (result != 0)
        {
            ERROR_OUT(("Error saving page = %d", result));
            DC_QUIT;
        }
    }

    //
    // If we have successfully written the contents, we write an end-of-page
    // marker to the file.
    //
    ZeroMemory(&endOfFile, sizeof(endOfFile));
    endOfFile.length = sizeof(endOfFile);
    endOfFile.type   = TYPE_END_OF_FILE;

    //
    // Write the end-of-file object
    //
    result = wbObjectSave(hFile, (LPBYTE) &endOfFile,  sizeof(endOfFile));
    if (result != 0)
    {
        ERROR_OUT(("Error writing end-of-page = %d", result));
        DC_QUIT;
    }

    //
    // Success!
    //
    TRACE_OUT(("Resetting changed flag"));
    m_changed = FALSE;

DC_EXIT_POINT:

    //
    // Close the file
    //
    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }

    //
    // If an error occurred in saving the contents to file, and the file was
    // opened, then delete it.
    //
    if (result != 0)
    {
        //
        // If the file was opened successfully, close it
        //
        if (hFile != INVALID_HANDLE_VALUE)
        {
            DeleteFile(pFileName);
        }
    }


    DebugExitDWORD(WBP_ContentsSave, result);
    return(result);
}




//
// WBP_ContentsChanged
//
STDMETHODIMP_(BOOL) WbClient::WBP_ContentsChanged(void)
{
    BOOL                changed = FALSE;
    UINT                result;
    WB_PAGE_HANDLE      hPage;
    POM_OBJECT          pObj;

    DebugEntry(WBP_ContentsChanged);

    TRACE_OUT(("changed %d", m_changed));

    if (m_changed)
    {
        //
        // The whiteboard may have been changed, but if the change was to
        // empty it then don't bother.  This is because we cannot detect that
        // the New operation was a local New or a remote clear and so we would
        // always prompt after New.  Assuming that the user never needs to
        // always prompt after New.  Assuming that the user will manually save
        // an workset he really wants to empty solves this problem.
        //

        //
        // Scan all objects looking to see what is there - get handle to first
        // page
        //
        result = wbPageHandle(WB_PAGE_HANDLE_NULL, PAGE_FIRST, &hPage);
        while (result == 0)
        {
            //
            // Get the handle of the first object in the page workset.
            //
            result = OM_ObjectH(m_pomClient, m_hWSGroup,
                (OM_WORKSET_ID)hPage, 0, &pObj, FIRST);
            if (result != OM_RC_NO_SUCH_OBJECT)
            {
                changed = TRUE;
                break;
            }

            //
            // Try the next page for an object
            //
            result = wbPageHandle(hPage, PAGE_AFTER, &hPage);
        }
    }

    DebugExitBOOL(WBP_ContentsChanged, changed);
    return(changed);
}




//
// WBP_ContentsLock
//
STDMETHODIMP_(void) WbClient::WBP_ContentsLock(void)
{
    UINT    result;

    DebugEntry(WBP_ContentsLock);

    //
    // Check that there is no lock currently
    //
    QUIT_LOCKED(result);
    QUIT_IF_CANCELLING_LOCK(result, WB_RC_BUSY);

    //
    // Request the lock
    //
    result = wbLock(WB_LOCK_TYPE_CONTENTS);
    if (result != 0)
    {
        WBP_PostEvent(0, WBP_EVENT_LOCK_FAILED, result, 0);
    }

DC_EXIT_POINT:
    DebugExitVOID(WBP_ContentsLock);
}



//
// WBP_PageOrderLock
//
STDMETHODIMP_(void) WbClient::WBP_PageOrderLock(void)
{
    UINT result = 0;

    DebugEntry(WBP_PageOrderLock);

    //
    // Check that there is no lock currently
    //
    QUIT_LOCKED(result);

    //
    // Check that we are not in the process of cancelling a lock request
    //
    QUIT_IF_CANCELLING_LOCK(result, WB_RC_BUSY);

    //
    // Request the lock
    //
    result = wbLock(WB_LOCK_TYPE_PAGE_ORDER);
    if (result != 0)
    {
        WBP_PostEvent(0, WBP_EVENT_LOCK_FAILED, result, 0);
    }

DC_EXIT_POINT:
    DebugExitVOID(WBP_PageOrderLock);
}



//
// WBP_Unlock
//
STDMETHODIMP_(void) WbClient::WBP_Unlock(void)
{
    UINT result = 0;

    DebugEntry(WBP_Unlock);

    //
    // If we are currently procesing a lock cancel request, leave the
    // function - it should unlock soon anyway.
    //
    QUIT_IF_CANCELLING_LOCK(result, 0);

    //
    // Check that we are currently processing a lock - the lock need not
    // necessarily have completed as we allow an application to call
    // WBP_Unlock any time after it has called WBP_Lock, effectively
    // cancelling a lock request.
    //
    QUIT_NOT_PROCESSING_LOCK(result);

    //
    // If we have completed the last lock request, simply do the unlock:
    //
    // The lock is not yet released, but will be when the
    // OM_OBJECT_DELETE_IND is received.
    //
    //
    if (m_lockState == LOCK_STATE_GOT_LOCK)
    {
        TRACE_OUT(("Unlock"));
        wbUnlock();
    }
    else
    {
        //
        // Otherwise we are part way through processing the last lock and need
        // to cancel the lock on the next OM/lock event.  e.g.  when we receive
        // the OM_WS_LOCK indication, we should abandon lock processing and
        // unlock the WS.
        //
        TRACE_OUT((
           "Part way through last lock set state to LOCK_STATE_CANCEL_LOCK"));
        m_lockState = LOCK_STATE_CANCEL_LOCK;
    }

DC_EXIT_POINT:
    DebugExitVOID(WBP_Unlock);
}



//
// WBP_LockStatus
//
STDMETHODIMP_(WB_LOCK_TYPE) WbClient::WBP_LockStatus(POM_OBJECT *ppObjPersonLock)
{
    DebugEntry(WBP_LockStatus);

    *ppObjPersonLock     = m_pObjPersonLock;

    DebugExitDWORD(WBP_LockStatus, m_lockType);
    return(m_lockType);
}




//
// WBP_ContentsCountPages
//
STDMETHODIMP_(UINT) WbClient::WBP_ContentsCountPages(void)
{
    UINT    countPages;

    DebugEntry(WBP_ContentsCountPages);

    countPages = (m_pageOrder).countPages;

    DebugExitDWORD(WBP_ContentsCountPages, countPages);
    return(countPages);
}



//
// WBP_PageClear
//
STDMETHODIMP_(UINT) WbClient::WBP_PageClear
(
    WB_PAGE_HANDLE  hPage
)
{
    UINT            result = 0;

    DebugEntry(WBP_PageClear);

    QUIT_CONTENTS_LOCKED(result);

    result = wbPageClear(hPage, RESET_CHANGED_FLAG);

DC_EXIT_POINT:
    DebugExitDWORD(WBP_PageClear, result);
    return(result);
}



//
// WBP_PageClearConfirm
//
STDMETHODIMP_(void) WbClient::WBP_PageClearConfirm
(
    WB_PAGE_HANDLE  hPage
)
{
    DebugEntry(WBP_PageClearConfirm);

    wbPageClearConfirm(hPage);

    DebugExitVOID(WBP_PageClearConfirm);
}




//
// WBP_PageAddBefore - See wb.h
//
STDMETHODIMP_(UINT) WbClient::WBP_PageAddBefore
(
    WB_PAGE_HANDLE  hRefPage,
    PWB_PAGE_HANDLE phPage
)
{
    UINT result = 0;

    DebugEntry(WBP_PageAddBefore);

    //
    // Make sure that we have the page order lock
    //
    QUIT_NOT_GOT_PAGE_ORDER_LOCK(result);

    //
    // Add a new page before the specified page
    //
    result = wbPageAdd(hRefPage, PAGE_BEFORE, phPage,
                     RESET_CHANGED_FLAG);

DC_EXIT_POINT:
    DebugExitDWORD(WBP_PageAddBefore, result);
    return(result);
}



//
// WBP_PageAddAfter - See wb.h
//
STDMETHODIMP_(UINT) WbClient::WBP_PageAddAfter
(
    WB_PAGE_HANDLE  hRefPage,
    PWB_PAGE_HANDLE phPage
)
{
    UINT result = 0;

    DebugEntry(WBP_PageAddAfter);

    //
    // Make sure that we have the Page Order Lock
    //
    QUIT_NOT_GOT_PAGE_ORDER_LOCK(result);

    //
    // Add a new page before the specified page
    //
    result = wbPageAdd(hRefPage, PAGE_AFTER, phPage,
                     RESET_CHANGED_FLAG);

DC_EXIT_POINT:
    DebugExitDWORD(WBP_PageAddAfter, result);
    return(result);
}




//
// WBP_PageHandle - See wb.h
//
STDMETHODIMP_(UINT) WbClient::WBP_PageHandle
(
    WB_PAGE_HANDLE  hRefPage,
    UINT            where,
    PWB_PAGE_HANDLE phPage
)
{
    UINT            result;

    DebugEntry(WBP_PageHandle);

    result = wbPageHandle(hRefPage, where, phPage);

    DebugExitDWORD(WBP_PageHandle, result);
    return(result);
}



//
// WBP_PageHandleFromNumber
//
STDMETHODIMP_(UINT) WbClient::WBP_PageHandleFromNumber
(
    UINT            pageNumber,
    PWB_PAGE_HANDLE phPage
)
{
    UINT            result;

    DebugEntry(WBP_PageHandleFromNumber);

    result = wbPageHandleFromNumber(pageNumber, phPage);

    DebugExitDWORD(WBP_PageHandleFromNumber, result);
    return(result);
}



//
// WBP_PageNumberFromHandle
//
STDMETHODIMP_(UINT) WbClient::WBP_PageNumberFromHandle
(
    WB_PAGE_HANDLE  hPage
)
{
    UINT            pageNumber = 0;

    DebugEntry(WBP_PageNumberFromHandle);

    if ((hPage < FIRST_PAGE_WORKSET) || (hPage > FIRST_PAGE_WORKSET + WB_MAX_PAGES - 1))
    {
        WARNING_OUT(("WB: Invalid hPage=%u", (UINT) hPage));
        DC_QUIT;
    }

    //
    // Validate the page handle given
    //
    if (GetPageState(hPage)->state != PAGE_IN_USE)
    {
        DC_QUIT;
    }

    pageNumber = wbPageOrderPageNumber(&(m_pageOrder), hPage);

DC_EXIT_POINT:
    DebugExitDWORD(WBP_PageNumberFromHandle, pageNumber);
    return(pageNumber);
}



//
// WBP_PageDelete - See wb.h
//
STDMETHODIMP_(UINT) WbClient::WBP_PageDelete
(
    WB_PAGE_HANDLE  hPage
)
{
    UINT            result = 0;
    PWB_PAGE_STATE  pPageState;

    DebugEntry(WBP_PageDelete);

    //
    // Make sure that we have the Page Order Lock
    //
    QUIT_NOT_GOT_PAGE_ORDER_LOCK(result);

    //
    // Delete the page
    //

    //
    // Check whether the page is already being deleted
    //
    pPageState = GetPageState(hPage);
    if (   (pPageState->state == PAGE_IN_USE)
        && (pPageState->subState == PAGE_STATE_EMPTY))
    {
        //
        // Set the page state to show that it is now in the delete process
        //
        pPageState->subState = PAGE_STATE_LOCAL_DELETE;
        TRACE_OUT(("Moved page %d substate to PAGE_STATE_LOCAL_DELETE",
             hPage));

        //
        // Update the page control object
        //
        if (wbWritePageControl(FALSE) != 0)
        {
            wbError();
            DC_QUIT;
        }
    }


DC_EXIT_POINT:
    DebugExitDWORD(WBP_PageDelete, result);
    return(result);
}




//
// WBP_PageDeleteConfirm - See wb.h
//
STDMETHODIMP_(void) WbClient::WBP_PageDeleteConfirm
(
    WB_PAGE_HANDLE hPage
)
{
    UINT            result = 0;
    PWB_PAGE_ORDER  pPageOrder;
    PWB_PAGE_STATE  pPageState;

    DebugEntry(WBP_PageDeleteConfirm);

    //
    // Validate the specified page
    //
    ASSERT(GetPageState(hPage)->state == PAGE_IN_USE);

    //
    // Delete the page
    //

    //
    // Check that the page specified is waiting for a delete confirm
    //
    pPageState = GetPageState(hPage);
    ASSERT(((pPageState->subState == PAGE_STATE_LOCAL_DELETE_CONFIRM) ||
            (pPageState->subState == PAGE_STATE_EXTERNAL_DELETE_CONFIRM)));

    //
    // Delete the page from the page order
    //
    pPageOrder = &(m_pageOrder);

    wbPageOrderPageDelete(pPageOrder, hPage);

    //
    // Clear the page (to free memory)
    //
    if (pPageState->subState == PAGE_STATE_LOCAL_DELETE_CONFIRM)
    {
        TRACE_OUT(("Local delete - clearing the page"));
        if (wbPageClear(hPage, RESET_CHANGED_FLAG) != 0)
        {
            ERROR_OUT(("Unable to clear page"));
            DC_QUIT;
        }
    }

    //
    // Update the page state to "not in use", with a substate of "ready" (we
    // do not close the associated workset.
    //
    pPageState->state = PAGE_NOT_IN_USE;
    pPageState->subState = PAGE_STATE_READY;
    TRACE_OUT(("Moved page %d state to PAGE_NOT_IN_USE", hPage));

    //
    // Continue updating the Page Order
    //
    wbProcessPageControlChanges();

    //
    // Check the load state to see whether we are waiting to load the
    // contents
    //
    if (m_loadState == LOAD_STATE_PENDING_DELETE)
    {
        //
        // We are waiting to load.  If there is now only one page available, we
        // are ready to load, otherwise we wait for the further page deletes to
        // happen.
        //
        if (m_pageOrder.countPages == 1)
        {
            //
            // Start the load proper
            //
            wbStartContentsLoad();
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(WBP_PageDeleteConfirm);
}




//
// WBP_PageMoveAfter
//
STDMETHODIMP_(UINT) WbClient::WBP_PageMove
(
    WB_PAGE_HANDLE  hRefPage,
    WB_PAGE_HANDLE  hPage,
    UINT            where
)
{
    UINT            result = 0;

    DebugEntry(WBP_PageMove);

    //
    // Make sure that we have the Page Order Lock
    //
    QUIT_NOT_GOT_PAGE_ORDER_LOCK(result);

    //
    // Validate the specified page handles
    //
    ASSERT(GetPageState(hPage)->state == PAGE_IN_USE);
    ASSERT(GetPageState(hRefPage)->state == PAGE_IN_USE);

    //
    // Move the page
    //
    result = wbPageMove(hRefPage, hPage, where);

DC_EXIT_POINT:
    DebugExitDWORD(WBP_PageMove, result);
    return(result);
}



//
// WBP_PageCountGraphics
//
STDMETHODIMP_(UINT) WbClient::WBP_PageCountGraphics
(
    WB_PAGE_HANDLE  hPage
)
{
    UINT    count;

    DebugEntry(WBP_PageCountGraphics);

    //
    // Count the number of graphics on the page
    //
    OM_WorksetCountObjects(m_pomClient, m_hWSGroup,
        (OM_WORKSET_ID)hPage, &count);

    DebugExitDWORD(WBP_PageCountGraphics, count);
    return(count);
}



//
// WBP_GraphicAllocate
//
STDMETHODIMP_(UINT) WbClient::WBP_GraphicAllocate
(
    WB_PAGE_HANDLE  hPage,
    UINT            length,
    PPWB_GRAPHIC    ppGraphic
)
{
    UINT            result = 0;
    POM_OBJECTDATA  pData;

    DebugEntry(WBP_GraphicAllocate);

    //
    // Check that the page handle is valid
    //
    ASSERT(GetPageState(hPage)->state == PAGE_IN_USE);

    //
    // Allocate a graphic object
    //
    result = OM_ObjectAlloc(m_pomClient, m_hWSGroup,
            (OM_WORKSET_ID)hPage, length, &pData);
    if (result != 0)
    {
        ERROR_OUT(("OM_ObjectAlloc = %d", result));
        DC_QUIT;
    }

    //
    // Set the length of the object
    //
    pData->length = length;

    //
    // Convert the ObMan pointer to a core pointer
    //
    *ppGraphic = GraphicPtrFromObjectData(pData);

    //
    // Initialize the graphic header
    //
    ZeroMemory(*ppGraphic, sizeof(WB_GRAPHIC));

DC_EXIT_POINT:
    DebugExitDWORD(WBP_GraphicAllocate, result);
    return(result);
}




//
// WBP_GraphicAddLast
//
STDMETHODIMP_(UINT) WbClient::WBP_GraphicAddLast
(
    WB_PAGE_HANDLE     hPage,
    PWB_GRAPHIC        pGraphic,
    PWB_GRAPHIC_HANDLE phGraphic
)
{
    UINT                result = 0;
    POM_OBJECTDATA      pData;
    PWB_PAGE_STATE      pPageState;

    DebugEntry(WBP_GraphicAddLast);

    //
    // Check whether another person has an active contents lock
    //
    QUIT_CONTENTS_LOCKED(result);

    //
    // Check that the page handle is valid
    //
    ASSERT(GetPageState(hPage)->state == PAGE_IN_USE);

    //
    // If the Client is asking for the lock, copy the local person ID into
    // the graphic object.
    //
    if (pGraphic->locked == WB_GRAPHIC_LOCK_LOCAL)
    {
        pGraphic->lockPersonID = m_personID;
    }

    //
    // Check whether the page has been deleted but not yet confirmed: in this
    // case return OK but do not add the object to the workset.
    //
    pPageState = GetPageState(hPage);
    if (   (pPageState->subState == PAGE_STATE_EXTERNAL_DELETE)
        || (pPageState->subState == PAGE_STATE_EXTERNAL_DELETE_CONFIRM))
    {
        TRACE_OUT(("Object add requested in externally deleted page - ignored"));
        *phGraphic = 0;
        DC_QUIT;
    }

    //
    // Add the graphic object to the page
    //
    pData = ObjectDataPtrFromGraphic(pGraphic);

    result = OM_ObjectAdd(m_pomClient,
                            m_hWSGroup,
                            (OM_WORKSET_ID)hPage,
                            &pData,
                            sizeof(WB_GRAPHIC),
                             phGraphic,
                            LAST);
    if (result != 0)
    {
        ERROR_OUT(("OM_ObjectAdd = %d", result));
        DC_QUIT;
    }

DC_EXIT_POINT:
    DebugExitDWORD(WBP_GraphicAddLast, result);
    return(result);
}




//
// WBP_GraphicUpdateRequest
//
STDMETHODIMP_(UINT) WbClient::WBP_GraphicUpdateRequest
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE   hGraphic,
    PWB_GRAPHIC         pGraphic
)
{
    UINT                result = 0;
    POM_OBJECTDATA      pData;
    PWB_PAGE_STATE      pPageState;

    DebugEntry(WBP_GraphicUpdateRequest);

    //
    // Check that the page handle is valid
    //
    ASSERT(GetPageState(hPage)->state == PAGE_IN_USE);

    //
    // Check whether another person has an active contents lock
    //
    QUIT_CONTENTS_LOCKED(result);

    //
    // Check whether another person has the graphic locked
    //
    QUIT_GRAPHIC_LOCKED(hPage, hGraphic, result);

    //
    // If the Client is asking for the lock, copy the local person ID into
    // the graphic object.
    //
    if (pGraphic->locked == WB_GRAPHIC_LOCK_LOCAL)
    {
        pGraphic->lockPersonID = m_personID;
    }

    //
    // Check whether the page has been deleted but not yet confirmed
    //
    pPageState = GetPageState(hPage);
    if (   (pPageState->subState == PAGE_STATE_EXTERNAL_DELETE)
        || (pPageState->subState == PAGE_STATE_EXTERNAL_DELETE_CONFIRM))
    {
        TRACE_OUT(("Object update requested in externally deleted page - ignored"));
        DC_QUIT;
    }

    //
    // Update the object
    //
    pData = ObjectDataPtrFromGraphic(pGraphic);

    result = OM_ObjectUpdate(m_pomClient,
                           m_hWSGroup,
                           (OM_WORKSET_ID)hPage,
                           hGraphic,
                           &pData);

    //
    // Dont worry too much if the update fails because the object has been
    // deleted, just trace an alert and return OK - the front end will be
    // told that the object has gone later.
    //
    if (result != 0)
    {
        if (result == OM_RC_OBJECT_DELETED)
        {
            TRACE_OUT(("Update failed because object has been deleted"));
            result = 0;
            DC_QUIT;
        }

        ERROR_OUT(("OM_ObjectUpdate = %d", result));
        DC_QUIT;
    }

    //
    // Note that the object has not yet been updated.  An
    // OM_OBJECT_UPDATE_IND event will be generated.
    //

DC_EXIT_POINT:
    DebugExitDWORD(WBP_GraphicUpdateRequest, result);
    return(result);
}




//
// WBP_GraphicUpdateConfirm
//
STDMETHODIMP_(void) WbClient::WBP_GraphicUpdateConfirm
(
    WB_PAGE_HANDLE    hPage,
    WB_GRAPHIC_HANDLE hGraphic
)
{
    DebugEntry(WBP_GraphicUpdateConfirm);

    //
    // Check that the page handle is valid
    //
    ASSERT(GetPageState(hPage)->state == PAGE_IN_USE);

    //
    // Confirm the update to ObMan
    //
    OM_ObjectUpdateConfirm(m_pomClient,
                         m_hWSGroup,
                         (OM_WORKSET_ID)hPage,
                         hGraphic);


    DebugExitVOID(WBP_GraphicUpdateConfirm);
}




//
// WBP_GraphicReplaceRequest
//
STDMETHODIMP_(UINT) WbClient::WBP_GraphicReplaceRequest
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE   hGraphic,
    PWB_GRAPHIC         pGraphic
)
{
    UINT                result = 0;
    POM_OBJECTDATA      pData;
    POM_OBJECT          pObjPersonLock;
    PWB_PAGE_STATE      pPageState;

    DebugEntry(WBP_GraphicReplaceRequest);

    //
    // Check that the page handle is valid
    //
    ASSERT(GetPageState(hPage)->state == PAGE_IN_USE);

    //
    // We allow the replace to go ahead if:
    //   -  The object is locked by the local user
    //   -  The object is not locked and the contents are not locked by
    //      a remote user
    //
    // Note that this allow the replace if the contents are locked by another
    // user, but the local user has the object locked.
    //
    if (wbGraphicLocked(hPage, hGraphic, &pObjPersonLock))
    {
        if (pObjPersonLock != m_pObjLocal)
        {
            TRACE_OUT(("Graphic is locked by remote client"));
            result = WB_RC_GRAPHIC_LOCKED;
            DC_QUIT;
        }
    }
    else
    {
        QUIT_CONTENTS_LOCKED(result);
    }

    //
    // If the Client is asking for the lock, copy the local person ID into
    // the graphic object.
    //
    if (pGraphic->locked == WB_GRAPHIC_LOCK_LOCAL)
    {
        pGraphic->lockPersonID = m_personID;
    }

    //
    // Check whether the page has been deleted but not yet confirmed
    //
    pPageState = GetPageState(hPage);
    if (   (pPageState->subState == PAGE_STATE_EXTERNAL_DELETE)
        || (pPageState->subState == PAGE_STATE_EXTERNAL_DELETE_CONFIRM))
    {
        TRACE_OUT(("Object replace requested in externally deleted page - ignored"));
        DC_QUIT;
    }

    //
    // Replace the object
    //
    pData = ObjectDataPtrFromGraphic(pGraphic);

    result = OM_ObjectReplace(m_pomClient,
                            m_hWSGroup,
                            (OM_WORKSET_ID)hPage,
                            hGraphic,
                            &pData);
    if (result != 0)
    {
        ERROR_OUT(("OM_ObjectReplace = %d", result));
        DC_QUIT;
    }

    //
    // Note that the object has not yet been updated.  An
    // OM_OBJECT_REPLACE_IND event will be generated.
    //

DC_EXIT_POINT:
    DebugExitDWORD(WBP_GraphicReplaceRequest, result);
    return(result);
}




//
// WBP_GraphicUpdateConfirm
//
STDMETHODIMP_(void) WbClient::WBP_GraphicReplaceConfirm
(
    WB_PAGE_HANDLE    hPage,
    WB_GRAPHIC_HANDLE hGraphic
)
{
    DebugEntry(WBP_GraphicReplaceConfirm);



    //
    // Check that the page handle is valid
    //
    ASSERT(GetPageState(hPage)->state == PAGE_IN_USE);

    //
    // Confirm the update to ObMan
    //
    OM_ObjectReplaceConfirm(m_pomClient,
                          m_hWSGroup,
                          (OM_WORKSET_ID)hPage,
                          hGraphic);

    DebugExitVOID(WBP_GraphicReplaceConfirm);
}



//
// WBP_GraphicDeleteRequest
//
STDMETHODIMP_(UINT) WbClient::WBP_GraphicDeleteRequest
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE   hGraphic
)
{
    UINT                result = 0;

    DebugEntry(WBP_GraphicDeleteRequest);



    //
    // Check that the page handle is valid
    //
    ASSERT(GetPageState(hPage)->state == PAGE_IN_USE);

    //
    // Check whether another person has an active contents lock
    //
    QUIT_CONTENTS_LOCKED(result);

    //
    // Check whether another person has the graphic locked
    //
    QUIT_GRAPHIC_LOCKED(hPage, hGraphic, result);

    //
    // Delete the object
    //
    result = OM_ObjectDelete(m_pomClient,
                           m_hWSGroup,
                           (OM_WORKSET_ID)hPage,
                           hGraphic);
    if (result != 0)
    {
        ERROR_OUT(("OM_ObjectDelete = %d", result));
        DC_QUIT;
    }

    //
    // Note that at this point the object is not yet deleted.  An
    // OM_OBJECT_DELETE_IND event is raised and processed by the Whiteboard
    // Core event handler.  A WB_EVENT_GRAPHIC_DELETED is then posted to the
    // client.  The client then calls WBP_GraphicDeleteConfirm to complete
    // the deletion.
    //

DC_EXIT_POINT:
    DebugExitDWORD(WBP_GraphicDeleteRequest, result);
    return(result);
}




//
// WBP_GraphicDeleteConfirm
//
STDMETHODIMP_(void) WbClient::WBP_GraphicDeleteConfirm
(
    WB_PAGE_HANDLE    hPage,
    WB_GRAPHIC_HANDLE hGraphic
)
{
    DebugEntry(WBP_GraphicDeleteConfirm);



    //
    // Check that the page handle is valid
    //
    ASSERT(GetPageState(hPage)->state == PAGE_IN_USE);

    //
    // Confirm the delete
    //
    OM_ObjectDeleteConfirm(m_pomClient,
                         m_hWSGroup,
                         (OM_WORKSET_ID)hPage,
                          hGraphic);


    DebugExitVOID(WBP_GraphicDeleteConfirm);
}




//
// WBP_GraphicUnlock
//
STDMETHODIMP_(void) WbClient::WBP_GraphicUnlock
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE   hGraphic
)
{
    UINT                rc;
    POM_OBJECTDATA      pData;
    PWB_PAGE_STATE      pPageState;
    PWB_GRAPHIC         pGraphic = NULL;
    PWB_GRAPHIC         pNewGraphic = NULL;

    DebugEntry(WBP_GraphicUnlock);

    //
    // Check that the page handle is valid
    //
    ASSERT(GetPageState(hPage)->state == PAGE_IN_USE);

    //
    // Check whether the page has been deleted but not yet confirmed
    //
    pPageState = GetPageState(hPage);
    if (   (pPageState->subState == PAGE_STATE_EXTERNAL_DELETE)
       || (pPageState->subState == PAGE_STATE_EXTERNAL_DELETE_CONFIRM))
    {
        TRACE_OUT(("Object update requested in externally deleted page - ignored"));
        DC_QUIT;
    }

    //
    // Read the object from ObMan
    //
    if (WBP_GraphicGet(hPage, hGraphic, &pGraphic) != 0)
    {
        TRACE_OUT(("Could not get graphic - leaving function"));
        DC_QUIT;
    }

    //
    // Check the local client has the graphic locked
    //
    QUIT_GRAPHIC_NOT_LOCKED(pGraphic, rc);

    //
    // Allocate a new graphic, copied from the existing one, and clear the
    // lock field.
    //
    if (WBP_GraphicAllocate(hPage, sizeof(WB_GRAPHIC),
                           &pNewGraphic) != 0)
    {
        ERROR_OUT(("Could not allocate memory for update object"));
        DC_QUIT;
    }

    memcpy(pNewGraphic, pGraphic, sizeof(WB_GRAPHIC));
    pNewGraphic->locked = WB_GRAPHIC_LOCK_NONE;

    //
    // Unlock & update the object
    //
    pData = ObjectDataPtrFromGraphic(pNewGraphic);
    pData->length = sizeof(WB_GRAPHIC);

    rc = OM_ObjectUpdate(m_pomClient,
                       m_hWSGroup,
                       (OM_WORKSET_ID)hPage,
                        hGraphic,
                       &pData);

    //
    // Dont worry too much if the update fails because the object has been
    // deleted, just trace an alert and return OK - the front end will be
    // told that the object has gone later.
    //
    if (rc != 0)
    {
        if (rc == OM_RC_OBJECT_DELETED)
        {
            TRACE_OUT(("Update failed because object has been deleted"));
        }
        else
        {
            ERROR_OUT(("OM_ObjectUpdate = %d", rc));
        }
        DC_QUIT;
    }

    //
    // Note that the object has not yet been updated.  An
    // OM_OBJECT_UPDATE_IND event will be generated.
    //

DC_EXIT_POINT:
    //
    // If we read the graphic successfully, release it now
    //
    if (pGraphic != NULL)
    {
        WBP_GraphicRelease(hPage, hGraphic, pGraphic);
    }

    DebugExitVOID(WBP_GraphicUnlock);
}



//
// WBP_GraphicMove
//
STDMETHODIMP_(UINT) WbClient::WBP_GraphicMove
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE   hGraphic,
    UINT                where
)
{
    UINT                result = 0;
    PWB_PAGE_STATE      pPageState;

    DebugEntry(WBP_GraphicMove);

    //
    // Check that the page handle is valid
    //
    ASSERT(GetPageState(hPage)->state == PAGE_IN_USE);

    //
    // Check whether another person has an active contents lock
    //
    QUIT_CONTENTS_LOCKED(result);

    //
    // Check whether the page has been deleted but not yet confirmed
    //
    pPageState = GetPageState(hPage);
    if (   (pPageState->subState == PAGE_STATE_EXTERNAL_DELETE)
        || (pPageState->subState == PAGE_STATE_EXTERNAL_DELETE_CONFIRM))
    {
        TRACE_OUT(("Object moved in externally deleted page - ignored"));
        DC_QUIT;
    }

    //
    // Do the move
    //
    result = OM_ObjectMove(m_pomClient,
                              m_hWSGroup,
                              (OM_WORKSET_ID)hPage,
                               hGraphic,
                            (OM_POSITION)where);
    if (result != 0)
    {
        ERROR_OUT(("OM_ObjectMove = %d", result));
        DC_QUIT;
    }

DC_EXIT_POINT:
    DebugExitDWORD(WBP_GraphicMove, result);
    return(result);
}



//
// WBP_GraphicSelectLast
//
STDMETHODIMP_(UINT) WbClient::WBP_GraphicSelect
(
    WB_PAGE_HANDLE      hPage,
    POINT               point,
    WB_GRAPHIC_HANDLE   hRefGraphic,
    UINT                where,
    PWB_GRAPHIC_HANDLE  phGraphic
)
{
    UINT                result = 0;

    DebugEntry(WBP_GraphicSelect);

    //
    // Check that the page handle is valid
    //
    ASSERT(GetPageState(hPage)->state == PAGE_IN_USE);

    //
    // Get the handle of the last object in the workset
    //
    result = OM_ObjectH(m_pomClient,
                          m_hWSGroup,
                          (OM_WORKSET_ID)hPage,
                          hRefGraphic,
                           &hRefGraphic,
                          (OM_POSITION)where);

    if (result == OM_RC_NO_SUCH_OBJECT)
    {
        result = WB_RC_NO_SUCH_GRAPHIC;
        DC_QUIT;
    }

    if (result != 0)
    {
        ERROR_OUT(("OM_ObjectH = %d", result));
        DC_QUIT;
    }

    //
    // Get the previous matching graphic - this function starts from the
    // object in hRefGraphic and works back.
    //
    result = wbGraphicSelectPrevious(hPage,
                                   &point,
                                   hRefGraphic,
                                   phGraphic);


DC_EXIT_POINT:
    DebugExitDWORD(WBP_GraphicSelect, result);
    return(result);
}



//
// WBP_GraphicGet
//
STDMETHODIMP_(UINT) WbClient::WBP_GraphicGet
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE   hGraphic,
    PPWB_GRAPHIC        ppGraphic
)
{
    UINT                result = 0;
    UINT                rc;
    POM_OBJECTDATA      pData;
    PWB_GRAPHIC         pGraphic;
    POM_OBJECT          pObjPersonLock;

    DebugEntry(WBP_GraphicGet);

    //
    // Check that the page handle is valid
    //
    ASSERT(GetPageState(hPage)->state == PAGE_IN_USE);

    //
    // Read the object.
    //
    result = OM_ObjectRead(m_pomClient,
                         m_hWSGroup,
                         (OM_WORKSET_ID)hPage,
                          hGraphic,
                         &pData);
    if (result != 0)
    {
        ERROR_OUT(("OM_ObjectRead = %d", result));
        DC_QUIT;
    }

    //
    // Convert the ObMan pointer to a core pointer
    //
    pGraphic = GraphicPtrFromObjectData(pData);

    //
    // If the graphic object indicates that it is locked - verify that the
    // locking person is still in the call.
    //
    if (pGraphic->locked != WB_GRAPHIC_LOCK_NONE)
    {
        TRACE_OUT(("Graphic has lock flag set"));

        //
        // Convert the lock person ID in the graphic to a person handle
        //
        rc = OM_ObjectIDToPtr(m_pomClient,
                             m_hWSGroup,
                             USER_INFORMATION_WORKSET,
                             pGraphic->lockPersonID,
                             &pObjPersonLock);

        if (rc == OM_RC_BAD_OBJECT_ID)
        {
            //
            // The locking person is no longer in the call - reset the lock flag
            // in the graphic.  This tells the client that the graphic can be
            // changed.
            //
            TRACE_OUT(("Lock person has left call - resetting lock flag"));
            pGraphic->locked = WB_GRAPHIC_LOCK_NONE;
        }
        else
        {
            if (rc == 0)
            {
                //
                // The object is locked - check whether the lock belongs to the
                // local person or a remote person.
                //
                if (pObjPersonLock == m_pObjLocal)
                {
                    //
                    // Change the lock type to local to tell the client that they
                    // have the lock on this object.
                    //
                    TRACE_OUT(("Lock belongs to local person"));
                    pGraphic->locked = WB_GRAPHIC_LOCK_LOCAL;
                }
                else
                {
                    //
                    // Change the lock type to remote to tell the client that another
                    // person has the lock on this object.
                    //
                    TRACE_OUT(("Lock belongs to remote person"));
                    pGraphic->locked = WB_GRAPHIC_LOCK_REMOTE;
                }
            }
        }
    }

    //
    // Return the pointer to the graphic data
    //
    *ppGraphic = pGraphic;


DC_EXIT_POINT:
    DebugExitDWORD(WBP_GraphicGet, result);
    return(result);
}



//
// WBP_GraphicRelease
//
STDMETHODIMP_(void) WbClient::WBP_GraphicRelease
(
    WB_PAGE_HANDLE     hPage,
    WB_GRAPHIC_HANDLE  hGraphic,
    PWB_GRAPHIC        pGraphic
)
{
    POM_OBJECTDATA pData;

    DebugEntry(WBP_GraphicRelease);

    //
    // Check that the page handle is valid
    //
    ASSERT(GetPageState(hPage)->state == PAGE_IN_USE);

    //
    // Release the object.
    //
    pData = ObjectDataPtrFromGraphic(pGraphic);
    OM_ObjectRelease(m_pomClient,
                   m_hWSGroup,
                   (OM_WORKSET_ID)hPage,
                    hGraphic,
                   &pData);


    DebugExitVOID(WBP_GraphicRelease);
}



//
// WBP_GraphicHandle
//
STDMETHODIMP_(UINT) WbClient::WBP_GraphicHandle
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE   hRefGraphic,
    UINT                where,
    PWB_GRAPHIC_HANDLE  phGraphic
)
{
    UINT                result;

    DebugEntry(WBP_GraphicHandle);



    //
    // Check that the page handle is valid
    //
    ASSERT(GetPageState(hPage)->state == PAGE_IN_USE);

    //
    // Get the handle of the first object in the page workset.
    //
    result = OM_ObjectH(m_pomClient,
                           m_hWSGroup,
                           (OM_WORKSET_ID)hPage,
                           hRefGraphic,
                            phGraphic,
                           (OM_POSITION)where);
    if (result == OM_RC_NO_SUCH_OBJECT)
    {
        TRACE_OUT(("No objects there"));
        result = WB_RC_NO_SUCH_GRAPHIC;
    }


    DebugExitDWORD(WBP_GraphicHandle, result);
    return(result);
}




//
// WBP_PersonHandleFirst
//
STDMETHODIMP_(void) WbClient::WBP_PersonHandleFirst
(
    POM_OBJECT *     ppObjPerson
)
{
    DebugEntry(WBP_PersonHandleFirst);

    OM_ObjectH(m_pomClient, m_hWSGroup,
        USER_INFORMATION_WORKSET, 0, ppObjPerson, FIRST);

    DebugExitVOID(WBP_PersonHandleFirst);
}




//
// WBP_PersonHandleNext
//
STDMETHODIMP_(UINT) WbClient::WBP_PersonHandleNext
(
    POM_OBJECT      pObjPerson,
    POM_OBJECT *    ppObjPersonNext
)
{
    UINT            rc;

    DebugEntry(WBP_PersonHandleNext);

    //
    // Get the handle of the next object in the user information workset.
    //
    rc = OM_ObjectH(m_pomClient,
                      m_hWSGroup,
                      USER_INFORMATION_WORKSET,
                      pObjPerson,
                    ppObjPersonNext,
                    AFTER);

    if (rc == OM_RC_NO_SUCH_OBJECT)
    {
        rc = WB_RC_NO_SUCH_PERSON;
    }
    else if (rc != 0)
    {
        ERROR_OUT(("OM_ObjectNextH = %d", rc));
    }


    DebugExitDWORD(WBP_PersonHandleNext, rc);
    return(rc);
}



//
// WBP_PersonHandleLocal
//
STDMETHODIMP_(void) WbClient::WBP_PersonHandleLocal
(
    POM_OBJECT *     ppObjPerson
)
{
    DebugEntry(WBP_PersonHandleLocal);

    *ppObjPerson = m_pObjLocal;

    DebugExitVOID(WBP_PersonHandleLocal);
}



//
// WBP_PersonCountInCall
//
STDMETHODIMP_(UINT) WbClient::WBP_PersonCountInCall(void)
{
    UINT        count;
    POM_OBJECT  pObj;

    DebugEntry(WBP_PersonCountInCall);

    //
    // Get the count:
    //
    pObj = NULL;
    WBP_PersonHandleFirst(&pObj);
    for (count = 1; ; count++)
    {
        if (WBP_PersonHandleNext(pObj, &pObj) == WB_RC_NO_SUCH_PERSON)
        {
            break;
        }
    }

    DebugExitDWORD(WBP_PersonCountInCall, count);
    return(count);
}




//
// WBP_GetPersonData
//
STDMETHODIMP_(UINT) WbClient::WBP_GetPersonData
(
    POM_OBJECT      pObjPerson,
    PWB_PERSON      pPerson
)
{
    UINT            rc;

    DebugEntry(WBP_GetPersonData);

    ASSERT(!IsBadWritePtr(pPerson, sizeof(WB_PERSON)));

    //
    // Get the object.
    //
    rc = wbPersonGet(pObjPerson, pPerson);

    DebugExitDWORD(WBP_GetPersonData, rc);
    return(rc);
}



//
// WBP_SetLocalPersonData
//
STDMETHODIMP_(UINT) WbClient::WBP_SetLocalPersonData(PWB_PERSON  pPerson)
{
    UINT        rc;
    POM_OBJECTDATA  pUserObject;

    DebugEntry(WBP_SetPersonData);

    ASSERT(!IsBadReadPtr(pPerson, sizeof(WB_PERSON)));

    //
    // Allocate a user object
    //
    rc = OM_ObjectAlloc(m_pomClient,
                          m_hWSGroup,
                          USER_INFORMATION_WORKSET,
                          sizeof(WB_PERSON),
                          &pUserObject);
    if (rc != 0)
    {
        ERROR_OUT(("OM_ObjectAlloc = %d", rc));
        DC_QUIT;
    }

    //
    // Set the length of the object
    //
    pUserObject->length = sizeof(WB_PERSON);

    //
    // Copy the user information into the ObMan object
    //
    memcpy(pUserObject->data, pPerson, sizeof(WB_PERSON));

    //
    // Replace the user object
    //
    rc = OM_ObjectReplace(m_pomClient,
                           m_hWSGroup,
                           USER_INFORMATION_WORKSET,
                           m_pObjLocal,
                           &pUserObject);
    if (rc != 0)
    {
        ERROR_OUT(("OM_ObjectReplace"));

        //
        // Discard the object
        //
        OM_ObjectDiscard(m_pomClient,
                     m_hWSGroup,
                     USER_INFORMATION_WORKSET,
                     &pUserObject);

        DC_QUIT;
    }

DC_EXIT_POINT:
    //
    // Note that the object has not yet been updated.  An
    // OM_OBJECT_UPDATE_IND event will be generated.
    //
    DebugExitDWORD(WBP_SetPersonData, rc);
    return(rc);
}



//
// WBP_PersonUpdateConfirm
//
STDMETHODIMP_(void) WbClient::WBP_PersonUpdateConfirm
(
    POM_OBJECT   pObjPerson
)
{
    DebugEntry(WBP_PersonUpdateConfirm);

    //
    // Confirm the update to ObMan
    //
    OM_ObjectUpdateConfirm(m_pomClient,
                         m_hWSGroup,
                         USER_INFORMATION_WORKSET,
                         pObjPerson);

    DebugExitVOID(WBP_PersonUpdateConfirm);
}




//
// WBP_PersonReplaceConfirm
//
STDMETHODIMP_(void) WbClient::WBP_PersonReplaceConfirm
(
    POM_OBJECT   pObjPerson
)
{
    DebugEntry(WBP_PersonReplaceConfirm);

    //
    // Confirm the replace to ObMan
    //
    OM_ObjectReplaceConfirm(m_pomClient,
                         m_hWSGroup,
                         USER_INFORMATION_WORKSET,
                         pObjPerson);

    DebugExitVOID(WBP_PersonReplaceConfirm);
}



//
// WBP_PersonLeftConfirm
//
STDMETHODIMP_(void) WbClient::WBP_PersonLeftConfirm
(
    POM_OBJECT      pObjPerson
)
{
    DebugEntry(WBP_PersonLeftConfirm);

    //
    // Confirm the update to ObMan
    //
    OM_ObjectDeleteConfirm(m_pomClient,
                         m_hWSGroup,
                         USER_INFORMATION_WORKSET,
                         pObjPerson);

    DebugExitVOID(WBP_PersonLeftConfirm);
}



//
// WBP_SyncPositionGet
//
STDMETHODIMP_(UINT) WbClient::WBP_SyncPositionGet
(
    PWB_SYNC            pSync
)
{
    UINT                result;
    POM_OBJECTDATA      pSyncObject = NULL;
    PWB_SYNC_CONTROL    pSyncControl = NULL;

    DebugEntry(WBP_SyncPositionGet);


    ASSERT(!IsBadWritePtr(pSync, sizeof(WB_SYNC)));

    //
    // Read the Sync Control object
    //
    result = OM_ObjectRead(m_pomClient,
                         m_hWSGroup,
                         SYNC_CONTROL_WORKSET,
                         m_pObjSyncControl,
                         &pSyncObject);
    if (result != 0)
    {
        ERROR_OUT(("Error reading Sync Control Object = %d", result));
        DC_QUIT;
    }

    pSyncControl = (PWB_SYNC_CONTROL) pSyncObject->data;

    //
    // Copy the Sync Person details to the result field
    // NOTE:
    // LiveLan sends a larger object, we need to ignore the stuff past the
    // end.
    //
    if (pSyncControl->sync.length != sizeof(WB_SYNC))
    {
        WARNING_OUT(("WBP_SyncPositionGet (interop): Remote created WB_SYNC of size %d, we expected size %d",
            pSyncControl->sync.length, sizeof(WB_SYNC)));
    }
    memcpy(pSync, &pSyncControl->sync, min(sizeof(WB_SYNC), pSyncControl->sync.length));

    //
    // Release the Sync Control Object
    //
    OM_ObjectRelease(m_pomClient,
                   m_hWSGroup,
                   SYNC_CONTROL_WORKSET,
                   m_pObjSyncControl,
                   &pSyncObject);

DC_EXIT_POINT:
    DebugExitDWORD(WBP_SyncPositionGet, result);
    return(result);
}



//
// WBP_SyncPositionUpdate
//
STDMETHODIMP_(UINT) WbClient::WBP_SyncPositionUpdate
(
    PWB_SYNC        pSync
)
{
    UINT            result;
    POM_OBJECTDATA      pSyncObject = NULL;
    PWB_SYNC_CONTROL pSyncControl = NULL;

    DebugEntry(WBP_SyncPositionUpdate);

    ASSERT(!IsBadReadPtr(pSync, sizeof(WB_SYNC)));

    //
    // Write the new sync control object (do not create it)
    //
    result = wbWriteSyncControl(pSync, FALSE);

    DebugExitDWORD(WBP_SyncPositionUpdate, result);
    return(result);
}



//
// WBP_CancelLoad
//
STDMETHODIMP_(UINT) WbClient::WBP_CancelLoad(void)
{
    UINT        result = 0;

    DebugEntry(WBP_CancelLoad);

    //
    // Check a load is in progress
    //
    if (m_loadState == LOAD_STATE_EMPTY)
    {
        TRACE_OUT(("request to cancel load, but there is no load in progress"));
        result = WB_RC_NOT_LOADING;
        DC_QUIT;
    }

    TRACE_OUT(("Cancelling load in progress"));

    //
    // Close the file
    //
    if (m_hLoadFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(m_hLoadFile);
        m_hLoadFile = INVALID_HANDLE_VALUE;
    }

    //
    // reset the load state to show we're no longer loading.
    //
    m_loadState = LOAD_STATE_EMPTY;

DC_EXIT_POINT:
    DebugExitDWORD(WBP_CancelLoad, result);
    return(result);
}



//
//
// Name:    WBP_ValidateFile
//
// Purpose: Validate that a passed filename holds a valid whiteboard file
//
// Returns: 0 if successful
//          !0 if an error
//
//
STDMETHODIMP_(UINT) WbClient::WBP_ValidateFile
(
    LPCSTR          pFileName,
    HANDLE *        phFile
)
{
    UINT            result = 0;
    HANDLE          hFile;
    WB_FILE_HEADER  fileHeader;
    UINT            length;
    ULONG           cbSizeRead;
    BOOL            fileOpen = FALSE;

    DebugEntry(WBP_ValidateFile);

    //
    // Open the file
    //
    hFile = CreateFile(pFileName, GENERIC_READ, 0, NULL,
                            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        WARNING_OUT(("Error opening file, win32 err=%d", GetLastError()));
        result = WB_RC_CREATE_FAILED;
        DC_QUIT;
    }

    //
    // Show that we have opened the file successfully
    //
    fileOpen = TRUE;

    //
    // Read the file header length
    //
    if (! ReadFile(hFile, (void *) &length, sizeof(length), &cbSizeRead, NULL))
    {
        WARNING_OUT(("Error reading file header length, win32 err=%d", GetLastError()));
        result = WB_RC_READ_FAILED;
        DC_QUIT;
    }
    ASSERT(cbSizeRead == sizeof(length));

    if (length != sizeof(fileHeader))
    {
        WARNING_OUT(("Bad file header"));
        result = WB_RC_BAD_FILE_FORMAT;
        DC_QUIT;
    }

    //
    // Read the file header
    //
    if (! ReadFile(hFile, (void *) &fileHeader, sizeof(fileHeader), &cbSizeRead, NULL))
    {
        WARNING_OUT(("Error reading file header, win32 err=%d", GetLastError()));
        result = WB_RC_READ_FAILED;
        DC_QUIT;
    }

    if (cbSizeRead != sizeof(fileHeader))
    {
        WARNING_OUT(("Could not read file header"));
        result = WB_RC_BAD_FILE_FORMAT;
        DC_QUIT;
    }

    //
    // Validate the file header
    //
    if (   (fileHeader.type != TYPE_FILE_HEADER)
        || lstrcmp(fileHeader.functionProfile, WB_FP_NAME))
    {
        WARNING_OUT(("Bad function profile in file header"));
        result = WB_RC_BAD_FILE_FORMAT;
        DC_QUIT;
    }


DC_EXIT_POINT:

    //
    // Return the handle, if the user needs it.
    //
    if ( (result == 0) && (phFile != NULL))
    {
        TRACE_OUT(("return file handle"));
        *phFile = hFile;
    }

    //
    // Close the file if there has been an error or the caller simply
    // doesnt want the file handle.
    //
    if ( (fileOpen) &&
         ((phFile == NULL) || (result != 0)) )
    {
        CloseHandle(hFile);
    }

    DebugExitDWORD(WBP_ValidateFile, result);
    return(result);
}




//
//
// Name:    wbGraphicLocked
//
// Purpose: Test whether a client has a lock on the specified graphic, and
//          if so, return the person handle of the client holding the lock.
//
// Returns: TRUE  if a client has a lock
//          FALSE otherwise
//
//
BOOL WbClient::wbGraphicLocked
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE   hGraphic,
    POM_OBJECT *     ppObjLock
)
{
    BOOL            result = FALSE;
    UINT            rc;
    PWB_GRAPHIC     pGraphic = NULL;

    DebugEntry(wbGraphicLocked);

    //
    // Read the object
    //
    if (WBP_GraphicGet(hPage, hGraphic, &pGraphic) != 0)
    {
        DC_QUIT;
    }

    //
    // Look at its lock details
    //
    if (pGraphic->locked != WB_GRAPHIC_LOCK_NONE)
    {
        //
        // The lock flag in the graphic is set
        //

        //
        // Convert the lock user ID in the graphic to a handle
        //
        rc = OM_ObjectIDToPtr(m_pomClient,
                                 m_hWSGroup,
                                 USER_INFORMATION_WORKSET,
                                 pGraphic->lockPersonID,
                                 ppObjLock);

        if (rc == 0)
        {

            TRACE_OUT(("Graphic is locked"));
            result = TRUE;
            DC_QUIT;
        }

        if (rc != OM_RC_BAD_OBJECT_ID)
        {
            //
            // An error occurred in converting the objectID
            //
            TRACE_OUT(("Error converting object ID to handle"));
            DC_QUIT;
        }
    }

    //
    // The object is not locked (or the lock user has left the call)
    //
    TRACE_OUT(("Graphic is not locked"));


DC_EXIT_POINT:
    //
    // If the graphic is still held by us, release it
    //
    if (pGraphic != NULL)
    {
        WBP_GraphicRelease(hPage, hGraphic, pGraphic);
    }

    DebugExitBOOL(wbGraphicLocked, result);
    return(result);
}




//
//
// Name:    wbAddLocalUserObject
//
// Purpose: Add an object to the user information workset for the local
//          user.
//
// Returns: Error code
//
//
UINT WbClient::wbAddLocalUserObject(void)
{
    UINT            rc;
    POM_OBJECTDATA     pData;
    PWB_PERSON      pUser;
    CM_STATUS       cmStatus;

    DebugEntry(wbAddLocalUserObject);

    TRACE_OUT(("Adding the necessary control objects"));

    //
    // Build a user object for this user and write it to the User Information
    // Workset.
    //
    rc = OM_ObjectAlloc(m_pomClient,
                      m_hWSGroup,
                      USER_INFORMATION_WORKSET,
                      sizeof(WB_PERSON),
                      &pData);
    if (rc != 0)
    {
        ERROR_OUT(("Error allocating object = %d", rc));
        DC_QUIT;
    }

    pData->length = sizeof(WB_PERSON);
    pUser = (PWB_PERSON) (pData->data);

    //
    // Initialize the contents of the user object for this user
    //
    TRACE_OUT(("Initialising user contents"));

    ZeroMemory(pUser, sizeof(WB_PERSON));

    pUser->currentPage        = FIRST_PAGE_WORKSET; // lonchanc: it was 1.
    pUser->synced             = FALSE;
    pUser->pointerActive      = FALSE;
    pUser->pointerPage        = FIRST_PAGE_WORKSET; // lonchanc: it was 1.
    pUser->colorId            = (TSHR_UINT16)wbSelectPersonColor();

    //
    // Fill in the Call Manager personID if we are in a call.
    //
    if (CMS_GetStatus(&cmStatus))
    {
        TRACE_OUT(("CMG personID %u", cmStatus.localHandle));
        pUser->cmgPersonID = cmStatus.localHandle;
    }
    else
    {
        pUser->cmgPersonID = 0;
    }

    //
    // Copy the user name into the object:
    //
    lstrcpy(pUser->personName, cmStatus.localName);

    //
    // Copy the person's color into the client's data
    //
    m_colorId = pUser->colorId;

    //
    // Add the object to the User Information Workset, saving the handle of
    // the user object in the client details.
    //
    rc = OM_ObjectAdd(m_pomClient,
                        m_hWSGroup,
                        USER_INFORMATION_WORKSET,
                        &pData,
                        WB_PERSON_OBJECT_UPDATE_SIZE,
                        &m_pObjLocal,
                        LAST);
    if (rc != 0)
    {
        //
        // The add failed, we must discard the object
        //
        OM_ObjectDiscard(m_pomClient,
                     m_hWSGroup,
                     USER_INFORMATION_WORKSET,
                     &pData);

        ERROR_OUT(("Error adding user object = %d", rc));
        DC_QUIT;
    }

    //
    // Save the ID of this user in the client details (for later use in the
    // lock information).
    //
    OM_ObjectPtrToID(m_pomClient,
                      m_hWSGroup,
                      USER_INFORMATION_WORKSET,
                      m_pObjLocal,
                      &(m_personID));

DC_EXIT_POINT:
    DebugExitDWORD(wbAddLocalUserObject, rc);
    return(rc);
}



//
//
// Name:    wbGetEmptyPageHandle
//
// Purpose: Return a handle for a page that does not have its workset open.
//
// Returns: Handle of free page (or 0 if none exists)
//
//
WB_PAGE_HANDLE WbClient::wbGetEmptyPageHandle(void)
{
    UINT    index;
    WB_PAGE_HANDLE hPage = WB_PAGE_HANDLE_NULL;
    PWB_PAGE_STATE pPageState = m_pageStates;

    //
    // Search the page list for an empty entry
    //
    for (index = 0; index < WB_MAX_PAGES; index++, pPageState++)
    {
        if (   (pPageState->state == PAGE_NOT_IN_USE)
            && (pPageState->subState == PAGE_STATE_EMPTY))
        {
            hPage = PAGE_INDEX_TO_HANDLE(index);
            break;
        }
    }


    return(hPage);
}



//
//
// Name:    wbGetReadyPageHandle
//
// Purpose: Return a handle for a page that has its workset open but is not
//          currently in use.
//
// Returns: Handle of free page (or 0 if none exists)
//
//
WB_PAGE_HANDLE WbClient::wbGetReadyPageHandle(void)
{
    UINT       index;
    WB_PAGE_HANDLE hPage = WB_PAGE_HANDLE_NULL;
    PWB_PAGE_STATE pPageState = m_pageStates;

    //
    // Search the page list for a ready entry
    //
    for (index = 0; index < WB_MAX_PAGES; index++, pPageState++)
    {
        if (   (pPageState->state == PAGE_NOT_IN_USE)
             && (pPageState->subState == PAGE_STATE_READY))
        {
            hPage = PAGE_INDEX_TO_HANDLE(index);
            break;
        }
    }

    return(hPage);
}



//
//
// Name:    wbPageOrderPageNumber
//
// Purpose: Return the number of the specified page.
//          This function performs no validation on its parameters.
//
// Returns: None
//
//
UINT WbClient::wbPageOrderPageNumber
(
    PWB_PAGE_ORDER pPageOrder,
    WB_PAGE_HANDLE hPage
)
{
    UINT       index;
    POM_WORKSET_ID pPage = pPageOrder->pages;

    DebugEntry(wbPageOrderPageNumber);

    //
    // Search the page order list for the page handle (workset ID)
    //
    for (index = 0; index <= pPageOrder->countPages; index++)
    {
        if (pPage[index] == (OM_WORKSET_ID)hPage)
        {
            DC_QUIT;
        }
    }

    //
    // The page was not found - this is an internal error
    //
    ERROR_OUT(("Page handle not found"));

  //
  // Return the page number starting from 1.
  //
DC_EXIT_POINT:
    DebugExitDWORD(wbPageOrderPageNumber, index + 1);
    return(index + 1);
}



//
//
// Name:    wbPageOrderPageAdd
//
// Purpose: Add a new page to a page order structure. This function expects
//          the parameters to be valid - they must be checked before
//          calling it. It also assumes that there is space in the page
//          list for the new page.
//
// Params:  pPageOrder - pointer to page list
//          hRefPage   - page used as a reference point for the new page
//          hPage      - handle of the page to be added
//          where      - relative position - before or after hRefPage
//
// Returns: None
//
//
void WbClient::wbPageOrderPageAdd
(
    PWB_PAGE_ORDER  pPageOrder,
    WB_PAGE_HANDLE  hRefPage,
    WB_PAGE_HANDLE  hPage,
    UINT            where
)
{
    UINT            index;
    POM_WORKSET_ID  pPage = pPageOrder->pages;

    DebugEntry(wbPageOrderPageAdd);

    //
    // Process according to the add position
    //
    switch(where)
    {
        case PAGE_FIRST:
            index = 0;
            if (pPageOrder->countPages != 0)
            {
                UT_MoveMemory(&pPage[1], &pPage[0], pPageOrder->countPages*sizeof(pPage[0]));
            }
            break;

        case PAGE_LAST:
            index = pPageOrder->countPages;
            break;

        case PAGE_AFTER:
        case PAGE_BEFORE:
            //
            // Make an empty space in the page order list
            //
            index = wbPageOrderPageNumber(pPageOrder, hRefPage);
            if (where == PAGE_BEFORE)
            {
                index--;
            }

            UT_MoveMemory(&pPage[index + 1], &pPage[index],
              (pPageOrder->countPages - index)*sizeof(pPage[0]));
            break;

        default:
            ERROR_OUT(("Bad where parameter"));
            DC_QUIT;
    }

    //
    // Save the new page handle in the list
    //
    pPage[index] = hPage;

    //
    // Show that the extra page is now present
    //
    pPageOrder->countPages += 1;

DC_EXIT_POINT:
    DebugExitVOID(wbPageOrderPageAdd);
}




//
//
// Name:    wbPageOrderPageDelete
//
// Purpose: Remove the specified page from a page order structure. This
//          function expects its the parameters to be valid - they must be
//          checked before calling it.
//
// Returns: None
//
//
void WbClient::wbPageOrderPageDelete
(
    PWB_PAGE_ORDER  pPageOrder,
    WB_PAGE_HANDLE  hPage
)
{
    UINT            index;
    POM_WORKSET_ID  pPage = pPageOrder->pages;

    DebugEntry(wbPageOrderPageDelete);

    index = wbPageOrderPageNumber(pPageOrder, hPage);
    UT_MoveMemory(&pPage[index - 1],
             &pPage[index],
             (pPageOrder->countPages - index)*sizeof(pPage[0]));

    pPageOrder->countPages -= 1;

    DebugExitVOID(wbPageOrderPageDelete);
}




//
//
// Name:    wbPagesPageAdd
//
// Purpose: Add a new page to the internal page list. This function expects
//          the parameters to be valid - they must be checked before
//          calling it. It also assumes that there is space in the page
//          list for the new page.
//
// Returns: None
//
//
void WbClient::wbPagesPageAdd
(
    WB_PAGE_HANDLE  hRefPage,
    WB_PAGE_HANDLE  hPage,
    UINT            where
)
{
    PWB_PAGE_STATE pPageState;

    DebugEntry(wbPagesPageAdd);

    //
    // Add the page to the page order structure
    //
    wbPageOrderPageAdd(&(m_pageOrder), hRefPage, hPage, where);

    //
    // Update the page state information
    //
    pPageState = GetPageState(hPage);
    pPageState->state    = PAGE_IN_USE;
    pPageState->subState = PAGE_STATE_EMPTY;

    DebugExitVOID(wbPagesPageAdd);
}



//
//
// Name:    wbClientReset
//
// Purpose: Reset the client data to a state where the client is not in a
//          call, but is registered with ObMan and has event and exit
//          handlers registered with utilities.
//
// Returns: None
//
//
void WbClient::wbClientReset(void)
{
    UINT       index;
    PWB_PAGE_ORDER pPageOrder = &(m_pageOrder);
    PWB_PAGE_STATE pPageState = m_pageStates;

    DebugEntry(wbClientReset);

    //
    // Initialize object handles
    //
    m_hWSGroup          = (OM_WSGROUP_HANDLE) NULL;

    m_pObjPageControl   = NULL;
    m_pObjSyncControl   = NULL;
    m_pObjLocal         = NULL;

    m_pObjLock          = NULL;
    m_pObjPersonLock    = NULL;

    //
    // Initialize the status variables
    //
    m_errorState        = ERROR_STATE_EMPTY;
    m_changed           = FALSE;
    m_lockState         = LOCK_STATE_EMPTY;
    m_lockType          = WB_LOCK_TYPE_NONE;
    m_lockRequestType   = WB_LOCK_TYPE_NONE;

    m_loadState         = LOAD_STATE_EMPTY;
    if (m_hLoadFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(m_hLoadFile);
        m_hLoadFile    = INVALID_HANDLE_VALUE;
    }

    m_countReadyPages   = 0;


    //
    // Zero the whole structure
    //
    ZeroMemory(pPageOrder, sizeof(*pPageOrder));

    //
    // Set the object type
    //
    pPageOrder->objectType = TYPE_CONTROL_PAGE_ORDER;

    //
    // Set up the page control elements
    //
    pPageOrder->generationLo   = 1;
    pPageOrder->generationHi   = 0;
    pPageOrder->countPages     = 0;

    //
    // Initialize the page state structures
    //
    for (index = 0; index < WB_MAX_PAGES; index++, pPageState++)
    {
        pPageState->state = PAGE_NOT_IN_USE;
        pPageState->subState = PAGE_STATE_EMPTY;
    }

    DebugExitVOID(wbClientReset);
}




//
//
// Name:    wbOnWsGroupRegisterCon
//
// Purpose: Routine processing OM_WSGROUP_REGISTER_CON events.
//
// Returns: Error code
//
//
BOOL WbClient::wbOnWsGroupRegisterCon
(
    UINT_PTR param1,
    UINT_PTR param2
)
{
    POM_EVENT_DATA16 pEvent16 = (POM_EVENT_DATA16) &param1;
    POM_EVENT_DATA32 pEvent32 = (POM_EVENT_DATA32) &param2;
    BOOL        processed;

    DebugEntry(wbOnWsGroupRegisterCon);

    //
    // Check that this is the event we are expecting
    //
    if (pEvent32->correlator != m_wsgroupCorrelator)
    {
        //
        // We are not expecting this event, this means that it must be for a
        // workset group which we wanted to deregister from (but had not yet
        // received confirmation). So deregister immediately.
        //

        //
        // Check that the return code for the registration is OK
        //
        if (pEvent32->result == 0)
        {
            OM_WSGroupDeregister(m_pomClient, &(pEvent16->hWSGroup));
        }

        processed = FALSE;
        DC_QUIT;
    }

    //
    // Show that we have processed the event
    //
    processed = TRUE;

    //
    // Test for the correct state
    //
    if (m_subState != STATE_REG_PENDING_WSGROUP_CON)
    {
        //
        // We are not in the correct state for this event - this is an internal
        // error.
        //
        ERROR_OUT(("Not in correct state for WSGroupRegisterCon"));
        DC_QUIT;
    }

    //
    // Check that the return code for the registration is OK
    //
    if (pEvent32->result != 0)
    {
        //
        // Registration with the workset group failed - tidy up
        //
        wbError();

        DC_QUIT;
    }

    //
    // Registration with the workset group succeeded
    //
    m_hWSGroup = pEvent16->hWSGroup;

    //
    // Get the clients network ID, used in graphic objects to determine where
    // they are loaded.
    //
    if (!wbGetNetUserID())
    {
        //
        // Tidy up (and post an error event to the client)
        //
        ERROR_OUT(("Failed to get user ID"));
        wbError();
        DC_QUIT;
    }

    //
    // Start opening the worksets.  We open them one at a time and wait for
    // the response to avoid flooding the message queue.
    // The user information workset is given high priority.  This allows
    // remote pointer movements to travel quickly.
    //
    if (OM_WorksetOpenPReq(m_pomClient,
                          m_hWSGroup,
                          USER_INFORMATION_WORKSET,
                          NET_HIGH_PRIORITY,
                          TRUE,
                          &(m_worksetOpenCorrelator)) != 0)
    {
        ERROR_OUT(("User Information Workset Open Failed"));
        wbError();
        DC_QUIT;
    }

    //
    // Move to the next state
    //
    m_subState = STATE_REG_PENDING_USER_WORKSET;

DC_EXIT_POINT:
    DebugExitBOOL(wbOnWsGroupRegisterCon, processed);
    return(processed);
}



//
//
// Name:    wbOnWorksetOpenCon
//
// Purpose: Routine processing OM_WORKSET_OPEN_CON events.
//
// Returns: Error code
//
//
BOOL WbClient::wbOnWorksetOpenCon
(
    UINT_PTR param1,
    UINT_PTR param2
)
{
    POM_EVENT_DATA16 pEvent16 = (POM_EVENT_DATA16) &param1;
    POM_EVENT_DATA32 pEvent32 = (POM_EVENT_DATA32) &param2;
    BOOL            processed = FALSE;
    OM_WORKSET_ID eventWorksetID;

    DebugEntry(wbOnWorksetOpenCon);

    //
    // Process according to the workset ID
    //
    eventWorksetID = pEvent16->worksetID;

    //
    // If the event is for a page workset
    //
    if (eventWorksetID >= FIRST_PAGE_WORKSET)
    {
        //
        // We are opening a page workset
        //
        processed = wbOnPageWorksetOpenCon(param1, param2);
        if (!processed)
        {
            DC_QUIT;
        }
    }

    //
    // We are done if this is a page workset other than the 1st page workset
    //
    if (eventWorksetID > FIRST_PAGE_WORKSET)
    {
        DC_QUIT;
    }

    //
    // Now check if it is one of the control worksets (the first page workset
    // is both a control workset and a page workset).
    //
    if (eventWorksetID != FIRST_PAGE_WORKSET)
    {
        //
        // Check the message correlator
        //
        if (pEvent32->correlator != m_worksetOpenCorrelator)
        {
            TRACE_OUT(("Correlators do not match - quitting"));
            DC_QUIT;
        }
    }

    //
    // We are opening a control workset - process the event
    //
    wbOnControlWorksetOpenCon(param1, param2);
    processed = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(wbOnWorksetOpenCon, processed);
    return(processed);
}




//
//
// Name:    wbOnControlWorksetOpenCon
//
// Purpose: Routine processing OM_WORKSET_OPEN_CON events for control
//          worksets.
//
// Returns: Error code
//
//
void WbClient::wbOnControlWorksetOpenCon
(
    UINT_PTR param1,
    UINT_PTR param2
)
{
    POM_EVENT_DATA16 pEvent16 = (POM_EVENT_DATA16) &param1;
    POM_EVENT_DATA32 pEvent32 = (POM_EVENT_DATA32) &param2;
    UINT            rc;
    OM_WORKSET_ID   eventId;

    DebugEntry(wbOnControlWorksetOpenCon);

    //
    // Check the return code in the open
    //
    if (pEvent32->result != 0)
    {
        ERROR_OUT(("Error reported on workset open = %d", pEvent32->result));
        wbError();
        DC_QUIT;
    }

    //
    // If we are in registration, we are opening the required worksets -
    // continue the process.
    //
    if (m_state > STATE_REGISTERING)
    {
        ERROR_OUT(("Control workset open con after registration"));
    }

    //
    // Set up for opening the next workset
    //
    eventId = pEvent16->worksetID;
    switch(eventId)
    {
        case USER_INFORMATION_WORKSET:
            //
            // The user information workset is given high priority.  This allows
            // remote pointer movements to travel quickly.
            //
            TRACE_OUT(("Opening Page Control workset"));
            rc = OM_WorksetOpenPReq(m_pomClient,
                              m_hWSGroup,
                              PAGE_CONTROL_WORKSET,
                              NET_HIGH_PRIORITY,
                              FALSE,
                              &(m_worksetOpenCorrelator));

            m_subState = STATE_REG_PENDING_WORKSET_OPEN;
            break;

        case PAGE_CONTROL_WORKSET:
            //
            // The sync control workset is given high priority to allow sync
            // updates to travel quickly.
            //
            TRACE_OUT(("Opening Sync Control workset"));
            rc = OM_WorksetOpenPReq(m_pomClient,
                              m_hWSGroup,
                              SYNC_CONTROL_WORKSET,
                              NET_HIGH_PRIORITY,
                              FALSE,
                              &(m_worksetOpenCorrelator));
            break;

        case SYNC_CONTROL_WORKSET:
            //
            // Open the first of the page worksets - we must do this to allow us
            // to use it as the only page available if we are the first person in
            // the call.
            //
            TRACE_OUT(("Opening first page workset"));
            rc = wbPageWorksetOpen((WB_PAGE_HANDLE)FIRST_PAGE_WORKSET,
                             OPEN_LOCAL);
            break;

        case FIRST_PAGE_WORKSET:
            break;

        default:
            ERROR_OUT(("Bad workset ID"));
            break;
    }

    //
    // Check whether we have just opened another workset
    //
    if (eventId != FIRST_PAGE_WORKSET)
    {
        //
        // Test the return code from the open
        //
        if (rc != 0)
        {
            ERROR_OUT(("Workset open failed = %d", rc));
            wbError();
        }

        DC_QUIT;
    }

    //
    // We have now opened all the control worksets. We now add the required
    // control objects.
    //
    rc = wbAddLocalUserObject();
    if (rc != 0)
    {
        //
        // Stop the join call process, tidy up and send an error message to the
        // client.
        //
        wbError();
        DC_QUIT;
    }

    m_subState = STATE_REG_USER_OBJECT_ADDED;
    TRACE_OUT(("Moved to substate STATE_REG_USER_OBJECT_ADDED"));

    //
    // Check whether the Page Control objects are available yet (they could
    // have been added by another user in the call).
    //
    TRACE_OUT(("%x PAGE WS object, %x SYNC WS object",
                                               m_pObjPageControl,
                                               m_pObjSyncControl));
    if ( (m_pObjPageControl == 0) &&
         (m_pObjSyncControl == 0))
    {
        TRACE_OUT(("No control objects - WE MIGHT BE FIRST IN CALL - get lock"));

        //
        // We may be the first user to register - request the lock on the Page
        // Control Workset.
        //
        rc = wbLock(WB_LOCK_TYPE_PAGE_ORDER);
		if (rc != 0)
        {
            ERROR_OUT(("Error from wbLock = %d", rc));
            wbError();
			DC_QUIT;
        }

        //
        // Set the new registration state
        //
        m_subState = STATE_REG_PENDING_LOCK;
        TRACE_OUT(("Moved to substate STATE_REG_PENDING_LOCK"));
        DC_QUIT;
    }
    else
    {
        if (m_pObjSyncControl == 0)
        {
            TRACE_OUT(("Waiting for sync control"));
            m_subState = STATE_REG_PENDING_SYNC_CONTROL;
            DC_QUIT;
        }

        if (m_pObjPageControl == 0)
        {
            TRACE_OUT(("Waiting for page control"));
            m_subState = STATE_REG_PENDING_PAGE_CONTROL;
            DC_QUIT;
        }
    }

    //
    // Complete registration
    //
    TRACE_OUT(("Page Control and Sync Control objects both there."));
    TRACE_OUT(("Registration can be completed"));

    wbOnControlWorksetsReady();


DC_EXIT_POINT:
    DebugExitVOID(wbOnControlWorksetOpenCon);
}




//
//
// Name:    wbPageWorksetOpen
//
// Purpose: Open a page workset
//
// Returns: Error code
//
//
UINT WbClient::wbPageWorksetOpen
(
    WB_PAGE_HANDLE  hPage,
    UINT            localOrExternal
)
{
    UINT            result;
    PWB_PAGE_STATE  pPageState;

    DebugEntry(wbPageWorksetOpen);

    //
    // Get the page state
    //
    pPageState = GetPageState(hPage);
    ASSERT((pPageState->state == PAGE_NOT_IN_USE));
    ASSERT((pPageState->subState == PAGE_STATE_EMPTY));

    //
    // Open the workset. We allow ObMan to choose the priority, this means
    // that ObMan uses a variable priority scheme allowing small objects to
    // overtake large ones.
    //
    result = OM_WorksetOpenPReq(m_pomClient,
                              m_hWSGroup,
                              (OM_WORKSET_ID)hPage,
                              OM_OBMAN_CHOOSES_PRIORITY,
                              FALSE,
                              &(pPageState->worksetOpenCorrelator));
    if (result != 0)
    {
        ERROR_OUT(("WorksetOpen failed = %d", result));
        DC_QUIT;
    }

    //
    // Update the page state
    //
    if (localOrExternal == OPEN_LOCAL)
    {
        pPageState->subState = PAGE_STATE_LOCAL_OPEN_CONFIRM;
        TRACE_OUT(("Moved page %d state to PAGE_STATE_PENDING_OPEN_CONFIRM",
                                                           (UINT) hPage));
    }
    else
    {
        pPageState->subState = PAGE_STATE_EXTERNAL_OPEN_CONFIRM;
        TRACE_OUT(("Moved page %d state to PAGE_STATE_PENDING_OPEN_CONFIRM",
                                                           (UINT) hPage));
    }

DC_EXIT_POINT:
    DebugExitDWORD(wbPageWorksetOpen, result);
    return(result);
}




//
//
// Name:    wbOnPageWorksetOpenCon
//
// Purpose: Routine processing OM_WORKSET_OPEN_CON events for page worksets
//
// Returns: Error code
//
//
BOOL WbClient::wbOnPageWorksetOpenCon
(
    UINT_PTR param1,
    UINT_PTR param2
)
{
    POM_EVENT_DATA16 pEvent16 = (POM_EVENT_DATA16) &param1;
    POM_EVENT_DATA32 pEvent32 = (POM_EVENT_DATA32) &param2;
    BOOL            processed = FALSE;
    OM_WORKSET_ID    eventId;
    PWB_PAGE_STATE   pPageState;
    WB_PAGE_HANDLE   hPage;
    UINT         oldState;

    DebugEntry(wbOnPageWorksetOpenCon);

    //
    // Get the page state pointer
    //
    eventId = pEvent16->worksetID;
    hPage   = (WB_PAGE_HANDLE)eventId;
    pPageState = GetPageState(hPage);

    //
    // Check the message correlator
    //
    if (pEvent32->correlator != pPageState->worksetOpenCorrelator)
    {
        TRACE_OUT(("Correlators do not match - quitting"));
        DC_QUIT;
    }

    //
    // Show that we have processed this event
    //
    processed = TRUE;

    //
    // Check the return code in the open
    //
    if (pEvent32->result != 0)
    {
        ERROR_OUT(("Error reported on page workset open = %d",
             pEvent32->result));

        pPageState->subState = PAGE_STATE_EMPTY;
        TRACE_OUT(("Moved page %d substate to PAGE_STATE_EMPTY",
             (UINT)hPage));
        DC_QUIT;
    }

    //
    // Update the page state to indicate that the page is now ready for use
    //
    oldState = pPageState->subState;
    pPageState->subState = PAGE_STATE_READY;
    TRACE_OUT(("Moved page %d to substate to PAGE_STATE_READY",
           (UINT)hPage));

    switch (oldState)
    {
        case PAGE_STATE_LOCAL_OPEN_CONFIRM:
            //
            // This workset was opened locally, therefore it is being opened as
            // part of the workset cache. Nothing more to do.
            //
            break;

        case PAGE_STATE_EXTERNAL_OPEN_CONFIRM:
            //
            // This workset was opened as a result of external updates to the
            // Page Control object.  We therefore need to add the page to the
            // page list now that the workset is open.  We no longer know where
            // the page is to be added - so call the main Page Control update
            // routine again to get all the information.
            //
            wbProcessPageControlChanges();
            break;

        default:
            ERROR_OUT(("Bad page state %d", pPageState->subState));
            break;
    }

    //
    // Increment the number of pages in ready state.  This count is never
    // decremented - once a workset is open it stays open.
    //
    m_countReadyPages += 1;

    //
    // If we are in registration and are waiting for the cache of ready
    // pages, we must complete registration now.
    //
    if ( (m_state == STATE_REGISTERING) &&
         (m_subState == STATE_REG_PENDING_READY_PAGES) )
    {
        //
        // If there are enough pages in the cache
        //
        if (wbCheckReadyPages())
        {
            //
            // We have enough ready pages - complete registration
            //
            wbCompleteRegistration();
            DC_QUIT;
        }

        //
        // There are not yet enough pages in the cache.  CheckReadyPages will
        // have made a new workset open request, so we will receive another
        // workset open confirm soon.
        //
        DC_QUIT;
    }


DC_EXIT_POINT:
    DebugExitBOOL(wbOnPageWorksetOpenCon, processed);
    return(processed);
}



//
//
// Name:    wbOnWorksetLockCon
//
// Purpose: Routine processing OM_WORKSET_LOCK_CON events.
//
// Returns: Error code
//
//
BOOL WbClient::wbOnWorksetLockCon
(
    UINT_PTR param1,
    UINT_PTR param2
)
{
    POM_EVENT_DATA16 pEvent16 = (POM_EVENT_DATA16) &param1;
    POM_EVENT_DATA32 pEvent32 = (POM_EVENT_DATA32) &param2;
    BOOL            processed = FALSE;
    UINT            rc;

    DebugEntry(wbOnWorksetLockCon);

    //
    // Check the message correlator
    //
    if (pEvent32->correlator != m_lockCorrelator)
    {
        DC_QUIT;
    }

    //
    // The message is for us - set the result to "processed"
    //
    processed = TRUE;

    //
    // Check that the event is for the Page Control Workset (this is the
    // only expected workset).
    //
    if (pEvent16->worksetID != PAGE_CONTROL_WORKSET)
    {
        ERROR_OUT(("Unexpected workset in LockCon = %d",
                                                       pEvent16->worksetID));
    }

    //
    // Process according to the current lock state
    //
    switch (m_lockState)
    {
        //
        // We were waiting for lock confirmation
        //
        case LOCK_STATE_PENDING_LOCK:
            //
            // Check the return code in the event
            //
            if (pEvent32->result != 0)
            {
                TRACE_OUT(("Posting WBP_EVENT_LOCK_FAILED, rc %d",
                                                           pEvent32->result));
                WBP_PostEvent(0,                      // No delay
                             WBP_EVENT_LOCK_FAILED,  // Lock request failed
                             0,                      // No parameters
                             0);

                //
                // The lock failed - update the state.  This means that
                // another user has acquired the lock.  We expect to get a
                // lock object add indication soon.
                //
                m_lockState = LOCK_STATE_EMPTY;
                TRACE_OUT(("Lock request failed - lock state is now EMPTY"));
                DC_QUIT;
            }

            //
            // Write the lock details to the Page Control Workset
            //
            rc = wbWriteLock();
            if (rc != 0)
            {
                ERROR_OUT(("Unable to write lock details = %d", rc));

                //
                // Tidy up by unlocking the Page Control Workset
                //
                OM_WorksetUnlock(m_pomClient,
                                 m_hWSGroup,
                                 PAGE_CONTROL_WORKSET);

                //
                // Tell the client of the failure
                //
                TRACE_OUT(("Posting WBP_EVENT_LOCK_FAILED"));
                WBP_PostEvent(0,                      // No delay
                             WBP_EVENT_LOCK_FAILED,  // Lock request failed
                             0,                      // No parameters
                             0);

                //
                // Update the lock state
                //
                m_lockState = LOCK_STATE_EMPTY;
                TRACE_OUT(("Moved lock state to LOCK_STATE_EMPTY"));
                DC_QUIT;
            }

            //
            // Once we get here the write of the lock object above will
            // trigger an object add event that completes the lock
            // processing.
            //
            m_lockState = LOCK_STATE_PENDING_ADD;
            TRACE_OUT(("Moved lock state to LOCK_STATE_PENDING_ADD"));
            break;

        //
        // The application has cancelled the lock request before it has had
        // time to complete - tidy up.
        //
        case LOCK_STATE_CANCEL_LOCK:
            TRACE_OUT(("LOCK_STATE_CANCEL_LOCK"));

            //
            // If the request failed, just reset the state.
            //
            //
            // The lock was cancelled - unlock the workset if necessary,
            // and notify the front-end of the unlock.
            //
            if (pEvent32->result == 0)
            {
                //
                // We have locked the workset successfully, but in the
                // meantime the front-end has cancelled the lock, so unlock
                // the workset now.
                //
                TRACE_OUT((
                      "Lock cancelled before workset locked, so unlock now"));
                OM_WorksetUnlock(m_pomClient,
                                 m_hWSGroup,
                                 PAGE_CONTROL_WORKSET);
            }
            m_lockState = LOCK_STATE_EMPTY;

            //
            // Tell the app that we have cancelled the lock.
            //
            TRACE_OUT(("Posting WBP_EVENT_UNLOCKED"));
            WBP_PostEvent(0,
                         WBP_EVENT_UNLOCKED,
                         0,
                         0);
            break;

        //
        // Another has got in before us
        //
        case LOCK_STATE_LOCKED_OUT:

            //
            // We have received a lock confirmation and should have been
            // expecting the lock.  But we are locked out.  This means that
            // another user has got in just before us, acquired the lock
            // and added the lock object.  We have processed the add and
            // changed the lock state accordingly.  This lock confirmation
            // will therefore normally be a failure. If by some fluke it
            // isn't, then we treat it as a failure for safety.
            //
            if (pEvent32->result == 0)
            {
                ERROR_OUT(("Lock violation"));

                //
                // Tidy up by unlocking the Page Control Workset - leave
                // the state as LOCKED_OUT; we'll clear it on receipt of
                // the unlock (either local, or from the locking user).
                //
                OM_WorksetUnlock(m_pomClient,
                                 m_hWSGroup,
                                 PAGE_CONTROL_WORKSET);
            }
            break;

        default:
            ERROR_OUT(("Bad lock state %d", m_lockState));
            break;
    } // Switch on lock state

DC_EXIT_POINT:
    DebugExitBOOL(wbOnWorksetLockCon, processed);
    return(processed);
}



//
//
// Name:    wbOnWorksetUnlockInd
//
// Purpose: Routine processing OM_WORKSET_UNLOCK_IND events.
//
// Returns: Error code
//
//
BOOL WbClient::wbOnWorksetUnlockInd
(
    UINT_PTR param1,
    UINT_PTR param2
)
{
    POM_EVENT_DATA16 pEvent16 = (POM_EVENT_DATA16) &param1;
    POM_EVENT_DATA32 pEvent32 = (POM_EVENT_DATA32) &param2;
    BOOL            processed = TRUE;

    DebugEntry(wbOnWorksetUnlockInd);

    //
    // We are only interested if the workset id is that of the Page Control
    // Workset.
    //
    if (pEvent16->worksetID != PAGE_CONTROL_WORKSET)
    {
        TRACE_OUT(("Unexpected workset in unlock = %d", pEvent16->worksetID));
        DC_QUIT;
    }

    switch (m_lockState)
    {
        //
        // We had the lock and are waiting to unlock or another user had
        // the lock and has now removed it.
        //
        case LOCK_STATE_LOCKED_OUT:
            //
            // We received the unlock of the workset before the removal of
            // the lock object; we just ignore this, since the deletion of
            // the lock object is our indication that the wb lock is removed.
            //
            TRACE_OUT(("Unlock of page control workset while locked out"));
            break;

        //
        // We are unlocking after an error acquiring the lock or after a
        // user has cancelled alock before we had time to complete it.
        //
        case LOCK_STATE_CANCEL_LOCK:

            //
            // An error occurred in getting the lock - the client has
            // already been informed so we just record the state change.
            //
            m_lockState = LOCK_STATE_EMPTY;
            TRACE_OUT(("Moved lock state to LOCK_STATE_EMPTY"));
            break;

        //
        // We are waiting for the lock - but have got an unlock instead.
        // This could be from another user, or from previous aborted
        // attempts by us to get the lock.  We ignore the event and wait
        // for our lock confirmation.
        //
        case LOCK_STATE_PENDING_LOCK:
            TRACE_OUT((
                "Got unlock indication while waiting for lock confirmation"));
            break;

        //
        // We can get an unlock indication without ever having seen the
        // lock object if the lock object was never added (failure at
        // another user) or if ObMan has spoiled the add and delete.
        //
        case LOCK_STATE_EMPTY:
            TRACE_OUT(("Unlock received in LOCK_STATE_EMPTY - ignoring"));
            break;

		//
        // Unlock not expected in this state
        //
        default:
            ERROR_OUT(("Bad lock state %d", m_lockState));
            break;
    }


DC_EXIT_POINT:
    DebugExitBOOL(wbOnWorksetUnlockInd, processed);
    return(processed);
}



//
//
// Name:    wbOnControlWorksetsReady
//
// Purpose: The control worksets have been opened and set up. Continue the
//          registration process by updating the internal page order to
//          ensure that in matches the external order.
//
// Returns: Error code
//
//
void WbClient::wbOnControlWorksetsReady(void)
{
    DebugEntry(wbOnControlWorksetsReady);

    //
    // Read the Page Control object and compare its content to the internal
    // Page Order.
    //
    wbProcessPageControlChanges();

    //
    // Update the state to show that we are waiting for the Page Order
    // Updated event indicating that the internal page order now matches
    // the external order.
    //
    m_subState = STATE_REG_PENDING_PAGE_ORDER;
    TRACE_OUT(("Moved sub state to STATE_REG_PENDING_PAGE_ORDER"));

    DebugExitVOID(wbOnControlWorksetsReady);
}



//
//
// Name:    wbCompleteRegistration
//
// Purpose: Perform the final steps in registering a client.  These are:
//          post a WB_EVENT_REGISTERED event to the client; check if
//          another user has a lock on the contents or page order, if so,
//          post a WB_EVENT_CONTENTS_LOCKED or WB_EVENT_PAGE_ORDER_LOCKED
//          to the client.
//
// Returns: Error code
//
//
void WbClient::wbCompleteRegistration(void)
{
    DebugEntry(wbCompleteRegistration);

    //
    // Inform the client that we are fully registered
    //
    TRACE_OUT(("Posting WBP_EVENT_REGISTER_OK"));
    WBP_PostEvent(0,                               // No delay
                 WBP_EVENT_JOIN_CALL_OK,          // Fully registered
                 0,                               // No parameters
                 0);

    //
    // Notify the client of the lock status
    //
    wbSendLockNotification();

    //
    // Record that we are now fully registered
    //
    m_state = STATE_IDLE;
    m_subState = STATE_EMPTY;
    TRACE_OUT(("Moved to state STATE_IDLE"));

    DebugExitVOID(wbCompleteRegistration);
}



//
//
// Name:    wbLeaveCall
//
// Purpose: Remove a client from a call/workset group
//
// Returns: None
//
//
void WbClient::wbLeaveCall(void)
{
    DebugEntry(wbLeaveCall);

    //
    // If we have not got far enough to have entered a call - leave now
    // (there is nothing to tidy up).
    //
    if (m_state < STATE_REGISTERING)
    {
        DC_QUIT;
    }

    //
    // If we have the lock - delete the lock object (the workset will be
    // unlocked by ObMan when we deregister).
    //
    if (m_lockState == LOCK_STATE_GOT_LOCK)
    {
        TRACE_OUT(("Still got lock - deleting lock object, handle %d",
                                                      m_pObjLock));
		if (OM_ObjectDelete(m_pomClient,
                                m_hWSGroup,
                                PAGE_CONTROL_WORKSET,
                                m_pObjLock) != 0)
		{
	            ERROR_OUT(("Error deleting lock object"));
		}

        //
        // If all is well at this point the unlock process will be
        // completed when the object delete ind is received.
        //
        m_lockState = LOCK_STATE_PENDING_DELETE;
        TRACE_OUT(("Moved to state LOCK_STATE_PENDING_DELETE"));
    }

    //
    // Fix up the sub state to indicate that all registration actions have
    // been completed (to ensure that they are all undone).
    //
    if (m_state > STATE_REGISTERING)
    {
        m_subState = STATE_REG_END;
        TRACE_OUT(("Moved to substate STATE_REG_END"));
    }

    //
    // Delete the user object representing the local user from the User
    // Information Workset (if it is present).  Note that we are about to
    // deregister from ObMan - this acts as automatic confirmation of the
    // delete request so we do not need to wait for the
    // OM_OBJECT_DELETE_IND event.
    //
    if (m_subState >= STATE_REG_USER_OBJECT_ADDED)
    {
        TRACE_OUT(("Deleting user object"));
        if (OM_ObjectDelete(m_pomClient,
                                 m_hWSGroup,
                                 USER_INFORMATION_WORKSET,
                                 m_pObjLocal) != 0)
        {
            //
            // Trace the error but do not quit - we expect everything to be
            // tidied up when we deregister from ObMan.
            //
            ERROR_OUT(("Error deleting local user object"));
        }
    }

    //
    // If we have already registered with the Workset Group, deregister
    // now.  we have not yet received the confirmation, and get it later we
    // will deregister immediately.
    //
    if (m_subState > STATE_REG_PENDING_WSGROUP_CON)
    {
        OM_WSGroupDeregister(m_pomClient, &(m_hWSGroup));
    }
    else
    {
        //
        // We have not yet received the Workset Group Registration
        // confirmation, change the value in the correlator field so that
        // we recognize the fact that we have cancelled registration later.
        //
        m_wsgroupCorrelator--;
    }

    //
    // Reset the handles of objects added during registration
    //
    TRACE_OUT(("Resetting client data"));
    wbClientReset();

    //
    // Set the client state to the appropriate value
    //
    m_state = STATE_STARTED;
    m_subState = STATE_STARTED_START;
    TRACE_OUT(("Moved state to STATE_STARTED"));

DC_EXIT_POINT:
    DebugExitVOID(wbLeaveCall);
}



//
//
// Name:    wbContentsDelete
//
// Purpose: Remove all the current graphics and pages, leaving a single
//          blank page.
//
// Returns: None
//
//
void WbClient::wbContentsDelete
(
    UINT        changedFlagAction
)
{
    PWB_PAGE_ORDER   pPageOrder = &(m_pageOrder);
    PWB_PAGE_STATE   pPageState;
    UINT         index;

    DebugEntry(wbContentsDelete);

    //
    // Just clear the first page in the list
    //
    wbPageClear(pPageOrder->pages[0], changedFlagAction);

    //
    // If there is only one page left in the list - we're done.
    //
    if (pPageOrder->countPages == 1)
    {
        DC_QUIT;
    }

    //
    // There is more than one page
    //

    //
    // Mark all of the active pages (except the first) as "delete pending"
    //
    for (index = 1; index < pPageOrder->countPages; index++)
    {
        pPageState = GetPageState((pPageOrder->pages)[index]);

        if ((pPageState->state == PAGE_IN_USE) &&
            (pPageState->subState == PAGE_STATE_EMPTY))
        {
            pPageState->subState = PAGE_STATE_LOCAL_DELETE;
        }
    }

    //
    // Write the page control information.  The replace event generated by
    // the write will kick off the actual deletion of the pages marked.
    //
    wbWritePageControl(FALSE);

DC_EXIT_POINT:
    DebugExitVOID(wbContentsDelete);
}



//
//
// Name:    wbStartContentsLoad
//
// Purpose: Start the loading of a file (after the contents have been
//          cleared).
//
// Returns: Error code
//
//
void WbClient::wbStartContentsLoad(void)
{
    DebugEntry(wbStartContentsLoad);

    //
    // Specify the first (and only) page handle as the page to load to
    //
    wbPageHandleFromNumber(1, &m_loadPageHandle);

    //
    // Update the load state to show that we are now loading
    //
    m_loadState = LOAD_STATE_LOADING;
    TRACE_OUT(("Moved load state to LOAD_STATE_LOADING"));

    //
    // Load the first page - subsequent pages are chained from this first one
    //
    wbPageLoad();

    DebugExitVOID(wbStartContentsLoad);
}




//
//
// Name:    wbLock
//
// Purpose: Request the lock for the Whiteboard contents or the page order
//          generating one of the following events:
//
//          WB_EVENT_CONTENTS_LOCKED
//          WB_EVENT_CONTENTS_LOCK_FAILED.
//
// Returns: Error code
//
//
UINT WbClient::wbLock(WB_LOCK_TYPE lockType)
{
    UINT            result = 0;
    OM_CORRELATOR   correlator;

    DebugEntry(wbLock);

    //
    // If we already have the lock we can merely change its status
    //
    if (m_lockState == LOCK_STATE_GOT_LOCK)
    {
        TRACE_OUT(("Already got the lock"));

        m_lockRequestType = lockType;
        result = wbWriteLock();
        DC_QUIT;
    }

    //
    // Request the lock for the Page Control Workset
    //
    result = OM_WorksetLockReq(m_pomClient,
                             m_hWSGroup,
                             PAGE_CONTROL_WORKSET,
                             &correlator);
    if (result != 0)
    {
        ERROR_OUT(("OM_WorksetLockReq failed, result = %d", result));
        DC_QUIT;
    }

    TRACE_OUT(("Requested lock for the Page Control Workset"));

    //
    // Save the lock details
    //

	m_lockState       = LOCK_STATE_PENDING_LOCK;
    m_lockCorrelator  = correlator;
    m_lockRequestType = lockType;

    TRACE_OUT(("Moved lock state to LOCK_STATE_PENDING_LOCK"));
    TRACE_OUT(("Lock type requested = %d", lockType));

    //
    // We return now, further processing is done when the OM_WORKSET_LOCK_CON
    // event is received.
    //

DC_EXIT_POINT:
    DebugExitDWORD(wbLock, result);
    return(result);
}




//
//
// Name:    wbUnlock
//
// Purpose: Unlock the Contents or Page Order.
//
// Returns: Error code
//
//
void WbClient::wbUnlock(void)
{
    DebugEntry(wbUnlock);

    //
    // Check that we have the lock
    //
    if (m_lockState != LOCK_STATE_GOT_LOCK)
    {
        ERROR_OUT(("Local person doesn't have lock"));
        DC_QUIT;
    }

    //
    // Delete the lock object
    //
    TRACE_OUT(("Delete Lock handle %x", m_pObjLock));
    if (OM_ObjectDelete(m_pomClient,
                           m_hWSGroup,
                           PAGE_CONTROL_WORKSET,
                           m_pObjLock) != 0)
    {
        ERROR_OUT(("Could not delete lock object"));
        DC_QUIT;
    }

    //
    // If all is well at this point the unlock process will be completed when
    // the object delete ind is received.
    //
    m_lockState = LOCK_STATE_PENDING_DELETE;
    TRACE_OUT(("Moved to state LOCK_STATE_PENDING_DELETE"));


DC_EXIT_POINT:
    DebugExitVOID(wbUnlock);
}



//
//
// Name:    wbObjectSave
//
// Purpose: Save a structure to file
//
// Returns: Error code
//
//
UINT WbClient::wbObjectSave
(
    HANDLE      hFile,
    LPBYTE      pData,
    UINT        length
)
{
    UINT        result = 0;
    ULONG       cbSizeWritten;

    DebugEntry(wbObjectSave);

    //
    // Save the length
    //
    if (! WriteFile(hFile, (void *) &length, sizeof(length), &cbSizeWritten, NULL))
    {
        result = WB_RC_WRITE_FAILED;
        ERROR_OUT(("Error writing length to file, win32 err=%d", GetLastError()));
        DC_QUIT;
    }
    ASSERT(cbSizeWritten == sizeof(length));

    //
    // Save the object data
    //
    if (! WriteFile(hFile, pData, length, &cbSizeWritten, NULL))
    {
        result = WB_RC_WRITE_FAILED;
        ERROR_OUT(("Error writing data to file, win32 err=%d", GetLastError()));
        DC_QUIT;
    }
    ASSERT(cbSizeWritten == length);

DC_EXIT_POINT:
  DebugExitDWORD(wbObjectSave, result);
  return result;
}



//
//
// Name:    wbPageSave
//
// Purpose: Save the contents of a single page to file.
//
// Returns: Error code
//
//
UINT WbClient::wbPageSave
(
    WB_PAGE_HANDLE  hPage,
    HANDLE           hFile
)
{
    UINT            result = 0;
    UINT            rc;
    OM_WORKSET_ID   worksetID = (OM_WORKSET_ID)hPage;
    POM_OBJECT pObj;
    POM_OBJECTDATA     pData;
    WB_END_OF_PAGE  endOfPage;

    DebugEntry(wbPageSave);

    //
    // Get the first object
    //
    result = OM_ObjectH(m_pomClient,
                           m_hWSGroup,
                           worksetID,
                           0,
                           &pObj,
                           FIRST);
    if (result == OM_RC_NO_SUCH_OBJECT)
    {
        // This can happen on an empty page, not an error
        TRACE_OUT(("No objects left, quitting with good return"));
        result = 0;
        DC_QUIT;
    }

    if (result != 0)
    {
        ERROR_OUT(("Error getting first object in page"));
        DC_QUIT;
    }

    //
    // Loop through the objects
    //
    for( ; ; )
    {
        //
        // Get a pointer to the object
        //
        result = OM_ObjectRead(m_pomClient,
                           m_hWSGroup,
                           worksetID,
                           pObj,
                           &pData);
        if (result != 0)
        {
            ERROR_OUT(("Error reading object = %d", result));
            DC_QUIT;
        }

        //
        // Save the object data
        //
        rc = wbObjectSave(hFile,
                      (LPBYTE) pData->data,
                      pData->length);

        //
        // The return code is tested after we have released the object because
        // we must always do the release.
        //

        //
        // Release the object
        //
        OM_ObjectRelease(m_pomClient,
                     m_hWSGroup,
                     worksetID,
                     pObj,
                     &pData);

        //
        // Now test the write return code
        //
        if (rc != 0)
        {
            result = rc;
            ERROR_OUT(("Error writing object data = %d", result));
            DC_QUIT;
        }

        //
        // Get the next object
        //
        result = OM_ObjectH(m_pomClient,
                            m_hWSGroup,
                            worksetID,
                            pObj,
                            &pObj,
                            AFTER);
        if (result == OM_RC_NO_SUCH_OBJECT)
        {
            TRACE_OUT(("No objects left, quitting with good return"));
            result = 0;
            DC_QUIT;
        }
    }


DC_EXIT_POINT:

    //
    // If we have successfully written the page contents, we write an end-of-
    // page marker to the file.
    //
    if (result == 0)
    {
        //
        // Set the end of page object details
        //
        ZeroMemory(&endOfPage, sizeof(endOfPage));

        endOfPage.length = sizeof(endOfPage);
        endOfPage.type   = TYPE_END_OF_PAGE;

        //
        // Write the end-of-page object
        //
        result = wbObjectSave(hFile,
                          (LPBYTE) &endOfPage,
                          sizeof(endOfPage));
        if (result != 0)
        {
            ERROR_OUT(("Error writing end-of-page = %d", result));
        }
    }

    DebugExitDWORD(wbPageSave, result);
    return(result);
}




//
//
// Name:    wbPageLoad
//
// Purpose: Load the contents of a single page from file.
//
// Returns: Error code
//
//
void WbClient::wbPageLoad(void)
{
    UINT            result = 0;
    UINT            type;
    POM_OBJECT      pObj;
    POM_OBJECTDATA  pData  = NULL;
    PWB_GRAPHIC     pGraphic = NULL;
    WB_PAGE_HANDLE  hPage = m_loadPageHandle;
    WB_PAGE_HANDLE  hNewPage;
    UINT            postDelay = 0;

    DebugEntry(wbPageLoad);
    TRACE_OUT(("Entered wbPageLoad for page %d", (UINT) hPage));

    //
    // Check the load state - if we're not loading, then quit (can happen if
    // the load is cancelled).
    //
    if (m_loadState == LOAD_STATE_EMPTY)
    {
        TRACE_OUT(("Load has been cancelled - abandoning page load"));
        DC_QUIT;
    }

    //
    // Check that we have a full complement of ready pages before starting
    // the load.
    //
    if (!wbCheckReadyPages())
    {
        //
        // There are not enough pages worksets ready to be used.  We exit now
        // to allow the page to be made ready before we continue.  We set up a
        // delay on the message that will be used to restart the process to
        // allow the worksets to be opened before we get back in here.
        //
        postDelay = 200;
        DC_QUIT;
    }

    //
    // If we are waiting to add a new page, get the handle of the page we
    // expect to add next here.  (We have to do this as ObMan requires that
    // we allocate memory for the object in the correct workset, but we do
    // not want to actually add the page here because we may not need it.)
    //
    if (m_loadState == LOAD_STATE_PENDING_NEW_PAGE)
    {
        hNewPage = wbGetReadyPageHandle();

        //
        // If we cannot get a ready page - we must have run out of pages (we
        // have already done a check on the availability of ready pages above).
        // If we cannot get a new page we continue using the old.
        //
        if (hNewPage != WB_PAGE_HANDLE_NULL)
        {
            hPage = hNewPage;
        }
    }

    //
    // Read the next object
    //
    result = wbObjectLoad(m_hLoadFile,
                        (OM_WORKSET_ID)hPage,
                        &pGraphic);
    if (result != 0)
    {
        ERROR_OUT(("Error reading object = %d", result));
        DC_QUIT;
    }

    pData = ObjectDataPtrFromGraphic(pGraphic);
    type = pGraphic->type;

    //
    // Process the object according to type
    //

    //
    // End of file marker
    //
    if (type == TYPE_END_OF_FILE)
    {
        //
        // Let the Front End know that the load has completed
        //
        TRACE_OUT(("Posting WBP_EVENT_LOAD_COMPLETE"));
        WBP_PostEvent(
                 0,                        // No delay
                 WBP_EVENT_LOAD_COMPLETE,  // Load completed
                 0,                        // No parameters
                 0);

        //
        // Leave now - the file will be closed below
        //
        DC_QUIT;
    }

    //
    // It is not an end-of file object.  So it must be either an end-of page
    // or a graphic object.  In either case we may already have flagged the
    // need to add a new page.
    //

    //
    // Add a new page (if necessary)
    //
    if (m_loadState == LOAD_STATE_PENDING_NEW_PAGE)
    {
        //
        // If we could not get a new page handle above leave with an error
        //
        if (hPage == m_loadPageHandle)
        {
            ERROR_OUT(("Run out of pages for load"));
            result = WB_RC_TOO_MANY_PAGES;
            DC_QUIT;
        }

        //
        // Add a new page after the current page.  The new page handle is saved
        // in the client details.
        //
        result = wbPageAdd(m_loadPageHandle,
                       PAGE_AFTER,
                       &(m_loadPageHandle),
                       DONT_RESET_CHANGED_FLAG);
        if (result != 0)
        {
            ERROR_OUT(("Failed to add page"));
            DC_QUIT;
        }

        //
        // Check that we got the page handle we expected
        //
        ASSERT((hPage == m_loadPageHandle));

        //
        // Show that we are no longer waiting for a new page
        //
        m_loadState = LOAD_STATE_LOADING;
    }

    //
    // End of page marker
    //
    if (type == TYPE_END_OF_PAGE)
    {
        TRACE_OUT(("End of page object"));

        //
        // Discard the object
        //
        OM_ObjectDiscard(m_pomClient,
                     m_hWSGroup,
                     (OM_WORKSET_ID)hPage,
                     &pData);
        pData = NULL;

        //
        // Set the load state to "pending new page" and leave the routine
        // immediately.  The process continues when we return to this routine.
        //
        m_loadState = LOAD_STATE_PENDING_NEW_PAGE;

        //
        // Exit (we post ourselves a message below to get us back into this
        // routine later).
        //
        postDelay = 100;
        DC_QUIT;
    }

    //
    // The object is a standard graphic
    //
    TRACE_OUT(("Graphic object"));

    //
    // Add the object to the page
    //
    result = OM_ObjectAdd(m_pomClient,
                            m_hWSGroup,
                            (OM_WORKSET_ID)hPage,
                            &pData,
                            sizeof(WB_GRAPHIC),
                            &pObj,
                            LAST);
    if (result != 0)
    {
        DC_QUIT;
    }

    //
    // Show that we have finished with the object
    //
    pGraphic = NULL;
    pData  = NULL;

DC_EXIT_POINT:

    //
    // If we still have the object - discard it
    //
    if (pData != NULL)
    {
        TRACE_OUT(("Discarding object"));
        OM_ObjectDiscard(m_pomClient,
                     m_hWSGroup,
                     (OM_WORKSET_ID)hPage,
                     &pData);
    }

    //
    // If an error occurred or we have reached the end-of-file - close the
    // file.
    //
    if ((result != 0) || (type == TYPE_END_OF_FILE))
    {
        CloseHandle(m_hLoadFile);
        m_hLoadFile = INVALID_HANDLE_VALUE;

        //
        // If the final result is an error - post an error message to ourselves
        //
        if (result != 0)
        {
            TRACE_OUT(("Posting WBP_EVENT_LOAD_FAILED"));
            WBP_PostEvent(
                   0,                      // No delay
                   WBP_EVENT_LOAD_FAILED,  // Load the next object
                   0,                      // No parameters
                   0);
        }

        //
        // Record that we are no longer in the load process
        //
        m_loadState = LOAD_STATE_EMPTY;
        TRACE_OUT(("Moved load state to LOAD_STATE_EMPTY"));
    }

    //
    // send a message to load the next page, unless the load has been
    // cancelled
    //
    if (m_loadState != LOAD_STATE_EMPTY)
    {
        //
        // We have not reached the end-of-file and there has been no error.
        // Post a message to ourselves to continue the load process.
        //
        TRACE_OUT(("Posting WBPI_EVENT_LOAD_NEXT"));
        WBP_PostEvent(postDelay,                // With delay
                 WBPI_EVENT_LOAD_NEXT,     // Load the next object
                 0,                        // No parameters
                 0);
    }

    DebugExitVOID(wbPageLoad);
}



//
//
// Name:    wbObjectLoad
//
// Purpose: Load a single object from file.
//
// Returns: Error code
//
//
UINT WbClient::wbObjectLoad
(
    HANDLE          hFile,
    WB_PAGE_HANDLE  hPage,
    PPWB_GRAPHIC    ppGraphic
)
{
    UINT            result = 0;
    OM_WORKSET_ID   worksetID = (OM_WORKSET_ID)hPage;
    UINT            length;
    ULONG           cbSizeRead;
    POM_OBJECTDATA     pData  = NULL;
    PWB_GRAPHIC     pGraphic = NULL;

    DebugEntry(wbObjectLoad);

    TRACE_OUT(("Entered wbObjectLoad for page %d", (UINT) hPage));

    //
    // Read the next object's length
    //
    if ( (! ReadFile(hFile, (void *) &length, sizeof(length), &cbSizeRead, NULL)) ||
        (cbSizeRead != sizeof(length)) ||
        (length > OM_MAX_OBJECT_SIZE) ||
        (length == 0) )
    {
        //
        // Make sure we return a sensible error.
        //
        ERROR_OUT(("reading object length, win32 err=%d, length=%d", GetLastError(), length));
        result = WB_RC_BAD_FILE_FORMAT;
        DC_QUIT;
    }

    //
    // Allocate memory for the object
    //
    result = OM_ObjectAlloc(m_pomClient,
                          m_hWSGroup,
                          worksetID,
                          length,
                        &pData);
    if (result != 0)
    {
        ERROR_OUT(("Error allocating object = %d", result));
        DC_QUIT;
    }

    pData->length = length;
    pGraphic = GraphicPtrFromObjectData(pData);

    //
    // Read the object into memory
    //
    if ( (! ReadFile(hFile, (void *) pGraphic, length, &cbSizeRead, NULL)) ||
           (cbSizeRead != length))
    {
        //
        // Make sure we return a sensible error.
        //
        ERROR_OUT((
            "Reading object from file: win32 err=%d, asked for %d got %d bytes",
            GetLastError(),
            length,
            cbSizeRead));
        result = WB_RC_BAD_FILE_FORMAT;
        DC_QUIT;
    }

    //
    // Validate the object type
    //
    switch (pGraphic->type)
    {
        //
        // Standard type, end-of-page or end-of-file
        //
        case TYPE_END_OF_PAGE:
        case TYPE_END_OF_FILE:
        case TYPE_GRAPHIC_FREEHAND:
        case TYPE_GRAPHIC_LINE:
        case TYPE_GRAPHIC_RECTANGLE:
        case TYPE_GRAPHIC_FILLED_RECTANGLE:
        case TYPE_GRAPHIC_ELLIPSE:
        case TYPE_GRAPHIC_FILLED_ELLIPSE:
        case TYPE_GRAPHIC_TEXT:
        case TYPE_GRAPHIC_DIB:
            break;

        //
        // Unrecognized object type - probably wrong version
        //
        default:
            result = WB_RC_BAD_FILE_FORMAT;
            DC_QUIT;
            break;
    }

    //
    // For graphic objects, set the flag in the object header showing that it
    // was loaded from file.  Add our user ID so we know where it came from.
    //
    if ( (pGraphic->type != TYPE_END_OF_FILE) &&
       (pGraphic->type != TYPE_END_OF_PAGE))
    {
        pGraphic->loadedFromFile = TRUE;
        pGraphic->loadingClientID = m_clientNetID;
    }

    *ppGraphic = pGraphic;

DC_EXIT_POINT:

    //
    // If an error has occurred - discard the object (if we have it)
    //
    if ((result != 0) && (pData != NULL))
    {
        OM_ObjectDiscard(m_pomClient,
                     m_hWSGroup,
                     worksetID,
                     &pData);
    }

    DebugExitDWORD(wbObjectLoad, result);
    return(result);
}



//
//
// Name:    wbPageHandleFromNumber
//
// Purpose: Return the handle of a page specified by page number
//
// Returns: Error code
//
//
UINT WbClient::wbPageHandleFromNumber
(
    UINT            pageNumber,
    PWB_PAGE_HANDLE phPage
)
{
    UINT        result = 0;
    WB_PAGE_HANDLE  hPage;
    PWB_PAGE_ORDER  pPageOrder = &(m_pageOrder);

    DebugEntry(wbPageHandleFromNumber);

    //
    // Validate the requested page number
    //
    if ((pageNumber < 1)|| (pageNumber > WB_MAX_PAGES))
    {
        result = WB_RC_BAD_PAGE_NUMBER;
        DC_QUIT;
    }

    if (pageNumber > pPageOrder->countPages)
    {
        result = WB_RC_NO_SUCH_PAGE;
        DC_QUIT;
    }

    //
    // Get the page handle
    //
    hPage = (pPageOrder->pages)[pageNumber - 1];

    //
    // Check that this page is in use
    //
    if (GetPageState(hPage)->state != PAGE_IN_USE)
    {
        ERROR_OUT(("Page list is bad"));
    }

    //
    // Return the page handle
    //
    *phPage = hPage;

DC_EXIT_POINT:
    DebugExitDWORD(wbPageHandleFromNumber, result);
    return(result);
}




//
//
// Name:    wbPageClear
//
// Purpose: Clear the specified page of all graphic objects
//
// Returns: Error code
//
//
UINT WbClient::wbPageClear
(
    WB_PAGE_HANDLE  hPage,
    UINT            changedFlagAction
)
{
    UINT            result = 0;

    DebugEntry(wbPageClear);

    //
    // Show that the contents have changed, if required.
    //
    if (changedFlagAction == RESET_CHANGED_FLAG)
    {
        m_changed = TRUE;
        TRACE_OUT(("Changed flag now TRUE"));
    }

    //
    // Request that the page be cleared
    //
    result = OM_WorksetClear(m_pomClient,
                           m_hWSGroup,
                           (OM_WORKSET_ID)hPage);


    DebugExitDWORD(wbPageClear, result);
    return(result);
}




//
//
// Name:    wbPageClearConfirm
//
// Purpose: Complete the clearing of a page
//
// Returns: Error code
//
//
void WbClient::wbPageClearConfirm(WB_PAGE_HANDLE hPage)
{
    DebugEntry(wbPageClearConfirm);

    //
    // Request that the page be cleared
    //
    OM_WorksetClearConfirm(m_pomClient,
                         m_hWSGroup,
                         (OM_WORKSET_ID)hPage);


    //
    // Check the load state to see whether we are waiting to load the
    // contents
    //
    if (m_loadState == LOAD_STATE_PENDING_CLEAR)
    {
        //
        // We are waiting to load.  If there is only one page available (ie the
        // one that has just been cleared) we are ready to load, otherwise we
        // wait for the page deletes to happen.
        //
        if ((m_pageOrder).countPages == 1)
        {
            //
            // Start the load proper
            //
            wbStartContentsLoad();
        }
        else
        {
            //
            // Move the load state to show that we are waiting for all the pages
            // to be deleted.
            //
            m_loadState = LOAD_STATE_PENDING_DELETE;
            TRACE_OUT(("Moved load state to LOAD_STATE_PENDING_DELETE"));
        }
    }

    DebugExitVOID(wbPageClearConfirm);
}




//
//
// Name:    wbCheckReadyPages
//
// Purpose: Check that we have enough worksets open for the local user to
//          use immediately (during page adds).
//
// Returns: None
//
//
BOOL WbClient::wbCheckReadyPages(void)
{
    BOOL         bResult = TRUE;
    WB_PAGE_HANDLE hNewPage;
    UINT       countPages = m_pageOrder.countPages;
    UINT       countReadyPages = m_countReadyPages;

    //
    // If we have opened all the worksets
    //
    if (countReadyPages == WB_MAX_PAGES)
    {
        //
        // Quit there are no more worksets that we can open
        //
        DC_QUIT;
    }

    //
    // If the number of pages in use is getting close to the number of ready
    // pages.
    //
    if (   (countReadyPages >= PREINITIALIZE_PAGES)
        && (countPages <= (countReadyPages - PREINITIALIZE_PAGES)))
    {
        DC_QUIT;
    }

    //
    // If the number of pages ready is less than the required cache size,
    // open another one.
    //
    hNewPage = wbGetEmptyPageHandle();
    if (hNewPage != WB_PAGE_HANDLE_NULL)
    {
        //
        // Open the workset associated with the page
        //
        wbPageWorksetOpen(hNewPage, OPEN_LOCAL);
    }

    bResult = FALSE;

DC_EXIT_POINT:
    return(bResult);
}




//
//
// Name:    wbPageAdd
//
// Purpose: Add a new (blank) page in a specified position
//
// Returns: Error code
//
//
UINT WbClient::wbPageAdd
(
    WB_PAGE_HANDLE  hRefPage,
    UINT            where,
    PWB_PAGE_HANDLE phPage,
    UINT            changedFlagAction
)
{
    UINT            result = 0;
    WB_PAGE_HANDLE  hNewPage;

    DebugEntry(wbPageAdd);

    //
    // Check that there are not too many pages already
    //
    if (m_pageOrder.countPages == WB_MAX_PAGES)
    {
        result = WB_RC_TOO_MANY_PAGES;
        DC_QUIT;
    }

    //
    // Validate the specified reference page
    //
    ASSERT(GetPageState(hRefPage)->state == PAGE_IN_USE);

    //
    // Get a handle for the new page
    //
    hNewPage = wbGetReadyPageHandle();

    //
    // If there are no handles ready we attempt to create one and return a
    // busy indication.
    //
    if (hNewPage == WB_PAGE_HANDLE_NULL)
    {
        result = WB_RC_BUSY;
        DC_QUIT;
    }

    //
    // Make the internal update immediately - this allows the client to
    // reference the new page as soon as this function has returned.
    //
    wbPagesPageAdd(hRefPage, hNewPage, where);

    //
    // Update the Page Control Object
    //
    result = wbWritePageControl(FALSE);
    if (result != 0)
    {
        wbError();
        DC_QUIT;
    }

    //
    // Show that the contents have changed (if required).
    //
    if (changedFlagAction == RESET_CHANGED_FLAG)
    {
        m_changed = TRUE;
        TRACE_OUT(("Changed flag now TRUE"));
    }

    //
    // Return the handle of the new page
    //
    *phPage = hNewPage;

DC_EXIT_POINT:
    //
    // If we successfully added the page, or could not get a spare page
    // handle, attempt to create a spare one for next time.
    //
    if ((result == 0) || (result == WB_RC_BUSY))
    {
        wbCheckReadyPages();
    }

    DebugExitDWORD(wbPageAdd, result);
    return(result);
}




//
//
// Name:    wbPageMove
//
// Purpose: Move a page relative to another page
//
// Returns: Error code
//
//
UINT WbClient::wbPageMove
(
    WB_PAGE_HANDLE  hRefPage,
    WB_PAGE_HANDLE  hPage,
    UINT            where
)
{
    UINT       result = 0;
    PWB_PAGE_ORDER pPageOrder = &(m_pageOrder);

    DebugEntry(wbPageMove);

    //
    // Extract the page to be moved
    //
    wbPageOrderPageDelete(pPageOrder, hPage);

    //
    // Add it back at its new position
    //
    wbPageOrderPageAdd(pPageOrder, hRefPage, hPage, where);

    //
    // Update the page control object
    //
    result = wbWritePageControl(FALSE);
    if (result != 0)
    {
        wbError();
        DC_QUIT;
    }

    //
    // Show that the contents have changed
    //
    m_changed = TRUE;
    TRACE_OUT(("Changed flag now TRUE"));

DC_EXIT_POINT:
    DebugExitDWORD(wbPageMove, result);
    return(result);
}





//
//
// Name:    wbPageHandle
//
// Purpose: Return a page handle.  The page for which the handle is
//          required can be specified relative to another page or as the
//          first/last page.
//
// Returns: Error code
//
//
UINT WbClient::wbPageHandle
(
    WB_PAGE_HANDLE  hRefPage,
    UINT            where,
    PWB_PAGE_HANDLE phPage
)
{
    UINT       result = 0;
    UINT       pageNumber;
    PWB_PAGE_ORDER pPageOrder = &(m_pageOrder);
    POM_WORKSET_ID pPage = pPageOrder->pages;
    WB_PAGE_HANDLE hPage;

    DebugEntry(wbPageHandle);

    //
    // Check the relative position
    //
    switch (where)
    {
        case PAGE_FIRST:
            hPage = pPage[0];
            break;

        case PAGE_LAST:
            hPage = pPage[pPageOrder->countPages - 1];
            break;

        case PAGE_AFTER:
        case PAGE_BEFORE:
            //
            // Validate the specified reference page
            //
            ASSERT(GetPageState(hRefPage)->state == PAGE_IN_USE);

            //
            // Get the page number of the reference page
            //
            pageNumber = wbPageOrderPageNumber(pPageOrder, hRefPage);
            TRACE_OUT(("Reference page number is %d", pageNumber));

            //
            // Get the page number of the required page
            //
            pageNumber = (UINT)(pageNumber + ((where == PAGE_AFTER) ? 1 : -1));
            TRACE_OUT(("New page number is %d", pageNumber));

            //
            // Check that the new page is valid
            //
            TRACE_OUT(("Number of pages is %d", pPageOrder->countPages));
            if (   (pageNumber < 1)
                || (pageNumber > pPageOrder->countPages))
            {
                TRACE_OUT(("Returning WB_RC_NO_SUCH_PAGE"));
                result = WB_RC_NO_SUCH_PAGE;
                DC_QUIT;
            }

            //
            // Get the handle of the page
            //
            hPage = pPage[pageNumber - 1];
            TRACE_OUT(("Returning handle %d", (UINT) hPage));
            break;
    }

    //
    // Return the page handle
    //
    *phPage = hPage;

DC_EXIT_POINT:
    DebugExitDWORD(wbPageHandle, result);
    return(result);
}



//
//
// Name:    wbGraphicSelectPrevious
//
// Purpose: Return the next graphic object in the specified page whose
//          bounding rectangle contains the specified point.  The function
//          starts with the graphic whose handle is given as parameter and
//          will return this graphic if it contains the point.
//
// Returns: Error code
//
//
UINT WbClient::wbGraphicSelectPrevious
(
    WB_PAGE_HANDLE      hPage,
    LPPOINT             pPoint,
    WB_GRAPHIC_HANDLE   hGraphic,
    PWB_GRAPHIC_HANDLE  phGraphic
)
{
    UINT                result = 0;
    OM_WORKSET_ID       worksetID = (OM_WORKSET_ID)hPage;
    PWB_GRAPHIC         pGraphic;
    POM_OBJECTDATA         pData;
    RECT                rect;

    DebugEntry(wbGraphicSelectPrevious);

    *phGraphic = (WB_GRAPHIC_HANDLE) NULL;

    //
    // Loop back through the objects starting at the reference point
    //
    do
    {
        //
        // Get the object from ObMan
        //
        result = OM_ObjectRead(m_pomClient,
                           m_hWSGroup,
                           worksetID,
                           hGraphic,
                           &pData);

        //
        // Leave the loop if error on read - we do not need to do the release
        //
        if (result != 0)
        {
            DC_QUIT;
        }

        pGraphic = GraphicPtrFromObjectData(pData);

        //
        // Extract the bounding rectangle of the object
        //
        RECT_FROM_TSHR_RECT16(&rect, pGraphic->rectBounds);

        //
        // Release the object
        //
        OM_ObjectRelease(m_pomClient,
                     m_hWSGroup,
                     worksetID,
                     hGraphic,
                     &pData);

        //
        // Check whether the point lies in bounds
        //
        if (PtInRect(&rect, *pPoint))
        {
            //
            // Set the result handle
            //
            TRACE_OUT(("Returning graphic handle"));
            *phGraphic = hGraphic;
            DC_QUIT;
        }

        //
        // Get the next object to test
        //
        result = OM_ObjectH(m_pomClient,
                            m_hWSGroup,
                            worksetID,
                             hGraphic,
                             &hGraphic,
                            BEFORE);
    }
    while (result == 0);

    //
    // Correct the return code (if necessary)
    //
    if (result == OM_RC_NO_SUCH_OBJECT)
    {
        TRACE_OUT(("Returning WB_RC_NO_SUCH_GRAPHIC"));
        result = WB_RC_NO_SUCH_GRAPHIC;
    }

DC_EXIT_POINT:
    DebugExitDWORD(wbGraphicSelectPrevious, result);
    return(result);
}




//
//
// Name:    wbCoreExitHandler
//
// Purpose: Exit handler for the Whiteboard Core. This handler is
//          registered with the Utilities by the WBP_Start call. It is
//          deregistered by the client deregistration process, so it is
//          only called when an abnormal termination occurs.
//
// Returns: None
//
//
void CALLBACK wbCoreExitHandler(LPVOID clientData)
{
    WbClient*    pwbClient = (WbClient *)clientData;

    pwbClient->wbExitHandler();
}


void WbClient::wbExitHandler(void)
{
    DebugEntry(wbExitHandler);

    //
    // Leave the current call if there is one, removing any locks etc.
    //
    wbLeaveCall();

    //
    // Dereg from call manager
    //
    if (m_pcmClient != NULL)
    {
        CMS_Deregister(&(m_pcmClient));
    }

    //
    // Dereg exit handler
    //
    if (m_subState >= STATE_START_REGISTERED_EXIT)
    {
        UT_DeregisterExit(m_putTask, wbCoreExitHandler, this);
    }

    //
    // Dereg obman
    //
    if (m_subState >= STATE_START_REGISTERED_OM)
    {
        OM_Deregister(&m_pomClient);
    }

    //
    // Dereg event handler
    //
    if (m_subState >= STATE_START_REGISTERED_EVENT)
    {
        UT_DeregisterEvent(m_putTask, wbCoreEventHandler, this);
    }

    //
    // delete ourself!
    //
    delete this;

    DebugExitVOID(wbExitHandler);
}



//
//
// Name:    wbCoreEventHandler
//
// Purpose: Event handler for the Whiteboard Core. This handler is
//          registered with the Utilities by the WBP_Start call.
//
// Params:  clientData  - pointer to the data stored for a client
//          event       - event identifier
//          param1      - word event parameter (content depends on event)
//          param2      - long event parameter (content depends on event)
//
// Returns: Error code
//
//
BOOL CALLBACK wbCoreEventHandler
(
    LPVOID      clientData,
    UINT        event,
    UINT_PTR    param1,
    UINT_PTR    param2
)
{
    WbClient*   pwbClient = (WbClient *)clientData;

    return(pwbClient->wbEventHandler(event, param1, param2));
}


BOOL WbClient::wbEventHandler
(
    UINT    event,
    UINT_PTR param1,
    UINT_PTR param2
)
{
    POM_EVENT_DATA16    pEvent16 = (POM_EVENT_DATA16) &param1;
    POM_EVENT_DATA32    pEvent32 = (POM_EVENT_DATA32) &param2;
    BOOL                processed = FALSE;

    DebugEntry(wbEventHandler);

    TRACE_OUT(("event %d, param1 %d, param2 %d", event, param1, param2));

    switch (event)
    {
        //
        // Confirmation that we have registered with a workset group
        //
        case OM_WSGROUP_REGISTER_CON:
            TRACE_OUT(("OM_WSGROUP_REGISTER_CON %x %x",param1,param2));
            processed = wbOnWsGroupRegisterCon(param1, param2);
            break;

        //
        // Confirmation that we have moved a workset group
        //
        case OM_WSGROUP_MOVE_CON:
            TRACE_OUT(("OM_WSGROUP_MOVE_CON %x %x",param1,param2));
            processed = wbOnWsGroupMoveCon(param1, param2);
            break;

        //
        // Our workset group has been moved
        //
        case OM_WSGROUP_MOVE_IND:
            TRACE_OUT(("OM_WSGROUP_MOVE_IND %x %x",param1,param2));
            processed = wbOnWsGroupMoveInd(param1, param2);
            break;

        //
        // A workset has been created - we do nothing
        //
        case OM_WORKSET_NEW_IND:
            TRACE_OUT(("OM_WORKSET_NEW_IND %x %x",param1,param2));
            processed = TRUE;
            break;

        //
        // A workset has been opened
        //
        case OM_WORKSET_OPEN_CON:
            TRACE_OUT(("OM_WORKSET_OPEN_CON %x %x",param1,param2));
            processed = wbOnWorksetOpenCon(param1, param2);
            break;

        //
        // A workset has been locked
        //
        case OM_WORKSET_LOCK_CON:
            TRACE_OUT(("OM_WORKSET_LOCK_CON %x %x",param1,param2));
            processed = wbOnWorksetLockCon(param1, param2);
            break;

        //
        // A workset has been unlocked
        //
        case OM_WORKSET_UNLOCK_IND:
            TRACE_OUT(("OM_WORKSET_UNLOCK_IND %x %x",param1,param2));
            processed = wbOnWorksetUnlockInd(param1, param2);
            break;

        //
        // ObMan has run out of resources
        //
        case OM_OUT_OF_RESOURCES_IND:
            TRACE_OUT(("OM_OUT_OF_RESOURCES_IND %x %x",param1,param2));
            wbError();
            processed = TRUE;
            break;

        //
        // A workset has been cleared
        //
        case OM_WORKSET_CLEAR_IND:
            TRACE_OUT(("OM_WORKSET_CLEAR_IND %x %x",param1,param2));
            processed = wbOnWorksetClearInd(param1, param2);
            break;

        //
        // A new object has been added to a workset
        //
        case OM_OBJECT_ADD_IND:
            TRACE_OUT(("OM_OBJECT_ADD_IND %x %x",param1,param2));
            processed = wbOnObjectAddInd(param1, (POM_OBJECT)param2);
            break;

        //
        // An object has been moved
        //
        case OM_OBJECT_MOVE_IND:
            TRACE_OUT(("OM_OBJECT_MOVE_IND %x %x",param1,param2));
            processed = wbOnObjectMoveInd(param1, param2);
            break;

        //
        // An object has been deleted
        //
        case OM_OBJECT_DELETE_IND:
            TRACE_OUT(("OM_OBJECT_DELETE_IND %x %x",param1,param2));
            processed = wbOnObjectDeleteInd(param1, (POM_OBJECT)param2);
            break;

        //
        // An object has been updated
        //
        case OM_OBJECT_UPDATE_IND:
            TRACE_OUT(("OM_OBJECT_UPDATE_IND %x %x",param1,param2));
            processed = wbOnObjectUpdateInd(param1, (POM_OBJECT)param2);
            break;

        //
        // An object has been updated
        //
        case OM_OBJECT_REPLACE_IND:
            TRACE_OUT(("OM_OBJECT_REPLACE_IND %x %x",param1,param2));
            processed = wbOnObjectReplaceInd(param1, (POM_OBJECT)param2);
            break;

        //
        // Load chaining event
        //
        case WBPI_EVENT_LOAD_NEXT:
            TRACE_OUT(("WBPI_EVENT_LOAD_NEXT"));
            wbPageLoad();
            processed = TRUE;
            break;

        //
        // Whiteboard page clear indication
        //
        case WBP_EVENT_PAGE_CLEAR_IND:
            TRACE_OUT(("WBP_EVENT_PAGE_CLEAR_IND"));
            processed = wbOnWBPPageClearInd((WB_PAGE_HANDLE) param1);
            break;

        //
        // Whiteboard lock notification
        //
        case WBP_EVENT_PAGE_ORDER_LOCKED:
        case WBP_EVENT_CONTENTS_LOCKED:
            TRACE_OUT(("WBP_EVENT_xxx_LOCKED (%#hx) %#hx %#lx",
                     event,
                     param1,
                     param2));
            processed = wbOnWBPLock();
            break;

        //
        // Whiteboard lock failure notification
        //
        case WBP_EVENT_LOCK_FAILED:
            TRACE_OUT(("WBP_EVENT_LOCK_FAILED %x %x",param1,param2));
            processed = wbOnWBPLockFailed();
            break;

        //
        // Whiteboard Unlock notification
        //
        case WBP_EVENT_UNLOCKED:
            TRACE_OUT(("WBP_EVENT_UNLOCKED %x %x",param1,param2));
            processed = wbOnWBPUnlocked();
            break;

        //
        // Whiteboard Page Order Updated notification
        //
        case WBP_EVENT_PAGE_ORDER_UPDATED:
            TRACE_OUT(("WBP_EVENT_PAGE_ORDER_UPDATED %x %x",
                     param1,
                     param2));
            processed = wbOnWBPPageOrderUpdated();
            break;

        //
        // We are not interested in this event - do nothing
        //
        default:
            TRACE_OUT(("Event ignored"));
            break;
    } // Switch on event type


    DebugExitBOOL(wbEventHandler, processed);
    return(processed);
}




//
// wbJoinCallError
//
// This function should be called in STATE_REGISTERING only.
//
//
void WbClient::wbJoinCallError(void)
{
    DebugEntry(wbJoinCallError);

    ASSERT((m_state == STATE_REGISTERING));

    //
    // Post a registration failed message to the client
    //
    TRACE_OUT(("Posting WBP_EVENT_REGISTER_FAILED"));
    WBP_PostEvent(
               0,                              // No delay
               WBP_EVENT_JOIN_CALL_FAILED,     // Failure
               0,                              // No parameters
               0);

    //
    // Tidy up after the attempt to join the call
    //
    wbLeaveCall();

    DebugExitVOID(wbJoinCallError);
}




//
// wbError
//
void WbClient::wbError(void)
{
    DebugEntry(wbError);

    //
    // An error has occurred during Core processing.  We act according to the
    // current state.
    //
    switch (m_state)
    {
        //
        // If the error has occurred during registration, post a registration
        // failure message to the client and cancel registration.
        //
        case STATE_REGISTERING:
            wbJoinCallError();
            break;

        //
        // If the error occurred during normal running, we tell the client who
        // must deregister.
        //
        case STATE_IDLE:
            //
            // Only take action if we are not already in fatal error state
            //
            if (m_errorState == ERROR_STATE_EMPTY)
            {
                //
                // Post an error message to the client
                //
                TRACE_OUT(("Posting WBP_EVENT_ERROR"));
                WBP_PostEvent(
                     0,                            // No delay
                     WBP_EVENT_ERROR,              // Error
                     0,                            // No parameters
                     0);

                //
                // Record that an error has occurred
                //
                m_errorState = ERROR_STATE_FATAL;
                TRACE_OUT(("Moved error state to ERROR_STATE_FATAL"));
            }
            break;

        //
        // Client is in an unknown state
        //
        default:
            ERROR_OUT(("Bad main state for call"));
            break;
    }

    DebugExitVOID(wbError);
}



//
//
// Name:    wbOnWSGroupMoveCon
//
// Purpose: Routine processing OM_WSGROUP_MOVE_CON events.
//
//
BOOL WbClient::wbOnWsGroupMoveCon
(
    UINT_PTR param1,
    UINT_PTR param2
)
{
    POM_EVENT_DATA16 pEvent16 = (POM_EVENT_DATA16) &param1;
    POM_EVENT_DATA32 pEvent32 = (POM_EVENT_DATA32) &param2;
    BOOL            processed = FALSE;
    UINT rc;
    BOOL   failedToJoin     = FALSE;

    DebugEntry(wbOnWsGroupMoveCon);

    //
    // Check that this is the event we are expecting
    //
    if (pEvent32->correlator != m_wsgroupCorrelator)
    {
        DC_QUIT;
    }

    //
    // Show that we have processed the event
    //
    processed = TRUE;

    //
    // Test for the correct state
    //
    if (m_subState != STATE_REG_PENDING_WSGROUP_MOVE)
    {
        //
        // We are not in the correct state for this event - this is an internal
        // error.
        //
        ERROR_OUT(("Wrong state for WSGroupMoveCon"));
    }

    //
    // Check that the return code for the move is OK
    //
    if (pEvent32->result != 0)
    {
        //
        // Moving the workset group failed - post a "join call failed" message
        // to the front-end.
        //
        TRACE_OUT(("WSGroup move failed, result = %d", pEvent32->result));
        failedToJoin = TRUE;
        DC_QUIT;
    }

    //
    // The WSGroupMove has completed successfully.  Replace our local user
    // object by deleting the current one (we must have one to get to this
    // point) and adding a new one.
    //
    // The reason we do this is that our existing user object has been moved
    // from the local domain into a call, but since it is in a non-persistent
    // workset, the Obman behaviour for this object when the call ends is
    // undefined.  So we replace the object to get a defined behaviour.
    //
    TRACE_OUT(("Deleting local user object"));
    rc = OM_ObjectDelete(m_pomClient,
                       m_hWSGroup,
                       USER_INFORMATION_WORKSET,
                       m_pObjLocal);
    if (rc != 0)
    {
        ERROR_OUT(("Error deleting local user object = %u", rc));
    }

    TRACE_OUT(("Adding new local user object"));
    rc = wbAddLocalUserObject();
    if (rc != 0)
    {
        TRACE_OUT(("Failed to add local user object"));
        failedToJoin = TRUE;
        DC_QUIT;
    }

    //
    // Get the clients network ID, used in graphic objects to determine where
    // they are loaded.
    //
    if (!wbGetNetUserID())
    {
        //
        // Tidy up (and post an error event to the client)
        //
        ERROR_OUT(("Failed to get user ID, rc %u", rc));
        failedToJoin = TRUE;
        DC_QUIT;
    }

    //
    // We added our user object successfully, so now wait for the
    // OBJECT_ADD_IND to arrive.
    //
    m_subState = STATE_REG_PENDING_NEW_USER_OBJECT;

DC_EXIT_POINT:
    if (failedToJoin)
    {
        //
        // We have failed to join the call, so clean up.
        //
        wbError();
    }

    DebugExitBOOL(wbOnWsGroupMoveCon, processed);
    return(processed);
}




//
//
// Name:    wbOnWSGroupMoveInd
//
// Purpose: Routine processing OM_WSGROUP_MOVE_IND events.
//
//
BOOL WbClient::wbOnWsGroupMoveInd
(
    UINT_PTR param1,
    UINT_PTR callID
)
{
    POM_EVENT_DATA16 pEvent16 = (POM_EVENT_DATA16) &param1;
    BOOL        processed = TRUE;

    DebugEntry(wbOnWsGroupMoveInd);

    if (callID != OM_NO_CALL)
    {
        TRACE_OUT(("Moved into new call"));
        DC_QUIT;
    }

    //
    // If we are registering, treat it as a failure to join the call,
    // otherwise let the client know about the network failure.
    //
    if (m_state == STATE_REGISTERING)
    {
        TRACE_OUT(("Call went down while registering"));
        wbError();
        DC_QUIT;
    }

    TRACE_OUT(("Posting WBP_EVENT_NETWORK_LOST"));
    WBP_PostEvent(0,
                 WBP_EVENT_NETWORK_LOST,      // Unlocked
                 0,                           // No parameters
                 0);

    //
    // Tidy up the User Information workset (the local client is now the
    // only user).  Note that since the user information workset it
    // non-persistent, Obman will delete the remote user objects for us.
    //

    //
    // - check we have opened the user workset
    //
    if ( (m_state    > STATE_REGISTERING) ||
         (m_subState > STATE_REG_PENDING_USER_WORKSET))
    {
        //
        // Delete the lock object.
        //
        if (m_pObjLock != NULL)
        {
            TRACE_OUT(("Deleting lock object %d", m_pObjLock));
            if (OM_ObjectDelete(m_pomClient,
                                     m_hWSGroup,
                                     PAGE_CONTROL_WORKSET,
                                     m_pObjLock) != 0)
            {
                ERROR_OUT(("Error deleting lock object"));
            }

            if (m_lockState == LOCK_STATE_GOT_LOCK)
            {
                //
                // If all is well at this point the unlock process will be
                // completed when the object delete ind is received.
                //
                m_lockState = LOCK_STATE_PENDING_DELETE;
                TRACE_OUT(("Moved to state LOCK_STATE_PENDING_DELETE"));
            }
            else
            {
                m_lockState = LOCK_STATE_EMPTY;
                TRACE_OUT(("Moved to state LOCK_STATE_EMPTY"));
            }
        }
    }

DC_EXIT_POINT:
    DebugExitBOOL(wbOnWSGroupMoveInd, processed);
    return(processed);
}




//
//
// Name:    wbOnWorksetClearInd
//
// Purpose: Routine processing OM_WORKSET_CLEAR_IND events.
//
// Returns: Error code
//
//
BOOL WbClient::wbOnWorksetClearInd
(
    UINT_PTR param1,
    UINT_PTR param2
)
{
    POM_EVENT_DATA16 pEvent16 = (POM_EVENT_DATA16) &param1;
    POM_EVENT_DATA32 pEvent32 = (POM_EVENT_DATA32) &param2;
    BOOL            processed = FALSE;

    DebugEntry(wbOnWorksetClearInd);

    //
    // Check that the workset group is ours
    //
    if (pEvent16->hWSGroup != m_hWSGroup)
    {
        ERROR_OUT(("Event for unknown workset group = %d", pEvent16->hWSGroup));
        DC_QUIT;
    }

    //
    // We will process the event
    //
    processed = TRUE;

    //
    // Process the event according to the workset ID
    //
    switch(pEvent16->worksetID)
    {
        //
        // Page Control Workset
        //
        case PAGE_CONTROL_WORKSET:
            ERROR_OUT(("Unexpected clear for Page Control Workset"));
            break;

        //
        // Lock Workset
        //
        case SYNC_CONTROL_WORKSET:
            ERROR_OUT(("Unexpected clear for Sync Control Workset"));
            break;

        //
        // User Information Workset
        //
        case USER_INFORMATION_WORKSET:
            ERROR_OUT(("Unexpected clear for User Information Workset"));
            break;

        //
        // Other (should be a Page Workset)
        //
        default:
            //
            // Tell the client that the page has been cleared - the client must then
            // confirm the clear.
            //
            TRACE_OUT(("Posting WBP_EVENT_PAGE_CLEAR_IND"));
            WBP_PostEvent(
               0,
               WBP_EVENT_PAGE_CLEAR_IND,
               pEvent16->worksetID,
               0);
            break;
    }


DC_EXIT_POINT:
    DebugExitBOOL(wbOnWorksetClearInd, processed);
    return(processed);
}




//
//
// Name:    wbOnWBPPageClearInd
//
// Purpose: Routine processing WBP_PAGE_CLEAR_IND events.
//
// Returns: Error code
//
//
BOOL WbClient::wbOnWBPPageClearInd(WB_PAGE_HANDLE  hPage)
{
    BOOL            processed;

    DebugEntry(wbOnWBPPageClearInd);

    //
    // This routine catches WB_PAGE_CLEAR_IND events posted to the client.
    // Because of the asynchronous nature of page order updates these can
    // sometimes have been sent previously for pages that are now no longer
    // in use. We trap these events here, confirm the clear to ObMan and
    // discard the event.
    //
    if (GetPageState(hPage)->state != PAGE_IN_USE)
    {
        TRACE_OUT(("Page is not in use - confirming workset clear immediately"));

        //
        // Accept the page clear immediately
        //
        wbPageClearConfirm(hPage);
        processed = TRUE;
    }
    else
    {
        //
        // If we get here the page is in use - so we must pass the event on to
        // the client.  Resetting the result code of this routine to "not
        // processed" will ask the utilities to pass it on to the next event
        // handler.
        //
        processed = FALSE;
    }


    DebugExitBOOL(wbOnWBPPageClearInd, processed);
    return(processed);
}




//
//
// Name:    wbOnObjectAddInd
//
// Purpose: Routine processing OM_OBJECT_ADD_IND events.
//
// Returns: Error code
//
//
BOOL WbClient::wbOnObjectAddInd
(
    UINT_PTR param1,
    POM_OBJECT pObj
)
{
    POM_EVENT_DATA16 pEvent16 = (POM_EVENT_DATA16) &param1;
    BOOL            processed = FALSE;

    DebugEntry(wbOnObjectAddInd);

    //
    // Check that the workset group is ours
    //
    if (pEvent16->hWSGroup != m_hWSGroup)
    {
        ERROR_OUT(("Event for unknown workset group = %d", pEvent16->hWSGroup));
        DC_QUIT;
    }

    //
    // We will process the event
    //
    processed = TRUE;

    //
    // Process the event according to the workset ID
    //
    switch(pEvent16->worksetID)
    {
        //
        // Page Control Workset
        //
        case PAGE_CONTROL_WORKSET:
            wbOnPageObjectAddInd(pObj);
            break;

        //
        // Sync Control Workset
        //
        case SYNC_CONTROL_WORKSET:
            wbOnSyncObjectAddInd(pObj);
            break;

        //
        // User Information Workset
        //
        case USER_INFORMATION_WORKSET:
            wbOnUserObjectAddInd(pObj);
            break;

        //
        // Other (should be a Page Workset)
        //
        default:
            wbOnGraphicObjectAddInd(pEvent16->worksetID, pObj);
            break;
    }

DC_EXIT_POINT:
    DebugExitBOOL(wbOnObjectAddInd, processed);
    return(processed);
}



//
//
// Name:    wbGetPageObjectType
//
// Purpose: Get the type of an object in the Page Control Workset
//
// Returns: Error code
//
//
UINT WbClient::wbGetPageObjectType
(
    POM_OBJECT    pObj,
    UINT *        pObjectType
)
{
    UINT            result;
    POM_OBJECTDATA  pData;

    DebugEntry(wbGetPageObjectType);

    //
    // Read the object to get its type
    //
    result = OM_ObjectRead(m_pomClient,
                         m_hWSGroup,
                         PAGE_CONTROL_WORKSET,
                         pObj,
                         &pData);
    if (result != 0)
    {
        ERROR_OUT(("Error reading object = %d", result));
        wbError();
        DC_QUIT;
    }

    //
    // The first two bytes of the object data give its type
    //
    *pObjectType = *((TSHR_UINT16 *)pData->data);

    //
    // Release the object
    //
    OM_ObjectRelease(m_pomClient,
                   m_hWSGroup,
                   PAGE_CONTROL_WORKSET,
                   pObj,
                   &pData);


DC_EXIT_POINT:
    DebugExitDWORD(wbGetPageObjectType, result);
    return(result);
}



//
//
// Name:    wbOnPageObjectAddInd
//
// Purpose: Routine processing OM_OBJECT_ADD_IND events occurring on the
//          Page Control Workset.
//
// Returns: Error code
//
//
void WbClient::wbOnPageObjectAddInd(POM_OBJECT pObj)
{
    UINT    objectType;

    DebugEntry(wbOnPageObjectAddInd);

    //
    // Read the object to get its type
    //
    if (wbGetPageObjectType(pObj, &objectType) != 0)
    {
        DC_QUIT;
    }

    //
    // Act according to the type of object added
    //
    switch (objectType)
    {
        case TYPE_CONTROL_LOCK:
            TRACE_OUT(("It is a lock object"));
            wbReadLock();
            break;

        case TYPE_CONTROL_PAGE_ORDER:
            TRACE_OUT(("It is the Page Control object"));
            wbOnPageControlObjectAddInd(pObj);
            break;

        default:
            ERROR_OUT(("Unknown object type added to Page Control Workset"));
            break;
    }

DC_EXIT_POINT:
    DebugExitVOID(wbOnPageObjectAddInd);
}



//
//
// Name:    wbOnPageControlObjectAddInd
//
// Purpose: Routine processing add of page control object
//
// Returns: Error code
//
//
void WbClient::wbOnPageControlObjectAddInd(POM_OBJECT    pObj)
{
    DebugEntry(wbOnPageControlObjectAddInd);

    //
    // We only ever expect to get one of these objects
    //
    if (m_pObjPageControl != 0)
    {
        //
        // Check that this is the same object - the add has been triggered by
        // the workset open but we have already read the contents.
        //
        ASSERT((m_pObjPageControl == pObj));
    }

    //
    // Save the handle of the object
    //
    m_pObjPageControl = pObj;
    TRACE_OUT(("Got Page Control object"));

    //
    // Continue according to the current state
    //
    switch (m_state)
    {
        case STATE_REGISTERING:
            //
            // We now have a Page Control Object - if we are waiting for the
            // object we can now move to the next stage.
            //
            if (m_subState == STATE_REG_PENDING_PAGE_CONTROL)
            {
                //
                // If we have the lock on the Page Control Workset then we are in
                // control of the registration process.  We must add the sync
                // control object to the Sync Workset.
                //
                if (m_lockState == LOCK_STATE_GOT_LOCK)
                {
                    //
                    // Create the Sync Control Object
                    //
                    if (wbCreateSyncControl() != 0)
                    {
                        ERROR_OUT(("Error adding Sync Control Object"));
                        wbError();
                        DC_QUIT;
                    }
                }

                //
                // If we do not have the sync control object then wait for it -
                // otherwise we can complete initialisation.
                //
                if (m_pObjSyncControl == 0)
                {
                    m_subState = STATE_REG_PENDING_SYNC_CONTROL;
                    TRACE_OUT(("Moved substate to STATE_REG_PENDING_SYNC_CONTROL"));
                    DC_QUIT;
                }
                else
                {
                    //
                    // If it is us who has the Page Control Workset locked - release
                    // the lock.
                    //
                    if (m_lockState == LOCK_STATE_GOT_LOCK)
                    {
                        //
                        // Unlock the workset
                        //
                        wbUnlock();

                        //
                        // Wait for notification of the lock being released
                        //
                        TRACE_OUT(("Sub state change %d to %d",
                            m_subState, STATE_REG_PENDING_UNLOCK));

                        m_subState = STATE_REG_PENDING_UNLOCK;
                    }
                    else
                    {
                        TRACE_OUT(("Page Control and Sync Control objects both there."));
                        TRACE_OUT(("Registration can be completed"));
                        wbOnControlWorksetsReady();
                    }
                }
            }

            //
            // In other registration states we are not ready to process the
            // event.  It will be dealt with later.
            //
            break;

        case STATE_IDLE:
            //
            // We must already have a Page COntrol Object since we are in idle
            // state.  So this is an error.  It may have been caused by another
            // client so we just trace it rather than asserting.
            //
            ERROR_OUT(("Unexpected add of Page Control Object in idle state"));
            break;

        default:
            ERROR_OUT(("Bad main state"));
            break;
    }

DC_EXIT_POINT:
    DebugExitVOID(wbOnPageControlObjectAddInd);
}




//
//
// Name:    wbOnSyncObjectAddInd
//
// Purpose: Routine processing OM_OBJECT_ADD_IND events occurring on the
//          Sync Control Workset.
//
// Returns: Error code
//
//
void WbClient::wbOnSyncObjectAddInd(POM_OBJECT    pObj)
{
    DebugEntry(wbOnSyncObjectAddInd);

    //
    // We only expect this during registration
    //
    switch(m_state)
    {
        //
        // We are waiting for registration to continue
        //
        case STATE_REGISTERING:
            switch(m_subState)
            {
                //
                // We are waiting for a Sync Control Object
                //
                case STATE_REG_PENDING_SYNC_CONTROL:
                    m_pObjSyncControl = pObj;

                    //
                    // The Sync Control object has been added.  We do not need to do
                    // anything with it yet.
                    //

                    //
                    // If we already have the page control object then we can
                    // complete initilisation, otherwise we have to wait for it.
                    //
                    if (m_pObjPageControl == 0)
                    {
                        TRACE_OUT(("Sub state change %d to %d",
                            m_subState, STATE_REG_PENDING_PAGE_CONTROL));
                        m_subState = STATE_REG_PENDING_PAGE_CONTROL;
                    }
                    else
                    {
                        //
                        // If it is us who has the Page Control Workset locked -
                        // release the lock.
                        //
                        if (m_lockState == LOCK_STATE_GOT_LOCK)
                        {
                            //
                            // Unlock the workset
                            //
                            wbUnlock();

                            //
                            // Wait for notification of the lock being released
                            //
                            TRACE_OUT(("Sub state change %d to %d",
                               m_subState, STATE_REG_PENDING_UNLOCK));
                            m_subState = STATE_REG_PENDING_UNLOCK;
                        }
                        else
                        {
                            TRACE_OUT(("Page Control and Sync Control objects both there."));
                            TRACE_OUT(("Registration can be completed"));
                            wbOnControlWorksetsReady();
                        }
                    }
                    break;

                default:
                    //
                    // Save the handle of the Sync Control Object
                    //
                    m_pObjSyncControl = pObj;
                    break;
            }
            break;

        //
        // We are fully registered and are therefore not expecting an add event
        // on this workset.  However, since we are registered we must be
        // satisfied that we have a Sync Control Object - so ignore the error.
        //
        case STATE_IDLE:
            ERROR_OUT(("Sync object add not expected in idle state"));
            break;

        //
        // The client is in an unknown state
        //
        default:
            ERROR_OUT(("Client in unknown state = %d", m_state));
            break;
    }

    DebugExitVOID(wbOnSyncObjectAddInd);
}



//
//
// Name:    wbOnUserObjectAddInd
//
// Purpose: A user object has been added to the User Information Workset.
//          Inform the client that a new user has joined the call.
//
// Returns: Error code
//
//
void WbClient::wbOnUserObjectAddInd(POM_OBJECT    pObj)
{
    UINT                countUsers;

    DebugEntry(wbOnUserObjectAddInd);

    OM_WorksetCountObjects(m_pomClient,
                           m_hWSGroup,
                           USER_INFORMATION_WORKSET,
                           &countUsers);
    TRACE_OUT(("Number of users is now %d", countUsers));

    //
    // Ignore the add indication for our own user.
    //
    if (m_pObjLocal == pObj)
    {
        TRACE_OUT(("Got add of own user object"));
        //
        // If we have the lock (temporarily, with NULL lock owner handle),
        // then we need to update the lock object with our actual handle.
        //
        if ((m_pObjLock != NULL) &&
            (m_lockState == LOCK_STATE_GOT_LOCK))
        {
            TRACE_OUT(("Got the lock - update lock object"));
            wbWriteLock();
        }

        if ((m_state == STATE_REGISTERING) &&
            (m_subState == STATE_REG_PENDING_NEW_USER_OBJECT))
        {
            //
            // We have successfully joined the call.
            //
            TRACE_OUT(("Posting WBP_EVENT_JOIN_CALL_OK"));
            WBP_PostEvent(
                       0,                             // No delay
                       WBP_EVENT_JOIN_CALL_OK,        // Unlocked
                       0,                             // No parameters
                       0);

            //
            // Update the state to show that we are ready for work again
            //
            m_state = STATE_IDLE;
            m_subState = STATE_EMPTY;
            TRACE_OUT(("Moved state back to STATE_IDLE"));
        }

        DC_QUIT;
    }

    //
    // If we have created our user object we must check to see if the new
    // user has usurped our color.  If so we may need to change color.
    //
    if (m_pObjLocal != NULL)
    {
        TRACE_OUT(("We have added our user object - check colors"));
        wbCheckPersonColor(pObj);
    }

    //
    // Ignore these events unless we are fully registered
    //
    if (m_state != STATE_IDLE)
    {
        TRACE_OUT(("Ignoring user object add - not fully registered"));
        DC_QUIT;
    }

    //
    // Tell the client that a new user has joined
    //
    TRACE_OUT(("Posting WBP_EVENT_USER_JOINED"));
    WBP_PostEvent(
                 0,                               // No delay
                 WBP_EVENT_PERSON_JOINED,         // Event type
                 0,                               // No short parameter
                 (UINT_PTR) pObj);                // User object handle

    //
    // Try to read the lock object - we may not have been able to do this
    // yet.
    //
    wbReadLock();


DC_EXIT_POINT:
    DebugExitVOID(wbOnUserObjectAddInd);
}



//
//
// Name:    wbOnGraphicObjectAddInd
//
// Purpose: A graphic object has been added to a page workset.
//          Inform the client that a new graphic has been added.
//
// Returns: Error code
//
//
void WbClient::wbOnGraphicObjectAddInd
(
    OM_WORKSET_ID       worksetID,
    POM_OBJECT    pObj
)
{
    WB_PAGE_HANDLE      hPage = (WB_PAGE_HANDLE)worksetID;
    POM_OBJECTDATA         pData;
    PWB_GRAPHIC         pGraphic;
    UINT                result;

    DebugEntry(wbOnGraphicObjectAddInd);

    //
    // NFC, SFR 6450.  If this object was loaded from file on this machine,
    // then we dont need to set the "changed flag".  Otherwise record that
    // the contents have changed
    //
    //
    // Read the object.
    //
    result = OM_ObjectRead(m_pomClient,
                         m_hWSGroup,
                         worksetID,
                          pObj,
                         &pData);
    if (result != 0)
    {
        WARNING_OUT(("OM_ObjectRead (%u) failed, set changed flag anyway ", result));
        m_changed = TRUE;
        TRACE_OUT(("changed flag now TRUE"));
    }
    else
    {
        //
        // Convert the ObMan pointer to a core pointer
        //
        pGraphic = GraphicPtrFromObjectData(pData);

        if ( ! ((pGraphic->loadedFromFile) &&
              (pGraphic->loadingClientID == m_clientNetID)))
        {
            TRACE_OUT(("Not loaded from file locally - Set changed flag on"));
            m_changed = TRUE;
            TRACE_OUT(("Changed flag now TRUE"));
        }

        //
        // Finished with the object, so release it.
        //
        OM_ObjectRelease(m_pomClient,
                       m_hWSGroup,
                       worksetID,
                        pObj,
                       &pData);
    }

    //
    // These events are ignored unless we are fully registered (the client
    // can do nothing about them if it is not registered correctly).
    //
    if (m_state != STATE_IDLE)
    {
        TRACE_OUT(("Ignoring add of graphic object - not registered"));
        DC_QUIT;
    }

    //
    // Check that this page is actually in use
    //
    if (GetPageState(hPage)->state != PAGE_IN_USE)
    {
        TRACE_OUT(("Ignoring add to page not in use"));
        DC_QUIT;
    }

    //
    // Inform the client of the object being added
    //
    TRACE_OUT(("Posting WBP_EVENT_GRAPHIC_ADDED"));
    WBP_PostEvent(
               0,                               // No delay
               WBP_EVENT_GRAPHIC_ADDED,         // Event type
               hPage,                           //
               (UINT_PTR)pObj);                 // User object handle


DC_EXIT_POINT:
    DebugExitVOID(wbOnGraphicObjectAddInd);
}


//
//
// Name:    wbOnObjectMoveInd
//
// Purpose: This routine is called whenever OM_OBJECT_MOVE_IND events are
//          received.
//
// Returns: Error code
//
//
BOOL WbClient::wbOnObjectMoveInd
(
    UINT_PTR param1,
    UINT_PTR param2
)
{
    POM_EVENT_DATA16 pEvent16 = (POM_EVENT_DATA16) &param1;
    POM_EVENT_DATA32 pEvent32 = (POM_EVENT_DATA32) &param2;
    BOOL        processed = FALSE;

    DebugEntry(wbOnObjectMoveInd);

    //
    // Check that the workset group is ours
    //
    if (pEvent16->hWSGroup != m_hWSGroup)
    {
        ERROR_OUT(("Event for unknown workset group = %d", pEvent16->hWSGroup));
        DC_QUIT;
    }

    //
    // We will process the event
    //
    processed = TRUE;

    //
    // Process the event according to the workset ID
    //
    switch(pEvent16->worksetID)
    {
        //
        // Page Control Workset Lock Workset User Information Workset
        //
        case PAGE_CONTROL_WORKSET:
        case SYNC_CONTROL_WORKSET:
        case USER_INFORMATION_WORKSET:
            //
            // Event not expected for these worksets
            //
            ERROR_OUT(("Unexpected for workset %d", (UINT) pEvent16->worksetID));
            break;

        //
        // Other (should be a Page Workset)
        //
        default:
            wbOnGraphicObjectMoveInd(pEvent16->worksetID,
                               (POM_OBJECT) param2);
            break;
    }


DC_EXIT_POINT:
    DebugExitBOOL(wbOnObjectMoveInd, processed);
    return(processed);
}




//
//
// Name:    wbOnGraphicObjectMoveInd
//
// Purpose: This routine is called whenever an OM_OBJECT_MOVE_IND is
//          received for a graphic object.
//
// Returns: Error code
//
//
void WbClient::wbOnGraphicObjectMoveInd
(
    OM_WORKSET_ID   worksetID,
    POM_OBJECT      pObj
)
{
    WB_PAGE_HANDLE hPage = (WB_PAGE_HANDLE)worksetID;

    DebugEntry(wbOnGraphicObjectMoveInd);

    //
    // Record that the contents have changed
    //
    m_changed = TRUE;

    //
    // These events are ignored unless we are fully registered (the client
    // can do nothing about them).
    //
    if (m_state != STATE_IDLE)
    {
        TRACE_OUT(("Ignoring move of graphic object before registration"));
        DC_QUIT;
    }

    //
    // Check that this page is actually in use
    //
    if (GetPageState(hPage)->state != PAGE_IN_USE)
    {
        TRACE_OUT(("Ignoring move in page not in use"));
        DC_QUIT;
    }

    //
    // Inform the client of the object being added
    //
    TRACE_OUT(("Posting WBP_EVENT_GRAPHIC_MOVED"));
    WBP_PostEvent(
               0,                                  // No delay
               WBP_EVENT_GRAPHIC_MOVED,            // Event type
               hPage,                              // Page handle
               (UINT_PTR)pObj);                    // Object handle


DC_EXIT_POINT:
    DebugExitVOID(wbOnGraphicObjectMoveInd);
}



//
//
// Name:    wbOnObjectDeleteInd
//
// Purpose: This routine is called whenever an OM_OBJECT_DELETE_IND is
//          received.
//
// Returns: Error code
//
//
BOOL WbClient::wbOnObjectDeleteInd
(
    UINT_PTR param1,
    POM_OBJECT pObj
)
{
    POM_EVENT_DATA16 pEvent16 = (POM_EVENT_DATA16) &param1;
    BOOL             processed = FALSE;

    DebugEntry(wbOnObjectDeleteInd);

    //
    // Check that the workset group is ours
    //
    if (pEvent16->hWSGroup != m_hWSGroup)
    {
        ERROR_OUT(("Event for unknown workset group = %d", pEvent16->hWSGroup));
        DC_QUIT;
    }

    //
    // We will process the event
    //
    processed = TRUE;

    //
    // Process the event according to the workset ID
    //
    switch(pEvent16->worksetID)
    {
        //
        // Page Control Workset
        //
        case PAGE_CONTROL_WORKSET:
            wbOnPageObjectDeleteInd(pObj);
            break;

        //
        // Sync Workset
        //
        case SYNC_CONTROL_WORKSET:
            ERROR_OUT(("Illegal object delete on sync control workset - ignored"));

            //
            // We do not confirm the delete since we do not want to lose the Sync
            // Control Object.
            //
            break;

        //
        // User Information Workset
        //
        case USER_INFORMATION_WORKSET:
            wbOnUserObjectDeleteInd(pObj);
            break;

        //
        // Other (should be a Page Workset)
        //
        default:
            wbOnGraphicObjectDeleteInd(pEvent16->worksetID, pObj);
            break;
    }


DC_EXIT_POINT:
    DebugExitBOOL(wbOnObjectDeleteInd, processed);
    return(processed);
}



//
//
// Name:    wbOnPageObjectDeleteInd
//
// Purpose: This routine is called whenever an OM_OBJECT_DELETE_IND is
//          received for an object in the Page Control Workset.
//
// Returns: Error code
//
//
void WbClient::wbOnPageObjectDeleteInd(POM_OBJECT    pObj)
{
    UINT                objectType;

    DebugEntry(wbOnPageObjectDeleteInd);

    //
    // Get the type of object that is being deleted
    //
    if (wbGetPageObjectType(pObj, &objectType) != 0)
    {
        DC_QUIT;
    }

    switch(objectType)
    {
        case TYPE_CONTROL_PAGE_ORDER:
            //
            // The object is the Page Control Object - something serious is wrong
            // as this object should never be deleted.
            //
            ERROR_OUT(("Attempt to delete page control object"));
            break;

        case TYPE_CONTROL_LOCK:
            TRACE_OUT(("Lock object being deleted"));
            wbOnLockControlObjectDeleteInd(pObj);
            break;

        default:
            ERROR_OUT(("Bad object type"));
            break;
    }


DC_EXIT_POINT:
    DebugExitVOID(wbOnPageObjectDeleteInd);
}



//
//
// Name:    wbOnLockControlObjectDeleteInd
//
// Purpose: This routine is called whenever an OM_OBJECT_DELETE_IND is
//          received for a lock object in the Page Control Workset.
//
// Returns: Error code
//
//
void WbClient::wbOnLockControlObjectDeleteInd(POM_OBJECT      pObj
)
{
    DebugEntry(wbOnLockControlObjectDeleteInd);

    //
    // Confirm the delete to ObMan
    //
    TRACE_OUT(("Lock handle %x, expecting %x", pObj, m_pObjLock));
    if (pObj != m_pObjLock)
    {
        WARNING_OUT(("Unexpected lock handle %x, expecting %x",
                                       pObj, m_pObjLock));
    }

    OM_ObjectDeleteConfirm(m_pomClient,
                           m_hWSGroup,
                           PAGE_CONTROL_WORKSET,
                           pObj);
    m_pObjLock = NULL;

    //
    // Process according to the current lock state
    //
    switch(m_lockState)
    {
        case LOCK_STATE_PENDING_DELETE:
            //
            // We are deleting our lock object.  We must unlock the
            // workset.
            //
            TRACE_OUT(("Our lock object delete confirmed - unlocking the workset"));
            OM_WorksetUnlock(m_pomClient,
                             m_hWSGroup,
                             PAGE_CONTROL_WORKSET);
            break;

        case LOCK_STATE_LOCKED_OUT:
            //
            // The user with the lock has deleted the lock object. We treat
            // this as a removal of the whiteboard lock - we reset the
            // state at the end of this function.
            //
            TRACE_OUT(("Remote user's lock object deleted"));
            break;

        case LOCK_STATE_EMPTY:
            //
            // We have just deleted the object at the end of a call to tidy
            // up.  Carry on so we reset lockType / pObjPersonLock etc.
            //
            TRACE_OUT(("LOCK_STATE_EMPTY"));
            break;

        case LOCK_STATE_PENDING_LOCK:
            WARNING_OUT(("LOCK_STATE_PENDING_LOCK"));
            //
            // We don't expect to get here. If by some chance we do, then
            // just quit, since we should still get the workset lock con.
            //
            DC_QUIT;
            break;

        default:
            ERROR_OUT(("Bad lock state %d", m_lockState));
            break;
    }

    //
    // The lock object has been deleted, so there is no lock active
    //
    m_lockType             = WB_LOCK_TYPE_NONE;
    m_pObjPersonLock    = NULL;

    //
    // Record that there is now no lock
    //
    m_lockState = LOCK_STATE_EMPTY;
    TRACE_OUT(("Moved lock state to LOCK_STATE_EMPTY"));

    //
    // Notify the client of the lock status change
    //
    wbSendLockNotification();


DC_EXIT_POINT:
    DebugExitVOID(wbOnLockControlObjectDeleteInd);
}




//
//
// Name:    wbOnGraphicObjectDeleteInd
//
// Purpose: This routine is called whenever an OM_OBJECT_DELETE_IND is
//          received for an object in a page workset.
//
// Returns: Error code
//
//
void WbClient::wbOnGraphicObjectDeleteInd
(
    OM_WORKSET_ID       worksetID,
    POM_OBJECT    pObj
)
{
    WB_PAGE_HANDLE      hPage = (WB_PAGE_HANDLE)worksetID;
    BOOL                bConfirm = FALSE;

    DebugEntry(wbOnGraphicObjectDeleteInd);

    //
    // Record that the contents have changed
    //
    m_changed = TRUE;
    TRACE_OUT(("Changed flag now TRUE"));

    //
    // These events are handled within the core until the client is ready.
    //
    if (m_state != STATE_IDLE)
    {
        TRACE_OUT(("Delete of graphic object before registration"));
        bConfirm = TRUE;
    }

    //
    // Check that this page is actually in use
    //
    if (GetPageState(hPage)->state != PAGE_IN_USE)
    {
        TRACE_OUT(("Delete in page that is not in use"));
        bConfirm = TRUE;
    }

    //
    // Check whether we are to pass the event on to the client
    //
    if (bConfirm)
    {
        //
        // Confirm the delete to ObMan
        //
        TRACE_OUT(("Confirming delete immediately"));
        OM_ObjectDeleteConfirm(m_pomClient,
                           m_hWSGroup,
                           worksetID,
                           pObj);
    }
    else
    {
        //
        // Inform the client of the object being added
        //
        TRACE_OUT(("Posting WBP_EVENT_GRAPHIC_DELETE_IND"));
        WBP_PostEvent(
                 0,                                  // No delay
                 WBP_EVENT_GRAPHIC_DELETE_IND,       // Event type
                 hPage,                              // Page handle
                 (UINT_PTR)pObj);                    // Object handle
    }

    DebugExitVOID(wbOnGraphicObjectDeleteInd);
}




//
//
// Name:    wbOnUserObjectDeleteInd
//
// Purpose: This routine is called whenever an OM_OBJECT_DELETE_IND is
//          received for an object in the User Information Workset.
//
// Returns: Error code
//
//
void WbClient::wbOnUserObjectDeleteInd
(
    POM_OBJECT   pObjPerson
)
{
    DebugEntry(wbOnUserObjectDeleteInd);

    //
    // If the user which has been removed had a lock then remove its user
    // handle from the client data.  The lock is still there, and will be
    // removed when we get the WORKSET_UNLOCK_IND for the lock workset.  This
    // arrives after the user-object delete, because the user workset is of
    // higher priority.
    //
    if (m_pObjPersonLock == pObjPerson)
    {
        m_pObjPersonLock = NULL;
    }

    //
    // These events are ignored unless we are fully registered (the client
    // can do nothing about them).
    //
    if (m_state != STATE_IDLE)
    {
        TRACE_OUT(("Delete of user object before registration - confirming"));

        //
        // Confirm the delete
        //
        OM_ObjectDeleteConfirm(m_pomClient,
                           m_hWSGroup,
                           USER_INFORMATION_WORKSET,
                           pObjPerson);

        //
        // Nothing more to be done
        //
        DC_QUIT;
    }

    //
    // Inform the client of the user leaving
    //
    TRACE_OUT(("Posting WBP_EVENT_USER_LEFT_IND"));
    WBP_PostEvent(
               0,                                  // No delay
               WBP_EVENT_PERSON_LEFT,              // Event type
               0,                                  // No short parameter
               (UINT_PTR) pObjPerson);             // User object handle


DC_EXIT_POINT:
    DebugExitVOID(wbOnUserObjectDeleteInd);
}



//
//
// Name:    wbOnObjectUpdateInd
//
// Purpose: This routine is called whenever an OM_OBJECT_UPDATE_IND is
//          received for an object in a page workset.
//
// Returns: Error code
//
//
BOOL WbClient::wbOnObjectUpdateInd
(
    UINT_PTR param1,
    POM_OBJECT pObj
)
{
    POM_EVENT_DATA16 pEvent16 = (POM_EVENT_DATA16) &param1;
    BOOL            processed = FALSE;

    DebugEntry(wbOnObjectUpdateInd);

    //
    // Check that the workset group is ours
    //
    if (pEvent16->hWSGroup != m_hWSGroup)
    {
        ERROR_OUT(("Event for unknown workset group = %d", pEvent16->hWSGroup));
        DC_QUIT;
    }

    //
    // We will process the event
    //
    processed = TRUE;

    //
    // Process the event according to the workset ID
    //
    switch(pEvent16->worksetID)
    {
        //
        // Page Control Workset
        //
        case PAGE_CONTROL_WORKSET:
            ERROR_OUT(("Illegal object update on page control workset - ignored"));

            //
            // Updates on the Page Control Object are not allowed - do not
            // confirm it.
            //
            break;

        //
        // Lock Workset
        //
        case SYNC_CONTROL_WORKSET:
            ERROR_OUT(("Illegal object update on sync control workset"));

            //
            // Updates to the Sync Control Object itself are not allowed - do not
            // confirm it.
            //
            break;

        //
        // User Information Workset
        //
        case USER_INFORMATION_WORKSET:
            wbOnUserObjectUpdateInd(pObj);
            break;

        //
        // Other (should be a Page Workset)
        //
        default:
            wbOnGraphicObjectUpdateInd(pEvent16->worksetID, pObj);
            break;
    }


DC_EXIT_POINT:
    DebugExitBOOL(wbOnObjectUpdateInd, processed);
    return(processed);
}




//
//
// Name:    wbOnUserObjectUpdateInd
//
// Purpose: This routine is called whenever an OM_OBJECT_UPDATE_IND is
//          received for an object in the User Information Workset.
//
// Returns: Error code
//
//
void WbClient::wbOnUserObjectUpdateInd(POM_OBJECT    pObj)
{
    DebugEntry(wbOnUserObjectUpdateInd);

    //
    // if the updated user object is not the local user's, and we have
    // already added the local user's object, then check the color hasn't
    // changed to clash with the local user's color.
    //
    if (   (m_pObjLocal != pObj)
        && (m_pObjLocal != NULL))
    {
        TRACE_OUT(("Check color of updated user object"));
        wbCheckPersonColor(pObj);
    }

    //
    // Don't inform the front end if we aren't fully registered
    //
    if (m_state != STATE_IDLE)
    {
        TRACE_OUT(("User object updated before registration - confirming"));

        //
        // Confirm the update immediately
        //
        OM_ObjectUpdateConfirm(m_pomClient,
                           m_hWSGroup,
                           USER_INFORMATION_WORKSET,
                           pObj);

        //
        // Nothing more to be done
        //
        DC_QUIT;
    }

    //
    // Tell the client that a user has been updated
    //
    TRACE_OUT(("Posting WBP_EVENT_PERSON_UPDATE_IND"));
    WBP_PostEvent(
               0,                               // No delay
               WBP_EVENT_PERSON_UPDATE,         // Event type
               0,                               // No short parameter
               (UINT_PTR) pObj);                // User object handle


DC_EXIT_POINT:
    DebugExitVOID(wbOnUserObjectUpdateInd);
}



//
//
// Name:    wbOnUserObjectReplaceInd
//
// Purpose: This routine is called whenever an OM_OBJECT_REPLACE_IND is
//          received for an object in the User Information Workset.
//
//
// Returns: Error code
//
//
void WbClient::wbOnUserObjectReplaceInd(POM_OBJECT   pObj)
{
    DebugEntry(wbOnUserObjectReplaceInd);

    //
    // if the updated user object is not the local user's, and we have
    // already added the local user's object, then check the color hasn't
    // changed to clash with the local user's color.
    //
    if (   (m_pObjLocal != pObj)
        && (m_pObjLocal != NULL))
    {
        TRACE_OUT(("Check color of updated user object"));
        wbCheckPersonColor(pObj);
    }

    //
    // Don't inform the front end if we aren't fully registered
    //
    if (m_state != STATE_IDLE)
    {
        TRACE_OUT(("User object replaced before registration - confirming"));

        //
        // Confirm the replace immediately
        //
        OM_ObjectReplaceConfirm(m_pomClient,
                           m_hWSGroup,
                           USER_INFORMATION_WORKSET,
                           pObj);

        //
        // Nothing more to be done
        //
        DC_QUIT;
    }

    //
    // Tell the client that a user has been updated
    //
    TRACE_OUT(("Posting WBP_EVENT_PERSON_UPDATE_IND"));
    WBP_PostEvent(
               0,                               // No delay
               WBP_EVENT_PERSON_REPLACE,        // Event type
               0,                               // No short parameter
               (UINT_PTR) pObj);                // User object handle


DC_EXIT_POINT:
    DebugExitVOID(wbOnUserObjectReplaceInd);
}




//
//
// Name:    wbOnGraphicObjectUpdateInd
//
// Purpose: This routine is called whenever an OM_OBJECT_UPDATE_IND is
//          received for an object in a page workset.
//
// Returns: Error code
//
//
void WbClient::wbOnGraphicObjectUpdateInd
(
    OM_WORKSET_ID    worksetID,
    POM_OBJECT pObj
)
{
    WB_PAGE_HANDLE hPage = (WB_PAGE_HANDLE)worksetID;
    BOOL         bConfirm = FALSE;

    DebugEntry(wbOnGraphicObjectUpdateInd);

    //
    // Record that the contents have changed
    //
    m_changed = TRUE;
    TRACE_OUT(("Changed flag now TRUE"));

    //
    // These events are handled within the core until the client is ready.
    //
    if (m_state != STATE_IDLE)
    {
        TRACE_OUT(("Update of graphic object before registration"));
        bConfirm = TRUE;
    }

    //
    // Check that this page is actually in use
    //
    if (GetPageState(hPage)->state != PAGE_IN_USE)
    {
        TRACE_OUT(("Update for page that is not in use"));
        bConfirm = TRUE;
    }

    //
    // Check whether we are to confirm the update now or ask the client
    //
    if (bConfirm)
    {
        //
        // Confirm the update immediately
        //
        TRACE_OUT(("Confirming update immediately"));
        OM_ObjectUpdateConfirm(m_pomClient,
                           m_hWSGroup,
                           worksetID,
                           pObj);
    }
    else
    {
        //
        // Inform the client of the object being added
        //
        TRACE_OUT(("Posting WBP_EVENT_GRAPHIC_UPDATE_IND"));
        WBP_PostEvent(
                 0,                               // No delay
                 WBP_EVENT_GRAPHIC_UPDATE_IND,    // Event type
                 hPage,                           // Page handle
                 (UINT_PTR)pObj);                 // Object handle
    }

    DebugExitVOID(wbOnGraphicObjectUpdateInd);
}



//
//
// Name:    wbOnObjectReplaceInd
//
// Purpose: This routine is called whenever an OM_OBJECT_REPLACE_IND is
//          received.
//
// Returns: Error code
//
//
BOOL WbClient::wbOnObjectReplaceInd
(
    UINT_PTR param1,
    POM_OBJECT pObj
)
{
    POM_EVENT_DATA16 pEvent = (POM_EVENT_DATA16) &param1;
    BOOL        processed = FALSE;

    DebugEntry(wbOnObjectReplaceInd);

    //
    // Check that the workset group is ours
    //
    if (pEvent->hWSGroup != m_hWSGroup)
    {
        ERROR_OUT(("Event for unknown workset group = %d", pEvent->hWSGroup));
        DC_QUIT;
    }

    //
    // We will process the event
    //
    processed = TRUE;

    //
    // Process the event according to the workset ID
    //
    switch (pEvent->worksetID)
    {
        //
        // Page Control Workset
        //
        case PAGE_CONTROL_WORKSET:
            wbOnPageObjectReplaceInd(pObj);
            break;

        //
        // Lock Workset
        //
        case SYNC_CONTROL_WORKSET:
            wbOnSyncObjectReplaceInd(pObj);
            break;

        //
        // User Information Workset
        //
        case USER_INFORMATION_WORKSET:
            wbOnUserObjectReplaceInd(pObj);
            break;

        //
        // Other (should be a Page Workset)
        //
        default:
            wbOnGraphicObjectReplaceInd(pEvent->worksetID, pObj);
            break;
    }


DC_EXIT_POINT:
    DebugExitBOOL(wbOnObjectReplaceInd, processed);
    return(processed);
}


//
//
// Name:    wbOnPageObjectReplaceInd
//
// Purpose: This routine is called whenever the Page Control object is
//          replaced.
//
// Returns: Error code
//
//
void WbClient::wbOnPageObjectReplaceInd(POM_OBJECT    pObj)
{
    UINT                objectType;

    DebugEntry(wbOnPageObjectReplaceInd);

    //
    // Confirm the change to ObMan (cannot fail)
    //
    OM_ObjectReplaceConfirm(m_pomClient,
                          m_hWSGroup,
                          PAGE_CONTROL_WORKSET,
                          pObj);

    //
    // Read the object to get its type
    //
    if (wbGetPageObjectType(pObj, &objectType) != 0)
    {
        DC_QUIT;
    }

    //
    // Act according to the type of object added
    //
    switch (objectType)
    {
        case TYPE_CONTROL_LOCK:
            wbReadLock();
            break;

        case TYPE_CONTROL_PAGE_ORDER:
            wbOnPageControlObjectReplaceInd();
            break;

        default:
            ERROR_OUT(("Unknown object type added to Page Control Workset"));
            break;
    }


DC_EXIT_POINT:
    DebugExitVOID(wbOnPageObjectReplaceInd);
}



//
//
// Name:    wbOnPageControlObjectReplaceInd
//
// Purpose: This routine is called whenever the Page Control object is
//          replaced.
//
// Returns: Error code
//
//
void WbClient::wbOnPageControlObjectReplaceInd(void)
{
    DebugEntry(wbOnPageControlObjectReplaceInd);

    //
    // Process according to the current state
    //
    switch (m_state)
    {
        case STATE_REGISTERING:
            //
            // During registration we do nothing - the Page Order is updated
            // explicitly as one of the last registration actions.
            //
            break;

        case STATE_IDLE:
            //
            // When we are fully registered we must send events to the front-end
            // indicating what changes have been made to the page list.
            //
            wbProcessPageControlChanges();
            break;

        default:
            ERROR_OUT(("Bad client major state"));
            break;
    }

    DebugExitVOID(wbOnPageControlObjectReplaceInd);
}



//
//
// Name:    wbProcessPageControlChanges
//
// Purpose: This routine is called whenever the Page Control object is
//          replaced in idle state. It reads the new Page Control data
//          and starts the process of informing the client of any changes.
//
// Returns: Error code
//
//
void WbClient::wbProcessPageControlChanges(void)
{
    BYTE          toBeMarked[WB_MAX_PAGES];
    UINT         indexExternal;
    UINT         indexInternal;
    UINT         lLengthExternal;
    BOOL           addOutstanding = TRUE;
    PWB_PAGE_ORDER   pPageOrderExternal;
    PWB_PAGE_ORDER   pPageOrderInternal = &(m_pageOrder);
    PWB_PAGE_STATE   pPageState;
    POM_WORKSET_ID   pPageExternal;
    UINT     countPagesExternal;
    POM_OBJECTDATA      pData = NULL;

    DebugEntry(wbProcessPageControlChanges);

    //
    // Read the new Page Control Object
    //
    if (OM_ObjectRead(m_pomClient,
                     m_hWSGroup,
                     PAGE_CONTROL_WORKSET,
                     m_pObjPageControl,
                     &pData) != 0)
    {
        ERROR_OUT(("Error reading Page Control Object"));
        wbError();
        DC_QUIT;
    }

    //
    // Extract details from the external page order
    //
    lLengthExternal    = pData->length;
    pPageOrderExternal = (PWB_PAGE_ORDER) pData->data;
    pPageExternal      = pPageOrderExternal->pages;
    countPagesExternal = pPageOrderExternal->countPages;

    //
    // Process existing and newly added pages
    //
    for (indexExternal = 0; indexExternal < countPagesExternal; indexExternal++)
    {
        //
        // Convert the index into the Page Control Object to an index into the
        // internal Page List.
        //
        indexInternal = PAGE_WORKSET_ID_TO_INDEX(pPageExternal[indexExternal]);

        //
        // Test and update the internal page state as necessary
        //
        pPageState = &((m_pageStates)[indexInternal]);

        //
        // If the page is in use locally then we do not need to do anything
        // (the external and internal page lists agree already).
        //
        if (pPageState->state != PAGE_IN_USE)
        {
            switch (pPageState->subState)
            {
                case PAGE_STATE_EMPTY:
                    //
                    // The page does not yet have a workset open for it - open one
                    // now.  (But only open one per call to this routine to prevent
                    // swamping the message queue.  The other outstanding opens will
                    // be done when this routine is next called).
                    //
                    wbPageWorksetOpen(PAGE_INDEX_TO_HANDLE(indexInternal),
                            OPEN_EXTERNAL);

                    //
                    // Leave now - this routine will be called again when the open
                    // confirm is received for the workset just opened.
                    //
                    DC_QUIT;
                    break;

                case PAGE_STATE_LOCAL_OPEN_CONFIRM:
                case PAGE_STATE_EXTERNAL_OPEN_CONFIRM:
                case PAGE_STATE_EXTERNAL_ADD:
                    //
                    // Do nothing - the page is already in the add process
                    //
                    TRACE_OUT(("Page %d is already pending local add",
                                        PAGE_INDEX_TO_HANDLE(indexInternal)));
                    break;

                case PAGE_STATE_READY:
                    //
                    // The page workset has been opened previously - we can just mark
                    // the page as being in use immediately.
                    //
                    pPageState->state = PAGE_IN_USE;
                    pPageState->subState = PAGE_STATE_EMPTY;
                    TRACE_OUT(("Moved page %d state to PAGE_IN_USE",
                            (UINT) PAGE_INDEX_TO_HANDLE(indexInternal) ));
                    break;

                default:
                    ERROR_OUT(("Bad page substate %d", pPageState->subState));
                    break;
            }
        }
    }

    //
    // Mark any pages that no longer appear in the Page Control Object as
    // "delete pending" (unless they are already marked).
    //

    FillMemory(toBeMarked, sizeof(toBeMarked), TRUE);

    //
    // Flag which pages should be marked
    //
    for (indexExternal = 0; indexExternal < countPagesExternal; indexExternal++)
    {
        toBeMarked[PAGE_WORKSET_ID_TO_INDEX(pPageExternal[indexExternal])] = 0;
    }

    //
    // Mark them
    //
    for (indexInternal = 0; indexInternal < WB_MAX_PAGES; indexInternal++)
    {
        pPageState = &((m_pageStates)[indexInternal]);

        if (   (toBeMarked[indexInternal] == 1)
            && (pPageState->state == PAGE_IN_USE))
        {
            switch (pPageState->subState)
            {
                case PAGE_STATE_EMPTY:
                    //
                    // Ask the client for confirmation of the delete
                    //
                    TRACE_OUT(("Posting WBP_EVENT_PAGE_DELETE_IND"));
                    WBP_PostEvent(
                       0,                         // No delay
                       WBP_EVENT_PAGE_DELETE_IND, // Page being deleted
                       PAGE_INDEX_TO_HANDLE(indexInternal), // Page handle
                       0);

                    //
                    // Update the page state
                    //
                    pPageState->subState = PAGE_STATE_EXTERNAL_DELETE_CONFIRM;
                    TRACE_OUT(("Moved page %d substate to PAGE_STATE_EXTERNAL_DELETE_CONFIRM",
                            (UINT) PAGE_INDEX_TO_HANDLE(indexInternal) ));

                    //
                    // Leave now - this routine will be called again when the delete
                    // confirm is received for this workset.
                    //
                    DC_QUIT;
                    break;

                case PAGE_STATE_LOCAL_DELETE:
                    //
                    // Ask the client for confirmation of the delete
                    //
                    TRACE_OUT(("Posting WBP_EVENT_PAGE_DELETE_IND"));
                    WBP_PostEvent(
                       0,                         // No delay
                       WBP_EVENT_PAGE_DELETE_IND, // Page being deleted
                       PAGE_INDEX_TO_HANDLE(indexInternal), // Page handle
                       0);

                    //
                    // Update the page state
                    //
                    pPageState->subState = PAGE_STATE_LOCAL_DELETE_CONFIRM;
                    TRACE_OUT(("Moved page %d substate to PAGE_STATE_LOCAL_DELETE_CONFIRM",
                          (UINT) PAGE_INDEX_TO_HANDLE(indexInternal) ));

                    //
                    // Leave now - this routine will be called again when the delete
                    // confirm is received for this workset.
                    //
                    DC_QUIT;
                    break;

                case PAGE_STATE_EXTERNAL_DELETE:
                case PAGE_STATE_EXTERNAL_DELETE_CONFIRM:
                case PAGE_STATE_LOCAL_DELETE_CONFIRM:
                    //
                    // We are already expecting a delete for this page
                    //
                    TRACE_OUT(("Page %d is already pending local delete",
                                        PAGE_INDEX_TO_HANDLE(indexInternal)));
                    DC_QUIT;
                    break;

                default:
                    ERROR_OUT(("Bad page substate %d", pPageState->subState));
                    break;
            }
        }
    }

    //
    // There are no deletes or adds outstanding now
    //

    //
    // Copy the new page order to the internal page list
    //
    memcpy(pPageOrderInternal, pPageOrderExternal, lLengthExternal);

    //
    // Inform the client of the change
    //
    TRACE_OUT(("Posting WBP_EVENT_PAGE_ORDER_UPDATED"));
    WBP_PostEvent(
               0,                                      // No delay
               WBP_EVENT_PAGE_ORDER_UPDATED,           // Event number
               0,                                      // No parameters
               0);

    //
    // Check the number of pages ready in the cache
    //
    wbCheckReadyPages();

DC_EXIT_POINT:
    //
    // Release the Page Control Object
    //
    if (pData != NULL)
    {
        OM_ObjectRelease(m_pomClient,
                     m_hWSGroup,
                     PAGE_CONTROL_WORKSET,
                     m_pObjPageControl,
                     &pData);
    }

    DebugExitVOID(wbProcessPageControlChanges);
}



//
//
// Name:    wbOnSyncObjectReplaceInd
//
// Purpose: This routine is called whenever the Sync Control object is
//          replaced.
//
// Returns: Error code
//
//
void WbClient::wbOnSyncObjectReplaceInd(POM_OBJECT    pObj)
{
    POM_OBJECTDATA         pSyncObject;
    PWB_SYNC_CONTROL    pSyncControl;
    OM_OBJECT_ID        syncPersonID;

    DebugEntry(wbOnSyncControlReplaced);

    //
    // Confirm the replace of the object
    //
    OM_ObjectReplaceConfirm(m_pomClient,
                          m_hWSGroup,
                          SYNC_CONTROL_WORKSET,
                          pObj);

    //
    // Read the object and determine whether it was written by this client or
    // another.
    //
    if (OM_ObjectRead(m_pomClient,
                         m_hWSGroup,
                         SYNC_CONTROL_WORKSET,
                         m_pObjSyncControl,
                         &pSyncObject) != 0)
    {
        ERROR_OUT(("Error reading Sync Control Object"));
        wbError();
        DC_QUIT;
    }

    pSyncControl = (PWB_SYNC_CONTROL) pSyncObject->data;

    //
    // Get the user ID from the object
    //
    syncPersonID = pSyncControl->personID;

    //
    // Release the Sync Control Object
    //
    OM_ObjectRelease(m_pomClient,
                   m_hWSGroup,
                   SYNC_CONTROL_WORKSET,
                   m_pObjSyncControl,
                   &pSyncObject);
    pSyncControl = NULL;

    //
    // If the user ID in the object is not the ID of the current client, we
    // must post a message to the front-end.
    //
    if (memcmp(&syncPersonID,
                &(m_personID),
                sizeof(syncPersonID)) != 0)
    {
        //
        // Post a "sync position updated" event to the front-end
        //
        TRACE_OUT(("Posting WBP_EVENT_SYNC_POSITION_UPDATED"));
        WBP_PostEvent(
                 0,
                 WBP_EVENT_SYNC_POSITION_UPDATED,
                 0,
                 0);
    }

DC_EXIT_POINT:
    DebugExitVOID(wbOnSyncControlReplaced);
}



//
//
// Name:    wbOnGraphicObjectReplaceInd
//
// Purpose: This routine is called whenever an OM_OBJECT_REPLACE_IND is
//          received for an object in a page workset.
//
// Returns: Error code
//
//
void WbClient::wbOnGraphicObjectReplaceInd
(
    OM_WORKSET_ID   worksetID,
    POM_OBJECT      pObj
)
{
    WB_PAGE_HANDLE hPage = (WB_PAGE_HANDLE)worksetID;
    BOOL         bConfirm = FALSE;

    DebugEntry(wbOnGraphicObjectReplaceInd);

    //
    // Record that the contents have changed
    //
    m_changed = TRUE;
    TRACE_OUT(("Changed flag now TRUE"));

    //
    // These events are handled within the core until the client is ready.
    //
    if (m_state != STATE_IDLE)
    {
        TRACE_OUT(("Replace of graphic object before registration"));
        bConfirm = TRUE;
    }

    //
    // Check that this page is actually in use
    //
    if (GetPageState(hPage)->state != PAGE_IN_USE)
    {
        TRACE_OUT(("Replace in page that is not in use"));
        bConfirm = TRUE;
    }

    //
    // Check whether we are to pass the replace on to the client
    //
    if (bConfirm)
    {
        //
        // Confirm the change to ObMan (cannot fail)
        //
        TRACE_OUT(("Confirming replace immediately"));
        OM_ObjectReplaceConfirm(m_pomClient,
                            m_hWSGroup,
                            worksetID,
                            pObj);
    }
    else
    {
        //
        // Inform the client of the object being added
        //
        TRACE_OUT(("Posting WBP_EVENT_GRAPHIC_REPLACE_IND"));
        WBP_PostEvent(
                 0,                               // No delay
                 WBP_EVENT_GRAPHIC_REPLACE_IND,   // Event type
                 hPage,                           // Page handle
                 (UINT_PTR)pObj);                 // Object handle
    }


    DebugExitVOID(wbOnGraphicObjectReplaceInd);
}



//
//
// Name:    wbWritePageControl
//
// Purpose: Write the page control information to the Page Control Workset
//          from the copy held in client data. We write only those pages
//          which are marked as being in use (and are not pending delete).
//
// Returns: Error code
//
//
UINT WbClient::wbWritePageControl(BOOL create)
{
    UINT                result = 0;
    UINT                rc;
    UINT                index;
    UINT                length;
    PWB_PAGE_ORDER    pPageOrderInternal = &(m_pageOrder);
    PWB_PAGE_ORDER    pPageOrderExternal;
    WB_PAGE_HANDLE    hPage;
    PWB_PAGE_STATE    pPageState;
    POM_OBJECT  pObj;
    POM_OBJECTDATA       pData = NULL;
    UINT          generation;

    DebugEntry(wbWritePageControl);

    //
    // Allocate memory for the object.
    //
    length = sizeof(WB_PAGE_ORDER)
         - (  (WB_MAX_PAGES - pPageOrderInternal->countPages)
            * sizeof(OM_WORKSET_ID));

    if (OM_ObjectAlloc(m_pomClient,
                      m_hWSGroup,
                      PAGE_CONTROL_WORKSET,
                      length,
                      &pData) != 0)
    {
        ERROR_OUT(("Error allocating object"));
        DC_QUIT;
    }

    pData->length = length;

    //
    // Get a pointer to the page control object itself
    //
    pPageOrderExternal = (PWB_PAGE_ORDER) pData->data;

    //
    // Set the object type
    //
    pPageOrderExternal->objectType = TYPE_CONTROL_PAGE_ORDER;

    //
    // Increment the page list generation number indicating that we have
    // written a new version of the page list.
    //
    generation = MAKELONG(pPageOrderInternal->generationLo,
                              pPageOrderInternal->generationHi);
    generation++;
    pPageOrderInternal->generationLo = LOWORD(generation);
    pPageOrderInternal->generationHi = HIWORD(generation);

    //
    // Copy the page control data
    //
    pPageOrderExternal->objectType   = TYPE_CONTROL_PAGE_ORDER;
    pPageOrderExternal->generationLo = pPageOrderInternal->generationLo;
    pPageOrderExternal->generationHi = pPageOrderInternal->generationHi;
    pPageOrderExternal->countPages   = 0;

    //
    // Loop through the internal page order finding the pages that are in
    // use.
    //
    for (index = 0; index < pPageOrderInternal->countPages; index++)
    {
        //
        // Get the handle of the next page
        //
        hPage = (pPageOrderInternal->pages)[index];

        //
        // Check the page state
        //
        pPageState = GetPageState(hPage);
        if (   (pPageState->state == PAGE_IN_USE)
           && (pPageState->subState == PAGE_STATE_EMPTY))
        {
            //
            // Add the page to the external list
            //
            (pPageOrderExternal->pages)[pPageOrderExternal->countPages] = hPage;
            pPageOrderExternal->countPages++;
        }
    }

    //
    // We expect always to copy at least one page
    //
    ASSERT((pPageOrderExternal->countPages >= 1));

    //
    // Check whether we are creating or replacing the object
    //
    if (create)
    {
        //
        // Add the object to the workset (we never update these objects, so the
        // update length is set to 0).
        //
        rc = OM_ObjectAdd(m_pomClient,
                          m_hWSGroup,
                          PAGE_CONTROL_WORKSET,
                          &pData,
                          0,
                          &pObj,
                          LAST);
    }
    else
    {
        //
        // Replace the existing object
        //
        TRACE_OUT(("Replacing Page Control Object"));
        rc = OM_ObjectReplace(m_pomClient,
                          m_hWSGroup,
                          PAGE_CONTROL_WORKSET,
                          m_pObjPageControl,
                          &pData);
    }

    if (rc != 0)
    {
        //
        // Discard the object - it was not used to replace the existing one
        //
        TRACE_OUT(("Adding Page Control Object"));
        OM_ObjectDiscard(m_pomClient,
                     m_hWSGroup,
                     PAGE_CONTROL_WORKSET,
                     &pData);

        ERROR_OUT(("Error adding/replacing page control object"));
        DC_QUIT;
    }

DC_EXIT_POINT:
    DebugExitDWORD(wbWritePageControl, result);
    return(result);
}



//
//
// Name:    wbCreateSyncControl
//
// Purpose: Create the sync control object
//
// Returns: None
//
//
UINT WbClient::wbCreateSyncControl(void)
{
    UINT    result;
    WB_SYNC sync;

    DebugEntry(wbCreateSyncControl);

    //
    // Set the sync information to no page, empty rectangle
    //
    ZeroMemory(&sync, sizeof(WB_SYNC));
    sync.length             = WB_SYNC_SIZE;
    sync.currentPage        = WB_PAGE_HANDLE_NULL;

    //
    // Write the object
    //
    result = wbWriteSyncControl(&sync, TRUE);

    DebugExitDWORD(wbCreateSyncControl, result);
    return(result);
}



//
//
// Name:    wbWriteSyncControl
//
// Purpose: Write the Sync Control object to the Page Control Workset
//
// Returns: Error code
//
//
UINT WbClient::wbWriteSyncControl
(
    PWB_SYNC    pSync,
    BOOL        create
)
{
    UINT         result = 0;
    UINT         rc;
    POM_OBJECT pObj;
    POM_OBJECTDATA      pData = NULL;
    PWB_SYNC_CONTROL pSyncControl;

    DebugEntry(wbWriteSyncControl);

    //
    // Allocate memory for the object.
    //
    rc = OM_ObjectAlloc(m_pomClient,
                      m_hWSGroup,
                      SYNC_CONTROL_WORKSET,
                      WB_SYNC_CONTROL_SIZE,
                      &pData);
    if (rc != 0)
    {
        ERROR_OUT(("Error allocating object"));
        DC_QUIT;
    }

    pData->length = WB_SYNC_CONTROL_SIZE;

    //
    // Copy the sync control data from the client information
    //
    pSyncControl           = (PWB_SYNC_CONTROL) pData->data;
    pSyncControl->personID = m_personID;
    memcpy(&(pSyncControl->sync), pSync, WB_SYNC_SIZE);

    //
    // Check whether we are creating or replacing the object
    //
    if (create)
    {
        //
        // Add the object to the workset
        //
        rc = OM_ObjectAdd(m_pomClient,
                          m_hWSGroup,
                          SYNC_CONTROL_WORKSET,
                          &pData,
                          WB_SYNC_CONTROL_SIZE,
                          &pObj,
                          LAST);

        //
        // If successful
        //
        if (rc == 0)
        {
            //
            // Save the handle of the sync control object
            //
            m_pObjSyncControl = pObj;

            //
            // Make sure we do not discard the object below
            //
            pData = NULL;
        }
    }
    else
    {
        //
        // Replace the existing object
        //
        rc = OM_ObjectReplace(m_pomClient,
                          m_hWSGroup,
                          SYNC_CONTROL_WORKSET,
                          m_pObjSyncControl,
                          &pData);

        //
        // Make sure we do not discard the object below
        //
        pData = NULL;
    }


DC_EXIT_POINT:
    //
    // If we still have the Sync Control object - discard it
    //
    if (pData != NULL)
    {
        //
        // Discard the object - it was not used to replace the existing one
        //
        OM_ObjectDiscard(m_pomClient,
                     m_hWSGroup,
                     SYNC_CONTROL_WORKSET,
                     &pData);
    }

    //
    // If an error occurred during processing - report it
    //
    if (rc != 0)
    {
        ERROR_OUT(("Error adding/replacing sync control object"));
        wbError();
        DC_QUIT;
    }

    DebugExitDWORD(wbWriteSyncControl, result);
    return(result);
}



//
//
// Name:    wbSelectPersonColor
//
// Purpose: Select a color identifier for the local user
//
// Returns: Selected color
//
//
UINT WbClient::wbSelectPersonColor(void)
{
    UINT    count = 0;
    UINT    result;
    POM_OBJECT   pObjUser;

    DebugEntry(wbSelectPersonColor);

    //
    // Select the color according to the order in the workset.  See comments
    // in wbCheckPersonColor for further details.
    //

    //
    // start at the first object, search for the position of the local user's
    // user object.
    //
    result = OM_ObjectH(m_pomClient,
                           m_hWSGroup,
                           USER_INFORMATION_WORKSET,
                           0,
                           &pObjUser,
                            FIRST);
    while ((result == 0) && (pObjUser != m_pObjLocal))
    {
        count++;
        result = OM_ObjectH(m_pomClient,
                            m_hWSGroup,
                            USER_INFORMATION_WORKSET,
                            pObjUser,
                            &pObjUser,
                            AFTER);

    }

    if ((result != 0) && (result != OM_RC_NO_SUCH_OBJECT))
    {
        ERROR_OUT(("Unexpected return code from ObMan"));
    }

    DebugExitDWORD(wbSelectPersonColor, count);
    return (count);
}



//
//
// Name:    wbCheckPersonColor
//
// Purpose: Check whether a new user has usurped our color. If so we must
//          update our own color.
//
// Returns: None
//
//
void WbClient::wbCheckPersonColor
(
    POM_OBJECT    hCheckObject
)
{
    POM_OBJECTDATA        pCheckObject = NULL;
    PWB_PERSON         pUser;
    WB_PERSON          user;

    DebugEntry(wbCheckPersonColor);

    //
    // Read the new user information
    //
    if (OM_ObjectRead(m_pomClient,
                     m_hWSGroup,
                     USER_INFORMATION_WORKSET,
                     hCheckObject,
                     &pCheckObject) != 0)
    {
        wbError();
        DC_QUIT;
    }

    pUser = (PWB_PERSON) pCheckObject->data;

    //
    // Compare the color identifier in the new user with that of the local
    // user, if they are different there is nothing to do.
    //
    if (pUser->colorId == m_colorId)
    {
        TRACE_OUT(("New user has same color as local user = %d", pUser->colorId));

        //
        // The user color is determined by the order in the workset group of
        // the user objects.  The first user has color 0, the second color 1
        // etc.
        //
        // When a user leaves the workset, however, the colors do not change.
        //
        // When a new user joins, it sets its color to its new position, and
        // the others will then be forced to change accordingly.  Whenever an
        // object add or update is received where the new remote user color
        // clashes with the local one, it is always the local user's job to
        // change color, since the remote user has selected his new color
        // according to his current position in the workset.  The local user
        // can't have the same position (since two users have two distinct user
        // objects, so therefore must have the wrong color.
        //

        //
        // Get the user object for the local user
        //
        if (wbPersonGet(m_pObjLocal, &user) != 0)
        {
            DC_QUIT;
        }

        //
        // Update the color
        //
        TRACE_OUT(("Old color ID for local user is %d", user.colorId));
        user.colorId = (TSHR_UINT16)wbSelectPersonColor();
        TRACE_OUT(("New color ID for local user is %d", user.colorId));

        //
        // Copy the person's color into the client's data
        //
        m_colorId = user.colorId;

        //
        // Write the new user information back
        //
        if (wbPersonUpdate(&user) != 0)
        {
            DC_QUIT;
        }
    }

DC_EXIT_POINT:

    //
    // If an object has been read, release it now
    //
    if (pCheckObject != NULL)
    {
        OM_ObjectRelease(m_pomClient,
                     m_hWSGroup,
                     USER_INFORMATION_WORKSET,
                     hCheckObject,
                     &pCheckObject);
    }

    DebugExitVOID(wbCheckPersonColor);
}



//
//
// Name:    wbWriteLock
//
// Purpose: Add a lock object to the Page Control Workset
//
// Returns: Error code
//
//
UINT WbClient::wbWriteLock(void)
{
    UINT         result;
    POM_OBJECTDATA      pData;
    PWB_LOCK         pLock;
    POM_OBJECT pObj;

    DebugEntry(wbWriteLock);

    //
    // Create a lock object
    //
    result = OM_ObjectAlloc(m_pomClient,
                            m_hWSGroup,
                            PAGE_CONTROL_WORKSET,
                            sizeof(WB_LOCK),
                            &pData);
    if (result != 0)
    {
        ERROR_OUT(("Unable to allocate lock object = %d", result));
        wbError();
        DC_QUIT;
    }

    pData->length = sizeof(WB_LOCK);

    //
    // Set the lock object fields
    //
    pLock = (PWB_LOCK) pData->data;
    pLock->objectType = TYPE_CONTROL_LOCK;
    pLock->personID     = m_personID;
    pLock->lockType   = m_lockRequestType;

    //
    // If we already have the lock, then we can just replace the object
    //
    if (m_pObjLock == NULL)
    {
        //
        // Add the lock object to the Workset.  The Add indication received
        // by the remote users signals the presence of the lock to them.
        //
        result = OM_ObjectAdd(m_pomClient,
                                  m_hWSGroup,
                                  PAGE_CONTROL_WORKSET,
                                  &pData,
                                  sizeof(WB_LOCK),
                                  &pObj,
                                  LAST);
    }
    else
    {
        //
        // Replace the existing object
        //
        result = OM_ObjectReplace(m_pomClient,
                                  m_hWSGroup,
                                  PAGE_CONTROL_WORKSET,
                                  m_pObjLock,
                                  &pData);
    }

    if (result != 0)
    {
        //
        // The add or replace failed, we must discard the object
        //
        OM_ObjectDiscard(m_pomClient,
                         m_hWSGroup,
                         PAGE_CONTROL_WORKSET,
                         &pData);

        ERROR_OUT(("Error adding user object"));
        wbError();
        DC_QUIT;
    }

    //
    // Save the handle of the lock object
    //
    TRACE_OUT(("Lock handle was %x, now %x", m_pObjLock, pObj));
    m_pObjLock = pObj;

DC_EXIT_POINT:
    DebugExitDWORD(wbWriteLock, result);
    return(result);
}



//
//
// Name:    wbReadLock
//
// Purpose: Update the lock information stored in the client data after a
//          change in the Lock Object.
//
// Returns: Error code
//
//
void WbClient::wbReadLock(void)
{
    UINT  count = 0;

    DebugEntry(wbReadLock);

    //
    // Before we read the lock information we need to ensure that the
    // PAGE_CONTROL_WORKSET and the USER_INFORMATION_WORKSET both contain
    // the objects we need.  If either of the objects are missing, quit and
    // wait until we are called again - this function will be called
    // whenever new objects are added to these worksets.
    //
    OM_WorksetCountObjects(m_pomClient,
                           m_hWSGroup,
                           USER_INFORMATION_WORKSET,
                           &count);
    TRACE_OUT(("%d objects in USER_INFORMATION_WORKSET", count));
    if (count == 0)
    {
        TRACE_OUT(("Need to wait for USER_INFO object"));
        DC_QUIT;
    }
    OM_WorksetCountObjects(m_pomClient,
                           m_hWSGroup,
                           PAGE_CONTROL_WORKSET,
                           &count);
    TRACE_OUT(("%d objects in PAGE_CONTROL_WORKSET", count));
    if (count == 0)
    {
        TRACE_OUT(("Need to wait for PAGE_CONTROL object"));
        DC_QUIT;
    }

    TRACE_OUT(("Process lock"));
    wbProcessLockNotification();

DC_EXIT_POINT:
    DebugExitVOID(wbReadLock);
}


//
//
// Name:    wbProcessLockNotification
//
// Purpose:
//
// Returns: Error code
//
//
void WbClient::wbProcessLockNotification(void)
{
    UINT            rc = 0;
    POM_OBJECTDATA      pData;
    PWB_LOCK        pLock;
    WB_LOCK_TYPE    lockType;
    POM_OBJECT   pObjPersonLock;
    POM_OBJECT   pObj;
    POM_OBJECT   pObjLock;
    UINT            objectType = 0;

    DebugEntry(wbProcessLockNotification);

    //
    // Get the handle of the lock object.  We use the last object in the
    // workset to protect against lock objects being left lying around.
    //
    rc = OM_ObjectH(m_pomClient,
                        m_hWSGroup,
                        PAGE_CONTROL_WORKSET,
                        0,
                        &pObj,
                        LAST);
    if (rc != 0)
    {
        ERROR_OUT(("Error getting lock object handle = %d", rc));
        wbError();
        DC_QUIT;
    }

    //
    // Check that this is the CONTROL_LOCK object.  Quit if it isnt - we
    // will be called again later when the object arrices.
    //
    rc = wbGetPageObjectType(pObj, &objectType);
    if (rc != 0)
    {
        DC_QUIT;
    }
    if (objectType != TYPE_CONTROL_LOCK)
    {
        TRACE_OUT(("not LOCK control object - quit"));
        DC_QUIT;
    }

    //
    // Save the handle of the lock object
    //
    pObjLock = pObj;

    //
    // Read the object
    //
    rc = OM_ObjectRead(m_pomClient,
                       m_hWSGroup,
                       PAGE_CONTROL_WORKSET,
                       pObj,
                       &pData);
    if (rc != 0)
    {
        ERROR_OUT(("Error reading lock object %d", rc));
        wbError();
        DC_QUIT;
    }
    pLock = (PWB_LOCK) &(pData->data);

    //
    // Save the lock details
    //
    lockType   = (WB_LOCK_TYPE)pLock->lockType;
    TRACE_OUT(("Lock type %d", lockType));

    //
    // Convert the object ID held in the PAGE_CONTROL workset to an object
    // handle.
    //
    rc = OM_ObjectIDToPtr(m_pomClient,
                             m_hWSGroup,
                             USER_INFORMATION_WORKSET,
                             pLock->personID,
                             &pObjPersonLock);

    //
    // The return code is checked after the object release to ensure that
    // the object is not held and read again.
    //

    //
    // Release the lock object
    //
    OM_ObjectRelease(m_pomClient,
                     m_hWSGroup,
                     PAGE_CONTROL_WORKSET,
                     pObj,
                     &pData);

    //
    // Check the return code from the ID to Handle call
    //
    if (rc == OM_RC_BAD_OBJECT_ID)
    {
        WARNING_OUT(("Unknown ID - wait for next add of user object"));
        DC_QUIT;
    }
    else if (rc != 0)
    {
        ERROR_OUT(("Error (%d) converting lock user ID to handle", rc));
        wbError();
        DC_QUIT;
    }

    //
    // Validate the lock state and details
    //
    switch (m_lockState)
    {
        //
        // In this state we do not actually have the lock, but are waiting
        // for confirmation of an earlier workset-lock request. In this
        // case, we let the front end know that the lock request has failed
        // before sending indication of the lock by the other user.
        //
        case LOCK_STATE_PENDING_LOCK:
            ASSERT((pObjPersonLock != m_pObjLocal));

            m_lockState = LOCK_STATE_LOCKED_OUT;
            TRACE_OUT(("Moved lock state to LOCK_STATE_LOCKED_OUT"));

            WBP_PostEvent(
                         0,                      // No delay
                         WBP_EVENT_LOCK_FAILED,  // Lock request failed
                         0,                      // No parameters
                         0);
            break;

        //
        // In these states we do not have a lock - this must be a new lock
        // from remote user or an update to an old lock.
        //
        case LOCK_STATE_EMPTY:
        case LOCK_STATE_LOCKED_OUT:
            ASSERT((pObjPersonLock != m_pObjLocal));

            //
            // Update the lock state to show that we are now locked out
            //
            m_lockState = LOCK_STATE_LOCKED_OUT;
            TRACE_OUT(("Moved lock state to LOCK_STATE_LOCKED_OUT"));
            break;

        //
        // In these states we have the lock (or are expecting to get it)
        //
        case LOCK_STATE_GOT_LOCK:
        case LOCK_STATE_PENDING_ADD:
            ASSERT((pObjPersonLock == m_pObjLocal));

            //
            // Update the lock state to show that we are now locked out
            //
            m_lockState = LOCK_STATE_GOT_LOCK;
            TRACE_OUT(("Moved lock state to LOCK_STATE_GOT_LOCK"));
            break;

        //
        // The lock request has been cancelled - unlock the WS.
        //
        case LOCK_STATE_CANCEL_LOCK:
            break;

        //
        // In any other state we are not expecting any lock
        //
        default:
            ERROR_OUT(("Not expecting lock object add"));
            break;
    }

    //
    // Save the lock details
    //
    TRACE_OUT(("Lock handle was %x, now %x",
             m_pObjLock, pObjLock));
    m_pObjLock          = pObjLock;
    m_lockType          = lockType;
    m_pObjPersonLock    = pObjPersonLock;

    //
    // If the lock has subsequently been cancelled, unlock the WS.
    //
    if (m_lockState == LOCK_STATE_CANCEL_LOCK)
    {
        TRACE_OUT(("Cancel lock"));
        m_lockState = LOCK_STATE_GOT_LOCK;
        wbUnlock();
    }
    else
    {
        //
        // Inform the client of the lock.  The notification will be trapped
        // by the core if the client is not fully registered.
        //
        wbSendLockNotification();
    }

DC_EXIT_POINT:
    DebugExitVOID(wbProcessLockNotification);
}



//
//
// Name:    wbSendLockNotification
//
// Purpose: Post a lock notification to the client.  The lock information
//          held in the client memory must be up to date when this function
//          is called.
//
// Returns: Error code
//
//
void WbClient::wbSendLockNotification(void)
{
    UINT result = 0;
    UINT lockEvent;

    DebugEntry(wbSendLockNotification);

    //
    // Check that we are in a valid state for sending a lock notification
    //
    if (   (m_lockState == LOCK_STATE_GOT_LOCK)
        || (m_lockState == LOCK_STATE_LOCKED_OUT)
        || (m_lockState == LOCK_STATE_EMPTY))
    {
        //
        // Verify the lock type
        //
        switch (m_lockType)
        {
            case WB_LOCK_TYPE_CONTENTS:
                TRACE_OUT(("Posting WBP_EVENT_CONTENTS_LOCKED"));
                lockEvent = WBP_EVENT_CONTENTS_LOCKED;
                break;

            case WB_LOCK_TYPE_PAGE_ORDER:
                TRACE_OUT(("Posting WBP_EVENT_PAGE_ORDER_LOCKED"));
                lockEvent = WBP_EVENT_PAGE_ORDER_LOCKED;
                break;

            case WB_LOCK_TYPE_NONE:
                TRACE_OUT(("Posting WBP_EVENT_UNLOCKED"));
                lockEvent = WBP_EVENT_UNLOCKED;
                break;

            default:
                ERROR_OUT(("Bad lock type %d", (UINT) m_lockType));
                DC_QUIT;
        }

        //
        // Tell the client that the lock has been acquired or released
        //
        WBP_PostEvent(
                 0,
                 lockEvent,
                 0,
                 (UINT_PTR)m_pObjPersonLock);

        TRACE_OUT(("Sent lock notification"));
    }

DC_EXIT_POINT:
    DebugExitVOID(wbSendLockNotification);
}



//
//
// Name:    wbOnWBPLock
//
// Purpose: Process a successful lock acquisitoin
//
// Returns: Error code
//
//
BOOL WbClient::wbOnWBPLock(void)
{
    BOOL    processed = TRUE;

    DebugEntry(wbOnWBPLock);

    //
    // If we are registering and have just acquired the lock - we can now
    // continue the registration process.
    //

    //
    // Test the current state
    //
    switch (m_state)
    {
        //
        // We are waiting for registration to continue
        //
        case STATE_REGISTERING:
            //
            // Act on the registration substate
            //
            if (m_subState == STATE_REG_PENDING_LOCK)
            {
                //
                // Check that it is us who now has the lock
                //
                if (m_lockState != LOCK_STATE_GOT_LOCK)
                {
                    TRACE_OUT(("It is not us who has the lock"));

                    //
                    // Another client has acquired the lock - we must wait for them
                    // to add the Page Control Object.
                    //
                    m_subState = STATE_REG_PENDING_PAGE_CONTROL;
                    TRACE_OUT(("Moved to substate STATE_REG_PENDING_PAGE_CONTROL"));
                    DC_QUIT;
                }

                //
                // We now have the Page Control Workset locked - check for the
                // existence of the Page Control and Sync Control objects.  (We
                // have to do this because another client could have locked the
                // workset, added the objects and unlocked the workset just before
                // we requested the lock.  The Page Control Object may not have
                // reached us before we requested the lock.  Now that we have the
                // lock we are guaranteed to have all objects in the workset so the
                // object add events may have arrived just before the lock
                // confirmation.
                //
                if (   (m_pObjPageControl != 0)
                    && (m_pObjSyncControl != 0))
                {
                    //
                    // Unlock the workset
                    //
                    wbUnlock();

                    //
                    // Wait for the unlock to complete
                    //
                    m_subState = STATE_REG_PENDING_UNLOCK;
                    TRACE_OUT(("Moved to substate STATE_REG_PENDING_UNLOCK"));
                    DC_QUIT;
                }

                //
                // We are the first in the call - we must add the Page Control
                // Object.  (It is possible that another client added the Page
                // Control object and then failed.  To cover this we check
                // separately for the Page Control and Sync objects.)
                //
                if (m_pObjPageControl == 0)
                {
                    //
                    // Add a single page to the page control object using the first
                    // page workset (which we always open).
                    //
                    wbPagesPageAdd(0, FIRST_PAGE_WORKSET,
                         PAGE_FIRST);

                    //
                    // Write the Page Control information
                    //
                    if (wbWritePageControl(TRUE) != 0)
                    {
                        ERROR_OUT(("Error adding Page Control Object"));
                        wbError();
                        DC_QUIT;
                    }

                    //
                    // Update the state to "waiting for Page Control"
                    //
                    m_subState = STATE_REG_PENDING_PAGE_CONTROL;
                    TRACE_OUT(("Moved to substate STATE_REG_PENDING_PAGE_CONTROL"));
                    DC_QUIT;
                }

                //
                // The Page Control object is there, so the Sync Control object
                // must not be (we checked above for both being there and would
                // have exited by now if they were).
                //
                ASSERT((m_pObjSyncControl == 0));

                //
                // Create the Sync Control Object.
                //
                if (wbCreateSyncControl() != 0)
                {
                    ERROR_OUT(("Error adding Sync Control Object"));
                    wbError();
                    DC_QUIT;
                }

                //
                // Wait for the Sync Control object to be added
                //
                m_subState = STATE_REG_PENDING_SYNC_CONTROL;
                TRACE_OUT(("Moved substate to STATE_REG_PENDING_SYNC_CONTROL"));
                DC_QUIT;
            }
            break;

        case STATE_IDLE:
            //
            // We are fully registered.  The event must be passed on to the
            // front-end
            //
            processed = FALSE;
            break;

        //
        // We are in an unknown state
        //
        default:
            ERROR_OUT(("Bad client major state"));
            break;
    }

DC_EXIT_POINT:
    DebugExitBOOL(wbOnWBPLock, processed);
    return(processed);
}

//
//
// Name:    wbOnWBPLockFailed
//
// Purpose: Process a failed lock acquisition
//
// Returns: Error code
//
//
BOOL WbClient::wbOnWBPLockFailed(void)
{
    BOOL    processed = TRUE;

    DebugEntry(wbOnWBPLockFailed);

    //
    // Check the current state
    //
    switch (m_state)
    {
        case STATE_REGISTERING:
            //
            // If we are registering and have just failed to acquire the lock -
            // this is because another user has the lock.  If both the page and
            // sync objects have been added, finish registration, otherwise wait
            // for them to be added.
            //
            if ( (m_pObjPageControl != 0) &&
                 (m_pObjSyncControl != 0))
            {
                TRACE_OUT(("Page Control and Sync Control objects both there."));
                TRACE_OUT(("Registration can be completed"));
                wbOnControlWorksetsReady();
                DC_QUIT;
            }

            if (m_pObjPageControl == 0)
            {
                TRACE_OUT(("Waiting for page control"));
                m_subState = STATE_REG_PENDING_PAGE_CONTROL;
                DC_QUIT;
            }

            if (m_pObjSyncControl == 0)
            {
                TRACE_OUT(("Waiting for sync control"));
                m_subState = STATE_REG_PENDING_SYNC_CONTROL;
                DC_QUIT;
            }
            break;

        case STATE_IDLE:
            //
            // We are fully registered.  The event must be passed on to the
            // front-end
            //
            processed = FALSE;
            break;

        default:
            ERROR_OUT(("Bad main state"));
            break;
    }

DC_EXIT_POINT:
    DebugExitBOOL(wbOnWBPLockFailed, processed);
    return(processed);
}

//
//
// Name:    wbOnWBPUnlocked
//
// Purpose: Process an unlock notification
//
// Returns: Error code
//
//
BOOL WbClient::wbOnWBPUnlocked(void)
{
    BOOL    processed = TRUE;

    DebugEntry(wbOnWBPUnlocked);

    //
    // If we are registering and waiting to unlock the Page Control Workset
    // we must complete registration here.
    //

    //
    // Check the current state
    //
    switch (m_state)
    {
        case STATE_REGISTERING:
            //
            // Check whether we are expecting his event
            //
            if(m_subState == STATE_REG_PENDING_UNLOCK)
            {
                //
                // Continue the registration process
                //
                wbOnControlWorksetsReady();
                DC_QUIT;
            }

            //
            // We were not expecting the unlock event
            //
            WARNING_OUT(("Unexpected unlock event"));
            break;

        case STATE_IDLE:
            //
            // We are fully registered.  The event must be passed on to the
            // front-end
            //
            processed = FALSE;
            break;

        default:
            ERROR_OUT(("Bad main state"));
            break;
    } // Switch on client state


DC_EXIT_POINT:
    DebugExitBOOL(wbOnWBPUnlocked, processed);
    return(processed);
}




//
//
// Name:    wbOnWBPPageOrderUpdated
//
// Purpose: Process a page order updated notification
//
// Returns: Error code
//
//
BOOL WbClient::wbOnWBPPageOrderUpdated(void)
{
    BOOL    processed = FALSE;

    DebugEntry(wbOnWBPPageOrderUpdated);

    //
    // If we are registering and waiting for the Page Order to be brought
    // up-to-date we can now continue registration.
    //
    if (m_state == STATE_REGISTERING)
    {
        //
        // Show that we have processed the event (we do not want to pass it on
        // to the client, they are not yet fully registered and will not be
        // expecting it).
        //
        processed = TRUE;

        //
        // If we have enough pages ready in the cache, we have completed
        // registration.  (Otherwise the call to CheckReadyPages will open
        // another page and will complete registration later.)
        //
        if (wbCheckReadyPages())
        {
            wbCompleteRegistration();
            DC_QUIT;
        }

        //
        // We must wait for sufficiently many pages to be ready
        //
        m_subState = STATE_REG_PENDING_READY_PAGES;
        TRACE_OUT(("Moved substate to STATE_REG_PENDING_READY_PAGES"));
    }

DC_EXIT_POINT:
    DebugExitBOOL(wbOnWBPPageOrderUpdated, processed);
    return(processed);
}



//
//
// Name:    wbPersonGet
//
// Purpose: Get user details
//
// Returns: Error code
//
//
UINT WbClient::wbPersonGet
(
    POM_OBJECT      pObjUser,
    PWB_PERSON      pUser
)
{
    UINT    result = 0;
    POM_OBJECTDATA pUserObject;

    DebugEntry(wbPersonGet);

    if (pObjUser == m_pObjLocal)
    {
        TRACE_OUT(("Call is for local user details"));
    }

    //
    // Read the object.
    //
    result = OM_ObjectRead(m_pomClient,
                         m_hWSGroup,
                         USER_INFORMATION_WORKSET,
                         pObjUser,
                         &pUserObject);
    if (result != 0)
    {
        ERROR_OUT(("OM_ObjectRead = %d", result));
        DC_QUIT;
    }

    //
    // Copy the read user object into the buffer passed
    //
    memcpy(pUser, pUserObject->data, sizeof(WB_PERSON));
    TRACE_OUT(("CMG personID %u", pUser->cmgPersonID));

    //
    // Release the object
    //
    OM_ObjectRelease(m_pomClient,
                   m_hWSGroup,
                   USER_INFORMATION_WORKSET,
                    pObjUser,
                   &pUserObject);

    //
    // If the call is for the local user, update the color field to ensure it
    // doesn't get overwritten in a race condition with the front-end (i.e.
    // the front end tries to update the user before the color-change event
    // has been received).  The core "knows better" than ObMan what the local
    // user's color is.  This is safe because the color field is only ever
    // changed locally.
    //
    if (pObjUser == m_pObjLocal)
    {
        pUser->colorId = (TSHR_UINT16)m_colorId;
    }


DC_EXIT_POINT:
    DebugExitDWORD(wbPersonGet, result);
    return(result);
}



//
//
// Name:    wbPersonUpdate
//
// Purpose: Update the local user object - this is only used by the CORE -
//          the front-end calls WBP_SetPersonData, which does a _replace_.
//
// Returns: Error code
//
//
UINT WbClient::wbPersonUpdate(PWB_PERSON pUser)
{
    UINT    result = 0;
    POM_OBJECTDATA pUserObject;

    DebugEntry(wbPersonUpdate);

    //
    // Allocate a user object
    //
    result = OM_ObjectAlloc(m_pomClient,
                          m_hWSGroup,
                          USER_INFORMATION_WORKSET,
                          sizeof(WB_PERSON),
                          &pUserObject);
    if (result != 0)
    {
        ERROR_OUT(("OM_ObjectAlloc = %d", result));
        DC_QUIT;
    }

    //
    // Set the length of the object
    //
    pUserObject->length = WB_PERSON_OBJECT_UPDATE_SIZE,

    //
    // Copy the user information into the ObMan object
    //
    memcpy(pUserObject->data, pUser, sizeof(WB_PERSON));

    //
    // Update the object
    //
    result = OM_ObjectUpdate(m_pomClient,
                           m_hWSGroup,
                           USER_INFORMATION_WORKSET,
                           m_pObjLocal,
                           &pUserObject);

    if (result != 0)
    {
        ERROR_OUT(("OM_ObjectUpdate = %d", result));

        //
        // Discard the object
        //
        OM_ObjectDiscard(m_pomClient,
                     m_hWSGroup,
                     USER_INFORMATION_WORKSET,
                     &pUserObject);

        DC_QUIT;
    }

    //
    // Note that the object has not yet been updated.  An
    // OM_OBJECT_UPDATE_IND event will be generated.
    //

DC_EXIT_POINT:
    DebugExitDWORD(wbPersonUpdate, result);
    return(result);
}



//
//
// Name:    wbGetNetUserID().
//
// Purpose: Get the network user ID for this client
//
// Returns:
//
//
BOOL WbClient::wbGetNetUserID(void)
{
    BOOL    result = TRUE;
    UINT  rc = 0;

    DebugEntry(wbGetNetUserID);

    rc = OM_GetNetworkUserID(m_pomClient,
                             m_hWSGroup,
                             &m_clientNetID);
    if (rc != 0)
    {
        if (rc == OM_RC_LOCAL_WSGROUP)
        {
            m_clientNetID = 0;
        }
        else
        {
            result = FALSE;
        }
    }

    DebugExitBOOL(wbGetNetUserID, result);
    return(result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32.95\im.cpp ===
#include "precomp.h"


//
// IM.C
// Backport Input Manager
//
// Copyright(c) Microsoft 1997-
//

extern "C"
{
    #include <asthk.h>
}

#define MLZ_FILE_ZONE  ZONE_INPUT


//
// OSI_InstallControlledHooks()
//
BOOL WINAPI OSI_InstallControlledHooks(BOOL fEnable, BOOL fDesktop)
{
    ASSERT(g_hInstAs16);
    return(OSIInstallControlledHooks16(fEnable, fDesktop));
}



//
// OSI_InjectMouseEvent()
//
void WINAPI OSI_InjectMouseEvent
(   
    DWORD       flags,
    LONG        x,
    LONG        y,
    DWORD       mouseData,
    DWORD       dwExtraInfo
)
{
    ASSERT(g_hInstAs16);

    TRACE_OUT(("Before MOUSE inject:  %08lx, %08lx %08lx",
        flags, mouseData, dwExtraInfo));

    OSIInjectMouseEvent16(flags, x, y, mouseData, dwExtraInfo);

    TRACE_OUT(("After MOUSE inject"));
}



//
// OSI_InjectKeyboardEvent()
//
void WINAPI OSI_InjectKeyboardEvent
(
    DWORD       flags,
    WORD        vkCode,
    WORD        scanCode,
    DWORD       dwExtraInfo
)
{
    ASSERT(g_hInstAs16);

    TRACE_OUT(("Before KEY inject:  %04lx, {%04x, %04x}, %04lx",
        flags, vkCode, scanCode, dwExtraInfo));

    OSIInjectKeyboardEvent16(flags, vkCode, scanCode, dwExtraInfo);

    TRACE_OUT(("After KEY inject"));
}

//
// OSI_InjectCtrlAltDel()
//
void WINAPI OSI_InjectCtrlAltDel(void)
{
	// BUGBUG do we want to support ctl-alt-del injection on Win9x?
	ERROR_OUT(("Attempt to inject Ctrl+Alt+Del"));
}


//
// OSI_DesktopSwitch()
//
void WINAPI OSI_DesktopSwitch(UINT from, UINT to)
{
    // Nothing to do, should never happen.
    ERROR_OUT(("Can't desktop switch on Win95"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32.95\osi.cpp ===
#include "precomp.h"


//
// OSI.C
// OS Isolation Layer, Win95 version
//
// Copyright(c) Microsoft 1997-
//

#include <version.h>
#include <ndcgver.h>

#include <osi.h>

extern "C"
{
    #include <asthk.h>
}

#define MLZ_FILE_ZONE  ZONE_CORE


//
// OSI_Load()
// This handles our process attach code.  It establishes thunks to the
// 16-bit Win95 library.  WE CAN ONLY DO THIS ONCE.  It is imperative
// that a flat-thunk pair come/go together, since the 32-bit piece hangs
// on to a shared memory section that is the thunk table in the 16-bit piece.
//
void OSI_Load(void)
{
    DebugEntry(OSI_Load);

    ASSERT(!g_hInstAs16);

    g_asWin95 = TRUE;

    //
    // Establish the thunks with AS16
    //
    if (FT_thkConnectToFlatThkPeer(TEXT("nmaswin.dll"), TEXT("nmas.dll")))
    {
        OSILoad16(&g_hInstAs16);
        ASSERT(g_hInstAs16);
    }
    else
    {
        ERROR_OUT(("Couldn't load nmaswin.dll"));

        //
        // Note, even on load failure, we will continue.  We just don't let
        // you do app sharing stuff.
        //
    }

    DebugExitVOID(OSI_Load);
}


//
// OSI_Unload()
// This handles our process detach code.  It frees the 16-bit library that
// we are pared with.
//
void OSI_Unload(void)
{

    DebugEntry(OSI_Unload);

    if (g_hInstAs16)
    {
        //
        // See comment for OSI_Term().  On catastropic failure, we may
        // call this BEFORE OSI_Term.  So null out variables it uses.
        //
        g_osiInitialized = FALSE;

        //
        // Free 16-bit library so loads + frees are paired.  Note that 16-bit
        // cleanup occurs when the library is freed.
        //
        FreeLibrary16(g_hInstAs16);
        g_hInstAs16 = 0;


    }

    DebugExitVOID(OSI_Unload);
}



//
// OSI_Init
// This initializes our display driver/hook dll communication code.
//
// We load our 16-bit library and establish thunks to it.
//
void OSI_Init(void)
{
    DebugEntry(OSI_Init);

    if (!g_hInstAs16)
    {
        WARNING_OUT(("No app sharing at all since library not present"));
        DC_QUIT;
    }

    //
    // We are quasi initialized.
    //
    g_osiInitialized = TRUE;

    ASSERT(g_asMainWindow);
    ASSERT(g_asHostProp);

    //
    // Call into 16-bit code to do any initialization necessary
    //

    g_asCanHost = OSIInit16(DCS_MAKE_VERSION(), g_asMainWindow, g_asHostProp,
        (LPDWORD)&g_asSharedMemory, (LPDWORD)g_poaData,
        (LPDWORD)&g_lpimSharedData, (LPDWORD)&g_sbcEnabled, (LPDWORD)g_asbcShuntBuffers,
        g_asbcBitMasks);

    if (g_asCanHost)
    {
        ASSERT(g_asSharedMemory);
        ASSERT(g_poaData[0]);
        ASSERT(g_poaData[1]);
        ASSERT(g_lpimSharedData);

        if (g_sbcEnabled)
        {
            ASSERT(g_asbcShuntBuffers[0]);
        }
    }
    else
    {
        ASSERT(!g_asSharedMemory);
        ASSERT(!g_poaData[0]);
        ASSERT(!g_poaData[1]);
        ASSERT(!g_sbcEnabled);
        ASSERT(!g_asbcShuntBuffers[0]);
    }

DC_EXIT_POINT:
    DebugExitVOID(OSI_Init);
}



//
// OSI_Term()
// This cleans up our resources, closes the driver, etc.
//
void  OSI_Term(void)
{
    UINT    i;

    DebugEntry(OSI_Term);

    ASSERT(GetCurrentThreadId() == g_asMainThreadId);

    if (g_osiInitialized)
    {
        g_osiInitialized = FALSE;

        //
        // In Ctl+Alt+Del, the process detach of mnmcpi32.dll may happen
        // first, followed by the process detach of mnmcrsp_.dll.  The latter
        // will call DCS_Term, which will call OSI_Term().  We don't want to
        // blow up.  So OSI_Unload nulls out these variables also.
        //
        ASSERT(g_hInstAs16);

        OSITerm16(FALSE);
    }

    // Clear our shared memory variables
    for (i = 0; i < 3; i++)
    {
        g_asbcBitMasks[i] = 0;
    }

    for (i = 0; i < SBC_NUM_TILE_SIZES; i++)
    {
        g_asbcShuntBuffers[i] = NULL;
    }
    g_sbcEnabled = FALSE;

    g_asSharedMemory = NULL;
    g_poaData[0] = NULL;
    g_poaData[1] = NULL;
    g_asCanHost = FALSE;
    g_lpimSharedData = NULL;

    DebugExitVOID(OSI_Term);
}



//
// OSI_FunctionRequest()
//
// This is a generic way of communicating with the graphics part of
// hosting.  On NT, it's a real display driver, and this uses ExtEscape.
// On Win95, it's a 16-bit dll, and this uses a thunk.
//
BOOL  OSI_FunctionRequest
(
    DWORD   escapeFn,
    LPOSI_ESCAPE_HEADER  pRequest,
    DWORD   requestLen
)
{
    BOOL    rc;

    DebugEntry(OSI_FunctionRequest);

    ASSERT(g_osiInitialized);
    ASSERT(g_hInstAs16);

    //
    // NOTE:  In Win95, since we use a direct thunk to communicate
    // with our driver, we don't really need to
    //      (1) Fill in an identifier (AS16 knows it's us)
    //      (2) Fill in the escape fn field
    //      (3) Fill in the version stamp (the thunk fixups will fail
    //          if pieces are mismatched)
    //
    // However, we keep the identifer field around.  If/when we support
    // multiple AS clients at the same time, we will want to know
    // who the caller was.
    //

    pRequest->identifier = OSI_ESCAPE_IDENTIFIER;
    pRequest->escapeFn   = escapeFn;
    pRequest->version    = DCS_MAKE_VERSION();

    rc = OSIFunctionRequest16(escapeFn, pRequest, requestLen);

    DebugExitBOOL(OSI_FunctionRequest, rc);
    return(rc);
}



BOOL WINAPI OSI_StartWindowTracking(void)
{
    ASSERT(g_hInstAs16);
    return(OSIStartWindowTracking16());
}



void WINAPI OSI_StopWindowTracking(void)
{
    ASSERT(g_hInstAs16);
    OSIStopWindowTracking16();
}



BOOL WINAPI OSI_IsWindowScreenSaver(HWND hwnd)
{
    ASSERT(g_hInstAs16);
    return(OSIIsWindowScreenSaver16(hwnd));
}


BOOL WINAPI OSI_IsWOWWindow(HWND hwnd)
{
    return(FALSE);
}


BOOL WINAPI OSI_ShareWindow(HWND hwnd, UINT uType, BOOL fRepaint, BOOL fUpdateCount)
{
    ASSERT(g_hInstAs16);
    return(OSIShareWindow16(hwnd, uType, fRepaint, fUpdateCount));
}


BOOL WINAPI OSI_UnshareWindow(HWND hwnd, BOOL fUpdateCount)
{
    ASSERT(g_hInstAs16);
    return(OSIUnshareWindow16(hwnd, fUpdateCount));
}

void OSI_RepaintDesktop(void)
{
}

void OSI_SetGUIEffects(BOOL fOn)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32.95\global95.h ===
//
// GLOBAL95.H
// Global variables specific to Win95
//

DC_DATA ( DWORD,     g_hInstAs16 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32.nt\globalnt.cpp ===
#include "precomp.h"


//
// This file generates the storage for our NT specific global variables
//

#include <datainit.h>
#include <globalnt.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32.nt\globalnt.h ===
//
// GLOBALNT.H
// Global variables specific to NT
//

DC_DATA ( IM_SHARED_DATA,   g_imSharedData );
DC_DATA ( IM_NT_DATA,       g_imNTData );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32.nt\precomp.h ===
#include <dcg.h>
#include <ut.h>
#include <dcs.h>
#include <globals.h>
#include <globalnt.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32.95\i386\asthkls.asm ===
page	,132

;Thunk Compiler Version 1.8  Dec 14 1994 14:53:05
;File Compiled Thu Apr 01 11:42:56 1999

;Command Line: d:\projects\cayman\dev\bin\misc\i386\thunk -t thk -o i386\asthkls.asm ..\thk\asthkls.thk 

	TITLE	$i386\asthkls.asm

	.386
	OPTION READONLY
	OPTION OLDSTRUCTS

IFNDEF IS_16
IFNDEF IS_32
%out command line error: specify one of -DIS_16, -DIS_32
.err
ENDIF  ;IS_32
ENDIF  ;IS_16


IFDEF IS_32
IFDEF IS_16
%out command line error: you can't specify both -DIS_16 and -DIS_32
.err
ENDIF ;IS_16
;************************* START OF 32-BIT CODE *************************


	.model FLAT,STDCALL


;-- Import common flat thunk routines (in k32)

externDef AllocMappedBuffer	:near32
externDef FreeMappedBuffer		:near32
externDef MapHInstLS	:near32
externDef MapHInstLS_PN	:near32
externDef MapHInstSL	:near32
externDef MapHInstSL_PN	:near32
externDef FT_PrologPrime	:near32
externDef FT_Prolog	:near32
externDef FT_Thunk	:near32
externDef QT_Thunk	:near32
externDef QT_ThunkPrime	:near32
externDef FT_Exit0	:near32
externDef FT_Exit4	:near32
externDef FT_Exit8	:near32
externDef FT_Exit12	:near32
externDef FT_Exit16	:near32
externDef FT_Exit20	:near32
externDef FT_Exit24	:near32
externDef FT_Exit28	:near32
externDef FT_Exit32	:near32
externDef FT_Exit36	:near32
externDef FT_Exit40	:near32
externDef FT_Exit44	:near32
externDef FT_Exit48	:near32
externDef FT_Exit52	:near32
externDef FT_Exit56	:near32
externDef SMapLS	:near32
externDef SUnMapLS	:near32
externDef SMapLS_IP_EBP_8	:near32
externDef SUnMapLS_IP_EBP_8	:near32
externDef SMapLS_IP_EBP_12	:near32
externDef SUnMapLS_IP_EBP_12	:near32
externDef SMapLS_IP_EBP_16	:near32
externDef SUnMapLS_IP_EBP_16	:near32
externDef SMapLS_IP_EBP_20	:near32
externDef SUnMapLS_IP_EBP_20	:near32
externDef SMapLS_IP_EBP_24	:near32
externDef SUnMapLS_IP_EBP_24	:near32
externDef SMapLS_IP_EBP_28	:near32
externDef SUnMapLS_IP_EBP_28	:near32
externDef SMapLS_IP_EBP_32	:near32
externDef SUnMapLS_IP_EBP_32	:near32
externDef SMapLS_IP_EBP_36	:near32
externDef SUnMapLS_IP_EBP_36	:near32
externDef SMapLS_IP_EBP_40	:near32
externDef SUnMapLS_IP_EBP_40	:near32

MapLS	PROTO NEAR STDCALL :DWORD
UnMapLS	PROTO NEAR STDCALL :DWORD
MapSL	PROTO NEAR STDCALL p32:DWORD

;***************** START OF KERNEL32-ONLY SECTION ******************
; Hacks for kernel32 initialization.

IFDEF FT_DEFINEFTCOMMONROUTINES

	.data
public FT_thkTargetTable	;Flat address of target table in 16-bit module.

public FT_thkChecksum32
FT_thkChecksum32	dd	016bddh


ENDIF ;FT_DEFINEFTCOMMONROUTINES
;***************** END OF KERNEL32-ONLY SECTION ******************



	.code 

;************************* COMMON PER-MODULE ROUTINES *************************

	.data
;---------------------------------------------------------------
;Flat address of target table in 16-bit module name.
;Filled in by the initial handshaking routine: FT_thkConnectToFlatThkPeer
;---------------------------------------------------------------
FT_thkTargetTable	dd	0	;Flat address of target table in 16-bit module.


	.code 

FT_thkDynaName	db	'FT_thkThkConnectionData',0

;------------------------------------------------------------
;FT_thkConnectToFlatThkPeer:;
; The 32-bit dll must call this routine once at initialization
; time. It will load the 16-bit library and fetch the pointers
; needed to make the flat thunk run.
;
; Calling sequence:
;
;   FT_thkConnectToFlatThkPeer	proto	near stdcall, dll16:dword, dll32:dword
;
;   Name16     db   'mumble16.dll',0   ;Name of 16-bit library
;   Name32     db   'mumble32.dll',0   ;Name of 32-bit library
;
;              invoke FT_thkConnectToFlatThkPeer offset Name16, offset Name32
;              or   eax,eax
;              jz   failed
;              ;success
;
;------------------------------------------------------------
public FT_thkConnectToFlatThkPeer@8
FT_thkConnectToFlatThkPeer@8:
extern ThunkInitLSF@20:near32
	pop	edx	;Pop return address
	push	offset 016bddh	;Checksum
	push	offset FT_thkDynaName	;Symbol exported from peer.
	push	offset FT_thkTargetTable	;Address of destination.
	push	edx
	jmp	ThunkInitLSF@20
		





pfnQT_Thunk_thk	dd offset QT_Thunk_thk
pfnFT_Prolog_thk	dd offset FT_Prolog_thk
	.data
QT_Thunk_thk	db	0ebh, 30
	db	30 dup(0cch)	;Patch space.
	db	0e8h,0,0,0,0	;CALL NEAR32 $
	db	58h	;POP EAX
	db	2dh,32+5,0,0,0	;SUB EAX, IMM32
	db	0bah	;MOV EDX, IMM32
	dd	offset FT_thkTargetTable - offset QT_Thunk_thk
	db	068h	;PUSH IMM32
	dd	offset QT_ThunkPrime
	db	0c3h	;RETN

FT_Prolog_thk	db	0ebh, 30
	db	30 dup(0cch)	;Patch space.
	db	0e8h,0,0,0,0	;CALL NEAR32 $
	db	5ah	;POP EDX
	db	81h,0eah, 32+5,0,0,0	;SUB EDX, IMM32
	db	52h	;PUSH EDX
	db	068h	;PUSH IMM32
	dd	offset FT_thkTargetTable - offset FT_Prolog_thk
	db	068h	;PUSH IMM32
	dd	offset FT_PrologPrime
	db	0c3h	;RETN


	.code 




ebp_top		equ	<[ebp + 8]>	;First api parameter
ebp_retval	equ	<[ebp + -64]>	;Api return value
FT_ESPFIXUP	macro	dwSpOffset
	or	dword ptr [ebp + -20], 1 SHL ((dwSpOffset) SHR 1)
endm


ebp_qttop	equ	<[ebp + 8]>


include fltthk.inc	;Support definitions
include asthkls.inc



;************************ START OF THUNK BODIES************************




;
public OSILoad16@4
OSILoad16@4:
	FAPILOG16	270
	mov	cl,11
; OSILoad16(16) = OSILoad16(32) {}
;
; dword ptr [ebp+8]:  phInstance
;
public IIOSILoad16@4
IIOSILoad16@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	SMapLS_IP_EBP_8
	push	eax
	call	dword ptr [pfnQT_Thunk_thk]
	call	SUnMapLS_IP_EBP_8
	leave
	retn	4





;
public OSIInit16@36
OSIInit16@36:
	FAPILOG16	256
	mov	cl,10
; OSIInit16(16) = OSIInit16(32) {}
;
; dword ptr [ebp+8]:  version
; dword ptr [ebp+12]:  hwnd
; dword ptr [ebp+16]:  atom
; dword ptr [ebp+20]:  ppShared
; dword ptr [ebp+24]:  ppoaShared
; dword ptr [ebp+28]:  pimShared
; dword ptr [ebp+32]:  psbcEnabled
; dword ptr [ebp+36]:  psbcShunt
; dword ptr [ebp+40]:  pBitmasks
;
public IIOSIInit16@36
IIOSIInit16@36:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	dword ptr [ebp+8]	;version: dword->dword
	push	word ptr [ebp+12]	;hwnd: dword->word
	push	word ptr [ebp+16]	;atom: dword->word
	call	SMapLS_IP_EBP_20
	push	eax
	call	SMapLS_IP_EBP_24
	push	eax
	call	SMapLS_IP_EBP_28
	push	eax
	call	SMapLS_IP_EBP_32
	push	eax
	call	SMapLS_IP_EBP_36
	push	eax
	call	SMapLS_IP_EBP_40
	push	eax
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	call	SUnMapLS_IP_EBP_20
	call	SUnMapLS_IP_EBP_24
	call	SUnMapLS_IP_EBP_28
	call	SUnMapLS_IP_EBP_32
	call	SUnMapLS_IP_EBP_36
	call	SUnMapLS_IP_EBP_40
	leave
	retn	36





;
public OSITerm16@4
OSITerm16@4:
	FAPILOG16	242
	mov	cl,9
; OSITerm16(16) = OSITerm16(32) {}
;
; dword ptr [ebp+8]:  fUnloading
;
public IIOSITerm16@4
IIOSITerm16@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;fUnloading: dword->word
	call	dword ptr [pfnQT_Thunk_thk]
	leave
	retn	4





;
public OSIFunctionRequest16@12
OSIFunctionRequest16@12:
	FAPILOG16	217
	mov	cl,8
; OSIFunctionRequest16(16) = OSIFunctionRequest16(32) {}
;
; dword ptr [ebp+8]:  escape
; dword ptr [ebp+12]:  lpvEsc
; dword ptr [ebp+16]:  cbEsc
;
public IIOSIFunctionRequest16@12
IIOSIFunctionRequest16@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	dword ptr [ebp+8]	;escape: dword->dword
	call	SMapLS_IP_EBP_12
	push	eax
	push	dword ptr [ebp+16]	;cbEsc: dword->dword
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	call	SUnMapLS_IP_EBP_12
	leave
	retn	12





;
public OSIStartWindowTracking16@0
OSIStartWindowTracking16@0:
	FAPILOG16	188
	mov	cl,7
; OSIStartWindowTracking16(16) = OSIStartWindowTracking16(32) {}
;
;
public IIOSIStartWindowTracking16@0
IIOSIStartWindowTracking16@0:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	leave
	retn





;
public OSIStopWindowTracking16@0
OSIStopWindowTracking16@0:
	FAPILOG16	160
	mov	cl,6
; OSIStopWindowTracking16(16) = OSIStopWindowTracking16(32) {}
;
;
public IIOSIStopWindowTracking16@0
IIOSIStopWindowTracking16@0:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	dword ptr [pfnQT_Thunk_thk]
	leave
	retn





;
public OSIShareWindow16@16
OSIShareWindow16@16:
	FAPILOG16	139
	mov	cl,5
; OSIShareWindow16(16) = OSIShareWindow16(32) {}
;
; dword ptr [ebp+8]:  hwnd
; dword ptr [ebp+12]:  uType
; dword ptr [ebp+16]:  fRedraw
; dword ptr [ebp+20]:  fUpdate
;
public IIOSIShareWindow16@16
IIOSIShareWindow16@16:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hwnd: dword->word
	push	word ptr [ebp+12]	;uType: dword->word
	push	word ptr [ebp+16]	;fRedraw: dword->word
	push	word ptr [ebp+20]	;fUpdate: dword->word
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	leave
	retn	16





;
public OSIIsWindowScreenSaver16@4
OSIIsWindowScreenSaver16@4:
	FAPILOG16	87
	mov	cl,3
; OSIIsWindowScreenSaver16(16) = OSIIsWindowScreenSaver16(32) {}
;
; dword ptr [ebp+8]:  hwnd
;
public IIOSIIsWindowScreenSaver16@4
IIOSIIsWindowScreenSaver16@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hwnd: dword->word
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	leave
	retn	4





;
public OSIInstallControlledHooks16@8
OSIInstallControlledHooks16@8:
	FAPILOG16	55
	mov	cl,2
	jmp	IIOSIInstallControlledHooks16@8
public OSIUnshareWindow16@8
OSIUnshareWindow16@8:
	FAPILOG16	116
	mov	cl,4
; OSIInstallControlledHooks16(16) = OSIInstallControlledHooks16(32) {}
;
; dword ptr [ebp+8]:  fInstall
; dword ptr [ebp+12]:  fDesktop
;
public IIOSIInstallControlledHooks16@8
IIOSIInstallControlledHooks16@8:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;fInstall: dword->word
	push	word ptr [ebp+12]	;fDesktop: dword->word
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	leave
	retn	8





;
public OSIInjectMouseEvent16@20
OSIInjectMouseEvent16@20:
	FAPILOG16	29
	mov	cl,1
; OSIInjectMouseEvent16(16) = OSIInjectMouseEvent16(32) {}
;
; dword ptr [ebp+8]:  param1
; dword ptr [ebp+12]:  param2
; dword ptr [ebp+16]:  param3
; dword ptr [ebp+20]:  param4
; dword ptr [ebp+24]:  param5
;
public IIOSIInjectMouseEvent16@20
IIOSIInjectMouseEvent16@20:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;param1: dword->word
	push	word ptr [ebp+12]	;param2: dword->word
	push	word ptr [ebp+16]	;param3: dword->word
	push	word ptr [ebp+20]	;param4: dword->word
	push	dword ptr [ebp+24]	;param5: dword->dword
	call	dword ptr [pfnQT_Thunk_thk]
	leave
	retn	20





;
public OSIInjectKeyboardEvent16@16
OSIInjectKeyboardEvent16@16:
	FAPILOG16	0
	mov	cl,0
; OSIInjectKeyboardEvent16(16) = OSIInjectKeyboardEvent16(32) {}
;
; dword ptr [ebp+8]:  param1
; dword ptr [ebp+12]:  param2
; dword ptr [ebp+16]:  param3
; dword ptr [ebp+20]:  param4
;
public IIOSIInjectKeyboardEvent16@16
IIOSIInjectKeyboardEvent16@16:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;param1: dword->word
	push	word ptr [ebp+12]	;param2: dword->word
	push	word ptr [ebp+16]	;param3: dword->word
	push	dword ptr [ebp+20]	;param4: dword->dword
	call	dword ptr [pfnQT_Thunk_thk]
	leave
	retn	16




;-----------------------------------------------------------
ifdef DEBUG
FT_ThunkLogNames label byte
	db	'[F] OSIInjectKeyboardEvent16',0
	db	'[F] OSIInjectMouseEvent16',0
	db	'[F] OSIInstallControlledHooks16',0
	db	'[F] OSIIsWindowScreenSaver16',0
	db	'[F] OSIUnshareWindow16',0
	db	'[F] OSIShareWindow16',0
	db	'[F] OSIStopWindowTracking16',0
	db	'[F] OSIStartWindowTracking16',0
	db	'[F] OSIFunctionRequest16',0
	db	'[F] OSITerm16',0
	db	'[F] OSIInit16',0
	db	'[F] OSILoad16',0
endif ;DEBUG
;-----------------------------------------------------------



ELSE
;************************* START OF 16-BIT CODE *************************




	OPTION SEGMENT:USE16
	.model LARGE,PASCAL


	.code	



externDef OSIInjectKeyboardEvent16:far16
externDef OSIInjectMouseEvent16:far16
externDef OSIInstallControlledHooks16:far16
externDef OSIIsWindowScreenSaver16:far16
externDef OSIUnshareWindow16:far16
externDef OSIShareWindow16:far16
externDef OSIStopWindowTracking16:far16
externDef OSIStartWindowTracking16:far16
externDef OSIFunctionRequest16:far16
externDef OSITerm16:far16
externDef OSIInit16:far16
externDef OSILoad16:far16


FT_thkTargetTable label word
	dw	offset OSIInjectKeyboardEvent16
	dw	   seg OSIInjectKeyboardEvent16
	dw	offset OSIInjectMouseEvent16
	dw	   seg OSIInjectMouseEvent16
	dw	offset OSIInstallControlledHooks16
	dw	   seg OSIInstallControlledHooks16
	dw	offset OSIIsWindowScreenSaver16
	dw	   seg OSIIsWindowScreenSaver16
	dw	offset OSIUnshareWindow16
	dw	   seg OSIUnshareWindow16
	dw	offset OSIShareWindow16
	dw	   seg OSIShareWindow16
	dw	offset OSIStopWindowTracking16
	dw	   seg OSIStopWindowTracking16
	dw	offset OSIStartWindowTracking16
	dw	   seg OSIStartWindowTracking16
	dw	offset OSIFunctionRequest16
	dw	   seg OSIFunctionRequest16
	dw	offset OSITerm16
	dw	   seg OSITerm16
	dw	offset OSIInit16
	dw	   seg OSIInit16
	dw	offset OSILoad16
	dw	   seg OSILoad16


; The following symbol must be exported in the .def file.
public	FT_thkThkConnectionData
FT_thkThkConnectionData label dword
	dd	016bddh	;Checksum
	dw	offset FT_thkTargetTable
	dw	seg    FT_thkTargetTable



ENDIF
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\dd\ba.c ===
#include "precomp.h"


//
// BA.C
// Bounds Accumulation, disply driver side
//
// Copyright(c) Microsoft 1997-
//


//
//
// BA_DDProcessRequest() - see ba.h
//
//
BOOL BA_DDProcessRequest
(
    DWORD                   fnEscape,
    LPOSI_ESCAPE_HEADER     pRequest,
    DWORD                   cbRequest,
    LPOSI_ESCAPE_HEADER     pResult,
    DWORD                   cbResult
)
{
    BOOL                    rc = TRUE;
    LPBA_BOUNDS_INFO        pBoundsInfo;
    UINT                    i;
    RECT                    rect;

    DebugEntry(BA_DDProcessRequest);

    if ((cbRequest != sizeof(BA_BOUNDS_INFO)) ||
        (cbResult  != sizeof(BA_BOUNDS_INFO)))
    {
        ERROR_OUT(("BA_DDProcessRequest:  Invalid sizes %d, %d for BA_ESC", cbRequest, cbResult));
        rc = FALSE;
        DC_QUIT;
    }

    switch (fnEscape)
    {
        case BA_ESC_GET_BOUNDS:
        {
            //
            // The share core is calling us to get the current bounds
            // (presumably to try to send them).  While the share core is
            // processing the bounds, we reset the bounds, but take a copy
            // first to use for spoiling orders by SDA.  When the share
            // core has completed processing the bounds, it will call us
            // again with a BA_ESC_RETURN_BOUNDS escape (even if it has
            // sent all the bounds).
            //
            // So, we have to:
            //  - return the bounds to the share core
            //  - set up the spoiling rects to be these bounds
            //  - clear our main bounds.
            //

            //
            // This will copy the current bounds to the caller's buffer and
            // clear our current bounds.
            // NOTE:  We keep these in globals because the caller will shortly
            // call us to return any unsent bounds rects.
            //
            BA_CopyBounds(g_baSpoilingRects, &g_baNumSpoilingRects, TRUE);

            //
            // Return the bounds info to the share core
            //
            TRACE_OUT(( "Returning %d rects to share core", g_baNumSpoilingRects));

            pBoundsInfo = (LPBA_BOUNDS_INFO)pResult;
            pBoundsInfo->numRects = g_baNumSpoilingRects;

            for (i = 0; i < g_baNumSpoilingRects; i++)
            {
                RECT_TO_RECTL(&g_baSpoilingRects[i], &pBoundsInfo->rects[i]);
            }
        }
        break;

        case BA_ESC_RETURN_BOUNDS:
        {
            //
            // The share core has completed its processing of the bounds
            // which we passed on the BA_ESC_GET_BOUNDS escape.  We have to
            // reset the spoiling rectangles and add any bounds which the
            // share core failed to process into our current bounds.
            //

            //
            // To reset the spoiling bounds we just have to reset the
            // number of bounds.
            //
            g_baNumSpoilingRects = 0;

            //
            // Now add the share core's bounds into our current bounds
            //
            pBoundsInfo = (LPBA_BOUNDS_INFO)pRequest;
            TRACE_OUT(( "Received %d rects from share core",
                         pBoundsInfo->numRects));

            for (i = 0 ; i < pBoundsInfo->numRects ; i++)
            {
                RECTL_TO_RECT(&pBoundsInfo->rects[i], &rect);

                TRACE_OUT(( "Rect %d, {%d, %d, %d, %d}",
                     i, rect.left, rect.top, rect.right, rect.bottom));

                BA_AddScreenData(&rect);
            }
        }
        break;

        default:
        {
            ERROR_OUT(( "Unrecognised BA escape"));
            rc = FALSE;
        }
        break;
    }

DC_EXIT_POINT:
    DebugExitBOOL(BA_DDProcessRequest, rc);
    return(rc);
}



//
// BA_DDInit - see ba.h for description.
//
void BA_DDInit(void)
{
    DebugEntry(BA_DDInit);

    BA_ResetBounds();

    DebugExitVOID(BA_DDInit);
}




//
// This gets a current version of our bound rect list, and clears it 
// afterwards if requested.
//
void BA_CopyBounds
(
    LPRECT  pRects,
    LPUINT  pNumRects,
    BOOL    fReset
)
{
    UINT    i;
#ifdef DEBUG
    UINT    cRects = 0;
#endif

    DebugEntry(BA_CopyBounds);

    if (*pNumRects = g_baRectsUsed)
    {
        //
        // Return the bounds that have been accumulated.
        //
        TRACE_OUT(( "num rects : %d", g_baRectsUsed));

        //
        // We can return the bounds in any order - we don't care how we
        // order the SDA rectangles.
        //
        // Also note that we must compare BA_NUM_RECTS + 1 sets of
        // rectangles because that's the number actually used by the add
        // rectangle code and while it guarantees that it will only use
        // BA_NUM_RECTS rectangles, it does not guarantee that the last
        // element in the array is the merge rectangle.
        //
        for (i = 0; i <= BA_NUM_RECTS; i++)
        {
            if (g_baBounds[i].InUse)
            {
                TRACE_OUT(("Found rect: {%04d,%04d,%04d,%04d}",
                    g_baBounds[i].Coord.left, g_baBounds[i].Coord.top,
                    g_baBounds[i].Coord.right, g_baBounds[i].Coord.bottom));

                *pRects = g_baBounds[i].Coord;
                pRects++;
#ifdef DEBUG
                cRects++;
#endif
            }
        }

        //
        // Check for self-consistency
        //
        ASSERT(cRects == *pNumRects);

        if (fReset)
            BA_ResetBounds();
    }

    DebugExitVOID(BACopyBounds);
}



//
//
// BA_AddScreenData(..)
//
// Adds the specified rectangle to the current Screen Data Area.
//
// Called by the GDI interception code for orders that it cannot send as
// orders.
//
// NOTE that the rectangle is INCLUSIVE coords
//
//
void BA_AddScreenData(LPRECT pRect)
{
    RECT  preRects[BA_NUM_RECTS];
    RECT  postRects[BA_NUM_RECTS];
    UINT  numPreRects;
    UINT  numPostRects;
    UINT  i;

    DebugEntry(BA_AddScreenData);

    //
    // Check that the caller has passed a valid rectangle.  If not, do a
    // trace alert, and then return immediately (as an invalid rectangle
    // shouldn't contribute to the accumulated bounds) - but report an OK
    // return code, so we keep running.
    //
    if ((pRect->right < pRect->left) ||
        (pRect->bottom < pRect->top) )
    {
        WARNING_OUT(( "Invalid Add Rect (%d,%d,%d,%d)",
                   pRect->left,
                   pRect->top,
                   pRect->right,
                   pRect->bottom ));
        DC_QUIT;
    }

    if ((g_oaFlow == OAFLOW_SLOW) && g_baSpoilByNewSDAEnabled)
    {
        //
        // We are spoiling existing orders by new SDA, so query the current
        // bounds.
        //
        BA_CopyBounds(preRects, &numPreRects, FALSE);
    }


    //
    // Add the rect to the bounds.
    //
    if (BAAddRect(pRect, 0))
    {
        if ((pRect->right > pRect->left) && (pRect->bottom > pRect->top))
        {
            LPBA_FAST_DATA  lpbaFast;

            lpbaFast = BA_FST_START_WRITING;

            SHM_CheckPointer(lpbaFast);
            lpbaFast->totalSDA += COM_SizeOfRectInclusive(pRect);

            TRACE_OUT(("Added rect to bounds, giving %ld of SD", lpbaFast->totalSDA));

            //
            // This is where the Win95 product would make a call to
            // DCS_TriggerEarlyTimer
            //

            BA_FST_STOP_WRITING;
        }

        if ((g_oaFlow == OAFLOW_SLOW) && g_baSpoilByNewSDAEnabled)
        {
            //
            // Adding the new rectangle changed the existing bounds so
            // query the new bounds
            //
            BA_CopyBounds(postRects, &numPostRects, FALSE);

            //
            // Try to spoil existing orders using each of the rectangles
            // which have changed.
            //
            for (i = 0; i < numPostRects; i++)
            {
                if ( (i > numPreRects)                          ||
                     (postRects[i].left   != preRects[i].left)  ||
                     (postRects[i].right  != preRects[i].right) ||
                     (postRects[i].top    != preRects[i].top)   ||
                     (postRects[i].bottom != preRects[i].bottom) )
                {
                    OA_DDSpoilOrdersByRect(&postRects[i]);
                }
            }
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(BA_AddScreenData);
}



//
//
// BA_QuerySpoilingBounds() - see ba.h
//
//
void BA_QuerySpoilingBounds(LPRECT pRects, LPUINT pNumRects)
{
    DebugEntry(BA_QuerySpoilingBounds);

    //
    // Just have to return the number of spoiling rectangles, and the
    // rectangles themselves.  No rectangles is perfectly valid.
    //
    TRACE_OUT(( "Num rects %d", g_baNumSpoilingRects));

    *pNumRects = g_baNumSpoilingRects;
    memcpy(pRects, g_baSpoilingRects, g_baNumSpoilingRects*sizeof(RECT));

    DebugExitVOID(BA_QuerySpoilingBounds);
}



void BA_ResetBounds(void)
{
    UINT i;

    DebugEntry(BA_ResetBounds);

    //
    // Clear the bounds - reset the number we are using, mark all slots as
    // free, and clean the list.
    //
    for ( i = 0; i <= BA_NUM_RECTS; i++ )
    {
        g_baBounds[i].InUse = FALSE;
        g_baBounds[i].iNext = BA_INVALID_RECT_INDEX;
    }

    g_baFirstRect = BA_INVALID_RECT_INDEX;
    g_baLastRect  = BA_INVALID_RECT_INDEX;
    g_baRectsUsed = 0;

    DebugExitVOID(BA_ResetBounds);
}





//
// Name:        BAOverlap
//
// Description: Detects overlap between two rectangles.
//
//              - check for no overlap using loose test that lets through
//                adjacent/overlapping merges
//              - check for adjacent/overlapping merges
//              - check for no overlap (using strict test)
//              - use outcodes to check internal edge cases
//              - use outcodes to check external edge cases
//
//              If at each stage the check detects that the two rectangles
//              meet the criteria, the function returns the appropriate
//              return or outcode combination.
//
//              Note that all rectangle coordinates are inclusive, ie
//              a rectangle of 0,0,0,0 has an area of 1 pel.
//
//              This function does not alter either of the rectangles.
//
// Params (IN): pRect1 - first rectangle
//              pRect2 - second rectangle
//
// Returns:     One of the overlap return codes or outcode combinations
//              defined above.
//
//
int BAOverlap(LPRECT pRect1, LPRECT pRect2 )
{
    int ExternalEdges;
    int ExternalCount;
    int InternalEdges;
    int InternalCount;

    //
    // Check for no overlap.
    //
    // Note that this test is looser than strict no overlap, and will let
    // through rectangles that do not overlap, but just abutt by one pel -
    // so that we get a chance to detect adjacent merges.
    //
    // So (for example) for the following:
    //
    // - it detects no overlap when there is at least 1 pel between rects
    //
    //                  10,10        52,10
    //                   +----------++----------+
    //                   |          ||          |
    //                   |          ||          |
    //                   |          ||          |
    //                   |  Rect 1  ||  Rect 2  |
    //                   |          ||          |
    //                   |          ||          |
    //                   |          ||          |
    //                   +----------++----------+
    //                          50,50         100,50
    //
    // - it allows rectangles through when they abutt and are mergable
    //
    //                  10,10        51,10
    //                   +----------++----------+
    //                   |          ||          |
    //                   |          ||          |
    //                   |          ||          |
    //                   |  Rect 1  ||  Rect 2  |
    //                   |          ||          |
    //                   |          ||          |
    //                   |          ||          |
    //                   +----------++----------+
    //                          50,50         100,50
    //
    // - it allows rectangles through when they abutt, even where they are
    //   not mergable
    //
    //                  10,10
    //                   +----------+51,15
    //                   |          |+----------+
    //                   |          ||          |
    //                   |          ||          |
    //                   |  Rect 1  ||          |
    //                   |          ||  Rect 2  |
    //                   |          ||          |
    //                   |          ||          |
    //                   +----------+|          |
    //                          50,50+----------+
    //                                        100,55
    //
    // - it allows rectangles through when they overlap in some way
    //
    //                          40,0
    //                           +------------+
    //                  10,10    |            |
    //                   +-------+--+         |
    //                   |       |  |         |
    //                   |       |  | Rect 2  |
    //                   |       |  |         |
    //                   |Rect 1 |  |         |
    //                   |       |  |         |
    //                   |       +--+---------+
    //                   |          |        90,40
    //                   +----------+
    //                          50,50
    //
    //
    if (!((pRect1->left <= pRect2->right + 1) &&
          (pRect1->top <= pRect2->bottom + 1) &&
          (pRect1->right >= pRect2->left - 1) &&
          (pRect1->bottom >= pRect2->top - 1)   ))
    {
        return(OL_NONE);
    }

    //
    // Check for adjoining/overlapping rectangles which can be merged.
    //
    // These tests detect (for example for the XMAX variant), where:
    //
    // - the rectangles abutt and can be merged
    //
    //                  10,10        51,10
    //                   +----------++----------+
    //                   |          ||          |
    //                   |          ||          |
    //                   |          ||          |
    //                   |  Rect 1  ||  Rect 2  |
    //                   |          ||          |
    //                   |          ||          |
    //                   |          ||          |
    //                   +----------++----------+
    //                          50,50         100,50
    //
    // - the rectangles overlap and can be merged
    //
    //                  10,10   40,10
    //                   +-------+--+------+
    //                   |       |  |      |
    //                   |       |  |      |
    //                   |       |  |      |
    //                   |Rect 1 |  |Rect 2|
    //                   |       |  |      |
    //                   |       |  |      |
    //                   |       |  |      |
    //                   +-------+--+------+
    //                              50,50  90,50
    //
    // - the rectangles abutt and cannot be merged - this case is detected
    //   by the strict overlap case below
    //
    //                  10,10
    //                   +----------+51,15
    //                   |          |+----------+
    //                   |          ||          |
    //                   |          ||          |
    //                   |  Rect 1  ||          |
    //                   |          ||  Rect 2  |
    //                   |          ||          |
    //                   |          ||          |
    //                   +----------+|          |
    //                          50,50+----------+
    //                                        100,55
    //
    // - the rectangles overlap and cannot be merged - this case is
    //   detected by the outcode tests below
    //
    //                          40,0
    //                           +------------+
    //                  10,10    |            |
    //                   +-------+--+         |
    //                   |       |  |         |
    //                   |       |  | Rect 2  |
    //                   |       |  |         |
    //                   |Rect 1 |  |         |
    //                   |       |  |         |
    //                   |       +--+---------+
    //                   |          |        90,40
    //                   +----------+
    //                          50,50
    //
    // - rectangle 2 is enclosed in rectangle 1 and should not be merged -
    //   this case is detected by the outcode tests below.
    //
    //                  10,10   40,10
    //                   +-------+------+-----+
    //                   |       |      |     |
    //                   |       |      |     |
    //                   |       |      |     |
    //                   |Rect 1 |Rect 2|     |
    //                   |       |      |     |
    //                   |       |      |     |
    //                   |       |      |     |
    //                   +-------+------+-----+
    //                               60,50   90,50
    //                               Rect2   Rect1
    //
    //
    if ( (pRect1->left <= pRect2->right + 1) &&
         (pRect1->left >  pRect2->left    ) &&
         (pRect1->right >  pRect2->right    ) &&
         (pRect1->top == pRect2->top    ) &&
         (pRect1->bottom == pRect2->bottom    )   )
    {
        return(OL_MERGE_XMIN);
    }

    if ( (pRect1->top <= pRect2->bottom + 1) &&
         (pRect1->top >  pRect2->top    ) &&
         (pRect1->bottom >  pRect2->bottom    ) &&
         (pRect1->left == pRect2->left    ) &&
         (pRect1->right == pRect2->right    )   )
    {
        return(OL_MERGE_YMIN);
    }

    if ( (pRect1->right >= pRect2->left - 1) &&
         (pRect1->right <  pRect2->right    ) &&
         (pRect1->left <  pRect2->left    ) &&
         (pRect1->top == pRect2->top    ) &&
         (pRect1->bottom == pRect2->bottom    )   )
    {
        return(OL_MERGE_XMAX);
    }

    if ( (pRect1->bottom >= pRect2->top - 1) &&
         (pRect1->bottom <  pRect2->bottom    ) &&
         (pRect1->top <  pRect2->top    ) &&
         (pRect1->left == pRect2->left    ) &&
         (pRect1->right == pRect2->right    )   )
    {
        return(OL_MERGE_YMAX);
    }

    //
    // Check for no overlap.
    // Note that this test is a stricter version than the earlier one, so
    // that we now only continue testing rectangles that do genuinely
    // overlap.
    //
    if (!((pRect1->left <= pRect2->right) &&
          (pRect1->top <= pRect2->bottom) &&
          (pRect1->right >= pRect2->left) &&
          (pRect1->bottom >= pRect2->top)   ))
    {
        return(OL_NONE);
    }

    //
    // Use outcodes for Internal edge cases, as follows:
    //
    // EE_XMIN - rect1 xmin is enclosed within rect2
    // EE_YMIN - rect1 ymin is enclosed within rect2
    // EE_XMAX - rect1 xmax is enclosed within rect2
    // EE_YMAX - rect1 ymax is enclosed within rect2
    //
    // If 3 or more bits are set then rect1 is enclosed either partially or
    // completely within rect2 as follows (see individual switch cases for
    // diagrams).
    //
    // OL_ENCLOSED           = EE_XMIN | EE_YMIN | EE_XMAX | EE_YMAX
    // OL_PART_ENCLOSED_XMIN = EE_XMIN | EE_YMIN |           EE_YMAX
    // OL_PART_ENCLOSED_YMIN = EE_XMIN | EE_YMIN | EE_XMAX
    // OL_PART_ENCLOSED_XMAX =           EE_YMIN | EE_XMAX | EE_YMAX
    // OL_PART_ENCLOSED_YMAX = EE_XMIN |           EE_XMAX | EE_YMAX
    //
    // In practice, if 3 or more bits are set, the negative of the outcode
    // value is retruned to ensure that it is distinct from the external
    // edge outcode returns (see below).
    //
    //
    InternalCount = 0;
    InternalEdges = 0;
    if ( pRect1->left >= pRect2->left && pRect1->left <= pRect2->right)
    {
        InternalEdges |= EE_XMIN;
        InternalCount ++;
    }
    if ( pRect1->top >= pRect2->top && pRect1->top <= pRect2->bottom)
    {
        InternalEdges |= EE_YMIN;
        InternalCount ++;
    }
    if ( pRect1->right >= pRect2->left && pRect1->right <= pRect2->right)
    {
        InternalEdges |= EE_XMAX;
        InternalCount ++;
    }
    if ( pRect1->bottom >= pRect2->top && pRect1->bottom <= pRect2->bottom)
    {
        InternalEdges |= EE_YMAX;
        InternalCount ++;
    }

    if ( InternalCount >= 3)
    {
        return(-InternalEdges);
    }

    //
    // Use outcodes for External edge cases as follows.
    //
    // EE_XMIN - rect1 xmin is left of rect2 xmin
    // EE_YMIN - rect1 ymin is above rect2 ymin
    // EE_XMAX - rect1 xmax is right of rect2 xmax
    // EE_YMAX - rect1 ymax is below rect2 ymax
    //
    // These are the classic "line" outcodes.
    //
    // If 2 or more bits are set then rect1 overlaps rect2 as follows (see
    // individual switch cases for diagrams).
    //
    // OL_ENCLOSES           = EE_XMIN | EE_YMIN | EE_XMAX | EE_YMAX
    // OL_PART_ENCLOSES_XMIN =           EE_YMIN | EE_XMAX | EE_YMAX
    // OL_PART_ENCLOSES_XMAX = EE_XMIN | EE_YMIN |           EE_YMAX
    // OL_PART_ENCLOSES_YMIN = EE_XMIN |           EE_XMAX | EE_YMAX
    // OL_PART_ENCLOSES_YMAX = EE_XMIN | EE_YMIN | EE_XMAX
    // OL_SPLIT_X            =           EE_YMIN |           EE_YMAX
    // OL_SPLIT_Y            = EE_XMIN |           EE_XMAX
    // OL_SPLIT_XMIN_YMIN    =                     EE_XMAX | EE_YMAX
    // OL_SPLIT_XMAX_YMIN    = EE_XMIN |                     EE_YMAX
    // OL_SPLIT_XMIN_YMAX    =           EE_YMIN | EE_XMAX
    // OL_SPLIT_XMAX_YMAX    = EE_XMIN | EE_YMIN
    //
    // The accumulated outcode value is returned.
    //
    //
    ExternalEdges = 0;
    ExternalCount = 0;
    if ( pRect1->left <= pRect2->left )
    {
        ExternalEdges |= EE_XMIN;
        ExternalCount ++;
    }
    if ( pRect1->top <= pRect2->top )
    {
        ExternalEdges |= EE_YMIN;
        ExternalCount ++;
    }
    if ( pRect1->right >= pRect2->right )
    {
        ExternalEdges |= EE_XMAX;
        ExternalCount ++;
    }
    if ( pRect1->bottom >= pRect2->bottom )
    {
        ExternalEdges |= EE_YMAX;
        ExternalCount ++;
    }
    if (ExternalCount >= 2)
    {
        return(ExternalEdges);
    }

    //
    // If get here then we failed to detect a valid case.
    //
    WARNING_OUT(( "Unrecognised Overlap: (%d,%d,%d,%d),(%d,%d,%d,%d)",
            pRect1->left, pRect1->top, pRect1->right, pRect1->bottom,
            pRect2->left, pRect2->top, pRect2->right, pRect2->bottom ));
    return(OL_NONE);
}



//
// Name:        BAAddRectList
//
// Description: Adds a rectangle to the list of accumulated rectangles.
//
//              - find a free slot in the array
//              - add slot record to list
//              - fill slot record with rect and mark as in use.
//
// Params (IN): pRect - rectangle to add
//
// Returns:
//
//
void BAAddRectList(LPRECT pRect)
{
    UINT     i;
    BOOL     fFoundFreeSlot;

    DebugEntry(BAAddRectList);

    //
    // Find a free slot in the array.  Note that the loop searches to
    // BA_NUM_RECTS+1, because:
    //
    // - the array is defined as having one more slot than BA_NUM_RECTS
    //
    // - we may need to add a rect in that slot when BA_NUM_RECTS are
    //   in use prior to a forced merge.
    //
    fFoundFreeSlot = FALSE;
    for ( i = 0; i <= BA_NUM_RECTS; i++ )
    {
        if (!g_baBounds[i].InUse)
        {
            fFoundFreeSlot = TRUE;
            break;
        }
    }

    if (!fFoundFreeSlot)
    {
        WARNING_OUT(( "No space in array for rect (%d,%d,%d,%d)",
                   pRect->left,
                   pRect->top,
                   pRect->right,
                   pRect->bottom));

        for ( i = 0; i <= BA_NUM_RECTS; i++ )
        {
            WARNING_OUT((
                     "Entry %i:Next(%lx),(%d,%d,%d,%d),Index(%d),InUse(%d)",
                       g_baBounds[i].iNext,
                       g_baBounds[i].Coord.left,
                       g_baBounds[i].Coord.top,
                       g_baBounds[i].Coord.right,
                       g_baBounds[i].Coord.bottom,
                       i,
                       g_baBounds[i].InUse));
        }

        DC_QUIT;
    }

    //
    // If first rect, then set up list.
    // If not, add to tail of list.
    //
    if (g_baRectsUsed == 0)
    {
        g_baFirstRect = i;
        g_baLastRect = i;
    }
    else
    {
        g_baBounds[g_baLastRect].iNext = i;
        g_baLastRect = i;
    }
    g_baBounds[i].iNext = BA_INVALID_RECT_INDEX;

    //
    // Fill in slot and mark as in use.
    //
    g_baBounds[i].InUse = TRUE;
    g_baBounds[i].Coord = *pRect;

    //
    // Increment number of rectangles.
    //
    TRACE_OUT(( "Add Rect  : ix - %d, (%d,%d,%d,%d)", i,
                    pRect->left,pRect->top,pRect->right,pRect->bottom));
    g_baRectsUsed++;

DC_EXIT_POINT:
    DebugExitVOID(BAAddRectList);
}


//
// Name:        BA_RemoveRectList
//
// Description: Removes a rectangle from the list of accumulated
//              rectangles.
//
//              - find the rectangle in the list
//              - unlink it from the list and mark the slot as free
//
// Params (IN): pRect - rectangle to remove
//
// Returns:
//
//
void BA_RemoveRectList(LPRECT pRect)
{
    UINT      i;
    UINT      j;

    DebugEntry(BA_RemoveRectList);

    //
    // If rectangle to remove is first...
    // Remove it by adjusting first pointer and mark as free.
    // Note that the check for tail adjustment has to be done before we
    // change first.
    //
    if ( g_baBounds[g_baFirstRect].Coord.left == pRect->left &&
         g_baBounds[g_baFirstRect].Coord.top == pRect->top &&
         g_baBounds[g_baFirstRect].Coord.right == pRect->right &&
         g_baBounds[g_baFirstRect].Coord.bottom == pRect->bottom   )
    {
        TRACE_OUT(( "Remove first"));
        if (g_baFirstRect == g_baLastRect)
        {
            g_baLastRect = BA_INVALID_RECT_INDEX;
        }
        g_baBounds[g_baFirstRect].InUse = FALSE;
        g_baFirstRect = g_baBounds[g_baFirstRect].iNext;
    }

    //
    // If rectangle to remove is not first...
    // Find it in list, remove it by adjusting previous pointer and mark it
    // as free.
    // Note that the check for tail adjustment has to be done before we
    // change the previous pointer.
    //
    else
    {
        TRACE_OUT(( "Remove not first"));
        for ( j = g_baFirstRect;
              g_baBounds[j].iNext != BA_INVALID_RECT_INDEX;
              j = g_baBounds[j].iNext )
        {
            if ( (g_baBounds[g_baBounds[j].iNext].Coord.left == pRect->left) &&
                 (g_baBounds[g_baBounds[j].iNext].Coord.top == pRect->top) &&
                 (g_baBounds[g_baBounds[j].iNext].Coord.right == pRect->right) &&
                 (g_baBounds[g_baBounds[j].iNext].Coord.bottom == pRect->bottom) )
            {
                break;
            }
        }

        if (j == BA_INVALID_RECT_INDEX)
        {
            WARNING_OUT(( "Couldn't remove rect (%d,%d,%d,%d)",
                       pRect->left,
                       pRect->top,
                       pRect->right,
                       pRect->bottom ));

            for ( i = 0; i <= BA_NUM_RECTS; i++ )
            {
                WARNING_OUT((
                       "Entry %i:Next(%lx),(%d,%d,%d,%d),Index(%d),InUse(%d)",
                           g_baBounds[i].iNext,
                           g_baBounds[i].Coord.left,
                           g_baBounds[i].Coord.top,
                           g_baBounds[i].Coord.right,
                           g_baBounds[i].Coord.bottom,
                           i,
                           g_baBounds[i].InUse));
            }
            return;
        }

        if (g_baBounds[j].iNext == g_baLastRect )
        {
             g_baLastRect = j;
        }
        g_baBounds[g_baBounds[j].iNext].InUse = FALSE;
        g_baBounds[j].iNext = g_baBounds[g_baBounds[j].iNext].iNext;
    }

    //
    // One less rect...
    //
    g_baRectsUsed--;
    DebugExitVOID(BA_RemoveRectList);
}


//
// Name:        BAAddRect
//
// Description: Accumulates rectangles.
//
//              This is a complex routine, with the essential algorithm
//              as follows.
//
//              - Start with the supplied rectangle as the candidate
//                rectangle.
//
//              - Compare the candidate against each of the existing
//                accumulated rectangles.
//
//              - If some form of overlap is detected between the
//                candidate and an existing rectangle, this may result in
//                one of the following (see the cases of the switch for
//                details):
//
//                - adjust the candidate or the existing rectangle or both
//                - merge the candidate into the existing rectangle
//                - discard the candidate as it is enclosed by an existing
//                  rectangle.
//
//              - If the merge or adjustment results in a changed
//                candidate, restart the comparisons from the beginning of
//                the list with the changed candidate.
//
//              - If the adjustment results in a split (giving two
//                candidate rectangles), invoke this routine recursively
//                with one of the two candidates as its candidate.
//
//              - If no overlap is detected against the existing rectangles,
//                add the candidate to the list of accumulated rectangles.
//
//              - If the add results in more than BA_NUM_RECTS
//                accumulated rectangles, do a forced merge of two of the
//                accumulate rectangles (which include the newly added
//                candidate) - choosing the two rectangles where the merged
//                rectangle results in the smallest increase in area over
//                the two non-merged rectangles.
//
//              - After a forced merge, restart the comparisons from the
//                beginning of the list with the newly merged rectangle as
//                the candidate.
//
//              For a particular call, this process will continue until
//              the candidate (whether the supplied rectangle, an adjusted
//              version of that rectangle, or a merged rectangle):
//
//              - does not find an overlap among the rectangles in the list
//                and does not cause a forced merge
//              - is discarded becuase it is enclosed within one of the
//                rectangles in the list.
//
//              Note that all rectangle coordinates are inclusive, ie
//              a rectangle of 0,0,0,0 has an area of 1 pel.
//
// Params (IN): pCand - new candidate rectangle
//              level - recursion level
//
// Returns:  TRUE if rectandle was spoilt due to a complete overlap.
//
//
BOOL BAAddRect
(
    LPRECT  pCand,
    int     level
)
{
    int     bestMergeIncrease;
    int     mergeIncrease;
    UINT    iBestMerge1;
    UINT    iBestMerge2;
    UINT    iExist;
    UINT    iTmp;
    BOOL    fRectToAdd;
    BOOL    fRectMerged;
    BOOL    fResetRects;
    RECT    rectNew;
    UINT    iLastMerge;
    int     OverlapType;
    BOOL    rc = TRUE;

    DebugEntry(BAAddRect);

    //
    // Increase the level count in case we recurse.
    //
    level++;

    //
    // Start off by assuming the candidate rectangle will be added to the
    // accumulated list of rectangles, and that no merges will occur.
    //
    fRectToAdd  = TRUE;
    fRectMerged = FALSE;

    //
    // Loop until no merges occur.
    //
    do
    {
        TRACE_OUT(( "Candidate rect: (%d,%d,%d,%d)",
                    pCand->left,pCand->top,pCand->right,pCand->bottom));

        //
        // Compare the current candidate rectangle against the rectangles
        // in the current accumulated list.
        //
        iExist = g_baFirstRect;

        while (iExist != BA_INVALID_RECT_INDEX)
        {
            //
            // Assume that the comparisons will run through the whole list.
            //
            fResetRects = FALSE;

            //
            // If the candidate and the existing rectangle are the same
            // then ignore.  This occurs when an existing rectangle is
            // replaced by a candidate and the comparisons are restarted
            // from the front of the list - whereupon at some point the
            // candidate will be compared with itself.
            //
            if ( &g_baBounds[iExist].Coord == pCand )
            {
                TRACE_OUT(( "OL_SAME - %d", iExist));
                iExist = g_baBounds[iExist].iNext;
                continue;
            }

            //
            // Switch on the overlap type (see Overlap routine).
            //
            OverlapType = BAOverlap(&(g_baBounds[iExist].Coord), pCand);
            switch (OverlapType)
            {

                case OL_NONE:
                    //
                    // No overlap.
                    //
                    TRACE_OUT(( "OL_NONE - %d", iExist));
                    break;

                case OL_MERGE_XMIN:
                    //
                    // - either the candidate abutts the existing rectangle
                    //   on the left
                    //
                    //              10,10        51,10
                    //               +----------++----------+
                    //               |          ||          |
                    //               |          ||          |
                    //               |          ||          |
                    //               |  Cand    ||  Exist   |
                    //               |          ||          |
                    //               |          ||          |
                    //               |          ||          |
                    //               +----------++----------+
                    //                      50,50         100,50
                    //
                    // - or the candidate overlaps the existing on the left
                    //   and can be merged
                    //
                    //              10,10   40,10
                    //               +-------+--+------+
                    //               |       |  |      |
                    //               |       |  |      |
                    //               |       |  |      |
                    //               | Cand  |  |Exist |
                    //               |       |  |      |
                    //               |       |  |      |
                    //               |       |  |      |
                    //               +-------+--+------+
                    //                          50,50  90,50
                    //
                    // If the candidate is the original, merge the
                    // candidate into the existing, and make the existing
                    // the new candidate.
                    //
                    // If this is a merge of two existing rectangles (ie
                    // the candidate is the result of a merge), merge the
                    // overlapping existing into the candidate (the last
                    // merged) and remove the existing.
                    //
                    // For both, start the comparisons again with the new
                    // candidate.
                    //
                    TRACE_OUT(( "OL_MERGE_XMIN - %d", iExist));

                    if ( fRectToAdd )
                    {
                        g_baBounds[iExist].Coord.left = pCand->left;
                        pCand      = &(g_baBounds[iExist].Coord);
                        fRectToAdd = FALSE;
                        iLastMerge = iExist;
                    }
                    else
                    {
                        pCand->right = g_baBounds[iExist].Coord.right;
                        BA_RemoveRectList(&(g_baBounds[iExist].Coord));
                    }

                    fResetRects = TRUE;
                    break;


                case OL_MERGE_XMAX:
                    //
                    // - either the candidate abutts the existing rectangle
                    //   on the right
                    //
                    //              10,10        51,10
                    //               +----------++----------+
                    //               |          ||          |
                    //               |          ||          |
                    //               |          ||          |
                    //               |  Exist   ||  Cand    |
                    //               |          ||          |
                    //               |          ||          |
                    //               |          ||          |
                    //               +----------++----------+
                    //                      50,50         100,50
                    //
                    // - or the candidate overlaps the existing on the right
                    //   and can be merged
                    //
                    //              10,10   40,10
                    //               +-------+--+------+
                    //               |       |  |      |
                    //               |       |  |      |
                    //               |       |  |      |
                    //               | Exist |  | Cand |
                    //               |       |  |      |
                    //               |       |  |      |
                    //               |       |  |      |
                    //               +-------+--+------+
                    //                          50,50  90,50
                    //
                    // If the candidate is the original, merge the
                    // candidate into the existing, and make the existing
                    // the new candidate.
                    //
                    // If this is a merge of two existing rectangles (ie
                    // the candidate is the result of a merge), merge the
                    // overlapping existing into the candidate (the last
                    // merged) and remove the existing.
                    //
                    // For both, start the comparisons again with the new
                    // candidate.
                    //
                    TRACE_OUT(( "OL_MERGE_XMAX - %d", iExist));

                    if ( fRectToAdd )
                    {
                        g_baBounds[iExist].Coord.right = pCand->right;
                        pCand      = &(g_baBounds[iExist].Coord);
                        fRectToAdd = FALSE;
                        iLastMerge = iExist;
                    }
                    else
                    {
                        pCand->left = g_baBounds[iExist].Coord.left;
                        BA_RemoveRectList(&(g_baBounds[iExist].Coord));
                    }

                    fResetRects = TRUE;
                    break;

                case OL_MERGE_YMIN:
                    //
                    // - either the candidate abutts the existing rectangle
                    //   on the top
                    //
                    //              10,10
                    //                 +---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 |  Cand   |
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,50
                    //            10,51+---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 |  Exist  |
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,100
                    //
                    // - or the candidate overlaps the existing on the top
                    //   and can be merged
                    //
                    //              10,10
                    //                 +---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 |  Cand   |
                    //                 |         |
                    //                 |         |
                    //      Exist 10,40+---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,60 Cand
                    //                 |         |
                    //                 |  Exist  |
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,100
                    //
                    // If the candidate is the original, merge the
                    // candidate into the existing, and make the existing
                    // the new candidate.
                    //
                    // If this is a merge of two existing rectangles (ie
                    // the candidate is the result of a merge), merge the
                    // overlapping existing into the candidate (the last
                    // merged) and remove the existing.
                    //
                    // For both, start the comparisons again with the new
                    // candidate.
                    //
                    TRACE_OUT(( "OL_MERGE_YMIN - %d", iExist));

                    if ( fRectToAdd )
                    {
                        g_baBounds[iExist].Coord.top = pCand->top;
                        pCand      = &(g_baBounds[iExist].Coord);
                        fRectToAdd = FALSE;
                        iLastMerge = iExist;
                    }
                    else
                    {
                        pCand->bottom = g_baBounds[iExist].Coord.bottom;
                        BA_RemoveRectList(&(g_baBounds[iExist].Coord));
                    }

                    fResetRects = TRUE;
                    break;

                case OL_MERGE_YMAX:
                    //
                    // - either the candidate abutts the existing rectangle
                    //   from below
                    //
                    //              10,10
                    //                 +---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 |  Exist  |
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,50
                    //            10,51+---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 |  Cand   |
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,100
                    //
                    // - or the candidate overlaps the existing from below
                    //   and can be merged
                    //
                    //              10,10
                    //                 +---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 |  Exist  |
                    //                 |         |
                    //                 |         |
                    //       Cand 10,40+---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,60 Exist
                    //                 |         |
                    //                 |  Cand   |
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,100
                    //
                    // If the candidate is the original, merge the
                    // candidate into the existing, and make the existing
                    // the new candidate.
                    //
                    // If this is a merge of two existing rectangles (ie
                    // the candidate is the result of a merge), merge the
                    // overlapping existing into the candidate (the last
                    // merged) and remove the existing.
                    //
                    // For both, start the comparisons again with the new
                    // candidate.
                    //
                    TRACE_OUT(( "OL_MERGE_YMAX - %d", iExist));
                    if ( fRectToAdd )
                    {
                        g_baBounds[iExist].Coord.bottom = pCand->bottom;
                        pCand      = &(g_baBounds[iExist].Coord);
                        fRectToAdd = FALSE;
                        iLastMerge = iExist;
                    }
                    else
                    {
                        pCand->top = g_baBounds[iExist].Coord.top;
                        BA_RemoveRectList(&(g_baBounds[iExist].Coord));
                    }

                    fResetRects = TRUE;
                    break;

                case OL_ENCLOSED:
                    //
                    // The existing is enclosed by the candidate.
                    //
                    //              100,100
                    //              +----------------------+
                    //              |        Cand          |
                    //              |                      |
                    //              |    130,130           |
                    //              |    +------------+    |
                    //              |    |            |    |
                    //              |    |            |    |
                    //              |    |   Exist    |    |
                    //              |    |            |    |
                    //              |    +------------+    |
                    //              |             170,170  |
                    //              |                      |
                    //              +----------------------+
                    //                                   200,200
                    //
                    // If the candidate is the original, replace the
                    // existing by the candidate, and make the new existing
                    // the new candidate.
                    //
                    // If the candidate is an existing rectangle, remove
                    // the other existing rectangle.
                    //
                    // For both, start the comparisons again with the new
                    // candidate.
                    //
                    TRACE_OUT(( "OL_ENCLOSED - %d", iExist));

                    if ( fRectToAdd )
                    {
                        g_baBounds[iExist].Coord   = *pCand;
                        pCand      = &(g_baBounds[iExist].Coord);
                        fRectToAdd = FALSE;
                        iLastMerge = iExist;
                    }
                    else
                    {
                        BA_RemoveRectList(&(g_baBounds[iExist].Coord));
                    }

                    fResetRects = TRUE;
                    break;

                case OL_PART_ENCLOSED_XMIN:
                    //
                    // The existing is partially enclosed by the candidate
                    // - but not on the right.
                    //
                    //           100,100
                    //           +----------------------+
                    //           |        Cand          |
                    //           |                      |
                    //           |    130,130           |
                    //           |    +-----------------+---+
                    //           |    |                 |   |
                    //           |    |                 |   |
                    //           |    |   Exist         |   |
                    //           |    |                 |   |
                    //           |    +-----------------+---+
                    //           |                      |  220,170
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Adjust the existing rectangle to be the non-
                    // overlapped portion.
                    //
                    //           100,100
                    //           +----------------------+
                    //           |                      |
                    //           |                      |201,130
                    //           |                      |+--+
                    //           |                      ||E |
                    //           |                      ||x |
                    //           |        Cand          ||i |
                    //           |                      ||s |
                    //           |                      ||t |
                    //           |                      ||  |
                    //           |                      |+--+
                    //           |                      |  220,170
                    //           +----------------------+
                    //                                200,200
                    //
                    // Note that this does not restart the comparisons.
                    //
                    TRACE_OUT(( "OL_PART_ENCLOSED_XMIN - %d", iExist));
                    g_baBounds[iExist].Coord.left = pCand->right + 1;
                    break;

                case OL_PART_ENCLOSED_XMAX:
                    //
                    // The existing is partially enclosed by the candidate
                    // - but not on the left.
                    //
                    //           100,100
                    //           +----------------------+
                    //           |        Cand          |
                    //   70,130  |                      |
                    //     +-----+---------------+      |
                    //     |     |               |      |
                    //     |     |               |      |
                    //     |     |        Exist  |      |
                    //     |     |               |      |
                    //     +-----+---------------+      |
                    //           |           170,170    |
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Adjust the existing rectangle to be the non-
                    // overlapped portion.
                    //
                    //           100,100
                    //           +----------------------+
                    //    70,130 |                      |
                    //     +----+|                      |
                    //     | E  ||                      |
                    //     | x  ||                      |
                    //     | i  ||        Cand          |
                    //     | s  ||                      |
                    //     | t  ||                      |
                    //     |    ||                      |
                    //     +----+|                      |
                    //     99,170|                      |
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Note that this does not restart the comparisons.
                    //
                    TRACE_OUT(( "OL_PART_ENCLOSED_XMAX - %d", iExist));
                    g_baBounds[iExist].Coord.right = pCand->left - 1;
                    break;

                case OL_PART_ENCLOSED_YMIN:
                    //
                    // The existing is partially enclosed by the candidate
                    // - but not on the bottom.
                    //
                    //     100,100
                    //           +----------------------+
                    //           |        Cand          |
                    //           | 130,130              |
                    //           |     +--------+       |
                    //           |     |        |       |
                    //           |     |  Exist |       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           +-----+--------+-------+
                    //                 |        |     200,200
                    //                 |        |
                    //                 |        |
                    //                 +--------+170,230
                    //
                    // Adjust the existing rectangle to be the non-
                    // overlapped portion.
                    //
                    //
                    //     100,100
                    //           +----------------------+
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |        Cand          |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           +----------------------+
                    //          130,201+---------+   200,200
                    //                 |         |
                    //                 |  Exist  |
                    //                 |         |
                    //                 +---------+170,230
                    //
                    // Note that this does not restart the comparisons.
                    //
                    TRACE_OUT(( "OL_PART_ENCLOSED_YMIN - %d", iExist));
                    g_baBounds[iExist].Coord.top = pCand->bottom + 1;
                    break;

                case OL_PART_ENCLOSED_YMAX:
                    //
                    // The existing is partially enclosed by the candidate
                    // - but not on the top.
                    //
                    //               70,130
                    //                 +---------+
                    //                 |         |
                    //                 |         |
                    //     100,100     |         |
                    //           +-----+---------+------+
                    //           |     |         |      |
                    //           |     |         |      |
                    //           |     |         |      |
                    //           |     |         |      |
                    //           |     |  Exist  |      |
                    //           |     |         |      |
                    //           |     |         |      |
                    //           |     +---------+      |
                    //           |           170,170    |
                    //           |                      |
                    //           |        Cand          |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Adjust the existing rectangle to be the non-
                    // overlapped portion.
                    //
                    //               70,130
                    //                 +---------+
                    //                 |         |
                    //                 |  Exist  |
                    //                 |         |
                    //     100,100     +---------+170,99
                    //           +----------------------+
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |        Cand          |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Note that this does not restart the comparisons.
                    //
                    TRACE_OUT(( "OL_PART_ENCLOSED_YMAX - %d", iExist));
                    g_baBounds[iExist].Coord.bottom = pCand->top - 1;
                    break;

                case OL_ENCLOSES:
                    //
                    // The existing encloses the candidate.
                    //
                    //              100,100
                    //              +----------------------+
                    //              |        Exist         |
                    //              |                      |
                    //              |    130,130           |
                    //              |    +------------+    |
                    //              |    |            |    |
                    //              |    |            |    |
                    //              |    |   Cand     |    |
                    //              |    |            |    |
                    //              |    |            |    |
                    //              |    +------------+    |
                    //              |             170,170  |
                    //              |                      |
                    //              +----------------------+
                    //                                   200,200
                    //
                    // Just discard the candidate by exiting.
                    //
                    //
                    TRACE_OUT(( "OL_ENCLOSES - %d", iExist));

                    //
                    // Return FALSE indicating that the rectangle is
                    // already catered for by the existing bounds
                    //
                    rc= FALSE;
                    DC_QUIT;
                    break;

                case OL_PART_ENCLOSES_XMIN:
                    //
                    // The existing partially encloses the candidate - but
                    // not on the left.
                    //
                    //           100,100
                    //           +----------------------+
                    //           |        Exist         |
                    //   70,130  |                      |
                    //     +-----+---------------+      |
                    //     |     |               |      |
                    //     |     |        Cand   |      |
                    //     |     |               |      |
                    //     +-----+---------------+      |
                    //           |           170,170    |
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Adjust the candidate rectangle to be the non-
                    // overlapped portion.
                    //
                    //           100,100
                    //           +----------------------+
                    //    70,130 |                      |
                    //     +----+|                      |
                    //     |    ||                      |
                    //     | C  ||                      |
                    //     | a  ||                      |
                    //     | n  ||        Exist         |
                    //     | d  ||                      |
                    //     |    ||                      |
                    //     +----+|                      |
                    //     99,170|                      |
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Because this affects the candidate, restart the
                    // comparisons to check for overlaps between the
                    // adjusted candidate and other existing rectangles.
                    //
                    //
                    TRACE_OUT(( "OL_PART_ENCLOSES_XMIN - %d", iExist));
                    pCand->right = g_baBounds[iExist].Coord.left - 1;

                    fResetRects = TRUE;
                    break;

                case OL_PART_ENCLOSES_XMAX:
                    //
                    // The existing partially encloses the candidate - but
                    // not on the right.
                    //
                    //           100,100
                    //           +----------------------+
                    //           |        Exist         |
                    //           |                      |
                    //           |    130,130           |
                    //           |    +-----------------+---+
                    //           |    |                 |   |
                    //           |    |                 |   |
                    //           |    |   Cand          |   |
                    //           |    |                 |   |
                    //           |    +-----------------+---+
                    //           |                      |  220,170
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Adjust the candidate rectangle to be the non-
                    // overlapped portion.
                    //
                    //           100,100
                    //           +----------------------+
                    //           |                      |201,130
                    //           |                      |+--+
                    //           |                      ||  |
                    //           |                      ||C |
                    //           |        Exist         ||a |
                    //           |                      ||n |
                    //           |                      ||d |
                    //           |                      ||  |
                    //           |                      |+--+
                    //           |                      |  220,170
                    //           +----------------------+
                    //                                200,200
                    //
                    // Because this affects the candidate, restart the
                    // comparisons to check for overlaps between the
                    // adjusted candidate and other existing rectangles.
                    //
                    //
                    TRACE_OUT(( "OL_PART_ENCLOSES_XMAX - %d", iExist));
                    pCand->left = g_baBounds[iExist].Coord.right + 1;

                    fResetRects = TRUE;
                    break;

                case OL_PART_ENCLOSES_YMIN:
                    //
                    // The existing partially encloses the candidate - but
                    // not on the top.
                    //
                    //               70,130
                    //                 +---------+
                    //                 |         |
                    //                 |         |
                    //     100,100     |         |
                    //           +-----+---------+------+
                    //           |     |         |      |
                    //           |     |         |      |
                    //           |     |  Cand   |      |
                    //           |     |         |      |
                    //           |     |         |      |
                    //           |     +---------+      |
                    //           |           170,170    |
                    //           |                      |
                    //           |        Exist         |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Adjust the candidate rectangle to be the non-
                    // overlapped portion.
                    //
                    //
                    //               70,130
                    //                 +---------+
                    //                 |         |
                    //                 |  Cand   |
                    //                 |         |
                    //     100,100     +---------+170,99
                    //           +----------------------+
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |        Exist         |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Because this affects the candidate, restart the
                    // comparisons to check for overlaps between the
                    // adjusted candidate and other existing rectangles.
                    //
                    //
                    TRACE_OUT(( "OL_PART_ENCLOSES_YMIN - %d", iExist));
                    pCand->bottom = g_baBounds[iExist].Coord.top - 1;

                    fResetRects = TRUE;
                    break;

                case OL_PART_ENCLOSES_YMAX:
                    //
                    // The existing partially encloses the candidate - but
                    // not on the bottom.
                    //
                    //     100,100
                    //           +----------------------+
                    //           |        Exist         |
                    //           |                      |
                    //           | 130,130              |
                    //           |     +--------+       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           |     |  Cand  |       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           +-----+--------+-------+
                    //                 |        |     200,200
                    //                 |        |
                    //                 |        |
                    //                 +--------+170,230
                    //
                    // Adjust the candidate rectangle to be the non-
                    // overlapped portion.
                    //
                    //
                    //     100,100
                    //           +----------------------+
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |        Exist         |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           +----------------------+
                    //          130,201+---------+   200,200
                    //                 |         |
                    //                 |  Cand   |
                    //                 |         |
                    //                 +---------+170,230
                    //
                    // Because this affects the candidate, restart the
                    // comparisons to check for overlaps between the
                    // adjusted candidate and other existing rectangles.
                    //
                    //
                    TRACE_OUT(( "OL_PART_ENCLOSES_YMAX - %d", iExist));
                    pCand->top = g_baBounds[iExist].Coord.bottom + 1;

                    fResetRects = TRUE;
                    break;

                case OL_SPLIT_X:
                    //
                    // The existing overlaps the candicate, but neither can
                    // be merged or adjusted.
                    //
                    //               100,100
                    //                 +--------+
                    //                 |        |
                    //        70,130   |  Exist |
                    //           +-----+--------+------+
                    //           |     |        |      |
                    //           |     |        |      |
                    //           | Cand|        |      |
                    //           |     |        |      |
                    //           |     |        |      |
                    //           +-----+--------+------+180,160
                    //                 |        |
                    //                 |        |
                    //                 +--------+150,200
                    //
                    // Need to split candidate into left and right halves.
                    //
                    // Only do a split if there is spare room in the list -
                    // because both the split rectangles may need to be
                    // added to the list.
                    //
                    // If there is spare room, split the candidate into a
                    // smaller candidate on the left and a new rectangle on
                    // the right. Call this routine recursively to handle
                    // the new rectangle.
                    //
                    //               100,100
                    //                 +--------+
                    //                 |        |
                    //        70,130   |        |151,130
                    //           +----+|        |+-----+
                    //           |    ||        ||     |
                    //           |    ||        ||     |
                    //           |Cand|| Exist  || New |
                    //           |    ||        ||     |
                    //           |    ||        ||     |
                    //           +----+|        |+-----+
                    //           99,160|        |     180,160
                    //                 |        |
                    //                 +--------+150,200
                    //
                    // After the recursion, because the candidate has
                    // changed, restart the comparisons to check for
                    // overlaps between the adjusted candidate and other
                    // existing rectangles.
                    //
                    //
                    TRACE_OUT(( "OL_SPLIT_X - %d", iExist));

                    if ((g_baRectsUsed < BA_NUM_RECTS) &&
                        (level < ADDR_RECURSE_LIMIT))
                    {
                        rectNew.left   = g_baBounds[iExist].Coord.right + 1;
                        rectNew.right  = pCand->right;
                        rectNew.top    = pCand->top;
                        rectNew.bottom = pCand->bottom;
                        pCand->right   = g_baBounds[iExist].Coord.left - 1;

                        TRACE_OUT(( "*** RECURSION ***"));
                        BAAddRect(&rectNew, level);
                        TRACE_OUT(( "*** RETURN    ***"));

                        if (!fRectToAdd && !g_baBounds[iLastMerge].InUse)
                        {
                            TRACE_OUT(( "FINISHED - %d", iLastMerge));
                            DC_QUIT;
                        }

                        fResetRects = TRUE;
                    }
                    break;

                case OL_SPLIT_Y:
                    //
                    // The existing overlaps the candicate, but neither can
                    // be merged or adjusted.
                    //
                    //               100,100
                    //                 +--------+
                    //                 |        |
                    //        70,130   |  Cand  |
                    //           +-----+--------+------+
                    //           |     |        |      |
                    //           |     |        |      |
                    //           |Exist|        |      |
                    //           |     |        |      |
                    //           |     |        |      |
                    //           +-----+--------+------+180,160
                    //                 |        |
                    //                 |        |
                    //                 +--------+150,200
                    //
                    // Need to split candidate into top and bottom halves.
                    //
                    // Only do a split if there is spare room in the list -
                    // because both the split rectangles may need to be
                    // added to the list.
                    //
                    // If there is spare room, split the candidate into a
                    // smaller candidate on the top and a new rectangle on
                    // the bottom.  Call this routine recursively to handle
                    // the new rectangle.
                    //
                    //               100,100
                    //                 +--------+
                    //                 |  Cand  |
                    //        70,130   +--------+150,129
                    //           +---------------------+
                    //           |                     |
                    //           |                     |
                    //           |                     |
                    //           |                     |
                    //           |                     |
                    //           +---------------------+180,160
                    //          100,161+--------+
                    //                 |  New   |
                    //                 +--------+150,200
                    //
                    // After the recursion, because the candidate has
                    // changed, restart the comparisons to check for
                    // overlaps between the adjusted candidate and other
                    // existing rectangles.
                    //
                    //
                    TRACE_OUT(( "OL_SPLIT_Y - %d", iExist));

                    if ((g_baRectsUsed < BA_NUM_RECTS) &&
                        (level < ADDR_RECURSE_LIMIT))
                    {
                        rectNew.left   = pCand->left;
                        rectNew.right  = pCand->right;
                        rectNew.top    = g_baBounds[iExist].Coord.bottom + 1;
                        rectNew.bottom = pCand->bottom;
                        pCand->bottom  = g_baBounds[iExist].Coord.top - 1;

                        TRACE_OUT(( "*** RECURSION ***"));
                        BAAddRect(&rectNew, level);
                        TRACE_OUT(( "*** RETURN    ***"));

                        if (!fRectToAdd && !g_baBounds[iLastMerge].InUse)
                        {
                            TRACE_OUT(( "FINISHED - %d", iLastMerge));
                            DC_QUIT;
                        }

                        fResetRects = TRUE;
                    }
                    break;

                case OL_SPLIT_XMIN_YMIN:
                    //
                    // The existing overlaps the candicate, but neither can
                    // be merged or adjusted.
                    //
                    //          100,100
                    //              +---------------+
                    //              |   Cand        |
                    //              |               |
                    //              |               |
                    //              |      150,150  |
                    //              |       +-------+-----+
                    //              |       |       |     |
                    //              |       |       |     |
                    //              |       |       |     |
                    //              |       |       |     |
                    //              |       |       |     |
                    //              +-------+-------+     |
                    //                      |    200,200  |
                    //                      |             |
                    //                      |    Exist    |
                    //                      |             |
                    //                      +-------------+
                    //                                 250,250
                    //
                    // Need to split candidate into top and left pieces.
                    //
                    // Only do a split if there is spare room in the list -
                    // because both the split rectangles may need to be
                    // added to the list.
                    //
                    // If there is spare room, split the candidate into a
                    // smaller candidate on the left and a new rectangle on
                    // the top.  Call this routine recursively to handle
                    // the new rectangle.
                    //
                    //          100,100     151,100
                    //              +-------+-------+
                    //              |       |       |
                    //              |       |  New  |
                    //              |       |       |
                    //              |       |       |200,149
                    //              |       +-------+-----+
                    //              | Cand  |150,150      |
                    //              |       |             |
                    //              |       |             |
                    //              |       |             |
                    //              |       |    Exist    |
                    //              +-------+             |
                    //               150,200|             |
                    //                      |             |
                    //                      |             |
                    //                      |             |
                    //                      +-------------+
                    //                                 250,250
                    //
                    // After the recursion, because the candidate has
                    // changed, restart the comparisons to check for
                    // overlaps between the adjusted candidate and other
                    // existing rectangles.
                    //
                    //
                    TRACE_OUT(( "OL_SPLIT_XMIN_YMIN - %d", iExist));

                    if ( g_baRectsUsed < BA_NUM_RECTS )
                    {
                        rectNew.left   = g_baBounds[iExist].Coord.left;
                        rectNew.right  = pCand->right;
                        rectNew.top    = pCand->top;
                        rectNew.bottom = g_baBounds[iExist].Coord.top - 1;
                        pCand->right   = g_baBounds[iExist].Coord.left - 1;

                        TRACE_OUT(( "*** RECURSION ***"));
                        BAAddRect(&rectNew, level);
                        TRACE_OUT(( "*** RETURN    ***"));

                        if (!fRectToAdd && !g_baBounds[iLastMerge].InUse)
                        {
                            TRACE_OUT(( "FINISHED - %d", iLastMerge));
                            DC_QUIT;
                        }

                        fResetRects = TRUE;
                    }
                    break;

                case OL_SPLIT_XMAX_YMIN:
                    //
                    // The existing overlaps the candicate, but neither can
                    // be merged or adjusted.
                    //
                    //                  150,100
                    //                     +---------------+
                    //                     |               |
                    //                     |       Cand    |
                    //          100,150    |               |
                    //              +------+--------+      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      +--------+------+
                    //              |               |   250,200
                    //              |  Exist        |
                    //              |               |
                    //              +---------------+
                    //                           200,250
                    //
                    // Need to split candidate into top and right pieces.
                    //
                    // Only do a split if there is spare room in the list -
                    // because both the split rectangles may need to be
                    // added to the list.
                    //
                    // If there is spare room, split the candidate into a
                    // smaller candidate on the right and a new rectangle
                    // on the top.  Call this routine recursively to handle
                    // the new rectangle.
                    //
                    //                  150,100     201,100
                    //                     +--------+------+
                    //                     |  New   |      |
                    //                     |        |      |
                    //          100,150    | 200,149|      |
                    //              +------+--------+      |
                    //              |               | Cand |
                    //              |               |      |
                    //              |               |      |
                    //              |               |      |
                    //              |     Exist     |      |
                    //              |               |      |
                    //              |               +------+
                    //              |               |   250,200
                    //              |               |
                    //              |               |
                    //              +---------------+
                    //                           200,250
                    //
                    // After the recursion, because the candidate has
                    // changed, restart the comparisons to check for
                    // overlaps between the adjusted candidate and other
                    // existing rectangles.
                    //
                    //
                    TRACE_OUT(( "OL_SPLIT_XMAX_YMIN - %d", iExist));

                    if ((g_baRectsUsed < BA_NUM_RECTS) &&
                        (level < ADDR_RECURSE_LIMIT))
                    {
                        rectNew.left   = pCand->left;
                        rectNew.right  = g_baBounds[iExist].Coord.right;
                        rectNew.top    = pCand->top;
                        rectNew.bottom = g_baBounds[iExist].Coord.top - 1;
                        pCand->left    = g_baBounds[iExist].Coord.right + 1;

                        TRACE_OUT(( "*** RECURSION ***"));
                        BAAddRect(&rectNew, level);
                        TRACE_OUT(( "*** RETURN    ***"));

                        if (!fRectToAdd && !g_baBounds[iLastMerge].InUse)
                        {
                            TRACE_OUT(( "FINISHED - %d", iLastMerge));
                            DC_QUIT;
                        }

                        fResetRects = TRUE;
                    }
                    break;

                case OL_SPLIT_XMIN_YMAX:
                    //
                    // The existing overlaps the candicate, but neither can
                    // be merged or adjusted.
                    //
                    //                  150,100
                    //                     +---------------+
                    //                     |               |
                    //                     |      Exist    |
                    //          100,150    |               |
                    //              +------+--------+      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      +--------+------+
                    //              |               |   250,200
                    //              |  Cand         |
                    //              |               |
                    //              +---------------+
                    //                           200,250
                    //
                    // Need to split candidate into left and bottom pieces.
                    //
                    // Only do a split if there is spare room in the list -
                    // because both the split rectangles may need to be
                    // added to the list.
                    //
                    // If there is spare room, split the candidate into a
                    // smaller candidate on the left and a new rectangle on
                    // the bottom.  Call this routine recursively to handle
                    // the new rectangle.
                    //
                    //                  150,100
                    //                     +---------------+
                    //                     |               |
                    //                     |               |
                    //          100,150    |               |
                    //              +------+               |
                    //              |      |               |
                    //              |      |               |
                    //              |      |               |
                    //              |      |               |
                    //              | Cand |               |
                    //              |      |               |
                    //              |      +--------+------+
                    //              |      |151,200 |   250,200
                    //              |      |        |
                    //              |      |  New   |
                    //              +------+--------+
                    //                  149,250   200,250
                    //
                    // After the recursion, because the candidate has
                    // changed, restart the comparisons to check for
                    // overlaps between the adjusted candidate and other
                    // existing rectangles.
                    //
                    //
                    TRACE_OUT(( "OL_SPLIT_XMIN_YMAX - %d", iExist));

                    if ((g_baRectsUsed < BA_NUM_RECTS) &&
                        (level < ADDR_RECURSE_LIMIT))
                    {
                        rectNew.left   = g_baBounds[iExist].Coord.left;
                        rectNew.right  = pCand->right;
                        rectNew.top    = g_baBounds[iExist].Coord.bottom + 1;
                        rectNew.bottom = pCand->bottom;
                        pCand->right   = g_baBounds[iExist].Coord.left - 1;

                        TRACE_OUT(( "*** RECURSION ***"));
                        BAAddRect(&rectNew, level);
                        TRACE_OUT(( "*** RETURN    ***"));

                        if (!fRectToAdd && !g_baBounds[iLastMerge].InUse)
                        {
                            TRACE_OUT(( "FINISHED - %d", iLastMerge));
                            DC_QUIT;
                        }

                        fResetRects = TRUE;
                    }
                    break;

                case OL_SPLIT_XMAX_YMAX:
                    //
                    // The existing overlaps the candicate, but neither can
                    // be merged or adjusted.
                    //
                    //          100,100
                    //              +---------------+
                    //              |   Exist       |
                    //              |               |
                    //              |               |
                    //              |      150,150  |
                    //              |       +-------+-----+
                    //              |       |       |     |
                    //              |       |       |     |
                    //              |       |       |     |
                    //              |       |       |     |
                    //              |       |       |     |
                    //              +-------+-------+     |
                    //                      |    200,200  |
                    //                      |             |
                    //                      |    Cand     |
                    //                      |             |
                    //                      +-------------+
                    //                                 250,250
                    //
                    // Need to split candidate into bottom and right pieces.
                    //
                    // Only do a split if there is spare room in the list -
                    // because both the split rectangles may need to be
                    // added to the list.
                    //
                    // If there is spare room, split the candidate into a
                    // smaller candidate on the right and a new rectangle
                    // on the bottom.  Call this routine recursively to
                    // handle the new rectangle.
                    //
                    //          100,100
                    //              +---------------+
                    //              |               |
                    //              |               |
                    //              |               |
                    //              |               |201,150
                    //              |    Exist      +-----+
                    //              |               |     |
                    //              |               |     |
                    //              |               |     |
                    //              |               |Cand |
                    //              |        200,200|     |
                    //              +-------+-------+     |
                    //               150,201|       |     |
                    //                      |       |     |
                    //                      |  New  |     |
                    //                      |       |     |
                    //                      +-------+-----+
                    //                         200,250  250,250
                    //
                    // After the recursion, because the candidate has
                    // changed, restart the comparisons to check for
                    // overlaps between the adjusted candidate and other
                    // existing rectangles.
                    //
                    //
                    TRACE_OUT(( "OL_SPLIT_XMAX_YMAX - %d", iExist));

                    if ((g_baRectsUsed < BA_NUM_RECTS) &&
                        (level < ADDR_RECURSE_LIMIT))
                    {
                        rectNew.left   = pCand->left;
                        rectNew.right  = g_baBounds[iExist].Coord.right;
                        rectNew.top    = g_baBounds[iExist].Coord.bottom + 1;
                        rectNew.bottom = pCand->bottom;
                        pCand->left    = g_baBounds[iExist].Coord.right + 1;

                        TRACE_OUT(( "*** RECURSION ***"));
                        BAAddRect(&rectNew, level);
                        TRACE_OUT(( "*** RETURN    ***"));

                        if (!fRectToAdd && !g_baBounds[iLastMerge].InUse)
                        {
                            TRACE_OUT(( "FINISHED - %d", iLastMerge));
                            DC_QUIT;
                        }

                        fResetRects = TRUE;
                    }
                    break;

                default:
                    //
                    // This should not happen.
                    //
                    ERROR_OUT(( "Unrecognised overlap case-%d",OverlapType));
                    break;
            }

            iExist = (fResetRects) ? g_baFirstRect :
                                     g_baBounds[iExist].iNext;
        }


        //
        // Arriving here means that no overlap was found between the
        // candidate and the existing rectangles.
        //
        // - If the candidate is the original rectangle, add it to the
        //   list.
        // - If the candidate is an existing rectangle, it is already in
        //   the list.
        //
        if ( fRectToAdd )
        {
            BAAddRectList(pCand);
        }


        //
        // The compare and add processing above is allowed to add a
        // rectangle to the list when there are already BA_NUM_RECTS
        // (eg. when doing a split or when there is no overlap at all with
        // the existing rectangles) - and there is an extra slot for that
        // purpose.
        //
        // If we now have more than BA_NUM_RECTS rectangles, do a
        // forced merge, so that the next call to this routine has a spare
        // slot.
        //
        //
        fRectMerged = ( g_baRectsUsed > BA_NUM_RECTS );
        if ( fRectMerged )
        {
            //
            // Start looking for merged rectangles.
            //
            // For each rectangle in the list, compare it with the others,
            // and Determine cost of merging.
            //
            // We want to merge the two rectangles with the minimum
            // area difference, ie that will produce a merged
            // rectangle that covers the least superfluous screen
            // area.
            //
            // Note that we calculate the areas of the rectangles here
            // (rather than on the fly as they are created/ manipulated in
            // the loop), as the statistics show that forced merges occur
            // very much less frequently than non-forced manipulations (ie
            // splits, adds etc.
            //
            //
            bestMergeIncrease = 0x7FFFFFFF;

            for ( iExist = g_baFirstRect;
                  iExist != BA_INVALID_RECT_INDEX;
                  iExist = g_baBounds[iExist].iNext )
            {
                g_baBounds[iExist].Area =
                    COM_SizeOfRectInclusive(&g_baBounds[iExist].Coord);
            }

#ifdef _DEBUG
            iBestMerge1 = BA_INVALID_RECT_INDEX;
            iBestMerge2 = BA_INVALID_RECT_INDEX;
#endif

            for ( iExist = g_baFirstRect;
                  iExist != BA_INVALID_RECT_INDEX;
                  iExist = g_baBounds[iExist].iNext )
            {
                for ( iTmp = g_baBounds[iExist].iNext;
                      iTmp != BA_INVALID_RECT_INDEX;
                      iTmp = g_baBounds[iTmp].iNext )
                {
                    rectNew.left = min( g_baBounds[iExist].Coord.left,
                                           g_baBounds[iTmp].Coord.left );
                    rectNew.top = min( g_baBounds[iExist].Coord.top,
                                          g_baBounds[iTmp].Coord.top );
                    rectNew.right = max( g_baBounds[iExist].Coord.right,
                                            g_baBounds[iTmp].Coord.right );
                    rectNew.bottom = max( g_baBounds[iExist].Coord.bottom,
                                             g_baBounds[iTmp].Coord.bottom );

                    mergeIncrease = COM_SizeOfRectInclusive(&rectNew) -
                        g_baBounds[iExist].Area - g_baBounds[iTmp].Area;

                    if (bestMergeIncrease > mergeIncrease)
                    {
                        iBestMerge1 = iExist;
                        iBestMerge2 = iTmp;
                        bestMergeIncrease = mergeIncrease;
                    }
                }
            }

            ASSERT(iBestMerge1 != BA_INVALID_RECT_INDEX);
            ASSERT(iBestMerge2 != BA_INVALID_RECT_INDEX);

            //
            // Now do the merge.
            //
            // We recalculate the size of the merged rectangle here -
            // alternatively we could remember the size of the best so far
            // in the loop above.  The trade off is between calculating
            // twice or copying at least once but probably more than once
            // as we find successively better merges.
            //
            TRACE_OUT(("BestMerge1 %d, (%d,%d,%d,%d)", iBestMerge1,
                       g_baBounds[iBestMerge1].Coord.left,
                       g_baBounds[iBestMerge1].Coord.top,
                       g_baBounds[iBestMerge1].Coord.right,
                       g_baBounds[iBestMerge1].Coord.bottom ));

            TRACE_OUT(("BestMerge2 %d, (%d,%d,%d,%d)", iBestMerge2,
                       g_baBounds[iBestMerge2].Coord.left,
                       g_baBounds[iBestMerge2].Coord.top,
                       g_baBounds[iBestMerge2].Coord.right,
                       g_baBounds[iBestMerge2].Coord.bottom ));

            g_baBounds[iBestMerge1].Coord.left =
                            min( g_baBounds[iBestMerge1].Coord.left,
                                    g_baBounds[iBestMerge2].Coord.left );
            g_baBounds[iBestMerge1].Coord.top =
                            min( g_baBounds[iBestMerge1].Coord.top,
                                    g_baBounds[iBestMerge2].Coord.top );
            g_baBounds[iBestMerge1].Coord.right =
                            max( g_baBounds[iBestMerge1].Coord.right,
                                    g_baBounds[iBestMerge2].Coord.right );
            g_baBounds[iBestMerge1].Coord.bottom =
                            max( g_baBounds[iBestMerge1].Coord.bottom,
                                    g_baBounds[iBestMerge2].Coord.bottom );

            //
            // Remove the second best merge.
            //
            BA_RemoveRectList(&(g_baBounds[iBestMerge2].Coord));

            //
            // The best merged rectangle becomes the candidate, and we fall
            // g_back to the head of the comparison loop to start again.
            //
            pCand      = &(g_baBounds[iBestMerge1].Coord);
            iLastMerge = iBestMerge1;
            fRectToAdd = FALSE;
        }

    } while ( fRectMerged );

DC_EXIT_POINT:
    DebugExitBOOL(BAAddRect, rc);
    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32.nt\makefile.inc ===
!include $(ROOT)\as\common.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32.nt\im.cpp ===
#include "precomp.h"

//
// IM.CPP
// Input Manager, NT specific code
//

#define MLZ_FILE_ZONE  ZONE_INPUT

//
// OSI_InstallControlledHooks()
//
// Installs/removes input hooks for control
//
BOOL WINAPI OSI_InstallControlledHooks(BOOL fEnable, BOOL fDesktop)
{
    BOOL    rc = FALSE;

    DebugEntry(OSI_InstallControlledHooks);

    if (fEnable)
    {
        //
        // Create the service thread, it will install the hooks.
        //
        ASSERT(!g_imNTData.imLowLevelInputThread);

        if (!DCS_StartThread(IMLowLevelInputProcessor))
        {
            ERROR_OUT(( "Failed to create LL IM thread"));
            DC_QUIT;
        }
    }
    else
    {
        if (g_imNTData.imLowLevelInputThread != 0)
        {
            PostThreadMessage( g_imNTData.imLowLevelInputThread, WM_QUIT, 0, 0);
            g_imNTData.imLowLevelInputThread = 0;
        }
    }

    if (fDesktop)
    {
        rc = TRUE;
    }
    else
    {
        rc = OSI_InstallHighLevelMouseHook(fEnable);
    }

DC_EXIT_POINT:
    DebugExitBOOL(OSI_InstallControlledHooks, rc);
    return(rc);
}



// Name:      IMLowLevelInputProcessor
//
// Purpose:   Main function for the low-level input handler thread.
//
// Returns:   wParam of the WM_QUIT message.
//
// Params:    syncObject - sync object that allows this thread to signal
//            the creating thread via COM_SignalThreadStarted.
//
// Operation: This function is the start point for the low-level input
//            handler thread.
//
//            We raise the priority of this thread to:
//            (a) ensure that we avoid hitting the low-level callback
//            timeout - which would cause us to miss events.
//            (b) minimize visible mouse movement lag on the screen.
//
//            The thread installs the low-level hooks and enters a
//            GetMessage/DispatchMessage loop which handles the low-level
//            callbacks.
//
//            The Share Core sends the thread a WM_QUIT message to
//            terminate it, which causes it to exit the message loop and
//            removes the low-level hooks before it terminates.
//
DWORD WINAPI IMLowLevelInputProcessor(LPVOID hEventWait)
{
    MSG             msg;
    UINT            rc = 0;

    DebugEntry(IMLowLevelInputProcessor);

    TRACE_OUT(( "Thread started..."));

    //
    // Give ourseleves the highest possible priority (within our process
    // priority class) to ensure that the low-level events are serviced as
    // soon as possible.
    //
    SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);

    g_imNTData.imLowLevelInputThread = GetCurrentThreadId();

    //
    // Install low-level input hooks.
    //
    g_imNTData.imhLowLevelMouseHook = SetWindowsHookEx(
                                     WH_MOUSE_LL,
                                     IMLowLevelMouseProc,
                                     g_asInstance,
                                     0 );

    g_imNTData.imhLowLevelKeyboardHook = SetWindowsHookEx(
                                     WH_KEYBOARD_LL,
                                     IMLowLevelKeyboardProc,
                                     g_asInstance,
                                     0 );

    //
    // We're done with our init code, for better or for worse.  Let the
    // calling thread continue.
    //
    SetEvent((HANDLE)hEventWait);

    if ( (g_imNTData.imhLowLevelMouseHook == NULL) ||
         (g_imNTData.imhLowLevelKeyboardHook == NULL) )
    {
        ERROR_OUT(( "SetWindowsHookEx failed: hMouse(%u) hKeyboard(%u)",
            g_imNTData.imhLowLevelMouseHook, g_imNTData.imhLowLevelKeyboardHook ));
        DC_QUIT;
    }

    //
    // Do our message loop to get events
    //
    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    //
    // Remove hooks
    //

    if (g_imNTData.imhLowLevelMouseHook != NULL)
    {
        UnhookWindowsHookEx(g_imNTData.imhLowLevelMouseHook);
        g_imNTData.imhLowLevelMouseHook = NULL;
    }

    if (g_imNTData.imhLowLevelKeyboardHook != NULL)
    {
        UnhookWindowsHookEx(g_imNTData.imhLowLevelKeyboardHook);
        g_imNTData.imhLowLevelKeyboardHook = NULL;
    }

DC_EXIT_POINT:
    DebugExitDWORD(IMLowLevelInputProcessor, rc);
    return(rc);
}


//
// Name:      IMOtherDesktopProc()
//
// This allows us to inject (but not block) input into other desktops
// besides default, where the user's desktop resides.  Specifically, the
// winlogon desktop and/or the screensaver desktop.
//
// This is trickier than it might seem, because the winlogon desktop is
// always around, but the screen saver one is transitory.
//
// The periodic SWL_ code, called when hosting, checks for the current
// desktop and if it's switched posts us a message so we can change our
// desktop and our hooks.
//
DWORD WINAPI IMOtherDesktopProc(LPVOID hEventWait)
{
    MSG             msg;
    UINT            rc = 0;
    HDESK           hDesktop;
    GUIEFFECTS      effects;

    DebugEntry(IMOtherDesktopProc);

    TRACE_OUT(("Other desktop thread started..."));

    g_imNTData.imOtherDesktopThread = GetCurrentThreadId();

    //
    // Start out attached to the WinLogon desktop because it's always
    // around.
    //

    // Set our desktop to the winlogon desktop
    hDesktop = OpenDesktop(NAME_DESKTOP_WINLOGON,
                        0,
                        FALSE,
                        DESKTOP_JOURNALPLAYBACK);

    if ( !hDesktop )
    {
        WARNING_OUT(("OpenDesktop failed: %ld", GetLastError()));
        DC_QUIT;
    }
    else if (!SetThreadDesktop (hDesktop))
    {
        WARNING_OUT(("SetThreadDesktop failed: %ld", GetLastError()));
        DC_QUIT;
    }

    //
    // Attempt to load the driver dynamically on this thread also.
    //
    if (g_asNT5)
    {
        OSI_InitDriver50(TRUE);
    }

    // Let the calling thread continue.
    SetEvent((HANDLE)hEventWait);

    ZeroMemory(&effects, sizeof(effects));

    while (GetMessage(&msg, NULL, 0, 0))
    {
        switch(msg.message)
        {
            case OSI_WM_MOUSEINJECT:
                mouse_event(
                                LOWORD(msg.wParam), // flags
                                HIWORD(msg.lParam), // x
                                LOWORD(msg.lParam), // y
                                HIWORD(msg.wParam), // mouseData
                                0);                 // dwExtraInfo
                break;

            case OSI_WM_KEYBDINJECT:
                keybd_event(
                                (BYTE)(LOWORD(msg.lParam)), // vkCode
                                (BYTE)(HIWORD(msg.lParam)), // scanCode
                                (DWORD)msg.wParam,          // flags
                                0);                         // dwExtraInfo
                break;

            case OSI_WM_DESKTOPREPAINT:
                USR_RepaintWindow(NULL);
                break;

            case OSI_WM_INJECTSAS:
            {
                HWND hwndSAS;

                if ( hwndSAS = FindWindow("SAS window class",NULL))
                {
                    PostMessage(hwndSAS,WM_HOTKEY,0,
                        MAKELONG(0x8000|MOD_ALT|MOD_CONTROL,VK_DELETE));
                }
                else
                {
                    WARNING_OUT(("SAS window not found, on screensaver desktop"));
                }
                break;
            }

            case OSI_WM_DESKTOPSWITCH:
            {
                HDESK   hDesktopNew;

                TRACE_OUT(("OSI_WM_DESKTOPSWITCH:  switching desktop from %d to %d",
                    msg.wParam, msg.lParam));

                if (msg.lParam == DESKTOP_SCREENSAVER)
                {
                    // We're switching TO the screensaver, attach to it.
                    TRACE_OUT(("Switching TO screensaver"));
                    hDesktopNew = OpenDesktop(NAME_DESKTOP_SCREENSAVER,
                        0, FALSE, DESKTOP_JOURNALPLAYBACK);
                }
                else if (msg.wParam == DESKTOP_SCREENSAVER)
                {
                    //
                    // We're switching FROM the screensaver, reattach to
                    // winlogon
                    //
                    TRACE_OUT(("Switching FROM screensaver"));
                    hDesktopNew = OpenDesktop(NAME_DESKTOP_WINLOGON,
                        0, FALSE, DESKTOP_JOURNALPLAYBACK);
                }
                else
                {
                    hDesktopNew = NULL;
                }

                if (hDesktopNew != NULL)
                {
                    if (!SetThreadDesktop(hDesktopNew))
                    {
                        WARNING_OUT(("SetThreadDesktop to 0x%08x, type %d failed",
                            hDesktopNew, msg.lParam));
                    }
                    else
                    {
                        CloseHandle(hDesktop);
                        hDesktop = hDesktopNew;
                    }
                }
                break;
            }

            case OSI_WM_SETGUIEFFECTS:
            {
                HET_SetGUIEffects((msg.wParam != 0), &effects);
                break;
            }
        }
    }

DC_EXIT_POINT:

    if (g_asNT5)
    {
        OSI_InitDriver50(FALSE);
    }

    if (hDesktop)
    {
        CloseHandle(hDesktop);
    }

    g_imNTData.imOtherDesktopThread = 0;

    DebugExitDWORD(IMOtherDesktopProc, rc);
    return(rc);
}


//
// IMLowLevelMouseProc()
// NT callback for low-level mouse events.
//
// It is installed and called on a secondary thread with high priority to
// service the APC call outs.  It follows the windows hook conventions for
// parameters and return values--zero to accept the event, non-zero to
// discard.
//
//
LRESULT CALLBACK IMLowLevelMouseProc
(
    int       nCode,
    WPARAM    wParam,
    LPARAM    lParam
)
{
    LRESULT             rc = 0;
    PMSLLHOOKSTRUCT     pMouseEvent;

    DebugEntry(IMLowLevelMouseProc);

    pMouseEvent = (PMSLLHOOKSTRUCT)lParam;

    //
    // If this isn't for an event that is happening or it's one we
    // injected ourself, pass it through and no need for processing.
    //
    if ((nCode != HC_ACTION) || (pMouseEvent->flags & LLMHF_INJECTED))
    {
        DC_QUIT;
    }

    //
    // This is a local user event.  If controlled, throw it away.  Unless
    // it's a click, in that case post a REVOKECONTROL message.
    //
    if (g_imSharedData.imControlled)
    {
        //
        // If this is a button click, take control back
        //
        if ((wParam == WM_LBUTTONDOWN) ||
            (wParam == WM_RBUTTONDOWN) ||
            (wParam == WM_MBUTTONDOWN))
        {
            //
            // Don't take control back if this is unattended.
            //
            if (!g_imSharedData.imUnattended)
            {
                PostMessage(g_asMainWindow, DCS_REVOKECONTROL_MSG, 0, 0);
            }
        }

        // Swallow event.
        rc = 1;
    }

DC_EXIT_POINT:
    //
    // Don't pass on to the next hook (if there is one) if we are
    // discarding the event.
    //
    if (!rc)
    {
        rc = CallNextHookEx(g_imNTData.imhLowLevelMouseHook, nCode,
            wParam, lParam);
    }

    DebugExitDWORD(IMLowLevelMouseProc, rc);
    return(rc);
}


// Name:      IMLowLevelKeyboardProc
//
// Purpose:   Windows callback function for low-level keyboard events.
//
// Returns:   0 if event is to be passed on to USER.
//            1 if event is to be discarded.
//
// Params:    Low-level callback params (see Windows documentation).
//
// Operation: Determines whether to allow the given event into USER.
//
//            We always pass on injected events.
//            The Control Arbitrator determines whether local events are
//            passed on.
//
LRESULT CALLBACK IMLowLevelKeyboardProc
(
    int       nCode,
    WPARAM    wParam,
    LPARAM    lParam
)
{
    LRESULT             rc = 0;
    PKBDLLHOOKSTRUCT    pKbdEvent;

    DebugEntry(IMLowLevelKeyboardProc);

    pKbdEvent = (PKBDLLHOOKSTRUCT)lParam;

    //
    // If this isn't for an action or it's an event we ourself originated,
    // let it through, and do no processing.
    //
    if ((nCode != HC_ACTION) || (pKbdEvent->flags & LLKHF_INJECTED))
    {
        DC_QUIT;
    }

    if (g_imSharedData.imControlled)
    {
        if (!(pKbdEvent->flags & LLKHF_UP))
        {
            //
            // This is a key down.  Take control back, and kill control
            // allowability if it's the ESC key.
            //
            if ((pKbdEvent->vkCode & 0x00FF) == VK_ESCAPE || g_imSharedData.imUnattended)
            {
                // ESC key always disallows control, even in unattended mode
                PostMessage(g_asMainWindow, DCS_ALLOWCONTROL_MSG, FALSE, 0);
            }
            else if (!g_imSharedData.imUnattended)
            {
                PostMessage(g_asMainWindow, DCS_REVOKECONTROL_MSG, 0, 0);
            }
        }

        //
        // Don't discard toggle keys.  The enabled/disabled function
        // is already set before we see the keystroke.  If we discard,
        // the lights are incorrect.
        //
        // LAURABU:  How do we fix this in new model?  Post a toggle-key
        // message and undo it (fake press)?
        //
        if (!IM_KEY_IS_TOGGLE(pKbdEvent->vkCode & 0x00FF))
            rc = 1;
    }

DC_EXIT_POINT:
    //
    // Don't pass on to the next hook if we are swallowing the event.
    //
    if (!rc)
    {
        rc = CallNextHookEx(g_imNTData.imhLowLevelKeyboardHook,
            nCode, wParam, lParam);
    }

    DebugExitDWORD(IMLowLevelKeyboardProc, rc);
    return(rc);
}



//
// IMInjectMouseEvent()
// NT-specific version to inject mouse events into the local system
//
void WINAPI OSI_InjectMouseEvent
(
    DWORD   flags,
    LONG    x,
    LONG    y,
    DWORD   mouseData,
    DWORD   dwExtraInfo
)
{
    TRACE_OUT(("Before MOUSE inject:  %08lx, %08lx %08lx",
        flags, mouseData, dwExtraInfo));

    mouse_event(flags, (DWORD)x, (DWORD)y, mouseData, dwExtraInfo);

    if ( g_imNTData.imOtherDesktopThread )
    {
        // Stuff these dword parameters through WORDS
        // need to make sure we don't clip anything
        ASSERT(!(flags & 0xffff0000));
        //ASSERT(!(mouseData & 0xffff0000)); BUGBUG possible loss
        ASSERT(!(x & 0xffff0000));
        ASSERT(!(y & 0xffff0000));

        PostThreadMessage(
            g_imNTData.imOtherDesktopThread,
            OSI_WM_MOUSEINJECT,
            MAKEWPARAM((WORD)flags,(WORD)mouseData),
            MAKELPARAM((WORD)y, (WORD)x ));
    }

    TRACE_OUT(("After MOUSE inject"));
}


//
// OSI_InjectSAS()
// NT-specific version to inject ctrl+alt+del into the local system
//
void WINAPI OSI_InjectCtrlAltDel(void)
{
    if ( g_imNTData.imOtherDesktopThread )
    {
        PostThreadMessage(
            g_imNTData.imOtherDesktopThread,
            OSI_WM_INJECTSAS,
            0,
            0 );
    }
    else
    {
        WARNING_OUT(("Ignoring SAS Injection attempt"));
    }
}


//
// OSI_InjectKeyboardEvent()
// NT-specific version to inject keyboard events into the local system
//
void WINAPI OSI_InjectKeyboardEvent
(
    DWORD   flags,
    WORD    vkCode,
    WORD    scanCode,
    DWORD   dwExtraInfo
)
{
    TRACE_OUT(("Before KEY inject:  %04lx, {%04x, %04x}, %04lx",
        flags, vkCode, scanCode, dwExtraInfo));

    keybd_event((BYTE)vkCode, (BYTE)scanCode, flags, dwExtraInfo);

    if ( g_imNTData.imOtherDesktopThread )
    {
        PostThreadMessage(
            g_imNTData.imOtherDesktopThread,
            OSI_WM_KEYBDINJECT,
            (WPARAM)flags,
            MAKELPARAM(vkCode, scanCode));
    }

    TRACE_OUT(("After KEY inject"));
}


//
// OSI_DesktopSwitch()
// NT-specific, called when we think the current desktop has changed.
//
void WINAPI OSI_DesktopSwitch
(
    UINT    desktopFrom,
    UINT    desktopTo
)
{
    DebugEntry(OSI_DesktopSwitch);

    if (g_imNTData.imOtherDesktopThread)
    {
        PostThreadMessage(
            g_imNTData.imOtherDesktopThread,
            OSI_WM_DESKTOPSWITCH,
            desktopFrom,
            desktopTo);
    }

    DebugExitVOID(OSI_DesktopSwitch);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32.nt\osi.cpp ===
#include "precomp.h"

#ifndef DM_POSITION
#define DM_POSITION         0x00000020L
#endif

//
// OSI.CPP
// OS Isolation layer, NT version
//
// Copyright(c) Microsoft 1997-
//

#include <version.h>
#include <ndcgver.h>
#include <osi.h>

#define MLZ_FILE_ZONE  ZONE_CORE


//
// NT 5.0 app sharing stuff.
// NOTE:
//      The name for NetMeeting's display driver, s_szNmDD, comes from
// mnmdd.sys.  We have no define for it nor access to the source.  DO NOT
// CHANGE THIS without talking to Andre Vachon.  Hopefully, he will perform
// the same courtesy for us if he changes mnmdd.sys.  If not, we can't share 
// anymore.  We won't even find our driver to load.
//
typedef BOOL (WINAPI * FN_ENUMDD)(LPVOID, DWORD, LPDISPLAY_DEVICE, DWORD);
static TCHAR s_szNmDD[] = "NetMeeting driver";


//
// OSI_Load()
// This handles our process attach.  We figure out if this is NT5 or not
//
void OSI_Load(void)
{
    OSVERSIONINFO       osVersion;

    ZeroMemory(&osVersion, sizeof(osVersion));
    osVersion.dwOSVersionInfoSize = sizeof(osVersion);
    GetVersionEx(&osVersion);
    ASSERT(osVersion.dwPlatformId == VER_PLATFORM_WIN32_NT);

    if (osVersion.dwMajorVersion >= 5)
        g_asNT5 = TRUE;
}



//
// OSI_Unload()
// This handles our process detach.  We currently do nothing.
//
void OSI_Unload(void)
{
    return;
}



//
// OSI_InitDriver50()
//
// Attemps to dynamically load/unload our display driver for NT 5.0.  This is
// called on the main thread, and if under a service, on the winlogon
// thread also.  It will only succeed on the input focus desktop.
//
void  OSI_InitDriver50(BOOL fInit)
{
    DWORD               iEnum;
    DISPLAY_DEVICE      dd;
    DEVMODE             devmode;
    FN_ENUMDD           pfnEnumDD;

    DebugEntry(OSI_InitDriver50);

    ASSERT(g_asNT5);

    pfnEnumDD = (FN_ENUMDD)GetProcAddress(GetModuleHandle("USER32.DLL"),
        "EnumDisplayDevicesA");
    if (pfnEnumDD != NULL)
    {
        ZeroMemory(&dd, sizeof(dd));
        dd.cb = sizeof(dd);

        iEnum = 0;
        while (pfnEnumDD(NULL, iEnum++, &dd, 0))
        {
            if ((dd.StateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER) &&
                !lstrcmpi((LPCSTR)dd.DeviceString, s_szNmDD))
            {
                LONG    lResult;

                //
                // There may be multiple monitors, drivers, etc.  
                // We have to actually tell the system what bit depth, 
                // format, etc. our driver wants just like if we were 
                // a real driver.  We therefore always ask to get 24bpp 
                // format info, no myriad 16bpp and 32bpp formats to deal
                // with anymore.
                //
                // Also, no more 4bpp not VGA nonsense either--just 8 or 24.
                //

                ZeroMemory(&devmode, sizeof(devmode));
                devmode.dmSize = sizeof(devmode);
                devmode.dmFields = DM_POSITION | DM_BITSPERPEL | DM_PELSWIDTH |
                    DM_PELSHEIGHT;

                if (fInit)
                {
                    //
                    // Fill in fields to get driver attached.
                    //
                    if (g_usrCaptureBPP <= 8)
                        g_usrCaptureBPP = 8;
                    else
                        g_usrCaptureBPP = 24;
                    devmode.dmBitsPerPel = g_usrCaptureBPP;

                    // devmode.dmPosition is (0, 0), this means "primary"
                    devmode.dmPelsWidth = GetSystemMetrics(SM_CXSCREEN);
                    devmode.dmPelsHeight = GetSystemMetrics(SM_CYSCREEN);
                }


				//
				// Before we change the display settings in a multimonitor machine, we better move the cursor out of the way
				// If we do not do do we get an extra cursor in the middle of the primary monitor
				//
				::SetCursorPos(-1, -1);


                //
                // This simply changes the state in the registry from
                // attached to unattached, without the system actually 
                // reflecting the change.  If/when we have multiple 
                // listings for our shadow driver, move the CDS(NULL, 0)
                // call outside the loop, and get rid of the break.
                //
                lResult = ChangeDisplaySettingsEx((LPCSTR)dd.DeviceName, &devmode,
                        NULL, CDS_UPDATEREGISTRY | CDS_NORESET, NULL);
                if (lResult != DISP_CHANGE_SUCCESSFUL)
                {
                    WARNING_OUT(("ChangeDisplaySettingsEx failed, error %d", lResult));
                }
                else
                {
	
                    //
                    // This causes Windows to actually go reread the registry and 
                    // update the current display to reflect the attached items, 
                    // positions, sizes, and color depths.
                    //
                    ChangeDisplaySettings(NULL, 0);

#ifdef _DEBUG
                    if (fInit)
                    {
                        HDC hdc;
                            
                        //
                        // Create a temp DC based on this driver and make sure
                        // the settings matched what we asked for.
                        //
                        hdc = CreateDC(NULL, (LPCSTR)dd.DeviceName, NULL, NULL);

                        if (!hdc)
                        {
                            WARNING_OUT(("OSI_Init:  dynamic display driver load failed"));
                        }
                        else
                        {
                            ASSERT(GetDeviceCaps(hdc, HORZRES) == (int)devmode.dmPelsWidth);
                            ASSERT(GetDeviceCaps(hdc, VERTRES) == (int)devmode.dmPelsHeight);
                            ASSERT(GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES) ==
                                (int)g_usrCaptureBPP);

                            DeleteDC(hdc);
                        }
                    }
#endif // _DEBUG

                    //
                    // Tell MNMHOOK_ the name of our driver so it can talk
                    // to it via ExtEscape.
                    //
                    OSI_SetDriverName(fInit ? (LPCSTR)dd.DeviceName : NULL);
                }

                break;
            }
        }
    }

    DebugExitVOID(OSI_InitDriver50);
}


//
// OSI_Init - see osi.h
//
void  OSI_Init(void)
{
    UINT                i;
    OSI_INIT_REQUEST    requestBuffer;
    OSI_INIT_REQUEST    requestTerm;
    DebugEntry(OSI_Init);

    //
    // First, setup up pointer to shared data.  This data lives here in NT.
    //
#ifdef DEBUG
    g_imSharedData.cbSize = sizeof(g_imSharedData);
#endif

    g_lpimSharedData = &g_imSharedData;

    requestBuffer.result = FALSE;
    requestBuffer.pSharedMemory = NULL;
    requestBuffer.poaData[0] = NULL;
    requestBuffer.poaData[1] = NULL;
    requestBuffer.sbcEnabled = FALSE;

    for (i = 0; i < SBC_NUM_TILE_SIZES; i++)
    {
        ASSERT(!g_asbcShuntBuffers[i]);
        requestBuffer.psbcTileData[i] = NULL;
    }

    //
    // Do this FIRST.  On NT5, only threads on the desktop with input
    // can succeed at calling ChangeDisplaySettings.  So like other things,
    // we must try to dynamically load/unload our driver on both desks.
    //

    //
    // Create the winlogon desktop event injection helper thread
    // only if we're started as a service.  Note that it will try to
    // load display at start too.
    //
    ASSERT(!g_imNTData.imOtherDesktopThread);

    if (g_asOptions & AS_SERVICE)
    {
        WARNING_OUT(("Starting other desktop thread for SERVICE"));
        if (!DCS_StartThread(IMOtherDesktopProc))
        {
            WARNING_OUT(( "Failed to create other desktop IM thread"));
            DC_QUIT;
        }
    }


    //
    // DO THIS ONLY FOR NT5
    // We are going to enumerate all the entries for our shadow driver
    // (currently only one) and attach each to the actual display.
    //
    if (g_asNT5)
    {
        OSI_InitDriver50(TRUE);
    }

DC_EXIT_POINT:
    //$wilhelms - calling OSI_ESC_TERM in this case does not really help. 
    // In the driver we try to delete the WNDOBJ objects on OSI_ESC_TERM 
    // and we fail. The reason for that is the fact that you can't call EngDeleteWnd
    // if you are not in the context of a DrvEscape WNDOBJ_SETUP. If you are in the 
    // right context GDI will aquire some locks before calling into your DrvEscape. 
    // Without the right locks the EngDeleteWnd will fail.
    // First we will call HetClear to unshare all the windows (clear the atom and tell the
    // driver to delete the window tracking object). And then we will to a OSI_ESC_TERM to clean up other structures.
    // Note that the HET_ESC_UNSHARE_ALL is called as a WNDOBJ_SETUP function.
    HET_Clear();

    ZeroMemory(&requestTerm, sizeof(requestTerm));
    OSI_FunctionRequest(OSI_ESC_TERM, (LPOSI_ESCAPE_HEADER)&requestTerm,
        sizeof(requestTerm));


    g_osiInitialized = OSI_FunctionRequest(OSI_ESC_INIT, (LPOSI_ESCAPE_HEADER)&requestBuffer,
            sizeof(requestBuffer));

    if (!g_osiInitialized)
    {
        WARNING_OUT(("OSI_ESC_INIT: display driver not present"));
    }
    else
    {
        if (requestBuffer.result)
        {
            g_asCanHost = TRUE;

            //
            // Got shared memory pointers; keep them around
            //
            g_asSharedMemory   = (LPSHM_SHARED_MEMORY)requestBuffer.pSharedMemory;
            ASSERT(g_asSharedMemory);

            g_poaData[0]        = (LPOA_SHARED_DATA)requestBuffer.poaData[0];
            ASSERT(g_poaData[0]);

            g_poaData[1]        = (LPOA_SHARED_DATA)requestBuffer.poaData[1];
            ASSERT(g_poaData[1]);

            g_sbcEnabled        = requestBuffer.sbcEnabled;
            if (g_sbcEnabled)
            {
                //
                // Get shunt buffers
                //
                for (i = 0; i < SBC_NUM_TILE_SIZES; i++)
                {
                    g_asbcShuntBuffers[i] = (LPSBC_SHUNT_BUFFER)requestBuffer.psbcTileData[i];
                    ASSERT(g_asbcShuntBuffers[i]);

                    TRACE_OUT(("OSI_Init: sbc shunt buffer %d:  entries %08d, bytes 0x%08x",
                        i, g_asbcShuntBuffers[i]->numEntries, g_asbcShuntBuffers[i]->numBytes));
                }

                for (i = 0; i < 3; i++)
                {
                    g_asbcBitMasks[i] = requestBuffer.aBitmasks[i];
                }
            }
        }
    }

    if (g_asCanHost)
    {
        //
        // Tell HOOK dll (used for control as well as sharing) about our hwnd
        // and stuff.  If we are able to host.
        //
        ASSERT(g_asMainWindow);
        ASSERT(g_asHostProp);

        HOOK_Init(g_asMainWindow, g_asHostProp);
    }

    DebugExitVOID(OSI_Init);
}


//
// OSI_Term - see osi.h
//
void  OSI_Term(void)
{
    UINT    i;

    DebugEntry(OSI_Term);

    //
    // This can be called on multiple threads:
    //      * The main DCS thread
    //      * The last thread of the process causing us to get a process
    //              detach.
    // We call it in the latter case also to make sure we cleanup properly.
    //
    ASSERT(GetCurrentThreadId() == g_asMainThreadId);

    //
    // Kill the other desktop thread if it's around.
    //
    if (g_imNTData.imOtherDesktopThread != 0)
    {
        ASSERT(g_asOptions & AS_SERVICE);
        PostThreadMessage(g_imNTData.imOtherDesktopThread, WM_QUIT, 0, 0);
        while (g_imNTData.imOtherDesktopThread)
        {
            WARNING_OUT(("OSI_Term: waiting for other desktop thread to exit"));
            Sleep(1);
        }
    }


    if (g_osiInitialized)
    {
        OSI_TERM_REQUEST    requestBuffer;

        g_osiInitialized = FALSE;

        //
        // We call the term routine only if the driver is actually loaded
        // (as opposed to whether something went wrong when trying to setup
        // for hosting) so that we will cleanup if something went wrong in
        // the middle.
        //
        OSI_FunctionRequest(OSI_ESC_TERM, (LPOSI_ESCAPE_HEADER)&requestBuffer,
            sizeof(requestBuffer));
    }

    //
    // ONLY DO THIS FOR NT5
    // We need to undo all the work we did at init time to attach our 
    // driver(s) to the display, and detach them.  Again, enumerate the
    // registry entries and look for ours.
    //
    //

    if (g_asNT5)
    {
        OSI_InitDriver50(FALSE);
    }

    // Clear our shared memory variables
    for (i = 0; i < 3; i++)
    {
        g_asbcBitMasks[i] = 0;
    }

    for (i = 0; i < SBC_NUM_TILE_SIZES; i++)
    {
        g_asbcShuntBuffers[i] = NULL;
    }
    g_sbcEnabled = FALSE;

    g_asSharedMemory = NULL;
    g_poaData[0] = NULL;
    g_poaData[1] = NULL;

    g_asCanHost = FALSE;

    g_lpimSharedData = NULL;

    DebugExitVOID(OSI_Term);
}




VOID OSI_RepaintDesktop(void)
{
    DebugEntry(OSI_RepaintDesktop);

    // If this does not appear to be a window it may be a window on the
    // winlogon desktop, so we need to get the proxy thread to repaint it
    if ( g_imNTData.imOtherDesktopThread )
    {
        PostThreadMessage(g_imNTData.imOtherDesktopThread,
                        OSI_WM_DESKTOPREPAINT, 0, 0);
    }
    DebugExitVOID(OSI_RepaintDesktop);
}


VOID OSI_SetGUIEffects(BOOL fOff)
{
    DebugEntry(OSI_SetGUIEffects);

    if (g_imNTData.imOtherDesktopThread)
    {
        PostThreadMessage(g_imNTData.imOtherDesktopThread,
                        OSI_WM_SETGUIEFFECTS, fOff, 0);
    }

    DebugExitVOID(OSI_SetGUIEffects);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\dd\globals.c ===
//
// GLOBALS.C
// Global variable storage
//
// Copyright(c) Microsoft 1997-
//


#include "precomp.h"


#include <datainit.h>
#include "globals.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\dd\cm.c ===
#include "precomp.h"


//
// CM.C
// Cursor Manager, display driver side
//
// Copyright(c) Microsoft 1997-
//


//
//
// CM_DDProcessRequest() - see cm.h
//
//
ULONG CM_DDProcessRequest
(
    SURFOBJ*    pso,
    UINT        cjIn,
    void *      pvIn,
    UINT        cjOut,
    void *      pvOut
)
{
    BOOL                rc;
    LPOSI_ESCAPE_HEADER pHeader;
    LPOSI_PDEV          ppDev = (LPOSI_PDEV)pso->dhpdev;

    DebugEntry(CM_DDProcessRequest);

    if ((cjIn != sizeof(CM_DRV_XFORM_INFO)) ||
        (cjOut != sizeof(CM_DRV_XFORM_INFO)))
    {
        ERROR_OUT(("CM_DDProcessRequest:  Invalid sizes %d, %d for CM_ESC", cjIn, cjOut));
        rc = FALSE;
        DC_QUIT;
    }

    //
    // Get the request number.
    //
    pHeader = pvIn;
    switch (pHeader->escapeFn)
    {
        case CM_ESC_XFORM:
        {
            ASSERT(cjIn == sizeof(CM_DRV_XFORM_INFO));
            ASSERT(cjOut == sizeof(CM_DRV_XFORM_INFO));

            ((LPCM_DRV_XFORM_INFO)pvOut)->result =
                     CMDDSetTransform(ppDev, (LPCM_DRV_XFORM_INFO)pvIn);

            rc = TRUE;
            break;
        }
        break;

        default:
        {
            ERROR_OUT(("Unrecognised CM_ escape"));
            rc = FALSE;
        }
        break;
    }

DC_EXIT_POINT:
    DebugExitDWORD(CM_DDProcessRequest, rc);
    return((ULONG)rc);
}



// Name:      CM_DDInit
//
// Purpose:   Allocate a working surface for colour cursors
//
// Returns:   TRUE/FALSE
//
// Params:    IN      ppDev  - surface information
//
BOOL CM_DDInit(LPOSI_PDEV ppDev)
{
    SIZEL   bitmapSize;
    BOOL    rc = FALSE;

    DebugEntry(CM_DDInit);

    ASSERT(!g_cmWorkBitmap);

    //
    // Allocate the work bitmap, at the local device resolution.  Note that
    // we create it "top down" rather than the default of "bottom up" to
    // simplify copying data from the bitmap (we don't have to work out
    // offsets into the data - we can copy from the beginning).
    //
    bitmapSize.cx = CM_MAX_CURSOR_WIDTH;
    bitmapSize.cy = CM_MAX_CURSOR_HEIGHT;
    g_cmWorkBitmap = EngCreateBitmap(bitmapSize,
            BYTES_IN_BITMAP(bitmapSize.cx, 1, ppDev->cBitsPerPel),
            ppDev->iBitmapFormat, BMF_TOPDOWN, NULL);

    if (!g_cmWorkBitmap)
    {
        ERROR_OUT(( "Failed to create work bitmap"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(CM_DDInit, rc);
    return(rc);
}



//
//
// CM_DDTerm - see cm.h
//
//
void CM_DDTerm(void)
{
    DebugEntry(CM_DDTerm);

    //
    // Destroy the bitmap.  Despite its name, EngDeleteSurface is the
    // correct function to do this.
    //
    if (g_cmWorkBitmap)
    {
        if (!EngDeleteSurface((HSURF)g_cmWorkBitmap))
        {
            ERROR_OUT(( "Failed to delete work bitmap"));
        }
        else
        {
            TRACE_OUT(( "Deleted work bitmap"));
        }

        g_cmWorkBitmap = NULL;
    }

    DebugExitVOID(CM_DDTerm);
}


//
// CM_DDViewing()
//
void CM_DDViewing
(
    SURFOBJ *   pso,
    BOOL        fViewers
)
{
    DebugEntry(CM_DDViewing);

    if (fViewers)
    {
        //
        // Jiggle the cursor so we get the current image.
        //
        EngSetPointerTag(((LPOSI_PDEV)pso->dhpdev)->hdevEng, NULL, NULL, NULL, 0);
    }

    DebugExitVOID(CM_DDViewing);
}


//
//
// DrvSetPointerShape - see winddi.h
//
//
ULONG  DrvSetPointerShape(SURFOBJ  *pso,
                          SURFOBJ  *psoMask,
                          SURFOBJ  *psoColor,
                          XLATEOBJ *pxlo,
                          LONG      xHot,
                          LONG      yHot,
                          LONG      x,
                          LONG      y,
                          RECTL    *prcl,
                          FLONG     fl)
{
    ULONG                 rc         = SPS_ACCEPT_NOEXCLUDE;
    SURFOBJ *         pWorkSurf  = NULL;
    LPOSI_PDEV             ppDev      = (LPOSI_PDEV)pso->dhpdev;
    BOOL                writingSHM = FALSE;
    LPCM_SHAPE_DATA pCursorShapeData;
    RECTL                 destRectl;
    POINTL                sourcePt;
    int                   ii;
    LONG                  lineLen;
    LPBYTE              srcPtr;
    LPBYTE              dstPtr;
    LPCM_FAST_DATA      lpcmShared;

    DebugEntry(DrvSetPointerShape);

    //
    // Returning SPS_ACCEPT_NOEXCLUDE means we can ignore prcl.
    //

    //
    // Only process the change if we are hosting.  (Hosting implies being
    // initialized).
    //
    if (!g_oeViewers)
    {
        DC_QUIT;
    }

    //
    // Get access to the shared memory.
    //
    lpcmShared = CM_SHM_START_WRITING;
    writingSHM = TRUE;

    //
    // First of all, let's trace out some useful information.
    //
    TRACE_OUT(( "pso %#hlx psoMask %#hlx psoColor %#hlx pxlo %#hlx",
                  pso, psoMask, psoColor, pxlo));
    TRACE_OUT(( "hot spot (%d, %d) x, y (%d, %d)", xHot, yHot, x, y));
    TRACE_OUT(( "Flags %#hlx", fl));

    //
    // Set up a local pointer to the cursor shape data.
    //

    pCursorShapeData = &lpcmShared->cmCursorShapeData;

    if (psoMask == NULL)
    {
        //
        // This is a transparent cursor.  Send a NULL cursor.  Note that
        // this is not the same as hiding the cursor using DrvMovePointer -
        // as in this case the cursor cannot be unhidden unless
        // DrvSetPointerShape is called again.
        //
        TRACE_OUT(( "Transparent Cursor"));
        CM_SET_NULL_CURSOR(pCursorShapeData);
        g_asSharedMemory->cmCursorHidden = FALSE;
        lpcmShared->cmCursorStamp = g_cmNextCursorStamp++;
        DC_QUIT;
    }

    //
    // We've been passed a system cursor.  Fill in the header for our local
    // cursor.  We can get the hot spot position and cursor size and width
    // easily.
    //
    pCursorShapeData->hdr.ptHotSpot.x = xHot;
    pCursorShapeData->hdr.ptHotSpot.y = yHot;

    TRACE_OUT(( "Pointer mask is %#hlx by %#hlx pixels (lDelta: %#hlx)",
             psoMask->sizlBitmap.cx,
             psoMask->sizlBitmap.cy,
             psoMask->lDelta));

    pCursorShapeData->hdr.cx = (WORD)psoMask->sizlBitmap.cx;
    pCursorShapeData->hdr.cy = (WORD)psoMask->sizlBitmap.cy / 2;

    //
    // Check cursor size
    //
    if ((pCursorShapeData->hdr.cx > CM_MAX_CURSOR_WIDTH) ||
        (pCursorShapeData->hdr.cy > CM_MAX_CURSOR_HEIGHT))
    {
        ERROR_OUT(( "Cursor too big! %d %d",
                     psoMask->sizlBitmap.cx, psoMask->sizlBitmap.cy));
        DC_QUIT;
    }

    //
    // lDelta may be negative for an inverted cursor (which is what we get
    // from DC-Share).
    //
    lineLen = abs(psoMask->lDelta);

    //
    // At this point we need to know if we are dealing with a color cursor.
    //
    if (NULL == psoColor)
    {
        TRACE_OUT(( "Monochrome pointer"));

        pCursorShapeData->hdr.cPlanes     = 1;
        pCursorShapeData->hdr.cBitsPerPel = 1;

        pCursorShapeData->hdr.cbRowWidth  = (WORD)lineLen;

        //
        // Copy the 1bpp AND mask and cursor shape (XOR mask) across.
        //
        TRACE_OUT(( "Copying AND mask across from %#hlx (size: %#hlx)",
                 psoMask->pvBits,
                 psoMask->cjBits));

        dstPtr = pCursorShapeData->data;
        srcPtr = (LPBYTE) psoMask->pvScan0;
        for (ii = pCursorShapeData->hdr.cy * 2; ii > 0 ; ii--)
        {
            memcpy(dstPtr, srcPtr, lineLen);
            srcPtr += psoMask->lDelta;
            dstPtr += lineLen;
        }

        //
        // Copy black-and-white palette colors
        //
        TRACE_OUT(( "Copy B+W palette"));

        lpcmShared->colorTable[0].peRed   = 0;
        lpcmShared->colorTable[0].peGreen = 0;
        lpcmShared->colorTable[0].peBlue  = 0;
        lpcmShared->colorTable[0].peFlags = 0;

        lpcmShared->colorTable[1].peRed   = 255;
        lpcmShared->colorTable[1].peGreen = 255;
        lpcmShared->colorTable[1].peBlue  = 255;
        lpcmShared->colorTable[1].peFlags = 0;

        //
        // That's all we need to do in this case.
        //
    }
    else
    {
        TRACE_OUT(( "Color pointer - mask of %#hlx by %#hlx (lDelta: %#hlx)",
                 psoColor->sizlBitmap.cx,
                 psoColor->sizlBitmap.cy,
                 psoColor->lDelta));

        //
        // Note: row width used to calculate AND mask size - and is thus
        // for the 1bpp mask.
        //
        pCursorShapeData->hdr.cbRowWidth  = (WORD)lineLen;
        pCursorShapeData->hdr.cPlanes     = 1;

        //
        // Note: data at device bpp.
        //
        TRACE_OUT(( "BPP is %d", pCursorShapeData->hdr.cBitsPerPel));
        pCursorShapeData->hdr.cBitsPerPel = (BYTE)ppDev->cBitsPerPel;

        //
        // Lock the work bitmap to get a surface to pass to EngBitBlt.
        //
        pWorkSurf = EngLockSurface((HSURF)g_cmWorkBitmap);
        if (NULL == pWorkSurf)
        {
            ERROR_OUT(( "Failed to lock work surface"));
            DC_QUIT;
        }
        TRACE_OUT(( "Locked surface"));

        //
        // Perform the Blt to our work bitmap so that we can get the bits
        // at the native bpp.
        //
        destRectl.top    = 0;
        destRectl.left   = 0;
        destRectl.right  = psoColor->sizlBitmap.cx;
        destRectl.bottom = psoColor->sizlBitmap.cy;

        sourcePt.x = 0;
        sourcePt.y = 0;

        if (!EngBitBlt(pWorkSurf,
                       psoColor,
                       NULL,                    // mask surface
                       NULL,                    // clip object
                       pxlo,                    // XLATE object
                       &destRectl,
                       &sourcePt,
                       NULL,                    // mask origin
                       NULL,                    // brush
                       NULL,                    // brush origin
                       0xcccc))                 // SRCCPY
        {
            ERROR_OUT(( "Failed to Blt to work bitmap"));
            DC_QUIT;
        }
        TRACE_OUT(( "Got the bits at native format into the work bitmap"));

        //
        // Now copy the bits we want from this work bitmap into the
        // DCCURSORSHAPE shared memory.
        // First copy the AND bits (but ignore the redundant 1bpp XOR bits)
        //
        TRACE_OUT(( "Copy %d bytes of 1bpp AND mask", psoMask->cjBits/2));

        dstPtr = pCursorShapeData->data;
        srcPtr = (LPBYTE) psoMask->pvScan0;
        for (ii = pCursorShapeData->hdr.cy; ii > 0 ; ii--)
        {
            memcpy(dstPtr, srcPtr, lineLen);
            srcPtr += psoMask->lDelta;
            dstPtr += lineLen;
        }

        TRACE_OUT(( "Copy %d bytes of color", pWorkSurf->cjBits));
        memcpy(&(pCursorShapeData->data[psoMask->cjBits / 2]),
                  pWorkSurf->pvBits,
                  pWorkSurf->cjBits);


        //
        // Now work out the palette and copy into shared memory
        //
        if (pCursorShapeData->hdr.cBitsPerPel > 8)
        {
            //
            // Need the bitmasks.
            //
            TRACE_OUT(( "Copy bitmasks"));
            lpcmShared->bitmasks[0] = ppDev->flRed;
            lpcmShared->bitmasks[1] = ppDev->flGreen;
            lpcmShared->bitmasks[2] = ppDev->flBlue;
        }
        else
        {
            //
            // Need a palette.
            //
            TRACE_OUT(( "Copy %d palette bytes",
                  COLORS_FOR_BPP(ppDev->cBitsPerPel) * sizeof(PALETTEENTRY)));
            memcpy(lpcmShared->colorTable,
                      ppDev->pPal,
                      COLORS_FOR_BPP(ppDev->cBitsPerPel) *
                                                      sizeof(PALETTEENTRY));
        }
    }

    //
    // Set the cursor stamp, and the cursor hidden state.
    //
    lpcmShared->cmCursorStamp = g_cmNextCursorStamp++;
    g_asSharedMemory->cmCursorHidden = FALSE;

DC_EXIT_POINT:

    //
    // Free access to the shared memory if we got it earlier.
    //
    if (writingSHM)
    {
        CM_SHM_STOP_WRITING;
    }

    if (pWorkSurf != NULL)
    {
        //
        // Unlock the work bitmap surface.
        //
        EngUnlockSurface(pWorkSurf);
    }

    DebugExitDWORD(DrvSetPointerShape, rc);
    return(rc);

} // DrvSetPointerShape


//
// DrvMovePointer - see NT DDK documentation.
// We only look at this in order to check for hidden cursors - normal
// pointer moves are ignored.
//
VOID DrvMovePointer(SURFOBJ *pso,
                    LONG     x,
                    LONG     y,
                    RECTL   *prcl)
{
    LPOSI_PDEV ppdev = (LPOSI_PDEV) pso->dhpdev;

    DebugEntry(DrvMovePointer);

    //
    // We don't use the exclusion rectangle because we only support
    // hardware Pointers.  If we were doing our own Pointer simulations we
    // would want to update prcl so that the engine would call us to
    // exclude our pointer before drawing to the pixels in prcl.
    //

    //
    // Only process the mouse move if we are hosting.  (Hosting implies
    // being initialized).
    //
    if (!g_oeViewers)
    {
        DC_QUIT;
    }

    if (x == -1)
    {
        if (!g_cmCursorHidden)
        {
            //
            // Pointer is hidden.
            //
            TRACE_OUT(("Hide the cursor"));

            //
            // Set the 'hide cursor' flag.
            //
            CM_SHM_START_WRITING;
            g_asSharedMemory->cmCursorHidden = TRUE;
            CM_SHM_STOP_WRITING;

            //
            // Update our fast-path variable.
            //
            g_cmCursorHidden = TRUE;
        }
    }
    else
    {
        if (g_cmCursorHidden)
        {
            //
            // The pointer is unhidden
            //
            TRACE_OUT(("Show the cursor"));

            CM_SHM_START_WRITING;
            g_asSharedMemory->cmCursorHidden = FALSE;
            CM_SHM_STOP_WRITING;

            //
            // Update our fast-path variable.
            //
            g_cmCursorHidden = FALSE;
        }
    }


DC_EXIT_POINT:
    DebugExitVOID(DrvMovePointer);
}



// Name:      CMDDSetTransform
//
// Purpose:   Set up a cursor transform
//
// Returns:   TRUE/FALSE
//
// Params:    IN      ppDev - device info
//            IN      pXformInfo - data passed in to DrvEscape
//
BOOL CMDDSetTransform(LPOSI_PDEV ppDev, LPCM_DRV_XFORM_INFO pXformInfo)
{
    BOOL        rc = FALSE;
    LPBYTE      pAND   = pXformInfo->pANDMask;
    SIZEL       bitmapSize;
    HBITMAP     andBitmap;
    SURFOBJ  *  pANDSurf;

    DebugEntry(CMDDSetTransform);

    if (pAND == NULL)
    {
        //
        // Reset the transform
        //
        TRACE_OUT(( "Clear transform"));
        EngSetPointerTag(ppDev->hdevEng, NULL, NULL, NULL, 0);
        rc = TRUE;
        DC_QUIT;
    }

    //
    // Transforms are always monochrome
    //

    //
    // Create a 1bpp bitmap, double-height, with the AND bits followed by
    // the XOR bits.  We are given a top-down DIB, so we need to create
    // a top-down bitmap.
    //
    bitmapSize.cx = pXformInfo->width;
    bitmapSize.cy = pXformInfo->height * 2;

    andBitmap = EngCreateBitmap(bitmapSize, BYTES_IN_BITMAP(bitmapSize.cx, 1, 1),
        BMF_1BPP, BMF_TOPDOWN, NULL);

    pANDSurf = EngLockSurface((HSURF)andBitmap);
    if (pANDSurf == NULL)
    {
        ERROR_OUT(( "Failed to lock work surface"));
        DC_QUIT;
    }

    //
    // Copy the bits
    //
    memcpy(pANDSurf->pvBits, pAND, pANDSurf->cjBits);

    TRACE_OUT(( "Set the tag"));
    EngSetPointerTag(ppDev->hdevEng, pANDSurf, NULL, NULL, 0);

    EngUnlockSurface(pANDSurf);
    EngDeleteSurface((HSURF)andBitmap);

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(CMDDSetTransform, rc);
    return(rc);

} // CMDDSetTransform
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\dd\globals.h ===
//
// GLOBALS.H
// Global variable decls
//
// Copyright(c) Microsoft 1997-
//

#include <osi.h>
#include <shm.h>
#include <oa.h>
#include <ba.h>
#include <cm.h>
#include <host.h>
#include <fh.h>
#include <ssi.h>
#include <oe.h>
#include <sbc.h>


//
// Debug stuff
//
#if defined(DEBUG) || defined(INIT_TRACE)
DC_DATA_VAL   ( char,           g_szAssertionFailure[], "Assertion failure!" );
DC_DATA_ARRAY ( char,           g_szDbgBuf, CCH_DEBUG_MAX );
DC_DATA_VAL   ( UINT,           g_trcConfig, ZONE_INIT );
#endif // DEBUG or INIT_TRACE



//
// Driver
//




//
// Shared Memory Manager
//
DC_DATA     ( LPSHM_SHARED_MEMORY,      g_asSharedMemory );
DC_DATA_ARRAY ( LPOA_SHARED_DATA,       g_poaData,    2 );

//
// Shared memory.
//
DC_DATA ( UINT,           g_shmSharedMemorySize );
DC_DATA ( LPVOID,         g_shmMappedMemory );      // user mode ptr




//
// Bounds Accumulator
//
DC_DATA ( UINT,           g_baFirstRect );
DC_DATA ( UINT,           g_baLastRect );
DC_DATA ( UINT,           g_baRectsUsed );

DC_DATA_ARRAY ( DD_BOUNDS,  g_baBounds,   BA_NUM_RECTS+1);


//
// A local copy of the bounding rectangles which the share core is
// currently processing.  These are used when accumulating orders which
// rely on the contents of the destination.
//
DC_DATA         ( UINT,    g_baNumSpoilingRects);
DC_DATA_ARRAY   ( RECT,    g_baSpoilingRects,    BA_NUM_RECTS);


//
// Is the spoiling of existing orders when adding screen data allowed at
// the moment, or temporarily disabled ?  To do the spoiling, both
// baSpoilByNewSDA and baSpoilByNewSDAEnabled must be TRUE.
//
DC_DATA_VAL ( BOOL,   g_baSpoilByNewSDAEnabled,     TRUE);




//
// Cursor Manager
//

DC_DATA (HBITMAP,   g_cmWorkBitmap );
DC_DATA (DWORD,     g_cmNextCursorStamp );
DC_DATA (BOOL,      g_cmCursorHidden );



//
// Hosted Entity Tracker
//
DC_DATA ( BASEDLIST,           g_hetWindowList );  // Anchor for hosted wnd list
DC_DATA ( BASEDLIST,           g_hetFreeWndList ); // Anchor for free list
DC_DATA ( BASEDLIST,           g_hetMemoryList );  // Anchor for memory block list

//
// Flag which indicates if the desktop is shared.
//
DC_DATA ( BOOL,             g_hetDDDesktopIsShared );



//
// Order Accumulator
//

// Throughput
DC_DATA ( UINT,         g_oaFlow );

//
// Flag to indicate whether we are allowed to purge the order heap.
//
DC_DATA_VAL ( BOOL,     g_oaPurgeAllowed,            TRUE);


//
// Order Encoder 
//

//
// Are we supporting all ROPS in a conference, or do we disallow ROPS which
// involve the destination bits.
//
DC_DATA ( BOOL,             g_oeSendOrders );

//
// Are text orders allowed?
//
DC_DATA ( BOOL,           g_oeTextEnabled );

//
// Array of supported orders
//
DC_DATA_ARRAY ( BYTE,       g_oeOrderSupported,   ORD_NUM_INTERNAL_ORDERS );



//
// Temporary buffer to store the memblt and mem3blt orders which are
// initially created by the display driver interception code.  This buffer
// is used because the subsequent logic for these orders breaks down the
// original order into smaller tiled orders and then throws the original
// away.  So to keep a coherent order heap, we do not allocate the
// temporary order off the heap.
//
DC_DATA_ARRAY(BYTE,
                   g_oeTmpOrderBuffer,
                   sizeof(INT_ORDER) +
                       max( max( max(sizeof(MEMBLT_ORDER),
                                              sizeof(MEMBLT_R2_ORDER) ),
                                       sizeof(MEM3BLT_ORDER) ),
                               sizeof(MEM3BLT_R2_ORDER) ));

//
// Storage space to create a temporary solid brush for BitBlt orders.
//
DC_DATA ( OE_BRUSH_DATA,    g_oeBrushData );

//
// Local font matching data - this is passed from the share core
//
DC_DATA ( LPLOCALFONT,  g_poeLocalFonts );

//
// Local font index.  This is an array of bookmarks that indicate the first
// entry in the local font table that starts with a particular character.
// For example, g_oeLocalFontIndex[65] gives the first index in g_oeLocalFonts
// that starts with the character 'A'.
//
DC_DATA_ARRAY( WORD,  g_oeLocalFontIndex, FH_LOCAL_INDEX_SIZE );

//
// Number of local fonts
//
DC_DATA ( UINT,             g_oeNumFonts );

//
// Capabilities - from PROTCAPS_ORDERS
//
DC_DATA ( UINT,             g_oeFontCaps );

//
// Do we support baseline text orders for this conference?
//
DC_DATA ( BOOL,           g_oeBaselineTextEnabled );

//
// Local font matching data - this is passed from the share core
//
DC_DATA_ARRAY ( WCHAR,      g_oeTempString, (ORD_MAX_STRING_LEN_WITHOUT_DELTAS+1));

DC_DATA ( BOOL,             g_oeViewers );         // Accumulate graphics



//
// Send Bitmap Cache
//


//
// BPP for bitmap data sent over the wire
//
DC_DATA ( UINT,  g_sbcSendingBPP );

//
// Cache info
//
DC_DATA_ARRAY( SBC_SHM_CACHE_INFO,  g_asbcCacheInfo,  NUM_BMP_CACHES );


//
// Array of structures holding the info required to get the bitmap bits
// from the source surface into the shunt buffer.
//
DC_DATA_ARRAY (SBC_TILE_WORK_INFO, g_asbcWorkInfo, SBC_NUM_TILE_SIZES );

//
// The Id to use for the next tile passed to the share core in a shunt
// buffer.
//
DC_DATA ( WORD,   g_sbcNextTileId );

//
// This is the number of ticks per second which the performance timer
// generates.  We store this rather than making lots of calls to
// EngQueryPerformanceFrequency.
//
DC_DATA ( LONGLONG, g_sbcPerfFrequency );

//
// Array of structures containing info about bitmap cache thrashers
//
DC_DATA_ARRAY (SBC_THRASHERS,   g_sbcThrashers, SBC_NUM_THRASHERS );


//
// Save Screenbits Interceptor
//

//
// Remote status for SSB
//
DC_DATA ( REMOTE_SSB_STATE,  g_ssiRemoteSSBState );

//
// Local status for SSB
//
DC_DATA ( LOCAL_SSB_STATE,  g_ssiLocalSSBState );

//
// Current max for save screen bitmap size
//
DC_DATA ( DWORD,            g_ssiSaveBitmapSize );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\dd\oa.c ===
#include "precomp.h"


//
// OA.C
// Order Accumulation, both cpi32 and display driver sides
//
// Copyright(c) Microsoft 1997-
//



//
// OA_DDProcessRequest - see oa.h
//
BOOL OA_DDProcessRequest
(
    UINT                fnEscape,
    LPOSI_ESCAPE_HEADER pRequest,
    DWORD               cbRequest
)
{
    BOOL                rc;

    DebugEntry(OA_DDProcessRequest);

    //
    // Get the request number.
    //
    switch (fnEscape)
    {
        case OA_ESC_FLOW_CONTROL:
        {
            if (cbRequest != sizeof(OA_FLOW_CONTROL))
            {
                ERROR_OUT(("OA_DDProcessRequest:  Invalid size %d for OA_ESC_FLOW_CONTROL",
                    cbRequest));
                rc = FALSE;
                DC_QUIT;
            }

            //
            // Save new order accum throughput value
            //
            g_oaFlow = ((LPOA_FLOW_CONTROL)pRequest)->oaFlow;
            rc = TRUE;
        }
        break;

        default:
        {
            ERROR_OUT(("Unrecognized OA escape"));
            rc = FALSE;
        }
        break;
    }

DC_EXIT_POINT:
    DebugExitBOOL(OA_DDProcessRequest, rc);
    return(rc);
}



//
//
// OA_DDAddOrder(..)
//
// Adds an order to the queue for transmission.
//
// If the new order is completetly covered by the current SDA then
// it is spoilt.
//
// If the order is opaque and overlaps earlier orders it may clip
// or spoil them.
//
// Called by the GDI interception code.
//
//
void  OA_DDAddOrder(LPINT_ORDER pNewOrder, void FAR * pExtraInfo)
{
    RECT      SDARects[BA_NUM_RECTS*2];
    UINT      cBounds;
    UINT      spoilingBounds;
    UINT      totalBounds;
    UINT      i;
    RECT      SrcRect;
    RECT      tmpRect;
    BOOL      gotBounds = FALSE;
    int       dx;
    int       dy;
    RECT      IntersectedSrcRect;
    RECT      InvalidDstRect;
    LPINT_ORDER  pTmpOrder;
    LPEXTTEXTOUT_ORDER  pExtTextOut;
    LPOA_SHARED_DATA    lpoaShared;
    LPOA_FAST_DATA      lpoaFast;

    DebugEntry(OA_DDAddOrder);

    lpoaShared  = OA_SHM_START_WRITING;
    lpoaFast    = OA_FST_START_WRITING;

    //
    // Accumulate order accumulation rate.  We are interested in how
    // quickly orders are being added to the buffer, so that we can tell
    // DCS scheduling whether frequent sends are advisable
    //
    SHM_CheckPointer(&lpoaFast->ordersAccumulated);
    lpoaFast->ordersAccumulated++;

    //
    // If the order is a private one, then we just add it to the Order
    // List and return immediately.
    //
    // Private Orders are used to send bitmap cache information (bitmap
    // bits and color tables).
    //
    // Private Orders never spoil any others and must never be spoilt.
    //
    if (pNewOrder->OrderHeader.Common.fOrderFlags & OF_PRIVATE)
    {
        TRACE_OUT(("Add private order (%lx)", pNewOrder));
        OADDAppendToOrderList(lpoaShared, pNewOrder);
        DC_QUIT;
    }

    //
    // If this order is spoilable and its is completely enclosed by the
    // current screen data area, we can spoil it.  Unless...
    //
    // PM - Performance
    //
    // We have observed in usability testing that clipping orders always
    // degrades the end-user's perceived performance.  This is because the
    // orders flow much faster than the screendata and tend to relate to
    // text, which is what the user really wants to see.  For example, text
    // overwriting a bitmap will be delayed because we want to send the
    // bitmap as screendata.
    //
    // Also, word documents tend to contain sections of screendata due to
    // mismatched fonts, intelliquotes, spelling annotation, current line
    // memblit.  Nothing we can do about this, but if we page down two or
    // three times, or down and up again we get an accumulation of the
    // screendata on all the pages spoiling the orders and the end result
    // is that we have to wait longer than we would if we had not spoiled
    // the orders.
    //
    // So, what we can do instead is leave the text orders in and overwrite
    // them with screendata when it gets through.  However, to make this
    // really effective what we also do is convert any transparent text
    // (as WEB browsers tend to use) into opaque text on a default
    // background.
    //
    //
    if ((pNewOrder->OrderHeader.Common.fOrderFlags & OF_SPOILABLE) != 0)
    {
        //
        // Get the driver's current bounds.
        //
        BA_CopyBounds(SDARects, &cBounds, FALSE);
        gotBounds = TRUE;

        for (i = 0; i < cBounds ; i++)
        {
            if ( OADDCompleteOverlapRect(&pNewOrder->OrderHeader.Common.rcsDst,
                                      &(SDARects[i])) )
            {
                //
                // The destination of the order is completely covered by
                // the SDA.  Check for a text order.
                //
                pExtTextOut = (LPEXTTEXTOUT_ORDER)pNewOrder->abOrderData;
                if (pExtTextOut->type == ORD_EXTTEXTOUT_TYPE)
                {
                    //
                    // The order is going to be completely overwritten so
                    // we can play around with it all we like.
                    // Just make it opaque so the user can read it while
                    // waiting for the screendata to follow on.
                    //
                    pExtTextOut->fuOptions |= ETO_OPAQUE;

                    //
                    // pExtTextOut->rectangle is a TSHR_RECT32
                    //
                    pExtTextOut->rectangle.left = pNewOrder->OrderHeader.Common.rcsDst.left;
                    pExtTextOut->rectangle.top = pNewOrder->OrderHeader.Common.rcsDst.top;
                    pExtTextOut->rectangle.right = pNewOrder->OrderHeader.Common.rcsDst.right;
                    pExtTextOut->rectangle.bottom = pNewOrder->OrderHeader.Common.rcsDst.bottom;

                    TRACE_OUT(("Converted text order to opaque"));
                    break;
                }
                else
                {
                    TRACE_OUT(("Spoiling order by SDA"));
                    OA_DDFreeOrderMem(pNewOrder);
                    DC_QUIT;
                }
            }
        }
    }

    //
    // Pass the order onto the Bitmap Cache Controller to try to cache the
    // src bitmap.
    //
    if (ORDER_IS_MEMBLT(pNewOrder) || ORDER_IS_MEM3BLT(pNewOrder))
    {
        if (!SBC_DDCacheMemScreenBlt(pNewOrder, pExtraInfo))
        {
            //
            // The memory to screen blt cannot be handled as an order (the
            // source bitmap could not cached).  Add the destination of the
            // blt into the SDA and discard the order.
            //
            TRACE_OUT(("Failed to cache mem->screen blt"));
            TRACE_OUT(("Add rect to SDA (%d,%d)(%d,%d)",
                           pNewOrder->OrderHeader.Common.rcsDst.left,
                           pNewOrder->OrderHeader.Common.rcsDst.top,
                           pNewOrder->OrderHeader.Common.rcsDst.right,
                           pNewOrder->OrderHeader.Common.rcsDst.bottom ));

            RECT_FROM_TSHR_RECT16(&tmpRect,
                                    pNewOrder->OrderHeader.Common.rcsDst);
            OA_DDFreeOrderMem(pNewOrder);
            BA_AddScreenData(&tmpRect);
            DC_QUIT;
        }
        else
        {
            TRACE_OUT(("Cached MEMBLT targetted at (%d,%d)(%d,%d)",
                           pNewOrder->OrderHeader.Common.rcsDst.left,
                           pNewOrder->OrderHeader.Common.rcsDst.top,
                           pNewOrder->OrderHeader.Common.rcsDst.right,
                           pNewOrder->OrderHeader.Common.rcsDst.bottom ));
        }
    }

    if (ORDER_IS_SCRBLT(pNewOrder))
    {
        //
        //
        // Handle Screen to Screen (SS) bitblts.
        //
        // The basic plan
        // --------------
        //
        // If the source of a screen to screen blt intersects with the
        // current SDA then we have to do some additional work because all
        // orders are always executed before the SDA is copied.  This means
        // that the data within the SDA will not be available at the time
        // we want to do the SS blt.
        //
        // In this situation we adjust the SS blt to remove all overlap
        // from the src rectangle.  The destination rectangle is adjusted
        // accordingly.  The area removed from the destination rectangle is
        // added into the SDA.
        //
        //
        TRACE_OUT(("Handle SS blt(%lx)", pNewOrder));

        //
        // Make the order non-spoilable because we don't want the adding
        // of screen data to delete the order.
        //
        pNewOrder->OrderHeader.Common.fOrderFlags &= ~OF_SPOILABLE;

        //
        // Calculate the src rect.
        //
        SrcRect.left = ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nXSrc;
        SrcRect.right = SrcRect.left +
                        ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nWidth - 1;
        SrcRect.top = ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nYSrc;
        SrcRect.bottom = SrcRect.top +
                       ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nHeight - 1;

        //
        //
        // ORIGINAL SCRBLT SCHEME
        // ----------------------
        //
        // If the source rectangle intersects the current Screen Data Area
        // (SDA) then the src rectangle is modified so that no there is no
        // intersection with the SDA, and the dst rectangle adjusted
        // accordingly (this is the theory - in practice the operation
        // remains the same and we just adjust the dst clip rectangle).
        // The destination area that is removed is added into the SDA.
        //
        // The code works, but can result in more screen data being sent
        // than is required.
        //
        // e.g.
        //
        // Operation:
        //
        //      SSSSSS      DDDDDD
        //      SSSSSS  ->  DDDDDD
        //      SSSSSS      DDDDDD
        //      SxSSSS      DDDDDD
        //
        //      S - src rect
        //      D - dst rect
        //      x - SDA overlap
        //
        // The bottom edge of the blt is trimmed off, and the corresponding
        // destination area added into the SDA.
        //
        //      SSSSSS      DDDDDD
        //      SSSSSS  ->  DDDDDD
        //      SSSSSS      DDDDDD
        //                  xxxxxx
        //
        //
        //
        // NEW SCRBLT SCHEME
        // ------------------
        //
        // The new scheme does not modify the blt rectangles, and just
        // maps the SDA overlap to the destination rect and adds that
        // area back into the SDA.
        //
        // e.g. (as above)
        //
        // Operation:
        //
        //      SSSSSS      DDDDDD
        //      SSSSSS  ->  DDDDDD
        //      SSSSSS      DDDDDD
        //      SxSSSS      DDDDDD
        //
        //      S - src rect
        //      D - dst rect
        //      x - SDA overlap
        //
        // The blt operation remains the same, but the overlap area is
        // mapped to the destination rectangle and added into the SDA.
        //
        //      SSSSSS      DDDDDD
        //      SSSSSS  ->  DDDDDD
        //      SSSSSS      DDDDDD
        //      SxSSSS      DxDDDD
        //
        //
        // This scheme results in a smaller SDA area. However, this scheme
        // does blt potentially invalid data to the destination - which
        // may briefly be visible at the remote machine (because orders
        // are replayed before Screen Data). This has not (yet) proved to
        // be a problem.
        //
        // The main benefit of the new scheme is when scrolling an area
        // that includes a small SDA.
        //
        //                                         new         old
        //                                        scheme      scheme
        //
        //     AAAAAAAA                          AAAAAAAA    AAAAAAAA
        //     AAAAAAAA                          AAAxAAAA    xxxxxxxx
        //     AAAAAAAA  scroll up 3 times ->    AAAxAAAA    xxxxxxxx
        //     AAAAAAAA                          AAAxAAAA    xxxxxxxx
        //     AAAxAAAA                          AAAxAAAA    xxxxxxxx
        //
        //
        //
        if (!gotBounds)
        {
            //
            // Get the driver's current bounds.
            //
            BA_CopyBounds(SDARects, &cBounds, FALSE);
        }

        //
        // Now get any bounds which the share core is currently processing.
        // We have to include these bounds when we are doing the above
        // processing to avoid a situation where the core grabs the screen
        // data from the source of a ScrBlt after the source has been
        // updated by another order.
        //
        // e.g.  If there is no driver SDA, but the core is processing the
        // area marked 'c'...
        //
        // If we ignore the core SDA, we queue a ScrBlt order which does
        // the following.
        //
        //      SSSSSS      DDDDDD
        //      SccccS  ->  DDDDDD
        //      SccccS      DDDDDD
        //      SSSSSS      DDDDDD
        //
        // However, if another order (marked 'N') is accumulated before
        // the core grabs the SDA, we end up with the shadow doing the
        // following
        //
        //      SSSSSS      DDDDDD
        //      ScNNcS  ->  DDNNDD
        //      ScNNcS      DDNNDD
        //      SSSSSS      DDDDDD
        //
        // i.e. the new order gets copied to the destination of the ScrBlt.
        // So, the ScrBlt order must be processed as
        //
        //      SSSSSS      DDDDDD
        //      SccccS  ->  DxxxxD
        //      SccccS      DxxxxD
        //      SSSSSS      DDDDDD
        //
        //
        BA_QuerySpoilingBounds(&SDARects[cBounds], &spoilingBounds);
        totalBounds = cBounds + spoilingBounds;

        //
        //
        // This is the new SCRBLT handler.
        //
        //
        for (i = 0; i < totalBounds ; i++)
        {
            if ( (SrcRect.left >= SDARects[i].left) &&
                 (SrcRect.right <= SDARects[i].right) &&
                 (SrcRect.top >= SDARects[i].top) &&
                 (SrcRect.bottom <= SDARects[i].bottom) )
            {
                //
                // The src of the SS blt is completely within the SDA.  We
                // must add in the whole destination rectangle into the SDA
                // and spoil the SS blt.
                //
                TRACE_OUT(("SS blt src within SDA - spoil it"));

                RECT_FROM_TSHR_RECT16(&tmpRect,
                                        pNewOrder->OrderHeader.Common.rcsDst);
                OA_DDFreeOrderMem(pNewOrder);
                BA_AddScreenData(&tmpRect);
                DC_QUIT;
            }

            //
            // Intersect the src rect with the SDA rect.
            //
            IntersectedSrcRect.left = max( SrcRect.left,
                                              SDARects[i].left );
            IntersectedSrcRect.right = min( SrcRect.right,
                                               SDARects[i].right );
            IntersectedSrcRect.top = max( SrcRect.top,
                                             SDARects[i].top );
            IntersectedSrcRect.bottom = min( SrcRect.bottom,
                                                SDARects[i].bottom );


            dx = ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nLeftRect -
                   ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nXSrc;
            dy = ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nTopRect -
                   ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nYSrc;

            InvalidDstRect.left   = IntersectedSrcRect.left + dx;
            InvalidDstRect.right  = IntersectedSrcRect.right + dx;
            InvalidDstRect.top    = IntersectedSrcRect.top + dy;
            InvalidDstRect.bottom = IntersectedSrcRect.bottom + dy;

            //
            // Intersect the invalid destination rectangle with the
            // destination clip rectangle.
            //
            InvalidDstRect.left = max(
                                InvalidDstRect.left,
                                pNewOrder->OrderHeader.Common.rcsDst.left );
            InvalidDstRect.right = min(
                                InvalidDstRect.right,
                                pNewOrder->OrderHeader.Common.rcsDst.right );
            InvalidDstRect.top = max(
                                InvalidDstRect.top,
                                pNewOrder->OrderHeader.Common.rcsDst.top );
            InvalidDstRect.bottom = min(
                                InvalidDstRect.bottom,
                                pNewOrder->OrderHeader.Common.rcsDst.bottom );

            if ( (InvalidDstRect.left <= InvalidDstRect.right) &&
                 (InvalidDstRect.top <= InvalidDstRect.bottom) )
            {
                //
                // Add the invalid area into the SDA.
                //
                BA_AddScreenData(&InvalidDstRect);
            }

        } // for (i = 0; i < totalBounds ; i++)

        //
        // Make the order spoilable again (this assumes that all SS blts
        // are spoilable.
        //
        pNewOrder->OrderHeader.Common.fOrderFlags |= OF_SPOILABLE;

    } // if (ORDER_IS_SCRBLT(pNewOrder))

    else if ((pNewOrder->OrderHeader.Common.fOrderFlags & OF_DESTROP) != 0)
    {
        //
        // This is the case where the output of the order depends on the
        // existing contents of the target area (e.g.  an invert).
        //
        // What we have to do here is to add any parts of the destination
        // of this order which intersect the SDA which the share core is
        // processing to the driver SDA.  The reason for this is the same
        // as the SCRBLT case - the share core may grab the data from the
        // screen after we have applied this order (e.g.  after we have
        // inverted an area of the screen), then send the order as well
        // (re-inverting the area of the screen).
        //
        // Note that we only have to worry about the SDA which the share
        // core is processing - we can ignore the driver's SDA.
        //
        TRACE_OUT(("Handle dest ROP (%#.8lx)", pNewOrder));

        BA_QuerySpoilingBounds(SDARects, &spoilingBounds);
        for (i = 0; i < spoilingBounds ; i++)
        {
            //
            // Intersect the dest rect with the share core SDA rect.
            //
            InvalidDstRect.left = max(
                                SDARects[i].left,
                                pNewOrder->OrderHeader.Common.rcsDst.left );
            InvalidDstRect.right = min(
                                SDARects[i].right,
                                pNewOrder->OrderHeader.Common.rcsDst.right );
            InvalidDstRect.top = max(
                                SDARects[i].top,
                                pNewOrder->OrderHeader.Common.rcsDst.top );
            InvalidDstRect.bottom = min(
                                SDARects[i].bottom,
                                pNewOrder->OrderHeader.Common.rcsDst.bottom );

            if ( (InvalidDstRect.left <= InvalidDstRect.right) &&
                 (InvalidDstRect.top <= InvalidDstRect.bottom) )
            {
                //
                // Add the invalid area into the SDA.
                //
                TRACE_OUT(("Adding to SDA (%d,%d) (%d,%d)",
                             InvalidDstRect.left,
                             InvalidDstRect.top,
                             InvalidDstRect.right,
                             InvalidDstRect.bottom));
                BA_AddScreenData(&InvalidDstRect);
            }
        }
    }

    //
    // Add the new order to the end of the Order List.
    //
    OADDAppendToOrderList(lpoaShared, pNewOrder);
    TRACE_OUT(("Append order(%lx) to list", pNewOrder));

    //
    // Now see if this order spoils any existing orders
    //
    if ((pNewOrder->OrderHeader.Common.fOrderFlags & OF_SPOILER) != 0)
    {
        //
        // Its a spoiler, so try to spoil with it.
        //
        // We have to pass in the bounding rectangle of the order, and the
        // first order to try to spoil to OADDSpoilFromOrder.  The first
        // order to try to spoil is the one before the new order.
        //
        RECT_FROM_TSHR_RECT16(&tmpRect,
                                pNewOrder->OrderHeader.Common.rcsDst);

        pTmpOrder = COM_BasedListPrev(&lpoaShared->orderListHead, pNewOrder,
            FIELD_OFFSET(INT_ORDER, OrderHeader.list));

        OADDSpoilFromOrder(lpoaShared, pTmpOrder, &tmpRect);
    }

    //
    // This is where the Win95 product would call DCS_TriggerEarlyTimer.
    //

DC_EXIT_POINT:
    OA_FST_STOP_WRITING;
    OA_SHM_STOP_WRITING;
    DebugExitVOID(OA_DDAddOrder);
}

//
//
// FUNCTION: OA_DDAllocOrderMem
//
// DESCRIPTION:
//
// Allocates memory for an internal order structure from our own private
// Order Heap.
//
// Allocates any Additional Order Memory from global memory.  A pointer to
// the Additional Order Memory is stored within the allocated order's
// header (pOrder->OrderHeader.pAdditionalOrderData).
//
//
// PARAMETERS:
//
// cbOrderDataLength - length in bytes of the order data to be allocated
// from the Order Heap.
//
// cbAdditionalOrderDataLength - length in bytes of additional order data
// to be allocated from Global Memory.  If this parameter is zero no
// additional order memory is allocated.
//
//
// RETURNS:
//
// A pointer to the allocated order memory.  NULL if the memory allocation
// failed.
//
//
//
LPINT_ORDER  OA_DDAllocOrderMem(UINT cbOrderDataLength, UINT cbAdditionalOrderDataLength)
{
    LPINT_ORDER  pOrder = NULL;
    LPINT_ORDER  pFirstOrder;
    LPINT_ORDER  pTailOrder;
    RECT      tferRect;
    int     targetSize;
    UINT    moveOffset;
    UINT    moveBytes;
    LPINT_ORDER  pColorTableOrder = NULL;
    LPBYTE     pNextOrderPos;
    LPOA_SHARED_DATA    lpoaShared;

    DebugEntry(OA_DDAllocOrderMem);

    lpoaShared = OA_SHM_START_WRITING;

    //
    // PM Performance
    //
    // Although turning order accumulation off does clear the pipe, ready
    // for us to get the screendata over the wire as soon as we can, it
    // actually hinders end-user responsiveness because they see a longer
    // interval when nothing is happening, rather than getting feedback
    // that we are busy and the whole thing taking longer!
    //
    // So, what we do when we fill up the order buffer is we discard half
    // the orders in the buffer, adding them to the screendata.  In this
    // way we will always keep between 50 and 100% of the orders for the
    // final updates to the window, which hopefully will be what the user
    // really wants to see.
    //
    // If the orders keep coming then we will keep on accumulating some,
    // sending them, discarding others until things quiet down, at which
    // point we will flush out our order buffer.
    //
    // When we come to flush the order buffer we also spoil the early ones
    // against screendata, so that we only have the final set of orders to
    // replay.  We control the size of this final non-spoiled set depending
    // on whether we are running over a high or low speed connection.
    // Also, if we did not encounter any back pressure during the session
    // then we do not purge any orders at all, preferring to send
    // everything we possibly can as orders.
    //
    // Note that this approach assumes that we do not spoil all orders
    // against screendata on the fly because that leads to us generally
    // sending out-of-data orders followed by up-to-date screendata, which
    // is exactly what we do not want to see.
    //
    //

    //
    // First check that we have not already exceeded our high water mark
    // recommended by flow control.  If we have then purge half the queue
    // so we have space to accumulate the later, more valuable, orders
    //
    // Note that this does not guarantee that we will have less orders
    // accumulated than the limit set by flow control.  However, if enough
    // orders are generated, we will come through this branch on each order
    // and finally reduce to below the imposed limit.
    //
    SHM_CheckPointer(&lpoaShared->totalOrderBytes);
    if (g_oaPurgeAllowed && (lpoaShared->totalOrderBytes >
        (DWORD)(g_oaFlow == OAFLOW_FAST ? OA_FAST_HEAP : OA_SLOW_HEAP)))
    {
        RECT        aRects[BA_NUM_RECTS];
        UINT        numRects;
        UINT        i;

        WARNING_OUT(("Purging orders; total 0x%08x is greater than heap 0x%08x",
            lpoaShared->totalOrderBytes,
            (g_oaFlow == OAFLOW_FAST ? OA_FAST_HEAP : OA_SLOW_HEAP)));

        //
        //
        // If we need to make room for the new order then purge half the
        // current queue.  We do this so we end up with the most recent
        // orders on the queue, rather than the oldest.
        //
        SHM_CheckPointer(&lpoaShared->totalOrderBytes);
        targetSize = lpoaShared->totalOrderBytes / 2;
        TRACE_OUT(("Target size %ld", targetSize));

        //
        // Iterate through the list until we have found the first order
        // beyond the limit to be destroyed.  Once we have got this order,
        // we can shuffle the list over the useless orders.
        //
        SHM_CheckPointer(&lpoaShared->orderListHead);
        pOrder = COM_BasedListFirst(&lpoaShared->orderListHead,
            FIELD_OFFSET(INT_ORDER, OrderHeader.list));

        pTailOrder = (LPINT_ORDER)COM_BasedPrevListField(&lpoaShared->orderListHead);

        //
        // If we hit this condition, we have to have at least one order
        // pending, so these both must be non NULL.
        //
        SHM_CheckPointer(pOrder);
        SHM_CheckPointer(pTailOrder);

        TRACE_OUT(("Order 0x%08lx, tail 0x%08lx", pOrder, pTailOrder));

        //
        // Disable spoiling of existing orders by screen data while we do
        // the purge otherwise we may try to spoil an order which we are
        // purging !
        //
        g_baSpoilByNewSDAEnabled = FALSE;

        while ((pOrder != NULL) && (targetSize > 0))
        {
            //
            // Can't check at end; COM_BasedListNext may return NULL and
            // SHM_CheckPointer doesn't like that.
            //
            SHM_CheckPointer(pOrder);

            //
            // Check to see if this is an internal color table order.  If
            // it is, the OF_INTERNAL flag will be set.
            //
            // MemBlt orders rely on being preceeded by a color table order
            // to set up the colors correctly.  If we purge all the color
            // table orders, the following Mem(3)Blts will get the wrong
            // colors.  So, we have to keep track of the last color table
            // order to be purged and then add it back into the order heap
            // later.
            //
            if ((pOrder->OrderHeader.Common.fOrderFlags & OF_INTERNAL) != 0)
            {
                TRACE_OUT(("Found color table order at %#.8lx", pOrder));
                pColorTableOrder = pOrder;
            }
            else
            {
                //
                // Add the order to the Screen Data Area
                //
                TRACE_OUT(("Purging orders. Add rect to SDA (%d,%d)(%d,%d)",
                             pOrder->OrderHeader.Common.rcsDst.left,
                             pOrder->OrderHeader.Common.rcsDst.top,
                             pOrder->OrderHeader.Common.rcsDst.right,
                             pOrder->OrderHeader.Common.rcsDst.bottom));

                RECT_FROM_TSHR_RECT16(&tferRect,
                                        pOrder->OrderHeader.Common.rcsDst);
                BA_AddScreenData(&tferRect);
            }

            //
            // Keep track of how much data still needs removing.
            //
            targetSize                 -= INT_ORDER_SIZE(pOrder);
            lpoaShared->totalHeapOrderBytes -= INT_ORDER_SIZE(pOrder);
            lpoaShared->totalOrderBytes     -= MAX_ORDER_SIZE(pOrder);

            //
            // If the order is a Mem(3)Blt, we have to tell SBC that we are
            // getting rid of it.
            //
            if (ORDER_IS_MEMBLT(pOrder) || ORDER_IS_MEM3BLT(pOrder))
            {
                SBC_DDOrderSpoiltNotification(pOrder);
            }

            //
            // Get the next order to be removed.
            //
            pOrder = COM_BasedListNext(&lpoaShared->orderListHead,
                pOrder, FIELD_OFFSET(INT_ORDER, OrderHeader.list));
        }

        TRACE_OUT(("Stopped at order %#.8lx", pOrder));

        //
        // Orders have been transferred to SDA, so now we have to
        //   - move the last purged color table order (if there is one) to
        //     the start of the order heap
        //   - shuffle up the heap
        //   - reset the pointers.
        //
        // pOrder points to the first non-purged order.
        //
        if (pOrder != NULL)
        {
            SHM_CheckPointer(&lpoaShared->orderHeap);
            SHM_CheckPointer(&lpoaShared->orderListHead);

            pNextOrderPos = lpoaShared->orderHeap;

            //
            // If we purged (at least) one color table order, move the last
            // color table order to the start of the order heap.
            //
            if (pColorTableOrder != NULL)
            {
                TRACE_OUT(("Moving color table from %#.8lx to start",
                             pColorTableOrder));

                RtlMoveMemory(pNextOrderPos, pColorTableOrder,
                              INT_ORDER_SIZE(pColorTableOrder));

                pColorTableOrder        = (LPINT_ORDER)pNextOrderPos;
                lpoaShared->totalHeapOrderBytes
                                       += INT_ORDER_SIZE(pColorTableOrder);
                lpoaShared->totalOrderBytes += MAX_ORDER_SIZE(pColorTableOrder);
                pNextOrderPos          += INT_ORDER_SIZE(pColorTableOrder);

                //
                // Chain the order into the start of the order list.  Just
                // do the pointers to and from the list head for now, we
                // will do the rest later.
                //
                lpoaShared->orderListHead.next =
                   PTRBASE_TO_OFFSET(pColorTableOrder, &lpoaShared->orderListHead);

                pColorTableOrder->OrderHeader.list.prev =
                   PTRBASE_TO_OFFSET(&lpoaShared->orderListHead, pColorTableOrder);
            }

            //
            // Move the heap up to the top of the buffer.  The following
            // diagram illustrates how the order heap is split up at the
            // moment.
            //
            //              OA_SHM_NEXTORDER
            // |<>|
            //
            //         moveOffset          moveBytes
            //     |<>|<>|
            //
            // ͻ
            //                                                       
            //        purged           remaining          unused     
            //        orders           orders                        
            //                                                      
            // ͼ
            // ^  ^                 ^
            //                    
            //                    
            //                     pOrder
            //   
            //    pNextOrderPos
            //  
            //   color table order
            // 
            //  lpoaShared->orderHeap (pColorTableOrder)
            //
            // If there is no color table order, pNextOrderPos is equal to
            // lpoaShared->orderHeap.
            //
            // moveOffset is the number of bytes to move the remaining
            // orders by.
            //
            // moveBytes is the number of bytes to be moved.
            //
            //
            moveOffset = (UINT)((UINT_PTR)pOrder - (UINT_PTR)pNextOrderPos);
            moveBytes  = (UINT)(lpoaShared->nextOrder
                       - moveOffset
                       - (pNextOrderPos - lpoaShared->orderHeap));

            TRACE_OUT(("Moving %d bytes", moveBytes));

            RtlMoveMemory(pNextOrderPos, pOrder, moveBytes);

            //
            // Update the head and tail pointers to reflect their new
            // positions.
            //
            pFirstOrder = (LPINT_ORDER)pNextOrderPos;
            pTailOrder  = (LPINT_ORDER)((LPBYTE)pTailOrder - moveOffset);
            SHM_CheckPointer(pFirstOrder);
            SHM_CheckPointer(pTailOrder);

            TRACE_OUT(("New first unpurged %#.8lx, tail %#.8lx",
                         pFirstOrder,
                         pTailOrder));

            //
            // Since the offsets are relative to the order pointer, we only
            // need to modify the start and end offsets.
            //
            // Unfortunately, the possibility of a color table order at the
            // start of the heap complicates the chaining of pFirstOrder.
            // If there is a color table order, we chain pFirstOrder to the
            // color table order, otherwise we chain it to the start of the
            // order list.
            //
            lpoaShared->orderListHead.prev =
                         PTRBASE_TO_OFFSET(pTailOrder, &lpoaShared->orderListHead);
            pTailOrder->OrderHeader.list.next =
                         PTRBASE_TO_OFFSET(&lpoaShared->orderListHead, pTailOrder);

            if (pColorTableOrder != NULL)
            {
                pColorTableOrder->OrderHeader.list.next =
                             PTRBASE_TO_OFFSET(pFirstOrder, pColorTableOrder);
                pFirstOrder->OrderHeader.list.prev =
                             PTRBASE_TO_OFFSET(pColorTableOrder, pFirstOrder);
            }
            else
            {
                lpoaShared->orderListHead.next =
                        PTRBASE_TO_OFFSET(pFirstOrder, &lpoaShared->orderListHead);
                pFirstOrder->OrderHeader.list.prev =
                        PTRBASE_TO_OFFSET(&lpoaShared->orderListHead, pFirstOrder);
            }

            //
            // Sort out where the next order to be allocated will go
            //
            lpoaShared->nextOrder -= moveOffset;
        }
        else
        {
            //
            // No orders left - this happens if we've had lots of spoiling.
            // We have now cleared out all the valid orders so let's
            // re-initialise the heap for next time.
            //
            OA_DDResetOrderList();
        }

        //
        // Now re-enable the spoiling of orders by SDA.
        //
        g_baSpoilByNewSDAEnabled = TRUE;

        WARNING_OUT(("Purged orders, total is now 0x%08x", lpoaShared->totalOrderBytes));

        //
        // Lastly, spoil the remaining orders by the screen data.
        // If we've gotten this far, there's a lot of data being sent
        // and/or we're slow.  So nuke 'em.
        //
        BA_CopyBounds(aRects, &numRects, FALSE);

        for (i = 0; i < numRects; i++)
        {
            OA_DDSpoilOrdersByRect(aRects+i);
        }

        WARNING_OUT(("Spoiled remaining orders by SDA, total is now 0x%08x", lpoaShared->totalOrderBytes));

        TRACE_OUT(("Next 0x%08lx", lpoaShared->nextOrder));
        TRACE_OUT(("Head 0x%08lx", lpoaShared->orderListHead.next));
        TRACE_OUT(("Tail 0x%08lx", lpoaShared->orderListHead.prev));
        TRACE_OUT(("Total heap bytes 0x%08lx", lpoaShared->totalHeapOrderBytes));
        TRACE_OUT(("Total order bytes 0x%08lx", lpoaShared->totalOrderBytes));
    }

    pOrder = OADDAllocOrderMemInt(lpoaShared, cbOrderDataLength,
                                cbAdditionalOrderDataLength);
    if ( pOrder != NULL )
    {
        //
        // Update the count of total order data.
        //
        SHM_CheckPointer(&lpoaShared->totalHeapOrderBytes);
        lpoaShared->totalHeapOrderBytes       += sizeof(INT_ORDER_HEADER)
                                         +  cbOrderDataLength;

        SHM_CheckPointer(&lpoaShared->totalAdditionalOrderBytes);
        lpoaShared->totalAdditionalOrderBytes += cbAdditionalOrderDataLength;

    }
    TRACE_OUT(("Alloc order, addr %lx, size %u", pOrder,
                                                   cbOrderDataLength));

    OA_SHM_STOP_WRITING;
    DebugExitPVOID(OA_DDAllocOrderMem, pOrder);
    return(pOrder);
}

//
//
// FUNCTION: OA_DDFreeOrderMem
//
//
// DESCRIPTION:
//
// Frees order memory from our own private heap.
// Frees any Additional Order Memory associated with this order.
//
//
// PARAMETERS:
//
// pOrder - pointer to the order to be freed.
//
//
// RETURNS:
//
// Nothing.
//
//
void  OA_DDFreeOrderMem(LPINT_ORDER pOrder)
{
    LPOA_SHARED_DATA    lpoaShared;

    DebugEntry(OA_DDFreeOrderMem);

    ASSERT(pOrder);

    lpoaShared = OA_SHM_START_WRITING;

    TRACE_OUT(("Free order %lx", pOrder));

    //
    // Update the data totals.
    //
    SHM_CheckPointer(&lpoaShared->totalHeapOrderBytes);
    lpoaShared->totalHeapOrderBytes -= (sizeof(INT_ORDER_HEADER)
                              + pOrder->OrderHeader.Common.cbOrderDataLength);

    SHM_CheckPointer(&lpoaShared->totalAdditionalOrderBytes);
    lpoaShared->totalAdditionalOrderBytes -=
                              pOrder->OrderHeader.cbAdditionalOrderDataLength;

    //
    // Do the work.
    //
    OADDFreeOrderMemInt(lpoaShared, pOrder);

    OA_SHM_STOP_WRITING;
    DebugExitVOID(OA_DDFreeOrderMem);
}


//
//
// FUNCTION: OA_DDResetOrderList
//
//
// DESCRIPTION:
//
// Frees all Orders and Additional Order Data in the Order List.
// Frees up the Order Heap memory.
//
//
// PARAMETERS:
//
// None.
//
//
// RETURNS:
//
// Nothing.
//
//
void  OA_DDResetOrderList(void)
{
    LPOA_SHARED_DATA    lpoaShared;

    DebugEntry(OA_DDResetOrderList);

    lpoaShared = OA_SHM_START_WRITING;

    //
    // First free all the orders on the list.
    //
    OADDFreeAllOrders(lpoaShared);

    //
    // Ensure that the list pointers are NULL.
    //
    SHM_CheckPointer(&lpoaShared->orderListHead);
    if ((lpoaShared->orderListHead.next != 0) || (lpoaShared->orderListHead.prev != 0))
    {
        ERROR_OUT(("Non-NULL list pointers (%lx)(%lx)",
                       lpoaShared->orderListHead.next,
                       lpoaShared->orderListHead.prev));

        SHM_CheckPointer(&lpoaShared->orderListHead);
        COM_BasedListInit(&lpoaShared->orderListHead);
    }

    OA_SHM_STOP_WRITING;
    DebugExitVOID(OA_DDResetOrderList);
}



//
// OA_DDSyncUpdatesNow
//
// Called when a sync operation is required.
//
// Discards all outstanding orders.
//
void  OA_DDSyncUpdatesNow(void)
{
    DebugEntry(OA_SyncUpdatesNow);

    OADDFreeAllOrders(g_poaData[g_asSharedMemory->displayToCore.currentBuffer]);

    DebugExitVOID(OA_DDSyncUpdatesNow);
}


//
//
// OA_DDRemoveListOrder(..)
//
// Removes the specified order from the Order List by marking it as spoilt.
//
// Returns:
//   Pointer to the order following the removed order.
//
//
LPINT_ORDER  OA_DDRemoveListOrder(LPINT_ORDER pCondemnedOrder)
{
    LPINT_ORDER pSaveOrder;
    LPOA_SHARED_DATA    lpoaShared;

    DebugEntry(OA_DDRemoveListOrder);

    TRACE_OUT(("Remove list order (%lx)", pCondemnedOrder));

    lpoaShared = OA_SHM_START_WRITING;

    SHM_CheckPointer(pCondemnedOrder);

    //
    // Check for a valid order.
    //
    if (pCondemnedOrder->OrderHeader.Common.fOrderFlags & OF_SPOILT)
    {
        TRACE_OUT(("Invalid order"));
        DC_QUIT;
    }

    //
    // Get the offset value of this order.
    //
    SHM_CheckPointer(&lpoaShared->orderHeap);

    //
    // Mark the order as spoilt.
    //
    pCondemnedOrder->OrderHeader.Common.fOrderFlags |= OF_SPOILT;

    //
    // Update the count of bytes currently in the Order List.
    //
    SHM_CheckPointer(&lpoaShared->totalOrderBytes);
    lpoaShared->totalOrderBytes -= (UINT)MAX_ORDER_SIZE(pCondemnedOrder);

    //
    // SAve the order so we can remove it from the linked list after having
    // got the next element in the chain.
    //
    pSaveOrder = pCondemnedOrder;

    //
    // Return the next order in the list.
    //
    SHM_CheckPointer(&lpoaShared->orderListHead);

    pCondemnedOrder = COM_BasedListNext(&lpoaShared->orderListHead,
        pCondemnedOrder, FIELD_OFFSET(INT_ORDER, OrderHeader.list));

    if (pSaveOrder == pCondemnedOrder)
    {
        ERROR_OUT(("Order list has gone circular !"));
    }

    //
    // Delete the unwanted order from the linked list.
    //
    COM_BasedListRemove(&pSaveOrder->OrderHeader.list);

    //
    // Check that the list is still consistent with the total number of
    // order bytes.
    //
    if ( (lpoaShared->orderListHead.next != 0) &&
         (lpoaShared->orderListHead.prev != 0) &&
         (lpoaShared->totalOrderBytes    == 0) )
    {
        ERROR_OUT(("List head wrong: %ld %ld", lpoaShared->orderListHead.next,
                                                 lpoaShared->orderListHead.prev));
        COM_BasedListInit(&lpoaShared->orderListHead);
        pCondemnedOrder = NULL;
    }

DC_EXIT_POINT:
    OA_SHM_STOP_WRITING;

    DebugExitPVOID(OA_DDRemoveListOrder, pCondemnedOrder);
    return(pCondemnedOrder);
}



//
// OA_DDSpoilOrdersByRect - see oa.h
//
void  OA_DDSpoilOrdersByRect(LPRECT pRect)
{
    LPOA_SHARED_DATA lpoaShared;
    LPINT_ORDER  pOrder;

    DebugEntry(OA_DDSpoilOrdersByRect);

    lpoaShared = OA_SHM_START_WRITING;

    //
    // We want to start spoiling from the newest order i.e.  the one at the
    // end of the order list.
    //
    pOrder = COM_BasedListLast(&lpoaShared->orderListHead,
        FIELD_OFFSET(INT_ORDER, OrderHeader.list));

    if (pOrder != NULL)
    {
        OADDSpoilFromOrder(lpoaShared, pOrder, pRect);
    }

    OA_SHM_STOP_WRITING;

    DebugExitVOID(OA_DDSpoilOrdersByRect);
}





//
//
// OADDAppendToOrderList(..)
//
// Commits an allocated order to the end of the Order List.  The order must
// NOT be freed once it has been added.  The whole list must be invalidated
// to free the committed orders.
//
//
void  OADDAppendToOrderList(LPOA_SHARED_DATA lpoaShared, LPINT_ORDER pNewOrder)
{
    DebugEntry(OADDAppendToOrderList);

    //
    // Chain entry is already set up so all we do is keep track of
    // committed orders.
    //

    //
    // Store the total number of order bytes used.
    //
    SHM_CheckPointer(&lpoaShared->totalOrderBytes);
    lpoaShared->totalOrderBytes += (UINT)MAX_ORDER_SIZE(pNewOrder);

    DebugExitVOID(OADDAppendToOrderList);
}


//
//
// FUNCTION: OADDAllocOrderMemInt
//
// DESCRIPTION:
//
// Allocates memory for an internal order structure from our order heap.
//
//
// PARAMETERS:
//
// cbOrderDataLength - length in bytes of the order data to be allocated
// from the Order Heap.
//
// cbAdditionalOrderDataLength - length in bytes of additional order data
// to be allocated.  If this parameter is zero no additional order memory
// is allocated.
//
//
// RETURNS:
//
// A pointer to the allocated order memory.  NULL if the memory allocation
// failed.
//
//
//
LPINT_ORDER  OADDAllocOrderMemInt
(
    LPOA_SHARED_DATA    lpoaShared,
    UINT                cbOrderDataLength,
    UINT                cbAdditionalOrderDataLength
)
{
    LPINT_ORDER   pOrder = NULL;
    UINT       cbOrderSize;

    DebugEntry(OADDAllocOrderMemInt);

    //
    // If the additional data will take us over our Additional Data Limit
    // then fail the memory allocation.
    //
    SHM_CheckPointer(&lpoaShared->totalAdditionalOrderBytes);
    if ((lpoaShared->totalAdditionalOrderBytes + cbAdditionalOrderDataLength) >
                                                    MAX_ADDITIONAL_DATA_BYTES)
    {
        TRACE_OUT(("Hit Additional Data Limit, current %lu addint %u",
                     lpoaShared->totalAdditionalOrderBytes,
                     cbAdditionalOrderDataLength));
        DC_QUIT;
    }

    //
    // Calculate the number of bytes we need to allocate (including the
    // order header).  Round up to the nearest 4 bytes to keep the 4 byte
    // alignment for the next order.
    //
    cbOrderSize = sizeof(INT_ORDER_HEADER) + cbOrderDataLength;
    cbOrderSize = (cbOrderSize + 3) & 0xFFFFFFFC;

    //
    // Make sure we don't overrun our heap limit
    //
    SHM_CheckPointer(&lpoaShared->nextOrder);
    if (lpoaShared->nextOrder + cbOrderSize > OA_HEAP_MAX)
    {
        TRACE_OUT(("Heap limit hit"));
        DC_QUIT;
    }

    //
    // Construct a far pointer to the allocated memory, and fill in the
    // length field in the Order Header.
    //
    SHM_CheckPointer(&lpoaShared->orderHeap);
    pOrder = (LPINT_ORDER)(lpoaShared->orderHeap + lpoaShared->nextOrder);
    pOrder->OrderHeader.Common.cbOrderDataLength = (TSHR_UINT16)cbOrderDataLength;

    //
    // Update the order header to point to the next section of free heap.
    //
    SHM_CheckPointer(&lpoaShared->nextOrder);
    lpoaShared->nextOrder += cbOrderSize;

    //
    // Allocate any Additional Order Memory from Global Memory.
    //
    if (cbAdditionalOrderDataLength > 0)
    {
        //
        // Make sure we don't overrun our heap limit
        //
        SHM_CheckPointer(&lpoaShared->nextOrder);
        if (lpoaShared->nextOrder + cbAdditionalOrderDataLength > OA_HEAP_MAX)
        {
            TRACE_OUT(("Heap limit hit for additional data"));

            //
            // Clear the allocated order and quit.
            //
            SHM_CheckPointer(&lpoaShared->nextOrder);
            lpoaShared->nextOrder -= cbOrderSize;
            pOrder            = NULL;
            DC_QUIT;
        }

        //
        // Store the space for the additional data.
        //
        SHM_CheckPointer(&lpoaShared->nextOrder);
        pOrder->OrderHeader.additionalOrderData         = lpoaShared->nextOrder;
        pOrder->OrderHeader.cbAdditionalOrderDataLength =
                                                  (WORD)cbAdditionalOrderDataLength;

        //
        // Update the next order pointer to point to the next 4-byte
        // boundary.
        //
        SHM_CheckPointer(&lpoaShared->nextOrder);
        lpoaShared->nextOrder += cbAdditionalOrderDataLength + 3;
        lpoaShared->nextOrder &= 0xFFFFFFFC;
    }
    else
    {
        pOrder->OrderHeader.additionalOrderData         = 0;
        pOrder->OrderHeader.cbAdditionalOrderDataLength = 0;
    }

    //
    // Create the chain entry.
    //
    SHM_CheckPointer(&lpoaShared->orderListHead);
    COM_BasedListInsertBefore(&lpoaShared->orderListHead, &pOrder->OrderHeader.list);

DC_EXIT_POINT:
    DebugExitPVOID(OADDAllocOrderMemInit, pOrder);
    return(pOrder);
}


//
//
// FUNCTION: OADDFreeOrderMemInt
//
//
// DESCRIPTION:
//
// Frees order memory from our orders heap.  Frees any Additional Order
// Memory associated with this order.  This must NOT be used on an order
// that has been committed to the order list.
//
//
// PARAMETERS:
//
// pOrder - pointer to the order to be freed.
//
//
// RETURNS:
//
// Nothing.
//
//
void  OADDFreeOrderMemInt(LPOA_SHARED_DATA lpoaShared, LPINT_ORDER pOrder)
{
    LPINT_ORDER pOrderTail;

    DebugEntry(OADDFreeOrderMemInt);

    //
    // The order heap is real a misnomer.  We know that the memory is only
    // allocated in a purely sequential manner and deallocated as one large
    // lump of memory.
    //
    // So we do not need to implement a full memory heap allocation
    // mechanism.  Instead, we just need to keep track of where the
    // previous high water mark was before this order was freed.
    //

    //
    // Find the tail of the current chain.
    //
    pOrderTail = COM_BasedListLast(&lpoaShared->orderListHead, FIELD_OFFSET(INT_ORDER, OrderHeader.list));
    SHM_CheckPointer(pOrderTail);

    //
    // We wont necessarily be freeing the last item in the order heap.
    //
    if (pOrder == pOrderTail)
    {
        //
        // This is the last item in the heap, so we can set the pointer to
        // the next order to be used back to the start of the order being
        // freed.
        //
        SHM_CheckPointer(&lpoaShared->nextOrder);
        lpoaShared->nextOrder = (LONG)((LPBYTE)pOrder -
                                      (LPBYTE)(lpoaShared->orderHeap));
    }
    else
    {
        //
        // This is not the last item in the heap - we must not reset the
        // pointer to the next item to be used.
        //
        TRACE_OUT(("Not resetting next order (not last item in heap)"));
    }

    //
    // Delete the item from the chain.
    //
    COM_BasedListRemove(&pOrder->OrderHeader.list);

    DebugExitVOID(OADDFreeOrderMemInt);
}


//
// OADDFreeAllOrders
//
// Free the all the individual orders on the orders list, without
// discarding the list itself.
//
void  OADDFreeAllOrders(LPOA_SHARED_DATA lpoaShared)
{
    DebugEntry(OADDFreeAllOrders);

    //
    // Simply clear the list head.
    //
    COM_BasedListInit(&lpoaShared->orderListHead);
    SHM_CheckPointer(&lpoaShared->orderListHead);

    lpoaShared->totalHeapOrderBytes       = 0;
    lpoaShared->totalOrderBytes           = 0;
    lpoaShared->totalAdditionalOrderBytes = 0;
    lpoaShared->nextOrder                 = 0;

    DebugExitVOID(OADDFreeAllOrders);
}


//
//
// OADDOrderIsValid(..)
//
// Determines if a pointer points to a valid order.
//
// Returns:
//   TRUE if valid order, FALSE if invalid.
//
//
BOOL  OADDOrderIsValid(LPINT_ORDER pOrder)
{
    BOOL rc;

    DebugEntry(OADDOrderIsValid);

    //
    // Check the order is not already spoilt
    //
    rc = ((pOrder->OrderHeader.Common.fOrderFlags & OF_SPOILT) == 0);

    DebugExitBOOL(OADDOrderIsValid, rc);
    return(rc);
}


BOOL  OADDCompleteOverlapRect(LPTSHR_RECT16 prcsSrc, LPRECT   prcsOverlap)
{
    //
    // Return TRUE if the source is completely enclosed by the overlap
    // rectangle.
    //
    return( (prcsSrc->left >= prcsOverlap->left) &&
            (prcsSrc->right <= prcsOverlap->right) &&
            (prcsSrc->top >= prcsOverlap->top) &&
            (prcsSrc->bottom <= prcsOverlap->bottom) );
}


//
// Name:      OADDSpoilFromOrder
//
// Purpose:   Remove any orders from the order heap which should be spoiled
//            by a given rectangle..
//
// Returns:   Nothing
//
// Params:    IN  pTargetOrder - Pointer to the first order to try to
//                               spoil.
//            IN  pRect        - Pointer to the spoiling rectangle.
//
// Operation: pTargetOrder may be spoiled by this function, so be careful
//            on return.
//
void  OADDSpoilFromOrder
(
    LPOA_SHARED_DATA    lpoaShared,
    LPINT_ORDER         pTargetOrder,
    LPRECT              pSpoilRect
)
{
    UINT      nonProductiveScanDepth = 0;
    UINT      scanExitDepth;
    BOOL      reachedBlocker = FALSE;

    DebugEntry(OADDSpoilFromOrder);

    TRACE_OUT(("Spoiling rect is {%d, %d, %d, %d}",
                 pSpoilRect->left,
                 pSpoilRect->top,
                 pSpoilRect->right,
                 pSpoilRect->bottom));

    //
    // Work out how deep we will scan if the spoiling is non-productive.
    // We go further for bigger orders over PSTN.  (ie Irrespective of the
    // bandwidth we do not want to do much work when the app is blasting
    // out a lot of single pel orders!)
    //
    if (((pSpoilRect->right - pSpoilRect->left) < FULL_SPOIL_WIDTH) &&
        ((pSpoilRect->bottom - pSpoilRect->top) < FULL_SPOIL_HEIGHT))
    {
        TRACE_OUT(("Small order so reducing spoil depth"));
        scanExitDepth = OA_FAST_SCAN_DEPTH;
    }
    else
    {
        //
        // Use the current default scan depth (this is based on the
        // current network throughput).
        //
        scanExitDepth = (g_oaFlow == OAFLOW_FAST) ?
            OA_FAST_SCAN_DEPTH : OA_SLOW_SCAN_DEPTH;
    }

    //
    // Loop backwards from the base order until we have one of the
    // following occurs.
    //   - We spoil all the preceeding orders.
    //   - We reach a blocker which we can't spoil.
    //   - We find scanExitDepth orders which we can't spoil.
    //
    while ((pTargetOrder != NULL)
             && !reachedBlocker
             && (nonProductiveScanDepth < scanExitDepth))
    {
        //
        // We do not exit immediately when we reach a blocker because it is
        // possible that we will spoil it.  If we do spoil it, then we can
        // quite happily try spoiling the orders which preceed it.
        //
        // So, just set a flag here which we will reset if we spoil the
        // order.
        //
        reachedBlocker =
           ((pTargetOrder->OrderHeader.Common.fOrderFlags & OF_BLOCKER) != 0);

        //
        // Only try to spoil spoilable orders.
        //
        if ((pTargetOrder->OrderHeader.Common.fOrderFlags &
                                                 OF_SPOILABLE) != 0)
        {
            if (OADDCompleteOverlapRect(
                        &pTargetOrder->OrderHeader.Common.rcsDst, pSpoilRect))
            {
                //
                // The order can be spoilt.  If the order is a MemBlt or a
                // Mem3Blt, we have to notify SBC to allow it to free up
                // associated data.
                //
                if (ORDER_IS_MEMBLT(pTargetOrder) ||
                    ORDER_IS_MEM3BLT(pTargetOrder))
                {
                    SBC_DDOrderSpoiltNotification(pTargetOrder);
                }

                TRACE_OUT(("Spoil by order (%hd, %hd) (%hd, %hd)",
                             pTargetOrder->OrderHeader.Common.rcsDst.left,
                             pTargetOrder->OrderHeader.Common.rcsDst.top,
                             pTargetOrder->OrderHeader.Common.rcsDst.right,
                             pTargetOrder->OrderHeader.Common.rcsDst.bottom));

                pTargetOrder = OA_DDRemoveListOrder(pTargetOrder);

                //
                // Reset the blocker flag - we spoiled the order, so if it
                // was a blocker we can now try to spoil earlier orders.
                //
                reachedBlocker = FALSE;
            }
            else
            {
                nonProductiveScanDepth++;
            }
        }
        else
        {
            nonProductiveScanDepth++;
        }

        //
        // Get the previous order in the list.  We have to be careful
        // because we may have just removed the last item in the list, in
        // which case pTargetOrder will be NULL.
        //
        if (pTargetOrder == NULL)
        {
            pTargetOrder = COM_BasedListLast(&lpoaShared->orderListHead,
                FIELD_OFFSET(INT_ORDER, OrderHeader.list));
        }
        else
        {
            pTargetOrder = COM_BasedListPrev(&lpoaShared->orderListHead,
                pTargetOrder, FIELD_OFFSET(INT_ORDER, OrderHeader.list));
        }
    }

    DebugExitVOID(OADDSpoilFromOrder);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\dd\com.c ===
#include "precomp.h"


//
// COM.C
// Common functions, simple
//
// Copyright(c) Microsoft 1997-
//



//
// COM_BasedListInsertBefore(...)
//
// See com.h for description.
//
void COM_BasedListInsertBefore(PBASEDLIST pExisting, PBASEDLIST pNew)
{
    PBASEDLIST  pTemp;

    DebugEntry(COM_BasedListInsertBefore);

    //
    // Check for bad parameters.
    //
    ASSERT((pNew != NULL));
    ASSERT((pExisting != NULL));

    //
    // Find the item before pExisting:
    //
    pTemp = COM_BasedPrevListField(pExisting);
    ASSERT((pTemp != NULL));

    TRACE_OUT(("Inserting item at %#lx into list between %#lx and %#lx",
                 pNew, pTemp, pExisting));

    //
    // Set its <next> field to point to the new item
    //
    pTemp->next = PTRBASE_TO_OFFSET(pNew, pTemp);
    pNew->prev  = PTRBASE_TO_OFFSET(pTemp, pNew);

    //
    // Set <prev> field of pExisting to point to new item:
    //
    pExisting->prev = PTRBASE_TO_OFFSET(pNew, pExisting);
    pNew->next      = PTRBASE_TO_OFFSET(pExisting, pNew);

    DebugExitVOID(COM_BasedListInsertBefore);
} // COM_BasedListInsertBefore


//
// COM_BasedListInsertAfter(...)
//
// See com.h for description.
//
void COM_BasedListInsertAfter(PBASEDLIST pExisting, PBASEDLIST pNew)
{
    PBASEDLIST  pTemp;

    DebugEntry(COM_BasedListInsertAfter);

    //
    // Check for bad parameters.
    //
    ASSERT((pNew != NULL));
    ASSERT((pExisting != NULL));

    //
    // Find the item after pExisting:
    //
    pTemp = COM_BasedNextListField(pExisting);
    ASSERT((pTemp != NULL));

    TRACE_OUT(("Inserting item at %#lx into list between %#lx and %#lx",
                 pNew, pExisting, pTemp));

    //
    // Set its <prev> field to point to the new item
    //
    pTemp->prev = PTRBASE_TO_OFFSET(pNew, pTemp);
    pNew->next  = PTRBASE_TO_OFFSET(pTemp, pNew);

    //
    // Set <next> field of pExisting to point to new item:
    //
    pExisting->next = PTRBASE_TO_OFFSET(pNew, pExisting);
    pNew->prev      = PTRBASE_TO_OFFSET(pExisting, pNew);

    DebugExitVOID(COM_BasedListInsertAfter);
} // COM_BasedListInsertAfter


//
// COM_BasedListRemove(...)
//
// See com.h for description.
//
void COM_BasedListRemove(PBASEDLIST pListItem)
{
    PBASEDLIST pNext     = NULL;
    PBASEDLIST pPrev     = NULL;

    DebugEntry(COM_BasedListRemove);

    //
    // Check for bad parameters.
    //
    ASSERT((pListItem != NULL));

    pPrev = COM_BasedPrevListField(pListItem);
    pNext = COM_BasedNextListField(pListItem);

    ASSERT((pPrev != NULL));
    ASSERT((pNext != NULL));

    TRACE_OUT(("Removing item at %#lx from list", pListItem));

    pPrev->next = PTRBASE_TO_OFFSET(pNext, pPrev);
    pNext->prev = PTRBASE_TO_OFFSET(pPrev, pNext);

    DebugExitVOID(COM_BasedListRemove);
} // COM_BasedListRemove


//
//
// List manipulation routines
//  COM_BasedListNext
//  COM_BasedListPrev
//  COM_BasedListFirst
//  COM_BasedListLast
//
//

void FAR * COM_BasedListNext( PBASEDLIST pHead, void FAR * pEntry, UINT nOffset )
{
     PBASEDLIST p;

     ASSERT(pHead != NULL);
     ASSERT(pEntry != NULL);

     p = COM_BasedNextListField(COM_BasedStructToField(pEntry, nOffset));
     return ((p == pHead) ? NULL : COM_BasedFieldToStruct(p, nOffset));
}

void FAR * COM_BasedListPrev ( PBASEDLIST pHead, void FAR * pEntry, UINT nOffset )
{
     PBASEDLIST p;

     ASSERT(pHead != NULL);
     ASSERT(pEntry != NULL);

     p = COM_BasedPrevListField(COM_BasedStructToField(pEntry, nOffset));
     return ((p == pHead) ? NULL : COM_BasedFieldToStruct(p, nOffset));
}


void FAR * COM_BasedListFirst ( PBASEDLIST pHead, UINT nOffset )
{
    return (COM_BasedListIsEmpty(pHead) ?
            NULL :
            COM_BasedFieldToStruct(COM_BasedNextListField(pHead), nOffset));
}

void FAR * COM_BasedListLast ( PBASEDLIST pHead, UINT nOffset )
{
    return (COM_BasedListIsEmpty(pHead) ?
            NULL :
            COM_BasedFieldToStruct(COM_BasedPrevListField(pHead), nOffset));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\dd\oe.c ===
#include "precomp.h"


//
// OE.C
// Order Encoder, display driver side
//
// Copyright(c) Microsoft 1997-
//

//
// Number of entries in the font alias table.
//
#define NUM_ALIAS_FONTS 3

//
// Define entries in the Font Alias table.  This table is used to convert
// non-existant fonts (used by certain widely used applications) into
// something we can use as a local font.
//
// The font names that we alias are:
//
// "Helv"
// This is used by Excel. It is mapped directly onto "MS Sans Serif".
//
// "MS Dialog"
// This is used by Word. It is the same as an 8pt bold MS Sans Serif.
// We actually map it to a "MS Sans Serif" font that is one pel narrower
// than the metrics specify (because all matching is done on non-bold
// fonts) - hence the 1 value in the charWidthAdjustment field.
//
// "MS Dialog Light"
// Added as part of the Win95 performance enhancements...Presumably for
// MS-Word...
//
//
FONT_ALIAS_TABLE fontAliasTable[NUM_ALIAS_FONTS] =
{
    { "Helv",            "MS Sans Serif", 0 },
    { "MS Dialog",       "MS Sans Serif", 1 },
    { "MS Dialog Light", "MS Sans Serif", 0 }
};




//
// FUNCTION: OE_SendAsOrder see oe.h
//
BOOL  OE_SendAsOrder(DWORD order)
{
    BOOL  rc = FALSE;

    DebugEntry(OE_SendAsOrder);

    //
    // Only check the order if we are allowed to send orders in the first
    // place!
    //
    if (g_oeSendOrders)
    {
        TRACE_OUT(("Orders enabled"));

        //
        // We are sending some orders, so check individual flags.
        //
        rc = (BOOL)g_oeOrderSupported[HIWORD(order)];
        TRACE_OUT(("Send order %lx HIWORD %hu", order, HIWORD(order)));
    }

    DebugExitDWORD(OE_SendAsOrder, rc);
    return(rc);
}


//
// OE_RectIntersectsSDA - see oe.h
//
BOOL  OE_RectIntersectsSDA(LPRECT pRect)
{
    RECT  rectVD;
    BOOL  fIntersection = FALSE;
    UINT  i;

    DebugEntry(OE_RectIntersectsSDA);

    //
    // Copy the supplied rectangle, converting to inclusive Virtual
    // Desktop coords.
    //
    rectVD.left   = pRect->left;
    rectVD.top    = pRect->top;
    rectVD.right  = pRect->right - 1;
    rectVD.bottom = pRect->bottom - 1;

    //
    // Loop through each of the bounding rectangles checking for
    // an intersection with the supplied rectangle.
    //
    for (i = 0; i <= BA_NUM_RECTS; i++)
    {
        if ( (g_baBounds[i].InUse) &&
             (g_baBounds[i].Coord.left <= rectVD.right) &&
             (g_baBounds[i].Coord.top <= rectVD.bottom) &&
             (g_baBounds[i].Coord.right >= rectVD.left) &&
             (g_baBounds[i].Coord.bottom >= rectVD.top) )
        {
            TRACE_OUT(("Rect(%d,%d)(%d,%d) intersects SDA(%d,%d)(%d,%d)",
                          rectVD.left, rectVD.top,
                          rectVD.right, rectVD.bottom,
                          g_baBounds[i].Coord.left, g_baBounds[i].Coord.top,
                          g_baBounds[i].Coord.right, g_baBounds[i].Coord.bottom));
            fIntersection = TRUE;
            break;
        }
    }

    DebugExitDWORD(OE_RectIntersectsSDA, fIntersection);
    return(fIntersection);
}


//
// DrvBitBlt - see NT DDK documentation.
//
BOOL DrvBitBlt( SURFOBJ  *psoDst,
                      SURFOBJ  *psoSrc,
                      SURFOBJ  *psoMask,
                      CLIPOBJ  *pco,
                      XLATEOBJ *pxlo,
                      RECTL    *prclDst,
                      POINTL   *pptlSrc,
                      POINTL   *pptlMask,
                      BRUSHOBJ *pbo,
                      POINTL   *pptlBrush,
                      ROP4      rop4 )
{
    LPOSI_PDEV               ppdev = (LPOSI_PDEV)psoDst->dhpdev;
    BOOL                    rc = TRUE;
    UINT                orderType = 0;
    BYTE                 rop3;
    LPINT_ORDER              pOrder = NULL;
    LPDSTBLT_ORDER          pDstBlt;
    LPSCRBLT_ORDER          pScrBlt;
    LPMEMBLT_ORDER          pMemBlt;
    LPMEM3BLT_ORDER         pMem3Blt;
    BOOL                  fSendOrder  = FALSE;
    BOOL                  fAccumulate = FALSE;
    UINT                fOrderFlags = OF_SPOILABLE;
    RECT                  bounds;
    RECT                  intersectRect;
    POINT                 origin;
    POE_BRUSH_DATA          pCurrentBrush;
    MEMBLT_ORDER_EXTRA_INFO memBltExtraInfo;

    DebugEntry(DrvBitBlt);

    //
    // DO THIS _BEFORE_ TAKING LOCKS
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;


    OE_SHM_START_WRITING;

    //
    // Get the bounding rectangle for the operation.
    //
    RECT_FROM_RECTL(bounds, (*prclDst));

    //
    // Check if we are accumulating data for this function
    //
    fAccumulate = OEAccumulateOutput(psoDst, pco, &bounds);
    if (!fAccumulate)
    {
        DC_QUIT;
    }

    //
    // Convert the data to virtual coordinates.
    //
    OELRtoVirtual(&bounds, 1);

    //
    // Check if this 4-way ROP simplifies to a 3-way ROP.  A 4-way ROP
    // contains two 3-way ROPS, one for each setting of a mask bit - the
    // high ROP3 corresponds to a value of zero in the mask bit.
    //
    // If the two 3-way ROPs are the same, we know the 4-way ROP is a 3-way
    // ROP.
    //
    if (ROP3_LOW_FROM_ROP4(rop4) == ROP3_HIGH_FROM_ROP4(rop4))
    {
        //
        // Take the high byte as the 3-way ROP.
        //
        rop3 = ROP3_HIGH_FROM_ROP4(rop4);
        TRACE_OUT(( "4-way ROP %04x is really 3-way %02x", rop4, rop3));
    }
    else
    {
        TRACE_OUT(( "4-way ROP %08x", rop4));
        DC_QUIT;
    }

    //
    // Determine the command type.  It can be one of the following.
    //
    // DSTBLT  - A destination only BLT (no source, or pattern)
    // PATBLT  - a pattern BLT (no source)
    // SCRBLT  - a screen to screen BLT
    // MEMBLT  - a memory to screen BLT (no pattern)
    // MEM3BLT - a memory to screen 3-way BLT
    //

    //
    // Check for destination only BLTs (ie. independent of source bits).
    //
    if ((psoSrc == NULL) || ROP3_NO_SOURCE(rop3))
    {
        //
        // Check for a pattern or true destination BLT.
        //
        if (ROP3_NO_PATTERN(rop3))
        {
            TRACE_OUT(( "DSTBLT"));
            orderType = ORD_DSTBLT;
        }
        else
        {
            TRACE_OUT(( "PATBLT"));
            orderType = ORD_PATBLT;
        }
    }
    else
    {
        //
        // We have a source BLT, check whether we have screen or memory
        // BLTs.
        //
        if (psoSrc->hsurf != ppdev->hsurfScreen)
        {
            if (psoDst->hsurf != ppdev->hsurfScreen)
            {
                ERROR_OUT(( "MEM to MEM blt!"));
            }
            else
            {
                //
                // We have a memory to screen BLT, check which type.
                //
                if ((ppdev->cBitsPerPel == 4) && (rop3 != 0xcc))
                {
                    //
                    // No order -- the result depends on the palette
                    // which is dicy in VGA
                    //
                    TRACE_OUT(("No order on VGA for rop 0x%02x", rop3));
                    DC_QUIT;
                }

                if (ROP3_NO_PATTERN(rop3))
                {
                    TRACE_OUT(( "MEMBLT"));
                    orderType = ORD_MEMBLT;
                }
                else
                {
                    TRACE_OUT(( "MEM3BLT"));
                    orderType = ORD_MEM3BLT;
                }
            }
        }
        else
        {
            if (psoDst->hsurf != ppdev->hsurfScreen)
            {
                TRACE_OUT(( "SCR to MEM blt!"));
            }
            else
            {
                //
                // We only support destination only screen BLTs (ie.  no
                // patterns allowed).
                //
                if (ROP3_NO_PATTERN(rop3))
                {
                    TRACE_OUT(( "SCRBLT"));
                    orderType = ORD_SCRBLT;
                }
                else
                {
                    TRACE_OUT(( "Unsupported screen ROP %x", rop3));
                }
            }
        }
    }

    //
    // Check if we have a supported order.
    //
    if (orderType == 0)
    {
        TRACE_OUT(( "Unsupported BLT"));
        fAccumulate = FALSE;
        DC_QUIT;
    }

    //
    // Check if we are allowed to send this order (determined by the
    // negotiated capabilities of all the machines in the conference).
    //
    if (!OE_SendAsOrder(orderType))
    {
        TRACE_OUT(( "Order %d not allowed", orderType));
        DC_QUIT;
    }

    //
    // Check if we are allowed to send the ROP.
    //
    if (!OESendRop3AsOrder(rop3))
    {
        TRACE_OUT(( "Cannot send ROP %d", rop3));
        DC_QUIT;
    }

    //
    // Check for overcomplicated clipping.
    //
    if (OEClippingIsComplex(pco))
    {
        TRACE_OUT(( "Clipping is too complex"));
        DC_QUIT;
    }

    //
    // If this is a Memblt, do an initial check on whether it is cachable
    //
    if ((orderType == ORD_MEMBLT) || (orderType == ORD_MEM3BLT))
    {
        //
        // We have to fill in a structure containing extra into
        // specifically for a MEM(3)BLT order.
        //
        memBltExtraInfo.pSource   = psoSrc;
        memBltExtraInfo.pDest     = psoDst;
        memBltExtraInfo.pXlateObj = pxlo;

        if (!SBC_DDIsMemScreenBltCachable(&memBltExtraInfo))
        {
            TRACE_OUT(( "MemBlt is not cachable"));
            DC_QUIT;
        }

        //
        // It is cachable.  Before we get SBC to do the caching, we have to
        // allow it to queue a color table (if required).
        //
        if (!SBC_DDMaybeQueueColorTable(ppdev))
        {
            TRACE_OUT(( "Unable to queue color table for MemBlt"));
            DC_QUIT;
        }
    }

    //
    // We have a recognised order - do the specific checks for each order.
    //
    switch (orderType)
    {
        case ORD_DSTBLT:
            //
            // Allocate the memory for the order.
            //
            pOrder = OA_DDAllocOrderMem(sizeof(DSTBLT_ORDER),0);
            if (pOrder == NULL)
            {
                TRACE_OUT(( "Failed to alloc order"));
                DC_QUIT;
            }
            pDstBlt = (LPDSTBLT_ORDER)pOrder->abOrderData;

            //
            // Set the spoiler flag if the rop is opaque.
            //
            if (ROP3_IS_OPAQUE(rop3))
            {
                fOrderFlags |= OF_SPOILER;
            }

            //
            // Store the order type.
            //
            pDstBlt->type = LOWORD(orderType);

            //
            // Virtual desktop co-ordinates.
            //
            pDstBlt->nLeftRect  = bounds.left;
            pDstBlt->nTopRect   = bounds.top;
            pDstBlt->nWidth     = bounds.right  - bounds.left + 1;
            pDstBlt->nHeight    = bounds.bottom - bounds.top  + 1;
            pDstBlt->bRop       = rop3;

            TRACE_OUT(( "DstBlt X %d Y %d w %d h %d rop %02X",
                    pDstBlt->nLeftRect,
                    pDstBlt->nTopRect,
                    pDstBlt->nWidth,
                    pDstBlt->nHeight,
                    pDstBlt->bRop));
            break;

        case ORD_PATBLT:
            if ( !OEEncodePatBlt(ppdev,
                                 pbo,
                                 pptlBrush,
                                 rop3,
                                 &bounds,
                                 &pOrder) )
            {
                //
                // Something went wrong with the encoding, so skip to the
                // end to add this operation to the SDA.
                //
                DC_QUIT;
            }

            fOrderFlags = pOrder->OrderHeader.Common.fOrderFlags;
            break;

        case ORD_SCRBLT:
            //
            // Check for a SCRBLT as a result of a Desktop Scroll.  We must
            // ignore these as they will stuff the remote desktop.
            //
            // The check is simple - if the virtual position of the source
            // is the same as the virual position of the target for a
            // SRCCOPY type SCRBLT, we have a hit...
            //
            POINT_FROM_POINTL(origin, (*pptlSrc));

            //
            // Allocate the memory for the order.
            //
            pOrder = OA_DDAllocOrderMem(sizeof(SCRBLT_ORDER),0);
            if (pOrder == NULL)
            {
                TRACE_OUT(( "Failed to alloc order"));
                DC_QUIT;
            }
            pScrBlt = (LPSCRBLT_ORDER)pOrder->abOrderData;

            //
            // Store the order type.
            //
            pScrBlt->type = LOWORD(orderType);

            //
            // All data which is sent over the wire must be in virtual
            // desktop co-ordinates.  OELRtoVirtual has already converted
            // bounds to an inclusive rectangle in virtual co-ordinates.
            //
            pScrBlt->nLeftRect  = bounds.left;
            pScrBlt->nTopRect   = bounds.top;
            pScrBlt->nWidth     = bounds.right  - bounds.left + 1;
            pScrBlt->nHeight    = bounds.bottom - bounds.top  + 1;
            pScrBlt->bRop       = rop3;

            //
            // Source point on the screen.
            //
            OELPtoVirtual(&origin, 1);
            pScrBlt->nXSrc = origin.x;
            pScrBlt->nYSrc = origin.y;

            //
            // Screen to screen blts are Blocking orders (i.e.  they
            // prevent any previous orders from being spoilt).
            //
            // We do not mark Screen to Screen blts as SPOILER orders.  If
            // the ROP is opaque we could spoil the destination rect, but
            // only the area that does not overlap with the src rectangle.
            // The most common use of Screen to Screen blts is scrolling,
            // where the src and dst rects almost completely overlap,
            // giving only a small "spoiler" region.  The spoiler region
            // could also be complex (more that 1 rect).
            //
            // Consequently, the potential gains of trying to spoil using
            // these orders are small compared to the complexity of the
            // code required.
            //
            //
            fOrderFlags |= OF_BLOCKER;

            //
            // If the blt is screen to screen and the source overlaps the
            // destination and the clipping is not simple (> 1 rect) then
            // we do not want to send this as an order.
            //
            // (This is because we would need some complex code to
            // calculate the order in which to blt through each of the clip
            // rects.  As this case is pretty rare, it seems reasonable to
            // just send it as Screen Data).
            //
            if (!OEClippingIsSimple(pco))
            {
                //
                // Calculate the overlapping rectangle.
                //
                intersectRect.left  = max(pScrBlt->nLeftRect, pScrBlt->nXSrc);

                intersectRect.right = min(
                          pScrBlt->nLeftRect + pScrBlt->nWidth-1,
                          pScrBlt->nXSrc     + pScrBlt->nWidth-1 );

                intersectRect.top   = max(pScrBlt->nTopRect, pScrBlt->nYSrc);

                intersectRect.bottom = min(
                               pScrBlt->nTopRect + pScrBlt->nHeight-1,
                               pScrBlt->nYSrc    + pScrBlt->nHeight-1 );

                //
                // Check for a src / dst overlap.  If they overlap, the
                // intersection is a well-ordered non-trivial rectangle.
                //
                if ( (intersectRect.left <= intersectRect.right ) &&
                     (intersectRect.top  <= intersectRect.bottom) )
                {
                    //
                    // The src & dest overlap.  Free up the order memory
                    // and skip out now.  The destination rectangle will be
                    // added to the Screen Data Area.
                    //
                    OA_DDFreeOrderMem(pOrder);
                    DC_QUIT;
                }
            }

            TRACE_OUT(( "ScrBlt x %d y %d w %d h %d sx %d sy %d rop %02X",
                   pScrBlt->nLeftRect,
                   pScrBlt->nTopRect,
                   pScrBlt->nWidth,
                   pScrBlt->nHeight,
                   pScrBlt->nXSrc,
                   pScrBlt->nYSrc,
                   pScrBlt->bRop));
            break;

        case ORD_MEMBLT:
            //
            // Allocate the memory for the order - don't use OA as we are
            // only going to tile this order immediately.  Instead, we have
            // a static buffer to receive the template order data.
            //
            pOrder  = (LPINT_ORDER)g_oeTmpOrderBuffer;
            pMemBlt = (LPMEMBLT_ORDER)pOrder->abOrderData;
            pOrder->OrderHeader.Common.cbOrderDataLength
                                                    = sizeof(MEMBLT_R2_ORDER);

            //
            // Store the order type.
            //
            pMemBlt->type = LOWORD(orderType);

            //
            // Any data which is sent over the wire must be in virtual
            // desktop co-ordinates.  The bounding rectangle has already
            // been converted by OELRtoScreen.
            //
            pMemBlt->nLeftRect  = bounds.left;
            pMemBlt->nTopRect   = bounds.top;
            pMemBlt->nWidth     = bounds.right  - bounds.left + 1;
            pMemBlt->nHeight    = bounds.bottom - bounds.top  + 1;
            pMemBlt->bRop       = rop3;

            //
            // We need to store the source bitmap origin.  This is a memory
            // object, so screen/virtual conversions are unnecessary.
            //
            pMemBlt->nXSrc = pptlSrc->x;
            pMemBlt->nYSrc = pptlSrc->y;

            //
            // Mark the order as opaque if necessary.
            //
            if (ROP3_IS_OPAQUE(rop3))
            {
                fOrderFlags |= OF_SPOILER;
            }

            //
            // Store the src bitmap handle in the order.
            //
            pMemBlt->cacheId = 0;

            TRACE_OUT(( "MemBlt dx %d dy %d w %d h %d sx %d sy %d rop %04X",
                   pMemBlt->nLeftRect,
                   pMemBlt->nTopRect,
                   pMemBlt->nWidth,
                   pMemBlt->nHeight,
                   pMemBlt->nXSrc,
                   pMemBlt->nYSrc,
                   pMemBlt->bRop));
            break;

        case ORD_MEM3BLT:
            //
            // Check that the brush pattern is simple.
            //
            if (!OECheckBrushIsSimple(ppdev, pbo, &pCurrentBrush))
            {
                TRACE_OUT(( "Brush is not simple"));
                orderType = 0;
                DC_QUIT;
            }

            //
            // Allocate the memory for the order - don't use OA as we are
            // only going to tile this order immediately.  Instead, we have
            // a static buffer to receive the template order data.
            //
            pOrder   = (LPINT_ORDER)g_oeTmpOrderBuffer;
            pMem3Blt = (LPMEM3BLT_ORDER)pOrder->abOrderData;
            pOrder->OrderHeader.Common.cbOrderDataLength
                                                   = sizeof(MEM3BLT_R2_ORDER);

            //
            // Store the order type.
            //
            pMem3Blt->type = LOWORD(orderType);

            //
            // All data which is sent over the wire must be in virtual
            // desktop co-ordinates.  OELRtoVirtual has already done this
            // conversion for us.
            //
            pMem3Blt->nLeftRect  = bounds.left;
            pMem3Blt->nTopRect   = bounds.top;
            pMem3Blt->nWidth     = bounds.right  - bounds.left + 1;
            pMem3Blt->nHeight    = bounds.bottom - bounds.top  + 1;
            pMem3Blt->bRop       = rop3;

            //
            // We need to store the source bitmap origin.  This is a memory
            // object, so screen/virtual conversions are unnecessary.
            //
            pMem3Blt->nXSrc = pptlSrc->x;
            pMem3Blt->nYSrc = pptlSrc->y;

            //
            // Mark the order as opaque if necessary.
            //
            if (ROP3_IS_OPAQUE(rop3))
            {
                fOrderFlags |= OF_SPOILER;
            }

            //
            // Store the src bitmap handle in the order.
            //
            pMem3Blt->cacheId = 0;

            //
            // Set up the information required for the pattern.
            //
            pMem3Blt->BackColor = pCurrentBrush->back;
            pMem3Blt->ForeColor = pCurrentBrush->fore;

            //
            // The protocol brush origin is the point on the screen where
            // we want the brush to start being drawn from (tiling where
            // necessary).  This must be in virtual coordinates.
            //
            pMem3Blt->BrushOrgX  = pptlBrush->x;
            pMem3Blt->BrushOrgY  = pptlBrush->y;
            OELPtoVirtual((LPPOINT)&pMem3Blt->BrushOrgX, 1);

            //
            // Extra brush data from the data when we realised the brush.
            //
            pMem3Blt->BrushStyle = pCurrentBrush->style;
            pMem3Blt->BrushHatch = pCurrentBrush->style;

            RtlCopyMemory(pMem3Blt->BrushExtra,
                          pCurrentBrush->brushData,
                          sizeof(pMem3Blt->BrushExtra));

            TRACE_OUT(( "Mem3Blt brush %02X %02X dx %d dy %d w %d h %d "
                         "sx %d sy %d rop %04X",
                    pMem3Blt->BrushStyle,
                    pMem3Blt->BrushHatch,
                    pMem3Blt->nLeftRect,
                    pMem3Blt->nTopRect,
                    pMem3Blt->nWidth,
                    pMem3Blt->nHeight,
                    pMem3Blt->nXSrc,
                    pMem3Blt->nYSrc,
                    pMem3Blt->bRop));
            break;

        default:
            ERROR_OUT(( "New unsupported order %08lx", orderType));
            orderType = 0;
            break;
    }

    //
    // We have generated an order so make sure we send it.
    //
    if (orderType != 0)
    {
        fSendOrder = TRUE;
    }

DC_EXIT_POINT:
    //
    // If we did not send an order, we must accumulate the output in the
    // Screen Data Area.
    //
    if (fSendOrder)
    {
        //
        // Check if the ROP has a dependency on the destination.
        //
        if (!ROP3_NO_TARGET(rop3))
        {
            TRACE_OUT(( "ROP has a target dependency"));
            fOrderFlags |= OF_DESTROP;
        }

        //
        // Store the general order data.  The bounding rectagle
        // co-ordinates must be virtual desktop.  OELRtoVirtual has already
        // converted rect for us.
        //
        pOrder->OrderHeader.Common.fOrderFlags   = (TSHR_UINT16)fOrderFlags;

        TSHR_RECT16_FROM_RECT(&pOrder->OrderHeader.Common.rcsDst, bounds);

        //
        // Add the order to the cache.  Note that we have the new tiled
        // processing for MEMBLT and MEM3BLT orders.
        //
        if ((orderType == ORD_MEMBLT) || (orderType == ORD_MEM3BLT))
        {
            OETileBitBltOrder(pOrder, &memBltExtraInfo, pco);
        }
        else
        {
            OEClipAndAddOrder(pOrder, NULL, pco);
        }
    }
    else
    {
        if (fAccumulate)
        {
            OEClipAndAddScreenData(&bounds, pco);
        }

    }

    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    DebugExitDWORD(DrvBitBlt, rc);
    return(rc);
}


//
// DrvStretchBlt - see NT DDK documentation.
//
BOOL DrvStretchBlt(SURFOBJ         *psoDst,
                         SURFOBJ         *psoSrc,
                         SURFOBJ         *psoMask,
                         CLIPOBJ         *pco,
                         XLATEOBJ        *pxlo,
                         COLORADJUSTMENT *pca,
                         POINTL          *pptlHTOrg,
                         RECTL           *prclDst,
                         RECTL           *prclSrc,
                         POINTL          *pptlMask,
                         ULONG            iMode)
{
    BOOL    rc = TRUE;
    RECT  rectSrc;
    RECT  rectDst;
    BOOL  fAccumulate = FALSE;
    POINTL  ptlSrc;
    BOOL    usedBitBlt  = FALSE;

    DebugEntry(DrvStretchBlt);

    //
    // DO THIS _BEFORE_ TAKING LOCK
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;

    OE_SHM_START_WRITING;


    //
    // Get the source and destination rectangles
    //
    RECT_FROM_RECTL(rectSrc, (*prclSrc));
    RECT_FROM_RECTL(rectDst, (*prclDst));

    //
    // Check if we are accumulating data for this function
    //
    fAccumulate = OEAccumulateOutput(psoDst, pco, &rectDst);
    if (!fAccumulate)
    {
        DC_QUIT;
    }

    //
    // Check that we have a valid ROP code.  The NT DDK states that the ROP
    // code for the StretchBlt is implicit in the mask specification.  If a
    // mask is specified, we have an implicit ROP4 of 0xCCAA, otherwise the
    // code is 0xCCCC.
    //
    // Our BitBlt code only encodes orders for ROP3s, so we must throw any
    // StretchBlts with a mask.
    //
    if (psoMask != NULL)
    {
        TRACE_OUT(( "Mask specified"));
        DC_QUIT;
    }

    //
    // Check for overcomplicated clipping.
    //
    if (OEClippingIsComplex(pco))
    {
        TRACE_OUT(( "Clipping is too complex"));
        DC_QUIT;
    }

    //
    // Rectangles are now well-ordered, check if we have a degenerate (ie.
    // no stretch) case.
    //
    if ( (rectSrc.right  - rectSrc.left == rectDst.right  - rectDst.left) &&
         (rectSrc.bottom - rectSrc.top  == rectDst.bottom - rectDst.top ) )
    {
        //
        // This can be passed on to the BitBlt code.
        //
        usedBitBlt = TRUE;

        ptlSrc.x = prclSrc->left;
        ptlSrc.y = prclSrc->top;

        rc = DrvBitBlt(psoDst,
                       psoSrc,
                       psoMask,
                       pco,
                       pxlo,
                       prclDst,
                       &ptlSrc,
                       pptlMask,
                       NULL,
                       NULL,
                       0xCCCC);

        //
        // We have stored this object in the BitBlt, so don't store the
        // data again.
        //
        fAccumulate = FALSE;
    }

DC_EXIT_POINT:
    if (fAccumulate)
    {
        //
        // Convert the data to virtual coordinates.
        //
        OELRtoVirtual(&rectDst, 1);

        //
        // Update the screen data area
        //
        OEClipAndAddScreenData(&rectDst, pco);
    }

    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    DebugExitDWORD(DrvStretchBlt, rc);
    return(rc);
}


//
// DrvCopyBits - see NT DDK documentation.
//
BOOL DrvCopyBits(SURFOBJ  *psoDst,
                       SURFOBJ  *psoSrc,
                       CLIPOBJ  *pco,
                       XLATEOBJ *pxlo,
                       RECTL    *prclDst,
                       POINTL   *pptlSrc)
{
    //
    // CopyBits is a fast path for the NT display drivers.  In our case it
    // can always be processed as a BITBLT.
    //
    return(DrvBitBlt( psoDst,
                    psoSrc,
                    NULL,
                    pco,
                    pxlo,
                    prclDst,
                    pptlSrc,
                    NULL,
                    NULL,
                    NULL,
                    0xCCCC));
}


//
// DrvTextOut - see NT DDK documentation.
//
BOOL DrvTextOut(SURFOBJ  *pso,
                      STROBJ   *pstro,
                      FONTOBJ  *pfo,
                      CLIPOBJ  *pco,
                      RECTL    *prclExtra,
                      RECTL    *prclOpaque,
                      BRUSHOBJ *pboFore,
                      BRUSHOBJ *pboOpaque,
                      POINTL   *pptlOrg,
                      MIX       mix)
{
    LPOSI_PDEV           ppdev = (LPOSI_PDEV)pso->dhpdev;
    BOOL                rc = TRUE;
    RECT              rectDst;
    RECT              rectText;
    LPINT_ORDER          pOrder;
    LPINT_ORDER          pOpaqueOrder;
    LPTEXTOUT_ORDER     pTextOut;
    LPEXTTEXTOUT_ORDER  pExtTextOut;
    BOOL              fSendOrder  = FALSE;
    BOOL              fAccumulate = FALSE;
    char              ansiString[ORD_MAX_STRING_LEN_WITHOUT_DELTAS+2];
    ULONG               ansiLen;
    ULONG               tempLen;
    UINT            orderType = 0;
    ULONG               maxLength;
    LPSTR             lpVariable;
    BOOL                fMoreData;
    ULONG               count;
    ULONG               i;
    GLYPHPOS*           pGlyphData;
    int                 currentDelta;
    LPVARIABLE_DELTAX   lpDeltaPos;
    UINT                fontFlags;
    UINT                fontAscender;
    UINT                fontHeight;
    UINT                fontWidth;
    UINT                fontWeight;
    UINT                fontIndex;
    POINTL              lastPtl;
    LPCOMMON_TEXTORDER   pCommon;
    POINT               startPoint;
    BOOL              sendDeltaX = FALSE;

    DebugEntry(DrvTextOut);

    //
    // DO THIS _BEFORE_ TAKING LOCKS
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;

    OE_SHM_START_WRITING;

    //
    // Get bounding rectangle and convert to a RECT.
    //
    if (prclOpaque != NULL)
    {
        RECT_FROM_RECTL(rectDst, (*prclOpaque));
    }
    else
    {
        RECT_FROM_RECTL(rectDst, pstro->rclBkGround);
        TRACE_OUT(( "Using STROBJ bgd for size"));
    }

    //
    // Check if we are accumulating data for this function
    //
    fAccumulate = OEAccumulateOutput(pso, pco, &rectDst);
    if (!fAccumulate)
    {
        DC_QUIT;
    }

    //
    // Convert to virtual coordinates
    //
    OELRtoVirtual(&rectDst, 1);

    //
    // Determine which order we will generate
    //
    if ( ((pstro->flAccel & SO_FLAG_DEFAULT_PLACEMENT) != 0) &&
         (prclOpaque == NULL) )
    {
        orderType = ORD_TEXTOUT;
        maxLength = ORD_MAX_STRING_LEN_WITHOUT_DELTAS;
    }
    else
    {
        orderType = ORD_EXTTEXTOUT;
        maxLength = ORD_MAX_STRING_LEN_WITH_DELTAS;
    }

    //
    // Check if we are allowed to send this order (determined by the
    // negotiated capabilities of all the machines in the conference).
    //
    if (!OE_SendAsOrder(orderType))
    {
        TRACE_OUT(( "Text order %x not allowed", orderType));
        DC_QUIT;
    }

    //
    // Check for a valid brush for the test operation.
    //
    if (pboFore->iSolidColor == -1)
    {
        TRACE_OUT(( "Bad brush for text fg"));
        DC_QUIT;
    }
    if (pboOpaque->iSolidColor == -1)
    {
        TRACE_OUT(( "Bad brush for text bg"));
        DC_QUIT;
    }

    //
    // Check that we don't have any modifiers rects on the font
    //
    if (prclExtra != NULL)
    {
        TRACE_OUT(( "Unsupported extra rects"));
        DC_QUIT;
    }

    //
    // Check that text orientation is OK.
    //
    if (pstro->flAccel & OE_BAD_TEXT_MASK)
    {
        TRACE_OUT(("DrvTextOut - unsupported flAccel 0x%08x", pstro->flAccel));
        DC_QUIT;
    }

    //
    // Check we have a valid string.
    //
    if (pstro->pwszOrg == NULL)
    {
        TRACE_OUT(( "No string - opaque %x", prclOpaque));
        DC_QUIT;
    }

    //
    // Check for overcomplicated clipping.
    //
    if (OEClippingIsComplex(pco))
    {
        TRACE_OUT(( "Clipping is too complex"));
        DC_QUIT;
    }

    //
    // Convert the string to an ANSI representation.
    //
    RtlFillMemory(ansiString, sizeof(ansiString), 0);
    EngUnicodeToMultiByteN(ansiString,
                           maxLength,
                           &ansiLen,
                           pstro->pwszOrg,
                           pstro->cGlyphs * sizeof(WCHAR));


    //
    // The conversion claims it never fails, but we have seen results that
    // are completely different on the remote box.  So we convert the ANSI
    // string back to UNICODE and check that we still have what we started
    // with.
    //
    EngMultiByteToUnicodeN(g_oeTempString,
                           sizeof(g_oeTempString),
                           &tempLen,
                           ansiString,
                           ansiLen);

    //
    // Check we don't have too much data, or that the translation failed to
    // give the correct data.  This happens when we try to translate
    // UNICODE text.
    //
    if ( (tempLen != pstro->cGlyphs * sizeof(WCHAR))           ||
         (memcmp(pstro->pwszOrg, g_oeTempString, tempLen) != 0) )
    {
        TRACE_OUT(( "String not translated"));
        DC_QUIT;
    }

    //
    // Check that the font is valid.
    //
    if (!OECheckFontIsSupported(pfo, ansiString, ansiLen,
                                &fontHeight,
                                &fontAscender,
                                &fontWidth,
                                &fontWeight,
                                &fontFlags,
                                &fontIndex,
                                &sendDeltaX))
    {
        TRACE_OUT(( "Unsupported font for '%s'", ansiString));
        //
        // Check if there is an opaque rectangle. If so it is worth
        // splitting this out. Word can output an entire line comprising a
        // single character followed by background, eg bullets, where the
        // line is blanked by drawing the bullet character at the start of
        // the line followed by a large - >1000 pixel - opaque rect.
        // Splitting the opaque rect from the text means we can send a
        // small area of SD for the unmatched font char while encoding the
        // large opaque rectangle.
        //
        if ( (prclOpaque != NULL) &&
             (pstro->cGlyphs == 1) &&
             (pstro->flAccel & SO_HORIZONTAL) &&
             OE_SendAsOrder(ORD_PATBLT))
        {
            //
            // There is an opaque rectangle and a single char.
            // Encode the opaque rectangle. First get a copy of the target
            // rect so we can use it later (and flip it into screen
            // coordinates).
            //
            TRACE_OUT(( "Have 1 char + opaque rect"));
            rectText.left = rectDst.left;
            rectText.top = rectDst.top;
            rectText.right = rectDst.right + 1;
            rectText.bottom = rectDst.bottom + 1;

            //
            // Call into the PATBLT encoding function.
            //
            if ( !OEEncodePatBlt(ppdev,
                                 pboOpaque,
                                 pptlOrg,
                                 OE_COPYPEN_ROP,
                                 &rectDst,
                                 &pOpaqueOrder) )
            {
                //
                // Something went wrong with the encoding, so skip to the
                // end to add this operation to the SDA.
                //
                TRACE_OUT(( "Failed to encode opaque rect"));
                DC_QUIT;
            }

            //
            // Store the general order data.  The bounding rectagle
            // co-ordinates must be virtual desktop.  OELRtoVirtual has
            // already converted rect for us.
            //
            TSHR_RECT16_FROM_RECT(&pOpaqueOrder->OrderHeader.Common.rcsDst, rectDst);

            //
            // Add the order to the cache.
            //
            OEClipAndAddOrder(pOpaqueOrder, NULL, pco);

            //
            // Calculate the bounds of the text. Get the glyph positions
            // for the left and right, and assume the top and bottom equate
            // approximately to the opaque rectangle.
            //
            if ( pstro->pgp == NULL)
            {
                //
                // The string object doesn't contain the GLYPHPOS info, so
                // enumerate the glyphs.
                //
                TRACE_OUT(( "Enumerate glyphs"));
                STROBJ_vEnumStart(pstro);
                STROBJ_bEnum(pstro, &count, &pGlyphData);
            }
            else
            {
                //
                // The string object already contains the GLYPHPOS info, so
                // just grab the pointer to it.
                //
                pGlyphData = pstro->pgp;
            }

            rectDst = rectText;
            rectDst.left = max(rectDst.left, pGlyphData[0].ptl.x);
            if ( pstro->ulCharInc == 0 )
            {
                //
                // No character increment for this string object. Just use
                // the maximum glyph width to calculate the right bounding
                // edge.
                //
                TRACE_OUT(( "no charinc glyph %d trg %d left %d maxX %d",
                                                   pGlyphData[0].ptl.x,
                                                   rectDst.right,
                                                   rectDst.left,
                                                   pfo->cxMax));
                rectDst.right = min(rectDst.right, (int)(pGlyphData[0].ptl.x +
                                                              pfo->cxMax - 1));
            }
            else
            {
                //
                // The string object has a character increment, so use it
                // to determine the right bounding edge.
                //
                TRACE_OUT(( "charinc %x glyph %d trg %d left %d",
                                                    pstro->ulCharInc,
                                                    pGlyphData[0].ptl.x,
                                                    rectDst.right,
                                                    rectDst.left));
                rectDst.right = min(rectDst.right, (int)(pGlyphData[0].ptl.x +
                                                        pstro->ulCharInc - 1));
            }

            //
            // Flip the target rectangle back to virtual coordinates.
            //
            rectDst.right -= 1;
            rectDst.bottom -= 1;
        }

        //
        // Skip to the end to add to the SDA.
        //
        DC_QUIT;
    }

    //
    // It is possible that the font matching blows our previous decision to
    // generate a TextOut order and we need to generate an ExtTextOut order
    // instead.  We need to reverify our parameters if this is the case.
    //
    if ((sendDeltaX) && (orderType != ORD_EXTTEXTOUT))
    {
        TRACE_OUT(( "Text order must be EXTTEXTOUT"));

        //
        // Set up for ExtTexOut orders.
        //
        orderType = ORD_EXTTEXTOUT;
        maxLength = ORD_MAX_STRING_LEN_WITH_DELTAS;

        //
        // Check if we are allowed to send this order (determined by the
        // negotiated capabilities of all the machines in the conference).
        //
        if (!OE_SendAsOrder(orderType))
        {
            TRACE_OUT(( "Text order %x not allowed", orderType));
            DC_QUIT;
        }

        //
        // Make sure we haven't blown the order size.
        //
        if (pstro->cGlyphs > maxLength)
        {
            TRACE_OUT(( "Text limit blown", pstro->cGlyphs));
            DC_QUIT;
        }
    }

    //
    // Get the proper start position for the text.
    //
    if ( pstro->pgp == NULL)
    {
        STROBJ_vEnumStart(pstro);
        STROBJ_bEnum(pstro, &count, &pGlyphData);
        if (count == 0)
        {
            WARNING_OUT(( "No glyphs"));
            DC_QUIT;
        }
    }
    else
    {
        pGlyphData = pstro->pgp;
    }

    startPoint.x = pGlyphData[0].ptl.x;

    //
    // Check if we should be using baseline alignment for the y
    // coordinate.  If we should be, the value in the glyph data is
    // correct.  If not, we the y coordinate is for the top of the
    // text, and we have to calculate it.
    //
    if (g_oeBaselineTextEnabled)
    {
        startPoint.y = pGlyphData[0].ptl.y;
        fontFlags   |= NF_BASELINE;
    }
    else
    {
        startPoint.y = pGlyphData[0].ptl.y - fontAscender;
    }

    //
    // Allocate memory for the order
    //
    switch (orderType)
    {
        case ORD_TEXTOUT:
        {
            //
            // Allocate the memory
            //
            pOrder = OA_DDAllocOrderMem((UINT)( sizeof(TEXTOUT_ORDER)
                                          - ORD_MAX_STRING_LEN_WITHOUT_DELTAS
                                          + ansiLen ),
                                      0);
            if (pOrder == NULL)
            {
                TRACE_OUT(( "Failed to alloc order"));
                DC_QUIT;
            }
            pTextOut = (LPTEXTOUT_ORDER)pOrder->abOrderData;

            //
            // Set up the order type.
            //
            pTextOut->type    = ORD_TEXTOUT_TYPE;

            //
            // Get a pointer to the fields which are common to both TextOut
            // and ExtTextOut
            //
            pCommon           = &pTextOut->common;
        }
        break;


        case ORD_EXTTEXTOUT:
        {
            //
            // BOGUS LAURABU
            // This allocates space for a deltax array whether or not one is needed
            //
            //
            // Allocate the memory
            //
            pOrder = OA_DDAllocOrderMem((UINT)( sizeof(EXTTEXTOUT_ORDER)
                                      -  ORD_MAX_STRING_LEN_WITHOUT_DELTAS
                                      - (ORD_MAX_STRING_LEN_WITH_DELTAS
                                                            * sizeof(TSHR_INT32))
                                      + ansiLen * (sizeof(TSHR_INT32) + 1)
                                      + 4),   // Allow for internal padding
                                      0);
            if (pOrder == NULL)
            {
                TRACE_OUT(( "Failed to alloc order"));
                DC_QUIT;
            }
            pExtTextOut = (LPEXTTEXTOUT_ORDER)pOrder->abOrderData;

            //
            // Set up the order type.
            //
            pExtTextOut->type = ORD_EXTTEXTOUT_TYPE;

            //
            // Get a pointer to the fields which are common to both TextOut
            // and ExtTextOut
            //
            pCommon           = &pExtTextOut->common;
        }
        break;

        default:
        {
            ERROR_OUT(( "Unknown order %x", orderType));
            DC_QUIT;
        }
        break;
    }

    //
    // Fill in the fields which are common to both TextOut and ExtTextOut
    //
    // Convert to virtual coordinates
    //
    OELPtoVirtual(&startPoint, 1);

    //
    // The x and y values are available in virtual coords from the bounds
    // rectangle.
    //
    pCommon->nXStart = startPoint.x;
    pCommon->nYStart = startPoint.y;

    //
    // Get the text colours.
    //
    OEConvertColor(ppdev,
                   &pCommon->BackColor,
                   pboOpaque->iSolidColor,
                   NULL);
    OEConvertColor(ppdev,
                   &pCommon->ForeColor,
                   pboFore->iSolidColor,
                   NULL);

    //
    // The transparency of the operation is determined by whether we have
    // an opaque rectangle or not.
    //
    pCommon->BackMode    = (prclOpaque == NULL) ? TRANSPARENT : OPAQUE;

    //
    // NT has a character extra spacing, not a generic for every character
    // spacing.  So, we always set this value to 0.
    //
    pCommon->CharExtra   = 0;

    //
    // NT does not provide a break of any sorts.
    //
    pCommon->BreakExtra  = 0;
    pCommon->BreakCount  = 0;

    //
    // Copy the font details
    //
    pCommon->FontHeight  = fontHeight;
    pCommon->FontWidth   = fontWidth;
    pCommon->FontWeight  = fontWeight;
    pCommon->FontFlags   = fontFlags;
    pCommon->FontIndex   = fontIndex;

    //
    // Now fill in the order specific data
    //
    switch (orderType)
    {
        case ORD_TEXTOUT:

            //
            // Copy across the text string.
            //
            pTextOut->variableString.len = (BYTE)ansiLen;
            RtlCopyMemory(pTextOut->variableString.string,
                          ansiString,
                          ansiLen);

            //
            // Make sure we send the order
            //
            fSendOrder = TRUE;

            TRACE_OUT(( "TEXTOUT: X %u Y %u bm %u FC %02X%02X%02X "
                         "BC %02X%02X%02X",
                         pTextOut->common.nXStart,
                         pTextOut->common.nYStart,
                         pTextOut->common.BackMode,
                         pTextOut->common.ForeColor.red,
                         pTextOut->common.ForeColor.green,
                         pTextOut->common.ForeColor.blue,
                         pTextOut->common.BackColor.red,
                         pTextOut->common.BackColor.green,
                         pTextOut->common.BackColor.blue));

            TRACE_OUT(( "Font: fx %u fy %u fw %u ff %04x fh %u len %u",
                         pTextOut->common.FontWidth,
                         pTextOut->common.FontHeight,
                         pTextOut->common.FontWeight,
                         pTextOut->common.FontFlags,
                         pTextOut->common.FontIndex,
                         ansiLen));

            TRACE_OUT(( "String '%s'", ansiString));
            break;

        case ORD_EXTTEXTOUT:
            //
            // Since our text is only ever fully contained within the
            // opaque rectangle, we only set the opaque flag (and ignore
            // the clipping).
            //
            pExtTextOut->fuOptions = (prclOpaque == NULL) ? 0 : ETO_OPAQUE;

            //
            // Set up the bounding rectangle for the operation.
            // EXT_TEXT_OUT orders use TSHR_RECT32s, hence we can't directly
            // assign rectDst to it.
            //
            pExtTextOut->rectangle.left     = rectDst.left;
            pExtTextOut->rectangle.top      = rectDst.top;
            pExtTextOut->rectangle.right    = rectDst.right;
            pExtTextOut->rectangle.bottom   = rectDst.bottom;

            //
            // Copy across the text string.
            //
            pExtTextOut->variableString.len = ansiLen;
            RtlCopyMemory(pExtTextOut->variableString.string,
                          ansiString,
                          ansiLen);

            //
            // WHOOP WHOOP WHOOP - Prepare to shut your eyes...
            //
            // Although we have a defined fixed length structure for
            // storing ExtTextOut orders, we must not send the full
            // structure over the network as the text will only be, say, 10
            // characters while the structure contains room for 127.
            //
            // Hence we pack the structure now to remove all the blank data
            // BUT we must maintain the natural alignment of the variables.
            //
            // So we know the length of the string which we can use to
            // start the new delta structure at the next 4-byte boundary.
            //
            lpVariable = ((LPBYTE)(&pExtTextOut->variableString))
                       + ansiLen
                       + sizeof(pExtTextOut->variableString.len);

            lpVariable = (LPSTR)
                         DC_ROUND_UP_4((UINT_PTR)lpVariable);

            lpDeltaPos = (LPVARIABLE_DELTAX)lpVariable;

            //
            // Do we need a delta array, or are the chars at their default
            // positions.
            //
            if ( sendDeltaX ||
                 ((pstro->flAccel & SO_FLAG_DEFAULT_PLACEMENT) == 0) )
            {
                //
                // Store the length of the position deltas.
                //
                lpDeltaPos->len = ansiLen * sizeof(TSHR_INT32);

                //
                // Set up the position deltas.
                //
                STROBJ_vEnumStart(pstro);
                fMoreData    = TRUE;
                currentDelta = 0;
                while (fMoreData)
                {
                    //
                    // Get the next set of glyph data
                    //
                    fMoreData = STROBJ_bEnum(pstro, &count, &pGlyphData);
                    for (i = 0; i < count; i++)
                    {
                        //
                        // The first time through we must set up the first
                        // glyph position.
                        //
                        if ((currentDelta == 0) && (i == 0))
                        {
                            lastPtl.x = pGlyphData[0].ptl.x;
                            lastPtl.y = pGlyphData[0].ptl.y;

                            TRACE_OUT(( "First Pos %d", lastPtl.x));
                        }
                        else
                        {
                            //
                            // For subsequent entries, we need to add the
                            // delta on the X position to the array.
                            //
                            if (pstro->ulCharInc == 0)
                            {
                                 lpDeltaPos->deltaX[currentDelta]
                                                         = pGlyphData[i].ptl.x
                                                         - lastPtl.x;

                                //
                                // Check for delta Y's - which we can't
                                // encode
                                //
                                if (pGlyphData[i].ptl.y - lastPtl.y)
                                {
                                    WARNING_OUT(( "New Y %d",
                                                 pGlyphData[i].ptl.y));
                                    OA_DDFreeOrderMem(pOrder);
                                    DC_QUIT;
                                }

                                //
                                // Store the last position for the next
                                // time round.
                                //
                                lastPtl.x = pGlyphData[i].ptl.x;
                                lastPtl.y = pGlyphData[i].ptl.y;

                                TRACE_OUT(( "Next Pos %d %d", i, lastPtl.x));
                            }
                            else
                            {
                                lpDeltaPos->deltaX[currentDelta]
                                                           = pstro->ulCharInc;
                            }

                            currentDelta++;
                        }
                    }
                }

                //
                // For the last entry, we need to set up the data by hand
                // (there are only n-1 deltas for n chars)
                //
                // This is done for compatibility with Windows 95 which
                // requires the last delta to be the delta to the place
                // where the next char would be if there were n+1 chars in
                // the string.
                //
                if (pstro->ulCharInc == 0)
                {
                    //
                    // No characters left - fudge a value of the width of
                    // the last character.
                    //
                    lpDeltaPos->deltaX[currentDelta] =
                                 pGlyphData[count-1].pgdf->pgb->sizlBitmap.cx;
                }
                else
                {
                    //
                    // All chars are evenly spaced, so just stick the value
                    // in.
                    //
                    lpDeltaPos->deltaX[currentDelta] = pstro->ulCharInc;
                }

                //
                // WHOOP WHOOP WHOOP - You can open your eyes now...
                //

                //
                // We must indicate the presence of this field to the
                // receiver.
                //
                pExtTextOut->fuOptions |= ETO_LPDX;
            }
            else
            {
                //
                // Mark the delta array as empty.
                //
                lpDeltaPos->len = 0;
            }

            //
            // WHOOP WHOOP WHOOP - You can open your eyes now...
            //


            //
            // Make sure we send the order
            //
            fSendOrder = TRUE;

            TRACE_OUT(( "EXTTEXTOUT: X %u Y %u bm %u FC %02X%02X%02X "
                         "BC %02X%02X%02X",
                         pExtTextOut->common.nXStart,
                         pExtTextOut->common.nYStart,
                         pExtTextOut->common.BackMode,
                         pExtTextOut->common.ForeColor.red,
                         pExtTextOut->common.ForeColor.green,
                         pExtTextOut->common.ForeColor.blue,
                         pExtTextOut->common.BackColor.red,
                         pExtTextOut->common.BackColor.green,
                         pExtTextOut->common.BackColor.blue));

            TRACE_OUT(( "Extra: Opt %x X1 %d Y1 %d X2 %d Y2 %d",
                         pExtTextOut->fuOptions,
                         pExtTextOut->rectangle.left,
                         pExtTextOut->rectangle.top,
                         pExtTextOut->rectangle.right,
                         pExtTextOut->rectangle.bottom));

            TRACE_OUT(( "Font: fx %u fy %u fw %u ff %04x fh %u len %u",
                         pExtTextOut->common.FontWidth,
                         pExtTextOut->common.FontHeight,
                         pExtTextOut->common.FontWeight,
                         pExtTextOut->common.FontFlags,
                         pExtTextOut->common.FontIndex,
                         ansiLen));

            TRACE_OUT(( "String '%s'", ansiString));
            break;

        default:
            ERROR_OUT(( "Unknown order %x", orderType));
            break;
    }

DC_EXIT_POINT:
    //
    // If we did not send an order, we must accumulate the output in the
    // Screen Data Area.
    //
    if (fSendOrder)
    {
        //
        // Store the general order data.  The bounding rectangle position
        // must be in virtual desktop co-ordinates.  OELRtoVirtual has
        // already done this.
        //
        pOrder->OrderHeader.Common.fOrderFlags   = OF_SPOILABLE;
        TSHR_RECT16_FROM_RECT(&pOrder->OrderHeader.Common.rcsDst, rectDst);

        //
        // Add the order to the cache.
        //
        OEClipAndAddOrder(pOrder, NULL, pco);
    }
    else
    {
        if (fAccumulate)
        {
            OEClipAndAddScreenData(&rectDst, pco);
        }
    }

    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    DebugExitDWORD(DrvTextOut, rc);
    return(rc);
}


//
// DrvLineTo - see NT DDK documentation.
//
BOOL DrvLineTo(SURFOBJ   *pso,
                     CLIPOBJ   *pco,
                     BRUSHOBJ  *pbo,
                     LONG       x1,
                     LONG       y1,
                     LONG       x2,
                     LONG       y2,
                     RECTL     *prclBounds,
                     MIX        mix)
{
    LPOSI_PDEV      ppdev = (LPOSI_PDEV)pso->dhpdev;
    BOOL           rc = TRUE;
    RECT         rectDst;
    POINT           startPoint;
    POINT           endPoint;
    BOOL          fAccumulate = FALSE;

    DebugEntry(DrvLineTo);

    //
    // DO THIS _BEFORE_ TAKING LOCK
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;


    OE_SHM_START_WRITING;


    //
    // Get bounding rectangle and convert to a RECT.
    //
    RECT_FROM_RECTL(rectDst, (*prclBounds));

    //
    // Check if we are accumulating data for this function
    //
    fAccumulate = OEAccumulateOutput(pso, pco, &rectDst);
    if (!fAccumulate)
    {
        DC_QUIT;
    }

    //
    // Convert the data to virtual coordinates.
    //
    OELRtoVirtual(&rectDst, 1);

    //
    // Check if we are allowed to send this order (determined by the
    // negotiated capabilities of all the machines in the conference).
    //
    if (!OE_SendAsOrder(ORD_LINETO))
    {
        TRACE_OUT(( "LineTo order not allowed"));
        DC_QUIT;
    }

    //
    // Check for a valid brush for the test operation.
    //
    if (pbo->iSolidColor == -1)
    {
        TRACE_OUT(( "Bad brush for line"));
        DC_QUIT;
    }

    //
    // Check for overcomplicated clipping.
    //
    if (OEClippingIsComplex(pco))
    {
        TRACE_OUT(( "Clipping is too complex"));
        DC_QUIT;
    }

    //
    // Set up data for order
    //
    startPoint.x = x1;
    startPoint.y = y1;
    endPoint.x   = x2;
    endPoint.y   = y2;

    //
    // Store that order.
    //
    if (!OEAddLine(ppdev,
              &startPoint,
              &endPoint,
              &rectDst,
              mix & 0x1F,
              1,
              pbo->iSolidColor,
              pco))
    {
        TRACE_OUT(( "Failed to add order - use SDA"));
        DC_QUIT;
    }

    //
    // We have stored this object, so don't store the data in the SDA
    // again.
    //
    fAccumulate = FALSE;

DC_EXIT_POINT:
    if (fAccumulate)
    {
        OEClipAndAddScreenData(&rectDst, pco);
    }

    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    DebugExitDWORD(DrvLineTo, rc);
    return(rc);
}


//
// DrvStrokePath - see NT DDK documentation.
//
BOOL DrvStrokePath(SURFOBJ   *pso,
                         PATHOBJ   *ppo,
                         CLIPOBJ   *pco,
                         XFORMOBJ  *pxo,
                         BRUSHOBJ  *pbo,
                         POINTL    *pptlBrushOrg,
                         LINEATTRS *plineattrs,
                         MIX        mix)
{
    LPOSI_PDEV      ppdev = (LPOSI_PDEV)pso->dhpdev;
    BOOL           rc = TRUE;
    RECTFX         rectfxTrg;
    RECT         rectDst;
    BOOL           fMore = TRUE;
    PATHDATA       pathData;
    POINT        startPoint;
    POINT        nextPoint;
    POINT        endPoint;
    BOOL         fAccumulate = FALSE;
    UINT         i;

    DebugEntry(DrvStrokePath);

    //
    // DO THIS _BEFORE_ TAKING LOCK
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;

    OE_SHM_START_WRITING;


    //
    // Get bounding rectangle and convert to a RECT.
    //
    PATHOBJ_vGetBounds(ppo, &rectfxTrg);
    RECT_FROM_RECTFX(rectDst, rectfxTrg);

    //
    // Check if we are accumulating data for this function
    //
    fAccumulate = OEAccumulateOutput(pso, pco, &rectDst);
    if (!fAccumulate)
    {
        DC_QUIT;
    }

    //
    // Check if we are allowed to send this order (determined by the
    // negotiated capabilities of all the machines in the conference).
    //
    if (!OE_SendAsOrder(ORD_LINETO))
    {
        TRACE_OUT(( "LineTo order not allowed"));
        DC_QUIT;
    }

    //
    // Check for a valid brush for the test operation.
    //
    if (pbo->iSolidColor == -1)
    {
        TRACE_OUT(( "Bad brush for line"));
        DC_QUIT;
    }

    //
    // Check for overcomplicated clipping.
    //
    if (OEClippingIsComplex(pco))
    {
        TRACE_OUT(( "Clipping is too complex"));
        DC_QUIT;
    }

    //
    // See if we can optimize the path...
    //
    // We cannot send:
    //
    // - curvy lines (i.e. beziers)
    // - lines with funny end patterns (i.e. geometric lines)
    // - non Windows standard patterns
    //
    if ( ((ppo->fl        & PO_BEZIERS)   == 0) &&
         ((plineattrs->fl & LA_GEOMETRIC) == 0) &&
         (plineattrs->pstyle              == NULL) )
    {
        //
        // This is a set of solid cosmetic (i.e.  no fancy end styles)
        // lines.  Let's send those orders.
        //
        // NT stores all paths as a set of independent sub-paths.  Each
        // sub-path can start at a new point that is NOT linked to the
        // previous sub-path.
        //
        // Paths used for this function (as opposed to DrvFillPath or
        // DrvStrokeAndFillPath) do not need to be closed.
        //
        PATHOBJ_vEnumStart(ppo);

        while (fMore)
        {
            //
            // Get the next set of lines
            //
            fMore = PATHOBJ_bEnum(ppo, &pathData);

            TRACE_OUT(( "PTS: %lu FLAG: %08lx",
                         pathData.count,
                         pathData.flags));

            //
            // If this is the start of a path, remember the point in case
            // we need to close the path at the end.
            //
            if (pathData.flags & PD_BEGINSUBPATH)
            {
                POINT_FROM_POINTFIX(startPoint, pathData.pptfx[0]);
                POINT_FROM_POINTFIX(nextPoint,  pathData.pptfx[0]);
            }

            //
            // Generate orders for each line in the path.
            //
            for (i = 0; i < pathData.count; i++)
            {
                POINT_FROM_POINTFIX(endPoint, pathData.pptfx[i]);

                if ( (nextPoint.x != endPoint.x) ||
                     (nextPoint.y != endPoint.y) )
                {
                    if (!OEAddLine(ppdev,
                                   &nextPoint,
                                   &endPoint,
                                   &rectDst,
                                   mix & 0x1f,
                                   plineattrs->elWidth.l,
                                   pbo->iSolidColor,
                                   pco))
                    {
                        DC_QUIT;
                    }
                }

                nextPoint.x = endPoint.x;
                nextPoint.y = endPoint.y;
            }

            //
            // Close the path if necessary.
            //
            if ((pathData.flags & PD_CLOSEFIGURE) != 0)
            {
                if (!OEAddLine(ppdev,
                               &endPoint,
                               &startPoint,
                               &rectDst,
                               mix & 0x1f,
                               plineattrs->elWidth.l,
                               pbo->iSolidColor,
                               pco))
                {
                    DC_QUIT;
                }
            }
        }

        //
        // We have processed the entire thing as orders - don't send screen
        // data.
        //
        fAccumulate = FALSE;
    }

DC_EXIT_POINT:
    if (fAccumulate)
    {
        //
        // Convert the bounds to virtual coordinates.
        //
        OELRtoVirtual(&rectDst, 1);
        TRACE_OUT(( "SDA: (%d,%d)(%d,%d)",
                     rectDst.left,
                     rectDst.top,
                     rectDst.right,
                     rectDst.bottom));

        //
        // Update the Screen Data Area
        //
        OEClipAndAddScreenData(&rectDst, pco);

    }
    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    DebugExitDWORD(DrvStrokePath, rc);
    return(rc);
}


//
// DrvFillPath - see NT DDK documentation.
//
BOOL DrvFillPath(SURFOBJ  *pso,
                       PATHOBJ  *ppo,
                       CLIPOBJ  *pco,
                       BRUSHOBJ *pbo,
                       POINTL   *pptlBrushOrg,
                       MIX       mix,
                       FLONG     flOptions)
{
    BOOL    rc = TRUE;
    RECTFX  rectfxTrg;
    RECT  rectDst;

    DebugEntry(DrvFillPath);

    //
    // DO THIS _BEFORE_ TAKING LOCK
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;


    OE_SHM_START_WRITING;


    //
    // Get bounding rectangle and convert to a RECT.
    //
    PATHOBJ_vGetBounds(ppo, &rectfxTrg);
    RECT_FROM_RECTFX(rectDst, rectfxTrg);

    //
    // Check if we are accumulating data for this function
    //
    if (!OEAccumulateOutput(pso, pco, &rectDst))
    {
        DC_QUIT;
    }

    //
    // Convert the bounds to virtual coordinates.
    //
    OELRtoVirtual(&rectDst, 1);
    TRACE_OUT(( "SDA: (%d,%d)(%d,%d)",
                 rectDst.left,
                 rectDst.top,
                 rectDst.right,
                 rectDst.bottom));

    //
    // Update the Screen Data Area
    //
    OEClipAndAddScreenData(&rectDst, pco);

DC_EXIT_POINT:
    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    DebugExitDWORD(DrvFillPath, rc);
    return(rc);
}


//
// DrvStrokeAndFillPath - see NT DDK documentation.
//
BOOL DrvStrokeAndFillPath(SURFOBJ   *pso,
                                PATHOBJ   *ppo,
                                CLIPOBJ   *pco,
                                XFORMOBJ  *pxo,
                                BRUSHOBJ  *pboStroke,
                                LINEATTRS *plineattrs,
                                BRUSHOBJ  *pboFill,
                                POINTL    *pptlBrushOrg,
                                MIX        mixFill,
                                FLONG      flOptions)
{
    BOOL    rc = TRUE;
    RECTFX  rectfxTrg;
    RECT  rectDst;

    DebugEntry(DrvStrokeAndFillPath);

    //
    // DO THIS _BEFORE_ TAKING LOCK
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;


    OE_SHM_START_WRITING;


    //
    // Get bounding rectangle and convert to a RECT.
    //
    PATHOBJ_vGetBounds(ppo, &rectfxTrg);
    RECT_FROM_RECTFX(rectDst, rectfxTrg);

    //
    // Check if we are accumulating data for this function
    //
    if (!OEAccumulateOutput(pso, pco, &rectDst))
    {
        DC_QUIT;
    }

    //
    // Convert the bounds to virtual coordinates.
    //
    OELRtoVirtual(&rectDst, 1);

    //
    // Update the Screen Data Area
    //
    OEClipAndAddScreenData(&rectDst, pco);

DC_EXIT_POINT:
    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    DebugExitDWORD(DrvStrokeAndFillPath, rc);
    return(rc);
}


//
// DrvPaint - see NT DDK documentation.
//
BOOL DrvPaint(SURFOBJ  *pso,
                    CLIPOBJ  *pco,
                    BRUSHOBJ *pbo,
                    POINTL   *pptlBrushOrg,
                    MIX       mix)
{
    BOOL    rc = TRUE;
    RECT  rectDst;
    BOOL  fAccumulate = FALSE;
    ROP4    rop4;

    DebugEntry(DrvPaint);

    //
    // DO THIS _BEFORE_ TAKING LOCK
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;


    OE_SHM_START_WRITING;


    //
    // Get bounding rectangle and convert to a RECT.
    //
    RECT_FROM_RECTL(rectDst, pco->rclBounds);

    //
    // Check if we are accumulating data for this function
    //
    fAccumulate = OEAccumulateOutput(pso, pco, &rectDst);
    if (!fAccumulate)
    {
        DC_QUIT;
    }

    //
    // Convert to virtual coordinates.
    //
    OELRtoVirtual(&rectDst, 1);

    //
    // Check for overcomplicated clipping.
    //
    if (OEClippingIsComplex(pco))
    {
        TRACE_OUT(( "Clipping is too complex"));
        DC_QUIT;
    }

    //
    // The low byte of the mix represents a ROP2.  We need a ROP4 for
    // BitBlt, so convert the mix as follows.
    //
    // Remember the definitions of 2, 3 & 4 way ROP codes.
    //
    //  Msk Pat Src Dst
    //
    //  1   1   1   1    ͸ͻ         ROP2 uses P & D only
    //  1   1   1   0                  
    //  1   1   0   1    Ŀ                     ROP3 uses P, S & D
    //  1   1   0   0     ROP2-1ROP3  ROP4
    //  1   0   1   1     (see                 ROP4 uses M, P, S & D
    //  1   0   1   0     note)      
    //  1   0   0   1                  
    //  1   0   0   0    ;      
    //  0   1   1   1                   
    //  0   1   1   0                            NOTE: Windows defines its
    //  0   1   0   1                            ROP2 codes as the bitwise
    //  0   1   0   0                            value calculated here
    //  0   0   1   1                            plus one.  All other ROP
    //  0   0   1   0                            codes are the straight
    //  0   0   0   1                            bitwise value.
    //  0   0   0   0    ͼ
    //
    // Or, algorithmically...
    //
    // ROP3 = (ROP2 & 0x3) | ((ROP2 & 0xC) << 4) | (ROP2 << 2)
    //
    // ROP4 = (ROP3 << 8) | ROP3
    //
    mix  = (mix & 0x1F) - 1;
    rop4 = (mix & 0x3) | ((mix & 0xC) << 4) | (mix << 2);
    rop4 = (rop4 << 8) | rop4;

    //
    // This can be passed on to the BitBlt code.
    //
    rc = DrvBitBlt( pso,
                    NULL,
                    NULL,
                    pco,
                    NULL,
                    &pco->rclBounds,
                    NULL,
                    NULL,
                    pbo,
                    pptlBrushOrg,
                    rop4 );

    //
    // We have stored this object in the BitBlt, so don't store the data
    // again.
    //
    fAccumulate = FALSE;

DC_EXIT_POINT:
    if (fAccumulate)
    {
        OEClipAndAddScreenData(&rectDst, pco);
    }

    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    DebugExitDWORD(DrvPaint, rc);
    return(rc);
}


//
// OE_DDProcessRequest - see oe.h
//
ULONG OE_DDProcessRequest
(
    SURFOBJ* pso,
    UINT    cjIn,
    void *  pvIn,
    UINT    cjOut,
    void *  pvOut
)
{
    BOOL                    rc = TRUE;
    LPOSI_ESCAPE_HEADER      pHeader;

    DebugEntry(OE_DDProcessRequest);

    //
    // Get the request number.
    //
    pHeader = pvIn;
    switch (pHeader->escapeFn)
    {
        case OE_ESC_NEW_FONTS:
        {
            if ((cjIn != sizeof(OE_NEW_FONTS)) ||
                (cjOut != sizeof(OE_NEW_FONTS)))
            {
                ERROR_OUT(("OE_DDProcessRequest:  Invalid sizes %d, %d for OE_ESC_NEW_FONTS",
                    cjIn, cjOut));
                rc = FALSE;
                DC_QUIT;
            }

            //
            // Get new local font data
            //
            OEDDSetNewFonts(pvIn);
        }
        break;

        case OE_ESC_NEW_CAPABILITIES:
        {
            if ((cjIn != sizeof(OE_NEW_CAPABILITIES)) ||
                (cjOut != sizeof(OE_NEW_CAPABILITIES)))
            {
                ERROR_OUT(("OE_DDProcessRequest:  Invalid sizes %d, %d for OE_ESC_NEW_CAPABILITIES",
                    cjIn, cjOut));
                rc = FALSE;
                DC_QUIT;
            }

            //
            // The capabilities have changed - take the new copy.
            //
            OEDDSetNewCapabilities(pvIn);
        }
        break;

        default:
        {
            ERROR_OUT(("Unrecognised OE escape"));
            rc = FALSE;
        }
        break;
    }

DC_EXIT_POINT:
    DebugExitDWORD(OE_DDProcessRequest, rc);
    return((ULONG)rc);
}


//
// OE_DDTerm()
// This cleans up objects used
//
void OE_DDTerm(void)
{
    DebugEntry(OE_DDTerm);

    //
    // Free font list
    //
    if (g_poeLocalFonts)
    {
        TRACE_OUT(("OE_DDLocalHosting: freeing font block since we're done sharing"));
        EngFreeMem(g_poeLocalFonts);

        g_poeLocalFonts = NULL;
        g_oeNumFonts = 0;
    }

    DebugExitVOID(OE_DDTerm);
}


//
// DrvRealizeBrush - see NT DDK documentation.
//
BOOL DrvRealizeBrush(BRUSHOBJ *pbo,
                           SURFOBJ  *psoTarget,
                           SURFOBJ  *psoPattern,
                           SURFOBJ  *psoMask,
                           XLATEOBJ *pxlo,
                           ULONG    iHatch)
{
    LPOSI_PDEV ppdev = (LPOSI_PDEV)psoTarget->dhpdev;
    BOOL      rc    = TRUE;
    LPBYTE  pData;
    BYTE   brushBits[8];
    UINT  color1;
    UINT  color2;
    int     i;
    int     j;
    BOOL    monochromeBrush = TRUE;

    DebugEntry(DrvRealizeBrush);

    //
    // This function only sets up local data, so shared memory protection
    // is not required.
    //

    //
    // Since this function is called only when we call BRUSHOBJ_pvGetRBrush
    // and we don't do any processing until we are in a share we don't need
    // an explicit check for hosting here ('coz that happened before the
    // call to realise the brush).
    //

    //
    // A valid brush satisfies either of the following criteria.
    //
    //  1) It is a standard hatch brush (as passed by DrvEnablePDEV)
    //  2) It is an 8x8 monochrome bitmap
    //

    //
    // Check for a Windows standard hatch
    //
    if (iHatch < HS_DDI_MAX)
    {
        TRACE_OUT(( "Standard hatch %lu", iHatch));
        rc = OEStoreBrush(ppdev,
                          pbo,
                          BS_HATCHED,
                          NULL,
                          pxlo,
                          (BYTE)iHatch,
                          0,
                          1);
        DC_QUIT;
    }

    //
    // If the driver has been passed a dither color brush we can support
    // this by sending a solid color brush definition
    //
    if ((iHatch & RB_DITHERCOLOR) != 0)
    {
        TRACE_OUT(( "Standard hatch %lu", iHatch));
        rc = OEStoreBrush(ppdev,
                          pbo,
                          BS_SOLID,
                          NULL,
                          NULL,
                          (BYTE)iHatch,
                          iHatch & 0xFFFFFF,
                          0);
        DC_QUIT;
    }


    //
    // Check for a simple 8x8 brush
    //
    if ( (psoPattern->sizlBitmap.cx == 8) &&
         (psoPattern->sizlBitmap.cy == 8) )
    {
        //
        // Check for 2 colours only in the bitmap.
        //
        // NOTE: There's a flag (BMF_TOPDOWN) in psoPattern->fjBitmap
        // that's supposed to indicate whether the bitmap is top-down or
        // bottom-up, but it is not always set up correctly.  In fact, the
        // bitmaps are always the wrong way up for our protocol, so we have
        // to flip them regardless of the flag.  Hence the row numbers are
        // reversed ('i' loops) in all the conversions below.
        //
        pData = psoPattern->pvScan0;
        switch (psoPattern->iBitmapFormat)
        {
            case BMF_1BPP:
            {
                //
                // 1 bpp MUST be 2 colours maximum.
                //
                color1 = 1;
                color2 = 0;
                for (i = 7; i >= 0; i--)
                {
                    brushBits[i] = *pData;
                    pData       += psoPattern->lDelta;
                }
            }
            break;

            case BMF_4BPP:
            {
                //
                // See if it is really a 2 colour brush.  Start off with
                // both colours the same.
                //
                color1 = pData[0] & 15;
                color2 = color1;

                //
                // Iterate through each row of the bitmap.
                //
                for (i = 7; (i >= 0) && (monochromeBrush); i--)
                {
                    brushBits[i] = 0;

                    //
                    // Check each pixel in the row: 4bpp->2 pixels per byte
                    //
                    for (j = 0; (j < 4) && (monochromeBrush); j++)
                    {
                        //
                        // Check the 1st pixel color
                        //
                        if ( (color1 != (UINT)(pData[j] & 0x0F)) &&
                             (color2 != (UINT)(pData[j] & 0x0F)) )
                        {
                            if (color1 == color2)
                            {
                                color2 = (pData[j] & 0x0F);
                            }
                            else
                            {
                                monochromeBrush = FALSE;
                            }
                        }

                        //
                        // Check the 2nd pixel color
                        //
                        if ( (color1 != (UINT)((pData[j] & 0xF0) >> 4)) &&
                             (color2 != (UINT)((pData[j] & 0xF0) >> 4)) )
                        {
                            if (color1 == color2)
                            {
                                color2 = (pData[j] & 0xF0) >> 4;
                            }
                            else
                            {
                                monochromeBrush = FALSE;
                            }
                        }

                        //
                        // Set up the brush data.  High bit is leftmost.
                        //
                        if ((UINT)(pData[j] & 0x0F) == color1)
                        {
                            brushBits[i] |= 0x40 >> (j * 2);
                        }
                        if ((UINT)(pData[j] & 0xF0) >> 4  == color1)
                        {
                            brushBits[i] |= 0x80 >> (j * 2);
                        }
                    }

                    //
                    // Get start of next row.
                    //
                    pData += psoPattern->lDelta;
                }
            }
            break;

            case BMF_8BPP:
            {
                //
                // See if it is really a 2 colour brush.  Start off with
                // both colours the same.
                //
                color1 = pData[0];
                color2 = color1;

                //
                // Iterate through each row of the bitmap.
                //
                for (i = 7; (i >= 0) && (monochromeBrush); i--)
                {
                    brushBits[i] = 0;

                    //
                    // Check each pixel in the row: 8bpp->1 pixel per byte
                    //
                    for (j = 0; (j < 8) && (monochromeBrush); j++)
                    {
                        //
                        // Check each pixel.
                        //
                        if ( (color1 != pData[j]) &&
                             (color2 != pData[j]) )
                        {
                            if (color1 == color2)
                            {
                                color2 = pData[j];
                            }
                            else
                            {
                                monochromeBrush = FALSE;
                            }
                        }

                        //
                        // Update the brush data.  High bit is leftmost.
                        //
                        if (pData[j] == color1)
                        {
                           brushBits[i] |= 0x80 >> j;
                        }
                    }

                    //
                    // Get start of next row.
                    //
                    pData += psoPattern->lDelta;
                }
            }
            break;

            default:
            {
                //
                // Unsupported colour depth.
                //
                monochromeBrush = FALSE;
            }
            break;
        }
    }
    else
    {
        //
        // The brush is the wrong size or requires dithering and so cannot
        // be sent over the wire.
        //
        monochromeBrush = FALSE;
    }

    //
    // Store that brush.
    //
    if (monochromeBrush)
    {
        //
        // Store the brush - note that we have a monochrome brush where the
        // color bit is set up so that 0 = color2 and 1 = color1.  This
        // actually corresponds to 0 = fg and 1 = bg for the protocol
        // colors.
        //
        TRACE_OUT(( "Storing brush: type %d bg %x fg %x",
                     psoPattern->iBitmapFormat,
                     color1,
                     color2));

        rc = OEStoreBrush(ppdev,
                          pbo,
                          BS_PATTERN,
                          brushBits,
                          pxlo,
                          0,
                          color2,
                          color1);
    }
    else
    {
        TRACE_OUT(( "Rejected brush h %08lx s (%ld, %ld) fmt %lu",
                     iHatch,
                     psoPattern != NULL ? psoPattern->sizlBitmap.cx : 0,
                     psoPattern != NULL ? psoPattern->sizlBitmap.cy : 0,
                     psoPattern != NULL ? psoPattern->iBitmapFormat : 0));
        rc = OEStoreBrush(ppdev, pbo, BS_NULL, NULL, pxlo, 0, 0, 0);
    }

DC_EXIT_POINT:

    DebugExitDWORD(DrvRealizeBrush, rc);
    return(rc);
}


//
// DrvSaveScreenBits - see NT DDK documentation.
//
ULONG_PTR DrvSaveScreenBits(SURFOBJ *pso,
                              ULONG    iMode,
                              ULONG_PTR    ident,
                              RECTL   *prcl)
{
    BOOL    rc;
    UINT  ourMode;
    RECT  rectDst;

    DebugEntry(DrvSaveScreenBits);

    TRACE_OUT(("DrvSaveScreenBits:  %s",
        ((iMode == SS_SAVE) ? "SAVE" :
            ((iMode == SS_RESTORE) ? "RESTORE" : "DISCARD"))));
    TRACE_OUT(("      rect        {%04ld, %04ld, %04ld, %04ld}",
        prcl->left, prcl->top, prcl->right, prcl->bottom));
    //
    // Default is TRUE, let SaveBits happen if we don't care.  Which we don't
    // if we have no shared memory (NetMeeting isn't running), no window list
    // (no shared apps), or the operation isn't intersecting a window we
    // care about.
    //
    // Note that if we return TRUE on a save, and FALSE on a restore later
    // (because we are now sharing that area for example), USER+GRE handle
    // that.  So it's ok.
    //
    rc = TRUE;

    //
    // DO THIS _BEFORE_ TAKING LOCK
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;

    //
    // If we have no shared memory (NetMeeting isn't running), this will bail
    // out immediately.
    //

    OE_SHM_START_WRITING;


    //
    // Get the bounding rectangle for the operation.  NOTE that this is
    // meaningless for SS_FREE.
    //
    RECT_FROM_RECTL(rectDst, (*prcl));
    if (iMode != SS_FREE)
    {
        //
        // Check if we are accumulating data for this area, ONLY FOR
        // SAVEs.  We may get notified after a window is gone to
        // restore or discard bits we had saved.
        //
        if (!OEAccumulateOutputRect(pso, &rectDst))
        {
            TRACE_OUT(("DrvSaveScreenBits:  save/restore in area we don't care about"));
            DC_QUIT;
        }
    }

    //
    // Convert the NT orders to our generic save/restore types.
    //
    switch (iMode)
    {
        case SS_SAVE:
        {
            ourMode = ONBOARD_SAVE;
        }
        break;

        case SS_RESTORE:
        {
            ourMode = ONBOARD_RESTORE;
        }
        break;

        case SS_FREE:
        {
            ourMode = ONBOARD_DISCARD;
        }
        break;

        default:
        {
            ERROR_OUT(( "Unknown type %lu", iMode));
            DC_QUIT;
        }
    }

    //
    // Call through to the SSI handler.
    //
    rc = SSI_SaveScreenBitmap(&rectDst, ourMode);

DC_EXIT_POINT:
    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    TRACE_OUT(("DrvSaveScreenBits returning %d", rc));
    DebugExitDWORD(DrvSaveScreenBits, rc);
    return(rc);
}



//
// Function:    OEUnicodeStrlen
//
// Description: Get the length of a unicode string in bytes.
//
// Parameters:  pString - Unicode string to be read
//
// Returns:     Length of the Unicode string in bytes
//
int  OEUnicodeStrlen(PWSTR pString)
{
    int i;

    for (i = 0; pString[i] != 0; i++)
        ;

    return((i + 1) * sizeof(WCHAR));
}



//
// Function:    OEExpandColor
//
// Description: Converts a generic bitwise representation of an RGB color
//              index into an 8-bit color index as used by the line
//              protocol.
//
//
void  OEExpandColor
(
    LPBYTE  lpField,
    ULONG   srcColor,
    ULONG   mask
)
{
    ULONG   colorTmp;

    DebugEntry(OEExpandColor);

    //
    // Different example bit masks:
    //
    // Normal 24-bit:
    //      0x000000FF  (red)
    //      0x0000FF00  (green)
    //      0x00FF0000  (blue)
    //
    // True color 32-bits:
    //      0xFF000000  (red)
    //      0x00FF0000  (green)
    //      0x0000FF00  (blue)
    //
    // 5-5-5 16-bits
    //      0x0000001F  (red)
    //      0x000003E0  (green)
    //      0x00007C00  (blue)
    //
    // 5-6-5 16-bits
    //      0x0000001F  (red)
    //      0x000007E0  (green)
    //      0x0000F800  (blue)
    //
    //
    // Convert the color using the following algorithm.
    //
    // <new color> = <old color> * <new bpp mask> / <old bpp mask>
    //
    // where:
    //
    // new bpp mask = mask for all bits at new setting (0xFF for 8bpp)
    //
    // This way maximal (eg.  0x1F) and minimal (eg.  0x00) settings are
    // converted into the correct 8-bit maximum and minimum.
    //
    // Rearranging the above equation we get:
    //
    // <new color> = (<old color> & <old bpp mask>) * 0xFF / <old bpp mask>
    //
    // where:
    //
    // <old bpp mask> = mask for the color
    //

    //
    // LAURABU BOGUS:
    // We need to avoid overflow caused by the multiply.  NOTE:  in theory
    // we should use a double, but that's painfully slow.  So for now hack
    // it.  If the HIBYTE is set, just right shift 24 bits.
    //
    colorTmp = srcColor & mask;
    if (colorTmp & 0xFF000000)
        colorTmp >>= 24;
    else
        colorTmp = (colorTmp * 0xFF) / mask;
    *lpField = (BYTE)colorTmp;

    TRACE_OUT(( "0x%lX -> 0x%X", srcColor, *lpField));

    DebugExitVOID(OEExpandColor);
}


//
// Function:    OEConvertColor
//
// Description: Convert a color from the NT Display Driver into a TSHR_COLOR
//
// Parameters:  pDCColor  - (returned) color in protocol format
//              osColor   - color from the NT display driver
//              pxlo      - XLATEOBJ for the color to be converted
//                          (NULL if no translation is required)
//
// Returns:     (none)
//
void  OEConvertColor(LPOSI_PDEV ppdev, LPTSHR_COLOR pTshrColor,
                                         ULONG     osColor,
                                         XLATEOBJ* pxlo)
{
    ULONG    realIndex;

    DebugEntry(OEConvertColor);

    //
    // Make sure we have a default setting.
    //
    RtlFillMemory(pTshrColor, sizeof(TSHR_COLOR), 0);

    //
    // Check if color translation is required.
    //
    if ((pxlo != NULL) && (pxlo->flXlate != XO_TRIVIAL))
    {
        //
        // Convert from BMP to device color.
        //
        realIndex = XLATEOBJ_iXlate(pxlo, osColor);
        if (realIndex == -1)
        {
            ERROR_OUT(( "Failed to convert color 0x%lx", osColor));
            DC_QUIT;
        }
    }
    else
    {
        //
        // Use the OS color without translation
        //
        realIndex = osColor;
    }

    TRACE_OUT(( "Device color 0x%lX", realIndex));

    //
    // We now have the device specific version of the color.  Time to
    // convert it into a 24-bit RGB color as used by the line protocol.
    //
    switch (ppdev->iBitmapFormat)
    {
        case BMF_1BPP:
        case BMF_4BPP:
        case BMF_4RLE:
        case BMF_8BPP:
        case BMF_8RLE:
            //
            // Palette type device - use the device color as an index into
            // our palette array.
            //
            pTshrColor->red  = (BYTE)ppdev->pPal[realIndex].peRed;
            pTshrColor->green= (BYTE)ppdev->pPal[realIndex].peGreen;
            pTshrColor->blue = (BYTE)ppdev->pPal[realIndex].peBlue;
            break;

        case BMF_16BPP:
        case BMF_24BPP:
        case BMF_32BPP:
            //
            // Generic colour masks (could be eg.  5-6-5 for 16 or 8-8-8
            // for 24 bits per pel).  We must mask off the other bits and
            // shift down to bit 0.
            //
            OEExpandColor(&(pTshrColor->red),
                          realIndex,
                          ppdev->flRed);

            OEExpandColor(&(pTshrColor->green),
                          realIndex,
                          ppdev->flGreen);

            OEExpandColor(&(pTshrColor->blue),
                          realIndex,
                          ppdev->flBlue);
            break;

        default:
            ERROR_OUT(( "Unrecognised BMP color depth %lu",
                                                       ppdev->iBitmapFormat));
            break;
    }

    TRACE_OUT(( "Red %x green %x blue %x", pTshrColor->red,
                                            pTshrColor->green,
                                            pTshrColor->blue));

DC_EXIT_POINT:
    DebugExitVOID(OEConvertColor);
}


//
// Function:    OEStoreBrush
//
// Description: Store the brush data required for pattern realted orders.
//              This function is called by DrvRealiseBrush when it has data
//              to be stored about a brush.
//
// Parameters:  pbo        - BRUSHOBJ of the brush to be stored
//              style      - Style of the brush (as defined in the DC-Share
//                           protocol)
//              pBits      - Pointer to the bits which are used to define
//                           a BS_PATTERN brush.
//              pxlo       - XLATEOBJ for the brush.
//              hatch      - Standard Windows hatch pattern index for a
//                           BS_HATCHED brush.
//              color1     - index into XLATEOBJ for bit set color
//                           OR exact 24bpp color to use (pxlo == NULL)
//              color2     - index into XLATEOBJ for bit clear color
//                           OR exact 24bpp color to use (pxlo == NULL)
//
// Returns:     (none)
//
BOOL  OEStoreBrush(LPOSI_PDEV ppdev,
                                       BRUSHOBJ* pbo,
                                       BYTE   style,
                                       LPBYTE  pBits,
                                       XLATEOBJ* pxlo,
                                       BYTE   hatch,
                                       UINT  color1,
                                       UINT  color2)
{
    BOOL         rc = FALSE;
    int          i;
    LPBYTE       pData;
    ULONG*         pColorTable;
    POE_BRUSH_DATA pBrush;

    DebugEntry(OEStoreBrush);

    //
    // Allocate the space for the brush data.
    //
    pBrush = (POE_BRUSH_DATA)BRUSHOBJ_pvAllocRbrush(pbo,
                                                    sizeof(OE_BRUSH_DATA));
    if (pBrush == NULL)
    {
        ERROR_OUT(( "No memory"));
        DC_QUIT;
    }

    //
    // Reset the brush definition
    //
    RtlFillMemory(pBrush, sizeof(OE_BRUSH_DATA), 0);

    //
    // Set the new brush data.
    //
    pBrush->style = style;
    pBrush->hatch = hatch;

    TRACE_OUT(( " Style: %d Hatch: %d", style, hatch));

    //
    // For pattern brushes, copy the brush specific data.
    //
    if (style == BS_PATTERN)
    {
        //
        // Copy the brush bits.  Since this is an 8x8 mono bitmap, we can
        // copy the first byte of the brush data for each scan line.
        //
        // NOTE however that the brush structures sent over the wire
        // re-use the hatching variable as the first byte of the brush data.
        //
        pData         = pBits;
        pBrush->hatch = *pData;
        TRACE_OUT(( " Hatch: %d", *pData));

        pData++;

        for (i = 0; i < 7; i++)
        {
            pBrush->brushData[i] = pData[i];
            TRACE_OUT(( " Data[%d]: %d", i, pData[i]));
        }

        //
        // Get pointer to the bitmap color table.
        //
        pColorTable = pxlo->pulXlate;
        if (pColorTable == NULL)
        {
            pColorTable = XLATEOBJ_piVector(pxlo);
        }
    }

    //
    // Store the foreground and background colours for the brush.
    //
    if (pxlo != NULL)
    {
        //
        // Conversion required.
        //
        OEConvertColor(ppdev,
                       &pBrush->fore,
                       color1,
                       pxlo);

        OEConvertColor(ppdev,
                       &pBrush->back,
                       color2,
                       pxlo);
    }
    else
    {
        //
        // We have been passed an exact 24bpp color - this only happens for
        // solid brushes so we don't need to convert color2.
        //
        pBrush->fore.red   = (BYTE) (color1 & 0x0000FF);
        pBrush->fore.green = (BYTE)((color1 & 0x00FF00) >> 8);
        pBrush->fore.blue  = (BYTE)((color1 & 0xFF0000) >> 16);
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(OEStoreBrush, rc);
    return(rc);
}


//
// Function:    OECheckBrushIsSimple
//
// Description: Check that the brush is a 'simple' object we can transfer
//              over the DC-Share protocol.
//
// Parameters:  pbo - BRUSHOBJ of the brush to be checked.
//
// Returns:     TRUE  - brush can be sent as DC-Share order
//              FALSE - brush is too complicated.
//
BOOL  OECheckBrushIsSimple(LPOSI_PDEV       ppdev,
                                               BRUSHOBJ*       pbo,
                                               POE_BRUSH_DATA* ppBrush)
{
    BOOL         rc     = FALSE;
    POE_BRUSH_DATA pBrush = NULL;

    DebugEntry(OECheckBrushIsSimple);

    //
    // A 'simple' brush satisfies any of the following.
    //
    //  1) It is a solid color.
    //  2) It is a valid brush as stored by DrvRealizeBrush.
    //

    //
    // Check for a simple solid colour.
    //
    if (pbo->iSolidColor != -1)
    {
        //
        // Use the reserved brush definition to set up the solid colour.
        //
        TRACE_OUT(( "Simple solid colour %08lx", pbo->iSolidColor));
        pBrush = &g_oeBrushData;

        //
        // Set up the specific data for this brush.
        //
        OEConvertColor(ppdev, &pBrush->fore, pbo->iSolidColor, NULL);

        pBrush->back.red   = 0;
        pBrush->back.green = 0;
        pBrush->back.blue  = 0;

        pBrush->style      = BS_SOLID;
        pBrush->hatch      = 0;

        RtlFillMemory(pBrush->brushData, 7, 0);

        //
        // We have a valid brush - return true.
        //
        rc = TRUE;
        DC_QUIT;
    }

    //
    // Check brush definition (which was stored when we realized the
    // brush).
    //
    pBrush = (POE_BRUSH_DATA)pbo->pvRbrush;
    if (pBrush == NULL)
    {
        pBrush = (POE_BRUSH_DATA)BRUSHOBJ_pvGetRbrush(pbo);
        if (pBrush == NULL)
        {
            //
            // We can get NULL returned from BRUSHOBJ_pvGetRbrush when the
            // brush is NULL or in low-memory situations (when the brush
            // realization may fail).
            //
            TRACE_OUT(( "NULL returned from BRUSHOBJ_pvGetRbrush"));
            DC_QUIT;
        }
    }

    //
    // Check it is an encodable brush.
    //
    if (pBrush->style == BS_NULL)
    {
        TRACE_OUT(( "Complex brush"));
        DC_QUIT;
    }

    //
    // Evrything passed - let's use this brush.
    //
    rc = TRUE;

DC_EXIT_POINT:
    //
    // Return the brush definition
    //
    *ppBrush = pBrush;

    TRACE_OUT(( "Returning %d - 0x%08lx", rc, pBrush));

    DebugExitDWORD(OECheckBrushIsSimple, rc);
    return(rc);
}


//
// Function:    OEClippingIsSimple
//
// Description: Check to see if the clipping on the graphics object is
//              trivial
//
// Parameters:  pco - CLIPOBJ of the graphics object to be checked.
//
// Returns:     TRUE  - Clipping is trivial
//              FALSE - Clipping is complex
//
BOOL  OEClippingIsSimple(CLIPOBJ* pco)
{
    BOOL rc = TRUE;

    DebugEntry(OEClippingIsSimple);

    //
    // Check for a valid clip object
    //
    if (pco == NULL)
    {
        TRACE_OUT(( "No clipobj"));
        DC_QUIT;
    }

    //
    // Check for complexity of clipping
    //
    switch (pco->iDComplexity)
    {
        case DC_TRIVIAL:
        case DC_RECT:
            //
            // Trivial (ignore clipping) or simple (one square) clipping -
            // no worries.
            //
            TRACE_OUT(( "Simple clipping"));
            DC_QUIT;

        default:
            TRACE_OUT(( "Clipping is complex"));
            break;
    }

    //
    // Failed all tests - must be too complicated.
    //
    rc = FALSE;

DC_EXIT_POINT:
    DebugExitDWORD(OEClippingIsSimple, rc);
    return(rc);
}


//
// Function:    OEClippingIsComplex
//
// Description: Check to see if the clipping on the graphics object is too
//              complicated to be sent as an order or multiple orders.
//
// Parameters:  pco - CLIPOBJ of the graphics object to be checked.
//
// Returns:     TRUE  - Clipping is too complicated
//              FALSE - Clipping is sufficiently simple to send as orders
//
BOOL  OEClippingIsComplex(CLIPOBJ* pco)
{
    BOOL       rc         = FALSE;
    BOOL       fMoreRects;
    OE_ENUMRECTS clip;
    UINT       numRects = 0;

    DebugEntry(OEClippingIsComplex);

    //
    // If the any of the following are true, the clipping is not too
    // complicated.
    //
    //  1) The clip object does not exist.
    //  2) The clipping is trivial (the object exists, but there are no
    //     clipping rectangles).
    //  3) The clipping is a single rectangle.
    //  4) The object enumerates to less than 'n' rectangles.
    //

    //
    // Check for a valid clip object
    //
    if (pco == NULL)
    {
        TRACE_OUT(( "No clipobj"));
        DC_QUIT;
    }

    //
    // Check for complexity of clipping
    //
    switch (pco->iDComplexity)
    {
        case DC_TRIVIAL:
        case DC_RECT:
            //
            // Trivial or simple clipping - no worries.
            //
            TRACE_OUT(( "Simple clipping"));
            DC_QUIT;

        case DC_COMPLEX:
            //
            // Lots of rectangles - make sure that it is less than the
            // acceptable limit.
            // The documentation for this function incorrectly states that
            // the returned value is the total number of rectangles
            // comprising the clip region. In fact, -1 is always returned,
            // even when the final parameter is non-zero. This means we
            // have to enumerate to get the number of rects.
            //
            CLIPOBJ_cEnumStart(pco,
                               FALSE,
                               CT_RECTANGLES,
                               CD_ANY,
                               0);

            //
            // MSDN: It is possible for CLIPOBJ_bEnum to return TRUE with
            // the number of clipping rectangles equal to zero. In such
            // cases, the driver should call CLIPOBJ_bEnum again without
            // taking any action. Get as many rectangles as we permit for
            // order encoding - this loop should execute once only.
            // If the number of rects equals COMPLEX_CLIP_RECT_COUNT the
            // 1st invocation of CLIPOBJ_bEnum returns that there are more
            // rects and a second call returns there are no more without
            // returning any in addition to those returned on the first
            // call. Our buffer has space for COMPLEX_CLIP_RECT_COUNT+1
            // rects so we should never have to execute the loop more than
            // once.
            //
            do
            {
                fMoreRects = CLIPOBJ_bEnum(pco,
                                           sizeof(clip),
                                           (ULONG *)&clip.rects);
                numRects += clip.rects.c;
            } while ( fMoreRects && (numRects <= COMPLEX_CLIP_RECT_COUNT) );

            //
            // If there are no more rectangles in the clip region then the
            // clipping complexity is within our limits for order encoding.
            //
            if ( numRects <= COMPLEX_CLIP_RECT_COUNT )
            {
                TRACE_OUT(( "Acceptable clipping %u", numRects));
                DC_QUIT;
            }
            break;

        default:
            ERROR_OUT(( "Unknown clipping"));
            break;
    }

    //
    // Failed all tests - must be too complicated.
    //
    TRACE_OUT(( "Complex clipping"));
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(OEClippingIsComplex, rc);
    return(rc);
}


//
// Function:    OEAccumulateOutput
//
// Description: Check to see if we should accumulate this output for
//              sending to the remote machine.
//
// Parameters:  pso   - Pointer to the target surface
//              pco   - Pointer to the clip object (may be NULL)
//              pRect - Pointer to the bounding rectangle of the operation
//
// Returns:     TRUE  - We should accumulate the output
//              FALSE - ignore the output
//
BOOL   OEAccumulateOutput(SURFOBJ* pso, CLIPOBJ *pco, LPRECT pRect)
{
    BOOL    rc = FALSE;
    POINT   pt = {0,0};
    ENUMRECTS clipRect;
    LPOSI_PDEV ppdev = ((LPOSI_PDEV)pso->dhpdev);

    DebugEntry(OEAccumulateOutput);

    //
    // Validate we have valid parameters to access the surface.
    //
    if (ppdev == NULL)
    {
        TRACE_OUT(( "NULL PDEV"));
        DC_QUIT;
    }

    //
    // Check for the screen surface, which will be a bitmap in the hosting
    // only code.
    //
    if (ppdev->hsurfScreen != pso->hsurf)
    {
        TRACE_OUT(( "Dest is not our surface"));
        DC_QUIT;
    }

    if (pso->dhsurf == NULL)
    {
        ERROR_OUT(( "NULL hSurf"));
        DC_QUIT;
    }

    //
    // Extract a single point from the clip object
    //
    if (pco == NULL)
    {
        //
        // No clip object - use a point from the bounding rectangle
        //
        pt.x = pRect->left;
        pt.y = pRect->top;
        TRACE_OUT(( "No clip object, point is %d, %d", pt.x, pt.y));
    }
    else if (pco->iDComplexity == DC_TRIVIAL)
    {
        //
        // Trivial clip object - use a point from the bounding rectangle
        //
        pt.x = pRect->left;
        pt.y = pRect->top;
        TRACE_OUT(( "Trivial clip object, point is %d, %d", pt.x, pt.y));
    }
    else if (pco->iDComplexity == DC_RECT)
    {
        //
        // Single clip rectangle - use a point from it
        //
        // It appears that the clip rectangle is frequantly the entire
        // display.  This is about as much use as a chocolate teapot.  If
        // this is the case, use a point from the bounding rectangle
        // instead.
        //
        if ((pco->rclBounds.left == 0) && (pco->rclBounds.top == 0))
        {
            pt.x = pRect->left;
            pt.y = pRect->top;
            TRACE_OUT(( "Meaningless clip rect, point is %d, %d",
                    pt.x, pt.y));
        }
        else
        {
            pt.x = pco->rclBounds.left;
            pt.y = pco->rclBounds.top;
            TRACE_OUT(( "Single clip rect, point is %d, %d", pt.x, pt.y));
        }
    }
    else
    {
        //
        // Complex clip object - enumerate its first rectangle and use a
        // point from that.
        //
        TRACE_OUT(( "Complex clip rect - call cEnumStart"));
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        clipRect.c = 1;
        memset(clipRect.arcl, 0, sizeof(RECTL));
        TRACE_OUT(( "Complex clip rect - call bEnum"));
        CLIPOBJ_bEnum(pco, sizeof(clipRect), (ULONG *)(&clipRect));

        pt.x = clipRect.arcl[0].left;
        pt.y = clipRect.arcl[0].top;
        TRACE_OUT(( "Complex clip rect, point is %d, %d", pt.x, pt.y));
    }

    //
    // Check if we are accumulating this window.
    //
    rc = HET_DDOutputIsHosted(pt);

DC_EXIT_POINT:
    TRACE_OUT(("OEAccumulateOutput:  point {%d, %d} is %sshared",
        pt.x, pt.y, (rc ? "" : "NOT ")));
    DebugExitBOOL(OEAccumulateOutput, rc);
    return(rc);
}


//
// Function:    OEAccumulateOutputRect
//
// Description: Check to see if we should accumulate the given output rect
//              for sending to the remote machine.
//
//              Most drawing functions will use OEAccumulateOutput, which
//              just checks for a single point within the hosted area.
//              This function checks for any part of the given rectangle
//              intersecting with the hosted area.  It is currently only
//              used by DrvSaveScreenBitmap - operations which may not
//              lie completetely within the hosted area.
//
// Parameters:  pso   - Pointer to the target surface
//              pRect - Pointer to the bounding rectangle of the operation
//
// Returns:     TRUE  - We should accumulate the output
//              FALSE - ignore the output
//
BOOL   OEAccumulateOutputRect( SURFOBJ* pso, LPRECT pRect)
{
    BOOL    rc = FALSE;
    LPOSI_PDEV ppdev = ((LPOSI_PDEV)pso->dhpdev);

    DebugEntry(OEAccumulateOutputRect);

    //
    // Validate we have valid parameters to access the surface.
    //
    if (ppdev == NULL)
    {
        TRACE_OUT(( "NULL PDEV"));
        DC_QUIT;
    }

    //
    // Check for the screen surface, which will be a bitmap in the hosting
    // only code.
    //
    if (ppdev->hsurfScreen != pso->hsurf)
    {
        TRACE_OUT(( "Dest is not our surface"));
        DC_QUIT;
    }

    if (pso->dhsurf == NULL)
    {
        ERROR_OUT(( "NULL hSurf"));
        DC_QUIT;
    }

    //
    // Check if we are accumulating this window.
    //
    rc = HET_DDOutputRectIsHosted(pRect);

DC_EXIT_POINT:
    TRACE_OUT(("OEAccumulateOutputRect:  rect {%d, %d, %d, %d} is %sshared",
        pRect->left, pRect->top, pRect->right, pRect->bottom,
        (rc ? "" : "NOT ")));
    DebugExitBOOL(OEAccumulateOutputRect, rc);
    return(rc);
}


//
// Function:    OESendRop3AsOrder
//
// Description: Check if we are allowed to send this 3-way ROP.  A ROP may
//              be disallowed if it relies on the destination data.
//
// Parameters:  rop3 - the 3-way ROP to be checked.
//
// Returns:     TRUE  - We are allowed to send this ROP
//              FALSE - We can't send this ROP
//
BOOL  OESendRop3AsOrder(BYTE rop3)
{
    BOOL   rc = TRUE;

    DebugEntry(OESendRop3AsOrder);

    //
    // Rop 0x5F is used by MSDN to highlight search keywords.  This XORs
    // a pattern with the destination, producing markedly different (and
    // sometimes unreadable) shadow output.  We special-case no-encoding for
    // it.
    //
    if (rop3 == 0x5F)
    {
        TRACE_OUT(("Rop3 0x5F never encoded"));
        rc = FALSE;
    }

    DebugExitBOOL(OESendRop3AsOrder, rc);
    return(rc);
}




//
// Function:    OECheckFontIsSupported
//
// Description: Check if we are allowed to send this font.  Fonts are
//              disallowed while they are being negotiated on a new entry
//              to the share.
//
// Parameters:  pfo           - (IN)  the font to be checked
//              pFontText     - (IN)  text message to be sent
//              textLen       - (IN)  length of text message
//              pFontHeight   - (OUT) font height in points
//              pFontAscender - (OUT) font ascender in points
//              pFontWidth    - (OUT) ave font width in points
//              pFontWeight   - (OUT) font weight
//              pFontFlags    - (OUT) font style flags
//              pFontIndex    - (OUT) font table index
//              pSendDeltaX   - (OUT) Do we need to send delta X coords?
//
// Returns:     TRUE  - We are allowed to send this font
//              FALSE - We can't send this font
//
BOOL   OECheckFontIsSupported
(
    FONTOBJ*    pfo,
    LPSTR       pFontText,
    UINT        textLen,
    LPUINT      pFontHeight,
    LPUINT      pFontAscender,
    LPUINT      pFontWidth,
    LPUINT      pFontWeight,
    LPUINT      pFontFlags,
    LPUINT      pFontIndex,
    LPBOOL      pSendDeltaX
)
{
    BOOL            rc = FALSE;
    PIFIMETRICS     pFontMetrics;
    UINT            codePage;
    UINT            i;
    UINT            iLocal;
    UINT            matchQuality;
    UINT            charWidthAdjustment = 0;
    char            fontName[FH_FACESIZE];
    ULONG           fontNameLen;
    PWSTR           pUnicodeString;
    XFORMOBJ*       pxform;
    POINTL          xformSize[3];
    int             compareResult;
    FLOATOBJ_XFORM  xformFloatData;

    DebugEntry(OECheckFontIsSupported);

    //
    // Set up default return values
    //
    *pSendDeltaX = FALSE;

    //
    // Check that we have a valid list of font data from the remotes.
    //
    if (!g_oeTextEnabled)
    {
        TRACE_OUT(( "Fonts unavailable"));
        DC_QUIT;
    }

    //
    // Check for valid font attributes
    //
    pFontMetrics = FONTOBJ_pifi(pfo);
    if (pFontMetrics->fsSelection & FM_SEL_OUTLINED)
    {
        TRACE_OUT(( "Unsupported font style"));
        DC_QUIT;
    }

    //
    // The current protocol cannot apply a general 2-D transform to text
    // orders, so we must reject any weird ones such as:
    //
    // - rotations
    // - X or Y shears
    // - X or Y reflections
    // - scaling with a negative value.
    //
    // Or put another way, we only allow:
    //
    // - the identity transformation
    // - scaling with a positive value.
    //
    pxform = FONTOBJ_pxoGetXform(pfo);
    if (pxform != NULL)
    {
        //
        // Get the details of the transformation.  Note we can ignore the
        // translation vector as it does not affect the font sizing /
        // orientation, so we are only interested in the matrix values...
        //

        //
        // NOTE:  Do NOT use floating point explicitly!
        // Can't do float ops in ring 0 with normal lib for x86.
        // Use FLOATOBJs instead and corresponding Eng services.
        // On alpha, these are macros and are way fast in any case.
        //

        if (XFORMOBJ_iGetFloatObjXform(pxform, &xformFloatData) != DDI_ERROR)
        {
            //
            // Rotations and shears will have cross dependencies on the x
            // and y components.
            //
            if ( (!FLOATOBJ_EqualLong(&xformFloatData.eM12, 0)) ||
                 (!FLOATOBJ_EqualLong(&xformFloatData.eM21, 0)) )
            {
                TRACE_OUT(( "Rejected rotn/shear"));
                DC_QUIT;
            }

            //
            // Reflections and scaling operations with negative scale
            // factors will have negative values on the leading diagonal of
            // the matrix.
            //
            if ( (FLOATOBJ_LessThanLong(&xformFloatData.eM11, 0)) ||
                 (FLOATOBJ_LessThanLong(&xformFloatData.eM22, 0)) )
            {
                TRACE_OUT(( "Rejected refln/-ive"));
                DC_QUIT;
            }
        }
    }

    //
    // Get the current font code page for font matching.
    //
    switch (pFontMetrics->jWinCharSet)
    {
        case ANSI_CHARSET:
            TRACE_OUT(( "ANSI font"));
            codePage = NF_CP_WIN_ANSI;
            break;

        case OEM_CHARSET:
            TRACE_OUT(( "OEM font"));
            codePage = NF_CP_WIN_OEM;
            break;

        case SYMBOL_CHARSET:
            TRACE_OUT(("Symbol font"));
            codePage = NF_CP_WIN_SYMBOL;
            break;

        default:
            TRACE_OUT(( "Unknown CP %d", pFontMetrics->jWinCharSet));
            codePage = NF_CP_UNKNOWN;
            break;
    }

    //
    // Get the name of the font.
    //
    pUnicodeString = (PWSTR)( (LPBYTE)pFontMetrics +
                                        pFontMetrics->dpwszFamilyName );
    EngUnicodeToMultiByteN(fontName,
                           sizeof(fontName),
                           &fontNameLen,
                           pUnicodeString,
                           OEUnicodeStrlen(pUnicodeString));

    //
    // Search our Font Alias Table for the current family name.  If we find
    // it, replace it with the alias name from the table.
    //
    for (i = 0; i < NUM_ALIAS_FONTS; i++)
    {
        if (!strcmp((LPSTR)fontName,
                        (LPSTR)(fontAliasTable[i].pszOriginalFontName)))
        {
            TRACE_OUT(( "Alias name: %s -> %s",
                              (LPSTR)fontName,
                              (LPSTR)(fontAliasTable[i].pszAliasFontName)));
            strcpy((LPSTR)fontName,
                   (LPSTR)(fontAliasTable[i].pszAliasFontName));
            charWidthAdjustment = fontAliasTable[i].charWidthAdjustment;
            break;
        }
    }

    TRACE_OUT(( "Font name: '%s'", fontName));

    //
    // We have a font name to match with those we know to be available
    // remotely.  Try to jump straight to the first entry in the local font
    // table starting with the same character as this font.  If this index
    // slot is empty (i.e.  has a value of USHRT_MAX) then the loop will
    // immediately exit
    //
    TRACE_OUT(( "Looking for matching fonts"));

    for (iLocal = g_oeLocalFontIndex[(BYTE)fontName[0]];
         iLocal < g_oeNumFonts;
         iLocal++)
    {
        TRACE_OUT(( "Trying font number %hd", iLocal));

        //
        // If this font is not supported remotely then skip it.
        //
        ASSERT(g_poeLocalFonts);
        matchQuality = g_poeLocalFonts[iLocal].SupportCode;
        if (matchQuality == FH_SC_NO_MATCH)
        {
            continue;
        }

        //
        // See if we've got a facename match
        //
        compareResult =
                 strcmp(g_poeLocalFonts[iLocal].Details.nfFaceName, fontName);

        if (compareResult < 0)
        {
            //
            // We haven't found a match yet, but we haven't gone far enough
            // into this list.
            //
            continue;
        }
        else if (compareResult > 0)
        {
            //
            // We're past the part of the local font array that's applicable.
            // We didn't find a match, it must not exist.
            //
            break;
        }

        //
        // The font names match.  Now see if the other attributes do...
        //

        //
        // This is looking promising - a font with the right name is
        // supported on the remote system.
        //
        // Start building up the details in the global variables while
        // making further checks...
        //
        *pFontFlags  = 0;
        *pFontIndex = iLocal;
        *pFontWeight = pFontMetrics->usWinWeight;

        //
        // Check for a fixed pitch font.
        //
        if ((pFontMetrics->jWinPitchAndFamily & FIXED_PITCH) != 0)
        {
            *pFontFlags |= NF_FIXED_PITCH;
        }

        //
        // Is it a TrueType font?
        //
        if ((pfo->flFontType & TRUETYPE_FONTTYPE) != 0)
        {
            *pFontFlags |= NF_TRUE_TYPE;
        }

        //
        // Get the basic width and height.
        //
        xformSize[0].y = 0;
        xformSize[0].x = 0;
        xformSize[1].y = pFontMetrics->fwdUnitsPerEm;
        xformSize[1].x = pFontMetrics->fwdAveCharWidth;
        xformSize[2].y = pFontMetrics->fwdWinAscender;
        xformSize[2].x = 0;

        //
        // We now need to convert these sizes if the GDI has provided a
        // transform object.
        //
        if (pxform != NULL)
        {
            if (!XFORMOBJ_bApplyXform(pxform,
                                      XF_LTOL,
                                      3,
                                      xformSize,
                                      xformSize))
            {
                ERROR_OUT(( "Xform failed"));
                continue;
            }
        }

        //
        // Calculate the font width and height.
        //
        *pFontHeight = (UINT)(xformSize[1].y - xformSize[0].y);
        *pFontWidth  = (UINT)(xformSize[1].x - xformSize[0].x
                                                 - charWidthAdjustment);

        TRACE_OUT(( "Device font size %hdx%hd", *pFontWidth, *pFontHeight));

        //
        // Get the offset to the start of the text cell.
        //
        *pFontAscender = (UINT)(xformSize[2].y - xformSize[0].y);

        //
        // Check that we have a matching pair - where we require that the
        // fonts (ie the one being used by the application and the one
        // we've matched with the remote system) are the same pitch (ie
        // variable or fixed) and use the same technology (ie TrueType or
        // not).
        //
        if ((g_poeLocalFonts[iLocal].Details.nfFontFlags & NF_FIXED_PITCH) !=
                ((TSHR_UINT16)(*pFontFlags) & NF_FIXED_PITCH))
        {
            TRACE_OUT(( "Fixed pitch mismatch"));
            continue;
        }
        if ((g_poeLocalFonts[iLocal].Details.nfFontFlags & NF_TRUE_TYPE) !=
                ((TSHR_UINT16)*pFontFlags & NF_TRUE_TYPE))
        {
            TRACE_OUT(( "True type mismatch"));
            continue;
        }

        //
        // We have a pair of fonts with the same attributes - either both
        // fixed pitch or both variable pitch - and using the same font
        // technology.
        //
        // If the font is fixed pitch then we must also check that this
        // particular size matches.
        //
        // If the font is not fixed pitch (scalable) then we assume that it
        // is matchable.
        //
        if (g_poeLocalFonts[iLocal].Details.nfFontFlags & NF_FIXED_SIZE)
        {
            //
            // The font is fixed size, so we must check that this
            // particular size is matchable.
            //
            if ( (*pFontHeight != g_poeLocalFonts[iLocal].Details.nfAveHeight) ||
                 (*pFontWidth  != g_poeLocalFonts[iLocal].Details.nfAveWidth)  )
            {
                //
                // The sizes differ, so we must fail this match.
                //
                TRACE_OUT(( "Size mismatch"));
                continue;
            }
        }

        //
        // Hey! We've got a matched pair!
        //
        rc = TRUE;
        TRACE_OUT(( "Found match at local font %hd", iLocal));
        break;
    }

    if (rc != TRUE)
    {
        TRACE_OUT(( "Couldn't find matching font in table"));
        DC_QUIT;
    }

    //
    // Build up the rest of the font flags.  We have already put the pitch
    // flag in place.
    //
    if ( ((pFontMetrics->fsSelection & FM_SEL_ITALIC) != 0) ||
         ((pfo->flFontType           & FO_SIM_ITALIC) != 0) )
    {
        TRACE_OUT(( "Italic"));
        *pFontFlags |= NF_ITALIC;
    }
    if ((pFontMetrics->fsSelection & FM_SEL_UNDERSCORE) != 0)
    {
        TRACE_OUT(( "Underline"));
        *pFontFlags |= NF_UNDERLINE;
    }
    if ((pFontMetrics->fsSelection & FM_SEL_STRIKEOUT) != 0)
    {
        TRACE_OUT(( "Strikeout"));
        *pFontFlags |= NF_STRIKEOUT;
    }

    //
    // It is possible to have a font made bold by Windows, i.e.  the
    // standard font definition is not bold, but windows manipulates the
    // font data to create a bold effect.  This is marked by the
    // FO_SIM_BOLD flag.
    //
    // In this case we need to ensure that the font flags are marked as
    // bold according to the weight.
    //
    if ( ((pfo->flFontType & FO_SIM_BOLD) != 0)       &&
         ( pFontMetrics->usWinWeight      <  FW_BOLD) )
    {
        TRACE_OUT(( "Upgrading weight for a bold font"));
        *pFontWeight = FW_BOLD;
    }

    //
    // If the font is an exact match, or if it is an approximate match for
    // its entire range (0x00 to 0xFF) then send it happily.  If not...only
    // send chars within the range 0x20->0x7F ("true ASCII").
    //
    ASSERT(g_poeLocalFonts);
    if (codePage != g_poeLocalFonts[iLocal].Details.nfCodePage)
    {
        TRACE_OUT(( "Using different CP: downgrade to APPROX_ASC"));
        matchQuality = FH_SC_APPROX_ASCII_MATCH;
    }

    //
    // If we don't have an exact match, check the individual characters.
    //
    if ( (matchQuality != FH_SC_EXACT_MATCH ) &&
         (matchQuality != FH_SC_APPROX_MATCH) )
    {
        //
        // The approximate match is only valid if we use a font that
        // supports the ANSI character set.
        //
        if ((pFontMetrics->jWinCharSet & ANSI_CHARSET) != 0)
        {
            TRACE_OUT(( "Cannot do match without ANSI support"));
            DC_QUIT;
        }

        //
        // This font is not a good match across its entire range.  Check
        // that all chars are within the desired range.
        //
        for (i = 0; i < textLen; i++)
        {
            if ( (pFontText[i] == 0) ||
                 ( (pFontText[i] >= NF_ASCII_FIRST) &&
                   (pFontText[i] <= NF_ASCII_LAST)  )  )
            {
                continue;
            }

            //
            // Can only get here by finding a char outside our acceptable
            // range.
            //
            TRACE_OUT(( "found non ASCII char %x", pFontText[i]));
            DC_QUIT;
        }

    }

    //
    // We have a valid font. Now sort out delta X issues.
    //

    //
    // If we do not need to send delta X arrays then exit now.
    //
    if (!(g_oeFontCaps & CAPS_FONT_NEED_X_ALWAYS))
    {
        if (!(g_oeFontCaps & CAPS_FONT_NEED_X_SOMETIMES))
        {
            //
            // CAPS_FONT_NEED_X_SOMETIMES and CAPS_FONT_NEED_X_ALWAYS are
            // both not set so we can exit now.  (We do not need a delta X
            // array).
            //
            TRACE_OUT(( "Capabilities eliminated delta X"));
            DC_QUIT;
        }

        //
        // CAPS_FONT_NEED_X_SOMETIMES is set and CAPS_FONT_NEED_X_ALWAYS is
        // not set.  In this case whether we need a delta X is determined
        // by whether the font is an exact match or an approximate match
        // (because of either approximation of name, signature, or aspect
        // ratio).  We can only find this out after we have extracted the
        // font handle from the existing order.
        //
    }

    //
    // If the string is a single character (or less) then we can just
    // return.
    //
    if (textLen <= 1)
    {
        TRACE_OUT(( "String only %lu long", textLen));
        DC_QUIT;
    }

    //
    // Capabilities allow us to ignore delta X position if we have an exact
    // match.
    //
    if ((matchQuality & FH_SC_EXACT) != 0)
    {
        //
        // Exit immediately, providing that there is no override to always
        // send increments.
        //
        if (!(g_oeFontCaps & CAPS_FONT_NEED_X_ALWAYS))
        {
            TRACE_OUT(( "Font has exact match"));
            DC_QUIT;
        }
    }

    //
    // We have passed all the checks - we must send a delta X array.
    //
    TRACE_OUT(( "Must send delta X"));
    *pSendDeltaX = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(OECheckFontIsSupported, rc);
    return(rc);
}


//
// Function:    OELPtoVirtual
//
// Description: Adjusts window coordinates to virtual desktop coordinates.
//              Clips the result to [+32766, -32768].
//
// Parameters:  pPoints - Array of points to be converted
//              cPoints - Number of points to be converted
//
// Returns:     (none)
//
void  OELPtoVirtual
(
    LPPOINT aPts,
    UINT    cPts
)
{
    int         l;
    TSHR_INT16  s;

    DebugEntry(OELPtoVirtual);

    //
    // Convert to screen coordinates
    //
    while (cPts > 0)
    {
        //
        // Look for int16 overflow in the X coordinate
        //
        l = aPts->x;
        s = (TSHR_INT16)l;

        if (l == (int)s)
        {
            aPts->x = s;
        }
        else
        {
            //
            // HIWORD(l) will be 1 for positive overflow, 0xFFFF for
            // negative overflow.  Therefore we will get 0x7FFE or 0x8000
            // (+32766 or -32768).
            //
            aPts->x = 0x7FFF - HIWORD(l);
            TRACE_OUT(("adjusted X from %ld to %d", l, aPts->x));
        }

        //
        // Look for int16 overflow in the Y coordinate
        //
        l = aPts->y;
        s = (TSHR_INT16)l;

        if (l == (int)s)
        {
            aPts->y = s;
        }
        else
        {
            //
            // HIWORD(l) will be 1 for positive overflow, 0xFFFF for
            // negative overflow.  Therefore we will get 0x7FFE or 0x8000
            // (+32766 or -32768).
            //
            aPts->y = 0x7FFF - HIWORD(l);
            TRACE_OUT(("adjusted Y from %ld to %d", l, aPts->y));
        }

        //
        // Move on to the next point
        //
        --cPts;
        ++aPts;
    }

    DebugExitVOID(OELPtoVirtual);
}


//
// Function:    OELRtoVirtual
//
// Description: Adjusts RECT in window coordinates to virtual coordinates.
//              Clips the result to [+32766, -32768].
//
// Parameters:  pRects  - Array of rects to be converted
//              numRects  - Number of rects to be converted
//
// Returns:     (none)
//
// NB.  This function takes a Windows rectangle (exclusive coords) and
//      returns a DC-Share rectangle (inclusive coords).
//
void OELRtoVirtual
(
    LPRECT  aRects,
    UINT    cRects
)
{
    DebugEntry(OELRtoVirtual);

    //
    // Convert the points to screen coords, clipping to INT16s
    //
    OELPtoVirtual((LPPOINT)aRects, 2 * cRects);

    //
    // Make each rectangle inclusive
    //
    while (cRects > 0)
    {
        aRects->right--;
        aRects->bottom--;

        //
        // Move on to the next rect
        //
        cRects--;
        aRects++;
    }

    DebugExitVOID(OELRtoVirtual);
}


//
// Function:    OEClipAndAddOrder
//
// Description: Adds the order to the order buffer, splitting it up into
//              multiple orders if the clipping is complicated.  If we fail
//              to send the full order, we accumulate it in the SDA instead
//
// Parameters:  pOrder     - Order to be stored.
//              pExtraInfo - Pointer to extra data associated with the
//                           order.  This data depends on the order type,
//                           and may be NULL.
//              pco        - Clipping object for the area
//
// Returns:     (none)
//
void   OEClipAndAddOrder(LPINT_ORDER pOrder,
                                             void *    pExtraInfo,
                                             CLIPOBJ*   pco)
{
    BOOL             fOrderClipped;
    BOOL             fMoreRects;
    RECT             clippedRect;
    RECT             orderRect;
    LPINT_ORDER         pNewOrder;
    LPINT_ORDER         pLastOrder = NULL;
    OE_ENUMRECTS       clip;
    UINT             i;
    UINT             numRects = 0;

    DebugEntry(OEClipAndAddOrder);

    //
    // Convert the order rectangle passed in (in virtual co-ordinates) back
    // to screen co-ordinates.  It is going to be clipped against clip
    // rectangles returned to us in screen co-ordinates.
    //
    // Note that we also convert to exclusive coords here to make
    // comparison with the exclusive Windows coords easier.
    //
    orderRect.left   = pOrder->OrderHeader.Common.rcsDst.left;
    orderRect.top    = pOrder->OrderHeader.Common.rcsDst.top;
    orderRect.right  = pOrder->OrderHeader.Common.rcsDst.right + 1;
    orderRect.bottom = pOrder->OrderHeader.Common.rcsDst.bottom + 1;
    fOrderClipped    = FALSE;

    TRACE_OUT(( "orderRect: (%d,%d)(%d,%d)",
                 orderRect.left,
                 orderRect.top,
                 orderRect.right,
                 orderRect.bottom));

    //
    // Check if we have a clipping object at all.
    //
    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
    {
        //
        // No clipping object - just use the bounds
        //
        clippedRect   = orderRect;
        fOrderClipped = TRUE;
        pLastOrder    = pOrder;
    }
    else if (pco->iDComplexity == DC_RECT)
    {
        //
        // One clipping rectangle - use it directly.
        //
        RECT_FROM_RECTL(clippedRect, pco->rclBounds);
        clippedRect.left   = max(clippedRect.left,   orderRect.left);
        clippedRect.bottom = min(clippedRect.bottom, orderRect.bottom);
        clippedRect.right  = min(clippedRect.right,  orderRect.right);
        clippedRect.top    = max(clippedRect.top,    orderRect.top);
        fOrderClipped = TRUE;
        pLastOrder     = pOrder;
    }
    else
    {
        //
        // OA can only cope as long as the orders are added in the same
        // order that they were allocated, so we need to do a little
        // shuffling here.
        //
        // We always keep one order outstanding (pLastOrder) and a flag to
        // indicate if it is valid (fOrderClipped).  The first time we find
        // a valid clipping rectangle, we set up pLastOrder and
        // fOrderClipped.  If we find we need to allocate a new order, we
        // request the memory for the new order (pNewOrder), add pLastOrder
        // and store pNewOrder in pLastOrder.
        //
        // Once we have finished enumerating the clipping rectangles, if
        // pLastOrder is valid, we add it in.
        //
        // Also, while we are adding all these orders, OA must not purge
        // the order heap otherwise we'll be left holding an invalid
        // pointer.
        //
        pNewOrder = pOrder;
        g_oaPurgeAllowed = FALSE;

        //
        // Multiple clipping rectangles - Enumerate all the rectangles
        // involved in this drawing operation.
        // The documentation for this function incorrectly states that
        // the returned value is the total number of rectangles
        // comprising the clip region. In fact, -1 is always returned,
        // even when the final parameter is non-zero.
        //
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        //
        // Get the clip rectangles. We fetch these into the clip buffer
        // which is big enough to get all the clip rectangles we expect + 1.
        // If the order runs across this number of clip rects or more then
        // we will already have decided to send it as screen data.
        // The clip rectangle fetching is contained within a loop because,
        // while we expect to call CLIPOBJ_bEnum once only, it is possible
        // for this functio to return zero rects and report that there are
        // more to fetch (according to MSDN).
        //
        do
        {
            fMoreRects = CLIPOBJ_bEnum(pco,
                                       sizeof(clip),
                                       (ULONG *)&clip.rects);

            //
            // The clipping object can decide that there are no more
            // rectangles and that this query has returned no rectangles,
            // so we must check for any valid data in the returned
            // rectangle list.
            //
            if (clip.rects.c == 0)
            {
                //
                // We didn't get any rects this time so go round again - if
                // we're finished, the loop termination condition will take
                // us out. CLIPOBJ_bEnum can return a count of zero when
                // there are still more rects.
                //
                TRACE_OUT(( "No rects this time, more %u", fMoreRects));
                continue;
            }

            //
            // To get to here we expect to have fetched all the rects and
            // no more. Do a quick check.
            //
            numRects += clip.rects.c;
            ASSERT( (numRects <= COMPLEX_CLIP_RECT_COUNT) );

            //
            // Process each clip rectangle by clipping the drawing order to
            // it.
            //
            for ( i = 0; i < clip.rects.c; i++ )
            {
                TRACE_OUT(( "  (%d,%d)(%d,%d)",
                             clip.rects.arcl[i].left,
                             clip.rects.arcl[i].top,
                             clip.rects.arcl[i].right,
                             clip.rects.arcl[i].bottom));

                //
                // Check for an intersection
                //
                if ( (clip.rects.arcl[i].left >= orderRect.right)  ||
                     (clip.rects.arcl[i].bottom <= orderRect.top)    ||
                     (clip.rects.arcl[i].right <= orderRect.left)   ||
                     (clip.rects.arcl[i].top >= orderRect.bottom) )
                {
                    //
                    // No intersection, move on to next clip rect.
                    //
                    continue;
                }

                //
                // There is an intersection, so we may need to add a new
                // order to the buffer to cater for this rectangle.
                //
                if (fOrderClipped)
                {
                    //
                    // The order has already been clipped once, so it
                    // actually intersects more than one clip rect, ie
                    // fOrderClipped is always FALSE for at least the first
                    // clip rectangle in the clip.rects buffer.  We cope
                    // with this by duplicating the order and clipping it
                    // again.
                    //
                    pNewOrder = OA_DDAllocOrderMem(
                         pLastOrder->OrderHeader.Common.cbOrderDataLength, 0);

                    if (pNewOrder == NULL)
                    {
                        WARNING_OUT(( "Order memory allocation failed" ));
                        goto CLIP_ORDER_FAILED;
                    }

                    //
                    // Copy the header & data from the original order to
                    // the new order (making sure that we don't overwrite
                    // the list information at the start of the header).
                    //
                    memcpy((LPBYTE)pNewOrder
                                    + FIELD_SIZE(INT_ORDER, OrderHeader.list),
                              (LPBYTE)pLastOrder
                                    + FIELD_SIZE(INT_ORDER, OrderHeader.list),
                              pLastOrder->OrderHeader.Common.cbOrderDataLength
                                    + sizeof(INT_ORDER_HEADER)
                                    - FIELD_SIZE(INT_ORDER, OrderHeader.list));

                    //
                    // Set the destination (clip) rectangle (in virtual
                    // desktop coordinates).
                    //
                    TSHR_RECT16_FROM_RECT(
                                       &pLastOrder->OrderHeader.Common.rcsDst,
                                       clippedRect);

                    pLastOrder->OrderHeader.Common.rcsDst.right -= 1;
                    pLastOrder->OrderHeader.Common.rcsDst.bottom -= 1;

                    TRACE_OUT(( "Adding duplicate order  (%d,%d) (%d,%d)",
                               pLastOrder->OrderHeader.Common.rcsDst.left,
                               pLastOrder->OrderHeader.Common.rcsDst.top,
                               pLastOrder->OrderHeader.Common.rcsDst.right,
                               pLastOrder->OrderHeader.Common.rcsDst.bottom));

                    //
                    // Add the order to the Order List.
                    //
                    OA_DDAddOrder(pLastOrder, pExtraInfo);
                }

                //
                // Update the clipping rectangle for the order to be sent.
                //
                clippedRect.left  = max(clip.rects.arcl[i].left,
                                           orderRect.left);
                clippedRect.bottom= min(clip.rects.arcl[i].bottom,
                                           orderRect.bottom);
                clippedRect.right = min(clip.rects.arcl[i].right,
                                           orderRect.right);
                clippedRect.top   = max(clip.rects.arcl[i].top,
                                           orderRect.top);
                fOrderClipped     = TRUE;
                pLastOrder        = pNewOrder;
            }
        } while (fMoreRects);
    }

    //
    // Check whether the clipping has removed the order entirely.
    //
    if (fOrderClipped)
    {
        TSHR_RECT16_FROM_RECT(&pLastOrder->OrderHeader.Common.rcsDst,
                                clippedRect);

        pLastOrder->OrderHeader.Common.rcsDst.right -= 1;
        pLastOrder->OrderHeader.Common.rcsDst.bottom -= 1;

        TRACE_OUT(( "Adding order  (%d,%d) (%d,%d)",
                    pLastOrder->OrderHeader.Common.rcsDst.left,
                    pLastOrder->OrderHeader.Common.rcsDst.top,
                    pLastOrder->OrderHeader.Common.rcsDst.right,
                    pLastOrder->OrderHeader.Common.rcsDst.bottom));

        //
        // Add the order to the Order List.
        //
        OA_DDAddOrder(pLastOrder, pExtraInfo);
    }
    else
    {

        TRACE_OUT(( "Order clipped completely"));
        OA_DDFreeOrderMem(pOrder);
    }

    DC_QUIT;


CLIP_ORDER_FAILED:
    //
    // Allocation of memory for a duplicate order failed.  Just add the
    // original order's destination rect into the SDA and free the order.
    //
    // The order rectangle is already in inclusive virtual coordinates.
    //
    TRACE_OUT(( "Order add failed, add to SDA"));
    RECT_FROM_TSHR_RECT16(&orderRect,pLastOrder->OrderHeader.Common.rcsDst);
    OA_DDFreeOrderMem(pLastOrder);
    BA_AddScreenData(&orderRect);

DC_EXIT_POINT:
    //
    // Make sure that we always re-enable heap purging.
    //
    g_oaPurgeAllowed = TRUE;

    DebugExitVOID(OEClipAndAddOrder);
}


//
// Function:    OEClipAndAddScreenData
//
// Description: Determines if we need to accumulate any screen data for the
//              specified area.  If so, it is added to the SDA.
//
// Parameters:  pRect - Bounding rectangle of area to be accumulated
//              pco   - Clipping object for the area
//
// Returns:     (none)
//
void   OEClipAndAddScreenData(LPRECT pRect, CLIPOBJ* pco)
{
    RECT    SDACandidate;
    BOOL    fMoreRects;
    RECT    clippedRect;
    OE_ENUMRECTS clip;
    UINT    i;

    DebugEntry(OEClipAndAddScreenData);

    //
    // Convert the order rectangle passed in (in virtual co-ordinates) back
    // to screen co-ordinates.  It is going to be clipped against clip
    // rectangles returned to us in screen co-ordinates.
    //
    // Note that we also convert to exclusive coords here to make
    // comparison with the exclusive Windows coords easier.
    //
    SDACandidate.left   = pRect->left;
    SDACandidate.top    = pRect->top;
    SDACandidate.right  = pRect->right + 1;
    SDACandidate.bottom = pRect->bottom + 1;

    TRACE_OUT(( "SDACandidate: (%d,%d)(%d,%d)",
                 SDACandidate.left,
                 SDACandidate.top,
                 SDACandidate.right,
                 SDACandidate.bottom));

    //
    // Check if we have a clipping object at all.
    //
    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
    {
        //
        // Convert the clipped rect into Virtual Desktop coords.
        //
        clippedRect         = SDACandidate;
        clippedRect.right  -= 1;
        clippedRect.bottom -= 1;

        //
        // Add the clipped rect into the SDA.
        //
        TRACE_OUT(( "Adding SDA (%d,%d)(%d,%d)", clippedRect.left,
                                                  clippedRect.top,
                                                  clippedRect.right,
                                                  clippedRect.bottom));

        BA_AddScreenData(&clippedRect);
    }
    else if (pco->iDComplexity == DC_RECT)
    {
        //
        // One clipping rectangle - use it directly, converting into
        // Virtual Desktop coords. Make sure the rectangle is valid before
        // adding to the SDA.
        //
        RECT_FROM_RECTL(clippedRect, pco->rclBounds);
        clippedRect.left = max(clippedRect.left, SDACandidate.left);
        clippedRect.right = min(clippedRect.right, SDACandidate.right) + -1;

        if ( clippedRect.left <= clippedRect.right )
        {
            clippedRect.bottom = min(clippedRect.bottom,
                                        SDACandidate.bottom) + -1;
            clippedRect.top = max(clippedRect.top, SDACandidate.top);

            if ( clippedRect.bottom >= clippedRect.top )
            {
                //
                // Add the clipped rect into the SDA.
                //
                TRACE_OUT(( "Adding SDA RECT (%d,%d)(%d,%d)",
                                                         clippedRect.left,
                                                         clippedRect.top,
                                                         clippedRect.right,
                                                         clippedRect.bottom));
                BA_AddScreenData(&clippedRect);
            }
        }
    }
    else
    {
        //
        // Enumerate all the rectangles involved in this drawing operation.
        // The documentation for this function incorrectly states that
        // the returned value is the total number of rectangles
        // comprising the clip region. In fact, -1 is always returned,
        // even when the final parameter is non-zero.
        //
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        do
        {
            //
            // Get the next batch of clipping rectangles
            //
            fMoreRects = CLIPOBJ_bEnum(pco,
                                       sizeof(clip),
                                       (ULONG *)&clip.rects);

            for ( i = 0; i < clip.rects.c; i++ )
            {
                TRACE_OUT(( "  (%d,%d)(%d,%d)",
                             clip.rects.arcl[i].left,
                             clip.rects.arcl[i].top,
                             clip.rects.arcl[i].right,
                             clip.rects.arcl[i].bottom));

                //
                // Intersect the SDA rect with the clip rect, checking for
                // no intersection.
                //
                clippedRect.left  = max( clip.rects.arcl[i].left,
                                            SDACandidate.left );
                clippedRect.right = min( clip.rects.arcl[i].right,
                                            SDACandidate.right );

                if (clippedRect.left >= clippedRect.right)
                {
                    //
                    // No horizontal intersection.
                    //
                    continue;
                }

                clippedRect.bottom = min( clip.rects.arcl[i].bottom,
                                             SDACandidate.bottom );
                clippedRect.top    = max( clip.rects.arcl[i].top,
                                             SDACandidate.top );

                if (clippedRect.top >= clippedRect.bottom)
                {
                    //
                    // No vertical intersection.
                    //
                    continue;
                }

                //
                // Convert the clipped rect into Virtual Desktop coords.
                //
                clippedRect.right  -= 1;
                clippedRect.bottom -= 1;

                //
                // Add the clipped rect into the SDA.
                //
                TRACE_OUT(( "Adding SDA (%d,%d)(%d,%d)",
                             clippedRect.left,
                             clippedRect.top,
                             clippedRect.right,
                             clippedRect.bottom));

                BA_AddScreenData(&clippedRect);
            }
        } while (fMoreRects);
    }

    DebugExitVOID(OEClipAndAddScreenData);
}





//
// FUNCTION:    OEDDSetNewFonts
//
// DESCRIPTION:
//
// Set the new font handling information to be used by the display driver.
//
// RETURNS:
//
// NONE
//
//
void  OEDDSetNewFonts(LPOE_NEW_FONTS pRequest)
{
    UINT    cbNewSize;

    DebugEntry(OEDDSetNewFonts);

    TRACE_OUT(( "New fonts %d", pRequest->countFonts));

    //
    // Initialize new number of fonts to zero in case an error happens.
    // We don't want to use stale font info if so.
    //
    g_oeNumFonts = 0;

    g_oeFontCaps = pRequest->fontCaps;

    //
    // Free our previous font block if we had one.
    //
    if (g_poeLocalFonts)
    {
        EngFreeMem(g_poeLocalFonts);
        g_poeLocalFonts = NULL;
    }

    //
    // Alloc a new one, the size of the new font block.
    //
    cbNewSize = pRequest->countFonts * sizeof(LOCALFONT);
    g_poeLocalFonts = EngAllocMem(0, cbNewSize, OSI_ALLOC_TAG);
    if (! g_poeLocalFonts)
    {
        ERROR_OUT(("OEDDSetNewFonts: can't allocate space for font info"));
        DC_QUIT;
    }

    //
    // OK, if we're here, this is going to succeed.  Copy the info over.
    //
    g_oeNumFonts = pRequest->countFonts;

    memcpy(g_poeLocalFonts, pRequest->fontData, cbNewSize);

    memcpy(g_oeLocalFontIndex, pRequest->fontIndex,
              sizeof(g_oeLocalFontIndex[0]) * FH_LOCAL_INDEX_SIZE);

DC_EXIT_POINT:
    DebugExitVOID(OEDDSetNewFonts);
}


//
// FUNCTION:    OEDDSetNewCapabilities
//
// DESCRIPTION:
//
// Set the new OE related capabilities
//
// RETURNS:
//
// NONE
//
// PARAMETERS:
//
// pDataIn  - pointer to the input buffer
//
//
void  OEDDSetNewCapabilities(LPOE_NEW_CAPABILITIES pCapabilities)
{
    DebugEntry(OEDDSetNewCapabilities);

    //
    // Copy the data from the Share Core.
    //
    g_oeBaselineTextEnabled = pCapabilities->baselineTextEnabled;

    g_oeSendOrders          = pCapabilities->sendOrders;

    g_oeTextEnabled         = pCapabilities->textEnabled;

    //
    // The share core has passed down a pointer to it's copy of the order
    // support array.  We take a copy for the kernel here.
    //
    memcpy(g_oeOrderSupported,
              pCapabilities->orderSupported,
              sizeof(g_oeOrderSupported));

    TRACE_OUT(( "OE caps: BLT %c Orders %c Text %c",
                 g_oeBaselineTextEnabled ? 'Y': 'N',
                 g_oeSendOrders ? 'Y': 'N',
                 g_oeTextEnabled ? 'Y': 'N'));

    DebugExitVOID(OEDDSetNewCapabilities);
}


//
// Function:    OETileBitBltOrder
//
// Description: Divides a single large BitBlt order into a series of small,
//              "tiled" BitBlt orders, each of which is added to the order
//              queue.
//
// Parameters:  pOrder     - Template order to be tiled
//              pExtraInfo - Structure containing pointers to the source
//                           and destination surface objects, and a pointer
//                           to the color translation object for the Blt
//              pco        - Clipping object for the operation
//
// Returns:     TRUE - Stored in orders (and possibly some SDA)
//              FALSE- Stored in SDA (or contained bad data)
//
//
void   OETileBitBltOrder
(
    LPINT_ORDER                 pOrder,
    LPMEMBLT_ORDER_EXTRA_INFO   pExtraInfo,
    CLIPOBJ*                    pco
)
{
    UINT        tileWidth;
    UINT        tileHeight;
    int         srcLeft;
    int         srcTop;
    int         srcRight;
    int         srcBottom;
    int         xFirstTile;
    int         yFirstTile;
    int         xTile;
    int         yTile;
    UINT        type;
    int         bmpWidth, bmpHeight;
    RECT        destRect;

    DebugEntry(OETileBitBltOrder);

    //
    // Extract the src bitmap handle from the Order - if the order is not a
    // memory to screen blit, we get out now.
    //
    type = ((LPMEMBLT_ORDER)pOrder->abOrderData)->type;
    switch (type)
    {
        case ORD_MEMBLT_TYPE:
        {
            srcLeft   = ((LPMEMBLT_ORDER)pOrder->abOrderData)->nXSrc;
            srcTop    = ((LPMEMBLT_ORDER)pOrder->abOrderData)->nYSrc;
            srcRight  = srcLeft +
                       ((LPMEMBLT_ORDER)pOrder->abOrderData)->nWidth;
            srcBottom = srcTop +
                       ((LPMEMBLT_ORDER)pOrder->abOrderData)->nHeight;
            destRect.left  = ((LPMEMBLT_ORDER)pOrder->abOrderData)->nLeftRect;
            destRect.top   = ((LPMEMBLT_ORDER)pOrder->abOrderData)->nTopRect;
            destRect.right = destRect.left +
                ((LPMEMBLT_ORDER)pOrder->abOrderData)->nWidth;
            destRect.bottom= destRect.top +
                ((LPMEMBLT_ORDER)pOrder->abOrderData)->nHeight;
        }
        break;

        case ORD_MEM3BLT_TYPE:
        {
            srcLeft   = ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nXSrc;
            srcTop    = ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nYSrc;
            srcRight  = srcLeft +
                       ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nWidth;
            srcBottom = srcTop +
                       ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nHeight;

            destRect.left = ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nLeftRect;
            destRect.top  = ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nTopRect;
            destRect.right= destRect.left +
                            ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nWidth;
            destRect.bottom = destRect.top +
                            ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nHeight;
        }
        break;

        default:
        {
            ERROR_OUT(( "Invalid order type %u", type));
        }
        break;
    }

    //
    // Fetch the bitmap details.
    //
    bmpWidth  = (int)pExtraInfo->pSource->sizlBitmap.cx;
    bmpHeight = (int)pExtraInfo->pSource->sizlBitmap.cy;

    if (!SBC_DDQueryBitmapTileSize(bmpWidth, bmpHeight, &tileWidth, &tileHeight))
    {
        //
        // This could happen if some 2.x user joins the share.
        //
        TRACE_OUT(("Bitmap is not tileable"));
        OEClipAndAddScreenData(&destRect, pco);
    }
    else
    {
        //
        // Tile the order.  If an individual tile fails to get queued as an
        // order, OEAddTiledBitBltOrder() will add it as screen data.  Hence
        // no return value to be checked.
        //
        xFirstTile = srcLeft - (srcLeft % tileWidth);
        yFirstTile = srcTop - (srcTop % tileHeight);

        for (yTile = yFirstTile; yTile < srcBottom; yTile += tileHeight)
        {
            for (xTile = xFirstTile; xTile < srcRight; xTile += tileWidth)
            {
                OEAddTiledBitBltOrder(pOrder, pExtraInfo, pco, xTile, yTile,
                    tileWidth,  tileHeight);
            }
        }
    }

    DebugExitVOID(OETileBitBltOrder);
}



//
// Function:    OEAddTiledBitBltOrder
//
// Description: Takes an unmodified "large" BitBlt and a tile rectangle,
//              makes a copy of the order and modifies the copied order's
//              src/dest so it applies to the source tile only. The order
//              is added to the order queue.  If the allocation of the
//              "tiled" order fails, the destination rect is added to SDA
//
// Parameters:  pOrder     - Template order to be added
//              pExtraInfo - Pointer to the extra BitBlt info
//              pco        - Clipping object for the BitBlt
//              xTile      - X position of the tile
//              yTile      - Y position of the tile
//              tileWidth  - tile width
//              tileHeight - tile height
//
// Returns:     none
//
//
void   OEAddTiledBitBltOrder(
                                         LPINT_ORDER               pOrder,
                                         LPMEMBLT_ORDER_EXTRA_INFO pExtraInfo,
                                         CLIPOBJ*                 pco,
                                         int                  xTile,
                                         int                  yTile,
                                         UINT                 tileWidth,
                                         UINT                 tileHeight)
{
    LPINT_ORDER pTileOrder;
    LPINT  pXSrc   = NULL;
    LPINT  pYSrc   = NULL;
    LPINT  pLeft   = NULL;
    LPINT  pTop    = NULL;
    LPINT  pWidth  = NULL;
    LPINT  pHeight = NULL;
    RECT    srcRect;
    RECT    destRect;
    UINT  type;

    DebugEntry(OETileAndAddBitBltOrder);

    //
    // This is a trusted interface - assume the type is correct
    //
    type = ((LPMEMBLT_ORDER)pOrder->abOrderData)->type;
    ASSERT(((type == ORD_MEMBLT_TYPE) || (type == ORD_MEM3BLT_TYPE)));

    //
    // Do processing which depends on the type of bit blt being tiled:
    // - save existing src and dest rects
    // - make a copy of the order (which will be the tile order)
    // - save pointers to the fields in the tile order which we're likely
    //   to change.
    //
    if (type == ORD_MEMBLT_TYPE)
    {
        srcRect.left  = ((LPMEMBLT_ORDER)pOrder->abOrderData)->nXSrc;
        srcRect.top   = ((LPMEMBLT_ORDER)pOrder->abOrderData)->nYSrc;
        srcRect.right = srcRect.left +
                        ((LPMEMBLT_ORDER)pOrder->abOrderData)->nWidth;
        srcRect.bottom = srcRect.top +
                        ((LPMEMBLT_ORDER)pOrder->abOrderData)->nHeight;
        destRect.left = ((LPMEMBLT_ORDER)pOrder->abOrderData)->nLeftRect;
        destRect.top  = ((LPMEMBLT_ORDER)pOrder->abOrderData)->nTopRect;

        //
        // We must allocate enough space for the maximum size order that
        // SBC may use (i.e.  an R2 order).  We default to filling in the
        // data as an R1 order.
        //
        pTileOrder = OA_DDAllocOrderMem(sizeof(MEMBLT_R2_ORDER),0);
        if (pTileOrder == NULL)
        {
            TRACE_OUT(( "No space for tile order"));
            DC_QUIT;
        }

        //
        // We must not mess up the linked list data in the orders.
        //
        RtlCopyMemory(((LPBYTE)pTileOrder) +
                                       FIELD_SIZE(INT_ORDER, OrderHeader.list),
                      ((LPBYTE)pOrder)     +
                                       FIELD_SIZE(INT_ORDER, OrderHeader.list),
                      sizeof(INT_ORDER_HEADER)
                                    + sizeof(MEMBLT_R2_ORDER)
                                    - FIELD_SIZE(INT_ORDER, OrderHeader.list));

        pXSrc   = &((LPMEMBLT_ORDER)pTileOrder->abOrderData)->nXSrc;
        pYSrc   = &((LPMEMBLT_ORDER)pTileOrder->abOrderData)->nYSrc;
        pWidth  = &((LPMEMBLT_ORDER)pTileOrder->abOrderData)->nWidth;
        pHeight = &((LPMEMBLT_ORDER)pTileOrder->abOrderData)->nHeight;
        pLeft   = &((LPMEMBLT_ORDER)pTileOrder->abOrderData)->nLeftRect;
        pTop    = &((LPMEMBLT_ORDER)pTileOrder->abOrderData)->nTopRect;
    }
    else
    {
        srcRect.left  = ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nXSrc;
        srcRect.top   = ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nYSrc;
        srcRect.right = srcRect.left +
                        ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nWidth;
        srcRect.bottom = srcRect.top +
                        ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nHeight;
        destRect.left = ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nLeftRect;
        destRect.top  = ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nTopRect;

        //
        // We must allocate enough space for the maximum size order that
        // SBC may use (i.e.  an R2 order).  We default to filling in the
        // data as an R1 order.
        //
        pTileOrder = OA_DDAllocOrderMem(sizeof(MEM3BLT_R2_ORDER),0);
        if (pTileOrder == NULL)
        {
            TRACE_OUT(( "No space for tile order"));
            DC_QUIT;
        }

        //
        // We must not mess up the linked list data in the orders.
        //
        RtlCopyMemory(((LPBYTE)pTileOrder) +
                                       FIELD_SIZE(INT_ORDER, OrderHeader.list),
                      ((LPBYTE)pOrder)     +
                                       FIELD_SIZE(INT_ORDER, OrderHeader.list),
                      sizeof(INT_ORDER_HEADER)
                                    + sizeof(MEM3BLT_R2_ORDER)
                                    - FIELD_SIZE(INT_ORDER, OrderHeader.list));

        pXSrc   = &((LPMEM3BLT_ORDER)pTileOrder->abOrderData)->nXSrc;
        pYSrc   = &((LPMEM3BLT_ORDER)pTileOrder->abOrderData)->nYSrc;
        pWidth  = &((LPMEM3BLT_ORDER)pTileOrder->abOrderData)->nWidth;
        pHeight = &((LPMEM3BLT_ORDER)pTileOrder->abOrderData)->nHeight;
        pLeft   = &((LPMEM3BLT_ORDER)pTileOrder->abOrderData)->nLeftRect;
        pTop    = &((LPMEM3BLT_ORDER)pTileOrder->abOrderData)->nTopRect;
    }

    TRACE_OUT(( "Tiling order, orig srcLeft=%hd, srcTop=%hd, srcRight=%hd, "
           "srcBottom=%hd, destX=%hd, destY=%hd; "
           "xTile=%hd, yTile=%hd, tileW=%hd, tileH=%hd",
           srcRect.left, srcRect.top, srcRect.right, srcRect.bottom,
           destRect.left, destRect.top,
           xTile, yTile, tileWidth, tileHeight));

DC_EXIT_POINT:
    //
    // NOTE: ALL THE POINTERS MAY BE NULL AT THIS POINT - DO NOT USE THEM
    // UNTIL YOU VERIFY PTILEORDER IS NON-NULL.
    //
    // Intersect source and tile rects, and set up destination rect
    // accordingly - we need to do this even if we failed to copy the
    // order, because the tiled source rect will have to be added to the
    // screen data area.
    //
    if (xTile > srcRect.left)
    {
        destRect.left += (xTile - srcRect.left);
        srcRect.left = xTile;
    }

    if (yTile > srcRect.top)
    {
        destRect.top += (yTile - srcRect.top);
        srcRect.top = yTile;
    }

    srcRect.right  = min((UINT)srcRect.right, xTile + tileWidth);
    srcRect.bottom = min((UINT)srcRect.bottom, yTile + tileHeight);

    destRect.right  = destRect.left + (srcRect.right - srcRect.left);
    destRect.bottom = destRect.top + (srcRect.bottom - srcRect.top);

    //
    // If the order was successfully copied above, then modify the order
    // to contain the tiled coordinates, and add it to the order list.
    // Otherwise, send the dest rect as screen data.
    //
    if (pTileOrder != NULL)
    {
        TRACE_OUT(( "Tile order originally: srcX=%hd, srcY=%hd, destX=%hd, "
               "destY=%hd, w=%hd, h=%hd",
               *pXSrc, *pYSrc, *pLeft, *pTop, *pWidth, *pHeight));

        *pXSrc = srcRect.left;
        *pYSrc = srcRect.top;
        *pLeft = destRect.left;
        *pTop  = destRect.top;
        *pWidth = srcRect.right - srcRect.left;
        *pHeight = srcRect.bottom - srcRect.top;

        pTileOrder->OrderHeader.Common.rcsDst.left = (TSHR_INT16)destRect.left;
        pTileOrder->OrderHeader.Common.rcsDst.right = (TSHR_INT16)destRect.right;
        pTileOrder->OrderHeader.Common.rcsDst.top = (TSHR_INT16)destRect.top;
        pTileOrder->OrderHeader.Common.rcsDst.bottom =
                                                     (TSHR_INT16)destRect.bottom;

        TRACE_OUT(( "Adding order srcX=%hd, srcY=%hd, destX=%hd, destY=%hd,"
               " w=%hd, h=%hd",
               *pXSrc, *pYSrc, *pLeft, *pTop, *pWidth, *pHeight));
        OEClipAndAddOrder(pTileOrder, pExtraInfo, pco);
    }
    else
    {
        TRACE_OUT(( "Failed to allocate order - sending as screen data"));
        OEClipAndAddScreenData(&destRect, pco);
    }

    DebugExitVOID(OETileAndAddBitBltOrder);
}



// NAME:      OEAddLine
//
// PURPOSE:
//
// Add a LineTo order to the order heap.
//
// RETURNS:
//
// TRUE  - Attempted to add to heap
// FALSE - No room left to allocate an order
//
// PARAMS:
//
// ppdev      - display driver PDEV
// startPoint - start point of line
// endPoint   - end point of line
// rectDst    - bounding rectangle
// rop2       - ROP2 to use with line
// width      - width of line to add
// color      - color of line to add
// pco        - clipping object for drawing operation
//
BOOL  OEAddLine(LPOSI_PDEV ppdev,
                    LPPOINT  startPoint,
                    LPPOINT  endPoint,
                                    LPRECT   rectDst,
                                    UINT  rop2,
                                    UINT  width,
                                    UINT  color,
                                    CLIPOBJ*  pco)
{
    BOOL         rc = FALSE;
    LPLINETO_ORDER pLineTo;
    LPINT_ORDER     pOrder;

    DebugEntry(OEAddLine);

    //
    // Allocate the memory for the order.
    //
    pOrder = OA_DDAllocOrderMem(sizeof(LINETO_ORDER),0);
    if (pOrder == NULL)
    {
        TRACE_OUT(( "Failed to alloc order"));
        DC_QUIT;
    }
    pLineTo = (LPLINETO_ORDER)pOrder->abOrderData;

    //
    // Mark this order type.
    //
    pLineTo->type = ORD_LINETO_TYPE;

    //
    // Store the line end coordinates.
    //
    pLineTo->nXStart   = startPoint->x;
    pLineTo->nYStart   = startPoint->y;
    pLineTo->nXEnd     = endPoint->x;
    pLineTo->nYEnd     = endPoint->y;

    //
    // We must convert these values to virtual coords.
    //
    OELPtoVirtual((LPPOINT)&pLineTo->nXStart, 2);

    //
    // Always do solid lines, so it does not matter what we specify as the
    // back color.
    //
    RtlFillMemory(&pLineTo->BackColor,
                  sizeof(pLineTo->BackColor),
                  0);

    //
    // We only draw solid lines with no option as to what we do to the
    // background, so this is always transparent.
    //
    pLineTo->BackMode  = TRANSPARENT;

    //
    // Get the ROP value.
    //
    pLineTo->ROP2      = rop2;

    //
    // The NT Display Driver is only called to accelerate simple solid
    // lines.  So we only support pen styles of PS_SOLID.
    //
    pLineTo->PenStyle  = PS_SOLID;

    //
    // Get the pen width.
    //
    pLineTo->PenWidth = width;

    //
    // Set up the color.
    //
    OEConvertColor(ppdev,
                   &pLineTo->PenColor,
                   color,
                   NULL);

    TRACE_OUT(( "LineTo BC %02x%02x%02x BM %04X rop2 %02X "
                 "pen %04X %04X %02x%02x%02x x1 %d y1 %d x2 %d y2 %d",
            pLineTo->BackColor.red,
            pLineTo->BackColor.green,
            pLineTo->BackColor.blue,
            pLineTo->BackMode,
            pLineTo->ROP2,
            pLineTo->PenStyle,
            pLineTo->PenWidth,
            pLineTo->PenColor.red,
            pLineTo->PenColor.green,
            pLineTo->PenColor.blue,
            pLineTo->nXStart,
            pLineTo->nYStart,
            pLineTo->nXEnd,
            pLineTo->nYEnd));

    //
    // Store the general order data.  The bounding rectangle must be in to
    // virtual desktop co-ordinates.  OELRtoVirtual has already done this.
    //
    pOrder->OrderHeader.Common.fOrderFlags   = OF_SPOILABLE;
    pOrder->OrderHeader.Common.rcsDst.left   = (TSHR_INT16)rectDst->left;
    pOrder->OrderHeader.Common.rcsDst.right  = (TSHR_INT16)rectDst->right;
    pOrder->OrderHeader.Common.rcsDst.top    = (TSHR_INT16)rectDst->top;
    pOrder->OrderHeader.Common.rcsDst.bottom = (TSHR_INT16)rectDst->bottom;

    //
    // Store that order!
    //
    OEClipAndAddOrder(pOrder, NULL, pco);
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(OEAddLine, rc);
    return(rc);
}


// NAME:      OEEncodePatBlt
//
// PURPOSE:
//
// Attempts to encode a PatBlt order. This function allocates the memory
// for the encoded order (pointer returned in ppOrder). If the function
// completes successfully, it is the caller's responsibility to free this
// memory.
//
// RETURNS:
//
// TRUE  - Order encoded
// FALSE - Order not encoded (so add to SDA)
//
// PARAMS:
//
// ppdev       - display driver PDEV
// pbo         - brush object for the blt
// pptlBrush   - brush origin
// rop3        - 3-way rop to use
// pBounds     - bounding rectangle
// ppOrder     - the encoded order
//
BOOL  OEEncodePatBlt(LPOSI_PDEV   ppdev,
                                         BRUSHOBJ   *pbo,
                                         POINTL     *pptlBrush,
                                         BYTE     rop3,
                                         LPRECT     pBounds,
                                         LPINT_ORDER *ppOrder)
{
    BOOL rc = FALSE;
    POE_BRUSH_DATA pCurrentBrush;
    LPPATBLT_ORDER pPatBlt;
    UINT orderFlags = OF_SPOILABLE;

    DebugEntry(OEEncodePatBlt);

    //
    // Check for a simple brush pattern.
    //
    if ( OECheckBrushIsSimple(ppdev, pbo, &pCurrentBrush) )
    {
        //
        // Allocate the memory for the order.
        //
        *ppOrder = OA_DDAllocOrderMem(sizeof(PATBLT_ORDER),0);
        if (*ppOrder != NULL)
        {
            pPatBlt = (LPPATBLT_ORDER)((*ppOrder)->abOrderData);

            //
            // Set the opaque flag if the rop is opaque.
            //
            if (ROP3_IS_OPAQUE(rop3))
            {
               orderFlags |= OF_SPOILER;
            }

            //
            // Set up order type.
            //
            pPatBlt->type = LOWORD(ORD_PATBLT);

            //
            // Virtual desktop co-ordinates.
            //
            pPatBlt->nLeftRect  = pBounds->left;
            pPatBlt->nTopRect   = pBounds->top;
            pPatBlt->nWidth     = pBounds->right  - pBounds->left + 1;
            pPatBlt->nHeight    = pBounds->bottom - pBounds->top  + 1;
            pPatBlt->bRop       = rop3;

            //
            // Pattern colours.
            //
            pPatBlt->BackColor  = pCurrentBrush->back;
            pPatBlt->ForeColor  = pCurrentBrush->fore;

            //
            // The protocol brush origin is the point on the screen where
            // we want the brush to start being drawn from (tiling where
            // necessary).  This must be in virtual coordinates.
            //
            pPatBlt->BrushOrgX  = pptlBrush->x;
            pPatBlt->BrushOrgY  = pptlBrush->y;
            OELPtoVirtual((LPPOINT)&pPatBlt->BrushOrgX, 1);

            //
            // Extra brush data from the data when we realised the brush.
            //
            pPatBlt->BrushStyle = pCurrentBrush->style;
            pPatBlt->BrushHatch = pCurrentBrush->hatch;

            RtlCopyMemory(pPatBlt->BrushExtra,
                          pCurrentBrush->brushData,
                          sizeof(pPatBlt->BrushExtra));

            TRACE_OUT(( "PatBlt BC %02x%02x%02x FC %02x%02x%02x "
                         "Brush %02X %02X X %d Y %d w %d h %d rop %02X",
                    pPatBlt->BackColor.red,
                    pPatBlt->BackColor.green,
                    pPatBlt->BackColor.blue,
                    pPatBlt->ForeColor.red,
                    pPatBlt->ForeColor.green,
                    pPatBlt->ForeColor.blue,
                    pPatBlt->BrushStyle,
                    pPatBlt->BrushHatch,
                    pPatBlt->nLeftRect,
                    pPatBlt->nTopRect,
                    pPatBlt->nWidth,
                    pPatBlt->nHeight,
                    pPatBlt->bRop));

            //
            // Copy any order flags into the encoded order structure.
            //
            (*ppOrder)->OrderHeader.Common.fOrderFlags = (TSHR_UINT16)orderFlags;

            rc = TRUE;
        }
        else
        {
            TRACE_OUT(( "Failed to alloc order"));
        }
    }
    else
    {
        TRACE_OUT(( "Brush is not simple"));
    }

    DebugExitDWORD(OEEncodePatBlt, rc);
    return(rc);
}




//
// DrvTransparentBlt()
// NEW FOR NT5
//
BOOL DrvTransparentBlt
(
    SURFOBJ *   psoDst,
    SURFOBJ *   psoSrc,
    CLIPOBJ *   pco,
    XLATEOBJ *  pxlo,
    RECTL *     prclDst,
    RECTL *     prclSrc,
    ULONG       iTransColor,
    ULONG       ulReserved
)
{
    BOOL        rc = TRUE;
    RECT        rectSrc;
    RECT        rectDst;
    BOOL        fAccumulate = FALSE;

    DebugEntry(DrvTransparentBlt);

    //
    // DO THIS _BEFORE_ TAKING LOCK
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;

    OE_SHM_START_WRITING;

    //
    // Get bounding rectangle and convert to a RECT.
    //
    RECT_FROM_RECTL(rectSrc, (*prclSrc));
    RECT_FROM_RECTL(rectDst, (*prclDst));


    //
    // Check if we are accumulating data for this function
    //
    fAccumulate = OEAccumulateOutput(psoDst, pco, &rectDst);
    if (!fAccumulate)
    {
        DC_QUIT;
    }

    //
    // Convert to virtual coordinates.
    //
    OELRtoVirtual(&rectDst, 1);

DC_EXIT_POINT:
    if (fAccumulate)
    {
        OEClipAndAddScreenData(&rectDst, pco);
    }

    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    DebugExitBOOL(DrvTransparentBlt, rc);
    return(rc);
}



//
// DrvAlphaBlend()
// NEW FOR NT5
//
BOOL DrvAlphaBlend
(
    SURFOBJ *   psoDst,
    SURFOBJ *   psoSrc,
    CLIPOBJ *   pco,
    XLATEOBJ *  pxlo,
    RECTL *     prclDst,
    RECTL *     prclSrc,
    BLENDOBJ *  pBlendObj
)
{
    BOOL        rc = TRUE;
    RECT        rectSrc;
    RECT        rectDst;
    BOOL        fAccumulate = FALSE;

    DebugEntry(DrvAlphaBlend);

    //
    // DO THIS _BEFORE_ TAKING LOCK
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;

    OE_SHM_START_WRITING;

    //
    // Get bounding rectangle and convert to a RECT.
    //
    RECT_FROM_RECTL(rectSrc, (*prclSrc));
    RECT_FROM_RECTL(rectDst, (*prclDst));


    //
    // Check if we are accumulating data for this function
    //
    fAccumulate = OEAccumulateOutput(psoDst, pco, &rectDst);
    if (!fAccumulate)
    {
        DC_QUIT;
    }

    //
    // Convert to virtual coordinates.
    //
    OELRtoVirtual(&rectDst, 1);

DC_EXIT_POINT:
    if (fAccumulate)
    {
        OEClipAndAddScreenData(&rectDst, pco);
    }

    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    DebugExitBOOL(DrvAlphaBlend, rc);
    return(rc);
}



//
// DrvPlgBlt()
// NEW FOR NT5
//
BOOL DrvPlgBlt
(
    SURFOBJ *           psoDst,
    SURFOBJ *           psoSrc,
    SURFOBJ *           psoMsk,
    CLIPOBJ *           pco,
    XLATEOBJ *          pxlo,
    COLORADJUSTMENT *   pca,
    POINTL *            pptlBrushOrg,
    POINTFIX *          pptfx,
    RECTL *             prclDst,
    POINTL *            pptlSrc,
    ULONG               iMode
)
{
    BOOL        rc = TRUE;
    RECT        rectDst;
    BOOL        fAccumulate = FALSE;

    DebugEntry(DrvPlgBlt);

    //
    // DO THIS _BEFORE_ TAKING LOCK
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;

    OE_SHM_START_WRITING;

    //
    // Get bounding rectangle and convert to a RECT.
    //
    RECT_FROM_RECTL(rectDst, (*prclDst));

    //
    // Check if we are accumulating data for this function
    //
    fAccumulate = OEAccumulateOutput(psoDst, pco, &rectDst);
    if (!fAccumulate)
    {
        DC_QUIT;
    }

    //
    // Convert to virtual coordinates.
    //
    OELRtoVirtual(&rectDst, 1);

DC_EXIT_POINT:
    if (fAccumulate)
    {
        OEClipAndAddScreenData(&rectDst, pco);
    }

    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    DebugExitBOOL(DrvPlgBlt, rc);
    return(rc);
}



//
// DrvStretchBltROP()
// NEW FOR NT5
//
BOOL DrvStretchBltROP
(
    SURFOBJ *           psoDst,
    SURFOBJ *           psoSrc,
    SURFOBJ *           psoMask,
    CLIPOBJ *           pco,
    XLATEOBJ *          pxlo,
    COLORADJUSTMENT *   pca,
    POINTL *            pptlHTOrg,
    RECTL *             prclDst,
    RECTL *             prclSrc,
    POINTL *            pptlMask,
    ULONG               iMode,
    BRUSHOBJ *          pbo,
    DWORD               rop4
)
{
    BOOL        rc = TRUE;
    RECT        rectSrc;
    RECT        rectDst;
    BOOL        fAccumulate = FALSE;

    DebugEntry(DrvStretchBltROP);

    //
    // DO THIS _BEFORE_ TAKING LOCK
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;

    OE_SHM_START_WRITING;

    //
    // Get bounding rectangle and convert to a RECT.
    //
    RECT_FROM_RECTL(rectSrc, (*prclSrc));
    RECT_FROM_RECTL(rectDst, (*prclDst));

    //
    // Check if we are accumulating data for this function
    //
    fAccumulate = OEAccumulateOutput(psoDst, pco, &rectDst);
    if (!fAccumulate)
    {
        DC_QUIT;
    }

    //
    // Convert to virtual coordinates.
    //
    OELRtoVirtual(&rectDst, 1);

DC_EXIT_POINT:
    if (fAccumulate)
    {
        OEClipAndAddScreenData(&rectDst, pco);
    }

    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    DebugExitBOOL(DrvStretchBltROP, rc);
    return(rc);
}



//
// DrvGradientFill()
// NEW FOR NT5
//
BOOL DrvGradientFill
(
    SURFOBJ *       psoDst,
    CLIPOBJ *       pco,
    XLATEOBJ *      pxlo,
    TRIVERTEX *     pVertex,
    ULONG           nVertex,
    PVOID           pMesh,
    ULONG           nMesh,
    RECTL *         prclExtents,
    POINTL *        pptlDitherOrg,
    ULONG           ulMode
)
{
    BOOL        rc = TRUE;
    RECT        rectDst;
    BOOL        fAccumulate = FALSE;

    DebugEntry(DrvGradientFill);

    //
    // DO THIS _BEFORE_ TAKING LOCK
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;

    OE_SHM_START_WRITING;

    //
    // Get bounding rectangle and convert to a RECT.
    //
    RECT_FROM_RECTL(rectDst, pco->rclBounds);

    //
    // Check if we are accumulating data for this function
    //
    fAccumulate = OEAccumulateOutput(psoDst, pco, &rectDst);
    if (!fAccumulate)
    {
        DC_QUIT;
    }

    //
    // Convert to virtual coordinates.
    //
    OELRtoVirtual(&rectDst, 1);

DC_EXIT_POINT:
    if (fAccumulate)
    {
        OEClipAndAddScreenData(&rectDst, pco);
    }

    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    DebugExitBOOL(DrvGradientFill, rc);
    return(rc);
}








=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\dd\precomp.h ===
#include <dcg.h>
#include <ut.h>
#include <dcs.h>
#include <globals.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\dd\het.c ===
#include "precomp.h"


//
// HET.C
// Hosted Entity Tracker, NT Display Driver version
//
// Copyright(c)Microsoft 1997-
//

#include <limits.h>

//
// HET_DDTerm()
//
void HET_DDTerm(void)
{
    LPHET_WINDOW_MEMORY pMem;

    DebugEntry(HET_DDTerm);

    //
    // Clean up any window/graphics tracking stuff
    //
    g_hetDDDesktopIsShared = FALSE;
    HETDDViewing(NULL, FALSE);
    HETDDUnshareAll();


    //
    // Loop through the memory list blocks, freeing each.  Then clear
    // the Window and Free lists.
    //                           
    while (pMem = COM_BasedListFirst(&g_hetMemoryList, FIELD_OFFSET(HET_WINDOW_MEMORY, chain)))
    {
        TRACE_OUT(("HET_DDTerm:  Freeing memory block %lx", pMem));

        COM_BasedListRemove(&(pMem->chain));
        EngFreeMem(pMem);
    }

    //
    // Clear the window linked lists since they contain elements in
    // the now free memory block.
    //
    COM_BasedListInit(&g_hetFreeWndList);
    COM_BasedListInit(&g_hetWindowList);

    DebugExitVOID(HET_DDTerm);
}


//
// HET_DDProcessRequest - see host.h
//
ULONG HET_DDProcessRequest(SURFOBJ  *pso,
                               UINT  cjIn,
                               void *   pvIn,
                               UINT  cjOut,
                               void *   pvOut)
{
    ULONG rc = TRUE;
    LPOSI_ESCAPE_HEADER  pHeader;

    DebugEntry(HET_DDProcessRequest);

    pHeader = pvIn;
    TRACE_OUT(( "Request %#x", pHeader->escapeFn));
    switch (pHeader->escapeFn)
    {
        case HET_ESC_SHARE_WINDOW:
        {
            if ((cjIn != sizeof(HET_SHARE_WINDOW)) ||
                (cjOut != sizeof(HET_SHARE_WINDOW)))
            {
                ERROR_OUT(("HET_DDProcessRequest:  Invalid sizes %d, %d for HET_ESC_SHARE_WINDOW",
                    cjIn, cjOut));
                rc = FALSE;
                DC_QUIT;
            }

            ((LPHET_SHARE_WINDOW)pvOut)->result =
                HETDDShareWindow(pso, (LPHET_SHARE_WINDOW)pvIn);
        }
        break;

        case HET_ESC_UNSHARE_WINDOW:
        {
            if ((cjIn != sizeof(HET_UNSHARE_WINDOW)) ||
                (cjOut != sizeof(HET_UNSHARE_WINDOW)))
            {
                ERROR_OUT(("HET_DDProcessRequest:  Invalid sizes %d, %d for HET_ESC_UNSHARE_WINDOW",
                    cjIn, cjOut));
                rc = FALSE;
                DC_QUIT;
            }

            HETDDUnshareWindow((LPHET_UNSHARE_WINDOW)pvIn);
        }
        break;

        case HET_ESC_UNSHARE_ALL:
        {
            if ((cjIn != sizeof(HET_UNSHARE_ALL)) ||
                (cjOut != sizeof(HET_UNSHARE_ALL)))
            {
                ERROR_OUT(("HET_DDProcessRequest:  Invalid sizes %d, %d for HET_ESC_UNSHARE_ALL",
                    cjIn, cjOut));
                rc = FALSE;
                DC_QUIT;
            }

            HETDDUnshareAll();
        }
        break;

        case HET_ESC_SHARE_DESKTOP:
        {
            if ((cjIn != sizeof(HET_SHARE_DESKTOP)) ||
                (cjOut != sizeof(HET_SHARE_DESKTOP)))
            {
                ERROR_OUT(("HET_DDProcessRequest:  Invalid sizes %d, %d for HET_ESC_SHARE_DESKTOP",
                    cjIn, cjOut));
                rc = FALSE;
                DC_QUIT;
            }

            g_hetDDDesktopIsShared = TRUE;
        }
        break;

        case HET_ESC_UNSHARE_DESKTOP:
        {
            if ((cjIn != sizeof(HET_UNSHARE_DESKTOP)) ||
                (cjOut != sizeof(HET_UNSHARE_DESKTOP)))
            {
                ERROR_OUT(("HET_DDProcessRequest:  Invalid sizes %d, %d for HET_ESC_UNSHARE_DESKTOP",
                    cjIn, cjOut));
                rc = FALSE;
                DC_QUIT;
            }

            g_hetDDDesktopIsShared = FALSE;
            HETDDViewing(NULL, FALSE);
        }
        break;

        case HET_ESC_VIEWER:
        {
            //
            // We may turn OFF viewing but keep stuff shared and the windows
            // tracked -- hosting a meeting and sharing something, for 
            // example. 
            //
            if ((cjIn != sizeof(HET_VIEWER)) ||
                (cjOut != sizeof(HET_VIEWER)))
            {
                ERROR_OUT(("HET_DDProcessRequest:  Invalid sizes %d, %d for HET_ESC_VIEWER",
                    cjIn, cjOut));
                rc = FALSE;
                DC_QUIT;
            }

            HETDDViewing(pso, (((LPHET_VIEWER)pvIn)->viewersPresent != 0));
            break;
        }

        default:
        {
            ERROR_OUT(( "Unknown request type %#x", pHeader->escapeFn));
            rc = FALSE;
        }
        break;
    }

DC_EXIT_POINT:
    DebugExitDWORD(HET_DDProcessRequest, rc);
    return(rc);
}


//
// HET_DDOutputIsHosted - see host.h
//
BOOL HET_DDOutputIsHosted(POINT pt)
{
    BOOL              rc = FALSE;
    UINT              j;
    LPHET_WINDOW_STRUCT  pWnd;

    DebugEntry(HET_DDOutputIsHosted);

    //
    // Now check to see if the desktop is shared - if it is then simply
    // return TRUE.
    //
    if (g_hetDDDesktopIsShared)
    {
        rc = TRUE;
        DC_QUIT;
    }

    //
    // Search through the window list
    //
    pWnd = COM_BasedListFirst(&g_hetWindowList, FIELD_OFFSET(HET_WINDOW_STRUCT, chain));
    while (pWnd != NULL)
    {
        //
        // Search each enumerated rectangle
        //
        TRACE_OUT(( "Window %#x has %u rectangle(s)",
                pWnd, pWnd->rects.c));
        for (j = 0; j < pWnd->rects.c; j++)
        {
            //
            // See whether the point passed in is within this rectangle.
            // Note that at this point we are dealing with exclusive
            // co-ordinates.
            //
            if ((pt.x >= pWnd->rects.arcl[j].left) &&
                (pt.x <  pWnd->rects.arcl[j].right) &&
                (pt.y >= pWnd->rects.arcl[j].top) &&
                (pt.y <  pWnd->rects.arcl[j].bottom))
            {
                TRACE_OUT((
                    "Pt {%d, %d}, in win %#x rect %u {%ld, %ld, %ld, %ld}",
                    pt.x, pt.y, pWnd->hwnd, j,
                    pWnd->rects.arcl[j].left, pWnd->rects.arcl[j].right,
                    pWnd->rects.arcl[j].top, pWnd->rects.arcl[j].bottom ));

                //
                // Found it!  Re-order the list, most recently used first
                //
                COM_BasedListRemove(&(pWnd->chain));
                COM_BasedListInsertAfter(&g_hetWindowList, &(pWnd->chain));

                //
                // Stop looking
                //
                rc = TRUE;
                DC_QUIT;
            }

            TRACE_OUT(( "Pt not in win %#x rect %u {%ld, %ld, %ld, %ld}",
                    pWnd->hwnd, j,
                    pWnd->rects.arcl[j].left, pWnd->rects.arcl[j].right,
                    pWnd->rects.arcl[j].top, pWnd->rects.arcl[j].bottom ));

        } // for all rectangles

        //
        // Move on to next window
        //
        pWnd = COM_BasedListNext(&g_hetWindowList, pWnd, FIELD_OFFSET(HET_WINDOW_STRUCT, chain));
    }

DC_EXIT_POINT:
    DebugExitBOOL(HET_DDOutputIsHosted, rc);
    return(rc);
}


//
// HET_DDOutputRectIsHosted - see host.h
//
BOOL HET_DDOutputRectIsHosted(LPRECT pRect)
{
    BOOL              rc = FALSE;
    UINT              j;
    LPHET_WINDOW_STRUCT  pWnd;
    RECT              rectIntersect;

    DebugEntry(HET_DDOutputRectIsHosted);

    //
    // Now check to see if the desktop is shared - if it is then simply
    // return TRUE.
    //
    if (g_hetDDDesktopIsShared)
    {
        rc = TRUE;
        DC_QUIT;
    }

    //
    // Search through the window list
    //
    pWnd = COM_BasedListFirst(&g_hetWindowList, FIELD_OFFSET(HET_WINDOW_STRUCT, chain));
    while (pWnd != NULL)
    {
        //
        // Search each enumerated rectangle
        //
        TRACE_OUT(( "Window %#x has %u rectangle(s)",
                pWnd, pWnd->rects.c));
        for (j = 0; j < pWnd->rects.c; j++)
        {
            //
            // See whether the rect passed in intersects this rectangle.
            // Note that at this point we are dealing with exclusive
            // co-ordinates.
            //
            rectIntersect.left = max( pRect->left,
                                         pWnd->rects.arcl[j].left );
            rectIntersect.top = max( pRect->top,
                                        pWnd->rects.arcl[j].top );
            rectIntersect.right = min( pRect->right,
                                          pWnd->rects.arcl[j].right );
            rectIntersect.bottom = min( pRect->bottom,
                                           pWnd->rects.arcl[j].bottom );

            //
            // If the intersection rectangle is well-ordered and non-NULL
            // then we have an intersection.
            //
            // The rects that we are dealing with are exclusive.
            //
            if ((rectIntersect.left < rectIntersect.right) &&
                (rectIntersect.top < rectIntersect.bottom))
            {
                TRACE_OUT((
             "Rect  {%d, %d, %d, %d} intersects win %#x rect %u {%ld, %ld, %ld, %ld}",
                    pRect->left, pRect->top, pRect->right, pRect->bottom,
                    pWnd, j,
                    pWnd->rects.arcl[j].left, pWnd->rects.arcl[j].right,
                    pWnd->rects.arcl[j].top, pWnd->rects.arcl[j].bottom ));

                //
                // Found it!  Re-order the list, most recently used first
                //
                COM_BasedListRemove(&(pWnd->chain));
                COM_BasedListInsertAfter(&g_hetWindowList, &(pWnd->chain));

                //
                // Stop looking
                //
                rc = TRUE;
                DC_QUIT;
            }

            TRACE_OUT(( "Rect not in win %#x rect %u {%ld, %ld, %ld, %ld}",
                    pWnd, j,
                    pWnd->rects.arcl[j].left, pWnd->rects.arcl[j].right,
                    pWnd->rects.arcl[j].top, pWnd->rects.arcl[j].bottom ));

        } // for all rectangles

        //
        // Move on to next window
        //
        pWnd = COM_BasedListNext(&g_hetWindowList, pWnd, FIELD_OFFSET(HET_WINDOW_STRUCT, chain));
    }

DC_EXIT_POINT:
    DebugExitBOOL(HET_DDOutputRectIsHosted, rc);
    return(rc);
}


//
//
// Name:        HETDDVisRgnCallback
//
// Description: WNDOBJ Callback
//
// Params:      pWo - pointer to the WNDOBJ which has changed
//              fl  - flags (se NT DDK documentation)
//
// Returns:     none
//
// Operation:
//
//
VOID CALLBACK HETDDVisRgnCallback(PWNDOBJ pWo, FLONG fl)
{
    ULONG               count;
    int               size;
    LPHET_WINDOW_STRUCT  pWnd;
    RECTL             rectl;
    UINT              i;

    DebugEntry(HETDDVisRgnCallback);

    //
    // Some calls pass a NULL pWo - exit now in this case
    //
    if (pWo == NULL)
    {
        DC_QUIT;
    }

    //
    // Find the window structure for this window
    //
    pWnd = pWo->pvConsumer;
    if (pWnd == NULL)
    {
        ERROR_OUT(( "Wndobj %x (fl %x) has no window structure", pWo, fl));
        DC_QUIT;
    }

    //
    // Check for window deletion
    //
    if (fl & WOC_DELETE)
    {
        TRACE_OUT(( "Wndobj %x (structure %x) deleted", pWo, pWo->pvConsumer));

        // ASSERT the window is valid
        ASSERT(pWnd->hwnd != NULL);

        //
        // Move the window from the active to the free list
        //
        COM_BasedListRemove(&(pWnd->chain));
        COM_BasedListInsertAfter(&g_hetFreeWndList, &(pWnd->chain));

#ifdef DEBUG
        // Check if this has reentrancy problems
        pWnd->hwnd = NULL;
#endif

        //
        // Do any processing if this is the last window to be unshared.
        //
        // If we are not keeping track of any windows, the first pointer in
        // the list will point to itself, ie list head->next == 0
        //
        if (g_hetWindowList.next == 0)
        {
            HETDDViewing(NULL, FALSE);
        }

        //
        // Exit now
        //
        DC_QUIT;
    }

    //
    // If we get here, this callback must be for a new visible region on a
    // tracked window.
    //

    //
    // Start the enumeration.  This function is supposed to count the
    // rectangles, but it always returns 0.
    //
    WNDOBJ_cEnumStart(pWo, CT_RECTANGLES, CD_ANY, 200);

    //
    // BOGUS BUGBUG LAURABU (perf opt for NT):
    //
    // NT will enum up to HET_WINDOW_RECTS at a time.  Note that the enum
    // function returns FALSE if, after obtaining the current batch, none
    // are left to grab the next time.
    //
    // If the visrgn is composed of more than that, we will wipe out the 
    // previous set of rects, then ensure that the bounding box of the 
    // preceding rects is the last rect in the list.
    //
    // This is bad in several cases.  For example if there are n visrgn piece
    // rects, and n == c*HET_WINDOW_RECTS + 1, we will end up with 2 entries:
    //      * The last piece rect
    //      * The bounding box of the previous n-1 piece rects 
    // A lot of output may be accumulated in deadspace as a result.
    //
    // A better algorithm may be to fill the first HET_WINDOW_RECTS-1 slots,
    // then union the rest into the last rectangle.  That way we make use of
    // all the slots.  But this could be awkward, since we need a scratch
    // ENUM_RECT struct rather than using the HET_WINDOW_STRUCT directly.
    //

    //
    // First time through, enumerate HET_WINDOW_RECTS rectangles.
    // Subsequent times, enumerate HET_WINDOW_RECTS-1 (see bottom of loop).
    // This guarantees that there will be room to store a combined
    // rectangle when we finally finish enumerating them.
    //
    pWnd->rects.c = HET_WINDOW_RECTS;
    rectl.left   = LONG_MAX;
    rectl.top    = LONG_MAX;
    rectl.right  = 0;
    rectl.bottom = 0;

    //
    // Enumerate the rectangles
    // NOTE that WNDOBJ_bEnum returns FALSE when there is nothing left
    // to enumerate AFTER grabbing this set.
    //

    while (WNDOBJ_bEnum(pWo, sizeof(pWnd->rects), (ULONG *)&pWnd->rects))
    {
#ifdef _DEBUG
        {
            char    trcStr[200];
            UINT    j;

            sprintf(trcStr, "WNDOBJ %p %d: ", pWo, pWnd->rects.c);

            for (j = 0; j < pWnd->rects.c; j++)
            {
                sprintf(trcStr, "%s {%ld, %ld, %ld, %ld} ", trcStr,
                    pWnd->rects.arcl[j].left, pWnd->rects.arcl[j].top,
                    pWnd->rects.arcl[j].right, pWnd->rects.arcl[j].bottom);
                if ((j & 3) == 3)       // output every 4th rect
                {
                    TRACE_OUT(( "%s", trcStr));
                    strcpy(trcStr, "                ");
                }
            }
            if ((j & 3) != 0)           // if any rects left
            {
                TRACE_OUT(( "%s", trcStr));
            }
        }
#endif

        //
        // Combine the preceding rectangles into one bounding rectangle
        //
        for (i = 0; i < pWnd->rects.c; i++)
        {
            if (pWnd->rects.arcl[i].left < rectl.left)
            {
                rectl.left = pWnd->rects.arcl[i].left;
            }
            if (pWnd->rects.arcl[i].top < rectl.top)
            {
                rectl.top = pWnd->rects.arcl[i].top;
            }
            if (pWnd->rects.arcl[i].right > rectl.right)
            {
                rectl.right = pWnd->rects.arcl[i].right;
            }
            if (pWnd->rects.arcl[i].bottom > rectl.bottom)
            {
                rectl.bottom = pWnd->rects.arcl[i].bottom;
            }
        }
        TRACE_OUT(( "Combined into {%ld, %ld, %ld, %ld}",
                rectl.left, rectl.top, rectl.right, rectl.bottom));

        //
        // Second & subsequent times, enumerate HET_WINDOW_RECTS-1
        //
        pWnd->rects.c = HET_WINDOW_RECTS - 1;
    }

    //
    // If any combining was done, save the combined rectangle now.
    //
    if (rectl.right != 0)
    {
        pWnd->rects.arcl[pWnd->rects.c] = rectl;
        pWnd->rects.c++;
        TRACE_OUT(( "Add combined rectangle to list"));
    }

    //
    // On the assumption that this WNDOBJ is the most likely to be the
    // target of the next output command, move it to the top of the list.
    //
    COM_BasedListRemove(&(pWnd->chain));
    COM_BasedListInsertAfter(&g_hetWindowList, &(pWnd->chain));

    //
    // Return to caller
    //
DC_EXIT_POINT:
    DebugExitVOID(HETDDVisRgnCallback);
}


//
//
// Name:        HETDDShareWindow
//
// Description: Share a window (DD processing)
//
// Params:      pso      - SURFOBJ
//              pReq     - request received from DrvEscape
//
//
BOOL HETDDShareWindow(SURFOBJ *pso, LPHET_SHARE_WINDOW  pReq)
{
    PWNDOBJ            pWo;
    FLONG              fl = WO_RGN_CLIENT | WO_RGN_UPDATE_ALL | WO_RGN_WINDOW;
    LPHET_WINDOW_STRUCT pWnd;
    BOOL                rc = FALSE;

    DebugEntry(HETDDShareWindow);

    ASSERT(!g_hetDDDesktopIsShared);

    //
    // Try to track the window
    //
    pWo = EngCreateWnd(pso, (HWND)pReq->winID, HETDDVisRgnCallback, fl, 0);

    //
    // Failed to track window - exit now
    //
    if (pWo == 0)
    {
        ERROR_OUT(( "Failed to track window %#x", pReq->winID));
        DC_QUIT;
    }

    //
    // Window is already tracked.  This happens when an invisible window is
    // shown in a process the USER shared, and we caught its create.
    //
    if (pWo == (PWNDOBJ)-1)
    {
        //
        // No more to do here
        //
        TRACE_OUT(( "Window %#x already tracked", pReq->winID));
        rc = TRUE;
        DC_QUIT;
    }

    //
    // Add window into our list.
    //

    //
    // Find free window structure
    //
    pWnd = COM_BasedListFirst(&g_hetFreeWndList, FIELD_OFFSET(HET_WINDOW_STRUCT, chain));

    //
    // If no free structures, grow the list
    //
    if (pWnd == NULL)
    {
        if (!HETDDAllocWndMem())
        {
            ERROR_OUT(( "Unable to allocate new window structures"));
            DC_QUIT;
        }

        pWnd = COM_BasedListFirst(&g_hetFreeWndList, FIELD_OFFSET(HET_WINDOW_STRUCT, chain));
    }

    //
    // Fill in the structure
    //
    TRACE_OUT(( "Fill in details for new window"));
    pWnd->hwnd     = (HWND)pReq->winID;
    pWnd->wndobj   = pWo;

    //
    // Set this to zero.  There's a brief period between the time we put
    // this in our tracked list and the time we get called back to recalc
    // the visrgn (because the ring 3 code invalidates the window completely).
    // We might get graphical output and we don't want to parse garbage
    // from this window's record.
    //
    pWnd->rects.c  = 0;

    //
    // Move the window structure from free to active list
    //
    COM_BasedListRemove(&(pWnd->chain));
    COM_BasedListInsertAfter(&g_hetWindowList, &(pWnd->chain));

    //
    // Save backwards pointer in the WNDOBJ
    // THIS MUST BE LAST since our callback can happen anytime afterwards.
    //
    // NOTE that the window's visrgn rects get into our list because the
    // ring3 code completely invalidates the window, causing the callback
    // to get called.
    //
    TRACE_OUT(( "Save pointer %#lx in Wndobj %#x", pWnd, pWo));
    WNDOBJ_vSetConsumer(pWo, pWnd);

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(HETDDShareWindow, rc);
    return(rc);
}


//
//
// Name:        HETDDUnshareWindow
//
// Description: Unshare a window (DD processing)
//
//
//
void HETDDUnshareWindow(LPHET_UNSHARE_WINDOW  pReq)
{
    LPHET_WINDOW_STRUCT  pWnd, pNextWnd;

    DebugEntry(HETDDUnshareWindow);

    TRACE_OUT(( "Unshare %x", pReq->winID));
    //
    // Scan window list for this window and its descendants
    //
    pWnd = COM_BasedListFirst(&g_hetWindowList, FIELD_OFFSET(HET_WINDOW_STRUCT, chain));
    while (pWnd != NULL)
    {
        //
        // If this window is being unshared, free it
        //
        pNextWnd = COM_BasedListNext(&g_hetWindowList, pWnd, FIELD_OFFSET(HET_WINDOW_STRUCT, chain));

        if (pWnd->hwnd == (HWND)pReq->winID)
        {
            TRACE_OUT(( "Unsharing %x", pReq->winID));

            //
            // Stop tracking the window
            //
            HETDDDeleteAndFreeWnd(pWnd);
        }

        //
        // Go on to (previously saved) next window
        //
        pWnd = pNextWnd;
    }

    //
    // Return to caller
    //
    DebugExitVOID(HETDDUnshareWindow);
}


//
//
// Name:        HETDDUnshareAll
//
// Description: Unshare all windows (DD processing) (what did you expect)
//
//
void HETDDUnshareAll(void)
{
    LPHET_WINDOW_STRUCT pWnd;

    DebugEntry(HETDDUnshareAll);

    //
    // Clear all window structures
    //
    while (pWnd = COM_BasedListFirst(&g_hetWindowList, FIELD_OFFSET(HET_WINDOW_STRUCT, chain)))
    {
        TRACE_OUT(( "Unshare Window structure %x", pWnd));

        //
        // Stop tracking the window
        //
        HETDDDeleteAndFreeWnd(pWnd);
    }

    //
    // Return to caller
    //
    DebugExitVOID(HETDDUnshareAll);
}


//
//
// Name:        HETDDAllocWndMem
//
// Description: Allocate memory for a (new) window list
//
// Parameters:  None
//
//
BOOL HETDDAllocWndMem(void)
{
    BOOL             rc = FALSE;
    int              i;
    LPHET_WINDOW_MEMORY pNew;

    DebugEntry(HETDDAllocWndMem);

    //
    // Allocate a new strucure
    //
    pNew = EngAllocMem(FL_ZERO_MEMORY, sizeof(HET_WINDOW_MEMORY), OSI_ALLOC_TAG);
    if (pNew == NULL)
    {
        ERROR_OUT(("HETDDAllocWndMem: unable to allocate memory"));
        DC_QUIT;
    }

    //
    // Add this memory block to the list of memory blocks
    //
    COM_BasedListInsertAfter(&g_hetMemoryList, &(pNew->chain));

    //
    // Add all new entries to free list
    //
    TRACE_OUT(("HETDDAllocWndMem: adding new entries to free list"));
    for (i = 0; i < HET_WINDOW_COUNT; i++)
    {
        COM_BasedListInsertAfter(&g_hetFreeWndList, &(pNew->wnd[i].chain));
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(HETDDAllocWndMem, rc);
    return(rc);
}

//
//
// Name:        HETDDDeleteAndFreeWnd
//
// Description: Delete and window and free its window structure
//
// Parameters:  pWnd - pointer to window structure to delete & free
//
// Returns:     none
//
// Operation:   Ths function stops tracking a window and frees its memory
//
//
void HETDDDeleteAndFreeWnd(LPHET_WINDOW_STRUCT pWnd)
{
    DebugEntry(HETDDDeleteAndFreeWnd);

    //
    // Stop tracking the window
    //
    EngDeleteWnd(pWnd->wndobj);

    //
    // NOTE LAURABU!  EngDeleteWnd() will call the VisRgnCallback with
    // WO_DELETE, which will cause us to exectute a duplicate of exactly 
    // the code below.  So why do it twice (which is scary anyway), especially
    // the stop hosting code?
    //
    ASSERT(pWnd->hwnd == NULL);

    //
    // Return to caller
    //
    DebugExitVOID(HETDDDeleteAndFreeWnd);
}


//
// HETDDViewers()
//
// Called when viewing of our shared apps starts/stops.  Naturally, no longer
// sharing anything stops viewing also.
//
void HETDDViewing
(
    SURFOBJ *   pso,
    BOOL        fViewers
)
{
    DebugEntry(HETDDViewers);

    if (g_oeViewers != fViewers)
    {
        g_oeViewers = fViewers;
        CM_DDViewing(pso, fViewers);

        if (g_oeViewers)
        {
            //
            // Force palette grab.
            //
            g_asSharedMemory->pmPaletteChanged = TRUE;
        }
    }

    DebugExitVOID(HETDDViewing);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\dd\osi.c ===
#include "precomp.h"


//
// OSI.C
// OS Isolation layer, display driver side
//
// Copyright(c) Microsoft 1997-
//


#include <version.h>
#include <ndcgver.h>


//
// These are the default 20 Windows colors, lifted from the base S3 driver.
//
// Global Table defining the 20 Window default colours.  For 256 colour
// palettes the first 10 must be put at the beginning of the palette
// and the last 10 at the end of the palette.
const PALETTEENTRY s_aWinColors[20] =
{
    { 0,   0,   0,   0 },       // 0
    { 0x80,0,   0,   0 },       // 1
    { 0,   0x80,0,   0 },       // 2
    { 0x80,0x80,0,   0 },       // 3
    { 0,   0,   0x80,0 },       // 4
    { 0x80,0,   0x80,0 },       // 5
    { 0,   0x80,0x80,0 },       // 6
    { 0xC0,0xC0,0xC0,0 },       // 7
    { 192, 220, 192, 0 },       // 8
    { 166, 202, 240, 0 },       // 9
    { 255, 251, 240, 0 },       // 10
    { 160, 160, 164, 0 },       // 11
    { 0x80,0x80,0x80,0 },       // 12
    { 0xFF,0,   0   ,0 },       // 13
    { 0,   0xFF,0   ,0 },       // 14
    { 0xFF,0xFF,0   ,0 },       // 15
    { 0   ,0,   0xFF,0 },       // 16
    { 0xFF,0,   0xFF,0 },       // 17
    { 0,   0xFF,0xFF,0 },       // 18
    { 0xFF,0xFF,0xFF,0 },       // 19
};



//
// Functions supported by our Display Driver.  Each entry is of the form:
//
//  index    - NT DDK defined index for the DDI function
//
//  function - pointer to our intercept function
//
//
const DRVFN s_osiDriverFns[] =
{
    //
    // NT4 FUNCTIONS
    //
    { INDEX_DrvEnablePDEV,        (PFN)DrvEnablePDEV        },
    { INDEX_DrvCompletePDEV,      (PFN)DrvCompletePDEV      },
    { INDEX_DrvDisablePDEV,       (PFN)DrvDisablePDEV       },
    { INDEX_DrvEnableSurface,     (PFN)DrvEnableSurface     },
    { INDEX_DrvDisableSurface,    (PFN)DrvDisableSurface    },

    { INDEX_DrvAssertMode,        (PFN)DrvAssertMode        },
    { INDEX_DrvResetPDEV,         (PFN)DrvResetPDEV         },
        // INDEX_DrvCreateDeviceBitmap  not used
        // INDEX_DrvDeleteDeviceBitmap  not used
    { INDEX_DrvRealizeBrush,      (PFN)DrvRealizeBrush      },
        // INDEX_DrvDitherColor         not used
    { INDEX_DrvStrokePath,        (PFN)DrvStrokePath        },
    { INDEX_DrvFillPath,          (PFN)DrvFillPath          },

    { INDEX_DrvStrokeAndFillPath, (PFN)DrvStrokeAndFillPath },
    { INDEX_DrvPaint,             (PFN)DrvPaint             },
    { INDEX_DrvBitBlt,            (PFN)DrvBitBlt            },
    { INDEX_DrvCopyBits,          (PFN)DrvCopyBits          },
    { INDEX_DrvStretchBlt,        (PFN)DrvStretchBlt        },

    { INDEX_DrvSetPalette,        (PFN)DrvSetPalette        },
    { INDEX_DrvTextOut,           (PFN)DrvTextOut           },
    { INDEX_DrvEscape,            (PFN)DrvEscape            },
        // INDEX_DrvDrawEscape          not used
        // INDEX_DrvQueryFont           not used
        // INDEX_DrvQueryFontTree       not used
        // INDEX_DrvQueryFontData       not used
    { INDEX_DrvSetPointerShape,   (PFN)DrvSetPointerShape   },
    { INDEX_DrvMovePointer,       (PFN)DrvMovePointer       },

    { INDEX_DrvLineTo,            (PFN)DrvLineTo            },
        // INDEX_DrvSendPage            not used
        // INDEX_DrvStartPage           not used
        // INDEX_DrvEndDoc              not used
        // INDEX_DrvStartDoc            not used
        // INDEX_DrvGetGlyphMode        not used
        // INDEX_DrvSynchronize         not used
    { INDEX_DrvSaveScreenBits,    (PFN)DrvSaveScreenBits    },
    { INDEX_DrvGetModes,          (PFN)DrvGetModes          },
        // INDEX_DrvFree                not used
        // INDEX_DrvDestroyFont         not used
        // INDEX_DrvQueryFontCaps       not used
        // INDEX_DrvLoadFontFile        not used
        // INDEX_DrvUnloadFontFile      not used
        // INDEX_DrvFontManagement      not used
        // INDEX_DrvQueryTrueTypeTable  not used
        // INDEX_DrvQueryTrueTypeOutline    not used
        // INDEX_DrvGetTrueTypeFile     not used
        // INDEX_DrvQueryFontFile       not used
        // INDEX_DrvQueryAdvanceWidths  not used
        // INDEX_DrvSetPixelFormat      not used
        // INDEX_DrvDescribePixelFormat not used
        // INDEX_DrvSwapBuffers         not used
        // INDEX_DrvStartBanding        not used
        // INDEX_DrvNextBand            not used
        // INDEX_DrvGetDirectDrawInfo   not used
        // INDEX_DrvEnableDirectDraw    not used
        // INDEX_DrvDisableDirectDraw   not used
        // INDEX_DrvQuerySpoolType      not used

    //
    // NT5 FUNCTIONS - 5 of them currently.  If you add to this list,
    // update CFN_NT5 below.
    //
        // INDEX_DrvIcmCreateColorTransform not used
        // INDEX_DrvIcmDeleteColorTransform not used
        // INDEX_DrvIcmCheckBitmapBits  not used
        // INDEX_DrvIcmSetDeviceGammaRamp   not used
    { INDEX_DrvGradientFill,      (PFN)DrvGradientFill      },
    { INDEX_DrvStretchBltROP,     (PFN)DrvStretchBltROP     },

    { INDEX_DrvPlgBlt,            (PFN)DrvPlgBlt            },
    { INDEX_DrvAlphaBlend,        (PFN)DrvAlphaBlend        },
        // INDEX_DrvSynthesizeFont      not used
        // INDEX_DrvGetSynthesizedFontFiles not used
    { INDEX_DrvTransparentBlt,    (PFN)DrvTransparentBlt    },
        // INDEX_DrvQueryPerBandInfo    not used
        // INDEX_DrvQueryDeviceSupport  not used
        // INDEX_DrvConnect             not used
        // INDEX_DrvDisconnect          not used
        // INDEX_DrvReconnect           not used
        // INDEX_DrvShadowConnect       not used
        // INDEX_DrvShadowDisconnect    not used
        // INDEX_DrvInvalidateRect      not used
        // INDEX_DrvSetPointerPos       not used
        // INDEX_DrvDisplayIOCtl        not used
        // INDEX_DrvDeriveSurface       not used
        // INDEX_DrvQueryGlyphAttrs     not used
    {   INDEX_DrvDisableDriver,         (PFN) DrvDisableDriver      }        
};


#define CFN_NT5         5



//
// s_osiDefaultGdi
//
// This contains the default GDIINFO fields that are passed back to GDI
// during DrvEnablePDEV.
//
// NOTE: This structure defaults to values for an 8bpp palette device.
//       Some fields are overwritten for different colour depths.
//
//       It is expected that DDML ignores a lot of these parameters and
//       uses the values from the primary driver instead
//

const GDIINFO s_osiDefaultGdi =
{
    GDI_DRIVER_VERSION,
    DT_RASDISPLAY,          // ulTechnology
    400,                    // ulHorzSize (display width: mm)
    300,                    // ulVertSize (display height: mm)
    0,                      // ulHorzRes (filled in later)
    0,                      // ulVertRes (filled in later)
    0,                      // cBitsPixel (filled in later)
    1,                      // cPlanes
    (ULONG)-1,              // ulNumColors (palette managed)
    0,                      // flRaster (DDI reserved field)
    96,                     // ulLogPixelsX (filled in later)
    96,                     // ulLogPixelsY (filled in later)
    TC_RA_ABLE,             // flTextCaps - If we had wanted console windows
                        // to scroll by repainting the entire window,
                        // instead of doing a screen-to-screen blt, we
                        // would have set TC_SCROLLBLT (yes, the flag
                        // is backwards).

    0,                      // ulDACRed (filled in later)
    0,                      // ulDACGreen (filled in later)
    0,                      // ulDACBlue (filled in later)
    0x0024,                 // ulAspectX
    0x0024,                 // ulAspectY
    0x0033,                 // ulAspectXY (one-to-one aspect ratio)
    1,                      // xStyleStep
    1,                      // yStyleStep
    3,                      // denStyleStep -- Styles have a one-to-one
                            // aspect ratio, and every dot is 3 pixels long
    { 0, 0 },               // ptlPhysOffset
    { 0, 0 },               // szlPhysSize
    0,                      // ulNumPalReg

    {
        { 6700, 3300, 0 },   //      Red
        { 2100, 7100, 0 },   //      Green
        { 1400,  800, 0 },   //      Blue
        { 1750, 3950, 0 },   //      Cyan
        { 4050, 2050, 0 },   //      Magenta
        { 4400, 5200, 0 },   //      Yellow
        { 3127, 3290, 0 },   //      AlignmentWhite
        20000,               //      RedGamma
        20000,               //      GreenGamma
        20000,               //      BlueGamma
        0, 0, 0, 0, 0, 0     //      No dye correction for raster displays
    },

    0,                       // ulDevicePelsDPI (for printers only)
    PRIMARY_ORDER_CBA,       // ulPrimaryOrder
    HT_PATSIZE_4x4_M,        // ulHTPatternSize
    HT_FORMAT_8BPP,          // ulHTOutputFormat
    HT_FLAG_ADDITIVE_PRIMS,  // flHTFlags
    0,                       // ulVRefresh
    0,                       // ulBltAlignment
    0,                       // ulPanningHorzRes
    0,                       // ulPanningVertRes
};


//
// s_osiDefaultDevInfo
//
// This contains the default DEVINFO fields that are passed back to GDI
// during DrvEnablePDEV.
//
// NOTE: This structure defaults to values for an 8bpp palette device.
//       Some fields are overwritten for different colour depths.
//
//
const DEVINFO s_osiDefaultDevInfo =
{
    {
        GCAPS_OPAQUERECT       |
        GCAPS_DITHERONREALIZE  |
        GCAPS_PALMANAGED       |
        GCAPS_MONO_DITHER      |
        GCAPS_COLOR_DITHER     |
        GCAPS_LAYERED
    },                          // NOTE: Only enable ASYNCMOVE if your code
                            //   and hardware can handle DrvMovePointer
                            //   calls at any time, even while another
                            //   thread is in the middle of a drawing
                            //   call such as DrvBitBlt.

                            // flGraphicsFlags
    {   16,7,0,0,700,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,
        CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY,
        VARIABLE_PITCH | FF_DONTCARE, L"System"
    },
                            // lfDefaultFont

    {
        12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,
        CLIP_STROKE_PRECIS,PROOF_QUALITY,
        VARIABLE_PITCH | FF_DONTCARE, L"MS Sans Serif"
    },
                            // lfAnsiVarFont

    {
        12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,
        CLIP_STROKE_PRECIS,PROOF_QUALITY,
        FIXED_PITCH | FF_DONTCARE, L"Courier"
    },
                            // lfAnsiFixFont

    0,                          // cFonts
    BMF_8BPP,                   // iDitherFormat
    8,                          // cxDither
    8,                          // cyDither
    0                           // hpalDefault (filled in later)
};



//
// DrvEnableDriver - see NT DDK documentation.
//
// This is the only directly exported entry point to the display driver.
// All other entry points are exported through the data returned from this
// function.
//
BOOL DrvEnableDriver
(
    ULONG          iEngineVersion,
    ULONG          cj,
    DRVENABLEDATA* pded
)
{
    DebugEntry(DrvEnableDriver);

    INIT_OUT(("DrvEnableDriver(iEngineVersion = 0x%08x)", iEngineVersion));

    //
    // Check that the engine version is correct - we refuse to load on
    // other versions because we will almost certainly not work.
    //
    if ((iEngineVersion != DDI_DRIVER_VERSION_SP3) &&
        (iEngineVersion != DDI_DRIVER_VERSION_NT5) &&
        (iEngineVersion != DDI_DRIVER_VERSION_NT5_01))
    {
        INIT_OUT(("DrvEnableDriver: Not NT 4.0 SP-3 or NT 5.0; failing enable"));
        return(FALSE);
    }

    //
    // Fill in as much as we can.  Start with the entry points.
    //
    if ( cj >= FIELD_OFFSET(DRVENABLEDATA, pdrvfn) +
               FIELD_SIZE  (DRVENABLEDATA, pdrvfn) )
    {
        pded->pdrvfn = (DRVFN *)s_osiDriverFns;
    }

    //
    // Size of our entry point array.
    //
    if ( cj >= FIELD_OFFSET(DRVENABLEDATA, c) +
               FIELD_SIZE  (DRVENABLEDATA, c) )
    {
        //
        // If this is NT4, return back a subset -- it doesn't like tables
        // with unknown indeces
        //
        pded->c = sizeof(s_osiDriverFns) / sizeof(s_osiDriverFns[0]);
        if (iEngineVersion != DDI_DRIVER_VERSION_NT5 && 
            iEngineVersion != DDI_DRIVER_VERSION_NT5_01)
        {
            pded->c -= CFN_NT5;
        }
        INIT_OUT(("DrvEnableDriver: Returning driver function count %u", pded->c));
    }

    //
    // DDI version this driver was targeted for is passed back to engine.
    // Future graphics engines may break calls down to old driver format.
    //
    if ( cj >= FIELD_OFFSET(DRVENABLEDATA, iDriverVersion) +
               FIELD_SIZE  (DRVENABLEDATA, iDriverVersion) )
    {
        //
        // Return back NT5 when we're on NT5.  Hopefully this will work
        // OK...
        //
        pded->iDriverVersion = iEngineVersion;
        INIT_OUT(("DrvEnableDriver: Returning driver version 0x%08x", pded->iDriverVersion));
    }

    DebugExitVOID(DrvEnableDriver);
    return(TRUE);
}


//
// DrvDisableDriver - see NT DDK documentation.
//
VOID DrvDisableDriver(VOID)
{
    DebugEntry(DrvDisableDriver);

    DebugExitVOID(DrvDisableDriver);
}


//
// DrvEnablePDEV - see NT DDK documentation.
//
// Initializes a bunch of fields for GDI, based on the mode we've been
// asked to do.  This is the first thing called after DrvEnableDriver, when
// GDI wants to get some information about us.
//
// (This function mostly returns back information; DrvEnableSurface is used
// for initializing the hardware and driver components.)
//
//
DHPDEV DrvEnablePDEV(DEVMODEW*   pdm,
                     PWSTR       pwszLogAddr,
                     ULONG       cPat,
                     HSURF*      phsurfPatterns,
                     ULONG       cjCaps,
                     ULONG*      pdevcaps,
                     ULONG       cjDevInfo,
                     DEVINFO*    pdi,
                     HDEV        hdev,
                     PWSTR       pwszDeviceName,
                     HANDLE      hDriver)
{
    DHPDEV    rc = NULL;
    LPOSI_PDEV ppdev = NULL;
    GDIINFO   gdiInfoNew;

    DebugEntry(DrvEnablePDEV);

    INIT_OUT(("DrvEnablePDEV: Parameters:"));
    INIT_OUT(("     PWSTR       pdm->dmDeviceName %ws", pdm->dmDeviceName));
    INIT_OUT(("     HDEV        hdev            0x%08x", hdev));
    INIT_OUT(("     PWSTR       pwszDeviceName  %ws", pwszDeviceName));
    INIT_OUT(("     HANDLE      hDriver         0x%08x", hDriver));

    //
    // This function only sets up local data, so shared memory protection
    // is not required.
    //

    //
    // Make sure that we have large enough data to reference.
    //
    if ((cjCaps < sizeof(GDIINFO)) || (cjDevInfo < sizeof(DEVINFO)))
    {
        ERROR_OUT(( "Buffer size too small %lu %lu", cjCaps, cjDevInfo));
        DC_QUIT;
    }

    //
    // Allocate a physical device structure.
    //
    ppdev = EngAllocMem(FL_ZERO_MEMORY, sizeof(OSI_PDEV), OSI_ALLOC_TAG);
    if (ppdev == NULL)
    {
        ERROR_OUT(( "DrvEnablePDEV - Failed EngAllocMem"));
        DC_QUIT;
    }

    ppdev->hDriver = hDriver;

    //
    // Set up the current screen mode information based upon the supplied
    // mode settings.
    //
    if (!OSIInitializeMode((GDIINFO *)pdevcaps,
                                 pdm,
                                 ppdev,
                                 &gdiInfoNew,
                                 pdi))
    {
        ERROR_OUT(( "Failed to initialize mode"));
        DC_QUIT;
    }

    memcpy(pdevcaps, &gdiInfoNew, min(sizeof(GDIINFO), cjCaps));

    INIT_OUT(("DrvEnablePDEV: Returning DEVINFO:"));
    INIT_OUT(("     FLONG       flGraphicsCaps  0x%08x", pdi->flGraphicsCaps));
    INIT_OUT(("     ULONG       iDitherFormat   %d",     pdi->iDitherFormat));
    INIT_OUT(("     HPALETTE    hpalDefault     0x%08x", pdi->hpalDefault));

    INIT_OUT(("DrvEnablePDEV: Returning GDIINFO (pdevcaps):"));
    INIT_OUT(("     ULONG       ulVersion       0x%08x",    gdiInfoNew.ulVersion));
    INIT_OUT(("     ULONG       ulHorzSize      %d",    gdiInfoNew.ulHorzSize));
    INIT_OUT(("     ULONG       ulVertSize      %d",    gdiInfoNew.ulVertSize));
    INIT_OUT(("     ULONG       ulHorzRes       %d",    gdiInfoNew.ulHorzRes));
    INIT_OUT(("     ULONG       ulVertRes       %d",    gdiInfoNew.ulVertRes));
    INIT_OUT(("     ULONG       cBitsPixel      %d",    gdiInfoNew.cBitsPixel));
    INIT_OUT(("     ULONG       cPlanes         %d",    gdiInfoNew.cPlanes));
    INIT_OUT(("     ULONG       ulNumColors     %d",    gdiInfoNew.ulNumColors));
    INIT_OUT(("     ULONG       ulDACRed        0x%08x",    gdiInfoNew.ulDACRed));
    INIT_OUT(("     ULONG       ulDACGreen      0x%08x",    gdiInfoNew.ulDACGreen));
    INIT_OUT(("     ULONG       ulDACBlue       0x%08x",    gdiInfoNew.ulDACBlue));
    INIT_OUT(("     ULONG       ulHTOutputFormat %d",   gdiInfoNew.ulHTOutputFormat));

    //
    // We have successfully initialized - return the new PDEV.
    //
    rc = (DHPDEV)ppdev;

DC_EXIT_POINT:
    //
    // Release any resources if we failed to initialize.
    //
    if (rc == NULL)
    {
        ERROR_OUT(("DrvEnablePDEV failed; cleaning up by disabling"));
        DrvDisablePDEV(NULL);
    }

    DebugExitPVOID(DrvEnablePDEV, rc);
    return(rc);
}


//
// DrvDisablePDEV - see NT DDK documentation
//
// Release the resources allocated in DrvEnablePDEV.  If a surface has been
// enabled DrvDisableSurface will have already been called.
//
// Note that this function will be called when previewing modes in the
// Display Applet, but not at system shutdown.
//
// Note: In an error, we may call this before DrvEnablePDEV is done.
//
//
VOID DrvDisablePDEV(DHPDEV  dhpdev)
{
    LPOSI_PDEV ppdev = (LPOSI_PDEV)dhpdev;

    DebugEntry(DrvDisablePDEV);

    INIT_OUT(("DrvDisablePDEV(dhpdev = 0x%08x)", dhpdev));

    //
    // Free the resources we allocated for the display.
    //
    if (ppdev != NULL)
    {
        if (ppdev->hpalCreated != NULL)
        {
            EngDeletePalette(ppdev->hpalCreated);
            ppdev->hpalCreated = NULL;
        }

        if (ppdev->pPal != NULL)
        {
            EngFreeMem(ppdev->pPal);
            ppdev->pPal = NULL;
        }

        EngFreeMem(ppdev);
    }

    DebugExitVOID(DrvDisablePDEV);
}


//
// DrvCompletePDEV - see NT DDK documentation
//
// Stores the HPDEV, the engine's handle for this PDEV, in the DHPDEV.
//
VOID DrvCompletePDEV( DHPDEV dhpdev,
                      HDEV   hdev )
{
    DebugEntry(DrvCompletePDEV);

    //
    // Store the device handle for our display handle.
    //
    INIT_OUT(("DrvCompletePDEV(dhpdev = 0x%08x, hdev = 0x%08x)", dhpdev, hdev));

    ((LPOSI_PDEV)dhpdev)->hdevEng = hdev;

    DebugExitVOID(DrvCompletePDEV);
}


//
// DrvResetPDEV - see NT DDK documentation
//
// Allows us to reject dynamic screen changes if necessary ON NT4 ONLY
// This is NOT CALLED on NT5.
//
BOOL DrvResetPDEV
(
    DHPDEV  dhpdevOld,
    DHPDEV  dhpdevNew
)
{
    BOOL rc = TRUE;

    DebugEntry(DrvResetPDEV);

    INIT_OUT(("DrvResetPDEV(dhpdevOld = 0x%08x, dhpdevNew = 0x%08x)", dhpdevOld,
        dhpdevNew));

    //
    // We can only allow the display driver to change modes while DC-Share
    // is not running.
    //
    if (g_shmMappedMemory != NULL)
    {
        //
        // Deny the request.
        //
        rc = FALSE;
    }

    DebugExitDWORD(DrvResetPDEV, rc);
    return(rc);
}


//
// DrvEnableSurface - see NT DDK documentation
//
// Creates the drawing surface and initializes driver components.  This
// function is called after DrvEnablePDEV, and performs the final device
// initialization.
//
//
HSURF DrvEnableSurface(DHPDEV dhpdev)
{
    LPOSI_PDEV  ppdev = (LPOSI_PDEV)dhpdev;
    HSURF      hsurf;
    SIZEL      sizl;
    LPOSI_DSURF pdsurf;
    HSURF      rc = 0;

    DWORD returnedDataLength;
    DWORD MaxWidth, MaxHeight;
    VIDEO_MEMORY videoMemory;
    VIDEO_MEMORY_INFORMATION videoMemoryInformation;

    DebugEntry(DrvEnableSurface);

    INIT_OUT(("DrvEnableSurface: Parameters:"));
    INIT_OUT(("     LPOSI_PDEV  ppdev           0x%08x", ppdev));
    INIT_OUT(("     HDRIVER     ->hDriver       0x%08x", ppdev->hDriver));
    INIT_OUT(("     INT         ->cxScreen      %d", ppdev->cxScreen));
    INIT_OUT(("     INT         ->cyScreen      %d", ppdev->cyScreen));

    //
    // Now create our private surface structure.
    //
    // Whenever we get a call to draw directly to the screen, we'll get
    // passed a pointer to a SURFOBJ whose 'dhpdev' field will point
    // to our PDEV structure, and whose 'dhsurf' field will point to the
    // DSURF structure allocated below.
    //
    // Every device bitmap we create in DrvCreateDeviceBitmap will also
    // have its own unique DSURF structure allocated (but will share the
    // same PDEV).  To make our code more polymorphic for handling drawing
    // to either the screen or an off-screen bitmap, we have the same
    // structure for both.
    //
    pdsurf = EngAllocMem(FL_ZERO_MEMORY, sizeof(OSI_DSURF), OSI_ALLOC_TAG);
    if (pdsurf == NULL)
    {
        ERROR_OUT(( "DrvEnableSurface - Failed pdsurf EngAllocMem"));
        DC_QUIT;
    }

    //
    // Store the screen surface details.
    //
    ppdev->pdsurfScreen = pdsurf;
    pdsurf->sizl.cx     = ppdev->cxScreen;
    pdsurf->sizl.cy     = ppdev->cyScreen;
    pdsurf->ppdev       = ppdev;

    INIT_OUT(("DrvEnableSurface: Returning surface pointer 0x%08x", pdsurf));

    //
    // Only map the shared memory the first time we are called.
    //
    if (g_asSharedMemory == NULL)
    {
        //
        // Map the pointer to the shared section in the miniport driver
        //
        videoMemory.RequestedVirtualAddress = NULL;

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_MAP_VIDEO_MEMORY,
                               &videoMemory,
                               sizeof(VIDEO_MEMORY),
                               &videoMemoryInformation,
                               sizeof(VIDEO_MEMORY_INFORMATION),
                               &returnedDataLength))
        {
            ERROR_OUT(( "Could not MAP miniport section"));
            DC_QUIT;
        }

        INIT_OUT(("DrvEnableSurface: Got video memory info from EngDeviceIoControl:"));
        INIT_OUT(("    FrameBufferBase          0x%08x", videoMemoryInformation.FrameBufferBase));
        INIT_OUT(("    FrameBufferLength        0x%08x", videoMemoryInformation.FrameBufferLength));

        g_shmSharedMemorySize = videoMemoryInformation.FrameBufferLength;

        // First block is shared memory header
        g_asSharedMemory = (LPSHM_SHARED_MEMORY)
                           videoMemoryInformation.FrameBufferBase;

        // Next are the two large OA_FAST_DATA blocks
        g_poaData[0]    = (LPOA_SHARED_DATA)(g_asSharedMemory + 1);
        g_poaData[1]    = (LPOA_SHARED_DATA)(g_poaData[0] + 1);
    }

    //
    // Next, have GDI create the actual SURFOBJ.
    //
    // Our drawing surface is going to be 'device-managed', meaning that
    // GDI cannot draw on the framebuffer bits directly, and as such we
    // create the surface via EngCreateDeviceSurface.  By doing this, we
    // ensure that GDI will only ever access the bitmaps bits via the Drv
    // calls that we've HOOKed.
    //
    sizl.cx = ppdev->cxScreen;
    sizl.cy = ppdev->cyScreen;

    //
    // Otherwise the primary display driver has its own bitmap used by the
    // physical hardware, so we do not need to do any drawing ourself.
    //
    INIT_OUT(("DrvEnableSurface: Calling EngCreateDeviceSurface with:"));
    INIT_OUT(("     Sizl.cx         %d", sizl.cx));
    INIT_OUT(("     Sizl.cy         %d", sizl.cy));
    INIT_OUT(("     BitmapFormat    %d", ppdev->iBitmapFormat));

    hsurf = EngCreateDeviceSurface( (DHSURF)pdsurf,
                                    sizl,
                                    ppdev->iBitmapFormat );

    if (hsurf == 0)
    {
        ERROR_OUT(( "Could not allocate surface"));
        DC_QUIT;
    }

    //
    // Store the screen surface handle.
    //
    ppdev->hsurfScreen = hsurf;

    //
    // Now associate the surface and the PDEV.
    //
    // We have to associate the surface we just created with our physical
    // device so that GDI can get information related to the PDEV when
    // it's drawing to the surface (such as, for example, the length of
    // styles on the device when simulating styled lines).
    //
    if (!EngAssociateSurface(hsurf, ppdev->hdevEng,
                HOOK_BITBLT             |
                HOOK_STRETCHBLT         |
                HOOK_PLGBLT             |
                HOOK_TEXTOUT            |
                HOOK_PAINT              |       // OBSOLETE
                HOOK_STROKEPATH         |
                HOOK_FILLPATH           |
                HOOK_STROKEANDFILLPATH  |
                HOOK_LINETO             |
                HOOK_COPYBITS           |
                HOOK_STRETCHBLTROP      |
                HOOK_TRANSPARENTBLT     |
                HOOK_ALPHABLEND         |
                HOOK_GRADIENTFILL       |
                HOOK_SYNCHRONIZEACCESS))        // OBSOLETE
    {
        ERROR_OUT(( "DrvEnableSurface - Failed EngAssociateSurface"));
        DC_QUIT;
    }

    //
    // We have successfully associated the surface so return it to the GDI.
    //
    rc = hsurf;

DC_EXIT_POINT:
    //
    // Tidy up any resources if we failed.
    //
    if (rc == 0)
    {
        DrvDisableSurface((DHPDEV) ppdev);
    }

    DebugExitPVOID(DrvEnableSurface, rc);
    return(rc);
}


//
// DrvDisableSurface - see NT DDK documentation
//
// Free resources allocated by DrvEnableSurface.  Release the surface.
//
// Note that this function will be called when previewing modes in the
// Display Applet, but not at system shutdown.  If you need to reset the
// hardware at shutdown, you can do it in the miniport by providing a
// 'HwResetHw' entry point in the VIDEO_HW_INITIALIZATION_DATA structure.
//
// Note: In an error case, we may call this before DrvEnableSurface is
//       completely done.
//
VOID DrvDisableSurface(DHPDEV dhpdev)
{
    LPOSI_PDEV ppdev = (LPOSI_PDEV)dhpdev;

    DebugEntry(DrvDisableSurface);

    INIT_OUT(("DrvDisableSurface(dhpdev = 0x%08x)", dhpdev));

    if (ppdev->hsurfScreen != 0)
    {
        EngDeleteSurface(ppdev->hsurfScreen);
    }

    if (ppdev->pdsurfScreen != NULL)
    {
        EngFreeMem(ppdev->pdsurfScreen);
    }

    DebugExitVOID(DrvDisableSurface);
}


//
// DrvEscape - see NT DDK documentation.
//
ULONG DrvEscape(SURFOBJ *pso,
                ULONG    iEsc,
                ULONG    cjIn,
                PVOID    pvIn,
                ULONG    cjOut,
                PVOID    pvOut)
{
    ULONG                   rc = FALSE;
    LPOSI_ESCAPE_HEADER     pHeader;

    DebugEntry(DrvEscape);

    TRACE_OUT(("DrvEscape called with escape %d", iEsc));

    //
    // All functions we support use an identifier in the input data to make
    // sure that we don't try to use another driver's escape functions.  If
    // the identifier is not present, we must not process the request.
    //
    // NOTE: This function is NOT protected for shared memory access
    // because it is responsible for allocating / deallocating the shared
    // memory.
    //

    //
    // Check the data is long enough to store our standard escape header.
    // If it is not big enough this must be an escape request for another
    // driver.
    //
    if (cjIn < sizeof(OSI_ESCAPE_HEADER))
    {
        INIT_OUT(("DrvEscape ignoring; input size %04d too small", cjIn));
        WARNING_OUT(("DrvEscape ignoring; input size %04d too small", cjIn));
        DC_QUIT;
    }
    if (cjOut < sizeof(OSI_ESCAPE_HEADER))
    {
        INIT_OUT(("DrvEscape ignoring; output size %04d too small", cjOut));
        WARNING_OUT(("DrvEscape ignoring; output size %04d too small", cjOut));
        DC_QUIT;
    }

    //
    // Check for our escape ID.  If it is not our escape ID this must be an
    // escape request for another driver.
    //
    pHeader = pvIn;
    if (pHeader->identifier != OSI_ESCAPE_IDENTIFIER)
    {
        INIT_OUT(("DrvEscape ignoring; identifier 0x%08x is not for NetMtg", pHeader->identifier));
        WARNING_OUT(("DrvEscape ignoring; identifier 0x%08x is not for NetMtg", pHeader->identifier));
        DC_QUIT;
    }
    else if (pHeader->version != DCS_MAKE_VERSION())
    {
        INIT_OUT(("DrvEscape failing; version 0x%08x of NetMtg is not that of driver",
            pHeader->version));
        WARNING_OUT(("DrvEscape failing; version 0x%08x of NetMtg is not that of driver",
            pHeader->version));
        DC_QUIT;
    }

    //
    // If we haven't initialized yet, fail all other escapes.
    //
    if (g_shmMappedMemory == NULL)
    {
        if ((iEsc != OSI_ESC_CODE) || (pHeader->escapeFn != OSI_ESC_INIT))
        {
            WARNING_OUT(("DrvEscape failing; driver not initialized"));
            DC_QUIT;
        }
    }

    //
    // Everything is tickety boo - process the request.
    //
    switch (iEsc)
    {
        case OSI_ESC_CODE:
        {
            //
            // This is a request from the share core.  Pass it on to the
            // correct component.
            //
            TRACE_OUT(( "Function %ld", pHeader->escapeFn));

            if( // (pHeader->escapeFn >= OSI_ESC_FIRST) && Always True
                (pHeader->escapeFn <= OSI_ESC_LAST ) )
            {
                //
                // OSI requests.
                //
                rc = OSI_DDProcessRequest(pso, cjIn, pvIn, cjOut, pvOut);
            }
            else if( (pHeader->escapeFn >= OSI_OE_ESC_FIRST) &&
                     (pHeader->escapeFn <= OSI_OE_ESC_LAST ) )
            {
                //
                // Order Encoder requests.
                //
                rc = OE_DDProcessRequest(pso, cjIn, pvIn, cjOut, pvOut);
            }
            else if( (pHeader->escapeFn >= OSI_HET_ESC_FIRST) &&
                     (pHeader->escapeFn <= OSI_HET_ESC_LAST) )
            {
                //
                // Non-locking (wnd tracking) HET requests
                //
                rc = HET_DDProcessRequest(pso, cjIn, pvIn, cjOut, pvOut);
            }
            else if( (pHeader->escapeFn >= OSI_SBC_ESC_FIRST) &&
                     (pHeader->escapeFn <= OSI_SBC_ESC_LAST ) )
            {
                //
                // Send Bitmap Cache requests
                //
                rc = SBC_DDProcessRequest(pso, pHeader->escapeFn, pvIn, pvOut, cjOut);
            }
            else if( (pHeader->escapeFn >= OSI_SSI_ESC_FIRST) &&
                     (pHeader->escapeFn <= OSI_SSI_ESC_LAST ) )
            {
                //
                // Save Screen Bits requests.
                //
                rc = SSI_DDProcessRequest(pHeader->escapeFn, pHeader, cjIn);
            }
            else if( (pHeader->escapeFn >= OSI_CM_ESC_FIRST) &&
                     (pHeader->escapeFn <= OSI_CM_ESC_LAST ) )
            {
                //
                // Cursor Manager requests
                //
                rc = CM_DDProcessRequest(pso, cjIn, pvIn, cjOut, pvOut);
            }
            else if( (pHeader->escapeFn >= OSI_OA_ESC_FIRST) &&
                     (pHeader->escapeFn <= OSI_OA_ESC_LAST ) )
            {
                //
                // Order Accumulator requests.
                //
                rc = OA_DDProcessRequest(pHeader->escapeFn, pHeader, cjIn);
            }
            else if( (pHeader->escapeFn >= OSI_BA_ESC_FIRST) &&
                     (pHeader->escapeFn <= OSI_BA_ESC_LAST ) )
            {
                //
                // Bounds Accumulator requests.
                //
                rc = BA_DDProcessRequest(pHeader->escapeFn, pHeader, cjIn,
                    pvOut, cjOut);
            }
            else
            {
                WARNING_OUT(( "Unknown function", pHeader->escapeFn));
            }
        }
        break;

        case WNDOBJ_SETUP:
        {
            if ((pHeader->escapeFn >= OSI_HET_WO_ESC_FIRST) &&
                (pHeader->escapeFn <= OSI_HET_WO_ESC_LAST))
            {
                TRACE_OUT(("WNDOBJ_SETUP Escape code - pass to HET"));
                rc = HET_DDProcessRequest(pso, cjIn, pvIn, cjOut, pvOut);
            }
            else
            {
                INIT_OUT(("WNDOBJ_SETUP Escape is unrecognized, ignore"));
                WARNING_OUT(("WNDOBJ_SETUP Escape is unrecognized, ignore"));
            }
        }
        break;

        default:
        {
            ERROR_OUT(( "Unrecognised request %lu", iEsc));
        }
        break;
    }

DC_EXIT_POINT:
    DebugExitDWORD(DrvEscape, rc);
    return(rc);
}


//
// DrvSetPalette - see NT DDK documentation.
//
BOOL DrvSetPalette(DHPDEV  dhpdev,
                   PALOBJ* ppalo,
                   FLONG   fl,
                   ULONG   iStart,
                   ULONG   cColors)
{
    BOOL rc = FALSE;
    LPOSI_PDEV ppdev = (LPOSI_PDEV)dhpdev;

    DebugEntry(DrvSetPalette);

    //
    // Check that this doesn't hose our palette.  Note that NT passes a
    // zero indexed array element and a count, hence to fill a palette, the
    // values are 'start at 0 with 256 colours'.  Thus a total of 256 is
    // the maximum for our 8-bit palette.
    //
    if (iStart + cColors > OSI_MAX_PALETTE)
    {
        ERROR_OUT(("Overflow: start %lu count %lu", iStart, cColors));
        DC_QUIT;
    }

    //
    // Fill in the palette
    //
    if (cColors != PALOBJ_cGetColors(ppalo,
                                     iStart,
                                     cColors,
                                     (ULONG*)&ppdev->pPal[iStart]))
    {
        //
        // Don't bother tracing the return code - it's always 0.
        //
        ERROR_OUT(("Failed to read palette"));
        DC_QUIT;
    }

    //
    // BOGUS LAURABU!
    // For NT 5.0, do we need to turn around and reset the contents of
    // our created palette object with these new color values?  Real
    // display drivers don't (S3 e.g.)
    //

    //
    // Set the flag in the PDEV to indicate that the palette has changed
    //
    ppdev->paletteChanged = TRUE;

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(DrvSetPalette, rc);
    return(rc);
}


//
// DrvGetModes - see NT DDK documentation
//
// Returns the list of available modes for the device.
// As a mirroring driver, we return 0.  That will cause NT GRE to use
// whatever ChangeDisplaySettingsEx passed along.
//
ULONG DrvGetModes
(
    HANDLE      hDriver,
    ULONG       cjSize,
    DEVMODEW*   pdm
)
{
    return(0);
}


//
// DrvAssertMode - see NT DDK documentation.
//
BOOL DrvAssertMode
(
    DHPDEV  dhpdev,
    BOOL    bEnable
)
{
    LPOSI_PDEV ppdev = (LPOSI_PDEV)dhpdev;

    DebugEntry(DrvAssertMode);

    INIT_OUT(("DrvAssertMode(dhpdev = 0x%08x, bEnable = %d)", dhpdev, bEnable));

    //
    // Check for fullscreen switching.
    //
    if ((g_asSharedMemory != NULL) && (ppdev != NULL))
    {
        g_asSharedMemory->fullScreen = (BOOL)(!bEnable);
        TRACE_OUT(("Fullscreen is now  %d", g_asSharedMemory->fullScreen));
    }

    DebugExitVOID(DrvAssertMode);
    return(TRUE);
}



//
// Name:      OSIInitializeMode
//
// Purpose:
//
// Initializes a bunch of fields in the pdev, devcaps (aka gdiinfo), and
// devinfo based on the requested mode.
//
// Returns:
//
// TRUE  - Successfully initialized the data
// FALSE - Failed to set up mode data
//
// Params:
//
// pgdiRequested    - GDI info from the primary display driver (empty in NT 5.0)
// pdmRequested     - DEVMODE info with GDI's requested settings for our driver
// ppdev            - Our driver's private copy of settings, values
// pgdiReturn       - GDI info to return for our driver
// pdiReturn        - DEVINFO to return for our driver
//
BOOL  OSIInitializeMode
(
    const GDIINFO*      pgdiRequested,
    const DEVMODEW*     pdmRequested,
    LPOSI_PDEV          ppdev,
    GDIINFO*            pgdiReturn,
    DEVINFO*            pdiReturn
)
{
    BOOL                rc = FALSE;
    HPALETTE            hpal;
    ULONG               cColors;
    ULONG               iMode;

    DebugEntry(OSIInitializeMode);

    INIT_OUT(("DrvEnablePDEV: DEVMODEW requested contains:"));
    INIT_OUT(("     Screen width    -- %li", pdmRequested->dmPelsWidth));
    INIT_OUT(("     Screen height   -- %li", pdmRequested->dmPelsHeight));
    INIT_OUT(("     Bits per pel    -- %li", pdmRequested->dmBitsPerPel));
    INIT_OUT(("DrvEnablePDEV: DEVINFO parameter contains:"));
    INIT_OUT(("     flGraphicsCaps  -- 0x%08x", pdiReturn->flGraphicsCaps));
    INIT_OUT(("     iDitherFormat   -- 0x%08x", pdiReturn->iDitherFormat));
    INIT_OUT(("     hpalDefault     -- 0x%08x", pdiReturn->hpalDefault));
    INIT_OUT(("DrvEnablePDEV: GDIINFO (devcaps) parameter contains:"));
    INIT_OUT(("    ULONG       ulVersion       0x%08x",    pgdiRequested->ulVersion));
    INIT_OUT(("    ULONG       ulHorzSize      %d",    pgdiRequested->ulHorzSize));
    INIT_OUT(("    ULONG       ulVertSize      %d",    pgdiRequested->ulVertSize));
    INIT_OUT(("    ULONG       ulHorzRes       %d",    pgdiRequested->ulHorzRes));
    INIT_OUT(("    ULONG       ulVertRes       %d",    pgdiRequested->ulVertRes));
    INIT_OUT(("    ULONG       cBitsPixel      %d",    pgdiRequested->cBitsPixel));
    INIT_OUT(("    ULONG       cPlanes         %d",    pgdiRequested->cPlanes));
    INIT_OUT(("    ULONG       ulNumColors     %d",    pgdiRequested->ulNumColors));
    INIT_OUT(("    ULONG       ulDACRed        0x%08x",    pgdiRequested->ulDACRed));
    INIT_OUT(("    ULONG       ulDACGreen      0x%08x",    pgdiRequested->ulDACGreen));
    INIT_OUT(("    ULONG       ulDACBlue       0x%08x",    pgdiRequested->ulDACBlue));
    INIT_OUT(("    ULONG       ulHTOutputFormat %d",   pgdiRequested->ulHTOutputFormat));


    //
    // Fill in the GDIINFO we're returning with the info for our driver.
    // First, copy the default settings.
    //
    *pgdiReturn = s_osiDefaultGdi;

    //
    // Second, update the values that vary depending on the requested
    // mode and color depth.
    //

    pgdiReturn->ulHorzRes         = pdmRequested->dmPelsWidth;
    pgdiReturn->ulVertRes         = pdmRequested->dmPelsHeight;
    pgdiReturn->ulVRefresh        = pdmRequested->dmDisplayFrequency;
    pgdiReturn->ulLogPixelsX      = pdmRequested->dmLogPixels;
    pgdiReturn->ulLogPixelsY      = pdmRequested->dmLogPixels;

    //
    // If this is NT 4.0 SP-3, we get passed in the original GDIINFO of
    // the real display.  If not, we need to fake up one.
    //
    if (pgdiRequested->cPlanes != 0)
    {
        //
        // Now overwrite the defaults with the relevant information returned
        // from the kernel driver:
        //
        pgdiReturn->cBitsPixel        = pgdiRequested->cBitsPixel;
        pgdiReturn->cPlanes           = pgdiRequested->cPlanes;

        pgdiReturn->ulDACRed          = pgdiRequested->ulDACRed;
        pgdiReturn->ulDACGreen        = pgdiRequested->ulDACGreen;
        pgdiReturn->ulDACBlue         = pgdiRequested->ulDACBlue;
    }
    else
    {
        pgdiReturn->cBitsPixel        = pdmRequested->dmBitsPerPel;
        pgdiReturn->cPlanes           = 1;

        switch (pgdiReturn->cBitsPixel)
        {
            case 8:
                pgdiReturn->ulDACRed = pgdiReturn->ulDACGreen = pgdiReturn->ulDACBlue = 8;
                break;

            case 24:
                pgdiReturn->ulDACRed    = 0x00FF0000;
                pgdiReturn->ulDACGreen  = 0x0000FF00;
                pgdiReturn->ulDACBlue   = 0x000000FF;
                break;

            default:
                ERROR_OUT(("Invalid color depth in NT 5.0 mirror driver"));
                DC_QUIT;
                break;
        }
    }

    //
    // Now save private copies of info we're returning to GDI
    //
    ppdev->cxScreen         = pgdiReturn->ulHorzRes;
    ppdev->cyScreen         = pgdiReturn->ulVertRes;
    ppdev->cBitsPerPel      = pgdiReturn->cBitsPixel * pgdiReturn->cPlanes;
    if (ppdev->cBitsPerPel == 15)
        ppdev->cBitsPerPel = 16;
    ppdev->flRed            = pgdiReturn->ulDACRed;
    ppdev->flGreen          = pgdiReturn->ulDACGreen;
    ppdev->flBlue           = pgdiReturn->ulDACBlue;

    //
    // Fill in the devinfo structure with the default 8bpp values, taking
    // care not to trash the supplied hpalDefault (which allows us to
    // query information about the real display driver's color format).
    //
    // On NT 5.0, we don't get passed on the screen palette at all, we need
    // to create our own.
    //
    hpal = pdiReturn->hpalDefault;
    *pdiReturn = s_osiDefaultDevInfo;

    switch (pgdiReturn->cBitsPixel * pgdiReturn->cPlanes)
    {
        case 4:
        {
            //
            // NT 4.0 SP-3 ONLY
            //

            pgdiReturn->ulNumColors     = 16;
            pgdiReturn->ulNumPalReg     = 0;
            pgdiReturn->ulHTOutputFormat = HT_FORMAT_4BPP;

            pdiReturn->flGraphicsCaps   &= ~GCAPS_PALMANAGED;
            pdiReturn->iDitherFormat    = BMF_4BPP;

            ppdev->iBitmapFormat        = BMF_4BPP;

            cColors = 16;
            goto AllocPalEntries;
        }
        break;

        case 8:
        {
            pgdiReturn->ulNumColors     = 20;
            pgdiReturn->ulNumPalReg     = 256;

            pdiReturn->iDitherFormat    = BMF_8BPP;

            ppdev->iBitmapFormat        = BMF_8BPP;

            cColors = 256;
AllocPalEntries:
            //
            // Alloc memory for the palette entries.
            //
            ppdev->pPal = EngAllocMem( FL_ZERO_MEMORY,
                            sizeof(PALETTEENTRY) * cColors,
                            OSI_ALLOC_TAG );
            if (ppdev->pPal == NULL)
            {
                ERROR_OUT(("Failed to allocate palette memory"));
                DC_QUIT;
            }
        }
        break;

        case 15:
        case 16:
        {
            //
            // NT 4.0 SP-3 ONLY
            //
            pgdiReturn->ulHTOutputFormat = HT_FORMAT_16BPP;

            pdiReturn->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
            pdiReturn->iDitherFormat    = BMF_16BPP;

            ppdev->iBitmapFormat        = BMF_16BPP;
        }
        break;

        case 24:
        {
            //
            // DIB conversions will only work if we have a standard RGB
            // surface for 24bpp.
            //
            pgdiReturn->ulHTOutputFormat = HT_FORMAT_24BPP;

            pdiReturn->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
            pdiReturn->iDitherFormat    = BMF_24BPP;

            ppdev->iBitmapFormat        = BMF_24BPP;
        }
        break;

        case 32:
        {
            //
            // NT 4.0 SP-3 ONLY
            //
            pgdiReturn->ulHTOutputFormat = HT_FORMAT_32BPP;

            pdiReturn->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
            pdiReturn->iDitherFormat    = BMF_32BPP;

            ppdev->iBitmapFormat        = BMF_32BPP;
        }
        break;

        default:
        {
            //
            // Unsupported bpp - pretend we are 8 bpp.
            //
            ERROR_OUT(("Unsupported bpp value: %d",
                pgdiReturn->cBitsPixel * pgdiReturn->cPlanes));
            DC_QUIT;
        }
        break;
    }


    if (!hpal)
    {
        //
        // This is NT 5.0.  We need to create a palette, either an 8bpp
        // indexed one, or a 24bpp bitfield one.
        //
        if (ppdev->iBitmapFormat == BMF_8BPP)
        {
            ULONG   ulLoop;

            //
            // We have to initialize the fixed part (top 10 and bottom 10)
            // of the palette entries.
            //
            for (ulLoop = 0; ulLoop < 10; ulLoop++)
            {
                // First 10
                ppdev->pPal[ulLoop]     = s_aWinColors[ulLoop];

                // Last 10
                ppdev->pPal[256 - 10 + ulLoop] = s_aWinColors[ulLoop + 10];
            }

            // Create the palette from the entries.
            hpal = EngCreatePalette(PAL_INDEXED, 256, (ULONG*)ppdev->pPal,
                0, 0, 0);

            //
            // Set the flag in the PDEV to indicate that the palette has
            // changed.
            //
            ppdev->paletteChanged = TRUE;
        }
        else
        {
            ASSERT(ppdev->iBitmapFormat == BMF_24BPP);

            hpal = EngCreatePalette(PAL_BITFIELDS, 0, NULL,
                ppdev->flRed, ppdev->flGreen, ppdev->flBlue);
        }

        ppdev->hpalCreated = hpal;
        if (!hpal)
        {
            ERROR_OUT(("DrvEnablePDEV: could not create DEVINFO palette"));
            DC_QUIT;
        }
    }
    else
    {
        //
        // This is NT 4.0 SP-3.  Get the real bitmasks for > 8 bpp and
        // the current palette colors for <= 8 bpp.
        //
        if (pgdiReturn->cBitsPixel <= 8)
        {
            if (ppdev->iBitmapFormat == BMF_4BPP)
            {
                ASSERT(cColors == 16);
            }
            else
            {
                ASSERT(cColors == 256);
            }

            if (cColors != EngQueryPalette(hpal, &iMode, cColors,
                    (ULONG *)ppdev->pPal))
            {
                ERROR_OUT(("Failed to query current display palette"));
            }

            //
            // Set the flag in the PDEV to indicate that the palette has
            // changed.
            //
            ppdev->paletteChanged = TRUE;
        }
        else
        {
            ULONG       aulBitmasks[3];

            //
            // Query the true color bitmasks.
            //
            cColors = EngQueryPalette(hpal,
                               &iMode,
                               sizeof(aulBitmasks) / sizeof(aulBitmasks[0]),
                               &aulBitmasks[0] );

            if (cColors == 0)
            {
                ERROR_OUT(("Failed to query real bitmasks"));
            }

            if (iMode == PAL_INDEXED)
            {
                ERROR_OUT(("Bitmask palette is indexed"));
            }

            //
            // Get the real bitmasks for NT 4.0 SP-3 displays since we
            // get the same info the real global display does, and we need
            // to parse the bits in BitBlts, color tanslations, etc.
            //
            ppdev->flRed   = aulBitmasks[0];
            ppdev->flGreen = aulBitmasks[1];
            ppdev->flBlue  = aulBitmasks[2];
        }
    }

    pdiReturn->hpalDefault = hpal;

    rc = TRUE;

    INIT_OUT(("DrvEnablePDEV: Returning bitmasks of:"));
    INIT_OUT(("     red     %08x", ppdev->flRed));
    INIT_OUT(("     green   %08x", ppdev->flGreen));
    INIT_OUT(("     blue    %08x", ppdev->flBlue));

DC_EXIT_POINT:
    DebugExitBOOL(OSIInitializeMode, rc);
    return(rc);
}








//
// FUNCTION:      OSI_DDProcessRequest
//
// DESCRIPTION:
//
// Called by the display driver to process an OSI specific request
//
// PARAMETERS:    pso   - pointer to surface object
//                cjIn  - (IN)  size of request block
//                pvIn  - (IN)  pointer to request block
//                cjOut - (IN)  size of response block
//                pvOut - (OUT) pointer to response block
//
// RETURNS:       None
//
//
ULONG OSI_DDProcessRequest(SURFOBJ* pso,
                                     UINT cjIn,
                                     void *  pvIn,
                                     UINT cjOut,
                                     void *  pvOut)
{
    ULONG               rc;
    LPOSI_ESCAPE_HEADER pHeader;
    LPOSI_PDEV          ppdev = (LPOSI_PDEV)pso->dhpdev;

    DebugEntry(OSI_DDProcessRequest);

    //
    // Get the request number.
    //
    pHeader = pvIn;
    switch (pHeader->escapeFn)
    {
        case OSI_ESC_INIT:
        {
            TRACE_OUT(("DrvEscape:  OSI_ESC_INIT"));
            ASSERT(cjOut == sizeof(OSI_INIT_REQUEST));

            //
            // Get shared memory block
            //
            OSI_DDInit(ppdev, (LPOSI_INIT_REQUEST)pvOut);
            rc = TRUE;
        }
        break;

        case OSI_ESC_TERM:
        {
            TRACE_OUT(("DrvEscape:  OSI_ESC_TERM"));
            ASSERT(cjIn == sizeof(OSI_TERM_REQUEST));

            //
            // Cleanup, NM is going away
            //
            OSI_DDTerm(ppdev);
            rc = TRUE;
        }
        break;

        case OSI_ESC_SYNC_NOW:
        {
            TRACE_OUT(("DrvEscape:  OSI_ESC_SYNC_NOW"));
            ASSERT(cjIn == sizeof(OSI_ESCAPE_HEADER));

            //
            // Resync with the 32-bit ring 3 core.  This happens when
            // somebody joins or leaves a share.
            //
            BA_ResetBounds();
            OA_DDSyncUpdatesNow();
            SBC_DDSyncUpdatesNow(ppdev);
            rc = TRUE;
        }
        break;


        default:
        {
            ERROR_OUT(("Unrecognised request %lu", pHeader->escapeFn));
            rc = FALSE;
        }
        break;
    }

    DebugExitBOOL(OSI_DDProcessRequest, rc);
    return(rc);
}




//
// Function:    OSI_DDInit
//
// Description: Map the shared memory into Kernel and User space
//
// Parameters:  count - size of the buffer to return to user space
//              pData - pointer to the buffer to be returned to user space
//
// Returns:     (none)
//
void OSI_DDInit(LPOSI_PDEV ppdev, LPOSI_INIT_REQUEST pResult)
{
    DWORD               memRemaining;
    LPBYTE              pBuffer;
    LPVOID              shmMappedMemory;

    VIDEO_SHARE_MEMORY              ShareMemory;
    VIDEO_SHARE_MEMORY_INFORMATION  ShareMemoryInformation;
    DWORD                           ReturnedDataLength;

    DebugEntry(OSI_DDInit);

    // Init to FALSE
    pResult->result = FALSE;

    // Initialize these to NULL
    pResult->pSharedMemory  = NULL;
    pResult->poaData[0]     = NULL;
    pResult->poaData[1]     = NULL;
    pResult->sbcEnabled   = FALSE;

    //
    // Check that the memory is available to the driver and that we are not
    // in a race condition.
    //
    if (g_asSharedMemory == NULL)
    {
        ERROR_OUT(("No memory available"));
        DC_QUIT;
    }

    if (g_shmMappedMemory != NULL)
    {
        //
        // We will never come in here with two copies of NetMeeting running.
        // The UI code prevents the second instance from starting long
        // before app sharing is in the picture.  Therefore, these are the
        // only possibilities:
        //
        //  (1) Previous version is almost shutdown but hasn't called OSI_DDTerm
        // yet and new version is starting up and calls OSI_DDInit
        //
        //  (2) Previous version terminated abnormally and never called
        // OSI_DDTerm().  This code handles the second case.  The first one
        // is handled by the same code in the UI that prevents two copies
        // from starting around the same time.
        //
        WARNING_OUT(("OSI_DDInit:  NetMeeting did not shutdown cleanly last time"));
        OSI_DDTerm(ppdev);
    }

    //
    // Map the shared section into the caller's process.
    //
    INIT_OUT(("OSI_DDInit: Mapping 0x%08x bytes of kernel memory at 0x%08x into caller process",
        g_shmSharedMemorySize, g_asSharedMemory));
    ShareMemory.ProcessHandle           = LongToHandle(-1);
    ShareMemory.ViewOffset              = 0;
    ShareMemory.ViewSize                = g_shmSharedMemorySize;
    ShareMemory.RequestedVirtualAddress = NULL;

    if (EngDeviceIoControl(ppdev->hDriver,
            IOCTL_VIDEO_SHARE_VIDEO_MEMORY,
            &ShareMemory,
            sizeof(VIDEO_SHARE_MEMORY),
            &ShareMemoryInformation,
            sizeof(VIDEO_SHARE_MEMORY_INFORMATION),
            &ReturnedDataLength) != 0)
    {
        ERROR_OUT(("Failed to map shared memory into calling process"));
        DC_QUIT;
    }

    //
    // USER MODE pointer (not valid in kernel mode)
    //
    INIT_OUT(("OSI_DDInit: Mapped 0x%08x bytes of kernel memory to user memory 0x%08x",
        g_shmSharedMemorySize, ShareMemoryInformation.VirtualAddress));

    shmMappedMemory        = ShareMemoryInformation.VirtualAddress;
    pResult->pSharedMemory = shmMappedMemory;
    pResult->poaData[0]    = ((LPSHM_SHARED_MEMORY)pResult->pSharedMemory) + 1;
    pResult->poaData[1]    = ((LPOA_SHARED_DATA)pResult->poaData[0]) + 1;

    TRACE_OUT(("Shared memory %08lx %08lx %08lx",
            pResult->pSharedMemory, pResult->poaData[0], pResult->poaData[1]));

    //
    // Clear out the shared memory, so it's ready for immediate use.
    // NOTE THAT THIS SETS ALL VALUES TO FALSE.
    // NOTE ALSO THAT THIS CLEARS the two OA_SHARED_DATAs also
    //
    RtlFillMemory(g_asSharedMemory, SHM_SIZE_USED, 0);
    g_asSharedMemory->displayToCore.indexCount    = 0;

    //
    // Set up our pointer to the variable part of the shared memory i.e.
    // the part which is not used for the SHM_SHARED_MEMORY structure
    // We must skip past g_asSharedMemory, two CM_FAST_DATA structs, and
    // two OA_SHARED_DATA structs.
    //
    pBuffer      = (LPBYTE)g_asSharedMemory;
    pBuffer     += SHM_SIZE_USED;
    memRemaining = g_shmSharedMemorySize - SHM_SIZE_USED;

    //
    // Initialise the other components required for DC-Share
    //

    //
    // Bounds accumulation
    //
    BA_DDInit();

    //
    // Cursor
    //
    if (!CM_DDInit(ppdev))
    {
        ERROR_OUT(("CM failed to init"));
        DC_QUIT;
    }

    //
    // Send Bitmap Cache
    // NOTE that if it initializes OK but no caching allowed, we will continue.
    //
    // This will fill in the tile buffers & info.  If no SBC caching allowed,
    // the sbcEnabled field will be FALSE.
    //
    if (SBC_DDInit(ppdev, pBuffer, memRemaining, pResult))
    {
        pResult->sbcEnabled = TRUE;
    }

    //
    // Mark memory as ready to use.
    //
    g_shmMappedMemory = shmMappedMemory;
    pResult->result = TRUE;

DC_EXIT_POINT:
    DebugExitVOID(OSI_DDInit);
}


//
// Function:    OSI_DDTerm
//
// Description: Cleanup when NM shuts down
//
// Returns:     (none)
//
void OSI_DDTerm(LPOSI_PDEV ppdev)
{
    DebugEntry(OSI_DDTerm);

    //
    // Check for a valid address - must be non-NULL.
    //
    if (!g_asSharedMemory)
    {
        ERROR_OUT(("Invalid memory"));
        DC_QUIT;
    }


    //
    // Terminate the dependent components.
    //

    //
    // Hosted Entity Tracker
    //
    HET_DDTerm();

    //
    // Order Encoding
    //
    OE_DDTerm();

    //
    // Send Bitmap Cache
    //
    SBC_DDTerm();

    //
    // Cursor manager.
    //
    CM_DDTerm();

    //
    // The shared memory will be unmapped automatically in this process
    // by OS cleanup, in both NT4 and NT5
    //
    g_shmMappedMemory = NULL;

DC_EXIT_POINT:
    DebugExitVOID(OSI_DDTerm);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\dd\shm.c ===
#include "precomp.h"


//
// SHM.C
// Shared Memory Access, cpi32 and display driver sides both
//
// Copyright(c) Microsoft 1997-
//


//
// SHM_StartAccess
//
LPVOID  SHM_StartAccess(int block)
{
    LPBUFFER_CONTROL    pControl    = NULL;
    LPVOID              pMemBlock   = NULL;

    DebugEntry(SHM_StartAccess);

    //
    // Test for shared memory present
    //
    ASSERT(g_asSharedMemory != NULL);

    //
    // Determine which data block we are handling...
    //
    switch (block)
    {
        case SHM_OA_DATA:
            pControl = &g_asSharedMemory->displayToCore;
            break;

        case SHM_OA_FAST:
        case SHM_BA_FAST:
        case SHM_CM_FAST:
            pControl = &g_asSharedMemory->fastPath;
            break;

        default:
            ERROR_OUT(("Unknown type %d", block));
            DC_QUIT;
    }

    //
    // Mark the double-buffer as busy.
    //
    pControl->busyFlag = 1;

    //
    // Set up the current buffer pointer if this is the first access to the
    // shared memory.
    //
    pControl->indexCount++;
    if (pControl->indexCount == 1)
    {
        //
        // Set up the 'in use' buffer pointer
        //
        pControl->currentBuffer = pControl->newBuffer;

        //
        // Mark the buffer as busy so that the Share Core knows where we
        // are.
        //
        pControl->bufferBusy[pControl->currentBuffer] = 1;
    }

    //
    // Get the pointer to the block to return
    //
    switch (block)
    {
        case SHM_OA_DATA:
            pMemBlock = g_poaData[pControl->currentBuffer];
            break;

        case SHM_OA_FAST:
            pMemBlock = &(g_asSharedMemory->oaFast[pControl->currentBuffer]);
            break;

        case SHM_BA_FAST:
            pMemBlock = &(g_asSharedMemory->baFast[pControl->currentBuffer]);
            break;

        case SHM_CM_FAST:
            pMemBlock = &(g_asSharedMemory->cmFast[pControl->currentBuffer]);
            break;

        default:
            ERROR_OUT(("Unknown type %d", block));
            DC_QUIT;
    }

DC_EXIT_POINT:
    DebugExitPVOID(SHM_StartAccess, pMemBlock);
    return(pMemBlock);
}


//
// SHM_StopAccess
//
void  SHM_StopAccess(int block)
{
    LPBUFFER_CONTROL pControl;

    DebugEntry(SHM_StopAccess);

    ASSERT(g_asSharedMemory != NULL);

    //
    // Determine which data block we are handling...
    //
    switch (block)
    {
        case SHM_OA_DATA:
            pControl = &g_asSharedMemory->displayToCore;
            break;

        case SHM_OA_FAST:
        case SHM_BA_FAST:
        case SHM_CM_FAST:
            pControl = &g_asSharedMemory->fastPath;
            break;

        default:
            ERROR_OUT(("Unknown type %d", block));
            DC_QUIT;
    }

    //
    // Decrement usage count - if we have finally finished with the memory,
    // clear the busy flags so that the Share Core knows it won't tread on
    // the display driver's toes.
    //
    pControl->indexCount--;
    if (pControl->indexCount == 0)
    {
        pControl->bufferBusy[pControl->currentBuffer] = 0;

        pControl->busyFlag = 0;
    }

DC_EXIT_POINT:
    DebugExitVOID(SHM_StopAccess);
}


#ifdef _DEBUG
//
// SHM_CheckPointer - see shm.h
//
void  SHM_CheckPointer(LPVOID ptr)
{
    DebugEntry(SHMCheckPointer);

    if (ptr == NULL)
    {
        ERROR_OUT(("Null pointer"));
        DC_QUIT;
    }

    ASSERT(g_asSharedMemory);

    if (((LPBYTE)ptr - (LPBYTE)g_asSharedMemory < 0) ||
        ((LPBYTE)ptr - (LPBYTE)g_asSharedMemory >= SHM_SIZE_USED))
    {
        ERROR_OUT(("Bad pointer"));
    }

DC_EXIT_POINT:
    DebugExitVOID(SHM_CheckPointer);
}
#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\dd\sbc.c ===
#include "precomp.h"


//
// SBC.C
// Send Bitmap Cache, display driver side
//
// Copyright(c) Microsoft 1997-
//


//
//
// SBC_DDProcessRequest() - see sbc.h
//
//
BOOL SBC_DDProcessRequest
(
    SURFOBJ*  pso,
    DWORD     fnEscape,
    LPOSI_ESCAPE_HEADER pRequest,
    LPOSI_ESCAPE_HEADER pResult,
    DWORD     cbResult
)
{
    BOOL            rc;
    LPOSI_PDEV      ppDev = (LPOSI_PDEV)pso->dhpdev;

    DebugEntry(SBC_DDProcessRequest);

    //
    // Get the request number.
    //
    switch (fnEscape)
    {
        case SBC_ESC_NEW_CAPABILITIES:
        {
            if (cbResult != sizeof(SBC_NEW_CAPABILITIES))
            {
                ERROR_OUT(("SBC_DDProcessRequest:  Invalid size %d for SBC_ESC_NEW_CAPABILITIES",
                    cbResult));
                rc = FALSE;
                DC_QUIT;
            }
            TRACE_OUT(("SBC_ESC_NEW_CAPABILITIES"));

            SBCDDSetNewCapabilities((LPSBC_NEW_CAPABILITIES)pRequest);

            rc = TRUE;
        }
        break;

        default:
        {
            ERROR_OUT(("Unrecognized SBC_ escape"));
            rc = FALSE;
        }
        break;
    }

DC_EXIT_POINT:
    DebugExitBOOL(SBC_DDProcessRequest, rc);
    return(rc);
}


//
//
// SBC_DDInit() - see sbc.h
//
//
BOOL SBC_DDInit
(
    LPOSI_PDEV  ppDev,
    LPBYTE      pRestOfMemory,
    DWORD       cbRestOfMemory,
    LPOSI_INIT_REQUEST   pResult
)
{
    UINT    i;
    SIZEL   bitmapSize;
    BOOL    rc = FALSE;

    DebugEntry(SBC_DDInit);

    //
    // We have to create work DIBs to Blt into when SBC_CacheMemScreenBlt
    // is called.
    //
    for (i = 0 ; i < SBC_NUM_TILE_SIZES ; i++)
    {
        ASSERT(!g_asbcWorkInfo[i].pShuntBuffer);
        ASSERT(!g_asbcWorkInfo[i].mruIndex);
        ASSERT(!g_asbcWorkInfo[i].workBitmap);

        if (i == SBC_MEDIUM_TILE_INDEX)
        {
            g_asbcWorkInfo[SBC_MEDIUM_TILE_INDEX].tileWidth = MP_MEDIUM_TILE_WIDTH;
            g_asbcWorkInfo[SBC_MEDIUM_TILE_INDEX].tileHeight = MP_MEDIUM_TILE_HEIGHT;
        }
        else
        {
            ASSERT(i == SBC_LARGE_TILE_INDEX);

            g_asbcWorkInfo[SBC_LARGE_TILE_INDEX].tileWidth = MP_LARGE_TILE_WIDTH;
            g_asbcWorkInfo[SBC_LARGE_TILE_INDEX].tileHeight = MP_LARGE_TILE_HEIGHT;
        }

        //
        // Create the bitmap.  Note that we create it "top down" rather
        // than the default of "bottom up" to simplify copying data from
        // the bitmap (we don't have to work out offsets into the data - we
        // can copy from the beginning).
        //
        // We set the last parameter to NULL, to allow GDI to allocate
        // memory for the bits.  We can get a pointer to the bits later
        // when we have a SURFOBJ for the bitmap.
        //
        bitmapSize.cx = g_asbcWorkInfo[i].tileWidth;
        bitmapSize.cy = g_asbcWorkInfo[i].tileHeight;

        g_asbcWorkInfo[i].workBitmap = EngCreateBitmap(bitmapSize,
            BYTES_IN_BITMAP(g_asbcWorkInfo[i].tileWidth, 1, ppDev->cBitsPerPel),
            ppDev->iBitmapFormat, BMF_TOPDOWN, NULL);

        if (! g_asbcWorkInfo[i].workBitmap)
        {
            ERROR_OUT(( "Failed to create work bitmap %d", i));
            DC_QUIT;
        }
    }

    //
    // Initialize the shunt buffers
    //
    if (! SBCDDCreateShuntBuffers(ppDev, pRestOfMemory, cbRestOfMemory))
    {
        ERROR_OUT(( "Failed to create shunt buffers"));
        DC_QUIT;
    }

    //
    // Set up the remaining global variables
    //
    EngQueryPerformanceFrequency(&g_sbcPerfFrequency);

    //
    // OK, so we can create our SBC cache.  Fill in the details.
    //

    for (i = 0 ; i < SBC_NUM_TILE_SIZES; i++)
    {
        //
        // This is filling in the APP address to the shunt buffers.
        //
        pResult->psbcTileData[i] = (LPBYTE)pResult->pSharedMemory +
            PTRBASE_TO_OFFSET(g_asbcWorkInfo[i].pShuntBuffer, g_asSharedMemory);
    }

    pResult->aBitmasks[0] = ppDev->flRed;
    pResult->aBitmasks[1] = ppDev->flGreen;
    pResult->aBitmasks[2] = ppDev->flBlue;

    //
    // If we are a palette device (i.e.  we are running at 8 bpp or less),
    // set the paletteChanged flag so that we will send a color table to
    // the share core before our first Mem(3)Blt.
    //
    ppDev->paletteChanged = (ppDev->cBitsPerPel <= 8);

    rc = TRUE;
DC_EXIT_POINT:
    DebugExitBOOL(SBC_DDInit, rc);
    return(rc);
}


//
//
// SBC_DDTerm() - see sbc.h
//
//
void SBC_DDTerm(void)
{
    UINT    i;

    DebugEntry(SBC_DDTerm);

    //
    // We just have to set the pointers to the shunt buffers to NULL
    //
    for (i = 0 ; i < SBC_NUM_TILE_SIZES ; i++)
    {
        // Kill the bitmap if there
        if (g_asbcWorkInfo[i].workBitmap)
        {
            EngDeleteSurface((HSURF)g_asbcWorkInfo[i].workBitmap);
            g_asbcWorkInfo[i].workBitmap = 0;
        }

        g_asbcWorkInfo[i].pShuntBuffer = NULL;
        g_asbcWorkInfo[i].mruIndex        = 0;
    }

    DebugExitVOID(SBC_DDTerm);
}


//
//
// SBC_DDIsMemScreenBltCachable() - see sbc.h
//
//
BOOL SBC_DDIsMemScreenBltCachable(LPMEMBLT_ORDER_EXTRA_INFO pMemBltInfo)
{
    BOOL            rc = FALSE;
    UINT            tileWidth;
    UINT            tileHeight;
    SURFOBJ *       pSourceSurf;

    DebugEntry(SBC_DDIsMemScreenBltCachable);

    //
    // Is this an RLE bitmap - these bitmaps can have effective transparent
    // sections which we cannot mimic with SBC.
    //
    pSourceSurf = pMemBltInfo->pSource;
    if ( (pSourceSurf->iBitmapFormat == BMF_4RLE) ||
         (pSourceSurf->iBitmapFormat == BMF_8RLE) )
    {
        TRACE_OUT(( "RLE Bitmap %d", pSourceSurf->iBitmapFormat));
        DC_QUIT;
    }

    //
    // If this is a thrasher then don't cache it
    //
    if (SBCDDIsBitmapThrasher(pSourceSurf))
    {
        TRACE_OUT(( "Its a thrasher"));
        DC_QUIT;
    }

    //
    // Make sure that this bitmap can be tiled OK
    //
    if (!SBC_DDQueryBitmapTileSize(pSourceSurf->sizlBitmap.cx,
                                   pSourceSurf->sizlBitmap.cy,
                                   &tileWidth,
                                   &tileHeight))
    {
        TRACE_OUT(("Cache does not support tiling"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(SBC_DDIsMemScreenBltCachable, rc);
    return(rc);
}


//
//
// SBC_DDCacheMemScreenBlt() - see sbc.h
//
//
BOOL SBC_DDCacheMemScreenBlt
(
    LPINT_ORDER         pOrder,
    LPMEMBLT_ORDER_EXTRA_INFO   pMemBltInfo
)
{
    BOOL                rc = FALSE;
    LPMEMBLT_ORDER      pMemBltOrder = (LPMEMBLT_ORDER)&(pOrder->abOrderData);
    LPMEM3BLT_ORDER     pMem3BltOrder = (LPMEM3BLT_ORDER)pMemBltOrder;
    UINT                bmpWidth;
    UINT                bmpHeight;
    UINT                tileWidth;
    UINT                tileHeight;
    POINTL              tileOrg;
    UINT                cxSubBitmapWidth;
    UINT                cySubBitmapHeight;
    UINT                type;
    SURFOBJ *           pDestSurf;
    SURFOBJ *           pSourceSurf;
    LPOSI_PDEV          pDestDev;
    SURFOBJ *           pWorkSurf = NULL;
    LPBYTE              pWorkBits;
    RECTL               destRectl;
    POINTL              sourcePt;
    int                 tileSize;
    LPSBC_TILE_DATA     pTileData = NULL;

    DebugEntry(SBC_DDCacheMemScreenBlt);

    //
    // Do a first pass on the cacheability of the Blt
    //
    if (!SBC_DDIsMemScreenBltCachable(pMemBltInfo))
    {
        TRACE_OUT(( "This MemBlt Order is not cachable"));
        DC_QUIT;
    }

    //
    // Get the width and height of the source bitmap
    //
    pSourceSurf = pMemBltInfo->pSource;
    bmpWidth    = pSourceSurf->sizlBitmap.cx;
    bmpHeight   = pSourceSurf->sizlBitmap.cy;

    //
    // Calculate the tile size for this blit
    //

    if (!SBC_DDQueryBitmapTileSize(bmpWidth, bmpHeight, &tileWidth, &tileHeight))
    {
        TRACE_OUT(("Cache does not support tiling"));
        DC_QUIT;
    }

    //
    // Set up pointers to the source coordinates in the order.
    //
    type = pMemBltOrder->type;
    if (type == ORD_MEMBLT_TYPE)
    {
        sourcePt.x = pMemBltOrder->nXSrc;
        sourcePt.y = pMemBltOrder->nYSrc;
        TRACE_OUT((
              "Request to cache MemBlt (%d, %d), %d x %d -> (%d, %d), src %x",
                 sourcePt.x,
                 sourcePt.y,
                 pMemBltOrder->nWidth,
                 pMemBltOrder->nHeight,
                 pMemBltOrder->nLeftRect,
                 pMemBltOrder->nTopRect,
                 pSourceSurf->hsurf));
    }
    else
    {
        sourcePt.x = pMem3BltOrder->nXSrc;
        sourcePt.y = pMem3BltOrder->nYSrc;
        TRACE_OUT((
             "Request to cache Mem3Blt (%d, %d), %d x %d -> (%d, %d), src %x",
                 sourcePt.x,
                 sourcePt.y,
                 pMem3BltOrder->nWidth,
                 pMem3BltOrder->nHeight,
                 pMem3BltOrder->nLeftRect,
                 pMem3BltOrder->nTopRect,
                 pSourceSurf->hsurf));
    }

    //
    // Calculate the tile origin and size of remaining bitmap.  Origin is
    // rounded down to the nearest tile.  Actual size of bitmap to cache
    // may be smaller than tile size if the tile runs off the right/bottom
    // of the bitmap
    //
    tileOrg.x = sourcePt.x - (sourcePt.x % tileWidth);
    tileOrg.y = sourcePt.y - (sourcePt.y % tileHeight);

    //
    // Actual size of bitmap to cache may be smaller than tile size if the
    // tile runs off the right/bottom of the bitmap. To see why this
    // calculation is correct, realize that (bmpWidth - tileOrg.x) is the
    // remaining width of the bitmap after the start of this tile.
    //
    cxSubBitmapWidth  = min(tileWidth, bmpWidth - tileOrg.x);
    cySubBitmapHeight = min(tileHeight, bmpHeight - tileOrg.y);

    //
    // We know how large a tile we have - we now have to Blt it into one of
    // our work bitmaps and pass it up to the share core.  First, work out
    // which of our work bitmaps we should use and set up some variables
    // based on this.
    //
    for (tileSize = 0; tileSize < SBC_NUM_TILE_SIZES ; tileSize++)
    {
        if ((cxSubBitmapWidth <= g_asbcWorkInfo[tileSize].tileWidth) &&
            (cySubBitmapHeight <= g_asbcWorkInfo[tileSize].tileHeight))
        {
            break;
        }
    }

    if (tileSize == SBC_NUM_TILE_SIZES)
    {
        ERROR_OUT(( "%d x %d tile doesn't fit into work bmp",
                     cxSubBitmapWidth,
                     cySubBitmapHeight));
        DC_QUIT;
    }

    //
    // Before doing any more work, get the next free entry in the shunt
    // buffer.  Note that this fills in the tileId element of the returned
    // structure.
    //
    // It is perfectly valid for this call to fail.  The shunt buffer may
    // just be full if we are sending lots of bitmap data up to the share
    // core.
    //
    if (!SBCDDGetNextFreeTile(tileSize, &pTileData))
    {
        TRACE_OUT(( "Unable to get a free tile in shunt buffer"));
        DC_QUIT;
    }

    //
    // Lock the work bitmap to get a surface to pass to EngBitBlt
    //
    pWorkSurf = EngLockSurface((HSURF)g_asbcWorkInfo[tileSize].workBitmap);
    if (pWorkSurf == NULL)
    {
        ERROR_OUT(( "Failed to lock work surface"));
        DC_QUIT;
    }
    TRACE_OUT(( "Locked surface"));

    //
    // Do the Blt to our work bitmap to get the bits at native bpp, and
    // using the color table which we sent to the share core.
    //
    destRectl.top    = 0;
    destRectl.left   = 0;
    destRectl.right  = cxSubBitmapWidth;
    destRectl.bottom = cySubBitmapHeight;

    sourcePt = tileOrg;

    if (!EngBitBlt(pWorkSurf,
                   pSourceSurf,
                   NULL,                    // mask surface
                   NULL,                    // clip object
                   pMemBltInfo->pXlateObj,
                   &destRectl,
                   &sourcePt,
                   NULL,                    // mask origin
                   NULL,                    // brush
                   NULL,                    // brush origin
                   0xcccc))                 // SRCCPY
    {
        ERROR_OUT(( "Failed to Blt to work bitmap"));
        DC_QUIT;
    }
    TRACE_OUT(( "Completed BitBlt"));

    //
    // The Blt succeeded, so pass the bits to the share core by copying
    // them into the correct shunt buffer.
    //
    // bytesUsed is set to the number of bytes required for
    // cySubBitmapHeight number of full scanlines in the shunt buffer tile
    // (NOT the number of bytes available in the tile, or the number of
    // bytes of data which was actually Blted)
    //
    // major/minorCacheInfo are set to details from the source surface.
    // hdev does not change on consecutive Blts from the same surface, but
    // iUniq may.
    //
    pDestSurf            = pMemBltInfo->pDest;
    pDestDev             = (LPOSI_PDEV)pDestSurf->dhpdev;
    pTileData->bytesUsed = BYTES_IN_BITMAP(g_asbcWorkInfo[tileSize].tileWidth,
                                           cySubBitmapHeight,
                                           pDestDev->cBitsPerPel);
    pTileData->srcX           = (TSHR_UINT16)sourcePt.x;
    pTileData->srcY           = (TSHR_UINT16)sourcePt.y;
    pTileData->width          = (WORD)cxSubBitmapWidth;
    pTileData->height         = (WORD)cySubBitmapHeight;
    pTileData->tilingWidth    = (WORD)tileWidth;
    pTileData->tilingHeight   = (WORD)tileHeight;
    pTileData->majorCacheInfo = (UINT_PTR)pSourceSurf->hsurf;
    pTileData->minorCacheInfo = (UINT)pSourceSurf->iUniq;
    pTileData->majorPalette   = (UINT_PTR)pMemBltInfo->pXlateObj;
    pTileData->minorPalette   = (UINT)(pMemBltInfo->pXlateObj != NULL ?
                                           pMemBltInfo->pXlateObj->iUniq : 0);

    //
    // If the source surface has the BMF_DONTCACHE flag set then it is a
    // DIB Section.  This means that an app can change the bits in the
    // surface without calling GDI, and hence without the iUniq value being
    // updated.
    //
    // We rely on iUniq changing for the fast path to work, so we must
    // exclude these bitmaps from the fast path.  Do this by resetting the
    // majorCacheInfo field (we use this rather than minorCacheInfo because
    // we can't tell what an invalid iUniq value is).
    //
    if ( (pSourceSurf->iType == STYPE_BITMAP) &&
         ((pSourceSurf->fjBitmap & BMF_DONTCACHE) != 0) )
    {
        TRACE_OUT(( "Source hsurf %#.8lx has BMF_DONTCACHE set",
                     pTileData->majorCacheInfo));
        pTileData->majorCacheInfo = SBC_DONT_FASTPATH;
    }

    //
    // Note that this only works correctly because we create our work
    // bitmaps to be "top down" rather than the default of "bottom up".
    // i.e.  the data for the top scanline is first in memory, so we can
    // start copying from the start of the bit data.  Bottom up would mean
    // working out an offset into the work bitmap to start copying from.
    //
    memcpy(pTileData->bitData, pWorkSurf->pvBits, pTileData->bytesUsed);

    //
    // We've done the copy.  Reset the work bitmap bits for next time we
    // use this work bitmap - this helps with compression later on.
    //
    memset(pWorkSurf->pvBits, 0, pWorkSurf->cjBits);

    //
    // Fill in the required info in the Mem(3)Blt order.
    //
    if (type == ORD_MEMBLT_TYPE)
    {
        pMemBltOrder->cacheId = pTileData->tileId;
    }
    else
    {
        pMem3BltOrder->cacheId = pTileData->tileId;
    }

    //
    // We've filled in all the data in the shunt buffer entry, so mark it
    // as in use so that the share core can access it.
    //
    pTileData->inUse = TRUE;

    //
    // Must have completed successfully to get to here
    //
    TRACE_OUT(( "Queued tile (%d, %d), %d x %d, tile %d x %d, Id %hx",
                 sourcePt.x,
                 sourcePt.y,
                 cxSubBitmapWidth,
                 cySubBitmapHeight,
                 g_asbcWorkInfo[tileSize].tileWidth,
                 g_asbcWorkInfo[tileSize].tileHeight,
                 pTileData->tileId));
    rc = TRUE;

DC_EXIT_POINT:

    //
    // Unlock the work surface (if required)
    //
    if (pWorkSurf != NULL)
    {
        EngUnlockSurface(pWorkSurf);
        TRACE_OUT(( "Unlocked surface"));
    }

    DebugExitDWORD(SBC_DDCacheMemScreenBlt, rc);
    return(rc);
}



//
// SBC_DDQueryBitmapTileSize()
//
// Once 2.X COMPAT is gone, we don't need this anymore.  We won't set our
// random cell sizes based off of what REMOTES say.
//
BOOL SBC_DDQueryBitmapTileSize
(
    UINT    bmpWidth,
    UINT    bmpHeight,
    UINT *  pTileWidth,
    UINT *  pTileHeight
)
{
    BOOL    rc = FALSE;

    DebugEntry(SBC_DDQueryBitmapTileSize);

    //
    // The tile cell sizes are currently changed when back level nodes
    // join in a 3.0 call, in which case we must take the MINIMUM of the
    // cell sizes/entries for everybody in the share.
    //
    if (g_asbcCacheInfo[ID_LARGE_BMP_CACHE].cCellSize <
            BYTES_IN_BITMAP(g_asbcWorkInfo[SBC_MEDIUM_TILE_INDEX].tileWidth,
                            g_asbcWorkInfo[SBC_MEDIUM_TILE_INDEX].tileHeight,
                            g_sbcSendingBPP))
    {
        //
        // This should be a short-term thing.  When an old dude joins the
        // share, we'll also adjust g_sbcSendingBPP.
        //
        TRACE_OUT(("SBC_DDQueryBitmapTileSize:  No space for any cells"));
        DC_QUIT;
    }

    rc = TRUE;

    //
    // If the large size is adequate, use that cell size
    //
    if (g_asbcCacheInfo[ID_LARGE_BMP_CACHE].cCellSize >=
        BYTES_IN_BITMAP(g_asbcWorkInfo[SBC_LARGE_TILE_INDEX].tileWidth,
                        g_asbcWorkInfo[SBC_LARGE_TILE_INDEX].tileHeight,
                        g_sbcSendingBPP))
    {
        if ((bmpWidth > g_asbcWorkInfo[SBC_MEDIUM_TILE_INDEX].tileWidth) ||
            (bmpHeight > g_asbcWorkInfo[SBC_MEDIUM_TILE_INDEX].tileHeight))
        {
            *pTileWidth = g_asbcWorkInfo[SBC_LARGE_TILE_INDEX].tileWidth;
            *pTileHeight = g_asbcWorkInfo[SBC_LARGE_TILE_INDEX].tileHeight;
            DC_QUIT;
        }
    }

    //
    // Sigh, medium cells it is.
    //
    *pTileWidth = g_asbcWorkInfo[SBC_MEDIUM_TILE_INDEX].tileWidth;
    *pTileHeight = g_asbcWorkInfo[SBC_MEDIUM_TILE_INDEX].tileHeight;

DC_EXIT_POINT:
    DebugExitBOOL(SBC_DDQueryBitmapTileSize, rc);
    return(rc);
}




//
//
// SBC_DDSyncUpdatesNow() - see sbc.h
//
//
void SBC_DDSyncUpdatesNow(LPOSI_PDEV ppDev)
{
    LPSBC_TILE_DATA  pTileData;
    UINT          i;
    UINT          j;

    DebugEntry(SBC_DDSyncUpdatesNow);

    TRACE_OUT(( "Marking all shunt buffer entries as not in use"));

    //
    // We have to mark all entries in the shunt buffers as being free.
    //
    for (i = 0; i < SBC_NUM_TILE_SIZES ; i++)
    {
    	if(g_asbcWorkInfo[i].pShuntBuffer)
    	{
		for (j = 0; j < g_asbcWorkInfo[i].pShuntBuffer->numEntries ; j++)
       		{
        		pTileData = SBCTilePtrFromIndex(g_asbcWorkInfo[i].pShuntBuffer, j);
	            	pTileData->inUse = FALSE;
		}
    	}
        //
        // Reset the MRU counter for this shunt buffer
        //
        g_asbcWorkInfo[i].mruIndex = 0;
    }

    //
    // If we are a palette device (i.e.  we are running at 8 bpp or less),
    // set the paletteChanged flag so we will send up a color table before
    // our next Mem(3)Blt.  We do this because the color table order for
    // the current device palette may have been discarded during the OA
    // sync.
    //
    ppDev->paletteChanged = (ppDev->cBitsPerPel <= 8);

    DebugExitVOID(SBC_DDSyncUpdatesNow);
}


//
//
// SBC_DDOrderSpoiltNotification() - see sbc.h
//
//
void SBC_DDOrderSpoiltNotification(LPINT_ORDER pOrder)
{
    LPMEMBLT_ORDER      pMemBltOrder  = (LPMEMBLT_ORDER)&(pOrder->abOrderData);
    LPMEM3BLT_ORDER     pMem3BltOrder = (LPMEM3BLT_ORDER)pMemBltOrder;
    UINT                tileId;
    LPSBC_TILE_DATA     pTileData;
    UINT                tileType;
    UINT                i;

    DebugEntry(SBC_DDOrderSpoiltNotification);

    //
    // pOrder has been removed from the order heap before being processed.
    // We have to free up the entry which it references in one of the shunt
    // buffers.  First get the tile Id.
    //
    if (pMemBltOrder->type == ORD_MEMBLT_TYPE)
    {
        tileId = pMemBltOrder->cacheId;
    }
    else
    {
        tileId = pMem3BltOrder->cacheId;
    }
    TRACE_OUT(( "Order referencing tile %hx has been spoiled", tileId));

    //
    // Find out which of the shunt buffers the entry should be in based on
    // the tileId
    //
    tileType = SBC_TILE_TYPE(tileId);

    //
    // We implement the shunt buffers as circular FIFO queues, so we will
    // start looking from the last order which we marked as being in use,
    // and work BACKWARDS.  This is because, in general, the entries after
    // the last one we accessed will not be in use (unless the whole shunt
    // buffer is in use).
    //
    // So, get the index of the last tile we accessed.
    //
    i = g_asbcWorkInfo[tileType].mruIndex;

    //
    // Loop through the circular buffer until we get a match, or have
    // circled back to the beginning.
    //
    // Note that this has been coded as a "do while" loop, rather than just
    // a "while" loop so that we don't miss mruIndex.  mruIndex is set up
    // to point to the NEXT entry to be used, rather than the last entry to
    // be used, so decrementing i before doing any work first time round
    // the loop is actually what we want to do.
    //
    do
    {
        //
        // On to the next tile
        //
        i = (i == 0)
          ? g_asbcWorkInfo[tileType].pShuntBuffer->numEntries - 1
          : i - 1;

        pTileData = SBCTilePtrFromIndex(g_asbcWorkInfo[tileType].pShuntBuffer, i);

        if (pTileData->inUse && (pTileData->tileId == tileId))
        {
            //
            // We've got a match, so mark the tile as being free.
            //
            // We don't want to update the shunt buffer mruIndex - this
            // should remain indicating the next tile to be used when
            // adding an entry to the shunt buffer.
            //
            TRACE_OUT(( "Marked tile Id %hx at index %d as free",
                         tileId,
                         i));
            pTileData->inUse = FALSE;
            break;
        }
    }
    while (i != g_asbcWorkInfo[tileType].mruIndex);

    DebugExitVOID(SBC_DDOrderSpoiltNotification);
}


//
//
// SBC_DDMaybeQueueColorTable() - see sbc.h
//
//
BOOL SBC_DDMaybeQueueColorTable(LPOSI_PDEV ppDev)
{
    BOOL                      queuedOK = FALSE;
    int                       orderSize;
    LPINT_ORDER                  pOrder;
    LPINT_COLORTABLE_ORDER_1BPP  pColorTableOrder;
    UINT                      numColors;
    UINT                      i;

    DebugEntry(SBC_DDMaybeQueueColorTable);

    //
    // If we're running at > 8 bpp, then we don't have a palette, so just
    // quit out.
    //
    if (ppDev->cBitsPerPel > 8)
    {
        queuedOK = TRUE;
        DC_QUIT;
    }

    //
    // Check the boolean in our PDEV to see if the palette has changed
    // since the last time we sent a color table order.  Note that if we
    // have a non palette device, the boolean will never be set.
    //
    if (!ppDev->paletteChanged)
    {
        queuedOK = TRUE;
        DC_QUIT;
    }

    //
    // The palette has changed, so allocate order memory to queue a color
    // table order.  The order size depends on the bpp of our device.  Note
    // that the allocation can fail if the order buffer is full.
    //
    switch (ppDev->cBitsPerPel)
    {
        case 1:
        {
            orderSize = sizeof(INT_COLORTABLE_ORDER_1BPP);
        }
        break;

        case 4:
        {
            orderSize = sizeof(INT_COLORTABLE_ORDER_4BPP);
        }
        break;

        case 8:
        {
            orderSize = sizeof(INT_COLORTABLE_ORDER_8BPP);
        }
        break;

        default:
        {
            ERROR_OUT(("Invalid bpp (%d) for palette device", ppDev->cBitsPerPel));
            DC_QUIT;
        }
        break;
    }

    pOrder = OA_DDAllocOrderMem(orderSize, 0);
    if (pOrder == NULL)
    {
        TRACE_OUT(( "Failed to allocate %d bytes for order", orderSize));
        DC_QUIT;
    }
    TRACE_OUT(( "Allocate %d bytes for color table order", orderSize));

    //
    // We've successfully allocated the order, so fill in the details.  We
    // mark the order as internal so that the Update Packager will spot it
    // up in the share core and prevent it being sent over the wire.
    //
    pOrder->OrderHeader.Common.fOrderFlags = OF_INTERNAL;

    pColorTableOrder = (LPINT_COLORTABLE_ORDER_1BPP)&(pOrder->abOrderData);
    pColorTableOrder->header.type = INTORD_COLORTABLE_TYPE;
    pColorTableOrder->header.bpp  = (TSHR_UINT16)ppDev->cBitsPerPel;

    //
    // Unfortunately we can't just copy the palette from the PDEV into the
    // color table order because the PDEV has an array of PALETTEENTRY
    // structures which are RGBs whereas the order has an array of
    // TSHR_RGBQUADs which are BGRs...
    //
    numColors = COLORS_FOR_BPP(ppDev->cBitsPerPel);
    ASSERT(numColors);

    for (i = 0; i < numColors; i++)
    {
        pColorTableOrder->colorData[i].rgbRed   = ppDev->pPal[i].peRed;
        pColorTableOrder->colorData[i].rgbGreen = ppDev->pPal[i].peGreen;
        pColorTableOrder->colorData[i].rgbBlue  = ppDev->pPal[i].peBlue;
    }

    //
    // Add the order
    //
    OA_DDAddOrder(pOrder, NULL);
    TRACE_OUT(( "Added internal color table order, size %d", orderSize));

    //
    // Reset the flag which indicates that the palette needs to be sent
    //
    ppDev->paletteChanged = FALSE;

    //
    // Must be OK to get to here
    //
    queuedOK = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(SBC_DDMaybeQueueColorTable, queuedOK);
    return(queuedOK);
}





//
// SBCDDCreateShuntBuffers()
//
// Here's where we calc how many cache entries (tiles) we can support.  This
// depends on:
//      * The amount of shared memory we have
//      * The color depth of the driver
//
// There is an upper bound on the amount of memory we'll use, since this
// maps to how much memory on remotes will be needed to store our sent
// cache entries.
//
// The tiles are created in a fixed proportion (MP_RATIO_MTOL).
//
// We return TRUE for success if we can set up the caches and create the
// objects necessary for a sent bitmap cache.
//
BOOL SBCDDCreateShuntBuffers
(
    LPOSI_PDEV  ppDev,
    LPBYTE      psbcSharedMemory,
    DWORD       sbcSharedMemorySize
)
{
    int     i;
    UINT    memPerBuffer[SBC_NUM_TILE_SIZES];
    UINT    memPerTile[SBC_NUM_TILE_SIZES];
    UINT    numTiles[SBC_NUM_TILE_SIZES];
    UINT    memRequired;
    LPBYTE  pBuffer        = psbcSharedMemory;
    BOOL    rc             = FALSE;

    DebugEntry(SBCDDCreateShuntBuffers);

    //
    // We should already have a pointer to the shared memory we can use for
    // our shunt buffers, and the number of bytes available.  What we have
    // to do is to partition this shared memory into SBC_NUM_TILE_SIZE
    // shunt buffers.  i.e. one shunt buffer per tile size.
    //
    //
    // <--- buffer 0 ---><------------------ buffer 1 -------------------->
    //
    //Ŀ
    //    :  :  :  :             :        :         :         :        
    //    :  :  :  :       tile  :  tile  :  tile   :  tile   :  tile  
    //    :  :  :  :             :        :         :         :        
    //
    //^ ^                  ^
    //                   
    //  header[0]      header[1]
    //
    // psbcSharedMemory
    //
    //
    // We try to use the number of entries given in the pEntries array, but
    // if we do not have enough shared memory for this, we reduce the
    // number of entries in each shunt buffer, preserving the ratio between
    // the number of entries in each of the shunt buffers.
    //

    //
    // First make sure that we have some shared memory
    //
    if (sbcSharedMemorySize == 0)
    {
        ERROR_OUT(( "No SBC shared memory !"));
        DC_QUIT;
    }

    // Max out at MP_MEMORY_MAX bytes
    sbcSharedMemorySize = min(sbcSharedMemorySize, MP_MEMORY_MAX);

    //
    // Do we have enough shared memory to satisfy the requested number of
    // entries in each shunt buffer ?
    //
    memRequired = 0;

    for (i = 0; i < SBC_NUM_TILE_SIZES; i++)
    {
        memPerTile[i] = SBC_BYTES_PER_TILE(g_asbcWorkInfo[i].tileWidth,
                                           g_asbcWorkInfo[i].tileHeight,
                                           ppDev->cBitsPerPel);

        // We use the same amount of memory for each tile size.
        numTiles[i] = ((sbcSharedMemorySize / SBC_NUM_TILE_SIZES) -
                         (sizeof(SBC_SHUNT_BUFFER) - sizeof(SBC_TILE_DATA))) /
                        memPerTile[i];
        TRACE_OUT(("Can fit %d tiles of memory size %d in tile cache %d",
            numTiles[i], memPerTile[i], i));

        memPerBuffer[i] = (numTiles[i] * memPerTile[i]) +
                          (sizeof(SBC_SHUNT_BUFFER) - sizeof(SBC_TILE_DATA));
        memRequired    += memPerBuffer[i];
    }

    TRACE_OUT(( "%d bytes required for request, %d bytes available",
                 memRequired,
                 sbcSharedMemorySize));

    ASSERT(memRequired <= sbcSharedMemorySize);

    // Zero out rest of amount we're going to use
    RtlFillMemory(psbcSharedMemory, memRequired, 0);


    //
    // OK, we've got the
    //   - the bytes per tile in memPerTile[i]
    //   - number of entries per shunt buffer in numTiles[i]
    //   - the total size of each shunt buffer in memPerBuffer[i].
    //
    // Do the partitioning.
    //
    for (i = 0; i < SBC_NUM_TILE_SIZES ; i++)
    {
        g_asbcWorkInfo[i].pShuntBuffer = (LPSBC_SHUNT_BUFFER)pBuffer;

        g_asbcWorkInfo[i].pShuntBuffer->numEntries    = numTiles[i];
        g_asbcWorkInfo[i].pShuntBuffer->numBytes      = memPerTile[i]
                                                   - sizeof(SBC_TILE_DATA);
        g_asbcWorkInfo[i].pShuntBuffer->structureSize = memPerTile[i];

        //
        // Move the buffer pointer past the memory we are using for this
        // shunt buffer.
        //
        pBuffer += memPerBuffer[i];

        TRACE_OUT(( "Shunt buffer %d at %#.8lx: tile bytes %u, "
                     "structure size %u, num entries %u",
                     i,
                     g_asbcWorkInfo[i].pShuntBuffer,
                     g_asbcWorkInfo[i].pShuntBuffer->numBytes,
                     g_asbcWorkInfo[i].pShuntBuffer->structureSize,
                     g_asbcWorkInfo[i].pShuntBuffer->numEntries));

        //
        // Fill in the mruIndex for this shunt buffer
        //
        g_asbcWorkInfo[i].mruIndex = 0;
    }

    //
    // Initialize the global variables associated with the shunt buffers
    //
    g_sbcNextTileId = 0;

    //
    // Must be OK to get to here
    //
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(SBCDDCreateShuntBuffers, rc);
    return(rc);
}




//
// Name:      SBCGetNextFreeTile
//
// Purpose:   Return the next free tile of the correct size from one of the
//            shunt buffers.
//
// Returns:   TRUE if a tile is returned, FALSE otherwise
//
// Params:    IN  workTileSize - The tile size.  One of
//                     SBC_MEDIUM_TILE
//                     SBC_LARGE_TILE
//            OUT ppTileData   - A pointer to the tile.
//
// Operation: The tileId field of the tile is filled in on return from
//            this function.
//
//
BOOL SBCDDGetNextFreeTile(int tileSize, LPSBC_TILE_DATA FAR * ppTileData)
{
    BOOL              foundFreeTile = FALSE;
    LPSBC_TILE_DATA      pTileData;

    DebugEntry(SBCDDGetNextFreeTile);

    //
    // Make sure that we have a valid tile size
    //
    if (tileSize >= SBC_NUM_TILE_SIZES)
    {
        ERROR_OUT(( "Invalid tile size %d", tileSize));
        DC_QUIT;
    }

    //
    // Get a pointer to th