vided by
caller).

Return:        HRESULT
Side Affect:

Note:
===================================================================*/
HRESULT GetSafeArrayOfCLSIDs
(
IN LPCWSTR      szComponentCLSID,
OUT SAFEARRAY** paCLSIDs
)
{
    SAFEARRAY*          aCLSIDs = NULL;
    SAFEARRAYBOUND      rgsaBound[1];
    LONG                Indices[1];
    VARIANT             varT;
    HRESULT             hr = NOERROR;

    DBG_ASSERT(szComponentCLSID && paCLSIDs);
    DBG_ASSERT(*paCLSIDs == NULL);

    // PopulateByKey is expecting a SAFEARRAY parameter input,
    // Create a one element SAFEARRAY, the one element of the SAFEARRAY contains
    // the packageID.
    rgsaBound[0].cElements = 1;
    rgsaBound[0].lLbound = 0;
    aCLSIDs = SafeArrayCreate(VT_VARIANT, 1, rgsaBound);

    if (aCLSIDs)
        {
        Indices[0] = 0;

        VariantInit(&varT);
        varT.vt = VT_BSTR;
        varT.bstrVal = SysAllocString(szComponentCLSID);
        hr = SafeArrayPutElement(aCLSIDs, Indices, &varT);
        VariantClear(&varT);

        if (FAILED(hr))
            {
            DBGPRINTF((DBG_CONTEXT, "Failed to call SafeArrayPutElement, CLSID is %S, hr %08x\n",
                szComponentCLSID,
                hr));

            if (aCLSIDs != NULL)
                {
                HRESULT hrT = SafeArrayDestroy(aCLSIDs);
                if (FAILED(hrT))
                    {
                    DBGPRINTF((DBG_CONTEXT, "Failed to call SafeArrayDestroy(aCLSIDs), hr = %08x\n",
                        hr));
                    }
                aCLSIDs = NULL;
                }
            }
        }
    else
        {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DBGPRINTF((DBG_CONTEXT, "Failed to call SafeArrayCreate, hr %08x\n",
                hr));
        }

    *paCLSIDs = aCLSIDs;
    return hr;
}

/*===================================================================
ViperizeContextObject

Creates a Viper package, and adds the Context object to that
package, and marks the object as "InProc".

Returns:
        HRESULT - NOERROR on success

Side effects:
        Creates Viper package, Viperizes Context object
===================================================================*/
HRESULT ViperizeContextObject(void)
        {
        HRESULT         hr;

        // Add the IIS utility package
        hr = AddViperUtilPackage();

        // Add the context object to the package
        if (SUCCEEDED(hr))
                hr = AddContextObjectToViperPackage();

        return hr;
        }

/*===================================================================
AddViperUtilPackage

Creates a Viper package named "IIS Utility"

Returns:
        HRESULT - NOERROR on success

Side effects:
        Creates Viper package
===================================================================*/
HRESULT AddViperUtilPackage(void)
        {
        HRESULT         hr;
        BSTR bstr       = NULL;
        VARIANT         varT;
        ICatalogCollection* pPkgCollection = NULL;
        ICatalogObject*         pPackage = NULL;
        ICOMAdminCatalog*   pCatalog = NULL;

        long lPkgCount, lChanges, i;

        VariantInit(&varT);

        // Create instance of the catalog object
        hr = CoCreateInstance(CLSID_COMAdminCatalog
                                        , NULL
                                        , CLSCTX_INPROC_SERVER
                                        , IID_ICOMAdminCatalog
                                        , (void**)&pCatalog);
        if (FAILED(hr))
                goto LErr;

        // Get the Packages collection
        bstr = SysAllocString(L"Applications");
        hr = pCatalog->GetCollection(bstr, (IDispatch**)&pPkgCollection);
        FREEBSTR(bstr);
        if (FAILED(hr))
                goto LErr;

        // Add new IIS Utilities package
        hr = pPkgCollection->Add((IDispatch**)&pPackage);
        if (FAILED(hr))
                goto LErr;

        // Set package ID to L"{ADA44581-02C1-11D1-804A-0000F8036614}",
        // MTS replication code looks for This fixed packageID
        bstr = SysAllocString(L"ID");
        varT.vt = VT_BSTR;
        varT.bstrVal = SysAllocString(wszASPUtilitiesPackageID);
        hr = pPackage->put_Value(bstr, varT);
        FREEBSTR(bstr);
        VariantClear(&varT);
        if (FAILED(hr))
                goto LErr;

        // Set package "Name" property to "IIS Utilities"
        bstr = SysAllocString(L"Name");
        varT.vt = VT_BSTR;
        varT.bstrVal = SysAllocString(L"IIS Utilities");
        hr = pPackage->put_Value(bstr, varT);
        FREEBSTR(bstr);
        VariantClear(&varT);
        if (FAILED(hr))
                goto LErr;

        // Set activation to InProc
        bstr = SysAllocString(L"Activation");
        varT.vt = VT_BSTR;
        varT.bstrVal = SysAllocString(L"InProc");
        hr = pPackage->put_Value(bstr, varT);
        FREEBSTR(bstr);
        VariantClear(&varT);
        if (FAILED(hr))
                goto LErr;

        // Set CreatedBy to MS IIS
        bstr = SysAllocString(L"CreatedBy");
        varT.vt = VT_BSTR;
        varT.bstrVal = SysAllocString(L"Microsoft Internet Information Services (tm)");
        hr = pPackage->put_Value(bstr, varT);
        FREEBSTR(bstr);
        VariantClear(&varT);
        if (FAILED(hr))
                goto LErr;

        // Set Deleteable = N property on package
        bstr = SysAllocString(L"Deleteable");
        varT.vt = VT_BSTR;
        varT.bstrVal = SysAllocString(L"N");
        hr = pPackage->put_Value(bstr, varT);
        FREEBSTR(bstr);
        VariantClear(&varT);
        if (FAILED(hr))
                goto LErr;

    	bstr = SysAllocString(L"AccessChecksLevel");
        varT.vt = VT_BSTR;
        varT.bstrVal = SysAllocString(L"0");
        hr = pPackage->put_Value(bstr, varT);
        FREEBSTR(bstr);
        VariantClear(&varT);
        if (FAILED(hr))
                goto LErr;

        // Save changes
        hr = pPkgCollection->SaveChanges(&lChanges);
        if (FAILED(hr))
                goto LErr;

LErr:
        RELEASE(pPkgCollection);
        RELEASE(pPackage);
        RELEASE(pCatalog);

        return hr;
        }

/*===================================================================
RemoveViperUtilPackage

Removes the Viper package named "IIS Utility"

Parameters:
        ICatalogCollection* pPkgCollection
                If non-null, will use this collection.  Otherwise, will
                open its own collection

Returns:
        HRESULT - NOERROR on success

Side effects:
        Removes Viper package
===================================================================*/
HRESULT RemoveViperUtilPackage(ICatalogCollection* pPkgCollectionT)
        {
        HRESULT                 hr;
    ICatalogCollection* pPkgCollection = NULL;
        ICatalogObject*         pPackage = NULL;
        ICOMAdminCatalog*       pCatalog = NULL;
        LONG                lPkgCount, lChanges, i;
        SAFEARRAY*          aCLSIDs = NULL;

        // if package collection was passed, use it
        if (pPkgCollectionT != NULL)
                {
                pPkgCollection = pPkgCollectionT;
                }
        else
                {
                BSTR                bstr = NULL;

                // Create instance of the catalog object
                hr = CoCreateInstance(CLSID_COMAdminCatalog
                                                , NULL
                                                , CLSCTX_INPROC_SERVER
                                                , IID_ICOMAdminCatalog
                                                , (void**)&pCatalog);
                if (FAILED(hr))
                        goto LErr;

                // Get the Packages collection
                bstr = SysAllocString(L"Applications");
                hr = pCatalog->GetCollection(bstr, (IDispatch**)&pPkgCollection);
                FREEBSTR(bstr);
                if (FAILED(hr))
                        goto LErr;
                }

    hr = GetSafeArrayOfCLSIDs(wszASPUtilitiesPackageID, &aCLSIDs);
    if (FAILED(hr))
        {
        DBGPRINTF((DBG_CONTEXT, "Failed to get SafeArrayofCLSIDs, szPackageID is %S, hr %08x",
            wszASPUtilitiesPackageID,
            hr));
        goto LErr;
        }

    //
    // Populate it
    //
    hr = pPkgCollection->PopulateByKey(aCLSIDs);
    if (FAILED(hr))
        {
        DBGPRINTF((DBG_CONTEXT, "Failed to call PopulateByKey(), hr = %08x\n",
            hr));
        goto LErr;
        }

        // Delete any existing "IIS Utilities" package
    hr = pPkgCollection->get_Count(&lPkgCount);
    if (FAILED(hr))
        {
        DBGPRINTF((DBG_CONTEXT, "pPkgCollection->Populate() failed, hr = %08x\n",
            hr));
        goto LErr;
        }

    if (SUCCEEDED(hr) && lPkgCount == 1)
        {
        hr = pPkgCollection->get_Item(0, (IDispatch**)&pPackage);
        if (FAILED(hr))
            {
            goto LErr;
            }

        BSTR    bstr = NULL;
        VARIANT varT;

        // Found it - remove it and call Save Changes
        // First, Set Deleteable = Y property on package
        bstr = SysAllocString(L"Deleteable");
        VariantInit(&varT);
        varT.vt = VT_BSTR;
        varT.bstrVal = SysAllocString(L"Y");
        hr = pPackage->put_Value(bstr, varT);
        FREEBSTR(bstr);
        VariantClear(&varT);
        if (FAILED(hr))
            {
            goto LErr;
            }

        RELEASE(pPackage);

        // Let save the Deletable settings
        hr = pPkgCollection->SaveChanges(&lChanges);
        if (FAILED(hr))
            {
            DBGPRINTF((DBG_CONTEXT, "Save the Deletable settings failed, hr = %08x\n",
                hr));
            goto LErr;
            }

        // Now we can delete
        hr = pPkgCollection->Remove(0);
        if (FAILED(hr))
            {
            DBGPRINTF((DBG_CONTEXT, "Remove the Component from package failed, hr = %08x\n",
                hr));
            goto LErr;
            }

        // Aha, we should be able to delete now.
        hr = pPkgCollection->SaveChanges(&lChanges);
        if (FAILED(hr))
            {
            DBGPRINTF((DBG_CONTEXT, "Save changes failed, hr = %08x\n",
                hr));
            goto LErr;
            }
        }
LErr:

    if (aCLSIDs != NULL)
        {
        HRESULT hrT = SafeArrayDestroy(aCLSIDs);
        aCLSIDs = NULL;
        }

    if (pPkgCollectionT == NULL)
                RELEASE(pPkgCollection);
        RELEASE(pCatalog);
        RELEASE(pPackage);

        return hr;
        }

/*===================================================================
AddContextObjectToViperPackage

Adds the Context object to the Viper package named "IIS Utility"

Returns:
        HRESULT - NOERROR on success

Side effects:
        Adds the object to the Viper package
===================================================================*/
HRESULT AddContextObjectToViperPackage()
{
        HRESULT         hr;
        BSTR bstr                   = NULL;
        BSTR bstrAppGUID    = NULL;
        BSTR bstrGUID       = NULL;
        VARIANT varName;
        VARIANT varKey;
        VARIANT varT;
        ICatalogCollection* pPkgCollection = NULL;
        ICatalogCollection* pCompCollection = NULL;
        ICatalogObject*         pComponent = NULL;
        ICatalogObject*         pPackage = NULL;
        ICOMAdminCatalog*       pCatalog = NULL;
        long                lPkgCount, lCompCount, lChanges, iT;
    BOOL                fFound;
        SAFEARRAY*          aCLSIDs = NULL;

        VariantInit(&varKey);
        VariantClear(&varKey);
        VariantInit(&varName);
        VariantClear(&varName);
        VariantInit(&varT);
        VariantClear(&varT);

        // Create instance of the catalog object
        hr = CoCreateInstance(CLSID_COMAdminCatalog
                                        , NULL
                                        , CLSCTX_INPROC_SERVER
                                        , IID_ICOMAdminCatalog
                                        , (void**)&pCatalog);
        if (FAILED(hr))
                goto LErr;

        // Get the Packages collection
        bstr = SysAllocString(L"Applications");
        hr = pCatalog->GetCollection(bstr, (IDispatch**)&pPkgCollection);
        SysFreeString(bstr);
        if (FAILED(hr))
                goto LErr;

    hr = GetSafeArrayOfCLSIDs(wszASPUtilitiesPackageID, &aCLSIDs);
    if (FAILED(hr))
        {
        DBGPRINTF((DBG_CONTEXT, "Failed to get SafeArrayofCLSIDs, szPackageID is %S, hr %08x",
            wszASPUtilitiesPackageID,
            hr));
        goto LErr;
        }

    bstrAppGUID = SysAllocString(wszASPUtilitiesPackageID);

        // Actually put the components in the package
        bstrGUID = SysAllocString(wszCLSID_ASPObjectContextTxRequired);
        hr = pCatalog->ImportComponent(bstrAppGUID ,bstrGUID);
        SysFreeString(bstrGUID);
        if (FAILED(hr))
                goto LErr;
        bstrGUID = SysAllocString(wszCLSID_ASPObjectContextTxRequiresNew);
        hr = pCatalog->ImportComponent(bstrAppGUID ,bstrGUID);
        SysFreeString(bstrGUID);
        if (FAILED(hr))
                goto LErr;
        bstrGUID = SysAllocString(wszCLSID_ASPObjectContextTxSupported);
        hr = pCatalog->ImportComponent(bstrAppGUID ,bstrGUID);
        SysFreeString(bstrGUID);
        if (FAILED(hr))
                goto LErr;
        bstrGUID = SysAllocString(wszCLSID_ASPObjectContextTxNotSupported);
        hr = pCatalog->ImportComponent(bstrAppGUID ,bstrGUID);
        SysFreeString(bstrGUID);
        if (FAILED(hr))
                goto LErr;

    varKey.vt = VT_BSTR;
    varKey.bstrVal = SysAllocString(wszASPUtilitiesPackageID);

    //
    // Populate packages
    //
    hr = pPkgCollection->PopulateByKey(aCLSIDs);
    if (FAILED(hr))
        {
        DBGPRINTF((DBG_CONTEXT, "Failed to call PopulateByKey(), hr = %08x\n",
            hr));
        goto LErr;
        }

        // Find "IIS Utilities" package
    hr = pPkgCollection->get_Count(&lPkgCount);
    if (FAILED(hr))
        {
        DBGPRINTF((DBG_CONTEXT, "pPkgCollection->Populate() failed, hr = %08x\n",
            hr));
        goto LErr;
        }

    if (SUCCEEDED(hr) && lPkgCount == 1)
        {
        hr = pPkgCollection->get_Item(0, (IDispatch**)&pPackage);
        if (FAILED(hr))
            {
            goto LErr;
            }
        }

        DBG_ASSERT(pPackage != NULL);

        // Get the "ComponentsInPackage" collection.
        bstr = SysAllocString(L"Components");
        hr = pPkgCollection->GetCollection(bstr, varKey, (IDispatch**)&pCompCollection);
        SysFreeString(bstr);
        if (FAILED(hr))
                goto LErr;

        // Repopulate the collection so we can find our object and set properties on it
        hr = pCompCollection->Populate();
        if (FAILED(hr))
                goto LErr;

        // Find our components in the list (should be four)

        hr = pCompCollection->get_Count(&lCompCount);
        if (FAILED(hr))
                goto LErr;
        DBG_ASSERT(lCompCount == 4);
        RELEASE(pComponent);
        VariantClear(&varKey);

        for (iT = (lCompCount-1); iT >= 0 ; iT--)
                {
                hr = pCompCollection->get_Item(iT, (IDispatch**)&pComponent);
                if (FAILED(hr))
                        goto LErr;

                hr = pComponent->get_Key(&varKey);
                if (FAILED(hr))
                        goto LErr;
                DBG_ASSERT(varKey.bstrVal);
                fFound = FALSE;

                if (_wcsicmp(varKey.bstrVal, wszCLSID_ASPObjectContextTxRequired) == 0)
                        {
            // Required
                bstr = SysAllocString(L"3");
                fFound = TRUE;
                        }
                else if (_wcsicmp(varKey.bstrVal, wszCLSID_ASPObjectContextTxRequiresNew) == 0)
                    {
                    // Requires New
                bstr = SysAllocString(L"4");
                fFound = TRUE;
                    }
                else if (_wcsicmp(varKey.bstrVal, wszCLSID_ASPObjectContextTxSupported) == 0)
                    {
                    // Supported
                bstr = SysAllocString(L"2");
                fFound = TRUE;
                    }
                else if (_wcsicmp(varKey.bstrVal, wszCLSID_ASPObjectContextTxNotSupported) == 0)
                    {
                    // Not Supported
                bstr = SysAllocString(L"1");
                fFound = TRUE;
                    }

        if (fFound)
            {
                varT.vt = VT_BSTR;
                varT.bstrVal = bstr;
                bstr = SysAllocString(L"Transaction");
                hr = pComponent->put_Value(bstr, varT);
                FREEBSTR(bstr);
                VariantClear(&varT);
                if (FAILED(hr))
                        goto LErr;

                bstr = SysAllocString(L"Description");
                varT.vt = VT_BSTR;
                varT.bstrVal = SysAllocString(L"ASP Tx Script Context");
                hr = pComponent->put_Value(bstr, varT);
                FREEBSTR(bstr);
                VariantClear(&varT);
                if (FAILED(hr))
                        goto LErr;

                bstr = SysAllocString(L"EventTrackingEnabled");
                varT.vt = VT_BSTR;
                varT.bstrVal = SysAllocString(L"N");
                hr = pComponent->put_Value(bstr, varT);
                FREEBSTR(bstr);
                VariantClear(&varT);
                if (FAILED(hr))
                        goto LErr;
            }

                VariantClear(&varKey);
                RELEASE(pComponent);
                }

        // Save changes
        hr = pCompCollection->SaveChanges(&lChanges);
        if (FAILED(hr))
                goto LErr;

        bstr = SysAllocString(L"Activation");
        varT.vt = VT_BSTR;
        varT.bstrVal = SysAllocString(L"InProc");
        hr = pPackage->put_Value(bstr, varT);
        FREEBSTR(bstr);
        VariantClear(&varT);
        if (FAILED(hr))
                goto LErr;

        // Save changes
        hr = pPkgCollection->SaveChanges(&lChanges);
        if (FAILED(hr))
                goto LErr;

        hr = pPkgCollection->Populate();
        if (FAILED(hr))
                goto LErr;

        // Now that our one object is added to the package, set the Changeable property
        // on the package to "No", so no one can mess with it
        bstr = SysAllocString(L"Changeable");
        varT.vt = VT_BSTR;
        varT.bstrVal = SysAllocString(L"N");
        hr = pPackage->put_Value(bstr, varT);
        FREEBSTR(bstr);
        VariantClear(&varT);
        if (FAILED(hr))
                goto LErr;

        // Save changes
        hr = pPkgCollection->SaveChanges(&lChanges);
        if (FAILED(hr))
                goto LErr;

LErr:
        DBG_ASSERT(SUCCEEDED(hr));
    if (aCLSIDs)
        {
        SafeArrayDestroy(aCLSIDs);
        aCLSIDs = NULL;
        }

        RELEASE(pCompCollection);
        RELEASE(pPkgCollection);
        RELEASE(pComponent);
        RELEASE(pPackage);
        RELEASE(pCatalog);
    FREEBSTR(bstrAppGUID);
        FREEBSTR(bstr);
        VariantClear(&varName);
        VariantClear(&varKey);
        VariantClear(&varT);

        return hr;

} // AddContextObjectToViperPackage
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspidl\makefile.inc ===
#
# Supplemental rules for generating Type library.
#
iCPU=$(PROCESSOR_ARCHITECTURE)
!IF "$(iCPU)"=="x86"
iCPU=I386
!ENDIF

ASPTLB_H        = ..\..\..\inc\$(O)\asptlb.h
CDROOT=$(_NTTREE)\inetsrv

# MkTypeLib Stuff
$(O)\_asptlb.h $(O)\asp.tlb: .\asp.idl
	midl /mktyplib203 /Oicf /out .\$(O) /I $(SDK_INC_PATH) /h _asptlb.h  /tlb asp.tlb asp.idl

$(ASPTLB_H): $(O)\_asptlb.h
	echo // This file was generated by mktyplib.exe, then munged by Active Server Pages build. > $@
	echo // Changes: >> $@
	echo // - we include "dispatch.h" (our standard IDispatch implementation) >> $@
	echo // >> $@
	echo // - we #define "NO_BASEINTERFACE_FUNCS" to prevent pure virtual >> $@
	echo // redefinitions of the four IDispatch members that CDispatch defines. >> $@
	echo // >> $@
	echo // - we change the derivation of the classes from "IDispatch" to "CDispatch" >> $@
	echo // >> $@
	echo #include "dispatch.h" >> $@
	echo #define NO_BASEINTERFACE_FUNCS >> $@
	echo // >> $@
	perl -n -e "s/\: public IDispatch/\: public CDispatch/g;print $_;" $(O)\_asptlb.h >> $@

# MIDL for asptxn object
$(O)\asptxn.h: $(O)\_asptxn.h
	echo // This file was generated by mktyplib.exe, then munged by Active Server Pages build. > $@
	echo // Changes: >> $@
	echo // - we include "dispatch.h" (our standard IDispatch implementation) >> $@
	echo // >> $@
	echo // - we #define "NO_BASEINTERFACE_FUNCS" to prevent pure virtual >> $@
	echo // redefinitions of the four IDispatch members that CDispatch defines. >> $@
	echo // >> $@
	echo // - we change the derivation of the classes from "IDispatch" to "CDispatch" >> $@
	echo // >> $@
	echo #include "dispatch.h" >> $@
	echo #define NO_BASEINTERFACE_FUNCS >> $@
	echo // >> $@
	perl -n -e "s/\: public IDispatch/\: public CDispatch/g;print $_;" $(O)\_asptxn.h >> $@


$(O)\_asptxn.h : .\asptxn.idl
	midl /robust /Oicf /I $(SDK_INC_PATH) /out .\$(O) /h _asptxn.h /tlb asptxn.tlb asptxn.idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asptxn\makefile.inc ===
#
# Supplemental rules for generating Type library.
#
iCPU=$(PROCESSOR_ARCHITECTURE)
!IF "$(iCPU)"=="x86"
iCPU=I386
!ENDIF

CPP             = -cpp_cmd "$(MIDL_CPP)" $(MIDL_FLAGS) \
                   $(C_DEFINES) $(NET_C_DEFINES)

# MIDL for TxnScript object
$(O)\txnscrpt.h $(O)\txnscrpt.tlb $(O)\txnscrpt_i.c $(O)\txnscrpt_p.c $(O)\dlldata.c: .\txnscrpt.idl
	midl /robust /Oicf /I $(SDK_INC_PATH) $(CPP) /dlldata $(O)\dlldata.c /h $(O)\txnscrpt.h /iid $(O)\txnscrpt_i.c /proxy $(O)\txnscrpt_p.c /tlb $(O)\txnscrpt.tlb txnscrpt.idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asptxn\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "txnscrpt_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asptxn\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by asptxn.rc
//
#define IDS_PROJNAME                    100
#define IDR_ASPOBJECTCONTEXT            101
#define IDR_ACCELERATOR1                201
#define ID_ACCEL32768                   32768

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32769
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asptxn\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__E9642BC6_0968_11D3_A7F6_0000F8085B95__INCLUDED_)
#define AFX_STDAFX_H__E9642BC6_0968_11D3_A7F6_0000F8085B95__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__E9642BC6_0968_11D3_A7F6_0000F8085B95__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asptxn\txnobj.h ===
// txnobj.h : Declaration of the CASPObjectContext

#ifndef __TXNOBJ_H_
#define __TXNOBJ_H_

#include "resource.h"       // main symbols
#include <mtx.h>

/////////////////////////////////////////////////////////////////////////////
// CASPObjectContext
//
class ATL_NO_VTABLE CASPObjectContext 
	: public IObjectControl
    , public IASPObjectContextCustom
	, public ISupportErrorInfo
	, public CComObjectRootEx<CComMultiThreadModel>
	, public CComCoClass<CASPObjectContext, &CLSID_ASPObjectContextTxRequired>
	, public IDispatchImpl<IASPObjectContext, &IID_IASPObjectContext, &LIBID_ASPTxnTypeLibrary, 2, 0>
{
public:
	CASPObjectContext() 
        : m_fAborted(FALSE)
	{
	}

    DECLARE_REGISTRY_RESOURCEID(IDR_ASPOBJECTCONTEXT)

    BEGIN_COM_MAP(CASPObjectContext)
	    COM_INTERFACE_ENTRY(IASPObjectContextCustom)
	    COM_INTERFACE_ENTRY(IASPObjectContext)
	    COM_INTERFACE_ENTRY(IObjectControl)
    	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	    COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()


// IObjectControl
public:
	STDMETHOD(Activate)();
	STDMETHOD_(BOOL, CanBePooled)();
	STDMETHOD_(void, Deactivate)();

// ISupportsErrorInfo
public:
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

private:
	CComPtr<IObjectContext> m_spObjectContext;
    BOOL                    m_fAborted;

// IASPObjectContext & IASPObjectContextCustom
public:

	STDMETHOD(SetAbort)();
	STDMETHOD(SetComplete)();
#ifdef _WIN64
	// Win64 fix -- use UINT64 instead of LONG_PTR since LONG_PTR is broken for Win64 1/21/2000
	STDMETHOD(Call)(UINT64 pvScriptEngine, LPCOLESTR strEntryPoint, boolean *pfAborted);
	STDMETHOD(ResetScript)(UINT64 pvScriptEngine);
#else
	STDMETHOD(Call)(LONG_PTR pvScriptEngine, LPCOLESTR strEntryPoint, boolean *pfAborted);
	STDMETHOD(ResetScript)(LONG_PTR pvScriptEngine);
#endif

};

#endif //__TXNOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\perfcmd\denver.h ===
#include <winver.h>
#include "iisver.h"

/*------------------------------------------------------------------------------*/
/* the following section defines values used in the version     		*/
/* data structure for all files, and which do not change.            		*/
/*------------------------------------------------------------------------------*/

/* default is nodebug */
#ifndef DEBUG
#define VER_DEBUG                   0
#else
#define VER_DEBUG                   VS_FF_DEBUG
#endif

/* default is privatebuild */
#ifndef OFFICIAL
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_DOS_WINDOWS32
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation\0"

#ifndef DLL_VER
#undef	VER_PRODUCTNAME_STR
#define VER_PRODUCTNAME_STR         "Microsoft\256 Windows(TM) Operating System\0"
#endif //DLL_VER

#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation.\0"

#define	VER_FILETYPE            	VFT_DLL
#define	VER_FILESUBTYPE         	0

#define	VER_LEGALCOPYRIGHT_YEARS 	"1996"

#ifndef DLL_VER
#undef	VER_PRODUCTNAME_STR
#define	VER_PRODUCTNAME_STR 		"Active Server Pages"
#undef	VER_FILEDESCRIPTION_STR
#define	VER_FILEDESCRIPTION_STR	 	"Active Server Pages Performance Counters"
#undef	VER_INTERNALNAME_STR
#define	VER_INTERNALNAME_STR		"Active Server Pages"
#undef	VER_ORIGINALFILENAME_STR
#define	VER_ORIGINALFILENAME_STR 	"ASPPERF.DLL"

#endif //DLL_VER

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\perfcmd\denpre.h ===
#pragma warning(disable:4237)
#define _CRYPT32_

#include <ctype.h>
#include <stdlib.h>     // for itow
#include <crtdbg.h>
#include <malloc.h>
#include <time.h>
#include <stdio.h>
#include <limits.h>
#include <windows.h>
#include <winerror.h>
#include <wtypes.h>
#include <process.h>

#include <rpc.h>
#include <rpcndr.h>
#include <ole2.h>
#include <olectl.h>
#include <oleauto.h>
#include <cguid.h>      // for GUID_NULL

#include <iis64.h>

#include "except.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\perfcmd\main.cpp ===
#include "denpre.h"
#include "windows.h"
#define _PERF_CMD
#include <asppdef.h>            // from denali

char *counterName[C_PERF_PROC_COUNTERS] = {
"ID_DEBUGDOCREQ",      
"ID_REQERRRUNTIME",    
"ID_REQERRPREPROC",    
"ID_REQERRCOMPILE",    
"ID_REQERRORPERSEC",   
"ID_REQTOTALBYTEIN",   
"ID_REQTOTALBYTEOUT",  
"ID_REQEXECTIME",      
"ID_REQWAITTIME",      
"ID_REQCOMFAILED",     
"ID_REQBROWSEREXEC",   
"ID_REQFAILED",        
"ID_REQNOTAUTH",       
"ID_REQNOTFOUND",      
"ID_REQCURRENT",       
"ID_REQREJECTED",      
"ID_REQSUCCEEDED",     
"ID_REQTIMEOUT",       
"ID_REQTOTAL",         
"ID_REQPERSEC",        
"ID_SCRIPTFREEENG",    
"ID_SESSIONLIFETIME",  
"ID_SESSIONCURRENT",   
"ID_SESSIONTIMEOUT",   
"ID_SESSIONSTOTAL",    
"ID_TEMPLCACHE",       
"ID_TEMPLCACHEHITS",   
"ID_TEMPLCACHETRYS",   
"ID_TEMPLFLUSHES",     
"ID_TRANSABORTED",     
"ID_TRANSCOMMIT",   
"ID_TRANSPENDING",
"ID_TRANSTOTAL",
"ID_TRANSPERSEC",
"ID_MEMORYTEMPLCACHE",
"ID_MEMORYTEMPLCACHEHITS",
"ID_MEMORYTEMPLCACHETRYS",
"ID_ENGINECACHEHITS",
"ID_ENGINECACHETRYS",
"ID_ENGINEFLUSHES"
};

CPerfMainBlock g_Shared;        // shared global memory block

__cdecl main(int argc, char *argv[])
{
    DWORD           dwCounters[C_PERF_PROC_COUNTERS];
    HRESULT         hr;

    // Init the shared memory.  This will give us access to the global shared
    // memory describing the active asp perf counter shared memory arrays

    if (FAILED(hr = g_Shared.Init())) {
        printf("Init() failed - %x\n", hr);
        return -1;
    }

    // give a little high level info about what is registered in the shared
    // array

    printf("Number of processes registered = %d\n", g_Shared.m_pData->m_cItems);

    // ident past the column with the counter names

    printf("\t");

    // the first counter column will contain the dead proc counters

    printf("DeadProcs\t");

    // print out the proc ids of the registered asp perf counter memory arrays

    for (DWORD i = 0; i < g_Shared.m_pData->m_cItems; i++) {
        printf("%d\t", g_Shared.m_pData->m_dwProcIds[i]);
    }

    // the last column is the counters total across all instances plus dead procs

    printf("Total\n");

    // need to call GetStats() to cause the perf blocks to get loaded

    if (FAILED(hr = g_Shared.GetStats(dwCounters))) {
        printf("GetStats() failed - %x\n",hr);
        goto LExit;
    }

    // now enter a loop to print out all of the counter values

    for (DWORD i=0; i < C_PERF_PROC_COUNTERS; i++) {

        // initialize total to be the value found in the dead proc array

        DWORD   total=g_Shared.m_pData->m_rgdwCounters[i];

        // get the first proc block in the list

        CPerfProcBlock *pBlock = g_Shared.m_pProcBlock;

        // print the name of the counter first

        printf("%s\t",counterName[i]);

        // next the dead proc counter value

        printf("%d\t",g_Shared.m_pData->m_rgdwCounters[i]);
 
        // print out each proc block's value for this counter.  Add the
        // value to the running total

        while (pBlock) {
            total += pBlock->m_pData->m_rgdwCounters[i];
            printf("%d\t",pBlock->m_pData->m_rgdwCounters[i]);
            pBlock = pBlock->m_pNext;
        }

        // print out the final total

        printf("%d\n",total);
    }
                    
LExit:
    g_Shared.UnInit();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asptxn\txnobj.cpp ===
// txnobj.cpp : Implementation of CASPObjectContext


#include "stdafx.h"
#include "txnscrpt.h"
#include "txnobj.h"
#include <hostinfo.h>
#include <scrpteng.h>

/////////////////////////////////////////////////////////////////////////////
// CASPObjectContext

HRESULT CASPObjectContext::Activate()
{
	HRESULT hr = GetObjectContext(&m_spObjectContext);
	if (SUCCEEDED(hr))
		return S_OK;
	return hr;
} 

BOOL CASPObjectContext::CanBePooled()
{
	return FALSE;
} 

void CASPObjectContext::Deactivate()
{
	m_spObjectContext.Release();
} 

STDMETHODIMP CASPObjectContext::Call
(
#ifdef _WIN64
// Win64 fix -- use UINT64 instead of LONG_PTR since LONG_PTR is broken for Win64 1/21/2000
UINT64  pvScriptEngine /*CScriptEngine*/,
#else
LONG_PTR  pvScriptEngine /*CScriptEngine*/,
#endif
LPCOLESTR strEntryPoint,
// BUGBUG - ASP uses this BOOLB type that resolves to a unsigned char. I changed things
// to boolean for simplicity, but this requires some strange casts.
boolean *pfAborted
)
{
    HRESULT hr = NOERROR;

    CScriptEngine *pScriptEngine = (CScriptEngine *)pvScriptEngine;
    m_fAborted = FALSE;

    hr = pScriptEngine->Call(strEntryPoint);

    // If the script timed out or there was an unhandled error, then autoabort
    if (SUCCEEDED(hr) && (pScriptEngine->FScriptTimedOut() || pScriptEngine->FScriptHadError()))
        {
        hr = SetAbort();
        m_fAborted = TRUE;
        }

    // If the script author did not do an explicit SetComplete or SetAbort
    // then do a SetComplete here so Viper will return the transaction
    // completion status to the caller
    if (SUCCEEDED(hr) && !m_fAborted)
        {
        hr = SetComplete();
        }

    *pfAborted = (boolean)m_fAborted;
    return hr;
}

STDMETHODIMP CASPObjectContext::ResetScript
(
#ifdef _WIN64
// Win64 fix -- use UINT64 instead of LONG_PTR since LONG_PTR is broken for Win64 1/21/2000
UINT64 pvScriptEngine /*CScriptEngine*/
#else
LONG_PTR pvScriptEngine /*CScriptEngine*/
#endif
)
{
    HRESULT hr = NOERROR;

    CScriptEngine *pScriptEngine = (CScriptEngine *)pvScriptEngine;
    hr = pScriptEngine->ResetScript();

    return hr;
}

STDMETHODIMP CASPObjectContext::SetComplete()
{
    HRESULT             hr = E_NOTIMPL;
    IObjectContext *    pContext = NULL;

    hr = GetObjectContext(&pContext);
    if( SUCCEEDED(hr) )
    {
        hr = pContext->SetComplete();

        pContext->Release();
        m_fAborted = FALSE;     // If it was aborted, its not any more
    }
    
    return hr;
}

STDMETHODIMP CASPObjectContext::SetAbort()
{
    IObjectContext *    pContext = NULL;
    HRESULT             hr = NOERROR;

    hr = GetObjectContext(&pContext);

    if( SUCCEEDED(hr) )
    {
        hr = pContext->SetAbort();
        pContext->Release();

        m_fAborted = TRUE;      // transaction was esplicitly aborted
    }

    return hr;
}

STDMETHODIMP CASPObjectContext::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		  &IID_IASPObjectContextCustom
        , &IID_IASPObjectContext
        , &IID_IObjectControl
        , &IID_IDispatch
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\perfmon\denpre.h ===
#pragma warning(disable:4237)
#define _CRYPT32_

#include <ctype.h>
#include <stdlib.h>     // for itow
#include <crtdbg.h>
#include <malloc.h>
#include <time.h>
#include <stdio.h>
#include <limits.h>
#include <windows.h>
#include <winerror.h>
#include <wtypes.h>
#include <process.h>

#include <rpc.h>
#include <rpcndr.h>
#include <ole2.h>
#include <olectl.h>
#include <oleauto.h>
#include <cguid.h>      // for GUID_NULL

#include <iis64.h>

#include "except.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\perfmon\axctrnm.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Main

File: axctrnm.h

Owner: LeiJin


  Abstract:

  Offset definition file for counter objects and counters.

  These relative offsets must start at 0 and be multiples of 2. (i.e.)
  even numbers). In the Open Procedure, they will be added to the "First 
  Counter" and "First Help" values for the device they belong to, in order
  to determine the absolute location of the counter and object names and 
  corresponding Explain text in the registry.

  This file is used by the extensible counter DLL code as well as the 
  counter name and Explain text definition (.INI) file that is used
  by LODCTR to load the names into the registry.
===================================================================*/

#define AXSOBJ 			 0
#define DEBUGDOCREQ      2
#define REQERRRUNTIME    4
#define REQERRPREPROC    6
#define REQERRCOMPILE    8
#define REQERRORPERSEC   10
#define REQTOTALBYTEIN   12
#define REQTOTALBYTEOUT  14
#define REQEXECTIME      16
#define REQWAITTIME      18
#define REQCOMFAILED     20
#define REQBROWSEREXEC   22
#define REQFAILED        24
#define REQNOTAUTH       26
#define REQNOTFOUND      28
#define REQCURRENT       30
#define REQREJECTED      32
#define REQSUCCEEDED     34
#define REQTIMEOUT       36
#define REQTOTAL         38
#define REQPERSEC        40
#define SCRIPTFREEENG    42
#define SESSIONLIFETIME  44
#define SESSIONCURRENT   46
#define SESSIONTIMEOUT   48
#define SESSIONSTOTAL    50
#define TEMPLCACHE       52
#define TEMPLCACHEHITS   54
#define TEMPLCACHETRYS   56
#define TEMPLFLUSHES     58
#define TRANSABORTED     60
#define TRANSCOMMIT      62
#define TRANSPENDING     64
#define TRANSTOTAL       66
#define TRANSPERSEC      68
#define MEMORYTEMPLCACHE   70
#define MEMORYTEMPLCACHEHITS 72
#define MEMORYTEMPLCACHETRYS 74
#define ENGINECACHEHITS   76
#define ENGINECACHETRYS   78
#define ENGINEFLUSHES     80
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\perfmon\denver.h ===
#include <winver.h>
#include "iisver.h"

/*------------------------------------------------------------------------------*/
/* the following section defines values used in the version     		*/
/* data structure for all files, and which do not change.            		*/
/*------------------------------------------------------------------------------*/

/* default is nodebug */
#ifndef DEBUG
#define VER_DEBUG                   0
#else
#define VER_DEBUG                   VS_FF_DEBUG
#endif

/* default is privatebuild */
#ifndef OFFICIAL
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_DOS_WINDOWS32
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation\0"

#ifndef DLL_VER
#undef	VER_PRODUCTNAME_STR
#define VER_PRODUCTNAME_STR         "Microsoft\256 Windows(TM) Operating System\0"
#endif //DLL_VER

#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation.\0"

#define	VER_FILETYPE            	VFT_DLL
#define	VER_FILESUBTYPE         	0

#define	VER_LEGALCOPYRIGHT_YEARS 	"1996"

#ifndef DLL_VER
#undef	VER_PRODUCTNAME_STR
#define	VER_PRODUCTNAME_STR 		"Active Server Pages"
#undef	VER_FILEDESCRIPTION_STR
#define	VER_FILEDESCRIPTION_STR	 	"Active Server Pages Performance Counters"
#undef	VER_INTERNALNAME_STR
#define	VER_INTERNALNAME_STR		"Active Server Pages"
#undef	VER_ORIGINALFILENAME_STR
#define	VER_ORIGINALFILENAME_STR 	"ASPPERF.DLL"

#endif //DLL_VER

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\perfmon\axpfdata.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Main

File: axpfdata.cpp

Owner: LeiJin

Abstract:

	Define the data structures used by the Performance Monitor data for the Denali Objects.
	Also include shared memory functions used by both perfmon dll and denali dll.
===================================================================*/


//-------------------------------------------------------------------------------------
//	Include Files
//
//-------------------------------------------------------------------------------------
#include "denpre.h"
#pragma hdrstop
#include "windows.h"
#include "winperf.h"

#include "axctrnm.h"
#include "axpfdata.h"
#include <perfutil.h>

//-------------------------------------------------------------------------------------
//	Constant structure initializations
//	defined in ActiveXPerfData.h
//-------------------------------------------------------------------------------------

AXPD g_AxDataDefinition = {
	{
		QWORD_MULTIPLE(sizeof(AXPD) + SIZE_OF_AX_PERF_DATA),
		sizeof(AXPD),
		sizeof(PERF_OBJECT_TYPE),
		AXSOBJ,
		0,
		AXSOBJ,
		0,
		PERF_DETAIL_NOVICE,
		(sizeof(AXPD) - sizeof(PERF_OBJECT_TYPE))/
			sizeof(PERF_COUNTER_DEFINITION),
		0,
		-1,
		0,
		1,	// NOTE: PerfTime ?
		1,	// NOTE: PerfFreq ?
	},
    { // Counters[]

        // DEBUGDOCREQ
        {
            sizeof(PERF_COUNTER_DEFINITION),
            DEBUGDOCREQ,
            0,
            DEBUGDOCREQ,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_DEBUGDOCREQ_OFFSET
        },

        // REQERRRUNTIME
        {
            sizeof(PERF_COUNTER_DEFINITION),
            REQERRRUNTIME,
            0,
            REQERRRUNTIME,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_REQERRRUNTIME_OFFSET
        },

        // REQERRPREPROC
        {
            sizeof(PERF_COUNTER_DEFINITION),
            REQERRPREPROC,
            0,
            REQERRPREPROC,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_REQERRPREPROC_OFFSET
        },

        // REQERRCOMPILE
        {
            sizeof(PERF_COUNTER_DEFINITION),
            REQERRCOMPILE,
            0,
            REQERRCOMPILE,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_REQERRCOMPILE_OFFSET
        },

        // REQERRORPERSEC
        {
            sizeof(PERF_COUNTER_DEFINITION),
            REQERRORPERSEC,
            0,
            REQERRORPERSEC,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_COUNTER,
            sizeof(DWORD),
            AX_REQERRORPERSEC_OFFSET
        },

        // REQTOTALBYTEIN
        {
            sizeof(PERF_COUNTER_DEFINITION),
            REQTOTALBYTEIN,
            0,
            REQTOTALBYTEIN,
            0,
            -4,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_REQTOTALBYTEIN_OFFSET
        },

        // REQTOTALBYTEOUT
        {
            sizeof(PERF_COUNTER_DEFINITION),
            REQTOTALBYTEOUT,
            0,
            REQTOTALBYTEOUT,
            0,
            -4,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_REQTOTALBYTEOUT_OFFSET
        },

        // REQEXECTIME
        {
            sizeof(PERF_COUNTER_DEFINITION),
            REQEXECTIME,
            0,
            REQEXECTIME,
            0,
            -3,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_REQEXECTIME_OFFSET
        },

        // REQWAITTIME
        {
            sizeof(PERF_COUNTER_DEFINITION),
            REQWAITTIME,
            0,
            REQWAITTIME,
            0,
            -3,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_REQWAITTIME_OFFSET
        },

        // REQCOMFAILED
        {
            sizeof(PERF_COUNTER_DEFINITION),
            REQCOMFAILED,
            0,
            REQCOMFAILED,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_REQCOMFAILED_OFFSET
        },

        // REQBROWSEREXEC
        {
            sizeof(PERF_COUNTER_DEFINITION),
            REQBROWSEREXEC,
            0,
            REQBROWSEREXEC,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_REQBROWSEREXEC_OFFSET
        },

        // REQFAILED
        {
            sizeof(PERF_COUNTER_DEFINITION),
            REQFAILED,
            0,
            REQFAILED,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_REQFAILED_OFFSET
        },

        // REQNOTAUTH
        {
            sizeof(PERF_COUNTER_DEFINITION),
            REQNOTAUTH,
            0,
            REQNOTAUTH,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_REQNOTAUTH_OFFSET
        },

        // REQNOTFOUND
        {
            sizeof(PERF_COUNTER_DEFINITION),
            REQNOTFOUND,
            0,
            REQNOTFOUND,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_REQNOTFOUND_OFFSET
        },

        // REQCURRENT
        {
            sizeof(PERF_COUNTER_DEFINITION),
            REQCURRENT,
            0,
            REQCURRENT,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_REQCURRENT_OFFSET
        },

        // REQREJECTED
        {
            sizeof(PERF_COUNTER_DEFINITION),
            REQREJECTED,
            0,
            REQREJECTED,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_REQREJECTED_OFFSET
        },

        // REQSUCCEEDED
        {
            sizeof(PERF_COUNTER_DEFINITION),
            REQSUCCEEDED,
            0,
            REQSUCCEEDED,
            0,
            -1,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_REQSUCCEEDED_OFFSET
        },

        // REQTIMEOUT
        {
            sizeof(PERF_COUNTER_DEFINITION),
            REQTIMEOUT,
            0,
            REQTIMEOUT,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_REQTIMEOUT_OFFSET
        },

        // REQTOTAL
        {
            sizeof(PERF_COUNTER_DEFINITION),
            REQTOTAL,
            0,
            REQTOTAL,
            0,
            -1,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_REQTOTAL_OFFSET
        },

        // REQPERSEC
        {
            sizeof(PERF_COUNTER_DEFINITION),
            REQPERSEC,
            0,
            REQPERSEC,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_COUNTER,
            sizeof(DWORD),
            AX_REQPERSEC_OFFSET
        },

        // SCRIPTFREEENG
        {
            sizeof(PERF_COUNTER_DEFINITION),
            SCRIPTFREEENG,
            0,
            SCRIPTFREEENG,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_SCRIPTFREEENG_OFFSET
        },

        // SESSIONLIFETIME
        {
            sizeof(PERF_COUNTER_DEFINITION),
            SESSIONLIFETIME,
            0,
            SESSIONLIFETIME,
            0,
            3,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_SESSIONLIFETIME_OFFSET
        },

        // SESSIONCURRENT
        {
            sizeof(PERF_COUNTER_DEFINITION),
            SESSIONCURRENT,
            0,
            SESSIONCURRENT,
            0,
            -1,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_SESSIONCURRENT_OFFSET
        },

        // SESSIONTIMEOUT
        {
            sizeof(PERF_COUNTER_DEFINITION),
            SESSIONTIMEOUT,
            0,
            SESSIONTIMEOUT,
            0,
            -1,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_SESSIONTIMEOUT_OFFSET
        },

        // SESSIONSTOTAL
        {
            sizeof(PERF_COUNTER_DEFINITION),
            SESSIONSTOTAL,
            0,
            SESSIONSTOTAL,
            0,
            -1,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_SESSIONSTOTAL_OFFSET
        },

        // TEMPLCACHE
        {
            sizeof(PERF_COUNTER_DEFINITION),
            TEMPLCACHE,
            0,
            TEMPLCACHE,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_TEMPLCACHE_OFFSET
        },

        // TEMPLCACHEHITS
        {
            sizeof(PERF_COUNTER_DEFINITION),
            TEMPLCACHEHITS,
            0,
            TEMPLCACHEHITS,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_RAW_FRACTION,
            sizeof(DWORD),
            AX_TEMPLCACHEHITS_OFFSET
        },

        // TEMPLCACHETRYS
        {
            sizeof(PERF_COUNTER_DEFINITION),
            TEMPLCACHETRYS,
            0,
            TEMPLCACHETRYS,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_RAW_BASE,
            sizeof(DWORD),
            AX_TEMPLCACHETRYS_OFFSET
        },

        // TEMPLFLUSHES
        {
            sizeof(PERF_COUNTER_DEFINITION),
            TEMPLFLUSHES,
            0,
            TEMPLFLUSHES,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_TEMPLFLUSHES_OFFSET
        },

        // TRANSABORTED
        {
            sizeof(PERF_COUNTER_DEFINITION),
            TRANSABORTED,
            0,
            TRANSABORTED,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_TRANSABORTED_OFFSET
        },

        // TRANSCOMMIT
        {
            sizeof(PERF_COUNTER_DEFINITION),
            TRANSCOMMIT,
            0,
            TRANSCOMMIT,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_TRANSCOMMIT_OFFSET
        },

        // TRANSPENDING
        {
            sizeof(PERF_COUNTER_DEFINITION),
            TRANSPENDING,
            0,
            TRANSPENDING,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_TRANSPENDING_OFFSET
        },

        // TRANSTOTAL
        {
            sizeof(PERF_COUNTER_DEFINITION),
            TRANSTOTAL,
            0,
            TRANSTOTAL,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_TRANSTOTAL_OFFSET
        },

        // TRANSPERSEC
        {
            sizeof(PERF_COUNTER_DEFINITION),
            TRANSPERSEC,
            0,
            TRANSPERSEC,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_COUNTER,
            sizeof(DWORD),
            AX_TRANSPERSEC_OFFSET
        },

        // MEMORYTEMPLCACHE
        {
            sizeof(PERF_COUNTER_DEFINITION),
            MEMORYTEMPLCACHE,
            0,
            MEMORYTEMPLCACHE,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_MEMORYTEMPLCACHE_OFFSET
        },

        // MEMORYTEMPLCACHEHITS
        {
            sizeof(PERF_COUNTER_DEFINITION),
            MEMORYTEMPLCACHEHITS,
            0,
            MEMORYTEMPLCACHEHITS,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_RAW_FRACTION,
            sizeof(DWORD),
            AX_MEMORYTEMPLCACHEHITS_OFFSET
        },
        // MEMORYTEMPLCACHETRYS
        {
            sizeof(PERF_COUNTER_DEFINITION),
            MEMORYTEMPLCACHETRYS,
            0,
            MEMORYTEMPLCACHETRYS,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_RAW_BASE,
            sizeof(DWORD),
            AX_MEMORYTEMPLCACHETRYS_OFFSET
        },       

        // ENGINECACHEHITS
        {
            sizeof(PERF_COUNTER_DEFINITION),
            ENGINECACHEHITS,
            0,
            ENGINECACHEHITS,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_RAW_FRACTION,
            sizeof(DWORD),
            AX_ENGINECACHEHITS_OFFSET
        },

        // ENGINECACHETRYS
        {
            sizeof(PERF_COUNTER_DEFINITION),
            ENGINECACHETRYS,
            0,
            ENGINECACHETRYS,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_RAW_BASE,
            sizeof(DWORD),
            AX_ENGINECACHETRYS_OFFSET
        },

        // ENGINEFLUSHES
        {
            sizeof(PERF_COUNTER_DEFINITION),
            ENGINEFLUSHES,
            0,
            ENGINEFLUSHES,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_ENGINEFLUSHES_OFFSET
        }
    }  // Counters[]
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\perfmon\axpfdata.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Main

File: axpfdata.h

Owner: LeiJin

 Abstract:

	header file for the Denali Extensible Object data definitions.
===================================================================*/

#ifndef _AXPFDATA_H_
#define _AXPFDATA_H_

// AX is shortcut for ActiveX

#define AX_NUM_PERF_OBJECT_TYPES		1
#define AX_NUM_PERFCOUNT				40

#pragma pack (4)

struct AXPD
    {
	PERF_OBJECT_TYPE			AXSObjectType;
	PERF_COUNTER_DEFINITION		Counters[AX_NUM_PERFCOUNT];
    };

#pragma pack ()

// Counter offset in the Perf Counter Block
// Note: those offsets are not the offsets in the counter defintion data structure.
//		 that is, not the offsets in the AXPD.

#define AX_DEBUGDOCREQ_OFFSET      sizeof(DWORD)
#define AX_REQERRRUNTIME_OFFSET    2*sizeof(DWORD)
#define AX_REQERRPREPROC_OFFSET    3*sizeof(DWORD)
#define AX_REQERRCOMPILE_OFFSET    4*sizeof(DWORD)
#define AX_REQERRORPERSEC_OFFSET   5*sizeof(DWORD)
#define AX_REQTOTALBYTEIN_OFFSET   6*sizeof(DWORD)
#define AX_REQTOTALBYTEOUT_OFFSET  7*sizeof(DWORD)
#define AX_REQEXECTIME_OFFSET      8*sizeof(DWORD)
#define AX_REQWAITTIME_OFFSET      9*sizeof(DWORD)
#define AX_REQCOMFAILED_OFFSET     10*sizeof(DWORD)
#define AX_REQBROWSEREXEC_OFFSET   11*sizeof(DWORD)
#define AX_REQFAILED_OFFSET        12*sizeof(DWORD)
#define AX_REQNOTAUTH_OFFSET       13*sizeof(DWORD)
#define AX_REQNOTFOUND_OFFSET      14*sizeof(DWORD)
#define AX_REQCURRENT_OFFSET       15*sizeof(DWORD)
#define AX_REQREJECTED_OFFSET      16*sizeof(DWORD)
#define AX_REQSUCCEEDED_OFFSET     17*sizeof(DWORD)
#define AX_REQTIMEOUT_OFFSET       18*sizeof(DWORD)
#define AX_REQTOTAL_OFFSET         19*sizeof(DWORD)
#define AX_REQPERSEC_OFFSET        20*sizeof(DWORD)
#define AX_SCRIPTFREEENG_OFFSET    21*sizeof(DWORD)
#define AX_SESSIONLIFETIME_OFFSET  22*sizeof(DWORD)
#define AX_SESSIONCURRENT_OFFSET   23*sizeof(DWORD)
#define AX_SESSIONTIMEOUT_OFFSET   24*sizeof(DWORD)
#define AX_SESSIONSTOTAL_OFFSET    25*sizeof(DWORD)
#define AX_TEMPLCACHE_OFFSET       26*sizeof(DWORD)
#define AX_TEMPLCACHEHITS_OFFSET   27*sizeof(DWORD)
#define AX_TEMPLCACHETRYS_OFFSET   28*sizeof(DWORD)
#define AX_TEMPLFLUSHES_OFFSET     29*sizeof(DWORD)
#define AX_TRANSABORTED_OFFSET     30*sizeof(DWORD)
#define AX_TRANSCOMMIT_OFFSET      31*sizeof(DWORD)
#define AX_TRANSPENDING_OFFSET     32*sizeof(DWORD)
#define AX_TRANSTOTAL_OFFSET       33*sizeof(DWORD)
#define AX_TRANSPERSEC_OFFSET      34*sizeof(DWORD)
#define AX_MEMORYTEMPLCACHE_OFFSET   35*sizeof(DWORD)
#define AX_MEMORYTEMPLCACHEHITS_OFFSET 36*sizeof(DWORD)
#define AX_MEMORYTEMPLCACHETRYS_OFFSET   37*sizeof(DWORD)
#define AX_ENGINECACHEHITS_OFFSET   38*sizeof(DWORD)
#define AX_ENGINECACHETRYS_OFFSET   39*sizeof(DWORD)
#define AX_ENGINEFLUSHES_OFFSET     40*sizeof(DWORD)

#define	AX_PERF_LASTOFFSET				AX_ENGINEFLUSHES_OFFSET
#define SIZE_OF_AX_PERF_DATA			AX_PERF_LASTOFFSET + sizeof(DWORD)

#endif // _AXPFDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\perfmon\axperf.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Main

File: axperf.cpp

Owner: LeiJin

Abstract:

    This file implements the Extensible Objects for the ActiveX Server
    object type
===================================================================*/

//--------------------------------------------------------------------
//  Include Files
//
//--------------------------------------------------------------------

#include "denpre.h"
#pragma hdrstop

#include "windows.h"
#include "winperf.h"

#include "axpfdata.h"

#define _NO_TRACING_

#include "dbgutil.h"

//DECLARE_DEBUG_PRINTS_OBJECT();
//DECLARE_DEBUG_VARIABLE();

#include <asppdef.h>            // from denali
#include <perfutil.h>

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)

extern AXPD g_AxDataDefinition;

DWORD   g_dwOpenCount = 0;
BOOL    bInitOK = FALSE;        // true = DLL Initialized OK
BOOL    bSharedMemInitd = FALSE; // state of Shared init

HANDLE  g_hASPWASProcessWait = NULL;  // handle to the W3SVC process
                                      // so we know when to release
                                      // the counters.

// WinSE 5901
CRITICAL_SECTION g_CS;

WCHAR GLOBAL_STRING[] = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[] = L"Costly";

WCHAR NULL_STRING[] = L"\0";    // pointer to null string

/*
 * Output Debug String should occur in Debug only
 */
#ifdef _DEBUG
BOOL gfOutputDebugString = TRUE;
#else
BOOL gfOutputDebugString = FALSE;
#endif
#define DebugOutputDebugString(x) \
    {\
    if (gfOutputDebugString) \
        { \
        OutputDebugString(x); \
        } \
    }

//-------------------------------------------------------------------
//  Function Prototypes
//
//  these are used to insure that the data collection functions accessed
//  by Perf lib will have the correct calling format
//-------------------------------------------------------------------

DWORD APIENTRY      OpenASPPerformanceData(LPWSTR lpDeviceNames);
DWORD APIENTRY      CollectASPPerformanceData(LPWSTR lpValueName,
                                              LPVOID *lppData,
                                              LPDWORD lpcbTotalBytes,
                                              LPDWORD lpNumObjectTypes
                                              );
DWORD APIENTRY      CloseASPPerformanceData(void);
DWORD APIENTRY      RegisterAXS(void);
DWORD APIENTRY      UnRegisterAXS(void);

DWORD   GetQueryType (IN LPWSTR lpValue);
BOOL    IsNumberInUnicodeList ( IN DWORD   dwNumber,
                                IN LPWSTR  lpwszUnicodeList);

CPerfMainBlock g_Shared;        // shared global memory block

/***************************************************************************++

Routine Description:

    Routine drops the shared memory if the managing process of the memory
    goes away.

Arguments:

    LPVOID lpParameter - Unused
    BOOL   bUnused     - Unused

Return Value:

    None

--***************************************************************************/
VOID CALLBACK ShutdownMemory(
    PVOID,
    BOOLEAN
    )
{

    EnterCriticalSection ( &g_CS );

    //
    // Now clean up the shared memory object.
    //
    if ( bSharedMemInitd )
    {
        g_Shared.UnInit();
        bSharedMemInitd = FALSE;
    }

    LeaveCriticalSection ( &g_CS );

}


//--------------------------------------------------------------------
//
//  OpenASPPerformanceData
//
//  This routine will open and map the memory used by the ActiveX Server
//  to pass performance data in.  This routine also initializes the data
//  structure used to pass data back to the registry.
//
//  Arguments:
//
//      Pointer to object ID to be opened.
//
//  Return Value:
//
//      None.
//--------------------------------------------------------------------
//extern "C" DWORD APIENTRY OpenASPPerformanceData(LPWSTR   lpDeviceNames)
DWORD APIENTRY OpenASPPerformanceData(LPWSTR    lpDeviceNames)
{
    int status;
    DWORD RetCode = ERROR_SUCCESS;
    PERF_COUNTER_DEFINITION *pCounterDef;
    DWORD   size = sizeof(DWORD);

    DebugOutputDebugString("Open");

    // WinSE  5901    
    EnterCriticalSection(&g_CS);
    
    LONG nOpenCount = InterlockedIncrement((LONG *)&g_dwOpenCount);
    if (nOpenCount > 1){
        goto ExitPathSuccess;
    };

    // Hold the counter to 1, even if we are no sure to have this 
    // initialized correctly
    
    // get counter and help index base values from registry
    //  Open key to registry entry
    //  read first counter and first help values
    //  update static data structures by adding base to offset
    //  value in structure

    HKEY    hKeyServerPerf;

    status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
        "SYSTEM\\CurrentControlSet\\Services\\ASP\\Performance",
        0L,
        KEY_READ,
        &hKeyServerPerf);

    if (ERROR_SUCCESS != status) {
        RetCode = status;
        goto ExitPath;
    }
    
    DWORD   type;
    DWORD   dwFirstCounter;
    DWORD   dwFirstHelp;

    status = RegQueryValueEx(hKeyServerPerf,
        "First Counter",
        0L,
        &type,
        (LPBYTE)&dwFirstCounter,
        &size);

    if (ERROR_SUCCESS != status || size != sizeof(DWORD)) {

        RegCloseKey(hKeyServerPerf);
        RetCode = status;
        goto ExitPath;        
    }

    status = RegQueryValueEx(hKeyServerPerf,
        "First Help",
        0L,
        &type,
        (LPBYTE)&dwFirstHelp,
        &size);

    if (ERROR_SUCCESS != status || size != sizeof(DWORD)) {

        RegCloseKey(hKeyServerPerf);
        RetCode = status;
        goto ExitPath;
    }

    //
    //  NOTE:   the initialiation could also retrieve
    //          LastCounter and LastHelp if they wanted
    //          to do bounds checking on the new number
    //

    g_AxDataDefinition.AXSObjectType.ObjectNameTitleIndex += dwFirstCounter;
    g_AxDataDefinition.AXSObjectType.ObjectHelpTitleIndex += dwFirstHelp;

    pCounterDef = (PERF_COUNTER_DEFINITION *)&(g_AxDataDefinition.Counters[0]);

    int i;
    for (i = 0; i < AX_NUM_PERFCOUNT; i++, pCounterDef++) {
        pCounterDef->CounterNameTitleIndex += dwFirstCounter;
        pCounterDef->CounterHelpTitleIndex += dwFirstHelp;
    }

    RegCloseKey(hKeyServerPerf); // close key to registry

    bInitOK = TRUE; // ok to use this function
    // we have already incremented g_dwOpenCount
    // before going through this path
ExitPathSuccess:
    LeaveCriticalSection(&g_CS);
    return ERROR_SUCCESS;

ExitPath:
    InterlockedDecrement((LONG *)&g_dwOpenCount);
    LeaveCriticalSection(&g_CS);
    return RetCode;
}

//--------------------------------------------------------------------
//  DWORD   CollectASPPerformanceData
//
//  Description:
//
//      This routine will return the data for the AxctiveX Server counters.
//
//  Arguments:
//
//      IN  LPWSTR  lpValueName
//          pointer to a wide chacter string passed by registry
//
//      IN  OUT LPVOID  *lppData
//          IN: pointer to the address of the buffer to receive the completed
//              PerfDataBlock and subordinate structures.  This routine will
//              append its data to the buffer starting at the point referenced
//              by the *lppData
//          OUT:points to the first byte after the data structure added by
//              this routine.  This routine updated the value at lppdata after
//              appending its data.
//
//      IN OUT  LPDWORD lpcbTotalBytes
//          IN: the address of the DWORD that tells the size in bytes of the
//              buffer referenced by the lppData argument
//          OUT:the number of bytes added by this routine is written to the
//              DWORD pointed to by this argument
//
//      IN OUT  LPDWORD NumObjectTypes
//          IN: the address of the DWORD that receives the number of the objects
//              added by this routine
//          OUT:the number of objects added by this routine is written to
//              the DWORD pointed to by this argument
//
//
//  Return Value:
//
//      ERROR_MORE_DATA if buffer passed is too small to hold data
//
//      ERROR_SUCCESS   if success or any other error.
//
//--------------------------------------------------------------------
DWORD APIENTRY CollectASPPerformanceData(IN     LPWSTR  lpValueName,
                                IN OUT  LPVOID  *lppData,
                                IN OUT  LPDWORD lpcbTotalBytes,
                                IN OUT  LPDWORD lpNumObjectTypes)
{

    BOOL fHookingUp = FALSE;

    // before doing anything else, see if Open went Ok.
    DebugOutputDebugString("collect");
    if(!bInitOK) {
        //unable to continue because open failed
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS;
    }

    //
    //  variables used for error logging

    DWORD   dwQueryType;

    // see if this is a foreign(i.e. non-NT) computer data request

    dwQueryType = GetQueryType(lpValueName);

    if (QUERY_FOREIGN == dwQueryType) {
        // this routine does not service requests for data from
        // Non-NT computers
        *lpcbTotalBytes = (DWORD)0;
        *lpNumObjectTypes = (DWORD)0;

        return ERROR_SUCCESS;
    }

    if (QUERY_ITEMS == dwQueryType) {
        if (!(IsNumberInUnicodeList(g_AxDataDefinition.AXSObjectType.ObjectNameTitleIndex,
            lpValueName))) {

            // request received for data object not provided by this routine
            *lpcbTotalBytes = (DWORD)0;
            *lpNumObjectTypes = (DWORD)0;

            return ERROR_SUCCESS;

        }
    }

    if (QUERY_GLOBAL == dwQueryType) {
        /* Comment the following code out, looks like that it is for
            debugging only.

        int i;
        i++;
        */
    }

     AXPD *pAxDataDefinition = (AXPD *)*lppData;

    ULONG SpaceNeeded = QWORD_MULTIPLE((sizeof(AXPD) + SIZE_OF_AX_PERF_DATA));

    if ( *lpcbTotalBytes < SpaceNeeded) {
        *lpcbTotalBytes = (DWORD)0;
        *lpNumObjectTypes = (DWORD)0;

        return ERROR_MORE_DATA;
    }

    //
    //Copy the (constant, initialized) Object Type and counter defintions to the caller's
    //data buffer
    //

    memmove(pAxDataDefinition, &g_AxDataDefinition, sizeof(AXPD));

    //
    //  Format and collect Active X server performance data from shared memory
    //

    PERF_COUNTER_BLOCK *pPerfCounterBlock = (PERF_COUNTER_BLOCK *)&pAxDataDefinition[1];


    pPerfCounterBlock->ByteLength = SIZE_OF_AX_PERF_DATA;

    PDWORD pdwCounter = (PDWORD)(&pPerfCounterBlock[1]);

    //
    // Must be in a Critical Section when dealing
    // with the shared memory, so we don't attempt
    // to release it while we are using it.
    //
    EnterCriticalSection(&g_CS);

    // if the shared memory isn't init, try again here

    // Whether we are trying to hook up or not will depend
    // completely on whether we are all ready hooked up.
    fHookingUp = !bSharedMemInitd;

    if (bSharedMemInitd == FALSE) {
        bSharedMemInitd = !!SUCCEEDED(g_Shared.Init());
    }

    // If we initialized the shared memory then we need
    // to start monitoring the W3SVC to make sure we let 
    // go of the memory if W3SVC goes down.
    if ( bSharedMemInitd && fHookingUp )
    {
        //
        // if we re-initialized then we need to setup the
        // wait on the process again.  it is possible that 
        // the previous wait has not been cleaned up (since
        // we can't clean it up in the callback function) so
        // if this is the case we need to clean it up first.
        //
        if ( g_hASPWASProcessWait != NULL )
        {
            if ( !UnregisterWait( g_hASPWASProcessWait ) )
            {
                // Nothing we could do here.  We will 
                // end up just leaking it.
            }

            g_hASPWASProcessWait = NULL;
        }

        HANDLE hWASHandle = g_Shared.GetWASProcessHandle();

        if ( hWASHandle == NULL )
        {
            g_Shared.UnInit();
            bSharedMemInitd = FALSE;
        }
        else
        {
            //
            // Register to wait on the managing process,
            // so we release any shared memory if the managing
            // process shutsdown or crashes.
            //
            if ( !RegisterWaitForSingleObject( &g_hASPWASProcessWait,
                                              hWASHandle,
                                              &ShutdownMemory,
                                              NULL,
                                              INFINITE,
                                              WT_EXECUTEONLYONCE | 
                                              WT_EXECUTEINIOTHREAD ) )
            {
                // If we could not wait on the handle then 
                // we have to release the shared memory now,
                // it's not safe to keep it around.
                g_Shared.UnInit();
                bSharedMemInitd = FALSE;

            }
        }

    }

    // Get statistics from shared memory if the shared memory is
    // inited.  Else, return just the definitions.

    // If we didn't get the counters we want to just memset the structure
    // to show all the counters as zero.
    if ((bSharedMemInitd == FALSE) || FAILED(g_Shared.GetStats(pdwCounter))) 
    {
        memset( pdwCounter, 0, SIZE_OF_AX_PERF_DATA );
    }

    // Done dealing with the shared memory,
    // so now we can go ahead and release it
    // if need be.
    LeaveCriticalSection(&g_CS);

    pdwCounter += AX_NUM_PERFCOUNT;


    // update arguments for return

    *lpNumObjectTypes = 1;
    *lpcbTotalBytes = QWORD_MULTIPLE((DIFF((PBYTE)pdwCounter - (PBYTE)pAxDataDefinition)));
    *lppData = (PBYTE)(*lppData) + *lpcbTotalBytes;

    return ERROR_SUCCESS;
}


//-------------------------------------------------------------------
//  DWORD   CloseASPPerformanceData
//
//  Description:
//
//      This routine closes the open handles to ActiveX Server performance
//      counters.
//
//  Arguments:
//
//      None.
//
//  Return Value:
//
//      ERROR_SUCCESS
//
//--------------------------------------------------------------------
DWORD APIENTRY CloseASPPerformanceData(void)
{
    DebugOutputDebugString("Close");

    EnterCriticalSection(&g_CS);

    LONG nLeft = InterlockedDecrement((LONG *)&g_dwOpenCount);
    
    if (nLeft == 0) {
        g_Shared.UnInit();
        bInitOK = FALSE;
    };

    if ( g_hASPWASProcessWait != NULL )
    {
        if ( !UnregisterWait( g_hASPWASProcessWait ) )
        {
            // Nothing we could do here.  We will 
            // end up just leaking it.
        }

        g_hASPWASProcessWait = NULL;
    }
    
    LeaveCriticalSection(&g_CS);

    return ERROR_SUCCESS;
}

static const TCHAR  szPerformance[]     = TEXT("SYSTEM\\CurrentControlSet\\Services\\ASP\\Performance");
static const TCHAR  szAXS[]     = TEXT("SYSTEM\\CurrentControlSet\\Services\\ASP");

static const TCHAR  szLibrary[]     = TEXT("Library");
static const TCHAR  szOpen[]        = TEXT("Open");
static const TCHAR  szClose[]       = TEXT("Close");
static const TCHAR  szCollect[]     = TEXT("Collect");

static const TCHAR  szLibraryValue[]    = TEXT("aspperf.dll");
static const TCHAR  szOpenValue[]       = TEXT("OpenASPPerformanceData");
static const TCHAR  szCloseValue[]      = TEXT("CloseASPPerformanceData");
static const TCHAR  szCollectValue[]    = TEXT("CollectASPPerformanceData");
//--------------------------------------------------------------------
//
//
//--------------------------------------------------------------------
DWORD APIENTRY      RegisterAXS(void)
{
    HKEY    hkey;

    if ((RegCreateKey(HKEY_LOCAL_MACHINE, szPerformance, &hkey)) != ERROR_SUCCESS)
        return E_FAIL;
    if ((RegSetValueEx(hkey, szLibrary, 0, REG_SZ, (const unsigned char *)&szLibraryValue, lstrlen(szLibraryValue))) != ERROR_SUCCESS)
        goto LRegErr;
    if ((RegSetValueEx(hkey, szOpen, 0, REG_SZ, (const unsigned char *)&szOpenValue, lstrlen(szOpenValue))) != ERROR_SUCCESS)
        goto LRegErr;
    if ((RegSetValueEx(hkey, szClose, 0, REG_SZ, (const unsigned char *)&szCloseValue, lstrlen(szCloseValue))) != ERROR_SUCCESS)
        goto LRegErr;
    if ((RegSetValueEx(hkey, szCollect, 0, REG_SZ, (const unsigned char *)&szCollectValue, lstrlen(szCollectValue))) != ERROR_SUCCESS)
        goto LRegErr;

    RegCloseKey(hkey);
    return NOERROR;

LRegErr:
    RegCloseKey(hkey);
    return E_FAIL;

}
//--------------------------------------------------------------------
//
//
//--------------------------------------------------------------------
DWORD APIENTRY      UnRegisterAXS(void)
{
    if ((RegDeleteKey(HKEY_LOCAL_MACHINE, szPerformance)) != ERROR_SUCCESS)
        return (E_FAIL);
    if ((RegDeleteKey(HKEY_LOCAL_MACHINE, szAXS)) != ERROR_SUCCESS)
        return (E_FAIL);
    else
        return NOERROR;
}

DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request

    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request

    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly,
    // then it must be an item list

    return QUERY_ITEMS;

}

BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL        bNewItem;
    //BOOL    bReturnValue;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;

    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;

            case DELIMITER:
                // a delimter is either the delimiter character or the
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList

STDAPI DLLRegisterServer(void)
{
    return RegisterAXS();
}

BOOL WINAPI DllMain(HINSTANCE hInstDLL,  // handle to the DLL module
                    DWORD  dwReason,     // reason for calling function
                    LPVOID lpvReserved   // reserved
                    )
{
    switch(dwReason){
        case DLL_PROCESS_ATTACH:
 //           CREATE_DEBUG_PRINT_OBJECT( "aspperf" );
            DisableThreadLibraryCalls(hInstDLL);
            InitializeCriticalSection(&g_CS);
            return TRUE;
        case DLL_PROCESS_DETACH:
            DeleteCriticalSection(&g_CS);
            return TRUE;   
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\perfmon\makefile.inc ===
#
# Supplemental rules for generating Type library.
#

iCPU=$(PROCESSOR_ARCHITECTURE)
!IF "$(iCPU)"=="x86"
iCPU=I386
!ENDIF

!ifdef _NTTREE
CDROOT=$(_NTTREE)\inetsrv

CopyFiles:
	#if not exist "$(CDROOT)" mkdir $(CDROOT)
	perl -S xcopy2binplace.pl /d /i axperf.ini $(_NTTREE)
	perl -S xcopy2binplace.pl /d /i axctrnm.h  $(CDROOT)
!else
CopyFiles:
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\davcdata\_davcdata.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	_ D A V C D A T A . C P P 
//
//		DAV process precompiled header
//
//
//	Copyright 2000 Microsoft Corporation, All Rights Reserved
//

#include <_davcdata.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\davcdata\davcdata.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	D A V C D A T A . C P P
//
//		HTTP 1.1/DAV 1.0 request handling via ISAPI
//
//      DAVCDATA is the dav process executable for storing handles that should
//      not be recycled when worker process recycle.  It also contains the timing
//      code for timing out locks, and it establishes the shared memory for 
//      the DAV worker processes.
//
//      This process must run under the same identity as the worker processes.
//
//	Copyright 2000 Microsoft Corporation, All Rights Reserved
//
/////////////////////////////////////////////////////////////////////////////

#include "_davcdata.h"
#include <caldbg.h>
#include <crc.h>
#include <davsc.h>
#include <fhcache.h>
#include <ex\autoptr.h>
#include <ex\baselist.h>
#include <ex\buffer.h>
#include <ex\calcom.h>
#include <ex\gencache.h>
#include <ex\reg.h>
#include <ex\synchro.h>
#include <ex\sz.h>

//	Code borrowed from htpext mem.cpp so we have use of the global heap
//
#define g_szMemDll L"staxmem.dll"

struct CHeap
{
	static BOOL FInit();
	static void Deinit();
	static LPVOID Alloc( SIZE_T cb );
	static LPVOID Realloc( LPVOID lpv, SIZE_T cb );
	static VOID Free( LPVOID pv );
};

#include <memx.h>

//	Mapping the exdav non-throwing allocators to something local
//
LPVOID __fastcall ExAlloc( UINT cb )				{ return g_heap.Alloc( cb ); }
LPVOID __fastcall ExRealloc( LPVOID pv, UINT cb )	{ return g_heap.Realloc( pv, cb ); }
VOID __fastcall ExFree( LPVOID pv )				{ g_heap.Free( pv ); }

//	GUIDs
//
const GUID CLSID_FileHandleCache = { 0xa93b88df, 0xef9d, 0x420c, { 0xb4, 0x69, 0xce, 0x07, 0x4e, 0xbe, 0x94, 0xbc}};
const GUID IID_IFileHandleCache = { 0x3017e0e1, 0x94d6, 0x4896, { 0xbc, 0x57, 0xb2, 0xdf, 0x75, 0x92, 0xd1, 0x75 }};

DEC_CONST WCHAR gc_wsz_RegServer[]	= L"/RegServer";
DEC_CONST INT gc_cch_RegServer			= CchConstString(gc_wsz_RegServer);
DEC_CONST WCHAR gc_wsz_UnregServer[]	= L"/UnregServer";
DEC_CONST INT gc_cch_UnregServer		= CchConstString(gc_wsz_UnregServer);
DEC_CONST WCHAR gc_wsz_Embedding[]	= L"-Embedding";
DEC_CONST INT gc_cch_Embedding		= CchConstString(gc_wsz_Embedding);
DEC_CONST WCHAR gc_wsz_CLSIDWW[]	= L"CLSID\\";
DEC_CONST INT gc_cch_CLSIDWW			= CchConstString(gc_wsz_CLSIDWW);
DEC_CONST WCHAR gc_wsz_AppIDWW[]	= L"AppID\\";
DEC_CONST INT gc_cch_AppIDWW			= CchConstString(gc_wsz_AppIDWW);
DEC_CONST WCHAR gc_wsz_AppID[]		= L"AppID";

DEC_CONST WCHAR gc_wsz_WebDAVFileHandleCache[] = L"Web DAV File Handle Cache";
DEC_CONST INT gc_cch_WebDAVFileHandleCache	= CchConstString(gc_wsz_WebDAVFileHandleCache);
DEC_CONST WCHAR gc_wszLaunchPermission[]	= L"LaunchPermission";
DEC_CONST INT gc_cchLaunchPermission		= CchConstString(gc_wszLaunchPermission);
DEC_CONST WCHAR gc_wszIIS_WPG[]			= L"IIS_WPG";
DEC_CONST INT gc_cchIIS_WPG				= CchConstString(gc_wszIIS_WPG);
DEC_CONST WCHAR gc_wsz_WWLocalServer32[]= L"\\LocalServer32";
DEC_CONST INT gc_cch_WWLocalServer32		= CchConstString(gc_wsz_WWLocalServer32);
DEC_CONST WCHAR gc_wsz_IFileHandleCache[]	= L"IFileHandleCache";
DEC_CONST INT gc_cch_IFileHandleCache		= CchConstString(gc_wsz_IFileHandleCache);

#ifdef	DBG
BOOL g_fDavTrace = FALSE;
DEC_CONST CHAR gc_szDbgIni[] = "DAVCData.INI";
DEC_CONST INT gc_cchDbgIni = CchConstString(gc_szDbgIni);
#endif

// Timer constants and globals.
//
const DWORD WAIT_PERIOD = 60000;   // 1 min = 60 sec = 60,000 milliseconds

//	Helper functions
//
BOOL FCanUnloadServer();
static DWORD s_dwMainTID = 0;

// ===============================================================
// Supporting class definitions
// ===============================================================

class CHandleArray
{

protected:
	
	HANDLE m_rgHandles[MAXIMUM_WAIT_OBJECTS];
	UINT m_uiHandles;

public:

	CHandleArray() :
		m_uiHandles(0)
	{
	}

	HANDLE * PhGetHandles()
	{
		return m_rgHandles;
	}

	UINT UiGetHandleCount()
	{
		return m_uiHandles;
	}

	BOOL FIsFull()
	{
		return (MAXIMUM_WAIT_OBJECTS == m_uiHandles);
	}

	VOID AddHandle(HANDLE h)
	{
		Assert(FALSE == FIsFull());
		m_rgHandles[m_uiHandles++] = h;
	}

	VOID RemoveHandle(UINT uiIndex, BOOL fCloseHandle)
	{
		Assert(m_uiHandles > uiIndex);

		if (fCloseHandle)
		{
			CloseHandle(m_rgHandles[uiIndex]);
		}
		memcpy(m_rgHandles + uiIndex, m_rgHandles + uiIndex + 1, (m_uiHandles - uiIndex - 1) * sizeof(HANDLE));
		m_uiHandles--;
	}
};

class CHandleArrayForHandlePool : public CListElement<CHandleArrayForHandlePool>,
										public CHandleArray
{

public:

	//	Indexes to the handles in the array
	//
	enum
	{
		ih_external_update,
		ih_delete_timer,
		c_events,
		ih_wp = c_events
	};


	CHandleArrayForHandlePool(HANDLE hEvtNewWP,
									HANDLE hEvtDelTimer)
	{
		Assert(c_events < MAXIMUM_WAIT_OBJECTS);
		
		AddHandle(hEvtNewWP);
		AddHandle(hEvtDelTimer);
	}

	BOOL FIsEmpty()
	{
		Assert(c_events <= m_uiHandles);
		
		return (c_events == m_uiHandles);
	}
};

class CHandlePool : public Singleton<CHandlePool>
{
	HANDLE m_hEvtUpdatesAllowed;
	HANDLE m_hEvtStartListening;
	HANDLE m_hEvtExternalUpdate;
	HANDLE m_hEvtDelTimer;
	LONG m_lUpdatesInProgress;
	LONG m_lShutDown;

	CCriticalSection m_cs;
	CListHead<CHandleArrayForHandlePool> m_listHandleArrayForHandlePool;

	//	Wait period in miliseconds for looking at single handle bucket
	//
	enum { WAIT_POLL_PERIOD = 5000 };

	//
	//	Friend declarations required by Singleton template
	//
	friend class Singleton<CHandlePool>;

	//	CREATORS
	//
	CHandlePool() :
		m_hEvtUpdatesAllowed(NULL),
		m_hEvtStartListening(NULL),
		m_hEvtExternalUpdate(NULL),
		m_hEvtDelTimer(NULL),
		m_lUpdatesInProgress(0),
		m_lShutDown(0)
	{
	}
	
	~CHandlePool()
	{
		UnInitialize();
	}

	//	NOT IMPLEMENTED
	//
	CHandlePool& operator=( const CHandlePool& );
	CHandlePool( const CHandlePool& );

public:

	//	CREATORS
	//
	//	Instance creating/destroying routines provided
	//	by the Singleton template.
	//
	using Singleton<CHandlePool>::CreateInstance;
	using Singleton<CHandlePool>::DestroyInstance;
	using Singleton<CHandlePool>::Instance;
	
	HRESULT HrInitialize()
	{
		HRESULT hr = S_OK;
		HANDLE hWaitingThread = NULL;
		auto_handle<HANDLE> a_hEvtUpdatesAllowed;
		auto_handle<HANDLE> a_hEvtStartListening;
		auto_handle<HANDLE> a_hEvtExternalUpdate;
		auto_handle<HANDLE> a_hEvtDelTimer;
		auto_ptr<CHandleArrayForHandlePool> a_pHandleArrayForHandlePool;

		//	Create the event that is used to indicate if the updates are allowed.
		//	While this event is set the updates can be performed and noone is
		//	listening on the handles in the pool handle arrays.
		//
		a_hEvtUpdatesAllowed =  CreateEvent (NULL,	// lpEventAttributes
										 TRUE,	// bManualReset
										 FALSE,	// bInitialState
										 NULL);	// lpName
		if (NULL == a_hEvtUpdatesAllowed.get())
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			DebugTrace ("CreateEvent failed 0x%08lX\n", hr);
			goto ret;
		}

		//	Create event that triggers the thread to again start listening on 
		//	process handes.
		//
		a_hEvtStartListening =  CreateEvent (NULL,		// lpEventAttributes
									     FALSE,	// bManualReset
									     FALSE,	// bInitialState
									     NULL);	// lpName
		if (NULL == a_hEvtStartListening.get())
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			DebugTrace ("CreateEvent failed 0x%08lX\n", hr);
			goto ret;
		}
	
		//	Create the event that is used to notify the arrival of new event
		//
		a_hEvtExternalUpdate =  CreateEvent (NULL,	// lpEventAttributes
										 FALSE,	// bManualReset
										 FALSE,	// bInitialState
										 NULL);	// lpName
		if (NULL == a_hEvtExternalUpdate.get())
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			DebugTrace ("CreateEvent failed 0x%08lX\n", hr);
			goto ret;
		}

		//	Create the event that listens for timer deletion
		//
		a_hEvtDelTimer =  CreateEvent (NULL,		// lpEventAttributes
								      FALSE,		// bManualReset
								      FALSE,		// bInitialState
								      NULL);		// lpName
		if (NULL == a_hEvtDelTimer.get())
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			DebugTrace ("CreateEvent failed 0x%08lX\n", hr);
			goto ret;
		}

		a_pHandleArrayForHandlePool = new CHandleArrayForHandlePool(a_hEvtExternalUpdate.get(), a_hEvtDelTimer.get());
		if (NULL == a_pHandleArrayForHandlePool.get())
		{
			hr = E_OUTOFMEMORY;
			DebugTrace ("Allocation failed 0x%08lX\n", hr);
			goto ret;
		}

		m_listHandleArrayForHandlePool.Append(a_pHandleArrayForHandlePool.relinquish());
		m_hEvtUpdatesAllowed = a_hEvtUpdatesAllowed.relinquish();
		m_hEvtStartListening = a_hEvtStartListening.relinquish();
		m_hEvtExternalUpdate = a_hEvtExternalUpdate.relinquish();
		m_hEvtDelTimer = a_hEvtDelTimer.relinquish();

	ret:

		if (FAILED(hr))
		{
			UnInitialize();
		}

		return hr;
	}

	VOID UnInitialize()
	{
		CHandleArrayForHandlePool * pHandleArrayForHandlePool;
		pHandleArrayForHandlePool = m_listHandleArrayForHandlePool.GetListHead();

		while (pHandleArrayForHandlePool)
		{
			HANDLE * pHandles = pHandleArrayForHandlePool->PhGetHandles();
			UINT uiHandles = pHandleArrayForHandlePool->UiGetHandleCount();
			
			for (UINT ui = CHandleArrayForHandlePool::ih_wp; ui < uiHandles; ui++)
			{
				CloseHandle(pHandles[ui]);
			}
		
			m_listHandleArrayForHandlePool.Remove(pHandleArrayForHandlePool);
			delete pHandleArrayForHandlePool;
			pHandleArrayForHandlePool = m_listHandleArrayForHandlePool.GetListHead();
		}

		if (m_hEvtUpdatesAllowed)
		{
			CloseHandle(m_hEvtUpdatesAllowed);
		}

		if (m_hEvtStartListening)
		{
			CloseHandle(m_hEvtStartListening);
		}

	
		if (m_hEvtExternalUpdate)
		{
			CloseHandle(m_hEvtExternalUpdate);
		}

		if (m_hEvtDelTimer)
		{
			CloseHandle(m_hEvtDelTimer);
		}
	}

	VOID AllowUpdatesToExecute()
	{
		//	Allow updates and start waiting for them to end
		//
		SetEvent(m_hEvtUpdatesAllowed);
		WaitForSingleObject(m_hEvtStartListening,
						  INFINITE);
	}

	VOID AllowShutdownToExecute()
	{
		InterlockedExchange(&m_lShutDown, 1);
		SetEvent(m_hEvtUpdatesAllowed);
	}

	VOID DisallowUpdates()
	{
		//	We disallow updates only if we are not in shutdown. I.e.
		//	we are in the listening loop
		//
		if (0 == InterlockedCompareExchange(&m_lShutDown,
											1,
											1))
		{
			ResetEvent(m_hEvtUpdatesAllowed);
		}
	}

	HRESULT HrAddHandle(HANDLE h)
	{
		HRESULT hr = S_OK;
		BOOL fHandleAdded = FALSE;

		//	Inform the thread that is waiting on process handles
		//	that the update has arrived. We do this only if there
		//	were no other updates in progress.
		//
		if (1 == InterlockedIncrement(&m_lUpdatesInProgress))
		{
			DisallowUpdates();
			SetEvent(m_hEvtExternalUpdate);
		}

		//	Wait until the listening thread is ready for updates, I.e. it 
		// stopped listening on process handles or doing other work.
		//
		WaitForSingleObject(m_hEvtUpdatesAllowed,
						  INFINITE);

		{
			CSynchronizedBlock sb(m_cs);

			CHandleArrayForHandlePool * pHandleArrayForHandlePoolNext;
			pHandleArrayForHandlePoolNext = m_listHandleArrayForHandlePool.GetListHead();

			do
			{
				Assert(NULL != pHandleArrayForHandlePoolNext);
			
				if (pHandleArrayForHandlePoolNext->FIsFull())
				{
					pHandleArrayForHandlePoolNext = pHandleArrayForHandlePoolNext->GetNextListElement();
				}
				else
				{
					pHandleArrayForHandlePoolNext->AddHandle(h);
					fHandleAdded = TRUE;
					break;
				}
			}
			while (NULL != pHandleArrayForHandlePoolNext);

			if (FALSE == fHandleAdded)
			{
				auto_ptr<CHandleArrayForHandlePool> a_pHandleArrayForHandlePool;

				Assert(NULL != m_hEvtExternalUpdate);
				Assert(NULL != m_hEvtDelTimer);
			
				a_pHandleArrayForHandlePool = new CHandleArrayForHandlePool(m_hEvtExternalUpdate, m_hEvtDelTimer);
				if (NULL == a_pHandleArrayForHandlePool.get())
				{
					hr = E_OUTOFMEMORY;
					DebugTrace ("Allocation failed 0x%08lX\n", hr);
					goto ret;
				}
				a_pHandleArrayForHandlePool->AddHandle(h);
				m_listHandleArrayForHandlePool.Append(a_pHandleArrayForHandlePool.relinquish());
			}
		}

		//	If this is last update to leave allow the thread listening
		//	on process handles to proceed
		//
		if (0 == InterlockedDecrement(&m_lUpdatesInProgress))
		{
			DisallowUpdates();
			SetEvent(m_hEvtStartListening);
		}

	ret:

		return hr;
	}

	VOID RemoveHandleInternal(CHandleArrayForHandlePool * pHandleArrayForHandlePool, UINT uiIndex)
	{
		pHandleArrayForHandlePool->RemoveHandle(uiIndex, TRUE);
		if (pHandleArrayForHandlePool->FIsEmpty())
		{
			//	Do not remove the last buffer in the list as we
			//	still want to wait for the events of external update
			//
			if (1 < m_listHandleArrayForHandlePool.ListSize())
			{
				m_listHandleArrayForHandlePool.Remove(pHandleArrayForHandlePool);
				delete pHandleArrayForHandlePool;
			}
		}
	}

	VOID SignalTimerDelete()
	{
		SetEvent(m_hEvtDelTimer);
	}

	static DWORD __stdcall DwWaitOnWPs (PVOID pvThreadData);
};

class CLockData
{
	//	Constant values
	//
	enum { DEFAULT_LOCK_TIMEOUT = 60 * 3 };

	//	Lock ID
	//
	LARGE_INTEGER m_liLockID;

	//	Lock description data
	//
	DWORD m_dwAccess;
	DWORD m_dwLockType;
	DWORD m_dwLockScope;
	DWORD m_dwSecondsTimeout;

	//	Resource and comment strings
	//
	auto_ptr<WCHAR> m_pwszResourceString;
	auto_ptr<WCHAR> m_pwszOwnerComment;

	//	Owner of the lock
	//
	DWORD m_dwSidLength;
	auto_ptr<BYTE> m_pbSid;

	//	File handle that this process is holding to keep the
	//	file open. It must be duplicated before using
	//
	auto_handle<HANDLE>	m_hFileHandle;

	//	Lock cache timeout data
	//
	FILETIME	m_ftLastAccess;

	//	Cached values to speed up timeout calculation
	//
	FILETIME	m_ftRememberNow;
	BOOL m_fHasTimedOut;

	//	Lock token string
	//
	UINT m_cchToken;
	WCHAR m_rgwchToken[MAX_LOCKTOKEN_LENGTH];

public:

	//	CREATORS
	//
	CLockData() :
		m_dwAccess(0),
		m_dwLockType(0),
		m_dwLockScope(0),
		m_dwSecondsTimeout(DEFAULT_LOCK_TIMEOUT),
		m_dwSidLength(0),
		m_fHasTimedOut(FALSE),
		m_cchToken(0)
	{
		m_liLockID.QuadPart = 0;
		m_ftLastAccess.dwLowDateTime = 0;
		m_ftLastAccess.dwHighDateTime = 0;
		m_ftRememberNow.dwLowDateTime = 0;
		m_ftRememberNow.dwHighDateTime = 0;
	}

	~CLockData()
	{
	}

 	HRESULT HrInitialize(LPCWSTR pwszGuid,
 						LARGE_INTEGER liLockID,
						DWORD dwAccess,
						DWORD dwLockType,
						DWORD dwLockScope,
						DWORD dwSecondsTimeout,
						LPCWSTR pwszResourceString,
						LPCWSTR pwszOwnerComment,
						DWORD dwSid,
						BYTE * pbSid)
 	{
 		HRESULT hr = S_OK;

		//	Opaquelocktoken format is partially defined by our IETF spec.
		//	First opaquelocktoken:<our guid>, then our specific lock id.
		//
		m_cchToken = _snwprintf(m_rgwchToken, 
							   CElems(m_rgwchToken),
							   L"<opaquelocktoken:%ls:%I64d>",
							   pwszGuid,
							   liLockID);
		if (((-1) == static_cast<INT>(m_cchToken)) || (CElems(m_rgwchToken) == m_cchToken))
		{
			//	This should not happen as we give sufficient buffer. But let us 
			//	handle this to the best of our ability for preventive reasons.
			//
			Assert(0);
			m_cchToken = CElems(m_rgwchToken) - 1;
			m_rgwchToken[m_cchToken] = L'\0';
		}

		m_liLockID = liLockID;
		m_dwAccess = dwAccess;
		m_dwLockType = dwLockType;
		m_dwLockScope = dwLockScope;
		if (dwSecondsTimeout)
		{
			m_dwSecondsTimeout = dwSecondsTimeout;
		}

		if (pwszResourceString)
		{
			UINT cchResourceString = static_cast<UINT>(wcslen(pwszResourceString));
			m_pwszResourceString = static_cast<LPWSTR>(ExAlloc(CbSizeWsz(cchResourceString)));
			if (NULL == m_pwszResourceString.get())
			{
				hr = E_OUTOFMEMORY;
				goto ret;
			}
			memcpy(m_pwszResourceString.get(), pwszResourceString, sizeof(WCHAR) * cchResourceString);
			m_pwszResourceString[cchResourceString] = L'\0';
		}

		if (pwszOwnerComment)
		{
			UINT cchOwnerComment = static_cast<UINT>(wcslen(pwszOwnerComment));
			m_pwszOwnerComment = static_cast<LPWSTR>(ExAlloc(CbSizeWsz(cchOwnerComment)));
			if (NULL == m_pwszOwnerComment.get())
			{
				hr = E_OUTOFMEMORY;
				goto ret;
			}
			memcpy(m_pwszOwnerComment.get(), pwszOwnerComment, sizeof(WCHAR) * cchOwnerComment);
			m_pwszOwnerComment[cchOwnerComment] = L'\0';
		}

		m_pbSid = static_cast<BYTE *>(ExAlloc(dwSid));
		if (NULL == m_pbSid.get())
		{
			hr = E_OUTOFMEMORY;
			goto ret;
		}
		if (!CopySid(dwSid, m_pbSid.get(), pbSid))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			goto ret;
		}
		m_dwSidLength = dwSid;

		//	Lastly set in the last file time that this was accessed.
		//
		GetSystemTimeAsFileTime(&m_ftLastAccess);

	ret:

		return hr;
 	}

	HRESULT HrLockFile(HANDLE hFile, DWORD dwProcessId)
	{
		HRESULT hr = S_OK;

		auto_handle<HANDLE> a_hProcess = NULL;
		auto_handle<HANDLE> a_hDupFileHandle = NULL;

		a_hProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwProcessId);
		if (NULL == a_hProcess.get())
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			DebugTrace("Opening original process failed  0x%08lX\n", hr);
			goto ret;
		}

		if (!DuplicateHandle(a_hProcess.get(),
						   hFile,
						   GetCurrentProcess(),
						   a_hDupFileHandle.load(),
						   0,
						   FALSE,
						   DUPLICATE_SAME_ACCESS))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			DebugTrace("Failed to duplicate handle 0x%08lX\n", hr);
			goto ret;
		}

		m_hFileHandle = a_hDupFileHandle.relinquish();

	ret:

		return hr;
	}

	//	Lock ID
	//
	LARGE_INTEGER LiLockID()
	{
		return m_liLockID;
	}

	//	Lock token string
	//
	UINT CchLockTokenString(LPCWSTR * ppwszLockToken) const
	{
		if (ppwszLockToken)
		{
			*ppwszLockToken = m_rgwchToken;
		}
		return m_cchToken;
	}

	//	Resource string
	//
	LPCWSTR PwszResourceString() const
	{
		return m_pwszResourceString.get();
	}

	//	Owner comment
	//
	LPCWSTR PwszOwnerComment() const
	{
		return m_pwszOwnerComment.get();
	}

	//	Touch the lock
	//
	VOID SetLastAccess(FILETIME ftNow)
	{
		m_ftLastAccess = ftNow;
	}

	//	Set timeout
	//
	VOID SetSecondsTimeout(DWORD dwSecondsTimeout)
	{
		m_dwSecondsTimeout = dwSecondsTimeout;
	}

	//	Check the owner
	//
	BOOL FIsSameOwner(PSID pSid) const
	{
		BOOL fIsSameOwner = TRUE;
	
		Assert(pSid);
		Assert(IsValidSid(m_pbSid.get()));
		Assert(IsValidSid(pSid));

		if (!EqualSid(m_pbSid.get(), pSid))
		{
			fIsSameOwner = FALSE;
		}

		return fIsSameOwner;
	}

	//	Check the resource
	//
	BOOL FIsSameResource(LPCWSTR pwszResource) const
	{
		BOOL fIsSameResource = TRUE;

		Assert(pwszResource);

		if (_wcsicmp(m_pwszResourceString.get(), pwszResource))
		{
			fIsSameResource = FALSE;
		}

		return fIsSameResource;
	}

	//	Check the type
	//
	BOOL FIsSameType(DWORD dwLockType) const
	{
		return (0 != (dwLockType & m_dwLockType));
	}

	//	Fill the data of the lock into the structure for marshalling
	//
	VOID FillSNewLockData(SNewLockData * pnld) const
	{
		Assert(pnld);
		
		pnld->m_dwAccess = m_dwAccess;
		pnld->m_dwLockType = m_dwLockType;
		pnld->m_dwLockScope = m_dwLockScope;
		pnld->m_dwSecondsTimeout = m_dwSecondsTimeout;
		pnld->m_pwszResourceString = m_pwszResourceString.get();
		pnld->m_pwszOwnerComment = m_pwszOwnerComment.get();
	}

	//	Fill the handle data of the lock for marshalling
	//
	VOID FillSLockHandleData(SLockHandleData * plhd) const
	{
		Assert(plhd);
	
		plhd->h = reinterpret_cast<DWORD_PTR>(m_hFileHandle.get());
		plhd->dwProcessID = /*CLockCache::Instance().DwGetThisProcessID();*/ GetCurrentProcessId();
	}

	BOOL FIsExpired(FILETIME ftNow)
	{
		//	This function will be called twice during each ExpiredLocks
		//	check.  The first time it is called we should do the checks
		//	and set the m_fHasTimedOut call.  The second time we want to
		//	avoid it because we all ready know the answer.  By keeping
		//	track of the ftNow times we are called with we can determine
		//	if we have all ready done the calculation or not.
		//	We also know that no matter what once a lock times out, it should
		//	remain timed out for it's lifetime.
		//
		if ((!m_fHasTimedOut) && (0 != CompareFileTime(&ftNow, &m_ftRememberNow)))
		{
			//	Find out if based on the time passed in has the lock expired
			//
			INT64 i64TimePassed;
			DWORD dwSecondsPassed;

			//	Do the math to figure out when this lock expires/expired.
			//
			//	First calculate how many seconds have passed since this lock
			//	was last accessed.
			//	Subtract the filetimes to get the time passed in 100-nanosecond
			//	increments. (That's how filetimes count.)
			//		NOTE: Operation bellow is very dangerous on 64 bit platforms,
			//	as the filetimes need to be alligned on 8 byte boundary. So even
			//	change in order of current member variables or adding new ones
			//	can get us in the trouble
			//
			i64TimePassed = ((*(INT64*)&ftNow) - (*(INT64*)&m_ftLastAccess));

			//	Convert our time passed into seconds (10,000,000 100-nanosec incs in a second).
			//
			dwSecondsPassed = static_cast<DWORD>(i64TimePassed/10000000);

			//	Compare the timeout from the lock object to the count of seconds.
			//	If this lock object has expired, remove it.
			//
			m_fHasTimedOut = m_dwSecondsTimeout < dwSecondsPassed;
			m_ftRememberNow = ftNow;
        	}

		return  m_fHasTimedOut;
	}
	
};
typedef CLockData* PLockData;

class CLockCache : public Singleton<CLockCache>
{
	//
	//	Friend declarations required by Singleton template
	//
	friend class Singleton<CLockCache>;

	//	Guid string for our lock IDs
	//
	WCHAR m_rgwchGuid[gc_cchMaxGuid];

	//	Current process ID
	//
	DWORD m_dwThisProcessId;

	//	Next lock ID counter
	//
	LARGE_INTEGER m_liLastLockID;

	class LIKey
	{
	public:

		LARGE_INTEGER	m_li;

		LIKey(LARGE_INTEGER li) :
			m_li(li)
		{
		}

		//	operators for use with the hash cache
		//
		int hash( const int rhs ) const
		{
			return (m_li.LowPart % rhs);
		}
		bool isequal( const LIKey& rhs ) const
		{
			return (m_li.QuadPart == rhs.m_li.QuadPart);
		}
	};

	typedef CCache<LIKey, PLockData> CLockCacheById;
	typedef CCache<CRCWsziLI, PLockData> CLockCacheByName;

	CMRWLock m_mrwCache;
	CLockCacheById m_lockCacheById;
	CLockCacheByName m_lockCacheByName;
	HANDLE m_hTimer;

	class COpClear : public CLockCacheById::IOp
	{
		//	NOT IMPLEMENTED
		//
		COpClear& operator=( const COpClear& );

	public:

		//	CREATORS
		//
		COpClear()
		{
		}

		BOOL operator() (const LIKey&,
						  const PLockData& pLockData)
		{
			delete pLockData;
			return TRUE;
		}
		
	};

	class COpExpire : public CLockCacheById::IOp
	{
		FILETIME m_ftNow;
		CLockCacheById& m_lockCacheById;
		CLockCacheByName& m_lockCacheByName;
	
		//	NOT IMPLEMENTED
		//
		COpExpire& operator=( const COpExpire& );

	public:

		//	CREATORS
		//
		COpExpire(FILETIME ftNow,
					 CLockCacheById& lockCacheById,
					 CLockCacheByName& lockCacheByName) : m_ftNow(ftNow),
					 									     m_lockCacheById(lockCacheById),
					 									     m_lockCacheByName(lockCacheByName)
					 
		{
		}

		BOOL operator() (const LIKey&,
						  const PLockData& pLockData)
		{
			if (pLockData->FIsExpired(m_ftNow))
			{
				m_lockCacheById.Remove(LIKey(pLockData->LiLockID()));
				m_lockCacheByName.Remove(CRCWsziLI(pLockData->PwszResourceString(),
													pLockData->LiLockID(),
													TRUE));
				delete pLockData;
			}

			return TRUE;
		}
	};

	class COpGatherLockData : public CLockCacheByName::IOp
	{
		//	The path to match
		//
		LPCWSTR m_pwszPath;

		//	Lock type to match
		//
		DWORD m_dwLockType;

		//	Error code in which operation has ended
		//
		HRESULT m_hr;

		//	Results gathered by the operation
		//
		DWORD m_dwLocksFound;
		ChainedBuffer<SNewLockData> m_chBufNewLockData;
		ChainedBuffer<LPWSTR> m_chBufPLockTokens;

		//	NOT IMPLEMENTED
		//
		COpGatherLockData& operator=( const COpGatherLockData& );

	public:

		//	CREATORS
		//
		COpGatherLockData( LPCWSTR pwszPath,
								DWORD dwLockType ) :
			m_pwszPath(pwszPath),
			m_dwLockType(dwLockType),
			m_hr(S_OK),
			m_dwLocksFound(0)
		{
		}

		//	MANIPULATORS
		//
		VOID Invoke( CLockCacheByName& cache )
		{
			//	Do the ForEachMatch()
			//
			LARGE_INTEGER li;
			li.QuadPart = 0;
			cache.ForEachMatch( CRCWsziLI(m_pwszPath, li, FALSE), *this );
		}

		BOOL operator() (const CRCWsziLI&,
						  const PLockData& pLockData)
		{
			BOOL fSuccess = TRUE;
		
			if (pLockData->FIsSameType(m_dwLockType))
			{
				SNewLockData * pNewLockData;
				LPWSTR * ppLockToken;
				
				pNewLockData = m_chBufNewLockData.Alloc(sizeof(SNewLockData));
				if (NULL == pNewLockData)
				{
					m_hr = E_OUTOFMEMORY;
					fSuccess = FALSE;
					goto ret;
				}
				pLockData->FillSNewLockData(pNewLockData);

				ppLockToken = m_chBufPLockTokens.Alloc(sizeof(LPWSTR));
				if (NULL == ppLockToken)
				{
					m_hr = E_OUTOFMEMORY;
					fSuccess = FALSE;
					goto ret;
				}
				pLockData->CchLockTokenString(const_cast<LPCWSTR *>(ppLockToken));

				m_dwLocksFound++;
			}
			
		ret:

			return fSuccess;
		}

		HRESULT HrLocksFound(DWORD * pdwLocksFound)
		{
			HRESULT hr = m_hr;

			Assert(pdwLocksFound);

			if (FAILED(hr))
			{
				goto ret;
			}
			
			*pdwLocksFound = m_dwLocksFound;

		ret:

			return hr;
		}

		HRESULT HrGetData(SNewLockData * pNewLockData,
							LPWSTR * ppwszLockToken)
		{
			HRESULT hr = m_hr;
			auto_co_task_mem<WCHAR> a_pwszResourceString;
			auto_co_task_mem<WCHAR> a_pwszOwnerComment;
			auto_co_task_mem<WCHAR> a_pwszLockToken;
			UINT cch;
			DWORD dw1 = 0;
			DWORD dw2 = 0;

			Assert(pNewLockData);
			Assert(ppwszLockToken);

			if (FAILED(hr))
			{
				goto ret;
			}

			m_chBufNewLockData.Dump(pNewLockData, sizeof(SNewLockData) * m_dwLocksFound);
			m_chBufPLockTokens.Dump(ppwszLockToken, sizeof(LPWSTR) * m_dwLocksFound);

			for (dw1 = 0; dw1 < m_dwLocksFound; dw1++)
			{
				cch = static_cast<UINT>(wcslen(pNewLockData[dw1].m_pwszResourceString));
				a_pwszResourceString = static_cast<LPWSTR>(CoTaskMemAlloc(CbSizeWsz(cch)));
				if (NULL == a_pwszResourceString.get())
				{
					hr = E_OUTOFMEMORY;
					goto ret;
				}
				memcpy(a_pwszResourceString.get(), pNewLockData[dw1].m_pwszResourceString, sizeof(WCHAR) * (cch + 1));

				cch = static_cast<UINT>(wcslen(pNewLockData[dw1].m_pwszOwnerComment));
				a_pwszOwnerComment = static_cast<LPWSTR>(CoTaskMemAlloc(CbSizeWsz(cch)));
				if (NULL == a_pwszOwnerComment.get())
				{
					hr = E_OUTOFMEMORY;
					goto ret;
					
				}
				memcpy(a_pwszOwnerComment.get(), pNewLockData[dw1].m_pwszOwnerComment, sizeof(WCHAR) * (cch + 1));

				cch = static_cast<UINT>(wcslen(ppwszLockToken[dw1]));
				a_pwszLockToken= static_cast<LPWSTR>(CoTaskMemAlloc(CbSizeWsz(cch)));
				if (NULL == a_pwszLockToken.get())
				{
					hr = E_OUTOFMEMORY;
					goto ret;
				}
				memcpy(a_pwszLockToken.get(), ppwszLockToken[dw1], sizeof(WCHAR) * (cch + 1));

				pNewLockData[dw1].m_pwszResourceString = a_pwszResourceString.relinquish();
				pNewLockData[dw1].m_pwszOwnerComment = a_pwszOwnerComment.relinquish();
				ppwszLockToken[dw1] = a_pwszLockToken.relinquish();
			}

		ret:

			if (FAILED(hr))
			{
				//	Cleanup whatever we have allocated so far
				//
				for (dw2 = 0; dw2 < dw1; dw2++)
				{
					CoTaskMemFree(pNewLockData[dw1].m_pwszResourceString);
					CoTaskMemFree(pNewLockData[dw1].m_pwszOwnerComment);
					CoTaskMemFree(ppwszLockToken[dw1]);
				}
			}

			return hr;
		}
	};

	//	CREATORS
	//
	CLockCache() :
		m_dwThisProcessId(0),
		m_hTimer(NULL)
	{
		m_liLastLockID.QuadPart = 0x0000003200000032;
	}
	
	~CLockCache()
	{
		COpClear opClear;
		m_lockCacheById.ForEach(opClear);
	}

	//	NOT IMPLEMENTED
	//
	CLockCache& operator=( const CLockCache& );
	CLockCache( const CLockCache& );

	LARGE_INTEGER LiGetNewLockID()
	{
		LARGE_INTEGER liLockID;

		//$BUGBUG. There is a problem if while high part is incrementing
		//	other thread comes in and tries to get the next ID. As lower part
		//	would be already incremented it still may get old high part. This
		//	is very rare condition, but we should have some synchronization
		//	here.
		//
		liLockID.LowPart = InterlockedIncrement(reinterpret_cast<LONG *>(&m_liLastLockID.LowPart));
		if (0 == liLockID.LowPart)
		{
			liLockID.HighPart = InterlockedIncrement(&m_liLastLockID.HighPart);
		}
		else
		{
			liLockID.HighPart = m_liLastLockID.HighPart;
		}

		return liLockID;
	}

	VOID ExpireLocks()
	{
		FILETIME ftNow;

		//	Get the current time
		//
		GetSystemTimeAsFileTime(&ftNow);

		//	Protect ourselves for the operation
		//
		CSynchronizedWriteBlock swb(m_mrwCache);

		//	Initialize the operation
		//
		COpExpire opExpire(ftNow,
						  m_lockCacheById,
						  m_lockCacheByName);

		//	Iterate through the cache trying to expire items
		//
		m_lockCacheById.ForEach(opExpire);

		//	Attempt to kill the timer if there are no locks
		//
		if (0 == m_lockCacheById.CItems())
		{
			CHandlePool::Instance().SignalTimerDelete();
		}
	}

	static VOID CALLBACK CheckLocks(PVOID pvIgnored, BOOLEAN fIgnored)
	{
		Instance().ExpireLocks();
	}

	HRESULT HrLaunchLockTimer()
	{
		HRESULT hr = S_OK;
		HANDLE hTimer = NULL;

		//	We do not protect ourselves for the operation as
		//	the only caller already protects us...
	
		if (NULL == m_hTimer)
		{
			if (!CreateTimerQueueTimer(&hTimer,		// timer that we created
									   NULL,			// use default timer queue
									   CheckLocks,	// function that will check the locks in the cache 
													 // and release any expired locks.
									   NULL,			// parameter to the callback function
									   WAIT_PERIOD,	// how long to wait before calling the callback function 
													 // the first time.
									   WAIT_PERIOD,	// how long to wait between calls to the callback function
									   WT_EXECUTEINIOTHREAD))  // where to execute the function call...
			{
				hr = HRESULT_FROM_WIN32(GetLastError());
				goto ret;
			}

			m_hTimer = hTimer;
		}

	ret:

		return hr;
	}

	VOID DeleteLockTimer(HANDLE hTimer)
	{
		if (NULL != hTimer)
		{
			//	Try to delete the timer, but if it fails just leave it there
			//
			if (!DeleteTimerQueueTimer(NULL,				//default timer queue
									hTimer,				// timer
									INVALID_HANDLE_VALUE))	// blocking call
			{
				DebugTrace ("Failed to delete timer 0x%08lX\n", HRESULT_FROM_WIN32(GetLastError()));
			}
		}
	}

public:

	//	CREATORS
	//
	//	Instance creating/destroying routines provided
	//	by the Singleton template.
	//
	using Singleton<CLockCache>::CreateInstance;
	using Singleton<CLockCache>::DestroyInstance;
	using Singleton<CLockCache>::Instance;

	HRESULT HrInitialize()
	{
		HRESULT hr = S_OK;
		DWORD dwResult;
		UUID guid = {0};

		if (!m_lockCacheById.FInit())
		{
			hr = E_OUTOFMEMORY;
			goto ret;
		}

		if (!m_lockCacheByName.FInit())
		{
			hr = E_OUTOFMEMORY;
			goto ret;
		}

		if (!m_mrwCache.FInitialize())
		{
			hr = E_OUTOFMEMORY;
			goto ret;
		}

		dwResult = UuidCreate(&guid);
		if (RPC_S_OK != dwResult)
		{
			hr = HRESULT_FROM_WIN32(dwResult);
			goto ret;
		}

		wsprintfW(m_rgwchGuid, gc_wszGuidFormat,
				guid.Data1, guid.Data2, guid.Data3,
				guid.Data4[0], guid.Data4[1], guid.Data4[2], guid.Data4[3],
				guid.Data4[4], guid.Data4[5], guid.Data4[6], guid.Data4[7]);

		m_dwThisProcessId = GetCurrentProcessId();

	ret:

		return hr;
	}

	DWORD DwGetThisProcessID()
	{
		return m_dwThisProcessId;
	}

	VOID DeleteLockTimerIfNotUsed()
	{
		HANDLE hTimer = NULL;
	
		{
			//	Protect ourselves for the operation
			//
			CSynchronizedWriteBlock swb(m_mrwCache);

			if (NULL != m_hTimer)
			{
				//	Kill the timer if there are no locks
				//
				if (0 == m_lockCacheById.CItems())
				{
					hTimer = m_hTimer;
					m_hTimer = NULL;
				}
			}
		}

		DeleteLockTimer(hTimer);
	}

	VOID DeleteLockTimerFinal()
	{
		//	We do not null out the member variable as this
		//	will serve as a flag for potential COM threads still
		//	coming in and trying to create new timers. They
		//	will not do that if the handle is not NULL.
		//
		DeleteLockTimer(m_hTimer);
	}

	HRESULT HrGetGUIDString( UINT cchBufferLen,
								WCHAR * pwszGUIDString,
								UINT * pcchGUIDString)
	{
		HRESULT hr = S_OK;
		
		if (gc_cchMaxGuid > cchBufferLen)
		{
			*pcchGUIDString = gc_cchMaxGuid;
			hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
			goto ret;
		}

		memcpy(pwszGUIDString, m_rgwchGuid, sizeof(WCHAR) * gc_cchMaxGuid);
		*pcchGUIDString = gc_cchMaxGuid;

	ret:

		return hr;
	}

	HRESULT HrGetNewLockData(HANDLE hFile,
								    DWORD dwProcessId,
								    DWORD dwSid,
								    BYTE * pbSid,
								    SNewLockData * pnld,
								    UINT cchBufferLen,
								    WCHAR * pwszLockToken,
								    UINT * pcchLockToken)
	{
		HRESULT hr = S_OK;
		LARGE_INTEGER liLockID;
		LPCWSTR pwszLockTokenT;
		UINT cchLockTokenT;
		auto_ptr<CLockData> a_pLockData;	

		a_pLockData = new CLockData();
		if (NULL == a_pLockData.get())
		{
			hr = E_OUTOFMEMORY;
			goto ret;
		}

		liLockID = LiGetNewLockID();

		hr = a_pLockData->HrInitialize(m_rgwchGuid,
								    liLockID,
								    pnld->m_dwAccess,
								    pnld->m_dwLockType,
								    pnld->m_dwLockScope,
								    pnld->m_dwSecondsTimeout,
								    pnld->m_pwszResourceString,
								    pnld->m_pwszOwnerComment,
								    dwSid,
								    pbSid);
		if (FAILED(hr))
		{
			goto ret;
		}

		//	Check if we will have enough space to return lock token header
		//
		cchLockTokenT = a_pLockData->CchLockTokenString(&pwszLockTokenT);
		if (cchBufferLen < cchLockTokenT + 1)
		{
			*pcchLockToken = cchLockTokenT + 1;
			hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
			goto ret;
		}

		hr = a_pLockData->HrLockFile(hFile, dwProcessId);
		if (FAILED(hr))
		{
			goto ret;
		}

		//	Add the lock data to the cache
		//
		{
			LIKey liKey(liLockID);
			CRCWsziLI crcWsziLIKey(a_pLockData->PwszResourceString(),
								     a_pLockData->LiLockID(),
								     TRUE);
			CSynchronizedWriteBlock swb(m_mrwCache);

			if (!m_lockCacheById.FAdd(liKey,
									a_pLockData.get()))
			{
				hr = E_OUTOFMEMORY;
				goto ret;
			}
			
			if (!m_lockCacheByName.FAdd(crcWsziLIKey,
									     a_pLockData.get()))
			{
				//	Remove the previous entry
				//
				m_lockCacheById.Remove(liKey);
			
				hr = E_OUTOFMEMORY;
				goto ret;
			}

			hr = HrLaunchLockTimer();
			if (FAILED(hr))
			{
				//	Remove the previous entries
				//
				m_lockCacheById.Remove(liKey);
				m_lockCacheByName.Remove(crcWsziLIKey);

				goto ret;
			}

			memcpy(pwszLockToken, pwszLockTokenT, sizeof(WCHAR) * cchLockTokenT);
			pwszLockToken[cchLockTokenT] = L'\0';
			*pcchLockToken = cchLockTokenT + 1;
			a_pLockData.relinquish();
		}
   
	ret:

		return hr;
	}

	HRESULT HrGetLockData(LARGE_INTEGER liLockID,
							  DWORD dwSid,
							  BYTE * pbSid,
							  LPCWSTR pwszPath,
							  DWORD dwTimeout,
							  SNewLockData * pnld,
							  SLockHandleData * plhd,
							  UINT cchBufferLen,
							  WCHAR * pwszLockToken,
							  UINT *pcchLockToken)
	{
		HRESULT hr = S_OK;

		auto_co_task_mem<WCHAR> a_pwszResourceString;
		auto_co_task_mem<WCHAR> a_pwszOwnerComment;

		LIKey liKey(liLockID);
		CSynchronizedWriteBlock swb(m_mrwCache);
			
		CLockData * pLockData;

		if (m_lockCacheById.FFetch(liKey,
								&pLockData))
		{
			FILETIME ftNow;
			GetSystemTimeAsFileTime(&ftNow);

			if (pLockData->FIsExpired(ftNow))
			{
				m_lockCacheById.Remove(liKey);
				m_lockCacheByName.Remove(CRCWsziLI(pLockData->PwszResourceString(),
													pLockData->LiLockID(),
													TRUE));
				delete pLockData;

				hr = E_DAV_LOCK_NOT_FOUND;
				goto ret;
			}
			else
			{
				pLockData->SetLastAccess(ftNow);

				if (!pLockData->FIsSameOwner(pbSid))
				{
					hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
					goto ret;
				}
				
				if (!pLockData->FIsSameResource(pwszPath))
				{
					hr = E_DAV_CONFLICTING_PATHS;
					goto ret;
				}

				if (pnld)
				{
					LPCWSTR pwszLockTokenT;
					UINT cchLockTokenT = pLockData->CchLockTokenString(&pwszLockTokenT) + 1;
					UINT cchOwnerOrResource;
					
					if (cchBufferLen < cchLockTokenT)
					{
						*pcchLockToken = cchLockTokenT;
						
						hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
						goto ret;
					}
					memcpy(pwszLockToken, pwszLockTokenT, sizeof(WCHAR) * cchLockTokenT);
					*pcchLockToken = cchLockTokenT;

					cchOwnerOrResource = static_cast<UINT>(wcslen(pLockData->PwszResourceString()));
					a_pwszResourceString = static_cast<LPWSTR>(CoTaskMemAlloc(CbSizeWsz(cchOwnerOrResource)));
					if (NULL == a_pwszResourceString.get())
					{
						hr = E_OUTOFMEMORY;
						goto ret;
					}
					memcpy(a_pwszResourceString.get(), pLockData->PwszResourceString(), sizeof(WCHAR) * (cchOwnerOrResource + 1));

					cchOwnerOrResource = static_cast<UINT>(wcslen(pLockData->PwszOwnerComment()));
					a_pwszOwnerComment = static_cast<LPWSTR>(CoTaskMemAlloc(CbSizeWsz(cchOwnerOrResource)));
					if (NULL == a_pwszOwnerComment.get())
					{
						hr = E_OUTOFMEMORY;
						goto ret;
					}
					memcpy(a_pwszOwnerComment.get(), pLockData->PwszOwnerComment(), sizeof(WCHAR) * (cchOwnerOrResource + 1));

					pLockData->FillSNewLockData(pnld);
					pnld->m_pwszResourceString = a_pwszResourceString.relinquish();
					pnld->m_pwszOwnerComment = a_pwszOwnerComment.relinquish();
				}

				if (plhd)
				{
					pLockData->FillSLockHandleData(plhd);
				}

				//	If there was a timeout passed in for a refresh then set it
				//
				if (dwTimeout)
				{
					pLockData->SetSecondsTimeout(dwTimeout);
				}
			}
		}
		else
		{
			hr = E_DAV_LOCK_NOT_FOUND;
			goto ret;
		}

	ret:

		return hr;
	}

	HRESULT HrDeleteLock(LARGE_INTEGER liLockID)
	{
		CSynchronizedWriteBlock swb(m_mrwCache);

		CLockData * pLockData;

		if (m_lockCacheById.FFetch(LIKey(liLockID),
								&pLockData))
		{
			m_lockCacheById.Remove(LIKey(liLockID));
			m_lockCacheByName.Remove(CRCWsziLI(pLockData->PwszResourceString(),
											      pLockData->LiLockID(),
											      TRUE));
			delete pLockData;
		}

		return S_OK;
	}

	HRESULT HrGetAllLockDataForName(LPCWSTR pwszPath,
										    DWORD dwLockType,
										    DWORD * pdwLocksFound,
										    SNewLockData ** ppNewLockDatas,
										    LPWSTR ** ppwszLockTokens)
	{
		HRESULT hr = S_OK;

		auto_co_task_mem<SNewLockData> a_pNewLockData;
		auto_co_task_mem<LPWSTR> a_ppwszLockToken;
		DWORD dwLocksFound;

		{
			CSynchronizedReadBlock srb(m_mrwCache);
			COpGatherLockData op(pwszPath, dwLockType);
			
			op.Invoke(m_lockCacheByName);

			hr = op.HrLocksFound(&dwLocksFound);
			if (FAILED(hr))
			{
				goto ret;
			}

			a_pNewLockData = static_cast<SNewLockData *>(CoTaskMemAlloc(sizeof(SNewLockData) * dwLocksFound));
			if (NULL == a_pNewLockData.get())
			{
				hr = E_OUTOFMEMORY;
				goto ret;
			}
			
			a_ppwszLockToken = static_cast<LPWSTR *>(CoTaskMemAlloc(sizeof(LPCWSTR) * dwLocksFound));
			if (NULL == a_ppwszLockToken.get())
			{
				hr = E_OUTOFMEMORY;
				goto ret;
			}

			hr = op.HrGetData(a_pNewLockData.get(), a_ppwszLockToken.get());
			if (FAILED(hr))
			{
				goto ret;
			}
		}		

		*pdwLocksFound = dwLocksFound;
		*ppNewLockDatas = a_pNewLockData.relinquish();
		*ppwszLockTokens = a_ppwszLockToken.relinquish();

	ret:

		return hr;
	}
};


//	DAV File Handle Cache
//
class CFileHandleCache : public IFileHandleCache
{
	static BOOL s_fHasBeenStarted;
	static LONG s_cActiveComponents;

	LONG m_cRef;

public:

	static BOOL FNoActiveComponents();

	//	Constructor
	//
	CFileHandleCache();
	virtual ~CFileHandleCache();

	//	IUnknown
	//
	virtual HRESULT __stdcall QueryInterface(REFIID iid,
										    void ** ppvObject);
	virtual ULONG __stdcall AddRef();
	virtual ULONG __stdcall Release();

	//	IFileHandleCache
	//
	virtual HRESULT __stdcall HrRegisterWorkerProcess(DWORD dwProcessId);
	
	virtual HRESULT _stdcall HrGetGUIDString( UINT cchBufferLen,
											WCHAR * pwszGUIDString,
											UINT * pcchGUIDString);

	virtual HRESULT __stdcall HrGetNewLockData(DWORD_PTR hFile,
												DWORD dwProcessId,
												DWORD dwSid,
												BYTE * pbSid,
												SNewLockData * pnld,
												UINT cchBufferLen,
												WCHAR * pwszLockToken,
												UINT * pcchLockToken);

	virtual HRESULT __stdcall HrGetLockData(LARGE_INTEGER liLockID,
										     DWORD dwSid,
										     BYTE * pbSid,
										     LPCWSTR pwszPath,
										     DWORD dwTimeout,
										     SNewLockData *pnld,
			     							     SLockHandleData * plhd,
										     UINT cchBufferLen,
										     WCHAR * pwszLockToken,
										     UINT * pcchLockToken);

	virtual HRESULT __stdcall HrCheckLockID(LARGE_INTEGER liLockID,
										      DWORD dwSid,
										      BYTE * pbSid,
										      LPCWSTR pwszPath);

	virtual HRESULT __stdcall HrDeleteLock(LARGE_INTEGER liLockID);

	virtual HRESULT __stdcall HrGetAllLockDataForName(LPCWSTR pwszPath,
													      DWORD dwLockType,
													      DWORD * pdwLocksFound,
													      SNewLockData ** ppNewLockDatas,
													      LPWSTR ** ppwszLockTokens);
};

BOOL CFileHandleCache::s_fHasBeenStarted = FALSE;
LONG CFileHandleCache::s_cActiveComponents = 0;

CFileHandleCache::FNoActiveComponents()
{
	if (0 == InterlockedCompareExchange(&s_cActiveComponents,
										 0,
										 0))
	{
		return s_fHasBeenStarted;
	}
	else
	{
		return FALSE;
	}
}

CFileHandleCache::CFileHandleCache() : m_cRef(1)
{
	InterlockedIncrement(&s_cActiveComponents);
	s_fHasBeenStarted = TRUE;
}

CFileHandleCache::~CFileHandleCache()
{
	InterlockedDecrement(&s_cActiveComponents);
}

HRESULT
CFileHandleCache::QueryInterface(REFIID iid,
								 void ** ppvObject)
{
	HRESULT hr = S_OK;
	
	if ((IID_IUnknown == iid) || (IID_IFileHandleCache == iid))
	{
		AddRef();
		*ppvObject = static_cast<IFileHandleCache *>(this);
	}
	else
	{
		*ppvObject = NULL;
		hr = E_NOINTERFACE;
	}

	return hr;
}

ULONG
CFileHandleCache::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

ULONG
CFileHandleCache::Release()
{
	if (0 == InterlockedDecrement(&m_cRef))
	{
		delete this;
		return 0;
	}

	return m_cRef;
}

HRESULT
CFileHandleCache::HrRegisterWorkerProcess(DWORD dwProcessId)
{
	HRESULT hr = S_OK;
	auto_handle<HANDLE> a_hWP;
		
	//	Open the worker process handle so that we can synchronize on it
	//
	a_hWP = OpenProcess(SYNCHRONIZE,
					      FALSE,
					      dwProcessId);
	if (NULL == a_hWP.get())
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		DebugTrace ("Failed to open worker process handle 0x%08lX\n", hr);
		goto ret;
	}

	//	Add the handle to the handle pool, so that we could listen on it
	//
	hr = CHandlePool::Instance().HrAddHandle(a_hWP.get());
	if (FAILED(hr))
	{
		DebugTrace ("Failed to add worker process handle 0x%08lX\n", hr);
		goto ret;
	}
	a_hWP.relinquish();

ret:
	
	return hr;
}

HRESULT
CFileHandleCache::HrGetGUIDString( UINT cchBufferLen,
									WCHAR * pwszGUIDString,
									UINT * pcchGUIDString)
{
	return CLockCache::Instance().HrGetGUIDString(cchBufferLen,
											   pwszGUIDString,
											   pcchGUIDString);
}

HRESULT
CFileHandleCache::HrGetNewLockData(DWORD_PTR hFile,
									    DWORD dwProcessId,
									    DWORD dwSid,
									    BYTE * pbSid,
									    SNewLockData * pnld,
									    UINT cchBufferLen,
									    WCHAR * pwszLockToken,
									    UINT * pcchLockToken)
{
	return CLockCache::Instance().HrGetNewLockData(reinterpret_cast<HANDLE>(hFile),
											      dwProcessId,
											      dwSid,
											      pbSid,
											      pnld,
											      cchBufferLen,
											      pwszLockToken,
											      pcchLockToken);
}

HRESULT
CFileHandleCache::HrGetLockData(LARGE_INTEGER liLockID,
								   DWORD dwSid,
								   BYTE * pbSid,
								   LPCWSTR pwszPath,
								   DWORD dwTimeout,
								   SNewLockData *pnld,
	   							   SLockHandleData * plhd,
								   UINT cchBufferLen,
								   WCHAR * pwszLockToken,
								   UINT * pcchLockToken)
{
	return CLockCache::Instance().HrGetLockData(liLockID,
											dwSid,
											pbSid,
											pwszPath,
											dwTimeout,
											pnld,
											plhd,
											cchBufferLen,
											pwszLockToken,
											pcchLockToken);
}

HRESULT
CFileHandleCache::HrCheckLockID(LARGE_INTEGER liLockID,
								    DWORD dwSid,
								    BYTE * pbSid,
								    LPCWSTR pwszPath)
{
	return CLockCache::Instance().HrGetLockData(liLockID,
											dwSid,
											pbSid,
											pwszPath,
											0,
											NULL,
											NULL,
											0,
											NULL,
											NULL);
}

HRESULT
CFileHandleCache::HrDeleteLock(LARGE_INTEGER liLockID)
{
	return CLockCache::Instance().HrDeleteLock(liLockID);
}

HRESULT
CFileHandleCache::HrGetAllLockDataForName(LPCWSTR pwszPath,
											    DWORD dwLockType,
											    DWORD * pdwLocksFound,
											    SNewLockData ** ppNewLockDatas,
											    LPWSTR ** ppwszLockTokens)
{
	return CLockCache::Instance().HrGetAllLockDataForName(pwszPath,
													  dwLockType,
													  pdwLocksFound,
													  ppNewLockDatas,
													  ppwszLockTokens);
}


//	DAV File Handle Cache class factory
//
class CFileHandleCacheClassFactory : public IClassFactory
{
	// Count of locks
	//
	static LONG s_cServerLocks;

	static IUnknown * s_pIClassFactory;
	static DWORD s_dwRegister;

	LONG m_cRef;

public:

	static HRESULT HrStartFactory();
	static HRESULT HrStopFactory();
	static BOOL FServerNotLocked();

	//	Constructor
	//
	CFileHandleCacheClassFactory();

	// IUnknown
	//
	virtual HRESULT __stdcall QueryInterface(REFIID iid,
										    void** ppvObject) ;
	virtual ULONG   __stdcall AddRef() ;
	virtual ULONG   __stdcall Release() ;
	
	// IClassFactory
	//
	virtual HRESULT __stdcall CreateInstance(IUnknown* pUnkOuter,
										    REFIID iid,
										    void ** ppvObject);
	virtual HRESULT __stdcall LockServer(BOOL fLock);
};

LONG CFileHandleCacheClassFactory::s_cServerLocks = 0;
IUnknown * CFileHandleCacheClassFactory::s_pIClassFactory = NULL;
DWORD CFileHandleCacheClassFactory::s_dwRegister = 0;

HRESULT
CFileHandleCacheClassFactory::HrStartFactory()
{
	HRESULT hr = S_OK;
	auto_ref_ptr<IUnknown> a_pIClassFactory;
	DWORD dwRegister;

	a_pIClassFactory.take_ownership(new CFileHandleCacheClassFactory());
	if (NULL == a_pIClassFactory.get())
	{
		hr = E_OUTOFMEMORY;
		goto ret;
	}

	hr = CoRegisterClassObject(CLSID_FileHandleCache,
						      a_pIClassFactory.get(),
						      CLSCTX_LOCAL_SERVER,
						      REGCLS_MULTIPLEUSE,
						      &dwRegister);
	if (FAILED(hr))
	{
		goto ret;
	}

	s_pIClassFactory = a_pIClassFactory.relinquish();
	s_dwRegister = dwRegister;

ret:

	return hr;
}

HRESULT
CFileHandleCacheClassFactory::HrStopFactory()
{
	HRESULT hr = S_OK;
	IUnknown * pIClassFactory;
	DWORD dwRegister;
	
	Assert(s_pIClassFactory);
	Assert(s_dwRegister);

	pIClassFactory = s_pIClassFactory;
	dwRegister = s_dwRegister;

	hr = CoRevokeClassObject(dwRegister);
	if (FAILED(hr))
	{
		goto ret;
	}

	pIClassFactory->Release();

	s_pIClassFactory = NULL;
	s_dwRegister = 0;

ret:

	return hr;
}

BOOL CFileHandleCacheClassFactory::FServerNotLocked()
{
	return (0 == InterlockedCompareExchange(&s_cServerLocks,
											 0,
											 0));
}

CFileHandleCacheClassFactory::CFileHandleCacheClassFactory() : m_cRef(1)
{
}

HRESULT
CFileHandleCacheClassFactory::QueryInterface(REFIID iid,
										      void** ppvObject)
{
	HRESULT hr = S_OK;
	
	if ((IID_IUnknown == iid) || (IID_IClassFactory == iid))
	{
		AddRef();
		*ppvObject = static_cast<IClassFactory *>(this);
	}
	else
	{
		*ppvObject = NULL;
		hr = E_NOINTERFACE;
	}
	
	return hr;
}

ULONG
CFileHandleCacheClassFactory::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

ULONG
CFileHandleCacheClassFactory::Release()
{
	ULONG cRef = InterlockedDecrement(&m_cRef);
	if (0 == cRef)
	{
		delete this;
		return 0;
	}

	return cRef;
}

HRESULT
CFileHandleCacheClassFactory::CreateInstance(IUnknown* pUnkOuter,
											REFIID iid,
											void ** ppvObject)
{
	HRESULT hr = S_OK;
	
	auto_ref_ptr<IUnknown> a_pIFileHandleCache;
		
	if (NULL != pUnkOuter)
	{
		//	Don't allow aggregation. No need for it.
		//
		hr = CLASS_E_NOAGGREGATION;
		goto ret;
	}

	a_pIFileHandleCache.take_ownership(new CFileHandleCache());
	if (NULL == a_pIFileHandleCache.get())
	{
		hr = E_OUTOFMEMORY;
		goto ret;
	}

	hr = a_pIFileHandleCache->QueryInterface(iid, ppvObject);
	if (FAILED(hr))
	{
		goto ret;
	}

ret:
	
	return hr;
}

HRESULT
CFileHandleCacheClassFactory::LockServer(BOOL fLock)
{
	if (fLock)
	{
		InterlockedIncrement(&s_cServerLocks);
	}
	else
	{
		InterlockedDecrement(&s_cServerLocks);
	}

	return S_OK;
}

BOOL FCanUnloadServer()
{
	return (CFileHandleCache::FNoActiveComponents() && CFileHandleCacheClassFactory::FServerNotLocked());
}

//	CHandlePool class
//
DWORD
CHandlePool::DwWaitOnWPs (PVOID pvThreadData)
{
	DWORD dwRet;

	CHandleArrayForHandlePool * pHandleArrayForHandlePool;
	pHandleArrayForHandlePool = Instance().m_listHandleArrayForHandlePool.GetListHead();
	Assert(NULL != pHandleArrayForHandlePool);
			
	while (!FCanUnloadServer())
	{
		dwRet = WaitForMultipleObjects (pHandleArrayForHandlePool->UiGetHandleCount(),	// nCount
								     pHandleArrayForHandlePool->PhGetHandles(), 		// lpHandles,
								     FALSE,										// fWaitAll,
								     WAIT_POLL_PERIOD);							// wait for specified period
		switch (dwRet)
		{
			case WAIT_TIMEOUT:
					
				pHandleArrayForHandlePool = pHandleArrayForHandlePool->GetNextListElementInCircle();
				break;
					
			case WAIT_OBJECT_0 + CHandleArrayForHandlePool::ih_external_update:

				//	Allow the updates to execute and then get the list head 
				//	as the array you had may be already gone.
				//
				Instance().AllowUpdatesToExecute();
				pHandleArrayForHandlePool = Instance().m_listHandleArrayForHandlePool.GetListHead();
				break;

			case WAIT_OBJECT_0 + CHandleArrayForHandlePool::ih_delete_timer:
				CLockCache::Instance().DeleteLockTimerIfNotUsed();
				break;

			default:

				Assert(CHandleArrayForHandlePool::ih_wp <= pHandleArrayForHandlePool->UiGetHandleCount());
					
				if ((WAIT_OBJECT_0 + CHandleArrayForHandlePool::ih_wp <= dwRet) &&
				     (WAIT_OBJECT_0 + pHandleArrayForHandlePool->UiGetHandleCount() - 1 >= dwRet))
				{
					//	Remove the handle and then get the list head 
					//	as the array you had may be already gone.
					//
					Instance().RemoveHandleInternal(pHandleArrayForHandlePool, dwRet - WAIT_OBJECT_0);
					pHandleArrayForHandlePool = Instance().m_listHandleArrayForHandlePool.GetListHead();
				}					
				break;
		}
	};


	//	This call will loose all updates to be executed so incoming COM calls would
	//	not block waiting on permission to execute the update
	//
	Instance().AllowShutdownToExecute();

	//	This call will block untill all expiry callbacks have completed
	//
	CLockCache::Instance().DeleteLockTimerFinal();

	//	Post the quit message. We do this in a loop to catch
	//	the case if this code has been reached faster than
	//	the message queue was created on the original thread
	//
	while (0 == PostThreadMessage(s_dwMainTID,
								WM_QUIT,
								0,
								0))
	{
		Sleep(WAIT_POLL_PERIOD);
	}

	return S_OK;
}

// ===============================================================
// File lock cache server registration routines
// ===============================================================

HRESULT HrRegisterServer(LPCWSTR pwszModulePath,	// EXE module path
						    UINT cchModulePath,			// Module path length
						    LPCWSTR pwszModuleName,		// EXE module name
						    UINT cchModuleName,			// Module name length
						    const CLSID& clsid)				// Class ID
{
	HRESULT hr = S_OK;
	DWORD dwResult;

	SECURITY_DESCRIPTOR sdAbsolute;
	CStackBuffer<BYTE> pSidOwnerAndGroup;
	CStackBuffer<BYTE> pSidIIS_WPG;
	CStackBuffer<BYTE> pSidLocalService;
	CStackBuffer<BYTE> pSidNetworkService;
	CStackBuffer<WCHAR> pwszDomainName;
	DWORD cbSidOwnerAndGroup = 0;
	DWORD cbSidIIS_WPG = 0;
	DWORD cbSidLocalService = 0;
	DWORD cbSidNetworkService = 0;
	DWORD cchDomainName = 0;
	SID_NAME_USE snu;
	CStackBuffer<BYTE> pACL;
	DWORD cbACL = 0;
	CStackBuffer<BYTE> pSelfRelativeSD;
	DWORD cbSelfRelativeSD = 0;

	CStackBuffer<WCHAR, (MAX_PATH + 1) * sizeof(WCHAR)> pwszKey;
	CRegKey regKeyCLSID;
	CRegKey regKeyCLSIDLocalServer;
	CRegKey regKeyAppIdCLSID;
	CRegKey	regKeyAppIdModule;

	auto_co_task_mem<WCHAR> pwszCLSID;
	UINT cchCLSID;

	//	First of all try to build up security descriptor for launch permissions
	//

	//	Initialize security descriptor
	//
	if (FALSE == InitializeSecurityDescriptor(&sdAbsolute,
									    SECURITY_DESCRIPTOR_REVISION))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ret;
	}

	//	Get the SID for the Administrators group
	//
	//	Get the size of memory needed for the sid.
	//
	if (FALSE == CreateWellKnownSid(WinBuiltinAdministratorsSid, 
								  NULL, 
								  NULL, 
								  &cbSidOwnerAndGroup))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) != hr)
		{
			goto ret;
		}
		else
		{
			hr = S_OK;
		}
    }

	Assert (0 < cbSidOwnerAndGroup);
	if (!pSidOwnerAndGroup.resize(cbSidOwnerAndGroup))
	{
		hr = E_OUTOFMEMORY;
		goto ret;		
	}

	// Ok now we can get the SID
	//
	if (FALSE == CreateWellKnownSid(WinBuiltinAdministratorsSid, 
								  NULL, 
								  pSidOwnerAndGroup.get(), 
								  &cbSidOwnerAndGroup))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ret;
	}

	//	Set security descriptor owner and group
	//
	if (FALSE == SetSecurityDescriptorOwner(&sdAbsolute,
									     pSidOwnerAndGroup.get(),
									     FALSE))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ret;
	}

	if (FALSE == SetSecurityDescriptorGroup(&sdAbsolute,
									     pSidOwnerAndGroup.get(),
									     FALSE))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ret;
	}

	//	Lookup IIS worker process group SID
	//
	if (FALSE == LookupAccountNameW(NULL,
								    gc_wszIIS_WPG,
								    NULL,
								    &cbSidIIS_WPG,
								    NULL,
								    &cchDomainName,
								    &snu))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) != hr)
		{
			goto ret;
		}
		else
		{
			hr = S_OK;
		}
	}

	Assert (0 < cbSidIIS_WPG);
	if (!pSidIIS_WPG.resize(cbSidIIS_WPG))
	{
		hr = E_OUTOFMEMORY;
		goto ret;		
	}

	if (!pwszDomainName.resize(cchDomainName * sizeof(WCHAR)))
	{
		hr = E_OUTOFMEMORY;
		goto ret;		
	}

	if (FALSE == LookupAccountNameW(NULL,
								    gc_wszIIS_WPG,
								    pSidIIS_WPG.get(),
								    &cbSidIIS_WPG,
								    pwszDomainName.get(),
								    &cchDomainName,
								    &snu))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ret;
	}

	if (SidTypeAlias != snu)
	{
		hr = E_FAIL;
		goto ret;
	}

	//	Get the SID for the local service account
	//
	// Get the size of memory needed for the sid.
	//
	if (FALSE == CreateWellKnownSid(WinLocalServiceSid, 
								  NULL, 
								  NULL, 
								  &cbSidLocalService))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) != hr)
		{
			goto ret;
		}
		else
		{
			hr = S_OK;
		}
    }

	Assert (0 < cbSidLocalService);
	if (!pSidLocalService.resize(cbSidLocalService))
	{
		hr = E_OUTOFMEMORY;
		goto ret;		
	}

	// Ok now we can get the SID
	//
	if (FALSE == CreateWellKnownSid(WinLocalServiceSid, 
								  NULL, 
								  pSidLocalService.get(), 
								  &cbSidLocalService))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ret;
	}

	//	Get the SID for the network service account
	//
	//	Get the size of memory needed for the sid.
	//
	if (FALSE == CreateWellKnownSid(WinNetworkServiceSid, 
								  NULL, 
								  NULL, 
								  &cbSidNetworkService))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) != hr)
		{
			goto ret;
		}
		else
		{
			hr = S_OK;
		}
	}

	Assert (0 < cbSidNetworkService);
	if (!pSidNetworkService.resize(cbSidNetworkService))
	{
		hr = E_OUTOFMEMORY;
		goto ret;		
	}

	// Ok now we can get the SID
	//
	if (FALSE == CreateWellKnownSid(WinNetworkServiceSid, 
								  NULL, 
								  pSidNetworkService.get(), 
								  &cbSidNetworkService))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ret;
	}
	
	//	Set up the launch permissions ACL
	//	We will be adding 4 aces
	//	1. IIS_WPG
	//	2. Administrators
	//	3. Local Service
	//	4. Network Service
	//
	cbACL = sizeof(ACL) + 
			(4 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof (DWORD))) +
			GetLengthSid(pSidIIS_WPG.get()) +
			GetLengthSid(pSidOwnerAndGroup.get()) +
			GetLengthSid(pSidLocalService.get()) +
			GetLengthSid(pSidNetworkService.get());
	if (!pACL.resize(cbACL))
	{
		hr = E_OUTOFMEMORY;
		goto ret;
	}

	if (FALSE == InitializeAcl(reinterpret_cast<PACL>(pACL.get()),
						   cbACL,
						   ACL_REVISION))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ret;
	}

	if (FALSE == AddAccessAllowedAce(reinterpret_cast<PACL>(pACL.get()),
								    ACL_REVISION,
								    COM_RIGHTS_EXECUTE,
								    pSidIIS_WPG.get()))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ret;
	}

		if (FALSE == AddAccessAllowedAce(reinterpret_cast<PACL>(pACL.get()),
								    ACL_REVISION,
								    COM_RIGHTS_EXECUTE,
								    pSidOwnerAndGroup.get()))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ret;
	}

	if (FALSE == AddAccessAllowedAce(reinterpret_cast<PACL>(pACL.get()),
								    ACL_REVISION,
								    COM_RIGHTS_EXECUTE,
								    pSidLocalService.get()))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ret;
	}

	if (FALSE == AddAccessAllowedAce(reinterpret_cast<PACL>(pACL.get()),
								    ACL_REVISION,
								    COM_RIGHTS_EXECUTE,
								    pSidNetworkService.get()))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ret;
	}
	if (FALSE == SetSecurityDescriptorDacl(&sdAbsolute,
									   TRUE,
									   reinterpret_cast<PACL>(pACL.get()),
									   FALSE))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ret;
	}

	//	Make self relative security descriptor out of absolute for storing in the registry
	//
	if (FALSE == MakeSelfRelativeSD(&sdAbsolute,
								 NULL,
								 &cbSelfRelativeSD))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) != hr)
		{
			goto ret;
		}
		else
		{
			hr = S_OK;
		}
	}

	if (!pSelfRelativeSD.resize(cbSelfRelativeSD))
	{
		hr = E_OUTOFMEMORY;
		goto ret;
	}

	if (FALSE == MakeSelfRelativeSD(&sdAbsolute,
								pSelfRelativeSD.get(),
								&cbSelfRelativeSD))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ret;
	}

	//	Procceed with setting up registry keys
	//
	hr = StringFromCLSID(CLSID_FileHandleCache, &pwszCLSID);
	if (FAILED(hr))
	{
		goto ret;
	}
	cchCLSID = static_cast<UINT>(wcslen(pwszCLSID.get()));

	if (!pwszKey.resize((gc_cch_CLSIDWW + cchCLSID +  1) * sizeof(WCHAR)))
	{
		hr = E_OUTOFMEMORY;
		goto ret;
	}
	memcpy(pwszKey.get(), gc_wsz_CLSIDWW, gc_cch_CLSIDWW * sizeof(WCHAR));
	memcpy(pwszKey.get() + gc_cch_CLSIDWW, pwszCLSID.get(), cchCLSID * sizeof(WCHAR));
	pwszKey[gc_cch_CLSIDWW + cchCLSID] = L'\0';
		
	dwResult = regKeyCLSID.DwCreate(HKEY_CLASSES_ROOT, pwszKey.get());
	if (ERROR_SUCCESS != dwResult)
	{
		hr = HRESULT_FROM_WIN32(dwResult);
		goto ret;
	}

	dwResult = regKeyCLSID.DwSetValue(NULL,
									REG_SZ,
									gc_wsz_WebDAVFileHandleCache,
									(gc_cch_WebDAVFileHandleCache + 1)  * sizeof(WCHAR));
	if (ERROR_SUCCESS != dwResult)
	{
		hr = HRESULT_FROM_WIN32(dwResult);
		goto ret;
	}

	dwResult = regKeyCLSID.DwSetValue(gc_wsz_AppID,
									REG_SZ,
									pwszCLSID.get(),
									(cchCLSID + 1)  * sizeof(WCHAR));
	if (ERROR_SUCCESS != dwResult)
	{
		hr = HRESULT_FROM_WIN32(dwResult);
		goto ret;
	}

	if (!pwszKey.resize((gc_cch_CLSIDWW + cchCLSID + gc_cch_WWLocalServer32 + 1) * sizeof(WCHAR)))
	{
		hr = E_OUTOFMEMORY;
		goto ret;
	}
	memcpy(pwszKey.get(), gc_wsz_CLSIDWW, gc_cch_CLSIDWW * sizeof(WCHAR));
	memcpy(pwszKey.get() + gc_cch_CLSIDWW, pwszCLSID.get(), cchCLSID * sizeof(WCHAR));
	memcpy(pwszKey.get() + gc_cch_CLSIDWW + cchCLSID, gc_wsz_WWLocalServer32, gc_cch_WWLocalServer32 * sizeof(WCHAR));
	pwszKey[gc_cch_CLSIDWW + cchCLSID + gc_cch_WWLocalServer32] = L'\0';

	dwResult = regKeyCLSIDLocalServer.DwCreate(HKEY_CLASSES_ROOT, pwszKey.get());
	if (ERROR_SUCCESS != dwResult)
	{
		hr = HRESULT_FROM_WIN32(dwResult);
		goto ret;
	}

	dwResult = regKeyCLSIDLocalServer.DwSetValue(NULL,
											   REG_SZ,
											   pwszModulePath,
											   (cchModulePath + 1)  * sizeof(WCHAR));
	if (ERROR_SUCCESS != dwResult)
	{
		hr = HRESULT_FROM_WIN32(dwResult);
		goto ret;
	}
	
	if (!pwszKey.resize((gc_cch_AppIDWW + cchCLSID +  1) * sizeof(WCHAR)))
	{
		hr = E_OUTOFMEMORY;
		goto ret;
	}	
	memcpy(pwszKey.get(), gc_wsz_AppIDWW, gc_cch_AppIDWW * sizeof(WCHAR));
	memcpy(pwszKey.get() + gc_cch_AppIDWW, pwszCLSID.get(), cchCLSID * sizeof(WCHAR));
	pwszKey[gc_cch_AppIDWW + cchCLSID] = L'\0';

	dwResult = regKeyAppIdCLSID.DwCreate(HKEY_CLASSES_ROOT, pwszKey.get());
	if (ERROR_SUCCESS != dwResult)
	{
		hr = HRESULT_FROM_WIN32(dwResult);
		goto ret;
	}

	dwResult = regKeyAppIdCLSID.DwSetValue(NULL,
										 REG_SZ,
										 gc_wsz_WebDAVFileHandleCache,
										 (gc_cch_WebDAVFileHandleCache + 1)  * sizeof(WCHAR));
	if (ERROR_SUCCESS != dwResult)
	{
		hr = HRESULT_FROM_WIN32(dwResult);
		goto ret;
	}

	dwResult = regKeyAppIdCLSID.DwSetValue(gc_wszLaunchPermission,
										 REG_BINARY,
										 pSelfRelativeSD.get(),
										 cbSelfRelativeSD);
	if (ERROR_SUCCESS != dwResult)
	{
		hr = HRESULT_FROM_WIN32(dwResult);
		goto ret;
	}
	
	if (!pwszKey.resize((gc_cch_AppIDWW + cchModuleName +  1) * sizeof(WCHAR)))
	{
		hr = E_OUTOFMEMORY;
		goto ret;
	}	
	memcpy(pwszKey.get(), gc_wsz_AppIDWW, gc_cch_AppIDWW * sizeof(WCHAR));
	memcpy(pwszKey.get() + gc_cch_AppIDWW, pwszModuleName, cchModuleName * sizeof(WCHAR));
	pwszKey[gc_cch_AppIDWW + cchModuleName] = L'\0';

	dwResult = regKeyAppIdModule.DwCreate(HKEY_CLASSES_ROOT, pwszKey.get());
	if (ERROR_SUCCESS != dwResult)
	{
		hr = HRESULT_FROM_WIN32(dwResult);
		goto ret;
	}

	dwResult = regKeyAppIdModule.DwSetValue(gc_wsz_AppID,
										  REG_SZ,
										  pwszCLSID.get(),
										  (cchCLSID + 1)  * sizeof(WCHAR));
	if (ERROR_SUCCESS != dwResult)
	{
		hr = HRESULT_FROM_WIN32(dwResult);
		goto ret;
	}

ret:

	return hr;
}

HRESULT HrUnregisterServer(LPCWSTR pwszModuleName,	// EXE module name
							 UINT cchModuleName,		// Module name length
							 const CLSID& clsid)			// Class ID)
{
	HRESULT hr = S_OK;
	DWORD dwResult;
	
	CStackBuffer<WCHAR, (MAX_PATH + 1) * sizeof(WCHAR)> pwszKey;

	auto_co_task_mem<WCHAR> pwszCLSID;
	UINT cchCLSID;

	hr = StringFromCLSID(CLSID_FileHandleCache, &pwszCLSID);
	if (FAILED(hr))
	{
		goto ret;
	}
	cchCLSID = static_cast<UINT>(wcslen(pwszCLSID.get()));

	if (!pwszKey.resize((gc_cch_CLSIDWW + cchCLSID + gc_cch_WWLocalServer32 + 1) * sizeof(WCHAR)))
	{
		hr = E_OUTOFMEMORY;
		goto ret;
	}
	memcpy(pwszKey.get(), gc_wsz_CLSIDWW, gc_cch_CLSIDWW * sizeof(WCHAR));
	memcpy(pwszKey.get() + gc_cch_CLSIDWW, pwszCLSID.get(), cchCLSID * sizeof(WCHAR));
	memcpy(pwszKey.get() + gc_cch_CLSIDWW + cchCLSID, gc_wsz_WWLocalServer32, gc_cch_WWLocalServer32 * sizeof(WCHAR));
	pwszKey[gc_cch_CLSIDWW + cchCLSID + gc_cch_WWLocalServer32] = L'\0';

	dwResult = RegDeleteKeyW(HKEY_CLASSES_ROOT,
							pwszKey.get());
	if (ERROR_SUCCESS != dwResult && ERROR_FILE_NOT_FOUND != dwResult)
	{
		hr = HRESULT_FROM_WIN32(dwResult);
		goto ret;		
	}

	pwszKey[gc_cch_CLSIDWW + cchCLSID] = L'\0';
	dwResult = RegDeleteKeyW(HKEY_CLASSES_ROOT,
							pwszKey.get());
	if (ERROR_SUCCESS != dwResult && ERROR_FILE_NOT_FOUND != dwResult)
	{
		hr = HRESULT_FROM_WIN32(dwResult);
		goto ret;		
	}

	if (!pwszKey.resize((gc_cch_AppIDWW + cchCLSID +  1) * sizeof(WCHAR)))
	{
		hr = E_OUTOFMEMORY;
		goto ret;
	}	
	memcpy(pwszKey.get(), gc_wsz_AppIDWW, gc_cch_AppIDWW * sizeof(WCHAR));
	memcpy(pwszKey.get() + gc_cch_AppIDWW, pwszCLSID.get(), cchCLSID * sizeof(WCHAR));
	pwszKey[gc_cch_AppIDWW + cchCLSID] = L'\0';

	dwResult = RegDeleteKeyW(HKEY_CLASSES_ROOT,
							pwszKey.get());
	if (ERROR_SUCCESS != dwResult && ERROR_FILE_NOT_FOUND != dwResult)
	{
		hr = HRESULT_FROM_WIN32(dwResult);
		goto ret;		
	}

	if (!pwszKey.resize((gc_cch_AppIDWW + cchModuleName +  1) * sizeof(WCHAR)))
	{
		hr = E_OUTOFMEMORY;
		goto ret;
	}	
	memcpy(pwszKey.get(), gc_wsz_AppIDWW, gc_cch_AppIDWW * sizeof(WCHAR));
	memcpy(pwszKey.get() + gc_cch_AppIDWW, pwszModuleName, cchModuleName * sizeof(WCHAR));
	pwszKey[gc_cch_AppIDWW + cchModuleName] = L'\0';

	dwResult = RegDeleteKeyW(HKEY_CLASSES_ROOT,
							pwszKey.get());
	if (ERROR_SUCCESS != dwResult && ERROR_FILE_NOT_FOUND != dwResult)
	{
		hr = HRESULT_FROM_WIN32(dwResult);
		goto ret;
	}

ret:

	return hr;
}

HRESULT HrInitCOMSecurity ()
{
	HRESULT hr = S_OK;

	SECURITY_DESCRIPTOR sdAbsolute;
	CStackBuffer<BYTE> pSidOwnerAndGroup;
	CStackBuffer<BYTE> pSidIIS_WPG;
	CStackBuffer<BYTE> pSidLocalService;
	CStackBuffer<BYTE> pSidNetworkService;
	CStackBuffer<WCHAR> pwszDomainName;
	DWORD cbSidOwnerAndGroup = 0;
	DWORD cbSidIIS_WPG = 0;
	DWORD cbSidLocalService = 0;
	DWORD cbSidNetworkService = 0;
	DWORD cchDomainName = 0;
	SID_NAME_USE snu;
	CStackBuffer<BYTE> pACL;
	DWORD cbACL = 0;

	//	First of all try to build up security descriptor for access permissions
	//

	//	Initialize security descriptor
	//
	if (FALSE == InitializeSecurityDescriptor(&sdAbsolute,
									    SECURITY_DESCRIPTOR_REVISION))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ret;
	}

	//	Lookup owner and primary group SID
	//
	// Get the size of memory needed for the sid.
	//
	if (FALSE == CreateWellKnownSid(WinBuiltinAdministratorsSid, 
								  NULL, 
								  NULL, 
								  &cbSidOwnerAndGroup))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) != hr)
		{
			goto ret;
		}
		else
		{
			hr = S_OK;
		}
	}

	Assert (0 < cbSidOwnerAndGroup);
	if (!pSidOwnerAndGroup.resize(cbSidOwnerAndGroup))
	{
		hr = E_OUTOFMEMORY;
		goto ret;		
	}

	// Ok now we can get the SID
	//
	if (FALSE == CreateWellKnownSid(WinBuiltinAdministratorsSid, 
								  NULL, 
								  pSidOwnerAndGroup.get(), 
								  &cbSidOwnerAndGroup))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ret;
	}

	//	Set security descriptor owner and group
	//
	if (FALSE == SetSecurityDescriptorOwner(&sdAbsolute,
									      pSidOwnerAndGroup.get(),
									     FALSE))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ret;
	}

	if (FALSE == SetSecurityDescriptorGroup(&sdAbsolute,
									     pSidOwnerAndGroup.get(),
									     FALSE))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ret;
	}

	//	Lookup IIS worker process group SID
	//
	if (FALSE == LookupAccountNameW(NULL,
								    gc_wszIIS_WPG,
								    NULL,
								    &cbSidIIS_WPG,
								    NULL,
								    &cchDomainName,
								    &snu))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) != hr)
		{
			goto ret;
		}
		else
		{
			hr = S_OK;
		}
	}

	Assert (0 < cbSidIIS_WPG);
	if (!pSidIIS_WPG.resize(cbSidIIS_WPG))
	{
		hr = E_OUTOFMEMORY;
		goto ret;		
	}

	if (!pwszDomainName.resize(cchDomainName * sizeof(WCHAR)))
	{
		hr = E_OUTOFMEMORY;
		goto ret;		
	}

	if (FALSE == LookupAccountNameW(NULL,
								    gc_wszIIS_WPG,
								    pSidIIS_WPG.get(),
								    &cbSidIIS_WPG,
								    pwszDomainName.get(),
								    &cchDomainName,
								    &snu))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ret;
	}

	if (SidTypeAlias != snu)
	{
		hr = E_FAIL;
		goto ret;
	}

	//	Get the SID for the local service account
	//
	// Get the size of memory needed for the sid.
	//
	if (FALSE == CreateWellKnownSid(WinLocalServiceSid, 
								  NULL, 
								  NULL, 
								  &cbSidLocalService))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) != hr)
		{
			goto ret;
		}
		else
		{
			hr = S_OK;
		}
	}

	Assert (0 < cbSidLocalService);
	if (!pSidLocalService.resize(cbSidLocalService))
	{
		hr = E_OUTOFMEMORY;
		goto ret;		
	}

	//	Ok now we can get the SID
	//
	if (FALSE == CreateWellKnownSid(WinLocalServiceSid, 
								  NULL, 
								  pSidLocalService.get(), 
								  &cbSidLocalService))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ret;
	}

	//	Get the SID for the network service account
	//
	//	Get the size of memory needed for the sid.
	//
	if (FALSE == CreateWellKnownSid(WinNetworkServiceSid, 
								  NULL, 
								  NULL, 
								  &cbSidNetworkService))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) != hr)
		{
			goto ret;
		}
		else
		{
			hr = S_OK;
		}
	}

	Assert (0 < cbSidNetworkService);
	if (!pSidNetworkService.resize(cbSidNetworkService))
	{
		hr = E_OUTOFMEMORY;
		goto ret;		
	}

	//	Ok now we can get the SID
	//
	if (FALSE == CreateWellKnownSid(WinNetworkServiceSid, 
								  NULL, 
								  pSidNetworkService.get(), 
								  &cbSidNetworkService))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ret;
	}
	
	//	Set up the launch permissions ACL
	//	We will be adding 4 aces
	//	1. IIS_WPG
	//	2. Administrators
	//	3. Local Service
	//	4. Network Service
	//
	cbACL = sizeof(ACL) + 
			(4 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof (DWORD))) +
			GetLengthSid(pSidIIS_WPG.get()) +
			GetLengthSid(pSidOwnerAndGroup.get()) +
			GetLengthSid(pSidLocalService.get()) +
			GetLengthSid(pSidNetworkService.get());
	if (!pACL.resize(cbACL))
	{
		hr = E_OUTOFMEMORY;
		goto ret;
	}

	if (FALSE == InitializeAcl(reinterpret_cast<PACL>(pACL.get()),
						   cbACL,
						   ACL_REVISION))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ret;
	}

	if (FALSE == AddAccessAllowedAce(reinterpret_cast<PACL>(pACL.get()),
								    ACL_REVISION,
								    COM_RIGHTS_EXECUTE,
								    pSidIIS_WPG.get()))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ret;
	}

	if (FALSE == AddAccessAllowedAce(reinterpret_cast<PACL>(pACL.get()),
								    ACL_REVISION,
								    COM_RIGHTS_EXECUTE,
								    pSidOwnerAndGroup.get()))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ret;
	}

	if (FALSE == AddAccessAllowedAce(reinterpret_cast<PACL>(pACL.get()),
								    ACL_REVISION,
								    COM_RIGHTS_EXECUTE,
								    pSidLocalService.get()))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ret;
	}

	if (FALSE == AddAccessAllowedAce(reinterpret_cast<PACL>(pACL.get()),
								    ACL_REVISION,
								    COM_RIGHTS_EXECUTE,
								    pSidNetworkService.get()))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ret;
	}
	
	if (FALSE == SetSecurityDescriptorDacl(&sdAbsolute,
									   TRUE,
									   reinterpret_cast<PACL>(pACL.get()),
									   FALSE))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ret;
	}

	hr = CoInitializeSecurity(&sdAbsolute,
						 -1,
						 NULL,
						 NULL,
						 RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
						 RPC_C_IMP_LEVEL_IDENTIFY,
						 NULL,
						 EOAC_DYNAMIC_CLOAKING | EOAC_DISABLE_AAA | EOAC_NO_CUSTOM_MARSHAL,
						 NULL);
	if (FAILED(hr))
	{
		goto ret;
	}
	
ret:

	return hr;
}

HRESULT HrExecuteServer()
{
	HRESULT hr = S_OK;
	HANDLE hThread;
	MSG msg;

	//	Save of the current thread ID so that the thread we will create
	//	would know who post pessages to
	//
	s_dwMainTID = GetCurrentThreadId();
		
	//	Now create thread that waits on events and WP handles
	//
	hThread = CreateThread (NULL,						// lpThreadAttributes
						   0,							// dwStackSize, ignored
						   CHandlePool::DwWaitOnWPs,	// lpStartAddress
						   NULL,						// lpParam
						   0,							// Start immediately
						   NULL);						// lpThreadId
	if (NULL == hThread)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		DebugTrace ("CreateThread failed 0x%08lX\n", hr);
		goto ret;
	}
	
	//	We need to close the handle to avoid having the thread object remains in the system forever.
	//
	CloseHandle(hThread);

	//	Wait for shutdown message that will be posted by the thread we created above
	//
	while (::GetMessage(&msg, 0, 0, 0))
	{
		::DispatchMessage(&msg) ;
	}

ret:

	return msg.wParam;
}

// ===============================================================
// Main Routine
// ===============================================================

int WINAPI WinMain(HINSTANCE hInstance,
				      HINSTANCE hPrevInstance,
				      LPSTR lpCmdLine,
				      int nCmdShow)
{	
	HRESULT	hr = S_OK;

	BOOL fStartDAVFileCacheServer = FALSE;
	BOOL fHeapInitialized = FALSE;
	BOOL fCOMInitialized = FALSE;
	BOOL fClassFactoryStarted = FALSE;

	//	Setup the heap for the process
	//
	if (!g_heap.FInit())
	{	
		hr = E_OUTOFMEMORY;
		DebugTrace ("Heap initialization failed 0x%08lX\n", hr);
		goto ret;
	}
	fHeapInitialized = TRUE;

	{		
		CStackBuffer<WCHAR, (MAX_PATH + 1) * sizeof(WCHAR)> pwszModulePath;
		UINT cchModulePath = MAX_PATH + 1;

		LPWSTR pwszModuleName;
		UINT cchModuleName;

		LPWSTR * argv;
		INT argc = 0;

		cchModulePath = GetModuleFileNameW(NULL,
										 pwszModulePath.get(),
										 cchModulePath);
		if (0 == cchModulePath)
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			DebugTrace ("Getting module path failed 0x%08lX\n", hr);
			goto ret;
		}

		pwszModuleName = wcsrchr(pwszModulePath.get(), L'\\');
		if (NULL == pwszModuleName)
		{
			pwszModuleName = wcsrchr(pwszModulePath.get(), L':');
		}
		if (pwszModuleName)
		{
			while (L'\\' == pwszModuleName[0] ||
				    L':' == pwszModuleName[0])
			{
				pwszModuleName++;
			}
		}
		else
		{
			pwszModuleName = pwszModulePath.get();
		}
		cchModuleName = static_cast<UINT>(wcslen(pwszModuleName));

		argv = CommandLineToArgvW(GetCommandLineW(),
								    &argc);
		if (NULL == argv)
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			DebugTrace ("Getting argument list  failed 0x%08lX\n", hr);
			goto ret;
		}

		//	Do not fail up to the GlobalFree call

		//	If command line has parameters...
		//
		if (2 == argc)
		{
			if (!_wcsicmp(argv[1], gc_wsz_RegServer))
			{
				hr = HrRegisterServer(pwszModulePath.get(),
									  cchModulePath,
									  pwszModuleName,
									  cchModuleName,
									  CLSID_FileHandleCache);
			}
			else if (!_wcsicmp(argv[1], gc_wsz_UnregServer))
			{
				hr = HrUnregisterServer(pwszModuleName,
									      cchModuleName,
									      CLSID_FileHandleCache);
			}
			else if (!_wcsicmp(argv[1], gc_wsz_Embedding))
			{
				fStartDAVFileCacheServer = TRUE;
			}
		}

		if (NULL != GlobalFree(argv))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			DebugTrace ("Freeing argument list  failed 0x%08lX\n", hr);
			goto ret;
		}

		if (!fStartDAVFileCacheServer)
		{
			goto ret;
		}
	}

	//	Setup lock cache
	//
	hr = CLockCache::CreateInstance().HrInitialize();
	if (FAILED(hr))
	{
		DebugTrace ("Lock cache initialization failed 0x%08lX\n", hr);
		goto ret;
	}

	//	Setup handle pool for worker process handles
	//
	hr = CHandlePool::CreateInstance().HrInitialize();
	if (FAILED(hr))
	{
		DebugTrace ("Handle pool initialization failed 0x%08lX\n", hr);
		goto ret;
	}

	hr = CoInitializeEx(NULL,
					COINIT_MULTITHREADED | COINIT_SPEED_OVER_MEMORY);
	if (FAILED(hr))
	{
		DebugTrace ("COM initialization failed 0x%08lX\n", hr);
		goto ret;
	}
	fCOMInitialized = TRUE;

	hr = HrInitCOMSecurity ();
	if (FAILED(hr))
	{
		DebugTrace ("COM security initialization failed 0x%08lX\n", hr);
		goto ret;
	}

	hr = CFileHandleCacheClassFactory::HrStartFactory();
	if (FAILED(hr))
	{
		DebugTrace ("File handle cache class factory startup failed 0x%08lX\n", hr);
		goto ret;
	}
	fClassFactoryStarted = TRUE;

	hr = HrExecuteServer();
	if (FAILED(hr))
	{
		DebugTrace ("Run failed 0x%08lX\n", hr);
		goto ret;
	}

ret:

	if (fClassFactoryStarted)
	{
		(VOID) CFileHandleCacheClassFactory::HrStopFactory();
	}
	
	if (fCOMInitialized)
	{
		CoUninitialize();
	}

	//	Singleton takes care of tracking if it was initialized or not itself, 
	//	so we simply always call DestroyInstance()
	//
	CHandlePool::DestroyInstance();
	CLockCache::DestroyInstance();

	if (fHeapInitialized)
	{
		g_heap.Deinit();
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\davcprox\dlldata_holder.c ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    dlldata_holder.c

Abstract:

    Wrapper around the MIDL-generated dlldata.c. This wrapper allows us
    to disable warning 4100.

Author:

    Mindaugas Krapauskas (mindaugk)       17-Jul-2002

Revision History:

--*/
#pragma warning(disable: 4100)
#include "dlldata.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\davcdata\_davcdata.h ===
/*
 *	_ D A V C D A T A . H
 *
 *	Precompiled header sources
 *
 *	Copyright 2000 Microsoft Corporation, All Rights Reserved
 */

#ifndef	__DAVCDATA_H_
#define __DAVCDATA_H_

#pragma warning(disable:4001)	/* single line comments */
#pragma warning(disable:4050)	/* different code attributes */
#pragma warning(disable:4100)	/* unreferenced formal parameter */
#pragma warning(disable:4115)	/* named type definition in parentheses */
#pragma warning(disable:4127)	/* conditional expression is constant */
#pragma warning(disable:4201)	/* nameless struct/union */
#pragma warning(disable:4206)	/* translation unit is empty */
#pragma warning(disable:4209)	/* benign typedef redefinition */
#pragma warning(disable:4214)	/* bit field types other than int */
#pragma warning(disable:4514)	/* unreferenced inline function */
#pragma warning(disable:4200)	/* zero-sized array in struct/union */
#pragma warning(disable:4710)	/* (inline) function not expanded */

//	Windows headers
//
//$HACK!
//
//	Define _WINSOCKAPI_ to keep windows.h from including winsock.h,
//	whose declarations would be redefined in winsock2.h,
//	which is included by iisextp.h,
//	which we include in davimpl.h!
//
#define _WINSOCKAPI_
#include <windows.h>
#include <winnls.h>

#include <stdio.h>				/* for  _snwprintf() */
#include <shellapi.h>			/* for CommandLineToArgvW() */

#endif	// __DAVCDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\davcprox\makefile.inc ===
#
#   makefile.inc
#       Makefile for generating files from the .idl file
#
#   Specify the following in the file for use
#
#   IDL_FILE_NAME   ( without the .idl suffix)
#   IDL_FLAGS       if any thing specific required
#

!INCLUDE $(NTMAKEENV)\makefile.plt


IDL_FILE_NAME   = fhcache
IDL_FLAGS       = /I $(BASEDIR)\public\sdk\inc -DREGISTER_PROXY_DLL


SDKINC          = $(BASEDIR)\public\sdk\inc

INCS            = -I. -I..\..\..\..\inc

CLIENT_STUB     =$(IDL_FILE_NAME)_i.c
SERVER_STUB     =$(IDL_FILE_NAME)_p.c
DLL_STUB        =dlldata.c
HEADER_FILE     =..\inc\$(IDL_FILE_NAME).h

CLIENT_TARGETS  = $(CLIENT_STUB) \

SERVER_TARGETS  = $(SERVER_STUB) \

DLL_TARGETS     = $(DLL_STUB) \

TARGETS         = $(CLIENT_TARGETS)  $(SERVER_TARGETS)  \
                  $(HEADER_FILE) $(DLL_TARGETS)

CPP             = -cpp_cmd "$(MIDL_CPP)" $(MIDL_FLAGS) \
                   $(C_DEFINES) -DMIDL_PASS

MSC_WARNING_LEVEL= /W4 /WX

#
#  Define output and dependencies
#


all:    $(TARGETS) $(EXTRN_DEPENDS)
!IF "$(BUILDMSG)" != ""
    @ech ; $(BUILDMSG) ;
!ENDIF

clean: delsrc all

delsrc:
        -erase $(TARGETS)

#
#  MIDL Compile stuff
#
$(HEADER_FILE) $(CLIENT_TARGETS) $(SERVER_TARGETS) $(DLL_TARGETS):  .\$(IDL_FILE_NAME).idl
    midl -no_stamp $(MIDL_OPTIMIZATION_NT5) -h $(HEADER_FILE) -iid $(CLIENT_STUB) -proxy $(SERVER_STUB) -dlldata $(DLL_STUB) $(IDL_FLAGS) $(CPP) $(INCS) .\$(IDL_FILE_NAME).idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\davcprox\fhcachexp.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    fhcachexp.c

Abstract:

    Wrapper around the MIDL-generated fhcache_p.c to disable certain warnings

Author:

    Mindaugas Krapauskas (mindaugk)       17-Jul-2002

Revision History:

--*/
#pragma warning(disable: 4100 4115 4152 4201 4211 4232 4310 4306)
#include "fhcache_p.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\httpext\davutil.cpp ===
/*
 *  d a v u t i l . c p p
 *
 *  Purpose:
 *      Little tools for DAVFS.
 *
 *  Owner:
 *      zyang.
 *
 *  Copyright (C) Microsoft Corp 1996 - 1997. All rights reserved.
 */

#include "_davfs.h"

BOOL FSucceededColonColonCheck(
	/* [in] */  LPCWSTR pwszURI)
{
	return !wcschr (pwszURI, L':');
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\httpext\diriter.cpp ===
/*
 *	D I R I T E R . C P P
 *
 *	Sources for directory ineration object
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davfs.h"

DEC_CONST WCHAR gc_wszGlobbing[] = L"**";
DEC_CONST UINT gc_cchwszGlobbing = CElems(gc_wszGlobbing) - 1;

//	CDirState -----------------------------------------------------------------
//
SCODE
CDirState::ScFindNext (void)
{
	SCODE sc = S_OK;

	//	If the find has not yet been established, then
	//	do so here
	//
	if (m_hFind == INVALID_HANDLE_VALUE)
	{	
		//	Establish the find handle
		//
		m_rpPathSrc.Extend (gc_wszGlobbing, gc_cchwszGlobbing, FALSE);
		if (FALSE == DavFindFirstFile(m_rpPathSrc.PszPath(), &m_hFind, &m_fd))
		{
			sc = HRESULT_FROM_WIN32(GetLastError());
			goto ret;
		}
	}
	else
	{
		//	Just find the next file
		//
		if (!FindNextFileW (m_hFind, &m_fd))
		{
			sc = S_FALSE;
			goto ret;
		}
	}

	//	Extend the resource paths with the new values
	//
	Extend (m_fd);

ret:
	return sc;
}

//	CDirIter ------------------------------------------------------------------
//
SCODE
CDirIter::ScGetNext(
	/* [in] */ BOOL fSubDirectoryAccess,
	/* [in] */ LPCWSTR pwszNewDestinationPath,
	/* [in] */ CVRoot* pvrDestinationTranslation)
{
	SCODE sc = S_OK;

	//	If the current item is a directory, and we intend to
	//	do subdirectory iteration, then go ahead and try and
	//	push our context down to the child directory
	//
	if (m_fSubDirectoryIteration &&
		fSubDirectoryAccess &&
		FDirectory() &&
		!FSpecial())
	{
		//	Add a reference to the current directory state
		//	and push it onto the stack
		//
		m_pds->AddRef();
		m_stack.push_back (m_pds.get());

		//	Replace the current directory state with the new one
		//
		m_pds = new CDirState (m_sbUriSrc,
							   m_sbPathSrc,
							   m_sbUriDst,
							   pwszNewDestinationPath
								   ? pwszNewDestinationPath
								   : m_pds->PwszDestination(),
							   pvrDestinationTranslation
								   ? pvrDestinationTranslation
								   : m_pds->PvrDestination(),

							   m_fd);
	}

	//	Find the next file in the current context
	//
	sc = m_pds->ScFindNext();

	//	If S_FALSE was returned, then there were no more
	//	resources to process within the current context.
	//	Pop the previous context off the stack and use it
	//
	while ((S_OK != sc) && !m_stack.empty())
	{
		//	Get a reference to the topmost context on the
		//	stack and pop it off
		//
		m_pds = const_cast<CDirState*>(m_stack.back());
		m_stack.pop_back();

		//	Release the reference held by the stack
		//
		m_pds->Release();

		//	Clear and/or reset the find data
		//
		memset (&m_fd, 0, sizeof(WIN32_FIND_DATAW));

		//	See if this context had anything left
		//
		sc = m_pds->ScFindNext();
	}

	//	If we have completely exhausted the files to process
	//	or encountered another error, make sure that we are 
	//	not holding onto anything still!
	//
	if (sc != S_OK)
	{
		//	This should perform the last release of anything
		//	we still have open.
		//
		m_pds.clear();
	}

	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\httpext\crtfile.cpp ===
/*
 *	C R T F I L E . C P P
 *
 *	Wrapper for CreateFileW() such that path the "\\?\" path extension
 *	is prefixed onto each path before a call to CreateFileW() is made.
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davfs.h"

//$	REVIEW: undefine the following to have DAV not prefix the paths
//	passed to the WIN32 file system APIs.
//
#define	DAV_PREFIX_PATHS
//
//$	REVIEW: end.

//	Dav path prefix -----------------------------------------------------------
//
DEC_CONST WCHAR gc_wszPathPrefix[] = L"\\\\?\\";
DEC_CONST WCHAR gc_wszUncPathPrefix[] = L"UNC";


//	Prefixing macro -----------------------------------------------------------
//
//	Note that this is a macro so that the stack buffer legitmately remains
//	in scope for the duration of the macro's calling function
//
#define DavPrefix(_v)															\
	CStackBuffer<WCHAR,MAX_PATH> lpPrefixed ## _v;								\
	{																			\
		/*	Trim off the trailing slash if need be... */						\
		UINT cch = static_cast<UINT>(wcslen(lp ## _v));							\
		if (L'\\' == lp ## _v[cch - 1])											\
		{																		\
			/* Allow for "drive roots" */										\
			if ((cch < 2) || (L':' != lp ## _v[cch - 2]))						\
				cch -= 1;														\
		}																		\
																				\
		/*	Adjust for UNC paths */												\
		UINT cchUnc = 0;														\
		if ((L'\\' == *(lp ## _v) && (L'\\' == lp ## _v[1])))					\
		{																		\
			/*	Skip past the first of the two slashes */						\
			lp ## _v += 1;														\
			cch -= 1;															\
			cchUnc = CchConstString(gc_wszUncPathPrefix);						\
		}																		\
																				\
		/*	Prefix the path */													\
		UINT cchT = cch + CchConstString(gc_wszPathPrefix) + cchUnc;			\
																				\
		if (NULL == lpPrefixed ## _v.resize(CbSizeWsz(cchT)))					\
		{ SetLastError(ERROR_NOT_ENOUGH_MEMORY); return FALSE; }				\
																				\
		memcpy (lpPrefixed ## _v.get(),											\
				gc_wszPathPrefix,												\
				sizeof(gc_wszPathPrefix));										\
		memcpy (lpPrefixed ## _v.get() + CchConstString(gc_wszPathPrefix),		\
				gc_wszUncPathPrefix,											\
				cchUnc * sizeof(WCHAR));										\
		memcpy (lpPrefixed ## _v.get() +										\
					CchConstString(gc_wszPathPrefix) +							\
					cchUnc,														\
				lp ## _v,														\
				CbSizeWsz(cch));												\
																				\
		/*	Terminate the path */												\
		lpPrefixed ## _v[cchT] = 0;												\
	}																			\

//	DavCreateFile() -----------------------------------------------------------
//
HANDLE __fastcall DavCreateFile (
	/* [in] */ LPCWSTR lpFileName,
	/* [in] */ DWORD dwDesiredAccess,
	/* [in] */ DWORD dwShareMode,
	/* [in] */ LPSECURITY_ATTRIBUTES lpSecurityAttributes,
	/* [in] */ DWORD dwCreationDisposition,
	/* [in] */ DWORD dwFlagsAndAttributes,
	/* [in] */ HANDLE hTemplateFile)
{
#ifdef	DAV_PREFIX_PATHS

	DavPrefix(FileName);
	return CreateFileW (lpPrefixedFileName.get(),
						dwDesiredAccess,
						dwShareMode,
						lpSecurityAttributes,
						dwCreationDisposition,
						dwFlagsAndAttributes,
						hTemplateFile);

#else

	return CreateFileW (lpFileName,
						dwDesiredAccess,
						dwShareMode,
						lpSecurityAttributes,
						dwCreationDisposition,
						dwFlagsAndAttributes,
						hTemplateFile);

#endif	// DAV_PREFIX_PATHS
}

//	DavDeleteFile() -----------------------------------------------------------
//
BOOL __fastcall DavDeleteFile (
	/* [in] */ LPCWSTR lpFileName)
{
#ifdef	DAV_PREFIX_PATHS

	DavPrefix(FileName);
	return DeleteFileW (lpPrefixedFileName.get());

#else

	return DeleteFileW (lpFileName);

#endif	// DAV_PREFIX_PATHS
}

//	DavCopyFile() -------------------------------------------------------------
//
BOOL __fastcall DavCopyFile (
	/* [in] */ LPCWSTR lpExistingFileName,
	/* [in] */ LPCWSTR lpNewFileName,
	/* [in] */ BOOL bFailIfExists)
{
#ifdef	DAV_PREFIX_PATHS

	DavPrefix(NewFileName);
	DavPrefix(ExistingFileName);
	return CopyFileW (lpPrefixedExistingFileName.get(),
					  lpPrefixedNewFileName.get(),
					  bFailIfExists);

#else

	return CopyFileW (lpExistingFileName,
					  lpNewFileName,
					  bFailIfExists);

#endif	// DAV_PREFIX_PATHS
}

//	DavMoveFile() -------------------------------------------------------------
//
BOOL __fastcall DavMoveFile (
	/* [in] */ LPCWSTR lpExistingFileName,
	/* [in] */ LPCWSTR lpNewFileName,
	/* [in] */ DWORD dwReplace)
{
#ifdef	DAV_PREFIX_PATHS

	DavPrefix(NewFileName);
	DavPrefix(ExistingFileName);
	return MoveFileExW (lpPrefixedExistingFileName.get(),
						lpPrefixedNewFileName.get(),
						dwReplace);

#else

	return MoveFileExW (lpExistingFileName,
						lpNewFileName,
						dwReplace);

#endif	// DAV_PREFIX_PATHS
}

//	DavCreateDirectory() ------------------------------------------------------
//
BOOL __fastcall DavCreateDirectory (
	/* [in] */ LPCWSTR lpFileName,
	/* [in] */ LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
#ifdef	DAV_PREFIX_PATHS

	DavPrefix(FileName);
	return CreateDirectoryW (lpPrefixedFileName.get(),
							 lpSecurityAttributes);

#else

	return CreateDirectoryW (lpFileName,
							 lpSecurityAttributes);

#endif	// DAV_PREFIX_PATHS
}

//	DavRemoveDirectory() ------------------------------------------------------
//
BOOL __fastcall DavRemoveDirectory (
	/* [in] */ LPCWSTR lpFileName)
{
#ifdef	DAV_PREFIX_PATHS

	DavPrefix(FileName)
	return RemoveDirectoryW (lpPrefixedFileName.get());

#else

	return RemoveDirectoryW (lpFileName);

#endif	// DAV_PREFIX_PATHS
}

//	DavGetFileAttributes() ----------------------------------------------------
//
BOOL __fastcall DavGetFileAttributes (
	/* [in] */ LPCWSTR lpFileName,
	/* [in] */ GET_FILEEX_INFO_LEVELS fInfoLevelId,
	/* [out] */ LPVOID lpFileInformation)
{
#ifdef	DAV_PREFIX_PATHS

	DavPrefix(FileName);
	return GetFileAttributesExW (lpPrefixedFileName.get(),
								 fInfoLevelId,
								 lpFileInformation);

#else

	return GetFileAttributesExW (lpFileName,
								 fInfoLevelId,
								 lpFileInformation);

#endif	// DAV_PREFIX_PATHS
}

BOOL __fastcall DavFindFirstFile(
	/* [in] */ LPCWSTR lpFileName,
	/* [out] */ HANDLE * ph,
	/* [out] */ WIN32_FIND_DATAW * pfd)
{
	HANDLE h;

	Assert(ph);
	
#ifdef	DAV_PREFIX_PATHS

	DavPrefix(FileName);
	h = FindFirstFileW (lpPrefixedFileName.get(),
					pfd);
	
#else

	h = FindFirstFileW (lpFileName,
					pfd);

#endif	// DAV_PREFIX_PATHS

	*ph = h;
	return (INVALID_HANDLE_VALUE != h);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\httpext\fsetag.cpp ===
/*
 *	E T A G F S . C P P
 *
 *	ETags for DAV resources
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davfs.h"

SCODE
CResourceInfo::ScGetResourceInfo (LPCWSTR pwszFile)
{
	if (!DavGetFileAttributes (pwszFile,
							   GetFileExInfoStandard,
							   &m_u.ad))
	{
		DebugTrace ("Dav: failed to sniff resource for attributes\n");
		return HRESULT_FROM_WIN32(GetLastError());
	}

	m_lmode = BY_ATTRIBUTE;
	return S_OK;
}

//	ETags and If-xxx headers --------------------------------------------------
//
SCODE
ScCheckIfHeaders (IMethUtil* pmu, LPCWSTR pwszPath, BOOL fGetMethod)
{
	CResourceInfo cri;
	SCODE sc = S_OK;
	LPCWSTR pwszNone;

	//	There is no reason to do any real work, if there are no
	//	"if-xxx" headers to begin with.  By the fact that the caller
	//	had no filetime to pass in, we might as well see if the headers
	//	even exist before we try and crack the file
	//
	pwszNone = pmu->LpwszGetRequestHeader (gc_szIf_None_Match, FALSE);
	if (!pwszNone &&
		!pmu->LpwszGetRequestHeader (gc_szIf_Match, FALSE) &&
		!pmu->LpwszGetRequestHeader (gc_szIf_Unmodified_Since, FALSE) &&
		!(fGetMethod && pmu->LpwszGetRequestHeader (gc_szIf_Modified_Since, FALSE)))
	{
		//	There was nothing for us to check...
		//
		return S_OK;
	}

	//	Since there was something for us to check against, go
	//	ahead and do the expensive path
	//
	//	Get the resource information
	//
	sc = cri.ScGetResourceInfo (pwszPath);
	if (FAILED (sc))
	{
		//	If we failed to get the resource info, we certainly
		//	cannot check against any of the values.  However, we
		//	do know that if the request has an "if-match", then
		//	that must fail.
		//
		if (pmu->LpwszGetRequestHeader (gc_szIf_Match, FALSE))
		{
			sc = E_DAV_IF_HEADER_FAILURE;
			goto ret;
		}

		//	Along that same line, if a if-non-match header specifies
		//	"*", then we actually should be able to perform the operation
		//
		if (sc == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
		{
			if (pwszNone)	
				sc = ScCheckEtagAgainstHeader (NULL, pwszNone);
			else
				sc = E_DAV_IF_HEADER_FAILURE;
		}		

		goto ret;
	}

	//	Check against the if-xxx headers
	//
	sc = ScCheckIfHeaders (pmu, cri.PftLastModified(), fGetMethod);
	if (FAILED (sc))
		goto ret;

ret:

	return sc;
}

BOOL
FGetLastModTime (IMethUtil * pmu, LPCWSTR pszPath, FILETIME * pft)
{
	CResourceInfo cri;

	if (FAILED (cri.ScGetResourceInfo (pszPath)))
		return FALSE;

	*pft = *cri.PftLastModified();
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\httpext\fsguid.c ===
/*
 *	F S G U I D . C
 *
 *	Filesystem GUIDs
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#pragma warning(disable:4001)	/* single line comments */
#pragma warning(disable:4050)	/* different code attributes */
#pragma warning(disable:4100)	/* unreferenced formal parameter */
#pragma warning(disable:4115)	/* named type definition in parentheses */
#pragma warning(disable:4127)	/* conditional expression is constant */
#pragma warning(disable:4201)	/* nameless struct/union */
#pragma warning(disable:4206)	/* translation unit is empty */
#pragma warning(disable:4209)	/* benign typedef redefinition */
#pragma warning(disable:4214)	/* bit field types other than int */
#pragma warning(disable:4514)	/* unreferenced inline function */

#include <windows.h>

#pragma warning(disable:4201)	/* nameless struct/union */

#define DBINITCONSTANTS

#include <oledb.h>
#include <msidxs.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\httpext\fsbase.cpp ===
/*
 *	F S B A S E . C P P
 *
 *	Sources file system implementation of DAV-Base
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davfs.h"
#include "_fsmvcpy.h"

//	DAV-Base Implementation ---------------------------------------------------
//
/*
 *	DAVOptions()
 *
 *	Purpose:
 *
 *		Win32 file system implementation of the DAV OPTIONS method.	 The
 *		OPTIONS method responds with a comma separated list of supported
 *		methods by the server.
 *
 *	Parameters:
 *
 *		pmu			[in]  pointer to the method utility object
 */

const CHAR gc_szHttpBase[] = "OPTIONS, TRACE, GET, HEAD";
const CHAR gc_szHttpDelete[] = ", DELETE";
const CHAR gc_szHttpPut[] = ", PUT";
const CHAR gc_szHttpPost[] = ", POST";
const CHAR gc_szDavCopy[] = ", COPY";
const CHAR gc_szDavMove[] = ", MOVE";
const CHAR gc_szDavMkCol[] = ", MKCOL";
const CHAR gc_szDavPropfind[] = ", PROPFIND";
const CHAR gc_szDavProppatch[] = ", PROPPATCH";
const CHAR gc_szDavLocks[] = ", LOCK, UNLOCK";
const CHAR gc_szDavSearch[] = ", SEARCH";
const CHAR gc_szDavNotif[] = "";	// no notification on httpext
const CHAR gc_szDavBatchDelete[] = "";	// no batch methods on httpext
const CHAR gc_szDavBatchCopy[] = "";	// no batch methods on httpext
const CHAR gc_szDavBatchMove[] = "";	// no batch methods on httpext
const CHAR gc_szDavBatchProppatch[] = "";	// no batch methods on httpext
const CHAR gc_szDavBatchPropfind[] = "";	// no batch methods on httpext
const CHAR gc_szDavPublic[] =
		"OPTIONS, TRACE, GET, HEAD, DELETE"
		", PUT"
		", POST"
		", COPY, MOVE"
		", MKCOL"
		", PROPFIND, PROPPATCH"
		", LOCK, UNLOCK"
		", SEARCH";
const UINT gc_cbszDavPublic = sizeof(gc_szDavPublic);
const CHAR gc_szCompliance[] = "1, 2";

void
DAVOptions (LPMETHUTIL pmu)
{
	CResourceInfo cri;
	RESOURCE_TYPE rt = RT_NULL;
	SCODE sc = S_OK;
	UINT uiErrorDetail = 0;
	BOOL fFrontPageWeb = FALSE;

	//	According to spec, If the request URI is '*', the OPTIONS request
	//	is intended to apply to the server in general rather than to the
	//	specific resource. Since a Server's communication options typically
	//	depend on the resource, the '*' request is only useful as a "ping"
	//	or "no-op" type of method; it does nothing beyong allowing client
	//	to test the capabilities of the server.
	//	So here we choose to return all the methods can ever be accepted
	//	by this server.
	//	NOTE: if the request URI is '*', WININET will convert it to '/*'.
	//	Handle this case also so that WININET clients aren't left in the dust.
	//
	if (!wcscmp(pmu->LpwszRequestUrl(), L"*") ||
		!wcscmp(pmu->LpwszRequestUrl(), L"/*"))
	{
		//	 So we simply allow all methods as defined in public
		//
		pmu->SetResponseHeader (gc_szAllow, gc_szDavPublic);
		pmu->SetResponseHeader (gc_szAccept_Ranges, gc_szBytes);

		//	Set the rest of common headers
		//
		goto ret;
	}

	//	Do ISAPI application and IIS access bits checking
	//
	//$ REVIEW	- Do we really need read access?
	//
	sc = pmu->ScIISCheck (pmu->LpwszRequestUrl(), MD_ACCESS_READ);
	if (FAILED(sc) && (sc != E_DAV_NO_IIS_READ_ACCESS))
	{
		//	Either the request has been forwarded, or some bad error occurred.
		//	In either case, quit here and map the error!
		//
		goto ret;
	}

	//	We can retrieve the file information if only we have MD_ACCESS_READ
	//	access. otherwise, we better not to try and treat it as non-existing
	//	resource.
	//
	if (SUCCEEDED(sc))
	{
		//	Get the file information for this resource
		//
		sc = cri.ScGetResourceInfo (pmu->LpwszPathTranslated());
		if (!FAILED (sc))
		{
			//	If the resource exists, adjust the resource type
			//	to the one that applies, and check to see if the URL
			//	and the resource type jibe.
			//
			rt = cri.FCollection() ? RT_COLLECTION : RT_DOCUMENT;

		}
		//	OPTIONS is allowed to return non-error responses for non-existing
		//	resources.  The response should indicate what a caller could do to
		//	create a resource at that location.  Any other error is an error.
		//
		else if ((sc != HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)) &&
				 (sc != HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND)))
		{
			goto ret;
		}

		//	Check state headers here.
		//
		sc = HrCheckStateHeaders (pmu, pmu->LpwszPathTranslated(), FALSE);
		if (FAILED (sc))
		{
			DebugTrace ("DavFS: If-State checking failed.\n");
			goto ret;
		}
	}
	else
	{
		//	Treat E_DAV_NO_IIS_READ_ACCESS as resource not exist
		//
		Assert (sc == E_DAV_NO_IIS_READ_ACCESS);
		sc = S_OK;
	}

	//	BIG NOTE ABOUT LOCKING
	//
	//	Locktoken checking is omitted here because it can't possibly
	//	make any difference.  The "loose" interpretation of lock tokens
	//	means that we try a method anyway if an invalid lock token
	//	is provided.  Since the calls in this method impl. are
	//	UNAFFECTED by locks (GetFileAttributesEx, used by
	//	ScCheckForLocationCorrectness doesn't fail for WRITE locks)
	//	this method can't fail and the values in the locktoken header
	//	are irrelevant.
	//
	//	NOTE: We still have to consider if-state-match headers,
	//	but that is done elsewhere (above -- HrCheckIfStateHeader).
	//

	//	Pass back the "allow" header
	//
	pmu->SetAllowHeader (rt);

	//	Pass back the "accept-ranges"
	//
	pmu->SetResponseHeader (gc_szAccept_Ranges,
							(rt == RT_COLLECTION)
								? gc_szNone
								: gc_szBytes);

	//
	//	Emit an appropriate "MS_Author_Via" header.  If MD_FRONTPAGE_WEB
	//	was set at the vroot, then use frontpage.  Otherwise use "DAV".
	//
	//	MD_FRONTPAGE_WEB must be checked only at the virtual root.
	//	It is inherited, so you have to be careful in how you check it.
	//
	//	We don't care if this fails: default to author via "DAV"
	//
	(void) pmu->HrMDIsAuthorViaFrontPageNeeded(&fFrontPageWeb);

	//	Pass back the "MS_Author_Via" header
	//
	pmu->SetResponseHeader (gc_szMS_Author_Via,
							fFrontPageWeb ? gc_szMS_Author_Via_Dav_Fp : gc_szMS_Author_Via_Dav);

ret:
	if (SUCCEEDED(sc))
	{
		//	Supported query languages
		//
		pmu->SetResponseHeader (gc_szDasl, gc_szSqlQuery);

		//	Public methods
		//
		pmu->SetResponseHeader (gc_szPublic, gc_szDavPublic);

		//	Do the canned bit to the response
		//
#ifdef DBG
		if (DEBUG_TRACE_TEST(HttpExtDbgHeaders))
		{
			pmu->SetResponseHeader (gc_szX_MS_DEBUG_DAV, gc_szVersion);
			pmu->SetResponseHeader (gc_szX_MS_DEBUG_DAV_Signature, gc_szSignature);
		}
#endif
		pmu->SetResponseHeader (gc_szDavCompliance, gc_szCompliance);
		pmu->SetResponseHeader (gc_szCache_Control, gc_szCache_Control_Private);
	}

	pmu->SetResponseCode (HscFromHresult(sc), NULL, uiErrorDetail, CSEFromHresult(sc));
}

/*
 *	DAVMkCol()
 *
 *	Purpose:
 *
 *		Win32 file system implementation of the DAV MKCOL method.  The
 *		MKCOL method creates a collection in the DAV name space and
 *		optionally populates the collection with the data found in the
 *		passed in request.  The response created indicates the success of
 *		the call.
 *
 *	Parameters:
 *
 *		pmu			[in]  pointer to the method utility object
 */
void
DAVMkCol (LPMETHUTIL pmu)
{
	LPCWSTR pwszPath = pmu->LpwszPathTranslated();
	SCODE sc = S_OK;
	UINT uiErrorDetail = 0;
	LPCWSTR pwsz;

	DavTrace ("Dav: creating collection/directory '%ws'\n", pwszPath);

	//	Do ISAPI application and IIS access bits checking
	//
	sc = pmu->ScIISCheck (pmu->LpwszRequestUrl(), MD_ACCESS_WRITE);
	if (FAILED(sc))
	{
		//	Either the request has been forwarded, or some bad error occurred.
		//	In either case, quit here and map the error!
		//
		goto ret;
	}

	//	Check the content-type of the request.
	//	To quote from the DAV spec:
	//	A MKCOL request message MAY contain a message body. ...
	//	If the server receives a MKCOL request entity type it does
	//	not support or understand it MUST respond with a 415 Unsupported
	//	Media Type status code.
	//
	//	Since we don't yet support ANY media types, check for ANY
	//	Content-Type header, or ANY body of any length ('cause no Content-Type
	//	could still have a valid body of type application/octet-stream),
	//	and FAIL if found!
	//
	pwsz = pmu->LpwszGetRequestHeader (gc_szContent_Length, FALSE);
	if (pwsz && wcscmp(pwsz, gc_wsz0) ||
	    pmu->LpwszGetRequestHeader (gc_szContent_Type, FALSE))
	{
		DebugTrace ("DavFS: Found a body on MKCOL -- 415");
		sc = E_DAV_UNKNOWN_CONTENT;
		goto ret;
	}

	//	This method is gated by If-xxx headers
	//
	sc = ScCheckIfHeaders (pmu, pwszPath, FALSE);
	if (FAILED (sc))
	{
		DebugTrace ("Dav: If-xxx failed their check\n");
		goto ret;
	}

	//	Check state headers here.
	//
	sc = HrCheckStateHeaders (pmu, pwszPath, FALSE);
	if (FAILED (sc))
	{
		DebugTrace ("DavFS: If-State checking failed.\n");
		goto ret;
	}

	//	BIG NOTE ABOUT LOCKING
	//
	//	Since DAVFS does not yet support locks on directories,
	//	(and since MKCOL does not have an Overwrite: header)
	//	this method cannot be affected by passed-in locktokens.
	//	So, for now, on DAVFS, don't bother to check locktokens.
	//
	//	NOTE: We still have to consider if-state-match headers,
	//	but that is done elsewhere (above -- HrCheckIfStateHeader).
	//

	//	Create the structured resource, ie. directory
	//
	if (!DavCreateDirectory (pwszPath, NULL))
	{
		DWORD	dwError = GetLastError();

		//	If the failure was caused by non-exist path, then
		//	fail with 403
		//
		if (ERROR_PATH_NOT_FOUND == dwError)
		{
			DebugTrace ("Dav: intermediate directories do not exist\n");
			sc = E_DAV_NONEXISTING_PARENT;
		}
		else
		{
			if ((ERROR_FILE_EXISTS == dwError) || (ERROR_ALREADY_EXISTS == dwError))
				sc = E_DAV_COLLECTION_EXISTS;
			else
				sc = HRESULT_FROM_WIN32 (dwError);
		}
		goto ret;
	}

	//	Emit the location
	//
	pmu->EmitLocation (gc_szLocation, pmu->LpwszRequestUrl(), TRUE);
	sc = W_DAV_CREATED;

ret:

	//	Return the response code
	//
	pmu->SetResponseCode (HscFromHresult(sc), NULL, uiErrorDetail, CSEFromHresult(sc));
}

/*
 *	DAVDelete()
 *
 *	Purpose:
 *
 *		Win32 file system implementation of the DAV DELETE method.	The
 *		DELETE method responds with a status line and possibly an XML
 *		web collection of failed deletes.
 *
 *	Parameters:
 *
 *		pmu			[in]  pointer to the method utility object
 */
void
DAVDelete (LPMETHUTIL pmu)
{
	CResourceInfo cri;
	LPCWSTR pwsz;
	LPCWSTR pwszPath = pmu->LpwszPathTranslated();
	SCODE sc = S_OK;
	UINT uiErrorDetail = 0;
	auto_ref_ptr<CXMLEmitter> pxml;
	auto_ptr<CParseLockTokenHeader> plth;
	auto_ref_ptr<CXMLBody> pxb;
	CStackBuffer<WCHAR> pwszMBPath;

	//	We don't know if we'll have chunked XML response, defer response anyway
	//
	pmu->DeferResponse();

	//	Do ISAPI application and IIS access bits checking
	//
	sc = pmu->ScIISCheck (pmu->LpwszRequestUrl(), MD_ACCESS_WRITE);
	if (FAILED(sc))
	{
		//	Either the request has been forwarded, or some bad error occurred.
		//	In either case, quit here and map the error!
		//
		goto ret;
	}

	//	Setup the access checking mechanism for deep operations
	//
	if (NULL == pwszMBPath.resize(pmu->CbMDPathW(pmu->LpwszRequestUrl())))
	{
		sc = E_OUTOFMEMORY;
		goto ret;
	}
	pmu->MDPathFromUrlW (pmu->LpwszRequestUrl(), pwszMBPath.get());

	//	Get the resource information
	//
	sc = cri.ScGetResourceInfo (pwszPath);
	if (FAILED (sc))
		goto ret;

	//	Check to see that the location is correct
	//
	sc = ScCheckForLocationCorrectness (pmu, cri, NO_REDIRECT);
	if (FAILED (sc))
		goto ret;

	//	This method is gated ny the "if-xxx" headers
	//
	sc = ScCheckIfHeaders (pmu, cri.PftLastModified(), FALSE);
	if (FAILED (sc))
		goto ret;

	//	Check state headers here.
	//
	sc = HrCheckStateHeaders (pmu, pwszPath, FALSE);
	if (FAILED (sc))
	{
		DebugTrace ("DavFS: If-State checking failed.\n");
		goto ret;
	}

	//	If there are locktokens, feed them to a parser object.
	//
	pwsz = pmu->LpwszGetRequestHeader (gc_szLockToken, TRUE);
	if (pwsz)
	{
		plth = new CParseLockTokenHeader (pmu, pwsz);
		Assert(plth.get());
		plth->SetPaths (pwszPath, NULL);
	}

	//	If the resource is a collection, iterate through
	//	and do a recursive delete
	//
	if (cri.FCollection())
	{
		CAuthMetaOp moAuth(pmu, pwszMBPath.get(), pmu->MetaData().DwAuthorization());
		CAccessMetaOp moAccess(pmu, pwszMBPath.get(), MD_ACCESS_READ|MD_ACCESS_WRITE);
		CIPRestrictionMetaOp moIP(pmu, pwszMBPath.get());

		BOOL fDeleted = FALSE;
		DWORD dwAcc = 0;
		LONG lDepth = pmu->LDepth(DEPTH_INFINITY);

		//	The client must not submit a depth header with any value
		//	but Infinity
		//
		if ((DEPTH_INFINITY != lDepth) &&
			(DEPTH_INFINITY_NOROOT != lDepth))
		{
			sc = E_DAV_INVALID_HEADER;
			goto ret;
		}

		//	Make sure we have access.  The access will come back out and we
		//	can then pass it into the call to delete.
		//
		(void) pmu->ScIISAccess (pmu->LpwszRequestUrl(),
								 MD_ACCESS_READ|MD_ACCESS_WRITE,
								 &dwAcc);

		//	Check for deep operation access blocking
		//
		sc = moAccess.ScMetaOp();
		if (FAILED (sc))
			goto ret;

		sc = moAuth.ScMetaOp();
		if (FAILED (sc))
			goto ret;

		sc = moIP.ScMetaOp();
		if (FAILED (sc))
			goto ret;

		//	Create an XML doc, NOT chunked
		//
		pxb.take_ownership (new CXMLBody (pmu));
		pxml.take_ownership(new CXMLEmitter(pxb.get()));

		//	Must set all the headers before XML emitting start
		//
		pmu->SetResponseHeader (gc_szContent_Type, gc_szText_XML);
		pmu->SetResponseCode (HscFromHresult(W_DAV_PARTIAL_SUCCESS),
							  NULL,
							  0,
							  CSEFromHresult(W_DAV_PARTIAL_SUCCESS));

		//	Delete the directory
		//
		DavTrace ("Dav: deleting '%ws'\n", pwszPath);
		sc = ScDeleteDirectoryAndChildren (pmu,
										   pmu->LpwszRequestUrl(),
										   pwszPath,
										   moAccess.FAccessBlocked() || moAuth.FAccessBlocked() || moIP.FAccessBlocked(),
										   dwAcc,
										   lDepth,
										   *pxml,
										   NULL, // translations are pmu based
										   &fDeleted,
										   plth.get(),
										   TRUE); // drop locks
	}
	else
	{
		//	If we have a locktoken for this file, drop the lock before
		//	trying the delete.
		//
		if (plth.get())
		{
			LARGE_INTEGER liLockID;

			sc = plth->HrGetLockIdForPath (pwszPath, GENERIC_WRITE, &liLockID);
			if (SUCCEEDED(sc))
			{
				//	Drop the lock
				//
				sc = CSharedLockMgr::Instance().HrDeleteLock(pmu->HitUser(),
														liLockID);
				if (FAILED(sc))
				{
					goto ret;
				}
			}
			else if (E_DAV_LOCK_NOT_FOUND != sc)
			{
				goto ret;
			}
		}

		//	Delete the file that is referred to by the URI
		//
		DavTrace ("Dav: deleting '%ws'\n", pwszPath);
		if (!DavDeleteFile (pwszPath))
		{
			DebugTrace ("Dav: failed to delete file\n");
			sc = HRESULT_FROM_WIN32 (GetLastError());

			//	Special work for 416 Locked responses -- fetch the
			//	comment & set that as the response body.
			//
			if (FLockViolation (pmu,
								GetLastError(),
								pwszPath,
								GENERIC_READ | GENERIC_WRITE))
			{
				sc = E_DAV_LOCKED;
			}
		}
	}

	if (SUCCEEDED (sc))
	{
		//	Delete the content-types
		//
		//$REVIEW	I don't believe we need to do this any longer because
		//$REVIEW	MOVE and COPY both unconditionally blow away the destination
		//$REVIEW	metadata before copying over the source, so there is no
		//$REVIEW	chance that the resulting content type will be wrong.
		//
		CContentTypeMetaOp amoContent(pmu, pwszMBPath.get(), NULL, TRUE);
		(void) amoContent.ScMetaOp();
	}

	//	Only continue on complete success
	//
	if (sc != S_OK)
		goto ret;

ret:
	if (pxml.get() && pxml->PxnRoot())
	{
		pxml->Done();

		//	Note we must not emit any headers after XML chunking starts
	}
	else
		pmu->SetResponseCode (HscFromHresult(sc), NULL, uiErrorDetail, CSEFromHresult(sc));

	pmu->SendCompleteResponse();
}

/*
 *	DAVPost()
 *
 *	Purpose:
 *
 *		Win32 file system implementation of the DAV POST method.  The
 *		POST method creates a file in the DAV name space and populates
 *		the file with the data found in the passed in request.  The
 *		response created indicates the success of the call.
 *
 *	Parameters:
 *
 *		pmu			[in]  pointer to the method utility object
 */
void
DAVPost (LPMETHUTIL pmu)
{
	//	DAVPost() is really an unknown/unsupported method
	//	at this point...
	//
	DAVUnsupported (pmu);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\httpext\entry.cpp ===
/*
 *	E N T R Y . C P P
 *
 *	Entrypoints for Caligula DLLs
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davfs.h"
#include "_shlkmgr.h"
#include <langtocpid.h>
#include <ex\idlethrd.h>
#include <ntverp.h>
#include <iisver.h>

//	Global items --------------------------------------------------------------
//
EXTERN_C const CHAR gc_szSignature[]	= "HTTPEXT";
EXTERN_C const WCHAR gc_wszSignature[]	= L"HTTPEXT";
HINSTANCE g_hinst						= NULL;
WCHAR gc_wszDllPath[MAX_PATH+1];

CHAR gc_szVersion[] = VER_PRODUCTVERSION_STR;

//	Per process instance data -------------------------------------------------
//
class CImplInst : private RefCountedGlobal<CImplInst, HSE_VERSION_INFO *>
{
	//
	//	Friend declarations required by RefCountedGlobal template
	//
	friend class Singleton<CImplInst>;
	friend class RefCountedGlobal<CImplInst, HSE_VERSION_INFO *>;

	//
	//	Flags to track initialization progress so we know
	//	how much to uninitialize if initialization fails overall
	//
	BOOL m_fInitializedHeap;

	//	CREATORS
	//
	//	Declared private to ensure that arbitrary instances
	//	of this class cannot be created.  The Singleton
	//	template (declared as a friend above) controls
	//	the sole instance of this class.
	//
	CImplInst() :
		m_fInitializedHeap(FALSE)
	{
	}
	BOOL FInit( HSE_VERSION_INFO * pver );
	~CImplInst();

	//
	//	Array of strings used in service state change
	//	event log messages.
	//
	static LPCSTR mc_rgszLogServiceStateChange[];

	//	NOT IMPLEMENTED
	//
	CImplInst( const CImplInst& );
	CImplInst& operator=( const CImplInst& );

public:
	using RefCountedGlobal<CImplInst, HSE_VERSION_INFO *>::DwInitRef;
	using RefCountedGlobal<CImplInst, HSE_VERSION_INFO *>::DeinitRef;
};

LPCSTR CImplInst::mc_rgszLogServiceStateChange[] = { gc_szSignature, gc_szVersion };

STGOPENSTORAGEONHANDLE		g_pfnStgOpenStorageOnHandle = NULL;

#ifdef	DBG
BOOL g_fDavTrace = FALSE;
DEC_CONST CHAR gc_szDbgIni[] = "HTTPEXT.INI";
DEC_CONST INT gc_cchDbgIni = CchConstString(gc_szDbgIni);
#endif

//	------------------------------------------------------------------------
//
//	CImplInst::FInit()
//
//	Second-phase (failable) CImplInst constructor.  Code that instantiates
//	the CImplInst should call this function after instantiation.  If the
//	call returns FALSE, calling code should immediately destroy the
//	CImplInst.
//
BOOL
CImplInst::FInit( HSE_VERSION_INFO * pver )
{
	BOOL fSuccess = FALSE;

	//
	//	Handle exceptions locally.  If anything below throws
	//	an exception then fail the initialization.
	//
	try
	{
		HINSTANCE hLib;

		//	First and foremost, check to ensure that
		//	our resources are well attached and accessible
		//	if this fails, then we want to fail our loading.
		//
		if (!LoadStringA (g_hinst,
						  IDS_ExtensionName,
						  pver->lpszExtensionDesc,
						  sizeof(pver->lpszExtensionDesc)))
			goto Exit;

		//	Setup the HSE version numbering
		//
		pver->dwExtensionVersion = MAKELONG (HSE_VERSION_MINOR, HSE_VERSION_MAJOR);

#ifdef	DBG
		//	Do the DBG tracing initialization
		//
		g_fDavTrace = GetPrivateProfileIntA (gc_szDbgTraces,
											 gc_szSignature,
											 FALSE,
											 gc_szDbgIni);
#endif	// DBG

		//	Init the heap allocators
		//
		if ( !g_heap.FInit() )
			goto Exit;
		m_fInitializedHeap = TRUE;

		//	Initialize the resource string cache
		//
		if ( !FInitResourceStringCache() )
			goto Exit;

		//	Init the volume type cache
		//
		if ( !FInitVolumeTypeCache() )
			goto Exit;

		//	Init the parser
		//
		if ( !CDAVExt::FVersion (pver) )
			goto Exit;

		//	Create shared lock mgr
		//
		if (FAILED(CSharedLockMgr::CreateInstance().HrInitialize()))
			goto Exit;

		//	Create the thread pool
		//
		if (!CPoolManager::FInit())
			goto Exit;

		//	Start the idle thread
		//
		if ( !FInitIdleThread() )
			goto Exit;

		//	Init the cache mapping accept language string to cpid
		//	cache used to decode non-UTF8 characters in URLs
		//
		if (!CLangToCpidCache::FCreateInstance())
			goto Exit;

		//	If this API is not available on ole32.dll. we'll not be able
		//	to operate properties, but we should still work to some extent
		//	so we'll take care of the NULL function pointer in our code.
		//	don't fail now
		//
		//	Don't use relative paths for dlls, It is easy to put suspect dlls 
		// 	somewhere in an application's path. Always use absolute paths.
		//
		CHAR szOle32Path[MAX_PATH+1];
		UINT cSystemDir;
		
		//	Get the system directory
		//
		cSystemDir = GetSystemDirectory (szOle32Path, CElems(szOle32Path));
		
		//	GetSystemDirectory will return 
		//	1. the number of characters copied if it succeeds (excluding the 
		//		terminating NULL)
		//	2. 0 if it fails
		//	3. the number of characters required if the supplied buffer is 
		//		too smallto hold the path. 
		//	Since we gave enough space for the system 
		//	directory, we will treat "buffer not enough" errors as failures.
		//
		if ((0 < cSystemDir) && (CElems(szOle32Path) > cSystemDir))
		{
			//	GetSystemDirectory path does not end with a backslash
			//
			if (CElems("\\ole32.dll") + cSystemDir <= CElems(szOle32Path))
			{
				strcat(szOle32Path, "\\ole32.dll");
				hLib = LoadLibraryA (szOle32Path);
				if (hLib)
				{
					g_pfnStgOpenStorageOnHandle = (STGOPENSTORAGEONHANDLE)
												  GetProcAddress (hLib, "StgOpenStorageOnHandle");
				}
			}
		}


		// 	Start up event log message takes two parameters
		//	the signature and the version
		//
		#undef	LOG_STARTUP_EVENT
		#ifdef	LOG_STARTUP_EVENT
		LogEvent (DAVPRS_SERVICE_STARTUP,
				  EVENTLOG_INFORMATION_TYPE,
				  sizeof(mc_rgszLogServiceStateChange) / sizeof(LPCSTR),
				  mc_rgszLogServiceStateChange,
				  0,
				  NULL);
		#endif	// LOG_STARTUP_EVENT
	}
	catch ( CDAVException& )
	{
		goto Exit;
	}

	fSuccess = TRUE;

Exit:
	return fSuccess;
}

//	------------------------------------------------------------------------
//
//	CImplInst::~CImplInst()
//
CImplInst::~CImplInst()
{
	//
	//	DO NOT allow exceptions to propagate out of this call.
	//	This is intended as a safety valve only.  In order to
	//	avoid leaking instance data, individual instance data
	//	components should handle any exceptions themselves.
	//
	try
	{
		//
		//	If we logged a startup message, then log a shutdown message
		//
		#undef	LOG_STARTUP_EVENT
		#ifdef	LOG_STARTUP_EVENT
		LogEvent (DAVPRS_SERVICE_SHUTDOWN,
				  EVENTLOG_INFORMATION_TYPE,
				  sizeof(mc_rgszLogServiceStateChange) / sizeof(LPCSTR),
				  mc_rgszLogServiceStateChange,
				  0,
				  NULL);
		#endif	// LOG_STARTUP_EVENT

		//
		//	Deinit the idle thread.  Do this before taking down the
		//	thread pool there may be delayed thread pool work items
		//	pending on the idle thread.
		//
		DeleteIdleThread();

		//
		//	Deinit the thread pool
		//
		CPoolManager::Deinit();

		//	Deinit the language string to cpid cache
		//
		CLangToCpidCache::DestroyInstance();

		//
		//	remove the IDBCreateCommand if exist
		//
		ReleaseDBCreateCommandObject();

		//	Destroy shared lock mgr
		//
		CSharedLockMgr::DestroyInstance();

		//	Shutdown the parser
		//
		(void) CDAVExt::FTerminate ();

		//	Deinit the volume type cache
		//
		DeinitVolumeTypeCache();

		//	Clean out the security-thread-token cache.
		//
		CleanupSecurityToken();

		//	Deinit the resource string cache
		//
		DeinitResourceStringCache();

		//	Destroy allocators
		//
		if ( m_fInitializedHeap )
			g_heap.Deinit();
	}
	catch ( CDAVException& )
	{
	}
}

//	------------------------------------------------------------------------
//
//	Instance refcounting callouts from _davprs
//
VOID AddRefImplInst()
{
	HSE_VERSION_INFO lVer;
	DWORD cRef;

	cRef = CImplInst::DwInitRef(&lVer);

	//
	//	We should already have at least one ref on the instance
	//	before we called DwInitRef(), so we should more than one
	//	ref after the call.
	//
	Assert( cRef > 1 );
}

VOID ReleaseImplInst()
{
	CImplInst::DeinitRef();
}

//	IIS Entrypoints -----------------------------------------------------------
//
EXTERN_C BOOL WINAPI
FGetExtensionVersion (HSE_VERSION_INFO * pver)
{
	CWin32ExceptionHandler win32ExceptionHandler;

	//
	//	Initialize one instance reference and return whether it succeeded.
	//
	return !!CImplInst::DwInitRef( pver );
}

EXTERN_C BOOL WINAPI
FTerminateDavFS (DWORD)
{
	CWin32ExceptionHandler win32ExceptionHandler;

	//
	//	Deinitialize one instance reference
	//
	CImplInst::DeinitRef();

	//
	//	After the instance data has been released, we are ready to terminate.
	//
	return TRUE;
}

EXTERN_C DWORD WINAPI
DwDavFSExtensionProc (LPEXTENSION_CONTROL_BLOCK pecb)
{
	HSE_VERSION_INFO lVer;

	DWORD dwHSEStatusRet = HSE_STATUS_ERROR;

	if ( CImplInst::DwInitRef(&lVer) )
	{
		dwHSEStatusRet = CDAVExt::DwMain(pecb);

		CImplInst::DeinitRef();
	}

	return dwHSEStatusRet;
}

//	Win32 DLL Entrypoints -----------------------------------------------------
//
EXTERN_C BOOL WINAPI
DllMain (HINSTANCE hinst, DWORD dwReason, LPVOID lpvReserved)
{
	switch (dwReason)
	{
		default:
		{
			DebugTrace ("FInitHttpExtDll(), unknown reason\n");
			return FALSE;
		}

		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
		{
			//
			//	We disable thread library calls (see below),
			//	so we should never see DLL_THREAD_ATTACH or
			//	DLL_THREAD_DETACH.
			//
			Assert (FALSE);

			//
			//	But if we do, it doesn't harm anything.
			//
			return TRUE;
		}

		case DLL_PROCESS_ATTACH:
		{
			//
			//	Init .INI file tagged debug traces
			//
			InitTraces();

			//	Cache the inst
			//
			g_hinst = hinst;

			//	And the full path to the DLL
			//
			if ( !GetModuleFileNameW( hinst, gc_wszDllPath, sizeof(gc_wszDllPath)/sizeof(WCHAR) ) )
			{
				DebugTrace( "FInitHttpExtDll() - GetModuleFileName() failed in DLL_PROCESS_ATTACH\n" );
				return FALSE;
			}

			//	Call the parser's initialization for every call into our
			//	DLL initialization proc.  The order of operations here is
			//	fairly important.  The parser should be called after we do
			//	our processing in the non-DETACH case.
			//
			if ( !CDAVExt::FInitializeDll (hinst, dwReason) )
				return FALSE;

			//	We are going to disable thread library calls.  If the parser
			//	really ever needs these then the this needs to change.
			//
			DisableThreadLibraryCalls (hinst);

			return TRUE;
		}

		case DLL_PROCESS_DETACH:
		{
			//	And in the detach case, the impl. gets the last word.
			//	Ignore any failures -- the DLL is being unloaded and
			//	the process is going away whether we like it or not.
			//
			(void) CDAVExt::FInitializeDll (hinst, dwReason);

			return TRUE;
		}
	}
}

//	OLE Entrypoints -----------------------------------------------------------
//
STDAPI
HrDllCanUnloadNowDavFS (VOID)
{

	return S_OK;
}

STDAPI
HrDllGetClassObjectDavFS (REFCLSID rclsid, REFIID riid, LPVOID * ppv)
{
	return E_NOINTERFACE;
}

STDAPI
HrDllRegisterServerDavFS (VOID)
{
	HRESULT hr;

	//	This is a "first line" entrypoint into our dll.  Need to init some stuff.
	//	Right now, the heap is the only important piece.
	//
	g_heap.FInit();

	//	Everybody gets to register regardless of failures
	//
	hr = EventLogDllRegisterServer( gc_wszDllPath );

	return hr;
}

STDAPI
HrDllUnregisterServerDavFS (VOID)
{
	HRESULT	hr;

	//	This is a "first line" entrypoint into our dll.  Need to init some stuff.
	//	Right now, the heap is the only important piece.
	//
	g_heap.FInit();

	//	Everybody gets to unregister regardless of failures
	//
	hr = EventLogDllUnregisterServer();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\httpext\fslnkfx.cpp ===
/*
 *	F S L N K F X . C P P
 *
 *	Link fixup impl support
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davfs.h"
const WCHAR gc_wszDavDLL[] = L"httpext.dll";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\httpext\fsget.cpp ===
/*
 *	F S G E T . C P P
 *
 *	Sources file system implementation of DAV-Base
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davfs.h"
#include <htmlmap.h>
#include <ex\rgiter.h>

/*
 *	ScEmitFile()
 *
 *	Purpose:
 *
 *		Helper function used to open and transmit a given
 *		file from the local dav namespace.
 *
 *	Parameters:
 *
 *		pmu				[in]  pointer to the method util obj
 *		pwszFile		[in]  name of file to emit
 *		pwszContent		[in]  content type of the file, we need it if it is a multipart response
 *
 *	Returns:
 *
 *		SCODE.
 *		S_OK (0) indicates success, and the WHOLE file was sent.
 *		W_DAV_PARTIAL_CONTENT indicates success, but only PARTIAL content was
 *			sent because of a Content-Range header.
 *		An error (FAILED(sc)) means that the file was not setn.
 */
SCODE
ScEmitFile (LPMETHUTIL pmu,
			LPCWSTR pwszFile,
			LPCWSTR pwszContent)
{
	auto_ref_handle hf;
	BOOL fMap = FALSE;
	BY_HANDLE_FILE_INFORMATION fi;
	CRangeParser riByteRange;
	LPCWSTR pwsz;
	SCODE sc = S_OK;
	UINT cch;

	//	Check validity of input
	//
	Assert (pwszFile);
	Assert (pwszContent);

	//	Check to see if we have a map file
	//
	cch = static_cast<UINT>(wcslen (pwszFile));
	if ((cch >= 4) && !_wcsicmp (L".map", pwszFile + cch - 4))
		fMap = TRUE;

	//	If we have a locktoken, try to get the lock handle from the cache.
	//	If this fails, fall through and do the normal processing.
	//	DO NOT put LOCK handles into an auto-object!!  The CACHE still owns it!!!
	//
	pwsz = pmu->LpwszGetRequestHeader (gc_szLockToken, TRUE);
	if (!pwsz ||
		!FGetLockHandle (pmu, pmu->LpwszPathTranslated(), GENERIC_READ, pwsz, &hf))
	{
		//	Open the file and go to it
		//
		if (!hf.FCreate(
			DavCreateFile (pwszFile,						// filename
						   GENERIC_READ,					// dwAccess
						   FILE_SHARE_READ | FILE_SHARE_WRITE,
						   NULL,							// lpSecurityAttributes
						   OPEN_EXISTING,					// creation flags
						   FILE_ATTRIBUTE_NORMAL |
						   FILE_FLAG_SEQUENTIAL_SCAN |
						   FILE_FLAG_OVERLAPPED,			// attributes
						   NULL)))							// template
		{
			DWORD dwErr = GetLastError();
			sc = HRESULT_FROM_WIN32 (dwErr);

			//	Special work for 416 Locked responses -- fetch the
			//	comment & set that as the response body.
			//
			if (FLockViolation (pmu, dwErr, pwszFile, GENERIC_READ))
			{
				sc = E_DAV_LOCKED;
			}

			DebugTrace ("Dav: failed to open the file for retrieval\n");
			goto ret;
		}
	}

	//	We better have a valid handle.
	Assert (hf.get() != INVALID_HANDLE_VALUE);

	//	We are going to need the file size for both map files and
	//	ordinary files. For map files, we read the entire file into
	//	memory. For ordinary files, we need the file size to do
	//	byte range validation.
	//
	if (!GetFileInformationByHandle(hf.get(), &fi))
	{
		sc = HRESULT_FROM_WIN32 (GetLastError());
		goto ret;
	}

	//	Again, if it is a mapfile, we need to parse the map and
	//	find the right URL to redirect to, otherwise, we can just
	//	emit the file back to the client.
	//
	if (fMap && pmu->FTranslated())
	{
		auto_handle<HANDLE>	hevt(CreateEvent(NULL, TRUE, FALSE, NULL));
		auto_heap_ptr<CHAR> pszBuf;
		BOOL fRedirect = FALSE;
		LPCSTR pszPrefix;
		CHAR pszRedirect[MAX_PATH];
		OVERLAPPED ov;
		ULONG cb;

		//	The common case is that these map files are not very large.
		//	We may want to put a physical upper bound on the size of the
		//	file, but I don't see that as an imperitive thing at this
		//	point.
		//
		//	Since we are going to need to parse the whole thing, we are
		//	going to read the whole thing into memory at once. Read the file
		//	in, and then parse it out.
		//
		//	Allocate space for the file.
		//	Lets put an uper bound of 64K on it.
		//
		if ((fi.nFileSizeHigh != 0) || (fi.nFileSizeLow > (128 * 1024)))
		{
			//	Mapping is too large for our tastes
			//
			DavTrace ("Dav: mapping file too large\n");
			sc = HRESULT_FROM_WIN32 (ERROR_MORE_DATA);
			goto ret;
		}
		pszBuf = (CHAR *)g_heap.Alloc (fi.nFileSizeLow + 1);

		//	Read it in
		//
		ov.hEvent = hevt;
		ov.Offset = 0;
		ov.OffsetHigh = 0;
		if (!ReadFromOverlapped (hf.get(), pszBuf, fi.nFileSizeLow, &cb, &ov))
		{
			sc = HRESULT_FROM_WIN32 (GetLastError());
			goto ret;
		}
		Assert (cb == fi.nFileSizeLow);

		//	Ensure the file data is NULL terminated
		//
		*(pszBuf + cb) = 0;

		//	Check the map...
		//
		pmu->CchUrlPrefix(&pszPrefix);
		if (FIsMapProcessed (pmu->LpszQueryString(),
							 pszPrefix,
							 pmu->LpszServerName(),
							 pszBuf.get(),
							 &fRedirect,
							 pszRedirect,
							 MAX_PATH))
		{
			//	Redirect the request
			//
			if (fRedirect)
			{
				sc = pmu->ScRedirect (pszRedirect);
				goto ret;
			}
		}

		//	if not redirect, we should rewind the file pointer
		//	back to the beginning.
		//
		if (INVALID_SET_FILE_POINTER == SetFilePointer (hf.get(), 0, NULL, FILE_BEGIN))
		{
			sc = HRESULT_FROM_WIN32 (GetLastError());
			goto ret;
		}
	}

	//	Do any byte range (206 Partial Content) processing. The function will fail out if the
	//	we are trying to do byte ranges on the file larger than 4GB.
	//
	sc = ScProcessByteRanges (pmu, pwszFile, fi.nFileSizeLow, fi.nFileSizeHigh, &riByteRange);

	//	Tell the parser to transmit the file
	//
	//	We need to transmit the entire file
	//
	if (S_OK == sc)
	{
		//	Just add the file
		//
		pmu->AddResponseFile (hf);
	}
	else if (W_DAV_PARTIAL_CONTENT == sc)
	{
		//	It is a byte range transmission. Tranmsit the ranges.
		//
		Assert(0 == fi.nFileSizeHigh);
		TransmitFileRanges(pmu, hf, fi.nFileSizeLow, &riByteRange, pwszContent);
	}

ret:

	return sc;
}

/*
 *	TransmitFileRanges()
 *
 *	Purpose:
 *
 *		Helper function used to transmit a byte range
 *		file from the local dav namespace.
 *
 *	Parameters:
 *
 *		pmu				[in]  pointer to the method util obj
 *		hf				[in]  handle of file to emit
 *		dwSize			[in]  size of file
 *		priRanges		[in]  the ranges
 *		pszContent		[in]  content type of the file, we need it if it is a multipart response
 *
 */
VOID
TransmitFileRanges (LPMETHUTIL pmu,
					const auto_ref_handle& hf,
					DWORD dwSize,
					CRangeBase * priRanges,
					LPCWSTR pwszContent)
{
	auto_heap_ptr<WCHAR> pwszPreamble;
	WCHAR rgwchBoundary[75];
	const RGITEM * prgi = NULL;
	DWORD dwTotalRanges;

	//	Create a buffer for the preamble we tramsit before each part
	//	of the response.
	//
	pwszPreamble = static_cast<LPWSTR>(g_heap.Alloc
		((2 + CElems(rgwchBoundary) + 2 +
		gc_cchContent_Type + 2 + wcslen(pwszContent) + 2 +
		gc_cchContent_Range + 2 + gc_cchBytes + 40) * sizeof(WCHAR)));

	//	Assert that we have a at least one range to transmit
	//
	Assert (priRanges);
	dwTotalRanges = priRanges->UlTotalRanges();
	Assert (dwTotalRanges > 0);

	//	Assert that we have a content type.
	//
	Assert (pwszContent);

	//	Rewind to the first range. This is only a precautionary measure.
	//
	priRanges->Rewind();
	prgi = priRanges->PrgiNextRange();

	//	Is it a singlepart response
	//
	if ((1 == dwTotalRanges) && prgi && (RANGE_ROW == prgi->uRT))
	{
		//	Set the content range header
		//
		wsprintfW(pwszPreamble, L"%ls %u-%u/%u",
				  gc_wszBytes,
				  prgi->dwrgi.dwFirst,
				  prgi->dwrgi.dwLast,
				  dwSize);

		pmu->SetResponseHeader (gc_szContent_Range, pwszPreamble);

		//	Add the file
		//
		pmu->AddResponseFile (hf,
							  prgi->dwrgi.dwFirst,
							  prgi->dwrgi.dwLast - prgi->dwrgi.dwFirst + 1);
	}
	else
	{
		//	We have multiple byte ranges, then we need to generate a
		//	boundary and set the Content-Type header with the multipart
		//	content type and boundary.
		//
		//	Generate a boundary
		//
		GenerateBoundary (rgwchBoundary, CElems(rgwchBoundary));

		//	Create the content type header with the boundary generated
		//
		wsprintfW(pwszPreamble, L"%ls; %ls=\"%ls\"",
				  gc_wszMultipart_Byterange,
				  gc_wszBoundary,
				  rgwchBoundary);

		//	Reset the content type header with the new content type
		//
		pmu->SetResponseHeader (gc_szContent_Type, pwszPreamble);

		do {

			if (RANGE_ROW == prgi->uRT)
			{
				//	Create preamble.
				//
				wsprintfW(pwszPreamble, L"--%ls%ls%ls: %ls%ls%ls: %ls %u-%u/%u%ls%ls",
						  rgwchBoundary,
						  gc_wszCRLF,
						  gc_wszContent_Type,
						  pwszContent,
						  gc_wszCRLF,
						  gc_wszContent_Range,
						  gc_wszBytes,
						  prgi->dwrgi.dwFirst,
						  prgi->dwrgi.dwLast,
						  dwSize,
						  gc_wszCRLF,
						  gc_wszCRLF);

				pmu->AddResponseText (static_cast<UINT>(wcslen(pwszPreamble)), pwszPreamble);
				pmu->AddResponseFile (hf,
									  prgi->dwrgi.dwFirst,
									  prgi->dwrgi.dwLast - prgi->dwrgi.dwFirst + 1);

				//	Add the CRLF
				//
				pmu->AddResponseText (gc_cchCRLF, gc_szCRLF);
			}
			prgi = priRanges->PrgiNextRange();

		} while (prgi);

		//	Add the last end of response text
		//
		wsprintfW(pwszPreamble, L"--%ls--", rgwchBoundary);
		pmu->AddResponseText (static_cast<UINT>(wcslen(pwszPreamble)), pwszPreamble);
	}
}

SCODE
ScGetFile (LPMETHUTIL pmu,
	LPWSTR pwszFile,
	LPCWSTR pwszURI)
{
	SCODE sc;
	WCHAR rgwszContent[MAX_PATH];
	FILETIME ft;

	//	Get the Content-Type of the file
	//
	UINT cchContent = CElems(rgwszContent);
	if (!pmu->FGetContentType(pwszURI, rgwszContent, &cchContent))
	{
		sc = E_FAIL;
		goto ret;
	}

	//	This method is gated by If-xxx headers
	//
	sc = ScCheckIfHeaders (pmu, pwszFile, TRUE);
	if (FAILED (sc))
	{
		DebugTrace ("Dav: If-xxx failed their check\n");
		goto ret;
	}

	sc = HrCheckStateHeaders (pmu,		//	methutil
							  pwszFile,	//	path
							  TRUE);	//	fGetMeth
	if (FAILED (sc))
	{
		DebugTrace ("DavFS: If-State checking failed.\n");
		//	304 returns from get should really have an ETag....
		//SideAssert(FGetLastModTime (pmu, pwszFile, &ft));
		//hsc = HscEmitHeader (pmu, pszContent, &ft);
		goto ret;
	}

	//	Emit the headers for the file
	//
	if (FGetLastModTime (pmu, pwszFile, &ft))
	{
		sc = pmu->ScEmitHeader (rgwszContent, pwszURI, &ft);
		if (sc != S_OK)
		{
			DebugTrace ("Dav: failed to emit headers\n");
			goto ret;
		}
	}

	//	Emit the file
	//
	sc = ScEmitFile (pmu, pwszFile, rgwszContent);
	if ( (sc != S_OK) && (sc != W_DAV_PARTIAL_CONTENT) )
	{
		DebugTrace ("Dav: failed to emit file\n");
		goto ret;
	}

ret:

	return sc;
}

void
GetDirectory (LPMETHUTIL pmu, LPCWSTR pwszUrl)
{
	auto_ref_ptr<IMDData> pMDData;
	ULONG ulDirBrowsing = 0;
	LPCWSTR pwszDftDocList = NULL;
	SCODE sc = S_OK;
	UINT cchUrl = static_cast<UINT>(wcslen(pwszUrl));

	//	Before we decide to do anything, we need to check to see what
	//	kind of default behavior is expected for a directory.  Values
	//	for this level of access are cached from the metabase.  Look
	//	them up and see what to do.

	//	Get the metabase doc attributes
	//
	if (FAILED(pmu->HrMDGetData (pwszUrl, pMDData.load())))
	{
		//
		//$REVIEW	HrMDGetData() can fail for timeout reasons,
		//$REVIEW	shouldn't we just pass back the hr that it returns?
		//
		sc = E_DAV_NO_IIS_READ_ACCESS;
		goto ret;
	}

	ulDirBrowsing = pMDData->DwDirBrowsing();
	pwszDftDocList = pMDData->PwszDefaultDocList();

	//	Try to load default file if allowed, do this only when translate: t
	//
	if ((ulDirBrowsing & MD_DIRBROW_LOADDEFAULT) && pwszDftDocList && pmu->FTranslated())
	{
		HDRITER_W hit(pwszDftDocList);
		LPCWSTR pwszDoc;

		while (NULL != (pwszDoc = hit.PszNext()))
		{
			auto_com_ptr<IStream> pstm;
			CStackBuffer<WCHAR> pwszDocUrl;
			CStackBuffer<WCHAR> pwszDocUrlNormalized;
			CStackBuffer<WCHAR,MAX_PATH> pwszDocPath;
			UINT cchDocUrlNormalized;
			UINT cchDoc;

			//	What happens here is that for EVERY possible default
			//	document, we are going to see if this document is something
			//	we can legitimately process.
			//
			//	So first, we need to extend our url and normalize it
			//	in such a way that we can pin-point the document it uses.
			//
			cchDoc = static_cast<UINT>(wcslen(pwszDoc));
			pwszDocUrl.resize(CbSizeWsz(cchUrl + cchDoc));
			memcpy (pwszDocUrl.get(), pwszUrl, cchUrl * sizeof(WCHAR));
			memcpy (pwszDocUrl.get() + cchUrl, pwszDoc, (cchDoc + 1) * sizeof(WCHAR));

			//	Now, someone could have been evil and stuffed path modifiers
			//	or escaped characters in the default document name.  So we
			//	need to parse those out here -- do both in place.  You can't
			//	do this per-say in the MMC snap in, but MDUTIL does (maybe
			//	ASDUTIL too).
			//
			cchDocUrlNormalized = cchUrl + cchDoc + 1;
			pwszDocUrlNormalized.resize(cchDocUrlNormalized * sizeof(WCHAR));

			sc = ScNormalizeUrl (pwszDocUrl.get(),
								 &cchDocUrlNormalized,
								 pwszDocUrlNormalized.get(),
								 NULL);
			if (S_FALSE == sc)
			{
				pwszDocUrlNormalized.resize(cchDocUrlNormalized * sizeof(WCHAR));
				sc = ScNormalizeUrl (pwszDocUrl.get(),
									 &cchDocUrlNormalized,
									 pwszDocUrlNormalized.get(),
									 NULL);

				//	Since we've given ScNormalizeUrl() the space it asked for,
				//	we should never get S_FALSE again.  Assert this!
				//
				Assert(S_FALSE != sc);
			}

			if (FAILED (sc))
				continue;

			//	Translate this into a local path.  We should be able to
			//
			//	At most we should go through the processing below twice, as the byte
			//	count required is an out param.
			//
			do {

				pwszDocPath.resize(cchDocUrlNormalized * sizeof(WCHAR));
				sc = pmu->ScStoragePathFromUrl (pwszDocUrlNormalized.get(),
												pwszDocPath.get(),
												&cchDocUrlNormalized);

			} while (sc == S_FALSE);
			if (FAILED (sc) || (W_DAV_SPANS_VIRTUAL_ROOTS == sc))
				continue;

			//$	SECURITY:
			//
			//	Check to see if the destination is really a short
			//	filename.
			//
			sc = ScCheckIfShortFileName (pwszDocPath.get(), pmu->HitUser());
			if (FAILED (sc))
				continue;

			//$	SECURITY:
			//
			//	Check to see if the destination is really the default
			//	data stream via alternate file access.
			//
			sc = ScCheckForAltFileStream (pwszDocPath.get());
			if (FAILED (sc))
				continue;

			if (static_cast<DWORD>(-1) != GetFileAttributesW (pwszDocPath.get()))
			{
				DWORD dwAcc = 0;

				//	See if we have the right access...
				//
				(void) pmu->ScIISAccess (pwszDocUrlNormalized.get(), MD_ACCESS_READ, &dwAcc);

				//	Found the default doc, if a child ISAPI doesn't want it,
				//	then we will handle it.
				//
				//	NOTE: Pass in TRUE for fCheckISAPIAccess to tell this
				//	function to do all the special access checking.
				//
				//	NOTE: Also pass in FALSE to fKeepQueryString 'cause
				//	we're re-routing this request to a whole new URI.
				//
				sc = pmu->ScApplyChildISAPI (pwszDocUrlNormalized.get(), dwAcc, TRUE, FALSE);
				if (FAILED(sc))
				{
					//	Either the request has been forwarded, or some bad error occurred.
					//	In either case, quit here and map the error!
					//
					goto ret;
				}

				//	Emit the location of the default document
				//
				pmu->EmitLocation (gc_szContent_Location, pwszDocUrlNormalized.get(), FALSE);

				//	If we don't have any read access, then there
				//	is no point in continuing the request.
				//
				if (0 == (dwAcc & MD_ACCESS_READ))
				{
					sc = E_DAV_NO_IIS_READ_ACCESS;
					goto ret;
				}

				//	Get the file
				//
				//	NOTE: This function can give a WARNING that needs to be mapped
				//	to get our 207 Partial Content in some cases.
				//
				sc = ScGetFile (pmu, pwszDocPath.get(), pwszDocUrlNormalized.get());
				goto ret;
			}
		}
	}

	//	If we haven't emitted any other way, see if HTML
	//	is allowed...
	//
	if (ulDirBrowsing & MD_DIRBROW_ENABLED)
	{
		//	At one point in time we would generate our own HTML rendering
		//	of the directories, but at the beginning of NT beta3, the change
		//	was made to behave the same in HTTPExt as in DavEX, etc.
		//
		sc = W_DAV_NO_CONTENT;
	}
	else
	{
		//	Otherwise, report forbidden
		//	We weren't allowed to browse the dir and there was no
		//	default doc.  IIS maps this scenario to a specific
		//	suberror (403.2).
		//
		sc = E_DAV_NO_IIS_READ_ACCESS;
	}

ret:

	pmu->SetResponseCode (HscFromHresult(sc), NULL, 0, CSEFromHresult(sc));
}

/*
 *	GetInt()
 *
 *	Purpose:
 *
 *		Win32 file system implementation of the DAV GET method.	 The
 *		GET method returns a file from the DAV name space and populates
 *		the headers with the info found in the file and its meta data.	The
 *		response created indicates the success of the call and contains
 *		the data from the file.
 *
 *	Parameters:
 *
 *		pmu			[in]  pointer to the method utility object
 */
void
GetInt (LPMETHUTIL pmu)
{
	CResourceInfo cri;
	LPCWSTR pwszUrl = pmu->LpwszRequestUrl();
	LPCWSTR pwszPath = pmu->LpwszPathTranslated();
	SCODE sc = S_OK;

	//	Do ISAPI application and IIS access bits checking
	//
	sc = pmu->ScIISCheck (pwszUrl, MD_ACCESS_READ, TRUE);
	if (FAILED(sc))
	{
		//	Either the request has been forwarded, or some bad error occurred.
		//	In either case, quit here and map the error!
		//
		goto ret;
	}

	//	If we have a directory, we are going to return
	//	HTML, otherwise the extenstion of the file gives
	//	us what we need.
	//
	sc = cri.ScGetResourceInfo (pwszPath);
	if (FAILED (sc))
		goto ret;

	//	If this is a hidden object, fail with 404 Resource Not Found.  This is to be
	//	consistent with IIS (See NTRAID #247218).  They do not allow GET on resources that
	//	have the HIDDEN bit set.
	//
	if (cri.FHidden())
	{
		sc = E_DAV_HIDDEN_OBJECT;
		goto ret;
	}

	//	If this is a directory, process it as such, otherwise
	//	handle the request as if the resource was a file
	//
	if (cri.FCollection())
	{
		//	GET allows for request url's that end in a trailing slash
		//	when getting data from a directory.	 Otherwise it is a bad
		//	request.  If it does not have a trailing slash and refers
		//	to a directory, then we want to redirect.
		//
		sc = ScCheckForLocationCorrectness (pmu, cri, REDIRECT);
		if (FAILED (sc))
			goto ret;

		//	A return of S_FALSE from above means that a redirect happened
		//	so we can forego trying to do a GET on the directory.
		//
		if (S_FALSE == sc)
			return;

		GetDirectory (pmu, pwszUrl);
		return;
	}

	//	GET allows for request url's that end in a trailing slash
	//	when getting data from a directory.	 Otherwise it is not found.
	//	This matches IIS's behavior as of 9/28/98.
	//
	if (FTrailingSlash (pwszUrl))
	{
		//	Trailing slash on a non-directory just doesn't work
		//
		sc = HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);
		goto ret;
	}

	//	Emit the file
	//
	sc = ScGetFile (pmu, const_cast<LPWSTR>(pwszPath), pwszUrl);

ret:

	pmu->SetResponseCode (HscFromHresult(sc), NULL, 0, CSEFromHresult(sc));
}

/*
 *	DAVGet()
 *
 *	Purpose:
 *
 *		Win32 file system implementation of the DAV GET method.	 The
 *		GET method returns a file from the DAV name space and populates
 *		the headers with the info found in the file and its meta data.	The
 *		response created indicates the success of the call and contains
 *		the data from the file.
 *
 *	Parameters:
 *
 *		pmu			[in]  pointer to the method utility object
 */
void
DAVGet (LPMETHUTIL pmu)
{
	GetInt (pmu);
}

/*
 *	DAVHead()
 *
 *	Purpose:
 *
 *		Win32 file system implementation of the DAV HEAD method.  The
 *		HEAD method returns a file from the DAV name space and populates
 *		the headers with the info found in the file and its meta data.
 *		The response created indicates the success of the call and contains
 *		the data from the file.
 *
 *	Parameters:
 *
 *		pmu			[in]  pointer to the method utility object
 */
void
DAVHead (LPMETHUTIL pmu)
{
	//	The HEAD method should never return any body what so ever...
	//
	pmu->SupressBody();

	//	Otherwise, it is just the same as a GET
	//
	GetInt (pmu);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\httpext\fsmeta.cpp ===
/*
 *	F S M E T A . C P P
 *
 *	Sources file system implementation of DAV-Meta
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davfs.h"

//	CFSFind -------------------------------------------------------------------
//
SCODE
CFSFind::ScAddProp (LPCWSTR, LPCWSTR pwszProp, BOOL)
{
	enum { cProps = 8 };

	//	If this is our first time in, we will need to allocate
	//	space for all of the properties we are expecting to get
	//	added over the coarse of this operation.
	//
	if (m_ft == FIND_NONE)
	{
		//	Note that we have started requesting specific properties
		//
		m_ft = FIND_SPECIFIC;
	}
	else if (m_ft != FIND_SPECIFIC)
	{
		//	If we are not finding specfic properties and somebody asked
		//	for one, then bts (by the spec) this should consititute an
		//	error.
		//
		return E_DAV_PROPFIND_TYPE_UNEXPECTED;
	}

	//	See if there is room at the in...
	//
	if (m_cMaxProps == m_cProps)
	{
		UINT cb;

		//	Allocate enough space for the next block of properties
		//
		m_cMaxProps = m_cProps + cProps;
		cb = m_cMaxProps * sizeof(PROPVARIANT);
		m_rgwszProps.realloc (cb);
	}

	//	If this is the getcontenttype property, then we need to remember
	//	its location for use when providing default values...
	//
	if (!wcscmp (pwszProp, gc_wszProp_iana_getcontenttype))
		m_ip_getcontenttype = m_cProps;

	//	Set the property up as one to process.
	//
	Assert (m_cProps < m_cMaxProps);
	m_rgwszProps[m_cProps++] = AppendChainedSz (m_csb, pwszProp);
	return S_OK;
}

SCODE
CFSFind::ScFind (CXMLEmitter& msr,
				 IMethUtil * pmu,
				 CFSProp& fpt)
{
	SCODE scFind;
	SCODE sc = S_OK;

	//	Setup the emitting of the response.  This will construct
	//	an XML node that looks like:
	//
	//	<multistatus>
	//		<response>
	//			<href>http:/www....</>
	//
	//
	CEmitterNode enItem;
	CEmitterNode en;

	sc = msr.ScSetRoot (gc_wszMultiResponse);
	if (FAILED (sc))
		goto ret;

	sc = enItem.ScConstructNode (msr, msr.PxnRoot(), gc_wszResponse);
	if (FAILED (sc))
		goto ret;

	//	If they havent asked for anything, then we should return an
	//	error
	//
	if (m_ft == FIND_NONE)
	{
		//$REVIEW: is it really correct to NOT add the HREF node here? --BeckyAn 6July1999
		return E_DAV_EMPTY_FIND_REQUEST;
	}
	//	If the request is an for a specific set of properties, then
	//	this is pretty easy...
	//
	else if (m_ft == FIND_SPECIFIC)
	{
		Assert (m_cProps);
		Assert (m_rgwszProps);

		sc = ScAddHref (enItem,
						pmu,
						fpt.PwszPath(),
						fpt.FCollection(),
						fpt.PcvrTranslation());
		if (FAILED (sc))
			goto ret;

		//	Get all the properties by name
		//
		scFind = fpt.ScGetSpecificProps (msr,
										 enItem,
										 m_cProps,
										 (LPCWSTR*)m_rgwszProps.get(),
										 m_ip_getcontenttype);
		if (FAILED (scFind))
		{
			(void) ScAddStatus (&enItem, HscFromHresult(scFind));
			goto ret;
		}
	}
	//	If the request is an for all properties or all names, then again,
	//	this is pretty easy...
	//
	else
	{
		Assert ((m_ft == FIND_ALL) || (m_ft == FIND_NAMES));

		//	Get all props or all names
		//
		scFind = fpt.ScGetAllProps (msr, enItem, m_ft == FIND_ALL);
		if (FAILED (scFind) && (scFind != E_DAV_SMB_PROPERTY_ERROR))
		{
			(void) ScAddStatus (&enItem, HscFromHresult(scFind));
			goto ret;
		}
	}

ret:
	return sc;
}


//	IPreloadNamespaces
//
SCODE
CFSFind::ScLoadNamespaces(CXMLEmitter * pmsr)
{
	SCODE	sc = S_OK;
	UINT	iProp;

	//	Load common namespaces
	//
	sc = pmsr->ScPreloadNamespace (gc_wszDav);
	if (FAILED(sc))
		goto ret;
	sc = pmsr->ScPreloadNamespace (gc_wszLexType);
	if (FAILED(sc))
		goto ret;
	sc = pmsr->ScPreloadNamespace (gc_wszXml_V);
	if (FAILED(sc))
		goto ret;

	//	Add more namespaces

	switch (m_ft)
	{
		case FIND_SPECIFIC:
			for (iProp = 0; iProp < m_cProps; iProp++)
			{
				sc = pmsr->ScPreloadNamespace (m_rgwszProps[iProp]);
				if (FAILED(sc))
					goto ret;
			}
			break;

		case FIND_ALL:
		case FIND_NAMES:
			//	Now that we don't have a way to predict what namespaces to
			//	be used.
			//	Per resource level namespaces will be added on <DAV:response>
			//	node later
			break;

		default:
			AssertSz (FALSE, "Unknown propfind type");
			// fall through

		case FIND_NONE:
			sc = E_DAV_EMPTY_FIND_REQUEST;
			goto ret;
	}

ret:
	return sc;
}


//	CFSPatch ------------------------------------------------------------------
//
SCODE
CFSPatch::ScDeleteProp (LPCWSTR, LPCWSTR pwszProp)
{
	enum { cProps = 8 };
	UINT irp;

	//	We cannot delete any reserved properties, so let's
	//	just shortcut this here and now...
	//
	if (CFSProp::FReservedProperty (pwszProp,
									CFSProp::RESERVED_SET,
									&irp))
	{
		//	Take ownership of the bstr as well
		//
		return m_csn.ScAddErrorStatus (HSC_FORBIDDEN, pwszProp);
	}

	//	Make sure there is room at the inn...
	//
	if (m_cMaxDeleteProps == m_cDeleteProps)
	{
		UINT cb;

		//	Allocate enough space for all the properties names
		//	we want to delete.
		//
		m_cMaxDeleteProps = m_cDeleteProps + cProps;
		cb = m_cMaxDeleteProps * sizeof(BSTR);
		m_rgwszDeleteProps.realloc (cb);
	}

	//	Set the property up as one to process.
	//
	Assert (m_cDeleteProps < m_cMaxDeleteProps);
	m_rgwszDeleteProps[m_cDeleteProps++] = AppendChainedSz(m_csb, pwszProp);
	return S_OK;
}

SCODE
CFSPatch::ScSetProp (LPCWSTR,
					 LPCWSTR pwszProp,
					 auto_ref_ptr<CPropContext>& pPropCtx)
{
	enum { cProps = 8 };
	UINT irp;

	//	We cannot set any reserved properties, so let's
	//	just shortcut this here and now...
	//
	if (CFSProp::FReservedProperty (pwszProp,
									CFSProp::RESERVED_SET,
									&irp))
	{
		//	Take ownership of the bstr as well
		//
		return m_csn.ScAddErrorStatus (HSC_FORBIDDEN, pwszProp);
	}

	//	Make sure there is room at the inn...
	//
	if (m_cMaxSetProps == m_cSetProps)
	{
		UINT cb;

		//	Allocate enough space for all the properties we
		//	might want to set
		//
		m_cMaxSetProps = m_cSetProps + cProps;
		cb = m_cMaxSetProps * sizeof(PROPVARIANT);
		m_rgvSetProps.realloc (cb);

		//	Make sure the VARIANT are properly initialized
		//	(only initialize the newly added space).
		//
		ZeroMemory (&m_rgvSetProps[m_cSetProps],
					sizeof(PROPVARIANT) * cProps);

		//	... and their names.
		//
		cb = m_cMaxSetProps * sizeof(LPCWSTR);
		m_rgwszSetProps.realloc (cb);
	}

	//	Set the property up as one to process.
	//
	Assert (m_cSetProps < m_cMaxSetProps);
	m_rgwszSetProps[m_cSetProps] = AppendChainedSz(m_csb, pwszProp);
	pPropCtx = new CFSPropContext(&m_rgvSetProps[m_cSetProps]);
	m_cSetProps++;

	return S_OK;
}

SCODE
CFSPatch::ScPatch (CXMLEmitter& msr,
				   IMethUtil * pmu,
				   CFSProp& fpt)
{
	SCODE sc = S_OK;
	SCODE scSet = S_OK;
	SCODE scDelete = S_OK;

	CEmitterNode enItem;

	//	If there are no properties at all, reserved or otherwise,
	//	we want to fail the call with BAD_REQUEST
	//
	if ((m_cSetProps == 0) &&
		(m_cDeleteProps == 0) &&
		m_csn.FEmpty())
	{
		return E_DAV_EMPTY_PATCH_REQUEST;
	}

	//	Setup the emitting of the response.  This will construct
	//	an XML node that looks like:
	//
	//	<multistatus>
	//		<response>
	//			<href>http:/www....</>
	//
	//
	sc = msr.ScSetRoot (gc_wszMultiResponse);
	if (FAILED (sc))
		goto ret;

	sc = enItem.ScConstructNode (msr, msr.PxnRoot(), gc_wszResponse);
	if (FAILED (sc))
		goto ret;

	sc = ScAddHref (enItem,
					pmu,
					fpt.PwszPath(),
					fpt.FCollection(),
					fpt.PcvrTranslation());
	if (FAILED (sc))
		goto ret;

	//	If the client requested any of the reserved properties, we know
	//	that they will fail and we also know that everything else will fail
	//	as well, so we might as well handle that here...
	//
	if (!m_csn.FEmpty())
	{
		//$	REVIEW:
		//
		//	If the possibly successful properties need to be
		//	marked as a failure as well (HSC_METHOD_FAILURE),
		//	then that would happen here.
		//

		//NT242086: Now that we've got a reponse node, we should
		//added to the response.
		//
		sc = m_csn.ScEmitErrorStatus (enItem);
		goto ret;
	}

	//	If there are no reserved properties we have a pretty good bet
	//	at setting these props...
	//
	scSet = fpt.ScSetProps (m_csn,
							m_cSetProps,
							m_rgwszSetProps.get(),
							m_rgvSetProps);
	if (FAILED (scSet))
	{
		sc = scSet;
		goto ret;
	}

	//	... and deleting these props.
	//
	scDelete = fpt.ScDeleteProps (m_csn,
								  m_cDeleteProps,
								  m_rgwszDeleteProps.get());
	if (FAILED (scDelete))
	{
		sc = scDelete;
		goto ret;
	}

	//	If the possibly successful properties need to be
	//	marked as a failure as well (HSC_METHOD_FAILURE),
	//	then that would happen here.  Either way, if there
	//	is a failure, then we do not want to commit the
	//	changes.
	//
	if ((scSet == S_FALSE) || (scDelete == S_FALSE))
		goto ret;

	//	Commit the changes to the property container
	//
	sc = fpt.ScPersist();
	if (FAILED (sc))
		goto ret;

	//	Emit the response,
	//
	sc = m_csn.ScEmitErrorStatus (enItem);
	if (FAILED(sc))
		goto ret;

ret:
	return sc;
}

CFSPatch::~CFSPatch()
{
	//	Make sure all the propvariants are cleaned up...
	//
	for (UINT i = 0; i < m_cSetProps; i++)
		PropVariantClear (&m_rgvSetProps[i]);
}

SCODE
CFSPatch::ScLoadNamespaces (CXMLEmitter * pmsr)
{
	SCODE	sc = S_OK;
	UINT	iProp;

	//	Load common namespaces
	//
	sc = pmsr->ScPreloadNamespace (gc_wszDav);
	if (FAILED(sc))
		goto ret;

	//	Add namespaces for set props
	//
	for (iProp = 0; iProp < m_cSetProps; iProp++)
	{
		sc = pmsr->ScPreloadNamespace (m_rgwszSetProps[iProp]);
		if (FAILED(sc))
			goto ret;
	}

	//	And delete props
	//
	for (iProp = 0; iProp < m_cDeleteProps; iProp++)
	{
		sc = pmsr->ScPreloadNamespace (m_rgwszDeleteProps[iProp]);
		if (FAILED(sc))
			goto ret;
	}


ret:
	return sc;
}

//	CFSProp -------------------------------------------------------------------
//
SCODE
CFSProp::ScGetPropsInternal (ULONG cProps,
	LPCWSTR* rgwszPropNames,
	PROPVARIANT* rgvar,
	LONG ip_getcontenttype)
{
	SCODE sc = S_OK;

	//	There really should only be one scenario where this could happen
	//	-- and it is a cheap test, so it is worth doing.  The case where
	//	we might see an invalid pbag is when the document extisted, but
	//	there was no existing property set to impose the pbag on.  Other
	//	than that, OLE is always giving us a property bag, regardless of
	//	whether the target drive can support it.
	//
	if (FInvalidPbag())
		return sc;

	//	We better be good to go...
	//
	sc = m_pbag->ReadMultiple (cProps,
							   rgwszPropNames,
							   rgvar,
							   NULL);

	//	If we succeeded, and the getcontenttype property was requested,
	//	we may need to do some special processing
	//
	if (SUCCEEDED (sc) && (ip_getcontenttype != -1))
	{
		//	We want to make sure that getcontenttype gets filled in
		//
		if (rgvar[ip_getcontenttype].vt == VT_EMPTY)
		{
			CStackBuffer<WCHAR> pwszT;
			LPWSTR pwszContentType;
			UINT cch = 40;

			//	No content type was explicitly set in the props.
			//	Fetch the default based on the file extension
			//	(fetching from our metabase-content-type-cache).
			//
			do {

				if (NULL == pwszT.resize(CbSizeWsz(cch)))
				{
					sc = E_OUTOFMEMORY;
					goto ret;
				}

			} while (!m_pmu->FGetContentType (m_pwszURI, pwszT.get(), &cch));

			//	Return the mapped content type
			//
			rgvar[ip_getcontenttype].vt = VT_LPWSTR;

			//	Must use task memory, as it will be freed by PropVariantClear
			//
			pwszContentType = (LPWSTR) CoTaskMemAlloc (cch * sizeof(WCHAR));
			if (NULL == pwszContentType)
			{
				MCDTrace ("Dav: MCD: CFSProp::ScGetPropsInternal() - CoTaskMemAlloc() failed to allocate %d bytes\n", cch * sizeof(WCHAR));

				sc = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
				goto ret;
			}

			rgvar[ip_getcontenttype].pwszVal = pwszContentType;
			memcpy(pwszContentType, pwszT.get(), cch * sizeof(WCHAR));

			//	In the case where this was the only property requested, make
			//	sure that our return code it correct.
			//
			if (cProps == 1)
			{
				Assert (ip_getcontenttype == 0);
				Assert (sc == S_FALSE);
				sc = S_OK;
			}
		}
	}
	else
	{
		//	This is the common path for when we are trying to access
		//	something over an SMB, but the host cannot support the
		//	request (it is not an NT5 NTFS machine).
		//
		if ((sc == STG_E_INVALIDNAME) || !FIsVolumeNTFS())
			sc = E_DAV_SMB_PROPERTY_ERROR;
	}

ret:

	return sc;
}

BOOL
CFSProp::FReservedProperty (LPCWSTR pwszProp, RESERVED_TYPE rt, UINT* prp)
{
	UINT irp;
	CRCWsz wsz(pwszProp);

	//	Search for the property in the list of local
	//	properties.
	//
	Assert (CElems(sc_rp) == sc_crp_set_reserved);
	for (irp = 0; irp < sc_crp_set_reserved; irp++)
	{
		//	If the crc and the strings match...
		//
		if ((wsz.m_dwCRC == sc_rp[irp].dwCRC) &&
			!wcscmp (wsz.m_pwsz, sc_rp[irp].pwsz))
		{
			break;
		}
	}

	//	Setup the return
	//
	Assert (sc_crp_set_reserved != iana_rp_content_type);
	*prp = irp;

	return (irp < static_cast<UINT>((rt == RESERVED_GET) ? sc_crp_get_reserved : sc_crp_set_reserved));
}

SCODE
CFSProp::ScGetReservedProp (CXMLEmitter& xml,
	CEmitterNode& enParent,
	UINT irp,
	BOOL fGetValues)
{
	CEmitterNode en;
	CStackBuffer<WCHAR> wszBuf;
	LARGE_INTEGER li;
	LPCWSTR pwszType = NULL;
	LPWSTR pwsz = NULL;
	SCODE sc = S_OK;
	SYSTEMTIME st;

	Assert (irp <= sc_crp_get_reserved);
	Assert (sc_crp_get_reserved == iana_rp_content_type);
	Assert (CElems(sc_rp) == sc_crp_set_reserved);

	//	Only generate values if the caller wants them
	//
	if (fGetValues)
	{
		//	Switch across the reserved properties generating
		//	a value for the property
		//
		switch (irp)
		{
			case iana_rp_etag:

				Assert(m_pmu);
				if (FETagFromFiletime (m_cri.PftLastModified(), wszBuf.get(), m_pmu->GetEcb()))
				{
					pwsz = wszBuf.get();
				}
				break;

			case iana_rp_displayname:

				//	The filename/displayname is simply the name of the file
				//	and we should be able to pick it off from the path with
				//	little and/or no trouble at all.  However, we will use
				//	the URI instead.  We do this such that the displayname
				//	for a vroot is the name of the vroot and not the name of
				//	the physical disk directory.
				//
				pwsz = wcsrchr (m_pwszURI, L'/');
				if (NULL == pwsz)
				{
					//	Arrgh.  If there was no path separator in the filename
					//	I don't know that we can really give a reasonable value
					//	for this file.
					//
					TrapSz ("resource path has no slashes....");
					return S_FALSE;
				}

				//	One more check.  If this is a directory path,
				//	they might have a trailing slash.  If that is what we're
				//	pointing to right now (next char is NULL), back up to the
				//	next delimiter to get the real item name.
				//
				if (L'\0' == pwsz[1])
				{
					//	This better be a collection.  Although it may not
					//	be if the client mis-terminated his/her url
					//
					//	There is a special case that we need to check for
					//	here.  It is possible that the URI was strictly "/"
					//	which means that if we continue this processing, the
					//	displayname and/or the filename would be empty or
					//	non-existant.  In this case only, return "/" as the
					//	display name.
					//
					if (m_pwszURI == pwsz)
					{
						pwsz = L"/";
					}
					else
					{
						//	Now we have to copy the string, to rip off that
						//	trailing slash we found in the step above.
						//	We want to remove the final slash because this is the
						//	displayname, not a URI.
						//
						LPCWSTR pwszEnd;
						UINT cchNew;

						for (pwszEnd = pwsz--; pwsz > m_pwszURI; pwsz--)
							if (L'/' == *pwsz)
								break;

						if (L'/' != *pwsz)
						{
							//	Arrgh.  If there was no path separator in the
							//	filename I don't know that we can really give
							//	a reasonable value for this file.
							//
							TrapSz ("resource path has no slashes (redux)....");
							return S_FALSE;
						}

						//	At this point, the segment defined by (pwsz + 1, pwszEnd)
						//	names the resource.
						//
						cchNew = static_cast<UINT>(pwszEnd - ++pwsz);
						if (NULL == wszBuf.resize(CbSizeWsz(cchNew)))
						{
							sc = E_OUTOFMEMORY;
							goto ret;
						}
						memcpy(wszBuf.get(), pwsz, cchNew * sizeof(WCHAR));
						wszBuf[cchNew] = L'\0';
						pwsz = wszBuf.get();
					}
				}
				else
				{
					//	At this point, the segment defined by (pwsz + 1, '\0'] names
					//	the resource.
					//
					pwsz++;
				}
				break;

			case iana_rp_resourcetype:

				//	Create the element to pass back
				//
				sc = en.ScConstructNode (xml, enParent.Pxn(), sc_rp[irp].pwsz);
				if (FAILED (sc))
					goto ret;

				if (m_cri.FCollection())
				{
					CEmitterNode enSub;
					sc = en.ScAddNode (gc_wszCollection, enSub);
					if (FAILED (sc))
						goto ret;
				}
				goto ret;

			case iana_rp_content_length:

				m_cri.FileSize(li);
				pwszType = gc_wszDavType_Int;

				//$	REVIEW: negative values of _int64 seem to have problems in
				//	the __i64tow() API.  Handle those cases ourselves.
				//
				//  In this instance, we shouldn't have to worry about it because
				//  the content-length *shouldn't* ever be negative.  We'll assert
				//  that this is the case.
				//
				Assert (li.QuadPart >= 0);
				_i64tow (li.QuadPart, wszBuf.get(), 10);
				pwsz = wszBuf.get();
				break;

			case iana_rp_creation_date:

				FileTimeToSystemTime (m_cri.PftCreation(), &st);
				if (FGetDateIso8601FromSystime (&st, wszBuf.get(), wszBuf.size()))
				{
					pwszType = gc_wszDavType_Date_ISO8601;
					pwsz = wszBuf.get();
				}
				break;

			case iana_rp_last_modified:

				FileTimeToSystemTime (m_cri.PftLastModified(), &st);
				if (FGetDateRfc1123FromSystime (&st, wszBuf.get(), wszBuf.size()))
				{
					pwszType = gc_wszDavType_Date_Rfc1123;
					pwsz = wszBuf.get();
				}
				break;

			case iana_rp_supportedlock:
			case iana_rp_lockdiscovery:

				//	Get the prop from the lock cache (and related subsystem calls).
				//
				sc = HrGetLockProp (m_pmu,
									sc_rp[irp].pwsz,
									m_pwszPath,
									m_cri.FCollection() ? RT_COLLECTION : RT_DOCUMENT,
									xml,
									enParent);

				//	Regardless of error or success, we are done here.  If we
				//	succeeded, then the pel has already been constructed and
				//	is ready to pass back.  Otherwise, we just want to report
				//	the error.
				//
				goto ret;

			case iana_rp_ishidden:

				pwszType = gc_wszDavType_Boolean;
				_itow (!!m_cri.FHidden(), wszBuf.get(), 10);
				pwsz = wszBuf.get();
				break;

			case iana_rp_iscollection:

				pwszType = gc_wszDavType_Boolean;
				_itow (!!m_cri.FCollection(), wszBuf.get(), 10);
				pwsz = wszBuf.get();
				break;

			//	Special case: getcontenttype should really be stored, but there
			//	are some cases where the file may live in such a place as there
			//	would be no property stream available to store the value in.
			//
			case iana_rp_content_type:

				//	Get the content-type if it was not stored in the property
				//	stream.
				//
				for (UINT cch = wszBuf.celems();;)
				{
					if (NULL == wszBuf.resize(CbSizeWsz(cch)))
					{
						sc = E_OUTOFMEMORY;
						goto ret;
					}
					if (m_pmu->FGetContentType(m_pwszURI, wszBuf.get(), &cch))
						break;
				}
		}
	}

	//	Create the element to pass back
	//
	sc = en.ScConstructNode (xml, enParent.Pxn(), sc_rp[irp].pwsz, pwsz, pwszType);
	if (FAILED (sc))
		goto ret;

ret:
	return sc;
}

SCODE
CFSProp::ScGetSpecificProps (CXMLEmitter& msr,
	CEmitterNode& enItem,
	ULONG cProps,
	LPCWSTR* rgwszPropNames,
	LONG ip_getcontenttype)
{
	//	safe_propvariant_array ----------------------------------------------------
	//
	//	Used to make sure the array of VARIANT can always be safely freed
	//
	class safe_propvariant_array
	{
		PROPVARIANT * 	m_rgv;
		ULONG		m_cv;

	public:

		safe_propvariant_array (PROPVARIANT* rgv, ULONG cv)
				: m_rgv(rgv),
				  m_cv(cv)
		{
			memset (rgv, 0, sizeof(PROPVARIANT) * cv);
		}

		~safe_propvariant_array ()
		{
			ULONG i;

			for (i = 0; i < m_cv; i++)
				PropVariantClear(&m_rgv[i]);
		}
	};

	SCODE sc = S_OK;
	CStackBuffer<PROPVARIANT> rgv;
	UINT iv;
	CStatusCache csn;
	CEmitterNode enPropStat;
	CEmitterNode enPropOK;


	//	allocate space to hold an array of variants and stuff it into
	//	a safe_variant_array to ensure cleanup
	//
	rgv.resize(sizeof(PROPVARIANT) * cProps);
	safe_propvariant_array sva(rgv.get(), cProps);

	sc = csn.ScInit();
	if (FAILED(sc))
		goto ret;

	//	Get the properties
	//
	sc = ScGetPropsInternal (cProps, rgwszPropNames, rgv.get(), ip_getcontenttype);
	if (FAILED(sc))
	{
		//	When getting properties, it is perfectly OK to ignore SMB errors
		//	and treat the file as if it were hosted on a FAT drive
		//
		if (sc == E_DAV_SMB_PROPERTY_ERROR)
			sc = S_OK;

		//	What this means is that the default not-found processing should
		//	kick in.
		//
	}

	//	Rip through the returned properties, adding to the response as we go
	//
	for (iv = 0; iv < cProps; iv++)
	{
		//	If there is a value to the property, write the variant as
		//	an XML element and add it to the response
		//
		if (rgv[iv].vt != VT_EMPTY)
		{
			if (!enPropOK.Pxn())
			{
				//	Get the insert point for props
				//
				sc = ScGetPropNode (enItem, HSC_OK, enPropStat, enPropOK);
				if (FAILED(sc))
					goto ret;
			}

			//	Write the variant as an XML element
			//
			sc = ScEmitFromVariant (msr,
									enPropOK,
									rgwszPropNames[iv],
									rgv[iv]);
			if (FAILED (sc))
				goto ret;
		}
		else
		{
			UINT irp;

			// Check if it's a reserved property
			//
			if (FReservedProperty (rgwszPropNames[iv], RESERVED_GET, &irp) ||
				(irp == iana_rp_content_type))
			{
				if (!enPropOK.Pxn())
				{
					//	Get the insert point for props
					//
					sc = ScGetPropNode (enItem, HSC_OK, enPropStat, enPropOK);
					if (FAILED(sc))
						goto ret;
				}

				//	If the property was reserved, then extract it from
				//	the property class directly
				//
				sc = ScGetReservedProp (msr, enPropOK, irp);
				if (FAILED (sc))
					goto ret;

				continue;
			}

			//	Now, if we got here, then for CFSProp, the property
			//	must not have existed.
			//
			sc = csn.ScAddErrorStatus (HSC_NOT_FOUND, rgwszPropNames[iv]);
			if (FAILED(sc))
				goto ret;
		}
	}

	//	Need to close the previous prop stat before more status node to be emitted
	//
	if (!csn.FEmpty())
	{
		//	The order is important, inner node must be closed first
		//
		sc = enPropOK.ScDone();
		if (FAILED(sc))
			goto ret;

		sc = enPropStat.ScDone();
		if (FAILED(sc))
			goto ret;

		sc = csn.ScEmitErrorStatus (enItem);
		if (FAILED(sc))
		goto ret;
	}

ret:
	return sc;
}

SCODE
CFSProp::ScGetAllProps (CXMLEmitter& msr,
	CEmitterNode& enItem,
	BOOL fFindValues)
{
	auto_com_ptr<IEnumSTATPROPBAG> penum;
	BOOL fContentType = FALSE;
	BOOL fHrefAdded = FALSE;
	SCODE sc = S_OK;
	UINT irp;
	CEmitterNode enPropStat;
	CEmitterNode enProp;

	//	There really should only be one scenario where this could happen
	//	-- and it is a cheap test, so it is worth doing.  The case where
	//	we might see an invalid pbag is when the document extisted, but
	//	there was no existing property set to impose the pbag on.  Other
	//	than that, OLE is always giving us a property bag, regardless of
	//	whether the target drive can support it.
	//
	if (!FInvalidPbag())
	{
		sc = m_pbag->Enum (NULL, 0, &penum);
		if (FAILED(sc))
		{
			//	AddHref was delayed to be done after local namespace is loaded
			//	but in this case, we know there'll be no local namespaces at all.
			//	so add href now
			//
			(void) ScAddHref (enItem,
							  m_pmu,
							  PwszPath(),
							  FCollection(),
							  PcvrTranslation());
			if ((sc == STG_E_INVALIDNAME) || !FIsVolumeNTFS())
			{
				//	This is the common path for when we are trying to access
				//	something over an SMB, but the host cannot support the
				//	request (it is not an NT5 NTFS machine).  We want to treat
				//	this as if the operation was against a FAT drive
				//
				sc = E_DAV_SMB_PROPERTY_ERROR;
				goto get_reserved;
			}
			goto ret;
		}

		//	We must preload all the potential namespaces in the <response> node,
		//	Note that the namespace for all reserved properties is "DAV:", which
		//	has been added already in CFSFind::ScLoadNamespace()
		//
		do
		{
			safe_statpropbag ssp[PROP_CHUNK_SIZE];
			ULONG csp = 0;
			UINT isp;

			//	Get next chunk of props
			//
			sc = penum->Next (PROP_CHUNK_SIZE, ssp[0].load(), &csp);
			if (FAILED(sc))
				goto ret;

			//	At this point, we either want to call the underlying
			//	property container to retrieve all the property data
			//	or we just want to emit the names.
			//
			for (isp = 0; isp < csp; isp++)
			{
				Assert (ssp[isp].get().lpwstrName);

				sc = msr.ScPreloadLocalNamespace (enItem.Pxn(), ssp[isp].get().lpwstrName);
				if (FAILED(sc))
					goto ret;
			}

		} while (sc != S_FALSE);


		//	Addhref must be done after all the local nmespaces has been emitted
		//
		sc = ScAddHref (enItem,
						m_pmu,
						PwszPath(),
						FCollection(),
						PcvrTranslation());
		if (FAILED (sc))
			goto ret;
		fHrefAdded = TRUE;

		//	Reset the enumerator back to the beginning
		//
		sc = penum->Reset();
		if (FAILED(sc))
			goto ret;

		//	Get the insert point for props
		//
		sc = ScGetPropNode (enItem, HSC_OK, enPropStat, enProp);
		if (FAILED(sc))
			goto ret;

		//	Enumerate the props and emit
		//
		do
		{
			safe_statpropbag ssp[PROP_CHUNK_SIZE];
			safe_propvariant propvar[PROP_CHUNK_SIZE];
			LPWSTR rglpwstr[PROP_CHUNK_SIZE] = {0};
			ULONG csp = 0;
			UINT isp;

			//	Get next chunk of props
			//
			sc = penum->Next (PROP_CHUNK_SIZE, ssp[0].load(), &csp);
			if (FAILED(sc))
				goto ret;

			//	At this point, we either want to call the underlying
			//	property container to retrieve all the property data
			//	or we just want to emit the names.
			//
			for (isp = 0; isp < csp; isp++)
			{
				Assert (ssp[isp].get().lpwstrName);

				//	We need to track whether or not the getcontenttype
				//	property was actually stored or not.  If it wasn't,
				//	then, we will want to default it at a later time.
				//
				if (!fContentType)
				{
					if (!wcscmp (ssp[isp].get().lpwstrName,
								 gc_wszProp_iana_getcontenttype))
					{
						//	Note that content-type is included
						//
						fContentType = TRUE;
					}
				}

				//	If we are just asking for names, then add the
				//	name to the list now...
				//
				if (!fFindValues)
				{
					CEmitterNode en;

					//	Add the result to the response
					//
					sc = enProp.ScAddNode (ssp[isp].get().lpwstrName, en);
					if (FAILED (sc))
						goto ret;
				}
				else
					rglpwstr[isp] = ssp[isp].get().lpwstrName;
			}

			//	If we are just asking about names, then we really
			//	are done with this group of properties, otherwise
			//	we need to generate the values and emit them.
			//
			if (!fFindValues)
				continue;

			//	Read properties in chunk
			//
			if (csp)
			{
				sc = m_pbag->ReadMultiple (csp,
										   rglpwstr,
										   propvar[0].addressof(),
										   NULL);
				if (FAILED (sc))
					goto ret;
			}

			//	Emit properties
			//
			for (isp = 0; isp < csp; isp++)
			{
				//	Contstruct the pel from the variant
				//
				sc = ScEmitFromVariant (msr,
										enProp,
										ssp[isp].get().lpwstrName,
										const_cast<PROPVARIANT&>(propvar[isp].get()));
				if (FAILED (sc))
					goto ret;
			}

		} while (sc != S_FALSE);
	}

get_reserved:

	//	Render all the reserved properties, this relies on the fact that
	//	the first non-GET reserved property is "DAV:getcontenttype".
	//
	Assert (iana_rp_content_type == sc_crp_get_reserved);

	if (!fHrefAdded)
	{
		//	Need to build the HREF node because it wasn't built above.
		//	This can happen when we don't have a pbag (like on FAT16).
		//
		sc = ScAddHref (enItem,
						m_pmu,
						PwszPath(),
						FCollection(),
						PcvrTranslation());
		if (FAILED (sc))
			goto ret;
	}

	if (!enProp.Pxn())
	{
		//	Get the insert point for props
		//
		sc = ScGetPropNode (enItem, HSC_OK, enPropStat, enProp);
		if (FAILED(sc))
			goto ret;

	}

	for (irp = 0; irp <= sc_crp_get_reserved; irp++)
	{
		//	If the content-type has already been processed, then
		//	don't do it here.
		//
		if ((irp == sc_crp_get_reserved) && fContentType)
			break;

		//	Construct the pel from the reserved property
		//
		sc = ScGetReservedProp (msr, enProp, irp, fFindValues);
		if (FAILED (sc))
			goto ret;
	}

	//	We are done with all the local namespaces
	//
	msr.DoneWithLocalNamespace();

ret:
	return sc;
}

SCODE
CFSProp::ScSetProps (CStatusCache& csn,
					 ULONG cProps,
					 LPCWSTR* rgwszProps,
					 PROPVARIANT* rgvProps)
{
	UINT ip;
	SCODE sc = S_OK;
	ULONG hsc;

	//	Zero props is a no-op
	//
	if (!cProps)
		return S_OK;

	Assert (!FInvalidPbag());
	sc = m_pbag->WriteMultiple (cProps, rgwszProps, rgvProps);
	if (FAILED(sc))
	{
		//	This is the common path for when we are trying to access
		//	something over an SMB, but the host cannot support the
		//	request (it is not an NT5 NTFS machine).
		//
		if ((sc == STG_E_INVALIDNAME) || !FIsVolumeNTFS())
			return E_DAV_SMB_PROPERTY_ERROR;
	}

	//	we don't know exactly which prop failed,
	//	return same error for all props
	//
	hsc = HscFromHresult(sc);
	for (ip = 0; ip < cProps; ip++)
	{
		sc = csn.ScAddErrorStatus (hsc, rgwszProps[ip]);
		if (FAILED(sc))
			goto ret;
	}

ret:
	return FAILED(sc) ? S_FALSE : S_OK;
}

SCODE
CFSProp::ScDeleteProps (CStatusCache& csn,
						ULONG cProps,
						LPCWSTR* rgwszProps)
{
	UINT ip;
	SCODE sc = S_OK;
	ULONG hsc;

	//	Zero props is a no-op
	//
	if (!cProps)
		return S_OK;

	Assert (!FInvalidPbag());
	sc = m_pbag->DeleteMultiple (cProps, rgwszProps, 0);
	if (FAILED(sc))
	{
		//	This is the common path for when we are trying to access
		//	something over an SMB, but the host cannot support the
		//	request (it is not an NT5 NTFS machine).
		//
		if ((sc == STG_E_INVALIDNAME) || !FIsVolumeNTFS())
			return E_DAV_SMB_PROPERTY_ERROR;
	}

	//	we don't know exactly which prop failed,
	//	return same error for all props
	//
	hsc = HscFromHresult(sc);
	for (ip = 0; ip < cProps; ip++)
	{
		sc = csn.ScAddErrorStatus (hsc, rgwszProps[ip]);
		if (FAILED(sc))
			goto ret;
	}

ret:
	return FAILED(sc) ? S_FALSE : S_OK;
}

SCODE
CFSProp::ScPersist ()
{
	//	We are not transacted now, just
	//
	return S_OK;
}

//	Content properties --------------------------------------------------------
//
SCODE
ScSetContentProperties (IMethUtil * pmu, LPCWSTR pwszPath, HANDLE hFile)
{
	LPCWSTR pwszContentType;
	LPCWSTR pwszContentLanguage;
	LPCWSTR pwszContentEncoding;

	SCODE sc = S_OK;

	//	Figure out which content properties we have
	//
	pwszContentType = pmu->LpwszGetRequestHeader (gc_szContent_Type, FALSE);
	pwszContentLanguage = pmu->LpwszGetRequestHeader (gc_szContent_Language, FALSE);
	pwszContentEncoding = pmu->LpwszGetRequestHeader (gc_szContent_Encoding, FALSE);

	//	Content-Type is special -- it is always set in the metabase.
	//	It should be set *before* setting any properties in the property bag
	//	since it's OK for the property bag stuff to fail.
	//
	if (NULL != pwszContentType)
	{
		//	Setting the content-type will not work if the metabase is read only,
		//	which is exactly what is happening in .NET server.  So we need to
		//	ignore the error -- if any.
		//
		(void) pmu->ScSetContentType (pmu->LpwszRequestUrl(), pwszContentType);
	}

	//	Set any content properties we have in the property bag
	//
	if (pwszContentLanguage || pwszContentEncoding)
	{
		auto_com_ptr<IPropertyBagEx> pbe;
		CStackBuffer<WCHAR> pwsz;

		//	Try to open the property bag.  If this fails because we're not
		//	on an NTFS filesystem, that's OK.  We just won't set the properties
		//	there.
		//
		//	We need to open propertybag by handle as it the main stream might
		//	be locked.
		//
		sc = ScGetPropertyBag (pwszPath,
							   STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
							   &pbe,
							   FALSE,	// not a collection
							   hFile);
		if (FAILED(sc))
		{
			//$	REVIEW:
			//
			//	We did our best here.  For DocFiles this will fail because
			//	of how we have to open the files.  What this means is that we
			//	could potentially lose the content-encoding and content-language
			//	which would put us on par with IIS (they don't store these either).
			//
			sc = S_OK;
			goto ret;
		}

		CResourceInfo cri;
		CFSProp xpt(pmu,
					pbe,
					pmu->LpwszRequestUrl(),
					pwszPath,
					NULL,
					cri);

		//	Content-Type
		//
		if (NULL != pwszContentType)
		{
			sc = xpt.ScSetStringProp (sc_rp[iana_rp_content_type].pwsz, pwszContentType);
			if (FAILED (sc))
				goto ret;
		}

		//	Content-Language
		//
		if (NULL != pwszContentLanguage)
		{
			sc = xpt.ScSetStringProp (sc_rp[iana_rp_content_language].pwsz, pwszContentLanguage);
			if (FAILED (sc))
				goto ret;
		}

		//	Content-Encoding
		//
		if (NULL != pwszContentEncoding)
		{
			sc = xpt.ScSetStringProp (sc_rp[iana_rp_content_encoding].pwsz, pwszContentEncoding);
			if (FAILED (sc))
				goto ret;
		}

		//	Persist the changes
		//
		sc = xpt.ScPersist();
		if (FAILED(sc))
			goto ret;
	}

ret:

	//	It is perfectly OK to ignore SMB errors when setting content properties.
	//
	if (sc == E_DAV_SMB_PROPERTY_ERROR)
		sc = S_OK;

	return sc;
}


//	ScFindFileProps -----------------------------------------------------------
//
SCODE
ScFindFileProps (IMethUtil* pmu,
				 CFSFind& cfc,
				 CXMLEmitter& msr,
				 LPCWSTR pwszUri,
				 LPCWSTR pwszPath,
				 CVRoot* pcvrTranslation,
				 CResourceInfo& cri,
				 BOOL fEmbedErrorsInResponse)
{
	auto_com_ptr<IPropertyBagEx> pbag;
	CFSProp fsp(pmu, pbag, pwszUri, pwszPath, pcvrTranslation, cri);
	SCODE sc = S_OK;

	//	Check access permission
	//
	sc = pmu->ScCheckMoveCopyDeleteAccess (pwszUri,
										   pcvrTranslation,
										   cri.FCollection(),
										   FALSE, // do not check against scriptmaps
										   MD_ACCESS_READ);
	if (FAILED (sc))
	{
		//	No permission to read, we certainly do not want
		//	to try and traverse down into the directory (if
		//	it was one), we do this by returning S_FALSE.
		//
		if (fEmbedErrorsInResponse)
		{
			sc = cfc.ScErrorAllProps (msr,
									  pmu,
									  pwszPath,
									  cri.FCollection(),
									  pcvrTranslation,
									  sc);
			if (FAILED (sc))
				goto ret;

			//	Pass back S_FALSE so that no further traversal of
			//	this resource is performed
			//
			sc = S_FALSE;
		}
		if (S_OK != sc)
			goto ret;
	}

	//	Don't get pbag for remote files. This would cause the files to
	//	be recalled, etc.
	//
	if (!cri.FRemote())
	{
		//	Get the IPropertyBagEx interface
		//
		//	Before call into this function, we've checked we have read access to
		//	this file. so we should always be able to read the proerties however,
		//	if the file is write locked, there may be some problems from the OLE
		//	properties code.
		//
		sc = ScGetPropertyBag (pwszPath,
							   STGM_READ | STGM_SHARE_DENY_WRITE,
							   &pbag,
							   cri.FCollection());
		if (FAILED (sc))
		{
			//	We need to check the volume of the file we are trying
			//	to read.
			//
			if (VOLTYPE_NTFS == VolumeType (pwszPath, pmu->HitUser()))
			{
				//	Report the errors for this file and come on back...
				//
				if (fEmbedErrorsInResponse)
				{
					sc = cfc.ScErrorAllProps (msr,
											  pmu,
											  pwszPath,
											  cri.FCollection(),
											  pcvrTranslation,
											  sc);
				}
				goto ret;
			}
		}
	}

	//	Find the properties
	//
	sc = cfc.ScFind (msr, pmu, fsp);
	if (FAILED (sc))
		goto ret;

ret:

	return sc;
}

SCODE
ScFindFilePropsDeep (IMethUtil* pmu,
					 CFSFind& cfc,
					 CXMLEmitter& msr,
					 LPCWSTR pwszUri,
					 LPCWSTR pwszPath,
					 CVRoot* pcvrTranslation,
					 LONG lDepth)
{
	BOOL fSubDirectoryAccess = TRUE;
	SCODE sc = S_OK;

	//	Query subdirs when do deep query
	//
	Assert ((lDepth == DEPTH_ONE) ||
			(lDepth == DEPTH_ONE_NOROOT) ||
			(lDepth == DEPTH_INFINITY));

	CDirIter di(pwszUri,
				pwszPath,
				NULL,	// no destination url
				NULL,	// no destination path
				NULL,	// no destination translation
				lDepth == DEPTH_INFINITY);

	while (S_OK == (sc = di.ScGetNext (fSubDirectoryAccess)))
	{
		CResourceInfo cri;

		//	If we found another directory, then iterate on it
		//
		fSubDirectoryAccess = FALSE;
		if (di.FDirectory())
		{
			auto_ref_ptr<CVRoot> arp;

			//	Skip the special and/or hidden directories
			//
			if (di.FSpecial())
				continue;

			//	If we happen to traverse into a directory
			//	that happens to be a vroot (as identified
			//	by url), then there is another entry in
			//	the list of child vroots that will refer
			//	to this directory.  Let that processing
			//	handle this directory instead of the
			//	doing it here.
			//
			//	This means that the file hierarchy is not
			//	strictly preserved, but I think that this
			//	is OK.
			//
			if (pmu->FFindVRootFromUrl (di.PwszUri(), arp))
				continue;

			//	Check the directory browsing bit and see
			//	if it is enabled.  And only progess down
			//	if it is set.
			//
			{
				auto_ref_ptr<IMDData> pMDData;
				if (SUCCEEDED(pmu->HrMDGetData (di.PwszUri(), pMDData.load())) &&
					(pMDData->DwDirBrowsing() & MD_DIRBROW_ENABLED))
				{
					//	Prepare to go into the subdir
					//
					fSubDirectoryAccess = TRUE;
				}
			}
		}

		//	Find the properties for the resource
		//
		*cri.PfdLoad() = di.FindData();
		sc = ScFindFileProps (pmu,
							  cfc,
							  msr,
							  di.PwszUri(),
							  di.PwszSource(),
							  pcvrTranslation,
							  cri,
							  TRUE /*fEmbedErrorsInResponse*/);
		if (FAILED (sc))
			goto ret;

		//	S_FALSE is a special return code that
		//	means we did not have access to read the
		//	resource...
		//
		if (sc == S_FALSE)
		{
			//	... and since we really didn't have access,
			//	we don't want to delve into the children of
			//	the resource.
			//
			fSubDirectoryAccess = FALSE;
		}
	}

ret:

	return sc;
}

//	ScCopyProps ---------------------------------------------------------------
//
/*
 *	ScCopyProps()
 *
 *	Purpose:
 *
 *		Copies the properties from one resource to another.  This is
 *		really only useful for copying full directories.  Standard file
 *		copies do the dirty work for us, but for directories, we need to
 *		do it ourselves.
 *		If we don't find any propstream on the source, we DELETE
 *		any propstream on the destination.
 */
SCODE
ScCopyProps (IMethUtil* pmu, LPCWSTR pwszSrc, LPCWSTR pwszDst,
			BOOL fCollection, HANDLE hSource, HANDLE hDest)
{
	enum { CHUNK_SIZE = 16 };

	auto_com_ptr<IPropertyBagEx> pbeSrc;
	auto_com_ptr<IPropertyBagEx> pbeDst;
	auto_com_ptr<IEnumSTATPROPBAG> penumSrc;
	auto_com_ptr<IEnumSTATPROPBAG> penumDst;

	SCODE sc;
	SCODE scEnum;
	ULONG cProp;

	MCDTrace ("Dav: MCD: copying props manually: %ws -> %ws\n", pwszSrc, pwszDst);

	//	Get the IPropertyBagEx on the source
	//
	sc = ScGetPropertyBag (pwszSrc,
						   STGM_READ | STGM_SHARE_DENY_WRITE,
						   &pbeSrc,
						   fCollection,
						   hSource);
	if (sc != S_OK)
		goto ret;

	MCDTrace ("Dav: MCD: opened source property bag: %ws\n", pwszSrc);

	//	Get the IPropertyBagEx on the destination
	//
	sc = ScGetPropertyBag (pwszDst,
						   STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
						   &pbeDst,
						   fCollection,
						   hDest);
	if (FAILED(sc))
		goto ret;

	MCDTrace ("Dav: MCD: opened destination property bag: %ws\n", pwszDst);

	//	Get the IEnumSTATPROPBAG interface on source
	//
	sc = pbeSrc->Enum (NULL, 0, &penumSrc);
	if (FAILED(sc))
		goto ret;

	//	Get the IEnumSTATPROPBAG interface on destination
	//
	sc = pbeDst->Enum (NULL, 0, &penumDst);
	if (FAILED(sc))
		goto ret;

	//	Delete all props from destination if there's any
	//$ COME BACK
	//$ Instead of delete props one by one, we can just delete the
	//	prop stream.
	//
	for (;;)
	{
		safe_statpropbag ssp[CHUNK_SIZE];
		safe_propvariant propvar[CHUNK_SIZE];
		ULONG csp = 0;

		//	Get next chunk of props
		//
		Assert (sizeof(safe_statpropbag) == sizeof(STATPROPBAG));
		scEnum = penumDst->Next(CHUNK_SIZE,
								reinterpret_cast<STATPROPBAG *>(&ssp[0]),
								&csp);
		if (FAILED(scEnum))
		{
			sc = scEnum;
			goto ret;
		}

		MCDTrace ("Dav: MCD: copying %ld props\n", csp);

		// 	Delete one by one
		//
		for (cProp = 0; cProp < csp; cProp++)
		{
			Assert (ssp[cProp].get().lpwstrName);

			//	Write to the destination
			//
			LPCWSTR pwsz = ssp[cProp].get().lpwstrName;
			sc = pbeDst->DeleteMultiple (1, &pwsz, 0);
			if (FAILED(sc))
				goto ret;
		}

		if (scEnum == S_FALSE)
			break;
	}

	//	Enumerate the props and emit
	//
	for (;;)
	{
		safe_statpropbag ssp[CHUNK_SIZE];
		safe_propvariant propvar[CHUNK_SIZE];
		LPWSTR rglpwstr[CHUNK_SIZE] = {0};
		ULONG csp = 0;

		//	Get next chunk of props
		//
		Assert (sizeof(safe_statpropbag) == sizeof(STATPROPBAG));
		scEnum = penumSrc->Next (CHUNK_SIZE,
								 reinterpret_cast<STATPROPBAG *>(&ssp[0]),
								 &csp);
		if (FAILED(scEnum))
		{
			sc = scEnum;
			goto ret;
		}

		// 	Prepare to call read multiple props
		//
		for (cProp=0; cProp<csp; cProp++)
		{
			Assert (ssp[cProp].get().lpwstrName);
			rglpwstr[cProp] = ssp[cProp].get().lpwstrName;
		}

		if (csp)
		{
			//	Read properties in chunk from source
			//
			sc = pbeSrc->ReadMultiple (csp, rglpwstr, &propvar[0], NULL);
			if (FAILED(sc))
				goto ret;

			//	Write to the destination
			//
			sc = pbeDst->WriteMultiple (csp, rglpwstr, propvar[0].addressof());
			if (FAILED(sc))
				goto ret;
		}

		if (scEnum == S_FALSE)
			break;
	}


ret:

	//	Copying properties is a harmless failure that
	//	we should feel free to ignore if we are not on
	//	an NFTS volume
	//
	if (FAILED(sc))
	{
		if ((sc == STG_E_INVALIDNAME) ||
			VOLTYPE_NTFS != VolumeType (pwszSrc, pmu->HitUser()) ||
			VOLTYPE_NTFS != VolumeType (pwszDst, pmu->HitUser()))
		{
			//	This is the common path for when we are trying to access
			//	something over an SMB, but the host cannot support the
			//	request (it is not an NT5 NTFS machine).
			//
			sc = S_OK;
		}
	}
	return sc;
}

//	OLE 32 IPropertyBagEx Access ----------------------------------------------
//
//	StgOpenStorageOnHandle() and StgCreateStorageOnHandle() are implemented
//	in OLE32.DLL but not exported.  We must load the library and get the proc
//	instances ourselves.  We wrap the calls to these functions with this small
//	wrapper such that we can catch when the API changes.
//
STDAPI
StgOpenStorageOnHandle (
	IN HANDLE hStream,
    IN DWORD grfMode,
    IN void *reserved1,
    IN void *reserved2,
    IN REFIID riid,
    OUT void **ppObjectOpen )
{
	Assert (g_pfnStgOpenStorageOnHandle);

	//	Yes, we've asserted.
	//	However, if it does happen, we don't want to fail and we can
	//	just treat this like we are on a FAT. (i.e. no property support)
	//
	if (!g_pfnStgOpenStorageOnHandle)
		return E_DAV_SMB_PROPERTY_ERROR;

	return (*g_pfnStgOpenStorageOnHandle) (hStream,
										   grfMode,
										   reserved1,
										   reserved2,
										   riid,
										   ppObjectOpen);
}


//	ScGetPropertyBag() --------------------------------------------------------
//
//	Helper function used to get IPropertyBagEx interface.  The important
//	thing to know about this function is that there are three interesting
//	return values:
//
//		S_OK means everything was OK, and there should be a
//		propertybag associated with the file in the out param.
//
//		S_FALSE means that the file did not exist.  There will
//		not be an associated property bag in that scenario.
//
//		FAILED(sc) means that there was a failure of some sort,
//		not all of which are fatal.  In many cases, we will simply
//		treat the file as if it was hosted on a FAT file system.
//
SCODE
ScGetPropertyBag (LPCWSTR pwszPath,
	DWORD dwAccessDesired,
	IPropertyBagEx** ppbe,
	BOOL fCollection,
	HANDLE hLockFile)
{
	SCODE sc = S_OK;
	auto_handle<HANDLE> hAlt;

	//	READ!!
	//
	//	The storage of property bag is different between docfile and flat file,
	//	In a flat file, the property bag is stored in an alternative file stream,
	//	(currently, ":Docf_\005Bagaaqy23kudbhchAaq5u2chNd"), in a docfile, the
	//	property bag is stored as a substream under the root storage.
	//
	//	We should not be concerned with where the pbag is stored.  The API with
	//	which we implement our IPropertyBagEx access is designed to have the
	//	behavior of...
	//
	//		We pass in a handle to the file that we want to get a property bag
	//		on.  If the file is a docfile, then OLE32 will dup the file handle
	//		and impose a IPropertyBagEx on the appropriate substorage.  If the
	//		file is a flat file -- directories included -- then OLE32 opens up
	//		a handle on the alternate file stream relative to the handle given
	//		in the call.
	//
	//	These are the only two combinations allowed, and we rely on this in the
	//	following flag checks.
	//
	Assert ((dwAccessDesired == (STGM_READWRITE | STGM_SHARE_EXCLUSIVE)) ||
			(dwAccessDesired == (STGM_READ | STGM_SHARE_DENY_WRITE)));

	if (hLockFile == INVALID_HANDLE_VALUE)
	{
		ULONG dwShare = 0;
		ULONG dwAccess;
		ULONG dwOpen;
		ULONG dwFile;

		//$	REVIEW: Directories are special critters and we need to
		//	open the directory with special access as not to conflict
		//	with IIS and/or ASP and their directory change notification
		//	stuff
		//
		if (fCollection)
		{
			dwAccess = 1;	// FILE_LIST_DIRECTORY
			dwShare = FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE;
			dwOpen = OPEN_EXISTING;

			//	The FILE_FLAG_BACKUP_SEMANTICS is used to open a directory handle
			//
			dwFile = FILE_FLAG_BACKUP_SEMANTICS|FILE_FLAG_OVERLAPPED;
		}
		else
		{
			//	Adjust access/open mode based on desired operation
			//
			dwAccess = GENERIC_READ;
			dwFile = FILE_ATTRIBUTE_NORMAL;
			if (dwAccessDesired & STGM_READWRITE)
			{
				dwAccess |= GENERIC_WRITE;
				dwOpen = OPEN_ALWAYS;
			}
			else
				dwOpen = OPEN_EXISTING;

			//	Adjust the sharing modes as well
			//
			if (dwAccessDesired & STGM_SHARE_DENY_WRITE)
				dwShare = FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE;
		}
		hAlt = DavCreateFile (pwszPath,
							  dwAccess,
							  dwShare,
							  NULL,
							  dwOpen,
							  dwFile,
							  NULL);
		if (INVALID_HANDLE_VALUE == hAlt.get())
		{
			DWORD dwErr = GetLastError();

			//	When open the property bag for read (PROPFIND), ERROR_FILE/PATH_NOT_FOUND
			//	could be returned if the file does not exists.
			//
			//	When open the property bag for write (PROPPATCH), ERROR_FILE/PATH_NOT_FOUND
			//	Could still be returned if the parent of the path does not exists
			//	(Such as c:\x\y\z and \x\y does not exist).
			//
			//	We need to differenciate the above two cases, when reading a file,
			//	it's not a fatal error as you could still try to read reserved
			//	properties, when write, we should treat this as a fatal error.
			//
			if ((dwErr == ERROR_FILE_NOT_FOUND) || (dwErr == ERROR_PATH_NOT_FOUND))
			{
				//	It's not a fatal error when read
				//
				if (dwAccessDesired == (STGM_READ|STGM_SHARE_DENY_WRITE))
					sc = S_FALSE;
				else
				{
					//	This is consistent with Mkcol, it will be mapped to 409
					//
					Assert (dwAccessDesired == (STGM_READWRITE|STGM_SHARE_EXCLUSIVE));
					sc = E_DAV_NONEXISTING_PARENT;
				}
			}
			else
				sc = HRESULT_FROM_WIN32 (dwErr);

			goto ret;
		}

		//	Setup the handle to use
		//
		hLockFile = hAlt.get();
	}

	//	Try to open the propertybag.
	//
	Assert (hLockFile != 0);
	Assert (hLockFile != INVALID_HANDLE_VALUE);
	sc = StgOpenStorageOnHandle (hLockFile,
								 dwAccessDesired,
								 NULL,
								 NULL,
								 IID_IPropertyBagEx,
								 reinterpret_cast<LPVOID *>(ppbe));
	if (FAILED (sc))
	{
		goto ret;
	}

	//$	WARNING
	//
	//	Argh!  The current implementation of OLE32 returns a non-failure
	//	with a NULL property bag!
	//
	if (*ppbe == NULL)
	{
		DebugTrace ("WARNING! OLE32 returned success w/NULL object!\n");
		sc = E_DAV_SMB_PROPERTY_ERROR;
	}

ret:
	return sc;
}

//	DAV-Properties Implementation ---------------------------------------------------
//

//	CPropFindRequest ----------------------------------------------------------------
//
class CPropFindRequest :
	public CMTRefCounted,
	private IAsyncIStreamObserver
{
	//
	//	Reference to the CMethUtil
	//
	auto_ref_ptr<CMethUtil> m_pmu;

	//
	//	Translated URI path
	//
	LPCWSTR m_pwszPath;

	//	Resource info
	//
	CResourceInfo m_cri;

	//	Depth
	//
	LONG m_lDepth;

	//	Contexts
	//
	CFSFind m_cfc;
	auto_ref_ptr<CNFFind> m_pcpf;

	//	Request body as an IStream.  This stream is async -- it can
	//	return E_PENDING from Read() calls.
	//
	auto_ref_ptr<IStream> m_pstmRequest;

	//	The XML parser used to parse the request body using
	//	the node factory above.
	//
	auto_ref_ptr<IXMLParser> m_pxprs;

	//	IAsyncIStreamObserver
	//
	VOID AsyncIOComplete();

	//	State functions
	//
	VOID ParseBody();
	VOID DoFind();
	VOID SendResponse( SCODE sc );

	//	NOT IMPLEMENTED
	//
	CPropFindRequest (const CPropFindRequest&);
	CPropFindRequest& operator= (const CPropFindRequest&);

public:
	//	CREATORS
	//
	CPropFindRequest(LPMETHUTIL pmu) :
		m_pmu(pmu),
		m_pwszPath(m_pmu->LpwszPathTranslated()),
		m_lDepth(DEPTH_INFINITY)
	{
	}

	//	MANIPULATORS
	//
	VOID Execute();
};

VOID
CPropFindRequest::Execute()
{
	auto_ref_handle hf;
	LPCWSTR pwsz;
	SCODE sc = S_OK;

	//
	//	First off, tell the pmu that we want to defer the response.
	//	Even if we send it synchronously (i.e. due to an error in
	//	this function), we still want to use the same mechanism that
	//	we would use for async.
	//
	m_pmu->DeferResponse();

	//	Do ISAPI application and IIS access bits checking
	//
	sc = m_pmu->ScIISCheck (m_pmu->LpwszRequestUrl(), MD_ACCESS_READ);
	if (FAILED(sc))
	{
		//	Either the request has been forwarded, or some bad error occurred.
		//	In either case, quit here and map the error!
		//
		SendResponse(sc);
		return;
	}

	//	For PropFind, content-length is required
	//
	//
	if (NULL == m_pmu->LpwszGetRequestHeader (gc_szContent_Length, FALSE))
	{
		pwsz = m_pmu->LpwszGetRequestHeader (gc_szTransfer_Encoding, FALSE);
		if (!pwsz || _wcsicmp (pwsz, gc_wszChunked))
		{
			DavTrace ("Dav: PUT: missing content-length in request\n");
			SendResponse(E_DAV_MISSING_LENGTH);
			return;
		}
	}

	//	Ensure the resource exists
	//
	sc = m_cri.ScGetResourceInfo (m_pwszPath);
	if (FAILED (sc))
	{
		SendResponse(sc);
		return;
	}

	//	Depth header only applies on directories
	//
	if (m_cri.FCollection())
	{
		//	Check the depth header only on collections
		//
		if (!FGetDepth (m_pmu.get(), &m_lDepth))
		{
			//	If Depth header is wrong, fail the operation
			//
			SendResponse(E_INVALIDARG);
			return;
		}
	}

	//	This method is gated by If-xxx headers
	//
	sc = ScCheckIfHeaders (m_pmu.get(), m_cri.PftLastModified(), FALSE);
	if (FAILED (sc))
	{
		SendResponse(sc);
		return;
	}

	//	Ensure the URI and resource match
	//
	(void) ScCheckForLocationCorrectness (m_pmu.get(), m_cri, NO_REDIRECT);

	//	Check state headers here.
	//
	//	For PROPFIND, when we check the state headers,
	//	we want to treat the request as if it were a
	//	GET-type request.
	//
	sc = HrCheckStateHeaders (m_pmu.get(), m_pwszPath, TRUE);
	if (FAILED (sc))
	{
		DebugTrace ("DavFS: If-State checking failed.\n");
		SendResponse(sc);
		return;
	}

	//	Handle locktokens and check for locks on this resource.
	//	Our locks don't lock the "secondary file stream" where we keep
	//	the properties, so we have to check manually before we do anything else.
	//$REVIEW: Joels, will this change when we switch to NT5 properties?
	//$REVIEW: If so, we need to change this code!
	//
	//	If we have a locktoken, try to get the lock handle from the cache.
	//	If this fails, fall through and do the normal processing.
	//
	pwsz = m_pmu->LpwszGetRequestHeader (gc_szLockToken, TRUE);
	if (!pwsz || !FGetLockHandle (m_pmu.get(), m_pwszPath, GENERIC_READ, pwsz, &hf))
	{
		//	Manually check for locks on this resource.
		//	(see if someone ELSE has it locked...)
		//	If a read lock exists, tell the caller that it's locked.
		//
		if (FLockViolation (m_pmu.get(), ERROR_SHARING_VIOLATION, m_pwszPath, GENERIC_READ))
		{
			SendResponse(E_DAV_LOCKED);
			return;
		}
	}

	//	If there was no request body, we want to get all props
	//
	if (!m_pmu->FExistsRequestBody())
	{
		sc = m_cfc.ScGetAllProps (m_pwszPath);
		if (FAILED (sc))
		{
			SendResponse(sc);
			return;
		}

		DoFind();
		return;
	}
	else
	{
		//	If there's a body, there must be a content-type header
		//	and the value must be text/xml
		//
		sc = ScIsContentTypeXML (m_pmu.get());
		if (FAILED(sc))
		{
			DebugTrace ("Dav: PROPFIND specific fails without specifying a text/xml contenttype\n");
			SendResponse(sc);
			return;
		}
	}

	//	Instantiate the XML parser
	//
	m_pcpf.take_ownership(new CNFFind(m_cfc));
	m_pstmRequest.take_ownership(m_pmu->GetRequestBodyIStream(*this));

	sc = ScNewXMLParser( m_pcpf.get(),
						 m_pstmRequest.get(),
						 m_pxprs.load() );

	if (FAILED(sc))
	{
		DebugTrace( "CPropFindRequest::Execute() - ScNewXMLParser() failed (0x%08lX)\n", sc );
		SendResponse(sc);
		return;
	}

	//	Parse the body
	//
	ParseBody();
}

VOID
CPropFindRequest::ParseBody()
{
	SCODE sc;

	Assert( m_pxprs.get() );
	Assert( m_pcpf.get() );
	Assert( m_pstmRequest.get() );

	//	Parse XML from the request body stream.
	//
	//	Add a ref for the following async operation.
	//	Use auto_ref_ptr rather than AddRef() for exception safety.
	//
	auto_ref_ptr<CPropFindRequest> pRef(this);

	sc = ScParseXML (m_pxprs.get(), m_pcpf.get());

	if ( SUCCEEDED(sc) )
	{
		Assert( S_OK == sc || S_FALSE == sc );

		DoFind();
	}
	else if ( E_PENDING == sc )
	{
		//
		//	The operation is pending -- AsyncIOComplete() will take ownership
		//	ownership of the reference when it is called.
		//
		pRef.relinquish();
	}
	else
	{
		DebugTrace( "CPropFindRequest::ParseBody() - ScParseXML() failed (0x%08lX)\n", sc );
		SendResponse(sc);
	}
}

VOID
CPropFindRequest::AsyncIOComplete()
{
	//	Take ownership of the reference added for the async operation.
	//
	auto_ref_ptr<CPropFindRequest> pRef;
	pRef.take_ownership(this);

	ParseBody();
}

VOID
CPropFindRequest::DoFind()
{
	LPCWSTR pwszUrl = m_pmu->LpwszRequestUrl();
	SCODE sc;

	//	At this point, make sure that they support text/xml
	//
	sc = ScIsAcceptable (m_pmu.get(), gc_wszText_XML);
	if (FAILED (sc))
	{
		SendResponse(sc);
		return;
	}

	//	All header must be emitted before chunked XML emitting starts
	//
	m_pmu->SetResponseHeader (gc_szContent_Type, gc_szText_XML);

	//	Set the response code and go
	//
	m_pmu->SetResponseCode( HscFromHresult(W_DAV_PARTIAL_SUCCESS),
							NULL,
							0,
							CSEFromHresult(W_DAV_PARTIAL_SUCCESS) );

	//	Find the properties...
	//
	auto_ref_ptr<CXMLEmitter> pmsr;
	auto_ref_ptr<CXMLBody> pxb;

	pxb.take_ownership (new CXMLBody(m_pmu.get()));
	pmsr.take_ownership (new CXMLEmitter(pxb.get(), &m_cfc));

	if (DEPTH_ONE_NOROOT != m_lDepth)
	{
		//	Get properties for root if it is not a noroot case
		//	Depth infinity,noroot is a bad request, that is why
		//	check above is valid.
		//
		sc = ScFindFileProps (m_pmu.get(),
							  m_cfc,
							  *pmsr,
							  pwszUrl,
							  m_pwszPath,
							  NULL,
							  m_cri,
							  FALSE /*fEmbeddErrorsInResponse*/);
		if (FAILED (sc))
		{
			SendResponse(sc);
			return;
		}
	}

	//	ScFindFilePropsDeep initializes the emitter root only
	//	when it sees there's an entry to emit. so we crash
	//	in the noroot empty response case, when we try to emit
	//	the response, as we have no entry to emit and the
	//	root is still NULL.
	//	so we here manually initialize the root,
	//
	sc = pmsr->ScSetRoot (gc_wszMultiResponse);
	if (FAILED (sc))
	{
		SendResponse(sc);
		return;
	}

	//	And then, if apropriate, go deep...
	//
	if (m_cri.FCollection() &&
		(m_lDepth != DEPTH_ZERO) &&
		(m_pmu->MetaData().DwDirBrowsing() & MD_DIRBROW_ENABLED))
	{
		ChainedStringBuffer<WCHAR> sb;
		CVRList vrl;

		//	Apply the property request across all the physical children
		//
		sc = ScFindFilePropsDeep (m_pmu.get(),
								  m_cfc,
								  *pmsr,
								  pwszUrl,
								  m_pwszPath,
								  NULL,
								  m_lDepth);
		if (FAILED (sc))
		{
			SendResponse(sc);
			return;
		}

		//	Enumerate the child vroots and perform the
		//	deletion of those directories as well
		//
		m_pmu->ScFindChildVRoots (pwszUrl, sb, vrl);
		for ( ; (!FAILED (sc) && !vrl.empty()); vrl.pop_front())
		{
			auto_ref_ptr<CVRoot> cvr;
			LPCWSTR pwszChildUrl;
			LPCWSTR pwszChildPath;

			if (m_pmu->FGetChildVRoot (vrl.front().m_pwsz, cvr))
			{
				//	Put the url into a multibyte string
				//
				cvr->CchGetVRoot (&pwszChildUrl);

				//	Only process the sub-vroot if we are
				//	truely are going deep or if the sub-vroot
				//	is the immediate child of the request URI
				//
				if ((m_lDepth == DEPTH_INFINITY) ||
					FIsImmediateParentUrl (pwszUrl, pwszChildUrl))
				{
					CResourceInfo criSub;

					//	Crack the vroot and go...
					//
					cvr->CchGetVRPath (&pwszChildPath);
					sc = criSub.ScGetResourceInfo (pwszChildPath);
					if (!FAILED (sc))
					{
						//	Find the properties on the vroot root
						//
						sc = ScFindFileProps (m_pmu.get(),
											  m_cfc,
											  *pmsr,
											  pwszChildUrl,
											  pwszChildPath,
											  cvr.get(),
											  criSub,
											  TRUE /*fEmbedErrorsInResponse*/);
					}
					if (FAILED (sc))
					{
						SendResponse(sc);
						return;
					}
					else if (S_FALSE == sc)
						continue;

					//	Find the properties on the vroot kids
					//
					if (m_lDepth == DEPTH_INFINITY)
					{
						auto_ref_ptr<IMDData> pMDData;

						//	See if we have directory browsing...
						//
						if (SUCCEEDED(m_pmu->HrMDGetData (pwszChildUrl, pMDData.load())) &&
							(pMDData->DwDirBrowsing() & MD_DIRBROW_ENABLED))
						{
							sc = ScFindFilePropsDeep (m_pmu.get(),
								m_cfc,
								*pmsr,
								pwszChildUrl,
								pwszChildPath,
								cvr.get(),
								m_lDepth);

							if (FAILED (sc))
							{
								SendResponse(sc);
								return;
							}
						}
					}
				}
			}
		}
	}


	//	Done with the reponse
	//
	pmsr->Done();
	m_pmu->SendCompleteResponse();
}

VOID
CPropFindRequest::SendResponse( SCODE sc )
{
	//
	//	Set the response code and go
	//
	m_pmu->SetResponseCode( HscFromHresult(sc), NULL, 0, CSEFromHresult(sc) );
	m_pmu->SendCompleteResponse();
}

/*
 *	DAVPropFind()
 *
 *	Purpose:
 *
 *		Win32 file system implementation of the DAV PROPGET method.	 The
 *		PROPGET method responds with a fully constructed XML that provides
 *		the values of the resources property/properties.
 *
 *	Parameters:
 *
 *		pmu			[in]  pointer to the method utility object
 */
void
DAVPropFind (LPMETHUTIL pmu)
{
	auto_ref_ptr<CPropFindRequest> pRequest(new CPropFindRequest(pmu));

	pRequest->Execute();
}


//	CPropPatchRequest ----------------------------------------------------------------
//
class CPropPatchRequest :
	public CMTRefCounted,
	private IAsyncIStreamObserver
{
	//
	//	Reference to the CMethUtil
	//
	auto_ref_ptr<CMethUtil> m_pmu;

	//
	//	Translated URI path
	//
	LPCWSTR m_pwszPath;

	// Holds a handle owned by the lock cache.
	//
	auto_ref_handle m_hf;

	//	Resource info
	//
	CResourceInfo m_cri;

	//	Contexts
	//
	CFSPatch m_cpc;
	auto_ref_ptr<CNFPatch> m_pnfp;

	//	Request body as an IStream.  This stream is async -- it can
	//	return E_PENDING from Read() calls.
	//
	auto_ref_ptr<IStream> m_pstmRequest;

	//	The XML parser used to parse the request body using
	//	the node factory above.
	//
	auto_ref_ptr<IXMLParser> m_pxprs;

	//	IAsyncIStreamObserver
	//
	VOID AsyncIOComplete();

	//	State functions
	//
	VOID ParseBody();
	VOID DoPatch();
	VOID SendResponse( SCODE sc );

	//	NOT IMPLEMENTED
	//
	CPropPatchRequest (const CPropPatchRequest&);
	CPropPatchRequest& operator= (const CPropPatchRequest&);

public:
	//	CREATORS
	//
	CPropPatchRequest(LPMETHUTIL pmu) :
		m_pmu(pmu),
		m_pwszPath(m_pmu->LpwszPathTranslated())
	{
	}

	SCODE	ScInit() { return m_cpc.ScInit(); }

	//	MANIPULATORS
	//
	VOID Execute();
};

VOID
CPropPatchRequest::Execute()
{
	LPCWSTR pwsz;
	SCODE sc = S_OK;

	//
	//	First off, tell the pmu that we want to defer the response.
	//	Even if we send it synchronously (i.e. due to an error in
	//	this function), we still want to use the same mechanism that
	//	we would use for async.
	//
	m_pmu->DeferResponse();

	//	Do ISAPI application and IIS access bits checking
	//
	sc = m_pmu->ScIISCheck (m_pmu->LpwszRequestUrl(), MD_ACCESS_WRITE);
	if (FAILED(sc))
	{
		//	Either the request has been forwarded, or some bad error occurred.
		//	In either case, quit here and map the error!
		//
		SendResponse(sc);
		return;
	}

	//	PropPatch must have a content-type header and the value must be text/xml
	//
	sc = ScIsContentTypeXML (m_pmu.get());
	if (FAILED(sc))
	{
		DebugTrace ("Dav: PROPPATCH fails without specifying a text/xml contenttype\n");
		SendResponse(sc);
		return;
	}

	//  Look to see the Content-length - required for this operation
	//  to continue.
	//
	if (NULL == m_pmu->LpwszGetRequestHeader (gc_szContent_Length, FALSE))
	{
		DebugTrace ("Dav: PROPPATCH fails without content\n");
		SendResponse(E_DAV_MISSING_LENGTH);
		return;
	}
	if (!m_pmu->FExistsRequestBody())
	{
		DebugTrace ("Dav: PROPPATCH fails without content\n");
		SendResponse(E_INVALIDARG);
		return;
	}

	//	This method is gated by If-xxx headers
	//
	if (!FAILED (m_cri.ScGetResourceInfo (m_pwszPath)))
	{
		//	Ensure the URI and resource match...
		//
		(void) ScCheckForLocationCorrectness (m_pmu.get(), m_cri, NO_REDIRECT);

		//	... then check the headers
		//
		sc = ScCheckIfHeaders (m_pmu.get(), m_cri.PftLastModified(), FALSE);
	}
	else
		sc = ScCheckIfHeaders (m_pmu.get(), m_pwszPath, FALSE);

	if (FAILED (sc))
	{
		SendResponse(sc);
		return;
	}

	//	Check state headers here.
	//
	sc = HrCheckStateHeaders (m_pmu.get(), m_pwszPath, FALSE);
	if (FAILED (sc))
	{
		DebugTrace ("DavFS: If-State checking failed.\n");
		SendResponse(sc);
		return;
	}

	//	Handle locktokens and check for locks on this resource.
	//	Our locks don't lock the "secondary file stream" where we keep
	//	the properties, so we have to check manually before we do anything else.
	//$REVIEW: Joels, will this change when we switch to NT5 properties?
	//$REVIEW: If so, we need to change this code!
	//
	//	If we have a locktoken, try to get the lock handle from the cache.
	//	If this fails, fall through and do the normal processing.
	//
	pwsz = m_pmu->LpwszGetRequestHeader (gc_szLockToken, TRUE);
	if (!pwsz || !FGetLockHandle (m_pmu.get(), m_pwszPath, GENERIC_WRITE, pwsz, &m_hf))
	{
		//	Manually check for any write locks on this resource.
		//	If a write lock exists, don't process the request.
		//
		if (FLockViolation (m_pmu.get(), ERROR_SHARING_VIOLATION, m_pwszPath, GENERIC_WRITE))
		{
			SendResponse(E_DAV_LOCKED);
			return;
		}
	}

	//	Instantiate the XML parser
	//
	m_pnfp.take_ownership(new CNFPatch(m_cpc));
	m_pstmRequest.take_ownership(m_pmu->GetRequestBodyIStream(*this));

	sc = ScNewXMLParser( m_pnfp.get(),
						 m_pstmRequest.get(),
						 m_pxprs.load() );

	if (FAILED(sc))
	{
		DebugTrace( "CPropPatchRequest::Execute() - ScNewXMLParser() failed (0x%08lX)\n", sc );
		SendResponse(sc);
		return;
	}

	//	Start parsing it into the context
	//
	ParseBody();
}

VOID
CPropPatchRequest::ParseBody()
{
	Assert( m_pxprs.get() );
	Assert( m_pnfp.get() );
	Assert( m_pstmRequest.get() );

	//	Parse XML from the request body stream.
	//
	//	Add a ref for the following async operation.
	//	Use auto_ref_ptr rather than AddRef() for exception safety.
	//
	auto_ref_ptr<CPropPatchRequest> pRef(this);

	SCODE sc = ScParseXML (m_pxprs.get(), m_pnfp.get());

	if ( SUCCEEDED(sc) )
	{
		Assert( S_OK == sc || S_FALSE == sc );

		DoPatch();
	}
	else if ( E_PENDING == sc )
	{
		//
		//	The operation is pending -- AsyncIOComplete() will take ownership
		//	ownership of the reference when it is called.
		//
		pRef.relinquish();
	}
	else
	{
		DebugTrace( "CPropPatchRequest::ParseBody() - ScParseXML() failed (0x%08lX)\n", sc );
		SendResponse(sc);
	}
}

VOID
CPropPatchRequest::AsyncIOComplete()
{
	//	Take ownership of the reference added for the async operation.
	//
	auto_ref_ptr<CPropPatchRequest> pRef;
	pRef.take_ownership(this);

	ParseBody();
}

VOID
CPropPatchRequest::DoPatch()
{
	SCODE sc;

	//	At this point, make sure that they support text/xml
	//
	sc = ScIsAcceptable (m_pmu.get(), gc_wszText_XML);
	if (FAILED (sc))
	{
		SendResponse(sc);
		return;
	}

	//	Get the IPropertyBagEx on the resource
	//	If the file is locked, we must use its handle to
	//	get the inteface. otherwise, access will be denied
	//
	auto_com_ptr<IPropertyBagEx> pbag;

	sc = ScGetPropertyBag (m_pwszPath,
						   STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
						   &pbag,
						   m_cri.FLoaded() ? m_cri.FCollection() : FALSE,
						   m_hf.get() ? m_hf.get() : INVALID_HANDLE_VALUE);
	if (FAILED (sc))
	{
		//	You can't set properties without a property bag...
		//
		if (VOLTYPE_NTFS != VolumeType (m_pwszPath, m_pmu->HitUser()))
			sc = E_DAV_VOLUME_NOT_NTFS;

		SendResponse(sc);
		return;
	}

	//	All header must be emitted before chunked XML emitting starts
	//
	m_pmu->SetResponseHeader (gc_szContent_Type, gc_szText_XML);

	//	Set the response code and go
	//
	m_pmu->SetResponseCode( HscFromHresult(W_DAV_PARTIAL_SUCCESS),
							NULL,
							0,
							CSEFromHresult(W_DAV_PARTIAL_SUCCESS) );

	//	Apply the request
	//
	auto_ref_ptr<CXMLEmitter> pmsr;
	auto_ref_ptr<CXMLBody>	pxb;

	pxb.take_ownership (new CXMLBody(m_pmu.get()));
	pmsr.take_ownership (new CXMLEmitter(pxb.get(), &m_cpc));

	CFSProp fsp(m_pmu.get(),
				pbag,
				m_pmu->LpwszRequestUrl(),
				m_pwszPath,
				NULL,
				m_cri);

	sc = m_cpc.ScPatch (*pmsr, m_pmu.get(), fsp);

	//	Make sure we close the file before sending any response
	//
	pbag.clear();

	if (FAILED (sc))
	{
		SendResponse(sc);
		return;
	}

	//	Done with the reponse
	//
	pmsr->Done();

	m_pmu->SendCompleteResponse();
}

VOID
CPropPatchRequest::SendResponse( SCODE sc )
{
	//
	//	Set the response code and go
	//
	m_pmu->SetResponseCode( HscFromHresult(sc), NULL, 0, CSEFromHresult(sc) );
	m_pmu->SendCompleteResponse();
}

/*
 *	DAVPropPatch()
 *
 *	Purpose:
 *
 *		Win32 file system implementation of the DAV PROPPATCH method.  The
 *		PROPPATCH method responds with a fully constructed XML that identifies
 *		the success of each prop request.
 *
 *	Parameters:
 *
 *		pmu			[in]  pointer to the method utility object
 */
void
DAVPropPatch (LPMETHUTIL pmu)
{
	SCODE	sc;
	auto_ref_ptr<CPropPatchRequest> pRequest(new CPropPatchRequest(pmu));

	sc = pRequest->ScInit();
	if (FAILED(sc))
	{
		pmu->SetResponseCode( HscFromHresult(sc), NULL, 0, CSEFromHresult(sc) );
		pmu->SendCompleteResponse();
	}

	pRequest->Execute();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\httpext\fslock.cpp ===
/*
 *	F S L O C K . C P P
 *
 *	Sources file system implementation of DAV-Lock
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davfs.h"
#include "_shlkmgr.h"

#include <stdlib.h>
#include <statetok.h>
#include <xlock.h>

//	Lock prop support ---------------------------------------------------------
//

//	------------------------------------------------------------------------
//
//	DwGetSupportedLockType
//
//		Return the supported locktype flags for the resource type.
//$LATER: If/when we have more types than just coll/non-coll, change
//$LATER: the boolean parameter to an enum.
//
DWORD __fastcall DwGetSupportedLockType (RESOURCE_TYPE rt)
{
	//	DAVFS doesn't support locks on collections.
	//	On files, DAVFS supports write locks and all lockscope flags.
	return (RT_COLLECTION == rt)
			?	0
			:	GENERIC_WRITE | DAV_LOCKSCOPE_FLAGS;
}

//	------------------------------------------------------------------------
//
//	ScSendLockComment
//
//		Set lock comment information from the lock object into the
//		response.
//
SCODE
ScSendLockComment(LPMETHUTIL pmu,
						  SNewLockData * pnld,
						  UINT cchLockToken,
						  LPCWSTR pwszLockToken)
{
	auto_ref_ptr<CXMLEmitter> pemitter;
	auto_ref_ptr<CXMLBody> pxb;
	
	SCODE sc = S_OK;

	Assert(pmu);
	Assert(pnld);
	Assert(cchLockToken);
	Assert(pwszLockToken);

	//	Emit the Content-Type: header
	//
	pmu->SetResponseHeader(gc_szContent_Type, gc_szText_XML);

	//	Construct the root ('DAV:prop') for the lock response, not chunked
	//
	pxb.take_ownership (new CXMLBody(pmu, FALSE));
	pemitter.take_ownership (new CXMLEmitter(pxb.get()));
	sc = pemitter->ScSetRoot (gc_wszProp);
	if (FAILED (sc))
	{
		goto ret;
	}

	{
		CEmitterNode enLockDiscovery;
		
		//	Construct the 'DAV:lockdiscovery' node
		//
		sc = enLockDiscovery.ScConstructNode (*pemitter, pemitter->PxnRoot(), gc_wszLockDiscovery);
		if (FAILED (sc))
		{
			goto ret;
		}

		//	Add the 'DAV:activelock' node for this CLock
		//
		sc = ScLockDiscoveryFromSNewLockData (pmu,
												*pemitter,
												enLockDiscovery,
												pnld, 
												pwszLockToken);
		if (FAILED (sc))
		{
			goto ret;
		}
	}
	
	//	Emit the XML body
	//
	pemitter->Done();

ret:

	return sc;
}


//	------------------------------------------------------------------------
//	LOCK helper functions
//

//	------------------------------------------------------------------------
//
//	HrProcessLockRefresh
//
//		pmu -- MethUtil access
//		pszLockToken -- header containing the locktoken to refresh
//		puiErrorDetail -- error detail string id, passed out on error
//		pnld -- pass back the lock attributes
//		cchBufferLen -- buffer length for the lock token
//		rgwszLockToken -- buffer for the lock token
//		pcchLockToken -- pointer that will receive the count of characters written
//						for the lock token
//
//	NOTE: This function still only can handle refreshing ONE locktoken.
//$REVIEW: Do we need to fix this?
//
HRESULT HrProcessLockRefresh (LPMETHUTIL pmu,
							  LPCWSTR pwszLockToken,
							  UINT * puiErrorDetail,
							  SNewLockData * pnld,
							  UINT cchBufferLen,
							  LPWSTR rgwszLockToken,
							  UINT * pcchLockToken)
{
	HRESULT hr = S_OK;
	
	DWORD dwTimeout = 0;
	
	LARGE_INTEGER liLockID;
	LPCWSTR pwszPath = pmu->LpwszPathTranslated();

	SLockHandleData lhd;

	Assert(pmu);
	Assert(pwszLockToken);
	Assert(puiErrorDetail);
	Assert(pnld);
	Assert(rgwszLockToken);
	Assert(pcchLockToken);

	//	Get a lock timeout, if they specified one.
	//
	if (!FGetLockTimeout (pmu, &dwTimeout))
	{
		DebugTrace ("DavFS: LOCK fails with improper Timeout header\n");
		hr = E_DAV_INVALID_HEADER;  //HSC_BAD_REQUEST;
		*puiErrorDetail = IDS_BR_TIMEOUT_SYNTAX;
		goto ret;
	}

	//	Here's the real work.
	//	Get the lock from the cache.  If this object is not in our cache,
	//	or the lockid doesn't match, don't let them refresh the lock.
	//$REVIEW: Should this be two distinct error codes?
	//

	//	Feed the Lock-Token header string into a parser object.
	//	Then get the lockid from the parser object.
	//
	{
		CParseLockTokenHeader lth(pmu, pwszLockToken);

		//	If there is more than one token, bad request.
		//
		if (!lth.FOneToken())
		{
			hr = HRESULT_FROM_WIN32 (ERROR_BAD_FORMAT);  //HSC_BAD_REQUEST;
			*puiErrorDetail = IDS_BR_MULTIPLE_LOCKTOKENS;
			goto ret;
		}

		lth.SetPaths (pwszPath, NULL);

		//	0 means match all access.
		//
		hr = lth.HrGetLockIdForPath (pwszPath, 0, &liLockID);
		if (FAILED (hr))
		{
			DavTrace ("DavFS: HrGetLockIdForPath could not find the path.\n");
			goto ret;
		}
	}

	//	Fetch the lock from the cache. (This call updates the timestamp.)
	//
	hr = CSharedLockMgr::Instance().HrGetLockData(liLockID,
											   pmu->HitUser(),
											   pwszPath,
											   dwTimeout,
											   pnld,
											   &lhd,
											   cchBufferLen,
											   rgwszLockToken,
											   pcchLockToken);
	if (FAILED(hr))
	{
		DavTrace ("DavFS: Refreshing a non-locked resource constitutes an unsatisfiable request.\n");
		
		//	If it's an access check failed, leave the return code unchanged.
		//	If the buffer was not sufficient, leave the return code unchanged.
		//	Otherwise, give "can't satisfy request" (412 Precondition Failed).
		//
		if (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) != hr &&
		    HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) != hr)
			hr = E_DAV_CANT_SATISFY_LOCK_REQUEST;
		*puiErrorDetail = IDS_BR_LOCKTOKEN_INVALID;
		goto ret;
	}

ret:

	return hr;
}


//	========================================================================
//
//	CLockRequest
//
//		Used by ProcessLockRequest() below to manage possible asynchronous
//		processing of a lock request in light of the fact that one cannot
//		determine whether a request body is so large that read operations
//		on it execute asynchronously.
//
class CLockRequest :
	public CMTRefCounted,
	private IAsyncIStreamObserver
{
	//	Reference to the CMethUtil
	//
	auto_ref_ptr<CMethUtil> m_pmu;

	//	Cached translated path
	//
	LPCWSTR m_pwszPath;

	//	File backing the lock we create
	//
	auto_ref_handle m_hfile;

	//	The lock XML node factory
	//
	auto_ref_ptr<CNFLock> m_pnfl;

	//	The request body stream
	//
	auto_ref_ptr<IStream> m_pstmRequest;

	//	The XML parser used to parse the request body using
	//	the node factory above.
	//
	auto_ref_ptr<IXMLParser> m_pxprs;

	//	Flag set to TRUE if we created the file as a result of creating
	//	the lock.  Used to indicate the status code to return as well
	//	as to know whether to delete the file on error.
	//
	BOOL m_fCreatedFile;

	//	IAsyncIStreamObserver
	//
	VOID AsyncIOComplete();

	//	State functions
	//
	VOID ParseBody();
	VOID DoLock();
	VOID SendResponse( SCODE sc, UINT uiErrorDetail = 0 );

	//	NOT IMPLEMENTED
	//
	CLockRequest& operator= (const CLockRequest&);
	CLockRequest (const CLockRequest&);

public:
	//	CREATORS
	//
	CLockRequest (CMethUtil * pmu) :
		m_pmu(pmu),
		m_pwszPath(m_pmu->LpwszPathTranslated()),
		m_fCreatedFile(FALSE)
	{
	}
	~CLockRequest();

	//	MANIPULATORS
	//
	VOID Execute();
};

//	------------------------------------------------------------------------
//
//	CLockRequest::~CLockRequest
//
CLockRequest::~CLockRequest()
{
	//	We have cleaned up the old handle in CLockRequest::SendResponse()
	//	The following path could be executed only in exception stack rewinding
	//
	if ( m_hfile.get() && m_fCreatedFile )
	{
		//	WARNING: the safe_revert class should only be
		//	used in very selective situations.  It is not
		//	a "quick way to get around" impersonation.
		//
		safe_revert sr(m_pmu->HitUser());

		m_hfile.clear();

		//$REVIEW	Note if exception happened after the lock handle is duplicated,
		//$REVIEW	then we won't be able to delete the file, but this is very
		//$REVIEW	rare. not sure if we ever want to handle this.
		//
		DavDeleteFile (m_pwszPath);
		DebugTrace ("Dav: deleting partial lock (%ld)\n", GetLastError());
	}
}

//	------------------------------------------------------------------------
//
//	CLockRequest::Execute
//
VOID
CLockRequest::Execute()
{
	//
	//	First off, tell the pmu that we want to defer the response.
	//	Even if we send it synchronously (i.e. due to an error in
	//	this function), we still want to use the same mechanism that
	//	we would use for async.
	//
	m_pmu->DeferResponse();

	//	The client must not submit a depth header with any value
	//	but 0 or Infinity.
	//	NOTE: Currently, DAVFS cannot lock collections, so the
	//	depth header doesn't change anything.  So, we don't change
	//	our processing at all for the Depth: infinity case.
	//
	//$LATER: If we do want to support locking collections,
	//$LATER: need to set DAV_RECURSIVE_LOCK on depth infinity.
	//
	LONG lDepth = m_pmu->LDepth(DEPTH_ZERO);
	if ((DEPTH_ZERO != lDepth) && (DEPTH_INFINITY != lDepth))
	{
		//	If the header is anything besides 0 or infinity, bad request.
		//
		SendResponse(E_DAV_INVALID_HEADER);
		return;
	}

	//	Instantiate the XML parser
	//
	m_pnfl.take_ownership(new CNFLock);
	m_pstmRequest.take_ownership(m_pmu->GetRequestBodyIStream(*this));

	SCODE sc = ScNewXMLParser( m_pnfl.get(),
							   m_pstmRequest.get(),
							   m_pxprs.load() );

	if (FAILED(sc))
	{
		DebugTrace( "CLockRequest::Execute() - ScNewXMLParser() failed (0x%08lX)\n", sc );
		SendResponse(sc);
		return;
	}

	//	Parse the body
	//
	ParseBody();
}

//	------------------------------------------------------------------------
//
//	CLockRequest::ParseBody()
//
VOID
CLockRequest::ParseBody()
{
	SCODE sc;

	Assert( m_pxprs.get() );
	Assert( m_pnfl.get() );
	Assert( m_pstmRequest.get() );

	//	Parse XML from the request body stream.
	//
	//	Add a ref for the following async operation.
	//	Use auto_ref_ptr rather than AddRef() for exception safety.
	//
	auto_ref_ptr<CLockRequest> pRef(this);

	sc = ScParseXML (m_pxprs.get(), m_pnfl.get());

	if ( SUCCEEDED(sc) )
	{
		Assert( S_OK == sc || S_FALSE == sc );

		DoLock();
	}
	else if ( E_PENDING == sc )
	{
		//
		//	The operation is pending -- AsyncIOComplete() will take ownership
		//	ownership of the reference when it is called.
		//
		pRef.relinquish();
	}
	else
	{
		DebugTrace( "CLockRequest::ParseBody() - ScParseXML() failed (0x%08lX)\n", sc );
		SendResponse( sc );
		return;
	}
}

//	------------------------------------------------------------------------
//
//	CLockRequest::AsyncIOComplete()
//
//	Called on completion of an async operation on our stream to
//	resume parsing XML from that stream.
//
VOID
CLockRequest::AsyncIOComplete()
{
	//	Take ownership of the reference added above in ParseBody()
	//
	auto_ref_ptr<CLockRequest> pRef;
	pRef.take_ownership(this);

	//	Resume parsing
	//
	ParseBody();
}

//	------------------------------------------------------------------------
//
//	CLockRequest::DoLock()
//
VOID
CLockRequest::DoLock()
{
	DWORD dw;
	DWORD dwAccess = 0;
	DWORD dwLockType;
	DWORD dwLockScope;
	DWORD dwSharing;
	DWORD dwSecondsTimeout;
	LPCWSTR pwszURI = m_pmu->LpwszRequestUrl();
	
	SNewLockData nld;
	WCHAR rgwszLockToken[MAX_LOCKTOKEN_LENGTH];
	UINT cchLockToken = CElems(rgwszLockToken);
	
	SCODE sc = S_OK;

	//	Pull lock flags out of the xml parser.
	//	NOTE: I'm doing special stuff here, rather than inside the xml parser.
	//	Our write locks get read access also -- I'm relying on all methods
	//	that USE a lock handle to check the metabase flags!!!
	//

	//	Rollback is not supported here.
	//	If we see this, fail explicitly.
	//
	dwLockType = m_pnfl->DwGetLockRollback();
	if (dwLockType)
	{
		SendResponse(E_DAV_CANT_SATISFY_LOCK_REQUEST);  //HSC_PRECONDITION_FAILED;
		return;
	}

	//	If the parser gives us a non-supported locktype (like rollback!)
	//	tell the user it's not supported.
	//
	dwLockType = m_pnfl->DwGetLockType();
	if (GENERIC_WRITE != dwLockType &&
		GENERIC_READ != dwLockType)
	{
		SendResponse(E_DAV_CANT_SATISFY_LOCK_REQUEST);  //HSC_PRECONDITION_FAILED;
		return;
	}

	Assert (GENERIC_WRITE == dwLockType ||
			GENERIC_READ == dwLockType);

	//	Since we KNOW (see above assumption) that our locktype is WRITE,
	//	we also KNOW that our access should be read+write.
	//
	dwAccess = GENERIC_READ | GENERIC_WRITE;
#ifdef	DBG
	//	This is needed for BeckyAn to test that our infrastructure still
	//	handles setting a read-lock. DBG ONLY.
	dwAccess = (dwLockType & GENERIC_WRITE)
			   ? GENERIC_READ | GENERIC_WRITE
			   : GENERIC_READ;
#endif	// DBG

	//	Get our lockscope from the parser.
	//
	dwLockScope = m_pnfl->DwGetLockScope();
	if (DAV_SHARED_LOCK != dwLockScope &&
		DAV_EXCLUSIVE_LOCK != dwLockScope)
	{
		SendResponse(E_DAV_CANT_SATISFY_LOCK_REQUEST);  //HSC_PRECONDITION_FAILED;
		return;
	}

	if (DAV_SHARED_LOCK == dwLockScope)
	{
		//	Shared lock -- turn on all sharing flags.
		dwSharing = FILE_SHARE_READ | FILE_SHARE_WRITE;
	}
	else
	{
		//	Our lock type is write (see above assumption).  Set the sharing
		//	flags correctly.
		//$LATER: If we have a different lock type later, fix these flags!
		//
		dwSharing = FILE_SHARE_READ;

#ifdef	DBG
		//	This is needed for BeckyAn to test that our infrastructure still
		//	handles setting a read-lock. DBG ONLY.
		dwSharing = 0;
		if (!(dwLockType & GENERIC_READ))
		{
			dwSharing |= FILE_SHARE_READ;
		}
		if (!(dwLockType & GENERIC_WRITE))
		{
			dwSharing |= FILE_SHARE_WRITE;
		}
#endif	// DBG
	}


	Assert(S_OK == sc);

	AssertSz (dwAccess, "Strange.  Lock requested with NO access (no locktypes?).");

	//	Check our LOCKTYPE against the metabase access rights.
	//	NOTE:  I'm not checking our ACCESS flags against the metabase
	//	because our access flags don't come directly from the caller's requested
	//	access.  This check just makes sure that the caller hasn't asked for
	//	anything he can't have.
	//	NOTE: I don't listen for metabase changes, so if I get a lock with
	//	more/less access than the user, I don't/can't change it for a
	//	metabase update.
	//	NOTE: This works IF we assiduously check the metabase flags on
	//	ALL other methds (which we currenly do).  If that checking ever
	//	goes missing, and we grab a lock handle that has more access than
	//	the caller rightfully is allowed, we have a security hole.
	//	(So keep checking metabase flags on all methods!)
	//
	dw = (dwLockType & GENERIC_READ) ? MD_ACCESS_READ : 0;
	dw |= (dwLockType & GENERIC_WRITE) ? MD_ACCESS_WRITE : 0;
	sc = m_pmu->ScIISAccess (pwszURI, dw);
	if (FAILED (sc))
	{
		DebugTrace( "CLockRequest::DoLock() - IMethUtil::ScIISAccess failed (0x%08lX)\n", sc );
		SendResponse(sc);
		return;
	}

	//	Check for user-specified timeout header.
	//	(The timeout header is optional, so it's okay to have no timeout
	//	header, but syntax errors in the timeout header are NOT okay.)
	//	If no timeout header is present, dw will come back ZERO.
	//
	if (!FGetLockTimeout (m_pmu.get(), &dwSecondsTimeout))
	{
		DebugTrace ("DavFS: LOCK fails with improper Time-Out header\n");
		SendResponse(HRESULT_FROM_WIN32 (ERROR_BAD_FORMAT), //HSC_BAD_REQUEST;
					 IDS_BR_TIMEOUT_SYNTAX);
		return;
	}

try_open_resource:

	//	And now lock the resource.
	//	NOTE: On WRITE operations, if the file doesn't exist, CREATE it here
	//	(OPEN_ALWAYS, not OPEN_EXISTING) and change the hsc below!
	//	NOTE: We NEVER allow delete access (no FILE_SHARE_DELETE).
	//	NOTE: All our reads/writes will be async, so open the file overlapped.
	//	NOTE: We will be reading/writing the whole file usually, so use SEQUENTIAL_SCAN.
	//
	if (!m_hfile.FCreate(
		DavCreateFile (m_pwszPath,
					   dwAccess,
					   dwSharing,
					   NULL,
					   (dwAccess & GENERIC_WRITE)
						   ? OPEN_ALWAYS
						   : OPEN_EXISTING,
					   FILE_ATTRIBUTE_NORMAL |
						   FILE_FLAG_OVERLAPPED |
						   FILE_FLAG_SEQUENTIAL_SCAN,
					   NULL)))
	{
		sc = HRESULT_FROM_WIN32 (GetLastError());

		//	Special check for NEW-STYLE write locks.
		//	We are asking for rw access when we get a write lock.
		//	IF we don't have read access (in the ACLs) for the resource,
		//	we will fail here with ERROR_ACCESS_DENIED.
		//	Catch this case and try again with just w access!
		//
		if (ERROR_ACCESS_DENIED == GetLastError() &&
			dwAccess == (GENERIC_READ | GENERIC_WRITE) &&
			dwLockType == GENERIC_WRITE)
		{
			// Try again.
			dwAccess = GENERIC_WRITE;
			goto try_open_resource;
		}

		//	Special work for 416 Locked responses -- fetch the
		//	comment & set that as the response body.
		//	(You'll hit here if someone else already has this file locked!)
		//
		if (FLockViolation (m_pmu.get(), sc, m_pwszPath, dwLockType))
		{
			sc = HRESULT_FROM_WIN32 (ERROR_SHARING_VIOLATION); //HSC_LOCKED;
		}

		DavTrace ("Dav: unable to lock resource on LOCK method\n");
		SendResponse(sc);
		return;
	}

	//	If we created the file (only for write locks),
	//	change the default error code to say so.
	//
	if (dwAccess & GENERIC_WRITE &&
		GetLastError() != ERROR_ALREADY_EXISTS)
	{
		//	Emit the location
		//
		m_pmu->EmitLocation (gc_szLocation, pwszURI, FALSE);
		m_fCreatedFile = TRUE;
	}

	//	Ask the shared lock manager to create a new shared lock token
	//
	nld.m_dwAccess = dwAccess;
   	nld.m_dwLockType = dwLockType;
   	nld.m_dwLockScope = dwLockScope;
   	nld.m_dwSecondsTimeout = dwSecondsTimeout;
   	nld.m_pwszResourceString = const_cast<LPWSTR>(m_pwszPath);
   	nld.m_pwszOwnerComment = const_cast<LPWSTR>(m_pnfl->PwszLockOwner());
   	
	sc = CSharedLockMgr::Instance().HrGetNewLockData(m_hfile.get(),
														  m_pmu->HitUser(),
														  &nld,
														  cchLockToken,
														  rgwszLockToken,
														  &cchLockToken);
	if (FAILED(sc))
	{
		DebugTrace ("DavFS: CLockRequest::DoLock() - CSharedLockMgr::Instance().HrGetNewLockData() failed 0x%08lX\n", sc);

		SendResponse(E_ABORT);	//HSC_INTERNAL_SERVER_ERROR;
		return;
	}

	//	Emit the Lock-Token: header
	//
	Assert(cchLockToken);
	Assert(L'\0' == rgwszLockToken[cchLockToken - 1]);
	m_pmu->SetResponseHeader (gc_szLockTokenHeader, rgwszLockToken);

	//	Generate a valid lock response
	//
	sc = ScSendLockComment(m_pmu.get(),
							 &nld,
							 cchLockToken,
							 rgwszLockToken);
	if (FAILED(sc))
	{
		DebugTrace ("DavFS: CLockRequest::DoLock() ScSendLockComment () failed 0x%08lX\n", sc);
		
		SendResponse(E_ABORT);
		return;
	}

	Assert(S_OK == sc);

	SendResponse(m_fCreatedFile ? W_DAV_CREATED : S_OK);
}

//	------------------------------------------------------------------------
//
//	CLockRequest::SendResponse()
//
//	Set the response code and send the response.
//
VOID
CLockRequest::SendResponse( SCODE sc, UINT uiErrorDetail )
{
	PutTrace( "DAV: TID %3d: 0x%08lX: CLockRequest::SendResponse() called\n", GetCurrentThreadId(), this );

	
	//	We must close the file handle before we send any respose back
	//  to client. Otherwise, if the lcok failed, client may send another
	//  request immediately and expect the resource is not locked.
	//
	//	Even in the case the lock succeeded, it's still cleaner we release
	//	the file handle here. Think about the following sequence:
	//		LOCK f1, UNLOCK f1, PUT f1;
	//	the last PUT could fail if the first LOCK reqeust hangs a little longer
	//	after it sends the response.
	//
	//	Keep in mind that if locked succeeded, the handle is already duplicated
	//	in davcdata.exe. so releasing the file handle here doesn't really 'unlock'
	//	file. the file is still locked.
	//
	m_hfile.clear();

	if (FAILED(sc) && m_fCreatedFile)
	{
		//	WARNING: the safe_revert class should only be
		//	used in very selective situations.  It is not
		//	a "quick way to get around" impersonation.
		//
		safe_revert sr(m_pmu->HitUser());

		//	If we created the new file, we much delete it. Note that
		//	DoLock() would never fail after it duplicate the filehandle
		//	to davcdata, so we should be able to delete the file successfully
		//
		DavDeleteFile (m_pwszPath);
		DebugTrace ("Dav: deleting partial lock (%ld)\n", GetLastError());

		//	Now that we have cleaned up. reset m_fCreateFile so that we can
		//	skip the exception-safe code in ~CLockRequest()
		//
		m_fCreatedFile = FALSE;
	}
	
	//	Set the response code and go
	//
	m_pmu->SetResponseCode (HscFromHresult(sc), NULL, uiErrorDetail);
	m_pmu->SendCompleteResponse();
}

//
//	ProcessLockRequest
//
//		pmu -- MethUtil access
//
VOID
ProcessLockRequest (LPMETHUTIL pmu)
{
	auto_ref_ptr<CLockRequest> pRequest(new CLockRequest (pmu));

	pRequest->Execute();
}

//	DAV-Lock Implementation ---------------------------------------------------
//
/*
 *	DAVLock()
 *
 *	Purpose:
 *
 *		Win32 file system implementation of the DAV LOCK method.  The
 *		LOCK method results in the locking of a resource for a specific
 *		type of access.  The response tells whether the lock was granted
 *		or not.  If the lock was granted, it provides a lockid to be used
 *		in future methods (including UNLOCK) on the resource.
 *
 *	Parameters:
 *
 *		pmu			[in]  pointer to the method utility object
 *
 *	Notes:
 *
 *		In the file system implementation, the LOCK method maps directly
 *		to the Win32 CreateFile() method with special access flags.
 */
void
DAVLock (LPMETHUTIL pmu)
{
	SCODE sc = S_OK;
	UINT uiErrorDetail = 0;
	LPCWSTR pwszLockToken;
	CResourceInfo cri;

	//	Do ISAPI application and IIS access bits checking
	//
	sc = pmu->ScIISCheck (pmu->LpwszRequestUrl());
	if (FAILED(sc))
	{
		//	Either the request has been forwarded, or some bad error occurred.
		//	In either case, quit here and map the error!
		//
		goto ret;
	}

	//	Process based on resource info
	//
	sc = cri.ScGetResourceInfo (pmu->LpwszPathTranslated());
	if (!FAILED (sc))
	{
		//  Check to see if the resource is a DIRECTORY.
		//	DAVFS can lock non-existant resources, but can't lock directories.
		//
		if (cri.FCollection())
		{
			//  The resource is a directory.
			//
			DavTrace ("Dav: directory resource specified for LOCK\n");
			sc = E_DAV_PROTECTED_ENTITY;
			uiErrorDetail = IDS_BR_NO_COLL_LOCK;
			goto ret;
		}

		//	Ensure the URI and resource match
		//
		sc = ScCheckForLocationCorrectness (pmu, cri, NO_REDIRECT);
		if (FAILED(sc))
		{
			goto ret;
		}

		//	Check against the "if-xxx" headers
		//
		sc = ScCheckIfHeaders (pmu, cri.PftLastModified(), FALSE);
	}
	else
	{
		sc = ScCheckIfHeaders (pmu, pmu->LpwszPathTranslated(), FALSE);
	}

	if (FAILED(sc))
	{
		DebugTrace ("DavFS: If-xxx checking failed.\n");
		goto ret;
	}

	//	Check If-State-Match headers.
	//
	sc = HrCheckStateHeaders (pmu, pmu->LpwszPathTranslated(), FALSE);
	if (FAILED(sc))
	{
		DebugTrace ("DavFS: If-State checking failed.\n");
		goto ret;
	}

	//	If they pass in a lock token *AND* a lockinfo header, it's a
	//	bad request.  (Lock upgrading is NOT allowed.)
	//	Just the lock token (no lockinfo) is a lock refresh request.
	//
	pwszLockToken = pmu->LpwszGetRequestHeader (gc_szLockToken, TRUE);
	if (pwszLockToken)
	{
		//	Lock-Token header present -- REFRESH request.
		//
		LPCWSTR pwsz;

		auto_co_task_mem<WCHAR> a_pwszResourceString;
		auto_co_task_mem<WCHAR> a_pwszOwnerComment;
		SNewLockData nld;
		
		WCHAR rgwszLockToken[MAX_LOCKTOKEN_LENGTH];
		UINT cchLockToken = CElems(rgwszLockToken);


		//	If we have a content-type, it better be text/xml.
		//
		pwsz = pmu->LpwszGetRequestHeader (gc_szContent_Type, FALSE);
		if (pwsz)
		{
			//	If it's not text/xml....
			//
			if (_wcsicmp(pwsz, gc_wszText_XML) && _wcsicmp(pwsz, gc_wszApplication_XML))
			{
				//	Invalid request -- has some other kind of request body
				//
				DebugTrace ("DavFS: Invalid body found on LOCK refresh method.\n");
				sc = E_DAV_UNKNOWN_CONTENT;
				uiErrorDetail = IDS_BR_LOCK_BODY_TYPE;
				goto ret;
			}
		}

		//	If we have a content length at all, it had better be zero.
		//	(Lock refreshes can't have a body!)
		//
		pwsz = pmu->LpwszGetRequestHeader (gc_szContent_Length, FALSE);
		if (pwsz)
		{
			//	If the Content-Length is anything other than zero, bad request.
			//
			if (_wcsicmp(pwsz, gc_wsz0))
			{
				//	Invalid request -- has some other kind of request body
				//
				DebugTrace ("DavFS: Invalid body found on LOCK refresh method.\n");
				sc = E_DAV_INVALID_HEADER; //HSC_BAD_REQUEST;
				uiErrorDetail = IDS_BR_LOCK_BODY_SYNTAX;
				goto ret;
			}
		}

		//	Process the refresh.
		//
		sc = HrProcessLockRefresh (pmu,
								   pwszLockToken,
								   &uiErrorDetail,
								   &nld,
								   cchLockToken,
								   rgwszLockToken,
								   &cchLockToken);
		if (FAILED(sc))
		{
			//	Make sure we did not get insufficient buffer errors as the 
			//	buffer we passed was sufficient.
			//
			Assert(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) != sc);
			goto ret;
		}

		//	Take ownership of the memory allocated
		//
		a_pwszResourceString.take_ownership(nld.m_pwszResourceString);
		a_pwszOwnerComment.take_ownership(nld.m_pwszOwnerComment);

		//	Send back the lock comment.
		//	Tell the lock to generate XML lockdiscovery prop data
		//	and emit it to the response body. 
		//
		sc = ScSendLockComment(pmu,
								 &nld,
								 cchLockToken,
								 rgwszLockToken);
		if (FAILED(sc))
		{
			goto ret;
		}
	}
	else
	{
		//	No Lock-Token header present -- LOCK request.
		//
		
		//	Go get this lock.  All error handling and response
		//	generation is done inside ProcessLockRequest()
		//	so there's nothing more to do here once we call it.
		//
		ProcessLockRequest (pmu);
		return;
	}
	
ret:
	
	pmu->SetResponseCode (HscFromHresult(sc), NULL, uiErrorDetail, CSEFromHresult(sc));
	
}


/*
 *	DAVUnlock()
 *
 *	Purpose:
 *
 *		Win32 file system implementation of the DAV UNLOCK method.  The
 *		UNLOCK method results in the moving of a resource from one location
 *		to another.	 The response is used to indicate the success of the
 *		call.
 *
 *	Parameters:
 *
 *		pmu			[in]  pointer to the method utility object
 *
 *	Notes:
 *
 *		In the file system implementation, the UNLOCK method maps directly
 *		to the Win32 CloseHandle() method.
 */
void
DAVUnlock (LPMETHUTIL pmu)
{
	LPCWSTR pwszPath = pmu->LpwszPathTranslated();

	LPCWSTR pwsz;
	LARGE_INTEGER liLockID;
	UINT uiErrorDetail = 0;
	HRESULT hr;
	CResourceInfo cri;

	//	Do ISAPI application and IIS access bits checking
	//
	hr = pmu->ScIISCheck (pmu->LpwszRequestUrl());
	if (FAILED(hr))
	{
		//	Either the request has been forwarded, or some bad error occurred.
		//	In either case, quit here and map the error!
		//
		goto ret;
	}

	//	Check what kind of lock is requested.
	//	(No lock-info header means this request is invalid.)
	//
	pwsz = pmu->LpwszGetRequestHeader (gc_szLockTokenHeader, FALSE);
	if (!pwsz)
	{
		DebugTrace ("DavFS: UNLOCK fails without Lock-Token.\n");
		hr = E_INVALIDARG;
		uiErrorDetail = IDS_BR_LOCKTOKEN_MISSING;
		goto ret;
	}

	hr = HrCheckStateHeaders (pmu,		//	methutil
							  pwszPath,	//	path
							  FALSE);	//	fGetMeth
	if (FAILED(hr))
	{
		DebugTrace ("DavFS: If-State checking failed.\n");
		goto ret;
	}

#ifdef	NEVER
	//$NEVER
	//	Old code -- the common functions use here have changed to expect
	//	If: header syntax.  We can't use this anymore.  It gives errors because
	//	the Lock-Token header doesn't have parens around the locktokens.
	//$NEVER: Remove this after Joel has a chance to test stuff!
	//

	//	Feed the Lock-Token header string into a parser object.
	//	Then get the lockid from the parser object.
	//
	{
		CParseLockTokenHeader lth(pmu, pwsz);

		//	If there is more than one token, bad request.
		//
		if (!lth.FOneToken())
		{
			DavTrace ("DavFS: More than one token in DAVUnlock.\n");
			hr = E_DAV_INVALID_HEADER;
			uiErrorDetail = IDS_BR_MULTIPLE_LOCKTOKENS;
			goto ret;
		}

		lth.SetPaths (pwszPath, NULL);

		hr = lth.HrGetLockIdForPath (pwszPath, 0, &i64LockId);
		if (FAILED(hr))
		{
			DavTrace ("Dav: Failure in DAVUnlock on davfs.\n");
			uiErrorDetail = IDS_BR_LOCKTOKEN_SYNTAX;
			goto ret;
		}
	}
#endif	// NEVER

	//	Call to fetch the lockid from the Lock-Token header.
	//
	hr = HrLockIdFromString(pmu, pwsz, &liLockID);
	if (FAILED(hr))
	{
		DavTrace ("DavFS: Failed to fetch locktoken in UNLOCK.\n");

		//	They have a well-formed request, but their locktoken is not right.
		//	Tell the caller we can't satisfy this (un)lock request. (412 Precondition Failed)
		//
		hr = E_DAV_CANT_SATISFY_LOCK_REQUEST;
		goto ret;
	}

	//	Fetch the lock from the cache. (This call updates the timestamp.)
	//	Get the lock from the cache.  If this object is not in our cache,
	//	or the lockid doesn't match, don't let them unlock the resource.
	//$REVIEW: Should this be two distinct error codes?
	//
	hr = CSharedLockMgr::Instance().HrCheckLockID(liLockID,
											   pmu->HitUser(),
											   pwszPath);
	if (FAILED(hr))
	{
		DavTrace ("DavFS: Unlocking a non-locked resource constitutes an unsatisfiable request.\n");

		//	If it's an access violation, leave the return code unchanged.
		//	Otherwise, give "can't satisfy request" (412 Precondition Failed).
		//
		if (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) != hr)
			hr = E_DAV_CANT_SATISFY_LOCK_REQUEST;
		uiErrorDetail = IDS_BR_LOCKTOKEN_INVALID;
		goto ret;
	}

	//	This method is gated by the "if-xxx" headers
	//
	hr = cri.ScGetResourceInfo (pwszPath);
	if (FAILED (hr))
	{
		goto ret;
	}
	hr = ScCheckIfHeaders (pmu, cri.PftLastModified(), FALSE);
	if (FAILED (hr))
	{
		goto ret;
	}

	//	Ensure the URI and resource match
	//
	(void) ScCheckForLocationCorrectness (pmu, cri, NO_REDIRECT);

	//	Delete the lock from the cache.
	//
	hr = CSharedLockMgr::Instance().HrDeleteLock(pmu->HitUser(),
											liLockID);
	if (FAILED(hr))
	{
		goto ret;
	}
	
ret:

	if (!FAILED (hr))
	{
		hr = W_DAV_NO_CONTENT;
	}

	//	Setup the response
	//
	pmu->SetResponseCode (HscFromHresult(hr), NULL, uiErrorDetail, CSEFromHresult(hr));
}


//	------------------------------------------------------------------------
//
//	Utility functions for other FS methods to use when accessing locks.
//
//	------------------------------------------------------------------------


//	------------------------------------------------------------------------
//
//	FGetLockHandleFromId
//
BOOL
FGetLockHandleFromId (LPMETHUTIL pmu, LARGE_INTEGER liLockID,
					  LPCWSTR pwszPath, DWORD dwAccess,
					  auto_ref_handle * phandle)
{
	HRESULT hr = S_OK;

	auto_co_task_mem<WCHAR> a_pwszResourceString;
	auto_co_task_mem<WCHAR> a_pwszOwnerComment;
	
	SNewLockData nld;
	SLockHandleData lhd;

	HANDLE hTemp =  NULL;
	
	//	These are unused. Oplimize the interface not to ask for them later
	//
	WCHAR rgwszLockToken[MAX_LOCKTOKEN_LENGTH];
	UINT cchLockToken = CElems(rgwszLockToken);

	Assert (pmu);
	Assert (pwszPath);
	Assert (!IsBadWritePtr(phandle, sizeof(auto_ref_handle)));

	//	Fetch the lock from the cache. (This call updates the timestamp.)
	//
	hr = CSharedLockMgr::Instance().HrGetLockData(liLockID,
											   pmu->HitUser(),
											   pwszPath,
											   0,
											   &nld,
											   &lhd,
											   cchLockToken,
											   rgwszLockToken,
											   &cchLockToken);
	if (FAILED(hr))
	{
		DavTrace ("Dav: Failure in FGetLockHandle on davfs.\n");
		return FALSE;
	}

	//	Take ownership of the memory allocated
	//
	a_pwszResourceString.take_ownership(nld.m_pwszResourceString);
	a_pwszOwnerComment.take_ownership(nld.m_pwszOwnerComment);

	//	Check the access type required.
	//	(If the lock is missing any single flag requested, fail.)
	//
	if ( (dwAccess & nld.m_dwAccess) != dwAccess )
	{
		DavTrace ("FGetLockHandleFromId: Access did not match -- bad request.\n");
		return FALSE;
	}

	hr = HrGetUsableHandle(reinterpret_cast<HANDLE>(lhd.h), lhd.dwProcessID, &hTemp);
	if (FAILED(hr))
	{
		DavTrace("HrGetUsableHandle failed with %x \r\n", hr);
		return FALSE;
	}

	if (!phandle->FCreate(hTemp))
	{
		hr = E_OUTOFMEMORY;
		DavTrace("FCreate on autohandler failed \r\n");
		return FALSE;
	}

	//	HACK: Rewind the handle here -- until we get a better solution!
	//$LATER: Need a real way to handle multiple access to the same lock handle.
	//
	SetFilePointer ((*phandle).get(), 0, NULL, FILE_BEGIN);

	return TRUE;
}


//	------------------------------------------------------------------------
//
//	FGetLockHandle
//
//	Main routine for all other methods to get a handle from the cache.
//
BOOL
FGetLockHandle (LPMETHUTIL pmu, LPCWSTR pwszPath,
				DWORD dwAccess, LPCWSTR pwszLockTokenHeader,
				auto_ref_handle * phandle)
{
	LARGE_INTEGER liLockID;
	HRESULT hr;

	Assert (pmu);
	Assert (pwszPath);
	Assert (pwszLockTokenHeader);
	Assert (!IsBadWritePtr(phandle, sizeof(auto_ref_handle)));


	//	Feed the Lock-Token header string into a parser object.
	//	And feed in the one path we're interested in.
	//	Then get the lockid from the parser object.
	//
	{
		CParseLockTokenHeader lth (pmu, pwszLockTokenHeader);

		lth.SetPaths (pwszPath, NULL);

		hr = lth.HrGetLockIdForPath (pwszPath, dwAccess, &liLockID);
		if (FAILED(hr))
		{
			DavTrace ("Dav: Failure in FGetLockHandle on davfs.\n");
			return FALSE;
		}
	}

	return FGetLockHandleFromId (pmu, liLockID, pwszPath, dwAccess, phandle);
}


//	========================================================================
//	Helper functions for locked MOVE and COPY
//

//	------------------------------------------------------------------------
//
//	ScDoOverlappedCopy
//
//		Takes two file handles that have been opened for overlapped (async)
//		processing, and copies data from the source to the dest.
//		The provided hevt is used in the async read/write operations.
//
SCODE
   ScDoOverlappedCopy (HANDLE hfSource, HANDLE hfDest, HANDLE hevtOverlapped)
{
	SCODE sc = S_OK;
	OVERLAPPED ov;
	BYTE rgbBuffer[1024];
	ULONG cbToWrite;
	ULONG cbActual;

	Assert (hfSource);
	Assert (hfDest);
	Assert (hevtOverlapped);

	ov.hEvent     = hevtOverlapped;
	ov.Offset     = 0;
	ov.OffsetHigh = 0;

	//	Big loop.  Read from one file, and write to the other.
	//

	while (1)
	{
		//	Read from the source file.
		//
		if (!ReadFromOverlapped (hfSource, rgbBuffer, sizeof(rgbBuffer),
								 &cbToWrite, &ov))
		{
			DebugTrace ("Dav: failed to write to file\n");
			sc = HRESULT_FROM_WIN32 (GetLastError());
			goto ret;
		}

		//	If no bytes were read (and no error), we're done!
		//
		if (!cbToWrite)
			break;

		//	Write the data to the destination file.
		//
		if (!WriteToOverlapped (hfDest,
								rgbBuffer,
								cbToWrite,
								&cbActual,
								&ov))
		{
			DebugTrace ("Dav: failed to write to file\n");
			sc = HRESULT_FROM_WIN32 (GetLastError());
			goto ret;
		}

		//	Adjust the starting read position.
		//
		ov.Offset += cbActual;
	}

	//	That's it.  Set the destination file's size (set EOF) and we're done.
	//
	SetFilePointer (hfDest,
					ov.Offset,
					reinterpret_cast<LONG *>(&ov.OffsetHigh),
					FILE_BEGIN);
	SetEndOfFile (hfDest);

ret:
	return sc;
}


//	------------------------------------------------------------------------
//
//	ScDoLockedCopy
//
//		Given the Lock-Token header and the source & destination paths,
//		handle copying from one file to another, with locks in the way.
//
//		The general flow is this:
//
//		First check the lock tokens for validity & fetch any valid lock handles.
//		We must have read access on the source and write access on the dest.
//		If any lock token is invalid, or doesn't have the correct access, fail.
//		We need two handles (source & dest) to do the copy, so
//		manually fetch handles that didn't have lock tokens.
//		Once we have both handles, call ScDoOverlappedCopy to copy the file data.
//		Then, copy the DAV property stream from the source to the dest.
//		Any questions?
//
//		NOTE: This routine should ONLY be called if we already tried to copy
//		the files and we hit a sharing violation.
//
//
//
SCODE
ScDoLockedCopy (LPMETHUTIL pmu,
				CParseLockTokenHeader * plth,
				LPCWSTR pwszSrc,
				LPCWSTR pwszDst)
{
	auto_handle<HANDLE> hfCreated;
	auto_handle<HANDLE>	hevt;
	BOOL fSourceLock = FALSE;
	BOOL fDestLock = FALSE;
	LARGE_INTEGER liSource;
	LARGE_INTEGER liDest;
	auto_ref_handle hfLockedSource;
	auto_ref_handle hfLockedDest;
	HANDLE hfSource = INVALID_HANDLE_VALUE;
	HANDLE hfDest = INVALID_HANDLE_VALUE;
	SCODE sc;

	Assert (pmu);
	Assert (plth);
	Assert (pwszSrc);
	Assert (pwszDst);


	//	Get any lockids for these paths.
	//
	sc = plth->HrGetLockIdForPath (pwszSrc, GENERIC_READ, &liSource);
	if (SUCCEEDED(sc))
	{
		fSourceLock = TRUE;
	}
	sc = plth->HrGetLockIdForPath (pwszDst, GENERIC_WRITE, &liDest);
	if (SUCCEEDED(sc))
	{
		fDestLock = TRUE;
	}

	//	If they didn't even pass in tokens for these paths, quit here.
	//	Return & tell them that there's still a sharing violation.
	//
	if (!fSourceLock && !fDestLock)
	{
		DebugTrace ("DwDoLockedCopy -- No locks apply to these paths!");
		return E_DAV_LOCKED;
	}

	if (fSourceLock)
	{
		if (FGetLockHandleFromId (pmu, liSource, pwszSrc, GENERIC_READ,
								  &hfLockedSource))
		{
			hfSource = hfLockedSource.get();
		}
		else
		{
			//	Clear our flag -- they passed in an invalid/expired token.
			fSourceLock = FALSE;
		}
	}

	if (fDestLock)
	{
		if (FGetLockHandleFromId (pmu, liDest, pwszDst, GENERIC_WRITE,
								  &hfLockedDest))
		{
			hfDest = hfLockedDest.get();
		}
		else
		{
			//	Clear our flag -- they passed in an invalid/expired token.
			fDestLock = FALSE;
		}
	}

	//	Okay, now we either have NO lockhandles (they passed in locktokens
	//	but they were all expired) or one handle, or two handles.
	//

	//	NO lockhandles (all their locks were expired) -- kick 'em out.
	//	And tell 'em there's still a sharing violation to deal with.
	//$REVIEW: Or should we try the copy again???
	if (!fSourceLock && !fDestLock)
	{
		DebugTrace ("DwDoLockedCopy -- No locks apply to these paths!");
		return E_DAV_LOCKED;
	}

	//	One handle -- open up the other file manually & shove the data across.

	//	Two handles -- shove the data across.


	//	If we don't have one of these handles, open the missing one manually.
	//
	if (!fSourceLock)
	{
		//	Open up the source file manually.
		//
		hfCreated = DavCreateFile (pwszSrc,					// filename
								  GENERIC_READ,				// dwAccess
								  FILE_SHARE_READ | FILE_SHARE_WRITE,	// don't clash with OTHER locks
								  NULL,						// lpSecurityAttributes
								  OPEN_ALWAYS,				// creation flags
								  FILE_ATTRIBUTE_NORMAL |	// attributes
								  FILE_FLAG_OVERLAPPED |
								  FILE_FLAG_SEQUENTIAL_SCAN,
								  NULL);					// tenplate
		if (INVALID_HANDLE_VALUE == hfCreated.get())
		{
			DebugTrace ("DavFS: DwDoLockedCopy failed to open source file\n");
			sc = HRESULT_FROM_WIN32 (GetLastError());
			goto ret;
		}
		hfSource = hfCreated.get();
	}
	else if (!fDestLock)
	{
		//	Open up the destination file manually.
		//	This guy is CREATE_NEW becuase we should have already deleted
		//	any files that would have conflicted!
		//
		hfCreated = DavCreateFile (pwszDst,					// filename
								  GENERIC_WRITE,			// dwAccess
								  0,  //FILE_SHARE_READ | FILE_SHARE_WRITE,	// DO clash with OTHER locks -- just like PUT
								  NULL,						// lpSecurityAttributes
								  CREATE_NEW,				// creation flags
								  FILE_ATTRIBUTE_NORMAL |	// attributes
								  FILE_FLAG_OVERLAPPED |
								  FILE_FLAG_SEQUENTIAL_SCAN,
								  NULL);					// tenplate
		if (INVALID_HANDLE_VALUE == hfCreated)
		{
			DebugTrace ("DavFS: DwDoLockedCopy failed to open destination file\n");
			sc = HRESULT_FROM_WIN32 (GetLastError());
			goto ret;
		}
		hfDest = hfCreated.get();
	}

	//	Now we should have two handles.
	//
	Assert ((hfSource != INVALID_HANDLE_VALUE) && (hfDest != INVALID_HANDLE_VALUE));

	//	Setup the overlapped structure so we can read/write to async files.
	//
	hevt = CreateEvent(NULL, TRUE, FALSE, NULL);
	if (!hevt.get())
	{
		DebugTrace ("DavFS: DwDoLockedCopy failed to create event for overlapped read.\n");
		sc = HRESULT_FROM_WIN32 (GetLastError());
		goto ret;
	}

	//	Copy the file data.
	//
	sc = ScDoOverlappedCopy (hfSource, hfDest, hevt.get());
	if (FAILED (sc))
		goto ret;

	//	Copy over any property data.
	//
	if (FAILED (ScCopyProps (pmu, pwszSrc, pwszDst, FALSE, hfSource, hfDest)))
		sc = E_DAV_LOCKED;

ret:

	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\httpext\fsput.cpp ===
/*
 *	F S P U T . C P P
 *
 *	Copyright 1986-1998 Microsoft Corporation, All Rights Reserved
 */

#include "_davfs.h"


//	========================================================================
//
//	CLASS CPutRequest
//
//	Encapsulates the entire PUT request as an object which can be
//	can be reentered at various points for asynchronous processing.
//
class CPutRequest :
	public CMTRefCounted,
	private IAsyncStream,
	private IAsyncPersistObserver,
	private CDavWorkContext
{
	//
	//	Reference to the CMethUtil
	//
	auto_ref_ptr<CMethUtil> m_pmu;

	//
	//	Cached request URI
	//
	LPCWSTR m_pwszURI;

	//
	//	Cached translated URI
	//
	LPCWSTR m_pwszPath;

	//
	//	File handle of target.
	//
	auto_ref_handle m_hf;

	//
	//	Boolean flag indicating whether the file is being created
	//	as a result of this PUT.  Used to tell whether we need
	//	to delete the file on failure as well as determine
	//	whether to send back a 200 OK or a 201 Created response.
	//
	BOOL m_fCreatedFile;

	//
	//	OVERLAPPED structure with file pointer info necessary
	//	for async file I/O
	//
	OVERLAPPED m_ov;

	//
	//	Minimum number of milliseconds between polls for WriteFile()
	//	I/O completion.  This number increases geometrically by a factor
	//	(below) to minimize polling by worker threads.
	//
	DWORD m_dwMsecPollDelay;

	//
	//	Initial poll delay (in milliseconds) and factor by which
	//	that delay is increased each we poll and find that the
	//	I/O has not completed.  The factor is expressed as a
	//	fraction: POLL_DELAY_NUMERATOR/POLL_DELAY_DENOMINATOR.
	//	Note that the new value is computed using integer arithmetic
	//	so choose values such that the delay will actually increase!
	//
	//$OPT	Are these values optimal?  Ideally, we want the
	//$OPT	first poll to happen immediately after the I/O
	//$OPT	completes.
	//
	enum
	{
		MSEC_POLL_DELAY_INITIAL = 10,
		POLL_DELAY_NUMERATOR = 2,
		POLL_DELAY_DENOMINATOR = 1
	};

	//
	//	Number of bytes written in the last write operation.
	//
	DWORD m_dwcbWritten;

	//
	//	Observer passed to AsyncWrite() to notify when the
	//	write completes.
	//
	IAsyncWriteObserver * m_pobs;

	//
	//	Status
	//
	SCODE m_sc;

	//	MANIPULATORS
	//
	VOID SendResponse();

	VOID AsyncWrite( const BYTE * pbBuf,
					 UINT         cbToWrite,
					 IAsyncWriteObserver& obsAsyncWrite );

	VOID PostIOCompletionPoll();

	//	CDavWorkContext callback called to poll for I/O completion
	//
	DWORD DwDoWork();

	VOID WriteComplete();

	VOID PersistComplete( HRESULT hr );

	//	NOT IMPLEMENTED
	//
	CPutRequest& operator=( const CPutRequest& );
	CPutRequest( const CPutRequest& );

public:
	//	CREATORS
	//
	CPutRequest( CMethUtil * pmu ) :
		m_pmu(pmu),
		m_pwszURI(pmu->LpwszRequestUrl()),
		m_pwszPath(pmu->LpwszPathTranslated()),
		m_fCreatedFile(FALSE),
		m_pobs(NULL),
		m_sc(S_OK)
	{
		m_ov.hEvent = NULL;
		m_ov.Offset = 0;
		m_ov.OffsetHigh = 0;
	}

	~CPutRequest()
	{
		if ( m_ov.hEvent )
			CloseHandle( m_ov.hEvent );
	}

	//	MANIPULATORS
	//
	void AddRef() { CMTRefCounted::AddRef(); }
	void Release() { CMTRefCounted::Release(); }
	VOID Execute();
};

//	------------------------------------------------------------------------
//
//	CPutRequest::Execute()
//
//	Process the request up to the point where we persist the body.
//
VOID
CPutRequest::Execute()
{
	LPCWSTR pwsz;


	PutTrace( "DAV: TID %3d: 0x%08lX: CPutRequest::Execute() called\n", GetCurrentThreadId(), this );

	//
	//	First off, tell the pmu that we want to defer the response.
	//	Even if we send it synchronously (i.e. due to an error in
	//	this function), we still want to use the same mechanism that
	//	we would use for async.
	//
	m_pmu->DeferResponse();

	//	Do ISAPI application and IIS access bits checking
	//
	m_sc = m_pmu->ScIISCheck (m_pwszURI, MD_ACCESS_WRITE);
	if (FAILED(m_sc))
	{
		//	Either the request has been forwarded, or some bad error occurred.
		//	In either case, quit here and map the error!
		//
		DebugTrace( "Dav: ScIISCheck() failed (0x%08lX)\n", m_sc );
		SendResponse();
		return;
	}

	//	From the HTTP/1.1 draft (update to RFC2068), Section 9.6:
	//		The recipient of the entity MUST NOT ignore any Content-*
	//		(e.g. Content-Range) headers that it does not understand
	//		or implement and MUST return a 501 (Not Implemented) response
	//		in such cases.
	//	So, let's do the checking....
	//
	if (m_pmu->LpwszGetRequestHeader(gc_szContent_Range, FALSE))
	{
		m_sc = E_DAV_NO_PARTIAL_UPDATE;	// 501 Not Implemented
		SendResponse();
		return;
	}

	//	For PUT, content-length is required
	//
	if (NULL == m_pmu->LpwszGetRequestHeader (gc_szContent_Length, FALSE))
	{
		pwsz = m_pmu->LpwszGetRequestHeader (gc_szTransfer_Encoding, FALSE);
		if (!pwsz || _wcsicmp (pwsz, gc_wszChunked))
		{
			DavTrace ("Dav: PUT: missing content-length in request\n");
			m_sc = E_DAV_MISSING_LENGTH;
			SendResponse();
			return;
		}
	}

	//	See if we are trying to trash the VROOT
	//
	if (m_pmu->FIsVRoot (m_pwszURI))
	{
		m_sc = E_DAV_PROTECTED_ENTITY;
		SendResponse();
		return;
	}

	//	This method is gated by If-xxx headers
	//
	m_sc = ScCheckIfHeaders (m_pmu.get(), m_pwszPath, FALSE);
	if (m_sc != S_OK)
	{
		DebugTrace ("Dav: If-xxx failed their check\n");
		SendResponse();
		return;
	}

	//	Check state headers.
	//
	m_sc = HrCheckStateHeaders (m_pmu.get(), m_pwszPath, FALSE);
	if (FAILED (m_sc))
	{
		DebugTrace ("DavFS: If-State checking failed.\n");
		SendResponse();
		return;
	}

	//	If we have a locktoken, try to get the lock handle from the cache.
	//	If this fails, fall through and do the normal processing.
	//	DO NOT put LOCK handles into an auto-object!!  The CACHE still owns it!!!
	//
	pwsz = m_pmu->LpwszGetRequestHeader (gc_szLockToken, TRUE);
	if (!pwsz || !FGetLockHandle (m_pmu.get(),
								  m_pwszPath,
								  GENERIC_WRITE,
								  pwsz,
								  &m_hf))
	{
		//	Open the file manually.
		//
		if (!m_hf.FCreate(
				DavCreateFile (m_pwszPath,							// filename
							   GENERIC_WRITE,						// dwAccess
							   0, //FILE_SHARE_READ | FILE_SHARE_WRITE,	// DO conflict with OTHER write locks
							   NULL,									// lpSecurityAttributes
							   OPEN_ALWAYS,							// creation flags
							   FILE_ATTRIBUTE_NORMAL |				// attributes
							   FILE_FLAG_OVERLAPPED |
							   FILE_FLAG_SEQUENTIAL_SCAN,
							   NULL)))								// template
		{
			DWORD dwErr = GetLastError();

			//	Return 409 Conflict in the case we were told that
			//	path was not found, that will indicate that the parent
			//	does not exist
			//
			if (ERROR_PATH_NOT_FOUND == dwErr)
			{
				m_sc = E_DAV_NONEXISTING_PARENT;
			}
			else
			{
				m_sc = HRESULT_FROM_WIN32(dwErr);
			}

			//	Special work for 416 Locked responses -- fetch the
			//	comment & set that as the response body.
			//
			if (FLockViolation (m_pmu.get(), dwErr, m_pwszPath, GENERIC_WRITE))
			{
				m_sc = E_DAV_LOCKED;
			}
			else
			{
				DWORD	dwFileAttr;

				//$Raid
				//	Special processing to find out if the resource is an
				//	existing directory
				//
				if (static_cast<DWORD>(-1) != (dwFileAttr = GetFileAttributesW (m_pwszPath)))
				{
					if (dwFileAttr & FILE_ATTRIBUTE_DIRECTORY)
						m_sc = E_DAV_COLLECTION_EXISTS;
				}
			}

			DebugTrace ("Dav: failed to open the file for writing\n");
			SendResponse();
			return;
		}

		//	Change the default error code to indicate the
		//	creation of the file or the existance of the file.
		//
		if (GetLastError() != ERROR_ALREADY_EXISTS)
		{
			//	Emit the location
			//
			m_pmu->EmitLocation (gc_szLocation, m_pwszURI, FALSE);
			m_fCreatedFile = TRUE;
		}
		//	Make sure the content-location reflects the corrected URI
		//
		else if (FTrailingSlash (m_pwszURI))
			m_pmu->EmitLocation (gc_szContent_Location, m_pwszURI, FALSE);
	}

	//
	//	Add a ref for the async persist and sloughf the data across.
	//	Note that we use an auto_ref_ptr rather than AddRef() directly
	//	because the persist call throws on failure and we need to clean
	//	up the reference if it does.
	//
	{
		auto_ref_ptr<CPutRequest> pRef(this);

		PutTrace( "DAV: TID %3d: 0x%08lX: CPutRequest::Execute() calling AsyncPersistRequestBody()\n", GetCurrentThreadId(), this );

		m_pmu->AsyncPersistRequestBody( *this, *this );

		pRef.relinquish();
	}
}

//	------------------------------------------------------------------------
//
//	CPutRequest::AsyncWrite()
//
//	Called indirectly from AsyncPersistRequestBody() periodically to
//	write bytes to the file.
//
void
CPutRequest::AsyncWrite( const BYTE * pbBuf,
						 UINT         cbToWrite,
						 IAsyncWriteObserver& obs )
{
	PutTrace( "DAV: TID %3d: 0x%08lX: CPutRequest::AsyncWrite() writing %d bytes\n", GetCurrentThreadId(), this, cbToWrite );

	//
	//	Stash the async write observer passed to us so that
	//	we can call it when the write completes
	//
	m_pobs = &obs;

	//
	//	Start writing.  I/O may complete before WriteFile() returns
	//	in which case we continue to execute synchronously.  If I/O
	//	is pending when WriteFile() returns, we complete the I/O
	//	asynchronously.
	//
	if ( WriteFile( m_hf.get(),
					pbBuf,
					cbToWrite,
					&m_dwcbWritten,
					&m_ov ) )
	{
		PutTrace( "DAV: TID %3d: 0x%08lX: CPutRequest::AsyncWrite(): WriteFile() succeeded\n", GetCurrentThreadId(), this );

		//
		//	WriteFile() executed synchronously, so call
		//	the completion routine now and keep processing
		//	on the current thread.
		//
		WriteComplete();
	}
	else if ( ERROR_IO_PENDING == GetLastError() )
	{
		PutTrace( "DAV: TID %3d: 0x%08lX: CPutRequest::AsyncWrite(): WriteFile() executing asynchronously...\n", GetCurrentThreadId(), this );

		//
		//	Set the polling delay to its initial value.  The polling delay
		//	is the amount of time before we'll check for I/O completion.
		//	As described in the CPutRequest class definition, this delay
		//	grows geometrically each time that the I/O is still pending
		//	when polled.  The value is only a hint -- polling may actually
		//	execute before or after, depending on server load.
		//
		m_dwMsecPollDelay = MSEC_POLL_DELAY_INITIAL;

		//
		//	WriteFile() is executing asynchronously, so make sure we
		//	find out when it completes.
		//
		PostIOCompletionPoll();
	}
	else
	{
		DebugTrace( "CPutRequest::AsyncWrite() - WriteFile() failed (%d)\n", GetLastError() );
		m_sc = HRESULT_FROM_WIN32(GetLastError());
		WriteComplete();
	}
}

//	------------------------------------------------------------------------
//
//	CPutRequest::PostIOCompletionPoll()
//
//	Post a work context to poll for WriteFile() I/O completion.
//
VOID
CPutRequest::PostIOCompletionPoll()
{
	PutTrace( "DAV: TID %3d: 0x%08lX: CPutRequest::PostIOCompletionPoll() called\n", GetCurrentThreadId(), this );

	//
	//	Post ourselves as a work context that will periodically
	//	poll for async I/O completion.  If successful our DwDoWork()
	//	(inherited from CDAVWorkContext) will eventually be called
	//	at some time > m_dwMsecPollDelay to poll for completion.
	//
	{
		auto_ref_ptr<CPutRequest> pRef(this);

		if ( CPoolManager::PostDelayedWork(this, m_dwMsecPollDelay) )
		{
			PutTrace( "DAV: TID %3d: 0x%08lX: CPutRequest::PostIOCompletionPoll(): PostDelayedWork() succeeded\n", GetCurrentThreadId(), this );
			pRef.relinquish();
			return;
		}
	}

	//
	//	If we were unable to post the work context for any reason
	//	we must wait for I/O completion and then call the completion
	//	routine manually.
	//
	DebugTrace( "CPutRequest::PostIOCompletionPoll() - CPoolManager::PostDelayedWork() failed (%d).  Waiting for completion....\n", GetLastError() );
	if ( GetOverlappedResult( m_hf.get(), &m_ov, &m_dwcbWritten, TRUE ) )
	{
		PutTrace( "DAV: TID %3d: 0x%08lX: CPutRequest::PostIOCompletionPoll(): GetOverlappedResult() succeeded\n", GetCurrentThreadId(), this );
		WriteComplete();
		return;
	}

	DebugTrace( "CPutRequest::PostIOCompletionPoll() - GetOverlappedResult() failed (%d).\n", GetLastError() );
	m_sc = HRESULT_FROM_WIN32(GetLastError());
	SendResponse();
}

//	------------------------------------------------------------------------
//
//	CPutRequest::DwDoWork()
//
//	Work completion callback routine.  Called when the work context posted
//	above executes.
//
DWORD
CPutRequest::DwDoWork()
{
	PutTrace( "DAV: TID %3d: 0x%08lX: CPutRequest::DwDoWork() called\n", GetCurrentThreadId(), this );

	//
	//	Take ownership of the reference added for posting.
	//
	auto_ref_ptr<CPutRequest> pRef;
	pRef.take_ownership(this);

	//
	//	Quickly check whether the I/O has completed.  If it has,
	//	then call the completion routine.  If not, then repost
	//	the polling context with a geometrically longer delay.
	//
	if ( HasOverlappedIoCompleted(&m_ov) )
	{
		PutTrace( "DAV: TID %3d: 0x%08lX: CPutRequest::DwDoWork(): Overlapped I/O complete\n", GetCurrentThreadId(), this );

		if ( !GetOverlappedResult( m_hf.get(),
								   &m_ov,
								   &m_dwcbWritten,
								   FALSE ) )
		{
			DebugTrace( "CPutRequest::DwDoWork() - Error in overlapped I/O (%d)\n", GetLastError() );
			m_sc = HRESULT_FROM_WIN32(GetLastError());
		}

		WriteComplete();
	}
	else
	{
		m_dwMsecPollDelay = (m_dwMsecPollDelay * POLL_DELAY_NUMERATOR) / POLL_DELAY_DENOMINATOR;

		PutTrace( "DAV: TID %3d: 0x%08lX: CPutRequest::DwDoWork(): I/O still pending.  Increasing delay to %lu msec.\n", GetCurrentThreadId(), this, m_dwMsecPollDelay );

		PostIOCompletionPoll();
	}

	return 0;
}

//	------------------------------------------------------------------------
//
//	CPutRequest::WriteComplete()
//
//	Called when WriteFile() I/O completes -- either synchronously or
//	asynchronously, with or without an error.
//
void
CPutRequest::WriteComplete()
{
	PutTrace( "DAV: TID %3d: 0x%08lX: CPutRequest::WriteComplete() called.  %d bytes written\n", GetCurrentThreadId(), this, m_dwcbWritten );

	//
	//	If there was an error, then gripe about it.
	//
	if ( FAILED(m_sc) )
		DebugTrace( "CPutRequest::WriteComplete() - Write() error (as an HRESULT) 0x%08lX\n", m_sc );

	//
	//	Update the current file position
	//
	m_ov.Offset += m_dwcbWritten;

	//
	//	Resume processing by notifying the observer
	//	we registered in AsyncWrite();
	//
	Assert( m_pobs );
	m_pobs->WriteComplete( m_dwcbWritten, m_sc );
}

//	------------------------------------------------------------------------
//
//	CPutRequest::PersistComplete()
//
//	AsyncPersistRequestBody() callback called when persisting completes.
//
VOID
CPutRequest::PersistComplete( HRESULT hr )
{
	PutTrace( "DAV: TID %3d: 0x%08lX: CPutRequest::PersistComplete() called\n", GetCurrentThreadId(), this );

	//
	//	Take ownership of the reference added for the async persist.
	//
	auto_ref_ptr<CPutRequest> pRef;
	pRef.take_ownership(this);

	//
	//	If the copy operation failed, gripe and send back
	//	an appropriate response.
	//
	m_sc = hr;
	if ( FAILED(m_sc ) )
	{
		DebugTrace( "CPutRequest::PersistComplete() - Error persiting request body (0x%08lX)\n", m_sc );
		SendResponse();
		return;
	}

	//
	//	Set EOF
	//
	SetFilePointer (m_hf.get(),
					m_ov.Offset,
					NULL,
					FILE_BEGIN);

	SetEndOfFile (m_hf.get());

	//	Set the Content-xxx properties
	//
	m_sc = ScSetContentProperties (m_pmu.get(), m_pwszPath, m_hf.get());
	if ( FAILED(m_sc) )
	{
		DebugTrace( "CPutRequest::PersistComplete() - ScSetContentProperties() failed (0x%08lX)\n", m_sc );
		SendResponse();
		return;
	}

	//	Passback an allow header
	//
	m_pmu->SetAllowHeader (RT_DOCUMENT);

	//	Send the response
	//
	SendResponse();
}

//	------------------------------------------------------------------------
//
//	CPutRequest::SendResponse()
//
//	Set the response code and send the response.
//
VOID
CPutRequest::SendResponse()
{
	PutTrace( "DAV: TID %3d: 0x%08lX: CPutRequest::SendResponse() called\n", GetCurrentThreadId(), this );

	//	Clear out any old handle here.  We can't send any response
	//	back while we are still holding a handle, otherwise, there
	//	exists the chance that a client request comes immediately to
	//	access this resource and receive 423 locked.
	//
	m_hf.clear();

	//
	//	Set the response code and go
	//
	if ( SUCCEEDED(m_sc) )
	{
		if ( m_fCreatedFile )
			m_sc = W_DAV_CREATED;
	}
	else
	{
		if ( m_fCreatedFile )
		{
			//	WARNING: the safe_revert class should only be
			//	used in very selective situations.  It is not
			//	a "quick way to get around" impersonation.
			//
			safe_revert sr(m_pmu->HitUser());

			DavDeleteFile (m_pwszPath);
			DebugTrace ("Dav: deleting partial put (%ld)\n", GetLastError());
		}
	}

	m_pmu->SetResponseCode (HscFromHresult(m_sc), NULL, 0, CSEFromHresult(m_sc));

	m_pmu->SendCompleteResponse();
}

/*
 *	DAVPut()
 *
 *	Purpose:
 *
 *		Win32 file system implementation of the DAV PUT method.	 The
 *		PUT method creates a file in the DAV name space and populates
 *		the file with the data found in the passed in request.  The
 *		response created indicates the success of the call.
 *
 *	Parameters:
 *
 *		pmu			[in]  pointer to the method utility object
 */
void
DAVPut (LPMETHUTIL pmu)
{
	auto_ref_ptr<CPutRequest> pRequest(new CPutRequest(pmu));

	PutTrace( "DAV: CPutRequest: TID %3d: 0x%08lX Calling CPutRequest::Execute() \n", GetCurrentThreadId(), pRequest );

	pRequest->Execute();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\httpext\fsmvcpy.cpp ===
/*
 *	 F S M V C P Y . C P P
 *
 *	Sources for directory ineration object
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davfs.h"
#include "_fsmvcpy.h"

#include "_shlkmgr.h"

//	ScAddMultiUrl
//		Helper function for XML emitting
//
SCODE
ScAddMultiFromUrl (
	/* [in] */ CXMLEmitter& emitter,
	/* [in] */ IMethUtil * pmu,
	/* [in] */ LPCWSTR pwszUrl,
	/* [in] */ ULONG hsc,
	/* [in] */ BOOL fCollection,
	/* [in] */ BOOL fMove = FALSE)
{
	SCODE sc = S_OK;

	//	NT#403615 -- Rosebud in Office9 or in NT5 re-issues a MOVE if they
	//	see a 401 inside the 207 Multi-Status response, which can result
	//	in data loss.
	//	WORKAROUND: If we are doing a MOVE, and the User-Agent string shows
	//	that this is Rosebud from Office9 or from NT5, change all 401s to 403s
	//	to avoid the problem -- Rosebud will not re-issue the MOVE, so the
	//	data (now sitting in the destination dir) will not be wiped.
	//	This is the minimal code needed to work around the problem.
	//
	if (fMove &&
		HSC_UNAUTHORIZED == hsc &&
		(pmu->FIsOffice9Request() || pmu->FIsRosebudNT5Request()))
	{
		hsc = HSC_FORBIDDEN;
	}

	//	Supress omitting of "Method Failure" node as it is a "SHOULD NOT"
	//	item in the DAV drafts.
	//	It's possible pszUrl passed in as NULL, in these cases, simply skip
	//	the emitting, do nothing
	//
	if ((hsc != HSC_METHOD_FAILURE) && pwszUrl)
	{
		auto_heap_ptr<CHAR> pszUrlEscaped;
		CEmitterNode enRes;
		UINT cchUrl;

		//$REVIEW: This is important, we should not start a xml document
		//$REVIEW: unless we have to. Otherwise, we may end up XML body
		//$REVIEW: when not necessary.
		//$REVIEW: So it's necessary to call ScSetRoot() to make sure
		//$REVIEW: that the xml document is intialized bofore continue
		//$REVIEW:
		//$REVIEW: This model works because in fsmvcpy.cpp, all the calls to
		//$REVIEW: XML emitter are through ScAddMultiFromUrl and ScAddMulti
		//$REVIEW:
		sc = emitter.ScSetRoot (gc_wszMultiResponse);
		if (FAILED (sc))
			goto ret;

		//	Construct the response
		//
		sc = enRes.ScConstructNode (emitter, emitter.PxnRoot(), gc_wszResponse);
		if (FAILED (sc))
			goto ret;

		//	Construct the href node
		//
		{
			CEmitterNode en;
			sc = enRes.ScAddNode (gc_wszXML__Href, en);
			if (FAILED (sc))
				goto ret;
			//	Set the value of the href node.  If the url is absolute,
			//	but not fully qualified, qualify it...
			//
			if (L'/' == *pwszUrl)
			{
				LPCSTR psz;
				UINT cch;

				//	Add the prefix
				//
				cch = pmu->CchUrlPrefix (&psz);
				sc = en.Pxn()->ScSetUTF8Value (psz, cch);
				if (FAILED (sc))
					goto ret;

				//$	REVIEW:	Does the host name need escaping?
				//
				//	Add the server
				//
				cch = pmu->CchServerName (&psz);
				sc = en.Pxn()->ScSetValue (psz, cch);
				if (FAILED (sc))
					goto ret;
			}

			//	Make the url wire safe
			//
			sc = ScWireUrlFromWideLocalUrl (static_cast<UINT>(wcslen(pwszUrl)),
											pwszUrl,
											pszUrlEscaped);
			if (FAILED (sc))
				goto ret;

			//	Add the url value
			//
			cchUrl = static_cast<UINT>(strlen(pszUrlEscaped.get()));
			sc = en.Pxn()->ScSetUTF8Value (pszUrlEscaped.get(), cchUrl);
			if (FAILED (sc))
				goto ret;

			//	If this is a collection, and the last char is not a
			//	trailing slash, add one....
			//
			if (fCollection && ('/' != pszUrlEscaped.get()[cchUrl-1]))
			{
				sc = en.Pxn()->ScSetUTF8Value ("/", 1);
				if (FAILED (sc))
					goto ret;
			}
		}

		//	Add the status/error string
		//
		sc = ScAddStatus (&enRes, hsc);
		if (FAILED (sc))
			goto ret;
	}

ret:
	return sc;
}

SCODE
ScAddMulti (
	/* [in] */ CXMLEmitter& emitter,
	/* [in] */ IMethUtil * pmu,
	/* [in] */ LPCWSTR pwszPath,
	/* [in] */ LPCWSTR pwszErr,
	/* [in] */ ULONG hsc,
	/* [in] */ BOOL fCollection,
	/* [in] */ CVRoot* pcvrTrans)
{
	SCODE sc = S_OK;

	//	Supress omitting of "Method Failure" node as it is a "SHOULD NOT"
	//	item in the DAV drafts.
	//
	if (hsc != HSC_METHOD_FAILURE)
	{
		CEmitterNode enRes;

		//$REVIEW: This is important, we should not start a xml document
		//$REVIEW: unless we have to. Otherwise, we may end up XML body
		//$REVIEW: when not necessary.
		//$REVIEW: So it's necessary to call ScSetRoot() to make sure
		//$REVIEW: that the xml document is intialized bofore continue
		//$REVIEW:
		//$REVIEW: This model works because in fsmvcpy.cpp, all the calls to
		//$REVIEW: XML emitter are through ScAddMultiFromUrl and ScAddMulti
		//$REVIEW:
		sc = emitter.ScSetRoot (gc_wszMultiResponse);
		if (FAILED (sc))
			goto ret;

		sc = enRes.ScConstructNode (emitter, emitter.PxnRoot(), gc_wszResponse);
		if (FAILED (sc))
			goto ret;

		sc = ScAddHref (enRes, pmu, pwszPath, fCollection, pcvrTrans);
		if (FAILED (sc))
			goto ret;

		sc = ScAddStatus (&enRes, hsc);
		if (FAILED (sc))
			goto ret;

		if (pwszErr)
		{
			sc = ScAddError (&enRes, pwszErr);
			if (FAILED (sc))
				goto ret;
		}
	}
ret:
	return sc;
}

//	class CAccessMetaOp -------------------------------------------------------
//
SCODE __fastcall
CAccessMetaOp::ScOp(LPCWSTR pwszMbPath, UINT cch)
{
	SCODE			sc;
	METADATA_RECORD	mdrec;

	Assert (MD_ACCESS_PERM == m_dwId);
	Assert (DWORD_METADATA == m_dwType);

	//	Get the value from the metabase and don't inherit
	//
	DWORD dwAcc = 0;
	DWORD cb = sizeof(DWORD);

	mdrec.dwMDIdentifier = m_dwId;
	mdrec.dwMDAttributes = METADATA_NO_ATTRIBUTES;
	mdrec.dwMDUserType = 0;
	mdrec.dwMDDataType = m_dwType;
	mdrec.dwMDDataLen = cb;
	mdrec.pbMDData = reinterpret_cast<LPBYTE>(&dwAcc);

	sc = m_mdoh.HrGetMetaData( pwszMbPath,
							   &mdrec,
							   &cb );
	if (FAILED(sc))
	{
		MCDTrace ("CAccessMetaOp::ScOp() - CMDObjectHandle::HrGetMetaData() failed 0x%08lX\n", sc);
		//	We will ignore any NOT_FOUND type errors
		//
		if ((HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == sc) ||
							(MD_ERROR_DATA_NOT_FOUND == sc))
			sc = S_OK;		
		goto ret;
	}

	//	Hey, we got a value, so let's do our quick check..
	//
	if (m_dwAcc == (dwAcc & m_dwAcc))
	{
		//	We have full required access to this node, so
		//	we can proceed.
		//
		Assert (S_OK == sc);
	}
	else
	{
		//	We do not have access to operate on this item and
		//	it's inherited children.
		//
		MCDTrace ("CAccessMetaOp::ScOp() - no access to '%S'\n", pwszMbPath);
		m_fAccessBlocked = TRUE;

		//	We know enough...
		//
		sc = S_FALSE;
	}

ret:

	return sc;
}

//	class CAuthMetaOp -------------------------------------------------------
//
SCODE __fastcall
CAuthMetaOp::ScOp(LPCWSTR pwszMbPath, UINT cch)
{
	SCODE			sc;
	METADATA_RECORD	mdrec;

	Assert (MD_AUTHORIZATION == m_dwId);
	Assert (DWORD_METADATA == m_dwType);

	//	Get the value from the metabase and don't inherit
	//
	DWORD dwAuth = 0;
	DWORD cb = sizeof(DWORD);

	mdrec.dwMDIdentifier = m_dwId;
	mdrec.dwMDAttributes = METADATA_NO_ATTRIBUTES;
	mdrec.dwMDUserType = 0;
	mdrec.dwMDDataType = m_dwType;
	mdrec.dwMDDataLen = cb;
	mdrec.pbMDData = reinterpret_cast<LPBYTE>(&dwAuth);

	sc = m_mdoh.HrGetMetaData( pwszMbPath,
							   &mdrec,
							   &cb );
	if (FAILED(sc))
	{
		MCDTrace ("CAuthMetaOp::ScOp() - CMDObjectHandle::HrGetMetaData() failed 0x%08lX\n", sc);
		//	We will ignore any NOT_FOUND type errors
		//
		if ((HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == sc) ||
							(MD_ERROR_DATA_NOT_FOUND == sc))
			sc = S_OK;		
		goto ret;
	}

	//	Hey, we got a value, so let's do our quick check..
	//
	if (m_dwAuth == dwAuth)
	{
		Assert(S_OK == sc);
	}
	else
	{
		//	We do not have access to operate on this item and
		//	it's inherited children.
		//
		MCDTrace ("CAuthMetaOp::ScOp() - authorization differs, no access to '%S'\n", pwszMbPath);
		m_fAccessBlocked = TRUE;

		//	We know enough...
		//
		sc = S_FALSE;
	}

ret:

	return sc;
}

//	class CIPRestrictionMetaOp ------------------------------------------------
//
SCODE __fastcall
CIPRestrictionMetaOp::ScOp(LPCWSTR pwszMbPath, UINT cch)
{
	SCODE			sc;
	METADATA_RECORD	mdrec;

	Assert (MD_IP_SEC == m_dwId);
	Assert (BINARY_METADATA == m_dwType);

	//	Get the value from the metabase and don't inherit
	//
	DWORD cb = 0;

	mdrec.dwMDIdentifier = m_dwId;
	mdrec.dwMDAttributes = METADATA_NO_ATTRIBUTES;
	mdrec.dwMDUserType = 0;
	mdrec.dwMDDataType = m_dwType;
	mdrec.dwMDDataLen = cb;
	mdrec.pbMDData = NULL;

	sc = m_mdoh.HrGetMetaData( pwszMbPath,
							   &mdrec,
							   &cb );
	if (FAILED(sc) && (0 == cb))
	{
		MCDTrace ("CIPRestrictionMetaOp::ScOp() - CMDObjectHandle::HrGetMetaData() failed 0x%08lX, but that means success in this path\n", sc);

		//	We will ignore any NOT_FOUND type errors
		//
		if ((HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == sc) ||
							(MD_ERROR_DATA_NOT_FOUND == sc))
			sc = S_OK;
	}
	else
	{
		Assert (S_OK == sc ||
				HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == sc);

		//	Hey, we got a value, and we don't want to check here so
		//	we are going to be pessimistic about this one....
		//
		MCDTrace ("CIPRestrictionMetaOp::ScOp() - IPRestriction exists in tree '%S'\n", pwszMbPath);
		m_fAccessBlocked = TRUE;

		//	We know enough...
		//
		sc = S_FALSE;
	}

	return sc;
}

//	ScCheckMoveCopyDeleteAccess() ---------------------------------------------
//
SCODE __fastcall
ScCheckMoveCopyDeleteAccess (
	/* [in] */ IMethUtil* pmu,
	/* [in] */ LPCWSTR pwszUrl,
	/* [in] */ CVRoot* pcvr,
	/* [in] */ BOOL fDirectory,
	/* [in] */ BOOL fCheckScriptmaps,
	/* [in] */ DWORD dwAccess,
	/* [out] */ SCODE* pscItem,
	/* [in] */ CXMLEmitter& msr)
{
	SCODE sc = S_OK;

	//	Check with the CMethUtil on whether or not we have access
	//
	sc = pmu->ScCheckMoveCopyDeleteAccess (pwszUrl,
										   pcvr,
										   fDirectory,
										   fCheckScriptmaps,
										   dwAccess);

	//	Pass back the results...
	//
	*pscItem = sc;

	//	... and if the call cannot proceed, then add the item to the
	//	multi-status response.
	//
	if (FAILED (sc))
	{
		//	Add to the reponse XML
		//
		sc = ScAddMultiFromUrl (msr,
								pmu,
								pwszUrl,
								HscFromHresult(sc),
								fDirectory);
		if (!FAILED (sc))
			sc = W_DAV_PARTIAL_SUCCESS;
	}

	return sc;
}

//	Directory deletes ---------------------------------------------------------
//
/*
 *	ScDeleteDirectory()
 *
 *	Purpose:
 *
 *		Helper function used to iterate through a directory
 *		and delete all its contents as well as the directory
 *		itself.
 *
 *	Notes:
 *
 *		BIG FAT NOTE ABOUT LOCKING.
 *
 *		The Lock-Token header may contain locks that we have to use in
 *		this operation.
 *		The following code was written with these assumptions:
 *		o	Directory locks are NOT SUPPORTED on davfs.
 *		o	Locks only affect the ability to WRITE to a resource.
 *			(The only currently supported locktype on davfs is WRITE.)
 *		o	This function may be called from DELETE or other methods.
 *			(If called from DELETE, we want to DROP the locks listed.)
 *		Because of these two assumptions, we only check the passed-in
 *		locktokens when we have a write-error (destination).
 *
 *		Locking uses the final two parameters.  plth is a
 *		pointer to a locktoken header parser object.  If we have a plth,
 *		then we must check it for provided locktokens when we hit a lock
 *		conflict. If a locktoken is provided, the failed delete operation
 *		should NOT be reported as an error, but instead skipped here
 *		(to be handled by the calling routine later in the operation) OR
 *		the lock should be dropped here and the delete attempted again.
 *		The fDeleteLocks variable tells whether to drop locks (TRUE),
 *		or to skip the deleteion of locked items that have locktokens.
 *
 *		Basic logic:
 *			Try to delete.
 *			If LOCKING failure (ERROR_SHARING_VIOLATION), check the plth.
 *			If the plth has a locktoken for this path, check fDeleteLocks.
 *			If fDeleteLocks == TRUE, drop the lock and try the delte again.
 *			If fDeleteLocks == FALSE, skip this file and move on.
 */
SCODE
ScDeleteDirectory (
	/* [in] */ IMethUtil* pmu,
	/* [in] */ LPCWSTR pwszUrl,
	/* [in] */ LPCWSTR pwszDir,
	/* [in] */ BOOL fCheckAccess,
	/* [in] */ DWORD dwAcc,
	/* [in] */ LONG lDepth,
	/* [in] */ CVRoot* pcvrTranslate,
	/* [in] */ CXMLEmitter& msr,
	/* [out] */ BOOL* pfDeleted,
	/* [in] */ CParseLockTokenHeader* plth,	// Usually NULL -- no locktokens to worry about
	/* [in] */ BOOL fDeleteLocks)			// Normally FALSE -- don't drop locks
{
	BOOL fOneSkipped = FALSE;
	ChainedStringBuffer<WCHAR> sb;
	SCODE sc = S_OK;
	SCODE scItem = S_OK;
	std::list<LPCWSTR, heap_allocator<LPCWSTR> > lst;

	CDirIter di(pwszUrl,
				pwszDir,
				NULL,	// no-destination for deletes
				NULL,	// no-destination for deletes
				NULL,	// no-destination for deletes
				TRUE);	// recurse into sub-driectories

	Assert (pfDeleted);
	*pfDeleted = TRUE;

	//	A SMALL FAT NOTE ABOUT ACCESS
	//
	//	The caller of this method is required to sniff the tree
	//	prior to this call.  If there is any access block in the
	//	tree, then each item will be checked for access before the
	//	operation proceeds.
	//
	const DWORD dwDirectory = MD_ACCESS_READ | MD_ACCESS_WRITE;
	const DWORD dwFile = MD_ACCESS_WRITE;
	if (fCheckAccess & (0 == (dwAcc & MD_ACCESS_READ)))
	{
		DebugTrace ("Dav: MCD: no permissions for deleting\n");
		sc = E_DAV_NO_IIS_READ_ACCESS;
		*pfDeleted = FALSE;
		goto ret;
	}

	//	Push the current path
	//
	//$	REVIEW: if "depth: infinity,no-root" ever needs to be supported,
	//	it really is as simple as not pushing the current path.
	//
	if (DEPTH_INFINITY_NOROOT != lDepth)
	{
		Assert (DEPTH_INFINITY == lDepth);
		lst.push_back(pwszDir);
	}

	//	Iterate through the directories.  Deleting files and pushing
	//	directory names as we go.
	//
	//	We really only want to push into the child directories if the
	//	operation on the parent succeeds.
	//
	while (S_OK == di.ScGetNext(!FAILED (scItem)))
	{
		//	Check our access rights and only push down into the directory
		//	if we have access to delete its contents.
		//
		// 	Note that we need read and write access to enum and delete
		//	a directory, but we need only write access in order to delete
		//	a file.
		//
		if (fCheckAccess)
		{
			sc = ScCheckMoveCopyDeleteAccess (pmu,
											  di.PwszUri(),
											  pcvrTranslate,
											  di.FDirectory(),
											  FALSE, // don't check scriptmaps
											  di.FDirectory() ? dwDirectory : dwFile,
											  &scItem,
											  msr);
			if (FAILED (sc))
				goto ret;

			//	If things were not 100%, don't process this resource
			//
			if (S_OK != sc)
				continue;
		}

		//	Process the file
		//
		if (di.FDirectory())
		{
			auto_ref_ptr<CVRoot> pcvr;

			if (di.FSpecial())
				continue;

			//	Child virtual root scriptmappings have been
			//	handled via ScCheckMoveCopyDeleteAccess(),
			//	and the physical deleting happens after this
			//	call completes!
			//
			//	So there is no need to do any special processing
			//	other than to push the directory and move on...
			//
			lst.push_back (AppendChainedSz (sb, di.PwszSource()));
			scItem = S_OK;
		}
		else
		{
			//	Delete the file
			//
			//	NOTE: We've already checked that we have write access.
			//	Also keep in mind that the ordering in which the directory
			//	traversals occur allows us to still key off of scItem to
			//	determine if we should push down into subdirectories.
			//
			//	This is because the directory entry is processed BEFORE
			//	any children are processed.  So the iteration on the dir
			//	will reset the scItem with the appropriate scode for access.
			//
			MCDTrace ("Dav: MCD: deleting '%ws'\n", di.PwszSource());
			if (!DavDeleteFile (di.PwszSource()))
			{
				DWORD dwLastError = GetLastError();
				ULONG hsc = HscFromLastError(dwLastError);
				
				DebugTrace ("Dav: MCD: failed to delete file (%d)\n", dwLastError);

				//	If it's a sharing (lock) violation, AND we have a
				//	locktoken for this path (lth.GetToken(pwsz))
				//	skip this path.
				//
				if ((ERROR_SHARING_VIOLATION == dwLastError) && plth)
				{
					LARGE_INTEGER liLockID;

					//	If we have a locktoken for this path, skip it.
					//
					scItem = plth->HrGetLockIdForPath(di.PwszSource(),
												     GENERIC_WRITE,
												     &liLockID);
					if (SUCCEEDED (scItem))
					{
						//	Should we try to delete locks?
						//
						if (!fDeleteLocks)
						{
							//	Don't delete locks.  Just skip this item.
							//	Remember that we skipped it, tho, so we don't
							//	complain about deleting the parent dir below.
							//
							fOneSkipped = TRUE;
							continue;
						}
						else
						{
							//	Drop the lock & try again.
							//
							scItem = CSharedLockMgr::Instance().HrDeleteLock(pmu->HitUser(),
																		liLockID);
							if (SUCCEEDED(scItem))
							{
								if (DavDeleteFile(di.PwszSource()))
								{
									//	We're done with this item.  Move along.
									//
									continue;
								}
								
								//	Else, record the error in our XML
								//
								hsc = HscFromLastError(GetLastError());
							}
							else
							{
								hsc = HscFromHresult(scItem);
							}							
						}
					}
					//	else, record the error in our XML.
					//
				}

				//	Add to the reponse XML
				//
				sc = ScAddMultiFromUrl (msr,
										pmu,
										di.PwszUri(),
										hsc,
										di.FDirectory());
				if (FAILED (sc))
					goto ret;

				sc = W_DAV_PARTIAL_SUCCESS;
			}
		}
	}

	//	Now that all the files are deleted, we can start deleting
	//	the directories.
	//
	while (!lst.empty())
	{
		MCDTrace ("Dav: MCD: removing '%ws'\n", lst.back());

		//	Try to delete the dir.  If it doesn't delete, check our
		//	"skipped because of a lock above" flag before complaining.
		//
		//$	LATER: Fix this to actually lookup the dir path in the
		//	lockcache (using "fPathLookup").
		//
		if (!DavRemoveDirectory (lst.back()) && !fOneSkipped)
		{
			DWORD dw = GetLastError();
			DebugTrace ("Dav: MCD: failed to delete directory: %ld\n", dw);

			//	Add to the reponse XML
			//
			sc = ScAddMulti (msr,
							 pmu,
							 lst.back(),
							 NULL,
							 HscFromLastError(dw),
							 TRUE,				//	We know it's a directory
							 pcvrTranslate);
			if (FAILED (sc))
				goto ret;

			sc = W_DAV_PARTIAL_SUCCESS;
			*pfDeleted = FALSE;
		}
		lst.pop_back();
	}

ret:
	return sc;
}

SCODE
ScDeleteDirectoryAndChildren (
	/* [in] */ IMethUtil* pmu,
	/* [in] */ LPCWSTR pwszUrl,
	/* [in] */ LPCWSTR pwszPath,
	/* [in] */ BOOL fCheckAccess,
	/* [in] */ DWORD dwAcc,
	/* [in] */ LONG lDepth,
	/* [in] */ CXMLEmitter& msr,
	/* [in] */ CVRoot* pcvrTranslate,
	/* [out] */ BOOL* pfDeleted,
	/* [in] */ CParseLockTokenHeader* plth,	// Usually NULL -- no locktokens to worry about
	/* [in] */ BOOL fDeleteLocks)			// Normally FALSE -- don't drop locks
{
	BOOL fPartial = FALSE;
	SCODE sc = S_OK;

	//	Delete the main body first
	//
	MCDTrace ("Dav: MCD: deleting '%ws'\n", pwszPath);
	sc = ScDeleteDirectory (pmu,
							pwszUrl,
							pwszPath,
							fCheckAccess,
							dwAcc,
							lDepth,
							pcvrTranslate, // translations are pmu based
							msr,
							pfDeleted,
							plth,
							fDeleteLocks);
	if (!FAILED (sc))
	{
		//	Enumerate the child vroots and perform the
		//	deletion of those directories as well
		//
		ChainedStringBuffer<WCHAR> sb;
		CVRList vrl;

		//	Cleanup the list such that our namespaces are in
		//	a reasonable order.
		//
		(void) pmu->ScFindChildVRoots (pwszUrl, sb, vrl);
		vrl.sort();

		for ( ; !FAILED(sc) && !vrl.empty(); vrl.pop_front())
		{
			auto_ref_ptr<CVRoot> pcvr;
			CResourceInfo cri;
			LPCWSTR pwszChildUrl;
			LPCWSTR pwszChildPath;
			SCODE scItem;

			//	Remember any partial returns
			//
			if (W_DAV_PARTIAL_SUCCESS == sc)
				fPartial = TRUE;

			if (pmu->FGetChildVRoot (vrl.front().m_pwsz, pcvr))
			{
				//	Note, only check access if required
				//
				Assert (fCheckAccess);
				pcvr->CchGetVRoot (&pwszChildUrl);
				pcvr->CchGetVRPath (&pwszChildPath);
				sc = ScCheckMoveCopyDeleteAccess (pmu,
												  pwszChildUrl,
												  pcvr.get(),
												  TRUE, // Directory
												  FALSE, // dont check scriptmaps
												  MD_ACCESS_READ|MD_ACCESS_WRITE,
												  &scItem,
												  msr);
				if (FAILED (sc))
					goto ret;

				//	If things were not 100%, don't process this resource
				//
				if (S_OK != sc)
					continue;

				//	Delete the sub-virtual roots files and and continue on
				//
				sc = ScDeleteDirectory (pmu,
										pwszChildUrl,
										pwszChildPath,
										fCheckAccess,
										dwAcc,
										DEPTH_INFINITY,
										pcvr.get(),
										msr,
										pfDeleted,
										plth,
										fDeleteLocks);
				if (FAILED (sc))
				{
					sc = ScAddMultiFromUrl (msr,
											pmu,
											pwszChildUrl,
											HscFromHresult(sc),
											TRUE); // We know it's a directory
					if (FAILED (sc))
						goto ret;

					sc = W_DAV_PARTIAL_SUCCESS;
					*pfDeleted = FALSE;
				}
			}
		}
	}

ret:

	return ((S_OK == sc) && fPartial) ? W_DAV_PARTIAL_SUCCESS : sc;
}

//	class CContentTypeMetaOp --------------------------------------------------
//
SCODE __fastcall
CContentTypeMetaOp::ScOp(LPCWSTR pwszMbPath, UINT cchSrc)
{
	Assert (MD_MIME_MAP == m_dwId);
	Assert (MULTISZ_METADATA == m_dwType);

	//	Ok, we are going to get the data and copy it across
	//	if there is a destination path.
	//
	if (NULL != m_pwszDestPath)
	{
		WCHAR prgchContentType[MAX_PATH];

		auto_heap_ptr<WCHAR> pwszContentType;
		CMDObjectHandle mdohDest(*m_pecb);
		CStackBuffer<WCHAR,128> pwsz;
		DWORD cb = sizeof(prgchContentType);
		LPBYTE pbValue = reinterpret_cast<LPBYTE>(prgchContentType);
		LPWSTR pwszLowest;
		METADATA_RECORD	mdrec;
		SCODE sc = S_OK;
		UINT cchBase;

		MCDTrace ("CContentTypeMetaOp::ScOp() - content-type: copying for '%S%S'...\n",
				  m_pwszMetaPath,
				  pwszMbPath);

		mdrec.dwMDIdentifier = m_dwId;
		mdrec.dwMDAttributes = METADATA_NO_ATTRIBUTES;
		mdrec.dwMDUserType = 0;
		mdrec.dwMDDataType = m_dwType;
		mdrec.dwMDDataLen = cb;
		mdrec.pbMDData = pbValue;

		sc = m_mdoh.HrGetMetaData( pwszMbPath,
								   &mdrec,
								   &cb );
		if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == sc)
		{
			pwszContentType = static_cast<LPWSTR>(g_heap.Alloc(cb));
			pbValue = reinterpret_cast<LPBYTE>(pwszContentType.get());

			mdrec.dwMDIdentifier = m_dwId;
			mdrec.dwMDAttributes = METADATA_NO_ATTRIBUTES;
			mdrec.dwMDUserType = 0;
			mdrec.dwMDDataType = m_dwType;
			mdrec.dwMDDataLen = cb;
			mdrec.pbMDData = pbValue;

			sc = m_mdoh.HrGetMetaData( pwszMbPath,
									   &mdrec,
									   &cb );
		}
		if (FAILED(sc))
		{
			//$	REVIEW: should failure to copy a content-type
			//	fail the call? So we will ignore any NOT_FOUND
			//	type errors
			//
			if ((HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == sc) ||
								(MD_ERROR_DATA_NOT_FOUND == sc))
				sc = S_OK;
			
			goto ret;
		}

		//	We sucesfully read some metadata. Remember the size.
		//
		cb = mdrec.dwMDDataLen;
		m_mdoh.Close();

		//	The destination path is the comprised of the stored
		//	destination path and the tail of the original source
		//	path.
		//
		MCDTrace ("CContentTypeMetaOp::ScOp() - content-type: ...to '%S%S'\n",
				  m_pwszDestPath,
				  pwszMbPath);

		//	Construct an metabase path for lowest node construction
		//
		cchBase = static_cast<UINT>(wcslen(m_pwszDestPath));
		if (NULL == pwsz.resize(CbSizeWsz(cchBase + cchSrc)))
		{
			sc = E_OUTOFMEMORY;
			goto ret;
		}

		//	Before we construct anything, make sure that we are not
		//	doing something stupid and creating two '//' in a row.
		//
		if ((L'/' == m_pwszDestPath[cchBase - 1]) &&
			(L'/' == *pwszMbPath))
		{
				cchBase -= 1;
		}
		memcpy (pwsz.get(), m_pwszDestPath, cchBase * sizeof(WCHAR));
		memcpy (pwsz.get() + cchBase, pwszMbPath, (cchSrc + 1) * sizeof(WCHAR));

		//	Release our hold on the metabase.  We need to do this
		//	because it is possible that the common root between
		//	the two nodes, may be in the same hierarchy.
		//
		//	NOTE: this should only really happen one time per
		//	move/copy operation.  The reason being that the lowest
		//	node will be established outside of the scope of the
		//	source on the first call.
		//
		sc = HrMDOpenLowestNodeMetaObject(pwsz.get(),
										  METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
										  &pwszLowest,
										  &mdohDest);
		if (SUCCEEDED(sc))
		{
			mdrec.dwMDIdentifier = m_dwId;
			mdrec.dwMDAttributes = METADATA_INHERIT;
			mdrec.dwMDUserType = IIS_MD_UT_FILE;
			mdrec.dwMDDataType = m_dwType;
			mdrec.dwMDDataLen = cb;
			mdrec.pbMDData = pbValue;

			(void) mdohDest.HrSetMetaData(pwszLowest, &mdrec);
			mdohDest.Close();
		}

		//	Reaquire our hold on the metabase
		//
		sc = HrMDOpenMetaObject( m_pwszMetaPath,
								 m_fWrite ? METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE : METADATA_PERMISSION_READ,
								 5000,
								 &m_mdoh);
		if (FAILED (sc))
			goto ret;
	}

	//	If this is a move, then delete the source
	//
	if (m_fDelete)
	{
		MCDTrace ("Dav: MCD: content-type: deleting from '%S'\n", pwszMbPath);
		(void) m_mdoh.HrDeleteMetaData( pwszMbPath,
										m_dwId,
										m_dwType);
	}

ret:

	return S_OK;
}

//	Directory moves/copies ----------------------------------------------------
//
/*
 *	ScMoveCopyDirectory()
 *
 *	Purpose:
 *
 *		Helper function used to iterate through a directory
 *		and copy all its contents to a destination directory.
 *
 *	Notes:
 *
 *		BIG FAT NOTE ABOUT LOCKING.
 *
 *		The Lock-Token header may contain locks that we have to use in
 *		this operation.
 *		The following code was written with these assumptions:
 *		o	Directory locks are NOT SUPPORTED on davfs.
 *		o	Locks only affect the ability to WRITE to a resource.
 *			(The only currently supported locktype on davfs is WRITE.)
 *		Because of these two assumptions, we only check the passed-in
 *		locktokens when we have a write-error (destination).
 */
SCODE
ScMoveCopyDirectory (
	/* [in] */ IMethUtil* pmu,
	/* [in] */ LPCWSTR pwszUrl,
	/* [in] */ LPCWSTR pwszSrc,
	/* [in] */ LPCWSTR pwszUrlDst,
	/* [in] */ LPCWSTR pwszDst,
	/* [in] */ BOOL fMove,
	/* [in] */ DWORD dwReplace,
	/* [in] */ BOOL fCheckAccess,
	/* [in] */ BOOL fCheckDestinationAccess,
	/* [in] */ DWORD dwAcc,
	/* [in] */ CVRoot* pcvrTranslateSrc,
	/* [in] */ CVRoot* pcvrTranslateDst,
	/* [in] */ CXMLEmitter& msr,
	/* [in] */ LONG lDepth,
	/* [in] */ CParseLockTokenHeader* plth)	// Usually NULL -- no locktokens to worry about
{
	auto_ref_ptr<CVRoot> pcvrDestination(pcvrTranslateDst);
	ChainedStringBuffer<WCHAR> sb;
	LPCWSTR pwszDestinationRedirect = NULL;
	SCODE sc = S_OK;
	SCODE scItem = S_OK;
	std::list<LPCWSTR, heap_allocator<LPCWSTR> > lst;

	CDirIter di(pwszUrl,
				pwszSrc,
				pwszUrlDst,
				pwszDst,
				pcvrTranslateDst,
				TRUE);	// Traverse into sub-directories

	//	See if there is a path conflict
	//
	if (FPathConflict (pwszSrc, pwszDst))
	{
		DebugTrace ("Dav: source and dest are in conflict\n");
		sc = E_DAV_CONFLICTING_PATHS;
		goto ret;
	}

	//	Ok, for MOVE requests where there is no blocked
	//	access along the way we can do the whole thing
	//	in one big shot.
	//
	//	Otherwise we are going to try and do this piece-wise.
	//
	//$	REVIEW:
	//
	//	Normally, we would do something like the following
	//
	//		if (!fMove ||
	//			fCheckAccess ||
	//			fCheckDestinationAccess ||
	//			!DavMoveFile (pwszSrc, pwszDst, dwReplace))
	//
	//	However, if the above code is used, IIS holds a lock
	//	on the moved source directory.  This prevents further
	//	access to that physical path.  NtCreateFile() reports
	//	a status of "DELETE PENDING" on the locked directory
	//	Win32 API's report "ACCESS DENIED"
	//
	//	If we do the degenerate case of always copying the root
	//	by hand, it reduces the likely hood of the lock out.
	//
	//	When this code gets checked in, a bug should be filed
	//	against IIS over this lock issue.  If and only if they
	//	do not fix this, will we fall back to the degenerate
	//	code.
	//
	if (!fMove ||
		fCheckAccess ||
		fCheckDestinationAccess ||
		!DavMoveFile (pwszSrc, pwszDst, dwReplace))
	//
	//$	REVIEW: end
	{
		//	Create the destination directory
		//
		if (!DavCreateDirectory (pwszDst, NULL))
		{
			//	If we have locks, and the dir is already there, it's okay.
			//	Otherwise, return an error.
			//
			//$	LATER: Fix this to actually lookup the dir path in the
			//	lockcache (using "fPathLookup").
			//
			if (!plth)
			{
				DWORD dw = GetLastError();
				if ((dw ==  ERROR_FILE_EXISTS) || (dw == ERROR_ALREADY_EXISTS))
					sc = E_DAV_OVERWRITE_REQUIRED;
				else
					sc = HRESULT_FROM_WIN32(dw);

				DebugTrace ("Dav: MCD: failed to create destination\n");
				goto ret;
			}
		}

		//	Slurp the properties over for the root directory
		//	We need to copy the properties first,
		//	Note, Currently, this call must be ahead of FInstantiate,
		//	as FInstantiate will keep the src dir open, and we won't be able to
		// 	get a IPropertyBagEx with STGM_SHARE_EXCLUSIVE, which is
		//	required by current nt5 impl. as STGM_SHARE_SHARE_WRITE
		//	does not work with IPropertyBagEx::Enum.
		//
		sc = ScCopyProps (pmu, pwszSrc, pwszDst, TRUE);
		if (FAILED(sc))
		{
			//	Do our best to remove the turd directory
			//
			DavRemoveDirectory (pwszDst);
			goto ret;
		}

		//	For MOVE's, push the current path
		//
		if (fMove)
			lst.push_back (pwszSrc);
	}
	else //	!fMove || fCheckAccess || fCheckDestinationAccess || !MoveFileEx()
	{
		Assert (DEPTH_INFINITY == lDepth);

		//	Ok, this is the cool bit.  If this succeeded,
		//	there there is no more processing required.
		//
		goto ret;
	}

	//	If we are not asked to copy internal members,
	//	then we are done
	//
	if (DEPTH_INFINITY != lDepth)
	{
		Assert (!fMove);
		goto ret;
	}

	//	Iterate through the directories -- copying as we go
	//
	while (S_OK == di.ScGetNext(!FAILED (scItem),
								pwszDestinationRedirect,
							    pcvrDestination.get()))
	{
		//$	REVIEW:
		//
		//	We have a very nasty case that we need to be
		//	able to handle...
		//
		//	If a virtual root already exists along the path of
		//	the destination, we need to redirect out destination
		//	path to the vrpath of that virtual root.
		//
		//	Reset the destination redirection
		//
		pwszDestinationRedirect = di.PwszDestination();
		pcvrDestination = di.PvrDestination();
		//
		//$	REVIEW: end

		//	Before anything, if this is one of the specials,
		//	do nothing...
		//
		if (di.FSpecial())
			continue;

		if (fCheckAccess)
		{
			//	Check our access rights and only push down
			//	into the directory if and only if we have access.
			//
			sc = ScCheckMoveCopyDeleteAccess (pmu,
											  di.PwszUri(),
											  pcvrTranslateSrc,
											  di.FDirectory(),
											  TRUE, // check scriptmaps
											  dwAcc,
											  &scItem,
											  msr);
			if (FAILED (sc))
				goto ret;

			//	If things were not 100%, don't process this resource
			//
			if (S_OK != sc)
				continue;
		}

		if (fCheckDestinationAccess)
		{
			//$	REVIEW:
			//
			//	We have a very nasty case that we need to be
			//	able to handle...
			//
			//	If a virtual root already exists along the path of
			//	the destination, we need to redirect out destination
			//	path to the vrpath of that virtual root.
			//
			//	Look for a virtual root matching the destination url,
			//	and set the redirect path if need be.
			//
			if (pmu->FFindVRootFromUrl(di.PwszUriDestination(), pcvrDestination))
			{
				MCDTrace ("Dav: MCD: destination url maps to virtual root\n");

				//	All access checking, including scriptmap honors are handled
				//	by ScCheckMoveCopyDeleteAccess()
				//

				//	Redirect the destination
				//
				pcvrDestination->CchGetVRPath (&pwszDestinationRedirect);
			}
			//
			//$	REVIEW: end

			//	Same kind of deal -- check our access rights and
			//	only push down into the directory if and only if
			//	we have access.
			//
			sc = ScCheckMoveCopyDeleteAccess (pmu,
											  di.PwszUriDestination(),
											  pcvrDestination.get(),
											  di.FDirectory(),
											  TRUE, // check scriptmap on dest
											  MD_ACCESS_WRITE,
											  &scItem,
											  msr);
			if (FAILED (sc))
				goto ret;

			//	If things were not 100%, don't process this resource
			//
			if (S_OK != sc)
				continue;
		}

		MCDTrace ("Dav: MCD: moving/copying '%S' to '%S'\n",
				  di.PwszSource(),
				  pwszDestinationRedirect);

		//	If we are moving, then just try the generic MoveFileW(),
		//	and if it fails, then do it piecewise...
		//
		if (!fMove ||
			fCheckAccess ||
			fCheckDestinationAccess ||
			!DavMoveFile (di.PwszSource(),
						  pwszDestinationRedirect,
						  dwReplace))
		{
			scItem = S_OK;

			//	If we found another directory, then iterate on it
			//
			if (di.FDirectory())
			{
				//	We need to create the sister directory in
				//	the destination directory
				//
				if (DavCreateDirectory (pwszDestinationRedirect, NULL) || plth)
				{
					scItem = ScCopyProps (pmu,
										  di.PwszSource(),
										  pwszDestinationRedirect,
										  TRUE);

					if (FAILED (scItem))
					{
						//	Do our best to remove the turd directory
						//
						DavRemoveDirectory (pwszDestinationRedirect);
					}

					//	For all MOVEs push the directory
					//
					if (!FAILED (scItem) && fMove)
					{
						lst.push_back (AppendChainedSz(sb, di.PwszSource()));
					}
				}
				else
				{
					DebugTrace ("Dav: MCD: failed to create directory\n");
					scItem = HRESULT_FROM_WIN32(GetLastError());
				}

				if (FAILED (scItem))
				{
					//	Add to the reponse XML
					//
					sc = ScAddMultiFromUrl (msr,
											pmu,
											di.PwszUri(),
											HscFromHresult(scItem),
											di.FDirectory());
					if (FAILED (sc))
						goto ret;

					sc = W_DAV_PARTIAL_SUCCESS;
				}
			}
			else
			{
				//	Copy the file
				//
				if (!DavCopyFile (di.PwszSource(),
								  pwszDestinationRedirect,
								  0 != dwReplace))
				{
					DWORD dw = GetLastError();
					scItem = HRESULT_FROM_WIN32(dw);

					//	If it's a sharing (lock) violation, AND we have a
					//	locktoken parser (plth) AND it has a locktoken for
					//	this path (lth.GetToken(pwsz)), copy it manually.
					//
					if (plth &&
						(ERROR_SHARING_VIOLATION == dw || ERROR_FILE_EXISTS == dw))
					{
						scItem = ScDoLockedCopy (pmu,
							plth,
							di.PwszSource(),
							pwszDestinationRedirect);
					}
				}

				//	In the case of a move, handle the potentially
				//	locked source.
				//
				if (!FAILED (scItem) && fMove)
				{
					LARGE_INTEGER liLockID;

					//	If we have a locktoken for this path, then we really
					//	want to try and release the lock for the source and
					//	delete the file.
					//
					if (plth)
					{
						//	Find the lock...
						//
						scItem = plth->HrGetLockIdForPath (di.PwszSource(),
													      GENERIC_WRITE,
													      &liLockID);
						if (SUCCEEDED(scItem))
						{
							//	... and drop it on the floor...
							//
							scItem = CSharedLockMgr::Instance().HrDeleteLock(pmu->HitUser(),
																		liLockID);
							if (SUCCEEDED(scItem))
							{
								//	... and try to delete the source again.
								//
								if (!DavDeleteFile (di.PwszSource()))
								{
									scItem = HRESULT_FROM_WIN32(GetLastError());
								}
							}
						}
					}
					else
					{
						//	... and try to delete the source again.
						//
						if (!DavDeleteFile (di.PwszSource()))
						{
							scItem = HRESULT_FROM_WIN32(GetLastError());
						}
					}
				}

				if (FAILED (scItem))
				{
					//	If the file that failed to be copied was a hidden
					//	and/or system file, then it was more than likely a
					//	trigger file, but even as such, if the file has the
					//	hidden attribute, we don't want to partial report
					//	the failure.
					//
					if (!di.FHidden())
					{
						sc = ScAddMultiFromUrl (msr,
												pmu,
												di.PwszUri(),
												HscFromHresult(scItem),
												di.FDirectory(),
											    fMove);
						if (FAILED (sc))
							goto ret;

						sc = W_DAV_PARTIAL_SUCCESS;
					}
				}
			}
		}
		else //	!fMove || fCheckAccess || fCheckDestinationAccess || !MoveFileEx()
		{
			//	Again, this is the cool bit.  If we got here, then
			//	there is no need to delve down into this particular
			//	branch of the tree.
			//
			//	To accomplish this, we are going to lie in a gentle
			//	way.  By setting scItem to a failure condition we are
			//	preventing the extra work.
			//
			scItem = HRESULT_FROM_WIN32(ERROR_FILE_EXISTS);
		}
	}

	//	Now that all the files are moved or copied, the pushed directories
	//	can be removed.
	//
	while (!lst.empty())
	{
		Assert (fMove);
		MCDTrace ("Dav: MCD: removing '%S'\n", lst.back());

		//	Try to delete the dir.  If it doesn't delete, check our
		//	"skipped because of a lock above" flag before complaining.
		//
		//$	LATER: Fix this to actually lookup the dir path in the
		//	lockcache (using "fPathLookup").
		//
		if (!DavRemoveDirectory (lst.back()))
		{
			DebugTrace ("Dav: MCD: failed to delete directory\n");

			//	Add to the reponse XML
			//
			sc = ScAddMulti (msr,
							 pmu,
							 lst.back(),
							 NULL,
							 HscFromLastError(GetLastError()),
							 TRUE,				//	We know it's a directory
							 pcvrTranslateSrc);
			if (FAILED (sc))
				goto ret;

			sc = W_DAV_PARTIAL_SUCCESS;
		}

		lst.pop_back();
	}

ret:

	return sc;
}

SCODE
ScMoveCopyDirectoryAndChildren (
	/* [in] */ IMethUtil* pmu,
	/* [in] */ LPCWSTR pwszUrl,
	/* [in] */ LPCWSTR pwszSrc,
	/* [in] */ LPCWSTR pwszUrlDst,
	/* [in] */ LPCWSTR pwszDst,
	/* [in] */ BOOL fMove,
	/* [in] */ DWORD dwReplace,
	/* [in] */ BOOL fCheckAccess,
	/* [in] */ BOOL fCheckDestinationAccess,
	/* [in] */ CVRoot* pcvrTranslateDestination,
	/* [in] */ DWORD dwAcc,
	/* [in] */ CXMLEmitter& msr,
	/* [in] */ LONG lDepth,
	/* [in] */ CParseLockTokenHeader* plth)	// Usually NULL -- no locktokens to worry about
{
	BOOL fPartial = FALSE;
	SCODE sc = S_OK;

	//	Move/Copy the main body first
	//
	MCDTrace ("Dav: copying '%S' to '%S'\n", pwszSrc, pwszDst);
	sc = ScMoveCopyDirectory (pmu,
							  pwszUrl,
							  pwszSrc,
							  pwszUrlDst,
							  pwszDst,
							  fMove,
							  dwReplace,
							  fCheckAccess,
							  fCheckDestinationAccess,
							  dwAcc,
							  NULL, // translations are pmu based
							  pcvrTranslateDestination,
							  msr,
							  lDepth,
							  plth);
	if (!FAILED (sc) && (lDepth != DEPTH_ZERO))
	{
		Assert (lDepth == DEPTH_INFINITY);

		//	Enumerate the child vroots and perform the
		//	deletion of those directories as well
		//
		ChainedStringBuffer<WCHAR> sb;
		CVRList vrl;
		UINT cchUrl = static_cast<UINT>(wcslen (pwszUrl));
		UINT cchDstUrl = static_cast<UINT>(wcslen (pwszUrlDst));
		UINT cchDstPath = static_cast<UINT>(wcslen (pwszDst));

		//	Cleanup the list such that our namespaces are in
		//	a reasonable order.
		//
		(void) pmu->ScFindChildVRoots (pwszUrl, sb, vrl);
		vrl.sort();

		for ( ; !FAILED(sc) && !vrl.empty(); vrl.pop_front())
		{
			auto_ref_ptr<CVRoot> pcvrDst;
			auto_ref_ptr<CVRoot> pcvrSrc;
			CResourceInfo cri;
			CStackBuffer<WCHAR,128> pwszChildDstT;
			LPCWSTR pwszChildDst;
			LPCWSTR pwszChildPath;
			LPCWSTR pwszChildUrl;
			SCODE scItem;
			UINT cchVRoot;

			//	Remember any partial returns
			//
			if (W_DAV_PARTIAL_SUCCESS == sc)
				fPartial = TRUE;

			if (pmu->FGetChildVRoot (vrl.front().m_pwsz, pcvrSrc))
			{
				Assert (fCheckAccess);
				cchVRoot = pcvrSrc->CchGetVRoot (&pwszChildUrl);
				sc = ScCheckMoveCopyDeleteAccess (pmu,
												  pwszChildUrl,
												  pcvrSrc.get(),
												  TRUE, // directory
												  TRUE, // check scriptmaps
												  dwAcc,
												  &scItem,
												  msr);
				if (FAILED (sc))
					goto ret;

				//	If things were not 100%, don't process this resource
				//
				if (S_OK != sc)
					continue;

				//	We now have to figure out how we can really do this!
				//
				//	The source path and url bits are easy.  The destination
				//	path, on the other hand, is a pain.  It is the original
				//	destination root with the delta between the source root
				//	and the child's url path.  Huh?
				//
				//	Ok, here is an example:
				//
				//		Source url:		/misc
				//		Source root:	c:\inetpub\wwwroot\misc
				//		Dest. root:		c:\inetpub\wwwroot\copy
				//
				//		Child url:		/misc/blah
				//
				//	In this example the childs, destination path would need to
				//	be:
				//
				//		Child dest.:	c:\inetpub\wwwroot\copy\blah
				//
				//$	REVIEW:
				//
				//	And the real pain here is that the child path could already
				//	exist, but not match the namespace path.  I am not too sure
				//	how to handle that eventuality at this point.
				//
				Assert (cchUrl < cchVRoot);
				//
				//	Construct the new destination url
				//
				UINT cchDest = cchVRoot - cchUrl + cchDstUrl + 1;
				CStackBuffer<WCHAR,128> pwszChildUrlDst;
				if (NULL == pwszChildUrlDst.resize(CbSizeWsz(cchDest)))
				{
					sc = E_OUTOFMEMORY;
					goto ret;
				}
				memcpy (pwszChildUrlDst.get(), pwszUrlDst, cchDstUrl * sizeof(WCHAR));
				memcpy (pwszChildUrlDst.get() + cchDstUrl, pwszChildUrl + cchUrl, (1 + cchDest - cchDstUrl) * sizeof(WCHAR));

				if (fCheckDestinationAccess)
				{
					sc = ScCheckMoveCopyDeleteAccess (pmu,
													  pwszChildUrlDst.get(),
													  pcvrSrc.get(),
													  TRUE, // directory
													  TRUE, // check scriptmap on dest
													  MD_ACCESS_WRITE,
													  &scItem,
													  msr);
					if (FAILED (sc))
						goto ret;

					//	If things were not 100%, don't process this resource
					//
					if (S_OK != sc)
						continue;
				}

				//	And now that we have perfomed the forbidden dance... we
				//	have to go back and see if the destination url actually
				//	refers to a new child virtual root as well.
				//
				if (pmu->FFindVRootFromUrl (pwszChildUrlDst.get(), pcvrDst))
				{
					MCDTrace ("Dav: MCD: destination url maps to virtual root\n");

					//	Access checking, as always is handled in ScCheckM/C/DAccess()
					//	So all we need to do here is setup the destination path
					//
					pcvrDst->CchGetVRPath (&pwszChildDst);
				}
				else
				{
					//	We actually need to construct a physical path from
					//	the url and current destination path.
					//
					cchDest = cchDstPath + cchVRoot - cchUrl + 1;
					if (NULL == pwszChildDstT.resize(CbSizeWsz(cchDest)))
					{
						sc = E_OUTOFMEMORY;
						goto ret;
					}
					memcpy (pwszChildDstT.get(), pwszDst, cchDstPath * sizeof(WCHAR));
					memcpy (pwszChildDstT.get() + cchDstPath, pwszChildUrl + cchUrl, (cchVRoot - cchUrl) * sizeof(WCHAR));
					pwszChildDstT[cchDstPath + cchVRoot - cchUrl] = L'\0';

					//	We also now need to rip through the trailing part of the
					//	path one more time, translating all '/' to '\\' as we go.
					//
					for (WCHAR* pwch = pwszChildDstT.get() + cchDstPath;
						 NULL != (pwch = wcschr (pwch, L'/'));
						 )
					{
						*pwch++ = L'\\';
					}

					pwszChildDst = pwszChildDstT.get();
				}

				//	Well, now we should be able to continue the MOVE/COPY
				//
				pcvrSrc->CchGetVRPath (&pwszChildPath);
				sc = ScMoveCopyDirectory (pmu,
										  pwszChildUrl,
										  pwszChildPath,
										  pwszChildUrlDst.get(),
										  pwszChildDst,
										  fMove,
										  dwReplace,
										  fCheckAccess,
										  fCheckDestinationAccess,
										  dwAcc,
										  pcvrSrc.get(),
										  pcvrDst.get(),
										  msr,
										  DEPTH_INFINITY,
										  plth);
				if (FAILED (sc))
				{
					sc = ScAddMultiFromUrl (msr,
											pmu,
											pwszChildUrl,
											HscFromHresult(sc),
											TRUE); // We know it's a directory
					if (FAILED (sc))
						goto ret;

					sc = W_DAV_PARTIAL_SUCCESS;
				}
			}
		}
	}

ret:
	return ((S_OK == sc) && fPartial) ? W_DAV_PARTIAL_SUCCESS : sc;
}

//	Move/Copy -----------------------------------------------------------------
//
void
MoveCopyResource (LPMETHUTIL pmu, DWORD dwAccRequired, BOOL fDeleteSrc)
{
	auto_ptr<CParseLockTokenHeader> plth;
	auto_ref_ptr<CXMLBody> pxb;
	auto_ref_ptr<CXMLEmitter> pxml;
	BOOL fCheckDestination = FALSE;
	BOOL fCheckSource = FALSE;
	BOOL fCreateNew = TRUE;
	BOOL fDestinationExists = TRUE; // IMPORTANT: assume exists for location header processing
	CResourceInfo criDst;
	CResourceInfo criSrc;
	CStackBuffer<WCHAR> pwszMBPathDst;
	CStackBuffer<WCHAR> pwszMBPathSrc;
	CVRoot* pcvrDestination;
	DWORD dwAccDest = MD_ACCESS_WRITE;
	DWORD dwReplace = 0;
	LONG lDepth;
	LPCWSTR pwsz;
	LPCWSTR pwszDst = NULL;
	LPCWSTR pwszDstUrl = NULL;
	LPCWSTR pwszSrc = pmu->LpwszPathTranslated();
	LPCWSTR pwszSrcUrl = pmu->LpwszRequestUrl();
	SCODE sc = S_OK;
	SCODE scDest = S_OK;
	UINT cch;
	UINT uiErrorDetail = 0;

	//	We don't know if we'll have chunked XML response, defer response anyway
	//
	pmu->DeferResponse();

	//	Create an XML doc, NOT chunked
	//
	pxb.take_ownership (new CXMLBody(pmu));
	pxml.take_ownership (new CXMLEmitter(pxb.get()));

	//	Must set all headers before XML emitting starts
	//
	pmu->SetResponseHeader (gc_szContent_Type, gc_szText_XML);
	pmu->SetResponseCode (HscFromHresult(W_DAV_PARTIAL_SUCCESS),
						  NULL,
						  0,
						  CSEFromHresult(W_DAV_PARTIAL_SUCCESS));

	//	Do ISAPI application and IIS access bits checking on source
	//
	sc = pmu->ScIISCheck (pmu->LpwszRequestUrl(), dwAccRequired);
	if (FAILED(sc))
	{
		//	Either the request has been forwarded, or some bad error occurred.
		//	In either case, quit here and map the error!
		//
		MCDTrace ("Dav: Move/Copy: insufficient access\n");
		goto ret;
	}

	//	If there's no valid destination header, it's a bad request.
	//
	//	NOTE: we are asking for the translated url's virtual root if
	//	it exists.  The ECB holds the reference for us, so we do not
	//	add one or release the one we have!
	//
	sc = pmu->ScGetDestination (&pwszDstUrl, &pwszDst, &cch, &pcvrDestination);
	if (FAILED (sc))
	{
		MCDTrace ("Dav: Move/Copy: no and/or bad destination header\n");
		if (sc != E_DAV_NO_DESTINATION)
		{
			Assert (pwszDstUrl);
			sc = ScAddMultiFromUrl (*pxml,
									pmu,
									pwszDstUrl,
									HscFromHresult(sc),
									FALSE); // do not check for trailing slash
			if (!FAILED (sc))
				sc = W_DAV_PARTIAL_SUCCESS;
		}
		goto ret;
	}

	//	Get the file attributes for the passed in URI.  If it aint there, then
	//	don't do jack!
	//
	sc = criSrc.ScGetResourceInfo (pwszSrc);
	if (FAILED (sc))
		goto ret;

	//	Get the metabase for the source and destination for later use
	//
	if ((NULL == pwszMBPathSrc.resize(pmu->CbMDPathW(pwszSrcUrl))) ||
		(NULL == pwszMBPathDst.resize(pmu->CbMDPathW(pwszDstUrl))))
	{
		sc = E_OUTOFMEMORY;
		goto ret;
	}
	pmu->MDPathFromUrlW (pwszSrcUrl, pwszMBPathSrc.get());
	pmu->MDPathFromUrlW (pwszDstUrl, pwszMBPathDst.get());

	//	Get the resource info for the destination up front
	//
	sc = criDst.ScGetResourceInfo (pwszDst);
	if (FAILED (sc))
	{
		MCDTrace ("Dav: Move/Copy: destination probably did not exist prior to op\n");

		//	The destination may or may not exist.  We will just act like
		//	it doesn't.  However, if we don't have access, then we want to
		//	stick the error into a 207 body.
		//
		fDestinationExists = FALSE;
		if ((HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) == sc))
		{
			sc = ScAddMultiFromUrl (*pxml,
									pmu,
									pwszDstUrl,
									HscFromHresult(sc),
									FALSE); // do not check for trailing slash
			if (!FAILED (sc))
				sc = W_DAV_PARTIAL_SUCCESS;

			goto ret;
		}
	}

	//	Again, emit all the headers before XML chunking starts
	//
	if (!fDestinationExists)
	{
		Assert (pxml->PxnRoot() == NULL);

		//$NOTE	At this time, we have only the destination URL, the destination
		//$NOTE is not created yet, but we do know whether it will be created
		//$NOTE as a collection by looking at the source
		//
		pmu->EmitLocation (gc_szLocation, pwszDstUrl, criSrc.FCollection());
	}

	//$	SECURITY:
	//
	//	Check to see if the destination is really a short
	//	filename.
	//
	sc = ScCheckIfShortFileName (pwszDst, pmu->HitUser());
	if (FAILED (sc))
	{
		DebugTrace ("Dav: MCD: destination is short-filename\n");
		sc = ScAddMultiFromUrl (*pxml,
								pmu,
								pwszDstUrl,
								HscFromHresult(sc),
								FALSE); // do not check for trailing slash
		if (!FAILED (sc))
			sc = W_DAV_PARTIAL_SUCCESS;

		goto ret;
	}
	//
	//$	SECURITY: end.

	//$	SECURITY:
	//
	//	Check to see if the destination is really the default
	//	data stream via alternate file access.
	//
	sc = ScCheckForAltFileStream (pwszDst);
	if (FAILED (sc))
	{
		DebugTrace ("Dav: MCD: destination is possible alternate filestream\n");
		sc = ScAddMultiFromUrl (*pxml,
								pmu,
								pwszDstUrl,
								HscFromHresult(sc),
								FALSE); // do not check for trailing slash
		if (!FAILED (sc))
			sc = W_DAV_PARTIAL_SUCCESS;

		goto ret;
	}
	//
	//$	SECURITY: end.

	//	See if we have move/copy access at destination
	//
	if (fDestinationExists && criDst.FCollection())
		dwAccDest |= MD_ACCESS_READ;

	sc = ScCheckMoveCopyDeleteAccess (pmu,
									  pwszDstUrl,
									  pcvrDestination,
									  fDestinationExists
										  ? criDst.FCollection()
										  : criSrc.FCollection(),
									  TRUE, // check scriptmaps on dest.
									  dwAccDest,
									  &scDest,
									  *pxml);
	if (sc != S_OK)
		goto ret;

	//	The client must not submit a depth header with any value
	//	but Infinity
	//
	lDepth = pmu->LDepth (DEPTH_INFINITY);
	if (DEPTH_INFINITY != lDepth)
	{
		if (fDeleteSrc || (DEPTH_ZERO != lDepth))
		{
			MCDTrace ("Dav: only 'Depth: inifinity' is allowed for MOVE\n"
					  "- 'Depth: inifinity' and 'Depth: 0' are allowed for COPY\n");
			sc = E_DAV_INVALID_HEADER;
			goto ret;
		}
	}

	//	See if there is a path conflict
	//
	if (FPathConflict (pwszSrc, pwszDst))
	{
		DebugTrace ("Dav: source and dest are in conflict\n");
		sc = E_DAV_CONFLICTING_PATHS;
		goto ret;
	}

	//	If we were to check either URI for correctness, the only
	//	real result would be to possibly emit a content-location
	//	header that would only be invalidated in the case of a
	//	successful move
	//
	if (!fDeleteSrc)
	{
		sc = ScCheckForLocationCorrectness (pmu, criSrc, NO_REDIRECT);
		if (FAILED (sc))
			goto ret;
	}

	//	This method is gated by If-xxx headers
	//
	sc = ScCheckIfHeaders (pmu, criSrc.PftLastModified(), FALSE);
	if (FAILED (sc))
		goto ret;

	//	Check state headers
	//
	sc = HrCheckStateHeaders (pmu, pwszSrc, FALSE);
	if (FAILED (sc))
	{
		DebugTrace ("DavFS: If-State checking failed.\n");
		goto ret;
	}

	//	If there are locktokens, feed them to a parser object.
	//
	pwsz = pmu->LpwszGetRequestHeader (gc_szLockToken, TRUE);
	if (pwsz)
	{
		plth = new CParseLockTokenHeader (pmu, pwsz);
		Assert(plth.get());

		plth->SetPaths (pwszSrc, pwszDst);
	}

	//	Check for deep access issues
	//
	//$	REVIEW: we wanted to be able to not have to check
	//	access at each level.  However, because of the semantics of
	//	MOVE/COPY, we have to check each source file for scriptmap
	//	access.  We cannot copy a file that has a scriptmap if the
	//	they do not have source access.
	//
	//	So we must always check the source of the MOVE/COPY operation.
	//
	fCheckSource = TRUE;
	//
	//$	REVIEW: end.
	//
	//	However, we still can try and be optimistic for the destination
	//
	if (NULL == pwszMBPathDst.resize(pmu->CbMDPathW(pwszDstUrl)))
	{
		sc = E_OUTOFMEMORY;
		goto ret;
	}
	pmu->MDPathFromUrlW (pwszDstUrl, pwszMBPathDst.get());
	if (fDestinationExists || (DEPTH_ONE != pmu->LDepth(DEPTH_INFINITY)))
	{
		CAccessMetaOp moAccess(pmu, pwszMBPathDst.get(), dwAccDest);
		CAuthMetaOp moAuth(pmu, pwszMBPathDst.get(), pmu->MetaData().DwAuthorization());
		CIPRestrictionMetaOp moIPRestriction(pmu, pwszMBPathDst.get());
		ChainedStringBuffer<WCHAR> sb;
		CVRList vrl;

		//	If we do not have access to COPY/MOVE or
		//	DELETE anything in the destination, then
		//	we really shouldn't blindly proceed.
		//
		sc = moAccess.ScMetaOp();
		if (FAILED (sc))
			goto ret;
		fCheckDestination |= moAccess.FAccessBlocked();

		if (!fCheckDestination)
		{
			//	If we do not have the same authorization anywhere along
			//	the destination as we do for the request url, then we
			//	really shouldn't blindly proceed.
			//
			sc = moAuth.ScMetaOp();
			if (FAILED (sc))
				goto ret;
			fCheckDestination |= moAuth.FAccessBlocked();
		}

		if (!fCheckDestination)
		{
			//	If we do not have the same authorization anywhere along
			//	the destination as we do for the request url, then we
			//	really shouldn't blindly proceed.
			//
			sc = moIPRestriction.ScMetaOp();
			if (FAILED (sc))
				goto ret;
			fCheckDestination |= moAuth.FAccessBlocked();
		}

		if (!fCheckDestination)
		{
			//	If there are any child virtual roots along
			//	the destination tree, there is some redirection
			//	that may need to happen as well.
			//
			(void) pmu->ScFindChildVRoots (pwszDstUrl, sb, vrl);
			fCheckDestination |= !vrl.empty();
		}
	}

	//	Determine if we are destructive or not.
	//
	if (pmu->LOverwrite() & OVERWRITE_YES)
	{
		dwReplace |= MOVEFILE_REPLACE_EXISTING;

		//	MoveFileEx does not seem to want to replace existing
		//	directories.. It returns E_ACCESS_DENIED so we delete
		//	the existing directory ourselves.
		//
		if (fDestinationExists)
		{
			BOOL fDeletedDestination;

			//	The destination exists already
			//
			fCreateNew = FALSE;

			//	If the destination is a directory, delete it.
			//
			if (criDst.FCollection())
			{
				//	Otherwise, go ahead and delete the directory currently at dest.
				//
				sc = ScDeleteDirectoryAndChildren (pmu,
												   pwszDstUrl,
												   pwszDst,
												   fCheckDestination,
												   dwAccDest,
												   DEPTH_INFINITY,
												   *pxml,
												   pcvrDestination,
												   &fDeletedDestination,
												   plth.get(),	// DO use locktokens, if any exist.
												   FALSE);		// Do NOT drop locks.  Just skip them.
				if (sc != S_OK)
				{
					DebugTrace("DavFS: MOVE failed to pre-delete destination directory.\n");
					goto ret;
				}
			}
			else
			{
				//	If the destination is locked (ERROR_SHARING_VIOLATION),
				//	DO NOT catch it here.  We'll handle it below....
				//
				if (!DavDeleteFile (pwszDst))
				{
					DWORD dw = GetLastError();
					if (ERROR_ACCESS_DENIED == dw)
					{
						sc = HRESULT_FROM_WIN32(dw);
						goto ret;
					}
				}
			}
		}
	}

	//	Do the move/copy.  If the operation is either a move, or the source
	//	is a collection, then call out to do the diry work.
	//
	MCDTrace ("DavFS: MCD: moving copying '%S' to '%S'\n", pwszSrc, pwszDst);
	if (criSrc.FCollection())
	{
		sc = ScMoveCopyDirectoryAndChildren (pmu,
											 pwszSrcUrl,
											 pwszSrc,
											 pwszDstUrl,
											 pwszDst,
											 fDeleteSrc,
											 dwReplace,
											 fCheckSource,
											 fCheckDestination,
											 pcvrDestination,
											 dwAccRequired,
											 *pxml,
											 lDepth,
											 plth.get());
		if (FAILED (sc))
			goto ret;
	}
	else
	{
		//	Well this should be the move/copy of a single file
		//
		if (!fDeleteSrc || !DavMoveFile (pwszSrc, pwszDst, dwReplace))
		{
			if (!DavCopyFile (pwszSrc, pwszDst, (0 == dwReplace)))
			{
				DWORD dw = GetLastError();
				DebugTrace ("Dav: failed to copy file\n");

				//	If it's a sharing violation (lock-caused error),
				//	AND we have a locktoken parser (plth), handle the copy.
				//
				if ((ERROR_SHARING_VIOLATION == dw) && plth.get())
				{
					//	Check if any locktokens apply to these file,
					//	and try the copy using the locks from the cache.
					//
					sc = ScDoLockedCopy (pmu, plth.get(), pwszSrc, pwszDst);
				}
				else
				{
					if ((dw == ERROR_FILE_EXISTS) ||
						(dw == ERROR_ALREADY_EXISTS))
					{
						sc = E_DAV_OVERWRITE_REQUIRED;
					}
					else
						sc = HRESULT_FROM_WIN32(dw);
				}

				//	If the file-manual-move failed, we'll hit here.
				//
				if (FAILED (sc))
				{
					DebugTrace("Dav: MCD: move/copy failed. Looking for lock conflicts.\n");

					//	Special work for '423 Locked' responses -- fetch the
					//	comment & set that as the response body.
					//
					if (FLockViolation (pmu, sc, pwszSrc,
										GENERIC_READ | GENERIC_WRITE))
					{
						sc = E_DAV_LOCKED;
						goto ret;
					}
					else
					{
						//	Test the destination too.
						//	However, if the dest is locked, do NOT add
						//	the lockinfo as the body -- we have to list the dest
						//	URI as the problem, so we need to have a multi-status
						//	body, and we put a plain 423 Locked node under there.
						//	(NOTE: Yes, this means we can't use FLockViolation.
						//	Instead, we have to check "by hand".)
						//

						if (CSharedLockMgr::Instance().FGetLockOnError (
							pmu,
							pwszDst,
							GENERIC_READ | GENERIC_WRITE))
						{
							sc = ScAddMultiFromUrl (*pxml,
													pmu,
													pwszDstUrl,
													HscFromHresult(E_DAV_LOCKED),
													FALSE);	//	We know it's not a directory
							if (!FAILED (sc))
								sc = W_DAV_PARTIAL_SUCCESS;

							goto ret;
						}
					}
				}
			} // end !DavCopyFile
			if (SUCCEEDED(sc) && fDeleteSrc)
			{
				//	Delete the source file by hand.
				//	(fDeleteSrc means this is a MOVE, not a COPY.)
				//
				//	Move the content-types only if the source is
				//	deleted, otherwise treat it as a copy the of
				//	the content-type
				//
				if (!DavDeleteFile (pwszSrc))
				{
					DWORD dwLastError = GetLastError();
				
					DebugTrace ("Dav: failed to delete file (%d)\n", dwLastError);

					//	If it's a sharing (lock) violation, AND we have a
					//	locktoken for this path (lth.GetToken(pwsz))
					//	skip this path.
					//
					if ((ERROR_SHARING_VIOLATION == dwLastError) && plth)
					{
						LARGE_INTEGER liLockID;

						//	If we have a locktoken for this path, drop
						//	the lock and try to delete the source again.
						//
						if (SUCCEEDED(plth->HrGetLockIdForPath (pwszSrc,
															 GENERIC_WRITE,
															 &liLockID)))
						{
							//	This item is locked in our cache.
							//	We are doing a MOVE, so DO delete the lock
							//	and try again.
							//
							if (SUCCEEDED(CSharedLockMgr::Instance().HrDeleteLock(pmu->HitUser(),
																			   liLockID)))
							{
								//	Try the delete again, and set/clear our error
								//	code for testing below.
								//	This error code will control whether we
								//	add this error to our XML.
								//
								if (DavDeleteFile(pwszSrc))
								{
									dwLastError = ERROR_SUCCESS;
								}
								else
								{
									dwLastError = GetLastError();
								}
							}
						}
						//	else, record the error in our XML.
						//
					}

					if (ERROR_SUCCESS != dwLastError)
					{
						//	We could not work around all the errors.
						//	Add this failure to the XML.
						//
						sc = ScAddMultiFromUrl (*pxml,
												pmu,
												pwszSrcUrl,
												HscFromLastError(dwLastError),
												FALSE);	//	We know it's not a directory
						if (FAILED (sc))
							goto ret;

						//	It is partial sucess if we are here. And do not fail out
						//	yet as we still need to take care of content types.
						//
						sc = W_DAV_PARTIAL_SUCCESS;
					}
				}
			}
		}
	}

	//	Now that we're done mucking around in the filesystem,
	//	muck around in the metabase.
	//	(Delete any destination content-types, then copy/move
	//	the source content-types on over.)
	//

	//	Delete the content-types for the destination
	//
	{
		Assert (pwszMBPathDst.get());
		CContentTypeMetaOp amoContent(pmu, pwszMBPathDst.get(), NULL, TRUE);
		(void) amoContent.ScMetaOp();
	}

	//	Move/copy the content-type
	//
	//$	REVIEW: I am not so sure what can be done when this fails
	//
	{
		Assert (pwszMBPathDst.get());

		//	Only delete the source content-types if everything has been 100%
		//	successfull up to this point.
		//
		CContentTypeMetaOp amoContent(pmu,
									  pwszMBPathSrc.get(),
									  pwszMBPathDst.get(),
									  (fDeleteSrc && (S_OK == sc)));
		(void) amoContent.ScMetaOp ();
	}
	//
	//$	REVIEW: end.

ret:
	if (pxml.get() && pxml->PxnRoot())
	{
		pxml->Done();

		//	No more header can be sent after XML chunking started
	}
	else
	{
		if (SUCCEEDED (sc))
			sc = fCreateNew ? W_DAV_CREATED : W_DAV_NO_CONTENT;

		pmu->SetResponseCode (HscFromHresult(sc), NULL, uiErrorDetail, CSEFromHresult(sc));
	}

	pmu->SendCompleteResponse();
}

/*
 *	DAVMove()
 *
 *	Purpose:
 *
 *		Win32 file system implementation of the DAV MOVE method.  The
 *		MOVE method results in the moving of a resource from one location
 *		to another.	 The response is used to indicate the success of the
 *		call.
 *
 *	Parameters:
 *
 *		pmu			[in]  pointer to the method utility object
 *
 *	Notes:
 *
 *		In the file system implementation, the MOVE method maps directly
 *		to the Win32 RenameFile() method.
 */
void
DAVMove (LPMETHUTIL pmu)
{
	MoveCopyResource (pmu,
					  MD_ACCESS_READ|MD_ACCESS_WRITE,	// src access required
					  TRUE);							// fDeleteSource
}

/*
 *	DAVCopy()
 *
 *	Purpose:
 *
 *		Win32 file system implementation of the DAV COPY method.  The
 *		COPY method results in the copying of a resource from one location
 *		to another.	 The response is used to indicate the success of the
 *		call.
 *
 *	Parameters:
 *
 *		pmu			[in]  pointer to the method utility object
 *
 *	Notes:
 *
 *		In the file system implementation, the COPY method maps directly
 *		to the Win32 CopyFile() API for a single file.  Directory copies
 *		are done via a custom process.
 */
void
DAVCopy (LPMETHUTIL pmu)
{
	MoveCopyResource (pmu,
					  MD_ACCESS_READ,	// src access required
					  FALSE);			// fDeleteSource
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\httpext\lockutil.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	LOCKUTIL.CPP
//
//		HTTP 1.1/DAV 1.0 LOCK request handling UTILITIES
//
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include "_davfs.h"

#include <tchar.h>	//_strspnp
#include <statetok.h>
#include <xlock.h>

#include "_shlkmgr.h"

//	========================================================================
//
//	ScLockDiscoveryFromSNewLockData
//
//		Takes an emitter and an already-constructed lockdiscovery node,
//		and adds an activelock node for this CLock under it.
//		May be called multiple times -- each call will add a new activelock
//		node under the lockdiscovery node in en.
//$HACK:ROSEBUD_OFFICE9_TIMEOUT_HACK
//		For the bug where rosebud waits until the last second
//		before issueing the refresh. Need to filter out this check with
//		the user agent string. The hack is to increase the timeout
//		by 30 seconds and return the actual timeout. So we
//		need the ecb/pmu to findout the user agent. If we
//		remove this	hack ever (I doubt if we can ever do that), then
//		change the interface of ScLockDiscoveryFromCLock.
//$HACK:END ROSEBUD_OFFICE9_TIMEOUT_HACK
//
SCODE
ScLockDiscoveryFromSNewLockData(LPMETHUTIL pmu,
										    CXMLEmitter& emitter,
										    CEmitterNode& en,
										    SNewLockData * pnld,
										    LPCWSTR pwszLockToken)
{
	BOOL fRollback;
	BOOL fDepthInfinity;
	DWORD dwLockScope;
	DWORD dwLockType;
	LPCWSTR pwszLockScope = NULL;
	LPCWSTR pwszLockType = NULL;
	HRESULT hr = S_OK;
	DWORD	dwSeconds = 0;

	Assert(pmu);
	Assert(pnld);

	//	Get the lock flags from the lock.
	//
	dwLockType = pnld->m_dwLockType;

	//	Note if the lock is a rollback
	//
	fRollback = !!(dwLockType & DAV_LOCKTYPE_ROLLBACK);

	//	Note if the lock is recursive
	//
	fDepthInfinity = !!(dwLockType & DAV_RECURSIVE_LOCK);

	//	Write lock?
	//
	if (dwLockType & GENERIC_WRITE)
	{
		pwszLockType = gc_wszLockTypeWrite;
	}
	
#ifdef	DBG
	if (dwLockType & GENERIC_READ)
	{
		pwszLockType = L"read";
	}
#else	// !DBG
	else
	{
		TrapSz ("Unexpected lock type!");
	}
#endif	// DBG, else

	//	Lock scope
	//
	dwLockScope = pnld->m_dwLockScope;
	if (dwLockScope & DAV_SHARED_LOCK)
	{
		pwszLockScope = gc_wszLockScopeShared;
	}
	else
	{
		Assert (dwLockScope & DAV_EXCLUSIVE_LOCK);
		pwszLockScope = gc_wszLockScopeExclusive;
	}

	dwSeconds = pnld->m_dwSecondsTimeout;

	//$HACK:ROSEBUD_OFFICE9_TIMEOUT_HACK
	//	For the bug where rosebud waits until the last second
	//	before issueing the refresh. Need to filter out this check with
	//	the user agent string. The hack is to increase the timeout
	//	by 30 seconds. Now decrease 30 seconds to send requested timeout.
	//
	if (pmu && pmu->FIsOffice9Request())
	{
		if (dwSeconds > gc_dwSecondsHackTimeoutForRosebud)
		{
			dwSeconds -= gc_dwSecondsHackTimeoutForRosebud;
		}
	}
	//$HACK: END: ROSEBUD_OFFICE9_TIMEOUT_HACK

	//	Construct the lockdiscovery node
	//
	hr = ScBuildLockDiscovery (emitter,
							   en,
							   pwszLockToken,
							   pwszLockType,
							   pwszLockScope,
							   fRollback,
							   fDepthInfinity,
							   dwSeconds,
							   pnld->m_pwszOwnerComment,
							   NULL);
	if (FAILED (hr))
	{
		goto ret;
	}

ret:

	return hr;
}

//	------------------------------------------------------------------------
//
//	ScAddSupportedLockProp
//
//		Add a lockentry node with the listed information.
//		NOTE: wszExtra is currently used for rollback information.
//
SCODE
ScAddSupportedLockProp (CEmitterNode& en,
	LPCWSTR wszLockType,
	LPCWSTR wszLockScope,
	LPCWSTR wszExtra = NULL)
{
	CEmitterNode enEntry;
	SCODE sc = S_OK;

	Assert (wszLockType);
	Assert (wszLockScope);

	//	Create a lockentry node to hold this info.
	//
	sc = en.ScAddNode (gc_wszLockEntry, enEntry);
	if (FAILED (sc))
		goto ret;

	//	Create a node for the locktype under the lockentry.
	//
	{
		//	Must scope here, all sibling nodes must be constructed sequentially
		//
		CEmitterNode enType;
		sc = enEntry.ScAddNode (wszLockType, enType);
		if (FAILED (sc))
			goto ret;
	}

	//	Create a node for the locktype under the lockentry.
	//
	{
		//	Must scope here, all sibling nodes must be constructed sequentially
		//
		CEmitterNode enScope;
		sc = enEntry.ScAddNode (wszLockScope, enScope);
		if (FAILED (sc))
			goto ret;
	}

	//	If we have extra info, create a node for it under the lockentry.
	//
	if (wszExtra)
	{
		//	Must scope here, all sibling nodes must be constructed sequentially
		//
		CEmitterNode enExtra;
		sc = enEntry.ScAddNode (wszExtra, enExtra);
		if (FAILED (sc))
			goto ret;
	}

ret:
	return sc;
}

//	------------------------------------------------------------------------
//
//	HrGetLockProp
//
//		Get the requested lock property for the requested resource.
//		(The lock properties are lockdiscovery and supportedlock.)
//		Lockdiscovery and supportedlock should ALWAYS be found --
//		they are required DAV: properties.  Add an empty node if there is
//		no real data to return.
//		NOTE: This function still assumes that write is the only locktype.
//		It will NOT add read/mixed locktypes.
//
//	Returns
//		S_FALSE if prop not found/not recognized.
//		error only if something really bad happens.
//
//$REVIEW: Should I return the depth element too? -- No (for now).
//$REVIEW: Spec does NOT list depth under the lockentry XML element.
//
HRESULT
HrGetLockProp (LPMETHUTIL pmu,
	LPCWSTR wszPropName,
	LPCWSTR wszResource,
	RESOURCE_TYPE rtResource,
	CXMLEmitter& emitter,
	CEmitterNode& enParent)
{
	SCODE sc = S_OK;

	Assert (pmu);
	Assert (wszPropName);
	Assert (wszResource);

	if (!wcscmp (wszPropName, gc_wszLockDiscovery))
	{
		//	Fill in lockdiscovery info.
		//

		//	Check for any lock in our lock cache.
		//	This call will scan the lock cache for any matching items
		//	and add a 'DAV:activelock' node for each match.
		//	We pass in DAV_LOCKTYPE_FLAGS so that we will find all matches.
		//
		if (!CSharedLockMgr::Instance().FGetLockOnError (pmu,
				wszResource,
				DAV_LOCKTYPE_FLAGS,
				TRUE,			//		Emit XML body
				&emitter,
				enParent.Pxn()))
		{
			//	This resource is not in our lock cache.
			//
			FsLockTrace ("HrGetLockProp -- No locks found for lockdiscovery.\n");

			//	And return.  This is a SUCCESS case!
			//
		}
	}
	else if (!wcscmp (wszPropName, gc_wszLockSupportedlock))
	{
		DWORD dwLockType;
		CEmitterNode en;

		//	Construct the 'DAV:supportedlock' node
		//
		sc = en.ScConstructNode (emitter, enParent.Pxn(), gc_wszLockSupportedlock);
		if (FAILED (sc))
			goto ret;

		//	Get the list of supported lock flags from the impl.
		//
		dwLockType = DwGetSupportedLockType (rtResource);
		if (!dwLockType)
		{
			//	No locktypes are supported.  We already have our empty
			//	supportedlock node.
			//	Just return.  This is a SUCCESS case!
			goto ret;
		}

		//	Add a lockentry node under the supportedlock node for each
		//	combination of flags that we detect.
		//
		//	NOTE: Currently, write is the only allowed access type.
		//
		if (dwLockType & GENERIC_WRITE)
		{
			//	Add a lockentry for each lockscope in the flags.
			//
			if (dwLockType & DAV_SHARED_LOCK)
			{
				sc = ScAddSupportedLockProp (en,
											 gc_wszLockTypeWrite,
											 gc_wszLockScopeShared);
				if (FAILED (sc))
					goto ret;

				//	If we support lock rollback, add another lockentry for this combo.
				//
				if (dwLockType & DAV_LOCKTYPE_ROLLBACK)
				{
					sc = ScAddSupportedLockProp (en,
						gc_wszLockTypeWrite,
						gc_wszLockScopeShared,
						gc_wszLockRollback);
					if (FAILED (sc))
						goto ret;
				}
			}
			if (dwLockType & DAV_EXCLUSIVE_LOCK)
			{
				sc = ScAddSupportedLockProp (en,
											 gc_wszLockTypeWrite,
											 gc_wszLockScopeExclusive);
				if (FAILED (sc))
					goto ret;

				//	If we support lock rollback, add another lockentry for this combo.
				//
				if (dwLockType & DAV_LOCKTYPE_ROLLBACK)
				{
					sc = ScAddSupportedLockProp (en,
						gc_wszLockTypeWrite,
						gc_wszLockScopeExclusive,
						gc_wszLockRollback);
					if (FAILED (sc))
						goto ret;
				}
			}

		}

	}
	else
	{
		//	Unrecognized lock property.  So we clearly do not have one
		//
		sc = S_FALSE;
		goto ret;
	}

ret:
	return sc;
}

//	------------------------------------------------------------------------
//
//	FLockViolation
//
//		TRUE return here means that we found a lock, and sent the response.
//
//$LATER: Need to be able to return an error here!
//
BOOL
FLockViolation (LPMETHUTIL pmu, HRESULT hr, LPCWSTR pwszPath, DWORD dwAccess)
{
	BOOL fFound = FALSE;
	SCODE sc = S_OK;
	auto_ref_ptr<CXMLBody>		pxb;
	auto_ref_ptr<CXMLEmitter>	emitter;

	Assert (pmu);
	Assert (pwszPath);
	AssertSz (dwAccess, "FLockViolation: Looking for a lock with no access!");

	//	Construct the root ('DAV:prop') for the lock response
	//$NOTE: this xml body is created NOT chunked
	//
	pxb.take_ownership (new CXMLBody (pmu, FALSE) );
	emitter.take_ownership (new CXMLEmitter(pxb.get()));

	sc = emitter->ScSetRoot (gc_wszProp);
	if (FAILED (sc))
		goto ret;

	//	If the error code is one of the "locked" error codes,
	//	check our lock cache for a corresponding lock object.
	//
	if ((ERROR_SHARING_VIOLATION == ((SCODE)hr) ||
		 HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION) == hr ||
		 STG_E_SHAREVIOLATION == hr) &&
		 CSharedLockMgr::Instance().FGetLockOnError (pmu, pwszPath, dwAccess, TRUE, emitter.get(), emitter->PxnRoot()))
	{
		//	Set our found bit to TRUE now, so that we'll report the lock's
		//	existence, even if the emitting below fails!
		//	NOTE: This is important for scenarios, like HTTPEXT PROPPATCH
		//	and destination deletion for Overwrite handling,  that
		//	PRE-check the lock cache (protocol-enforced locks)
		//	before trying to hit the file.
		//
		fFound = TRUE;

		//	Set content type header
		//
		pmu->SetResponseHeader (gc_szContent_Type, gc_szText_XML);

		//	Must set the response code before we set the body data.
		//
		pmu->SetResponseCode (HSC_LOCKED, NULL, 0);

		//	Emit the XML body
		//
		emitter->Done();

	}

	//	Tell our caller if we found any locks on this item.
	//
ret:
	return fFound;
}

//	------------------------------------------------------------------------
//
//	HrLockIdFromString
//
//		Returns S_OK on success (syntax check and conversion).
//		Returns E_DAV_INVALID_HEADER on syntax error or non-matching token guid (not ours).
//		Returns other errors if something fatal happened.
//
HRESULT
HrLockIdFromString (LPMETHUTIL pmu,
					      LPCWSTR pwszToken,
					      LARGE_INTEGER * pliLockID)
{
	HRESULT hr = S_OK;

	LPCWSTR pwsz = pwszToken;
	UINT cchGUIDString = gc_cchMaxGuid;
	WCHAR rgwszGUIDString[gc_cchMaxGuid];

	Assert (pmu);
	Assert (pwszToken);
	Assert (pliLockID);

	(*pliLockID).QuadPart = 0;

	//	Skip any initial whitespace.
	//
	pwsz = _wcsspnp (pwsz, gc_wszLWS);
	if (!pwsz)
	{
		FsLockTrace ("Dav: Invalid locktoken in HrLockIdFromString.\n");
		hr = E_DAV_INVALID_HEADER;
		goto ret;
	}

	//	Skip delimiter: double-quotes or angle-brackets.
	//	It's okay if no delimiter is present.  Caller just passed us raw locktoken string.
	//
	if (L'\"' == *pwsz ||
	    L'<' == *pwsz)
		pwsz++;

	if (wcsncmp (gc_wszOpaquelocktokenPrefix, pwsz, gc_cchOpaquelocktokenPrefix))
	{
		FsLockTrace ("Dav: Lock token is missing opaquelocktoken: prefix.\n");
		hr = E_DAV_INVALID_HEADER;
		goto ret;
	}

	//	Skip the opaquelocktoken: prefix
	//
	pwsz += gc_cchOpaquelocktokenPrefix; 
 
	//	Compare GUIDS here
	//
	hr = CSharedLockMgr::Instance().HrGetGUIDString(pmu->HitUser(),
											     cchGUIDString,
											     rgwszGUIDString,
											     &cchGUIDString);
	if (FAILED(hr))
	{
		goto ret;
	}

	//	Subtract L'\0' termination
	//
	Assert(cchGUIDString);
	cchGUIDString--;
	
	if (_wcsnicmp(pwsz, rgwszGUIDString, cchGUIDString))
	{
		FsLockTrace ("Dav: Error comparing guids -- not our locktoken!\n");
		hr = E_DAV_INVALID_HEADER;
		goto ret;
	}

	//	Skip the GUID, go to the lockid string.
	//
	pwsz = wcschr (pwsz, L':');
	if (!pwsz)
	{
		FsLockTrace ("Dav: Error skipping guid of opaquelocktoken.\n");
		hr = E_DAV_INVALID_HEADER;
		goto ret;
	}
	
	//	And skip the colon separator.
	//
	Assert (L':' == *pwsz);
	pwsz++;

	//	Convert the string to lockID and return (this one actually has boundary 
	//	condition that is not covered - lockID can actually be 0 in theory if there
	//	were so many locks that we rolled over)
	//
	(*pliLockID).QuadPart = _wtoi64(pwsz);
	if (0 == (*pliLockID).QuadPart)
	{
		hr = E_DAV_INVALID_HEADER;
		goto ret;
	}

ret:

	return hr;
}

//	------------------------------------------------------------------------
//	HrValidTokenExpression()
//
//	Helper function for If: header processing.
//	Once we've found a token, this function will check the path.
//	(So this function only succeeds completely if the token is still valid,
//	AND the token matches the provided path.)
//	If this token is valid, this function returns S_OK
//	If this token is not valid, this function returns E_DAV_INVALID_HEADER
//	If other fatal errors occured we propogate them out of the function
//
HRESULT
HrValidTokenExpression (IMethUtil * pmu,
							 LPCWSTR pwszToken,
							 LPCWSTR pwszPath,
							 OUT LARGE_INTEGER * pliLockID)
{
	HRESULT hr = S_OK;
	LARGE_INTEGER liLockID;

	Assert (pmu);
	Assert (pwszToken);
	Assert (pwszPath);

	//	Get the lock tokens
	//
	hr = HrLockIdFromString (pmu, pwszToken, &liLockID);
	if (FAILED(hr))
	{
		//	Unrecognized locktoken.  Does not match.
		//
		goto ret;
	}

	//	Check if the locktoken is valid (live in the cache).
	//	E_DAV_INVALID_HEADER means the lock was not found,
	//	paths conflicted or owners were not the same
	//
	hr = CSharedLockMgr::Instance().HrCheckLockID(liLockID,
											   pmu->HitUser(),
											   pwszPath);
	if (FAILED(hr))
	{
		if (E_DAV_LOCK_NOT_FOUND == hr ||
		    HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) == hr ||
		    E_DAV_CONFLICTING_PATHS == hr)
		{
			hr = E_DAV_INVALID_HEADER;
		}
		goto ret;
	}
	
	//	If they requested the lock id back, give it to 'em.
	//
	if (pliLockID)
	{
		*pliLockID = liLockID;
	}

ret:
	
	return hr;
}


//	------------------------------------------------------------------------
//
//	HrCheckIfHeader
//
//		Check the If header.
//		Processing will check the lock cache to validate locktokens.
//
//		The pmu (IMethUtil) is provided for access to the lock cache to check tokens.
//		The pwszPath provides the path to match for untagged lists.
//
//	Format of the If header
//		If = "If" ":" ( 1*No-tag-list | 1*Tagged-list)
//		No-tag-list = List
//		Tagged-list = Resource 1*List
//		Resource = Coded-url
//		List = "(" 1*(["Not"](State-token | "[" entity-tag "]")) ")"
//		State-token = Coded-url
//		Coded-url = "<" URI ">"
//	Basically, one thing has to match in the whole header in order for the
//	entire header to be "good".
//	Each URI has a _set_ of state lists.  A list is enclosed in parentheses.
//	Each list is a logical "and".
//	A set of lists is a logical "or".
//
//	Returns:
//		S_OK			Process the method.
//		other error		Map the error
//			(412 will be handled by this case)
//
//	DAV-compliance shortfalls
//	We fall short of true DAV-compliance in three spots in this function.
//	1 -	This code does not prevent (fail) an utagged list followed by
//		a tagged list.  Strict DAV-compliance would FAIL such an If-header
//		as a bad request.
//	2 - This code does not "correctly" apply tagged lists with multiple
//		URIs.  Strict DAV-compliance would require evaluating the If-header
//		once for each URI as the method is processed, and ignore any URIs
//		in the tagged list that never were "processed".  We don't (can't)
//		process our MOVE/COPY/DELETEs that way, but instead do a pre-checking
//		pass on the If: header.  At pre-check time, we treat the If-header
//		as if the tagged lists are all AND-ed together.
//		THIS MEANS that if a URI is listed, and it doesn't have a good
//		matching (valid) list, we will FAIL the whole method with 412 Precondition Failed.
//	3 -	This code does not handle ETags in the If-header.
//
//$LATER: When we are part of the locktoken header, check the m_fPathsSet.
//$LATER: We might be able to get our info quicker if paths are already set!
//
HRESULT
HrCheckIfHeader (IMethUtil * m_pmu,	// to ease the transition later...
				 LPCWSTR pwszDefaultPath)
{
	HRESULT hr = S_OK;
	BOOL fOneMatch = FALSE;
	FETCH_TOKEN_TYPE tokenNext = TOKEN_SAME_LIST;
	LPCWSTR pwsz;
	LPCWSTR pwszToken;
	LPCWSTR pwszPath = pwszDefaultPath;
	CStackBuffer<WCHAR,MAX_PATH> pwszTranslated;
	BOOL fFirstURI;
	WCHAR rgwchEtag[MAX_PATH];

	//	Quick check -- if the header doesn't exist, just process the method.
	//
	pwsz = m_pmu->LpwszGetRequestHeader (gc_szLockToken, TRUE);
	if (!pwsz)
		return S_OK;

	IFITER iter(pwsz);

	//	Double nested loop
	//	First loop (outer loop) looks through all the "tagged lists"
	//	(tagged list = URI + set of lists of tokens)
	//	If the first list is untagged, use the default path (the request URI)
	//	for the untagged first set of lists.
	//	Second loop looks through all the token lists for a single URI.
	//
	//	NOTE: This code does NOT perfectly implement the draft.
	//	The draft says that an untagged production (no initial URI)
	//	can't have any subsequent URIs.  Frankly, that's much more complex to
	//	implement -- need to set another bool var and DISALLOW that one case.
	//	So I'm skipping it for now. --BeckyAn
	//

	fFirstURI = TRUE;
	for (pwsz = iter.PszNextToken (TOKEN_URI); // start with the first URI
		 pwsz || fFirstURI;
		 pwsz = iter.PszNextToken (TOKEN_NEW_URI))  // skip to the next URI in the list
	{

		//	If our search for the first URI came up blank, use
		//	the default path instead.
		//	NOTE: This can only happen if it's the first URI (fFirstURI is TRUE)
		//	(we explicitly check psz in the loop condition, and QUIT the loop
		//	if neither psz or fFirstURI are true).
		//
		if (!pwsz)
		{
			Assert (fFirstURI);
			pwszPath = pwszDefaultPath;
		}
		else
		{
			//	If we have a name (tag, uri), use it instead of the default name.
			//
			CStackBuffer<WCHAR,MAX_PATH>	pwszNormalized;
			SCODE sc;
			UINT cch;

			//	NOTE: Our psz is still quoted with <>.  Unescaping must ignore these chars.
			//
			Assert (L'<' == *pwsz);

			//	Get sufficient buffer for canonicalization
			//
			cch = static_cast<UINT>(wcslen(pwsz + 1));
			if (NULL == pwszNormalized.resize(CbSizeWsz(cch)))
			{
				FsLockTrace ("HrCheckIfHeader() - Error while allocating memory 0x%08lX\n", E_OUTOFMEMORY);
				return E_OUTOFMEMORY;
			}

			//	Canonicalize the URL taking into account that it may be fully qualified.
			//	Does not mater what value we pass in cch - it is out parameter only.
			//
			sc = ScCanonicalizePrefixedURL (pwsz + 1,
											pwszNormalized.get(),
											&cch);
			if (S_OK != sc)
			{
				//	We gave sufficient space
				//
				Assert(S_FALSE != sc);
				FsLockTrace ("HrCheckIfHeader() - ScCanonicalizePrefixedURL() failed 0x%08lX\n", sc);
				return sc;
			}

			//	We're in a loop, so try to use a static buffer first when
			//	converting this storage path.
			//
			cch = pwszTranslated.celems();
			sc = m_pmu->ScStoragePathFromUrl (pwszNormalized.get(),
											  pwszTranslated.get(),
											  &cch);
			if (S_FALSE == sc)
			{
				if (NULL == pwszTranslated.resize(cch))
					return E_OUTOFMEMORY;

				sc = m_pmu->ScStoragePathFromUrl (pwszNormalized.get(),
												  pwszTranslated.get(),
												  &cch);
			}
			if (FAILED (sc))
			{
				FsLockTrace ("HrCheckIfHeader -- failed to translate a URI to a path.\n");
				return sc;
			}
			Assert ((S_OK == sc) || (W_DAV_SPANS_VIRTUAL_ROOTS == sc));

			//	Sniff the last character and remove any final quoting '>' here.
			//
			cch = static_cast<UINT>(wcslen(pwszTranslated.get()));
			if (L'>' == pwszTranslated[cch - 1])
				pwszTranslated[cch - 1] = L'\0';

			//	Hold onto the path.
			//
			pwszPath = pwszTranslated.get();
		}
		Assert (pwszPath);

		//	This is no longer our first time through the URI loop.  Clear our flag.
		//
		fFirstURI = FALSE;

		//	Loop through all tokens, checking as we go.
		//$REVIEW: Right now, PszNextToken can't give different returns
		//$REVIEW: for "not found" versus "syntax error".
		//$REVIEW: That means we'll can't really give different, distinct
		//$REVEIW: codes for syntax problems -- any failure is mapped to 412 Precond Failed.
		//
		for (pwszToken = iter.PszNextToken (TOKEN_START_LIST) ;
			 pwszToken;
			 pwszToken = iter.PszNextToken (tokenNext) )
		{
			Assert (pwszToken);

			//	Check this one token for validity.
			//$LATER: These checks could be folded into the HrValidTokenExpression
			//$LATER: call.  This will be important later, when we have
			//$LATER: more different token types to work with.
			//
			if (L'<' == *pwszToken)
			{
				hr = HrValidTokenExpression (m_pmu, pwszToken, pwszPath, NULL);
			}
			else if (L'[' == *pwszToken)
			{
				FILETIME ft;

				hr = S_OK;

				//	Manually fetch the Etag for this item, and compare it
				//	against the provided Etag.   Set the error code the
				//	same way that HrValidTokenExpression does:
				//	If the Etag does NOT match, set the error code to
				//	E_DAV_INVALID_HEADER.
				//	Remember to skip the enclosing brackets ([]) when
				//	comparing the Etag strings.
				//
				if (!FGetLastModTime (NULL, pwszPath, &ft))
					hr = E_DAV_INVALID_HEADER;
				else if (!FETagFromFiletime (&ft, rgwchEtag, m_pmu->GetEcb()))
					hr = E_DAV_INVALID_HEADER;
				else
				{
					//	Skip the square bracket -- this level of quoting
					//	is just for the if-header, not
					//
					pwszToken++;

					//	Since we do not do week ETAG checking, if the
					//	ETAG starts with "W/" skip those bits
					//
					if (L'W' == *pwszToken)
					{
						Assert (L'/' == *(pwszToken + 1));
						pwszToken += 2;
					}

					//	Our current Etags must be quoted.
					//
					Assert (L'\"' == pwszToken[0]);

					//	Compare these etags, INcluding the double-quotes,
					//	but EXcluding the square-brackets (those were added
					//	just for the IF: header.
					//
					if (wcsncmp (rgwchEtag, pwszToken, wcslen(rgwchEtag)))
						hr = E_DAV_INVALID_HEADER;
				}
			}
			else
				hr = E_FAIL;

			if ((S_OK == hr && !iter.FCurrentNot()) ||
				(S_OK != hr && iter.FCurrentNot()))
			{
				//	Either token matches, and this is NOT a "Not" expression,
				//	OR the token does NOT match, and this IS a "Not" expression.
				//	This one expression in the current list is true.
				//	Rember this match, and check the next token in the same list.
				//	If we don't find another token in the same list, we will
				//	drop out of the for-each-token loop with fOneMatch TRUE,
				//	and we will know that one whole list matched, so this URI
				//	has a valid list.
				//
				fOneMatch = TRUE;
				tokenNext = TOKEN_SAME_LIST;
				continue;
			}
			else
			{
				//	Either the token was not valid in a non-"Not" expression,
				//	or the token was valid in a "Not" expression.
				//	This one expression in this list is NOT true.
				//	That makes this list NOT true -- skip the rest of this
				//	list and move on to the next list for this URI.
				//
				fOneMatch = FALSE;
				tokenNext = TOKEN_NEW_LIST;
				continue;
			}

		} // rof - tokens in this list

		//	Check if we parsed a whole list with matches.
		//
		if (fOneMatch)
		{
			//	This whole list matched!  Return OK.
			//
			hr = S_OK;
		}
		else
		{
			//	This list did not match.
			//
			//	NOTE: We are quitting here if any one URI is lacking
			//	a matching list.  We are treating the URI-sets as if they
			//	are AND-ed together. This is not strictly DAV-compliant.
			//	NOTE: See the comments at the top of this function about
			//	true DAV-compliance and multi-URI Ifs.
			//
			hr = E_DAV_IF_HEADER_FAILURE;

			//	We've failed.  Quit now.
			//
			break;
		}

	} // rof - URIs in this header

	return hr;
}

HRESULT
HrCheckStateHeaders (IMethUtil * pmu,
					 LPCWSTR pwszPath,
					 BOOL fGetMeth)
{
	return HrCheckIfHeader(pmu, pwszPath);
}

//	------------------------------------------------------------------------
//	CParseLockTokenHeader::FOneToken
//	Special test -- F if not EXACTLY ONE item in the header.
BOOL
CParseLockTokenHeader::FOneToken()
{
	LPCWSTR pwsz;
	LPCWSTR pwszToken;
	BOOL fOnlyOne = FALSE;

	//	Quick check -- if the header doesn't exist, just process the method.
	//
	pwsz = m_pmu->LpwszGetRequestHeader (gc_szLockToken, TRUE);
	if (!pwsz)
		return FALSE;

	IFITER iter(pwsz);

	//	If we have LESS than one token, return FALSE.
	pwszToken = iter.PszNextToken(TOKEN_START_LIST);
	if (!pwszToken)
		goto ret;

	//	If we have MORE than one token in this list, return FALSE.
	pwszToken = iter.PszNextToken(TOKEN_SAME_LIST);
	if (pwszToken)
		goto ret;

	//	If we have other lists for this uri, return FALSE.
	pwszToken = iter.PszNextToken(TOKEN_NEW_LIST);
	if (pwszToken)
		goto ret;

	fOnlyOne = TRUE;

ret:
	//	We have exactly one token.
	return fOnlyOne;
}

//	------------------------------------------------------------------------
//	CParseLockTokenHeader::SetPaths
//	Feed the relevant paths to this lock token parser.
HRESULT
CParseLockTokenHeader::SetPaths (LPCWSTR pwszPath, LPCWSTR pwszDest)
{
	HRESULT hr = S_OK;

	//	They better be passing in at least one path.
	Assert(pwszPath);

	Assert(!m_fPathsSet);

	//	Copy the provided paths locally.
	//
	m_pwszPath = WszDupWsz (pwszPath);
	m_cwchPath = static_cast<UINT>(wcslen (m_pwszPath.get()));

	if (pwszDest)
	{
		m_pwszDest = WszDupWsz (pwszDest);
		m_cwchDest = static_cast<UINT>(wcslen (m_pwszDest.get()));
	}

	m_fPathsSet = TRUE;

	return hr;
}

//	------------------------------------------------------------------------
//	CParseLockTokenHeader::HrGetLockIdForPath
//	Get the token string for a path WITH a certain kind of access.
//$LATER: Obey fPathLookup (should be true on depth-type ops, when we add dir-locks)
//$LATER: Do back-path-lookup to find the dir-lock that is locking us.
HRESULT
CParseLockTokenHeader::HrGetLockIdForPath (LPCWSTR pwszPath,
										   DWORD dwAccess,
										   LARGE_INTEGER * pliLockID,
										   BOOL fPathLookup)  // defaulted to FALSE
{
	HRESULT hr = E_DAV_LOCK_NOT_FOUND;
	FETCH_TOKEN_TYPE tokenNext = TOKEN_SAME_LIST;
	LPCWSTR pwsz;
	LPCWSTR pwszToken;

	//	Assert that we're in the correct state to call this method.
	//
	Assert(m_fPathsSet);

	//	Init our out parameter.
	//
	Assert(pliLockID);
	(*pliLockID).QuadPart = 0;

	//	The requested path must be a child of one of our set paths.
	//
	Assert (!_wcsnicmp (pwszPath, m_pwszPath.get(), m_cwchPath) ||
			(m_pwszDest.get() &&
			 !_wcsnicmp (pwszPath, m_pwszDest.get(), m_cwchDest)));

	//	Quick check -- if the header doesn't exist, just process the method.
	//
	pwsz = m_pmu->LpwszGetRequestHeader (gc_szLockToken, TRUE);
	if (!pwsz)
		return hr;

	IFITER iter(pwsz);


	//	If this is a tagged production, there will be a URI here
	//	(pszToken will be non-NULL).  In that case,  search for
	//	the URI that matches (translates to match) our pwszPath.
	//	If there is NO URI here, we're a non-tagged production, and
	//	all lists & tokens are applied to the root URI of the request.
	//
	pwszToken = iter.PszNextToken (TOKEN_URI);
	if (pwszToken)
	{
		//	Loop through the tokens, looking only at uris.
		//	When we find the one that matches our given path, break out.
		//	Then the iter will hold our place, and the next set of code
		//	will search through the lists for this uri....
		//
		for (;	// already fetched first URI token above
			 pwszToken;
			 pwszToken = iter.PszNextToken (TOKEN_NEW_URI) )
		{
			CStackBuffer<WCHAR,MAX_PATH> pwszNormalized;
			CStackBuffer<WCHAR,MAX_PATH> pwszTranslated;
			SCODE sc;
			UINT cch;

			Assert (pwszToken);

			//	NOTE: Our psz is still quoted with <>.  Unescaping must ignore these chars.
			//
			Assert (L'<' == *pwszToken);

			//	Get sufficient buffer for canonicalization
			//
			cch = static_cast<UINT>(wcslen(pwszToken + 1));
			if (NULL == pwszNormalized.resize(CbSizeWsz(cch)))
			{
				FsLockTrace ("CParseLockTokenHeader::HrGetLockIdForPath()  - Error while allocating memory 0x%08lX\n", E_OUTOFMEMORY);
				return E_OUTOFMEMORY;
			}

			//	Canonicalize the URL taking into account that it may be fully qualified.
			//	Does not mater what value we pass in cch - it is out parameter only.
			//
			sc = ScCanonicalizePrefixedURL (pwszToken + 1,
											pwszNormalized.get(),
											&cch);
			if (S_OK != sc)
			{
				//	We gave sufficient space
				//
				Assert(S_FALSE != sc);
				FsLockTrace ("HrCheckIfHeader() - ScCanonicalizePrefixedURL() failed 0x%08lX\n", sc);
				return sc;
			}

			//	We're in a loop, so try to use a static buffer first when
			//	converting this storage path.
			//
			cch = pwszTranslated.celems();
			sc = m_pmu->ScStoragePathFromUrl (pwszNormalized.get(),
											  pwszTranslated.get(),
											  &cch);
			if (S_FALSE == sc)
			{
				if (NULL == pwszTranslated.resize(cch))
				{
					return E_OUTOFMEMORY;
				}

				sc = m_pmu->ScStoragePathFromUrl (pwszNormalized.get(),
												  pwszTranslated.get(),
												  &cch);
			}
			if (FAILED (sc))
			{
				FsLockTrace ("HrCheckIfHeader -- failed to translate a URI to a path.\n");
				return sc;
			}
			Assert ((S_OK == sc) || (W_DAV_SPANS_VIRTUAL_ROOTS == sc));

			//	Remove any final quoting '>' here.
			//
			cch = static_cast<UINT>(wcslen (pwszTranslated.get()));
			if (L'>' == pwszTranslated[cch - 1])
				pwszTranslated[cch - 1] = L'\0';

			if (!_wcsicmp (pwszPath, pwszTranslated.get()))
				break;
		}

		//	If we fall out of the loop with NO pszToken, then we didn't
		//	find ANY matching paths.... return an error.
		//
		if (!pwszToken)
		{
			hr = E_DAV_LOCK_NOT_FOUND;
			goto ret;
		}
	}
	else if (_wcsicmp (pwszPath, m_pwszPath.get()))
	{
		//	There is NO URI st the start, so we're a non-tagged production,
		//	BUT the caller was looking for some path BESIDES the root URI's path
		//	(didn't match m_pwszPath in the above test!!!).
		//	FAIL and tell them that we can't find any locktokens for this path.
		//
		hr = E_DAV_LOCK_NOT_FOUND;
		goto ret;
	}

	//	Now, the IFITER should be positioned at the start of the list
	//	that applies to this path.
	//	Look for a token under this tag that matches.
	//

	//	Loop through all tokens, checking as we go.
	//$REVIEW: Right now, PszNextToken can't give different returns
	//$REVIEW: for "not found" versus "syntax error".
	//$REVIEW: That means we'll never give "bad request" for syntax problems....
	//
	for (pwszToken = iter.PszNextToken (TOKEN_START_LIST);
		 pwszToken;
		 pwszToken = iter.PszNextToken (tokenNext) )
	{
		LARGE_INTEGER liLockID;

		Assert (pwszToken);

		//	Check this one token for validity.
		//
		if (L'<' == *pwszToken)
		{
			hr = HrValidTokenExpression (m_pmu,
										 pwszToken,
										 pwszPath,
										 &liLockID);
		}
		else
		{
			//	This is not a locktoken -- ignore it for now.
			//
			//	This list still could have our locktoken -- keep looking in
			//	this same list.
			//
			//	NTRaid#244243 -- However, this list might NOT have our locktoken.
			//	Need to look at any list for this uri.
			//
			tokenNext = TOKEN_ANY_LIST;
			continue;
		}

		//	We only want this lock token if it IS valid, AND
		//	it's not from a "Not" expression, AND it comes from a
		//	valid list.  So, if we hit an invalid token, QUIT searching
		//	this list. (Skip ahead to the next list.)
		//
		if (S_OK == hr && !iter.FCurrentNot())
		{
			//	The token matches, AND it's not from a "Not" expression.
			//	This one's good.  Send it back.
			//
			*pliLockID = liLockID;
			hr = S_OK;
			goto ret;
		}
		else if (S_OK != hr && iter.FCurrentNot())
		{
			//	The token does NOT match, and this IS a "Not" expression.
			//	This list still could be true overall -- keep looking in
			//	this same list.
			//
			//	NTRaid#244243 -- However, this list might NOT have our locktoken.
			//	Need to look at any list for this uri.
			//
			tokenNext = TOKEN_ANY_LIST;
			continue;
		}
		else
		{
			//	Either the token was not valid in a non-"Not" expression,
			//	or the token was valid in a "Not" expression.
			//	This expression in this list is NOT true.
			//	Since this is not a "good" list, don't look here
			//	for a matching token -- skip to the next list.
			//
			tokenNext = TOKEN_NEW_LIST;
			continue;
		}

	}

	//	We didn't find a token for this item.
	//
	hr = E_DAV_LOCK_NOT_FOUND;

ret:

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\httpext\mem.cpp ===
/*
 *	M E M . C P P
 *
 *	File system implementation of DAV allocators
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davfs.h"

//	Use the default DAV allocator implementations
//

#define g_szMemDll L"staxmem.dll"
#include <memx.h>

//	Mapping the exdav non-throwing allocators to something local
//
LPVOID __fastcall ExAlloc( UINT cb )				{ return g_heap.Alloc( cb ); }
LPVOID __fastcall ExRealloc( LPVOID pv, UINT cb )	{ return g_heap.Realloc( pv, cb ); }
VOID __fastcall ExFree( LPVOID pv )					{ g_heap.Free( pv ); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\httpext\fsutil.cpp ===
/*
 *	F S U T I L . C P P
 *
 *	File system routines
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davfs.h"
#include <aclapi.h>

const CHAR gc_szUncPrefix[] = "\\\\";
const UINT gc_cchszUncPrefix = CElems(gc_szUncPrefix) - 1;

//	Location checking ---------------------------------------------------------
//
//	ScCheckForLocationCorrectness() will check the url against the
//	resource and either add the appropriate location header, or it will
//	request a redirect if the url and the resource do not agree.  The
//	caller has the control over whether or not a true redirect is desired.
//	As an informational return, if a location header has been added S_FALSE
//	will be returned to the caller.
//
SCODE
ScCheckForLocationCorrectness (IMethUtil* pmu,
							   CResourceInfo& cri,
							   UINT modeRedirect)
{
	SCODE sc = S_OK;
	BOOL fTrailing;

	Assert (pmu);
	fTrailing = FTrailingSlash (pmu->LpwszRequestUrl());

	//	If the trailing slash existance does not jive with the resource type...
	//
	if (!cri.FCollection() != !fTrailing)
	{
		if (modeRedirect == REDIRECT)
		{
			auto_heap_ptr<CHAR>	pszLocation;

			//	Construct the redirect url.
			//
			sc = pmu->ScConstructRedirectUrl (cri.FCollection(),
											  pszLocation.load());
			if (FAILED (sc))
				goto ret;

			//	Redirect this badboy
			//
			sc = pmu->ScRedirect (pszLocation);
			if (FAILED (sc))
				goto ret;
		}
		else
		{
			//	EmitLocation takes care of the trailing slash checking
			//
			pmu->EmitLocation (gc_szContent_Location,
							   pmu->LpwszRequestUrl(),
							   cri.FCollection());
		}

		//	Tell the caller we had to change the location
		//
		sc = S_FALSE;
	}

ret:

	return sc;
}

//	Access checking -----------------------------------------------------------
//
//	class safe_security_revert ------------------------------------------------
//
//		Switches the current thread's impersonation token to the cached
//		"Reverted Security-enabled Thread Token" when FSecurityInit is called,
//		for the duration of the object's lifespan.
//		Unconditionally reimpersonates on exit, based on the provided handle.
//
//		NOTE: UNCONDITIONALLY reimpersonates on exit, using the impersonation
//			handle provided at construction-time.
//			(Just wanted to make that clear.)
//
//	WARNING: the safe_revert class should only be used by FChildISAPIAccessCheck
//	below.  It is not a "quick way to get around" impersonation.  If
//	you do need to do something like this, please see Becky -- she will then
//	wack you up'side the head.
//
class safe_security_revert
{
	//	Local client token to re-impersonate at dtor time.
	HANDLE		m_hClientToken;

	//	This is our cached security-enabled thread token.
	static HANDLE s_hSecurityThreadToken;

	//	NOT IMPLEMENTED
	//
	safe_security_revert (const safe_security_revert&);
	safe_security_revert& operator= (const safe_security_revert&);

public:

	explicit safe_security_revert (HANDLE h) : m_hClientToken(h)
	{
		Assert (m_hClientToken);
	}
	~safe_security_revert()
	{
		if (!ImpersonateLoggedOnUser (m_hClientToken))
		{
			DebugTrace ("ImpersonateLoggedOnUser failed with last error %d\n", GetLastError());

			//	There's not much we can do in this dtor. throw
			//
			throw CLastErrorException();
		}			
	}

	BOOL FSecurityInit (BOOL fForceRefresh);

	//	Token cache manipulators
	//
	static inline HANDLE GetToken();
	static inline VOID ClearToken();
	static inline BOOL FSetToken( HANDLE hToken );
};

//	Storage for our metaclass data (the cached thread token).
//
HANDLE safe_security_revert::s_hSecurityThreadToken = NULL;

//	Public function to clear out the cached thread token.
//	Simply calls the metaclass method.
//
void CleanupSecurityToken()
{
	safe_security_revert::ClearToken();
}

//	------------------------------------------------------------------------
//
//	GetToken()
//
//	Return the cached security token.
//
HANDLE safe_security_revert::GetToken()
{
	return s_hSecurityThreadToken;
}

//	------------------------------------------------------------------------
//
//	FSetToken()
//
//	Set the cached security token.
//
BOOL safe_security_revert::FSetToken( HANDLE hToken )
{
	//
	//	If the cache is clear then set it with this token
	//	and return whether we cache the token.
	//
	return NULL == InterlockedCompareExchangePointer(&s_hSecurityThreadToken,
													 hToken,
													 NULL);
}

//	------------------------------------------------------------------------
//
//	ClearToken()
//
//	Clear out the cached security token
//
VOID safe_security_revert::ClearToken()
{
	//
	//	Replace whatever token is cached with NULL.
	//
	HANDLE hToken = InterlockedExchangePointer(	&s_hSecurityThreadToken,
												NULL);

	//
	//	If we replaced a non-NULL token then close it.
	//
	if (hToken)
		CloseHandle (hToken);
}

//	------------------------------------------------------------------------
//
//	FSecurityInit()
//
//		Set our thread token to the cached security-enabled thread token.
//		If no security-enabled token is cached, go get one.
//
BOOL safe_security_revert::FSecurityInit (BOOL fForceRefresh)
{
	auto_handle<HANDLE> hTokenNew;
	HANDLE hToken;

	//	Clear out the cached security token if told to do so.
	//
	if (fForceRefresh)
		ClearToken();

	//	Fetch the cached security token.  Note that even if
	//	we just cleared it out, we may get back a non-NULL
	//	token here if another thread has already reloaded
	//	the cache.
	//
	hToken = GetToken();

	//
	//	If the cache was clear then create our own new token
	//	that is set up to do security access queries.
	//
	if ( NULL == hToken )
	{
		LUID SecurityPrivilegeID;
		TOKEN_PRIVILEGES tkp;

		//	RevertToSelf to get us running as system (the local diety).
		//
		if (!RevertToSelf())
			return FALSE;

		//	ImpersonateSelf copies the process token down to this thread.
		//	Then we can change the thread token's privileges without messing
		//	up the process token.
		//
		if (!ImpersonateSelf (SecurityImpersonation))
		{
			DebugTrace ("ssr::FSecurityInit--ImpersonateSelf failed with %d.\n",
						GetLastError());
			return FALSE;
		}

		//	Open our newly-copied thread token to add a privilege (security).
		//	NOTE: The adjust and query flags are needed for this operation.
		//	The impersonate flag is needed for use to use this token for
		//	impersonation -- as we do in SetThreadToken below.
		//	OpenAsSelf -- FALSE means open as thread, possibly impersonated.
		//	TRUE means open as the calling process, not as the local (impersonated) thread.
		//
		if (!OpenThreadToken (GetCurrentThread(),
							  TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY |
							  TOKEN_IMPERSONATE,
							  TRUE,
							  hTokenNew.load()))
		{
			DebugTrace ("ssr::FSecurityInit--OpenThreadToken failed with %d.\n",
						GetLastError());
			return FALSE;
		}

		//	Enable the SE_SECURITY_NAME privilege, so that we can fetch
		//	security descriptors and call AccessCheck.
		//
		if (!LookupPrivilegeValue (NULL,
								   SE_SECURITY_NAME,
								   &SecurityPrivilegeID))
		{
			DebugTrace ("ssr::FSecurityInit--LookupPrivilegeValue failed with %d\n",
						GetLastError());
			return FALSE;
		}

		tkp.PrivilegeCount = 1;
		tkp.Privileges[0].Luid = SecurityPrivilegeID;
		tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

		AdjustTokenPrivileges (hTokenNew,
							   FALSE,
							   &tkp,
							   sizeof(TOKEN_PRIVILEGES),
							   (PTOKEN_PRIVILEGES) NULL,
							   (PDWORD) NULL);

		//	The return value of AdjustTokenPrivileges cannot be tested directly...
		//	(always returns 1)
		//
		if (GetLastError() != ERROR_SUCCESS)
		{
			DebugTrace ("ssr::FSecurityInit--AdjustTokenPrivileges failed with %d\n",
						GetLastError());
			return FALSE;
		}

		//	Use this new token
		//
		hToken = hTokenNew.get();
	}

	//	At this point we must have a token
	//
	Assert (NULL != hToken);

	//	Set the current thread to use the token.
	//
	if (!SetThreadToken (NULL, hToken))
	{
		DebugTrace ("ssr::FSecurityInit--SetThreadToken failed with %d.\n",
					GetLastError());
		return FALSE;
	}

	//	Everything's cool.  We are now running with a thread token
	//	that has security-checking privileges.
	//
	//	If we created a new token along the way then attempt to cache it.
	//	We don't care if caching fails, but if it succeeds we DON'T want
	//	to close the handle because we just gave it to the cache.
	//
	if (hTokenNew.get())
	{
		if (FSetToken(hTokenNew.get()))
		{
			hTokenNew.relinquish();
		}
	}

	return TRUE;
}


GENERIC_MAPPING	gc_gmFile =
{
	FILE_GENERIC_READ,
	FILE_GENERIC_WRITE,
	FILE_GENERIC_EXECUTE,
	FILE_ALL_ACCESS
};


//	------------------------------------------------------------------------
//
//	ScChildISAPIAccessCheck
//
//	Checks if the client (our impersonation handle from off the ECB)
//	has the specified access to the specified resource.
//	NOTE: Uses a cached "security-enabled-thread-token" to query the
//	security descriptor for the specified resource.
//
SCODE __fastcall
ScChildISAPIAccessCheck (const IEcb& ecb, LPCWSTR pwsz, DWORD dwAccess, LPBYTE pbSD)
{
	SECURITY_DESCRIPTOR * pSD = NULL;
	DWORD dwRet;
	auto_handle<HANDLE>	hToken;
	BYTE	psFile[256];
	DWORD	dwPS = sizeof (psFile);
	DWORD	dwGrantedAccess = 0;
	BOOL	fAccess = FALSE;
	BOOL	fRet;

	//	pbSD is used only in DAVEX, should never be passed in from HTTPEXT
	//
	if (NULL != pbSD)
	{
		//	This should never happen.  Removing the param is not 
		//
		throw CHresultException (E_FAIL);
	}

	//	IIS should have granted our impersonated token the proper access
	//	rights to check the ACL's on the resource.  So we are going to go
	//	after it without any change of impersonation.
	//
	dwRet = GetNamedSecurityInfoW (const_cast<LPWSTR>(pwsz),
								   SE_FILE_OBJECT,
								   OWNER_SECURITY_INFORMATION |
								   GROUP_SECURITY_INFORMATION |
								   DACL_SECURITY_INFORMATION,
								   NULL, NULL, NULL, NULL,
								   reinterpret_cast<VOID **>(&pSD));
	if (ERROR_SUCCESS != dwRet)
	{
		//	If the resource does not exist at all, as no security prevent
		//	us from trying to access a non-existing resource, so we
		//	should allow the access.
		//
		if ((dwRet == ERROR_PATH_NOT_FOUND) ||
			(dwRet == ERROR_FILE_NOT_FOUND))
		{
			fAccess = TRUE;
			goto ret;
		}

		//	Now then... If we got here, we don't really know what went wrong,
		//	so we are going to try and do things the old way.
		//
		//	BTW: We really do not expect this code to ever get run.
		//
		DebugTrace ("WARNING: WARNING: WARNING: ScChildISAPIAccessCheck() -- "
					"GetNamedSecurityInfoW() failed %d (0x%08x): falling back...\n",
					dwRet, dwRet);

		//	Scope to control the lifetime of our un-impersonation.
		//
		safe_security_revert sr (ecb.HitUser());

		dwRet = GetNamedSecurityInfoW (const_cast<LPWSTR>(pwsz),
									   SE_FILE_OBJECT,
									   OWNER_SECURITY_INFORMATION |
									   GROUP_SECURITY_INFORMATION |
									   DACL_SECURITY_INFORMATION,
									   NULL, NULL, NULL, NULL,
									   reinterpret_cast<VOID **>(&pSD));
		if (ERROR_SUCCESS != dwRet)
		{
			//	If the resource does not exist at all, as no security prevent
			//	us from trying to access a non-existing resource, so we
			//	should allow the access.
			//
			if ((dwRet == ERROR_PATH_NOT_FOUND) ||
				(dwRet == ERROR_FILE_NOT_FOUND))
			{
				fAccess = TRUE;
			}
			
			goto ret;
		}

		//	End of safe_security_revert scope.
		//	Now the safe_security_revert dtor will re-impersonate us.
		//
	}

	//	Get our thread's access token.
	//	OpenAsSelf -- TRUE means open the thread token as the process
	//	itself FALSE would mean as thread, possibly impersonated
	//	We want the impersonated access token, so we want FALSE here!
	//
	fRet = OpenThreadToken (GetCurrentThread(),
							TOKEN_QUERY,
							TRUE,
							hToken.load());
	if (!fRet)
	{
		//	This should NEVER fail.  We are impersonated, so we do have
		//	a thread-level access token.  If  conditions change, and we
		//	have a state where this can fail,  remove the TrapSz below!
		//
		//$	REVIEW: OpenThreadToken() can fail for any number of reasons
		//	not excluding resource availability.  So, this trap is a bit
		//	harsh, no?
		//
		//	TrapSz("OpenThreadToken failed while we are impersonated!");
		//
		//$	REVIEW: end.
		DebugTrace ("ScChildISAPIAccessCheck--"
					"Error from OpenThreadToken %d (0x%08x).\n",
					GetLastError(), GetLastError());
		goto ret;
	}

	//	Map the requested access to file-specific access bits....
	//
	MapGenericMask (&dwAccess, &gc_gmFile);

	//	And now check for this access on the file.
	//
	fRet = AccessCheck (pSD,
						hToken,
						dwAccess,
						&gc_gmFile,
						(PRIVILEGE_SET*)psFile,
						&dwPS,
						&dwGrantedAccess,
						&fAccess);
	if (!fRet)
	{
		DebugTrace ("ScChildISAPIAccessCheck--Error from AccessCheck %d (0x%08x).\n",
					GetLastError(), GetLastError());
		goto ret;
	}

	//	Now, fAccess tells whether the impersonated token has
	//	the requested access.  Return this to the caller.
	//

ret:
	if (pSD)
		LocalFree (pSD);

	return fAccess ? S_OK : E_ACCESSDENIED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\httpext\fssearch.cpp ===
/*
 *	F S S E A R C H . C P P
 *
 *	Sources file system implementation of DAV-Search
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davfs.h"

#ifdef __cplusplus
extern "C" {
#endif
#include <msidxs.h>
#ifdef __cplusplus
}
#endif

#include "_fssrch.h"
#include <oledberr.h>
#include <cierror.h>

// 	20001801-5de6-11d1-8e38-00c04fb9386d is FMTID_PropertySet as defined
//	in pbagex.h. It's the guid of custom props,
//
static const WCHAR gsc_wszSetPropertyName[] =
	L"SET PROPERTYNAME '20001801-5de6-11d1-8e38-00c04fb9386d' PROPID '%s' AS \"%s\"";

//	gsc_wszPath is used for the Tripoli prop "Path", so don't move to common sz.cpp
//
static const WCHAR	gsc_wszSelectPath[] = L"SELECT Path ";
static const ULONG	MAX_FULLY_QUALIFIED_LENGTH = 2048;
static const WCHAR	gsc_wszShallow[] = L"Shallow";
static const ULONG	gsc_cchShallow = CchConstString(gsc_wszShallow);

//	class CDBCreateCommand ----------------------------------------------------
//
class CDBCreateCommand : private OnDemandGlobal<CDBCreateCommand, SCODE *>
{
	//
	//	Friend declarations required by OnDemandGlobal template
	//
	friend class Singleton<CDBCreateCommand>;
	friend class RefCountedGlobal<CDBCreateCommand, SCODE *>;

	//
	//	Pointer to the IDBCreateCommand object
	//
	auto_com_ptr<IDBCreateCommand> m_pDBCreateCommand;

	//	CREATORS
	//
	//	Declared private to ensure that arbitrary instances
	//	of this class cannot be created.  The Singleton
	//	template (declared as a friend above) controls
	//	the sole instance of this class.
	//
	CDBCreateCommand() {}
	BOOL FInit( SCODE * psc );

public:
	static SCODE CreateCommand( ICommandText ** ppCommandText );

	static VOID Release()
	{
		DeinitIfUsed();
	}
};

BOOL
CDBCreateCommand::FInit( SCODE * psc )
{
	SCODE sc = S_OK;

	auto_com_ptr<IDBInitialize>	pDBInit;
	auto_com_ptr<IDBCreateSession> pDBCS;

	// Get provider "MSIDXS"
	//
	sc = CoCreateInstance(CLSID_MSIDXS, NULL, CLSCTX_INPROC_SERVER,
				IID_IDBInitialize, (void **)&pDBInit);

	if (FAILED(sc))
    {
		DebugTrace ("Failed to initialized provider MSIDXS \n");
		goto ret;
	}

	//	Initialize the provider
	//
	sc = pDBInit->Initialize();
	if (FAILED(sc))
	{
		DebugTrace ("IDBInitialize::Initialize failed\n");
		goto ret;
	}

	//	Get IDBCreateSession
	//
	sc = pDBInit->QueryInterface(IID_IDBCreateSession, (void**) &pDBCS);
	if (FAILED(sc))
	{
		DebugTrace("QI for IDBCreateSession failed\n");
		goto ret;
	}

	//	Create a Session object
	//
	sc = pDBCS->CreateSession(NULL, IID_IDBCreateCommand,
							  (IUnknown**) m_pDBCreateCommand.load());
	if (FAILED(sc))
	{
		DebugTrace("pDBCS->CreateSession failed\n");
		goto ret;
	}

ret:
	*psc = sc;
	return SUCCEEDED(sc);
}

SCODE
CDBCreateCommand::CreateCommand( ICommandText ** ppCommandText )
{
	SCODE sc = S_OK;


	if ( !FInitOnFirstUse( &sc ) )
	{
		DebugTrace( "CDBCreateCommand::CreateCommand() - DwInitRef() failed (0x%08lX)\n", sc );
		goto ret;
	}

	Assert( Instance().m_pDBCreateCommand );

	sc = Instance().m_pDBCreateCommand->CreateCommand (NULL, IID_ICommandText,
					(IUnknown**) ppCommandText);

ret:
	return sc;
}

//	ReleaseDBCreateCommandObject()
//
//	Called from FSTerminate to free the DBCreateCommand object before quit
//
VOID
ReleaseDBCreateCommandObject()
{
	CDBCreateCommand::Release();
}

//	Search specifics ----------------------------------------------------------
//
BOOL IsLegalVarChar(WCHAR wch)
{
	return iswalnum(wch)
		|| (L'.' == wch)
		|| (L':' == wch)
		|| (L'-' == wch)
		|| (L'_' == wch)
		|| (L'/' == wch)
		|| (L'*' == wch);		//	* included to support 'select *'
}

//
//	FTranslateScope
//		detect whether a given URI or a path is under the
//	davfs virutal directory
//
//		pmu			  [in] 	pointer to IMethUtil object
//		pwszURIOrPath [in]	URI or the physical path, non-NULL terminated
//		cchPath	 	  [in] 	the number of chars of the path
//		ppwszPath	  [in] 	receive the pointer to the translated path
//
BOOL
FTranslateScope (LPMETHUTIL pmu,
	LPCWSTR pwszURI,
	ULONG cchURI,
	auto_heap_ptr<WCHAR>& pwszPath)
{
	SCODE sc = S_OK;

	CStackBuffer<WCHAR,MAX_PATH> pwszTerminatedURI;
	CStackBuffer<WCHAR,MAX_PATH> pwszURINormalized;
	UINT cchURINormalized;
	UINT cch;

	//	We need to make a copy of '\0' terminated URI
	//
	if (NULL == pwszTerminatedURI.resize(CbSizeWsz(cchURI)))
	{
		sc = E_OUTOFMEMORY;
		DebugTrace("FTranslatedScope() - Error while allocating memory 0x%08lX\n", sc);
		return FALSE;
	}
	memcpy(pwszTerminatedURI.get(), pwszURI, cchURI * sizeof(WCHAR));
	pwszTerminatedURI[cchURI] = L'\0';

	//	We need to unescape the scope URI before translate
	//
	cchURINormalized = pwszURINormalized.celems();
	sc = ScNormalizeUrl (pwszTerminatedURI.get(),
						 &cchURINormalized,
						 pwszURINormalized.get(),
						 NULL);
	if (S_FALSE == sc)
	{
		if (NULL == pwszURINormalized.resize(cchURINormalized * sizeof(WCHAR)))
		{
			sc = E_OUTOFMEMORY;
			DebugTrace("FTranslatedScope() - Error while allocating memory 0x%08lX\n", sc);
			return FALSE;
		}

		sc = ScNormalizeUrl (pwszTerminatedURI.get(),
							 &cchURINormalized,
							 pwszURINormalized.get(),
							 NULL);

		//	Since we've given ScNormalizeUrl() the space it asked for,
		//	we should never get S_FALSE again.  Assert this!
		//
		Assert(S_FALSE != sc);
	}
	if (FAILED (sc))
	{
		DebugTrace("FTranslatedScope() - ScNormalizeUrl() failed 0x%08lX\n", sc);
		return FALSE;
	}

	//	Do the translation and check the validation
	//
	//	At most we should go through the processing below twice, as the byte
	//	count required is an out param.
	//
	cch = MAX_PATH;
	do {

		pwszPath.realloc(cch * sizeof(WCHAR));
		sc = pmu->ScStoragePathFromUrl (pwszURINormalized.get(), pwszPath, &cch);

	} while (sc == S_FALSE);
	if (FAILED (sc))
	{
		DebugTrace ("FTranslateScope() - IMethUtil::ScStoragePathFromUrl() failed to translate scope URI 0x%08lX\n", sc);
		return FALSE;
	}

	//$	SECURITY:
	//
	//	Check to see if the scope is really a short filename.
	//
	sc = ScCheckIfShortFileName (pwszPath, pmu->HitUser());
	if (FAILED (sc))
	{
		DebugTrace ("FTranslateScope() - ScCheckIfShortFileName() failed to scope, is short filename 0x%08lX\n", sc);
		return FALSE;
	}

	//$	SECURITY:
	//
	//	Check to see if the destination is really the default
	//	data stream via alternate file access.
	//
	sc = ScCheckForAltFileStream (pwszPath);
	if (FAILED (sc))
	{
		DebugTrace ("FTranslateScope() - ScCheckForAltFileStream() failed to scope, is short filename 0x%08lX\n", sc);
		return FALSE;
	}

	return TRUE;
}

//
//	ScSetPropertyName
//
//		execute SET PROPERTYNAME command on the passed in property
//	so that Index Server will be aware of this prop
//
SCODE
ScSetPropertyName(ICommandText * pCommandText, LPWSTR pwszName)
{
	CStackBuffer<WCHAR,MAX_FULLY_QUALIFIED_LENGTH> pwszSet;
	auto_com_ptr<IRowset> pRowset;
	SCODE	sc = S_OK;
	int cchNeeded;
	int cchStored;

	Assert(pCommandText != NULL);
	Assert(pwszName != NULL);
	if ((NULL == pCommandText) || (NULL == pwszName))
	{
		sc = E_POINTER;
		goto ret;
	}

	// cchNeeded is the length of the final formatted string, including the
	// terminating null
	//
	cchNeeded = CchConstString(gsc_wszSetPropertyName) + wcslen(pwszName) * 2 + 1;

	if (NULL == pwszSet.resize(cchNeeded * sizeof(WCHAR)))
	{
		sc = E_OUTOFMEMORY;
		goto ret;
	}

	//	generate the SET PROPERTYNAME command
	//
	cchStored = _snwprintf(pwszSet.get(), cchNeeded, gsc_wszSetPropertyName, pwszName, pwszName);

	// _snwprintf returns the number of chars stored, not including the terminating null.
	// It returns a negative value if the buffer was too short to store the formatted string
	// plus the terminating null.
	// So, a non-negative result means that the string plus the terminating null was stored.
	//
	// We check even more strictly here - we always expect our up-front length calculation
	// to be exact.
	//
	Assert(cchStored == cchNeeded - 1);
	if (cchStored != cchNeeded - 1)
	{
		sc = E_FAIL;
		goto ret;
	}

	//	set the command text
	//
	sc = pCommandText->SetCommandText(DBGUID_DEFAULT, pwszSet.get());
	if (FAILED(sc))
	{
		DebugTrace ("failed to set command text %ws\n", pwszSet.get());
		goto ret;
	}

	//	do the actual set
	//
	sc = pCommandText->Execute(NULL, IID_IRowset, 0, 0, (IUnknown**) &pRowset);
	if (FAILED(sc))
	{
		DebugTrace ("failed to execute %ws\n", pwszSet.get());
		goto ret;
	}
	Assert (DB_S_NORESULT == sc);
	Assert (!pRowset);

ret:
	return (sc == DB_S_NORESULT) ? S_OK : sc;
}

void
AddChildVrPaths (IMethUtil* pmu,
				 LPCWSTR pwszUrl,
				 ChainedStringBuffer<WCHAR>& sb,
				 CVRList& vrl,
				 CWsziList& lst)
{
	CVRList::iterator it;
	ChainedStringBuffer<WCHAR> sbLocal;

	//	See if there are child vroots to process as well.  We don't
	//	have a path at this time for scoping, so we can pass NULL and
	//	duplicates will get removed when we sort/unique.
	//
	if (S_OK == pmu->ScFindChildVRoots (pwszUrl, sbLocal, vrl))
	{
		for (it = vrl.begin(); it != vrl.end(); it++)
		{
			auto_ref_ptr<CVRoot> cvr;
			if (pmu->FGetChildVRoot (it->m_pwsz, cvr))
			{
				LPCWSTR pwszPath;
				UINT cch;

				//	Add it to the list
				//
				cch = cvr->CchGetVRPath (&pwszPath);
				lst.push_back(CRCWszi(sb.Append (CbSizeWsz(cch), pwszPath)));
			}
		}
		lst.sort();
		lst.unique();
	}
}

//	Tripoli prop names
//
static const WCHAR gsc_Tripoli_wszFilename[] 	= L"filename";
static const WCHAR gsc_Tripoli_wszSize[] 		= L"size";
static const WCHAR gsc_Tripoli_wszCreate[] 		= L"create";
static const WCHAR gsc_Tripoli_wszWrite[]		= L"write";
static const WCHAR gsc_Tripoli_wszAttrib[]		= L"attrib";

//	ScMapReservedPropInWhereClause
//
//	Helper function to map DAV reserved props to
//
SCODE
ScMapReservedPropInWhereClause (LPWSTR pwszName, UINT * pirp)
{
	UINT	irp;
	SCODE	sc = S_OK;

	Assert (pirp);

	//	We only care those properties not stored in propertybag
	//	RESERVED_GET is just for this purpose
	//
	if (CFSProp::FReservedProperty (pwszName, CFSProp::RESERVED_GET, &irp))
	{
		//	Here's our mapping table
		//
		//	DAV Prop				Tripoli prop
		//
		//	DAV:getcontentlength	size
		//	DAV:displayname			filename
		//	DAV:creationdate		create
		//	DAV:lastmodified		write
		//	DAV:ishidden			attrib
		//	DAV:iscollection		attrib
		//	DAV:resourcetype			<no mapping>
		//	DAV:getetag					<no mapping>
		//	DAV:lockdiscovery			<no mapping>
		//	DAV:supportedlock			<no mapping>

		//	Now that we are to overwrite dav reserved prop name with
		//	the Tripoli prop name in place, the buffer must have enough
		//	space
		//	Assert this fact that all the six reserved we will ever map
		//	satisfy this requirement
		//
		Assert ((wcslen(sc_rp[iana_rp_content_length].pwsz)	>= wcslen (gsc_Tripoli_wszSize)) &&
				(wcslen(sc_rp[iana_rp_creation_date].pwsz) 	>= wcslen (gsc_Tripoli_wszCreate)) &&
				(wcslen(sc_rp[iana_rp_displayname].pwsz) 	>= wcslen (gsc_Tripoli_wszFilename)) &&
				(wcslen(sc_rp[iana_rp_last_modified].pwsz) 	>= wcslen (gsc_Tripoli_wszWrite)) &&
				(wcslen(sc_rp[iana_rp_ishidden].pwsz) 		>= wcslen (gsc_Tripoli_wszAttrib)) &&
				(wcslen(sc_rp[iana_rp_iscollection].pwsz) 	>= wcslen (gsc_Tripoli_wszAttrib)));

		switch  (irp)
		{
			case iana_rp_content_length:
				wcscpy (pwszName, gsc_Tripoli_wszSize);
				break;

			case iana_rp_creation_date:
				wcscpy (pwszName, gsc_Tripoli_wszCreate);
				break;

			case iana_rp_displayname:
				wcscpy (pwszName, gsc_Tripoli_wszFilename);
				break;

			case iana_rp_last_modified:
				wcscpy (pwszName, gsc_Tripoli_wszWrite);
				break;

			case iana_rp_ishidden:
			case iana_rp_iscollection:
				wcscpy (pwszName, gsc_Tripoli_wszAttrib);
				break;

			case iana_rp_etag:
			case iana_rp_resourcetype:
			case iana_rp_lockdiscovery:
			case iana_rp_supportedlock:
				//	Among these four props, we data type of resourcetype is
				//	a XML node, no way to express that in SQL.
				//	And the rest three, we don't have a Tripoli mapping for them
				//
				// 	DB_E_ERRORSINCOMMAND will be mapped to 400 Bad Request
				//
				sc = DB_E_ERRORSINCOMMAND;
				goto ret;

			default:
				//	Catch the bad boy
				//
				AssertSz (FALSE, "Unexpected reserved props");
				break;
		}

		*pirp = irp;
	}

ret:
	return sc;
}

const WCHAR  gsc_wszStar[] = L"*";
const WCHAR	 gsc_wszAll[] = L"all";
const WCHAR	 gsc_wszDistinct[] = L"distinct";

//	FSSearch::ScSetSQL
//
//		Translate a SQL query, basically is to just replace the alias with the
//		corresponding namespace.
//
SCODE
CFSSearch::ScSetSQL (CParseNmspcCache * pnsc, LPCWSTR pwszSQL)
{
	BOOL fPropAdded = FALSE;
	BOOL fStarUsed = FALSE;
	BOOL fQuoted = FALSE;
	CStackBuffer<WCHAR,128> pwszUrlT;
	LPCWSTR pwsz;
	LPCWSTR pwszNameBegin;
	LPCWSTR pwszWordBegin;
	SCODE sc = S_OK;
	UINT cLen;

	typedef enum {

		SQL_NO_STATE,
		SQL_SELECT,
		SQL_FROM,
		SQL_WHERE,
		SQL_MORE

	} SQL_STATE;
	SQL_STATE state = SQL_NO_STATE;

	//	Create the command text object
	//
	sc = CDBCreateCommand::CreateCommand (m_pCommandText.load());
	if (FAILED(sc))
		goto ret;

	//	Parse out the SQL
	//
	pwsz = const_cast<LPWSTR>(pwszSQL);
	Assert (pwsz);

	while (*pwsz)
	{
		//	Filter out white spaces
		//
		while (*pwsz && iswspace(*pwsz))
			pwsz++;

		//	check to see if we reach the end of the string
		//
		if (!(*pwsz))
			break;

		//	remember the starting position
		//
		pwszWordBegin = pwsz;
		if (IsLegalVarChar(*pwsz))
		{
			CStackBuffer<WCHAR> pwszName;

			pwszNameBegin = pwsz;
			cLen = 0;

			//	look for a variable
			//
			if (fQuoted)
			{
				// Pick up the propname as a whole
				//
				while (*pwsz && (*pwsz != L'"'))
					pwsz++;
			}
			else
			{
				while (*pwsz && IsLegalVarChar(*pwsz))
					pwsz++;
			}

			//	Translate the name here
			//
			cLen = static_cast<UINT>(pwsz - pwszNameBegin);
			if (NULL == pwszName.resize(CbSizeWsz(cLen)))
			{
				sc = E_OUTOFMEMORY;
				goto ret;
			}
			wcsncpy (pwszName.get(), pwszNameBegin, cLen);
			pwszName[cLen] = 0;

			switch (state)
			{
				case SQL_NO_STATE:

					if (!_wcsnicmp (pwszWordBegin, gc_wszSelect, pwsz-pwszWordBegin))
						state = SQL_SELECT;

					break;

				case SQL_SELECT:

					if (!_wcsnicmp (pwszWordBegin, gc_wszFrom, pwsz-pwszWordBegin))
					{
						//	Empty select statement is an error
						//
						if (!fPropAdded && !fStarUsed)
						{
							sc = E_INVALIDARG;
							goto ret;
						}

						//	We've finished the SELECT statement.
						//	Note that all that we need is 'SELECT path '.
						//	We take care of all the rest ourselves, so restruct
						//	the SELECT path here before we continue
						//
						m_sbSQL.Reset();
						m_sbSQL.Append(gsc_wszSelectPath);

						state = SQL_FROM;
						break;
					}

					//	Add to our list of properties to retrieve
					//
					if (!wcscmp(pwszName.get(), gsc_wszStar))
					{
						sc = m_cfc.ScGetAllProps (NULL);
						if (FAILED(sc))
							goto ret;

						fStarUsed = TRUE;
					}
					else
					{
						//	Following Monarch Stage 1.
						//
						if (!fQuoted)
						{
							if (!_wcsicmp(pwszName.get(), gsc_wszAll))
								break;
							if (!_wcsicmp(pwszName.get(), gsc_wszDistinct))
							{
								//	Monarch does not allow distinct
								//
								sc = E_INVALIDARG;
								goto ret;
							}
						}

						//	Normal props
						//
						sc = m_cfc.ScAddProp (NULL, pwszName.get(), FALSE);
						if (FAILED(sc))
							goto ret;
						fPropAdded = TRUE;
					}

					break;

				case SQL_FROM:
				{
					BOOL fScopeExist = FALSE;
					CWsziList lst;
					CWsziList::iterator itPath;
					LPCWSTR pwszScopePath = m_pmu->LpwszPathTranslated();
					LPCWSTR pwszUrl = m_pmu->LpwszRequestUrl();
					BOOL fShallow = FALSE;

					//	Monarch Syntax:
					//	FROM { SCOPE( [ 'Scope_Arguments' ] ) | View_Name }
					//	Scope_Arguments =
					//		' [ Traversal_Type ] ( "Path" [ , "Path", ...]
					//	Path can be URI or physical path

					//	We verify every path should must be under our
					//	virtual directory and we allow only one path
					//	Note, if we ever want to accept multiple path, then
					//	we need some extra code, mainly another for loop.
					//	For now, talk with Joels, keep it this way.
					//
					if (!_wcsnicmp (pwszWordBegin, gc_wszScope, pwsz-pwszWordBegin))
					{
						StringBuffer<WCHAR> sbNameBuilder;
						LPCWSTR pwszStart = pwsz;
						ULONG cLevel = 0;
						BOOL fInSingleQuote = FALSE;

						sbNameBuilder.Append(static_cast<UINT>(sizeof(WCHAR) * wcslen(pwszName.get())), pwszName.get());

						//	Parse the scope arguments list
						//
						while (*pwsz)
						{
							if (L'(' == *pwsz)
							{
								cLevel++;
							}
							else if (L')' == *pwsz)
							{
								if (NULL == (--cLevel))
									break;
							}
							else if (L'\'' == *pwsz)
							{
								//	If this is a closing single quote, flip the
								//	switch.
								//
								if (fInSingleQuote)
								{
									//	It's an error if no scope inside ''
									//
									if (!fScopeExist)
									{
										sc = E_INVALIDARG;
										goto ret;
									}

									//	The next single quote will be an
									//	opening single quote
									//
									fInSingleQuote = FALSE;
								}
								else
								{
									//	We need to find out the traversal type
									//	as we rely on Monarch to check syntax, so it
									//	is OK for us to assume the syntax is correct,
									//	Anything we missed can be caught later in
									//	Monarch.
									//
									pwsz++;
									while (*pwsz && iswspace(*pwsz))
										pwsz++;

									//	Check if it is "Shallow Traversal", again
									//	we check only the word "shallow", any syntax
									//	error can be caught later in Monarch.
									//
									if (!_wcsnicmp(pwsz, gsc_wszShallow, gsc_cchShallow))
										fShallow = TRUE;

									//	The next single quote will be a closing
									//	sinlge quote
									//
									fInSingleQuote = TRUE;

									//	we've point to the next char, so loop back
									//	immediately
									//
									continue;
								}
							}
							else if (L'"' == *pwsz)
							{
								auto_heap_ptr<WCHAR> pwszPath;
								LPCWSTR pwszPathStart;

								//	Copy over bytes up to '"'.
								//
								pwsz++;

								sbNameBuilder.Append(static_cast<UINT>(sizeof(WCHAR) * (pwsz -pwszStart)), pwszStart);

								//	Look for the start of scope
								//
								while ((*pwsz) && iswspace(*pwsz))
									pwsz++;
								pwszPathStart = pwsz;

								//	We really only allow a single
								//	path in our scope.  Fail others
								//	with bad request
								//
								if (fScopeExist)
								{
									sc = E_INVALIDARG;
									goto ret;
								}

								//	look for the end of the path
								//
								while (*(pwsz) && *pwsz != L'"')
									pwsz++;
								if (!(*pwsz))
									break;

								fScopeExist = TRUE;

								//	Translate the scope:
								//		- forbid the physical path
								//		- translate the URI and reject
								//		  any URI beyond our VR
								//
								if (pwsz > pwszPathStart)
								{
									UINT cchUrlT;

									if (!FTranslateScope (m_pmu,
														  pwszPathStart,
														  static_cast<UINT>(pwsz-pwszPathStart),
														  pwszPath))
									{
										//	return an error that would be mapped to
										//	HSC_FORBIDDEN
										//
										sc = STG_E_DISKISWRITEPROTECTED;
										Assert (HSC_FORBIDDEN == HscFromHresult(sc));
										goto ret;
									}

									//	use the translated physical path
									//
									pwszScopePath = AppendChainedSz(m_csb, pwszPath);

									lst.push_back(CRCWszi(pwszScopePath));

									//	Allocate space for the URL and keep it hanging on
									//
									cchUrlT = static_cast<UINT>(pwsz - pwszPathStart);
									if (NULL == pwszUrlT.resize(CbSizeWsz(cchUrlT)))
									{
										sc = E_OUTOFMEMORY;
										goto ret;
									}
									memcpy(pwszUrlT.get(), pwszPathStart, cchUrlT * sizeof(WCHAR));
									pwszUrlT[cchUrlT] = L'\0';
									pwszUrl = pwszUrlT.get();
								}
								else
								{
									//	we've got a "". Insert the request URI
									//
									Assert (pwsz == pwszPathStart);
									Assert ((*pwsz == L'"') && (*(pwsz-1) == L'"'));
									lst.push_back(CRCWszi(pwszScopePath));
								}
								pwszStart = pwsz;
							}
							pwsz++;
						}

						//	Syntax check
						//
						if (fInSingleQuote || !(*pwsz))
						{
							// unbalanced ', " or )
							//
							sc = E_INVALIDARG;
							goto ret;
						}

						//	include ')'
						//
						pwsz++;

						if (!fScopeExist)
						{
							static WCHAR gs_wszScopeBegin[] = L"('\"";
							sbNameBuilder.Append(sizeof(WCHAR) * CchConstString(gs_wszScopeBegin), gs_wszScopeBegin);

							//	Pickup the request uri
							//
							lst.push_back(CRCWszi(pwszScopePath));
						}

						//	Search Child Vroots only if we are doing
						//	a non-shallow traversal.
						//$ REVIEW(zyang).
						//	Here we drop the subvroot in the shallow search
						//	This is not quite right, Assume we are searching /fs
						//	and it has a sub vroot /fs/sub. we expect to see
						//	/fs/sub in the search result. but we lost it.
						//	However, if we include this sub vroot in the search
						//	path, it's even worse, as a shallow traversal on
						//	/fs/sub will give us all /fs/sub/*, which is another
						//	level deep.
						//	There's no easy fix for this, unless, we keep a list
						//	of first level vroots and emit ourselves. That's
						//	of extra code, and don't know how much it would buy us.
						//	As a compromise for now, we simply drop the sub vroot
						//	in shallow search.
						//
						if (!fShallow)
						{
							AddChildVrPaths (m_pmu,
											 pwszUrl,
											 m_csb,
											 m_vrl,
											 lst);
						}

						//	Construct the scope
						//
						Assert (!lst.empty());
						itPath = lst.begin();
						
						sbNameBuilder.Append(static_cast<UINT>(sizeof(WCHAR) * wcslen(itPath->m_pwsz)), itPath->m_pwsz);

						for (itPath++; itPath != lst.end(); itPath++)
						{
							static WCHAR gs_wszScopeMiddle[] = L"\", \"";

							sbNameBuilder.Append(sizeof(WCHAR) * CchConstString(gs_wszScopeMiddle), gs_wszScopeMiddle);
							sbNameBuilder.Append(static_cast<UINT>(sizeof(WCHAR) * wcslen(itPath->m_pwsz)), itPath->m_pwsz);
						}
						static WCHAR gs_wszScopeEnd[] = L"\"')";

						sbNameBuilder.Append(sizeof(WCHAR) * CchConstString(gs_wszScopeEnd), gs_wszScopeEnd);

						//	Get the size of constructed string without NULL 
						// termination
						//
						cLen = sbNameBuilder.CchSize();

						//	NULL terminate the string
						//
						sbNameBuilder.FTerminate();

						//	Replace with the new string
						//
						if (NULL == pwszName.resize(CbSizeWsz(cLen)))
						{
							sc = E_OUTOFMEMORY;
							goto ret;
						}
						lstrcpyW (pwszName.get(), sbNameBuilder.PContents());

						Assert(cLen == wcslen(pwszName.get()));
						Assert(cLen+1 <= pwszName.celems());

						//	After the Scope is processed, the only thing that
						//	we want to do is the custom properties. so we don't
						//	care if the rest is a WHERE or an ORDER BY or else
						//
						state = SQL_MORE;
					}

					break;
				}
				case SQL_WHERE:
				case SQL_MORE:

					//	It's not easy for us to tell which prop is custom prop
					//	and thus need to be set to the command object.
					//	without a real parse tree, we can't tell names from
					//	operators and literals.
					//
					//	a good guess is that if the prop is quoted by double
					//	quote, we can treat it as a custom prop. Note, this
					//	imposes the requirment that all props, including
					//	namespaceless props must be quoted. all unquoted
					//	are either Tripoli props or operators/literals which
					//	we can just copy over. this makes our life easier
					//

					//	We need to map some DAV reserved properties to tripoli
					//	props when they appear in the where clause
					//
					if (fQuoted)
					{
						UINT	irp = sc_crp_set_reserved; //max value

						sc = ScMapReservedPropInWhereClause (pwszName.get(), &irp);
						if (FAILED(sc))
							goto ret;

						if (irp != sc_crp_set_reserved)
							cLen = static_cast<UINT>(wcslen(pwszName.get()));
						else
						{
							//	SET PROPERTYNAME on custom props
							//
							sc = ScSetPropertyName (m_pCommandText, pwszName.get());
							if (FAILED(sc))
							{
								DebugTrace ("Failed to set custom prop %ws to Monarch\n",
											pwszName.get());
								goto ret;
							}
						}
					}

					break;

				default:
					break;
			}

			// Append the name
			//
			m_sbSQL.Append(sizeof(WCHAR)*cLen, pwszName.get());
			if (L'"' != *pwsz)
			{
				// add seperator
				//
				m_sbSQL.Append(L" ");
			}
		}
		else if (L'\'' == *pwsz)
		{
			//	copy literals over

			pwsz++;
			while (*pwsz && (L'\'' != *pwsz))
				pwsz++;

			if (!*pwsz)
			{
				DebugTrace("unbalanced single quote\n");
				sc = E_INVALIDARG;
				goto ret;
			}
			else
			{
				Assert(L'\'' == *pwsz);

				// copy over
				//
				pwsz++;
				m_sbSQL.Append( static_cast<UINT>(pwsz-pwszWordBegin) * sizeof(WCHAR),
								pwszWordBegin);
			}

			// add seperator
			//
			m_sbSQL.Append(L" ");
		}
		else if (L'"' == *pwsz)
		{
			// toggle the flag
			//
			fQuoted = !fQuoted;
			pwsz++;
			m_sbSQL.Append(L"\"");

			//	Apeend seperator after closing '"'
			//
			if (!fQuoted)
				m_sbSQL.Append(L" ");
		}
		else
		{
			//	some char we don't have interest on, just copy over
			//
			while (*pwsz && !IsLegalVarChar(*pwsz)
					&& (L'\'' != *pwsz) && (L'"' != *pwsz))
				pwsz++;

			// Append the name
			//
			m_sbSQL.Append(	static_cast<UINT>(pwsz-pwszWordBegin) * sizeof(WCHAR),
							pwszWordBegin);

		}

	}

	//	Close the string
	//
	m_sbSQL.Append(sizeof(WCHAR), L"");
	SearchTrace ("Search: translated query is: \"%ls\"\n", PwszSQL());

ret:

	return sc;
}

static void
SafeWcsCopy (LPWSTR pwszDst, LPCWSTR pwszSrc)
{
	//	Make sure we are not doing any evil copies...
	//
	Assert (pwszDst && pwszSrc && (pwszDst <= pwszSrc));
	if (pwszDst == pwszSrc)
		return;

	while (*pwszSrc)
		*pwszDst++ = *pwszSrc++;

	*pwszDst = L'\0';

	return;
}

SCODE
CFSSearch::ScEmitRow (CXMLEmitter& emitter)
{
	auto_ref_ptr<IMDData> pMDData;
	CResourceInfo cri;
	CStackBuffer<WCHAR,128> pwszExt;
	CVRList::iterator it;
	LPWSTR pwszFile;
	SCODE sc = S_OK;
	UINT cch;

	//	Get the filename
	//
	pwszFile = reinterpret_cast<LPWSTR>(m_pData.get());
	sc = cri.ScGetResourceInfo (pwszFile);
	if (FAILED (sc))
		goto ret;

	//	FSPropTarget sort of needs the URI of the target.
	//	What is really important here, is the file extension.
	//	We can fake it out by just pretending the file
	//	is the URL name.
	//
	cch = pwszExt.celems();
	sc = m_pmu->ScUrlFromStoragePath(pwszFile, pwszExt.get(), &cch);
	if (S_FALSE == sc)
	{
		if (NULL == pwszExt.resize(cch * sizeof(WCHAR)))
		{
			sc = E_OUTOFMEMORY;
			goto ret;
		}
		sc = m_pmu->ScUrlFromStoragePath(pwszFile, pwszExt.get(), &cch);
	}
	if (S_OK != sc)
	{
		Assert (S_FALSE != sc);
		goto ret;
	}

	//	Strip the prefix
	//
	SafeWcsCopy(pwszExt.get(), PwszUrlStrippedOfPrefix(pwszExt.get()));

	//	Emit the row (ie. call ScFindFileProps()) if-and-only-if
	//	We know this url is to be indexed.  In particular, can we
	//	sniff the metabase, and is the index bit set.
	//$178052: We also need to respect the dirbrowsing bit
	//
	SearchTrace ("Search: found row at '%S'\n", pwszExt.get());
	if (SUCCEEDED (m_pmu->HrMDGetData (pwszExt.get(), pMDData.load())))
	{
		if (pMDData->FIsIndexed() &&
		    (pMDData->DwDirBrowsing() & MD_DIRBROW_ENABLED))
		{
			//	Find the properties
			//
			sc = ScFindFileProps (m_pmu,
								  m_cfc,
								  emitter,
								  pwszExt.get(),
								  pwszFile,
								  NULL,
								  cri,
								  TRUE /*fEmbedErrorsInResponse*/);
			if (FAILED (sc))
				goto ret;
		}
		else
			SearchTrace ("Search: found '%S' is not indexed\n", pwszExt);

		pMDData.clear();
	}

	//	See if any of the other translation contexts apply to this
	//	path as well.
	//
	for (it = m_vrl.begin(); it != m_vrl.end(); it++)
	{
		auto_ref_ptr<CVRoot> cvr;

		if (!m_pmu->FGetChildVRoot (it->m_pwsz, cvr))
			continue;

		cch = pwszExt.celems();
		sc = ScUrlFromSpannedStoragePath (pwszFile,
										  *(cvr.get()),
										  pwszExt.get(),
										  &cch);
		if (S_FALSE == sc)
		{
			if (NULL == pwszExt.resize(cch * sizeof(WCHAR)))
			{
				sc = E_OUTOFMEMORY;
				goto ret;
			}
			sc = ScUrlFromSpannedStoragePath (pwszFile,
											  *(cvr.get()),
											  pwszExt.get(),
											  &cch);
		}
		if (S_OK == sc)
		{
			SafeWcsCopy (pwszExt.get(), PwszUrlStrippedOfPrefix(pwszExt.get()));
			SearchTrace ("Search: found row at '%S'\n", pwszExt.get());

			//	Again, we have to see if this resource is even allowed
			//	to be indexed...
			//
			LPCWSTR pwszMbPathVRoot;
			CStackBuffer<WCHAR,128> pwszMbPathChild;
			UINT cchPrefix;
			UINT cchUrl = static_cast<UINT>(wcslen(pwszExt.get()));

			//	Map the URI to its equivalent metabase path, and make sure
			//	the URL is stripped before we call into the MDPath processing
			//
			cchPrefix = cvr->CchPrefixOfMetabasePath (&pwszMbPathVRoot);
			if (NULL == pwszMbPathChild.resize(CbSizeWsz(cchPrefix + cchUrl)))
			{
				sc = E_OUTOFMEMORY;
				goto ret;
			}
			memcpy (pwszMbPathChild.get(), pwszMbPathVRoot, cchPrefix * sizeof(WCHAR));
			memcpy (pwszMbPathChild.get() + cchPrefix, pwszExt.get(), (cchUrl + 1) * sizeof(WCHAR));

			//	As above, Emit the row (ie. call ScFindFileProps())
			//	if-and-only-if We know this url is to be indexed.
			//	In particular, can we sniff the metabase, and is
			//	the index bit set.
			//
			if (SUCCEEDED(m_pmu->HrMDGetData (pwszMbPathChild.get(),
											  pwszMbPathVRoot,
											  pMDData.load())))
			{
				if (pMDData->FIsIndexed())
				{
					//	... and get the properties
					//
					sc = ScFindFileProps (m_pmu,
										  m_cfc,
										  emitter,
										  pwszExt.get(),
										  pwszFile,
										  cvr.get(),
										  cri,
										  TRUE /*fEmbedErrorsInResponse*/);

					if (FAILED (sc))
						goto ret;
				}
				else
					SearchTrace ("Search: found '%S' is not indexed\n", pwszExt);
			}
		}
	}

	sc = S_OK;

ret:

	return sc;
}

SCODE
CFSSearch::ScCreateAccessor()
{
	SCODE sc = S_OK;
	DBORDINAL cCols = 0;

	auto_com_ptr<IColumnsInfo> pColInfo;

	// QI to the IColumnsInfo interface, with which we can get the column information
	//
	sc = m_prs->QueryInterface (IID_IColumnsInfo,
								reinterpret_cast<VOID**>(pColInfo.load()));
	if (FAILED(sc))
		goto ret;

	// get all the column information
	//
	sc = pColInfo->GetColumnInfo (&cCols, &m_rgInfo, &m_pwszBuf);
	if (FAILED(sc))
		goto ret;

	//	'Path' is the only property in our SELECT list
	//
	Assert (cCols == 1);

	m_rgBindings = (DBBINDING *) g_heap.Alloc (sizeof (DBBINDING));

	// set the m_rgBindings according to the information we know
	//
	m_rgBindings->dwPart = DBPART_VALUE | DBPART_STATUS;

	// ignored fields
	//
	m_rgBindings->eParamIO = DBPARAMIO_NOTPARAM;

	//	set column ordinal
	//
	m_rgBindings->iOrdinal = m_rgInfo->iOrdinal;

	//	set the type
	//
	m_rgBindings->wType = m_rgInfo->wType;

	//	we own the memory
	//
	m_rgBindings->dwMemOwner = DBMEMOWNER_CLIENTOWNED;

	//	set the maximum length of the column
	//
	Assert (m_rgInfo->wType == DBTYPE_WSTR);
	m_rgBindings->cbMaxLen = m_rgInfo->ulColumnSize * sizeof(WCHAR);

	//	offset to the value in the consumer's buffer
	//
	m_rgBindings->obValue = 0;

	//	offset to the status
	//
	m_rgBindings->obStatus = Align8(m_rgBindings->cbMaxLen);

	// we'll see how to deal with objects as we know more
	//
	m_rgBindings->pObject = NULL;

	// not used field
	//
	m_rgBindings->pTypeInfo = NULL;
	m_rgBindings->pBindExt = NULL;
	m_rgBindings->dwFlags = 0;

	// Create the accessor
	//
	sc = m_pAcc->CreateAccessor (DBACCESSOR_ROWDATA,	// row accessor
								 1,						// number of bindings
								 m_rgBindings,			// array of bindings
								 0,						// cbRowSize, not used
								 &m_hAcc,				// HACCESSOR *
								 NULL);					// binding status
	if (FAILED(sc))
		goto ret;

ret:
	return sc;
}

SCODE
CFSSearch::ScMakeQuery()
{
	SCODE sc = S_OK;

	//	Make sure we have a query to play with
	//	m_pCommandText is initialized in ScSetSQL, if m_pCommantText
	//	is NULL, most likely is becuase ScSetSQL is not called
	//
	if (!PwszSQL() || !m_pCommandText.get())
	{
		sc = E_DAV_NO_QUERY;
		goto ret;
	}

	// Set the command text
	//
	sc = m_pCommandText->SetCommandText (DBGUID_DEFAULT, PwszSQL());
	if (FAILED (sc))
	{
		DebugTrace("pCommandText->SetCommandText failed\n");
		goto ret;
	}

	//	Excute the query
	//
	sc = m_pCommandText->Execute (NULL,
								  IID_IRowset,
								  0,
								  0,
								  reinterpret_cast<IUnknown**>(m_prs.load()));
	if (FAILED(sc) || (!m_prs))
	{
		DebugTrace("pCommandText->Execute failed\n");

		//	Munge a few, select error codes
		//	Map these errors locally, as they may only come back from Execute
		//
		switch (sc)
		{
			case QUERY_E_FAILED:			//$REVIEW: Is this a bad request?
			case QUERY_E_INVALIDQUERY:
			case QUERY_E_INVALIDRESTRICTION:
			case QUERY_E_INVALIDSORT:
			case QUERY_E_INVALIDCATEGORIZE:
			case QUERY_E_ALLNOISE:
			case QUERY_E_TOOCOMPLEX:
			case QUERY_E_TIMEDOUT:			//$REVIEW: Is this a bad request?
			case QUERY_E_DUPLICATE_OUTPUT_COLUMN:
			case QUERY_E_INVALID_OUTPUT_COLUMN:
			case QUERY_E_INVALID_DIRECTORY:
			case QUERY_E_DIR_ON_REMOVABLE_DRIVE:
			case QUERY_S_NO_QUERY:
				sc = E_INVALIDARG;			// All query errors will be mapped to 400
				break;
		}

		goto ret;
	}

ret:
	return sc;
}

//	DAV-Search Implementation -------------------------------------------------
//
class CSearchRequest :
	public CMTRefCounted,
	private IAsyncIStreamObserver
{
	//
	//	Reference to the CMethUtil
	//
	auto_ref_ptr<CMethUtil> m_pmu;

	//	Contexts
	//
	auto_ref_ptr<CNFSearch> m_pnfs;
	CFSSearch m_csc;

	//	Request body as an IStream.  This stream is async -- it can
	//	return E_PENDING from Read() calls.
	//
	auto_ref_ptr<IStream> m_pstmRequest;

	//	The XML parser used to parse the request body using
	//	the node factory above.
	//
	auto_ref_ptr<IXMLParser> m_pxprs;

	//	IAsyncIStreamObserver
	//
	VOID AsyncIOComplete();

	//	State functions
	//
	VOID ParseBody();
	VOID DoSearch();
	VOID SendResponse( SCODE sc );

	//	NOT IMPLEMENTED
	//
	CSearchRequest (const CSearchRequest&);
	CSearchRequest& operator= (const CSearchRequest&);

public:
	//	CREATORS
	//
	CSearchRequest(LPMETHUTIL pmu) :
		m_pmu(pmu),
		m_csc(pmu)
	{
	}

	//	MANIPULATORS
	//
	VOID Execute();
};

VOID
CSearchRequest::Execute()
{
	CResourceInfo cri;
	LPCWSTR pwsz;
	LPCWSTR pwszPath = m_pmu->LpwszPathTranslated();
	SCODE sc = S_OK;

	//
	//	First off, tell the pmu that we want to defer the response.
	//	Even if we send it synchronously (i.e. due to an error in
	//	this function), we still want to use the same mechanism that
	//	we would use for async.
	//
	m_pmu->DeferResponse();

	//	Do ISAPI application and IIS access bits checking
	//
	sc = m_pmu->ScIISCheck (m_pmu->LpwszRequestUrl(), MD_ACCESS_READ);
	if (FAILED(sc))
	{
		//	Either the request has been forwarded, or some bad error occurred.
		//	In either case, quit here and map the error!
		//
		SendResponse(sc);
		return;
	}

	//  Look to see the Content-length - required for this operation
	//  to continue.
	//
	//
	if (NULL == m_pmu->LpwszGetRequestHeader (gc_szContent_Length, FALSE))
	{
		pwsz = m_pmu->LpwszGetRequestHeader (gc_szTransfer_Encoding, FALSE);
		if (!pwsz || _wcsicmp (pwsz, gc_wszChunked))
		{
			DavTrace ("Dav: PUT: missing content-length in request\n");
			SendResponse(E_DAV_MISSING_LENGTH);
			return;
		}
	}

	//	Search must have a content-type header and value must be text/xml
	//
	sc = ScIsContentTypeXML (m_pmu.get());
	if (FAILED(sc))
	{
		DebugTrace ("Dav: PROPPATCH fails without specifying a text/xml contenttype\n");
		SendResponse(sc);
		return;
	}

	//  Check to see if the resource exists
	//
	sc = cri.ScGetResourceInfo (pwszPath);
	if (FAILED (sc))
	{
		SendResponse(sc);
		return;
	}

	//	Ensure the URI and resource match
	//
	(void) ScCheckForLocationCorrectness (m_pmu.get(), cri, NO_REDIRECT);

	//	Check state headers here.
	//
	sc = HrCheckStateHeaders (m_pmu.get(), pwszPath, FALSE);
	if (FAILED (sc))
	{
		DebugTrace ("DavFS: If-State checking failed.\n");
		SendResponse(sc);
		return;
	}

	//	BIG NOTE ABOUT LOCKING
	//
	//	The mechanism we actually use to do the search doesn't
	//	have any way to access our locked files.  So we are punting
	//	on supporting locktokens passed into SEARCH.
	//	So, for now, on DAVFS, don't bother to check locktokens.
	//	(This isn't a big problem because currently DAVFS can only
	//	lock single files, not whole directories, AND becuase currently
	//	our only locktype is WRITE, so our locks won't prevent the
	//	content-indexer from READING the file!)
	//
	//	NOTE: We still have to consider if-state-match headers,
	//	but that is done elsewhere (above -- HrCheckStateHeaders).
	//

	//	Instantiate the XML parser
	//
	m_pnfs.take_ownership(new CNFSearch(m_csc));
	m_pstmRequest.take_ownership(m_pmu->GetRequestBodyIStream(*this));

	sc = ScNewXMLParser( m_pnfs.get(),
						 m_pstmRequest.get(),
						 m_pxprs.load() );

	if (FAILED(sc))
	{
		DebugTrace( "CSearchRequest::Execute() - ScNewXMLParser() failed (0x%08lX)\n", sc );
		SendResponse(sc);
		return;
	}

	//	Start parsing it into the context
	//
	ParseBody();
}

VOID
CSearchRequest::ParseBody()
{
	Assert( m_pxprs.get() );
	Assert( m_pnfs.get() );
	Assert( m_pstmRequest.get() );

	//
	//	Add a ref for the following async operation.
	//	Use auto_ref_ptr rather than AddRef() for exception safety.
	//
	auto_ref_ptr<CSearchRequest> pRef(this);

	SCODE sc = ScParseXML (m_pxprs.get(), m_pnfs.get());

	if ( SUCCEEDED(sc) )
	{
		Assert( S_OK == sc || S_FALSE == sc );

		DoSearch();
	}
	else if ( E_PENDING == sc )
	{
		//
		//	The operation is pending -- AsyncIOComplete() will take ownership
		//	ownership of the reference when it is called.
		//
		pRef.relinquish();
	}
	else
	{
		DebugTrace( "CSearchRequest::ParseBody() - ScParseXML() failed (0x%08lX)\n", sc );
		SendResponse(sc);
	}
}

VOID
CSearchRequest::AsyncIOComplete()
{
	//	Take ownership of the reference added for the async operation.
	//
	auto_ref_ptr<CSearchRequest> pRef;
	pRef.take_ownership(this);

	ParseBody();
}

VOID
CSearchRequest::DoSearch()
{
	SCODE sc;

	//	Do the search
	//
	sc = m_csc.ScMakeQuery();
	if (FAILED (sc))
	{
		SendResponse(sc);
		return;
	}

	//	All header must be emitted before chunked XML emitting starts
	//
	m_pmu->SetResponseHeader (gc_szContent_Type, gc_szText_XML);

	//	Set the response code and go
	//
	m_pmu->SetResponseCode( HscFromHresult(W_DAV_PARTIAL_SUCCESS),
							NULL,
							0,
							CSEFromHresult(W_DAV_PARTIAL_SUCCESS) );

	//	Emit the results
	//
	auto_ref_ptr<CXMLEmitter> pmsr;
	auto_ref_ptr<CXMLBody>	  pxb;

	//	Get the XML body
	//
	pxb.take_ownership (new CXMLBody (m_pmu.get()));

	pmsr.take_ownership (new CXMLEmitter(pxb.get(), m_csc.PPreloadNamespaces()));
	sc = pmsr->ScSetRoot (gc_wszMultiResponse);
	if (FAILED (sc))
	{
		SendResponse(sc);
		return;
	}

	sc = m_csc.ScEmitResults (*pmsr);
	if (FAILED (sc))
	{
		SendResponse(sc);
		return;
	}

	//	Done with the reponse
	//
	pmsr->Done();
	m_pmu->SendCompleteResponse();
}

VOID
CSearchRequest::SendResponse( SCODE sc )
{
	//
	//	Set the response code and go
	//
	m_pmu->SetResponseCode( HscFromHresult(sc), NULL, 0, CSEFromHresult(sc) );
	m_pmu->SendCompleteResponse();
}

void
DAVSearch (LPMETHUTIL pmu)
{
	auto_ref_ptr<CSearchRequest> pRequest(new CSearchRequest(pmu));

	pRequest->Execute();
}

//	class CSearchRowsetContext ------------------------------------------------
//
enum { CROW_GROUP = 16 };

//	Mapping from DBSTATUS to HSC.
//
ULONG
CSearchRowsetContext::HscFromDBStatus (ULONG ulStatus)
{
	switch (ulStatus)
	{
		case DBSTATUS_S_OK:
		case DBSTATUS_S_ISNULL:
		case DBSTATUS_S_TRUNCATED:
		case DBSTATUS_S_DEFAULT:
			return HSC_OK;

		case DBSTATUS_E_BADACCESSOR:
			return HSC_BAD_REQUEST;

		case DBSTATUS_E_UNAVAILABLE:
			return HSC_NOT_FOUND;

		case DBSTATUS_E_PERMISSIONDENIED:
			return HSC_UNAUTHORIZED;

		case DBSTATUS_E_DATAOVERFLOW:
			return HSC_INSUFFICIENT_SPACE;

		case DBSTATUS_E_CANTCONVERTVALUE:
		case DBSTATUS_E_SIGNMISMATCH:
		case DBSTATUS_E_CANTCREATE:
		case DBSTATUS_E_INTEGRITYVIOLATION:
		case DBSTATUS_E_SCHEMAVIOLATION:
		case DBSTATUS_E_BADSTATUS:

			//	What error shoud these match to?
			//	return 400 temporarily.
			//
			return HSC_BAD_REQUEST;

		default:

			TrapSz ("New DBStutus value");
			return HSC_NOT_FOUND;
	}
}

SCODE
CSearchRowsetContext::ScEmitResults (CXMLEmitter& emitter)
{
	SCODE sc = S_OK;
	BOOL fReadAll = FALSE;

	//	Allocate enough space for the data buffer
	//
	if (!m_pData)
	{
		ULONG_PTR cbSize;

		//	Get the IAccessor interface, used later to release the accessor
		//
		sc = m_prs->QueryInterface (IID_IAccessor, (LPVOID *)&m_pAcc);
		if (FAILED(sc))
			goto ret;

		// Create the accessor
		//
		sc = ScCreateAccessor();
		if (FAILED(sc))
			goto ret;

		//	Calculate the size of the buffer needed by each row.
		//	(including a ULONG for status)
		//
		cbSize = Align8(m_rgBindings->cbMaxLen) + Align8(sizeof(ULONG));

		//	allocate enough memory for the data buffer on stack
		//
		m_pData = (BYTE *)g_heap.Alloc(cbSize);
	}

	while (!fReadAll)
	{
		sc = m_prs->GetNextRows(NULL, 0, CROW_GROUP, (DBCOUNTITEM *) &m_cHRow, &m_rgHRow);
		if (sc)
		{
			if (sc == DB_S_ENDOFROWSET)
			{
				// we have read all the rows, we'll be done after this loop
				//
				fReadAll = TRUE;
			}
			else
				goto ret;
		}

		if (!m_cHRow)
		{
			// no rows available, this happens when no rows in the rowset at all
			//
			break;
		}

		AssertSz (m_rgHRow, "something really bad happened");

		// For each row we have now, get data and convert it to XML and dump to the stream.
		//
		for (ULONG ihrow = 0; ihrow < m_cHRow; ihrow++)
		{
			AssertSz(m_rgHRow[ihrow], "returned row handle is NULL");

			//	get the data of one row.
			//
			sc = m_prs->GetData(m_rgHRow[ihrow], m_hAcc, m_pData);
			if (FAILED(sc) && (sc != DB_E_ERRORSOCCURRED))
				goto ret;

			//	Emit the row
			//
			sc = ScEmitRow (emitter);
			if (FAILED(sc))
				goto ret;
		}

		// Don't forget to clean up.
		//
		sc = m_prs->ReleaseRows (m_cHRow, m_rgHRow, NULL, NULL, NULL);
		if (FAILED(sc))
			goto ret;

		// free the memory retured from OLEDB provider with IMalloc::Free
		//
		CoTaskMemFree (m_rgHRow);
		m_rgHRow = NULL;
		m_cHRow = 0;
	}

ret:

	CleanUp();
	return sc;
}

VOID
CSearchRowsetContext::CleanUp()
{
	//	Try out best to clean up

	//	clean the array of HRows
	//
	if (m_rgHRow)
	{
		m_prs->ReleaseRows (m_cHRow, m_rgHRow, NULL, NULL, NULL);
		CoTaskMemFree (m_rgHRow);
	}

	//	Release the accessor handle
	//
	if (m_hAcc != DB_INVALID_HACCESSOR)
	{
		m_pAcc->ReleaseAccessor (m_hAcc, NULL);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\httpext\sof.cpp ===
/*
 *	S O F  . C P P
 *
 *	IStream on file implementation.
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davfs.h"
#include "_sof.h"

HRESULT STDMETHODCALLTYPE
StmOnFile::Read (void __RPC_FAR * pb,
				 ULONG cb,
				 ULONG __RPC_FAR * pcb)
{
	SCODE sc = S_OK;
	ULONG cbr;

	//	Read from the file
	//
	if (!ReadFile (m_hf, pb, cb, &cbr, NULL))
	{
		DebugTrace ("StmOnFile: failed to read (%ld)\n", GetLastError());
		sc = HRESULT_FROM_WIN32 (GetLastError());
	}
	if (pcb)
		*pcb = cbr;

	return sc;
}

HRESULT STDMETHODCALLTYPE
StmOnFile::Write (const void __RPC_FAR * pb,
				  ULONG cb,
				  ULONG __RPC_FAR * pcb)
{
	SCODE sc = S_OK;
	ULONG cbw;

	//	Write to the file
	//
	if (!WriteFile (m_hf, pb, cb, &cbw, NULL))
	{
		DebugTrace ("StmOnFile: failed to write (%ld)\n", GetLastError());
		sc = HRESULT_FROM_WIN32 (GetLastError());
	}
	if (pcb)
		*pcb = cbw;

	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\httpext\shlkmgr.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	S H L K M G R . C P P
//
//		HTTP 1.1/DAV 1.0 request handling via ISAPI
//
//  This file contains the CSharedLockMgr class that handles the shared
//  memory mapped file implementation of the lock cache.  It is used by
//  HTTPEXT only.
//
//	Copyright 2000 Microsoft Corporation, All Rights Reserved
//
#include <_davfs.h>
 #include <xlock.h>
#include "_shlkmgr.h" 

HRESULT HrGetUsableHandle(HANDLE hFile, DWORD dwProcessID, HANDLE * phFile)
{
	HRESULT hr = S_OK;
	HANDLE hFileT;

	Assert(phFile);

	*phFile = NULL;

	{
		safe_revert_self s;
		auto_handle<HANDLE> a_hProcT;

		a_hProcT = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwProcessID);
		if (NULL == a_hProcT.get())
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			goto ret;
		}

		if (!DuplicateHandle(a_hProcT.get(),
						   hFile,
						   GetCurrentProcess(),
						   &hFileT,
						   0,
						   FALSE,
						   DUPLICATE_SAME_ACCESS))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			goto ret;
		}
	}
	
	*phFile = hFileT;
	
ret:
	
	return hr;
}

// ========================================================================
//	CLASS CSharedLockMgr (Public Functions - inherited from ILockCache)
// =========================================================================

//
//  Print out all lock token information for locks of this type on this resource.
//  If the fEmitXML is false, just return if there are any locks.
//
BOOL CSharedLockMgr::FGetLockOnError( IMethUtil * pmu,
							 LPCWSTR pwszResource,
							 DWORD dwLockType,
							 BOOL	fEmitXML,
						     CXMLEmitter * pemitter,
						     CXNode * pxnParent)
{
	BOOL fRet = FALSE;

	HRESULT hr = S_OK;
	CEmitterNode enLockDiscovery;
	DWORD dw = 0;
	DWORD dwLocksFound = 0;
	auto_co_task_mem<SNewLockData> a_pNewLockDatas;
	auto_co_task_mem<LPWSTR> a_ppwszLockTokens;
	
	{
		safe_revert sr(pmu->HitUser());
		
		hr = m_pFileHandleCache->HrGetAllLockDataForName(pwszResource,
													   dwLockType,
													   &dwLocksFound,
													   a_pNewLockDatas.load(),
													   a_ppwszLockTokens.load());
		if (FAILED(hr))
		{
			goto ret;
		}
	}

	if (fEmitXML)
	{
		for (dw = 0; dw < dwLocksFound; dw++)
		{
			//	Construct the 'DAV:lockdiscovery' node
			//
			hr = enLockDiscovery.ScConstructNode (*pemitter, pxnParent, gc_wszLockDiscovery);
			if (FAILED(hr))
			{
				goto ret;
			}

			//	Add the 'DAV:activelock' property for this plock.
			//$HACK:ROSEBUD_TIMEOUT_HACK
			//  For the bug where rosebud waits until the last second
			//  before issueing the refresh. Need to filter out this check with
			//  the user agent string. The hack is to increase the timeout
			//	by 30 seconds and return the actual timeout. So we
			//	need the ecb/pmu to findout the user agent. At this point
			//	we do not know. So we pass NULL. If we remove this
			//	hack ever (I doubt if we can ever do that), then
			//	change the interface of ScLockDiscoveryFromSNewLockData.
			//    
			hr = ScLockDiscoveryFromSNewLockData(pmu,
												     *pemitter,
												     enLockDiscovery,
												     a_pNewLockDatas.get() + dw,
												     *(a_ppwszLockTokens.get() + dw));  

			//$HACK:END ROSEBUD_TIMEOUT_HACK
			//
			if (FAILED(hr))
			{
				goto ret;
			}

			hr = enLockDiscovery.ScDone();
			if (FAILED(hr))
			{
				goto ret;
			}
		}
	}


	fRet = (0 != dwLocksFound);

ret:

	if (dwLocksFound)
	{
		for (dw = 0; dw < dwLocksFound; dw++)
		{
			SNewLockData * pnld = a_pNewLockDatas.get() + dw;
			CoTaskMemFree(pnld->m_pwszResourceString);
			CoTaskMemFree(pnld->m_pwszOwnerComment);
			CoTaskMemFree(*(a_ppwszLockTokens.get() + dw));
		}
	}

	return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\httpext\traces.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	TRACES.CPP
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include "_davfs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\httpext\traces.h ===
#ifndef _TRACES_H_
#define _TRACES_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	TRACES.H
//
//	.INI file tagged traces
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

DEFINE_TRACE(Put);
DEFINE_TRACE(HttpExtDbgHeaders);
DEFINE_TRACE(MoveCopyDelete);
DEFINE_TRACE(Url);
DEFINE_TRACE(FsLock);

#define PutTrace				DO_TRACE(Put)
#define HttpExtDbgHeadersTrace	DO_TRACE(HttpExtDbgHeaders)
#define MCDTrace				DO_TRACE(MoveCopyDelete)
#define UrlTrace				DO_TRACE(Url)
#define FsLockTrace				DO_TRACE(FsLock)

inline void InitTraces()
{
	INIT_TRACE(Put);
	INIT_TRACE(HttpExtDbgHeaders);
	INIT_TRACE(MoveCopyDelete);
	INIT_TRACE(Url);
	INIT_TRACE(FsLock);
}

#endif // !defined(_TRACES_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\httpext\statcode.s ===
STRINGTABLE
BEGIN
	HSC_CONTINUE					L"Continue\0"
	HSC_SWITCH_PROTOCOL				L"Switching Protocols\0"
	HSC_PROCESSING					L"Processing Request\0"

	HSC_OK							L"OK\0"
	HSC_CREATED						L"Created\0"
	HSC_ACCEPTED					L"Accepted\0"
	HSC_NON_AUTHORITATIVE_INFO		L"Non-authoritative Information\0"
	HSC_NO_CONTENT					L"No Content\0"
	HSC_RESET_CONTENT				L"Reset Content\0"
	HSC_PARTIAL_CONTENT				L"Partial Content\0"
	HSC_MULTI_STATUS				L"Multi-Status\0"

	HSC_SUBSCRIBED					L"Subscribed\0"
	HSC_SUBSCRIPTION_FAILED			L"Subscription Failed\0"
	HSC_NOTIFICATION_FAILED				L"Notification Failed\0"
	HSC_NOTIFICATION_ACKNOWLEDGED			L"Notification Acknowledged\0"
	HSC_EVENTS_FOLLOW				L"Events Follow\0"
	HSC_NO_EVENTS_PENDING				L"No Events Pending\0"

	HSC_MULTIPLE_CHOICE				L"Multiple Choices\0"
	HSC_MOVED_PERMANENTLY			L"Moved Permanently\0"
	HSC_MOVED_TEMPORARILY			L"Moved Temporarily\0"
	HSC_SEE_OTHER					L"See Other\0"
	HSC_NOT_MODIFIED				L"Not Modified\0"
	HSC_USE_PROXY					L"Use Proxy\0"

	HSC_BAD_REQUEST					L"Bad Request\0"
	HSC_UNAUTHORIZED				L"Unauthorized\0"
	HSC_PAYMENT_REQUIRED			L"Payment Required\0"
	HSC_FORBIDDEN					L"Forbidden\0"
	HSC_NOT_FOUND					L"Resource Not Found\0"
	HSC_METHOD_NOT_ALLOWED			L"Method Not Allowed\0"
	HSC_NOT_ACCEPTABLE				L"Not Acceptable\0"
	HSC_PROXY_AUTH_REQUIRED			L"Proxy Authorization Required\0"
	HSC_REQUEST_TIMEOUT				L"Request Timed Out\0"
	HSC_CONFLICT					L"Conflict\0"
	HSC_GONE						L"Resource No Longer Exists -- Remove Any Links\0"
	HSC_LENGTH_REQUIRED				L"Length Required\0"
	HSC_PRECONDITION_FAILED			L"Precondition Failed\0"
	HSC_REQUEST_ENTITY_TOO_LARGE	L"Request Entity Too Large\0"
	HSC_REQUEST_URI_TOO_LARGE		L"Request-URI Too Large\0"
	HSC_UNSUPPORTED_MEDIA_TYPE		L"Unsupported Media Type\0"
	HSC_RANGE_NOT_SATISFIABLE		L"Requested Range Not Satisfiable\0"
	HSC_EXPECTATION_FAILED			L"Expectation Failed\0"

	HSC_UNPROCESSABLE				L"Unprocessable Entity\0"
	HSC_LOCKED						L"Locked\0"
	HSC_METHOD_FAILURE				L"Method Failure\0"
	HSC_INCOMPLETE_DATA				L"Incomplete Data\0"
	HSC_INSUFFICIENT_SPACE			L"Insufficient Space to Store Resource\0"

	HSC_INTERNAL_SERVER_ERROR		L"Internal Server Error\0"
	HSC_NOT_IMPLEMENTED				L"Not Implemented\0"
	HSC_BAD_GATEWAY					L"Bad Gateway\0"
	HSC_SERVICE_UNAVAILABLE			L"Service Unavailable\0"
	HSC_GATEWAY_TIMEOUT				L"Gateway Timeout\0"
	HSC_VERSION_NOT_SUPPORTED		L"HTTP Version Not Supported\0"
	HSC_NO_PARTIAL_UPDATE			L"Partial Update Not Implemented\0"

	HSC_SERVER_TOO_BUSY			L"Server Too Busy\0"

;	non-HTTP errors that need localization ------------------------------------

	IDS_WRITTEN						L"<body><h1>%hs was written successfully</h1></body>\r\n\0"
	IDS_CREATED						L"<body><h1>%hs was created successfully</h1></body>\r\n\0"

	IDS_FAIL_CREATE_DIR				L"Failed to create resource\0"

	IDS_FAIL_PROP_NO_EXIST			L"The requested property does not exist\0"
	IDS_FAIL_PROP_NO_ACCSS			L"The user cannot modify the requested property\0"

	IDS_BR_LOCKTOKEN_NOT_ALLOWED	L"Lock-Token not allowed\0"
	IDS_BR_LOCKTOKEN_SYNTAX			L"Syntax error in Lock-Token header\0"
	IDS_BR_LOCKTOKEN_MISSING		L"Missing Lock-Token header\0"
	IDS_BR_LOCKTOKEN_INVALID		L"Invalid Lock-Token encountered\0"
	IDS_BR_LOCKINFO_SYNTAX			L"Invalid or missing Lock type information\0"
	IDS_BR_TIMEOUT_SYNTAX			L"Syntax error in Time-Out header\0"
	IDS_BR_LOCK_BODY_TYPE			L"Invalid Content-Type on Lock request\0"
	IDS_BR_MULTIPLE_LOCKTOKENS		L"Multiple locktokens invalid on this request\0"
	IDS_BR_NO_COLL_LOCK				L"LOCKing a collection is not allowed\0"
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\httpext\_davfs.cpp ===
/*
 *	_ D A V F S . C
 *
 *	Precompiled header sources
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davfs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\httpext\voltype.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	VOLTYPE.CPP
//
//		Implements volume type checking.  Results are cached on a per volume
//		basis to improve performance -- the call to GetVolumeInformationW()
//		is around 100KCycles and never changes for a given volume without a
//		reboot.
//

#include "_davfs.h"

#define cbDriveSpec	(sizeof(L"c:\\"))
#define cchDriveSpec (CElems(L"c:\\") - 1)

//	========================================================================
//
//	CLASS CVolumeTypeCache
//
//	A cache of volume types per volume.
//
class CVolumeTypeCache : public Singleton<CVolumeTypeCache>
{
	//
	//	Friend declarations required by Singleton template
	//
	friend class Singleton<CVolumeTypeCache>;

	//
	//	Hint: the max expected number of volumes.  It is ok for the
	//	number of volumes to be greater than this number -- it's only a hint.
	//	The number should be prime -- it gets used for the hash table
	//	size.
	//
	enum { NUM_VOLUMES_MAX_HINT = 17 };

	//
	//	Cache of mappings from volumes to volume types
	//	and a reader/writer lock to proctet it.
	//
	CCache<CRCWsz, VOLTYPE> m_cache;
	CMRWLock m_mrwCache;

	//
	//	String buffer for cached strings
	//
	ChainedStringBuffer<WCHAR> m_sb;

	//	NOT IMPLEMENTED
	//
	CVolumeTypeCache& operator=( const CVolumeTypeCache& );
	CVolumeTypeCache( const CVolumeTypeCache& );

	//	CREATORS
	//
	//	Allow sufficient space initially for the expected
	//	max number of volumes.
	//
	CVolumeTypeCache() :
		m_cache(NUM_VOLUMES_MAX_HINT),
		m_sb(NUM_VOLUMES_MAX_HINT * sizeof(WCHAR) * cbDriveSpec)
	{
	}

public:
	//	CREATORS
	//
	//	Instance creating/destroying routines provided
	//	by the Singleton template.
	//
	using Singleton<CVolumeTypeCache>::CreateInstance;
	using Singleton<CVolumeTypeCache>::DestroyInstance;
	using Singleton<CVolumeTypeCache>::Instance;
	BOOL FInitialize();

	//	ACCESSORS
	//
	VOLTYPE VolumeType(LPCWSTR pwszPath, HANDLE htokUser);
};

BOOL
CVolumeTypeCache::FInitialize()
{
	//
	//	Init the cache
	//
	if ( !m_cache.FInit() )
		return FALSE;

	//
	//	Init its reader/writer lock
	//
	if ( !m_mrwCache.FInitialize() )
		return FALSE;

	return TRUE;
}

VOLTYPE
CVolumeTypeCache::VolumeType(LPCWSTR pwszPath, HANDLE htokUser)
{
	//	By default assume the volume type is NOT NTFS.  That way if we
	//	cannot determine the volume type, we at least don't end up saying
	//	that we support more functionality than might actually be there.
	//
	VOLTYPE voltype = VOLTYPE_NOT_NTFS;
	CStackBuffer<WCHAR> pwszVol;

	//	If the path now refers to a UNC, then treat it as such...
	//
	if ((*pwszPath == L'\\') && (*(pwszPath + 1) == L'\\'))
	{
		LPCWSTR pwsz;
		UINT cch;

		//	If there is not enough info here, then we don't know
		//	what the volume type is.
		//
		pwsz = wcschr (pwszPath + 2, L'\\');
		if (!pwsz)
			goto ret;

		//	Ok, we have picked off the server portion of the UNC, now
		//	we should check for the share name.  If is terminated with
		//	a slash, then we are set.  Otherwise, we need to be smart
		//	about it...
		//
		pwsz = wcschr (pwsz + 1, L'\\');
		if (!pwsz)
		{
			//	OK, we need to be smart.
			//
			//	The call to GetVolumeInformationW() requires that the
			//	path passed in be terminated with an extra slash in the
			//	case where it refers to a UNC.
			//
			cch = static_cast<UINT>(wcslen(pwszPath));
			if (NULL == pwszVol.resize((cch + 2) * sizeof(WCHAR)))
				goto ret;

			wcsncpy (pwszVol.get(), pwszPath, cch);
			pwszVol[cch] = L'\\';
			pwszVol[cch + 1] = 0;
		}
		else
		{
			cch = static_cast<UINT>(++pwsz - pwszPath);
			if (NULL == pwszVol.resize((cch + 1) * sizeof(WCHAR)))
				goto ret;

			wcsncpy (pwszVol.get(), pwszPath, cch);
			pwszVol[cch] = 0;
		}
	}
	else
	{
		if (NULL == pwszVol.resize(cbDriveSpec))
			goto ret;

		wcsncpy(pwszVol.get(), pwszPath, cchDriveSpec);
		pwszVol[cchDriveSpec] = 0;
	}

	//	Try the cache for volume info.
	//
	{
		CSynchronizedReadBlock sb(m_mrwCache);
		if (m_cache.FFetch(CRCWsz(pwszVol.get()), &voltype))
			goto ret;
	}

	//	Didn't find it in the cache, so do the expensive lookup.
	//
	{
		WCHAR wszLabel[20];
		DWORD dwSerial;
		DWORD cchNameMax;
		DWORD dwFlags;
		WCHAR wszFormat[20];

		//	Temporarily revert to local system before calling GetVolumeInformationW()
		//	so that we have adequate permission to query the volume type, even if the
		//	admin has secured the root of the drive.
		//
		safe_revert sr(htokUser);

		if (GetVolumeInformationW (pwszVol.get(),
								   wszLabel,
								   CElems(wszLabel),
								   &dwSerial,
								   &cchNameMax,
								   &dwFlags,
								   wszFormat,
								   CElems(wszFormat)))
		{
			//	If it is "NTFS", then I guess we have to believe it.
			//
			voltype = ((!_wcsicmp (wszFormat, L"NTFS"))
					    ? VOLTYPE_NTFS
						: VOLTYPE_NOT_NTFS);
		}
		else
		{
			//	If we couldn't get volume information for whatever reason then
			//	return the default volume type (VOLTYPE_NOT_NTFS), but DO NOT
			//	cache it.  If the failure is temporary, we want to force the
			//	call to GetVolumeInformationW() again the next time this volume
			//	is hit.  The call to GetVolumeInformationW() should theoretically
			//	not fail repeatedly given that we are passing in valid parameters,
			//	and that we have sufficient permission to query the device, etc.
			//
			goto ret;
		}
	}

	//	Add the volume to the cache.  Ignore errors -- we already have
	//	a volume type to return to the caller.  Also note that we use
	//	FSet() rather than FAdd().  The reason is that since we never
	//	expire items from this cache, duplicates would stick around forever.
	//	The number of potential dups is only as high as the number of
	//	simultaneous threads that hit a volume for the first time, but
	//	that could still be pretty high (on the order of a couple hundred).
	//
	{
		CSynchronizedWriteBlock sb(m_mrwCache);

		if (!m_cache.Lookup(CRCWsz(pwszVol.get())))
			(VOID) m_cache.FAdd(CRCWsz(m_sb.AppendWithNull(pwszVol.get())), voltype);
	}

ret:
	return voltype;
}

VOLTYPE
VolumeType(LPCWSTR pwszPath, HANDLE htokUser)
{
	return CVolumeTypeCache::Instance().VolumeType(pwszPath, htokUser);
}

BOOL
FInitVolumeTypeCache()
{
	return CVolumeTypeCache::CreateInstance().FInitialize();
}

VOID
DeinitVolumeTypeCache()
{
	CVolumeTypeCache::DestroyInstance();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\httpext\urlmap.cpp ===
//	========================================================================
//	H T T P E X T \ U R L M A P . C P P
//
//	Copyright Microsoft Corporation 1997-1999.
//
//	This file contains all necessary routines to deal with IIS URLs
//	properly.  This file is part of HTTPEXT, as in HTTPEXT, we need to
//	handle URLs the same way IIS would.
//
//	========================================================================

#include <_davfs.h>
#include <langtocpid.h>

//$	REVIEW: BUG:NT5:196814
//
//	<string.hxx> is an IIS header file that exposes the CanonURL() api.
//	It is exported from IISRTL.DLL and we should be able to call it
//	instead of us stealing their code.
//
//$	HACK:
//
//	<string.hxx> includes <buffer.hxx> which includes <nt.h> and all of
//	its minions.  DAV has already included all of the <winnt.h> and its
//	minions.  The <nt.h> and <winnt.h> are at odds, so we are defining
//	NT_INCLUDED, _NTRTL_, _NTURTL_, DBG_ASSERT(), IntializeListHead(),
//	and RemoveEntryList() to disable those conflicts.
//
#define NT_INCLUDED
#define _NTRTL_
#define _NTURTL_
#define InitializeListHead(_p)
#define RemoveEntryList(_p)
#define DBG_ASSERT Assert
#pragma warning (disable:4390)
#include <string.hxx>
#pragma warning (default:4390)

//
//$	HACK: end
//$	REVIEW: end

//
//  Private constants.
//
enum {

	ACTION_NOTHING			= 0x00000000,
	ACTION_EMIT_CH			= 0x00010000,
	ACTION_EMIT_DOT_CH		= 0x00020000,
	ACTION_EMIT_DOT_DOT_CH	= 0x00030000,
	ACTION_BACKUP			= 0x00040000,
	ACTION_MASK				= 0xFFFF0000

};

//	States and State translations ---------------------------------------------
//
const UINT gc_rguStateTable[16] = {

	//	State 0
	//
	0 ,             // other
	0 ,             // "."
	4 ,             // EOS
	1 ,             // "\"

	//	State 1
	//
	0 ,              // other
	2 ,             // "."
	4 ,             // EOS
	1 ,             // "\"

	//	State 2
	//
	0 ,             // other
	3 ,             // "."
	4 ,             // EOS
	1 ,             // "\"

	//	State 3
	//
	0 ,             // other
	0 ,             // "."
	4 ,             // EOS
	1               // "\"
};

const UINT gc_rguActionTable[16] = {

	// State 0
	//
	ACTION_EMIT_CH,             // other
	ACTION_EMIT_CH,             // "."
	ACTION_EMIT_CH,             // EOS
	ACTION_EMIT_CH,             // "\"

	//	State 1
	//
	ACTION_EMIT_CH,             // other
	ACTION_NOTHING,             // "."
	ACTION_EMIT_CH,             // EOS
	ACTION_NOTHING,             // "\"

	//	State 2
	//
	ACTION_EMIT_DOT_CH,         // other
	ACTION_NOTHING,             // "."
	ACTION_EMIT_CH,             // EOS
	ACTION_NOTHING,             // "\"

	//	State 3
	//
	ACTION_EMIT_DOT_DOT_CH,     // other
	ACTION_EMIT_DOT_DOT_CH,     // "."
	ACTION_BACKUP,              // EOS
	ACTION_BACKUP               // "\"
};

//	The following table provides the index for various ISA Latin1 characters
//  in the incoming URL.
//
//	It assumes that the URL is ISO Latin1 == ASCII
//
const UINT gc_rguIndexForChar[] = {

	2,								// null char
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	// 1 thru 10
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	// 11 thru 20
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   // 21 thru 30
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   // 31 thru 40
	0, 0, 0, 0, 0, 1, 3, 0, 0, 0,   // 41 thru 50  46 = '.' 47 = '/'
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   // 51 thru 60
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   // 61 thru 70
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   // 71 thru 80
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   // 81 thru 90
	0, 3, 0, 0, 0, 0, 0, 0, 0, 0,   // 91 thru 100  92 = '\\'
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   // 101 thru 110
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   // 111 thru 120
	0, 0, 0, 0, 0, 0, 0, 0          // 121 thru 128
};

//	FIsUTF8TrailingByte -------------------------------------------------------
//
//	Function returns TRUE if the given character is UTF-8 trailing byte
//
inline BOOL FIsUTF8TrailingByte (CHAR ch)
{
	return (0x80 == (ch & 0xc0));
}

//	FIsUTF8Url ----------------------------------------------------------------
//
//	Function returns TRUE if the given string can be treated as UTF-8
//
BOOL __fastcall
FIsUTF8Url (/* [in] */ LPCSTR pszUrl)
{
	CHAR ch;

	while (0 != (ch = *pszUrl++))
	{
		//	Sniff for a lead-byte
		//
		if (ch & 0x80)
		{
			CHAR chT1;
			CHAR chT2;

			//	Pick off the trailing bytes
			//
			chT1 = *pszUrl++;
			if (chT1)
				chT2 = *pszUrl;
			else
				chT2 = 0;

			//	Handle the three byte case
			//	1110xxxx 10xxxxxx 10xxxxxx
			//
			if (((ch & 0xF0) == 0xE0) &&
				FIsUTF8TrailingByte (chT1) &&
				FIsUTF8TrailingByte (chT2))
			{
				//	We found a UTF-8 character.  Keep going.
				//
				pszUrl++;
				continue;
			}
			//	Also watch for the two byte case
			//	110xxxxx 10xxxxxx
			//
			else if (((ch & 0xE0) == 0xC0) && FIsUTF8TrailingByte (chT1))
			{
				//	We found a UTF-8 character.  Keep going.
				//
				continue;
			}
			else
			{
				//	If we had a lead-byte but no UTF trailing bytes, then
				//	this cannot be a UTF8 url.
				//
				DebugTrace ("FIsUTF8Url(): url contains UTF8 lead byte with no trailing\n");
				return FALSE;
			}
		}
	}

	//	Hey, we made it through without any non-singlebyte chars, so we can
	//	operate as if this is a UTF8 url.
	//
	DebugTrace ("FIsUTF8Url(): url contains only UTF8 characters\n");
	return TRUE;
}

//	ScCanonicalizeURL ---------------------------------------------------------
//
//	Wide version of the CanonURL() function, which lives in iisrtl.lib
//
//	PURPOSE:    Sanitizes a path by removing bogus path elements.
//
//		As expected, "/./" entries are simply removed, and
//		"/../" entries are removed along with the previous
//		path element.
//
//		To maintain compatibility with URL path semantics
//		additional transformations are required. All backward
//		slashes "\\" are converted to forward slashes. Any
//		repeated forward slashes (such as "///") are mapped to
//		single backslashes.
//
//		A state table (see the p_StateTable global at the
//		beginning of this file) is used to perform most of
//		the transformations.  The table's rows are indexed
//		by current state, and the columns are indexed by
//		the current character's "class" (either slash, dot,
//		NULL, or other).  Each entry in the table consists
//		of the new state tagged with an action to perform.
//		See the ACTION_* constants for the valid action
//		codes.
//
//  PARAMETERS:
//
//		pwszSrc		- url to canonicalize
//		pwszDest	- buffer to fill
//		pcch		- number of characters written into the buffer
//					  (which includes '\0' termination)
//
//	RETURN CODES:
//
//		S_OK.
//
//	NOTE: This function assumes that destination buffer is
//		  equal or biger than the source.
//
SCODE __fastcall
ScCanonicalizeURL( /* [in]     */ LPCWSTR pwszSrc,
				   /* [in/out] */ LPWSTR pwszDest,
				   /* [out]	   */ UINT * pcch )
{
	LPCWSTR pwszPath;
	UINT  uiCh;
	UINT  uiIndex = 0;	// State = 0

	Assert( pwszSrc );
	Assert( pwszDest );
	Assert( pcch );

	//	Zero out return
	//
	*pcch = 0;

	//	Remember start of the buffer into which we will canonicalize
	//
	pwszPath = pwszDest;

	//  Loop until we enter state 4 (the final, accepting state).
	//
	do {

		//  Grab the next character from the path and compute its
		//  next state.  While we're at it, map any forward
		//  slashes to backward slashes.
		//
		uiIndex = gc_rguStateTable[uiIndex] * 4; // 4 = # states
		uiCh = *pwszSrc++;

		uiIndex += ((uiCh >= 0x80) ? 0 : gc_rguIndexForChar[uiCh]);

		//  Perform the action associated with the state.
		//
		switch( gc_rguActionTable[uiIndex] )
		{
			case ACTION_EMIT_DOT_DOT_CH :

				*pwszDest++ = L'.';

				/* fall through */

			case ACTION_EMIT_DOT_CH :

				*pwszDest++ = L'.';

				/* fall through */

			case ACTION_EMIT_CH :

				*pwszDest++ = static_cast<WCHAR>(uiCh);

				/* fall through */

			case ACTION_NOTHING :

				break;

			case ACTION_BACKUP :
				if ( (pwszDest > (pwszPath + 1) ) && (*pwszPath == L'/'))
				{
					pwszDest--;
					Assert( *pwszDest == L'/' );

					*pwszDest = L'\0';
					pwszDest = wcsrchr( pwszPath, L'/') + 1;
				}

				*pwszDest = L'\0';
				break;

			default :

				TrapSz("Invalid action code in state table!");
				uiIndex = 2;    // move to invalid state
				Assert( 4 == gc_rguStateTable[uiIndex] );
				*pwszDest++ = L'\0';
				break;
		}

	} while( gc_rguStateTable[uiIndex] != 4 );

	//	Point to terminating nul
	//
	if (ACTION_EMIT_CH == gc_rguActionTable[uiIndex])
	{
		pwszDest--;
	}

	Assert((L'\0' == *pwszDest) && (pwszDest >= pwszPath));

	//	Return number of characters written
	//
	*pcch = static_cast<UINT>(pwszDest - pwszPath + 1);

	return S_OK;
}

SCODE __fastcall
ScCanonicalizePrefixedURL( /* [in]     */ LPCWSTR pwszSrc,
						   /* [in]	   */ LPWSTR pwszDest,
						   /* [out]	   */ UINT * pcch )
{
	SCODE sc = S_OK;

	LPCWSTR pwszStripped;
	UINT cchStripped;
	UINT cch = 0;

	Assert(pwszSrc);
	Assert(pwszDest);
	Assert(pcch);

	//	Zero out return
	//
	*pcch = 0;

	pwszStripped = PwszUrlStrippedOfPrefix(pwszSrc);
	cchStripped = static_cast<UINT>(pwszStripped - pwszSrc);

	//	Copy the prefix over to the destination. I do not use
	//	memcpy here as source and destination may overlap,
	//	and in such case those functions are not recomended.
	//
	for (UINT ui = 0; ui < cchStripped; ui++)
	{
		pwszDest[ui] = pwszSrc[ui];
	}

	//	Canonicalize the remainder of te URL
	//
	sc = ScCanonicalizeURL(pwszStripped,
						   pwszDest + cchStripped,
						   &cch);
	if (S_OK != sc)
	{
		Assert(S_FALSE != sc);
		DebugTrace("ScCanonicalizePrefixedURL() - ScCanonicalizeUrl() failed 0x%08lX\n", sc);
		goto ret;
	}

	//	Return the number of characters written
	//
	*pcch = cchStripped + cch;

ret:

	return sc;
}

//	ScConvertToWide -----------------------------------------------------------
//
SCODE __fastcall
ScConvertToWide(/* [in]     */	LPCSTR	pszSource,
				/* [in/out] */  UINT *	pcchDest,
				/* [out]    */	LPWSTR	pwszDest,
				/* [in]		*/	LPCSTR	pszAcceptLang,
				/* [in]		*/	BOOL	fUrlConversion)
{
	SCODE sc = S_OK;
	CStackBuffer<CHAR, MAX_PATH> pszToConvert;
	UINT cpid = CP_UTF8;
	UINT cb;
	UINT cch;

	Assert(pszSource);
	Assert(pcchDest);
	Assert(pwszDest);

	if (fUrlConversion)
	{
		//	Allocate the space to escape URL into.
		//
		cb = static_cast<UINT>(strlen(pszSource));
		if (NULL == pszToConvert.resize(cb + 1))
		{
			sc = E_OUTOFMEMORY;
			DebugTrace("ScConvertToWide() -  Error while allocating memory 0x%08lX\n", sc);
			goto ret;
		}

		//	Unescape to the new buffer. Unescaping can only shrink the size,
		//	so we have enough buffer allocated.
		//
		HttpUriUnescape(pszSource, pszToConvert.get());

		//	Perform a quick pass over the url looking for non-UTF8 characters.
		//	Remember if we need to continue to scan for UTF8 characters.
		//
		if (!FIsUTF8Url(pszToConvert.get()))
		{
			//	... cannot do CP_UTF8, assume CP_ACP.
			//
			cpid = CP_ACP;
		}

		//	If the URL cannot be treated as UTF8 then find out the code page for it
		//
		if (CP_UTF8 != cpid)
		{
			if (pszAcceptLang)
			{
				HDRITER hdri(pszAcceptLang);
				LPCSTR psz;

				//	Let us try guessing the cpid from the language string
				//	Try all the languages in the header. We stop at the
				//	first language for which we have a cpid mapping. If
				//	none of the languages specified in the header have cpid
				//	mappings, then we will end up with the default cpid
				//	CP_ACP
				//
				for (psz = hdri.PszNext(); psz; psz = hdri.PszNext())
				{
					if (CLangToCpidCache::FFindCpid(psz, &cpid))
						break;
				}
			}
		}

		//	Swap the pointer and recalculate the size
		//
		pszSource = pszToConvert.get();
	}

	//	Find out the length of the string we will convert
	//
	cb = static_cast<UINT>(strlen(pszSource));

	//	Translate to unicode including '\0' termination
	//
	cch = MultiByteToWideChar(cpid,
							  (CP_UTF8 != cpid) ? MB_ERR_INVALID_CHARS : 0,
							  pszSource,
							  cb + 1,
							  pwszDest,
							  *pcchDest);
	if (0 == cch)
	{
		//	If buffer was not sufficient
		//
		if (ERROR_INSUFFICIENT_BUFFER == GetLastError())
		{
			//	Find out the size needed
			//
			cch = MultiByteToWideChar(cpid,
									  (CP_UTF8 != cpid) ? MB_ERR_INVALID_CHARS : 0,
									  pszSource,
									  cb + 1,
									  NULL,
									  0);
			if (0 == cch)
			{
				sc = HRESULT_FROM_WIN32(GetLastError());
				DebugTrace("ScConvertToWide() - MultiByteToWideChar() failed to fetch size 0x%08lX - CPID: %d\n", sc, cpid);
				goto ret;
			}

			//	Return the size and warning back
			//
			*pcchDest = cch;
			sc = S_FALSE;
			goto ret;
		}
		else
		{
			sc = HRESULT_FROM_WIN32(GetLastError());
			DebugTrace("ScConvertToWide() - MultiByteToWideChar() failed 0x%08lX - CPID: %d\n", sc, cpid);
			goto ret;
		}
	}

	*pcchDest = cch;

ret:

	return sc;
}


//	ScNormalizeUrl ------------------------------------------------------------
//
//	PURPOSE:	Normalization of a url.
//
//		Has two components to the operation:
//
//		1) All sequences of %xx are replaced by a single character that
//		   has a value that is equal to the hex representation of the
//		   following two characters.
//
//		2) All path modification sequences are stripped out and the url
//		   is adjusted accordingly.  The set of path modification sequences
//		   that we recognize are as follows:
//
//		"//"	reduces to "/"
//		"/./"	reduces to "/"
//		"/../"	strips off the last path segment
//
//		It is important to note that the unescaping happens first!
//
//		NOTE:  this function does NOT currently normalize the path separators
//		All '\' are NOT replaced with '/' in this function or vice versa.
//		The code is implemented such that slashes replaced due to a double
//		slash such as "//", "\\", "\/", or "/\" are defaulted to forward
//		slashes '/'
//
//		A state table (see the gc_rguStateTable global at the beginning
//		of this file) is used to perform most of the transformations.  The
//		table's rows are indexed by current state, and the columns are indexed
//		by the current character's "class" (either slash, dot, NULL, or other).
//		Each entry in the table consists of the new state tagged with an action
//		to perform.  See the ACTION_* constants for the valid action codes.//
//
//	PARAMETERS:
//
//		pwszSourceUrl		-- the URL to be normalized
//		pcchNormalizedUrl	-- the amount of characters available in buffer
//							   pointed by pwszNormalizedUrl
//		pwszNormalizedUrl	-- the place to put the normalized URL
//
//	RETURN CODES:
//
//		S_OK: Everything went well,	the URL was normalized into pwszNormalizedUrl.
//		S_FALSE: Buffer was not sufficient. Required size is in *pcchNormalizedUrl.
//		E_OUTOFMEMORY: Memory alocation failure
//		...other errors that we could get from the conversion routines
//
SCODE __fastcall
ScNormalizeUrl (
	/* [in]     */	LPCWSTR			pwszSourceUrl,
	/* [in/out] */  UINT *			pcchNormalizedUrl,
	/* [out]    */	LPWSTR			pwszNormalizedUrl,
	/* [in]		*/	LPCSTR			pszAcceptLang)
{
	SCODE sc = S_OK;
	CStackBuffer<CHAR, MAX_PATH> pszSourceUrl;
	UINT cchSourceUrl;
	UINT cbSourceUrl;

	Assert(pwszSourceUrl);
	Assert(pcchNormalizedUrl);
	Assert(pwszNormalizedUrl);

	//	We are given the wide version of the URL, so someone who
	//	converted it already should have done that correctly. So
	//	we will convert it to CP_UTF8
	//
	cchSourceUrl = static_cast<UINT>(wcslen(pwszSourceUrl));
	cbSourceUrl = cchSourceUrl * 3;
	if (NULL == pszSourceUrl.resize(cbSourceUrl + 1))
	{
		sc = E_OUTOFMEMORY;
		DebugTrace("ScNormalizeUrl() - Error while allocating memory 0x%08lX\n", sc);
		goto ret;
	}

	cbSourceUrl = WideCharToMultiByte(CP_UTF8,
									  0,
									  pwszSourceUrl,
									  cchSourceUrl + 1,
									  pszSourceUrl.get(),
									  cbSourceUrl + 1,
									  NULL,
									  NULL);
	if (0 == cbSourceUrl)
	{
		sc = HRESULT_FROM_WIN32(GetLastError());
		DebugTrace("ScNormalizeUrl() - WideCharToMultiByte() failed 0x%08lX\n", sc);
		goto ret;
	}

	sc = ScNormalizeUrl(pszSourceUrl.get(),
						pcchNormalizedUrl,
						pwszNormalizedUrl,
						pszAcceptLang);
	if (FAILED(sc))
	{
		DebugTrace("ScNormalizeUrl() - ScNormalizeUrl() failed 0x%08lX\n", sc);
		goto ret;
	}

ret:

	return sc;
}

SCODE __fastcall
ScNormalizeUrl (
	/* [in]     */	LPCSTR			pszSourceUrl,
	/* [in/out] */	UINT		  *	pcchNormalizedUrl,
	/* [out]    */	LPWSTR			pwszNormalizedUrl,
	/* [in]		*/	LPCSTR			pszAcceptLang)
{
	SCODE sc = S_OK;

	Assert(pszSourceUrl);
	Assert(pcchNormalizedUrl);
	Assert(pwszNormalizedUrl);

	//	Convert the URL to UNICODE into the given buffer.
	//	Function may return S_FALSE, so make sure we
	//	check the return code correctly - against S_OK
	//
	sc = ScConvertToWide(pszSourceUrl,
						 pcchNormalizedUrl,
						 pwszNormalizedUrl,
						 pszAcceptLang,
						 TRUE);
	if (S_OK != sc)
	{
		DebugTrace("ScNormalizeUrl() - ScConvertToWide() returned 0x%08lX\n", sc);
		goto ret;
	}

	//	Canonicalize in place, take into account that URL may be fully
	//	qualified.
	//
	sc = ScCanonicalizePrefixedURL(pwszNormalizedUrl,
								   pwszNormalizedUrl,
								   pcchNormalizedUrl);
	if (FAILED(sc))
	{
		DebugTrace("ScNormalizeUrl() - ScCanonicalizePrefixedURL() failed 0x%08lX\n", sc);
		goto ret;
	}

ret:

	return sc;
}

//	ScStoragePathFromUrl ------------------------------------------------------
//
//	PURPOSE:	Url to storage path translation.
//
SCODE __fastcall
ScStoragePathFromUrl (
	/* [in]     */ const IEcb &	ecb,
	/* [in]     */ LPCWSTR		pwszUrl,
	/* [out]    */ LPWSTR		wszStgID,
	/* [in/out] */ UINT		  *	pcch,
	/* [out]    */ CVRoot	 **	ppcvr)
{
	Assert (pwszUrl);
	Assert (wszStgID);
	Assert (pcch);

	SCODE sc = S_OK;
	HSE_UNICODE_URL_MAPEX_INFO mi;
	LPCWSTR pwszVRoot;
	UINT cchVRoot;
	UINT cch = 0;
	UINT cchUrl = 0;

#undef	ALLOW_RELATIVE_URL_TRANSLATION
#ifdef	ALLOW_RELATIVE_URL_TRANSLATION

	CStackBuffer<WCHAR,256> pwszNew;

#endif	// ALLOW_RELATIVE_URL_TRANSLATION

	//	Lets make sure this funcion is never called with a
	//	prefixed url.
	//
	sc = ScStripAndCheckHttpPrefix (ecb, &pwszUrl);
	if (FAILED (sc))
		return sc;

	//	Make sure that the url is absolute
	//
	if (L'/' != *pwszUrl)
	{

#ifdef	ALLOW_RELATIVE_URL_TRANSLATION

		//$	REVIEW:
		//
		//	This code is here should we ever decide we need
		//	to support relative url processing.
		//
		//	Construct an absolute url from the relative one
		//
		UINT cchRequestUrl = wcslen(ecb.LpwszRequestUrl());
		UINT cchUrl = static_cast<UINT>(wcslen(pwszUrl));

		if (NULL == pwszNew.resize(CbSizeWsz(cchRequestUrl + cchUrl)))
		{
			sc = E_OUTOFMEMORY;
			DebugTrace("ScStoragePathFromUrl() - CStackBuffer::resize() failed 0x%08lX\n", sc);
			return sc;
		}

		memcpy (pwszNew.get(), ecb.LpwszRequestUrl(), cchRequestUrl * sizeof(WCHAR));
		memcpy (pwszNew.get(), pwszUrl, (cchUrl + 1) * sizeof(WCHAR));

		//	Now pszURI points to the generated absolute URI
		//
		pwszUrl = pwszNew.get();
		//
		//$	REVIEW: end

#else

		DebugTrace ("ScStoragePathFromUrl(): cannot translate relative URIs\n");
		return E_DAV_BAD_DESTINATION;

#endif	// ALLOW_RELATIVE_URL_TRANSLATION
	}

	//	OK, here is where virtual root spanning needs to be supported...
	//
	//	When the virtual root of the request url does not match the
	//	the virtual root for the url being translated, extra work
	//	needs to be done.
	//
	//	There are two ways to do this.
	//
	//	1)	Call back to IIS and have it do the translation for us
	//	2)	Use our metabase cache to rip through each virtual root
	//		and find the longest matching virtual root.
	//
	//	At first thought, the second method seems efficient.  However,
	//	the changes being made to the metabase cache do not make this
	//	an easy matter.  The cache no longer will be containing just
	//	virtual roots, so the lookup will not be as cheap.
	//
	//$	REVIEW: In fact, I believe that we must do the virtual lookup
	//	via IIS for all translations.  The sub-virtual root thing keeps
	//	gnawing at me.
	//
	cchUrl = static_cast<UINT>(wcslen(pwszUrl));
	sc = ecb.ScReqMapUrlToPathEx(pwszUrl, &mi);
	if (FAILED(sc))
	{
		DebugTrace("ScStoragePathFromUrl() - IEcb::SSFReqMapUrlPathEx() failed 0x%08lX\n", sc);
		return sc;
	}

	//	Try and figure out if the url spanned a virtual root at all.
	//
	cchVRoot = ecb.CchGetVirtualRootW(&pwszVRoot);
	if (cchVRoot != mi.cchMatchingURL)
	{
		//	This case is not so cut-n-dry..
		//
		//	Since CchGetVirtualRoot() should always return a url
		//	that does not have a trailing slash, the matching count
		//	could be off by one and the root may actually be the
		//	same!
		//
		//  Assuming "/vroot" is the Virtual Root in question, this if
		//  statement protects against the following:
		//	1.  catches a two completely different sized vroots.
		//		disqualifies matches that are too short or
		//		too long "/vr", but allows "/vroot/" because need to
		//		handle IIS bug (NT:432359).
		//	2.  checks to make sure the URL is slash terminated.  This
		// 		allows "/vroot/" (again because of NT:432359), but
		//		disqualifies vroots such as "/vrootA"
		//  3.  allows "/vroot" to pass if mi.cchMatchingURL is off by
		//		one (again because of NT:432359).
		//
		if ((cchVRoot + 1 != mi.cchMatchingURL) ||	//  1
			((L'/' != pwszUrl[cchVRoot]) &&			//  2
			 (L'\0' != pwszUrl[cchVRoot])))			//  3
		{
			//  If we're here the virtual root of the URL does not match
			//  the current virtual root...
			//
			DebugTrace ("ScStoragePathFromUrl() - urls do not "
						"share common virtual root\n"
						"-- pwszUrl: %ls\n"
						"-- pwszVirtualRoot: %ls\n"
						"-- cchVirtualRoot: %ld\n",
						pwszUrl,
						pwszVRoot,
						cchVRoot);

			//	Tell the caller that the virtual root is spanned.  This allows
			//	the call to succeed, but the caller to fail the call if spanning
			//	is not allowed.
			//
			sc = W_DAV_SPANS_VIRTUAL_ROOTS;
		}
		else
		{
			//  If we're here we know that the current virtual root matches
			//  the virtual root of the URL, and the following character in
			//  the URL is a slash or a NULL termination.  cchMatchingURL is
			//  EXACTLY 1 greater than the number of characters in the virtual
			//  root (cchVRoot) due to the IIS bug (NT:432359).
			//
			//  Theoretically, if cchMatchingURL matches and matches
			//  one more than the number of characters in the
			//  vroot, the characters will match!  Thus we should assert this case.
			//
			Assert (!_wcsnicmp(pwszVRoot, pwszUrl, cchVRoot));

			//	In this case, mi.cchMatchingURL actually _includes_ the
			//	slash.  Below, when we copy in the trailing part of the
			//	URL, we skip mi.cchMatchingURL characters in the URL
			//	before copying in the trailing URL.  This has the
			//	unfortunate side effect in this case of missing the
			//	slash that is at the beginning of the URL after the
			//	virtual root, so you could end up with a path that looks
			//	like:
			//	\\.\BackOfficeStorage\mydom.extest.microsoft.com\MBXuser1/Inbox
			//	rather than:
			//	\\.\BackOfficeStorage\mydom.extest.microsoft.com\MBX/user1/Inbox
			//
			//	So decrement miw.cchMatchingURL here to handle this.
			//
			DebugTrace ("ScStoragePathFromUrl() : mi.cchMatchingURL included a slash!\n");
			mi.cchMatchingURL--;
		}
	}
	//  If we are hitting this conditional if statement, we know that
	//  the mi.cchMatchingURL is the same as the number of characters
	//	in the vroot.
	//	1.  We already checked for difference in the vroot lengts above
	//	    and if length of the vroot was 0 then they actually matched
	//	2.  We know that due to an IIS bug (NT:432359), cchMatchingURL
	//		could be 1 character too long.  This lines checks for that
	//		case.  If that is the case, we know that the VRoot is one
	//		character longer than the virtual root of the URL -- ie
	//		we are spanning virtual roots.
	//	3.  If the strings aren't in fact the same then we know that
	//		cchMatchingURL matched to a different virtual root than
	//		pszVRoot.
	//
	else if ((0 != cchVRoot) &&								//  1
			((L'\0' == pwszUrl[cchVRoot - 1]) ||			//  2
			_wcsnicmp(pwszVRoot, pwszUrl, cchVRoot)))		//  3
	{
		DebugTrace ("ScStoragePathFromUrl(): urls do not "
					"share common virtual root\n"
					"-- pwszUrl: %ls\n"
					"-- pwszVirtualRoot: %ls\n"
					"-- cchVirtualRoot: %ld\n",
					pwszUrl,
					pwszVRoot,
					cchVRoot);

		//	Tell the caller that the virtual root is spanned.  This allows
		//	the call to succeed, but the caller to fail the call if spanning
		//	is not allowed.
		//
		sc = W_DAV_SPANS_VIRTUAL_ROOTS;
	}

	//	If we span, and the caller wants it, look up the vroot
	//	for them.
	//
	if ((W_DAV_SPANS_VIRTUAL_ROOTS == sc) && ppcvr)
	{
		auto_ref_ptr<CVRoot> arp;
		CStackBuffer<WCHAR, MAX_PATH> pwsz;
		CStackBuffer<WCHAR, MAX_PATH> pwszMetaPath;
		if (NULL == pwsz.resize((mi.cchMatchingURL + 1) * sizeof(WCHAR)))
		{
			sc = E_OUTOFMEMORY;
			DebugTrace("ScStoragePathFromUrl() - CStackBuffer::resize() failed 0x%08lX\n", sc);
			return sc;
		}

		memcpy(pwsz.get(), pwszUrl, mi.cchMatchingURL * sizeof(WCHAR));
		pwsz[mi.cchMatchingURL] = L'\0';
		if (NULL == pwszMetaPath.resize(::CbMDPathW(ecb, pwsz.get())))
		{
			sc = E_OUTOFMEMORY;
			DebugTrace("ScStoragePathFromUrl() - CStackBuffer::resize() failed 0x%08lX\n", sc);
			return sc;
		}

		MDPathFromURIW (ecb, pwsz.get(), pwszMetaPath.get());
		_wcslwr (pwszMetaPath.get());

		//	Find the vroot
		//
		if (!CChildVRCache::FFindVroot (ecb, pwszMetaPath.get(), arp))
		{
			DebugTrace ("ScStoragePathFromUrl(): spanned virtual root not available\n");
			return E_DAV_BAD_DESTINATION;
		}

		*ppcvr = arp.relinquish();
	}

	//	Adjust the matching path the same way as we did matching URL
	//
	if ( mi.cchMatchingPath )
	{
		LPCWSTR pwsz = mi.lpszPath + mi.cchMatchingPath - 1;

		if ( L'\\' == *pwsz )
		{
			while ((0 < mi.cchMatchingPath) &&
				   (L'\\' == *pwsz) &&
				   (!FIsDriveTrailingChar(pwsz, mi.cchMatchingPath)))
			{
				mi.cchMatchingPath--;
				pwsz--;
			}
		}
		else if ( L'\0' == *pwsz )
		{
			mi.cchMatchingPath--;
		}
	}

	//	If there is not enough space in the buffer provided, a return
	//	of S_FALSE tells the caller to realloc and try again!
	//
	Assert (*pcch);
	cch = mi.cchMatchingPath + cchUrl - mi.cchMatchingURL + 1;
	if (*pcch < cch)
	{
		DebugTrace ("ScStoragePathFromUrl (IIS URL Version): buffer too "
					"small for url translation\n");
		*pcch = cch;

		//$	REVIEW: take ownership of the abandoned ref if one was abandoned
		//
		if (ppcvr)
		{
			auto_ref_ptr<CVRoot> arp;
			arp.take_ownership(*ppcvr);
			*ppcvr = NULL;
		}
		//
		//$	REVIEW: end.

		return S_FALSE;
	}

	//	Copy the Matching Path to the beginning of rgwchStgID
	//
	memcpy(wszStgID, mi.lpszPath, mi.cchMatchingPath * sizeof(WCHAR));

	//	Copy the request URL after the vroot, including '\0' termination
	//
	Assert (cchUrl >= mi.cchMatchingURL);
	memcpy (wszStgID + mi.cchMatchingPath,
			pwszUrl + mi.cchMatchingURL,
			(cchUrl - mi.cchMatchingURL + 1) * sizeof(WCHAR));

	//	Change all '/' that came from URL to '\\'
	//
	for (LPWSTR pwch = wszStgID + mi.cchMatchingPath; *pwch; pwch++)
		if (L'/' == *pwch) *pwch = L'\\';

	//	At this point, cch is the actual number of chars in the destination
	//	-- including the null
	//
	*pcch = cch;
	Assert (L'\0' == wszStgID[cch - 1]);
	Assert (L'\0' != wszStgID[cch - 2]);
	return sc;
}

//	Storage path to url translation -------------------------------------------
//
SCODE __fastcall
ScUrlFromStoragePath (
	/* [in]     */ const IEcbBase &	ecb,
	/* [in]     */ LPCWSTR			pwszPath,
	/* [out]    */ LPWSTR			pwszUrl,
	/* [in/out] */ UINT			  *	pcch,
	/* [in]		*/ LPCWSTR			pwszServer)
{
	WCHAR *	pwch;
	LPCWSTR	pwszPrefix;
	LPCWSTR	pwszVroot;
	LPCWSTR	pwszVrPath;
	UINT	cch;
	UINT	cchPath;
	UINT	cchMatching;
	UINT	cchAdjust;
	UINT	cchPrefix;
	UINT	cchServer;
	UINT	cchVroot;
	UINT	cchTrailing;

	//	Find the number of path characters that match the
	//	virtual root
	//
	cchVroot = ecb.CchGetVirtualRootW (&pwszVroot);

	//	We always return fully qualified Urls -- so we need to know
	//	the server name and the prefix.
	//
	cchPrefix = ecb.CchUrlPrefixW (&pwszPrefix);

	//	If server name is not given yet take default one
	//
	if (!pwszServer)
	{
		cchServer = ecb.CchGetServerNameW (&pwszServer);
	}
	else
	{
		cchServer = static_cast<UINT>(wcslen(pwszServer));
	}

	//	The number of characters to be skiped needs to include the physical
	//	vroot path.
	//
	cchMatching = ecb.CchGetMatchingPathW (&pwszVrPath);

	//	If the matching path is ending with '\\' we need to ajust accordingly
	//	as that symbol in the matching path is "overlapping" with the start
	//	of trailing URL part. To construct the URL correctly we need to make
	//	sure that we do not skip that separator. Also handle it the best way
	//	we can if someone is trying to commit suicide by putting '/' at the
	//	end of the matching path.
	//
	if ((0 != cchMatching) &&
		(L'\\' == pwszVrPath[cchMatching - 1] || L'/' == pwszVrPath[cchMatching - 1]) )
	{
		cchAdjust = 1;
	}
	else
	{
		cchAdjust = 0;
	}

	//	So, at this point, the length of the resulting url is the length
	//	of the servername, virtual root and trailing path all put together.
	//
	cchPath = static_cast<UINT>(wcslen(pwszPath));

	//	We assume that the path we are passed in is always fully qualified
	//	with the vroot. Assert that. Calculate the length of trailing
	//	portion including '\0' termination.
	//
	Assert (cchPath + cchAdjust >= cchMatching);
	cchTrailing = cchPath - cchMatching + cchAdjust + 1;
	cch = cchPrefix + cchServer + cchVroot + cchTrailing;

	//	If there is not enough room, a return value of S_FALSE will
	//	properly instruct the caller to realloc and call again.
	//
	if (*pcch < cch)
	{
		DebugTrace ("ScUrlFromStoragePath(): buffer too small for path translation.\n");
		*pcch = cch;
		return S_FALSE;
	}

	//	Start building the url by copying over the prefix and servername.
	//
	memcpy (pwszUrl, pwszPrefix, cchPrefix * sizeof(WCHAR));
	memcpy (pwszUrl + cchPrefix, pwszServer, cchServer * sizeof(WCHAR));
	cch = cchPrefix + cchServer;

	//	Copy over the virtual root
	//
	memcpy (pwszUrl + cch, pwszVroot, cchVroot * sizeof(WCHAR));
	cch += cchVroot;

	//$	REVIEW: I don't know what happens here when we want to be able to
	//	span virtual roots with MOVE/COPY and what not.  However, it will
	//	be up to the caller to fail this if that is the case.
	//
	if (!FSizedPathConflict (pwszPath,
							 cchPath,
							 pwszVrPath,
							 cchMatching))
	{
		DebugTrace ("ScUrlFromStoragePath (IIS URL Version): translation not "
					"scoped by current virtual root\n");
		return E_DAV_BAD_DESTINATION;
	}
	//
	//$	REVIEW: end

	//	While copying make sure that we are not skiping the '\' separator
	//	at the beginning of the trailing URL. That is what cchAdjust stands for.
	//
	memcpy( pwszUrl + cch, pwszPath + cchMatching - cchAdjust, cchTrailing * sizeof(WCHAR));

	//	Lastly, swap all '\\' to '/'
	//
	for (pwch = pwszUrl + cch;
		 NULL != (pwch = wcschr (pwch, L'\\'));
		 )
	{
		*pwch++ = L'/';
	}

	//	Pass back the length, cchTrailing includes the null-termination at this
	//	point.
	//
	*pcch = cch + cchTrailing;
	Assert (0 == pwszUrl[cch + cchTrailing - 1]);
	Assert (0 != pwszUrl[cch + cchTrailing - 2]);

	DebugTrace ("ScUrlFromStoragePath(): translated path:\n"
				"- path \"%ls\" maps to \"%ls\"\n"
				"- cchMatchingPath = %d\n"
				"- cchVroot = %d\n",
				pwszPath,
				pwszUrl,
				cchMatching,
				cchVroot);

	return S_OK;
}


SCODE __fastcall
ScUrlFromSpannedStoragePath (
	/* [in]     */ LPCWSTR	pwszPath,
	/* [in]     */ CVRoot &	vr,
	/* [in]     */ LPWSTR	pwszUrl,
	/* [in/out] */ UINT	  *	pcch)
{
	WCHAR * pwch;

	LPCWSTR	pwszPort;
	LPCWSTR	pwszServer;
	LPCWSTR	pwszVRoot;
	LPCWSTR	pwszVRPath;
	UINT	cch;
	UINT	cchPort;
	UINT	cchServer;
	UINT	cchTotal;
	UINT	cchTrailing;
	UINT	cchVRoot;

	//	Make sure that the path and the virtual root context share a
	//	common base path!
	//
	cch = vr.CchGetVRPath(&pwszVRPath);
	if (_wcsnicmp (pwszPath, pwszVRPath, cch))
	{
		DebugTrace ("ScUrlFromSpannedStoragePath (IIS URL Version): path "
					"is not from virtual root\n");
		return E_DAV_BAD_DESTINATION;
	}
	pwszPath += cch;

	//	If the next character is not a moniker separator, then this can't
	//	be a match
	//
	if (*pwszPath && (*pwszPath != L'\\'))
	{
		DebugTrace ("ScUrlFromSpannedStoragePath (IIS URL Version): path "
					"is not from virtual root\n");
		return E_DAV_BAD_DESTINATION;
	}

	//	A concatination of the url prefix, server, port, vroot prefix and
	//	the remaining path gives us our URL.
	//
	cchTrailing = static_cast<UINT>(wcslen (pwszPath));
	cchVRoot = vr.CchGetVRoot(&pwszVRoot);
	cchServer = vr.CchGetServerName(&pwszServer);
	cchPort = vr.CchGetPort(&pwszPort);
	cch = cchTrailing +
		  cchVRoot +
		  cchPort +
		  cchServer +
		  CchConstString(gc_wszUrl_Prefix_Secure) + 1;

	if (*pcch < cch)
	{
		DebugTrace ("ScUrlFromSpannedStoragePath (IIS URL Version): spanned "
					"translation buffer too small\n");

		*pcch = cch;
		return S_FALSE;
	}

	//	A small note about codepages....
	//
	//	Start constructing the url by grabbing the appropriate prefix
	//
	if (vr.FSecure())
	{
		cchTotal = gc_cchszUrl_Prefix_Secure;
		memcpy (pwszUrl, gc_wszUrl_Prefix_Secure, cchTotal * sizeof(WCHAR));
	}
	else
	{
		cchTotal = gc_cchszUrl_Prefix;
		memcpy (pwszUrl, gc_wszUrl_Prefix, cchTotal * sizeof(WCHAR));
	}

	//	Tack on the server name
	//
	memcpy (pwszUrl + cchTotal, pwszServer, cchServer * sizeof(WCHAR));
	cchTotal += cchServer;

	//	Tack on the port if it is neither the default or a secure port
	//
	if (!vr.FDefaultPort() && !vr.FSecure())
	{
		memcpy (pwszUrl + cchTotal, pwszPort, cchPort * sizeof(WCHAR));
		cchTotal += cchPort;
	}

	//	Add the vroot
	//
	memcpy (pwszUrl + cchTotal, pwszVRoot, cchVRoot * sizeof(WCHAR));
	cchTotal += cchVRoot;

	//	Add the trailing path.
	//
	//	IMPORTANT: The resulting cch will include the NULL
	//	termination.
	//
	if (cch < cchTotal + cchTrailing + 1)
	{
		DebugTrace ("ScUrlFromSpannedStoragePath (IIS URL Version): spanned "
					"translation buffer too small\n");

		*pcch = cchTotal + cchTrailing + 1;
		return S_FALSE;
	}
	else
	{
		memcpy (pwszUrl + cchTotal, pwszPath, (cchTrailing + 1) * sizeof(WCHAR));
	}

	Assert (L'\0' == pwszUrl[cchTotal + cchTrailing]);
	Assert (L'\0' != pwszUrl[cchTotal + cchTrailing - 1]);

	//	Translate all '\\' to '/'
	//
	for (pwch = pwszUrl + cchTrailing + 1; *pwch; pwch++)
	{
		if (L'\\' == *pwch)
		{
			*pwch = L'/';
		}
	}

	DebugTrace ("ScUrlFromSpannedStoragePath (IIS URL Version): spanned "
				"storage path fixed as '%S'\n", pwszUrl);
	*pcch = cchTotal + cchTrailing + 1;
	return S_OK;
}


//	Wire urls -----------------------------------------------------------------
//
SCODE __fastcall
ScWireUrlFromWideLocalUrl (
	/* [in]     */ UINT					cchLocal,
	/* [in]     */ LPCWSTR				pwszLocalUrl,
	/* [in/out] */ auto_heap_ptr<CHAR>&	pszWireUrl)
{
	UINT ib = 0;

	//	Since the url is already wide, all we need to do is
	//	to reduce the url to a UTF8 entity.
	//
	//	We could call the Win32 WideCharToMultiByte(), but we
	//	already know that production, and it would be best to
	//	skip the system call if possible.
	//
	//	Allocate enough space as if every char had maximum expansion
	//
	CStackBuffer<CHAR,MAX_PATH> psz;
	if (NULL == psz.resize((cchLocal * 3) + 1))
		return E_OUTOFMEMORY;

	if (cchLocal)
	{
		//	Currently we get UTF-8 url-s onto the wire. Do we ever
		//	want to pipe out any other codepage?
		//
		ib = WideCharToUTF8(pwszLocalUrl,
							cchLocal,
							psz.get(),
							(cchLocal * 3));
		Assert(ib);
	}

	//	Termination...
	//
	psz[ib] = 0;

	//	Escape it
	//
	HttpUriEscape (psz.get(), pszWireUrl);
	return S_OK;
}

SCODE __fastcall
ScWireUrlFromStoragePath (
	/* [in]     */ IMethUtilBase	  *	pmu,
	/* [in]     */ LPCWSTR				pwszStoragePath,
	/* [in]     */ BOOL					fCollection,
	/* [in]     */ CVRoot			  *	pcvrTranslate,
	/* [in/out] */ auto_heap_ptr<CHAR>&	pszWireUrl)
{
	Assert (pwszStoragePath);
	Assert (NULL == pszWireUrl.get());

	SCODE	sc = S_OK;

	//	Take a best guess for size and try and convert
	//	NOTE: we allocate space allowing for the trailing
	//	slash on directories - thus for the calls filling
	//	the buffer we indicate that available space is one
	//	character less than actually allocated.
	//
	CStackBuffer<WCHAR,128> pwszUrl;

	//$	REVIEW: WINRAID:462078: The "-1" below has to do
	//	with making sure that there is enough space to append
	//	a trailing slash at the end of the url for directories.
	//
	UINT cch = pwszUrl.celems() - 1;
	//
	//$	REVIEW: end.

	if (pcvrTranslate == NULL)
	{
		sc = pmu->ScUrlFromStoragePath (pwszStoragePath, pwszUrl.get(), &cch);
		if (S_FALSE == sc)
		{
			//	Try again, but with a bigger size.
			//
			if (NULL == pwszUrl.resize(CbSizeWsz(cch)))
				return E_OUTOFMEMORY;

			sc = pmu->ScUrlFromStoragePath (pwszStoragePath, pwszUrl.get(), &cch);
		}
		if (S_OK != sc)
		{
			DebugTrace ("ScWireUrlFromStoragePath (IIS URL Version): "
						"failed to translate path to href\n");
			return sc;
		}
	}
	else
	{
		sc = ScUrlFromSpannedStoragePath (pwszStoragePath,
										  *pcvrTranslate,
										  pwszUrl.get(),
										  &cch);
		if (S_FALSE == sc)
		{
			//	Try again, but with a bigger size.
			//
			if (NULL == pwszUrl.resize(CbSizeWsz(cch)))
				return E_OUTOFMEMORY;

			sc = ScUrlFromSpannedStoragePath (pwszStoragePath,
											  *pcvrTranslate,
											  pwszUrl.get(),
											  &cch);
		}
		if (S_OK != sc)
		{
			DebugTrace ("ScWireUrlFromStoragePath (IIS URL Version): "
						"failed to translate path to href\n");
			return sc;
		}
	}

	//	cch includes the termination char
	//
	Assert (cch);
	Assert (L'\0' == pwszUrl[cch - 1]);
	Assert (L'\0' != pwszUrl[cch - 2]);

	//	For directories, check the trailing slash
	//
	if (fCollection && (L'/' != pwszUrl[cch - 2]))
	{
		//	Add the trailing '/'
		//
		//	Remember we've added one extra bytes when allocating pwszUrl
		//
		pwszUrl[cch - 1] = L'/';
		pwszUrl[cch] = L'\0';
		cch += 1;
	}

	return ScWireUrlFromWideLocalUrl (cch - 1, pwszUrl.get(), pszWireUrl);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\httpext\_davfs.h ===
/*
 *	_ D A V F S . H
 *
 *	Precompiled header sources
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	__DAVFS_H_
#define __DAVFS_H_

#pragma warning(disable:4001)	/* single line comments */
#pragma warning(disable:4050)	/* different code attributes */
#pragma warning(disable:4100)	/* unreferenced formal parameter */
#pragma warning(disable:4115)	/* named type definition in parentheses */
#pragma warning(disable:4127)	/* conditional expression is constant */
#pragma warning(disable:4201)	/* nameless struct/union */
#pragma warning(disable:4206)	/* translation unit is empty */
#pragma warning(disable:4209)	/* benign typedef redefinition */
#pragma warning(disable:4214)	/* bit field types other than int */
#pragma warning(disable:4514)	/* unreferenced inline function */
#pragma warning(disable:4200)	/* zero-sized array in struct/union */
#pragma warning(disable:4710)	//	(inline) function not expanded

//	Windows headers
//
//$HACK!
//
//	Define _WINSOCKAPI_ to keep windows.h from including winsock.h,
//	whose declarations would be redefined in winsock2.h,
//	which is included by iisextp.h,
//	which we include in davimpl.h!
//
#define _WINSOCKAPI_
#include <windows.h>
#include <winnls.h>

#include <malloc.h>

#include <caldbg.h>
#include <calrc.h>
#include <crc.h>
#include <exo.h>
#include <singlton.h>
#include <thrdpool.h>

#include <align.h>
#include <mem.h>
#include <except.h>

#include <davimpl.h>
#include <security.h>
#include <davmb.h>
#include <eventlog.h>
#include <statcode.h>
#include <sz.h>
#include <etag.h>
#include <dav.rh>

#include <ex\cnvt.h>
#include <util.h>

#include <filter.h>
#include <filterr.h>

#include "_fslock.h"
#include "_fsimpl.h"
#include "_fsri.h"
#include "_fsutil.h"

#include "_diriter.h"

#include "_fsmvcpy.h"
#include "_fsmeta.h"

#include "_shlkmgr.h"

#include "_voltype.h"

#include "davprsmc.h"
#include "traces.h"

//	DAV Prefixed Win32 API's --------------------------------------------------
//
HANDLE __fastcall DavCreateFile (
	/* [in] */ LPCWSTR lpFileName,
    /* [in] */ DWORD dwDesiredAccess,
    /* [in] */ DWORD dwShareMode,
    /* [in] */ LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    /* [in] */ DWORD dwCreationDisposition,
    /* [in] */ DWORD dwFlagsAndAttributes,
    /* [in] */ HANDLE hTemplateFile);

BOOL __fastcall DavDeleteFile (
	/* [in] */ LPCWSTR lpFileName);

BOOL __fastcall DavCopyFile (
	/* [in] */ LPCWSTR lpExistingFileName,
	/* [in] */ LPCWSTR lpNewFileName,
	/* [in] */ BOOL bFailIfExists);

BOOL __fastcall DavMoveFile (
	/* [in] */ LPCWSTR lpExistingFileName,
	/* [in] */ LPCWSTR lpNewFileName,
	/* [in] */ DWORD dwReplace);

BOOL __fastcall DavCreateDirectory (
	/* [in] */ LPCWSTR lpFileName,
	/* [in] */ LPSECURITY_ATTRIBUTES lpSecurityAttributes);

BOOL __fastcall DavRemoveDirectory (
	/* [in] */ LPCWSTR lpFileName);

BOOL __fastcall DavGetFileAttributes (
	/* [in] */ LPCWSTR lpFileName,
	/* [in] */ GET_FILEEX_INFO_LEVELS fInfoLevelId,
	/* [out] */ LPVOID lpFileInformation);

BOOL __fastcall DavFindFirstFile (
	/* [in] */ LPCWSTR lpFileName,
	/* [out] */ HANDLE * ph,
	/* [out] */ WIN32_FIND_DATAW * pfd);

#endif	// __DAVFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\httpext\_fslock.h ===
#ifndef __FSLOCK_H_
#define __FSLOCK_H_

#include <fhcache.h>

//	------------------------------------------------------------------------
//
//	class CParseLockTokenHeader
//
//		Takes in a Lock-Token header (you need to fetch the header & pre-check
//		that it's not NULL) and provides parsing & iteration routines.
//
//		Can also be instantiated over a If-[None-]State-Match header to
//		do the state-token checking required.
//
//		Implemented in lockutil.cpp
//
class CParseLockTokenHeader
{
	//	The big stuff
	//
	LPMETHUTIL m_pmu;
	HDRITER_W m_hdr;
	LPCSTR m_pszCurrent;

	//	State bits
	BOOL m_fPathsSet : 1;
	BOOL m_fTokensChecked : 1;

	//	Data for paths
	UINT m_cwchPath;
	auto_heap_ptr<WCHAR> m_pwszPath;
	UINT m_cwchDest;
	auto_heap_ptr<WCHAR> m_pwszDest;

	//	Count of locktokens provided
	ULONG m_cTokens;

	//	Quick-access to single-locktoken data
	LPCSTR m_pszToken;

	//	Data for multiple tokens
	struct PATH_TOKEN
	{
		__int64 i64LockId;
		BOOL fFetched;	// TRUE = path & dwords below have been filled in.
		LPCWSTR pwszPath;
		DWORD dwLockType;
		DWORD dwAccess;
	};
	auto_heap_ptr<PATH_TOKEN> m_pargPathTokens;
	//	m_cTokens tells how many valid structures we have.

	//	Fetch info about this lockid from the lock cache.
	HRESULT HrFetchPathInfo (__int64 i64LockId, PATH_TOKEN * pPT);

	//	NOT IMPLEMENTED
	//
	CParseLockTokenHeader( const CParseLockTokenHeader& );
	CParseLockTokenHeader& operator=( const CParseLockTokenHeader& );

public:
	CParseLockTokenHeader (LPMETHUTIL pmu, LPCWSTR pwszHeader) :
			m_pmu(pmu),
			m_hdr(pwszHeader),
			m_pszCurrent(NULL),
			m_fPathsSet(FALSE),
			m_fTokensChecked(FALSE),
			m_cwchPath(0),
			m_cwchDest(0),
			m_cTokens(0),
			m_pszToken(NULL)
	{
		Assert(m_pmu);
		Assert(pwszHeader);
	}
	~CParseLockTokenHeader() {}

	//	Special test -- F if not EXACTLY ONE item in the header.
	//
	BOOL FOneToken();
	
	//	Feed the relevant paths to this lock token parser.
	//
	HRESULT SetPaths (LPCWSTR pwszPath, LPCWSTR pwszDest);
	
	//	Get the token string for a path WITH a certain kind of access.
	//
	HRESULT HrGetLockIdForPath (LPCWSTR pwszPath,
									DWORD dwAccess,
									LARGE_INTEGER * pliLockID,
									BOOL fPathLookup = FALSE);

};

BOOL FLockViolation (LPMETHUTIL pmu,
					 HRESULT hr,
					 LPCWSTR pwszPath,
					 DWORD dwAccess);

BOOL FDeleteLock (LPMETHUTIL pmu, __int64 i64LockId);

HRESULT HrCheckStateHeaders (LPMETHUTIL pmu,
							 LPCWSTR pwszPath,
							 BOOL fGetMeth);

HRESULT HrLockIdFromString (LPMETHUTIL pmu,
							LPCWSTR pwszToken,
							LARGE_INTEGER * pliLockID);

SCODE ScLockDiscoveryFromSNewLockData(LPMETHUTIL pmu,
												  CXMLEmitter& emitter,
												  CEmitterNode& en,
												  SNewLockData * pnld, 
												  LPCWSTR pwszLockToken);

HRESULT HrGetLockProp (LPMETHUTIL pmu,
					   LPCWSTR wszPropName,
					   LPCWSTR wszResource,
					   RESOURCE_TYPE rtResource,
					   CXMLEmitter& emitter,
					   CEmitterNode& enParent);

#endif // __FSLOCK_H_ endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\httpext\_fsmeta.h ===
/*
 *	_ F S M E T A . H
 *
 *	File system metadata routines
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef __FSMETA_H_
#define __FSMETA_H_

//	STL helpers ---------------------------------------------------------------
//
//	Use pragmas to disable the specific level 4 warnings
//	that appear when we use the STL.  One would hope our version of the
//	STL compiles clean at level 4, but alas it doesn't....
#pragma warning(disable:4663)	//	C language, template<> syntax
#pragma warning(disable:4244)	//	return conversion, data loss
// Turn this warning off for good.
#pragma warning(disable:4786)	//	symbol truncated in debug info
// Put STL includes here
#include <list>
// Turn warnings back on
#pragma warning(default:4663)	//	C language, template<> syntax
#pragma warning(default:4244)	//	return conversion, data loss

//	OLE and NT5 properties ----------------------------------------------------
//
#define OLEDBVER 0x200
#include <ole2.h>
#include <stgint.h>
#include <pbagex.h>

typedef HRESULT (__stdcall * STGOPENSTORAGEONHANDLE)(
	IN HANDLE hStream,
	IN DWORD grfMode,
	IN void *reserved1,
	IN void *reserved2,
	IN REFIID riid,
	OUT void **ppObjectOpen );

typedef HRESULT (__stdcall * STGCREATESTORAGEONHANDLE)(
	IN HANDLE hStream,
	IN DWORD grfMode,
	IN DWORD stgfmt,
	IN void *reserved1,
	IN void *reserved2,
	IN REFIID riid,
	OUT void **ppObjectOpen );

extern STGOPENSTORAGEONHANDLE	g_pfnStgOpenStorageOnHandle;

//	reserved properties ------------------------------------------------------
//
//	There are two conditions that make a property reserved.
//
//	The first and foremost is that the property is not something that is stored
//	in the resource's property container, but instead is calculated from file
//	system information or DAV specific conditions (lock info, etc.)
//
//	The second is that the property is not something that can be set via
//	PROPPATCH calls.  This distinction is needed when asking if a property is
//	reserved.
//
enum {

	//	The properties in this section are all properties that are calculated
	//	from the filesystem or DAV specific information.
	//
	iana_rp_content_length,
	iana_rp_creation_date,
	iana_rp_displayname,
	iana_rp_etag,
	iana_rp_last_modified,
	iana_rp_resourcetype,
	iana_rp_lockdiscovery,
	iana_rp_supportedlock,
	iana_rp_ishidden,
	iana_rp_iscollection,
	sc_crp_get_reserved,

	//	The properties in this section are actually stored in the property
	//	container (via PUT) but are reserved for the purpose of PUT.
	//
	//	IMPORTANT! "DAV:getcontenttype" must be the first non-get reserved
	//	property!
	//
	iana_rp_content_type = sc_crp_get_reserved,
	iana_rp_content_encoding,
	iana_rp_content_language,

	//	To be consistent with DAVEX, make the following property reserved
	//
	iana_rp_searchrequest,
	sc_crp_set_reserved
};

typedef struct RP { DWORD dwCRC; LPCWSTR pwsz; } RP;
#define IanaItemCrc(_sz,_crc) { _crc, L"DAV:" L#_sz }
DEC_CONST RP sc_rp[sc_crp_set_reserved] = {

	IanaItemCrc(getcontentlength,		0x25412A26),
	IanaItemCrc(creationdate,			0xA8A9F240),
	IanaItemCrc(displayname,			0xA399DB8D),
	IanaItemCrc(getetag,				0x5E54D3B8),
	IanaItemCrc(getlastmodified,		0x45D75CD4),
	IanaItemCrc(resourcetype,			0x8155BECE),
	IanaItemCrc(lockdiscovery,			0xC7ED2F96),
	IanaItemCrc(supportedlock,			0x39B9A692),
	IanaItemCrc(ishidden,				0xE31B1632),
	IanaItemCrc(iscollection,			0xD3E3FF13),
	IanaItemCrc(getcontenttype,			0xC28B9FED),
	IanaItemCrc(getcontentencoding,		0x4B7C7220),
	IanaItemCrc(getcontentlanguage,		0x5E9717C2),
	IanaItemCrc(searchrequest,			0x5AC72D67),
};

//	DAV Metadata --------------------------------------------------------------
//
#include <xmeta.h>

//	The FS impl of DAV uses the NT5 property interfaces and IPropertyBag
//	as its underlying property storage implementation.  This mechanism uses
//	strings and/or PROPVARIANTS to refer to properties and their values.
//
//	Therefore the PROPFIND and PROPPATCH contexts are written with this in
//	mind.
//
//	CFSFind/CFSPatch ----------------------------------------------------------
//
class CFSProp;
class CFSFind : public CFindContext, public IPreloadNamespaces
{
	ChainedStringBuffer<WCHAR>	m_csb;
	ULONG						m_cProps;
	ULONG						m_cMaxProps;
	auto_heap_ptr<LPCWSTR>		m_rgwszProps;

	LONG						m_ip_getcontenttype;

	//	non-implemented operators
	//
	CFSFind( const CFSFind& );
	CFSFind& operator=( const CFSFind& );

public:

	virtual ~CFSFind() {}
	CFSFind()
			: m_cProps(0),
			  m_cMaxProps(0),
			  m_ip_getcontenttype(-1)
	{
	}

	//	When the parser finds an item that the client wants returned,
	//	the item is added to the context via the following set context
	//	methods.  Each add is qualified by the resource on which the
	//	request is made. fExcludeProp is used for full-fidelity special
	//	cases in the Exchange implementation only.
	//
	virtual SCODE ScAddProp(LPCWSTR pwszPath, LPCWSTR pwszProp, BOOL fExcludeProp);

	//	The ScFind() method is used to invoke the context onto a given
	//	resources property object.
	//
	SCODE ScFind (CXMLEmitter& msr, IMethUtil * pmu, CFSProp& fpt);

	//	Add an error to the response that is based on the context.
	//
	SCODE ScErrorAllProps (CXMLEmitter& msr,
						   IMethUtil * pmu,
						   LPCWSTR pwszPath,
						   BOOL	fCollection,
						   CVRoot* pcvrTranslation,
						   SCODE scErr)
	{
		//	Add an item to the msr that says this entire
		//	file was not accessible
		//
		return  ScAddMulti (msr,
							pmu,
							pwszPath,
							NULL,
							HscFromHresult(scErr),
							fCollection,
							pcvrTranslation);
	}

	//	IPreloadNamespaces
	//
	SCODE	ScLoadNamespaces(CXMLEmitter * pmsr);
};

class CFSPatch : public CPatchContext, public IPreloadNamespaces
{
	class CFSPropContext : public CPropContext
	{
		PROPVARIANT*		m_pvar;
		BOOL				m_fHasValue;

		//	non-implemented operators
		//
		CFSPropContext( const CFSPropContext& );
		CFSPropContext& operator=( const CFSPropContext& );

	public:

		CFSPropContext(PROPVARIANT* pvar)
				: m_pvar(pvar),
				  m_fHasValue(FALSE)
		{
			Assert (pvar != NULL);
		}

		virtual ~CFSPropContext() {}
		virtual SCODE ScSetType(LPCWSTR pwszType)
		{
			return ScVariantTypeFromString (pwszType, m_pvar->vt);
		}
		virtual SCODE ScSetValue(LPCWSTR pwszValue, UINT cmvValues)
		{
			//	At this time, HTTPEXT does not support multivalued
			//	properties.
			//
			Assert (0 == cmvValues);

			//	If no type was specified, we default to a string
			//
			m_fHasValue = TRUE;
			if (m_pvar->vt == VT_EMPTY)
				m_pvar->vt = VT_LPWSTR;

			return ScVariantValueFromString (*m_pvar, pwszValue);
		}
		virtual SCODE ScComplete(BOOL fEmpty)
		{
			Assert (m_fHasValue);
			return m_fHasValue ? S_OK : E_DAV_XML_PARSE_ERROR;
		}

		//	At this time, HTTPEXT does not support multivalued
		//	properties.
		//
		virtual BOOL FMultiValued() { return FALSE; }
	};

	//	PATCH_SET items
	//
	ChainedStringBuffer<WCHAR>	m_csb;
	ULONG						m_cSetProps;
	ULONG						m_cMaxSetProps;
	auto_heap_ptr<LPCWSTR>		m_rgwszSetProps;
	auto_heap_ptr<PROPVARIANT>	m_rgvSetProps;

	//	Failed Propserties including reserverd properties
	//
	CStatusCache				m_csn;

	//	PATCH_DELETE items
	//
	ULONG						m_cDeleteProps;
	ULONG						m_cMaxDeleteProps;
	auto_heap_ptr<LPCWSTR>		m_rgwszDeleteProps;

	//	non-implemented operators
	//
	CFSPatch( const CFSPatch& );
	CFSPatch& operator=( const CFSPatch& );

public:

	virtual ~CFSPatch();
	CFSPatch()
			: m_cSetProps(0),
			  m_cMaxSetProps(0),
			  m_cDeleteProps(0),
			  m_cMaxDeleteProps(0)
	{
	}

	SCODE	ScInit() { return m_csn.ScInit(); }

	//	When the parser finds an item that the client wants operated on,
	//	the item is added to the context via the following set context
	//	methods.  Each request is qualified by the resource on which the
	//	request is made.
	//
	virtual SCODE ScDeleteProp(LPCWSTR pwszPath,
							   LPCWSTR pwszProp);
	virtual SCODE ScSetProp(LPCWSTR pwszPath,
							LPCWSTR pwszProp,
							auto_ref_ptr<CPropContext>& pPropCtx);

	//	The ScPatch() method is used to invoke the context onto a given
	//	resources property object.
	//
	SCODE ScPatch (CXMLEmitter& msr, IMethUtil * pmu, CFSProp& fpt);

	//	IPreloadNamespaces
	//
	SCODE	ScLoadNamespaces(CXMLEmitter * pmsr);
};

//	CFSProp -------------------------------------------------------------------
//
#include "_voltype.h"
class CFSProp
{
	IMethUtil*						m_pmu;

	LPCWSTR							m_pwszURI;
	LPCWSTR							m_pwszPath;
	CVRoot*							m_pcvrTranslation;

	CResourceInfo&					m_cri;

	auto_com_ptr<IPropertyBagEx>& 	m_pbag;
	BOOL FInvalidPbag() const		{ return (m_pbag.get() == NULL); }

	//	Volume type of the drive on which m_pwszPath resides
	//
	mutable VOLTYPE m_voltype;

	BOOL FIsVolumeNTFS() const
	{
		//	If we don't already know it, figure out the volume type
		//	for the volume on which our path resides.
		//
		if (VOLTYPE_UNKNOWN == m_voltype)
			m_voltype = VolumeType(m_pwszPath, m_pmu->HitUser());

		//	Return whether that volume is NTFS.
		//
		Assert(m_voltype != VOLTYPE_UNKNOWN);
		return VOLTYPE_NTFS == m_voltype;
	}

	//	non-implemented operators
	//
	CFSProp( const CFSProp& );
	CFSProp& operator=( const CFSProp& );

	enum { PROP_CHUNK_SIZE = 16 };

	SCODE ScGetPropsInternal (ULONG cProps,
							  LPCWSTR* rgwszPropNames,
							  PROPVARIANT* rgvar,
							  LONG ip_getcontenttype);


public:

	CFSProp(IMethUtil* pmu,
			auto_com_ptr<IPropertyBagEx>& pbag,
			LPCWSTR pwszUri,
			LPCWSTR pwszPath,
			CVRoot* pcvr,
			CResourceInfo& cri)
			: m_pmu(pmu),
			  m_pwszURI(pwszUri),
			  m_pwszPath(pwszPath),
			  m_pcvrTranslation(pcvr),
			  m_cri(cri),
			  m_pbag(pbag),
			  m_voltype(VOLTYPE_UNKNOWN)
	{
	}

	LPCWSTR PwszPath() const { return m_pwszPath; }
	CVRoot* PcvrTranslation() const { return m_pcvrTranslation; }
	BOOL FCollection() const
	{
		if (m_cri.FLoaded())
			return m_cri.FCollection();
		else
			return FALSE;
	}

	//	Reserved Properties
	//
	typedef enum { RESERVED_GET, RESERVED_SET } RESERVED_TYPE;
	static BOOL FReservedProperty (LPCWSTR pwszProp, RESERVED_TYPE rt, UINT* prp);
	SCODE ScGetReservedProp (CXMLEmitter& xml,
							 CEmitterNode& en,
							 UINT irp,
							 BOOL fValues = TRUE);

	//	PROPFIND context access
	//
	SCODE ScGetAllProps (CXMLEmitter&, CEmitterNode&, BOOL fValues);
	SCODE ScGetSpecificProps (CXMLEmitter&,
							  CEmitterNode&,
							  ULONG cProps,
							  LPCWSTR* rgwszProps,
							  LONG ip_gcontenttype);

	//	PROPPATCH context access
	//
	SCODE ScSetProps (CStatusCache & csn,
					  ULONG cProps,
					  LPCWSTR* rgwszProps,
					  PROPVARIANT* rgvProps);

	SCODE ScDeleteProps (CStatusCache & csn,
						 ULONG cProps,
						 LPCWSTR* rgwszProps);
	SCODE ScPersist();

	//	Non-context access
	//
	SCODE ScSetStringProp (LPCWSTR pwszProp, LPCWSTR pwszValue)
	{
		PROPVARIANT var = {0};
		SCODE sc = S_OK;

		var.vt = VT_LPWSTR;
		var.pwszVal = const_cast<LPWSTR>(pwszValue);

		Assert (!FInvalidPbag());
		sc = m_pbag->WriteMultiple (1, &pwszProp, &var);
		if (FAILED(sc))
		{
			//	This is the common path for when we are trying to access
			//	something over an SMB, but the host cannot support the
			//	request (it is not an NT5 NTFS machine).
			//
			if ((sc == STG_E_INVALIDNAME) || !FIsVolumeNTFS())
				sc = E_DAV_SMB_PROPERTY_ERROR;
		}
		return sc;
	}
};

//	Support functions ---------------------------------------------------------
//
SCODE ScFindFileProps (IMethUtil* pmu,
		CFSFind& cfc,
		CXMLEmitter& msr,
		LPCWSTR pwszUri,
		LPCWSTR pwszPath,
		CVRoot* pcvrTranslation,
		CResourceInfo& cri,
		BOOL fEmbedErrorsInResponse);

SCODE ScFindFilePropsDeep (IMethUtil* pmu,
		CFSFind& cfc,
		CXMLEmitter& msr,
		LPCWSTR pwszUri,
		LPCWSTR pwszPath,
		CVRoot* pcvrTranslation,
		LONG lDepth);

SCODE ScSetContentProperties (IMethUtil * pmu, LPCWSTR pwszPath,
						HANDLE hFile = INVALID_HANDLE_VALUE);

SCODE ScCopyProps (IMethUtil* pmu,
				   LPCWSTR pwszSrc,
				   LPCWSTR pwszDst,
				   BOOL fCollection,
				   HANDLE hSource = INVALID_HANDLE_VALUE,
				   HANDLE hfDest = INVALID_HANDLE_VALUE);

//	ScGetPropertyBag ----------------------------------------------------------
//
//	Helper function used to get IPropertyBagEx interface
//
SCODE ScGetPropertyBag (LPCWSTR pwszPath,
						DWORD dwAccessDesired,
						IPropertyBagEx** ppbe,
						BOOL fCollection,
						HANDLE hLockFile = INVALID_HANDLE_VALUE);

inline BOOL FGetDepth (IMethUtil * pmu, LONG * plDepth)
{
	LONG lDepth = pmu->LDepth (DEPTH_INFINITY);

	//	"Depth" header, if appears, can only be '0', '1' or 'infinity',
	//	all other values are treated as error
	//
	switch (lDepth)
	{
		case DEPTH_ZERO:
		case DEPTH_ONE:
		case DEPTH_ONE_NOROOT:
		case DEPTH_INFINITY:

			*plDepth = lDepth;
			break;

		default:

			return FALSE;
	}
	return TRUE;
}

// safe_statpropbag -------------------------------------------------------------
//
#pragma pack(8)
class safe_statpropbag
{
	//	IMPORTANT:  Do not add any other members to this class
	//	other than the STATPROP that is to be protected.
	//
	STATPROPBAG sp;

	//	non-implemented
	//
	safe_statpropbag(const safe_statpropbag& b);
	safe_statpropbag& operator=(const safe_statpropbag& b);

public:

	explicit safe_statpropbag()
	{
		memset (&sp, 0, sizeof(safe_statpropbag));
	}
	~safe_statpropbag()
	{
		CoTaskMemFree (sp.lpwstrName);
	}

	//	ACCESSORS
	//
	STATPROPBAG* load() { return &sp; }
	STATPROPBAG get() { return sp; }
};
#pragma pack()

#endif	// __FSMETA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\httpext\_fsimpl.h ===
/*
 *	_ F S I M P L . H
 *
 *	File System Implementation of DAV
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	__FSIMPL_H_
#define __FSIMPL_H_

extern const WCHAR gc_wszPathPrefix[];
extern const UINT gc_cchwszPathPrefix;

//	Support functions ---------------------------------------------------------
//
#include <ex\rgiter.h>

class auto_ref_handle;
VOID TransmitFileRanges (LPMETHUTIL pmu,
						 const auto_ref_handle& hf,
						 DWORD dwSize,
						 CRangeBase *priRanges,
						 LPCWSTR pwszContent);

//	Tracing -------------------------------------------------------------------
//
#ifdef	DBG
extern BOOL g_fDavTrace;
#define DavTrace				!g_fDavTrace?0:DebugTraceFn
#else
#define DavTrace				NOP_FUNCTION
#endif

//	Instance ------------------------------------------------------------------
//
extern HINSTANCE g_hinst;

extern CHAR gc_szVersion[];

// Gives the count of elements in an array
//
#define CElems(_rg)		(sizeof(_rg)/sizeof(_rg[0]))

//	free the global DBCreateCommand object
//
VOID ReleaseDBCreateCommandObject();

//	Locking support functions -------------------------------------------------
//	(Implemented in fslock.cpp)
//
BOOL FGetLockHandle (LPMETHUTIL pmu, LPCWSTR pwszPath,
					 DWORD dwAccess, LPCWSTR pwszLockTokenHeader,
					 auto_ref_handle * phandle);
SCODE ScDoLockedCopy (LPMETHUTIL pmu, CParseLockTokenHeader * plth,
					  LPCWSTR pwszSrc, LPCWSTR pwszDst);

#endif	// __FSIMPL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\httpext\_diriter.h ===
/*
 *	_ D I R I T E R . H
 *
 *	Headers for directory ineration object
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	__DIRITER_H_
#define __DIRITER_H_

#include <buffer.h>

//	Path separators -----------------------------------------------------------
//
DEC_CONST WCHAR gc_wszPathSeparator[] = L"\\";
DEC_CONST WCHAR gc_wszUriSeparator[] = L"/";

//	Helper functions ----------------------------------------------------------
//
inline BOOL
IsHidden(const WIN32_FIND_DATAW& fd)
{
	return !!(fd.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN);
}

inline BOOL
IsDirectory(const WIN32_FIND_DATAW& fd)
{
	return !!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
}

//	CInitedStringBuffer -------------------------------------------------------
//
template<class T>
class CInitedStringBuffer : public StringBuffer<T>
{
	//	non-implemented operators
	//
	CInitedStringBuffer (const CInitedStringBuffer& );
	CInitedStringBuffer& operator= (const CInitedStringBuffer& );

public:

	CInitedStringBuffer (const T* pszInit, const T* pszSep)
	{
		//	Initialize the uri
		//
		if (pszInit)
		{
			Append (pszInit);
			if (*(PContents() + CchSize() - 1) != *pszSep)
				Append (pszSep);
		}
		else
			Append (pszSep);
	}
};

//	CResPath ------------------------------------------------------------------
//
template<class T>
class CResPath
{
	const T*				m_sz;	//	Path separator
	StringBuffer<T>&		m_sb;
	UINT					m_ib;

	//	non-implemented operators
	//
	CResPath (const CResPath& );
	CResPath& operator= (const CResPath& );

public:

	CResPath (StringBuffer<T>& sb, const T* pszSep)
			: m_sz(pszSep),
			  m_sb(sb),
			  m_ib(sb.CbSize())
	{
		Assert (m_ib >= sizeof(T));
		const T* psz = m_sb.PContents() + ((m_ib/sizeof(T)) - 1);
		if (*psz == '\0')
		{
			Assert (!memcmp (m_sz, psz - 1, sizeof(T)));
			m_ib -= sizeof(T);
		}
		else
			Assert (!memcmp (m_sz, psz, sizeof(T)));
	}

	const T* PszPath(void) const { return m_sb.PContents(); }
	void Extend (const T* pszSegment, UINT cch, BOOL fDir)
	{
		//	Append the path segment, and in the case of a
		//	directory append the separator as well.
		//
		if (fDir)
		{
			//	Copy over the name, then append a slash and the
			//	null termination
			//
			m_sb.AppendAt (m_ib, cch * sizeof(T), pszSegment);
			m_sb.Append (2 * sizeof(T), m_sz);
		}
		else
		{
			//	Copy over the name, then append a null.
			T ch = 0;
			m_sb.AppendAt (m_ib, cch * sizeof(T), pszSegment);
			m_sb.Append (sizeof(T), &ch);
		}
	}
};

//	CDirState -----------------------------------------------------------------
//
class CDirState : public CMTRefCounted
{
	HANDLE						m_hFind;
	WIN32_FIND_DATAW&			m_fd;

	CInitedStringBuffer<WCHAR>	m_sbPathDst;
	auto_ref_ptr<CVRoot>		m_pvrDst;

	CResPath<WCHAR>				m_rpUriSrc;
	CResPath<WCHAR>				m_rpPathSrc;
	CResPath<WCHAR>				m_rpUriDst;
	CResPath<WCHAR>				m_rpPathDst;

	void Extend (WIN32_FIND_DATAW& fd)
	{
		BOOL fDirectory = IsDirectory (fd);
		UINT cch = static_cast<UINT>(wcslen (fd.cFileName));

		m_rpPathSrc.Extend (fd.cFileName, cch, fDirectory);
		m_rpPathDst.Extend (fd.cFileName, cch, fDirectory);

		//	We only want to extend the count of chars NOT INCLUDING
		//	the NULL
		//
		m_rpUriSrc.Extend (fd.cFileName, cch, fDirectory);
		m_rpUriDst.Extend (fd.cFileName, cch, fDirectory);
	}

	//	non-implemented operators
	//
	CDirState (const CDirState& );
	CDirState& operator= (const CDirState& );

public:

	CDirState (StringBuffer<WCHAR>& sbUriSrc,
			   StringBuffer<WCHAR>& sbPathSrc,
			   StringBuffer<WCHAR>& sbUriDst,
			   LPCWSTR pwszPathDst,
			   CVRoot* pvr,
			   WIN32_FIND_DATAW& fd)
			: m_hFind(INVALID_HANDLE_VALUE),
			  m_fd(fd),
			  m_sbPathDst(pwszPathDst, gc_wszPathSeparator),
			  m_pvrDst(pvr),
			  m_rpUriSrc(sbUriSrc, gc_wszUriSeparator),
			  m_rpPathSrc(sbPathSrc, gc_wszPathSeparator),
			  m_rpUriDst(sbUriDst, gc_wszUriSeparator),
			  m_rpPathDst(m_sbPathDst, gc_wszPathSeparator)
	{
		//	Clear and/or reset the find data
		//
		memset (&fd, 0, sizeof(WIN32_FIND_DATAW));
	}

	~CDirState()
	{
		if (m_hFind != INVALID_HANDLE_VALUE)
		{
			FindClose (m_hFind);
		}
	}

	SCODE ScFindNext(void);

	LPCWSTR PwszUri(void)				const { return m_rpUriSrc.PszPath(); }
	LPCWSTR PwszSource(void)			const { return m_rpPathSrc.PszPath(); }
	LPCWSTR PwszUriDestination(void)	const { return m_rpUriDst.PszPath(); }
	LPCWSTR PwszDestination(void)		const { return m_rpPathDst.PszPath(); }

	CVRoot* PvrDestination(void)		const { return m_pvrDst.get(); }
};

//	CDirectoryStack -----------------------------------------------------------
//
//	Use pragmas to disable the specific level 4 warnings
//	that appear when we use the STL.  One would hope our version of the
//	STL compiles clean at level 4, but alas it doesn't....
//
#pragma warning(disable:4663)	//	C language, template<> syntax
#pragma warning(disable:4244)	//	return conversion, data loss

// Turn this warning off for good.
//
#pragma warning(disable:4786)	//	symbol truncated in debug info

// Put STL includes here
//
#include <list>

// Turn warnings back on
//
#pragma warning(default:4663)	//	C language, template<> syntax
#pragma warning(default:4244)	//	return conversion, data loss

typedef std::list<const CDirState*, heap_allocator<const CDirState*> > CDirectoryStack;

//	Directory iteration class -------------------------------------------------
//
class CDirIter
{
	CInitedStringBuffer<WCHAR>	m_sbUriSrc;
	CInitedStringBuffer<WCHAR>	m_sbPathSrc;
	CInitedStringBuffer<WCHAR>	m_sbUriDst;

	auto_ref_ptr<CDirState>		m_pds;

	BOOL						m_fSubDirectoryIteration;
	CDirectoryStack				m_stack;

	WIN32_FIND_DATAW			m_fd;

	//	NOT IMPLEMENTED
	//
	CDirIter (const CDirIter&);
	CDirIter& operator= (const CDirIter&);

public:

	CDirIter (LPCWSTR pwszUri,
			  LPCWSTR pwszSource,
			  LPCWSTR pwszUriDestination,
			  LPCWSTR pwszDestination,
			  CVRoot* pvrDestination,
			  BOOL fDoSubDirs = FALSE)
			: m_sbUriSrc(pwszUri, gc_wszUriSeparator),
			  m_sbPathSrc(pwszSource, gc_wszPathSeparator),
			  m_sbUriDst(pwszUriDestination, gc_wszUriSeparator),
			  m_fSubDirectoryIteration(fDoSubDirs)
	{
		//	Create the initial directory state
		//
		m_pds = new CDirState (m_sbUriSrc,
							   m_sbPathSrc,
							   m_sbUriDst,
							   pwszDestination,
							   pvrDestination,
							   m_fd);
	}

	//	API -------------------------------------------------------------------
	//
	SCODE __fastcall ScGetNext (
		/* [in] */ BOOL fDoSubDirs = TRUE,
		/* [in] */ LPCWSTR pwszNewPath = NULL,
		/* [in] */ CVRoot* pvrDestination = NULL);

	LPCWSTR PwszSource() const			{ return m_pds->PwszSource(); }
	LPCWSTR PwszDestination() const		{ return m_pds->PwszDestination(); }
	LPCWSTR PwszUri() const				{ return m_pds->PwszUri(); }
	LPCWSTR PwszUriDestination() const	{ return m_pds->PwszUriDestination(); }
	CVRoot* PvrDestination()			{ return m_pds->PvrDestination(); }

	WIN32_FIND_DATAW& FindData()		{ return m_fd; }

	BOOL FDirectory() const				{ return IsDirectory(m_fd); }
	BOOL FHidden() const				{ return IsHidden(m_fd); }
	BOOL FSpecial() const
	{
		return (!wcscmp (L".", m_fd.cFileName) ||
				!wcscmp (L"..", m_fd.cFileName));
	}
};

#endif	// __DIRITER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\httpext\_fsri.h ===
/*
 *	_ F S R I . H
 *
 *	Resource information helper class
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	__FSRI_H_
#define __FSRI_H_

/*
 *	CResourceInfo -------------------------------------------------------------
 *
 *	The CResourceInfo object is intended to function as an abstraction
 *	to the file information available to the impl.  Namely, it should
 *	be used in such a way that file information calls to the Win32 kernel
 *	are kept to a minimum -- the ideal is once and only once.
 *
 *	The other issue is the efficiency of how this information is obtained.
 *	So if I need to know the attributes of a file, then I do not want to
 *	have to make a call to FindFirstFile()/CloseFind() just to get the
 *	attributes.  This is a tremendously expensive method for doing so.
 *	However, there are times that information beyond the information
 *	returned by GetFileAttributesEx() is desired, and in those instances,
 *	a more expensive mechanism should be employed to get that data.
 *
 *	Regardless of how the data was obtained, the caller wants unified
 *	access to the information.  This helper class provides that.
 *
 *	The object itself knows how the file information held there was
 *	obtained.  So to access the file information, the caller calls the
 *	accessor to obtain the values.  The accessors switch off of the mode
 *	indicator that describes how the information was filled in.
 *
 */
class CResourceInfo
{
	enum { NODATA, BY_ATTRIBUTE, BY_FIND };

	UINT m_lmode;
	union {

		WIN32_FILE_ATTRIBUTE_DATA ad;
		WIN32_FIND_DATAW fd;

	} m_u;

public:

	CResourceInfo()
		: m_lmode(NODATA)
	{
		memset(&m_u, 0, sizeof(m_u));
	}

	//	Resource information initialization
	//
	SCODE ScGetResourceInfo (LPCWSTR pwszFile);

	BOOL FLoaded() { return m_lmode != NODATA; }

	//	Data access
	//
	DWORD DwAttributes() const
	{
		Assert (m_lmode != NODATA);
		return (m_lmode == BY_ATTRIBUTE)
				? m_u.ad.dwFileAttributes
				: m_u.fd.dwFileAttributes;
	}
	BOOL FCollection() const
	{
		return !!(DwAttributes() & FILE_ATTRIBUTE_DIRECTORY);
	}
	BOOL FHidden() const
	{
		return !!(DwAttributes() & FILE_ATTRIBUTE_HIDDEN);
	}
	BOOL FRemote() const
	{
		return !!(DwAttributes() & FILE_ATTRIBUTE_OFFLINE);
	}
	FILETIME * PftCreation()
	{
		Assert (m_lmode != NODATA);
		return (m_lmode == BY_ATTRIBUTE)
				? &m_u.ad.ftCreationTime
				: &m_u.fd.ftCreationTime;
	}
	FILETIME * PftLastModified()
	{
		Assert (m_lmode != NODATA);
		return (m_lmode == BY_ATTRIBUTE)
				? &m_u.ad.ftLastWriteTime
				: &m_u.fd.ftLastWriteTime;
	}
	void FileSize (LARGE_INTEGER& li)
	{
		Assert (m_lmode != NODATA);
		if (m_lmode == BY_ATTRIBUTE)
		{
			li.LowPart = m_u.ad.nFileSizeLow;
			li.HighPart = m_u.ad.nFileSizeHigh;
		}
		else
		{
			li.LowPart = m_u.fd.nFileSizeLow;
			li.HighPart = m_u.fd.nFileSizeHigh;
		}
	}
	WIN32_FIND_DATAW * PfdLoad()
	{
		m_lmode = BY_FIND;
		return &m_u.fd;
	}
	WIN32_FIND_DATAW& Fd()
	{
		Assert (m_lmode == BY_FIND);
		return m_u.fd;
	}
	BOOL FFindData() const { return (m_lmode == BY_FIND); }
	void Reset() { m_lmode = NODATA; }
};

/*	Resource locations --------------------------------------------------------
 *
 *	DAVFS allows for the client to be somewhat lax in its url's when
 *	specifying a resource.  Namely, if the caller specifies a resource
 *	that is a collection, and the url does not end in a trailing slash,
 *	in most cases we will simply go ahead and succeed the call while
 *	making sure that we return the properly qualified url in the location
 *	header.  The FTrailingSlash() and the ScCheckForLocationCorrectness()
 *	methods provide for this lax checking.
 *
 *	FTrailingSlash() simply returns TRUE if (and only if) the url ends in
 *	a trailing slash.
 *
 *	ScCheckForLocationCorrectness() will check the url against the
 *	resource and either add the appropriate location header, or it will
 *	request a redirect if the url and the resource do not agree.  The
 *	caller has the control over whether or not a true redirect is desired.
 *	As an informational return, if a location header has been added S_FALSE
 *	will be returned to the caller.
 */
enum { NO_REDIRECT = FALSE, REDIRECT = TRUE };

inline BOOL FTrailingSlash (LPCWSTR pwsz)
{
	Assert (pwsz);
	UINT cch = static_cast<UINT>(wcslen (pwsz));
	return ((0 != cch) && (L'/' == pwsz[cch - 1]));
}

SCODE ScCheckForLocationCorrectness (IMethUtil*,
									 CResourceInfo&,
									 UINT mode = NO_REDIRECT);

/*
 *	If-xxx header helper functions --------------------------------------------
 *
 *	The current ScCheckIfHeaders() implementation in the common code
 *	takes the last modified time of the resource as the second parameter.
 *	This version helper function takes the actual path to the resource.
 *	It is implemented by getting the resource information for the file
 *	and then calling the common implementation of ScCheckIfHeaders().
 */
SCODE ScCheckIfHeaders (IMethUtil* pmu, LPCWSTR pwszPath, BOOL fGetMethod);

#endif	// __FSRI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\httpext\_fsmvcpy.h ===
/*
 *	_ F S M V C P Y . H
 *
 *	Sources for directory iteration object
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef __FSMVCPY_H_
#define __FSMVCPY_H_

#include <xemit.h>

//	Metabase operations -------------------------------------------------------
//

//	class CAccessMetaOp -------------------------------------------------------
//
class CAccessMetaOp : public CMetaOp
{
	enum { DONT_INHERIT = 0 };

	DWORD		m_dwAcc;
	BOOL		m_fAccessBlocked;

	//	non-implemented
	//
	CAccessMetaOp& operator=( const CAccessMetaOp& );
	CAccessMetaOp( const CAccessMetaOp& );

protected:

	//	Subclass' operation to perform for each node where
	//	a value is explicitly set.
	//
	virtual SCODE __fastcall ScOp(LPCWSTR pwszMbPath, UINT cch);

public:

	virtual ~CAccessMetaOp() {}
	CAccessMetaOp (const LPMETHUTIL pmu, LPCWSTR pwszPath, DWORD dwAcc)
			: CMetaOp (pmu->GetEcb(), pwszPath, MD_ACCESS_PERM, DWORD_METADATA, FALSE),
			  m_dwAcc(dwAcc),
			  m_fAccessBlocked(FALSE)
	{
	}

	//	If FAccessBlocked() returns true, the operation must
	//	check the access directly on all resources that the
	//	operation wishes to process
	//
	BOOL __fastcall FAccessBlocked() const { return m_fAccessBlocked; }
};

//	class CAuthMetaOp -------------------------------------------------------
//
class CAuthMetaOp : public CMetaOp
{
	enum { DONT_INHERIT = 0 };

	DWORD		m_dwAuth;
	BOOL		m_fAccessBlocked;

	//	non-implemented
	//
	CAuthMetaOp& operator=( const CAuthMetaOp& );
	CAuthMetaOp( const CAuthMetaOp& );

protected:

	//	Subclass' operation to perform for each node where
	//	a value is explicitly set.
	//
	virtual SCODE __fastcall ScOp(LPCWSTR pwszMbPath, UINT cch);

public:

	virtual ~CAuthMetaOp() {}
	CAuthMetaOp (const LPMETHUTIL pmu, LPCWSTR pwszPath, DWORD dwAuth)
			: CMetaOp (pmu->GetEcb(), pwszPath, MD_AUTHORIZATION, DWORD_METADATA, FALSE),
			  m_dwAuth(dwAuth),
			  m_fAccessBlocked(FALSE)
	{
	}

	//	If FAccessBlocked() returns true, the operation must
	//	check the access directly on all resources that the
	//	operation wishes to process
	//
	BOOL __fastcall FAccessBlocked() const { return m_fAccessBlocked; }
};

//	class CIPRestrictionMetaOp ------------------------------------------------
//
class CIPRestrictionMetaOp : public CMetaOp
{
	enum { DONT_INHERIT = 0 };

	BOOL					m_fAccessBlocked;

	//	non-implemented
	//
	CIPRestrictionMetaOp& operator=( const CIPRestrictionMetaOp& );
	CIPRestrictionMetaOp( const CIPRestrictionMetaOp& );

protected:

	//	Subclass' operation to perform for each node where
	//	a value is explicitly set.
	//
	virtual SCODE __fastcall ScOp(LPCWSTR pwszMbPath, UINT cch);

public:

	virtual ~CIPRestrictionMetaOp() {}
	CIPRestrictionMetaOp (const LPMETHUTIL pmu, LPCWSTR pwszPath)
			: CMetaOp (pmu->GetEcb(), pwszPath, MD_IP_SEC, BINARY_METADATA, FALSE),
			  m_fAccessBlocked(FALSE)
	{
	}

	//	If FAccessBlocked() returns true, the operation must
	//	check the access directly on all resources that the
	//	operation wishes to process
	//
	BOOL __fastcall FAccessBlocked() const { return m_fAccessBlocked; }
};

//	class CContentTypeMetaOp --------------------------------------------------
//
class CContentTypeMetaOp : public CMetaOp
{
	enum { DONT_INHERIT = 0 };

	LPCWSTR		m_pwszDestPath;
	BOOL		m_fDelete;

	//	non-implemented
	//
	CContentTypeMetaOp& operator=( const CContentTypeMetaOp& );
	CContentTypeMetaOp( const CContentTypeMetaOp& );

protected:

	//	Subclass' operation to perform for each node where
	//	a value is explicitly set.
	//
	virtual SCODE __fastcall ScOp(LPCWSTR pwszMbPath, UINT cch);

public:

	virtual ~CContentTypeMetaOp() {}
	CContentTypeMetaOp (const LPMETHUTIL pmu, LPCWSTR pwszSrcPath, LPCWSTR pwszDestPath, BOOL fDelete)
			: CMetaOp (pmu->GetEcb(), pwszSrcPath, MD_MIME_MAP, MULTISZ_METADATA, fDelete),
			  m_pwszDestPath(pwszDestPath),
			  m_fDelete(fDelete)
	{
	}
};

//	Helper functions
//
//	XML Error construction helpers ------------------------------------------------
//
SCODE ScAddMulti (
	/* [in] */ CXMLEmitter& emitter,
	/* [in] */ IMethUtil * pmu,
	/* [in] */ LPCWSTR pwszPath,
	/* [in] */ LPCWSTR pwszErr,
	/* [in] */ ULONG hsc,
	/* [in] */ BOOL fCollection = FALSE,
	/* [in] */ CVRoot* pcvrTrans = NULL);

//	Access --------------------------------------------------------------------
//
SCODE __fastcall
ScCheckMoveCopyDeleteAccess (
	/* [in] */ IMethUtil* pmu,
	/* [in] */ LPCWSTR pwszUrl,
	/* [in] */ CVRoot* pcvr,
	/* [in] */ BOOL fDirectory,
	/* [in] */ BOOL fCheckScriptmaps,
	/* [in] */ DWORD dwAccess,
	/* [out] */ SCODE* pscItem,
	/* [in] */ CXMLEmitter& msr);

//	Delete --------------------------------------------------------------------
//
SCODE
ScDeleteDirectoryAndChildren (
	/* [in] */ IMethUtil* pmu,
	/* [in] */ LPCWSTR pwszUrl,
	/* [in] */ LPCWSTR pwszPath,
	/* [in] */ BOOL fCheckAccess,
	/* [in] */ DWORD dwAcc,
	/* [in] */ LONG lDepth,
	/* [in] */ CXMLEmitter& msr,
	/* [in] */ CVRoot* pcvrTranslate,
	/* [out] */ BOOL* pfDeleted,
	/* [in] */ CParseLockTokenHeader* plth,	// Usually NULL -- no locktokens to worry about
	/* [in] */ BOOL fDeleteLocks);			// Normally FALSE -- don't drop locks

//	MoveCopy ------------------------------------------------------------------
//
void MoveCopyResource (
	/* [in] */ IMethUtil* pmu,
	/* [in] */ DWORD dwAccRequired,
	/* [in] */ BOOL fDeleteSrc);

#endif	// __FSMVCPY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\httpext\_fsutil.h ===
/*
 *	_ F S U T I L . H
 *
 *	File system routines
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef __FSUTIL_H_
#define __FSUTIL_H_

enum { CCH_PATH_PREFIX = 4 };

//	Public function to clear out the cached security-enabled thread token
//	used in ScChildISAPIAccessCheck.
//	Should be called in our ISAPI terminate proc.
//
void CleanupSecurityToken();

#endif	// __FSUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\httpext\_sof.h ===
/*
 *	_ S O F . H
 *
 *	Stream on file implementation class
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	__SOF_H_
#define __SOF_H_

#include <nonimpl.h>

//	StmOnFile -----------------------------------------------------------------
//
class StmOnFile : public CStreamNonImpl
{
private:

	HANDLE	m_hf;

public:

	StmOnFile(HANDLE hf) : m_hf(hf) {}
	~StmOnFile() {}

	virtual /* [local] */ HRESULT STDMETHODCALLTYPE Read(
		/* [length_is][size_is][out] */ void __RPC_FAR *,
		/* [in] */ ULONG,
		/* [out] */ ULONG __RPC_FAR *);

	virtual /* [local] */ HRESULT STDMETHODCALLTYPE Write(
		/* [size_is][in] */ const void __RPC_FAR * pb,
		/* [in] */ ULONG cb,
		/* [out] */ ULONG __RPC_FAR * pcb);

	virtual HRESULT STDMETHODCALLTYPE Commit(
		/* [in] */ DWORD)
	{
		//	Flush the file to disk
		//
		if (!FlushFileBuffers (m_hf))
			return HRESULT_FROM_WIN32(GetLastError());

		return S_OK;
	}
};

#endif // __SOF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\httpext\_voltype.h ===
#ifndef _VOLTYPE_H_
#define _VOLTYPE_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	_VOLTYPE.H
//
//		Volume type checking interface.  Results are cached on a per volume
//		basis to improve performance -- the call to GetVolumeInformationW()
//		is around 100KCycles and never changes for a given volume without a
//		reboot.
//
enum VOLTYPE
{
	VOLTYPE_UNKNOWN,
	VOLTYPE_NTFS,
	VOLTYPE_NOT_NTFS
};

//	Function to return tye volume type (from the enumeration above) of the
//	specified path.
//
VOLTYPE VolumeType(LPCWSTR pwszPath, HANDLE htokUser);

//	Init/Deinit of the volume type cache.  It is ok to call
//	DeinitVolumeTypeCache() if the call to FInitVolumeTypeCache()
//	failed (returned FALSE) or even if it was never called at all.
//
BOOL FInitVolumeTypeCache();
VOID DeinitVolumeTypeCache();

#endif // !defined(_VOLTYPE_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\httpext\_fssrch.h ===
/*
 *	_ F S S R C H . H
 *
 *	File system search routines
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef __FSSRCH_H_
#define __FSSRCH_H_

#include <xsearch.h>

//$REVIEW: 4510 -- Should we work this one out of the code?
#pragma warning(disable:4510)	// default constructor could not be generated
#pragma warning(disable:4610)	// class can never be instantiated - user defined constructor required

typedef std::list<CRCWszi, heap_allocator<CRCWszi> > CWsziList;

#include <oledb.h>

//	CSearchRowsetContext ------------------------------------------------------
//
class CSearchRowsetContext : public CSearchContext
{
	//	non-implemented operators
	//
	CSearchRowsetContext( const CSearchRowsetContext& );
	CSearchRowsetContext& operator=( const CSearchRowsetContext& );

protected:

	auto_com_ptr<IRowset>		m_prs;			//	Rowset

	auto_heap_ptr<DBBINDING>	m_rgBindings;	//	array of column bindings
	auto_com_ptr<IAccessor>		m_pAcc;			//	IAccessor
	auto_heap_ptr<BYTE>			m_pData;		//	data buffer
	DBCOUNTITEM					m_cHRow;		//	length of array of HROWS
	HROW *						m_rgHRow;		//	array of HROWs
	HACCESSOR					m_hAcc;			//	array of accessors
	ULONG						m_ulRowCur;		//	current row
	ULONG						m_cRowsEmitted; //	Number of rows emitted

	//	Rowset specific methods
	//
	VOID CleanUp();

public:

	virtual ~CSearchRowsetContext() {}
	CSearchRowsetContext ()
			: m_cHRow(0),
			  m_rgHRow(NULL),
			  m_hAcc(NULL),
			  m_ulRowCur(0),
			  m_cRowsEmitted(0)
	{
	}

	//	When the parser finds an item that applies to the search, a call is
	//	made such that the context is informed of the desired search.
	//
	virtual SCODE ScSetSQL(CParseNmspcCache * pnsc, LPCWSTR pwszSQL) = 0;

	//	Search processing
	//
	virtual SCODE ScMakeQuery() = 0;
	virtual SCODE ScEmitResults (CXMLEmitter& emitter);

	//	Impl. specific rowset methods
	//
	virtual SCODE ScCreateAccessor () = 0;
	virtual SCODE ScEmitRow (CXMLEmitter& emitter) = 0;

	//	OLE DB Error code translations
	//
	static ULONG HscFromDBStatus (ULONG ulStatus);
};

//	Search XMLDocument --------------------------------------------------------
//
class CFSSearch : public CSearchRowsetContext
{
	IMethUtil *					m_pmu;

	//	Receives the string buffer returned from
	//	GetColumnInfo. it is allocated by OLE DB
	//	provider and should be freed with
	//	CoTaskMemFree
	//
	LPWSTR						m_pwszBuf;
	DBCOLUMNINFO *				m_rgInfo;

	//	Used for SQL
	//
	StringBuffer<WCHAR>			m_sbSQL;
	auto_com_ptr<ICommandText>	m_pCommandText;

	//	Find context
	//
	CFSFind						m_cfc;

	//	Used for child-vroot processing
	//
	ChainedStringBuffer<WCHAR>	m_csb;
	CVRList						m_vrl;

	//	non-implemented operators
	//
	CFSSearch( const CFSSearch& );
	CFSSearch& operator=( const CFSSearch& );

	LPCWSTR PwszSQL() const { return m_sbSQL.PContents(); }

public:

	CFSSearch(IMethUtil * pmu)
		: m_pmu(pmu),
		  m_rgInfo(NULL),
		  m_pwszBuf(NULL)
	{
	}

	~CFSSearch()
	{
		//	free information returned from IColumnInfo
		//
		CoTaskMemFree (m_rgInfo);
		CoTaskMemFree (m_pwszBuf);
	}

	//	Impl. methods
	//
	virtual SCODE ScMakeQuery();
	virtual SCODE ScSetSQL(CParseNmspcCache * pnsc, LPCWSTR pwszSQL);
	virtual SCODE ScEmitRow (CXMLEmitter& emitter);
	virtual SCODE ScCreateAccessor();

	IPreloadNamespaces * PPreloadNamespaces () { return &m_cfc; }
};

#endif // __FSSRCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\align.h ===
/*
 *	A L I G N . H
 *
 *	Alignment macros
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_ALIGN_H_
#define _ALIGN_H_

//	Alignments ----------------------------------------------------------------
//
#undef	AlignN
#undef	Align2
#undef	Align4
#undef	Align8
#undef	AlignNatural
#undef	FIsAlignedCb
#undef	FIsAligned

enum {

	ALIGN_NONE = 0,
	ALIGN_WORD,
	ALIGN_INTEL,
	ALIGN_RISC,
	ALIGN_16BYTE,
	ALIGN_128BYTE = 7,
	ALIGN_4K = 12,
#if defined (_AMD64_) || defined (_IA64_)
	ALIGN_NATURAL = ALIGN_RISC
#elif defined (WIN32)
	ALIGN_NATURAL = ALIGN_INTEL
#endif
};

#define AlignN(x,n)			(((x)+(1<<(n))-1) & ~((1<<(n))-1))
#define PadN(x,n)			(AlignN(x,n) - (x))

#define Align2(x)			AlignN((x),ALIGN_WORD)
#define Align4(x)			AlignN((x),ALIGN_INTEL)
#define Align8(x)			AlignN((x),ALIGN_RISC)
#define Align16(x)			AlignN((x),ALIGN_16BYTE)
#define Align128(x)			AlignN((x),ALIGN_128BYTE)
#define Align4K(x)			AlignN((x),ALIGN_4K)
#define AlignNatural(x)		AlignN((x),ALIGN_NATURAL)

#define Pad2(x)				PadN((x),ALIGN_WORD)
#define Pad4(x)				PadN((x),ALIGN_INTEL)
#define Pad8(x)				PadN((x),ALIGN_RISC)
#define Pad16(x)			PadN((x),ALIGN_16BYTE)
#define Pad4K(x)			PadN((x),ALIGN_4K)

#define FIsAlignedCb(x)		(AlignNatural((ULONG_PTR)(x)) == (ULONG_PTR)(x))
#define FIsAligned(x)		(FIsAlignedCb((LPVOID)(x)))

#endif	// _ALIGN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\httpext\_shlkmgr.h ===
#ifndef _SHLKMGR_H_
#define _SHLKMGR_H_


//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	SHLKMGR.H
//
//		Declaration of the CSharedLockMgr class which inherits from ILockCache
//      and is used in place of CLockCache for httpext.  It wraps the shared
//      memory lock cache, needed to support recycling and multiple processes
//      handling dav requests.
//
//	Copyright 2000 Microsoft Corporation, All Rights Reserved
//

#include <fhcache.h>
#include <singlton.h> 

HRESULT HrGetUsableHandle(HANDLE hFile, DWORD dwProcessID, HANDLE * phFile);

/**********************************
* Class CSharedLockMgr
*
***********************************/
class CSharedLockMgr : private Singleton<CSharedLockMgr>
{
	//
	//	Friend declarations required by Singleton template
	//
	friend class Singleton<CSharedLockMgr>;

	//
	//	The IFileHandleCache interface to the file handle cache
	//
	auto_ref_ptr<IFileHandleCache> m_pFileHandleCache;

	//	CREATORS
	//
	CSharedLockMgr()
	{
	}
	
	~CSharedLockMgr()
	{
	}

	//  NOT IMPLEMENTED
	//
	CSharedLockMgr& operator=( const CSharedLockMgr& );
	CSharedLockMgr( const CSharedLockMgr& );

	HRESULT HrGetSIDFromHToken(HANDLE hit, BYTE ** ppSid, DWORD * pdwSid)
	{
		HRESULT hr = S_OK;

		enum { TOKENBUFFSIZE = (88) + sizeof(TOKEN_USER)};		
		BYTE rgbTokenBuff[TOKENBUFFSIZE];
		DWORD dwTu = TOKENBUFFSIZE;
		TOKEN_USER * pTu = reinterpret_cast<TOKEN_USER *>(rgbTokenBuff);

		SID * psid;
		DWORD dwSid;

		auto_heap_ptr<BYTE> a_pSid;
		
		Assert(hit);
		Assert(ppSid);
		Assert(pdwSid);

		//	Try to get the SID on this handle.
		//
		if (!GetTokenInformation(hit,
							   TokenUser,
							   pTu,
							   dwTu,
							   &dwTu))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			goto ret;
		}

		psid = reinterpret_cast<SID *>(pTu->User.Sid);
		dwSid = GetSidLengthRequired(psid->SubAuthorityCount);
		Assert(dwSid);

		a_pSid = reinterpret_cast<BYTE *>(ExAlloc(dwSid));
		if (NULL == a_pSid.get())
		{
			hr = E_OUTOFMEMORY;
			goto ret;
		}

		if (!CopySid(dwSid, a_pSid.get(), pTu->User.Sid))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			goto ret;
		}

		*ppSid = a_pSid.relinquish();
		*pdwSid = dwSid;

	ret:
	
		return hr;
	}


public:
		
	//	CREATORS
	//
	//	Instance creating/destroying routines provided
	//	by the Singleton template.
	//
	using Singleton<CSharedLockMgr>::CreateInstance;
	using Singleton<CSharedLockMgr>::DestroyInstance;
	using Singleton<CSharedLockMgr>::Instance;

	HRESULT HrInitialize()
	{
		HRESULT hr = S_OK;
		
		//	Create an instance of the com-base file handle cache  interface.
		//
		//	Note that we do not init COM at any point.  IIS should
		//	have already done that for us.
		//
		hr = CoCreateInstance (CLSID_FileHandleCache,
							NULL,
							CLSCTX_LOCAL_SERVER | CLSCTX_ENABLE_AAA,
							IID_IFileHandleCache,
							reinterpret_cast<LPVOID*>(m_pFileHandleCache.load()));
		if (FAILED(hr))
		{
			DebugTrace( "CSharedLockMgr::HrInitialize() - CoCreateInstance(CLSID_FileHandleCache) failed 0x%08lX\n", hr );
			goto ret;
		}

		//	Register this process with the file handle cache
		//
		hr = m_pFileHandleCache->HrRegisterWorkerProcess(GetCurrentProcessId());
		if (FAILED(hr))
		{
			DebugTrace( "CSharedLockMgr::HrInitialize() - IFileHandleCache::HrRegisterWorkerProcess() failed 0x%08lX\n", hr );
			goto ret;			
		}
		
	ret:

		return hr;
	}

	BOOL FGetLockOnError(IMethUtil * pmu,
							  LPCWSTR wszResource,
							  DWORD dwLockType,
							  BOOL	fEmitXML = FALSE,
							  CXMLEmitter * pemitter = NULL,
							  CXNode * pxnParent = NULL);

	// CSharedLockMgr specific classes
	//=================================

	//	Get the GUID string used by the locks
	//
	HRESULT HrGetGUIDString( HANDLE hit,
								UINT cchBufferLen,
								WCHAR * pwszGUIDString,
								UINT * pcchGUIDString)
	{
		safe_revert sr(hit);
		
		return m_pFileHandleCache->HrGetGUIDString(cchBufferLen,
												 pwszGUIDString,
												 pcchGUIDString);
    	}
    
	// Used to generate a new shared data lock token with 
	// the appropriate information stored it.  Has to be 
	// generated from here because of the need to get to the
	// new lock token ID, and to access the lock token guid.
	//
	HRESULT HrGetNewLockData(HANDLE hFile,
								    HANDLE hit,
								    SNewLockData * pnld,
								    UINT cchBufferLen,
								    WCHAR * pwszLockToken,
								    UINT * pcchLockToken)
	{
		HRESULT hr = S_OK;
		auto_heap_ptr<BYTE> a_pSid;
		DWORD dwSid = 0;

		hr = HrGetSIDFromHToken(hit, a_pSid.load(), &dwSid);
		if (FAILED(hr))
		{
			goto ret;
		}

		{
			safe_revert sr(hit);
			
			hr = m_pFileHandleCache->HrGetNewLockData(reinterpret_cast<DWORD_PTR>(hFile),
													GetCurrentProcessId(),
													dwSid,
													a_pSid.get(),
													pnld,
													cchBufferLen,
													pwszLockToken,
													pcchLockToken);
			if (FAILED(hr))
			{
				goto ret;
			}
		}

	ret:

		return hr;
	}

	HRESULT HrGetLockData(LARGE_INTEGER liLockID,
							   HANDLE hit,
							   LPCWSTR pwszPath,
							   DWORD dwTimeout,
							   SNewLockData * pnld,
							   SLockHandleData * plhd,
							   UINT cchBufferLen,
							   WCHAR rgwszLockToken[],
							   UINT * pcchLockToken)
	{
		HRESULT hr = S_OK;
		auto_heap_ptr<BYTE> a_pSid;
		DWORD dwSid = 0;

		hr = HrGetSIDFromHToken(hit, a_pSid.load(), &dwSid);
		if (FAILED(hr))
		{
			goto ret;
		}

		{
			safe_revert sr(hit);
		
			hr = m_pFileHandleCache->HrGetLockData(liLockID,
												 dwSid,
												 a_pSid.get(),
												 pwszPath,
												 dwTimeout,
												 pnld,
												 plhd,
												 cchBufferLen,
												 rgwszLockToken,
												 pcchLockToken);
			if (FAILED(hr))
			{
				goto ret;
			}
		}

	ret:

		return hr;
	}

	HRESULT HrCheckLockID(LARGE_INTEGER liLockID,
							   HANDLE hit,
							   LPCWSTR pwszPath)
	{
		HRESULT hr = S_OK;
		auto_heap_ptr<BYTE> a_pSid;
		DWORD dwSid = 0;
		
		hr = HrGetSIDFromHToken(hit, a_pSid.load(), &dwSid);
		if (FAILED(hr))
		{
			goto ret;
		}

		{
			safe_revert sr(hit);

			hr = m_pFileHandleCache->HrCheckLockID(liLockID,
												 dwSid,
												 a_pSid.get(),
												 pwszPath);
			if (FAILED(hr))
			{
				goto ret;
			}
		}
	
	ret:

		return hr;
	}

	HRESULT HrDeleteLock(HANDLE hit,
							LARGE_INTEGER liLockID)
	{
		safe_revert sr(hit);
		
		return m_pFileHandleCache->HrDeleteLock(liLockID);
	}    
};


#endif  // end _SHLKMGR_H_ define
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\autoptr.h ===
/*
 *	A U T O P T R . H
 *
 *	Implementation of the Standard Template Library (STL) auto_ptr template.
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef _AUTOPTR_H_
#define _AUTOPTR_H_

#include <ex\autoptr.h>

//	========================================================================
//
//	TEMPLATE CLASS auto_ptr_obsolete
//
//		auto_ptr for objects in _davprs
//
template<class X>
class auto_ptr_obsolete
{
	mutable X *		owner;
	X *				px;

public:
	explicit auto_ptr_obsolete(X* p=0) : owner(p), px(p) {}
	auto_ptr_obsolete(const auto_ptr_obsolete<X>& r)
			: owner(r.owner), px(r.relinquish()) {}

	auto_ptr_obsolete& operator=(const auto_ptr_obsolete<X>& r)
	{
		if ((void*)&r != (void*)this)
		{
			delete owner;
			owner = r.owner;
			px = r.relinquish();
		}

		return *this;
	}
	//	NOTE: This equals operator is meant to be used to load a
	//	new pointer (not yet held in any auto-ptr anywhere) into this object.
	auto_ptr_obsolete& operator=(X* p)
	{
		Assert(!owner);		//	Scream on overwrite of good data.
		owner = p;
		px = p;
		return *this;
	}

	~auto_ptr_obsolete()  { delete owner; }
	bool operator!()const { return (px == NULL); }
	operator X*()	const { return px; }
	X& operator*()  const { return *px; }
	X* operator->() const { return px; }
	X* get()		const { return px; }
	X* relinquish() const { owner = 0; return px; }

	void clear()
	{
		if (owner)
			delete owner;
		owner = 0;
		px = 0;
	}
};


//	========================================================================
//
//	TEMPLATE CLASS auto_com_ptr
//
//		auto_ptr for COM (IUnknown-derived) objects.
//
//		Yes, this is functionally a subset of CComPtr in the ATL,
//		but we don't want to pull in the whole friggin' ATL for one
//		measly template.
//
template<class X>
class auto_com_ptr
{
	X *		px;

	//	NOT IMPLEMENTED
	//
	void * operator new(size_t cb);

public:
	//	CONSTRUCTORS
	//
	explicit auto_com_ptr(X* p=0) : px(p) {}

	//	Copy constructor -- provided only for returning objects.
	//	Should ALWAYS be optimized OUT.  Scream if we actually execute this code!
	//$REVIEW:  Should we really be returning objects like this?
	//
	auto_com_ptr(const auto_com_ptr<X>& r) : px(r.px)
			{ TrapSz("Copy ctor for auto_com_ptr incorrectly called!"); }
	~auto_com_ptr()
	{
		if (px)
		{
			px->Release();
		}
	}

	//	MANIPULATORS
	//
	auto_com_ptr& operator=(const auto_com_ptr<X>& r)
	{
		if ((void*)&r != (void*)this)
		{
			clear();		// Release any object we're holding now
			px = r.px;		// Grab & hold a ref on the object passed in
			if (px)
				px->AddRef();
		}
		return *this;
	}

	//	NOTE: This equals operator is meant to be used to load a
	//	new pointer (not yet held in any auto-ptr anywhere) into this object.
	//$REVIEW: The other options is an "additional" wrapper on the rvalue:
	//$REVIEW:	current- m_pEventRouter = CreateEventRouter( m_szVRoot );
	//$REVIEW:	other option- m_pEventRouter = auto_com_ptr<>(CreateEventRouter( m_szVRoot ));
	//
	auto_com_ptr& operator=(X* p)
	{
		Assert(!px);		//	Scream on overwrite of good data.
		px = p;
		return *this;
	}

	//	ACCESSORS
	//
	bool operator!()const { return (px == NULL); }
	operator X*()	const { return px; }
	X& operator*()  const { return *px; }
	X* operator->() const { return px; }
	X** operator&() { Assert(NULL==px); return &px; }
	X* get()		const { return px; }

	//	MANIPULATORS
	//
	X* relinquish()	{ X* p = px; px = 0; return p; }
	X** load()		{ Assert(NULL==px); return &px; }
	void clear()
	{
		if (px)			// Release any object we're holding now
		{
			px->Release();
		}
		px = NULL;
	}
};

//	========================================================================
//
//	CLASS CMTRefCounted
//	TEMPLATE CLASS auto_ref_ptr
//
class CMTRefCounted
{
	//	NOT IMPLEMENTED
	//
	CMTRefCounted(const CMTRefCounted& );
	CMTRefCounted& operator=(const CMTRefCounted& );

protected:
	LONG	m_cRef;

public:
	CMTRefCounted() : m_cRef(0) {}
	virtual ~CMTRefCounted() {}

	void AddRef()
	{
		InterlockedIncrement(&m_cRef);
	}

	void Release()
	{
		if (0 == InterlockedDecrement(&m_cRef))
			delete this;
	}
};


//	========================================================================
//
//	TEMPLATE FUNCTION QI_cast
//
//		QI directly into an auto_com_ptr.
//
//		Queries for the given IID on the punk provided.
//		Returns NULL if failure.
//		Usage:
//			auto_com_ptr<INew> punkNew;
//			punkNew = QI_cast<INew, &IID_INew>( punkOld );
//			if (!punkNew)
//			{	// error handling	}
//
//$LATER: Fix this func (and all invocations!) to NOT return an auto_com_ptr!
//
template<class I, const IID * piid>
auto_com_ptr<I>
QI_cast( IUnknown * punk )
{
	I * p;
	punk->QueryInterface( *piid, (LPVOID *) &p );
	return auto_com_ptr<I>( p );
}

#include <safeobj.h>

#endif // _AUTOPTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\buffer.h ===
/*
 *	B U F F E R . H
 *
 *	Data buffer processing
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_BUFFER_H_
#define _BUFFER_H_

#ifdef _DAVCDATA_
#error "buffer.h uses throwing allocators"
#endif

//	Include the non-safe/throwing allocators
#include <mem.h>

//	Include safe buffer definition header
//
#include <ex\buffer.h>

//	AppendChainedSz -----------------------------------------------------------
//
inline LPCWSTR AppendChainedSz (ChainedStringBuffer<WCHAR>& sb, LPCWSTR pwsz)
{
	return sb.AppendWithNull (pwsz);
}

#endif // _BUFFER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\body.h ===
#ifndef _BODY_H_
#define _BODY_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	BODY.H
//
//		Common implementation classes from which request body and
//		response body are derived.
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include <sgstruct.h>
#include <limits.h>		// definition of LONG_MIN
#include <ex\refcnt.h>	// IRefCounted
#include <ex\astream.h>	// Async stream interfaces
#include <ex\refhandle.h> // auto_ref_handle, etc.


//	========================================================================
//
//	CLASS IAsyncPersistObserver
//
//	Async I/O completion callback object interface used by
//	IBody::AsyncPersist().  Callers of AsyncPersist() must pass an object
//	conforming to this interface.  That object will be notified when
//	the async persist operation completes via a call to its
//	PersistComplete() member function.
//
class IAsyncPersistObserver : public IRefCounted
{
	//	NOT IMPLEMENTED
	//
	IAsyncPersistObserver& operator=( const IAsyncPersistObserver& );

public:
	//	CREATORS
	//
	virtual ~IAsyncPersistObserver() = 0;

	//	MANIPULATORS
	//
	virtual VOID PersistComplete( HRESULT hr ) = 0;
};


//	========================================================================
//
//	CLASS IAcceptObserver
//
//	Passed to the IBody::Accept() and IBodyPartAccept() methods when
//	accepting a body part visitor.  The accept observer is called whenever
//	the accept operation completes (which may happen asynchronously).
//	Note that the body part visitor is often the accept observer itself,
//	but it doesn't have to be.  The accept code which notifies the observer
//	is not aware that it is notifying a visitor.
//
class IAcceptObserver
{
	//	NOT IMPLEMENTED
	//
	IAcceptObserver& operator=( const IAcceptObserver& );

public:
	//	CREATORS
	//
	virtual ~IAcceptObserver() = 0;

	//	MANIPULATORS
	//
	virtual VOID AcceptComplete( UINT64 cbAccepted64 ) = 0;
};


//	========================================================================
//
//	CLASS CAsyncDriver
//
//	Implements a mechanism to allow an object to be driven asynchronously
//	from any one thread at a time.
//
template<class X>
class CAsyncDriver
{
	//
	//	Number of calls to Run() that will be made before
	//	the object requires another call to Start() to
	//	get it going again.  Each call to Start() increments
	//	this count by one.  The count is decremented by
	//	one as each Run() completes.
	//
	LONG m_lcRunCount;

	//	NOT IMPLEMENTED
	//
	CAsyncDriver( const CAsyncDriver& );
	CAsyncDriver& operator=( const CAsyncDriver& );

public:
	//	CREATORS
	//
	CAsyncDriver() : m_lcRunCount(0) {}
#ifdef DBG
	~CAsyncDriver() { m_lcRunCount = LONG_MIN; }
#endif

	//	MANIPULATORS
	//
	VOID Start(X& x)
	{
		//
		//	The object's Run() implementation often allows the final ref
		//	on the object to be released.  And this CAsyncDriver is often
		//	a member of that object.  Therefore, we need to AddRef() the
		//	object to keep ourselves alive until we return from this
		//	function.  It's kinda strange, but the alternative is to
		//	require callers to AddRef() the object themselves, but that
		//	approach would be more prone to error.
		//
		auto_ref_ptr<X> px(&x);

		AssertSz( m_lcRunCount >= 0, "CAsyncDriver::Start() called on destroyed/bad CAsyncDriver!" );

		//
		//	Start/Restart/Continue the driver
		//
		if ( InterlockedIncrement( &m_lcRunCount ) == 1 )
		{
			do
			{
				x.Run();
			}
			while ( InterlockedDecrement( &m_lcRunCount ) > 0 );
		}
	}
};


//	========================================================================
//
//	CLASS IBodyPart
//
//	Defines the interface to a body part.  An IBodyPart object is assumed
//	to consist of the body part data and an internal iterator over that
//	data.
//
//	An IBodyPart must implement the following methods:
//
//	CbSize()
//		Returns the size (in bytes) of the body part.  Necessary for
//		computation of a part's contribution to the content length.
//
//	Rewind()
//		Prepares the body part to be traversed again by new visitor.
//
//	Accept()
//		Accepts a body part visitor object to iterate over the body part.
//		The accept operation may be asynchronous either because the
//		body part chooses to implement it that way, or because the accepted
//		visitor requires it.  For this reason, an accept observer is
//		also used.  This observer should be called whenever the
//		accept operation completes.
//
class IBodyPart
{
	//	NOT IMPLEMENTED
	//
	IBodyPart& operator=( const IBodyPart& );

public:
	//	CREATORS
	//
	virtual ~IBodyPart() = 0;

	//	ACCESSORS
	//
	virtual UINT64 CbSize64() const = 0;

	//	MANIPULATORS
	//
	virtual VOID Accept( IBodyPartVisitor& v,
						 UINT64 ibPos64,
						 IAcceptObserver& obsAccept ) = 0;

	virtual VOID Rewind() = 0;
};


//	========================================================================
//
//	CLASS IBodyPartVisitor
//
//	Defines an interface for an object used to access body part data.
//	A body part visitor handles three types of data: in-memory bytes (text),
//	files, and streams (via IAsyncStream).  What the visitor does with that
//	data and how it does it is not specified; the behavior is provided by
//	the visitor itself.  The IBodyPartVisitor interface just standardizes
//	things to provide for asynchronous iteration over the entire body
//	without the need for custom asynchronous iteration code everywhere.
//
//	A body part visitor may implement any of its VisitXXX() methods
//	as asynchronous operations.  Regardless, the visitor must call
//	VisitComplete() on the visitor observer passed to it whenever
//	the visit operation completes.
//
//	When visiting body part data in one of the VisitXXX() methods,
//	a visitor does not have to visit (i.e. buffer) ALL of the data
//	before calling IAcceptObserver::AcceptComplete().  It can just
//	call AcceptComplete() with the number of bytes that can actually
//	be accepted.
//
class IAsyncStream;
class IBodyPartVisitor
{
	//	NOT IMPLEMENTED
	//
	IBodyPartVisitor& operator=( const IBodyPartVisitor& );

public:
	//	CREATORS
	//
	virtual ~IBodyPartVisitor() = 0;

	//	MANIPULATORS
	//
	virtual VOID VisitBytes( const BYTE * pbData,
							 UINT cbToVisit,
							 IAcceptObserver& obsAccept ) = 0;

	virtual VOID VisitFile( const auto_ref_handle& hf,
							UINT64 ibOffset64,
							UINT64 cbToVisit64,
							IAcceptObserver& obsAccept ) = 0;

	virtual VOID VisitStream( IAsyncStream& stm,
							  UINT cbToVisit,
							  IAcceptObserver& obsAccept ) = 0;

	virtual VOID VisitComplete() = 0;
};


//	========================================================================
//
//	CLASS IBody
//
//	Common request/response body interface
//
class IAsyncStream;
class IBody
{
	//	NOT IMPLEMENTED
	//
	IBody& operator=( const IBody& );

public:
	//	========================================================================
	//
	//	CLASS iterator
	//
	class iterator
	{
		//	NOT IMPLEMENTED
		//
		iterator& operator=( const iterator& );

	public:
		//	CREATORS
		//
		virtual ~iterator() = 0;

		//	MANIPULATORS
		//
		virtual VOID Accept( IBodyPartVisitor& v,
							 IAcceptObserver& obs ) = 0;

		virtual VOID Prune() = 0;
	};

	//	CREATORS
	//
	virtual ~IBody() = 0;

	//	ACCESSORS
	//
	virtual BOOL FIsEmpty() const = 0;
	virtual UINT64 CbSize64() const = 0;

	//	MANIPULATORS
	//
	virtual VOID Clear() = 0;
	virtual VOID AddText( LPCSTR lpszText, UINT cbText ) = 0;
	VOID AddText( LPCSTR lpszText ) { AddText(lpszText, static_cast<UINT>(strlen(lpszText))); }
	virtual VOID AddFile( const auto_ref_handle& hf,
						  UINT64 ibFile64,
						  UINT64 cbFile64 ) = 0;
	virtual VOID AddStream( IStream& stm ) = 0;
	virtual VOID AddStream( IStream& stm, UINT ibOffset, UINT cbSize ) = 0;
	virtual VOID AddBodyPart( IBodyPart * pBodyPart ) = 0;

	virtual VOID AsyncPersist( IAsyncStream& stm,
							   IAsyncPersistObserver& obs ) = 0;

	virtual IStream * GetIStream( IAsyncIStreamObserver& obs ) = 0;
	virtual iterator * GetIter() = 0;
};

IBody * NewBody();

//	========================================================================
//
//	CLASS CFileBodyPart
//
//	Represents a file body part.  A file body part is a part whose content
//	can be accessed with the standard Win32 APIs ReadFile() and TransmitFile().
//
//	Note: File body parts using this implementation must be no longer
//	than ULONG_MAX bytes!
//
class CFileBodyPart : public IBodyPart
{
	//	The file handle
	//
	auto_ref_handle m_hf;

	//	Starting offset into the file
	//
	UINT64 m_ibFile64;

	//	Size of the content
	//
	UINT64 m_cbFile64;

	//	NOT IMPLEMENTED
	//
	CFileBodyPart( const CFileBodyPart& );
	CFileBodyPart& operator=( const CFileBodyPart& );

public:
	//	CREATORS
	//
	CFileBodyPart( const auto_ref_handle& hf,
				   UINT64 ibFile64,
				   UINT64 cbFile64 );


	//	ACCESSORS
	//
	UINT64 CbSize64() const { return m_cbFile64; }

	//	MANIPULATORS
	//
	VOID Rewind();

	VOID Accept( IBodyPartVisitor& v,
				 UINT64 ibPos64,
				 IAcceptObserver& obsAccept );
};

//	========================================================================
//
//	CLASS CTextBodyPart
//
class CTextBodyPart : public IBodyPart
{
	//	String buffer to hold the text
	//
	StringBuffer<char>	m_bufText;

	//	NOT IMPLEMENTED
	//
	CTextBodyPart( const CTextBodyPart& );
	CTextBodyPart& operator=( const CTextBodyPart& );

public:

	//	AddTextBytes()
	//
	//	NOTE: this method was added for XML emitting.
	//	In that scenaro, an XML response is composed of
	//	many -- potentially thousands -- of calls to add
	//	response bytes.  If we strictly went and used the
	//	CMethUtil methods to ::AddResponseText(), we would
	//	end up with many -- potentially thousands -- of body
	//	parts.  So, the upshot here is that performance of
	//	such a mechanism would suck.
	//
	//	By adding the method -- and moving the declaration of
	//	this class to a publicly available header, we can now
	//	create a text body part as a component of the emitting
	//	process, and pour our data into body part directly.
	//	Once the content is complete, we can then simply add
	//	the body part.
	//
	VOID AddTextBytes ( UINT cbText, LPCSTR lpszText );

	//	CREATORS
	//
	CTextBodyPart( UINT cbText, LPCSTR lpszText );

	//	ACCESSORS
	//
	UINT64 CbSize64() const { return m_bufText.CbSize(); }

	//	MANIPULATORS
	//
	VOID Rewind();

	VOID Accept( IBodyPartVisitor& v,
				 UINT64 ibPos64,
				 IAcceptObserver& obsAccept );
};


#endif // !defined(_BODY_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\calpc.h ===
/*
 *	C A L P C . H
 *
 *	PerfCounter data headers
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef _CALPC_H_
#define _CALPC_H_

#include <winperf.h>

//	Extensible Object definitions ---------------------------------------------
//
//	Update the following sort of define when adding an object type.
//
#define NUM_PERF_OBJECT_TYPES 1
typedef enum {

	PC_TOTALREQUESTS = 0,
	PC_NUMCURRENTREQUESTS,
	PC_NUMWORKERTHREADS,
	PC_NUMACTIVEWORKERTHREADS,
	PC_CURRENTLOCKS,
	PC_REQ_FORWARDS,
	PC_REQ_REDIRECTS,
	PC_EXCEPTIONS,
	CPC_COUNTERS

} PERFCOUNTER;

typedef enum {

	PCI_PERFMON = -1,
	PCI_TOTALS = 0,
	PCI_DAVFS,
	PCI_DAVOWS,
	PCI_DAVEX,
	CPC_INSTANCES

} PERFCOUNTERINSTANCE;

enum { CCH_MAX_INSTANCE_NAME = (sizeof(L"PERFMON") * sizeof(WCHAR)) };

//	Resource object type counter definitions.
//
//	This is the counter structure presently returned by the performance DLL.
//
#pragma pack(4)
typedef struct _PERFDLL_DATA_DEFINITION
{
	PERF_OBJECT_TYPE		potObjectType;
	PERF_COUNTER_DEFINITION	rgpcdCounters[CPC_COUNTERS];

} PERFDLL_DATA_DEFINITION;
#pragma pack()

//	This is the block of data that corresponds to each instance of
//	the object. This structure will immediately follow the instance
//	definition data structure.
//
#pragma pack(4)
typedef struct _PERFDLL_COUNTER_BLOCK
{
	PERF_COUNTER_BLOCK	pcbCounterBlock;
	LONG				rgdwCounters[CPC_COUNTERS];
	LONG				lActive;

} PERFDLL_COUNTER_BLOCK, * PPERFDLL_COUNTER_BLOCK;
#pragma pack()

enum { CB_PERF_COUNTER_MEMORY = (sizeof(PERFDLL_COUNTER_BLOCK) * CPC_INSTANCES) };

#ifdef __cplusplus
extern "C" {
#endif

SCODE __cdecl ScOpenPerfCounters (PERFCOUNTERINSTANCE ipc);
VOID __cdecl ClosePerfCounters (VOID);

extern PERFDLL_DATA_DEFINITION g_PerfDllDataDefinition;
extern PPERFDLL_COUNTER_BLOCK g_pcntrblk;
extern LPVOID g_pvcntrblk;

#ifdef __cplusplus
}
#endif

#define PERFDLL_COUNTER_BLOCK_NAME		L"CALIGULA_PERFORMANCE_DATA"
#define PERFDLL_COUNTER_MUTEX_NAME		L"CALIGULA_PERFORMANCE_DATA_MUTEX"

__inline void IncrementPerfCounter(PERFCOUNTER _x)
{
	InterlockedIncrement(&g_pcntrblk->rgdwCounters[_x]);
}
__inline void DecrementPerfCounter(PERFCOUNTER _x)
{
	InterlockedDecrement(&g_pcntrblk->rgdwCounters[_x]);
}
__inline void ResetPerfCounter(PERFCOUNTER _x)
{
	InterlockedExchange(&g_pcntrblk->rgdwCounters[_x], 0);
}

#endif	//	_CALPC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\caldbg.h ===
/*
 *	C A L D B G . H
 *
 *	Debugging support header
 *	Support functions are implemented in CALDBG.C.
 *
 *	Copyright 1986-1997 Microsoft Corporation. All Rights Reserved.
 */

#ifndef _CALDBG_H_
#define _CALDBG_H_

#include <malloc.h>

/*
 * Debugging Macros -------------------------------------------------------
 *
 *		IFDBG(x)		Results in the expression x if DBG is defined, or
 *						to nothing if DBG is not defined
 *
 *		IFNDBG(x)		Results in the expression x if DBG is not defined,
 *						or to nothing if DBG is defined
 *
 *		Unreferenced(a) Causes a to be referenced so that the compiler
 *						doesn't issue warnings about unused local variables
 *						which exist but are reserved for future use (eg
 *						ulFlags in many cases)
 */
#if defined(DBG)
#define IFDBG(x)			x
#define IFNDBG(x)
#else
#define IFDBG(x)
#define IFNDBG(x)			x
#endif

#ifdef __cplusplus
#define EXTERN_C_BEGIN		extern "C" {
#define EXTERN_C_END		}
#else
#define EXTERN_C_BEGIN
#define EXTERN_C_END
#endif

/*
 *	 Assert Macros ------------------------------------------------------------
 *
 *		Assert(a)		Displays a message indicating the file and line number
 *						of this Assert() if a == 0.	 OK'ing an assert traps
 *						into the debugger.
 *
 *		AssertSz(a,sz)	Works like an Assert(), but displays the string sz
 *						along with the file and line number.
 *
 *		Side asserts	A side assert works like an Assert(), but evaluates
 *						'a' even when asserts are not enabled.
 */
#if defined(DBG) || defined(ASSERTS_ENABLED)
#define IFTRAP(x)			x
#else
#define IFTRAP(x)			0
#endif

#define Trap()						IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,"Trap"))
#define TrapSz(psz)					IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz))

#define Assert(t)					IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,"Assertion Failure: " #t),0))
#define AssertSz(t,psz)				IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz),0))

#define SideAssert(t)				((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,"Assertion Failure: " #t)),0)
#define SideAssertSz(t,psz)			((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz)),0)


/*
 *	 Trace Macros -------------------------------------------------------------
 *
 *		DebugTrace			Use for arbitrary formatted output. It
 *							takes exactly the same arguments as the
 *							Windows wsprintf() function.
 *		DebugTraceNoCRLF	Same as DebugTrace, but doesn't add "\r\n".
 *							Good for writing a trace that is part of a longer line.
 *		TraceError			DebugTrace the function name (_func, any string)
 *							INI file entries allow you to filter based on the
 *							error code's failing/succeeding status.
 */

#if defined(DBG) || defined(TRACES_ENABLED)
#define IFTRACE(x)			x
#define DebugTrace			DebugTraceFn
#define DebugTraceCRLF		DebugTraceCRLFFn
#define DebugTraceNoCRLF	DebugTraceNoCRLFFn
#define TraceErrorEx(_err,_func,_flag)	TraceErrorFn(_err,_func,__FILE__,__LINE__,_flag)
#define TraceError(_err,_func)			TraceErrorEx(_err,_func,FALSE)
#else
#define IFTRACE(x)			0
#define DebugTrace			NOP_FUNCTION
#define DebugTraceCRLF		NOP_FUNCTION
#define DebugTraceNoCRLF	NOP_FUNCTION
#define TraceErrorEx(_err,_func,_flag)	NOP_FUNCTION
#define TraceError(_err,_func)			TraceErrorEx(_err,_func,FALSE)
#endif

/*	------------------------------------------------------------------------
 *
 *	.INI triggered traces
 */

#ifdef DBG
#define DEFINE_TRACE(trace)		__declspec(selectany) int g_fTrace##trace = FALSE
#define DO_TRACE(trace)			!g_fTrace##trace ? 0 : DebugTraceFn
#define INIT_TRACE(trace)		g_fTrace##trace = GetPrivateProfileInt( gc_szDbgTraces, #trace, FALSE, gc_szDbgIni )
//	Convenience macro for DBG code.  Will cause an error on non-debug builds.
#define DEBUG_TRACE_TEST(trace)	g_fTrace##trace
#else
#define DEFINE_TRACE(trace)
#define DO_TRACE(trace)			DebugTrace
#define INIT_TRACE(trace)
//#define DEBUG_TRACETEST(trace)	// Purposefully cause an error on non-debug builds
#endif

/* Debugging Functions ---------------------------------------------------- */

#define EXPORTDBG

EXTERN_C_BEGIN

INT EXPORTDBG __cdecl DebugTrapFn (int fFatal, char *pszFile, int iLine, char *pszFormat, ...);
INT EXPORTDBG __cdecl DebugTraceFn (char *pszFormat, ...);
INT EXPORTDBG __cdecl DebugTraceCRLFFn (char *pszFormat, ...);
INT EXPORTDBG __cdecl DebugTraceNoCRLFFn (char *pszFormat, ...);
INT EXPORTDBG __cdecl TraceErrorFn (DWORD error, char *pszFunction,
									char *pszFile, int iLine,
									BOOL fEcTypeError);

EXTERN_C_END

/* Debugging Strings ------------------------------------------------------ */

EXTERN_C_BEGIN

//	Inifile name -- must be set by calling code!
extern const CHAR gc_szDbgIni[];
extern const INT gc_cchDbgIni;

//	Strings set in caldbg.c for use in calling code.
extern const CHAR gc_szDbgDebugTrace[];
extern const CHAR gc_szDbgEventLog[];
extern const CHAR gc_szDbgGeneral[];
extern const CHAR gc_szDbgLogFile[];
extern const CHAR gc_szDbgTraces[];
extern const CHAR gc_szDbgUseVirtual[];

EXTERN_C_END

/* Virtual Allocations ---------------------------------------------------- */

EXTERN_C_BEGIN

VOID * EXPORTDBG __cdecl VMAlloc(ULONG);
VOID * EXPORTDBG __cdecl VMAllocEx(ULONG, ULONG);
VOID * EXPORTDBG __cdecl VMRealloc(VOID *, ULONG);
VOID * EXPORTDBG __cdecl VMReallocEx(VOID *, ULONG, ULONG);
ULONG EXPORTDBG __cdecl VMGetSize(VOID *);
ULONG EXPORTDBG __cdecl VMGetSizeEx(VOID *, ULONG);
VOID EXPORTDBG __cdecl VMFree(VOID *);
VOID EXPORTDBG __cdecl VMFreeEx(VOID *, ULONG);

EXTERN_C_END

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\calrc.h ===
/*
 *	C A L R C . H
 *
 *	Resource tracking header
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef _CALRC_H_
#define _CALRC_H_

#endif	//	_CALRC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\crc.h ===
/*
 *	C R C . H
 *
 *	CRC Implementation
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_CRC_H_
#define _CRC_H_
#ifdef __cplusplus
extern "C" {
#endif

//	Table used for CRC calculation
//
extern const DWORD g_rgdwCRC[256];

//	Basic CRC function
//
DWORD DwComputeCRC (DWORD dwCRC, PVOID pv, UINT cb);

//	Basic CRC iteration -- for use where DwComputeCRC is insufficient
//
#define CRC_COMPUTE(_crc,_ch)	(g_rgdwCRC[((_crc) ^ (_ch)) & 0xff] ^ ((_crc) >> 8))

#ifdef __cplusplus
}

//	CRC'd string classes
//
#include <crcsz.h>

#endif	// __cplusplus
#endif	// _CRC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\crcsz.h ===
/*
 *	C R C S Z . H
 *
 *	CRC Implementation
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_CRCSZ_H_
#define _CRCSZ_H_

//	Case Sensitive CRC'd string classes ---------------------------------------
//
//	Encapsulation of a CRC'ed string.  Use this class as the key type for
//	your cache class where a string key is called for.  The benefit is
//	increased cache search performance because a full string compare
//	is done only when the CRCs match (which typically happens only
//	for the string you're looking for).
//
class CRCSz
{
public:

	DWORD	m_dwCRC;
	LPCSTR	m_lpsz;

	CRCSz(LPCSTR psz) :
		m_lpsz(psz),
		m_dwCRC(DwComputeCRC(0,
							 const_cast<CHAR *>(psz),
							 static_cast<UINT>(strlen(psz))))
	{
	}

	//	operators for use with the hash cache
	//
	int hash( const int rhs ) const
	{
		return (m_dwCRC % rhs);
	}

	bool isequal( const CRCSz& rhs ) const
	{
		return ((m_dwCRC == rhs.m_dwCRC) &&
				!strcmp( m_lpsz, rhs.m_lpsz ));
	}
};

class CRCWszN
{
public:

	UINT		m_cch;
	DWORD		m_dwCRC;
	LPCWSTR		m_pwsz;

	CRCWszN(LPCWSTR pwsz, UINT cch) :
		m_cch(cch),
		m_pwsz(pwsz),
		m_dwCRC(DwComputeCRC (0,
							  const_cast<WCHAR *>(pwsz),
							  cch * sizeof(WCHAR)))
	{
	}

	//	operators for use with the hash cache
	//
	int hash( const int rhs ) const
	{
		return (m_dwCRC % rhs);
	}
	bool isequal( const CRCWszN& rhs ) const
	{
		return ((m_cch == rhs.m_cch) &&
				(m_dwCRC == rhs.m_dwCRC) &&
				!wcsncmp( m_pwsz, rhs.m_pwsz, m_cch ));
	}
};

class CRCWsz : public CRCWszN
{
	//	Not Implemented
	//
	CRCWsz();

public:

	CRCWsz(LPCWSTR pwsz) :
		CRCWszN(pwsz, static_cast<UINT>(wcslen(pwsz)))
	{
	}

	CRCWsz( const CRCWszN& rhs ) :
		CRCWszN (rhs)
	{
	}
};


//	Case Insensitive CRC'd string classes -------------------------------------
//
//	Encapsulation of a CRC'ed string.  Use this class as the key type for
//	your cache class where a string key is called for.  The benefit is
//	increased cache search performance because a full string compare
//	is done only when the CRCs match (which typically happens only
//	for the string you're looking for).
//
class CRCSzi
{
public:

	DWORD	m_dwCRC;
	LPCSTR	m_lpsz;

	CRCSzi( LPCSTR lpsz ) :
		m_lpsz(lpsz)
	{
		UINT cch = static_cast<UINT>(strlen(lpsz));
		CHAR lpszLower[128];

		//	Note that the CRC only is taken from the first 127 characters.
		//
		cch = (UINT)min(cch, sizeof(lpszLower) - 1);
		CopyMemory(lpszLower, lpsz, cch);
		lpszLower[cch] = 0;
		_strlwr(lpszLower);

		m_dwCRC = DwComputeCRC (0, const_cast<CHAR *>(lpszLower), cch);
	}

	//	operators for use with the hash cache
	//
	int hash( const int rhs ) const
	{
		return (m_dwCRC % rhs);
	}
	bool isequal( const CRCSzi& rhs ) const
	{
		return ((m_dwCRC == rhs.m_dwCRC) &&
				!lstrcmpiA( m_lpsz, rhs.m_lpsz ));
	}
};

class CRCWsziN
{
public:

	UINT		m_cch;
	DWORD		m_dwCRC;
	LPCWSTR		m_pwsz;

	CRCWsziN() :
			m_cch(0),
			m_dwCRC(0),
			m_pwsz(NULL)
	{}
	
	CRCWsziN(LPCWSTR pwsz, UINT cch) :
		m_cch(cch),
		m_pwsz(pwsz)
	{
		//	Note that the CRC only is taken from the first 127 characters.
		//
		WCHAR pwszLower[128];
		UINT cb = sizeof(WCHAR) * min(cch, (sizeof(pwszLower)/sizeof(WCHAR)) - 1);
		
		CopyMemory(pwszLower, pwsz, cb);
        pwszLower[cb / sizeof(WCHAR)] = L'\0';
		_wcslwr(pwszLower);

		m_dwCRC = DwComputeCRC (0, const_cast<WCHAR *>(pwszLower), cb);
	}

	//	operators for use with the hash cache
	//
	int hash( const int rhs ) const
	{
		return (m_dwCRC % rhs);
	}
	bool isequal( const CRCWsziN& rhs ) const
	{
		return ((m_cch == rhs.m_cch) &&
				(m_dwCRC == rhs.m_dwCRC) &&
				!_wcsnicmp( m_pwsz, rhs.m_pwsz, m_cch ));
	}
};

class CRCWszi : public CRCWsziN
{
public:
	CRCWszi()
	{}

	CRCWszi( LPCWSTR pwsz ) :
		CRCWsziN (pwsz, static_cast<UINT>(wcslen(pwsz)))
	{
	}

	//	operators for use with list::sort
	//
	bool operator<( const CRCWszi& rhs ) const
	{
		INT lret = 1;

		if (m_dwCRC < rhs.m_dwCRC)
			return true;

		if (m_dwCRC == rhs.m_dwCRC)
		{
			lret = _wcsnicmp(m_pwsz,
							 rhs.m_pwsz,
							 min(m_cch, rhs.m_cch));
		}
		return (lret ? (lret < 0) : (m_cch < rhs.m_cch));
	}

	//	operators for use with list::unique
	//
	bool operator==( const CRCWszi& rhs ) const
	{
		return isequal(rhs);
	}
};

class CRCWsziLI : public CRCWszi
{
public:

	LARGE_INTEGER m_li;
	bool m_fFullCompare;
	
	CRCWsziLI( LPCWSTR pwsz, LARGE_INTEGER li, bool fFullCompare ) :
		CRCWszi (pwsz),
		m_li(li),
		m_fFullCompare(fFullCompare)
	{
	}

	bool isequal( const CRCWsziLI& rhs ) const
	{
		bool fIsEqual;
		fIsEqual = CRCWszi::isequal(rhs);
		if (fIsEqual)
		{
			if (m_fFullCompare)
			{
				fIsEqual = (m_li.QuadPart == rhs.m_li.QuadPart);
			}
		}

		return fIsEqual;
	}
};

#endif	// _CRCSZ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\davsc.h ===
/*
 *	D A V S C . H
 *
 *	Extended error codes for DAV
 *
 *	These error codes should be designed/implemented in such a way as to
 *	provide better error code translations for returns to the client.
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#pragma once
#ifndef _DAVSC_H_
#define _DAVSC_H_

#define FACILITY_DAV		21
#define DAV_SCODE(_ids)		MAKE_SCODE(SEVERITY_ERROR,FACILITY_DAV,_ids)
#define DAV_WARNING(_ids)	MAKE_SCODE(SEVERITY_SUCCESS,FACILITY_DAV,_ids)

//	Core and/or common error codes range from 0x100-0x800
//	DAV Exchange reserves 0x001-0x0FF for IIS component errors
//	and 0x800-0xFFFF for server component errors.
//
#define E_DAV_NO_DESTINATION						DAV_SCODE(0x100)
#define E_DAV_BAD_DESTINATION						DAV_SCODE(0x101)
#define E_DAV_MALFORMED_PATH						DAV_SCODE(0x102)
#define E_DAV_CONFLICTING_PATHS						DAV_SCODE(0x103)
#define E_DAV_INVALID_HEADER						DAV_SCODE(0x104)
#define E_DAV_NO_IIS_ACCESS_RIGHTS					DAV_SCODE(0x105)
#define E_DAV_LOCKED								DAV_SCODE(0x106)
#define E_DAV_PROTECTED_ENTITY						DAV_SCODE(0x107)
#define E_DAV_NONEXISTING_PARENT					DAV_SCODE(0x108)
#define E_DAV_MISSING_LENGTH						DAV_SCODE(0x109)
#define E_DAV_ENTITY_NOT_LOCKED						DAV_SCODE(0x10A)
#define E_DAV_ENTITY_TYPE_CONFLICT					DAV_SCODE(0x10B)
#define E_DAV_ENTITY_NOT_MODIFIED					DAV_SCODE(0x10C)
#define E_DAV_IF_HEADER_FAILURE						DAV_SCODE(0x10D)
#define E_DAV_UNKNOWN_CONTENT						DAV_SCODE(0x10E)
#define E_DAV_RANGE_NOT_SATISFIABLE					DAV_SCODE(0x10F)
#define E_DAV_NO_PARTIAL_UPDATE						DAV_SCODE(0x110)
#define E_DAV_LOCK_NOT_FOUND						DAV_SCODE(0x111)
#define E_DAV_VOLUME_NOT_NTFS						DAV_SCODE(0x112)
#define E_DAV_PROPFIND_TYPE_UNEXPECTED				DAV_SCODE(0x113)
#define E_DAV_EMPTY_PATCH_REQUEST					DAV_SCODE(0x114)
#define E_DAV_EMPTY_FIND_REQUEST					DAV_SCODE(0x115)
#define E_DAV_PATCH_TYPE_MISMATCH					DAV_SCODE(0x116)
#define E_DAV_RESPONSE_TYPE_UNACCEPTED				DAV_SCODE(0x117)
#define E_DAV_BASE64_ENCODING_ERROR					DAV_SCODE(0x118)
#define E_DAV_METHOD_FORWARDED						DAV_SCODE(0x119)
#define E_DAV_READ_REQUEST_TIMEOUT					DAV_SCODE(0x11A)
#define E_DAV_INCOMPLETE_SQL_STATEMENT				DAV_SCODE(0x11B)
#define E_DAV_XML_PARSE_ERROR						DAV_SCODE(0x11C)
#define E_DAV_SMB_PROPERTY_ERROR					DAV_SCODE(0x11D)
#define E_DAV_OVERWRITE_REQUIRED					DAV_SCODE(0x11E)
#define E_DAV_NO_QUERY								DAV_SCODE(0x11F)
#define E_DAV_NAMED_PROPERTY_ERROR					DAV_SCODE(0x120)
#define E_DAV_UNEXPECTED_TYPE						DAV_SCODE(0x121)
#define E_DAV_COLLECTION_EXISTS						DAV_SCODE(0x122)
#define E_DAV_XML_DOM_ERROR							DAV_SCODE(0x123)
#define E_DAV_ROW_PACKING_ERROR						DAV_SCODE(0x124)
#define E_DAV_COLUMN_VALUE_NOT_FOUND				DAV_SCODE(0x125)
#define E_DAV_IPC_CONNECT_FAILED					DAV_SCODE(0x126)
#define E_DAV_IPC_ALLOC_FAILED						DAV_SCODE(0x127)
#define E_DAV_IPC_SEND_FAILED						DAV_SCODE(0x128)
#define E_DAV_IPC_REC_FAILED						DAV_SCODE(0x129)
#define E_DAV_IPC_IMPERSONATION_ERR					DAV_SCODE(0x12A)
#define E_DAV_INVALID_URI							DAV_SCODE(0x12B)
#define E_DAV_MISSING_CONTENT_TYPE					DAV_SCODE(0x12C)
#define E_DAV_IPC_CREATE_EVENT_FAIL					DAV_SCODE(0x12D)
#define E_DAV_REDIRECT_FAILED						DAV_SCODE(0x12E)
#define E_DAV_SHORT_FILENAME						DAV_SCODE(0x12F)
#define E_DAV_ALT_FILESTREAM						DAV_SCODE(0x130)
#define E_DAV_RESPONSE_INCOMPLETE					DAV_SCODE(0x131)
#define E_DAV_STAR_SCRIPTMAPING_MISMATCH			DAV_SCODE(0x132)
#define E_DAV_NO_IIS_READ_ACCESS					DAV_SCODE(0x133)
#define E_DAV_NO_IIS_WRITE_ACCESS					DAV_SCODE(0x134)
#define E_DAV_NO_IIS_EXECUTE_ACCESS					DAV_SCODE(0x135)
#define E_DAV_NO_ACL_ACCESS							DAV_SCODE(0x136)
#define E_DAV_METHOD_FAILURE_STAR_URL				DAV_SCODE(0x137)
#define E_DAV_SEARCH_SCOPE_ERROR					DAV_SCODE(0x138)
#define E_DAV_CANT_SATISFY_LOCK_REQUEST				DAV_SCODE(0x139)
#define E_DAV_CANT_PERSIST_SEARCH					DAV_SCODE(0x13A)
#define E_DAV_CANT_QUERY_ROWS						DAV_SCODE(0x13B)
#define E_DAV_CANT_MAKE_DBCOMMANDTREE				DAV_SCODE(0x13C)
#define E_DAV_UNSUPPORTED_SQL						DAV_SCODE(0x13D)
#define E_DAV_CANT_SEEK_ROW							DAV_SCODE(0x13E)
#define E_DAV_CANT_QUERY_POSITION					DAV_SCODE(0x13F)
#define E_DAV_EXPROX_CONNECT_FAILED					DAV_SCODE(0x140)
#define E_DAV_TRANSACTION_CACHE						DAV_SCODE(0x141)
#define E_DAV_NOTALLOWED_WITHIN_TRANSACTION			DAV_SCODE(0x142)
#define E_DAV_VIEW_NOT_FOUND						DAV_SCODE(0x143)
#define E_DAV_RSRC_NOT_FOUND						DAV_SCODE(0x144)
#define E_DAV_RSRC_INSUFFICIENT_BUFFER				DAV_SCODE(0x145)
#define E_DAV_FORBIDDEN								DAV_SCODE(0x146)
#define E_DAV_CONFLICT								DAV_SCODE(0x147)
#define E_DAV_INVALID_PROPERTY_NAME					DAV_SCODE(0x148)
#define E_DAV_HIDDEN_OBJECT							DAV_SCODE(0x149)
#define	E_DAV_FORMS_HANDLER							DAV_SCODE(0x14A)
#define E_DAV_XML_BAD_DATA							DAV_SCODE(0x14B)
//unused											DAV_SCODE(0x14C)
#define E_DAV_NATIVE_CONTENT_NOT_MAPI				DAV_SCODE(0x14D)


//	Special error to mark properties for which we have property streams open,
//	for seafety reasons do not use for anything else
//
#define E_DAV_USE_PROPERTY_STREAM					DAV_SCODE(0x14E)
#define E_DAV_PARTIAL_COLUMN						DAV_SCODE(0x14F)

//  Error code used by exprox exception handler code
//
#define E_DAV_EXPROX_THREW_EXCEPTION                DAV_SCODE(0x150)

#define E_DAV_MAIL_SUBMISSION_FORBIDDEN				DAV_SCODE(0x600)
#define E_DAV_MKCOL_REVISION_ID_FORBIDDEN			DAV_SCODE(0x601)
#define E_DAV_MKCOL_NOT_ALLOWED_ON_NULL_RESOURCE	DAV_SCODE(0x602)
#define	E_DAV_MKCOL_OBJECT_ALREADY_EXISTS			DAV_SCODE(0x603)
#define E_DAV_GET_DB_HELPER_FAILURE					DAV_SCODE(0x604)
#define E_DAV_NOTIF_SUBID_ERROR						DAV_SCODE(0x605)
#define E_DAV_NOTIF_POLL_FAILURE					DAV_SCODE(0x606)

#define W_DAV_RESPONSE_ALREADY_SENT					DAV_WARNING(0x7EF)
#define W_DAV_NOSAVECHANGESREQUIRED					DAV_WARNING(0x7F0)
#define W_DAV_NO_TARGETS							DAV_WARNING(0x7F1)
#define W_DAV_RELATIVE_URI							DAV_WARNING(0x7F2)
#define W_DAV_MOVED_TEMPORARILY						DAV_WARNING(0x7F3)
#define W_DAV_ESCAPED_SQL_TOKEN						DAV_WARNING(0x7F4)
#define W_DAV_NULL_RESOURCE							DAV_WARNING(0x7F5)
#define W_DAV_SEARCH_PENDING						DAV_WARNING(0x7F6)
#define W_DAV_SPANS_VIRTUAL_ROOTS					DAV_WARNING(0x7F7)
#define W_DAV_XML_NODE_NOT_CONSTRUCTED				DAV_WARNING(0x7F8)
#define W_DAV_SCRIPTMAP_MATCH_EXCLUDED				DAV_WARNING(0x7F9)
#define W_DAV_SCRIPTMAP_MATCH_FOUND					DAV_WARNING(0x7FA)
#define W_DAV_PARTIAL_CONTENT						DAV_WARNING(0x7FB)
#define W_DAV_NO_CONTENT							DAV_WARNING(0x7FC)
#define W_DAV_CREATED								DAV_WARNING(0x7FD)
#define W_DAV_PARTIAL_SUCCESS						DAV_WARNING(0x7FE)
#define W_DAV_VIEW_USE_DEFAULT						DAV_WARNING(0x7FF)

#define E_DAV_STORE_BAD_PATH						DAV_SCODE(0x800)
#define E_DAV_STORE_QUERY_SMTP_DOMAIN				DAV_SCODE(0x801)
#define E_DAV_STORE_OUTOFMEMORY						DAV_SCODE(0x802)
#define E_DAV_STORE_SESS_GET_INFO					DAV_SCODE(0x803)

//  E_DAV_STORE_MDB_UNAVAILABLE is only sent when the public store
//  is hit, but it is dismounted.
//
#define E_DAV_STORE_MDB_UNAVAILABLE					DAV_SCODE(0x804)
#define E_DAV_STORE_GET_MAILBOX_GUID				DAV_SCODE(0x805)
#define E_DAV_STORE_LOGON_FAILED					DAV_SCODE(0x806)
#define E_DAV_STORE_ADD_LOGON						DAV_SCODE(0x807)
#define E_DAV_STORE_NOT_FOUND						DAV_SCODE(0x808)
#define E_DAV_STORE_CHECK_FOLDER_NAME				DAV_SCODE(0x809)
#define E_DAV_STORE_OPEN_FOLDER						DAV_SCODE(0x80a)
#define E_DAV_STORE_GET_TABLE						DAV_SCODE(0x80b)
#define E_DAV_STORE_SET_COLUMNS						DAV_SCODE(0x80c)
#define E_DAV_STORE_FIND_ROW						DAV_SCODE(0x80d)
#define E_DAV_STORE_OPEN_IMAIL_OBJ					DAV_SCODE(0x80e)
#define E_DAV_STORE_OPEN_IMAIL_STREAM				DAV_SCODE(0x80f)
#define E_DAV_STORE_STREAM_READ						DAV_SCODE(0x810)
#define E_DAV_STORE_NOTIMPL							DAV_SCODE(0x811)
#define E_DAV_STORE_SAVE_CHANGES_MSG				DAV_SCODE(0x812)
#define E_DAV_STORE_GET_SESS						DAV_SCODE(0x813)
#define E_DAV_STORE_SAVE_CHANGES_ATTACH				DAV_SCODE(0x814)
#define E_DAV_STORE_SESS_CONFIG						DAV_SCODE(0x815)
#define E_DAV_STORE_OUTOFSHAREDMEMORY				DAV_SCODE(0x816)
#define E_DAV_STORE_IPC_SEND						DAV_SCODE(0x817)
#define E_DAV_STORE_CHECK_RIGHTS_FOLD				DAV_SCODE(0x818)
#define E_DAV_STORE_CREATE_ATTACH					DAV_SCODE(0x819)
#define E_DAV_STORE_CREATE_TEMP_STREAM				DAV_SCODE(0x81a)
#define E_DAV_STORE_QUERY_ROWS						DAV_SCODE(0x81b)
#define E_DAV_STORE_STREAM_WRITE					DAV_SCODE(0x81c)
#define E_DAV_STORE_GET_PROPS						DAV_SCODE(0x81d)
#define E_DAV_SEARCH_COULD_NOT_RESTRICT				DAV_SCODE(0x81e)
#define E_DAV_STORE_INTERNAL						DAV_SCODE(0x81f)
#define E_DAV_STORE_OPEN_MSG						DAV_SCODE(0x820)
#define E_DAV_STORE_OPEN_ATTACH						DAV_SCODE(0x821)
#define E_DAV_STORE_OPEN_STREAM						DAV_SCODE(0x822)
#define E_DAV_STORE_MDB_STREAM_READ					DAV_SCODE(0x823)
#define E_DAV_STORE_CREATE_FOLDER					DAV_SCODE(0x824)
#define E_DAV_STORE_ALREADY_EXISTS					DAV_SCODE(0x825)
#define E_DAV_STORE_GET_TOKEN_INFO					DAV_SCODE(0x826)
#define E_DAV_STORE_LOOKUP_ACCOUNT_SID				DAV_SCODE(0x827)
#define E_DAV_STORE_SET_PROPS						DAV_SCODE(0x828)
#define E_DAV_STORE_DELETE							DAV_SCODE(0x829)
#define E_DAV_SEARCH_FOLDER_NOT_CREATED				DAV_SCODE(0x82a)

#define E_DAV_STORE_MOVE_COPY						DAV_SCODE(0x830)
#define E_DAV_STORE_DELETE_PROPS					DAV_SCODE(0x831)
#define E_DAV_STORE_SESSPOOLERROR					DAV_SCODE(0x832)
#define E_DAV_STORE_BEGIN_GOP						DAV_SCODE(0x833)
#define E_DAV_STORE_COMMIT_GOP						DAV_SCODE(0x834)
#define E_DAV_STORE_ROLLBACK_GOP					DAV_SCODE(0x835)
#define E_DAV_STORE_GET_IDS_FROM_NAMES				DAV_SCODE(0x836)
#define E_DAV_STORE_GET_NAMES_FROM_IDS				DAV_SCODE(0x837)
#define E_DAV_STORE_OP_REQUIRES_FOLDER				DAV_SCODE(0x838)
#define E_DAV_STORE_SEARCH_ERROR					DAV_SCODE(0x839)
#define E_DAV_STORE_SEARCH_UNSUPPORTED				DAV_SCODE(0x83d)
#define E_DAV_STORE_TOO_MANY_CONNECTIONS			DAV_SCODE(0x83e)
#define E_DAV_STORE_SEEK_ROWS						DAV_SCODE(0x83f)
#define E_DAV_STORE_BAD_CONTEXT_INFO				DAV_SCODE(0x840)
#define E_DAV_STORE_IFS_FILE_OPEN					DAV_SCODE(0x841)
#define E_DAV_STORE_IFS_FILE_WRITE					DAV_SCODE(0x842)
#define E_DAV_STORE_MAIL_SUBMISSION					DAV_SCODE(0x843)
#define E_DAV_STORE_GET_IFS_ROOT					DAV_SCODE(0x844)
#define E_DAV_STORE_SESSMGRERROR					DAV_SCODE(0x845)
#define E_DAV_STORE_TIMEOUT_WAIT_FOR_TICKET			DAV_SCODE(0x846)
#define E_DAV_STORE_INVALIDTICKET					DAV_SCODE(0x847)
#define E_DAV_STORE_RESTRICT						DAV_SCODE(0x848)
#define E_DAV_STORE_SORTTABLE						DAV_SCODE(0x849)
#define E_DAV_INVALID_TPLT_FORMAT					DAV_SCODE(0x84a)
#define E_DAV_INVALID_CALLBACK						DAV_SCODE(0x84b)
#define E_DAV_STORE_QUERYPOS						DAV_SCODE(0x84c)
#define E_DAV_STORE_APPLY_VIEW						DAV_SCODE(0x84d)
#define E_DAV_STORE_INIT_VIEW						DAV_SCODE(0x84e)
#define E_DAV_STORE_FIND_VIEW						DAV_SCODE(0x84f)
#define E_DAV_STORE_MSHL_COLUMN						DAV_SCODE(0x850)
#define E_DAV_STORE_ADD_COLUMN						DAV_SCODE(0x851)
#define E_DAV_TLHNAME_PARSE_ERROR					DAV_SCODE(0x852)
#define E_DAV_STORE_USE_PROXY						DAV_SCODE(0x853)
#define E_DAV_SEARCH_TABLE_ERROR					DAV_SCODE(0x854)
#define E_DAV_STORE_USER_CACHE_ERROR				DAV_SCODE(0x855)
#define E_DAV_MDB_DOWN								DAV_SCODE(0x856)
#define E_DAV_STORE_COPY_PROPS						DAV_SCODE(0x857)
#define E_DAV_STORE_SAVE_MSG						DAV_SCODE(0x858)
#define E_DAV_STORE_RECIP							DAV_SCODE(0x859)
#define E_DAV_STORE_NOT_VERSIONED					DAV_SCODE(0x85a)
#define E_DAV_STORE_GET_VERSION_HISTORY				DAV_SCODE(0x85b)
#define E_DAV_STORE_REVISION_ID_FAILURE				DAV_SCODE(0x85c)
#define E_DAV_VERSIONING_BAD_VERB					DAV_SCODE(0x85d)
#define E_DAV_VERSIONING_BAD_COMMENT				DAV_SCODE(0x85e)
#define E_DAV_VERSIONING_BAD_LOCK_DEPTH				DAV_SCODE(0x85f)
#define E_DAV_VERSIONING_INVALID_PARAMETER			DAV_SCODE(0x860)
#define E_DAV_STORE_NEED_TRAILING_SLASH				DAV_SCODE(0x861)
#define E_DAV_STORE_SET_FILE_HANDLE_PROP			DAV_SCODE(0x862)
#define E_DAV_LOCK_TIMEOUT							DAV_SCODE(0x863)
#define E_DAV_STORE_DELETE_FOLDER					DAV_SCODE(0x864)
#define E_DAV_STORE_DELETE_MESSAGES					DAV_SCODE(0x865)
#define E_DAV_STORE_MOVECOPY_FOLDER					DAV_SCODE(0x866)
#define E_DAV_STORE_MOVECOPY_MESSAGES				DAV_SCODE(0x867)
#define E_DAV_EPOXY_ERROR_ALREADY_SENT				DAV_SCODE(0x868)
#define E_DAV_UNRESOLVED_RECIP						DAV_SCODE(0x869)
#define E_DAV_NO_OBJECT_SELECTED					DAV_SCODE(0x86a)
#define E_DAV_SELECT_ONE_FOLDER						DAV_SCODE(0x86b)
#define E_DAV_MESSAGE_TOO_LARGE						DAV_SCODE(0x86c)
#define E_DAV_QUOTA_EXCEEDED						DAV_SCODE(0x86d)
#define E_DAV_SID_AMBIGUOUS							DAV_SCODE(0x86e)
#define E_DAV_GUID_AMBIGUOUS						DAV_SCODE(0x86f)
#define E_DAV_NO_RECIPS								DAV_SCODE(0x870)
#define E_DAV_ALIAS_AMBIGUOUS						DAV_SCODE(0x871)

#endif	// _DAVSC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\etag.h ===
/*
 *	E T A G . H
 *
 *	ETags for DAV resources
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_ETAG_H_
#define _ETAG_H_

//	ETAG Format ---------------------------------------------------------------
//
enum { CCH_ETAG = 100, STRONG_ETAG_DELTA = 30000000 };

//	ETAG creation -------------------------------------------------------------
//
BOOL FGetLastModTime (IMethUtil *, LPCWSTR pwszPath, FILETIME * pft);
BOOL FETagFromFiletime (FILETIME * pft, LPWSTR rgwchETag, const IEcb * pecb);
//	If-xxx header processing --------------------------------------------------
//

//	Use the first function if you want to generate an ETag by calling FETagFromFiletime;
//	use the second function to override this generation by supplying your own ETag.
//
SCODE ScCheckIfHeaders (IMethUtil * pmu, FILETIME * pft, BOOL fGetMethod);
SCODE ScCheckIfHeadersFromEtag (IMethUtil *	pmu, FILETIME * pft,
								BOOL fGetMethod, LPCWSTR pwszEtag);

//	Use the first function if you want to generate an ETag by calling FETagFromFiletime;
//	use the second function to override this generation by supplying your own ETag.
//
SCODE ScCheckIfRangeHeader (IMethUtil * pmu, FILETIME * pft);
SCODE ScCheckIfRangeHeaderFromEtag (IMethUtil * pmu, FILETIME* pft,
									LPCWSTR pwszEtag);

SCODE ScCheckEtagAgainstHeader (LPCWSTR pwszEtag, LPCWSTR pwszHeader);

#endif	// _ETAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\ecbimpl.h ===
/*
	Copyright (c) 1999 Microsoft Corporation, All Rights Reserved

	Description
	===========
	This header defines the template class CEcbBaseImpl<>, which is used to implement
	specific ECB-related functions which are required by the WebClient.

	The reason for implementing the function this way is so that _WEBMAIL can be
	linked into multiple projects, and so that each of those projects can use this
	template to provide the ECB-related functions.  That is to say, we want to share
	the code, and this is the way we ended up doing it.

	Specifically, _WEBMAIL accepts pointers of type IEcbBase.  And _DAVPRS uses
	objects of type IEcb, which is derived from IEcbBase - and all of the functions
	in this template class used to be implemented by _DAVPRS.  And EXWFORM wants to
	use _WEBMAIL, and wants to share the implementation of these functions with
	_DAVPRS, but doesn't want to have to implement all of IEcb.

	So, in _DAVPRS, the class heirarchy looks like...
		class IEcbBase;
		class IEcb : public IEcbBase;
		class CEcb : public CEcbBaseImpl<IEcb>;

	In EXWFORM, the class heirarchy looks like...
		class IEcbBase;
		class CLocalEcb : public CEcbBaseImpl<IEcbBase>;

	History
	=======
	6/27/99	dondu	Created
*/


#ifndef _ECBIMPL_INC
#define _ECBIMPL_INC

#include <except.h>


template<class _T>
class CEcbBaseImpl : public _T
{
protected:

	//	Buffer for cached constant strings.  Must be WCHAR because it is
	//	used for both CHAR and WCHAR strings. Alignment must be pesimistic.
	//
	mutable ChainedStringBuffer<WCHAR> m_sb;

	//	Skinny vroot information
	//
	mutable UINT m_cchVroot;
	mutable LPSTR m_rgchVroot;

	//	Wide character vroot information
	//
	mutable UINT m_cchVrootW;
	mutable LPWSTR m_rgwchVroot;

	//	Skinny vroot path
	//
	mutable UINT m_cchVrootPath;
	mutable LPSTR m_rgchVrootPath;

	//	Wide character vroot path
	//
	mutable UINT m_cchVrootPathW;
	mutable LPWSTR m_rgwchVrootPath;

	//	Skinny server name
	//
	mutable UINT m_cchServerName;
	mutable LPSTR m_lpszServerName;

	//	Wide character server name
	//
	mutable UINT m_cchServerNameW;
	mutable LPWSTR m_pwszServerName;

	//	Cached path translated from request URI (e.g. L"c:\davfs\foo.txt")
	//
	mutable LPWSTR m_pwszPathTranslated;

	//	Cached request URL in skinny form.
	//
	mutable LPSTR m_pszRequestUrl;

	//	Cached request URL in wide form.
	//
	mutable LPWSTR m_pwszRequestUrl;

	//	Cached raw URL
	//
	mutable LPSTR	m_pszRawURL;
	mutable UINT	m_cbRawURL;

	//	Cached LCID of request/response language
	//
	mutable ULONG	m_lcid;

	//	ECB port secure state
	//
	mutable enum {

		HTTPS_UNKNOWN,
		NORMAL,
		SECURE
	}				m_secure;
	mutable BOOL	m_fFESecured;

	//	Cached Accept-Language: header
	//
	mutable auto_heap_ptr<CHAR> m_pszAcceptLanguage;

	//	Wide method name. Skinny version is on raw ECB
	//
	mutable LPWSTR	m_pwszMethod;

private:

	// NOT IMPLEMENTED
	//
	CEcbBaseImpl(const CEcbBaseImpl&);
	CEcbBaseImpl& operator=(const CEcbBaseImpl&);

	//	Internal private helpers for caching vroot information
	//
	VOID GetMapExInfo60After() const;
	VOID GetMapExInfo60Before() const;

protected:

	CEcbBaseImpl(EXTENSION_CONTROL_BLOCK& ecb);

	//	Internal helper for caching vroot information
	//
	VOID GetMapExInfo() const;

public:

	//	Server variables
	//
	virtual BOOL FGetServerVariable( LPCSTR pszName, LPSTR pszValue, DWORD * pcbValue ) const;
	virtual BOOL FGetServerVariable( LPCSTR pszName, LPWSTR pwszValue, DWORD * pcchValue ) const;

	//	Virtual root information
	//
	virtual UINT CchGetVirtualRoot( LPCSTR * ppszVroot ) const;
	virtual UINT CchGetVirtualRootW( LPCWSTR * ppwszVroot ) const;

	virtual UINT CchGetMatchingPathW( LPCWSTR * ppwszMatchingPath ) const;

	//	Server name
	//
	virtual UINT CchGetServerName( LPCSTR* ppszServer) const;
	virtual UINT CchGetServerNameW( LPCWSTR* ppwszServer) const;

	//	URL prefix
	//
	virtual LPCSTR LpszUrlPrefix() const;
	virtual LPCWSTR LpwszUrlPrefix() const;
	virtual UINT CchUrlPrefix( LPCSTR * ppszPrefix ) const;
	virtual UINT CchUrlPrefixW( LPCWSTR * ppwszPrefix ) const;

	//	ACCESSORS
	//
	virtual LPCSTR LpszRequestUrl() const;
	virtual LPCWSTR LpwszRequestUrl() const;
	virtual LPCWSTR LpwszMethod() const;
	virtual LPCWSTR LpwszPathTranslated() const;
	virtual UINT CbGetRawURL (LPCSTR * ppszRawURL) const;
	virtual ULONG  LcidAccepted() const;
	virtual VOID SetLcidAccepted(LCID lcid);

	virtual BOOL FSsl() const;
	virtual BOOL FFrontEndSecured() const { return FSsl() && m_fFESecured; }
};


//	------------------------------------------------------------------------
//
//	CEcbBaseImpl::CEcbBaseImpl()
//
template<class _T>
CEcbBaseImpl<_T>::CEcbBaseImpl(EXTENSION_CONTROL_BLOCK& ecb) :
   _T(ecb),
   m_sb(1024), // 1K for constant cached strings
   m_cchVroot(0),
   m_rgchVroot(NULL),
   m_cchVrootW(0),
   m_rgwchVroot(NULL),
   m_cchVrootPath(0),
   m_rgchVrootPath(NULL),
   m_cchVrootPathW(0),
   m_rgwchVrootPath(NULL),
   m_cchServerName(0),
   m_lpszServerName(NULL),
   m_cchServerNameW(0),
   m_pwszServerName(NULL),
   m_pwszPathTranslated(NULL),
   m_pszRequestUrl(NULL),
   m_pwszRequestUrl(NULL),
   m_pszRawURL(NULL),
   m_cbRawURL(0),
   m_lcid(0),
   m_secure(HTTPS_UNKNOWN),
   m_fFESecured(FALSE),
   m_pwszMethod(NULL)
{
#ifdef DBG

	// This is here (in the DBG build only) to help generate
	// compile errors for any inappropriate use of this template
	// class - basically, you're not supposed to use this class
	// with anything other than IEcbBase, or something which
	// derives from IEcbBase.
	//
	IEcbBase* p;
	p = reinterpret_cast<_T *> (NULL);

#endif
	// nothing
}

//	------------------------------------------------------------------------
//
//	CEcbBaseImpl::GetMapExInfo60After()
//
template<class _T>
VOID CEcbBaseImpl<_T>::GetMapExInfo60After() const
{
	if ( !m_rgwchVroot )
	{
		HSE_UNICODE_URL_MAPEX_INFO mi;
		UINT cbPath = sizeof(mi.lpszPath);

		//$REMOVE after 156176 is fixed START
		//
		mi.lpszPath[0] = L'\0';
		mi.cchMatchingPath = 0;
		//
		//$REMOVE after 156176 is fixed END

		//	No cached wide vroot data. Get mapings for the request URL.
		//
		//	We can get the virtual root by translating the path and using
		//	the count of matched characters in the URL.
		//
		//	NOTE: ServerSupportFunction(HSE_REQ_MAP_UNICODE_URL_TO_PATH_EX)
		//	has a bug - it requires the count of bytes available for the
		//	path. We know that MAX_PATH is available in HSE_UNICODE_URL_MAPEX_INFO
		//	so pass in the right value to work around the crash.
		//
		if ( !m_pecb->ServerSupportFunction( m_pecb->ConnID,
											 HSE_REQ_MAP_UNICODE_URL_TO_PATH_EX,
											 const_cast<LPWSTR>(LpwszRequestUrl()),
											 reinterpret_cast<DWORD *>(&cbPath),
											 reinterpret_cast<DWORD *>(&mi) ))
		{
			//	There is a fix for Windows Bugs 156176 that we need to do the
			//	following check for. It applies to IIS 6.0 (+) path only. In IIS 5.0
			//	the maping functions were silently succeeding, and truncating the
			//	buffer that contained the mapped path if it exceeded MAX_PATH.
			//	That behaviour suited us, but is not very nice, so IIS 6.0 chose
			//	to still fill in the buffer as before, but fail with special error
			//	(ERROR_INSUFFICIENT_BUFFER). That error still means success to us,
			//	so fail only if we see something different
			//
			if (ERROR_INSUFFICIENT_BUFFER != GetLastError())
			{
				//	Function does not allow to return failures, so the only option
				//	is to throw. We cannot proceed if we did not get the data anyway.
				//	If this function succeeds once, subsequent calls to it are non
				//	failing.
				//
				DebugTrace ("CEcbBaseImpl<_T>::GetMapExInfo60After() - ServerSupportFunction(HSE_REQ_MAP_UNICODE_URL_TO_PATH_EX) failed 0x%08lX\n", GetLastError());
				throw CLastErrorException();
			}
		}

		//$REMOVE after 156176 is fixed START
		//
		if (L'\0' == mi.lpszPath[0])
		{
			DebugTrace ("CEcbBaseImpl<_T>::GetMapExInfo60After() - ServerSupportFunction(HSE_REQ_MAP_UNICODE_URL_TO_PATH_EX) failed 0x%08lX\n", GetLastError());
			throw CLastErrorException();
		}
		//
		//$REMOVE after 156176 is fixed END

		EcbTrace ("Dav: caching request URI maping info (path for IIS 6.0 and later):\n"
					"   URL \"%ls\" maps to \"%ls\"\n"
					"   dwFlags = 0x%08x\n"
					"   cchMatchingPath = %d\n"
					"   cchMatchingURL  = %d\n",
					LpwszRequestUrl(),
					mi.lpszPath,
					mi.dwFlags,
					mi.cchMatchingPath,
					mi.cchMatchingURL);

		//	Adjust the matching URL ...
		//
		if ( mi.cchMatchingURL )
		{
			LPCWSTR pwsz = LpwszRequestUrl() + mi.cchMatchingURL - 1;

			//	... do not include the trailing slash, if any...
			//
			if ( L'/' == *pwsz )
			{
				mi.cchMatchingURL -= 1;
			}

			//	... also we found a case (INDEX on the vroot) where the
			//	cchMatching... points to the '\0' (where a trailing slash
			//	would be IF DAV methods required a trailing slash). So,
			//	also chop off any trailing '\0' here! --BeckyAn 21Aug1997
			//
			else if ( L'\0' == *pwsz )
			{
				mi.cchMatchingURL -= 1;
			}
		}

		//	Cache the vroot data.
		//	Corollary:  m_cchVrootW should always be > 0 when we have data.
		//
		m_cchVrootW = mi.cchMatchingURL + 1;
		m_rgwchVroot = reinterpret_cast<LPWSTR>(m_sb.Alloc(m_cchVrootW * sizeof(WCHAR)));
		memcpy (m_rgwchVroot, LpwszRequestUrl(), m_cchVrootW * sizeof(WCHAR));
		m_rgwchVroot[m_cchVrootW - 1] = L'\0';

		//	Adjust the matching path the same way as we did matching URL
		//
		if ( mi.cchMatchingPath )
		{
			LPCWSTR pwsz = mi.lpszPath + mi.cchMatchingPath - 1;

			if ( L'\\' == *pwsz )
			{
				while ((0 < mi.cchMatchingPath) &&
					   (L'\\' == *pwsz) &&
					   (!FIsDriveTrailingChar(pwsz, mi.cchMatchingPath)))
				{
					mi.cchMatchingPath--;
					pwsz--;
				}
			}
			else if ( L'\0' == *pwsz )
			{
				mi.cchMatchingPath--;
			}
		}

		//	Cache the matching path data.
		//	Corollary:  m_cchVrootPathW should always be > 0 when we have data.
		//
		m_cchVrootPathW = mi.cchMatchingPath + 1;
		m_rgwchVrootPath = reinterpret_cast<LPWSTR>(m_sb.Alloc(m_cchVrootPathW * sizeof(WCHAR)));
		memcpy (m_rgwchVrootPath, mi.lpszPath, mi.cchMatchingPath * sizeof(WCHAR));
		m_rgwchVrootPath[mi.cchMatchingPath] = L'\0';
	}
}

//	------------------------------------------------------------------------
//
//	CEcbBaseImpl::GetMapExInfo60Before()
//
template<class _T>
VOID CEcbBaseImpl<_T>::GetMapExInfo60Before() const
{
	if ( !m_rgchVroot )
	{
		HSE_URL_MAPEX_INFO mi;

		//	No cached wide vroot data. Get mapings for the request URL.
		//
		//	We can get the virtual root by translating the path and using
		//	the count of matched characters in the URL
		//
		//	NOTE: ServerSupportFunction(HSE_REQ_MAP_UNICODE_URL_TO_PATH_EX)
		//	does not require the count of bytes available for the path.
		//	So we just pass in NULL and it will figure out the available size
		//	itself - it knows the form of HSE_URL_MAPEX_INFO too, and that
		//	it gives MAX_PATH butes for the translated path.
		//
		if ( !m_pecb->ServerSupportFunction( m_pecb->ConnID,
											 HSE_REQ_MAP_URL_TO_PATH_EX,
											 const_cast<LPSTR>(LpszRequestUrl()),
											 NULL,
											 reinterpret_cast<DWORD *>(&mi) ))
		{
			//	Function does not allow to return failures, so the only option
			//	is to throw. We cannot proceed if we did not get the data anyway.
			//	If this function succeeds once, subsequent calls to it are non
			//	failing.
			//
			DebugTrace ("CEcbBaseImpl<_T>::GetMapExInfo60Before() - ServerSupportFunction(HSE_REQ_MAP_URL_TO_PATH_EX) failed 0x%08lX\n", GetLastError());
			throw CLastErrorException();
		}

		EcbTrace ("Dav: caching request URI maping info (path for pre IIS 6.0):\n"
					"   URL \"%hs\" maps to \"%hs\"\n"
					"   dwFlags = 0x%08x\n"
					"   cchMatchingPath = %d\n"
					"   cchMatchingURL  = %d\n",
					LpszRequestUrl(),
					mi.lpszPath,
					mi.dwFlags,
					mi.cchMatchingPath,
					mi.cchMatchingURL);

		//	Adjust the matching URL ...
		//
		if ( mi.cchMatchingURL )
		{
			LPCSTR psz = LpszRequestUrl() + mi.cchMatchingURL - 1;

			//	... do not include the trailing slash, if any...
			//
			if ( '/' == *psz )
			{
				//$	RAID: NT:359868
				//
				//	This is the first of many places where we need to be very
				//	careful with our usage of single character checks.  Namely,
				//	in DBCS land, we need to check for lead bytes before treating
				//	the last char as if it is a slash.
				//
				if (!FIsDBCSTrailingByte (psz, mi.cchMatchingURL))
					mi.cchMatchingURL -= 1;
				//
				//$	RAID: end.
			}

			//	... also we found a case (INDEX on the vroot) where the
			//	cchMatching... points to the '\0' (where a trailing slash
			//	would be IF DAV methods required a trailing slash). So,
			//	also chop off any trailing '\0' here! --BeckyAn 21Aug1997
			//
			else if ( '\0' == *psz )
			{
				mi.cchMatchingURL -= 1;
			}
		}

		//	Cache the vroot data.
		//	Corollary:  m_cchVrootW should always be > 0 when we have data.
		//
		m_cchVroot = mi.cchMatchingURL + 1;
		m_rgchVroot = reinterpret_cast<LPSTR>(m_sb.Alloc(m_cchVroot));
		memcpy (m_rgchVroot, LpszRequestUrl(), m_cchVroot);
		m_rgchVroot[m_cchVroot - 1] = '\0';

		//	Adjust the matching path the same way as we did maching URL
		//
		if ( mi.cchMatchingPath )
		{
			LPCSTR psz = mi.lpszPath + mi.cchMatchingPath - 1;

			if ( '\\' == *psz )
			{
				//$	RAID: NT:359868
				//
				//	This is the second of many places where we need to be very
				//	careful with our usage of single character checks.  Namely,
				//	in DBCS land, we need to check for lead bytes before treating
				//	the last char as if it is a backslash.
				//
				while ((0 < mi.cchMatchingPath) &&
					   ('\\' == *psz) &&
					   (!FIsDBCSTrailingByte (psz, mi.cchMatchingPath)) &&
					   (!FIsDriveTrailingChar (psz, mi.cchMatchingPath)))
				{
					mi.cchMatchingPath--;
					psz--;
				}

				//
				//$	RAID: end.
			}
			else if ( '\0' == *psz )
			{
				mi.cchMatchingPath--;
			}
		}

		//	Cache the matching path data.
		//	Corollary:  m_cchVrootPath should always be > 0 when we have data.
		//
		m_cchVrootPath = mi.cchMatchingPath + 1;
		m_rgchVrootPath = reinterpret_cast<LPSTR>(m_sb.Alloc(m_cchVrootPath));
		memcpy (m_rgchVrootPath, mi.lpszPath, mi.cchMatchingPath);
		m_rgchVrootPath[mi.cchMatchingPath] = '\0';
	}
}

//	------------------------------------------------------------------------
//
//	CEcbBaseImpl::GetMapExInfo()
//
template<class _T>
VOID CEcbBaseImpl<_T>::GetMapExInfo() const
{
	if ( m_pecb->dwVersion >= IIS_VERSION_6_0 )
	{
		GetMapExInfo60After();
	}
	else
	{
		GetMapExInfo60Before();
	}
}


//	------------------------------------------------------------------------
//
//	FGetServerVariable()
//
//		Get the value of an ECB variable (e.g. "SERVER_NAME")
//
template<class _T>
BOOL
CEcbBaseImpl<_T>::FGetServerVariable( LPCSTR pszName, LPSTR pszValue,
									  DWORD * pcbValue ) const
{
	BOOL fResult = FALSE;


	Assert( m_pecb );
	Assert( !IsBadWritePtr( pcbValue, sizeof(DWORD) ) );
	Assert( *pcbValue > 0 );
	Assert( !IsBadWritePtr( pszValue, *pcbValue ) );

	if ( m_pecb->GetServerVariable( m_pecb->ConnID,
									const_cast<LPSTR>(pszName),
									pszValue,
									pcbValue ) )
	{
		fResult = TRUE;
	}
	else if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
	{
		AssertSz( GetLastError() == ERROR_INVALID_INDEX, "Unexpected last error from GetServerVariable()\n" );
		*pcbValue = 0;
	}

	return fResult;
}

template<class _T>
BOOL
CEcbBaseImpl<_T>::FGetServerVariable( LPCSTR pszName, LPWSTR pwszValue,
									  DWORD * pcchValue ) const
{
	BOOL fResult = FALSE;
	CStackBuffer<CHAR> pszValue;
	DWORD cbValue;
	UINT cch;

	Assert( m_pecb );
	Assert( !IsBadWritePtr( pcchValue, sizeof(DWORD) ) );
	Assert( *pcchValue > 0 );
	Assert( !IsBadWritePtr( pwszValue, *pcchValue * sizeof(WCHAR) ) );

	//	Assume that 1 wide character can be made of 3 skinny ones,
	//	which may be true in the case codepage is CP_UTF8
	//
	cbValue = *pcchValue * 3;
	if (NULL != pszValue.resize(cbValue))
	{
		if ( m_pecb->GetServerVariable( m_pecb->ConnID,
										const_cast<LPSTR>(pszName),
										pszValue.get(),
										&cbValue ) )
		{
			fResult = TRUE;
		}
		else if ( ERROR_INSUFFICIENT_BUFFER == GetLastError() )
		{
			if (NULL != pszValue.resize(cbValue))
			{
				if ( m_pecb->GetServerVariable( m_pecb->ConnID,
												const_cast<LPSTR>(pszName),
												pszValue.get(),
												&cbValue ) )
				{
					fResult = TRUE;
				}
			}
		}
	}

	//	By now we should be succesfull in geting data as the buffer provided
	//	was big enough
	//
	if (FALSE == fResult)
	{
		EcbTrace( "Dav: CEcbBaseImpl<_T>::FGetServerVariable(). Error 0x%08lX from GetServerVariable()\n", GetLastError() );
		*pcchValue = 0;
		goto ret;
	}

	//	We have the data, need to convert it to wide version, assume we will fail
	//
	fResult = FALSE;
	cch = MultiByteToWideChar(CP_ACP,
							  MB_ERR_INVALID_CHARS,
							  pszValue.get(),
							  cbValue,
							  pwszValue,
							  *pcchValue);
	if (0 == cch)
	{
		//	The function failed...
		//
		if ( ERROR_INSUFFICIENT_BUFFER == GetLastError() )
		{
			//	... figure out the necessary size for the buffer
			//
			cch = MultiByteToWideChar(CP_ACP,
									  MB_ERR_INVALID_CHARS,
									  pszValue.get(),
									  cbValue,
									  NULL,
									  0);
			if (0 == cch)
			{
				//	We still failed
				//
				AssertSz( ERROR_INSUFFICIENT_BUFFER != GetLastError(), "We should not fail with ERROR_INSUFFICIENT BUFFER here.\n" );

				EcbTrace( "Dav: CEcbBaseImpl<_T>::FGetServerVariable(). Error 0x%08lX from MultiByteToWideChar() "
						  "while trying to find sufficient length for conversion.\n", GetLastError() );

				*pcchValue = 0;
				goto ret;
			}
		}
		else
		{
			//	... failure was fatal
			//
			EcbTrace( "Dav: CEcbBaseImpl<_T>::FGetServerVariable(), Error 0x%08lX from MultiByteToWideChar() "
					  "while trying to convert.\n", GetLastError() );

			*pcchValue = 0;
			goto ret;
		}
	}

	*pcchValue = cch;
	fResult = TRUE;

ret:

	return fResult;
}

//	------------------------------------------------------------------------
//
//	CEcbBaseImpl::CchGetVirtualRoot
//
//		Fetch and cache the vroot information.
//
template<class _T>
UINT CEcbBaseImpl<_T>::CchGetVirtualRoot( LPCSTR * ppszVroot ) const
{
	//	Tidiness.  If we fail, want to return a NULL.
	//	(We return zero for the cch if we fail.)
	//	Pre-set it here.
	//
	Assert( ppszVroot );
	*ppszVroot = NULL;

	//	Check if we have cached vroot data.
	//
	GetMapExInfo();

	//	If the skinny version of vroot is not available generate
	//	an cache one
	//
	if (NULL == m_rgchVroot)
	{
		//	We got the maping info, so if the skinny version of the
		//	vroot was not available, then at least wide will be there.
		//	That would meen that we are on IIS 6.0 or later. Also we
		//	should have 0 bytes for skinny vroot at this point.
		//
		Assert(m_rgwchVroot);
		Assert(m_pecb->dwVersion >= IIS_VERSION_6_0);
		Assert(0 == m_cchVroot);

		UINT cb = m_cchVrootW * 3;
		m_rgchVroot = reinterpret_cast<LPSTR>(m_sb.Alloc(cb));
		m_cchVroot = WideCharToMultiByte ( CP_ACP,
										   0,
										   m_rgwchVroot,
										   m_cchVrootW,
										   m_rgchVroot,
										   cb,
										   0,
										   0 );
		if (0 == m_cchVroot)
		{
			DebugTrace ("Dav: CEcbBaseImpl::CchGetVirtualRoot failed(%ld)\n", GetLastError());
			throw CLastErrorException();
		}
	}

	//	Give the data back to the caller from our cache.
	//
	*ppszVroot = m_rgchVroot;
	return m_cchVroot - 1;
}

//	------------------------------------------------------------------------
//
//	CEcbBaseImpl::CchGetVirtualRootW
//
//		Fetch and cache the vroot information.
//
template<class _T>
UINT CEcbBaseImpl<_T>::CchGetVirtualRootW( LPCWSTR * ppwszVroot ) const
{
	//	Tidiness.  If we fail, want to return a NULL.
	//	(We return zero for the cch if we fail.)
	//	Pre-set it here.
	//
	Assert( ppwszVroot );
	*ppwszVroot = NULL;

	//	Check if we have cached vroot data.
	//
	GetMapExInfo();

	//	If the wide version of vroot is not available generate
	//	an cache one
	//
	if (NULL == m_rgwchVroot)
	{
		//	We got the maping info, so if the wide version of the
		//	vroot was not available, then at least wide will be there.
		//	That would meen that we are on pre IIS 6.0 version. Also we
		//	should have 0 bytes for wide vroot at this point.
		//
		Assert(m_rgchVroot);
		Assert(m_pecb->dwVersion < IIS_VERSION_6_0);
		Assert(0 == m_cchVrootW);

		UINT cb	 = m_cchVroot * sizeof(WCHAR);
		m_rgwchVroot = reinterpret_cast<LPWSTR>(m_sb.Alloc(cb));
		m_cchVrootW = MultiByteToWideChar ( CP_ACP,
											MB_ERR_INVALID_CHARS,
											m_rgchVroot,
											m_cchVroot,
											m_rgwchVroot,
											m_cchVroot);
		if (0 == m_cchVrootW)
		{
			DebugTrace ("Dav: CEcbBaseImpl::CchGetVirtualRootW failed(%ld)\n", GetLastError());
			throw CLastErrorException();
		}
	}

	//	Give the data back to the caller from our cache.
	//
	*ppwszVroot = m_rgwchVroot;
	return m_cchVrootW - 1;
}

//	------------------------------------------------------------------------
//
//	CEcbBaseImpl::CchGetMatchingPathW
//
//		Fetch and cache the matching path information.
//
template<class _T>
UINT CEcbBaseImpl<_T>::CchGetMatchingPathW( LPCWSTR * ppwszPath ) const
{
	//	Tidiness.  If we fail, want to return a NULL.
	//	(We return zero for the cch if we fail.)
	//	Pre-set it here.
	//
	Assert( ppwszPath );
	*ppwszPath = NULL;

	//	Check if we have cached vroot data.
	//
	GetMapExInfo();

	//	Give the data back to the caller from our cache.
	//
	if (NULL == m_rgwchVrootPath)
	{
		//	We got the maping info, so if the wide version of the
		//	matching path was not available, then at least skinny will
		//	be there. That would meen that we are on pre IIS 6.0 version.
		//	Also we should have 0 bytes for wide matching path at
		//	this point.
		//
		Assert(m_rgchVrootPath);
		Assert(m_pecb->dwVersion < IIS_VERSION_6_0);
		Assert(0 == m_cchVrootPathW);

		UINT cb	 = m_cchVrootPath * sizeof(WCHAR);
		m_rgwchVrootPath = reinterpret_cast<LPWSTR>(m_sb.Alloc(cb));
		m_cchVrootPathW = MultiByteToWideChar ( CP_ACP,
												MB_ERR_INVALID_CHARS,
												m_rgchVrootPath,
												m_cchVrootPath,
												m_rgwchVrootPath,
												m_cchVrootPath);
		if (0 == m_cchVrootPathW)
		{
			DebugTrace ("Dav: CEcbBaseImpl::CchGetMatchingPathW failed(%ld)\n", GetLastError());
			throw CLastErrorException();
		}
	}

	//	Give the data back to the caller from our cache.
	//
	*ppwszPath = m_rgwchVrootPath;
	return m_cchVrootPathW - 1;
}

//	------------------------------------------------------------------------
//
//	CEcbBaseImpl::CchGetServerName
//
//		Fetch and cache the server name, including port number
//
template<class _T>
UINT
CEcbBaseImpl<_T>::CchGetServerName( LPCSTR* ppszServer ) const
{
	if ( !m_lpszServerName )
	{
		DWORD	cbName;
		DWORD	cbPort;
		CStackBuffer<CHAR> lpszName;
		CStackBuffer<CHAR> lpszPort;

		cbName = lpszName.celems();
		for ( ;; )
		{
			DWORD cbCur = cbName;
			
			lpszName.resize(cbName);
			if ( FGetServerVariable( gc_szServer_Name,
									 lpszName.get(),
									 &cbName ) )
			{
				break;
			}

			if ( cbName == 0 )
			{
				lpszName[0] = '\0';
				++cbName;
				break;
			}

			//	If the size was big enough but we still failed, we
			//	are probably out of memory.
			//
			if (cbName && (cbCur >= cbName))
			{
				throw CHresultException(E_OUTOFMEMORY);
			}
		}

		cbPort = lpszPort.celems();
		for ( ;; )
		{
			lpszPort.resize(cbPort);
			if ( FGetServerVariable( gc_szServer_Port,
									 lpszPort.get(),
									 &cbPort ) )
			{
				break;
			}

			if ( cbPort == 0 )
			{
				lpszPort[0] = '\0';
				++cbPort;
				break;
			}
			else
			{
				//	We should not have "PORT" values greater
				//	than 4 digits anyway....
				//
				throw CHresultException(E_INVALIDARG);
			}
		}

		//	Limit the servname/port combination to 256 (including NULL)
		//
		if (256 < (cbName + cbPort))
		{
			throw CHresultException(E_INVALIDARG);
		}

		//	Allocate enough space for the server name and port plus
		//	a ':' separator.  Note that the ':' replaces the '\0' at
		//	the end of the name, so we don't need to add 1 for it here.
		//
		m_lpszServerName = reinterpret_cast<LPSTR>(m_sb.Alloc(cbName + cbPort));

		//	Format the whole thing as "<name>[:<port>]" where
		//	:<port> is only included if the port is not the default
		//	port for the connection (:443 for SSL or :80 for standard)
		//
		CopyMemory( m_lpszServerName,
					lpszName.get(),
					cbName );

		//	If we are secure and the port is "443", or if the port is
		//	the default one, then there is no need to append the port
		//	number to the server name.
		//
		if (( FSsl() && !strcmp( lpszPort.get(), gc_sz443 )) ||
			!strcmp( lpszPort.get(), gc_sz80 ))
		{
			//	It was easier to write the conditional this way and
			//	have the real work done in the "else" clause.
			//
		}
		else
		{
			//	Append the port to the server name
			//
			m_lpszServerName[cbName-1] = ':';
			CopyMemory( m_lpszServerName + cbName,
						lpszPort.get(),
						cbPort );
		}

		m_cchServerName = static_cast<UINT>(strlen(m_lpszServerName));
	}

	*ppszServer = m_lpszServerName;
	return m_cchServerName;
}

//	------------------------------------------------------------------------
//
//	CEcbBaseImpl::CchGetServerNameW
//
//		Fetch and cache the server name, including port number
//
template<class _T>
UINT
CEcbBaseImpl<_T>::CchGetServerNameW( LPCWSTR* ppwszServer ) const
{
	if ( !m_pwszServerName )
	{
		//	Fetch the server name and include 0 termination in its length
		//
		LPCSTR pszServerName = NULL;
		UINT  cbServerName = CchGetServerName(&pszServerName) + 1;

		//	We are looking for the wide server name for the first time.
		//	The character count should be zero at that point.
		//
		Assert(!m_cchServerNameW);

		UINT cb = cbServerName * sizeof(WCHAR);
		m_pwszServerName = reinterpret_cast<LPWSTR>(m_sb.Alloc(cb));
		m_cchServerNameW = MultiByteToWideChar ( CP_ACP,
												 MB_ERR_INVALID_CHARS,
												 pszServerName,
												 cbServerName,
												 m_pwszServerName,
												 cbServerName);
		if (0 == m_cchServerNameW)
		{
			DebugTrace ("Dav: CEcbBaseImpl::CchGetServerNameW failed(%ld)\n", GetLastError());
			throw CLastErrorException();
		}

		//	Subtract 0 termination so that we would behave the same way as
		//	the skinny version of the function
		//
		m_cchServerNameW--;
	}

	*ppwszServer = m_pwszServerName;
	return m_cchServerNameW;
}

//	------------------------------------------------------------------------
//
//	CEcbBaseImpl::LpszUrlPrefix
//
//		Fetch and cache the url prefix
//
extern const __declspec(selectany) CHAR gsc_szHTTPS[] = "HTTPS";
extern const __declspec(selectany) CHAR gsc_szFrontEndHTTPS[] = "HTTP_FRONT_END_HTTPS";
extern const __declspec(selectany) CHAR gsc_szOn[] = "on";

template<class _T>
BOOL
CEcbBaseImpl<_T>::FSsl() const
{
	if (m_secure == HTTPS_UNKNOWN)
	{
		//	Start out believing that we are not in a secure environment
		//
		m_secure = NORMAL;

		//	We want to ask the ECB for the server variables that indicate
		//	whether or not the constructed urls should be secured or not.
		//
		//	In the case of a FE/BE topology, the FE will include a header
		//	"Front-End-HTTPS" that indicates whether or not the FE/BE was
		//	secured via SSL.  In the absence of the header, we should try
		//	to fallback to the IIS "HTTPS" header.  For either header, we
		//	we check its value -- in both cases, it should either be "on"
		//	or "off"
		//
		//	IMPORTANT: you have to check for the FE entry first!  That is
		//	the overriding value for this configuration.
		//
		CHAR szHttps[8];
		ULONG cb = sizeof(szHttps);
		ULONG cbFE = sizeof(szHttps);

		m_fFESecured = FGetServerVariable (gsc_szFrontEndHTTPS, szHttps, &cbFE);
		if (m_fFESecured || FGetServerVariable (gsc_szHTTPS, szHttps, &cb))
		{
			if (!_stricmp(szHttps, gsc_szOn))
				m_secure = SECURE;
		}
	}
	return (SECURE == m_secure);
}

template<class _T>
LPCSTR
CEcbBaseImpl<_T>::LpszUrlPrefix() const
{
	return (FSsl() ? gc_szUrl_Prefix_Secure : gc_szUrl_Prefix);
}

template<class _T>
LPCWSTR
CEcbBaseImpl<_T>::LpwszUrlPrefix() const
{
	return (FSsl() ? gc_wszUrl_Prefix_Secure : gc_wszUrl_Prefix);
}

template<class _T>
UINT
CEcbBaseImpl<_T>::CchUrlPrefix( LPCSTR * ppszPrefix ) const
{
	//	Make sure that we know which prefix we are working with...
	//
	LPCSTR psz = LpszUrlPrefix();

	//	If the caller wants the pointer, too, give it to 'em
	//
	if (ppszPrefix)
		*ppszPrefix = psz;

	//	Return the appropriate size
	//
	return ((m_secure == SECURE)
			? gc_cchszUrl_Prefix_Secure
			: gc_cchszUrl_Prefix);
}

template<class _T>
UINT
CEcbBaseImpl<_T>::CchUrlPrefixW( LPCWSTR * ppwszPrefix ) const
{
	//	Make sure that we know which prefix we are working with...
	//
	LPCWSTR pwsz = LpwszUrlPrefix();

	//	If the caller wants the pointer, too, give it to 'em
	//
	if (ppwszPrefix)
		*ppwszPrefix = pwsz;

	//	Return the appropriate size
	//
	return ((m_secure == SECURE)
			? gc_cchszUrl_Prefix_Secure
			: gc_cchszUrl_Prefix);
}


//	------------------------------------------------------------------------
//
//	CEcbBaseImpl::LpszRequestUrl()
//
template<class _T>
LPCWSTR
CEcbBaseImpl<_T>::LpwszRequestUrl() const
{
	if (!m_pwszRequestUrl)
	{
		SCODE sc;

		CStackBuffer<CHAR> pszAcceptLanguage;
		CStackBuffer<CHAR> pszRawUrlCopy;
		LPCSTR	pszQueryStringStart	= NULL;
		LPCSTR	pszRawUrl			= NULL;
		UINT	cbRawUrl			= 0;
		UINT	cchRequestUrl		= 0;

		//	Grab the raw URL.
		//
		cbRawUrl = CbGetRawURL(&pszRawUrl);

		//	We also need to cut off the URL at the beginning of the query
		//	string, if there is one.
		//
		pszQueryStringStart = strchr(pszRawUrl, '?');
		if (pszQueryStringStart)
		{
			//	If there is a query string we need to make a copy of
			//	the raw URL to work with.
			//
			cbRawUrl = static_cast<UINT>(pszQueryStringStart - pszRawUrl);

			//	Allocate a buffer, and copy it in!
			//
			pszRawUrlCopy.resize(cbRawUrl + 1);
			memcpy(pszRawUrlCopy.get(), pszRawUrl, cbRawUrl);
			pszRawUrlCopy[cbRawUrl] = '\0';

			//	Now set up to normalize from this copy. Do not forget
			//	to increment cbRawUrl to include '\0' termination.
			//
			cbRawUrl++;
			pszRawUrl = pszRawUrlCopy.get();
		}

		//	Before normalizing the url, get the Accept-Language: header
		//	to pass it in. This will be used in figuring out the correct
		//	code page to use to decode non-UTF8 urls.
		//
		for ( DWORD cbValue = 256; cbValue > 0; )
		{
			DWORD cbCur = cbValue;
			pszAcceptLanguage.resize(cbValue);

			//	Zero the string.
			//
			pszAcceptLanguage[0] = '\0';

			//	Get the header value
			//
			if ( FGetServerVariable( "HTTP_ACCEPT_LANGUAGE",
									 pszAcceptLanguage.get(),
									 &cbValue ) )
			{
				break;
			}

			//	If the size needed is the same as the size returned, but the
			//	header retrieval still fails, then we are probably out of memory.
			//
			if (cbValue && (cbCur >= cbValue))
			{
				throw CHresultException(E_OUTOFMEMORY);
			}
			
		}

		//	Now, normalize the URL and we're done
		//
		cchRequestUrl = cbRawUrl;
		m_pwszRequestUrl = reinterpret_cast<LPWSTR>(m_sb.Alloc (cchRequestUrl * sizeof(WCHAR)));

		sc = ScNormalizeUrl(pszRawUrl,
							&cchRequestUrl,
							m_pwszRequestUrl,
							pszAcceptLanguage.get());
		if (S_OK != sc)
		{
			//	We should never get S_FALSE here, since we've passed enough buffer space.
			//	Most often callers of this function assume that it cannot return NULL,
			//	and on the other hand we cannot do anything without request URL. Thus
			//	throw the last error exception.
			//
			Assert(S_FALSE != sc);
			DebugTrace("CEcbBaseImpl::LpwszRequestUrl() - ScNormalizeUrl() failed with error 0x%08lX\n", sc);
			SetLastError(sc);
			throw CLastErrorException();
		}

		//	Store the pointer to stripped request URL
		//
		m_pwszRequestUrl = const_cast<LPWSTR>(PwszUrlStrippedOfPrefix(m_pwszRequestUrl));
	}

	return m_pwszRequestUrl;
}

//	------------------------------------------------------------------------
//
//	CEcbBaseImpl::LpszRequestUrl()
//
template<class _T>
LPCSTR
CEcbBaseImpl<_T>::LpszRequestUrl() const
{
	if (!m_pszRequestUrl)
	{
		LPCWSTR pwszRequestUrl;
		UINT cbRequestUrl;
		UINT cchRequestUrl;

		pwszRequestUrl = LpwszRequestUrl();
		cchRequestUrl = static_cast<UINT>(wcslen(pwszRequestUrl));
		cbRequestUrl = cchRequestUrl * 3;
		m_pszRequestUrl = reinterpret_cast<LPSTR>(m_sb.Alloc (cbRequestUrl + 1));

		//	The reason for choosing CP_ACP codepage here is that it matches
		//	the old behaviour.
		//
		cbRequestUrl = WideCharToMultiByte(CP_ACP,
										   0,
										   pwszRequestUrl,
										   cchRequestUrl + 1,
										   m_pszRequestUrl,
										   cbRequestUrl + 1,
										   NULL,
										   NULL);
		if (0 == cbRequestUrl)
		{
			DebugTrace( "CEcbBaseImpl::LpszRequestUrl() - WideCharToMultiByte() failed 0x%08lX\n",
						HRESULT_FROM_WIN32(GetLastError()) );

			throw CLastErrorException();
		}
	}

	return m_pszRequestUrl;
}

//	------------------------------------------------------------------------
//
//	CEcbBaseImpl::LpwszRequestUrl()
//
template<class _T>
LPCWSTR
CEcbBaseImpl<_T>::LpwszMethod() const
{
	if (!m_pwszMethod)
	{
		LPCSTR pszMethod;
		UINT cbMethod;
		UINT cchMethod;

		pszMethod = LpszMethod();
		cbMethod = static_cast<UINT>(strlen(pszMethod));

		m_pwszMethod = reinterpret_cast<LPWSTR>(
				m_sb.Alloc (CbSizeWsz(cbMethod)));

		cchMethod = MultiByteToWideChar(CP_ACP,
										MB_ERR_INVALID_CHARS,
										pszMethod,
										cbMethod + 1,
										m_pwszMethod,
										cbMethod + 1);
		if (0 == cchMethod)
		{
			DebugTrace( "CEcbBaseImpl::LpwszRequestUrl() - MultiByteToWideChar() failed 0x%08lX\n",
						HRESULT_FROM_WIN32(GetLastError()) );

			throw CLastErrorException();
		}
	}

	return m_pwszMethod;
}

//	------------------------------------------------------------------------
//
//	CEcbBaseImpl::LpwszPathTranslated()
//
template<class _T>
LPCWSTR
CEcbBaseImpl<_T>::LpwszPathTranslated() const
{
	//	Cache the path info in the first call
	//
	if (!m_pwszPathTranslated)
	{
		LPCWSTR	pwszRequestUrl;
		UINT	cchRequestUrl;
		LPCWSTR	pwszMatching;
		UINT	cchMatching;
		LPCWSTR	pwszVroot;
		UINT	cchVroot;
		UINT	cchPathTranslated;

		//	Grab the request URL.
		//
		pwszRequestUrl = LpwszRequestUrl();
		cchRequestUrl = static_cast<UINT>(wcslen(pwszRequestUrl));

		//	Grab the matching path information.
		//
		pwszMatching = NULL;
		cchMatching = CchGetMatchingPathW(&pwszMatching);

		//	Grab the virtual root information.
		//
		pwszVroot = NULL;
		cchVroot = CchGetVirtualRootW(&pwszVroot);

		//	Move the request URL pointer over to snip off the virtual root.
		//
		pwszRequestUrl += cchVroot;
		cchRequestUrl -= cchVroot;

		//	Allocate enough space for the matching path and the request URL, and
		//	copy the pieces in.
		//
		m_pwszPathTranslated = reinterpret_cast<LPWSTR>(
				m_sb.Alloc (CbSizeWsz(cchMatching + cchRequestUrl)));

		//	Copy the matching path.
		//
		memcpy (m_pwszPathTranslated, pwszMatching, cchMatching * sizeof(WCHAR));

		//	Copy the request URL after the vroot, including '\0' termination
		//
		memcpy (m_pwszPathTranslated + cchMatching, pwszRequestUrl, (cchRequestUrl + 1) * sizeof(WCHAR));

		//	Change all '/' that came from URL to '\\'
		//
		for (LPWSTR pwch = m_pwszPathTranslated + cchMatching; *pwch; pwch++)
		{
			if (L'/' == *pwch)
			{
				*pwch = L'\\';
			}
		}

		//	We must remove all trailing slashes, in case the path is not empty string
		//
		cchPathTranslated = cchMatching + cchRequestUrl;
		if (0 < cchPathTranslated)
		{
			LPWSTR pwszTrailing = m_pwszPathTranslated + cchPathTranslated - 1;

			//	Since URL is normalized there may be not more than one trailing slash.
			//	We check only for backslash, as we already changed all forward slashes
			//	to backslashes. Also do not remove trailing slash for the root of the
			//	drive.
			//
			if ((L'\\' == *pwszTrailing) &&
				(!FIsDriveTrailingChar(pwszTrailing, cchPathTranslated)))
			{
				cchPathTranslated--;
				*pwszTrailing = L'\0';
			}
		}
	}

	return m_pwszPathTranslated;
}


//	------------------------------------------------------------------------
//
//	CEcbBaseImpl::CbGetRawURL
//
//		Fetch and cache the raw URL
//
template<class _T>
UINT
CEcbBaseImpl<_T>::CbGetRawURL (LPCSTR* ppszRawURL) const
{
	if (!m_pszRawURL)
	{
		DWORD	cbRawURL;
		CStackBuffer<CHAR,MAX_PATH> pszRawURL;

		cbRawURL = pszRawURL.size();
		for ( ;; )
		{
			DWORD cbCur = cbRawURL;
			pszRawURL.resize(cbRawURL);
			if (FGetServerVariable ("UNENCODED_URL",
									 pszRawURL.get(),
									 &cbRawURL))
			{
				break;
			}

			if (cbRawURL == 0)
			{
				pszRawURL[0] = '\0';
				cbRawURL++;
				break;
			}
			
			//	If the size needed is the same as the size returned, but the
			//	header retrieval still fails, then we are probably out of memory.
			//
			if (cbCur >= cbRawURL)
			{
				throw CHresultException(E_OUTOFMEMORY);
			}
		}

		Assert ('\0' == pszRawURL[cbRawURL - 1]);
		UrlTrace("CEcbBaseImpl::CbGetRawURL(): Raw URL = %s\n", pszRawURL.get());

		//	Copy the data to our object.
		//
		m_pszRawURL = reinterpret_cast<LPSTR>(m_sb.Alloc (cbRawURL));
		memcpy (m_pszRawURL, pszRawURL.get(), cbRawURL);
		m_cbRawURL = cbRawURL;
	}

	//	Return the cached values to the caller.
	//
	*ppszRawURL = m_pszRawURL;
	return m_cbRawURL;
}


//	------------------------------------------------------------------------
//
//	CEcbBaseImpl::LcidAccepted()
//
//		Fetch, cache, and return the LCID of the accepted language
//		based on the value of the Accept-Language header (if any).
//
//		The default LCID is the special constant referring to the
//      default system locale.
//
//$REVIEW$
//	The const at the end of the function needs to be removed
//
template<class _T>
ULONG
CEcbBaseImpl<_T>::LcidAccepted() const
{
	if ( !m_lcid )
	{
		LPCSTR psz = m_pszAcceptLanguage.get();
		HDRITER hdri(psz);
		ULONG lcid;

		m_lcid = LOCALE_NEUTRAL; // must be the same as lcidDefault in mdbeif.hxx

		for (psz = hdri.PszNext(); psz; psz = hdri.PszNext())
			if (FLookupLCID(psz, &lcid))
			{
				m_lcid = LANGIDFROMLCID(lcid);
				break;
			}
	}

	return m_lcid;
}

//	------------------------------------------------------------------------
//
//	CEcbBaseImpl::SetLcidAccepted
//
//	Sets the LCID for the request. We call this function when
//	we dont have an AcceptLang header and we want to override
//	the default LCID (with the LCID in the Cookie)
//
//$REVIEW$
//	After RTM, this function should be merged with the LcidAccepted() function.
//	The LcidAccepted() should check AcceptLang header and if it is not present,
//	should check the lcid in the cookie.
//
template<class _T>
VOID
CEcbBaseImpl<_T>::SetLcidAccepted(LCID lcid)
{
	m_lcid = lcid;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\cvroot.h ===
/*
 *	C V R O O T . H
 *
 *	Extended virtual root information used in link fixup
 *	and vroot enumeration
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_CVROOT_H_
#define _CVROOT_H_

#include <buffer.h>
#include <autoptr.h>

//	CVroot --------------------------------------------------------------------
//
class IMDData;
class CVRoot : public CMTRefCounted
{
private:

	//	Buffer for all of the string data that we own.  Note that it is
	//	declared before any of the string pointers because it must be
	//	constructed first.
	//
	ChainedStringBuffer<WCHAR> m_sb;

	//	VRoot metadata
	//
	auto_ref_ptr<IMDData>	m_pMDData;

	//	Real metabase path
	//
	LPCWSTR					m_pwszMbPath;

	//	Wide copy of the virtual root's physical path
	//
	auto_heap_ptr<WCHAR>	m_pwszVRPath;
	UINT					m_cchVRPath;

	//	Calculated values from the metadata
	//
	LPCWSTR					m_pwszVRoot;
	UINT					m_cchVRoot;

	LPCWSTR					m_pwszServer;
	UINT					m_cchServer;

	LPCWSTR					m_pwszPort;
	UINT					m_cchPort;
	BOOL					m_fDefaultPort;
	BOOL					m_fSecure;

	//	NOT IMPLEMENTED
	//
	CVRoot& operator=(const CVRoot&);
	CVRoot(const CVRoot&);

public:

	CVRoot( LPCWSTR pwszMetaUrl,
			UINT cchMetaUrlPrefix,
			UINT cchServerDefault,
		    LPCWSTR pwszServerDefault,
		    IMDData* pMDData );

	UINT CchPrefixOfMetabasePath (LPCWSTR* ppwsz) const
	{
		Assert (ppwsz);
		*ppwsz = m_pwszMbPath;
		return static_cast<UINT>(m_pwszVRoot - m_pwszMbPath);
	}

	UINT CchGetServerName (LPCWSTR* ppwsz) const
	{
		Assert (ppwsz);
		*ppwsz = m_pwszServer;
		return m_cchServer;
	}

	UINT CchGetPort (LPCWSTR* ppwsz) const
	{
		Assert (ppwsz);
		*ppwsz = m_pwszPort;
		return m_cchPort;
	}

	UINT CchGetVRoot (LPCWSTR* ppwsz) const
	{
		Assert (ppwsz);
		*ppwsz = m_pwszVRoot;
		return m_cchVRoot;
	}

	UINT CchGetVRPath (LPCWSTR* ppwsz) const
	{
		Assert (ppwsz);
		*ppwsz = m_pwszVRPath;
		return m_cchVRPath;
	}

	BOOL FSecure () const { return m_fSecure; }
	BOOL FDefaultPort () const { return m_fDefaultPort; }

	const IMDData * MetaData() const { return m_pMDData.get(); }
};

//	CVroot List ---------------------------------------------------------------
//
//	Use pragmas to disable the specific level 4 warnings
//	that appear when we use the STL.  One would hope our version of the
//	STL compiles clean at level 4, but alas it doesn't....
//
#pragma warning(disable:4663)	//	C language, template<> syntax
#pragma warning(disable:4244)	//	return conversion, data loss

// Turn this warning off for good.
//
#pragma warning(disable:4786)	//	symbol truncated in debug info

// Put STL includes here
//
#include <list>

// Turn warnings back on
//
#pragma warning(default:4663)	//	C language, template<> syntax
#pragma warning(default:4244)	//	return conversion, data loss

class CSortableStrings
{
public:

	LPCWSTR		m_pwsz;

	CSortableStrings(LPCWSTR pwsz = NULL)
			: m_pwsz(pwsz)
	{
	}

	//	operators for use with list::sort
	//
	BOOL operator<( const CSortableStrings& rhs ) const
	{

		if (_wcsicmp( m_pwsz, rhs.m_pwsz ) < 0)
			return TRUE;

		return FALSE;
	}
};

typedef std::list<CSortableStrings, heap_allocator<CSortableStrings> > CVRList;

#endif	// _CVROOT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\davmb.h ===
/*
 *	D A V M B . H
 *
 *	DAV metabase
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_DAVMB_H_
#define _DAVMB_H_

#include <initguid.h>
#include <exguid.h>
#include <iadmw.h>
#include <iwamreg.h>
#include <iiscnfg.h>
#include <autoptr.h>
#include <exo.h>
#include <malloc.h>
#include <szsrc.h>
#include <ex\refcnt.h>

//	Advising the notification sink --------------------------------------------
//
HRESULT
HrAdviseSink( IMSAdminBase& msAdminBase,
			  IMSAdminBaseSink * pMSAdminBaseSink,
			  DWORD * pdwCookie );

//	Unadvising the notification sink ------------------------------------------
//
VOID
UnadviseSink( IMSAdminBase& msAdminBase,
			  DWORD dwCookie );

//	Constructing metabase change object ---------------------------------
//
inline
SCODE ScBuildChangeObject(LPCWSTR pwszBase,
						  UINT cchBase,
						  LPCWSTR pwszPath,
						  UINT cchPath,
						  DWORD dwMDChangeType,
						  const DWORD * pdwMDDataId,
						  LPWSTR pwszBuf,
						  UINT * pcchBuf,
						  PMD_CHANGE_OBJECT_W pMdChObjW)
{
	SCODE sc = S_OK;
	UINT cchT;
	
	Assert(0 == cchBase || pwszBase);
	Assert(0 == cchPath || pwszPath);
	Assert(pdwMDDataId);
	Assert(pcchBuf);
	Assert(0 == *pcchBuf || pwszBuf);
	Assert(pMdChObjW);

	//	Ambiguous trace. I am comenting it out...
	//
	/*	DebugTrace(	"ScBuildChangeObject() called:\n"
				"   Base path: '%S'\n"
				"   Remaining path: '%S'\n"
				"   Change type: 0x%08lX\n"
				"   Data ID: 0x%08lX\n",
				pwszBase ? pwszBase : L"NONE",
				pwszPath ? pwszPath : L"NONE",
				dwMDChangeType,
				*pdwMDDataId );*/

	//	Construct the path change is occuring on.
	//
	BOOL fNeedSeparator  = FALSE;
	BOOL fNeedTerminator = FALSE;

	//	Make sure that we do not assemble the path with
	//	double '/' in the middle.
	//
	if (cchBase &&
		cchPath &&
		L'/' == pwszBase[cchBase - 1] &&
		L'/' == pwszPath[0])
	{
		//	Get rid of one '/'
		//
		cchBase--;
	}
	else if ((0 == cchBase || L'/' != pwszBase[cchBase - 1]) &&
			 (0 == cchPath || L'/' != pwszPath[0]))
	{
		//	We need a separator
		//
		fNeedSeparator = TRUE;
	}

	//	Check out if we need terminating '/' at the end.
	//
	if (cchPath && L'/' != pwszPath[cchPath - 1])
	{
		fNeedTerminator = TRUE;
	}

	cchT = cchBase + cchPath + 1;
	if (fNeedSeparator)
	{
		cchT++;
	}
	if (fNeedTerminator)
	{
		cchT++;
	}

	if (*pcchBuf < cchT)
	{
		*pcchBuf = cchT;
		sc = S_FALSE;
	}
	else
	{
		cchT = 0;
		if (cchBase)
		{
			memcpy(pwszBuf, pwszBase, cchBase * sizeof(WCHAR));
			cchT += cchBase;
		}
		if (fNeedSeparator)
		{
			pwszBuf[cchT] = L'/';
			cchT++;
		}
		if (cchPath)
		{
			memcpy(pwszBuf + cchT, pwszPath, cchPath * sizeof(WCHAR));
			cchT += cchPath;
		}
		if (fNeedTerminator)
		{
			pwszBuf[cchT] = L'/';
			cchT++;
		}
		pwszBuf[cchT] = L'\0';

		pMdChObjW->pszMDPath = pwszBuf;
		pMdChObjW->dwMDChangeType = dwMDChangeType;
		pMdChObjW->dwMDNumDataIDs = 1;
		pMdChObjW->pdwMDDataIDs = const_cast<DWORD *>(pdwMDDataId);
	}

	return sc;
}

class LFUData
{
	//	Approximate number of hits via Touch()
	//
	DWORD m_dwcHits;

	//	NOT IMPLEMENTED
	//
	LFUData& operator=(const LFUData&);
	LFUData(const LFUData&);

public:
	//	CREATORS
	//
	LFUData() : m_dwcHits(0) {}

	//	MANIPULATORS
	//

	//	--------------------------------------------------------------------
	//
	//	Touch()
	//
	//	Increments the hit count.  Note that this is done without an
	//	interlocked operation.  The expectation is that the actual count
	//	value is just a hint and as such, it is not critical that it be
	//	exactly accurate.
	//
	VOID Touch()
	{
		++m_dwcHits;
	}

	//	--------------------------------------------------------------------
	//
	//	DwGatherAndResetHitCount()
	//
	//	Fetches and resets the hit count.  Again, the actual value is
	//	unimportant, so there is no interlocked operation.
	//
	DWORD DwGatherAndResetHitCount()
	{
		DWORD dwcHits = m_dwcHits;

		m_dwcHits = 0;

		return dwcHits;
	}
};

class IContentTypeMap;
class ICustomErrorMap;
class IScriptMap;
class IMDData : public IRefCounted
{
	//	LFU data
	//
	LFUData m_lfudata;

	//	NOT IMPLEMENTED
	//
	IMDData& operator=(const IMDData&);
	IMDData(const IMDData&);

protected:
	//	CREATORS
	//	Only create this object through it's descendents!
	//
	IMDData() {}

public:
	//	CREATORS
	//
	virtual ~IMDData() {}

	//	MANIPULATORS
	//
	LFUData& LFUData() { return m_lfudata; }

	//	ACCESSORS
	//
	virtual LPCWSTR PwszMDPathDataSet() const = 0;
	virtual IContentTypeMap * GetContentTypeMap() const = 0;
	virtual const ICustomErrorMap * GetCustomErrorMap() const = 0;
	virtual const IScriptMap * GetScriptMap() const = 0;
	virtual LPCWSTR PwszDefaultDocList() const = 0;
	virtual LPCWSTR PwszVRUserName() const = 0;
	virtual LPCWSTR PwszVRPassword() const = 0;
	virtual LPCWSTR PwszExpires() const = 0;
	virtual LPCWSTR PwszBindings() const = 0;
	virtual LPCWSTR PwszVRPath() const = 0;
	virtual DWORD DwDirBrowsing() const = 0;
	virtual DWORD DwAccessPerms() const = 0;
	virtual BOOL FAuthorViaFrontPage() const = 0;
	virtual BOOL FHasIPRestriction() const = 0;
	virtual BOOL FSameIPRestriction(const IMDData* prhs) const = 0;
	virtual BOOL FHasApp() const = 0;
	virtual DWORD DwAuthorization() const = 0;
	virtual BOOL FIsIndexed() const = 0;
	virtual BOOL FSameStarScriptmapping(const IMDData* prhs) const = 0;

	//
	//	Any new metadata accessor should be added here and
	//	an implementation provided in \cal\src\_davprs\davmb.cpp.
	//
};

class IEcb;

//	========================================================================
//
//	CLASS CMDObjectHandle
//
//	Encapsulates access to a metabase object through an open handle,
//	ensuring that the handle is always propery closed.
//
class CMDObjectHandle
{
	enum { METADATA_TIMEOUT = 5000 };

	//
	//	Reference to ECB for security switching
	//
	const IEcb& m_ecb;

	//
	//	COM interface to the metabase
	//
	IMSAdminBase * m_pMSAdminBase;

	//
	//	Raw metabase handle
	//
	METADATA_HANDLE m_hMDObject;

	//
	//	The path for which the handle was opened
	//
	LPCWSTR m_pwszPath;

	//	NOT IMPLEMENTED
	//
	CMDObjectHandle(const CMDObjectHandle&);
	CMDObjectHandle& operator=(CMDObjectHandle&);

public:
	
	//	CREATORS
	//
	CMDObjectHandle(const IEcb& ecb, IMSAdminBase * pMSAdminBase = NULL) :
	    m_ecb(ecb),
		m_pMSAdminBase(pMSAdminBase),
		m_hMDObject(METADATA_MASTER_ROOT_HANDLE),
		m_pwszPath(NULL)
	{
	}

	~CMDObjectHandle();

	//	MANIPULATORS
	//
	HRESULT HrOpen( IMSAdminBase * pMSAdminBase,
					LPCWSTR pwszPath,
					DWORD dwAccess,
					DWORD dwMsecTimeout );

	HRESULT HrOpenLowestNode( IMSAdminBase * pMSAdminBase,
							  LPWSTR pwszPath,
							  DWORD dwAccess,
							  LPWSTR * ppwszPath );

	HRESULT HrEnumKeys( LPCWSTR pwszPath,
						LPWSTR pwszChild,
						DWORD dwIndex ) const;

	HRESULT HrGetDataPaths( LPCWSTR pwszPath,
							DWORD   dwPropID,
							DWORD   dwDataType,
							LPWSTR	 pwszDataPaths,
							DWORD * pcchDataPaths ) const;

	HRESULT HrGetMetaData( LPCWSTR pwszPath,
						   METADATA_RECORD * pmdrec,
						   DWORD * pcbBufRequired ) const;

	HRESULT HrGetAllMetaData( LPCWSTR pwszPath,
							  DWORD dwAttributes,
							  DWORD dwUserType,
							  DWORD dwDataType,
							  DWORD * pdwcRecords,
							  DWORD * pdwDataSet,
							  DWORD cbBuf,
							  LPBYTE pbBuf,
							  DWORD * pcbBufRequired ) const;

	HRESULT HrSetMetaData( LPCWSTR pwszPath,
						   const METADATA_RECORD * pmdrec ) const;

	HRESULT HrDeleteMetaData( LPCWSTR pwszPath,
							  DWORD dwPropID,
							  DWORD dwDataType ) const;

	VOID Close();
};

//	Initialize the metabase
//
BOOL FMDInitialize();

//	Deinit the metabase
//
VOID MDDeinitialize();

//	Fetch the metadata for a specific URI.
//
//	Note: If you need data for the request URI you
//	should use the MetaData() accessor on the IEcb
//	instead of this function.
//
HRESULT HrMDGetData( const IEcb& ecb,
					 LPCWSTR pwszURI,
					 IMDData ** ppMDData );

//	Fetch the metadata for a specific metabase path
//	which may not exist -- e.g. paths to objects
//	whose metadata is entirely inherited.
//
//	When fetching metadata for a path that may not
//	exist pszMDPathOpen must be set to a path that
//	is known to exist and is a proper prefix of
//	the desired access path -- typically the path
//	to the vroot.
//
HRESULT HrMDGetData( const IEcb& ecb,
					 LPCWSTR pwszMDPathAccess,
					 LPCWSTR pwszMDPathOpen,
					 IMDData ** ppMDData );

//	Get metabase change number
//
DWORD DwMDChangeNumber(const IEcb * pecb);

//	Open a metadata handle
//
HRESULT HrMDOpenMetaObject( LPCWSTR pwszMDPath,
							DWORD dwAccess,
							DWORD dwMsecTimeout,
							CMDObjectHandle * pmdoh );

HRESULT HrMDOpenLowestNodeMetaObject( LPWSTR pwszMDPath,
									  DWORD dwAccess,
									  LPWSTR * ppwszMDPath,
									  CMDObjectHandle * pmdoh );

HRESULT
HrMDIsAuthorViaFrontPageNeeded(const IEcb& ecb,
							   LPCWSTR pwszURI,
							   BOOL * pfFrontPageWeb);

//	------------------------------------------------------------------------
//
//	FParseMDData()
//
//	Parses a comma-delimited metadata string into fields.  Any whitespace
//	around the delimiters is considered insignificant and removed.
//
//	Returns TRUE if the data parsed into the expected number of fields
//	and FALSE otherwise.
//
//	Pointers to the parsed are returned in rgpszFields.  If a string
//	parses into fewer than the expected number of fields, NULLs are
//	returned for all of the fields beyond the last one parsed.
//
//	If a string parses into the expected number of fields then
//	the last field is always just the remainder of the string beyond
//	the second to last field, regardless whether the string could be
//	parsed into additional fields.  For example "  foo , bar ,  baz  "
//	parses into three fields as "foo", "bar" and "baz", but parses
//	into two fields as "foo" and "bar ,  baz"
//
//	The total number of characters in pszData, including the null
//	terminator, is also returned in *pcchzData.
//
//	Note: this function MODIFIES pszData.
//
BOOL
FParseMDData( LPWSTR pwszData,
			  LPWSTR rgpwszFields[],
			  UINT cFields,
			  UINT * pcchData );

//	------------------------------------------------------------------------
//
//	FCopyStringToBuf()
//
//	Copies a string (pszSource) to a buffer (pszBuf) if the size of the
//	buffer is large enough to hold the string.  The size of the string is
//	returned in *pchBuf.  A return value of TRUE indicates that the buffer
//	was large enough and string was successfully copied.
//
//	This function is primarily intended for use in copying string return
//	values from IMDData accessors into buffers so that they can be used
//	after the IMDData object from which they were obtained is gone.
//
inline BOOL
FCopyStringToBuf( LPCWSTR pwszSrc,
				  LPWSTR pwszBuf,
				  UINT * pcchBuf )
{
	Assert( pwszSrc );
	Assert( pwszBuf );
	Assert( pcchBuf );

	UINT cchSrc = static_cast<UINT>(wcslen(pwszSrc) + 1);

	//
	//	If the supplied buffer isn't big enough to copy the
	//	string type into, then fill in the required size and
	//	return an error.
	//
	if ( *pcchBuf < cchSrc )
	{
		*pcchBuf = cchSrc;
		return FALSE;
	}

	//
	//	The buffer was large enough so copy the string.
	//
	memcpy( pwszBuf, pwszSrc, cchSrc * sizeof(WCHAR) );
	*pcchBuf = cchSrc;
	return TRUE;
}

//	Metabase operations -------------------------------------------------------
//
//	class CMetaOp -------------------------------------------------------------
//
class CMetaOp
{
	//	Enumeration of metabase nodes
	//
	enum { CCH_BUFFER_SIZE = 4096 };
	SCODE __fastcall ScEnumOp (LPWSTR pwszMetaPath, UINT cch);

	//	non-implemented
	//
	CMetaOp& operator=(const CMetaOp&);
	CMetaOp(const CMetaOp&);

protected:

	const IEcb * m_pecb;
	CMDObjectHandle	m_mdoh;
	DWORD		m_dwId;
	DWORD		m_dwType;
	LPCWSTR		m_pwszMetaPath;
	BOOL		m_fWrite;

	//	Subclass' operation to perform for each node where
	//	a value is explicitly set.
	//
	virtual SCODE __fastcall ScOp(LPCWSTR pwszMbPath, UINT cch) = 0;

public:

	virtual ~CMetaOp() {}

	CMetaOp ( const IEcb * pecb, LPCWSTR pwszPath, DWORD dwID, DWORD dwType, BOOL fWrite)
			: m_pecb(pecb),
			  m_mdoh(*pecb),
			  m_dwId(dwID),
			  m_dwType(dwType),
			  m_pwszMetaPath(pwszPath),
			  m_fWrite(fWrite)
	{
	}

	//	Interface use by MOVE/COPY, etc.
	//
	//	NOTE: these operations do not go through the metabase cache
	//	for a very specific reason -- the resource is either being
	//	moved, copied or deleted.  Just because an item was a part
	//	of a large tree operation, does not mean it needs to be added
	//	into the cache.
	//
	SCODE __fastcall ScMetaOp();
};

#endif	// _DAVMB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\ecb.h ===
#ifndef _ECB_H_
#define _ECB_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	ECB.H
//
//		Header for IEcb interface class.
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include <autoptr.h>	// For CMTRefCounted parent
#include <cvroot.h>
#include <davmb.h>		// For IMDData
#include <url.h>		// For HttpUriEscape

//	========================================================================
//
//	ENUM TRANSFER_CODINGS
//
//	Valid transfer codings.  See HTTP/1.1 draft section 3.5.
//
//	TC_UNKNOWN  - Unknown value.
//	TC_IDENTITY - Identity encoding (i.e. no encoding).
//	TC_CHUNKED  - Chunked encoding.
//
enum TRANSFER_CODINGS
{
	TC_UNKNOWN,
	TC_IDENTITY,
	TC_CHUNKED
};

typedef struct _HSE_EXEC_URL_INFO_WIDE {

    LPCWSTR pwszUrl;           // URL to execute
    DWORD dwExecUrlFlags;      // Flags

} HSE_EXEC_URL_INFO_WIDE, * LPHSE_EXEC_URL_INFO_WIDE;

//	========================================================================
//
//	CLASS IIISAsyncIOCompleteObserver
//
//	Passed to IEcb async I/O methods
//
class IIISAsyncIOCompleteObserver
{
	//	NOT IMPLEMENTED
	//
	IIISAsyncIOCompleteObserver& operator=( const IIISAsyncIOCompleteObserver& );

public:
	//	CREATORS
	//
	virtual ~IIISAsyncIOCompleteObserver() = 0;

	//	MANIPULATORS
	//
	virtual VOID IISIOComplete( DWORD dwcbIO, DWORD dwLastError ) = 0;
};

//	========================================================================
//
//	CLASS IEcb
//
//		Provides a clean interface to the EXTENSION_CONTROL_BLOCK passed
//		to us by IIS.
//
class CInstData;

class IEcbBase : public CMTRefCounted
{
private:

	//	NOT IMPLEMENTED
	//
	IEcbBase( const IEcbBase& );
	IEcbBase& operator=( const IEcbBase& );

	//	Private URL mapping helpers
	//
	SCODE ScReqMapUrlToPathEx60After(
		/* [in]  */ LPCWSTR pwszUrl,
		/* [out] */ HSE_UNICODE_URL_MAPEX_INFO * pmi ) const
	{
		SCODE sc = S_OK;
		UINT cbPath = sizeof(pmi->lpszPath);

		Assert( m_pecb );
		Assert( pwszUrl );
		Assert( pmi );

		if (!m_pecb->ServerSupportFunction( m_pecb->ConnID,
											HSE_REQ_MAP_UNICODE_URL_TO_PATH_EX,
											const_cast<LPWSTR>(pwszUrl),
											reinterpret_cast<DWORD*>(&cbPath),
											reinterpret_cast<DWORD*>(pmi) ))
		{
			//	There is a fix for Windows Bugs 156176 that we need to do the
			//	following check for. It applies to IIS 6.0 (+) path only. In IIS 5.0
			//	the maping functions were silently succeeding, and truncating the
			//	buffer that contained the mapped path if it exceeded MAX_PATH.
			//	That behaviour suited us, but is not very nice, so IIS 6.0 chose
			//	to still fill in the buffer as before, but fail with special error
			//	(ERROR_INSUFFICIENT_BUFFER). That error still means success to us,
			//	so fail only if we see something different
			//
			if (ERROR_INSUFFICIENT_BUFFER != GetLastError())
			{
				//	Function does not allow to return failures, so the only option
				//	is to throw. We cannot proceed if we did not get the data anyway.
				//	If this function succeeds once, subsequent calls to it are non
				//	failing.
				//
				sc = HRESULT_FROM_WIN32(GetLastError());
				Assert(FAILED(sc));
				DebugTrace("IEcbBase::ScReqMapUrlToPathEx60After() - ServerSupportFunction(HSE_REQ_MAP_UNICODE_URL_TO_PATH_EX) failed 0x%08lX\n", sc);
				goto ret;
			}
		}

		DebugTrace ("IEcbBase::ScReqMapUrlToPathEx60After() - ServerSupportFunction"
					"(HSE_REQ_MAP_UNICODE_URL_TO_PATH_EX) succeded!\n"
					"mapinfo:\n"
					"- url \"%ls\" maps to \"%ls\"\n"
					"- dwFlags = 0x%08x\n"
					"- cchMatchingPath = %d\n"
					"- cchMatchingURL  = %d\n",
					pwszUrl,
					pmi->lpszPath,
					pmi->dwFlags,
					pmi->cchMatchingPath,
					pmi->cchMatchingURL);

		//	The value for cbPath, at this point, should include the L'\0'
		//	termination, and for that reason cbPath will always be more
		//	than the length of the matching path.
		//
		Assert (0 == cbPath % sizeof(WCHAR));
		Assert (pmi->cchMatchingPath < cbPath/sizeof(WCHAR));

	ret:

		return sc;
	}

	SCODE ScReqMapUrlToPathEx60Before(
		/* [in]  */ LPCWSTR pwszUrl,
		/* [out] */ HSE_UNICODE_URL_MAPEX_INFO * pmi ) const
	{
		SCODE sc = S_OK;

		HSE_URL_MAPEX_INFO mi;

		CStackBuffer<CHAR, MAX_PATH> pszUrl;
		UINT cchUrl;
		UINT cbUrl;
		UINT cbPath;
		UINT cchPath;

		Assert( m_pecb );
		Assert( pwszUrl );
		Assert( pmi );

		//	Find out the length of the URL
		//
		cchUrl = static_cast<UINT>(wcslen(pwszUrl));
		cbUrl = cchUrl * 3;

		//	Resize the buffer to the sufficient size, leave place for '\0' termination
		//
		if (!pszUrl.resize(cbUrl + 1))
		{
			sc = E_OUTOFMEMORY;
			DebugTrace("IEcbBase::ScReqMapUrlToPathEx60Before() - Error while allocating memory 0x%08lX\n", sc);
			goto ret;
		}

		//	Convert to skinny including '\0' termination
		//
		cbUrl = WideCharToMultiByte(CP_ACP,
									0,
									pwszUrl,
									cchUrl + 1,
									pszUrl.get(),
									cbUrl + 1,
									0,
									0);
		if (0 == cbUrl)
		{
			sc = HRESULT_FROM_WIN32(GetLastError());
			DebugTrace("IEcbBase::ScSSFReqMapUrlToPathEx() - WideCharToMultiByte() failed 0x%08lX\n", sc);
			goto ret;
		}

		cbPath = MAX_PATH;

		//	Get the skinny mappings from IIS
		//
		if (!m_pecb->ServerSupportFunction( m_pecb->ConnID,
											HSE_REQ_MAP_URL_TO_PATH_EX,
											pszUrl.get(),
											reinterpret_cast<DWORD*>(&cbPath),
											reinterpret_cast<DWORD*>(&mi)))
		{
			sc = HRESULT_FROM_WIN32(GetLastError());
			DebugTrace("IEcbBase::ScSSFReqMapUrlToPathEx() - ServerSupportFunction() failed 0x%08lX\n", sc);
			goto ret;
		}

		DebugTrace ("IEcbBase::ScSSFReqMapUrlToPathEx() - ServerSupportFunction"
					"(HSE_REQ_MAP_URL_TO_PATH_EX) succeded!\n"
					"mapinfo:\n"
					"- url \"%hs\" maps to \"%hs\"\n"
					"- dwFlags = 0x%08x\n"
					"- cchMatchingPath = %d\n"
					"- cchMatchingURL  = %d\n",
					pszUrl.get(),
					mi.lpszPath,
					mi.dwFlags,
					mi.cchMatchingPath,
					mi.cchMatchingURL);

		//	The value for cbPath, at this point, should include the null
		//	termination, and for that reason cbPath will always be more
		//	than the length of the matching path.
		//
		Assert (mi.cchMatchingPath < cbPath);
		Assert (mi.cchMatchingURL < cbUrl);

		//	First translate the matching path so we would know its
		//	length and would be able to pass it back
		//
		if (mi.cchMatchingPath)
		{
			//	Converting will never yield the buffer bigger than one we already have
			//
			pmi->cchMatchingPath = MultiByteToWideChar(CP_ACP,
													   MB_ERR_INVALID_CHARS,
													   mi.lpszPath,
													   mi.cchMatchingPath,
													   pmi->lpszPath,
													   MAX_PATH);
			if (0 == pmi->cchMatchingPath)
			{
				sc = HRESULT_FROM_WIN32(GetLastError());
				DebugTrace("IEcbBase::ScSSFReqMapUrlToPathEx() - MultiByteToWideChar() failed 0x%08lX\n", sc);
				goto ret;
			}
		}
		else
		{
			pmi->cchMatchingPath = 0;
		}

		//	Convert the remainder of the path including the '\0' termination
		//
		cchPath = MultiByteToWideChar(CP_ACP,
									  MB_ERR_INVALID_CHARS,
									  mi.lpszPath + mi.cchMatchingPath,
									  min(cbPath, MAX_PATH) - mi.cchMatchingPath,
									  pmi->lpszPath + pmi->cchMatchingPath,
									  MAX_PATH - pmi->cchMatchingPath);
		if (0 == cchPath)
		{
			sc = HRESULT_FROM_WIN32(GetLastError());
			DebugTrace("IEcbBase::ScReqMapUrlToPathEx() - MultiByteToWideChar() failed 0x%08lX\n", sc);
			goto ret;
		}

		//	Find the matching URL length for wide version
		//
		if (mi.cchMatchingURL)
		{
			pmi->cchMatchingURL = MultiByteToWideChar(CP_ACP,
													  MB_ERR_INVALID_CHARS,
													  pszUrl.get(),
													  mi.cchMatchingURL,
													  0,
													  0);
			if (0 == pmi->cchMatchingURL)
			{
				sc = HRESULT_FROM_WIN32(GetLastError());
				DebugTrace("IEcbBase::ScReqMapUrlToPathEx() - MultiByteToWideChar() failed 0x%08lX\n", sc);
				goto ret;
			}
		}
		else
		{
			pmi->cchMatchingURL = 0;
		}

	ret:

		return sc;
	}

protected:

	//	Declare the version constant
	//
	enum
	{
		IIS_VERSION_6_0	= 0x60000
	};

	//	A POINTER to the original EXTENSION_CONTROL_BLOCK.
	//	Using a reference would make it impossible for us
	//	to tell if IIS ever requires that we use the
	//	EXTENSION_CONTROL_BLOCK passed into async I/O
	//	completion routines for subsequent I/O.
	//
	EXTENSION_CONTROL_BLOCK * m_pecb;

	IEcbBase( EXTENSION_CONTROL_BLOCK& ecb) :
		m_pecb(&ecb)
	{
		m_cRef = 1; //$HACK Until we have 1-based refcounting
	}

public:
	virtual BOOL FSsl() const = 0;
	virtual BOOL FFrontEndSecured() const = 0;
	virtual BOOL FBrief() const = 0;
	virtual ULONG LcidAccepted() const = 0;
	virtual VOID  SetLcidAccepted(LCID lcid) = 0;
	virtual LPCSTR LpszRequestUrl() const = 0;
	virtual LPCWSTR LpwszRequestUrl() const = 0;
	virtual UINT CchUrlPrefix( LPCSTR * ppszPrefix ) const = 0;
	virtual UINT CchUrlPrefixW( LPCWSTR * ppwszPrefix ) const = 0;
	virtual UINT CchGetServerName( LPCSTR * ppszServer ) const = 0;
	virtual UINT CchGetServerNameW( LPCWSTR * ppwszServer ) const = 0;
	virtual UINT CchGetVirtualRoot( LPCSTR * ppszVroot ) const = 0;
	virtual UINT CchGetVirtualRootW( LPCWSTR * ppwszVroot ) const = 0;
	virtual UINT CchGetMatchingPathW( LPCWSTR * ppwszMatching ) const = 0;
	virtual LPCWSTR LpwszPathTranslated() const = 0;
	virtual CInstData& InstData() const = 0;

	virtual BOOL FGetServerVariable( LPCSTR	lpszName,
									 LPSTR lpszValue,
									 DWORD * pcbValue ) const = 0;
	virtual BOOL FGetServerVariable( LPCSTR lpszName,
									 LPWSTR lpwszValue,
									 DWORD * pcchValue ) const = 0;

    BOOL
	WriteClient( LPVOID  lpvBuf,
				 LPDWORD lpdwcbBuf,
				 DWORD   dwFlags ) const
	{
		Assert( m_pecb );

		return m_pecb->WriteClient( m_pecb->ConnID,
									lpvBuf,
									lpdwcbBuf,
									dwFlags );
	}

    BOOL
	ReadClient( LPVOID  lpvBuf,
				LPDWORD lpdwcbBuf ) const
	{
		Assert( m_pecb );

		return m_pecb->ReadClient( m_pecb->ConnID,
								   lpvBuf,
								   lpdwcbBuf );
	}

    BOOL
	ServerSupportFunction( DWORD      dwHSERequest,
						   LPVOID     lpvBuffer,
						   LPDWORD    lpdwSize,
						   LPDWORD    lpdwDataType ) const
	{
		Assert( m_pecb );

		return m_pecb->ServerSupportFunction( m_pecb->ConnID,
											  dwHSERequest,
											  lpvBuffer,
											  lpdwSize,
											  lpdwDataType );
	}

	SCODE
	ScReqMapUrlToPathEx( LPCWSTR pwszUrl,
						 HSE_UNICODE_URL_MAPEX_INFO * pmi ) const
	{
		Assert (m_pecb);

		if ( m_pecb->dwVersion >= IIS_VERSION_6_0 )
			return ScReqMapUrlToPathEx60After( pwszUrl, pmi );

		return ScReqMapUrlToPathEx60Before( pwszUrl, pmi );
	}
};

class IEcb : public IEcbBase
{
	//	NOT IMPLEMENTED
	//
	IEcb( const IEcb& );
	IEcb& operator=( const IEcb& );

protected:

	//	CREATORS
	//	Only create this object through it's descendents!
	//
	IEcb( EXTENSION_CONTROL_BLOCK& ecb ) :
		IEcbBase(ecb)
	{}

	~IEcb();

public:
	//	ACCESSORS
	//
	LPCSTR
	LpszMethod() const
	{
		Assert( m_pecb );

		return m_pecb->lpszMethod;
	}

	LPCSTR
	LpszQueryString() const
	{
		Assert( m_pecb );

		return m_pecb->lpszQueryString;
	}

	DWORD
	CbTotalBytes() const
	{
		Assert( m_pecb );

		return m_pecb->cbTotalBytes;
	}

	DWORD
	CbAvailable() const
	{
		Assert( m_pecb );

		return m_pecb->cbAvailable;
	}

	const BYTE *
	LpbData() const
	{
		Assert( m_pecb );

		return m_pecb->lpbData;
	}

	virtual LPCWSTR LpwszMethod() const = 0;
	virtual UINT CbGetRawURL( LPCSTR * ppszRawURL ) const = 0;
	virtual LPCSTR LpszUrlPrefix() const = 0;
	virtual LPCWSTR LpwszUrlPrefix() const = 0;
	virtual UINT CchUrlPortW( LPCWSTR * ppwszPort ) const = 0;

	virtual HANDLE HitUser() const = 0;
	virtual BOOL FKeepAlive() const = 0;
	virtual BOOL FCanChunkResponse() const = 0;
	virtual BOOL FAuthenticated() const = 0;
	virtual BOOL FProcessingCEUrl() const = 0;
	virtual BOOL FIIS60OrAfter() const = 0;

	virtual LPCSTR LpszVersion() const = 0;

	virtual BOOL FSyncTransmitHeaders( const HSE_SEND_HEADER_EX_INFO& shei ) = 0;

	virtual SCODE ScAsyncRead( BYTE * pbBuf,
							   UINT * pcbBuf,
							   IIISAsyncIOCompleteObserver& obs ) = 0;

	virtual SCODE ScAsyncWrite( BYTE * pbBuf,
								DWORD  dwcbBuf,
								IIISAsyncIOCompleteObserver& obs ) = 0;

	virtual SCODE ScAsyncTransmitFile( const HSE_TF_INFO& tfi,
									   IIISAsyncIOCompleteObserver& obs ) = 0;

	virtual SCODE ScAsyncCustomError60After( const HSE_CUSTOM_ERROR_INFO& cei,
											 LPSTR pszStatus ) = 0;

	virtual SCODE ScExecuteChild( LPCWSTR pwszURI, LPCSTR pszQueryString, BOOL fCustomErrorUrl ) = 0;

	virtual SCODE ScSendRedirect( LPCSTR lpszURI ) = 0;

	virtual IMDData& MetaData() const = 0;
	virtual LPCWSTR PwszMDPathVroot() const = 0;

#ifdef DBG
	virtual void LogString( LPCSTR szLocation ) const = 0;
#else
	void LogString( LPCSTR ) const {};
#endif

	//	MANIPULATORS
	//
	virtual VOID SendAsyncErrorResponse( DWORD dwStatusCode,
										 LPCSTR pszBody,
										 DWORD cchzBody,
										 LPCSTR pszStatusDescription,
										 DWORD cchzStatusDescription ) = 0;

	virtual DWORD HSEHandleException() = 0;

	//	To be used ONLY by request/response.
	//
	virtual void SetStatusCode( UINT iStatusCode ) = 0;
	virtual void SetConnectionHeader( LPCWSTR pwszValue ) = 0;
	virtual void SetAcceptLanguageHeader( LPCSTR pszValue ) = 0;
	virtual void CloseConnection() = 0;
};

IEcb * NewEcb( EXTENSION_CONTROL_BLOCK& ecb,
			   BOOL fUseRawUrlMappings,
			   DWORD * pdwHSEStatusRet );

#ifdef DBG
void InitECBLogging();
void DeinitECBLogging();
#endif

//
//	Routines to manipulate metadata (metabase) paths
//
ULONG CbMDPathW( const IEcb& ecb, LPCWSTR pwszURI );
VOID MDPathFromURIW( const IEcb& ecb, LPCWSTR pwszURI, LPWSTR pwszMDPath );

#endif // !defined(_ECB_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\davimpl.h ===
#ifndef _DAVIMPL_H_
#define _DAVIMPL_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	DAVIMPL.H
//
//		Header for DAV implementation methods interface
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include <objbase.h>	//	For common C/C++ interface macros

#include <httpext.h>
#include <ex\oldhack.h> //  This file is so that we build as there are some definitions in old headers that are not in new. Will go away.

#include <autoptr.h>	//	For CMTRefCounted base class
#include <ecb.h>
#include <request.h>
#include <response.h>
#include <sgstruct.h>
#include <vrenum.h>
#include <davsc.h>
#include <body.h>		//	For async stream interfaces, CRefHandle, etc.
#include <sz.h>
#include <ex\calcom.h>
#include <url.h>
#include <ex\xml.h>

//	Resource types ------------------------------------------------------------
//
typedef enum {

	RT_NULL = 0,
	RT_DOCUMENT,
	RT_STRUCTURED_DOCUMENT,
	RT_COLLECTION

} RESOURCE_TYPE;

enum { MAX_VERSION_LEN = 20*4 };

//	Access control scope ------------------------------------------------------
//
//	The acl scope is used when asking the metabase for the IIS access applied
//	to a specific resource.
//
//	The following enum actually represents bit flags.
//
//		STRICT:		resource access must have all requested access bits
//		LOOSE:		resource access must have at least one requested access bit
//		INHERIT:	resource access may be inherited from parent.
//
enum {

	ACS_STRICT	= 0x00,
	ACS_LOOSE	= 0x01,
	ACS_INHERIT	= 0x10
};

//	Implementation-defined items ----------------------------------------------
//
#include <impldef.h>
#include <implstub.h>

//	Parser-Defined items ------------------------------------------------------
//

//	Content-type --------------------------------------------------------------
//
//	Content-type is stored in the metabase for HTTPEXT.  Each resource, if it
//	has a content-type that is different than the default content-type, is store
//	explicitly on the resource.  If the content-type is the default value, then
//	there is no explicit setting in the metabase.  Instead, the mapping of a
//	resource's extension to the default content-type is stored.
//
BOOL FGetContentTypeFromURI(
	/* [in] */ const IEcb& ecb,
	/* [in] */ LPCWSTR pwszUrl,
	/* [i/o] */ LPWSTR pwszContentType,
	/* [i/o] */ UINT *  pcchContentType,
	/* [i/o] */ BOOL *  pfIsGlobalMapping = NULL );

BOOL FGetContentTypeFromPath( const IEcb& ecb,
							  LPCWSTR pwszPath,
							  LPWSTR  pwszContentType,
							  UINT *  pcchContentType );

SCODE ScSetContentType(
	/* [in] */ const IEcb& ecb,
	/* [in] */ LPCWSTR pwszUrl,
	/* [in] */ LPCWSTR pwszContentType );

//	Method ID's ---------------------------------------------------------------
//
//	Each DAV method has its own ID for use in scriptmap inclusion lists.
//
typedef enum {

	MID_UNKNOWN = -1,
	MID_OPTIONS,
	MID_GET,
	MID_HEAD,
	MID_PUT,
	MID_POST,
	MID_DELETE,
	MID_MOVE,
	MID_COPY,
	MID_MKCOL,
	MID_PROPFIND,
	MID_PROPPATCH,
	MID_SEARCH,
	MID_LOCK,
	MID_UNLOCK,
	MID_SUBSCRIBE,
	MID_UNSUBSCRIBE,
	MID_POLL,
	MID_BATCHDELETE,
	MID_BATCHCOPY,
	MID_BATCHMOVE,
	MID_BATCHPROPFIND,
	MID_BATCHPROPPATCH,
	MID_X_MS_ENUMATTS
} METHOD_ID;

//	Note: The method name handed to us from IIS is skinny, and there is no
//	real reason why it should be widened for this call.  However, when the
//	scriptmap metabase cache goes wide, we may want to do something smarter
//	here.
//
METHOD_ID MidMethod (LPCSTR pszMethod);
METHOD_ID MidMethod (LPCWSTR pwszMethod);

//	Custom error suberrors ----------------------------------------------------
//
typedef enum {

	//	Default
	//
	CSE_NONE = 0,

	//	401
	//
	CSE_401_LOGON_FAILED = 1,	// "Logon Failed"
	CSE_401_SERVER_CONFIG = 2,	// "Logon Failed due to server configuration"
	CSE_401_ACL = 3,			// "Unauthorized access due to ACL on resource"
	CSE_401_FILTER = 4,			// "Authorization failed by filter"
	CSE_401_ISAPI = 5,			// "Authorization failed by ISAPI/CGI app"

	//	403
	//
	CSE_403_EXECUTE = 1,			// "Execute Access Forbidden"
	CSE_403_READ = 2,				// "Read Access Forbidden"
	CSE_403_WRITE = 3,				// "Write Access Forbidden"
	CSE_403_SSL = 4,				// "SSL Required"
	CSE_403_SSL_128 = 5,			// "SSL 128 Required"
	CSE_403_IP = 6,					// "IP Address Rejected"
	CSE_403_CERT_REQUIRED = 7,		// "Client Certificate Required"
	CSE_403_SITE = 8,				// "Site Access Denied"
	CSE_403_TOO_MANY_USERS = 9,		// "Too many users are connected"
	CSE_403_INVALID_CONFIG = 10,	// "Invalid configuration"
	CSE_403_PASSWORD_CHANGE = 11,	// "Password change"
	CSE_403_MAPPER = 12,			// "Mapper access denied"
	CSE_403_CERT_REVOKED = 13,		// "Client certificate revoked"
	CSE_403_FOURTEEN,				// There is no suberror for this one.
	CSE_403_CALS_EXCEEDED = 15,		// "Client Access Licenses exceeded"
	CSE_403_CERT_INVALID = 16,		// "Client certificate untrusted or invalid"
	CSE_403_CERT_EXPIRED = 17,		// "Client certificate expired"

	//	500
	//
	CSE_500_SHUTDOWN = 11,			// "Server shutting down"
	CSE_500_RESTART = 12,			// "Application restarting"
	CSE_500_TOO_BUSY = 13,			// "Server too busy"
	CSE_500_INVALID_APP = 14,		// "Invalid application"
	CSE_500_GLOBAL_ASA = 15,		// "Requests for global.asa not allowed"
	CSE_500_ASP_ERROR = 100,		// "ASP error"
};

//	========================================================================
//
//	CLASS IAsyncIStreamObserver
//
//	Interface to async I/O completion mechanism for IStreams capable of
//	returning E_PENDING from IStream::Read() and IStream::CopyTo().
//	A client would typically associate an IAsyncIStreamObserver with
//	an IStream when creating the latter.  When one of the IStream calls
//	returns E_PENDING, the IAsyncIStreamObserver will be called when
//	the pending operation completes.
//
class IAsyncIStreamObserver
{
	//	NOT IMPLEMENTED
	//
	IAsyncIStreamObserver& operator=( const IAsyncIStreamObserver& );

public:
	//	CREATORS
	//
	virtual ~IAsyncIStreamObserver() = 0;

	//	MANIPULATORS
	//
	virtual VOID AsyncIOComplete() = 0;
};

//	========================================================================
//
//	DAV IMPL UTILITY CLASS
//
//		Utility class for use by the DAV impl.
//		ALL methods here are inlined on retail builds.  DON'T ADD NON-TRIVIAL METHODS!
//
class IBodyPart;

class IMethUtilBase : public CMTRefCounted
{
private:
	// NOT IMPLEMENTED
	IMethUtilBase(const IMethUtilBase&);
	IMethUtilBase& operator=(const IMethUtilBase&);
protected:
	auto_ref_ptr<IEcbBase> m_pecb;
	auto_ref_ptr<IResponseBase> m_presponse;
	IMethUtilBase(IEcbBase& ecb, IResponseBase& response) :
		m_pecb(&ecb),
		m_presponse(&response)
	{
	}
public:
	void AddResponseText( UINT	cbText,
						  LPCSTR pszText )
	{
		m_presponse->AddBodyText(cbText, pszText);
	}

	void AddResponseText( UINT	cchText,
						  LPCWSTR pwszText )
	{
		m_presponse->AddBodyText(cchText, pwszText);
	}

	void AddResponseFile( const auto_ref_handle& hf,
						  UINT64 ib64 = 0,
						  UINT64 cb64 = 0xFFFFFFFFFFFFFFFF )
	{
		m_presponse->AddBodyFile(hf, ib64, cb64);
	}
	ULONG LcidAccepted() const			{ return m_pecb->LcidAccepted(); }
	VOID  SetLcidAccepted(LCID lcid) 	{ m_pecb->SetLcidAccepted(lcid); }
	LPCWSTR LpwszRequestUrl() const		{ return m_pecb->LpwszRequestUrl(); }
	BOOL FSsl() const					{ return m_pecb->FSsl(); }
	BOOL FFrontEndSecured() const		{ return m_pecb->FFrontEndSecured(); }
	UINT CchUrlPrefix( LPCSTR * ppszPrefix ) const
	{
		return m_pecb->CchUrlPrefix( ppszPrefix );
	}
	UINT CchServerName( LPCSTR * ppszServer ) const
	{
		return m_pecb->CchGetServerName( ppszServer );
	}
	UINT CchGetVirtualRootW( LPCWSTR * ppwszVroot ) const
	{
		return m_pecb->CchGetVirtualRootW(ppwszVroot);
	}
	UINT CchGetMatchingPathW( LPCWSTR * ppwszVroot ) const
	{
		return m_pecb->CchGetMatchingPathW(ppwszVroot);
	}
	LPCWSTR LpwszPathTranslated() const	{ return m_pecb->LpwszPathTranslated(); }
	SCODE ScUrlFromStoragePath( LPCWSTR pwszPath,
								LPWSTR pwszUrl,
								UINT* pcch )
	{
		return ::ScUrlFromStoragePath( *m_pecb,
									   pwszPath,
									   pwszUrl,
									   pcch );
	}

	//	Instance data lookup --------------------------------------------------
	//
	CInstData& InstData() const
	{
		return m_pecb->InstData();
	}

	//$NOTE
	//$REVIEW
	// I had to pull HitUser into here as pure virtual because we needed access
	// to it in CWMRenderer class (which has IMethBaseUtil * as a member) in
	// order to do a Revert.  This was the only way to get davex and the forms
	// stuff to build without touching lots core headers this late in the Beta3
	// game.  We should revisit this in RC1 to try and remove this from the vtable.
	// (9/1/99 - russsi)
	//
	virtual	HANDLE	HitUser() const = 0;

	virtual LPCSTR	LpszServerName() const = 0;

	virtual	BOOL 	FAuthenticated() const = 0;

};

class CMethUtil : public IMethUtilBase
{
private:
	auto_ref_ptr<IEcb> m_pecb;
	auto_ref_ptr<IRequest> m_prequest;
	auto_ref_ptr<IResponse> m_presponse;

	//	Method ID
	//
	METHOD_ID m_mid;

	//	Translation
	//
	enum { TRANS_UNKNOWN = -1, TRANS_FALSE, TRANS_TRUE };
	mutable LONG m_lTrans;

	//	Overwrite
	//
	mutable LONG m_lOverwrite;

	//	Depth
	//
	//	The values for this member are defined in EX\CALCOM.H
	//
	mutable LONG m_lDepth;

	//	Destination url
	//
	mutable auto_heap_ptr<WCHAR> m_pwszDestinationUrl;
	mutable auto_heap_ptr<WCHAR> m_pwszDestinationPath;
	mutable UINT m_cchDestinationPath;
	mutable auto_ref_ptr<CVRoot> m_pcvrDestination;

	//	CREATORS
	//
	//	Only create this object through the construction function!
	//
	CMethUtil( IEcb& ecb, IRequest& request, IResponse& response, METHOD_ID mid ) :
			IMethUtilBase(ecb,response),
			m_pecb(&ecb),
			m_prequest(&request),
			m_presponse(&response),
			m_mid(mid),
			m_lTrans(TRANS_UNKNOWN),
			m_lOverwrite(OVERWRITE_UNKNOWN),
			m_lDepth(DEPTH_UNKNOWN),
			m_cchDestinationPath(0)
	{ }

	//	NOT IMPLEMENTED
	//
	CMethUtil( const CMethUtil& );
	CMethUtil& operator=( const CMethUtil& );

public:

	//	CREATORS
	//
	//	NOTE: Virtual destructor already provided by parent CMTRefCounted.
	//
	static CMethUtil * NewMethUtil( IEcb& ecb,
									IRequest& request,
									IResponse& response,
									METHOD_ID mid )
	{
		return new CMethUtil( ecb, request, response, mid );
	}

	//	Get the pointer to ECB so the we could pass it to the  objects that
	//	will need to query it for data. This object holds a ref on ECB, so
	//	make sure it is used only as long as this object is alive.
	//
	const IEcb * GetEcb() { return m_pecb.get(); }

	//	REQUEST ACCESSORS -----------------------------------------------------
	//
	//	Common header evaluation ----------------------------------------------
	//
	//	FTranslate():
	//
	//		Gets the value of the translate header.
	//
	BOOL FTranslated () const
	{
		//	If we don't have a value yet...
		//
		if (TRANS_UNKNOWN == m_lTrans)
		{
			//	Translation is expected when:
			//
			//		The "translate" header is not present or
			//		The "translate" header has a value other than "f" or "F"
			//
			//	NOTE: The draft says the valid values are "t" or "f".	So, we
			//	are draft compliant if we check only the first char.  This way
			//	we are faster and/or more flexible.
			//
			//	BTW: this is also an IIS-approved way to check boolean strings.
			//	-- BeckyAn (BA:js)
			//
			LPCSTR psz = m_prequest->LpszGetHeader (gc_szTranslate);
			if (!psz || (*psz != 'f' && *psz != 'F'))
				m_lTrans = TRANS_TRUE;
			else
				m_lTrans = TRANS_FALSE;
		}
		return (TRANS_TRUE == m_lTrans);
	}

	//	LOverwrite():
	//
	//		Gets the enumerated value of the Overwrite/Allow-Rename headers.
	//
	LONG LOverwrite () const
	{
		//	If we don't have a value yet...
		//
		if (OVERWRITE_UNKNOWN == m_lOverwrite)
		{
			//	Overwrite is expected when:
			//
			//		The "overwrite" header has a value of "t"
			//
			//	NOTE: The draft says the valid values are "t" or "f".	So, we
			//	are draft compliant if we check only the first char.  This way
			//	we are faster and/or more flexible.
			//
			//	BTW: this is also an IIS-approved way to check boolean strings.
			//	-- BeckyAn (BA:js)
			//
			//	NOTE also: the default value if there is no Overwrite: header
			//	is TRUE -- DO overwrite. Allow-rename if "f", when header is
			//	absent.
			//
			LPCSTR pszOverWrite = m_prequest->LpszGetHeader (gc_szOverwrite);
			if ((!pszOverWrite) || (*pszOverWrite == 't' || *pszOverWrite == 'T'))
			{
				m_lOverwrite |= OVERWRITE_YES;
			}
			LPCSTR pszAllowRename = m_prequest->LpszGetHeader (gc_szAllowRename);
			if (pszAllowRename && (*pszAllowRename == 't' || *pszAllowRename == 'T'))
				m_lOverwrite |= OVERWRITE_RENAME;
		}
		return (m_lOverwrite);
	}

	//	LDepth ():
	//
	//		Returns an enumerated value identifying the contents of the
	//		depth header.
	//
	//	The values for the enumeration are defined in EX\CALCOM.H
	//
	LONG __fastcall LDepth (LONG lDefault) const
	{
		//	If we do not have a value yet...
		//
		if (DEPTH_UNKNOWN == m_lDepth)
		{
			//	Depth can have several values:
			//
			//		DEPTH_ZERO				corresponds to "0"
			//		DEPTH_ONE				corresponds to "1"
			//		DEPTH_INFINITY			corresponds to "Infinity"
			//		DEPTH_ONE_NOROOT		corresponds to "1,NoRoot"
			//		DEPTH_INFINITY_NOROOT	corresponds to "Infinty,NoRoot"
			//
			//	In the case there is no depth header specified, there
			//	is a default that applies to each method.  The default
			//	is not the same from method to method, so the caller
			//	must pass in a default value.
			//
			LPCSTR psz = m_prequest->LpszGetHeader (gc_szDepth);

			if (NULL == psz)
			{
				m_lDepth = lDefault;
			}
			else
			{
				switch (*psz)
				{
					case '0':

						if (!_stricmp (psz, gc_sz0))
							m_lDepth = DEPTH_ZERO;
						break;

					case '1':

						if (!_stricmp(psz, gc_sz1))
							m_lDepth = DEPTH_ONE;
						else if (!_stricmp(psz, gc_sz1NoRoot))
							m_lDepth = DEPTH_ONE_NOROOT;
						break;

					case 'i':
					case 'I':

						if (!_stricmp(psz, gc_szInfinity))
							m_lDepth = DEPTH_INFINITY;
						else if (!_stricmp(psz, gc_szInfinityNoRoot))
							m_lDepth = DEPTH_INFINITY_NOROOT;
						break;
				}
			}
		}
		return m_lDepth;
	}

	//	FBrief():
	//
	//		Gets the value of the Brief header.
	//
	BOOL FBrief () const { return m_pecb->FBrief(); }

	//	FIsOffice9Request()
	//		Finds out if the request is comming from Rosebud as shipped
	//		in Office9.
	//
	BOOL FIsOffice9Request () const
	{
		//	Get the User-Agent header
		//
		LPCSTR pszUserAgent = m_prequest->LpszGetHeader(gc_szUser_Agent);

		//	If there is User-Agent header search for the product token of Office9
		//
		if (pszUserAgent)
		{
			LPCSTR pszProductToken = strstr(pszUserAgent, gc_szOffice9UserAgent);

			//	If we have found the Office9 product token, and it is the
			//	last token in the string, then the request is from Office9.
			//
			//	Important Note: Office9's entire User-Agent is "Microsoft Data
			//	Access Internet Publishing Provider DAV".  We want to make sure
			//	and NOT match "Microsoft Data Access Internet Publishing Provider
			//	DAV 1.1 (for instance).  So we require the token on the end of
			//	the string.  NOTE: Exprox currently adds itself BEFORE any
			//	User-Agent string, so we're okay here.
			//
			if (pszProductToken &&
				((pszProductToken == pszUserAgent) || FIsWhiteSpace(pszProductToken - 1)) &&
				('\0' == (pszProductToken[gc_cchOffice9UserAgent])))
			{
				return TRUE;
			}
		}

		return FALSE;
	}

	//	FIsRosebudNT5Request()
	//		Finds out if the request is comming from Rosebud as shipped
	//		in NT5.
	//
	BOOL FIsRosebudNT5Request () const
	{
		//	Get the User-Agent header
		//
		LPCSTR pszUserAgent = m_prequest->LpszGetHeader(gc_szUser_Agent);

		//	If there is User-Agent header search for the product token of Rosebud-NT5.
		//
		if (pszUserAgent)
		{
			LPCSTR pszProductToken = strstr(pszUserAgent, gc_szRosebudNT5UserAgent);

			//	If we have found the Rosebud product token, and it is the
			//	last token in the string, then the request is from Rosebud.
			//
			//	Important Note: Rosebud-NT5's entire User-Agent is "Microsoft Data
			//	Access Internet Publishing Provider DAV 1.1".  We want to make sure
			//	and NOT match "Microsoft Data Access Internet Publishing Provider
			//	DAV 1.1 refresh" (for instance).  So we require the token on the end of
			//	the string.  NOTE: Exprox currently adds itself BEFORE any
			//	User-Agent string, so we're okay here.
			//
			if (pszProductToken &&
				((pszProductToken == pszUserAgent) || FIsWhiteSpace(pszProductToken - 1)) &&
				('\0' == (pszProductToken[gc_cchRosebudNT5UserAgent])))
			{
				return TRUE;
			}
		}

		return FALSE;
	}

	//	Request item access ---------------------------------------------------
	//
	HANDLE HitUser() const				{ return m_pecb->HitUser(); }
	LPCSTR LpszMethod() const			{ return m_pecb->LpszMethod(); }
	LPCWSTR LpwszMethod() const			{ return m_pecb->LpwszMethod(); }
	METHOD_ID MidMethod() const			{ return m_mid; }
	LPCSTR LpszQueryString() const		{ return m_pecb->LpszQueryString(); }
	LPCSTR LpszServerName() const
	{
		LPCSTR pszServer;
		(void) m_pecb->CchGetServerName(&pszServer);
		return pszServer;
	}
	LPCSTR LpszVersion() const			{ return m_pecb->LpszVersion(); }
	BOOL FAuthenticated() const			{ return m_pecb->FAuthenticated(); }

	BOOL FGetServerVariable(LPCSTR	pszName,
							LPSTR	pszValue,
							DWORD *	pcbValue) const
		{ return m_pecb->FGetServerVariable(pszName, pszValue, pcbValue); }

	DWORD CbTotalRequestBytes() const 		{ return m_pecb->CbTotalBytes(); }
	DWORD CbAvailableRequestBytes() const 	{ return m_pecb->CbAvailable(); }

	//	Destination url access ------------------------------------------------
	//
	SCODE __fastcall ScGetDestination( LPCWSTR* ppwszUrl,
									   LPCWSTR* ppwszPath,
									   UINT* pcchPath,
									   CVRoot** ppcvr = NULL) const;

	//	Uncommon header access wide -------------------------------------------
	//
	LPCWSTR LpwszGetRequestHeader( LPCSTR pszName, BOOL fUrlConversion ) const
	{
		//	Assert that this is not one of the common headers handled above
		//
		Assert (_stricmp (gc_szTranslate, pszName));
		Assert (_stricmp (gc_szOverwrite, pszName));
		Assert (_stricmp (gc_szDepth, pszName));
		Assert (_stricmp (gc_szDestination, pszName));

		return m_prequest->LpwszGetHeader(pszName, fUrlConversion);
	}

	//	IIS Access ------------------------------------------------------------
	//
	SCODE ScIISAccess( LPCWSTR pwszURI,
					   DWORD dwAccessRequested,
					   DWORD* pdwAccessOut = NULL) const;

	//	Utility function to tell whether the scriptmap has an
	//	applicable entry for a given URI and access.
	//
	BOOL FInScriptMap( LPCWSTR pwszURI,
					   DWORD dwAccess,
					   BOOL * pfCGI = NULL,
					   SCODE * pscMatch = NULL) const;

	//	Child ISAPI invocation ------------------------------------------------
	//
	//	fForward = FALSE means just check if there's a scriptmap entry
	//	fCheckISAPIAccess means do extra ACL checking (workaround the ASP access bug)
	//	fKeepQueryString should only be set to FALSE on default doc processing
	//	pszQueryPrefix allows the query string to be prefixed with new data
	//	fIgnoreTFAccess if set to TRUE will ignore the access bits checking in translate: f case,
	//				  is handy when the acces bits are to be ignored by security checking functions
	//				  and function is used solely to redirect to the child ISAPI.
	//				  Example: we have real urls, constructed both from request URL
	//				  and relative URL parts from XML body (like B* methods). The object specified: t
	//				  by the request URL might need to be redirected to child ISAPI in the translate
	//				  case, while actual (constructed) URL-s might look like:
	//
	//						/exchange/user1/Inbox.asp/message.eml (where message.eml was relative part)
	//
	//				  if we do not disable the security checking on the request URL in translate: f case
	//				  we might be failed out up front in case for example script source access was disabled
	//				  and it turned to be that directory was named INBOX.ASP.
	//				  NOTE: of course later the security is being checked on each constructed URL separately,
	//						that is why we do not open the security hole.
	//
	//	fDoNotForward if set to TRUE instead of forwarding request to child ISAPI it will return bad gateway,
	//				  which is necessary in the case there would be an attempt to execute child ISAPI on the
	//				  URL that is a construct of the request URL and the relative URL that comes in the request
	//				  body (like in B* methods)
	//
	SCODE ScApplyChildISAPI( LPCWSTR pwszURI,
							 DWORD  dwAccess,
							 BOOL	fCheckISAPIAccess = FALSE,
							 BOOL	fKeepQueryString = TRUE) const;

	//	Apply child ISAPI if necessary, if not, verify if desired access
	//	is granted
	//
	SCODE ScIISCheck ( LPCWSTR pwszURI,
					   DWORD dwDesired = 0,
					   BOOL	fCheckISAPIAccess = FALSE) const;

	//	Move/Copy/Delete access
	//
	SCODE ScCheckMoveCopyDeleteAccess (
		/* [in] */ LPCWSTR pwszUrl,
		/* [in] */ CVRoot* pcvr,
		/* [in] */ BOOL fDirectory,
		/* [in] */ BOOL fCheckScriptmaps,
		/* [in] */ DWORD dwAccess);

	//	Url parsing/construction ----------------------------------------------
	//
	BOOL __fastcall FIsVRoot (LPCWSTR pwszURI);

	//	Exchange and FS uses different URL to path mappers.
	//
	SCODE ScStoragePathFromUrl( LPCWSTR pwszUrl,
								LPWSTR pwszPath,
								UINT * pcch ) const
	{
		return ::ScStoragePathFromUrl(
					*m_pecb,
					pwszUrl,
					pwszPath,
					pcch );
	}

	//	Construct the redirect url given the server name
	//
	SCODE ScConstructRedirectUrl( BOOL fNeedSlash,
								  LPSTR * ppszUrl,
								  LPCWSTR pwszServer = NULL ) const
	{
		return ::ScConstructRedirectUrl( *m_pecb,
										 fNeedSlash,
										 ppszUrl,
										 pwszServer );
	}

	SCODE ScStripAndCheckHttpPrefix( LPCWSTR * ppwszUrl ) const
	{
		return ::ScStripAndCheckHttpPrefix( *m_pecb,
											ppwszUrl );
	}


	//	Fetch the metadata for the request URI
	//
	IMDData& MetaData() const
	{
		return m_pecb->MetaData();
	}

	//	Fetch the metadata for an aribtrary URI.
	//	Note: use the MetaData() accessor above
	//	to get the metadata for the request URI.
	//
	HRESULT HrMDGetData( LPCWSTR pwszURI,
						 IMDData ** ppMDData )
	{
		Assert(m_pecb.get());
		return ::HrMDGetData( *m_pecb,
							  pwszURI,
							  ppMDData );
	}

	HRESULT HrMDGetData( LPCWSTR pwszMDPathAccess,
						 LPCWSTR pwszMDPathOpen,
						 IMDData ** ppMDData )
	{
		Assert(m_pecb.get());
		return ::HrMDGetData( *m_pecb,
							  pwszMDPathAccess,
							  pwszMDPathOpen,
							  ppMDData );
	}

	HRESULT HrMDIsAuthorViaFrontPageNeeded( BOOL * pfFrontPageWeb ) const
	{
		Assert( pfFrontPageWeb );

		return ::HrMDIsAuthorViaFrontPageNeeded(*m_pecb,
												m_pecb->PwszMDPathVroot(),
												pfFrontPageWeb);
	}

	BOOL FGetContentType( LPCWSTR  pwszURI,
						  LPWSTR   pwszContentType,
						  UINT *  pcchContentType ) const
	{
		return ::FGetContentTypeFromURI( *m_pecb,
										 pwszURI,
										 pwszContentType,
										 pcchContentType );
	}

	SCODE ScSetContentType( LPCWSTR pwszURI,
							LPCWSTR pwszContentType )
	{
		return ::ScSetContentType( *m_pecb,
								   pwszURI,
								   pwszContentType );
	}

	//	Url and child virtual directories -------------------------------------
	//
	SCODE ScFindChildVRoots( LPCWSTR pwszUri,
							 ChainedStringBuffer<WCHAR>& sb,
							 CVRList& vrl )
	{
		//	Get the wide metapath, and make sure the URL is
		//	stripped before we call into the MDPath processing
		//
		Assert (pwszUri == PwszUrlStrippedOfPrefix (pwszUri));
		UINT cb = ::CbMDPathW(*m_pecb, pwszUri);
		CStackBuffer<WCHAR,MAX_PATH> pwszMetaPath;
		if (NULL == pwszMetaPath.resize(cb))
			return E_OUTOFMEMORY;

		//	Find the vroot
		//
		MDPathFromURIW (*m_pecb, pwszUri, pwszMetaPath.get());
		return CChildVRCache::ScFindChildren( *m_pecb, pwszMetaPath.get(), sb, vrl );
	}

	BOOL FGetChildVRoot( LPCWSTR pwszMetaPath, auto_ref_ptr<CVRoot>& cvr )
	{
		return CChildVRCache::FFindVroot( *m_pecb, pwszMetaPath, cvr );
	}

	BOOL FFindVRootFromUrl( LPCWSTR pwszUri, auto_ref_ptr<CVRoot>& cvr )
	{
		//	Get the wide metapath, and make sure the URL is
		//	stripped before we call into the MDPath processing
		//
		Assert (pwszUri == PwszUrlStrippedOfPrefix (pwszUri));
		UINT cb = ::CbMDPathW(*m_pecb, pwszUri);
		CStackBuffer<WCHAR,MAX_PATH> pwszMetaPath(cb);
		if (NULL == pwszMetaPath.resize(cb))
			return FALSE;

		//	Build the path and go...
		//
		MDPathFromURIW (*m_pecb, pwszUri, pwszMetaPath.get());
		_wcslwr (pwszMetaPath.get());

		//	If the last char of the metabase path is a slash, trim
		//	it.
		//
		cb = static_cast<UINT>(wcslen(pwszMetaPath.get()));
		if (L'/' == pwszMetaPath[cb - 1])
			pwszMetaPath[cb - 1] = L'\0';

		//	Find the vroot
		//
		return CChildVRCache::FFindVroot( *m_pecb, pwszMetaPath.get(), cvr );
	}

	//	Exception handler -----------------------------------------------------
	//
	//	Impls must call this function whenever they catch an exception on
	//	a thread other than the thread on which the request initially
	//	executed.  This call causes a 500 Server Error response to be sent
	//	if no other response is already in the process of being sent (only
	//	a problem for chunked responses).  It also ensures that the
	//	EXTENSION_CONTROL_BLOCK from IIS will be properly cleaned up
	//	regardless whether the pmu or any other object gets leaked as a result
	//	of the exception.  This last function keeps IIS from hanging on
	//	shutdown.
	//
	void HandleException()
	{
		//
		//	Just forward the exception handling to the ECB and hope it works.
		//	If it doesn't then there is nothing we can do about it -- we
		//	may leak the ECB which would cause IIS to hang on shutdown.
		//
		(VOID) m_pecb->HSEHandleException();
	}

	//	Async error response handler ------------------------------------------
	//
	//	Used to handle non-exception asynchronous error responses.  The main
	//	distinction between the exception and non-exception case is that in
	//	the exception case we force a cleanup of the ECB, but here we don't.
	//	Also, the exception case is hardwired to 500 Internal Server Error,
	//	but this function can be used to send any 500 level error (e.g. a
	//	503 Service Unavailable).
	//
	VOID SendAsyncErrorResponse( DWORD dwStatusCode,
								 LPCSTR pszBody = NULL,
								 DWORD cchzBody = 0,
								 LPCSTR pszStatusDescription = NULL,
								 DWORD cchzStatusDescription = 0 )
	{
		m_pecb->SendAsyncErrorResponse( dwStatusCode,
										pszBody,
										cchzBody,
										pszStatusDescription,
										cchzStatusDescription );
	}

	//	Request body access ---------------------------------------------------
	//
	BOOL FExistsRequestBody() const
	{
		return m_prequest->FExistsBody();
	}

	IStream * GetRequestBodyIStream( IAsyncIStreamObserver& obs ) const
	{
		return m_prequest->GetBodyIStream(obs);
	}

	VOID AsyncPersistRequestBody( IAsyncStream& stm,
								  IAsyncPersistObserver& obs ) const
	{
		m_prequest->AsyncImplPersistBody( stm, obs );
	}

	//	Response manipulators -------------------------------------------------
	//
	SCODE ScRedirect( LPCSTR pszURI )
	{
		return m_presponse->ScRedirect(pszURI);
	}

	void RestartResponse()
	{
		m_presponse->ClearHeaders();
		m_presponse->ClearBody();
	}

	void SupressBody()
	{
		//	This should only be called by an IMPL. in response to a HEAD
		//	request...
		//
		Assert (MID_HEAD == MidMethod());
		m_presponse->SupressBody();
	}

	void SetResponseCode( ULONG		ulCode,
						  LPCSTR	lpszBodyDetail,
						  UINT		uiBodyDetail,
						  UINT		uiCustomSubError = CSE_NONE )
	{
		m_presponse->SetStatus( ulCode,
								NULL,
								uiCustomSubError,
								lpszBodyDetail,
								uiBodyDetail );
	}

	void SetResponseHeader( LPCSTR	pszName,
							LPCSTR	pszValue,
							BOOL	fMultiple = FALSE )
	{
		m_presponse->SetHeader(pszName, pszValue, fMultiple);
	}

	void SetResponseHeader( LPCSTR	pszName,
							LPCWSTR	pwszValue,
							BOOL	fMultiple = FALSE )
	{
		m_presponse->SetHeader(pszName, pwszValue, fMultiple);
	}

	void AddResponseStream( LPSTREAM pstm )
	{
		Assert( !IsBadReadPtr(pstm, sizeof(IStream)) );
		m_presponse->AddBodyStream(*pstm);
	}

	void AddResponseStream( LPSTREAM pstm,
							UINT     ibOffset,
							UINT     cbSize )
	{
		Assert( cbSize > 0 );
		Assert( !IsBadReadPtr(pstm, sizeof(IStream)) );
		m_presponse->AddBodyStream(*pstm, ibOffset, cbSize);
	}

	void AddResponseBodyPart( IBodyPart * pBodyPart )
	{
		m_presponse->AddBodyPart( pBodyPart );
	}

	//	Common response emission routines -------------------------------------
	//
	void __fastcall EmitLocation (	LPCSTR pszHeader,
									LPCWSTR pwszURI,
									BOOL fCollection);

	void __fastcall EmitLastModified (FILETIME * pft);
	void __fastcall EmitCacheControlAndExpires (LPCWSTR pwszUrl);

	SCODE __fastcall ScEmitHeader (LPCWSTR pwszContent,
								   LPCWSTR pwszURI = NULL,
								   FILETIME* pftLastModification = NULL);


	//	Etags -----------------------------------------------------------------
	//
	void __fastcall EmitETag (FILETIME * pft);
	void __fastcall EmitETag (LPCWSTR pwszPath);

	//	Deferred Sends --------------------------------------------------------
	//

	//
	//	DeferResponse()
	//
	//	If called in an implementation method, this function prevents the
	//	default automatic sending of the response upon the implementation
	//	method's return.
	//
	//	After calling this function the implementation must call either
	//	SendPartialResponse() or SendCompleteResponse() to send the response.
	//
	void DeferResponse()			{ m_presponse->Defer(); }

	//
	//	SendPartialResponse()
	//
	//	Starts sending accumulated response data.  The impl is expected to
	//	continue adding response data after calling this function.  The impl
	//	must call SendCompleteResponse() to indicate when it is done adding
	//	response data.
	//
	void SendPartialResponse()		{ m_presponse->SendPartial(); }

	//
	//	SendCompleteResponse()
	//
	//	Starts sending accumulated response data.  Indicates that the impl
	//	is done adding response data.  The impl must not add response data
	//	after calling this function.
	//
	void SendCompleteResponse()		{ m_presponse->SendComplete(); }

	//	Expiration/Cache-Control ----------------------------------------------
	//
	SCODE ScGetExpirationTime( IN		LPCWSTR	pwszURI,
							   IN		LPWSTR	pwszExpire,
							   IN OUT	UINT *	pcch);

	//	Allow header ----------------------------------------------------------
	//
	void SetAllowHeader (RESOURCE_TYPE rt);

	//	Metadata helpers ------------------------------------------------------
	//
	UINT CbMDPathW(LPCWSTR pwszUrl) const { return ::CbMDPathW(*m_pecb, pwszUrl); }
	VOID MDPathFromUrlW( LPCWSTR pwszUrl, LPWSTR pwszMDPath )
	{
		::MDPathFromURIW (*m_pecb, pwszUrl, pwszMDPath);
	}
};

typedef CMethUtil * LPMETHUTIL;
typedef CMethUtil IMethUtil;

//	========================================================================
//
//	STRUCT SImplMethods
//
//	Implementation methods
//
typedef void (DAVMETHOD)( LPMETHUTIL );

extern DAVMETHOD DAVOptions;
extern DAVMETHOD DAVGet;
extern DAVMETHOD DAVHead;
extern DAVMETHOD DAVPut;
extern DAVMETHOD DAVPost;
extern DAVMETHOD DAVDelete;
extern DAVMETHOD DAVMove;
extern DAVMETHOD DAVCopy;
extern DAVMETHOD DAVMkCol;
extern DAVMETHOD DAVPropFind;
extern DAVMETHOD DAVPropPatch;
extern DAVMETHOD DAVSearch;
extern DAVMETHOD DAVLock;
extern DAVMETHOD DAVUnlock;
extern DAVMETHOD DAVSubscribe;
extern DAVMETHOD DAVUnsubscribe;
extern DAVMETHOD DAVPoll;
extern DAVMETHOD DAVBatchDelete;
extern DAVMETHOD DAVBatchMove;
extern DAVMETHOD DAVBatchCopy;
extern DAVMETHOD DAVBatchPropFind;
extern DAVMETHOD DAVBatchPropPatch;
extern DAVMETHOD DAVEnumAtts;
extern DAVMETHOD DAVUnsupported;	// Returns 501 Not Supported

//	========================================================================
//
//	IIS ISAPI Extension interface
//
class CDAVExt
{
public:
	static BOOL FInitializeDll( HINSTANCE, DWORD );
	static BOOL FVersion ( HSE_VERSION_INFO * );
	static BOOL FTerminate();
	static VOID LogECBString( LPEXTENSION_CONTROL_BLOCK, LONG, LPCSTR );
	static DWORD DwMain( LPEXTENSION_CONTROL_BLOCK, BOOL fUseRawUrlMappings = FALSE );
};

//	Map last error to HTTP response code --------------------------------------
//
UINT HscFromLastError (DWORD dwErr);
UINT HscFromHresult (HRESULT hr);
UINT CSEFromHresult (HRESULT hr);

//	Virtual root mappings -----------------------------------------------------
//
BOOL FWchFromHex (LPCWSTR pwsz, WCHAR * pwch);

//	Lock header lookup --------------------------------------------------------
//
BOOL FGetLockTimeout (LPMETHUTIL pmu, DWORD * pdwSeconds, DWORD dwMaxOverride = 0);

//	Content type mappings -----------------------------------------------------
//
SCODE ScIsAcceptable (IMethUtil * pmu, LPCWSTR pwszContent);
SCODE ScIsContentType (IMethUtil * pmu, LPCWSTR pwszType, LPCWSTR pwszTypeAnother = NULL);
inline SCODE ScIsContentTypeXML(IMethUtil * pmu)
{
	return ScIsContentType(pmu, gc_wszText_XML, gc_wszApplication_XML);
}

//	Range header processors ---------------------------------------------------
//
class CRangeParser;

SCODE
ScProcessByteRanges(
	/* [in] */ IMethUtil * pmu,
	/* [in] */ LPCWSTR pwszPath,
	/* [in] */ DWORD dwSizeLow,
	/* [in] */ DWORD dwSizeHigh,
	/* [in] */ CRangeParser * pByteRange );

SCODE
ScProcessByteRangesFromEtagAndTime (
	/* [in] */ IMethUtil * pmu,
	/* [in] */ DWORD dwSizeLow,
	/* [in] */ DWORD dwSizeHigh,
	/* [in] */ CRangeParser *pByteRange,
	/* [in] */ LPCWSTR pwszEtag,
	/* [in] */ FILETIME * pft );

//	Non-Async IO on Top of Overlapped Files -----------------------------------
//
BOOL ReadFromOverlapped (HANDLE hf,
	LPVOID pvBuf,
	ULONG cbToRead,
	ULONG * pcbRead,
	OVERLAPPED * povl);
BOOL WriteToOverlapped (HANDLE hf,
	const void * pvBuf,
	ULONG cbToRead,
	ULONG * pcbRead,
	OVERLAPPED * povl);

//	DAVEX LOCK Support routines -----------------------------------------------
//
class CXMLEmitter;
class CEmitterNode;
SCODE   ScBuildLockDiscovery (CXMLEmitter& emitter,
							  CEmitterNode& en,
							  LPCWSTR wszLockToken,
							  LPCWSTR wszLockType,
							  LPCWSTR wszLockScope,
							  BOOL fRollback,
							  BOOL fDepthInfinity,
							  DWORD dwTimeout,
							  LPCWSTR pwszOwnerComment,
							  LPCWSTR pwszSubType);

//	========================================================================
//
//	CLASS CXMLBody
//		This class is wrapper around CTextBodyPart, it collects small XML pieces
//	and save them in a CTextBodyPart, the body part will be added to body part
//	list when it grow large enough. This avoid contructing CTextBodyPart too
//	frequently.
//
class CXMLBody : public IXMLBody
{
private:
	auto_ptr<CTextBodyPart>		m_ptbp;
	auto_ref_ptr<IMethUtil>		m_pmu;
	BOOL						m_fChunked;

	//	non-implemented
	//
	CXMLBody(const CXMLBody& p);
	CXMLBody& operator=(const CXMLBody& p);

	//	Helper
	//
	VOID	SendCurrentChunk()
	{
		XmlTrace ("Dav: Xml: adding %ld bytes to body\n", m_ptbp->CbSize64());
		m_pmu->AddResponseBodyPart (m_ptbp.relinquish());

		//$REVIEW: The auto_ptr clas defined in \inc\autoptr.h is different from
		//$REVIEW: the one defined in \inc\ex\autoptr.h. it does not set px
		//$REVIEW: to zero when it relinquish. I believe this is a bug. I am not
		//$REVIEW: sure if anyone is relying on this behavior, so I did not go ahead
		//$REVIEW: fix the relinquish(), a better/complete fix will be moving
		//$REVIEW: everyoen to \inc\ex\autoptr.h
		//$REVIEW:
		m_ptbp.clear();

		//	Send the data from this chunk back to the client before
		//	we go fetch the next chunk.
		//
		if (m_fChunked)
			m_pmu->SendPartialResponse();
	}

public:
	//	ctor & dtor
	//
	CXMLBody (IMethUtil * pmu, BOOL fChunked = TRUE)
			:	m_pmu(pmu),
				m_fChunked(fChunked)
	{
	}

	~CXMLBody ()
	{
	}

	//	IXMLBody methods
	//
	SCODE ScAddTextBytes ( UINT cbText, LPCSTR lpszText );

	VOID Done()
	{
		if (m_ptbp.get())
			SendCurrentChunk();
	}
};

SCODE ScAddTitledHref (CEmitterNode& enParent,
					   IMethUtil * pmu,
					   LPCWSTR pwszTag,
					   LPCWSTR pwszPath,
					   BOOL fCollection = FALSE,
					   CVRoot* pcvrTranslate = NULL);

inline
SCODE ScAddHref (CEmitterNode& enParent,
				 IMethUtil * pmu,
				 LPCWSTR pwszPath,
				 BOOL fCollection = FALSE,
				 CVRoot* pcvrTranslate = NULL)
{
	return ScAddTitledHref (enParent,
							pmu,
							gc_wszXML__Href,
							pwszPath,
							fCollection,
							pcvrTranslate);
}

//$HACK:ROSEBUD_TIMEOUT_HACK
//  For the bug where rosebud waits until the last second
//  before issueing the refresh. Need to filter out this check with
//  the user agent string. The hack is to increase the timeout
//	by 30 seconds and send back the requested timeout.
//
DEC_CONST gc_dwSecondsHackTimeoutForRosebud = 120;

//$HACK:END:ROSEBUD_TIMEOUT_HACK
//

#endif // !defined(_DAVIMPL_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\eventlog.h ===
/*
 *	E V E N T L O G . H
 *
 *	Event log interface
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef _EVNTLOG_H_
#define _EVNTLOG_H_

EXTERN_C const WCHAR gc_wszSignature[]; 

VOID LogEventW( DWORD     dwEventID,
				WORD      wEventType,
				WORD      wcDataStrings,
				LPCWSTR * plpwszDataStrings,
				DWORD     dwcbRawData,
			    LPVOID    lpvRawData,
				WORD	  wEventCategory=0);

VOID LogEvent( DWORD    dwEventID,
			   WORD     wEventType,
			   WORD     wcDataStrings,
			   LPCSTR * plpszDataStrings,
			   DWORD    dwcbRawData,
	           LPVOID   lpvRawData,
			   WORD		wEventCategory=0);

STDAPI EventLogDllRegisterServer( LPCWSTR lpwszDllPath, DWORD dwCategories = 0 );
STDAPI EventLogDllUnregisterServer();

#endif // _EVNTLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\except.h ===
#ifndef _EXCEPT_H_
#define _EXCEPT_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	EXCEPT.H
//
//		Exception classes used by this implementation
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include <stdexcpt.h>
#include <eh.h>

#include <caldbg.h>		//	For gc_szDbgIni definition

//	------------------------------------------------------------------------
//
//	CLASS CWin32ExceptionHandler
//
//		Handles Win32 exceptions (access violations, alignment faults, etc.)
//		by constructing a C++ exception from information in the Win32 SEH
//		exception record and throwing it.
//
class CWin32ExceptionHandler
{
	_se_translator_function			m_pfnOldHandler;

	static void __cdecl HandleWin32Exception( unsigned int, struct _EXCEPTION_POINTERS * );

public:
	CWin32ExceptionHandler();
	~CWin32ExceptionHandler();
};

//	------------------------------------------------------------------------
//
//	CLASS CDAVException
//
class CDAVException : public exception
{
public:
	//	CREATORS
	//
	CDAVException( const char * s = "DAV fatal error exception" );

	//	ACCESSORS
	//
#ifdef DBG
	virtual void DbgTrace() const;
#else
	void DbgTrace() const {}
#endif

	//	ACCESSORS
	//
	virtual HRESULT Hresult() const;
	virtual DWORD   DwLastError() const;
};


//	------------------------------------------------------------------------
//
//	CLASS CHresultException
//
class CHresultException : public CDAVException
{
	HRESULT	m_hr;

public:
	CHresultException( HRESULT hr, const char * s = "HRESULT exception" ) :
		CDAVException(s),
		m_hr(hr)
	{
	}

	virtual HRESULT Hresult() const;
};


//	------------------------------------------------------------------------
//
//	CLASS CLastErrorException
//
class CLastErrorException : public CDAVException
{
	DWORD	m_dwLastError;

public:
	CLastErrorException( const char * s = "LastError exception" ) :
		CDAVException(s),
		m_dwLastError(GetLastError())
	{
	}

	virtual DWORD DwLastError() const;
};


//	------------------------------------------------------------------------
//
//	CLASS CWin32Exception
//
//		This exception is thrown as a result of any Win32 exception
//		(access violation, alignment fault, etc.)  By catching it
//		you can better determine what happened.
//
class CWin32Exception : public CDAVException
{
	unsigned int						m_code;
	const struct _EXCEPTION_POINTERS&	m_ep;


	//	NOT IMPLEMENTED
	//
	CWin32Exception& operator=( const CWin32Exception& );

public:
	//	CREATORS
	//
	CWin32Exception( unsigned int code, const struct _EXCEPTION_POINTERS& ep ) :
		CDAVException(),
		m_code(code),
		m_ep(ep)
	{
	}

	//	ACCESSORS
	//
#ifdef DBG
	virtual void DbgTrace() const;
#endif
};

#endif // !defined(_EXCEPT_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\implstub.h ===
#ifndef _IMPLSTUB_H_
#define _IMPLSTUB_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	IMPLSTUB.H
//
//	This file is similar to impldef.h. The difference is that impldefs.h are
//	meant to be implemented by ISAPI dlls. and this implstub.h are for
//	those functions that might be implemented by all CAL componets.
//

namespace IMPLSTUB
{
	VOID __fastcall SaveHandle(HANDLE hHandle);
}

#endif  // _IMPLSTUB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\htmlmap.h ===
/*
 *	H T M L M A P . H
 *
 *	HTML .MAP file processing
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_HTMLMAP_H_
#define _HTMLMAP_H_

BOOL
FIsMapProcessed (
	LPCSTR lpszQueryString,
	LPCSTR lpszUrlPrefix,
	LPCSTR lpszServerName,
	LPCSTR pszMap,
	BOOL * pfRedirect,
	LPSTR pszRedirect,
	UINT cchBuf);

#endif	// _HTMLMAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\exguid.h ===
//	========================================================================
//
//	X G U I D . H
//
//		Header file for common GUID related data shared by DAVEX, EXOLEDB
//		and EXDAV.
//
//	========================================================================

#ifndef _XGUID_H_
#define _XGUID_H_

#define USES_PS_MAPI
#define USES_PS_PUBLIC_STRINGS
#define USES_PS_INTERNET_HEADERS
#include <mapiguid.h>

//	An enumeration of all the well-known GUIDs. Specifying a GUID by its
//	enumeration avoids marshalling and unmarshalling the entire GUID.
//$REVIEW: If the number of well-known GUIDs ever gets greater than TWELVE
//$REVIEW: we need to find another scheme to represent them. This is
//$REVIEW: because, during marshalling, we lay out the GUIDs after the
//$REVIEW: MAPINAMEID array in our buffer and convert their addresses
//$REVIEW: into offsets. The minimum offset is 12(size of MAPINAMEID
//$REVIEW: structure) when we have a single sized array. We don't want
//$REVIEW: to confuse an offset with a well-known GUID and vice-versa.
//$LATER: There is no point in having an enumeration of just one guid.
//	We should add some of the other well-known guids such as PS_MAPI,
//	PS_INTERNET_HEADERS and the outlook guids or remove this enumeration
//	altogether.
//
enum {
	FIRST_GUID,
	MAPI_PUBLIC = FIRST_GUID,
	LAST_GUID = MAPI_PUBLIC
};

//	A table of well-known guids for quick access.
//
const LPGUID rgGuidTable[LAST_GUID - FIRST_GUID + 1] = {
	(LPGUID)&PS_PUBLIC_STRINGS,
};

/*
 *	FWellKnownGUID
 *
 *	Purpose:
 *		Determines if a GUID is a well-known one. Well-known GUIDS are
 *		enumerated above. If a GUID is well-known, its pointer is a
 *		special value equal to its enumeration.
 *	Arguments:
 *		lpguid		Pointer to the GUID
 *	Returns:
 *		TRUE if the GUID is well known
 *		FALSE otherwise
 */
__inline BOOL
FWellKnownGUID(LPGUID lpguid)
{
	//	No need to compare lpguid with FIRST_GUID, as it's always greater
	//	than FIRST_GUID. Acutally, such comparison may cause C4296 in build
	//
	if (LAST_GUID >= (DWORD_PTR)lpguid)
		return TRUE;
	else return FALSE;
}

#endif //!_XGUID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\impldef.h ===
#ifndef	_IMPLDEF_H_
#define _IMPLDEF_H_

//	Implementation defined items ----------------------------------------------
//
//	The following must be DEFINED by the IMPL for use by the PARSER.
//

//	Allow header items --------------------------------------------------------
//
//	The impl. needs to define the following set of strings that identify the
//	methods supported by the impl. for particular resources.
//
extern const CHAR gc_szHttpBase[];
extern const CHAR gc_szHttpDelete[];
extern const CHAR gc_szHttpPut[];
extern const CHAR gc_szHttpPost[];
extern const CHAR gc_szDavCopy[];
extern const CHAR gc_szDavMove[];
extern const CHAR gc_szDavMkCol[];
extern const CHAR gc_szDavPropfind[];
extern const CHAR gc_szDavProppatch[];
extern const CHAR gc_szDavLocks[];
extern const CHAR gc_szDavSearch[];
extern const CHAR gc_szDavNotif[];
extern const CHAR gc_szDavBatchDelete[];
extern const CHAR gc_szDavBatchCopy[];
extern const CHAR gc_szDavBatchMove[];
extern const CHAR gc_szDavBatchProppatch[];
extern const CHAR gc_szDavBatchPropfind[];
extern const CHAR gc_szDavPublic[];
extern const CHAR gc_szCompliance[];
extern const UINT gc_cbszDavPublic;

//	Storage paths and urls ----------------------------------------------------
//
//	The storage path for a resource is no-different that the path as translated
//	by IIS.  This has not always been true, and there is code in the DAV source
//	tree that expects the path to have some sort of a prefix.
//
//	At the beginning of NT beta3 work, we are removing the idea that a storage
//	path in DAV looks any different than a storage path in IIS.  This is a very
//	important idea.  Otherwise, there could be items accessible via DAV that
//	are not accessible via IIS -- and visa versa.
//
//	Keeping this in mind...  There are several places where we have url's that
//	are a part of a DAV request that are not pre-handled for us by IIS.  Some
//	examples are the url's in the destination header of MOVE/COPY, the url's in
//	the scope of a SEARCH request, and the url's embedded in "if" headers.
//
//	There are also several instances where we may have to generate a url from
//	a storage path  -- as in the case of location headers and XML response
//	references.
//
//	The translation of those items uses only common elements.  So there is no
//	implementation specifc work that needs to be done here.
//

class IMethUtilBase;
class CMethUtil;
typedef CMethUtil IMethUtil;

//	The call to be used for proper conversion to unicode
//
SCODE __fastcall
ScConvertToWide(/* [in]     */	LPCSTR	pszSource,
				/* [in/out] */  UINT *	pcchDest,
				/* [out]    */	LPWSTR	pwszDest,
				/* [in]		*/	LPCSTR	pszAcceptLang,
				/* [in]		*/	BOOL	fUrlConversion);

//	The call to be used for canonicalization of URL
//
SCODE __fastcall
ScCanonicalizeURL( /* [in]     */ LPCWSTR pwszSrc,
				   /* [in/out] */ LPWSTR pwszDest,
				   /* [out]	   */ UINT * pcch );

//	The call to be used for canonicalization of URL,
//	taking into account if it is fully qualified
//
SCODE __fastcall
ScCanonicalizePrefixedURL( /* [in]     */ LPCWSTR pwszSrc,
						   /* [in/out] */ LPWSTR pwszDest,
						   /* [out]	   */ UINT * pcch );


//	These are the calls to be used to normalize URL
//
//	Normalization consists of 3 steps:
//		a) escaping of skinny version
//		b) conversion to unicode
//		c) canonicalization
//
SCODE __fastcall
ScNormalizeUrl (
	/* [in]     */	LPCWSTR			pwszSourceUrl,
	/* [in/out] */  UINT *			pcchNormalizedUrl,
	/* [out]    */	LPWSTR			pwszNormalizedUrl,
	/* [in]		*/	LPCSTR			pszAcceptLang);

SCODE __fastcall
ScNormalizeUrl (
	/* [in]     */	LPCSTR			pszSourceUrl,
	/* [in/out] */  UINT *			pcchNormalizedUrl,
	/* [out]    */	LPWSTR			pwszNormalizedUrl,
	/* [in]		*/	LPCSTR			pszAcceptLang);

SCODE __fastcall ScStoragePathFromUrl (
		/* [in] */ const IEcb& ecb,
		/* [in] */ LPCWSTR pwszUrl,
		/* [out] */ LPWSTR wszStgID,
		/* [in/out] */ UINT* pcch,
		/* [out] */ CVRoot** ppcvr = NULL);

SCODE __fastcall ScUrlFromStoragePath (
		/* [in] */ const IEcbBase& ecb,
		/* [in] */ LPCWSTR pwszPath,
		/* [out] */ LPWSTR pwszUrl,
		/* [in/out] */ UINT * pcb,
		/* [in] */ LPCWSTR pwszServer = NULL);

SCODE __fastcall ScUrlFromSpannedStoragePath (
		/* [in] */ LPCWSTR pwszPath,
		/* [in] */ CVRoot& vr,
		/* [in] */ LPWSTR pwszUrl,
		/* [in/out] */ UINT* pcch);

//	Wire urls -----------------------------------------------------------------
//
//	A note about a wire url.  IIS translate all its urls into CP_ACP.  So, to
//	keep consistant behavior in HTTPEXT, we also keep all local urls in CP_ACP.
//	However, for DAVEX, we don't hold to this.  We deal exclusively in CP_UTF8
//	style URLs.
//
//	However, when we spit the url back out over the wire.  The url must be in
//	UTF8.  Anytime a url goes back over the wire from IIS to client, it must be
//	sanitized via these calls.
//
SCODE __fastcall ScWireUrlFromWideLocalUrl (
		/* [in] */ UINT cchLocal,
		/* [in] */ LPCWSTR pwszLocalUrl,
		/* [in/out] */ auto_heap_ptr<CHAR>& pszWireUrl);

SCODE __fastcall ScWireUrlFromStoragePath (
		/* [in] */ IMethUtilBase* pmu,
		/* [in] */ LPCWSTR pwszStoragePath,
		/* [in] */ BOOL fCollection,
		/* [in] */ CVRoot* pcvrTranslate,
		/* [in/out] */ auto_heap_ptr<CHAR>& pszWireUrl);

BOOL __fastcall FIsUTF8Url (/* [in] */ LPCSTR pszUrl);

//	Child ISAPI aux. access check ---------------------------------------------
//
//	On both HTTPEXT and DAVEX, we have an additional stipulation that needs
//	satisfaction before we can hand back the source of an scriptmapped item.
//	We want to see if it has NT write access.
//	Note that among the parameters, pwszPath is used by HTTPEXT only and
//	pbSD is used by DAVEX only
//

SCODE __fastcall ScChildISAPIAccessCheck (
	/* [in] */ const IEcb& ecb,
	/* [in] */ LPCWSTR pwszPath,
	/* [in] */ DWORD dwAccess,
	/* [in] */ LPBYTE pbSD);

//	Supported lock types ------------------------------------------------------
//
//	Return the supported locktype flags for the resource type.  HTTPEXT only
//	supports documents and collections.  DavEX, on the other hand, understands
//	structured documents.
//

DWORD __fastcall DwGetSupportedLockType (RESOURCE_TYPE rtResource);

//	Access perm hack for DAVEX ------------------------------------------------
//
//$SECURITY
//	In DAVEX only, if either a VR_USERNAME or VR_PASSWORD is set then
//	to avoid a security problem, shut off all access.
//
VOID ImplHackAccessPerms( LPCWSTR pwszVRUserName,
						  LPCWSTR pwszVRPassword,
						  DWORD * pdwAccessPerms );

//	DLL instance refcounting --------------------------------------------------
//
VOID AddRefImplInst();
VOID ReleaseImplInst();

//	Exception safe DLL instance refcounting -----------------------------------
//
typedef enum {
	ADD_REF = 0,
	TAKE_OWNERSHIP
} REF_ACTION;

class safeImplInstRef
{
	BOOL m_fRelease;

	//	NOT IMPLEMENTED
	//
	safeImplInstRef( const safeImplInstRef& );
	safeImplInstRef& operator=( const safeImplInstRef& );

public:

	//	CREATORS
	//
	safeImplInstRef(REF_ACTION ra) : m_fRelease(TRUE)
	{
		if (ADD_REF == ra)
			AddRefImplInst();
	}

	//	DESTRUCTOR
	//
	~safeImplInstRef()
	{
		if (m_fRelease)
			ReleaseImplInst();
	}

	//	MANIPULATOR
	//
	VOID relinquish()
	{
		m_fRelease = FALSE;
	}
};

BOOL FSucceededColonColonCheck(
	/* [in] */  LPCWSTR pwszURI);

#endif	// _IMPLDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\exo.h ===
/*
 *	e x o . h
 *
 *	Purpose:
 *		Base Exchange COM Object
 *
 *		Any Exchange object that implements one or more COM interfaces
 *		should derive from EXObject and create an interface table
 *		using the macros below.
 *
 *	Originator:
 *		JohnKal
 *	Owner:
 *		BeckyAn
 *
 *	Copyright (C) Microsoft Corp 1993-1997. All rights reserved.
 */


//
//	How to use the macros (overview).
//	You need to do three things:
//		Declare your class.
//		Route your IUnknown processing to EXO.
//		Fill in EXO's data structures.
//
//	When declaring your class, you must:
//		Inherit from EXO.
//
//	To route your IUnknown processing to EXO:
//		Put the EXO[A]_INCLASS_DECL macro in the PUBLIC part of your class.
//			NOTE: This also declares the EXO static data in your class.
//
//	When filling in EXO's data structures:
//		In some source-file, build an interface mapping table.
//			BEGIN_INTERFACE_TABLE
//			INTERFACE_MAP
//			END_INTERFACE_TABLE
//		In the same source-file, after the interface mapping table,
//		declare & fill in the EXO class info structure.
//			EXO[A]_GLOBAL_DATA_DECL
//
//	Quick example:
//
/*
In snacks.h

class CSnackBag: public EXO, public IFiddle, public IFaddle
{
public:
	EXO_INCLASS_DECL(CSnackBag);

	// IFiddle methods
	// IFaddle methods
protected:
	// protected methods & data
private:
	// private methods & data
};

In snacks.cpp

BEGIN_INTERFACE_TABLE(CSnackBag)
	INTERFACE_MAP(CSnackBag, IFiddle),
	INTERFACE_MAP(CSnackBag, IFaddle)
END_INTERFACE_TABLE(CSnackBag);

EXO_GLOBAL_DATA_DECL(CSnackBag, EXO);

*/
//
//

#ifndef __exo_h_
#define __exo_h_


// Macros EXO needs ////////////////////////////////////////
// NOTE: All are named to avoid local name collisions, for your shopping convenience!

// Compute the offset to 'this' (of a specific type) when it's cast from one
// interface to another.  (concept: punk = (intf2) (intf1) (class) pobj --
// casting pobj, an instance of class, "from" intf1 "to" intf2.)
// We use them to get the offset from EXO (who is doing all the real work)
// to another interface in a particular class.
// NOTE: This is done in two steps because the compiler (VC5.0) was unable
// to figure out the math at compile-time when we subtracted one from the other.
// These values are used to initialize our static tables, and we don't
// want to explicitly call CRT_INIT just to get a few offsets.  So use two steps.
// (To get back to one step, combine these two steps as in ApplyDbCast, Down - Up).
// To is the delta of intf2 ("to") in cls.  From is the delta of intf1 ("from").
//
// NOTE: The 0x1000 for the pointer seems weird, but that is randomly chosen
// value and the thing we are interested in is the difference between the values
// of return from EXODbCastTo (IIDINFO::cbDown) and EXODbCastFrom (IIDINFO::cbUp).
//
#define EXODbCastTo(_cls, _intf1, _intf2)		((ULONG_PTR)static_cast<_intf2 *>(static_cast<_cls *>((void *)0x1000)))
#define EXODbCastFrom(_cls, _intf1, _intf2)		((ULONG_PTR)static_cast<_intf1 *>(static_cast<_cls *>((void *)0x1000)))

// apply that offset since the base class can't do it automagically
#define EXOApplyDbCast(_intf, _pobj, _cbTo, _cbFrom)	((_intf *)((BYTE *)_pobj + _cbTo - _cbFrom))

// Gives the count of elements in an array
#define EXOCElems(_rg)							(sizeof(_rg)/sizeof(_rg[0]))

// EXO is an abstract base class.  Since you can't instantiate him directly,
// he doesn't need his vtable pointers set in the ctor/dtor.  (And he
// promises not to do ANYTHING in his ctor/dtor that could cause a virtual
// function to be called).  So if we have a supporting MS C-compiler,
// turn off his vtables.
#if _MSC_VER<1100
#define EXO_NO_VTABLE
#else	// _MSC_VER check
#ifdef _EXO_DISABLE_NO_VTABLE
#define EXO_NO_VTABLE
#else	// !_EXODISABLE_NO_VTABLE
#define EXO_NO_VTABLE __declspec(novtable)
#endif	// _EXO_DISABLE_NO_VTABLE
#endif	// _MSC_VER check


// Global flag to turn on/off the EXO debug tracing.
#ifdef DBG
extern BOOL g_fExoDebugTraceOn;
#endif // DBG


// Interface map ////////////////////////////////////////


/*
 *  IIDINFO -- Interface ID (IID) INFOrmation
 *
 *	Contains a list of interfaces and offsets to convert an EXO-derived
 *	object pointer to that interface.
 */

typedef struct							// Information about interfaces.
{
	LPIID		iid;					// Interface ID.
	ULONG_PTR	cbDown;					// offset of interface from beginning
	ULONG_PTR	cbUp;					// of object.
#ifdef DBG
	LPTSTR		szIntfName;				// Interface name
#endif	// DBG
} IIDINFO;

// Macros for the name of a class's interface mapping table.
#define INTERFACE_TABLE(_cls) _cls ## ::c_rgiidinfo
#define DECLARE_INTERFACE_TABLE_INCLASS(_cls) static const IIDINFO c_rgiidinfo[]


// Helper macros to fill in the interface mapping table.
#ifdef DBG

#define INTERFACE_MAP_EX(_cl, _iid, _intf)			\
	{ (LPIID) & _iid, EXODbCastTo(_cl, EXO, _intf), EXODbCastFrom(_cl, EXO, _intf), TEXT(# _intf) }

#else	// !DBG

#define INTERFACE_MAP_EX(_cl, _iid, _intf)			\
	{ (LPIID) & _iid, EXODbCastTo(_cl, EXO, _intf), EXODbCastFrom(_cl, EXO, _intf) }

#endif	// DBG else


// Macros to actually fill in the interface mapping table.
//
// Use the BEGIN_INTERFACE_TABLE macro to start a table definition.
// Use the INTERFACE_MAP macro to express support for standard interfaces.
// These should be interfaces which, when prepended by IID_, yield a valid
// IID name. If you are doing advanced hackery, use the INTERFACE_MAP_EX
// macro instead. It allows you more control over which IID_ gets mapped
// to which interface.
// Use the END_INTERFACE_TABLE macro to end your table definition.
//
// NOTE: It is assumed that the very first interface of any non-aggregated
// class derived from EXO does double work as its IUnknown interface. This
// explains the '0' offset next to IID_IUnknown in the BEGIN_INTERFACE_TABLE
// macro below.

#ifdef DBG

#define BEGIN_INTERFACE_TABLE(_cl)					\
const IIDINFO INTERFACE_TABLE(_cl)[] =				\
{													\
	{ (LPIID) & IID_IUnknown, 0, 0, TEXT("IUnknown") },

#else	// DBG

#define BEGIN_INTERFACE_TABLE(_cl)					\
const IIDINFO INTERFACE_TABLE(_cl)[] =				\
{													\
	{ (LPIID) & IID_IUnknown, 0, 0 },
#endif	// DBG, else


#define INTERFACE_MAP(_cl, _intf)					\
	INTERFACE_MAP_EX(_cl, IID_ ## _intf, _intf)


#define END_INTERFACE_TABLE(_cl)					\
}


#ifdef EXO_CLASSFACTORY_ENABLED
// EXchange Object TYPes
// To be used with a general-purpose class factory.  These types
// can be used to check if a class needs special support in the DLL's
// self-registration (DllRegisterServer) routine.
enum {
	exotypNull = 0,			// invalid value
	exotypAutomation,		// OLE automation object derived from CAutomationObject
	exotypControl,			// ActiveX control derived from CInternetControl or COleControl
	exotypPropPage,			// property page derived from CPropertyPage
	exotypNonserver,		// not registered as an OLE server
};

// EXO prototype for a named constructor.  For use with a general-purpose
// class factory.
typedef HRESULT (* PFNEXOCLSINFO)(const struct _exoclsinfo *pxci, LPUNKNOWN punkOuter,
								  REFIID riid, LPVOID *ppvOut);
#endif // EXO_CLASSFACTORY_ENABLED


/*
 *	EXOCLSINFO -- EXchange Object CLaSs INFOrmation.
 *
 *	This structure contains all the constant class information of a
 *	particular class.  This includes the interface mapping table
 *	(IIDINFO count and array) and a pointer to the parent class's
 *	EXOCLSINFO structure.  These items are used by EXO's base implementation
 *	of QueryInterface.  The parent class here must be a subclass of EXO,
 *	or EXO itself if this class derives directly from EXO.  Thus these
 *	structures make a traceable chain of inforamtion back up to EXO, the root.
 *	For debugging purposes, a stringized version of the class name is included.
 *	In support of a general-purpose class factory, additional information,
 *	such as the CLSID and a standard creation function can be included.
 */

typedef struct _exoclsinfo
{
	UINT			ciidinfo;				// Count of interfaces this class supports.
	const IIDINFO * rgiidinfo;				// Info for interfaces this class supports.
	const _exoclsinfo * pexoclsinfoParent;	// Parent's EXOCLSINFO structure.
#ifdef DBG
	LPTSTR			szClassName;			// Class name -- for debug purposes.
#endif // DBG
#ifdef EXO_CLASSFACTORY_ENABLED
	// Data to use with a general, multi-class class factory.
	int				exotyp;					// type of the object
	const CLSID *	pclsid;					// CLaSs ID (NULL if not co-creatable)
	PFNEXOCLSINFO	HrCreate;				// Function to create an object of this class.
#endif // EXO_CLASSFACTORY_ENABLED
} EXOCLSINFO;

// Macros for the name of a class's exoclsinfo.
#define EXOCLSINFO_NAME(_cls) _cls ## ::c_exoclsinfo
#define DECLARE_EXOCLSINFO(_cls) const EXOCLSINFO EXOCLSINFO_NAME(_cls)
#define DECLARE_EXOCLSINFO_INCLASS(_cls) static const EXOCLSINFO c_exoclsinfo

// Helper macros to fill in the exoclsinfo.
#ifdef EXO_CLASSFACTORY_ENABLED
#ifdef DBG

#define EXOCLSINFO_CONTENT_EX(_cls, _iidinfoparent, _exotyp, _pclsid, _pfn) \
	{ EXOCElems(INTERFACE_TABLE(_cls)), INTERFACE_TABLE(_cls),	\
      (_iidinfoparent), TEXT( #_cls ),							\
	  (_exotyp), (LPCLSID) (_pclsid),	(_pfn) }				\

#else // !DBG

#define EXOCLSINFO_CONTENT_EX(_cls, _iidinfoparent, _exotyp, _pclsid, _pfn) \
	{ EXOCElems(INTERFACE_TABLE(_cls)), INTERFACE_TABLE(_cls),	\
      (_iidinfoparent),											\
	  (_exotyp), (LPCLSID) (_pclsid),	(_pfn) }				\

#endif // DBG, else
#else // !EXO_CLASSFACTORY_ENABLED
#ifdef DBG

#define EXOCLSINFO_CONTENT_EX(_cls, _iidinfoparent, _exotyp, _pclsid, _pfn) \
	{ EXOCElems(INTERFACE_TABLE(_cls)), INTERFACE_TABLE(_cls),	\
      (_iidinfoparent), TEXT( #_cls ) }

#else // !DBG

#define EXOCLSINFO_CONTENT_EX(_cls, _iidinfoparent, _exotyp, _pclsid, _pfn) \
	{ EXOCElems(INTERFACE_TABLE(_cls)), INTERFACE_TABLE(_cls),	\
      (_iidinfoparent), }

#endif // DBG, else
#endif // EXO_CLASSFACTORY_ENABLED

// Macro to actually fill in the exoclsinfo.
#define EXOCLSINFO_CONTENT(_cls, _clsparent)					\
	EXOCLSINFO_CONTENT_EX( _cls, &EXOCLSINFO_NAME(_clsparent),	\
        exotypNonserver, &CLSID_NULL, NULL )


// Macros to access members in the exoclsinfo structure.
#ifdef DBG
#define NAMEOFOBJECT(_pexoclsinfo)		 (((EXOCLSINFO *)(_pexoclsinfo))->szClassName)
#endif // DBG
#ifdef EXO_CLASSFACTORY_ENABLED
#define CLSIDOFOBJECT(_pexoclsinfo)		 (*(((EXOCLSINFO *)(_pexoclsinfo))->pclsid))
#define CREATEFNOFOBJECT(_pexoclsinfo)	 (((EXOCLSINFO *)(_pexoclsinfo))->HrCreate)
#endif // EXO_CLASSFACTORY_ENABLED


// EXO and EXOA declarations ////////////////////////////////////////

/*
 *	EXO is the base class of Exchange objects that present one or
 *	more COM interfaces. To derive from EXO, follow the example
 *	below:
 *
 *	class MyClass : public EXO, public ISomeInterface1, public ISomeInterface2
 *	{
 *	public:
 *		EXO_INCLASS_DECL(MyClass);
 *
 *		methods for ISomeInterface1
 *		methods for ISomeInterface2
 *
 *	protected:
 *		protected member functions & variables
 *
 *	private:
 *		private member functions & variables
 *	};
 *
 *
 *	DISCLAIMER: currently EXO inherits from IUnknown to prevent
 *	maintainability problems that would show up if
 *	(void *) pexo != (void *) (IUnknown *) pexo.  Yes, this means
 *	12 extra bytes in our vtable.  Those extra bytes are worth it
 *	(and we already had a vtable -- pure virt. dtor!).  Go deal.
 */
class EXO_NO_VTABLE EXO : public IUnknown
{
public:
	// Declare EXO's support structures.
	DECLARE_INTERFACE_TABLE_INCLASS(EXO);
	DECLARE_EXOCLSINFO_INCLASS(EXO);


protected:
	// Making the constructor protected prevents people from making these
	// objects on the stack. The pure virtual destructor forces derived
	// classes to implement their own dtors, and prevents instances of
	// EXObject from being created directly. Of course, a derived class
	// may want to allow the creation of instances on the stack. It is
	// up to such derived classes to make their own constructors public.

	EXO();
	virtual ~EXO() = 0;					// pure virtual destructor
										// forces derived classes to
										// implement their own dtors.

	// InternalQueryInterface() does the QI work for all for interfaces
	// supported by this class (directly and from a child aggregate).
	// Your class should route its QI work to this call using
	// EXO[A]_INCLASS_DECL 99.9% of the time.
	// Only override this if you have AGGREGATED another object and want to
	// get them in on the action.  And even then, make sure to call
	// this method, EXO::InternalQueryInterface, directly before searching
	// your aggregatee (kid) This is YOUR base QI!!
	// See the EXO implementation of this function for more important details.
	virtual HRESULT InternalQueryInterface(REFIID riid, LPVOID * ppvOut);

	// InternalAddRef() & InternalRelease() do the AddRef & Release work
	// for all descendents of EXO.  You should ALWAYS (100% of the time)
	// route AddRef/Release work to these functions.
	ULONG InternalAddRef();
	ULONG InternalRelease();

	// Virtual function to grab the correct lowest-level exoclsinfo struct.
	// All descendants who introduce a new interface (and thus have a new
	// interface mapping table) should implement this method (and pass back
	// an appropriately-chained exoclsinfo struct!) using one of these
	// macros: Iff you are an aggregator DECLARE_GETCLSINFO.  Otherwise,
	// EXO[A]_INCLASS_DECL will do the right stuff for you.
	virtual const EXOCLSINFO * GetEXOClassInfo() = 0;
		// Again, pure virtual to force derived classes to
		// implement their own before they can be instantiated.

	// Our reference counter.
	LONG m_cRef;
};


/*
 *	EXOA is the base class of Exchange objects that support being aggregated
 *	(in addition to having other OLE interfaces). To derive from EXOA, follow
 *	the example below:
 *
 *	class MyClass : public EXOA, public ISomeInterface1, public ISomeInterface2
 *	{
 *	public:
 *		EXOA_INCLASS_DECL(MyClass);
 *
 *		methods for ISomeInterface1
 *		methods for ISomeInterface2
 *
 *	protected:
 *		protected member functions & variables
 *
 *	private:
 *		private member functions & variables
 *	};
 */

class EXO_NO_VTABLE EXOA : public EXO
{
protected:
	// The following 3 methods are not virtual, so don't get into a tiff.
	HRESULT DeferQueryInterface(REFIID riid, LPVOID * ppvOut)
			{return m_punkOuter->QueryInterface(riid, ppvOut);}
	ULONG	DeferAddRef(void)
			{return m_punkOuter->AddRef();}
	ULONG	DeferRelease(void)
			{return m_punkOuter->Release();}

	// Making the constructor protected prevents people from making these
	// objects on the stack. The pure virtual destructor forces derived
	// classes to implement their own dtors, and prevents instances of
	// EXOA from being created directly. Of course, a derived class
	// may want to allow the creation of instances on the stack. It is
	// up to such derived classes to make their own constructors public.

	EXOA(IUnknown * punkOuter);
	virtual ~EXOA() = 0;				// pure virtual destructor
										// forces derived classes to
										// implement their own dtors.

	IUnknown * m_punkOuter;
	IUnknown * PunkPrivate(void) {return &m_exoa_unk;}

private:
	class EXOA_UNK : public IUnknown
	{
	public:
		STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvOut);
		STDMETHOD_(ULONG, AddRef)();
		STDMETHOD_(ULONG, Release)();
	public:
		EXOA *	m_pexoa;
	};
	friend class EXOA_UNK;

	EXOA_UNK	m_exoa_unk;
};



// Macros to properly route IUnknown calls //////////////////////////
// (Macros are your friends!) ///////////////////////////////////////

// This routes the IUnknown calls for an EXO-derived object properly.
#define DECLARE_EXO_IUNKNOWN(_cls)								\
	STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvOut)		\
		{return _cls::InternalQueryInterface(riid, ppvOut);}	\
	STDMETHOD_(ULONG, AddRef)(void)								\
		{return EXO::InternalAddRef();}							\
	STDMETHOD_(ULONG, Release)(void)							\
		{return EXO::InternalRelease();}						\

// If you are an aggregator (you have aggregatee kids),
// use this macro to override EXO's InternalQueryInterface
// and call your kids there.
#define OVERRIDE_EXO_INTERNALQUREYINTERFACE						\
	HRESULT InternalQueryInterface(REFIID, LPVOID * ppvOut)

// This routes the IUnknown calls for an EXOA-derived object properly.
#define DECLARE_EXOA_IUNKNOWN(_cls)								\
	STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvOut)		\
		{return EXOA::DeferQueryInterface(riid, ppvOut);}		\
	STDMETHOD_(ULONG, AddRef)(void)								\
		{return EXOA::DeferAddRef();}							\
	STDMETHOD_(ULONG, Release)(void)							\
		{return EXOA::DeferRelease();}							\


// Macro to implement GetEXOClassInfo & give back a pointer to the
// a correctly-chained classinfo struct.
#define DECLARE_GETCLSINFO(_cls)				\
		const EXOCLSINFO * GetEXOClassInfo() { return &c_exoclsinfo; }


// Here are the simple macros to use ///////////////////

// Use these in your class to declare the class's EXO data and
// to implement the properly-deferring IUnknown.

#define EXO_INCLASS_DECL(_cls)					\
		DECLARE_EXO_IUNKNOWN(_cls)				\
		DECLARE_GETCLSINFO(_cls);				\
		DECLARE_INTERFACE_TABLE_INCLASS(_cls);	\
		DECLARE_EXOCLSINFO_INCLASS(_cls)

#define EXOA_INCLASS_DECL(_cls)					\
		DECLARE_EXOA_IUNKNOWN(_cls)				\
		DECLARE_GETCLSINFO(_cls);				\
		DECLARE_INTERFACE_TABLE_INCLASS(_cls);	\
		DECLARE_EXOCLSINFO_INCLASS(_cls)

// Use these in your implementation file to define (declare space
// for the data AND fill it in) the class's EXO data.
// NOTE: These must come after your interface table declaration.
// NOTE: The parent listed here must be in the chain between you and EXO.

#define EXO_GLOBAL_DATA_DECL(_cls, _clsparent)	\
		DECLARE_EXOCLSINFO(_cls) =				\
		EXOCLSINFO_CONTENT(_cls, _clsparent)

#define EXOA_GLOBAL_DATA_DECL(_cls, _clsparent)	\
		EXO_GLOBAL_DATA_DECL(_cls, _clsparent)




#endif // !__exo_h_

// end of exo.h ////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\instobj.h ===
#ifndef _INSTOBJ_H_
#define _INSTOBJ_H_

// Gives the count of elements in an array
//
#ifndef CElems
#define CElems(_rg)							(sizeof(_rg)/sizeof(_rg[0]))
#endif // !CElems

//	========================================================================
//
//	CLASS CInstData
//
//		Instance data for a single DAV instance (vserver x vroot combination).
//
class CInstData : public CMTRefCounted
{
	//	Data items describing this instance.
	//
	auto_heap_ptr<WCHAR>		m_wszVRoot;
	LONG						m_lServerID;

	auto_ptr<CChildVRCache>		m_pChildVRootCache;

	//	NOT IMPLEMENTED
	//
	CInstData& operator=( const CInstData& );
	CInstData( const CInstData& );

public:

	CInstData( LPCWSTR pwszName );

	//	ACCESSORS
	//
	//	NOTE: These accessors do NOT give the caller ownership of the
	//	data object.  DO NOT put the returned objects into auto_ptrs
	//	and DO NOT release/delete them yourself!
	//

	LPCWSTR GetNameW() { return m_wszVRoot; }

	LONG GetServerId() { return m_lServerID; }
};


#endif // _INSTOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\gencache.h ===
#ifndef _GENCACHE_H_
#define _GENCACHE_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	GENCACHE.H
//
//		Header for generic cache classes.
//
//	Copyright 1997 Microsoft Corporation, All Rights Reserved
//

#ifdef _DAVCDATA_
#error "buffer.h uses throwing allocators"
#endif

//	Include the non-exdav-safe/throwing allocators
#include <mem.h>
#include <autoptr.h>
#include <synchro.h>

//	Include exdav-safe CCache definition header
#include <ex\gencache.h>

//	========================================================================
//
//	TEMPLATE CLASS CMTCache
//
//	Multithread-safe generic cache.
//
template<class _K, class _Ty>
class CMTCache
{
	typedef CCache<_K, _Ty> CBaseCache;

	//
	//	The cache
	//
	CBaseCache				m_cache;

	//
	//	Multi-reader/single-writer lock to protect the cache
	//
	mutable CMRWLock		m_mrw;

	//	NOT IMPLEMENTED
	//
	CMTCache& operator=( const CMTCache& );
	CMTCache( const CMTCache& );

public:
	typedef typename CBaseCache::IOp IOp;

	//	CREATORS
	//
	CMTCache()
	{
		if ( !m_mrw.FInitialize() )
			throw CLastErrorException();
		//	If this fails, our allocators will throw for us.
		m_cache.FInit();
	}

	//	ACCESSORS
	//
	BOOL FFetch( const _K& key, _Ty * pValueRet ) const
	{
		CSynchronizedReadBlock blk(m_mrw);

		return m_cache.FFetch(key, pValueRet);
	}

	void ForEach( IOp& op ) const
	{
		CSynchronizedReadBlock blk(m_mrw);

		m_cache.ForEach(op);
	}

	//	MANIPULATORS
	//
	void Set( const _K& key, const _Ty& value )
	{
		CSynchronizedWriteBlock blk(m_mrw);

		//	If this fails, our allocators will throw for us.
		(void)m_cache.FSet(key, value);
	}

	void Add( const _K& key, const _Ty& value )
	{
		CSynchronizedWriteBlock blk(m_mrw);

		//	If this fails, our allocators will throw for us.
		(void)m_cache.FAdd(key, value);
	}

	void Remove( const _K& key )
	{
		CSynchronizedWriteBlock blk(m_mrw);

		m_cache.Remove(key);
	}

	void Clear()
	{
		CSynchronizedWriteBlock blk(m_mrw);

		m_cache.Clear();
	}
};


//	========================================================================
//
//	CLASS CAccInv
//
//		Access/Invalidate synchronization logic.
//		This class encapsulates the logic needed to safely read
//		(access) from a datasource that may be invalidated (invalidate)
//		by an asynchronous, external event.  (IN-ternal events
//		should ALWAYS use the synch mechanisms we provide DIRECTLY.)
//
class IEcb;
class CAccInv
{
	//
	//	Multi-reader/single-writer lock to synchronize
	//	access and invalidation functions
	//
	CMRWLock m_mrw;

	//
	//	Flag to indicate whether the object is invalid.
	//	If 0, the object is invalid and and will
	//	be refreshed the next time it is accessed.
	//
	LONG m_lValid;

	//	NOT IMPLEMENTED
	//
	CAccInv& operator=( const CAccInv& );
	CAccInv( const CAccInv& );

public:

	//	Forward declaration
	//
	class IAccCtx;

protected:
	//
	//	Refresh operation to be provided by derived class
	//
	virtual void RefreshOp( const IEcb& ecb ) = 0;

	void Access( const IEcb& ecb, IAccCtx& context )
	{
		//
		//	Repeat the following validity check, refresh, and
		//	access, and recheck sequence until the access succeeds
		//	and the object is valid from start to finish.
		//
		for (;;)
		{
			//
			//	Check validity, and refresh if invalid.
			//
			while ( !m_lValid )
			{
				CTryWriteBlock blk(m_mrw);

				//
				//	Only one thread should refresh the object.
				//	Other threads detecting that the object is invalid
				//	periodically retry checking validity (spin waiting)
				//	until the object becomes valid.
				//
				if ( blk.FTryEnter() )
				{
					//
					//	By being the first to enter the write lock,
					//	this thread gets to refresh the object.
					//

					//
					//	Mark the object as valid BEFORE actually
					//	refreshing it so that it is possible to
					//	tell if the object gets marked invalid by
					//	another thread while it is being refreshed.
					//
					InterlockedExchange( &m_lValid, 1 );

					//
					//	Refresh the object
					//
					RefreshOp(ecb);
				}
				else
				{
					//
					//	Give up the rest of this thread's time slice so
					//	that the thread holding the write lock may finish
					//	as soon as possible.
					//
					Sleep(0);
				}
			}

			//
			//	The object is valid (or at least it was a tiny instant
			//	ago) so go ahead and access it.  Apply a read lock
			//	to prevent other threads from refreshing it during
			//	access (if the object is marked invalid during access).
			//
			{
				CSynchronizedReadBlock blk(m_mrw);

				context.AccessOp( *this );

				//
				//	Test whether the object is still valid after access.
				//	(Do this while holding the read lock to prevent other
				//	threads from marking the object as invalid and refreshing
				//	it since it was accessed on this thread.)  If the
				//	object is still valid now, then it was valid for
				//	the entire operation, so we're done.
				//
				if ( m_lValid )
					break;
			}
		}
	}

public:

	class IAccCtx
	{

	public:

		//
		//	Method on the cache context to perform the access operation.
		//	This allows for caches to support multiple access methods for
		//	both ::Lookup() and ::ForEach() mechanisms
		//
		virtual void AccessOp( CAccInv& cache ) = 0;
	};

	//	The object is initially considered invalid.  It will be refreshed
	//	the first time it is accessed.
	//
	CAccInv() :
		m_lValid(0)
	{
		if ( !m_mrw.FInitialize() )
			throw CLastErrorException();
	}

	void Invalidate()
	{
		InterlockedExchange( &m_lValid, 0 );
	}
};

#endif // !_GENCACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\langid.h ===
//	========================================================================
//	LANGID.H
//
//	Cache to map between language ids (LCIDs) and MIME language specifiers
//	("en-us" etc.)
//
//	Copyright 1997-1998 Microsoft Corporation, All Rights Reserved
//
//	========================================================================

#ifndef _LANGID_H_
#define _LANGID_H_

#include <ex\gencache.h>
#include <singlton.h>

//	We need to lookup LCID-s from strings on (IIS-side).
//
class CLangIDCache : private Singleton<CLangIDCache>
{
	//
	//	Friend declarations required by Singleton template
	//
	friend class Singleton<CLangIDCache>;

	//	Cache of mime mappings
	//
	typedef CCache<CRCSzi, LONG> CSzLCache;
	CSzLCache					m_cache;

	//	String data storage area.
	//
	ChainedStringBuffer<CHAR>	m_sb;

	//	CREATORS
	//
	//	Declared private to ensure that arbitrary instances
	//	of this class cannot be created.  The Singleton
	//	template (declared as a friend above) controls
	//	the sole instance of this class.
	//
	CLangIDCache() {};

	//	Function to fill cache with data.
	//
	static BOOL FFillCacheData();

	//	NOT IMPLEMENTED
	//
	CLangIDCache& operator=(const CLangIDCache&);
	CLangIDCache(const CLangIDCache&);

public:
	//	STATICS
	//

	//
	//	Instance creating/destroying routines provided
	//	by the Singleton template.
	//
	using Singleton<CLangIDCache>::CreateInstance;
	using Singleton<CLangIDCache>::DestroyInstance;

	static BOOL FInitialize()
	{
		BOOL fSuccess = FALSE;

		//	Init all our failing members.
		//
		if (!Instance().m_cache.FInit())
			goto ret;

		//	Call the function to fill the cache.
		//	If we do not succeed let us not block,
		//	We will proceed with whatever we have got.
		//
		(void)Instance().FFillCacheData();

		fSuccess = TRUE;

	ret:
		return fSuccess;
	}

	//	Find LangID from MIME language string
	//
	static LONG LcidFind (LPCSTR psz);
};

#endif // !_LANGID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\mem.h ===
/*
 *	M E M . H
 *
 *	DAV basic memory allocators.  Implementation of this class is
 *	owned by the individual implementations
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef _MEM_H_
#define _MEM_H_

#ifdef _DAVCDATA_
#error "mem.h defines throwing allocators"
#endif

//	Global heap "class" ---------------------------------------------------------
//
//	This really only acts as a namespace.  I.e. there are no non-static members.
//	For historical reasons (and, mainly, to avoid changing a LOT of code from
//	calling "g_heap.Fn()" to calling "g_heap::Fn()"), g_heap still appears
//	outwardly to be a real object.
//
//	!!! CHeap is used by multiple components.  Specifically, it may be
//		*IMPLEMENTED* by multiple components in various locations.
//		When changing the CHeap interface, make sure to recompile
//		EVERYTHING in the project.
//
struct CHeap
{
	static BOOL FInit();
	static void Deinit();
	static LPVOID Alloc( SIZE_T cb );
	static LPVOID Realloc( LPVOID lpv, SIZE_T cb );
	static VOID Free( LPVOID pv );
};

extern CHeap g_heap;

//	Safe allocators
//
#include <ex\exmem.h>

// Try using pragmas to turn off the undesired warnings from the STL.
#pragma warning(disable:4663)	//	C language, template<> syntax
#pragma warning(disable:4244)	//	return conversion, data loss

#include <memory>

// And undo it all so that we still get good checking!
#pragma warning(default:4663)	//	C language, template<> syntax
#pragma warning(default:4244)	//	return conversion, data loss


//	========================================================================
//
//	TEMPLATE CLASS heap_allocator<>
//
//		Allocator class to work with the STL (Standard C++ Template Library).
//		Allocations actually handled by our global heap allocator.
//
template<class _Ty>
class heap_allocator : public std::allocator<_Ty>
{
public:
	pointer allocate(size_type _N, const void *)
		{return (pointer) _Charalloc(_N * sizeof(_Ty)); }
	char _FARQ *_Charalloc(size_type _N)
		{return (char _FARQ *) g_heap.Alloc(_N); }
	void deallocate(void _FARQ *_P, size_type)
		{g_heap.Free(_P); }
};

#endif // _MEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\langtocpid.h ===
//	========================================================================
//
//	Module:		   langtocpid.h
//
//	Copyright Microsoft Corporation 1997, All Rights Reserved.
//
//	Description:	This file is used provide the support for HTTP_DAV
//					to make a best guess code page based on the Accept-
//					Language header. The code page is used to decode
//					non-UTF8 chanracters in URLs coming from Office/Rosebud
//					This file contains the static mapping of header values
//					to code pages as well as a cache to provide fast
//					retrieval of code pages.
//
//	========================================================================
#ifndef _LANGTOCPID_H_
#define _LANGTOCPID_H_

#include <ex\gencache.h>
#include <singlton.h>

struct ACCEPTLANGTOCPID_ENTRY { LPCSTR pszLang; UINT cpid; };

//	A static mapping of Accept-Language header values to the
//	corresponding CPIDs. This mapping comes from the DAV
//	implementation doc
//	http://exchange/doc/specs/Platinum/Future%20Protocols/ms-implementation/dav-codepage-support.doc
//
DEC_CONST ACCEPTLANGTOCPID_ENTRY gc_rgAcceptLangToCPIDTable[] =
{
	{"ar",		1256},
	{"ar-sa",	1256},
	{"ar-iq",	1256},
	{"ar-eg",	1256},
	{"ar-ly",	1256},
	{"ar-dz",	1256},
	{"ar-ma",	1256},
	{"ar-tn",	1256},
	{"ar-om",	1256},
	{"ar-ye",	1256},
	{"ar-sy",	1256},
	{"ar-jo",	1256},
	{"ar-lb",	1256},
	{"ar-kw",	1256},
	{"ar-ae",	1256},
	{"ar-bh",	1256},
	{"ar-qa",	1256},
	{"zh",		950},
	{"zh-tw",	950},
	{"zh-cn",	936},
	{"zh-hk",	950},
	{"zh-sg",	936},
	{"ja",		932},
	{"en-us",	1252},
	{"en-gb",	1252},
	{"en-au",	1252},
	{"en-ca",	1252},
	{"en-nz",	1252},
	{"en-ie",	1252},
	{"en-za",	1252},
	{"en-jm",	1252},
	{"en-bz",	1252},
	{"en-tt",	1252},
	{"fr",		1252},
	{"fr-be",	1252},
	{"fr-ca",	1252},
	{"fr-ch",	1252},
	{"fr-lu",	1252},
	{"de",		1252},
	{"de-ch",	1252},
	{"de-at",	1252},
	{"de-lu",	1252},
	{"de-li",	1252},
	{"el",		1253},
	{"he",		1255},
	{"it",		1252},
	{"it-ch",	1252},
	{"lt",		1257},
	{"ko",		949},
	{"es",		1252},
	{"es-mx",	1252},
	{"es-gt",	1252},
	{"es-cr",	1252},
	{"es-pa",	1252},
	{"es-do",	1252},
	{"es-ve",	1252},
	{"es-co",	1252},
	{"es-pe",	1252},
	{"es-ar",	1252},
	{"es-ec",	1252},
	{"es-cl",	1252},
	{"es-uy",	1252},
	{"es-py",	1252},
	{"es-bo",	1252},
	{"es-sv",	1252},
	{"es-hn",	1252},
	{"es-ni",	1252},
	{"es-pr",	1252},
	{"ru",		1251},
	{"th",		874},
	{"tr",		1254},
	{"vi",		1258}
};

//	The size of the table
//
const DWORD gc_cAcceptLangToCPIDTable = CElems(gc_rgAcceptLangToCPIDTable);

//	========================================================================
//
//	Singleton class CLangToCpidCache
//
//	A cache to provide fast retrieval of code pages based on values in the
//	Accept-Language header.
//
//
class CLangToCpidCache : private Singleton<CLangToCpidCache>
{
private:
	//
	//	Friend declarations required by Singleton template
	//
	friend class Singleton<CLangToCpidCache>;

	//	The cache mapping accept language strings to code pages.
	//
	CCache<CRCSzi, UINT> m_cacheAcceptLangToCPID;

	//	CONSTRUCTORS
	//
	//	Declared private to ensure that arbitrary instances
	//	of this class cannot be created.  The Singleton
	//	template (declared as a friend above) controls
	//	the sole instance of this class.
	//
	CLangToCpidCache() {};

	//	NOT IMPLEMENTED
	//
	CLangToCpidCache (const CLangToCpidCache&);
	CLangToCpidCache& operator= (const CLangToCpidCache&);

public:
	//	STATICS
	//

	//
	//	Instance creating/destroying routines provided
	//	by the Singleton template.
	//
	using Singleton<CLangToCpidCache>::DestroyInstance;

	//	Initialization. Wraps CreateInstance().
	//	This function hashes all the supported language strings
	//	to give us quick lookup by language string.
	//
	static BOOL FCreateInstance();

	//	Find the CPID from language string
	//
	static BOOL FFindCpid(IN LPCSTR pszLang, OUT UINT * puiCpid);
};

#endif // _LANGTOCPID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\memx.h ===
/*
 *	M E M X . H
 *
 *	Default implementation of DAV allocators.
 *
 *	It is possible that sometime in the future we may decide that different
 *	implementations of DAV may require different allocator implementations,
 *	so each DAV implementation has its own allocator implementation file
 *	(mem.cpp) in its own directory.  However, until we need to differentiate
 *	allocator implementations among DAV implementations (if we ever do),
 *	it is easier to have the common default implementation in one place -- here.
 *
 *	This header defines a full implementation for a fast heap allocator
 *	and implementations for other allocators that can be used for debugging.
 *	This file should be included exactly once by mem.cpp in each DAV implementation.
 *
 *	To use the virtual heap allocator set:
 *
 *	[General]
 *	UseVirtual=1
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include <singlton.h>
#include <except.h>

//	===================================================================================
//
//	IHeap
//
//	Heap interface base class.
//
class IHeap
{
public:
	//	CREATORS
	//
	virtual ~IHeap() = 0;

	//	ACCESSORS
	//
	virtual LPVOID Alloc( SIZE_T cb ) const = 0;
	virtual LPVOID Realloc( LPVOID lpv, SIZE_T cb ) const = 0;
	virtual VOID Free( LPVOID pv ) const = 0;
};

//	------------------------------------------------------------------------
//
//	IHeap::~IHeap()
//
//		Out of line virtual destructor necessary for proper deletion
//		of objects of derived classes via this class
//
IHeap::~IHeap() {}


//	===================================================================================
//
//	CMultiHeap
//
//	Multi-heap implementation (provided by STAXMEM.DLL).  It is significantly
//	faster than the process heap on multiprocessor machines because it uses
//	multiple internal heaps, lookaside lists and deferred freeing to reduce
//	contention on system heap critical sections.
//
class CMultiHeap :
	public IHeap,
	private Singleton<CMultiHeap>
{
	//
	//	Friend declarations required by Singleton template
	//
	friend class Singleton<CMultiHeap>;

	typedef HANDLE (WINAPI *HEAPCREATE) (
		ULONG	cHeaps,
		DWORD	dwFlags,
		SIZE_T	dwInitialSize,
		SIZE_T	dwMaxSize );

	typedef BOOL (WINAPI *HEAPDESTROY) ();

	typedef LPVOID (WINAPI *HEAPALLOC) (
		SIZE_T	dwSize );

	typedef LPVOID (WINAPI *HEAPREALLOC) (
		LPVOID	pvOld,
		SIZE_T	dwSize );

	typedef BOOL (WINAPI *HEAPFREE) (
		LPVOID	pvFree );

	//
	//	Allocation functions
	//
	HEAPCREATE	m_HeapCreate;
	HEAPDESTROY	m_HeapDestroy;
	HEAPALLOC	m_HeapAlloc;
	HEAPREALLOC	m_HeapRealloc;
	HEAPFREE	m_HeapFree;

	//	CREATORS
	//
	//	Declared private to ensure that arbitrary instances
	//	of this class cannot be created.  The Singleton
	//	template (declared as a friend above) controls
	//	the sole instance of this class.
	//
	CMultiHeap() :
		m_HeapCreate(NULL),
		m_HeapDestroy(NULL),
		m_HeapAlloc(NULL),
		m_HeapRealloc(NULL),
		m_HeapFree(NULL)
	{
	}

	//	MANIPULATORS
	//
	BOOL FInit();

public:
	//	STATICS
	//
	static CMultiHeap * New();

	//	CREATORS
	//
	~CMultiHeap();

	//	ACCESSORS
	//
	LPVOID Alloc( SIZE_T cb ) const;
	LPVOID Realloc( LPVOID lpv, SIZE_T cb ) const;
	VOID Free( LPVOID pv ) const;
};

CMultiHeap *
CMultiHeap::New()
{
	if ( CreateInstance().FInit() )
		return &Instance();

	DestroyInstance();
	return NULL;
}

BOOL
CMultiHeap::FInit()
{
	//
	//	Load up STAXMEM.DLL - or whatever
	//
	HINSTANCE hinst = LoadLibraryExW( g_szMemDll, NULL, 0 );

	if ( !hinst )
		return FALSE;

	//
	//	Get the function pointers for the multi-heap implementation
	//
	m_HeapCreate = reinterpret_cast<HEAPCREATE>(
		GetProcAddress( hinst, "ExchMHeapCreate" ));

	m_HeapDestroy = reinterpret_cast<HEAPDESTROY>(
		GetProcAddress( hinst, "ExchMHeapDestroy" ));

	m_HeapAlloc = reinterpret_cast<HEAPALLOC>(
		GetProcAddress( hinst, "ExchMHeapAlloc" ));

	m_HeapRealloc = reinterpret_cast<HEAPREALLOC>(
		GetProcAddress( hinst, "ExchMHeapReAlloc" ));

	m_HeapFree = reinterpret_cast<HEAPFREE>(
		GetProcAddress( hinst, "ExchMHeapFree" ));

	//
	//	Make sure we found all of the entrypoints
	//
	if ( !(m_HeapCreate &&
		   m_HeapDestroy &&
		   m_HeapAlloc &&
		   m_HeapRealloc &&
		   m_HeapFree) )
	{
		return FALSE;
	}

	//
	//	Create the multi-heap.  We don't need the heap HANDLE
	//	that is returned since none of the allocation functions
	//	take it.  We just need to know whether it succeeded.
	//
	return !!m_HeapCreate( 0,	 //	number of heaps -- 0 means use a default
								 //	proportional to the number of CPUs.
						   0,	 //	no flags
						   8192, //	initially 8K (growable)
						   0 );  // size unlimited
}

CMultiHeap::~CMultiHeap()
{
	if ( m_HeapDestroy )
		m_HeapDestroy();
}

LPVOID
CMultiHeap::Alloc( SIZE_T cb ) const
{
	return m_HeapAlloc( cb );
}

LPVOID
CMultiHeap::Realloc( LPVOID lpv, SIZE_T cb ) const
{
	return m_HeapRealloc( lpv, cb );
}

void
CMultiHeap::Free( LPVOID lpv ) const
{
	m_HeapFree( lpv );
}



//
//	Debug-only allocators...
//
#if defined(DBG)

//	===================================================================================
//
//	CVirtualHeap (X86 only)
//
//		Places allocations at the end of virtual memory pages.
//		While being drastically slower than other allocators,
//		this one catches memory overwrites immediately by
//		throwing a memory access violation exception.
//
#if defined(_X86_)

class CVirtualHeap :
	public IHeap,
	private Singleton<CVirtualHeap>
{
	//
	//	Friend declarations required by Singleton template
	//
	friend class Singleton<CVirtualHeap>;

	//	CREATORS
	//
	//	Declared private to ensure that arbitrary instances
	//	of this class cannot be created.  The Singleton
	//	template (declared as a friend above) controls
	//	the sole instance of this class.
	//
	CVirtualHeap() {}

public:
	//	STATICS
	//
	static CVirtualHeap * New()
	{
		return &CreateInstance();
	}

	//	ACCESSORS
	//
	LPVOID Alloc( SIZE_T cb ) const
	{
		return VMAlloc( cb );
	}

	LPVOID Realloc( LPVOID lpv, SIZE_T cb ) const
	{
		return VMRealloc( lpv, cb );
	}

	VOID Free( LPVOID lpv ) const
	{
		VMFree( lpv );
	}
};

#endif // defined(_X86)
#endif // DBG



//	===================================================================================
//
//	CHeapImpl
//
//	Top-level heap implementation
//
class CHeapImpl : private RefCountedGlobal<CHeapImpl>
{
	//
	//	Friend declarations required by RefCountedGlobal template
	//
	friend class Singleton<CHeapImpl>;
	friend class RefCountedGlobal<CHeapImpl>;

	//
	//	Pointer to the object that provides our heap implementation
	//
	auto_ptr<IHeap> m_pHeapImpl;

	//	CREATORS
	//
	//	Declared private to ensure that arbitrary instances
	//	of this class cannot be created.  The Singleton
	//	template (declared as a friend above) controls
	//	the sole instance of this class.
	//
	CHeapImpl() {}

	//	NOT IMPLEMENTED
	//
	CHeapImpl( const CHeapImpl& );
	CHeapImpl& operator=( const CHeapImpl& );

	//
	//	Initialization routine called
	//	by the RefCountedGlobal template
	//
	BOOL FInit()
	{
		//
		//	And bind to a particular heap implementation
		//
		//	In DBG builds only, check whether we are being told
		//	to use the virtual allocator heap implementation
		//
#if defined(DBG)
#if defined(_X86_)
		if ( GetPrivateProfileIntA( gc_szDbgGeneral,
									gc_szDbgUseVirtual,
									FALSE,
									gc_szDbgIni ) )
		{
			m_pHeapImpl = CVirtualHeap::New();
		}
		else
#endif // defined(_X86_)
#endif // DBG
		m_pHeapImpl = CMultiHeap::New();

		return !!m_pHeapImpl;
	}

public:
	using RefCountedGlobal<CHeapImpl>::DwInitRef;
	using RefCountedGlobal<CHeapImpl>::DeinitRef;

	static IHeap& Heap()
	{
		Assert( Instance().m_pHeapImpl.get() != NULL );

		return *Instance().m_pHeapImpl;
	}
};


//	===================================================================================
//
//	CHeap
//
//	Top-level heap.
//
//	This "class" (it's actually a struct) really only acts as a namespace.
//	I.e. its only members are static functions.  It remains a class for
//	historical reasons (mainly to avoid changing a LOT of code from calling
//	"g_heap.Fn()" to simply calling "Fn()").
//

BOOL
CHeap::FInit()
{
	return !!CHeapImpl::DwInitRef();
}

void
CHeap::Deinit()
{
	CHeapImpl::DeinitRef();
}

LPVOID
CHeap::Alloc( SIZE_T cb )
{
	LPVOID	lpv;

	Assert( cb > 0 );

	lpv = CHeapImpl::Heap().Alloc(cb);

#ifndef	_NOTHROW_
	if ( !lpv )
	{
		DebugTrace ("CHeap::Alloc() - Error allocating (%d)\n", GetLastError());
		throw CLastErrorException();
	}
#endif	// _NOTHROW_

	return lpv;
}

LPVOID
CHeap::Realloc( LPVOID lpv, SIZE_T cb )
{
	LPVOID	lpvNew;

	Assert( cb > 0 );

	//	Just in case some heap implementation doesn't handle
	//	realloc with NULL lpv, map that case to Alloc here.
	//
	if (!lpv)
		lpvNew = CHeapImpl::Heap().Alloc(cb);
	else
		lpvNew = CHeapImpl::Heap().Realloc(lpv, cb);

#ifndef	_NOTHROW_
	if ( !lpvNew )
	{
		DebugTrace ("CHeap::Alloc() - Error reallocating (%d)\n", GetLastError());
		throw CLastErrorException();
	}
#endif	// _NOTHROW_

	return lpvNew;
}

VOID
CHeap::Free( LPVOID lpv )
{
	if ( lpv )
	{
		CHeapImpl::Heap().Free( lpv );
	}
}

//
//	The one global heap "object".  CHeap is really just a struct
//	containing only static member functions, so there should be
//	no space required for this declaration.  The actual heap
//	implementation (CHeapImpl) provides everything.  CHeap is
//	now just an interface.
//
CHeap g_heap;



//	------------------------------------------------------------------------
//
//	Global new operator
//	Global delete operator
//
//		Remap all calls to new to use our memory manager.
//		(Don't forget to throw explicitly on error!)
//
void * __cdecl operator new(size_t cb)
{
#ifdef	DBG
	AssertSz(cb, "Zero-size allocation detecetd!");
	//	Force small allocations up to min size of four
	//	so that I can reliably do the "vtable-nulling trick" in delete!
	//
	if (cb < 4) cb = 4;
#endif	// DBG

	PVOID pv = g_heap.Alloc(cb);

#ifndef	_NOTHROW_
	if (!pv)
		throw CDAVException();
#endif	// _NOTHROW_

	return pv;
}

void __cdecl operator delete(void * pv)
{
#ifdef	DBG
	//	Zero-out the first four bytes of this allocation.
	//	(If there was a vtable there previously, we'll now trap
	//	if we try to use it!)
	//
	if (pv)
		*((DWORD *)pv) = 0;
#endif	// DBG

	g_heap.Free(pv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\profile.h ===
#ifndef _PROFILE_H_
#define _PROFILE_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	PROFILE.H
//
//		Profiling classes for use with IceCAP profiling
//
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

//	========================================================================
//
//	CLASS CProfiledBlock
//
//	Profiles any block of code in which an instance of this class exists.
//
//	To use, just declare one of these in the block you want profiled:
//
//		...
//		{
//			CProfiledBlock	profiledBlock;
//
//			//
//			//	Do stuff to be profiled
//			//
//			...
//
//			//
//			//	Do more stuff to be profiled
//			//
//			...
//		}
//
//		//
//		//	Do stuff that isn't to be profiled
//		//
//		...
//
//	and the block is automatically profiled.  Why bother?  Because
//	you don't need to have any cleanup code; profiling is automatically
//	turned off when execution leaves the block, even if via
//	an exception thrown from any of the synchronized stuff.  Also,
//	profiling information for initialization of local objects
//	is automatically gathered as long as the profiled block is
//	the first thing declared.
//
class CProfiledBlock
{
public:
#ifdef PROFILING
	//	CREATORS
	//
	CProfiledBlock() { StartCAP(); }
	~CProfiledBlock() { StopCAP(); }

	//	MANIPULATORS
	//
	void Suspend() { SuspendCAP(); }
	void Resume() { ResumeCAP(); }

#else // !defined(PROFILING)
	//	CREATORS
	//
	CProfiledBlock() {}
	~CProfiledBlock() {}

	//	MANIPULATORS
	//
	void Suspend() {}
	void Resume() {}

#endif // PROFILING
};

#endif // !defined(_PROFILE_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\msidxs.h ===
//--------------------------------------------------------------------
// Microsoft OLE DB Provider for Index Server
// (C) Copyright 1996 - 1997 By Microsoft Corporation.
//
// @doc
//
// @module MSIDXS.H | Provider Specific definitions
//
//--------------------------------------------------------------------

#ifndef  _MSIDXS_H_
#define  _MSIDXS_H_

// Provider Class Id
#ifdef DBINITCONSTANTS
extern const GUID CLSID_MSIDXS			= {0xF9AE8980, 0x7E52, 0x11d0, {0x89,0x64,0x00,0xC0,0x4F,0xD6,0x11,0xD7}};
extern const GUID CLSID_MSSEARCHSQL		= {0x0B63E349, 0x9CCC, 0x11D0, {0xBC,0xDB,0x00,0x80,0x5F,0xCC,0xCE,0x04}};
// Site Server
extern const GUID DBPROPSET_NLCOMMAND	= {0x0B63E344, 0x9CCC, 0x11D0, {0xBC,0xDB,0x00,0x80,0x5F,0xCC,0xCE,0x04}};
extern const GUID DBPROPSET_NLROWSET	= {0x0B63E36E, 0x9CCC, 0x11D0, {0xBC,0xDB,0x00,0x80,0x5F,0xCC,0xCE,0x04}};
#else // !DBINITCONSTANTS
extern const GUID CLSID_MSIDXS;
extern const GUID CLSID_MSSEARCHSQL;
// Site Server
extern const GUID DBPROPSET_NLCOMMAND;
extern const GUID DBPROPSET_NLROWSET;
#endif // DBINITCONSTANTS


//----------------------------------------------------------------------------
// MSIDXS and MSIDNL specific properties
#ifdef DBINITCONSTANTS
extern const GUID DBPROPSET_MSIDXS_ROWSET_EXT	= {0xAA6EE6B0, 0xE828, 0x11D0, {0xB2,0x3E,0x00,0xAA,0x00,0x47,0xFC,0x01} };
extern const GUID DBPROPSET_QUERY_EXT			= {0xA7AC77ED, 0xF8D7, 0x11CE, {0xA7,0x98,0x00,0x20,0xF8,0x00,0x80,0x25} };
#else // !DBINITCONSTANTS
extern const GUID DBPROPSET_MSIDXS_ROWSET_EXT;
extern const GUID DBPROPSET_QUERY_EXT;
#endif // DBINITCONSTANTS


// PropIds under DBPROPSET_MSIDX_ROWSET_EXT
#define MSIDXSPROP_ROWSETQUERYSTATUS			2
#define MSIDXSPROP_COMMAND_LOCALE_STRING		3
#define MSIDXSPROP_QUERY_RESTRICTION			4

// Prop IDs for DBPROPET_NLCOMMAND 
#define DBPROP_NLCOMMAND_STARTROW				3
#define DBPROP_NLCOMMAND_GETROWCOUNT			4

// Prop IDs for DBPROPSET_NLROWSET
#define DBPROP_NLROWSET_ROWCOUNT				1000
#define DBPROP_NLROWSET_NEXTSTARTROW			1001
#define DBPROP_NLROWSET_MOREROWS				1002
#define DBPROP_NLROWSET_CATSEQNUMS				1003

#endif
//----
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\pclib.h ===
#ifndef _PCLIB_H_
#define _PCLIB_H_

#include <winperf.h>

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	PCLIB.H
//
//		Public interface to PCLIB to be used by perf counter data
//		generating and monitoring components.
//
//	Copyright 1986-1998 Microsoft Corporation, All Rights Reserved
//

//
//	A signature that uniquely identifies the component whose perf counters are
//	being implemented.  This must be identical to the value of the drivername
//	key in the [info] section of the perf counter INI file.  It is used to
//	locate the counters' "first counter" information in the registry.
//	
EXTERN_C const WCHAR gc_wszPerfdataSource[];

//	The signature of the perf counter dll.
//	NOTE: This is usually NOT the same as the monitor component signature above!
//	This variable is defined to MATCH the definition in \cal\src\inc\eventlog.h.
//
EXTERN_C const WCHAR gc_wszSignature[]; 

// Gives the count of elements in an array
//
#ifndef CElems
#define CElems(_rg)							(sizeof(_rg)/sizeof(_rg[0]))
#endif // !CElems


//	************************************************************************
//
//	INTERFACE for counter data generating processes
//

//	========================================================================
//
//	CLASS IPerfCounterBlock
//
//	Created by IPerfObject::NewInstance().  A perf counter block
//	encapsulates the set of counters for a given instance.  The
//	methods of this interface define the mechanism for changing
//	the values of the counters in the counter block.
//
class IPerfCounterBlock
{
public:
	//	CREATORS
	//
	virtual ~IPerfCounterBlock() = 0;

	//	MANIPULATORS
	//
	virtual VOID IncrementCounter( UINT iCounter ) = 0;
	virtual VOID DecrementCounter( UINT iCounter ) = 0;
	virtual VOID SetCounter( UINT iCounter, LONG lValue ) = 0;
};

//	========================================================================
//
//	CLASS IPerfObject
//
//	Created by PCLIB::NewPerfObject().  A perf object defines a set of
//	counters.  In terms of the NT perf counter structures, a perf object
//	encapsulates a PERF_OBJECT_TYPE and its PERF_COUNTER_DEFINITIONs.
//
//	IPerfObject::NewInstance() creates a new instance of this perf object
//	from a PERF_INSTANCE_DEFINITION and a PERF_COUNTER_BLOCK.  All values
//	of both structures must be properly initialized prior to calling
//	IPerfObject::NewInstance() following standard conventions for these
//	structures.  I.e. the instance name must immediately follow the
//	PERF_INSTANCE_DEFINITION structure, and the PERF_COUNTER_BLOCK must
//	be DWORD-aligned following the name.  The PERF_COUNTER_BLOCK should
//	be followed by the counters themselves.  Read the documentation for
//	these structures if you're confused.
//
class IPerfObject
{
public:
	//	CREATORS
	//
	virtual ~IPerfObject() = 0;

	//	MANIPULATORS
	//
	virtual IPerfCounterBlock *
	NewInstance( const PERF_INSTANCE_DEFINITION& pid,
				 const PERF_COUNTER_BLOCK& pcb ) = 0;
};

//	========================================================================
//
//	NAMESPACE PCLIB
//
//	The top level of the PCLIB interface.  PCLIB::FInitialize() should be
//	called once per process to initialize the library.  Similarly,
//	PCLIB::Deinitialize() should be called once per process to deinitialize
//	it.  NOTE: To simplify your error code cleanup, it is safe to call
//	PCLIB::Deinitialize() even if you did not call PCLIB::FInitialize().
//
//	PCLIB::NewPerfObject() creates a new perf object from a
//	PERF_OBJECT_TYPE and subsequent PERF_COUNTER_DEFINITIONs.  All values
//	of both structures must be properly initialized prior to calling
//	PCLIB::NewPerfObject() following standard conventions for these
//	structures, with one exception: PERF_OBJECT_TYPE::NumInstances and
//	PERF_OBJECT_TYPE::TotalByteLength should both be initialized to 0.
//	These values are computed in the monitor process because the number
//	of instances is not generally fixed at the time the object is created.
//
namespace PCLIB
{
	//
	//	Initialization/Deinitialization
	//
	BOOL __fastcall FInitialize( LPCWSTR lpwszSignature );
	VOID __fastcall Deinitialize();

	//
	//	Instance registration
	//
	IPerfObject * __fastcall NewPerfObject( const PERF_OBJECT_TYPE& pot );
};

//	========================================================================
//
//	CLASS CPclibInit
//
//	PCLIB initializer class.  Simplifies PCLIB initialization and
//	deinitialization.
//
class CPclibInit
{
	//	NOT IMPLEMENTED
	//
	CPclibInit& operator=( const CPclibInit& );
	CPclibInit( const CPclibInit& );

public:
	CPclibInit()
	{
	}

	BOOL FInitialize( LPCWSTR lpwszSignature )
	{
		return PCLIB::FInitialize( lpwszSignature );
	}

	~CPclibInit()
	{
		PCLIB::Deinitialize();
	}
};


//	************************************************************************
//
//	INTERFACE for counter monitors
//

//	------------------------------------------------------------------------
//
//	The interface for monitors *IS* the perfmon interface!
//	Just define these as EXPORTS for your monitor DLL and you're done.
//
EXTERN_C DWORD APIENTRY
PclibOpenPerformanceData( LPCWSTR );

EXTERN_C DWORD APIENTRY
PclibCollectPerformanceData( LPCWSTR lpwszCounterIndices,
							 LPVOID * plpvPerfData,
							 LPDWORD lpdwcbPerfData,
							 LPDWORD lpcObjectTypes );

EXTERN_C DWORD APIENTRY
PclibClosePerformanceData();

EXTERN_C STDAPI
PclibDllRegisterServer(VOID);

EXTERN_C STDAPI
PclibDllUnregisterServer(VOID);

//	------------------------------------------------------------------------
//
//	Or, for the do-it-yourself'er....
//
//	Step 1) Initialize shared memory (see inc\smh.h)
//	Step 2) Call NewCounterPublisher() or NewCounterMonitor() (depending
//			on which you are!) passing in the string you used in Step 1.
//
class ICounterData
{
protected:
	//	CREATORS
	//	Only create this object through it's descendents!
	//
	ICounterData() {};

public:
	//	CREATORS
	//
	virtual ~ICounterData() = 0;

	//	MANIPULATORS
	//
	virtual IPerfObject *
		CreatePerfObject( const PERF_OBJECT_TYPE& pot ) = 0;

	virtual DWORD
		DwCollectData( LPCWSTR lpwszCounterIndices,
					   DWORD   dwFirstCounter,
					   LPVOID * plpvPerfData,
					   LPDWORD lpdwcbPerfData,
					   LPDWORD lpcObjectTypes ) = 0;
};

ICounterData * __fastcall
NewCounterPublisher( LPCWSTR lpwszSignature );

ICounterData * __fastcall
NewCounterMonitor( LPCWSTR lpwszSignature );

#endif // !defined(_PCLIB_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\nonimpl.h ===
/*
 *	N O N I M P L . H
 *
 *	Base classes for COM interfaces with no functionality except IUnknown.
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_NONIMPL_H_
#define _NONIMPL_H_

#include <exo.h>
#include <ocidl.h>		//	For IPersistStreamInit
#include <caldbg.h>

//	Non-Implemented IStream ---------------------------------------------------
//
class CStreamNonImpl : public EXO, public IStream
{
public:

	EXO_INCLASS_DECL(CStreamNonImpl);

	CStreamNonImpl() {}
	~CStreamNonImpl() {}

	virtual /* [local] */ HRESULT STDMETHODCALLTYPE Read(
		/* [length_is][size_is][out] */ void __RPC_FAR *,
		/* [in] */ ULONG,
		/* [out] */ ULONG __RPC_FAR *)
	{
		TrapSz ("CStreanNonImpl::Read() called");
		return E_NOTIMPL;
	}

	virtual /* [local] */ HRESULT STDMETHODCALLTYPE Write(
		/* [size_is][in] */ const void __RPC_FAR *,
		/* [in] */ ULONG,
		/* [out] */ ULONG __RPC_FAR *)
	{
		TrapSz ("CStreanNonImpl::Write() called");
		return E_NOTIMPL;
	}

	virtual /* [local] */ HRESULT STDMETHODCALLTYPE Seek(
		/* [in] */ LARGE_INTEGER,
		/* [in] */ DWORD,
		/* [out] */ ULARGE_INTEGER __RPC_FAR *)
	{
		TrapSz ("CStreanNonImpl::Seek() called");
		return E_NOTIMPL;
	}

	virtual HRESULT STDMETHODCALLTYPE SetSize(
		/* [in] */ ULARGE_INTEGER)
	{
		TrapSz ("CStreanNonImpl::SetSize() called");
		return E_NOTIMPL;
	}

	virtual /* [local] */ HRESULT STDMETHODCALLTYPE CopyTo(
		/* [unique][in] */ IStream __RPC_FAR *,
		/* [in] */ ULARGE_INTEGER,
		/* [out] */ ULARGE_INTEGER __RPC_FAR *,
		/* [out] */ ULARGE_INTEGER __RPC_FAR *)
	{
		TrapSz ("CStreanNonImpl::CopyTo() called");
		return E_NOTIMPL;
	}

	virtual HRESULT STDMETHODCALLTYPE Commit(
		/* [in] */ DWORD)
	{
		TrapSz ("CStreanNonImbdpl::Commit() called");
		return E_NOTIMPL;
	}

	virtual HRESULT STDMETHODCALLTYPE Revert( void)
	{
		TrapSz ("CStreanNonImpl::Revert() called");
		return E_NOTIMPL;
	}

	virtual HRESULT STDMETHODCALLTYPE LockRegion(
		/* [in] */ ULARGE_INTEGER,
		/* [in] */ ULARGE_INTEGER,
		/* [in] */ DWORD)
	{
		TrapSz ("CStreanNonImpl::LockRegion() called");
		return E_NOTIMPL;
	}

	virtual HRESULT STDMETHODCALLTYPE UnlockRegion(
		/* [in] */ ULARGE_INTEGER,
		/* [in] */ ULARGE_INTEGER,
		/* [in] */ DWORD)
	{
		TrapSz ("CStreanNonImpl::UnlockRegion() called");
		return E_NOTIMPL;
	}

	virtual HRESULT STDMETHODCALLTYPE Stat(
		/* [out] */ STATSTG __RPC_FAR *,
		/* [in] */ DWORD)
	{
		TrapSz ("CStreanNonImpl::Stat() called");
		return E_NOTIMPL;
	}

	virtual HRESULT STDMETHODCALLTYPE Clone(
		/* [out] */ IStream __RPC_FAR *__RPC_FAR *)
	{
		TrapSz ("CStreanNonImpl::Clone() called");
		return E_NOTIMPL;
	}
};

//	Non-Implemented IPersistStreamInit ----------------------------------------
//
class CPersistStreamInitNonImpl: public EXO, public IPersistStreamInit
{
public:
	EXO_INCLASS_DECL(CPersistStreamInitNonImpl);

	virtual HRESULT STDMETHODCALLTYPE GetClassID(
		/* [out] */ CLSID __RPC_FAR *)
	{
		TrapSz ("CPersistStreamInitNonImpl::GetClassID() called");
		return E_NOTIMPL;
	}

	virtual HRESULT STDMETHODCALLTYPE IsDirty( void)
	{
		TrapSz ("CPersistStreamInitNonImpl::IsDirty() called");
		return E_NOTIMPL;
	}

	virtual HRESULT STDMETHODCALLTYPE Load(
		/* [unique][in] */ IStream __RPC_FAR *)
	{
		TrapSz ("CPersistStreamInitNonImpl::Load() called");
		return E_NOTIMPL;
	}

	virtual HRESULT STDMETHODCALLTYPE Save(
		/* [unique][in] */ IStream __RPC_FAR *,
		/* [in] */ BOOL )
	{
		TrapSz ("CPersistStreamInitNonImpl::Save() called");
		return E_NOTIMPL;
	}

	virtual HRESULT STDMETHODCALLTYPE GetSizeMax(
		/* [out] */ ULARGE_INTEGER __RPC_FAR *)
	{
		TrapSz ("CPersistStreamInitNonImpl::GetSizeMax() called");
		return E_NOTIMPL;
	}

	virtual HRESULT STDMETHODCALLTYPE InitNew()
	{
		TrapSz ("CPersistStreamInitNonImpl::InitNew() called");
		return E_NOTIMPL;
	}
};

#endif // _NONIMPL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\request.h ===
#ifndef _REQUEST_H_
#define _REQUEST_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	REQUEST.H
//
//		Header for DAV request class.
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include <autoptr.h>	// For CMTRefCounted parent

class IEcb;
class IBodyPartVisitor;
class IAcceptObserver;
class IAsyncStream;
class IAsyncIStreamObserver;
class IAsyncPersistObserver;

//	========================================================================
//
//	CLASS IRequest
//
//		Interface for HTTP 1.1/DAV 1.0 request using an ISAPI
//		EXTENSION_CONTROL_BLOCK
//
class IRequest : public CMTRefCounted
{
private:
	//	NOT IMPLEMENTED
	//
	IRequest& operator=( const IRequest& );
	IRequest( const IRequest& );

protected:
	//	CREATORS
	//	Only create this object through it's descendents!
	//
	IRequest() {};

public:
	//	CREATORS
	//
	virtual ~IRequest() = 0;

	//	ACCESSORS
	//
	virtual LPCSTR LpszGetHeader( LPCSTR pszName ) const = 0;
	virtual LPCWSTR LpwszGetHeader( LPCSTR pszName, BOOL fUrlConversion ) const = 0;

	virtual BOOL FExistsBody() const = 0;
	virtual IStream * GetBodyIStream( IAsyncIStreamObserver& obs ) const = 0;
	virtual VOID AsyncImplPersistBody( IAsyncStream& stm,
									   IAsyncPersistObserver& obs ) const = 0;

	//	MANIPULATORS
	//
	virtual void ClearBody() = 0;
	virtual void AddBodyText( UINT cbText, LPCSTR pszText ) = 0;
	virtual void AddBodyStream( IStream& stm ) = 0;
};

IRequest * NewRequest( IEcb& ecb );

#endif // !defined(_REQUEST_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\response.h ===
#ifndef _RESPONSE_H_
#define _RESPONSE_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	RESPONSE.H
//
//		Header for DAV response class.
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include <sgstruct.h>	// For PSGITEM in IResponse::AddBodyFile()
#include <autoptr.h>	// For CMTRefCounted parent
#include <body.h>		// For auto_ref_handle, etc.

//	------------------------------------------------------------------------
//
//	CLASS IResponse
//
//		Interface of the HTTP 1.1/DAV 1.0 response using an ISAPI
//		EXTENSION_CONTROL_BLOCK
//
class IEcb;
class IBodyPart;

class IResponseBase : public CMTRefCounted
{
private:
	//	NOT IMPLEMENTED
	//
	IResponseBase& operator=( const IResponseBase& );
	IResponseBase( const IResponseBase& );
protected:
	//	CREATORS
	//	Only create this object through it's descendents!
	IResponseBase() {};
public:
	virtual void AddBodyText( UINT cbText, LPCSTR pszText ) = 0;
	virtual void AddBodyText( UINT cchText, LPCWSTR pwszText ) = 0;
	virtual void AddBodyFile( const auto_ref_handle& hf,
							  UINT64 ibFile64 = 0,
							  UINT64 cbFile64 = 0xFFFFFFFFFFFFFFFF ) = 0;
};

class IResponse : public IResponseBase
{
private:
	//	NOT IMPLEMENTED
	//
	IResponse& operator=( const IResponse& );
	IResponse( const IResponse& );

protected:
	//	CREATORS
	//	Only create this object through it's descendents!
	//
	IResponse() {};

public:
	//	CREATORS
	//
	virtual ~IResponse() = 0;

	//	ACCESSORS
	//
	virtual IEcb * GetEcb() const = 0;
	virtual BOOL FIsEmpty() const = 0;

	virtual DWORD DwStatusCode() const = 0;
	virtual DWORD DwSubError() const = 0;
	virtual LPCSTR LpszStatusDescription() const = 0;

	virtual LPCSTR LpszGetHeader( LPCSTR pszName ) const = 0;

	//	MANIPULATORS
	//
	virtual void SetStatus( int    iStatusCode,
							LPCSTR lpszReserved,
							UINT   uiCustomSubError,
							LPCSTR lpszBodyDetail,
							UINT   uiBodyDetail = 0 ) = 0;

	virtual void ClearHeaders() = 0;
	virtual void SetHeader( LPCSTR pszName, LPCSTR pszValue, BOOL fMultiple = FALSE ) = 0;
	virtual void SetHeader( LPCSTR pszName, LPCWSTR pwszValue, BOOL fMultiple = FALSE ) = 0;

	virtual void ClearBody() = 0;
	virtual void SupressBody() = 0;
	virtual void AddBodyText( UINT cbText, LPCSTR pszText ) = 0;
	virtual void AddBodyFile( const auto_ref_handle& hf,
							  UINT64 ibFile64 = 0,
							  UINT64 cbFile64 = 0xFFFFFFFFFFFFFFFF ) = 0;

	virtual void AddBodyStream( IStream& stm ) = 0;
	virtual void AddBodyStream( IStream& stm, UINT ibOffset, UINT cbSize ) = 0;
	virtual void AddBodyPart( IBodyPart * pBodyPart ) = 0;

	//
	//	Various sending mechanisms
	//
	virtual SCODE ScForward( LPCWSTR pwszURI,
							 BOOL	 fKeepQueryString=TRUE,
							 BOOL	 fCustomErrorUrl = FALSE) = 0;
	virtual SCODE ScRedirect( LPCSTR pszURI ) = 0;
	virtual void Defer() = 0;
	virtual void SendPartial() = 0;
	virtual void SendComplete() = 0;
	virtual void FinishMethod() = 0;
};

IResponse * NewResponse( IEcb& ecb );

#endif // !defined(_RESPONSE_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\security.h ===
/*
 *	S E C U R I T Y . H
 *
 *	Url security checks.  While these would seem to only apply to HttpEXT,
 *	all impls. that care about ASP execution should really think about this.
 *
 *	Bits stolen from the IIS5 project 'iis5\infocom\cache2\filemisc.cxx' and
 *	cleaned up to fit in with the DAV sources.
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_SECURITY_H_
#define _SECURITY_H_

SCODE __fastcall
ScCheckIfShortFileName (
	/* [in] */ LPCWSTR pwszPath,
	/* [in] */ const HANDLE hitUser);

SCODE __fastcall
ScCheckForAltFileStream (
	/* [in] */ LPCWSTR pwszPath);

#endif	// _SECURITY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\scrptmps.h ===
/*
 *	S C R P T M P S . H
 *
 *	Scriptmaps cacheing
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef _SCRPTMPS_H_
#define _SCRPTMPS_H_

//	CLASS IScriptMap ----------------------------------------------------------
//
//	NOTE: This interface must be "pure" -- can't use anything that is private
//	to DAVEX because ExINET re-implements this class on LocalStore installs.
//	For that reason, we pass in two pieces from CMethUtil, not the CMethUtil itself.
//
class IScriptMap : public IRefCounted
{
	//	NOT IMPLEMENTED
	//
	IScriptMap(const IScriptMap&);
	IScriptMap& operator=(IScriptMap&);

protected:
	//	CREATORS
	//	Only create this object through it's descendents!
	//
	IScriptMap() 
	{
	};

public:

	//	ScMatched
	//	This is the workhorse of the scriptmap matching.
	//	There are three possible returns here:
	//		S_OK -- there was NO match in the scriptmaps
	//		W_DAV_SCRIPTMAP_MATCH_FOUND -- There was a match.
	//		W_DAV_SCRIPTMAP_MATCH_EXCLUDED -- There was a match,
	//			but the current method is excluded.
	//	This is important, because the ExINET metabase-replacement code
	//	re-implements this function, and so the semantics must match!
	//
	virtual SCODE ScMatched (LPCWSTR pwszMethod,
							 METHOD_ID midMethod,
							 LPCWSTR pwszMap,
							 DWORD dwAccess,
							 BOOL * pfCGI) const = 0;

	virtual BOOL FSameStarScriptmapping (const IScriptMap *) const = 0;
};

IScriptMap *
NewScriptMap( LPWSTR pwszScriptMaps );

#endif	// _SCRPTMPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\sgstruct.h ===
#ifndef _SGSTRUCT_H_
#define _SGSTRUCT_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	SGSTRUCT.H
//
//		Data structures to specify Scatther Gather Files
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#pragma warning(disable:4200)	/* zero-sized array */


// Structure to specify the sizes and offsets of a Scatter-Gather File

typedef struct 	_SGITEM
{
	DWORD	dwibFile;		// offset into file of SG packet
	DWORD	dwcbSegment;    // size (in bytes) of SG packet
	UINT    ibBodyPart;		// offset into body part of SG packet
} SGITEM, *PSGITEM;

// structure to specify a scatther gather file
typedef struct _SCATTER_GATHER_FILE
{
	HANDLE 	hFile; 	// the file handle

	ULONG	cSGList;   //number of scatter-gather packets associated with file

	SGITEM rgSGList[];  // an array of size cSGList ie struct SGITEM rgSGList[cSGItem]

} SCATTER_GATHER_FILE;


#endif // !defined(_SGSTRUCT_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\replpropshack.h ===
//	========================================================================
//
//	REPLPROPSHACK.H
//
//		Extra bits for replication in DAVEX.
//
//	========================================================================

#ifndef _REPLPROPSHACK_H_
#define _REPLPROPSHACK_H_

//	Values for new XML nodes
DEC_CONST WCHAR gc_wszReplNode[]				= L"http://schemas.microsoft.com/repl/repl";
DEC_CONST WCHAR gc_wszReplCollBlob[]			= L"http://schemas.microsoft.com/repl/collblob";
DEC_CONST WCHAR gc_wszReplResTagList[]			= L"http://schemas.microsoft.com/repl/resourcetaglist";
DEC_CONST WCHAR gc_wszReplResTagItem[]			= L"http://schemas.microsoft.com/repl/resourcetag";

//	Names for new properties
DEC_CONST WCHAR gc_wszReplChangeType[]		= L"http://schemas.microsoft.com/repl/changetype";
DEC_CONST WCHAR gc_wszReplUid[]				= L"http://schemas.microsoft.com/repl/repl-uid";
DEC_CONST WCHAR gc_wszReplContentTag[]		= L"http://schemas.microsoft.com/repl/contenttag";
DEC_CONST WCHAR gc_wszReplResourceTag[] 	= L"http://schemas.microsoft.com/repl/resourcetag";

//	New headers
DEC_CONST CHAR gc_szResourceTag[] = "ResourceTag";
DEC_CONST CHAR gc_szReplUID[] = "Repl-UID";

//	Namespace string used for namespace preloading by the XML emitter
//
DEC_CONST WCHAR gc_wszReplNameSpace[]				= L"http://schemas.microsoft.com/repl/";

#endif // !_REPLPROPSHACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\safeobj.h ===
/*
 *	S A F E O B J . H
 *
 *	Implementation of safe object classes
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef _SAFEOBJ_H_
#define _SAFEOBJ_H_

#include <except.h>

//	safe_xxx classes ----------------------------------------------------------
//
class safe_bstr
{
	BSTR		bstr;

	//	NOT IMPLEMENTED
	//
	safe_bstr(const safe_bstr& b);
	safe_bstr& operator=(const safe_bstr& b);

public:

	//	CONSTRUCTORS
	//
	explicit safe_bstr(BSTR b=0) : bstr(b) {}
	~safe_bstr()
	{
		SysFreeString (bstr);
	}

	//	MANIPULATORS
	//
	safe_bstr& operator=(BSTR b)
	{
		Assert(!bstr);		//	Scream on overwrite of good data.
		bstr = b;
		return *this;
	}

	//	ACCESSORS
	//
	BSTR* operator&()	{ Assert(NULL==bstr); return &bstr; }
	BSTR get()			const { return bstr; }
	BSTR relinquish()	{ BSTR b = bstr; bstr = 0; return b; }
	BSTR* load()		{ Assert(NULL==bstr); return &bstr; }
};

class safe_propvariant
{
	PROPVARIANT		var;

	//	NOT IMPLEMENTED
	//
	safe_propvariant(const safe_propvariant& b);
	safe_propvariant& operator=(const safe_propvariant& b);

public:

	//	CONSTRUCTORS
	//
	explicit safe_propvariant()
	{
		//	Note! we cannot simply set vt to VT_EMPTY, as when this
		//	structure go across process, it will cause marshalling
		//	problem if not property initialized.
		//
		ZeroMemory (&var, sizeof(PROPVARIANT) );
	}

	~safe_propvariant()
	{
		PropVariantClear (&var);
	}

	//	MANIPULATORS
	//
	safe_propvariant& operator=(PROPVARIANT v)
	{
		Assert(var.vt == VT_EMPTY);		//	Scream on overwrite of good data.
		var = v;
		return *this;
	}

	//	ACCESSORS
	//
	PROPVARIANT* operator&()	{ Assert(var.vt == VT_EMPTY); return &var; }
	//	get() accessor
	//	NOTE that I am returning a const reference here.  The reference is to
	//	avoid creating a copy of our member var on return.  The const is
	//	because this method is a const accessor method.
	const PROPVARIANT& get()	const { return var; }
	//	relinquish() accessor
	//	NOTE that I am NOT returning a reference here.  The return for this
	//	method comes off the STACK (PROPVARIANT v), so a reference would point
	//	to that stack space, and our caller would be accessing OLD STACK frames.
	PROPVARIANT relinquish()	{ PROPVARIANT v = var; var.vt = VT_EMPTY; return v; }
	PROPVARIANT* addressof()	{ return &var; }
};

class safe_variant
{
	//	IMPORTANT:  Do not add any other members to this class
	//	other than the VARIANT that is to be protected.  You will
	//	break code all over the place if you do.  There are places
	//	where an array of these things are treated as an array of
	//	VARIANT structures.
	//
	VARIANT		var;

	//	NOT IMPLEMENTED
	//
	safe_variant(const safe_variant& b);
	safe_variant& operator=(const safe_variant& b);

public:

	//	CONSTRUCTORS
	//
	explicit safe_variant()
	{
		//	Note! we cannot simply set vt to VT_EMPTY, as when this
		//	structure go across process, it will cause marshalling
		//	problem if not property initialized.
		//
		ZeroMemory (&var, sizeof(VARIANT) );
	}
	~safe_variant()
	{
		VariantClear (&var);
	}

	//	MANIPULATORS
	//
	safe_variant& operator=(VARIANT v)
	{
		Assert(var.vt == VT_EMPTY);		//	Scream on overwrite of good data.
		var = v;
		return *this;
	}

	//	ACCESSORS
	//
	VARIANT* operator&()	{ Assert(var.vt == VT_EMPTY); return &var; }
	//	get() accessor
	//	NOTE that I am returning a const reference here.  The reference is to
	//	avoid creating a copy of our member var on return.  The const is
	//	because this method is a const accessor method.
	const VARIANT& get()	const { return var; }
	//	relinquish() accessor
	//	NOTE that I am NOT returning a reference here.  The return for this
	//	method comes off the STACK (PROPVARIANT v), so a reference would point
	//	to that stack space, and our caller would be accessing OLD STACK frames.
	VARIANT relinquish()	{ VARIANT v = var; var.vt = VT_EMPTY; return v; }
};

//	Safe impersonation --------------------------------------------------------
//
class safe_impersonation
{
	BOOL		m_fImpersonated;

	//	NOT IMPLEMENTED
	//
	safe_impersonation(const safe_impersonation& b);
	safe_impersonation& operator=(const safe_impersonation& b);

public:

	//	CONSTRUCTORS
	//
	explicit safe_impersonation(HANDLE h = 0) : m_fImpersonated(0)
	{
		if (h != 0)
			m_fImpersonated = ImpersonateLoggedOnUser (h);
	}

	~safe_impersonation()
	{
		if (m_fImpersonated)
			RevertToSelf();
	}

	BOOL FImpersonated() const { return m_fImpersonated; }
};

//	------------------------------------------------------------------------
//
//	class safe_revert
//
//		Turns impersonation OFF for the duration of the object's lifespan.
//		Unconditionally reimpersonates on exit, based on the provided handle.
//
//		NOTE: UNCONDITIONALLY reimpersonates on exit.
//			  (Just wanted to make that clear.)
//
//	WARNING: the safe_revert class should only be used in very selective
//	situations.  It is not a "quick way to get around" impersonation.  If
//	you do need to do something like this, please see Becky -- she will then
//	wack you up'side the head.
//
class safe_revert
{
	HANDLE		m_h;

	safe_revert( const safe_revert& );
	safe_revert& operator=( const safe_revert& );

public:

	explicit safe_revert( HANDLE h ) : m_h(h)
	{
		RevertToSelf();
	}

	~safe_revert()
	{
		if (!ImpersonateLoggedOnUser( m_h ))
		{
			//	There's not much we can do in this dtor. throw
		  	//
			throw CLastErrorException();
		}
	}
};

//	-------------------------------------------------------------------------
//
//	class safe_revert_self
//
//		This is class is essentially the same as safe_revert except it uses
//	the thread handle instead of an external handle
//
class safe_revert_self
{
    // Handle to hold on to the thread token
    // that we will want to use when we go back
    // to impersonating.
	//
    HANDLE m_hThreadHandle;

public:

    // constructor will revert to self if there is
    // a valid thread token it can get for the current thread
	//
    safe_revert_self() :
			m_hThreadHandle (INVALID_HANDLE_VALUE)
    {
        if (OpenThreadToken( GetCurrentThread(),
        					TOKEN_QUERY | TOKEN_IMPERSONATE | TOKEN_DUPLICATE,
                            		TRUE,	//	fOpenAsSelf
		                            &m_hThreadHandle ))
		{
            if (!RevertToSelf())
                DebugTrace ("Failed to revert to self \r\n");
        }
        else
        	DebugTrace ("Failed to open thread token, last error = %d\n",
        				GetLastError());
    }

    // destructor will impersonate again if we did a RevertToSelf above.
	//
    ~safe_revert_self()
    {
        if (m_hThreadHandle != INVALID_HANDLE_VALUE)
        {
            if (!ImpersonateLoggedOnUser(m_hThreadHandle))
            {
                DebugTrace("Failed to get back to correct user \r\n");
                
		  //	There's not much we can do in this dtor. throw
		  //
		  CloseHandle (m_hThreadHandle);
		  throw CLastErrorException();
            }
        }
    }
};

#endif // _SAFEOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\singlton.h ===
/*
 *	S I N G L T O N . H
 *
 *	Singleton (per-process global) classes
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef _SINGLTON_H_
#define _SINGLTON_H_

#include <caldbg.h>

//	========================================================================
//
//	TEMPLATE CLASS Singleton
//
//	Use this template to implement classes that can only have one instance.
//	NOTE: For ref-counted or on-demand global objects, see below
//		(RefCountedGlobal and OnDemandGlobal).
//
//	The Singleton template provides the following:
//
//		o	a common memory layout for singleton classes which
//			allows template folding to reduce overall code size.
//
//		o	an instantiation mechanism that verifies (asserts)
//			that only instance of your class ever exists.
//
//		o	asserts to catch any code which attempts to use
//			your class when it's not initialized.
//
//	To use this template, declare your class like this:
//
//		class YourClass : private Singleton<YourClass>
//		{
//			//
//			//	Declare Singleton as a friend of YourClass
//			//	if YourClass's constructor is private (which it
//			//	should be since YourClass is a singleton and
//			//	should not be allowed to arbitrarily create
//			//	instances of it).
//			//
//			friend class Singleton<YourClass>;
//
//			//
//			//	YourClass private members.  Since the 'staticness'
//			//	of YourClass is provided entirely by this template,
//			//	you do not need to declare your members as 'static'
//			//	and you should use standard Hungarian class member
//			//	naming conventions (e.g. m_dwShoeSize).
//			//
//			[...]
//
//		public:
//			//
//			//	Public declarations for YourClass.  Among these should
//			//	be static functions to init and deinit YourClass which
//			//	would call CreateInstance() and DestroyInstance()
//			//	respectively.  Or, you could just expose these functions
//			//	directly to clients of YourClass with using declarations:
//			//
//			//		using Singleton<YourClass>::CreateInstance;
//			//		using Singleton<YourClass>::DestroyInstance;
//			//
//			//	Similarly, YourClass will probably have additional
//			//	static methods which access or operate on the
//			//	singleton instance.  These will call Instance()
//			//	to get at the global instance.  Or, though it's
//			//	not recommended from an encapsulation standpoint,
//			//	you could expose the global instance directly to
//			//	clients with:
//			//
//			//		using Singleton<YourClass>::Instance;
//			//
//			[...]
//		};
//
template<class _X>
class Singleton
{
	//
	//	Space for the sole instance
	//
	static BYTE sm_rgbInstance[];

	//
	//	Pointer to the instance
	//
	static _X * sm_pInstance;

public:
	//	STATICS
	//

	//
	//	Create the single, global instance of class _X.
	//
	static _X& CreateInstance()
	{
		//
		//	This actually calls Singleton::new()
		//	(defined below), but calls to new()
		//	must always be unqualified.
		//
		return *(new _X());
	}

	//
	//	Destroy the single, global instance of class _X.
	//
	static VOID DestroyInstance()
	{
		//
		//	This actually calls Singleton::delete()
		//	(defined below), but calls to delete()
		//	must always be unqualified.
		//
		if (sm_pInstance)
			delete sm_pInstance;
	}

	//
	//	Provide access to the single, global instance of class _X.
	//
	static BOOL FIsInstantiated()
	{
		return !!sm_pInstance;
	}

	static _X& Instance()
	{
		Assert( sm_pInstance );

		return *sm_pInstance;
	}

	//
	//	Singleton operator new and operator delete "allocate"
	//	space for the object in static memory.  These must be
	//	defined public for syntactic reasons.  Do NOT call them
	//	directly!!  Use CreateInstance()/DestroyInstance().
	//
	static void * operator new(size_t)
	{
		Assert( !sm_pInstance );

		//
		//	Just return a pointer to the space
		//	in which to instantiate the object.
		//
		sm_pInstance = reinterpret_cast<_X *>(sm_rgbInstance);
		return sm_pInstance;
	}

	static void operator delete(void *, size_t)
	{
		Assert( sm_pInstance );

		//
		//	Since nothing was done to allocate space
		//	for the instance, we don't do anything
		//	here to free it.
		//
		sm_pInstance = NULL;
	}

};

//
//	Space for the sole instance of class _X
//
template<class _X>
BYTE Singleton<_X>::sm_rgbInstance[sizeof(_X)] = {0};

//
//	Pointer to the instance
//
template<class _X>
_X * Singleton<_X>::sm_pInstance = NULL;


//	========================================================================
//
//	CLASS _Empty
//
//	A completely empty, but instantiatable class.  Use the _Empty class
//	to get around the syntactic inability to instantiate anything of
//	type void (or VOID).
//
//	In retail builds, _Empty has the same memory footprint and code
//	impact as void -- none.
//
//	See the RefCountedGlobal template below for a usage example.
//
class _Empty
{
	//	NOT IMPLEMENTED
	//
	_Empty( const _Empty& );
	_Empty& operator=( const _Empty& );

public:
	_Empty() {}
	~_Empty() {}
};


//	========================================================================
//
//	TEMPLATE CLASS RefCountedGlobal
//
//	Use this template as boilerplate for any class that encapsulates
//	a global, refcounted initialization/deinitialization process.
//
//	This template maintains proper refcounting and synchronization when
//	there are multiple threads trying to initialize and deinitialize
//	references at the same time.  And it does so without a critical
//	section.
//
//	To use this template, declare your class like this:
//
//		class YourClass : private RefCountedGlobal<YourClass>
//		{
//			//
//			//	Declare Singleton and RefCountedGlobal as friends
//			//	of YourClass so that they can call your private
//			//	initialization functions.
//			//
//			friend class Singleton<YourClass>;
//			friend class RefCountedGlobal<YourClass>;
//
//			//
//			//	Private declarations for YourClass
//			//
//			[...]
//
//			//
//			//	Failable initialization function.  This function
//			//	should perform any failable initialization of the
//			//	instance of YourClass.  It should return TRUE
//			//	if initialization succeeds, and FALSE otherwise.
//			//	If YourClass does not have any initialization that
//			//	can fail then you should implement this function inline
//			//	to just return TRUE.
//			//
//			BOOL FInit();
//
//		public:
//			//
//			//	Public declarations for YourClass.  Among these should
//			//	be static functions to init and deinit YourClass.  These
//			//	functions would call DwInitRef() and DeinitRef() respectively.
//			//	Or, you could just expose DwInitRef() and DeinitRef()
//			//	directly to clients of YourClass with using declarations:
//			//
//			//		using RefCountedGlobal<YourClass>::DwInitRef;
//			//		using RefCountedGlobal<YourClass>::DeinitRef;
//			//
//			[...]
//		};
//
//	If YourClass::FInit() succeeds (returns TRUE), then DwInitRef()
//	returns the new refcount.  If YourClass::FInit() fails (returns
//	FALSE), then DwInitRef() returns 0.
//
//	See \cal\src\inc\memx.h for sample usage.
//
//	If YourClass::FInit() requires initialization parameters, you can
//	still use the RefCountedGlobal template.  You just need to provide
//	your parameter type in the template instantiation and declare your
//	FInit() to take a const reference to a parameter of that type:
//
//		class YourClass : private RefCountedGlobal<YourClass, YourParameterType>
//		{
//			//
//			//	Declare Singleton and RefCountedGlobal as friends
//			//	of YourClass so that htey can call your private
//			//	initialization functions.
//			//
//			//	Note the added parameter type to the RefCountedGlobal
//			//	declaration.
//			//
//			friend class Singleton<YourClass>;
//			friend class RefCountedGlobal<YourClass, YourParameterType>;
//
//			//
//			//	Private declarations for YourClass
//			//
//			[...]
//
//			//
//			//	Failable initialization function.  This function
//			//	now takes a const ref to the initialization parameters.
//			//
//			BOOL FInit( const YourParameterType& initParam );
//
//		public:
//			//
//			//	Public declarations for YourClass
//			//
//			[...]
//		};
//
//	See \cal\src\httpext\entry.cpp for an example of this usage.
//
template<class _X, class _ParmType = _Empty>
class RefCountedGlobal : private Singleton<_X>
{
	//
	//	The object's reference count.
	//
	static LONG sm_lcRef;

	//
	//	Member template that generates an appropriately-typed,
	//	(inline) function that calls _X::FInit with initialization
	//	parameters.
	//
	template<class _P> static BOOL
	FInit( const _P& parms ) { return Instance().FInit( parms ); }

	//
	//	Specialization of the above member template for
	//	the _Empty parameter type, which calls _X::FInit
	//	without initialization parameters.
	//
	static BOOL FInit( const _Empty& ) { return Instance().FInit(); }

protected:

	//
	//	Set of states which describe the object's state
	//	of initialization.  The object's state is
	//	STATE_UNKNOWN while it is being initialized or
	//	deinitialized.
	//
	enum
	{
		STATE_UNINITIALIZED,
		STATE_INITIALIZED,
		STATE_UNKNOWN
	};

	static LONG sm_lState;

	//
	//	Expose access to the single instance of class _X
	//
	using Singleton<_X>::Instance;

	//
	//	Expose operator new and operator delete from
	//	the Singleton template so that they will be
	//	used rather than the default new and delete
	//	to "allocate" space for the instance of class _X.
	//
	using Singleton<_X>::operator new;
	using Singleton<_X>::operator delete;

	static BOOL FInitialized()
	{
		return sm_lState == STATE_INITIALIZED;
	}

	static LONG CRef()
	{
		return sm_lcRef;
	}

public:
	static DWORD DwInitRef( const _ParmType& parms )
	{
		LONG lcRef;

		//
		//	Assert the invariant condition that we never have a
		//	reference without the state being initialized.
		//
		Assert( sm_lState != STATE_INITIALIZED || sm_lcRef >= 1 );

		//
		//	Add the reference for the instance we're about
		//	to initialize.  Doing this now simplifies the
		//	code below at the expense of having to decrement
		//	if first time initialization (FInit()) fails.
		//	The only thing critical to the design is that
		//	at any point, when sm_lState is STATE_INITIALIZED,
		//	sm_lcRef is at least 1.
		//
		lcRef = InterlockedIncrement( &sm_lcRef );
		Assert( lcRef > 0 );

		//
		//	Don't proceed until the object is initialized.
		//
		while ( sm_lState != STATE_INITIALIZED )
		{
			//
			//	Simultaneously check whether initialization has
			//	started and, if it has not, start it.
			//
			LONG lStatePrev = InterlockedCompareExchange(
								&sm_lState,
								STATE_UNKNOWN,
								STATE_UNINITIALIZED );

			//
			//	If we're starting first time initialization,
			//	then create and initialize the sole instance.
			//
			if ( lStatePrev == STATE_UNINITIALIZED )
			{
				CreateInstance();

				//	This calls our private member template FInit()
				//	(declared above), which in turn calls _X::Finit()
				//	with the appropriate parameters.
				//
				if ( FInit( parms ) )
				{
					sm_lState = STATE_INITIALIZED;
					break;
				}

				//	We failed to init.
				//	Tear down now.
				//

				Assert( lcRef == 1 );
				Assert( sm_lState == STATE_UNKNOWN );

				//	Let go of our ref on the object.
				//	Destroy the object.
				//	And LAST, set the state to UNINITIALIZED.
				//	NOTE: This will let the next caller through the
				//	InterlockedCompare above.
				//
				InterlockedDecrement( &sm_lcRef );
				DestroyInstance();
				sm_lState = STATE_UNINITIALIZED;

				return 0;
			}

			//
			//	If first time initialization is in progress on
			//	another thread, then get out of the way so
			//	it can finish.
			//
			//$OPT	We should probably spin rather than Sleep()
			//$OPT	on multi-proc machines on the assumption that
			//$OPT	we only get here on a processor other than
			//$OPT	the one which is doing the initialization
			//$OPT	and we don't want to invite a task switch
			//$OPT	by calling Sleep() while we are waiting
			//$OPT	for initialization to complete.
			//
			if ( lStatePrev == STATE_UNKNOWN )
				Sleep(0);
		}

		//
		//	At this point, there must be at least
		//	one initialized reference.
		//
		Assert( sm_lState == STATE_INITIALIZED );
		Assert( sm_lcRef > 0 );

		return static_cast<DWORD>(lcRef);
	}

	static VOID DeinitRef()
	{
		//
		//	At this point, there must be at least
		//	one initialized reference.
		//
		Assert( sm_lState == STATE_INITIALIZED );
		Assert( sm_lcRef > 0 );

		//
		//	Remove that reference.  If it is the last
		//	then deinit the object.
		//
		if ( 0 == InterlockedDecrement( &sm_lcRef ) )
		{
			//
			//	After releasing the last reference, declare that
			//	the object is in an unknown state.  This prevents
			//	other threads trying to re-initialize the object
			//	from proceeding until we're done.
			//
			sm_lState = STATE_UNKNOWN;

			//
			//	There is a tiny window between decrementing the
			//	refcount and changing the state where another
			//	initialization could have come through.  Test this
			//	by rechecking the refcount.
			//
			if ( 0 == sm_lcRef )
			{
				//
				//	If the refcount is still zero, then no
				//	initializations happened before we changed
				//	states.  At this point, if an initialization
				//	starts, it will block until we change state,
				//	so it is safe to actually destroy the instance.
				//
				DestroyInstance();

				//
				//	Once the object has been deinitialized, update
				//	the state information.  This unblocks any
				//	initializations waiting to happen.
				//
				sm_lState = STATE_UNINITIALIZED;
			}
			else // refcount is now non-zero
			{
				//
				//	If the refcount is no longer zero, then an
				//	initialization happened between decrementing
				//	the refcount above and entering the unknown
				//	state.  When that happens, DO NOT deinit --
				//	there is now another valid reference somewhere.
				//	Instead, just restore the object's state to let
				//	other references proceed.
				//
				sm_lState = STATE_INITIALIZED;
			}
		}

		//
		//	Assert the invariant condition that we never have a
		//	reference without the state being initialized.
		//
		Assert( sm_lState != STATE_INITIALIZED || sm_lcRef >= 1 );
	}

	//	This provides a no-parameter version of DwInitRef
	//	for clients that do not need any parameters in FInit().
	//
	static DWORD DwInitRef()
	{
		_Empty e;

		return DwInitRef( e );
	}
};

template<class _X, class _ParmType>
LONG RefCountedGlobal<_X, _ParmType>::sm_lcRef = 0;

template<class _X, class _ParmType>
LONG RefCountedGlobal<_X, _ParmType>::sm_lState = STATE_UNINITIALIZED;


//	========================================================================
//
//	TEMPLATE CLASS OnDemandGlobal
//
//	Use this template to implement a global object which should be
//	initialized on its first use ("on demand") and then explicitly
//	deinitialized once if it was ever used.
//
//	The most common usage is with global objects that ideally are never
//	used or for which up-front initialization is prohibitively
//	expensive.  However, once the object has been initialied, it should
//	remain initialized (to avoid having to initialize it again) until
//	it is explicitly deinitialized.
//
//	!!!	OnDemandGlobal DOES NOT provide refcounting functionality to
//		consumers -- It uses refcounting internally, but is not intended
//		to expose it to callers.  If you want refcounting, use RefCountedGlobal.
//		If you call DeinitIfUsed(), the instance WILL be destroyed if it
//		exists. In particular, calling code MUST ensure that DeinitIfUsed()
//		is not called while any other thread is inside FInitOnFirstUse().
//		Failure to do so can cause FInitOnFirstUse() to return with the
//		object uninitialized.
//
//	Usage:
//
//		class YourClass : private OnDemandGlobal<YourClass>
//		{
//			//
//			//	Declare Singleton and RefCountedGlobal as friends
//			//	of YourClass so that they can call your private
//			//	creation/initialization functions.
//			//
//			friend class Singleton<YourClass>;
//			friend class RefCountedGlobal<YourClass>;
//
//			//
//			//	Private declarations for YourClass
//			//
//			[...]
//
//			//
//			//	Failable initialization function.  This function
//			//	should perform any failable initialization of the
//			//	instance of YourClass.  It should return TRUE
//			//	if initialization succeeds, and FALSE otherwise.
//			//	If YourClass does not have any initialization that
//			//	can fail then you should implement this function inline
//			//	to just return TRUE.
//			//
//			BOOL FInit();
//
//		public:
//			//
//			//	Public declarations for YourClass.  Among these should
//			//	be static functions to init and deinit YourClass.  These
//			//	functions would call FInitOnFirstUse() and DeinitIfUsed()
//			//	respectively.  Or, you could just expose FInitOnFirstUse()
//			//	and DeinitIfUsed() directly to clients of YourClass with
//			//	using declarations:
//			//
//			//		using RefCountedGlobal<YourClass>::FInitOnFirstUse;
//			//		using RefCountedGlobal<YourClass>::DeinitIfUsed;
//			//
//			[...]
//		};
//
//	FInitOnFirstUse() can be called any number of times from any
//	thread, including simultaneously from multiple threads, but
//	DeinitIfUsed() should only ever be called once, and then
//	only when no other threads are calling FInitOnFirstUse().
//
//	OnDemandGlobal takes care of tracking whether YourClass was
//	ever actually used so that DeinitIfUsed() is safe to call
//	even if YourClass was never used (hence the name).
//
//	See \cal\src\_davprs\eventlog.cpp for sample usage.
//
template<class _X, class _ParmType = _Empty>
class OnDemandGlobal : private RefCountedGlobal<_X, _ParmType>
{
protected:
	//
	//	Expose access to the single instance of class _X
	//
	using RefCountedGlobal<_X, _ParmType>::Instance;

	//
	//	Expose operator new and operator delete from
	//	the Singleton template (via RefCountedGlobal)
	//	so that they will be used rather than the
	//	default new and delete to "allocate" space
	//	for the instance of class _X.
	//
	using RefCountedGlobal<_X, _ParmType>::operator new;
	using RefCountedGlobal<_X, _ParmType>::operator delete;

public:
	static BOOL FInitOnFirstUse( const _ParmType& parms )
	{
		DWORD dwResult = 1;

		if ( STATE_INITIALIZED != sm_lState )
		{
			//	Add a reference to the object.  If this is the first
			//	reference, RefCountedGlobal will call _X::FInit()
			//	to initialize the object.
			//
			dwResult = DwInitRef( parms );

			//	If this was not the first reference, then release
			//	the reference we just added.  We only want one
			//	reference left around by the time DeinitIfUsed()
			//	so that the DeinitRef() called from there will
			//	actually destroy the object.
			//
			if ( dwResult > 1 )
				DeinitRef();
		}

		//	Return success/failure (dwResult == 0 --> failure)
		//
		return !!dwResult;
	}

	static BOOL FInitOnFirstUse()
	{
		_Empty e;

		return FInitOnFirstUse( e );
	}

	static VOID DeinitIfUsed()
	{
		//
		//	If the object was never initialized (i.e. there was
		//	never a reference to it), then do nothing.
		//	Otherwise, deinit the object.
		//
		if ( FInitialized() )
		{
			//
			//	Make sure there is EXACTLY one reference.
			//	Zero references indicates a bug in setting the
			//	initialization state.  More than one reference
			//	most likely indicates that OnDemandGlobal is
			//	being used where RefCountedGlobal is needed.
			//
			Assert( CRef() == 1 );

			DeinitRef();
		}
	}
};

#endif // _SINGLTON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\szsrc.h ===
/*
 *	S Z S R C . H
 *
 *	Multi-language string support
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_SZSRC_H_
#define _SZSRC_H_

//	Include CAL common defines ('cause they used to live in this file!)
#include <ex\calcom.h>
#include <except.h>

//	Localized string lookup ---------------------------------------------------
//
class safe_lcid
{
	LONG		m_lcid;

	//	NOT IMPLEMENTED
	//
	safe_lcid(const safe_lcid& b);
	safe_lcid& operator=(const safe_lcid& b);

public:

	//	CONSTRUCTORS
	//
	explicit safe_lcid (LONG lcid = LOCALE_SYSTEM_DEFAULT)
		: m_lcid(GetThreadLocale())
	{
		SetThreadLocale (lcid);
	}
	~safe_lcid ()
	{
		if (!SetThreadLocale (m_lcid))
			throw CLastErrorException();
	}
};


//	Localized string fetching -------------------------------------------------
//
BOOL FLookupLCID (LPCSTR psz, ULONG * plcid);
ULONG LcidAccepted (LPCSTR psz);
LPSTR LpszAutoDupSz (LPCSTR psz);
LPWSTR WszDupWsz (LPCWSTR psz);
BOOL FInitResourceStringCache();
VOID DeinitResourceStringCache();
LPSTR LpszLoadString (
		UINT		uiResourceID,
		ULONG		lcid,
		LPSTR		lpszBuf,
		INT			cchBuf );
LPWSTR LpwszLoadString (
		UINT		uiResourceID,
		ULONG		lcid,
		LPWSTR		lpwszBuf,
		INT			cchBuf);

//	Service instance (otherwise referred as server ID)
//	parsing out of virtual root
//
LONG LInstFromVroot( LPCWSTR pwszServerId );

#endif // _SZSRC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\synchro.h ===
#ifndef _SYNCHRO_H_
#define _SYNCHRO_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	SYNCHRO.H
//
//		Header for DAV synchronization classes.
//
//	Copyright 1986-1998 Microsoft Corporation, All Rights Reserved
//

#ifdef _DAVCDATA_
#error "synchro.h: CInitGate can throw() -- not safe for DAVCDATA"
#endif

//	Include common EXDAV-safe synchronization items
#include <ex\stackbuf.h>
#include <ex\synchro.h>
#include <ex\autoptr.h>

#include <stdio.h>		// for swprintf()
#include <except.h>		// Exception throwing/handling

//	Security Descriptors ------------------------------------------------------
//
// ----------------------------------------------------------------------------
//
inline BOOL
FCreateWorldSid (PSID * ppsidEveryone)
{
	//	Assert initialize output
	//
	Assert (ppsidEveryone);
	*ppsidEveryone = NULL;

    //	An SID is built from an Identifier Authority and a set of Relative IDs
    //	(RIDs).  The Authority of interest to us SECURITY_NT_AUTHORITY.
    //
    SID_IDENTIFIER_AUTHORITY siaWorld = SECURITY_WORLD_SID_AUTHORITY;

    //	Each RID represents a sub-unit of the authority.  The SID we want to
	//	buils, Everyone, are in the "built in" domain.
    //
    //	For examples of other useful SIDs consult the list in
    //	\nt\public\sdk\inc\ntseapi.h.
    //
	return !AllocateAndInitializeSid (&siaWorld,
									  1, // 1 sub-authority
									  SECURITY_WORLD_RID,
									  0,0,0,0,0,0,0,
									  ppsidEveryone);
}
inline SECURITY_DESCRIPTOR *
PsdCreateWorld ()
{
	ACL *pacl = NULL;
	SECURITY_DESCRIPTOR * psd = NULL;
	SECURITY_DESCRIPTOR * psdRet = NULL;
	ULONG cbAcl = 0;
    PSID psidWorld = NULL;

	//	Create the SID for the world (ie. everyone).
	//
	if (!FCreateWorldSid (&psidWorld))
		goto ret;

	//  Calculate the size of and allocate a buffer for the DACL, we need
	//	this value independently of the total alloc size for ACL init.
	//
	// "- sizeof (ULONG)" represents the SidStart field of the
	// ACCESS_ALLOWED_ACE.  Since we're adding the entire length of the
	// SID, this field is counted twice.
	//
	cbAcl = sizeof(ACL)
			+ (1 * (sizeof (ACCESS_ALLOWED_ACE) - sizeof (ULONG)))
			+ GetLengthSid(psidWorld);

	//	Allocate space for the acl
	//
	psd = static_cast<SECURITY_DESCRIPTOR *>
		  (LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH + cbAcl));

	if (NULL == psd)
		goto ret;

	//	Find the start of the ACL and initialize it.
	//
	pacl = reinterpret_cast<ACL *>
		   (reinterpret_cast<BYTE *>(psd) + SECURITY_DESCRIPTOR_MIN_LENGTH);

	if (!InitializeAcl (pacl, cbAcl, ACL_REVISION))
		goto ret;

	if (!AddAccessAllowedAce (pacl,
							  ACL_REVISION,
							  SYNCHRONIZE | GENERIC_WRITE | GENERIC_READ,
							  psidWorld))
	{
		//	The security descriptor does not contain valid stuff, we need
		//	to clean that up (via auto_heap_ptr, this is pretty easy).
		//
		goto ret;
	}

	//	Set the security descriptor
	//
	if (!SetSecurityDescriptorDacl (psd,
									TRUE,
									pacl,
									FALSE))
	{
		//	Again, the security descriptor does not contain valid stuff, we
		//	need to clean that up (via auto_heap_ptr, this is pretty easy).
		//
		goto ret;
	}

	//	Setup the return
	//
	psdRet = psd;
	psd = NULL;

ret:

	if (psidWorld) FreeSid(psidWorld);
	if (psd) LocalFree (psd);

	return psdRet;
}

//	========================================================================
//
//	CLASS CInitGate
//
//	(The name of this class is purely historical)
//
//	Encapsulates ONE-SHOT initialization of a globally NAMED object.
//
//	Use to handle simultaneous on-demand initialization of named
//	per-process global objects.  For on-demand initialization of
//	unnamed per-process global objects, use the templates in singlton.h.
//
class CInitGate
{
	CEvent m_evt;
	BOOL m_fInit;

	//  NOT IMPLEMENTED
	//
	CInitGate& operator=( const CInitGate& );
	CInitGate( const CInitGate& );

public:

	CInitGate( LPCWSTR lpwszBaseName,
			   LPCWSTR lpwszName ) :

		m_fInit(FALSE)
	{
		//
		//	First, set up an empty security descriptor and attributes
		//	so that the event can be created with no security
		//	(i.e. accessible from any security context).
		//
		SECURITY_DESCRIPTOR * psdAllAccess = PsdCreateWorld();
		SECURITY_ATTRIBUTES saAllAccess;

		saAllAccess.nLength = sizeof(saAllAccess);
		saAllAccess.lpSecurityDescriptor = psdAllAccess;
		saAllAccess.bInheritHandle = FALSE;

		WCHAR lpwszEventName[MAX_PATH];
		if (MAX_PATH < (wcslen(lpwszBaseName) +
						wcslen(lpwszName) +
						1))
		{
			SetLastError(ERROR_NOT_ENOUGH_MEMORY);
			throw CLastErrorException();
		}

		swprintf(lpwszEventName, L"%ls%ls", lpwszBaseName, lpwszName);
		if ( !m_evt.FCreate( &saAllAccess,  // no security
							 TRUE,  // manual reset
							 FALSE, // initially non-signalled
							 lpwszEventName))
		{
			throw CLastErrorException();
		}

		if ( ERROR_ALREADY_EXISTS == GetLastError() )
			m_evt.Wait();
		else
			m_fInit = TRUE;

		LocalFree (psdAllAccess);
	}

	~CInitGate()
	{
		if ( m_fInit )
			m_evt.Set();
	}

	BOOL FInit() const { return m_fInit; }
};

#endif // !defined(_SYNCHRO_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\statcode.h ===
/*
 *	S T A T C O D E . H
 *
 *	DAV response status codes
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_STATCODE_H_
#define _STATCODE_H_

//	HTTP/1.1 Response Status Codes --------------------------------------------
//
#define	HSC_CONTINUE						100
#define	HSC_SWITCH_PROTOCOL					101
#define HSC_PROCESSING						102

#define	HSC_OK								200
#define	HSC_CREATED							201
#define	HSC_ACCEPTED						202
#define	HSC_NON_AUTHORITATIVE_INFO			203
#define	HSC_NO_CONTENT						204
#define	HSC_RESET_CONTENT					205
#define	HSC_PARTIAL_CONTENT					206
#define	HSC_MULTI_STATUS					207

#define HSC_SUBSCRIBED						241
#define HSC_SUBSCRIPTION_FAILED				242
#define HSC_NOTIFICATION_FAILED				243
#define HSC_NOTIFICATION_ACKNOWLEDGED		244
#define HSC_EVENTS_FOLLOW					245
#define HSC_NO_EVENTS_PENDING				246

#define	HSC_MULTIPLE_CHOICE					300
#define	HSC_MOVED_PERMANENTLY				301
#define	HSC_MOVED_TEMPORARILY				302
#define	HSC_SEE_OTHER						303
#define	HSC_NOT_MODIFIED					304
#define	HSC_USE_PROXY						305

#define	HSC_BAD_REQUEST						400
#define	HSC_UNAUTHORIZED					401
#define	HSC_PAYMENT_REQUIRED				402
#define	HSC_FORBIDDEN						403
#define	HSC_NOT_FOUND						404
#define	HSC_METHOD_NOT_ALLOWED				405
#define	HSC_NOT_ACCEPTABLE					406
#define	HSC_PROXY_AUTH_REQUIRED				407
#define	HSC_REQUEST_TIMEOUT					408
#define	HSC_CONFLICT						409
#define	HSC_GONE							410
#define	HSC_LENGTH_REQUIRED					411
#define	HSC_PRECONDITION_FAILED				412
#define	HSC_REQUEST_ENTITY_TOO_LARGE		413
#define	HSC_REQUEST_URI_TOO_LARGE			414
#define	HSC_UNSUPPORTED_MEDIA_TYPE			415
#define HSC_RANGE_NOT_SATISFIABLE			416
#define HSC_EXPECTATION_FAILED				417

#define HSC_UNPROCESSABLE					422
#define	HSC_LOCKED							423
#define HSC_METHOD_FAILURE					424

#define HSC_INCOMPLETE_DATA					437

#define	HSC_INTERNAL_SERVER_ERROR			500
#define	HSC_NOT_IMPLEMENTED					501
#define	HSC_BAD_GATEWAY						502
#define	HSC_SERVICE_UNAVAILABLE				503
#define	HSC_GATEWAY_TIMEOUT					504
#define	HSC_VERSION_NOT_SUPPORTED			505
#define	HSC_NO_PARTIAL_UPDATE				506
#define HSC_INSUFFICIENT_SPACE				507

#define HSC_SERVER_TOO_BUSY					513

//	Util macros ---------------------------------------------------------------
//
#define FSuccessHSC(_h)					((_h) < 300)
#define FFailedHSC(_h)					((_h) >= 300)
#define FRedirectHSC(_h)				(((_h) == 301) ||		\
										 ((_h) == 302) ||		\
										 ((_h) == 303) ||		\
										 ((_h) == 305))

#endif	// _STATCODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\spinlock.h ===
/*==========================================================================*\

    Module:        spinlock.h

    Copyright Microsoft Corporation 1996, All Rights Reserved.

    Author:        mikepurt

    Descriptions:  Implements a spin lock that can be used on Shared Memory

\*==========================================================================*/

#ifndef __SPINLOCK_H__
#define __SPINLOCK_H__

//
// This correct value of the spin count will depend heavily on how much time
//  is spent holding the lock.
//
const DWORD DEFAULT_SPIN_COUNT = 500; // ??
const DWORD SPIN_UNLOCKED      = 0;


/*$--CSpinLock==============================================================*\

\*==========================================================================*/

class CSpinLock
{
public:
    
    void  Initialize(IN DWORD cMaxSpin = DEFAULT_SPIN_COUNT);
    void  Acquire();
    void  Relinquish();
    void  ResetIfOwnedByOtherProcess();
    
private:
    BOOL  m_fMultiProc;
    DWORD m_cMaxSpin;
    
    volatile DWORD m_dwLock;
};



/*$--CSpinLock::Initialize==================================================*\

\*==========================================================================*/

inline
void
CSpinLock::Initialize(IN DWORD cMaxSpin)
{
    SYSTEM_INFO si;
    
    GetSystemInfo(&si);
    m_fMultiProc = (si.dwNumberOfProcessors > 1);
    
    m_dwLock     = SPIN_UNLOCKED;
    m_cMaxSpin   = cMaxSpin;
}


/*$--CSpinLock::Acquire=====================================================*\



\*==========================================================================*/

inline
void
CSpinLock::Acquire()
{
    DWORD cSpin       = m_cMaxSpin;
    DWORD dwLockId    = GetCurrentProcessId();



    while(InterlockedCompareExchange((LONG *)&m_dwLock,
                                     dwLockId,
                                     SPIN_UNLOCKED))
    {
        // We should only spin if we're running on a multiprocessor
        if (m_fMultiProc)
        {
            if (cSpin--)
                continue;
            cSpin = m_cMaxSpin;
        }
        Sleep(0);  // Deschedule ourselves and let whomever has the lock get out
    }
}



/*$--CSpinLock::Relinquish==================================================*\

\*==========================================================================*/

inline
void
CSpinLock::Relinquish()
{
    Assert(m_dwLock);
    
    m_dwLock = SPIN_UNLOCKED;
}



/*$--CSpinLock::ResetIfOwnedByOtherProcess==================================*\

  This method is needed to reset the spin lock in the case where it was being
  held by a process that died and didn't have a chance to relinquish it.

\*==========================================================================*/

inline
void
CSpinLock::ResetIfOwnedByOtherProcess()
{
    // If it's not locked by us, then reset it.
    if ((DWORD)m_dwLock != GetCurrentProcessId())
        m_dwLock = SPIN_UNLOCKED;
}


#endif // __SPINLOCK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\sz.h ===
/*
 *	S Z . H
 *
 *	Multi-language string support
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef _SZ_H_
#define _SZ_H_

#include <szsrc.h>
#include <statcode.h>

//	Impl Signature string ------------------------------------------------------
//	Provided by impl.  Used in various parser (_davprs) functions.
//	NOTE: This declaration is designed to match the signature in calrc.h.
//
extern const CHAR gc_szSignature[];		//	provided by impl.

//	Path Prefix ----------------------------------------------------------------
//	Provided by impl.  Used in default URI-to-Path translation code.
//
extern const WCHAR gc_wszPathPrefix[];
extern const int gc_cchPathPrefix;

//	String constants ----------------------------------------------------------
//	String constants live in \inc\ex\sz.h, so that they may be shared
//	with our Exchange components.
//
#include <ex\sz.h>

#endif	// _SZ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\thrdpool.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1997, Microsoft Corporation
//
//  File:        thrdpool.h
//
//  Contents:    definitions needed for clients of the thrdpool lib
//
//	Description: The thrdpool library defines the CWorkerThread base class
//				 Users of this lib should define their own derived class
//				 that inherits from CWorkerThread. Each CWorkerThread object
//				 has a thread that is used to do some work. It is also
//				 associated with a common completion port that is used to
//				 queue work items. All worker threads will normally block on
//				 GetQueuedCompletionStatus(). Clients of the CWorkerThread
//				 objects will call PostWork() to get work done. This will
//				 result in one of the worker threads returning from
//				 GetQueuedCompletionStatus() and calling the derived class'
//				 WorkCompletion() routine with a pvContext.
//
//				 NOTE: the base class has no knowledge of the type of work
//				 getting done. It just manages the details of getting work
//				 requests and distributing it to threads in its pool. This
//				 allows the derived class to focus on processing the actual
//				 work item without bothering about queueing etc.
//
//				 Completion ports are used merely to leverage its queueing
//				 semantics and not for I/O. If the work done by each thread
//				 is fairly small, LIFO semantics of completion ports will
//				 reduce context switches.
//
//  Functions:
//
//  History:     03/15/97     Rajeev Rajan (rajeevr)  Created
//				 11/11/97	  Adapted for DAV usage
//
//-----------------------------------------------------------------------------

#ifndef _THRDPOOL_H_
#define _THRDPOOL_H_

#include <autoptr.h>
#include <singlton.h>

//	CPoolManager --------------------------------------------------------------
//
class CDavWorkContext;
class CDavWorkerThread;
class CPoolManager : private Singleton<CPoolManager>
{
	//
	//	Friend declarations required by Singleton template
	//
	friend class Singleton<CPoolManager>;

private:

	//	Completion port for WorkerThreads
	//
	auto_handle<HANDLE> m_hCompletionPort;

	//	Array of worker threads
	//
	enum { CTHRD_WORKER = 5 };
	CDavWorkerThread *		m_rgpdwthrd[CTHRD_WORKER];

	//	CREATORS
	//
	//	Declared private to ensure that arbitrary instances
	//	of this class cannot be created.  The Singleton
	//	template (declared as a friend above) controls
	//	the sole instance of this class.
	//
	CPoolManager() {}
	~CPoolManager();

	BOOL FInitPool(DWORD dwConcurrency = CTHRD_WORKER);
	VOID TerminateWorkers();

	//	NOT IMPLEMENTED
	//
	CPoolManager(const CPoolManager& x);
	CPoolManager& operator=(const CPoolManager& x);

public:

	//	STATICS
	//
	static BOOL FInit()
	{
		if ( CreateInstance().FInitPool() )
			return TRUE;

		DestroyInstance();
		return FALSE;
	}

	static VOID Deinit()
	{
		DestroyInstance();
	}

	static BOOL PostWork (CDavWorkContext * pwc);

	static BOOL PostDelayedWork (CDavWorkContext * pwc,
								 DWORD dwMsecDelay);

	static HANDLE GetIOCPHandle()
	{
		return Instance().m_hCompletionPort.get();
	}
};

//	CDavWorkContext --------------------------------------------------------------
//
//	Work context base class for work items posted to the thread pool.
//
//	Note: this class is NOT refcounted.  Lifetime of work items is determined
//	external to the thread pool mechanism.  In particular, if a particular
//	derived work item class needs to have an indefinite lifetime, it is up
//	to the derived class to provide that functionality.  E.g. a derived work
//	item can have a refcount.  Code that posts the work item would then
//	add a reference before posting and release the reference (possibly destroying
//	the object if is the last ref) in its DwDoWork() call.
//
//	The reason for this is that not ALL work items may be refcounted.
//	In fact, some may be static....
//
class CDavWorkContext
{
private:

	//	NOT IMPLEMENTED
	//
	CDavWorkContext(const CDavWorkContext& x);
	CDavWorkContext& operator=(const CDavWorkContext& x);

	DWORD        m_cbTransferred;
	DWORD		 m_dwLastError;
	LPOVERLAPPED m_po;
public:

	CDavWorkContext() :
		m_cbTransferred(0),
		m_dwLastError(ERROR_SUCCESS),
		m_po(NULL)
	{
	}
	virtual ~CDavWorkContext() = 0;
	virtual DWORD DwDoWork () = 0;

	void SetCompletionStatusData(DWORD        cbTransferred,
								 DWORD		  dwLastError,
								 LPOVERLAPPED po)
	{
		m_cbTransferred = cbTransferred;
		m_dwLastError = dwLastError;
		m_po = po;
	}
	DWORD CbTransferred() const { return m_cbTransferred; }
	DWORD DwLastError() const { return m_dwLastError; }
	LPOVERLAPPED GetOverlapped() const { return m_po; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\url.h ===
/*
 *	U R L . H
 *
 *	Url normalization/canonicalization
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_URL_H_
#define _URL_H_

//	ACP Language vs. DBCS -----------------------------------------------------
//
//	ACP Language vs. DBCS -----------------------------------------------------
//
//	FIsSystemDBCS()
//
typedef enum {

	DBCS_UNKNOWN = 0,
	DBCS_NO,
	DBCS_YES

} LANG_DBCS;
DEC_GLOBAL LANG_DBCS gs_dbcs = DBCS_UNKNOWN;

inline BOOL
FIsSystemDBCS()
{
	if (DBCS_UNKNOWN == gs_dbcs)
	{
		UINT uPrimaryLangID = PRIMARYLANGID(GetSystemDefaultLangID());
		if ((uPrimaryLangID == LANG_JAPANESE) ||
			(uPrimaryLangID == LANG_CHINESE)  ||
			(uPrimaryLangID == LANG_KOREAN))
		{
			gs_dbcs = DBCS_YES;
		}
		else
			gs_dbcs = DBCS_NO;
	}

	return (DBCS_YES == gs_dbcs);
}

inline BOOL
FIsDBCSTrailingByte (const CHAR * pch, LONG cch)
{
	//	Checks to see if the previous byte of the pointed to character is
	//	a lead byte if and only if there is characters preceeding and the
	//	system is DBCS.
	//
	Assert (pch);
	return ((0 < cch) && FIsSystemDBCS() && IsDBCSLeadByte(*(pch - 1)));
}

inline BOOL
FIsDriveTrailingChar(const CHAR * pch, LONG cch)
{
	//	Checks if the character we are pointing at stands after the drive letter
	//
	Assert(pch);
	return ((2 < cch) && (':' == *(pch - 1)) &&
			((('a' <= *(pch - 2)) && ('z' >= *(pch - 2))) ||
			 (('A' <= *(pch - 2)) && ('Z' >= *(pch - 2)))));
}

inline BOOL
FIsDriveTrailingChar(const WCHAR * pwch, LONG cch)
{
	//	Checks if the character we are pointing at stands after the drive letter
	//
	Assert(pwch);
	return ((2 < cch) && (L':' == *(pwch - 1)) &&
			(((L'a' <= *(pwch - 2)) && (L'z' >= *(pwch - 2))) ||
			 ((L'A' <= *(pwch - 2)) && (L'Z' >= *(pwch - 2)))));
}

//	Processing ----------------------------------------------------------------
//
SCODE __fastcall
ScStripAndCheckHttpPrefix (
	/* [in] */ const IEcb& ecb,
	/* [in/out] */ LPCWSTR * ppwszRequest);

LPCWSTR __fastcall
PwszUrlStrippedOfPrefix (
	/* [in] */ LPCWSTR pwszUrl);

VOID __fastcall HttpUriEscape (
	/* [in] */ LPCSTR pszSrc,
	/* [out] */ auto_heap_ptr<CHAR>& pszDst);

VOID __fastcall HttpUriUnescape (
	/* [in] */ const LPCSTR pszUrl,
	/* [out] */ LPSTR pszUnescaped);

//	Path conflicts ------------------------------------------------------------
//
BOOL __fastcall FPathConflict (
	/* [in] */ LPCWSTR pwszSrc,
	/* [in] */ LPCWSTR pwszDst);

BOOL __fastcall FSizedPathConflict (
	/* [in] */ LPCWSTR pwszSrc,
	/* [in] */ UINT cchSrc,
	/* [in] */ LPCWSTR pwszDst,
	/* [in] */ UINT cchDst);

BOOL __fastcall FIsImmediateParentUrl (
	/* [in] */ LPCWSTR pwszParent,
	/* [in] */ LPCWSTR pwszChild);

SCODE __fastcall
ScConstructRedirectUrl (
	/* [in] */ const IEcb& ecb,
	/* [in] */ BOOL fNeedSlash,
	/* [out] */ LPSTR * ppszUrl,
	/* [in] */ LPCWSTR pwszServer = NULL);


#endif // _URL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\statetok.h ===
/*
 *	S T A T E T O K. H
 *
 *	Sources implementation of DAV-Lock common definitions.
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

/*
 *	This file contains the definitions used for parsing state token
 *	relared headers.
 *
 */

#ifndef __STATETOK_H__
#define __STATETOK_H__

//	Current max seconds = 1 day.
//
DEC_CONST INT	gc_cSecondsMaxLock = 60 * 60 * 24;

//	Current default lock time out is 3 minutes
//
DEC_CONST INT	gc_cSecondsDefaultLock = 60 * 3;

//$REVIEW	These flags are duplicated in lockmgr.h and statetok.h. before
//$REVIEW	this is addressed, to be safe, we make sure they match
//$REVIEW	Also inherit the excellent comments from the lockmgr.h regarding
//$REVIEW	how the flags should be defined when we merge.
#define DAV_LOCKTYPE_ROLLBACK			0x08000000
#define DAV_LOCKTYPE_CHECKOUT			0x04000000
#define DAV_LOCKTYPE_TRANSACTION_GOP	0x00100000
#define DAV_LOCKTYPE_READWRITE	(GENERIC_READ | GENERIC_WRITE)
#define DAV_LOCKTYPE_FLAGS		(GENERIC_READ | GENERIC_WRITE | DAV_LOCKTYPE_ROLLBACK | DAV_LOCKTYPE_CHECKOUT | DAV_LOCKTYPE_TRANSACTION_GOP)
#define DAV_EXCLUSIVE_LOCK		0x01000000
#define DAV_SHARED_LOCK			0x02000000
#define DAV_LOCKSCOPE_LOCAL		0x04000000
#define DAV_LOCKSCOPE_FLAGS		(DAV_EXCLUSIVE_LOCK | DAV_SHARED_LOCK | DAV_LOCKSCOPE_LOCAL)
#define DAV_RECURSIVE_LOCK		0x00800000
#define DAV_LOCK_FLAGS			(DAV_LOCKTYPE_FLAGS | DAV_RECURSIVE_LOCK | DAV_LOCKSCOPE_FLAGS)

/*
 -	IFITER
 -
 *
 *	This is the parser copied from the original IF header processor
 *	used in lockutil.cpp. Eventually lockutil.cpp shall use this
 *	file since this file shall have only the common stuff sharable
 *	between davex and davfs lock code.
 *
 *	Comment format change to the style used in this file otherwise.
 *
 *
 */
//	========================================================================
//
//	class IFITER
//
//		Built to parse the new If header.
//
//	Format of the If header
//		If = "If" ":" ( 1*No-tag-list | 1*Tagged-list)
//		No-tag-list = List
//		Tagged-list = Resource 1*List
//		Resource = Coded-url
//		List = "(" 1*(["Not"](State-token | "[" entity-tag "]")) ")"
//		State-token = Coded-url
//		Coded-url = "<" URI ">"
//
//
//		NOTE: We are going to be lax about tagged/untagged lists.
//		If the first list is not tagged, but we find tagged lists later,
//		that's cool by me.
//		(Realize that there no problem switching from tagged to untagged --
//		because that case cannot be detected & distinguished from another
//		list for the same URI!  The only problem is if the first list is
//		untagged, and later there are tagged lists.  That is a case that
//		*should*, by a perfectly tight reading of the spec, be a bad request.
//		I am treating it as perfectly valid until someone tells me that I have
//		to do the extra 1 bit of bookkeeping.)
//
//	State machine for this class
//		It's a really simple state machine.
//		(NOTE that I'm calling statetokens and etags "tokens", and the
//		contents of a single set of parentheses a "list", just like above.)
//
//		Three possible states: NONE, NAME, and LIST.
//		Starts in state NONE -- can accept a tag (URI) or a start of a list.
//		Moves to NAME if a tag (URI) is encountered.
//		Only a list can follow a tag (URI).
//		Moves to LIST when a list start (left paren) is encountered.
//		Moves back to NONE when a list end (right paren) is encountered.
//

//	------------------------------------------------------------------------
//	enum FETCH_TOKEN_TYPE
//		These are the flags used in IFITER::PszNextToken.
//		There are two basic types of fetching:
//		o	advance to next item of this type (xxx_NEW_xxx)
//		o	fetch the next item & fail if the type does not match.
//
enum FETCH_TOKEN_TYPE
{
	TOKEN_URI,			// Fetch a URI, don't skip anything.
	TOKEN_NEW_URI,		// Advance to the next URI, skipping stuff in between.
	TOKEN_START_LIST,	// Fetch the next list item.  Must be the starting list item.
	TOKEN_SAME_LIST,	// Fetch the next internal item in this list.
	TOKEN_NEW_LIST,		// Advance to the next start of a list, skipping past the
						//	end of the current list if necessary.  Don't skip uris.
	TOKEN_ANY_LIST,		// NTRaid#244243 -- special for looking up locktokens
						//	Fetch the next item for this same uri -- can cross lists,
						//	but not uris.
	TOKEN_NONE,			// Empty marker.
};

class IFITER
{
private:

	enum STATE_TYPE
	{
		STATE_NONE,
		STATE_NAME,
		STATE_LIST,
	};

	const LPCWSTR		m_pwszHdr;
	LPCWSTR				m_pwch;
	StringBuffer<WCHAR>	m_buf;
	//	State bits
	STATE_TYPE			m_state;
	BOOL				m_fCurrentNot;

	//  NOT IMPLEMENTED
	//
	IFITER& operator=( const IFITER& );
	IFITER( const IFITER& );

public:

	IFITER (LPCWSTR pwsz=0) :
			m_pwszHdr(pwsz),
			m_pwch(pwsz),
			m_state(STATE_NONE),
			m_fCurrentNot(FALSE)
	{
	}
	~IFITER() {}


	LPCWSTR PszNextToken (FETCH_TOKEN_TYPE type);
	BOOL FCurrentNot() const
	{
		return m_fCurrentNot;
	}
	void Restart()
	{
		m_pwch = m_pwszHdr; m_state = STATE_NONE;
	}
};

/*
 -	PwszSkipCodes
 -
 *	Remove <> or [] tags around stuff. Useful for if: header
 *	tags. also eliminates the LWS near to the delimiters.
 *
 *	*pdwLen may be zero or the length of the string. If zero
 *	the routine calculate the length using strlen. Wasteful,
 *	if you already know the length.
 *
 *	Returns the pointer to the first non-lws, non-delimiter.
 *	dwLen shall be set to the actual number of chars, from the
 *	first to the last char which is non-lws, non-delimiter when
 *	we start looking from the end. Does not stick the null char
 *	at the end. Do it yourself, if you need to, using dwLen.
 *
 */

LPCWSTR  PwszSkipCodes(IN LPCWSTR pwszTagged, IN OUT DWORD *pdwLen);


/*
 -	CStateToken
 -
 *	The state token is the lean string that we use to communicate
 *	with the client. It is the external representation of a DAV lock
 *	or any other kind of state information.
 *
 *	State token is a quoted uri which is <uri> for the external world.
 *	So we provide facilities to deal with this in this class. The < and
 *	> are not useful for internal processing - so we hide this to our
 *	customers - this will avoid copying to prepend the <.
 *
 *	E-TAGs are special beasts and are just plain quoted strings surrounded
 *	by [ and ].
 *
 */

class CStateToken
{
	
public:
	
	//	Common defintions which are public, also used privately!
	//
	typedef enum StateTokenType
	{
		TOKEN_NONE = 0,
		TOKEN_LOCK,
		TOKEN_TRANS,
		TOKEN_ETAG,
		TOKEN_RESTAG,
					  
	} STATE_TOKEN_TYPE;

	//	normally state tokens are about of this size
	//	ie lock tokens.
	//
	enum { NORMAL_STATE_TOKEN_SIZE = 128 };

private:
	
	//	Token buffer
	//
	LPWSTR m_pwszToken;

	//	Allocated size of the current buffer.
	//
	DWORD m_cchBuf;

	//	type of the token
	//
	STATE_TOKEN_TYPE m_tType;
	
	//	Never implemented
	//
	CStateToken( const CStateToken& );
	CStateToken& operator=( const CStateToken& );
	
public:

	CStateToken() : m_pwszToken(NULL), m_cchBuf(0), m_tType(TOKEN_NONE)
    {
    };

	~CStateToken()
    {
        if (NULL != m_pwszToken)
            ExFree(m_pwszToken);
    }

	//	Plain token accepted here.
	//	If the dwLen is zero, NULL terminated pszToken
	//	is the token. If non zero, it gives actual
	//	number of chars in the token.
	//	Useful when we parse the if: header.
	//
	BOOL FSetToken(LPCWSTR pwszToken, BOOL fEtag, DWORD dwLen = 0);
			
	//	Accessors to the token info
	//
	inline STATE_TOKEN_TYPE	GetTokenType() const { return m_tType; }

	//	TRUE if the lock tokens are equal.
	//
	BOOL FIsEqual(CStateToken *pstokRhs);

	//	get a pointer to the token string
	//
	inline LPCWSTR WszGetToken() const { return m_pwszToken; }

	//	Parses the state token as a lock token and
	//	get the lock token information.. Note that our lock
	//	tokens consist of a GUIID and a long long(int64).
	//	The guid string must be long enough to hold a GUID
	//	string (37 chars).
	//
	BOOL FGetLockTokenInfo(unsigned __int64 *pi64SeqNum, LPWSTR	pwszGuid);
};


/*
 -	CStateMatchOp
 -
 *	This class is used as the base class for doing
 *	state  match operations including e-tag
 *	checks. Each implementation shall derive its own
 *	ways to check the state of the resource. This way
 *	the core parse code is shared between subsystems.
 *
 *	Not multi-thread safe - create,use and delete in a
 *	single thread.
 *
 */

class CStateMatchOp
{
private:

	//	NOT IMPLEMENTED
	//
	CStateMatchOp( const CStateMatchOp& );
	CStateMatchOp& operator=( const CStateMatchOp& );

protected:

	//	Current token under investigation.
	//	All derived classes can access it.
	//	We do not pass this as the parameter.
	//
	CStateToken	m_tokCurrent;

	friend class CIfHeadParser;
	
	//	---------------------------------------------------------
	//	support API for the ifheader parser
	//	set the current token
	//
	inline BOOL FSetToken(LPCWSTR pwszToken, BOOL fEtag)
	{
		return m_tokCurrent.FSetToken(pwszToken, fEtag);
	}
	//	get the current token type
	//
	inline CStateToken::STATE_TOKEN_TYPE GetTokenType() const
	{
		return m_tokCurrent.GetTokenType();
	}
	//	return the storage path of the uri. Note that davex and davfs
	//	has different implementations of this.
	//
	virtual SCODE ScGetResourcePath(LPCWSTR pwszUri, LPCWSTR * ppwszStoragePath) = 0;

	//	check if the resource is locked by the lock specified
	//	by the current lock token above. fRecusrive says if the
	//	condition is to be applied to all the resources under the
	//	given path. Believe me, lpwszPath can be NULL. And it is
	//	NULL when the match condition is to be applied on the
	//	first path given to HrApplyIf!. Why we do this: normally
	//	we do lotsa processing on the method's resource before
	//	we call the if-header parser. This processing generates
	//	info like e-tags which can be used to do the state match
	//	check here. So the parser needs to tell the match checker
	//	that this is for the original uri and NULL is the indication
	//	of that.
	//
	virtual SCODE ScMatchLockToken(LPCWSTR pwszPath, BOOL fRecursive) = 0;
	virtual SCODE ScMatchResTag(LPCWSTR pwszPath) = 0;
	virtual SCODE ScMatchTransactionToken(LPCWSTR pwszPath) = 0;

	//	Checks if the resource is in the state specified by the
	//	(e-tag) state token above. Parameters have same meaning as above.
	//
	virtual SCODE ScMatchETag(LPCWSTR pwszPath, BOOL fRecursive) = 0;
	//	-----------------------------------------------------------

public:

	//	Usual suspects of CTOR and DTOR
	//
	CStateMatchOp() { };

	~CStateMatchOp() { };

	//	Using this object as the match operator parse an if header.
	//	This is used by all method impls.
	//
	SCODE ScParseIf(LPCWSTR pwszIfHeader, LPCWSTR rgpwszPaths[], DWORD cPaths, BOOL fRecur, SCODE * pSC);
};

/*
 -	FCompareSids
 -
 *	compare two sids
 *
 */
inline BOOL FCompareSids(PSID pSidLeft, PSID pSidRight)
{
	if ((NULL == pSidLeft) || (NULL == pSidRight))
		return FALSE;

	//	Assert the SID validity.
	//
	Assert(IsValidSid(pSidLeft));
	Assert(IsValidSid(pSidRight));

	return EqualSid(pSidLeft, pSidRight);
}

/*
 -	FSeparator
 -
 *  returns true if input is a path separator - used below
 *
 */

inline BOOL FSeparator(WCHAR wch)
{
   return ((wch == L'\\') || (wch == L'/'));
}

/*
 -	FIsChildPath
 -
 *	compare two paths to check if the child is within the scope
 *	of the parent.
 *
 *	For non recursive match, the two paths must match exactly for
 *	TRUE return. This is useful when tagged URIs within the IF header
 *	is processed and we have a deep operation going on. The other place
 *	this function is used is when we have a recursive lock and need to
 *	find out if a path is locked by this lock.
 *
 */
inline BOOL FIsChildPath(LPCWSTR pwszPathParent, LPCWSTR pwszPathChild, BOOL fRecursive)
{
	UINT	cchParentLen;

	if ((NULL == pwszPathParent) || (NULL == pwszPathChild))
		return FALSE;

	cchParentLen = static_cast<UINT>(wcslen(pwszPathParent));

	//	If the parent path is not an initial substring
	//	of child return fail immediately.
	//
	if ( 0 != _wcsnicmp(pwszPathChild, pwszPathParent, cchParentLen) )
	{
		return FALSE;
	}

	//	Parent indeed is the initial substring.
	//	Check the next char of child (for NULL) to see
	//	if they	match exactly. This is an instand good condition.
	//
	if (L'\0' == pwszPathChild[cchParentLen])
	{
		return TRUE;
	}
	//	We still have hope for a match ONLY for recursive checks.
	//
	if (! fRecursive)
	{
		return FALSE;
	}
	else
	{
		//	either parent or child need to have a separator
		//
		if ( FSeparator(pwszPathParent[cchParentLen-1]) ||
			 FSeparator(pwszPathChild[cchParentLen]) )
			 return TRUE;
		else
			 return FALSE;
	}
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\xatom.h ===
/*
 *	X A T O M . H
 *
 *	XML atom cache
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_XATOM_H_
#define _XATOM_H_

#include <ex\atomcache.h>

#endif	// _XATOM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\util.h ===
/*
 *	U T I L . H
 *
 *	Common DAV utilities
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef _UTIL_H_
#define _UTIL_H_

#include <autoptr.h>
#include <buffer.h>
#include <davimpl.h>
#include <ex\hdriter.h>

//	Function to generate a separator boundary for multipart responses.
//
VOID
GenerateBoundary(LPWSTR rgwchBoundary, UINT cch);

//	Alphabet allowed for multipart boundaries
const ULONG	gc_ulDefaultBoundarySz = 70;
const ULONG gc_ulAlphabetSz = 74;
const WCHAR gc_wszBoundaryAlphabet[] =
	L"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'()+_,-./:=?";
#endif // _UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\vrenum.h ===
/*
 *	V R E N U M . H
 *
 *	Vritual root enumeration
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_VRENUM_H_
#define _VRENUM_H_

#include <winsock2.h>

#include <crc.h>
#include <autoptr.h>
#include <buffer.h>
#include <davmb.h>
#include <gencache.h>
#include <cvroot.h>
#include <davimpl.h>
#include <singlton.h>

//	CChildVRCache ---------------------------------------------------------------
//
typedef CCache<CRCWsz, auto_ref_ptr<CVRoot> > CVRCache;

class CChildVRCache : public CAccInv,
					  private Singleton<CChildVRCache>
{
	//	Friend declarations required by Singleton template
	//
	friend class Singleton<CChildVRCache>;

	//	Cache
	//
	CVRCache m_cache;
	ChainedStringBuffer<WCHAR> m_sb;

	//	Server default values
	//
	enum { MAX_SERVER_NAME_LENGTH = 64 };
	WCHAR m_wszServerDefault[MAX_SERVER_NAME_LENGTH];
	UINT m_cchServerDefault;

	//	CAccInv access/modification methods
	//
	void RefreshOp(const IEcb& ecb);

	//	CFindChildren ---------------------------------------------------------
	//
	//	Functional classes to find all applicible child vroots
	//
	class CFindChildren : public CVRCache::IOp, public CAccInv::IAccCtx
	{
		CVRCache& m_cache;						//	Cache

		ChainedStringBuffer<WCHAR>& m_sb;		//	Return set of child
		CVRList& m_vrl;							//	virtual roots

		LPCWSTR m_pwsz;							//	Metadata path to find
		UINT m_cch;								//	children for

		//	NOT IMPLEMENTED
		//
		CFindChildren& operator=(const CFindChildren&);
		CFindChildren(const CFindChildren&);

	public:

		CFindChildren(CVRCache& cache,
					  LPCWSTR pwszMetaPath,
					  ChainedStringBuffer<WCHAR>& sb,
					  CVRList& vrl)
			: m_cache(cache),
			  m_sb(sb),
			  m_vrl(vrl),
			  m_pwsz(pwszMetaPath),
			  m_cch(static_cast<UINT>(wcslen(pwszMetaPath)))
		{
		}

		virtual BOOL operator()(const CRCWsz&, const auto_ref_ptr<CVRoot>&);
		virtual void AccessOp (CAccInv& cache)
		{
			m_cache.ForEach(*this);
		}

		BOOL FFound() const { return !m_vrl.empty(); }
	};

	//	CLookupChild ----------------------------------------------------------
	//
	//	Functional classes to find a given child vroot
	//
	class CLookupChild : public CAccInv::IAccCtx
	{
		CVRCache& m_cache;						//	Cache

		LPCWSTR m_pwsz;							//	Metadata path to lookup

		auto_ref_ptr<CVRoot>& m_cvr;			//	CVRoot for path

		//	NOT IMPLEMENTED
		//
		CLookupChild& operator=(const CLookupChild&);
		CLookupChild(const CLookupChild&);

	public:

		CLookupChild(CVRCache& cache,
					 LPCWSTR pwszMetaPath,
					 auto_ref_ptr<CVRoot>& cvr)
			: m_cache(cache),
			  m_pwsz(pwszMetaPath),
			  m_cvr(cvr)
		{
		}

		virtual void AccessOp (CAccInv& cache)
		{
			m_cache.FFetch(CRCWsz(m_pwsz), &m_cvr);
		}

		BOOL FFound() const { return m_cvr.get() != NULL; }
	};

	//	NOT IMPLEMENTED
	//
	CChildVRCache& operator=(const CChildVRCache&);
	CChildVRCache(const CChildVRCache&);

	//	Cache construction
	//
	SCODE ScCacheVroots (const IEcb& ecb);

	//	CONSTRUCTOR
	//
	//	Declared private to ensure that arbitrary instances
	//	of this class cannot be created.  The Singleton template
	//	(declared as a friend above) controls the sole instance
	//	of this class.
	//
	CChildVRCache()
	{
		CHAR rgchServerDefault[MAX_SERVER_NAME_LENGTH] = {0};
		UINT cbServerDefault;

		//	Call the WinSock api to learn our default host name
		//
		gethostname (rgchServerDefault, sizeof(rgchServerDefault));
		cbServerDefault = static_cast<UINT>(strlen(rgchServerDefault));

		//	It actually does not mater what codepage we will
		//	select for conversion. Server names are not allowed
		//	to contain funky characters.
		//
		m_cchServerDefault = MultiByteToWideChar(CP_ACP,
												 0,
												 rgchServerDefault,
												 cbServerDefault + 1,
												 m_wszServerDefault,
												 MAX_SERVER_NAME_LENGTH);

		//	There is no reason to fail and we would be converting at least
		//	termination character
		//
		Assert(1 <= m_cchServerDefault);
		m_cchServerDefault--;

		DebugTrace ("Dav: CVRoot: gethostname(): '%S'\n", m_wszServerDefault);

		//	If this fails, our allocators will throw for us.
		//
		(void) m_cache.FInit();
	}

public:

	//	Instance creating/destroying routines provided
	//	by the Singleton template.
	//
	using Singleton<CChildVRCache>::CreateInstance;
	using Singleton<CChildVRCache>::DestroyInstance;
	using Singleton<CChildVRCache>::Instance;

	//	Metabase notification methods
	//
	void OnNotify( DWORD dwElements,
				   MD_CHANGE_OBJECT_W pcoList[] );

	//	Access ----------------------------------------------------------------
	//
	static BOOL FFindVroot( const IEcb& ecb, LPCWSTR pwszMetaPath, auto_ref_ptr<CVRoot>& cvr )
	{
		CLookupChild clc(Instance().m_cache, pwszMetaPath, cvr);
		Instance().Access(ecb, clc);
		return clc.FFound();
	}

	static SCODE ScFindChildren( const IEcb& ecb,
								 LPCWSTR pwszMetaPath,
								 ChainedStringBuffer<WCHAR>& sb,
								 CVRList& vrl )
	{
		CFindChildren cfc(Instance().m_cache, pwszMetaPath, sb, vrl);
		Instance().Access(ecb, cfc);
		return cfc.FFound() ? S_FALSE : S_OK;
	}
};

#endif	// _VRENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\atomcache.h ===
/*
 *	A T O M C A C H E . H
 *
 *	atom cache
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_EX_ATOMCACHE_H_
#define _EX_ATOMCACHE_H_

#include <crc.h>
#include <crcsz.h>
#include <singlton.h>
#include <ex\buffer.h>
#include <ex\synchro.h>

class CXAtomCache : public OnDemandGlobal<CXAtomCache>
{
	//	Friend declarations required by Singleton template
	//
	friend class Singleton<CXAtomCache>;
	friend class RefCountedGlobal<CXAtomCache>;

	enum { CACHESIZE_START = 53 };

	//	Cache of atoms
	//
	typedef CCache<CRCWszN, LPCWSTR> CSzCache;
	CSzCache m_cache;
	CMRWLock m_lock;

	//	String data storage area.
	//
	ChainedStringBuffer<WCHAR> m_csb;

	//	GetCachedAtom()
	//
	SCODE ScGetCachedAtom (CRCWszN& key, LPCWSTR* pwszAtom);

	//	Declared private to ensure that arbitrary instances
	//	of this class cannot be created.  The Singleton
	//	template (declared as a friend above) controls
	//	the sole instance of this class.
	//
	CXAtomCache() : m_cache(CACHESIZE_START)
	{
	}

	//	Initialize lock and cache
	//
	BOOL FInit()
	{
		//	Initialize the MRWLock and the cache
		//
		return m_lock.FInitialize() && m_cache.FInit();
	}

	//	non-implmented
	//
	CXAtomCache& operator=(const CXAtomCache&);
	CXAtomCache(const CXAtomCache&);

public:

	using OnDemandGlobal<CXAtomCache>::FInitOnFirstUse;
	using OnDemandGlobal<CXAtomCache>::DeinitIfUsed;

	//	CacheAtom()
	//
	static SCODE ScCacheAtom (LPCWSTR* pwszAtom, UINT cch)
	{
		Assert (pwszAtom);
		Assert (*pwszAtom);

		if (!FInitOnFirstUse())
			return E_OUTOFMEMORY;

		//	Retrieve the string from the cache
		//
		CRCWszN key(*pwszAtom, cch);
		return Instance().ScGetCachedAtom (key, pwszAtom);
	}
};

#endif	// _EX_ATOMCACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\xmeta.h ===
/*
 *	X M E T A . H
 *
 *	XML push-model parsing for METADATA
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_XMETA_H_
#define _XMETA_H_

#include <xprs.h>

//	Parsers -------------------------------------------------------------------
//
//	METADATA ------------------------------------------------------------------
//
//	The metadata processing for DAV is all done via the PROPFIND and PROPPATCH
//	(and to some extent, SEARCH) methods.  In all of these cases, there is an
//	xml request that must be parsed to determine the state of type of request
//	being made.  Once known, the request is applied to the resource and/or its
//	children.  The response is generated and emitted back to the client.
//
//	In some cases, the client may ask for the operation to be carried out for
//	a resource and for each of its children.  In this scenario, we do not want
//	to reprocess the request for each resource, etc.
//
//	In an effort to make this code simple, and extendable to each individual
//	DAV implementation, the processing uses four classes:
//
//		a parsing class
//		a class describing the parsed context
//		a class that provides access to the properties
//		and a class that is used to generate the response
//
//	Both the parser and emitter classes are common across all DAV impls. While
//	the context and the property access are provided by the impl.
//

//	CFindContext/CPatchContext ------------------------------------------------
//
//	The context for a PROPFIND and a PROPGET are not expected to be the same,
//	and as such can be implemented as different objects.
//
class CFindContext
{
	//	non-implemented operators
	//
	CFindContext( const CFindContext& );
	CFindContext& operator=( const CFindContext& );

protected:

	typedef enum {

		FIND_NONE,
		FIND_SPECIFIC,
		FIND_ALL,
		FIND_NAMES,
		FIND_ALL_FULL,
		FIND_NAMES_FULL

	} FINDTYPE;
	FINDTYPE				m_ft;

public:

	CFindContext()
			: m_ft(FIND_NONE)
	{
	}
	virtual ~CFindContext() {}

	//	When the parser finds an item that the client wants returned,
	//	the item is added to the context via the following set context
	//	methods.  Each add is qualified by the resource on which the
	//	request is made. Some propfind requests support editing of the
	//	proplists: for example DAVEX implementation supports full-fidelity
	//	retrieval with certain properties added or deleted from the response
	//	that would have normally returned by the request. The BOOL flag is
	//	used to indicate whether the prop needs to be excluded.
	//
	virtual SCODE ScAddProp(LPCWSTR pwszPath, LPCWSTR pwszProp, BOOL fExcludeProp) = 0;

	//	defines for readability for the BOOL fExcludeProp param above.
	//
	enum {
		FIND_PROPLIST_INCLUDE = FALSE,
		FIND_PROPLIST_EXCLUDE = TRUE
	};

	virtual SCODE ScGetAllProps(LPCWSTR)
	{
		//	If we have already specified a find method, and the
		//	xml indicated another type was expected, then BTS
		//	(by the spec) this should consititute an error.
		//
		if (m_ft != FIND_NONE)
		{
			DebugTrace ("Dav: multiple PROPFIND types indicated\n");
			return E_DAV_PROPFIND_TYPE_UNEXPECTED;
		}
		m_ft = FIND_ALL;
		return S_OK;
	}
	virtual SCODE ScGetAllNames (LPCWSTR)
	{
		//	If we have already specified a find method, and the
		//	xml indicated another type was expected, then BTS
		//	(by the spec) this should consititute an error.
		//
		if (m_ft != FIND_NONE)
		{
			DebugTrace ("Dav: multiple PROPFIND types indicated\n");
			return E_DAV_PROPFIND_TYPE_UNEXPECTED;
		}
		m_ft = FIND_NAMES;
		return S_OK;
	}
	virtual SCODE ScGetFullFidelityProps ()
	{
		//	If we have full fidelity node (it is a child node of
		//	allprop or propname node) then we should allready
		//	be in the state of FIND_ALL or FIND_NAMES. Do not
		//	shift to full fidelity lookup, let the deriving classes
		//	decide if they need that.
		//
		Assert((FIND_ALL == m_ft) || (FIND_NAMES == m_ft));
		return S_OK;
	}

	//$REVIEW: Make the default behavior of the following methods
	//$REVIEW: to ignore the report tags. it's up to the impl which understands
	//$REVIEW: reports to overwrite these methods
	//
	virtual SCODE	ScEnumReport () { return S_OK; }
	virtual SCODE	ScSetReportName (ULONG ulLen, LPCWSTR pwszName)	{ return S_OK;	}
	virtual SCODE	ScSetReportLimit (ULONG ulLen, LPCWSTR pwszLimit) {	return S_OK; }
};

class CPatchContext
{
	//	non-implemented operators
	//
	CPatchContext( const CPatchContext& );
	CPatchContext& operator=( const CPatchContext& );

public:

	CPatchContext() {}
	virtual ~CPatchContext() {}

	//	When the parser finds an item that the client wants operated on,
	//	the item is added to the context via the following set context
	//	methods.  Each request is qualified by the resource on which the
	//	request is made.
	//
	virtual SCODE ScDeleteProp(LPCWSTR pwszPath, LPCWSTR pwszProp) = 0;
	virtual SCODE ScSetProp(LPCWSTR pwszPath,
							LPCWSTR pwszProp,
							auto_ref_ptr<CPropContext>& pPropCtx) = 0;

	//  If parser finds a resourcetype prop set request, we use this function
	//  to set correct behavior
	//
	virtual void SetCreateStructureddocument(void) {};
};

//	class CNFFind -------------------------------------------------------------
//
class CNFFind : public CNodeFactory
{

protected:

	//	The find context
	//
	CFindContext&				m_cfc;

	//	State tracking
	//
	typedef enum {

		ST_NODOC,
		ST_PROPFIND,
		ST_ALLPROP,
		ST_ALLNAMES,
		ST_PROPS,
		ST_INPROP,
		ST_ENUMREPORT,
		ST_INENUMREPORT,
		ST_ENUMLIMIT,
		ST_ALLPROPFULL,
		ST_ALLNAMESFULL,
		ST_ALLPROP_INCLUDE,
		ST_ALLPROP_INCLUDE_INPROP,
		ST_ALLPROP_EXCLUDE,
		ST_ALLPROP_EXCLUDE_INPROP

	} FIND_PARSE_STATE;
	FIND_PARSE_STATE			m_state;

private:

	//	non-implemented
	//
	CNFFind(const CNFFind& p);
	CNFFind& operator=(const CNFFind& p);

public:

	virtual ~CNFFind() {};
	CNFFind(CFindContext& cfc)
			: m_cfc(cfc),
			  m_state(ST_NODOC)
	{
	}

	//	CNodeFactory specific methods
	//
	virtual SCODE ScCompleteAttribute (void);

	virtual SCODE ScCompleteChildren (
		/* [in] */ BOOL fEmptyNode,
		/* [in] */ DWORD dwType,
		/* [in] */ const WCHAR __RPC_FAR *pwcText,
		/* [in] */ ULONG ulLen);

	virtual SCODE ScHandleNode (
		/* [in] */ DWORD dwType,
		/* [in] */ DWORD dwSubType,
		/* [in] */ BOOL fTerminal,
		/* [in] */ const WCHAR __RPC_FAR *pwcText,
		/* [in] */ ULONG ulLen,
		/* [in] */ ULONG ulNamespaceLen,
		/* [in] */ const WCHAR __RPC_FAR *pwcNamespace,
		/* [in] */ const ULONG ulNsPrefixLen);
};

//	class CNFFind -------------------------------------------------------------
//
class CNFPatch : public CNodeFactory
{

protected:

	//	The patch context
	//
	CPatchContext&				m_cpc;

	//	State tracking
	//
	typedef enum {

		ST_NODOC,
		ST_UPDATE,
		ST_SET,
		ST_DELETE,
		ST_PROPS,
		ST_INPROP,
		ST_INMVPROP,
		ST_SEARCHREQUEST,
		ST_RESOURCETYPE,
		ST_STRUCTUREDDOCUMENT,
		ST_LEXTYPE,
		ST_FLAGS

	} PATCH_PARSE_STATE;
	PATCH_PARSE_STATE			m_state;

	//	XML value echoing to m_xo object
	//
	typedef enum {

		VE_NOECHO,
		VE_NEEDNS,
		VE_INPROGRESS

	} PATCH_VALUE_ECHO;
	PATCH_VALUE_ECHO			m_vestate;

	//	Check if an element we are setting
	//	if an XML valued property
	//
	BOOL	FValueIsXML( const WCHAR *pwcTag );

private:

	//	Current property context
	//
	//	Property context is only used in property set and it is NULL
	//	when the prop to set is a reserved property
	//
	PATCH_PARSE_STATE			m_sType;
	auto_ref_ptr<CPropContext>	m_ppctx;

	//	Values for properties (and attributes) can be
	//	composed of mulitple items in the XML document
	//	and thus need to be stored until they are complete
	//	and can be handed off to the context
	//
	StringBuffer<WCHAR>			m_sbValue;
	UINT						m_cmvValues;

	CXMLOut						m_xo;

	SCODE ScHandleElementNode (
		/* [in] */ DWORD dwType,
		/* [in] */ DWORD dwSubType,
		/* [in] */ BOOL fTerminal,
		/* [in] */ const WCHAR __RPC_FAR *pwcText,
		/* [in] */ ULONG ulLen,
		/* [in] */ ULONG ulNamespaceLen,
		/* [in] */ const WCHAR __RPC_FAR *pwcNamespace,
		/* [in] */ const ULONG ulNsPrefixLen);

	//	non-implemented
	//
	CNFPatch(const CNFPatch& p);
	CNFPatch& operator=(const CNFPatch& p);

public:

	virtual ~CNFPatch() {};
	CNFPatch(CPatchContext& cpc)
			: m_cpc(cpc),
			  m_state(ST_NODOC),
			  m_vestate(VE_NOECHO),
			  m_cmvValues(0),
			  m_xo(m_sbValue)
	{
	}

	//	CNodeFactory specific methods
	//
	virtual SCODE ScCompleteAttribute (void);

	virtual SCODE ScCompleteChildren (
		/* [in] */ BOOL fEmptyNode,
		/* [in] */ DWORD dwType,
		/* [in] */ const WCHAR __RPC_FAR *pwcText,
		/* [in] */ ULONG ulLen);

	virtual SCODE ScHandleNode (
		/* [in] */ DWORD dwType,
		/* [in] */ DWORD dwSubType,
		/* [in] */ BOOL fTerminal,
		/* [in] */ const WCHAR __RPC_FAR *pwcText,
		/* [in] */ ULONG ulLen,
		/* [in] */ ULONG ulNamespaceLen,
		/* [in] */ const WCHAR __RPC_FAR *pwcNamespace,
		/* [in] */ const ULONG ulNsPrefixLen);

	virtual SCODE ScCompleteCreateNode (
		/* [in] */ DWORD dwType);
};

#endif	// _XMETA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\xsearch.h ===
/*
 *	X S E A R C H . H
 *
 *	XML push-model parsing for METADATA
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_XSEARCH_H_
#define _XSEARCH_H_

#include <xprs.h>

//	Debugging -----------------------------------------------------------------
//
DEFINE_TRACE(Search);
#define SearchTrace		DO_TRACE(Search)

//	Ranges --------------------------------------------------------------------
//
#include <ex\rgiter.h>

//	CSearchContext ------------------------------------------------------------
//
class CSearchContext
{
	//	non-implemented operators
	//
	CSearchContext( const CSearchContext& );
	CSearchContext& operator=( const CSearchContext& );

public:

	virtual ~CSearchContext() {}
	CSearchContext ()
	{
		INIT_TRACE(Search);
	}

	//	When the parser finds an item that applies to the search, a call is
	//	made such that the context is informed of the desired search.
	//
	virtual SCODE ScSetSQL(CParseNmspcCache * pnsc, LPCWSTR pwszSQL) = 0;

	//	REPL Search interface -------------------------------------------------
	//
	//	Default implementation fails on these items.  All impls that support
	//	this type of search must implement....
	//
	virtual SCODE ScSetCollBlob (LPCWSTR pwszBlob)
	{
		return E_DAV_UNEXPECTED_TYPE;
	}
	virtual SCODE ScSetResTagAdds (LPCWSTR pwszResTagAdd)
	{
		return E_DAV_UNEXPECTED_TYPE;
	}
	virtual SCODE ScSetReplRequest (BOOL fReplRequest)
	{
		return E_DAV_UNEXPECTED_TYPE;
	}

	//	Range Search interface ------------------------------------------------
	//
	//	Default impl. fails for these items.  All impls that support this type
	//	of search must implement....
	//
	virtual SCODE ScAddRange (UINT uRT, LPCWSTR pwszRange, LONG lCount)
	{
		return E_DAV_UNEXPECTED_TYPE;
	}

	//	'GROUP BY' Expansion --------------------------------------------------
	//
	//	Default impl. fails for these items.  All impls that support this type
	//	of search must implement....
	//
	virtual SCODE ScSetExpansion (DWORD dwExpansion)
	{
		return E_DAV_UNEXPECTED_TYPE;
	}
};

//	class CNFSearch -------------------------------------------------------------
//
class CNFSearch : public CNodeFactory
{
	//	The search context
	//
	CSearchContext&				m_csc;

	//	State tracking
	//
	typedef enum {

		ST_NODOC,
		ST_SEARCH,
		ST_QUERY,
		ST_QUERYENTITY,

		//	REPL (DAV Replication) XML nodes
		//
		ST_REPL,
		ST_REPLCOLLBLOB,
		ST_REPLRESTAGLIST,
		ST_REPLRESTAGADD,

		//	Range XML nodes
		//
		ST_RANGE,
		ST_RANGE_TYPE,
		ST_RANGE_ROWS,

		//	Group Expansion
		//
		ST_GROUP_EXPANSION,

	} SEARCH_PARSE_STATE;
	SEARCH_PARSE_STATE			m_state;

	//	Value buffer
	//
	StringBuffer<WCHAR>			m_sb;

	//	Range items
	//
	UINT						m_uRT;
	LONG						m_lcRows;

	//	non-implemented
	//
	CNFSearch(const CNFSearch& p);
	CNFSearch& operator=(const CNFSearch& p);

public:

	virtual ~CNFSearch() {};
	CNFSearch(CSearchContext& csc)
			: m_csc(csc),
			  m_state(ST_NODOC),
			  m_uRT(RANGE_UNKNOWN),
			  m_lcRows(0)
	{
	}

	//	CNodeFactory specific methods
	//
	virtual SCODE ScCompleteAttribute (void);

	virtual SCODE ScCompleteChildren (
		/* [in] */ BOOL fEmptyNode,
		/* [in] */ DWORD dwType,
		/* [in] */ const WCHAR __RPC_FAR *pwcText,
		/* [in] */ ULONG ulLen);

	virtual SCODE ScHandleNode (
		/* [in] */ DWORD dwType,
		/* [in] */ DWORD dwSubType,
		/* [in] */ BOOL fTerminal,
		/* [in] */ const WCHAR __RPC_FAR *pwcText,
		/* [in] */ ULONG ulLen,
		/* [in] */ ULONG ulNamespaceLen,
		/* [in] */ const WCHAR __RPC_FAR *pwcNamespace,
		/* [in] */ const ULONG ulNsPrefixLen);
};

#include <replpropshack.h>

#endif	// _XSEARCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\xprs.h ===
/*
 *	X P R S . H
 *
 *	XML push-model parsing
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_XPRS_H_
#define _XPRS_H_

#include <ex\xprs.h>

//	class CXMLOut -------------------------------------------------------------
//
//	Contstruction of XML text from parsed input
//
class CXMLOut
{
	StringBuffer<WCHAR>&	m_sb;
	BOOL					m_fElementNeedsClosing;

	UINT					m_lDepth;
	BOOL					m_fAddNamespaceDecl;
	
	VOID CloseElementDecl (
		/* [in] */ BOOL fEmptyNode);

	//	non-implemented
	//
	CXMLOut(const CXMLOut& p);
	CXMLOut& operator=(const CXMLOut& p);

public:

	CXMLOut(StringBuffer<WCHAR>& sb)
			: m_sb(sb),
			  m_fElementNeedsClosing(FALSE),
			  m_fAddNamespaceDecl(FALSE),
			  m_lDepth(0)
	{
	}

	VOID EndAttributesOut (
		/* [in] */ DWORD dwType);

	VOID EndChildrenOut (
		/* [in] */ BOOL fEmptyNode,
		/* [in] */ DWORD dwType,
		/* [in] */ const WCHAR __RPC_FAR *pwcText,
		/* [in] */ ULONG ulLen);

	VOID CreateNodeAttrOut (
		/* [in] */ const WCHAR __RPC_FAR *pwszAttr,
		/* [in] */ const WCHAR __RPC_FAR *pwcText,
		/* [in] */ ULONG ulLen);

	VOID CreateNodeOut(
		/* [in] */ DWORD dwType,
		/* [in] */ BOOL fTerminal,
		/* [in] */ const WCHAR __RPC_FAR *pwcText,
		/* [in] */ ULONG ulLen);

	BOOL FAddNamespaceDecl() const { return m_fAddNamespaceDecl; }
	UINT LDepth() const { return m_lDepth; }

	//	When CompleteAttribute here, we have started processing
	//	the out node attributes and all cached namespaces have
	//	been added.
	//
	VOID CompleteAttribute() {m_fAddNamespaceDecl = TRUE; }

	VOID CompleteCreateNode (/* [in] */ DWORD dwType)
	{
		EndAttributesOut (dwType);
	}

	SCODE ScCompleteChildren (
		/* [in] */ BOOL fEmptyNode,
		/* [in] */ DWORD dwType,
		/* [in] */ const WCHAR __RPC_FAR *pwcText,
		/* [in] */ ULONG ulLen);

	SCODE ScHandleNode (
		/* [in] */ DWORD dwType,
		/* [in] */ DWORD dwSubType,
		/* [in] */ BOOL fTerminal,
		/* [in] */ const WCHAR __RPC_FAR *pwcText,
		/* [in] */ ULONG ulLen,
		/* [in] */ ULONG ulNamespaceLen,
		/* [in] */ const WCHAR __RPC_FAR *pwcNamespace,
		/* [in] */ const ULONG ulNsPrefixLen);		
};

//	Namespace emitting ----------------------------------------------------
//
class CEmitNmspc : public CNmspcCache::NmspcCache::IOp
{
	CXMLOut&		m_xo;

	//	non-implemented
	//
	CEmitNmspc(const CEmitNmspc& c);
	CEmitNmspc& operator=(const CEmitNmspc&);

public:

	CEmitNmspc(CXMLOut& xo) :
			m_xo(xo)
	{
	}

	virtual BOOL operator()(const CRCWszN&, const auto_ref_ptr<CNmspc>& pns);
};

#endif	// _XPRS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\xlock.h ===
/*
 *	X L O C K . H
 *
 *	XML push-model parsing for the LOCK method
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_XLOCK_H_
#define _XLOCK_H_

#include <buffer.h>
#include <xprs.h>

extern const WCHAR gc_wszLockActive[];
extern const WCHAR gc_wszLockDepth[];
extern const WCHAR gc_wszLockDiscovery[];
extern const WCHAR gc_wszLockEntry[];
extern const WCHAR gc_wszLockInfo[];
extern const WCHAR gc_wszLockOwner[];
extern const WCHAR gc_wszLockScope[];
extern const WCHAR gc_wszLockScopeExclusive[];
extern const WCHAR gc_wszLockScopeShared[];
extern const WCHAR gc_wszLockSupportedlock[];
extern const WCHAR gc_wszLockTimeout[];
extern const WCHAR gc_wszLockToken[];
extern const WCHAR gc_wszLockType[];
extern const WCHAR gc_wszLockTypeWrite[];
extern const WCHAR gc_wszLockTypeCheckout[];
extern const WCHAR gc_wszLockTypeTransaction[];
extern const WCHAR gc_wszLockTypeTransactionGOP[];
extern const WCHAR gc_wszLockScopeLocal[];

extern const WCHAR gc_wszLockRollback[];

//	class CNFLock -------------------------------------------------------------
//
class CNFLock : public CNodeFactory
{
	//	Parsed bits
	//
	DWORD				m_dwLockType;
	DWORD				m_dwScope;
	DWORD				m_dwRollback;

	//	Lock owner
	//
	UINT				m_lOwnerDepth;
	BOOL				m_fAddNamespaceDecl;
	StringBuffer<WCHAR> m_sbOwner;
	CXMLOut				m_xo;

	//	State tracking
	//
	typedef enum {

		ST_NODOC,
		ST_LOCKINFO,
		ST_OWNER,
		ST_TYPE,
		ST_SCOPE,
		ST_ROLLBACK,
		ST_INTYPE,
		ST_INSCOPE,
		ST_INTYPE_TRANS,
	} LOCK_PARSE_STATE;
	LOCK_PARSE_STATE m_state;

	//	non-implemented
	//
	CNFLock(const CNFLock& p);
	CNFLock& operator=(const CNFLock& p);

public:

	virtual ~CNFLock() {};
	CNFLock() :
			m_dwLockType(0),
			m_dwScope(0),
			m_dwRollback(0),
			m_lOwnerDepth(0),
			m_fAddNamespaceDecl(FALSE),
			m_xo(m_sbOwner),
			m_state(ST_NODOC)
	{
	}

	//	CNodeFactory specific methods
	//
	virtual SCODE ScCompleteAttribute (void);

	virtual SCODE ScCompleteChildren (
		/* [in] */ BOOL fEmptyNode,
		/* [in] */ DWORD dwType,
		/* [in] */ const WCHAR __RPC_FAR *pwcText,
		/* [in] */ ULONG ulLen);

	virtual SCODE ScHandleNode (
		/* [in] */ DWORD dwType,
		/* [in] */ DWORD dwSubType,
		/* [in] */ BOOL fTerminal,
		/* [in] */ const WCHAR __RPC_FAR *pwcText,
		/* [in] */ ULONG ulLen,
		/* [in] */ ULONG ulNamespaceLen,
		/* [in] */ const WCHAR __RPC_FAR *pwcNamespace,
		/* [in] */ const ULONG ulNsPrefixLen);

	virtual SCODE ScCompleteCreateNode (
		/* [in] */ DWORD dwType);

	//	LockMgr Accessors
	//
	DWORD DwGetLockType() const		{ return m_dwLockType; }
	DWORD DwGetLockScope() const	{ return m_dwScope; }
	DWORD DwGetLockRollback() const { return m_dwRollback; }
	DWORD DwGetLockFlags() const
	{
		return m_dwLockType |
				m_dwRollback |
				m_dwScope;
	}

	//	Owner data access
	//
	LPCWSTR PwszLockOwner() const
	{
		return m_sbOwner.CbSize()
				? m_sbOwner.PContents()
				: NULL;
	}
};

//	class CNFUnlock -------------------------------------------------------------
//
class CNFUnlock : public CNodeFactory
{
	auto_heap_ptr<WCHAR> m_wszComment;
	BOOL				m_fCancelCheckout;
	BOOL				m_fAbortTransaction;
	BOOL				m_fCommitTransaction;

	//	State tracking
	//
	typedef enum {

		ST_NODOC,
		ST_UNLOCKINFO,
		ST_COMMENT,
		ST_CANCELCHECKOUT,
		ST_TRANSACTIONINFO,
		ST_TRANSACTIONSTATUS,
		ST_TRANSACTIONSTATUS_COMMIT,
		ST_TRANSACTIONSTATUS_ABORT
	} LOCK_PARSE_STATE;
	
	LOCK_PARSE_STATE m_state;

	//	non-implemented
	//
	CNFUnlock(const CNFUnlock& p);
	CNFUnlock& operator=(const CNFUnlock& p);

public:

	virtual ~CNFUnlock() {};
	CNFUnlock() :
			m_fCancelCheckout(FALSE),
			m_state(ST_NODOC),
			m_fAbortTransaction(FALSE),
			m_fCommitTransaction(FALSE)
	{
	}

	//	CNodeFactory specific methods
	//
	virtual SCODE ScCompleteAttribute (void);

	virtual SCODE ScCompleteChildren (
		/* [in] */ BOOL fEmptyNode,
		/* [in] */ DWORD dwType,
		/* [in] */ const WCHAR __RPC_FAR *pwcText,
		/* [in] */ ULONG ulLen);

	virtual SCODE ScHandleNode (
		/* [in] */ DWORD dwType,
		/* [in] */ DWORD dwSubType,
		/* [in] */ BOOL fTerminal,
		/* [in] */ const WCHAR __RPC_FAR *pwcText,
		/* [in] */ ULONG ulLen,
		/* [in] */ ULONG ulNamespaceLen,
		/* [in] */ const WCHAR __RPC_FAR *pwcNamespace,
		/* [in] */ const ULONG ulNsPrefixLen);

	// Accessors
	//
	BOOL 	FCancelCheckout() const { return m_fCancelCheckout; }
	LPCWSTR PwszUnlockComment() const { return m_wszComment.get(); }
	BOOL	FAbortTransaction() const { return m_fAbortTransaction; }
	BOOL	FCommitTransaction() const { return m_fCommitTransaction; }
};

#endif	// _XLOCK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\xemit.h ===
/*
 *	X E M I T . H
 *
 *	XML emitting
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_XEMIT_H_
#define _XEMIT_H_

#include <ex\xemit.h>

#include <cvroot.h>
#include <davimpl.h>

//	CXMLEmitter helper functions ----------------------------------------------
//
SCODE ScGetPropNode (
	/* [in] */ CEmitterNode& enItem,
	/* [in] */ ULONG hsc,
	/* [out] */ CEmitterNode& enPropStat,
	/* [out] */ CEmitterNode& enProp);

//	CXNode helper functions ---------------------------------------------------
//
SCODE ScSetEscapedValue (CXNode* pxn, LPCWSTR pwszValue, UINT cch, BOOL fHandleStoraePathEscaping);

SCODE ScEmitRawStoragePathValue (CXNode* pxn, LPCWSTR pcwsz, UINT cch);

//	This wrapper is used to output the HREF props in XML. It assumes that the HREF properties are in
//	the impl's storage path escaped form and calls into the impl defined storage path unescaping
//	routine before doing the http-uri-escape call.
//
//	$WARNING: pwszValue is assumed to the in the storage path escaped form (as in Exchange store escaped
//	$WARNING: form). If not use the above helper to emit the property. Note that this makes a difference
//	$WARNING: only for DAVEx. HTTPEXT and EXPROX have do-nothing storage path escape/unescape callouts.
//
inline SCODE ScSetEscapedValue (CXNode* pxn, LPCWSTR pwszValue)
{
	return ScSetEscapedValue (pxn, pwszValue, static_cast<UINT>(wcslen(pwszValue)), TRUE);
}

//	CEmitterNode helper functions ---------------------------------------------
//
SCODE __fastcall ScAddStatus (CEmitterNode* pen, ULONG hsc);
SCODE __fastcall ScAddError (CEmitterNode* pen, LPCWSTR pwszErrMsg);

//	class CStatusCache ------------------------------------------------------
//
class CStatusCache
{
	class CHsc
	{
	public:

		ULONG m_hsc;
		CHsc(ULONG hsc) : m_hsc(hsc)
		{
		}

		//	operators for use with the hash cache
		//
		int hash( const int rhs ) const
		{
			return (m_hsc % rhs);
		}
		bool isequal( const CHsc& rhs ) const
		{
			return (m_hsc == rhs.m_hsc);
		}
	};

	class CPropNameArray
	{
	private:

		StringBuffer<CHAR>	m_sb;

		//	Ref' counting.
		//
		//	!!! Please note that this is NON-THREADSAFE !!!
		//
		LONG						m_cRef;

		//	non-implemented
		//
		CPropNameArray(const CPropNameArray& p);
		CPropNameArray& operator=(const CPropNameArray& p);

	public:

		CPropNameArray() :
				m_cRef(1)
		{
		}

		VOID AddRef()				{ m_cRef++; }
		VOID Release()				{ if (0 == --m_cRef) delete this; }

		//	Accessors
		//
		UINT CProps ()				{ return m_sb.CbSize() / sizeof (LPCWSTR); }
		LPCWSTR PwszProp (UINT iProp)
		{
			//	Use C-style cast, reinterpret_cast cannot convert LPCSTR to LPCWSTR *
			//
			return *((LPCWSTR *)(m_sb.PContents() + iProp * sizeof(LPCWSTR)));
		}

		SCODE ScAddPropName (LPCWSTR pwszProp)
		{
			UINT cb = sizeof (LPCWSTR);

			//	Store the pointer in the string buffer
			//
			UINT cbAppend = m_sb.Append (cb, reinterpret_cast<LPSTR>(&pwszProp));
			return (cb == cbAppend) ? S_OK : E_OUTOFMEMORY;
		}
	};

	typedef CCache<CHsc, auto_ref_ptr<CPropNameArray> > CPropNameCache;
	CPropNameCache				m_cache;
	ChainedStringBuffer<WCHAR>	m_csbPropNames;

	class EmitStatusNodeOp : public CPropNameCache::IOp
	{
		CEmitterNode&	m_enParent;

		//	NOT IMPLEMENTED
		//
		EmitStatusNodeOp( const EmitStatusNodeOp& );
		EmitStatusNodeOp& operator=( const EmitStatusNodeOp& );

	public:
		EmitStatusNodeOp (CEmitterNode& enParent) :
				m_enParent(enParent)
		{
		}

		BOOL operator()( const CHsc& key,
						 const auto_ref_ptr<CPropNameArray>& pna );
	};

	//	non-implemented
	//
	CStatusCache(const CStatusCache& p);
	CStatusCache& operator=(const CStatusCache& p);

public:

	CStatusCache()
	{
	}

	SCODE	ScInit ()	{ return m_cache.FInit() ? S_OK : E_OUTOFMEMORY ; }
	BOOL	FEmpty ()	{ return m_cache.CItems() == 0; }

	SCODE	ScAddErrorStatus (ULONG hsc, LPCWSTR pwszProp);
	SCODE	ScEmitErrorStatus (CEmitterNode& enParent);
};

//	CEmitterNode construction helpers -----------------------------------------
//
SCODE ScEmitFromVariant (
	/* [in] */ CXMLEmitter& emitter,
	/* [in] */ CEmitterNode& enParent,
	/* [in] */ LPCWSTR pwszTag,
	/* [in] */ PROPVARIANT& var);

#endif	// _XEMIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\autoptr.h ===
/*
 *	E X \ A U T O P T R . H
 *
 *	Implementation of automatic-cleanup pointer template classes.
 *	This implementation is safe for use in NON-throwing environments
 *	(save for EXDAV & other store-loaded components).
 *
 *	Copyright 1986-1998 Microsoft Corporation, All Rights Reserved.
 */

//----------------------------------------------------------------------//
//
//	Automatic pointers defined here:
//
//		auto_ptr<>
//		auto_heap_ptr<>
//		auto_handle<>
//		auto_heap_array<>
//		auto_ref_ptr<CRefCountedObject>
//

#ifndef _EX_AUTOPTR_H_
#define _EX_AUTOPTR_H_

#include <caldbg.h>
#include <calrc.h>
#include <ex\exmem.h>

#pragma warning(disable: 4284)   // operator-> to a non UDT

//	========================================================================
//
//	TEMPLATE CLASS auto_ptr
//
//		Stripped down auto_ptr class based on the C++ STL standard one
//
//		Calls delete on dtor.
//		NO equals operator between these classes, as that hides
//		the transfer-of-ownership.  Handle those yourself, EXPLICITLY,
//		like this:
//			auto-ptr1 = auto-ptr2.relinquish();
//
template<class X>
class auto_ptr
{
protected:
	X *			px;

	//	NOT IMPLEMENTED
	//
	auto_ptr(const auto_ptr<X>& p);
	auto_ptr& operator=(const auto_ptr<X>& p);

public:

	//	CONSTRUCTORS
	//
	explicit auto_ptr(X* p=0) : px(p) {}
	~auto_ptr()
	{
		delete px;
	}

	//	ACCESSORS
	//
	bool operator!()const { return (px == NULL); }
	operator X*() const { return px; }
	// X& operator*()  const { Assert (px); return *px; }
	X* operator->() const { Assert (px); return px; }
	X* get()		const { return px; }

	//	MANIPULATORS
	//
	X* relinquish()	{ X* p = px; px = 0; return p; }
	X** operator&()	{ Assert (!px); return &px; }
	void clear()
	{
		delete px;
		px = NULL;
	}
	auto_ptr& operator=(X* p)
	{
		Assert(!px);		//	Scream on overwrite of good data.
		px = p;
		return *this;
	}
};



//	========================================================================
//
//	TEMPLATE CLASS auto_handle
//
//		auto_ptr for NT system handles.
//
//		Closes the handle on dtor.
//		NO equals operator between these classes, as that hides
//		the transfer-of-ownership.  Handle those yourself, EXPLICITLY,
//		like this:
//			auto-handle-1 = auto-handle-2.relinquish();
//
template<class X>
class auto_handle
{
private:
	X 	handle;

	//	NOT IMPLEMENTED
	//
	auto_handle(const auto_handle<X>& h);
	auto_handle& operator=(auto_handle<X>& h);

public:

	//	CONSTRUCTORS
	//
	auto_handle(X h=0) : handle(h) {}
	~auto_handle()
	{
		if (handle && INVALID_HANDLE_VALUE != handle)
		{
			CloseHandle(handle);
		}
	}

	//	ACCESSORS
	//
	operator X()	const { return handle; }
	X get()			const { return handle; }

	//	MANIPULATORS
	//
	X relinquish()	{ X h = handle; handle = 0; return h; }
	X* load()		{ Assert(NULL==handle); return &handle; }
	X* operator&()	{ Assert(NULL==handle); return &handle; }
	void clear()
	{
		if (handle && INVALID_HANDLE_VALUE != handle)
		{
			CloseHandle(handle);
		}

		handle = 0;
	}

	auto_handle& operator=(X h)
	{
		Assert (handle == 0);	//	Scream on overwrite of good data
		handle = h;
		return *this;
	}
};



//	========================================================================
//
//	TEMPLATE CLASS auto_ref_ptr
//
//		Holds a ref on an object.  Works with CRefCountedObject.
//		Grabs a ref when a pointer is assigned into this object.
//		Releases the ref when this object is destroyed.
//
template<class X>
class auto_ref_ptr
{
private:

	X *	m_px;

	void init()
	{
		if ( m_px )
		{
			m_px->AddRef();
		}
	}

	void deinit()
	{
		if ( m_px )
		{
			m_px->Release();
		}
	}

	//	NOT IMPLEMENTED
	//	We turn off operator new to try to prevent auto_ref_ptrs being
	//	created via new().  However, storext.h uses a macro to redefine new,
	//	so this line is only used on non-DBG.
#ifndef	DBG
	void * operator new(size_t cb);
#endif	// !DBG

public:

	//	CONSTRUCTORS
	//
	explicit auto_ref_ptr(X* px=0) :
			m_px(px)
	{
		init();
	}

	auto_ref_ptr(const auto_ref_ptr<X>& rhs) :
			m_px(rhs.m_px)
	{
		init();
	}

	~auto_ref_ptr()
	{
		deinit();
	}

	//	ACCESSORS
	//
	X& operator*()		const { return *m_px; }
	X* operator->()		const { return m_px; }
	X* get()			const { return m_px; }

	//	MANIPULATORS
	//
	X* relinquish()			{ X* p = m_px; m_px = 0; return p; }
	X** load()				{ Assert(NULL==m_px); return &m_px; }
	X* take_ownership(X* p) { Assert(NULL==m_px); return m_px = p; }
	void clear()
	{
		deinit();
		m_px = NULL;
	}
	auto_ref_ptr& operator=(const auto_ref_ptr<X>& rhs)
	{
		if ( m_px != rhs.m_px )
		{
			deinit();
			m_px = rhs.m_px;
			init();
		}

		return *this;
	}

	auto_ref_ptr& operator=(X* px)
	{
		if ( m_px != px )
		{
			deinit();
			m_px = px;
			init();
		}

		return *this;
	}
};




//	========================================================================
//
//	TEMPLATE CLASS auto_heap_ptr
//
//		An auto_ptr class based on the heap instead of new.
//
//		Calls ExFree() on dtor.
//		NO equals operator between these classes, as that hides
//		the transfer-of-ownership.  Handle those yourself, EXPLICITLY,
//		like this:
//			auto-heap-ptr1 = auto-heap-ptr2.relinquish();
//
template<class X>
class auto_heap_ptr
{
private:
	X *			m_px;

	//	NOT IMPLEMENTED
	//
	auto_heap_ptr (const auto_heap_ptr<X>& p);
	auto_heap_ptr& operator= (const auto_heap_ptr<X>& p);
	//void * operator new(size_t cb);

public:

	//	CONSTRUCTORS
	//
	explicit auto_heap_ptr (X* p=0) : m_px(p) {}
	~auto_heap_ptr()
	{
		clear();
	}

	//	ACCESSORS
	//
	//	NOTE: this simple cast operator (operator X*()) allows
	//	the [] operator to function.
	//$REVIEW: Should we add an explicit [] operator?
	operator X*()	const { return m_px; }
	X* operator->() const { Assert (m_px); return m_px; }
	X* get()		const { return m_px; }

	//X& operator[] (UINT index) const { return *(m_px + index); }
	//X& operator[] (UINT index) const { return m_px[index]; }

	//	MANIPULATORS
	//
	X* relinquish()	{ X* p = m_px; m_px = 0; return p; }
	X** load()		{ Assert(!m_px); return &m_px; }
	//$REVIEW: Can we migrate all users of operator&() to use load() instead???
	//$REVIEW: Benefit: it's more explicit.  Detriment: need to change existing code.
	X** operator&()	{ Assert (!m_px); return &m_px; }
	void clear()
	{
		if (m_px)			// Release any object we're holding now
		{
			ExFree (m_px);
		}
		m_px = NULL;
	}

	//	Realloc
	//$REVIEW:
	//	This operator is technically NOT safe for store-side code!
	//	It makes it easy to ignore memory failures.
	//	(However, it is currently so ingrained in our vocabulary that
	//	removing it will touch a very large number of files:   )
	//	For now, to be safe, callers MUST check the value of their
	//	object (using .get()) after calling this function.
	//
	void realloc(UINT cb)
	{
		VOID * pvTemp;

		if (m_px)
			pvTemp = ExRealloc (m_px, cb);
		else
			pvTemp = ExAlloc (cb);
		Assert (pvTemp);

		m_px = reinterpret_cast<X*>(pvTemp);
	}
	//$REVIEW: end

	//	Failing Realloc
	//
	BOOL frealloc(UINT cb)
	{
		VOID * pvTemp;

		if (m_px)
			pvTemp = ExRealloc (m_px, cb);
		else
			pvTemp = ExAlloc (cb);
		if (!pvTemp)
			return FALSE;

		m_px = static_cast<X*>(pvTemp);
		return TRUE;
	}

	//	NOTE: This method asserts if the auto-pointer already holds a value.
	//	Use clear() or relinquish() to clear the old value before
	//	taking ownership of another value.
	//
	void take_ownership (X * p)
	{
		Assert (!m_px);		//	Scream on overwrite of good data.
		m_px = p;
	}
	//	NOTE: This operator= is meant to do exactly the same as take_ownership().
	//
	auto_heap_ptr& operator= (X * p)
	{
		Assert (!m_px);		//	Scream on overwrite of good data.
		m_px = p;
		return *this;
	}

};

//	========================================================================
//
//	TEMPLATE CLASS auto_co_task_mem
//
//		Stripped down auto_co_task_mem class based on the C++ STL standard one
//
//		Calls CoTaskMemFree on dtor.
//		NO equals operator between these classes, as that hides
//		the transfer-of-ownership.  Handle those yourself, EXPLICITLY,
//		like this:
//			auto-co_task_mem1 = auto-co_task_mem2.relinquish();
//
template<class X>
class auto_co_task_mem
{
protected:
	X *			m_px;

	//	NOT IMPLEMENTED
	//
	auto_co_task_mem(const auto_co_task_mem<X>& p);
	auto_co_task_mem& operator=(const auto_co_task_mem<X>& p);

public:

	//	CONSTRUCTORS
	//
	explicit auto_co_task_mem(X* p=0) : m_px(p) {}
	~auto_co_task_mem()
	{
		CoTaskMemFree(m_px);
	}

	//	ACCESSORS
	//
	X* operator->() const { Assert (m_px); return m_px; }
	X* get()	const { return m_px; }

	//	MANIPULATORS
	//
	X* relinquish()	{ X* p = m_px; m_px = 0; return p; }
	X** load()		{ Assert(!m_px); return &m_px; }
	X** operator&() { Assert (!m_px); return &m_px; }
	void clear()
	{
		CoTaskMemFree(m_px);
		m_px = NULL;
	}

	//	NOTE: This method asserts if the auto-pointer already holds a value.
	//	Use clear() or relinquish() to clear the old value before
	//	taking ownership of another value.
	//
	void take_ownership (X * p)
	{
		Assert (!m_px);		//	Scream on overwrite of good data.
		m_px = p;
	}
	
	auto_co_task_mem& operator=(X* p)
	{
		Assert(!m_px);		//	Scream on overwrite of good data.
		m_px = p;
		return *this;
	}
};

#endif //!_EX_AUTOPTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\astream.h ===
#ifndef _ASTREAM_H_
#define _ASTREAM_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	ASTREAM.H
//
//		Async streams header.
//
#include <ex\refcnt.h>
#include <ex\refhandle.h>


//	========================================================================
//
//	CLASS IAsyncReadObserver
//
//	Passed to IAsyncStream::AsyncRead() and called when the asynchronous
//	operation completes.
//
class IAsyncReadObserver
{
	//	NOT IMPLEMENTED
	//
	IAsyncReadObserver& operator=( const IAsyncReadObserver& );

public:
	//	CREATORS
	//
	virtual ~IAsyncReadObserver() = 0 {}

	//	MANIPULATORS
	//
	virtual VOID ReadComplete( UINT cbRead, HRESULT hr ) = 0;
};


//	========================================================================
//
//	CLASS IAsyncWriteObserver
//
//	Passed to IAsyncStream::AsyncWrite() and called when the asynchronous
//	operation completes.
//
class IAsyncWriteObserver : public IRefCounted
{
	//	NOT IMPLEMENTED
	//
	IAsyncWriteObserver& operator=( const IAsyncWriteObserver& );

public:
	//	CREATORS
	//
	virtual ~IAsyncWriteObserver() = 0 {}

	//	MANIPULATORS
	//
	virtual VOID WriteComplete( UINT cbWritten, HRESULT hr ) = 0;
};


//	========================================================================
//
//	CLASS IAsyncFlushObserver
//
//	Passed to IAsyncStream::AsyncFlush() and called when the asynchronous
//	operation completes.
//
class IAsyncFlushObserver : public IRefCounted
{
	//	NOT IMPLEMENTED
	//
	IAsyncFlushObserver& operator=( const IAsyncFlushObserver& );

public:
	//	CREATORS
	//
	virtual ~IAsyncFlushObserver() = 0 {}

	//	MANIPULATORS
	//
	virtual VOID FlushComplete( HRESULT hr ) = 0;
};


//	========================================================================
//
//	CLASS IAsyncCopyToObserver
//
//	Passed to IAsyncStream::AsyncCopyTo() and called when the asynchronous
//	operation completes.
//
class IAsyncCopyToObserver
{
	//	NOT IMPLEMENTED
	//
	IAsyncCopyToObserver& operator=( const IAsyncCopyToObserver& );

public:
	//	CREATORS
	//
	virtual ~IAsyncCopyToObserver() = 0 {}

	//	MANIPULATORS
	//
	virtual VOID CopyToComplete( UINT cbCopied, HRESULT hr ) = 0;
};

//	========================================================================
//
//	CLASS IDavStream
//
//		Interface for sync streams.
//
class IDavStream
{
	//	NOT IMPLEMENTED
	//
	IDavStream& operator=( const IDavStream& );

protected:
	//	CREATORS
	//
	//		Only create this object through it's descendents!
	//
	IDavStream() {};

public:
	//	DESTRUCTORS
	//
	//		Out of line virtual destructor necessary for proper
	//		deletion of objects of derived classes via this class
	//
	virtual ~IDavStream() = 0
	{
	}

	//	ACCESSORS
	//

	//	DwLeft() is the function that must be implemented by the descendants of this 
	//	interface if they are to be passed to
	//
	//		IHybridStream::ScCopyFrom(const IDavStream * stmSrc,
	//								  IAsyncWriteObserver * pobsAsyncWrite)
	//	
	//	In that case it must return the number of bytes left in the stream to drain.
	//	That size can be an estimated one, not necessarily exact. That has to be
	//	implemented, that way, as the stream size that we are getting from the store
	//	when we open the stream on the property may be not correct (from the
	//	experience in that I can tell that still in most cases that data is
	//	correct, except for PR_BODY). Also for example in conversion streams we will
	//	not know the stream size in advance (we have not read all data yet and do not
	//	know in what converted size it will result in). Descendants that are not intended to
	//	be passed to the call above may choose to implement DwLeft() to trap or return 0.
	//	Of course in that case they should not rely on information comming back from
	//	that call. Also as soon as it is finally determined that we have reached the
	//	end of the stream (i.e. we read a piece of data, and we read less than we asked for),
	//	the function should always return 0.
	//	
	virtual DWORD DwLeft() const = 0;

	//	FEnd() is the function that must return TRUE in the case the whole stream has been
	//	already drained/consumed. FALSE must be returned in all other cases. Child classes
	//	may implement it to return FALSE always if they are always sure that ScCopyFrom
	//	operations from this stream will always be given amount of bytes to copy that is
	//	equal or less than actual amount of bytes still remaining in the stream. Of course
	//	if they choose always to return FLASE they should not use the function to determine
	//	if they reached the end of the stream.
	//
	virtual BOOL FEnd() const
	{
		TrapSz("IDavStream::FEnd() not implemented");
		return FALSE;
	}
	
	//	ScRead() reading from the stream
	//
	virtual SCODE ScRead( BYTE * pbBuf,
						  UINT   cbToRead,
						  UINT * pcbRead ) const
	{
		TrapSz("IDavStream::ScRead() not implemented");
		return E_NOTIMPL;
	}

	//	MANIPULATORS
	//
	virtual SCODE ScWrite( const BYTE * pbBuf,
						   UINT         cbToWrite,
						   UINT *       pcbWritten )
	{
		TrapSz("IDavStream::ScWrite() not implemented");
		return E_NOTIMPL;
	}

	virtual SCODE ScCopyTo( IDavStream& stmDst,
							UINT        cbToCopy,
							UINT *      pcbCopied )
	{
		TrapSz("IDavStream::ScCopyTo() not implemented");
		return E_NOTIMPL;
	}

	virtual SCODE ScFlush()
	{
		return S_OK;
	}
};

//	========================================================================
//
//	CLASS IAsyncStream
//
//		Interface for async streams.
//
//		AsyncRead() -
//			Asynchronously reads bytes from a stream and notifies an
//			observer when the I/O completes.  IAsyncStream provides
//			a default implementation that notifies the observer with
//			0 bytes read and an HRESULT of E_NOTIMPL.
//
//		AsyncWrite()
//			Asynchronously writes bytes to a stream and notifies an
//			observer when the I/O completes.  IAsyncStream provides
//			a default implementation that notifies the observer with
//			0 bytes written and an HRESULT of E_NOTIMPL.
//
//		AsyncCopyTo()
//			Asynchronously copies bytes from this stream to another
//			IAsyncStream and notifies an observer when the I/O completes.
//			IAsyncStream provides a default implementation that notifies
//			the observer with 0 bytes copied and an HRESULT of E_NOTIMPL.
//
//		AsyncFlush()
//			To be used with buffered writable streams.  Asynchronously
//			flushes accumulated data written in previous calls to
//			AsyncWrite() and notifies an observer when the I/O completes.
//			IAsyncStream provides a default implementation that notifies
//			the observer with an HRESULT of E_NOTIMPL.
//
//	!!!IMPORTANT!!!
//	Despite the refcounted base class of IAsyncWriteObserver and IAsyncFlushObserver,
//	it is the CALLER's sole responsbility to guarantee the lifetime of the stream
//	and observers through completion of any async I/O call.
//
class IAsyncStream
{
	//	NOT IMPLEMENTED
	//
	IAsyncStream& operator=( const IAsyncStream& );

public:
	//	DESTRUCTORS
	//
	virtual ~IAsyncStream() = 0
	{
	}

	//	ACCESSORS
	//
	virtual UINT CbReady() const
	{
		return 0;
	}

	//	MANIPULATORS
	//
	virtual VOID AsyncRead( BYTE * pbBuf,
							UINT   cbToRead,
							IAsyncReadObserver& obsAsyncRead )
	{
		obsAsyncRead.ReadComplete( 0, E_NOTIMPL );
	}

	virtual VOID AsyncWrite( const BYTE * pbBuf,
							 UINT         cbToWrite,
							 IAsyncWriteObserver& obsAsyncWrite )
	{
		obsAsyncWrite.WriteComplete( 0, E_NOTIMPL );
	}

	virtual VOID AsyncCopyTo( IAsyncStream& stmDst,
							  UINT          cbToCopy,
							  IAsyncCopyToObserver& obsAsyncCopyTo )
	{
		obsAsyncCopyTo.CopyToComplete( 0, E_NOTIMPL );
	}

	virtual VOID AsyncFlush( IAsyncFlushObserver& obsAsyncFlush )
	{
		obsAsyncFlush.FlushComplete( E_NOTIMPL );
	}
};

//	========================================================================
//
//	CLASS IHybridStream
//
//		Interface for a hybrid sync/async stream.  The main difference
//		between this interface and IAsyncStream is that the calls here
//		do not always complete via async observer notification.  If a
//		call executes synchronously, it fills in all return values and
//		returns status via an SCODE.  If a call executes asynchronously,
//		it immediately returns E_PENDING and calls the completion observer
//		with return values and status when the asynchronous I/O completes.
//
//		Callers cannot control whether a call executes synchronously or
//		asynchronously.
//
//	!!!IMPORTANT!!!
//	Despite the refcounted base class of IAsyncWriteObserver and IAsyncFlushObserver,
//	it is the CALLER's sole responsbility to guarantee the lifetime of the stream
//	and observers through completion of any async I/O call.
//
class IHybridStream
{
	//	NOT IMPLEMENTED
	//
	IHybridStream& operator=( const IHybridStream& );

public:
	//	CREATORS
	//
	virtual ~IHybridStream() = 0
	{
	}

	//	ACCESSORS
	//
	virtual UINT CbSize() const
	{
		TrapSz("IHybridStream::CbSize() not implemented");
		return 0;
	}

	//	MANIPULATORS
	//
	virtual SCODE ScRead( BYTE * pbToRead,
						  DWORD cbToRead,
						  DWORD * pcbRead,
						  IAsyncReadObserver * pobsAsyncRead )
	{
		TrapSz("IHybridStream::ScRead() not implemented");
		return E_NOTIMPL;
	}

	virtual SCODE ScWrite( const BYTE * pbToWrite,
						   DWORD cbToWrite,
						   DWORD * pcbWritten,
						   IAsyncWriteObserver * pobsAsyncWrite )
	{
		TrapSz("IHybridStream::ScWrite() not implemented");
		return E_NOTIMPL;
	}

	virtual SCODE ScCopyFrom( const IDavStream * pdsToCopy,
							  const DWORD cbToCopy,
							  DWORD * pcbCopied,
							  IAsyncWriteObserver * pobsAsyncWrite )
	{
		TrapSz("IHybridStream::ScCopyFrom() not implemented");
		return E_NOTIMPL;
	}

	virtual SCODE ScCopyFrom( const IDavStream * pdsToCopy,
							  IAsyncWriteObserver * pobsAsyncWrite )
	{
		DWORD cbCopied;
		return ScCopyFrom( pdsToCopy,
						   pdsToCopy->DwLeft(),
						   &cbCopied,
						   pobsAsyncWrite);
	}

	virtual SCODE ScCopyTo( IHybridStream& stmDst,
							DWORD cbToCopy,
							DWORD * pcbCopied,
							IAsyncCopyToObserver * pobsAsyncCopyTo )
	{
		TrapSz("IHybridStream::ScCopyTo() not implemented");
		return E_NOTIMPL;
	}

	virtual SCODE ScFlush( IAsyncFlushObserver * pobsAsyncFlush )
	{
		TrapSz("IHybridStream::ScFlush() not implemented");
		return E_NOTIMPL;
	}
};

//	========================================================================
//
//	TEMPLATE CLASS CBufferedStream
//
//	Inline buffering stream implementation.  See !!! IMPORTANT !!! section
//	below for limitations and other considerations.
//
//	Template parameters:
//
//		_RawStream
//			Raw stream type.  _RawStream must implement ScReadRaw() for
//			CBufferedStream::ScRead(), if it is to be used, and ScWriteRaw()
//			for CBufferedStream::ScWrite() and CBufferedStream::ScFlush()
//			if they are to be used.  The prototypes are:
//
//			SCODE ScReadRaw( BYTE * pbToRead,
//							 DWORD   cbToRead,
//							 DWORD * pcbRead,
//							 IAsyncReadObserver * pobsAsyncRead );
//
//			SCODE ScWriteRaw( const BYTE * pbToWrite,
//							  DWORD cbToWrite,
//							  DWORD * pcbWritten,
//							  IAsyncWriteObserver * pobsAsyncWrite );
//
//			These functions read and write from the raw stream.  The I/O
//			they implement can be synchronous or asynchronous or both.
//
//		CB_BUF
//			Size (in bytes) of the buffer to use.  The buffer is a direct
//			member of CBufferedStream; no allocation is done.
//
//
//	!!! IMPORTANT !!!
//
//	Reading and writing:
//		There is no restriction on the amount of data that can be read
//		or written at once, but data is buffered CB_BUF bytes at a time.
//		This means that a request to write, for example, 128K of data
//		will incur two buffer flushes when CB_BUF is 64K.  The same
//		is true of reads and buffer fills.  Buffer flushes/fills are
//		typically the expensive I/O operations, so choose a CB_BUF
//		that works well with the particular I/O (e.g. 64K for file I/O).
//
//	Flushing:
//		There is an assumption in ScFlush() that the stream being flushed
//		to is not a buffered stream; ScFlush() does not flush the raw stream.
//
//	Class size:
//		Since the buffer is inline (i.e. not allocated), instances of this class
//		can potentially be large.  Whenever such an instance is used as a
//		direct member of another class, it should be the last such member so as
//		to maximize data locality when accessing other members of the class.
//		
template<class _RawStream, UINT CB_BUF>
class CBufferedStream :
	private IAsyncReadObserver,
	private IAsyncWriteObserver
{
	//	Amount of the buffer used.
	//
	UINT m_cbBufUsed;

	//	Index of next byte to read from buffer.
	//
	UINT m_ibBufCur;

	//	Per read/write request state.  These members are used
	//	to keep track of state across various async I/O calls.
	//
	const IDavStream * m_pdsRequest;
	LPBYTE m_pbRequest;
	DWORD m_cbRequest;
	DWORD m_cbRequestDone;

	//	Caller-supplied observers.  Used to notify the caller
	//	when I/O completes.
	//
	IAsyncReadObserver * m_pobsRead;
	IAsyncWriteObserver * m_pobsWrite;
	IAsyncFlushObserver * m_pobsFlush;

	//	Pointer to the raw stream.  Used in buffer filling/flushing.
	//
	_RawStream * m_pstmRaw;

	//	The buffer.  The CB_BUF size is a template parameter.
	//
	BYTE m_rgbBuf[CB_BUF];

	//	Internal I/O routines
	//
	inline SCODE ScReadInt();
	inline SCODE ScWriteInt();
	inline SCODE ScCopyFromInt();

	//	Raw stream I/O completion routines
	//
	inline VOID RawReadComplete(UINT cbReadRaw);
	inline VOID RawWriteComplete(UINT cbWrittenRaw);

	//	Buffer filling and flushing utilities
	//
	inline SCODE ScFillBuffer();
	inline SCODE ScFlushBuffer();

	//	NOT IMPLEMENTED
	//
	CBufferedStream( const CBufferedStream& );
	CBufferedStream& operator=( const CBufferedStream& );

public:
	//	CREATORS
	//
	CBufferedStream() :
		m_cbBufUsed(0),
		m_ibBufCur(0),
		m_pobsRead(NULL),
		m_pobsWrite(NULL),
		m_pobsFlush(NULL)
	{
	}

	//	ACCESSORS
	//
	ULONG CbBufUsed() const
	{
		return m_cbBufUsed;
	}

	//	MANIPULATORS
	//
	inline
	SCODE ScRead( _RawStream& stmRaw,
				  BYTE * pbToRead,
				  DWORD cbToRead,
				  DWORD * pcbRead,
				  IAsyncReadObserver * pobsReadExt );

	inline
	SCODE ScWrite( _RawStream& stmRaw,
				   const BYTE * pbToWrite,
				   DWORD cbToWrite,
				   DWORD * pcbWritten,
				   IAsyncWriteObserver * pobsWriteExt );

	inline
	SCODE ScCopyFrom( _RawStream& stmRaw,
					  const IDavStream * pdsToCopy,
					  const DWORD cbToCopy,
					  DWORD * pcbCopied,
					  IAsyncWriteObserver * pobsWriteExt );

	inline
	SCODE ScFlush( _RawStream& stmRaw,
				   IAsyncFlushObserver * pobsFlushExt );

	//	IAsyncReadObserver/IAsyncWriteObserver
	//
	//	Note: these functions are not really inlined -- they are declared
	//	virtual in the observer interface classes.  However we must declare
	//	them inline so that the compiler will generate one instance of each
	//	function rather than one instance per function per module.  This is
	//	the member function equivalent of DEC_CONST.
	//
	inline
	VOID ReadComplete( UINT cbReadRaw,
					   HRESULT hr );

	inline
	VOID WriteComplete( UINT cbWrittenRaw,
						HRESULT hr );

	//$REVIEW
	//
	//	IAsyncWriteObserver and IAsyncReadObserver are both refcounted
	//	interfaces and don't need to be.  Caller assumes all responsibility
	//	for keeping stream and observer objects alive through any stream
	//	call.
	//
	void AddRef()
	{
		TrapSz("CBufferedStream::AddRef() is not implemented!");
	}

	void Release()
	{
		TrapSz("CBufferedStream::Release() is not implemented!");
	}
};

template<class _RawStream, UINT CB_BUF>
SCODE
CBufferedStream<_RawStream, CB_BUF>::ScRead(
	_RawStream& stmRaw,
	BYTE * pbToRead,
	DWORD cbToRead,
	DWORD * pcbRead,
	IAsyncReadObserver * pobsReadExt )
{
	//	Check parameters
	//
	Assert(cbToRead > 0);
	Assert(!IsBadWritePtr(pbToRead, cbToRead));
	Assert(!IsBadWritePtr(pcbRead, sizeof(UINT)));
	Assert(!pobsReadExt || !IsBadReadPtr(pobsReadExt, sizeof(IAsyncReadObserver)));

	//	We had better not be in any I/O of any sort.
	//
	Assert(!m_pobsRead);
	Assert(!m_pobsWrite);
	Assert(!m_pobsFlush);

	//	Set up state for a new read
	//
	m_pstmRaw = &stmRaw;
	m_pdsRequest = NULL;
	m_pbRequest = pbToRead;
	m_cbRequest = cbToRead;
	m_pobsRead = pobsReadExt;
	m_cbRequestDone = 0;

	//	Issue the read
	//
	SCODE sc = ScReadInt();

	//	If the read didn't pend then clear out the observer
	//	and return the amount of data read.
	//
	if (E_PENDING != sc)
	{
		m_pobsRead = NULL;
		*pcbRead = m_cbRequestDone;
	}

	//	Return the result of the I/O, which may be S_OK, E_PENDING
	//	or any other error.
	//
	return sc;
}

template<class _RawStream, UINT CB_BUF>
SCODE
CBufferedStream<_RawStream, CB_BUF>::ScReadInt()
{
	SCODE sc = S_OK;

	//	Loop around alternately filling and reading from the
	//	buffer until we finish the request or until a fill pends.
	//
	while ( m_cbRequestDone < m_cbRequest )
	{
		//	If we have read everything from the buffer then try
		//	to refill the buffer from the raw stream.
		//
		if (m_ibBufCur == m_cbBufUsed)
		{
			sc = ScFillBuffer();
			if (FAILED(sc))
			{
				if (E_PENDING != sc)
					DebugTrace("CBufferedStream::ScReadInt() - ScFillBuffer() failed 0x%08lX\n", sc);

				break;
			}

			//	If the buffer is still empty then we have
			//	exhausted the stream, so we are done.
			//
			if (0 == m_cbBufUsed)
				break;
		}

		//	The buffer should have data available to be read
		//	so read it.
		//
		Assert(m_ibBufCur < m_cbBufUsed);
		DWORD cbToRead = min(m_cbBufUsed - m_ibBufCur,
							 m_cbRequest - m_cbRequestDone);

		memcpy(m_pbRequest + m_cbRequestDone,
			   &m_rgbBuf[m_ibBufCur],
			   cbToRead);

		m_ibBufCur += cbToRead;
		m_cbRequestDone += cbToRead;
	}

	return sc;
}

template<class _RawStream, UINT CB_BUF>
SCODE
CBufferedStream<_RawStream, CB_BUF>::ScFillBuffer()
{
	//	We better have a stream to fill from
	//
	Assert(m_pstmRaw);

	//	Assert that we are not in any write/copy/flush I/O
	//
	Assert(!m_pobsWrite);
	Assert(!m_pobsFlush);

	//	We should only try to refill the buffer after all
	//	of the data in it has been consumed.
	//
	Assert(m_ibBufCur == m_cbBufUsed);

	//	Reset the buffer back to the beginning.
	//
	m_cbBufUsed = 0;
	m_ibBufCur = 0;

	//	Read data in from the raw stream.  If reading pends on I/O
	//	then we will resume processing in CBufferedStream::ReadComplete()
	//	when the I/O completes.
	//
	DWORD cbRead = 0;
	SCODE sc = m_pstmRaw->ScReadRaw(m_rgbBuf,
									CB_BUF,
									&cbRead,
									this);
	if (SUCCEEDED(sc))
	{
		//	ScReadRaw() did not pend, so update our internal state and continue.
		//
		RawReadComplete(cbRead);
	}
	else if (E_PENDING != sc)
	{
		DebugTrace("CBufferedStream::ScFillBuffer() - m_pstmRaw->ScReadRaw() failed 0x%08lX\n", sc);
	}

	return sc;
}

template<class _RawStream, UINT CB_BUF>
VOID
CBufferedStream<_RawStream, CB_BUF>::ReadComplete( UINT cbReadRaw,
												   HRESULT hr )
{
	//	Update our internal state
	//
	RawReadComplete(cbReadRaw);

	//	If I/O succeeded then continue reading where we left off.
	//	We are done reading only when ScReadInt() returns S_OK
	//	or any error other than E_PENDING.
	//
	if (SUCCEEDED(hr))
	{
		hr = ScReadInt();
		if (E_PENDING == hr)
			return;

		if (FAILED(hr))
			DebugTrace("CBufferedStream::ReadComplete() - ScReadInt() failed 0x%08lX\n", hr);
	}

	//	Pull the external read observer from where we saved it
	//
	Assert(m_pobsRead);
	IAsyncReadObserver * pobsReadExt = m_pobsRead;
	m_pobsRead = NULL;

	//	Complete the read by calling the client back with
	//	total amount read for the request.
	//
	//	Note that m_cbRequestDone != m_cbRequest only when there
	//	is an error.
	//
	Assert(FAILED(hr) || m_cbRequestDone == m_cbRequest);
	pobsReadExt->ReadComplete(m_cbRequestDone, hr);
}

template<class _RawStream, UINT CB_BUF>
VOID
CBufferedStream<_RawStream, CB_BUF>::RawReadComplete(UINT cbReadRaw)
{
	Assert(0 == m_cbBufUsed);
	Assert(0 == m_ibBufCur);

	//	Update the number of bytes read
	//
	m_cbBufUsed = cbReadRaw;
}

template<class _RawStream, UINT CB_BUF>
SCODE
CBufferedStream<_RawStream, CB_BUF>::ScWrite(
	_RawStream& stmRaw,
	const BYTE * pbToWrite,
	DWORD cbToWrite,
	DWORD * pcbWritten,
	IAsyncWriteObserver * pobsWriteExt )
{
	//	Check parameters
	//
	Assert(cbToWrite > 0);
	Assert(!IsBadReadPtr(pbToWrite, cbToWrite));
	Assert(!IsBadWritePtr(pcbWritten, sizeof(UINT)));
	Assert(!pobsWriteExt || !IsBadReadPtr(pobsWriteExt, sizeof(IAsyncWriteObserver)));

	//	We had better not be in any I/O of any sort.
	//
	Assert(!m_pobsRead);
	Assert(!m_pobsWrite);
	Assert(!m_pobsFlush);
	
	//	Set up state for a new write.  Casting away const-ness is OK;
	//	we don't write to m_pbRequest on writes.
	//
	m_pstmRaw = &stmRaw;
	m_pdsRequest = NULL;
	m_pbRequest = const_cast<BYTE *>(pbToWrite);
	m_cbRequest = cbToWrite;
	m_pobsWrite = pobsWriteExt;
	m_cbRequestDone = 0;

	//	Issue the write
	//
	SCODE sc = ScWriteInt();

	//	If the write didn't pend then clear out the observer
	//	and return the amount of data written.
	//
	if (E_PENDING != sc)
	{
		m_pobsWrite = NULL;
		*pcbWritten = m_cbRequestDone;
	}

	//	Return the result of the I/O, which may be S_OK, E_PENDING
	//	or any other error.
	//
	return sc;
}

template<class _RawStream, UINT CB_BUF>
SCODE
CBufferedStream<_RawStream, CB_BUF>::ScCopyFrom(
	_RawStream& stmRaw,
	const IDavStream * pdsToCopy,
	const DWORD cbToCopy,
	DWORD * pcbCopied,
	IAsyncWriteObserver * pobsWriteExt )
{
	//	Check parameters
	//
	Assert(cbToCopy >= 0);
	Assert(!IsBadReadPtr(pdsToCopy, sizeof(IDavStream)));
	Assert(!IsBadWritePtr(pcbCopied, sizeof(UINT)));
	Assert(!pobsWriteExt || !IsBadReadPtr(pobsWriteExt, sizeof(IAsyncWriteObserver)));

	//	We had better not be in any I/O of any sort.
	//
	Assert(!m_pobsRead);
	Assert(!m_pobsWrite);
	Assert(!m_pobsFlush);

	//	Set up state for a new write.  Casting away const-ness is OK;
	//	we don't write to m_pbRequest on writes.
	//
	m_pstmRaw = &stmRaw;
	m_pdsRequest = pdsToCopy;
	m_pbRequest = NULL;
	m_cbRequest = cbToCopy;
	m_pobsWrite = pobsWriteExt;
	m_cbRequestDone = 0;

	//	Issue the write
	//
	SCODE sc = ScCopyFromInt();

	//	If the write didn't pend then clear out the observer
	//	and return the amount of data written.
	//
	if (E_PENDING != sc)
	{
		m_pobsWrite = NULL;
		*pcbCopied = m_cbRequestDone;
	}

	//	Return the result of the I/O, which may be S_OK, E_PENDING
	//	or any other error.
	//
	return sc;
}

template<class _RawStream, UINT CB_BUF>
SCODE
CBufferedStream<_RawStream, CB_BUF>::ScWriteInt()
{
	SCODE sc = S_OK;

	//	Loop around alternately filling and flushing the buffer until
	//	we finish the request or until a buffer flush pends.
	//
	while ( m_cbRequestDone < m_cbRequest )
	{
		//	If there is no room left to write to the buffer then flush
		//	the buffer to the raw stream.
		//
		if (CB_BUF == m_cbBufUsed)
		{
			sc = ScFlushBuffer();
			if (FAILED(sc))
			{
				if (E_PENDING != sc)
					DebugTrace("CBufferedStream::ScWriteInt() - ScFlushBuffer() failed 0x%08lX\n", sc);

				break;
			}
		}

		//	There is room left in the buffer so copy over
		//	as much data from the request as will fit.
		//
		Assert(m_cbBufUsed < CB_BUF);
		DWORD cbToWrite = min(CB_BUF - m_cbBufUsed,
							  m_cbRequest - m_cbRequestDone);

		Assert(m_pbRequest);
		memcpy(&m_rgbBuf[m_cbBufUsed],
			   m_pbRequest + m_cbRequestDone,
			   cbToWrite);

		m_cbBufUsed += cbToWrite;
		m_cbRequestDone += cbToWrite;
	}

	return sc;
}

template<class _RawStream, UINT CB_BUF>
SCODE
CBufferedStream<_RawStream, CB_BUF>::ScCopyFromInt()
{
	SCODE sc = S_OK;

	//	Loop around alternately filling and flushing the buffer until
	//	we finish the request or until a buffer flush pends.
	//
	while ( m_cbRequestDone < m_cbRequest )
	{
		//	If there is no room left to write to the buffer then flush
		//	the buffer to the raw stream.
		//
		if (CB_BUF == m_cbBufUsed)
		{
			sc = ScFlushBuffer();
			if (FAILED(sc))
			{
				if (E_PENDING != sc)
					DebugTrace("CBufferedStream::ScCopyFromInt() - ScFlushBuffer() failed 0x%08lX\n", sc);

				break;
			}
		}

		//	There is room left in the buffer so copy over
		//	as much data from the request as will fit.
		//
		Assert(m_cbBufUsed < CB_BUF);
		UINT  cbCopied = 0;
		DWORD cbToCopy = min(CB_BUF - m_cbBufUsed,
							  m_cbRequest - m_cbRequestDone);

		Assert(m_pdsRequest);
		sc = m_pdsRequest->ScRead(&m_rgbBuf[m_cbBufUsed],
								  cbToCopy,
								  &cbCopied);
		if (FAILED(sc))
		{
			Assert(E_PENDING != sc);
			DebugTrace("CBufferedStream::ScCopyFromInt() - ScRead() from source buffer failed 0x%08lX\n", sc);
			break;
		}

		m_cbBufUsed += cbCopied;
		m_cbRequestDone += cbCopied;

		//	Even if the clients requested to read certain amount of bytes to be read,
		//	they may be wrong in their estimates, so let us be really smart about the
		//	case and check if the end of the stream has been reached
		//
		if (m_pdsRequest->FEnd())
		{
			//	Make sure that we certainly go out of the loop in the case we finished
			//
			m_cbRequest = m_cbRequestDone;
			break;
		}
	}

	return sc;
}

template<class _RawStream, UINT CB_BUF>
VOID
CBufferedStream<_RawStream, CB_BUF>::WriteComplete( UINT cbWritten,
													HRESULT hr )
{
	//	Update our internal state with the amount of buffered data that we
	//	flushed.  We only want to do this IF the call was successful....
	//	RawWriteComplete() asserts that cbWritten == m_cbBufUsed, which will
	//	not be true if the write failed.
	//
    if (SUCCEEDED(hr))
        RawWriteComplete(cbWritten);

	//	I/O is complete.  Either the write that just completed
	//	failed or the subsequent write completed synchronously.
	//	Notify the appropriate observer that we are done.
	//
	if (m_pobsWrite)
	{
		// I/O was a write, not a flush
		//
		Assert(!m_pobsFlush);

		//	If I/O succeeded then continue writing where we left off.
		//	We are done writing only when ScWriteInt() returns S_OK
		//	or any error other than E_PENDING.
		//
		if (SUCCEEDED(hr))
		{
			hr = ScWriteInt();
			if (E_PENDING == hr)
				return;

			if (FAILED(hr))
				DebugTrace("CBufferedStream::WriteComplete() - ScWriteInt() failed 0x%08lX\n", hr);
		}

		//	Pull the external write observer from where we saved it
		//
		IAsyncWriteObserver * pobsWriteExt = m_pobsWrite;
		m_pobsWrite = NULL;

		//	Complete the write by calling the client back with
		//	total amount written for the request.
		//
		//	Note that m_cbRequestDone != m_cbRequest only when there
		//	is an error.
		//
		Assert(FAILED(hr) || m_cbRequestDone == m_cbRequest);
		pobsWriteExt->WriteComplete(m_cbRequestDone, hr);
	}
	else
	{
		// I/O was a flush, not a write
		//
		Assert(m_pobsFlush);

		//	The buffer should be empty after flushing
		//
		Assert(0 == m_cbBufUsed);

		//	Pull the external flush observer from where we saved it
		//
		IAsyncFlushObserver * pobsFlushExt = m_pobsFlush;
		m_pobsFlush = NULL;

		//	Tell it that we are done.
		//
		pobsFlushExt->FlushComplete(hr);
	}
}

template<class _RawStream, UINT CB_BUF>
SCODE
CBufferedStream<_RawStream, CB_BUF>::ScFlushBuffer()
{
	//	We better have a stream to flush to.
	//
	Assert(m_pstmRaw);

	//	We better have something to flush.
	//
	Assert(m_cbBufUsed > 0);

	//	Write out all buffered data to the raw stream.  If writing
	//	pends on I/O then we will resume processing in
	//	CBufferedStream::WriteComplete() when the I/O completes.
	//
	DWORD cbWritten = 0;
	SCODE sc = m_pstmRaw->ScWriteRaw(m_rgbBuf,
									 m_cbBufUsed,
									 &cbWritten,
									 this);
	if (SUCCEEDED(sc))
	{
		//	ScWriteRaw() did not pend, so update our internal state and continue.
		//
		RawWriteComplete(cbWritten);
	}
	else if (E_PENDING != sc)
	{
		DebugTrace("CBufferedStream::ScFlushBuffer() - m_pstmRaw->ScWriteRaw() failed 0x%08lX\n", sc);
	}

	return sc;
}

template<class _RawStream, UINT CB_BUF>
VOID
CBufferedStream<_RawStream, CB_BUF>::RawWriteComplete(UINT cbWrittenRaw)
{
	//	Verify that we wrote the entire buffer
	//
	Assert(cbWrittenRaw == m_cbBufUsed);

	//	Start the buffer again from the beginning
	//
	m_cbBufUsed = 0;
}

template<class _RawStream, UINT CB_BUF>
SCODE
CBufferedStream<_RawStream, CB_BUF>::ScFlush( _RawStream& stmRaw,
											  IAsyncFlushObserver * pobsFlushExt )
{
	SCODE sc = S_OK;

	//	Check parameters
	//
	Assert(!pobsFlushExt || !IsBadReadPtr(pobsFlushExt, sizeof(IAsyncFlushObserver)));

	//	We had better not be in any I/O of any sort.
	//
	Assert(!m_pobsRead);
	Assert(!m_pobsFlush);
	Assert(!m_pobsWrite);

	//	If there's nothing to flush then we're done.
	//
	if (m_cbBufUsed)
	{
		//	Set up state for a flush
		//
		m_pstmRaw = &stmRaw;
		m_pobsFlush = pobsFlushExt;

		//	Flush buffered data to the raw stream.
		//
		sc = ScFlushBuffer();

		//	If the flush didn't pend then clear out the observer.
		//
		if (E_PENDING != sc)
			m_pobsFlush = NULL;
	}

	return sc;
}


//	========================================================================
//
//	CLASS CFileStreamImp
//
//		Base implementation class for a file stream.
//
template<class _RawStream, class _OVL>
class CFileStreamImp
{
	//
	//	File handle
	//
	auto_ref_handle m_hf;

	//
	//	File pointer
	//
	_OVL m_ovl;

	//
	//	Implementation stream is a buffered stream with a buffer size
	//	of 64K to optimize for file I/O.
	//
	//	Note: this data member is declared LAST because it contains
	//	an internal 64K buffer that we don't want sitting between
	//	other member variables.
	//
	CBufferedStream<_RawStream, 64 * 1024> m_BufferedStream;

	//	NOT IMPLEMENTED
	//
	CFileStreamImp( const CFileStreamImp& );
	CFileStreamImp& operator=( const CFileStreamImp& );

public:
	//	CREATORS
	//
	CFileStreamImp(const auto_ref_handle& hf) :
		m_hf(hf)
	{
		memset(&m_ovl, 0, sizeof(m_ovl));
	}

	//	ACCESSORS
	//
	HANDLE HFile() const
	{
		return m_hf.get();
	}

	_OVL * POverlapped()
	{
		return &m_ovl;
	}

	//	MANIPULATORS
	//
	SCODE ScRead( _RawStream& stmRaw,
				  BYTE * pbToRead,
				  DWORD cbToRead,
				  DWORD * pcbRead,
				  IAsyncReadObserver * pobsAsyncRead )
	{
		return m_BufferedStream.ScRead( stmRaw,
										pbToRead,
										cbToRead,
										pcbRead,
										pobsAsyncRead );
	}

	SCODE ScWrite( _RawStream& stmRaw,
				   const BYTE * pbToWrite,
				   DWORD cbToWrite,
				   DWORD * pcbWritten,
				   IAsyncWriteObserver * pobsAsyncWrite )
	{
		return m_BufferedStream.ScWrite( stmRaw,
										 pbToWrite,
										 cbToWrite,
										 pcbWritten,
										 pobsAsyncWrite );
	}

	SCODE ScCopyFrom( _RawStream& stmRaw,
					  const IDavStream * pdsToCopy,
					  const DWORD cbToCopy,
					  DWORD * pcbCopied,
					  IAsyncWriteObserver * pobsAsyncWrite )
	{
		return m_BufferedStream.ScCopyFrom( stmRaw,
											pdsToCopy,
											cbToCopy,
											pcbCopied,
											pobsAsyncWrite );
	}


	SCODE ScFlush( _RawStream& stmRaw,
				   IAsyncFlushObserver * pobsFlush )
	{
		return m_BufferedStream.ScFlush( stmRaw, pobsFlush );
	}

	//
	//	Update the current file position
	//
	VOID UpdateFilePos(UINT cbIO)
	{
		//
		//	Check for overflow of the low 32 bits of the offset.  If we are
		//	going to overflow then increment the high part of the offset.
		//
		if (m_ovl.Offset + cbIO < m_ovl.Offset)
		{
			++m_ovl.OffsetHigh;

			//
			//	OffsetHigh should NEVER overflow
			//
			Assert(m_ovl.OffsetHigh);
		}

		//
		//	Update the low 32 bits of the offset
		//
		m_ovl.Offset += cbIO;
	}
};

#endif // !defined(_ASTREAM_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\exmem.h ===
/*
 *	E X M E M . H
 *
 *	Defines a set of external functions that provide memory allocation
 *	for common code between impls and store-side processes.  The memory
 *	allocators defined here can fail and callers are responsible for
 *	checking the return values.
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_EX_EXMEM_H_
#define	_EX_EXMEM_H_

extern LPVOID __fastcall ExAlloc( UINT cb );
extern LPVOID __fastcall ExRealloc( LPVOID lpv, UINT cb );
extern VOID __fastcall ExFree( LPVOID pv );

#endif	// _EX_EXMEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\baselist.h ===
/*==========================================================================*\

    Module:        baselist.h

    Copyright Microsoft Corporation 1996, All Rights Reserved.

    Owner:         mikepurt

    Descriptions:

    CListElement is a base class for objects that will be used in such a way
    that they will only be on one list at a time.  The list that it's on is
    considered its owner.  CListHead is an anchor point for these lists.
    List manipulation is not protected by these classes.  The clients of these
    classes are responsible for providing multithread protection, if needed.
    List append/prepend/remove operations take O(1) time to complete.

\*==========================================================================*/

#ifndef __BASELIST_H__
#define __BASELIST_H__


/*$-- template<class T> class CListHead ===================================*\

\*=========================================================================*/

template<class T>
class CListHead
{
public:
    CListHead()
    {
        m_pleHead   = NULL;
		m_cElements = 0;
    };

#ifdef DEBUG
    ~CListHead()
    {
        Assert(NULL == m_pleHead);
    };
#endif
    
    void Prepend(IN T * ple);
    void Append(IN T * ple);
    void Remove(IN T * ple);

    BOOL FIsMember(IN T * ple);
    
    T * GetListHead()
    { return m_pleHead; };

	DWORD ListSize() { return m_cElements; };
	
private:
    T     * m_pleHead;
	DWORD   m_cElements;
};



/*$-- template<class T> class CListElement  ===============================*\

\*=========================================================================*/

template<class T>
class CListElement
{
public:
    CListElement()
    {
        m_plhOwner = NULL;
#ifdef DEBUG        
        m_pleNext  = NULL;
        m_plePrev  = NULL;
#endif // DEBUG
    };

#ifdef DEBUG
    ~CListElement()
    {
        Assert(NULL == m_plhOwner);
        Assert(NULL == m_pleNext);
        Assert(NULL == m_plePrev);
    };
#endif

    // The following is used for iterating through a list.
    T * GetNextListElement()
    { return (m_pleNext == m_plhOwner->GetListHead()) ? NULL : m_pleNext; };

    T * GetNextListElementInCircle()
    { return m_pleNext; };

    CListHead<T> * GetListElementOwner() { return m_plhOwner; };
    
private:
    CListHead<T> * m_plhOwner;
    T * m_pleNext;
    T * m_plePrev;

    friend class CListHead<T>;
};



/*$-- CListHead<T>::FIsMember =============================================*\

\*=========================================================================*/

template<class T>
inline
BOOL
CListHead<T>::FIsMember(IN T * ple)
{
    return (this == ple->CListElement<T>::GetListElementOwner());
}


/*$-- CListHead<T>::Prepend ===============================================*\

\*=========================================================================*/

template<class T>
void
CListHead<T>::Prepend(IN T *ple)
{
    Assert(ple);
    Assert(NULL == ple->CListElement<T>::GetListElementOwner());

    if (m_pleHead)
    { // list already has elements case.
        ple->CListElement<T>::m_pleNext = m_pleHead;
        ple->CListElement<T>::m_plePrev = m_pleHead->CListElement<T>::m_plePrev;
        m_pleHead->CListElement<T>::m_plePrev->CListElement<T>::m_pleNext = ple;
        m_pleHead->CListElement<T>::m_plePrev = ple;
    }
    else
    { // this is the first/only element in the list.
        ple->CListElement<T>::m_pleNext = ple;
        ple->CListElement<T>::m_plePrev = ple;
    }
    m_pleHead = ple;  // Prepend, so make this the head of the list.
    
    ple->CListElement<T>::m_plhOwner = this;
	m_cElements++;
}



/*$-- CListHead<T>::Append ================================================*\

\*=========================================================================*/

template<class T>
void
CListHead<T>::Append(IN T *ple)
{
    Assert(ple);
    Assert(NULL == ple->CListElement<T>::GetListElementOwner());
    
    if (m_pleHead)
    { // list already has elements.
        ple->CListElement<T>::m_pleNext = m_pleHead;
        ple->CListElement<T>::m_plePrev = m_pleHead->CListElement<T>::m_plePrev;
        m_pleHead->CListElement<T>::m_plePrev->CListElement<T>::m_pleNext = ple;
        m_pleHead->CListElement<T>::m_plePrev = ple;
    }
    else
    { // this is the first/only element in the list.
        ple->CListElement<T>::m_pleNext = ple;
        ple->CListElement<T>::m_plePrev = ple;
        m_pleHead = ple;
    }
    
    ple->CListElement<T>::m_plhOwner = this;    
	m_cElements++;
}



/*$-- CListHead<T>::Remove ================================================*\

\*=========================================================================*/

template<class T>
void
CListHead<T>::Remove(IN T *ple)
{
    Assert(ple);
    Assert(FIsMember(ple));
    Assert(m_pleHead);
    
    if (ple->CListElement<T>::m_pleNext == ple)  // Are we the only one?
    {
        Assert(m_pleHead == ple);
        Assert(ple->CListElement<T>::m_plePrev == ple);
        m_pleHead = NULL;
    }
    else
    {
        ple->CListElement<T>::m_plePrev->CListElement<T>::m_pleNext = 
            ple->CListElement<T>::m_pleNext;
        ple->CListElement<T>::m_pleNext->CListElement<T>::m_plePrev =
            ple->CListElement<T>::m_plePrev;
        if (m_pleHead == ple)                             // we're we at the head of the list?
            m_pleHead = ple->CListElement<T>::m_pleNext;  // move the next item to head of list.
    }
    
    ple->CListElement<T>::m_plhOwner = NULL;
    
#ifdef DEBUG
    // keep anyone from using these now.
    ple->CListElement<T>::m_pleNext = NULL;
    ple->CListElement<T>::m_plePrev = NULL;
#endif // DEBUG
	
	m_cElements--;
}


#endif  // __BASELIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\calcom.h ===
/*
 *	C A L C O M . H
 *
 *	Simple things, safe for use in ALL of CAL.
 *	Items in this file should NOT require other CAL libs to be linked in!
 *	Items is this file should NOT throw exceptions (not safe in exdav/exoledb).
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_EX_CALCOM_H_
#define _EX_CALCOM_H_

#include <caldbg.h>

//	Useful defines ------------------------------------------------------------
//
//	These are used to declare global and const vars in header files!
//	This means you can do this in a header file:
//
//		DEC_CONST CHAR gc_szFoo[]  = "Foo";
//		DEC_CONST UINT gc_cchszFoo = CchConstString(gc_szFoo);
//
#define DEC_GLOBAL		__declspec(selectany)
#define DEC_CONST		extern const __declspec(selectany)

//	Helper Macros -------------------------------------------------------------
//	CElems -- Count of elements in an array
//	CbSizeWsz -- byte-size of a wide string, including space for final NULL
//
#define CElems(_rg)			(sizeof(_rg)/sizeof(_rg[0]))
#define CbSizeWsz(_cch)		(((_cch) + 1) * sizeof(WCHAR))

//  Const string length -------------------------------------------------------
//
#define CchConstString(_s)  ((sizeof(_s)/sizeof(_s[0])) - 1)

//	The whitespace checker
//
inline
BOOL FIsWhiteSpace ( IN LPCSTR pch )
{
	return 
		*pch == ' ' ||
		*pch == '\t' ||
		*pch == '\r' ||
		*pch == '\n';
}

//	Global enum for DEPTH specification
//	NOTE: Not all values are valid on all calls.
//	I have tried to list the most common values first.
//
enum
{
	DEPTH_UNKNOWN = -1,
	DEPTH_ZERO,
	DEPTH_ONE,
	DEPTH_INFINITY,
	DEPTH_ONE_NOROOT,
	DEPTH_INFINITY_NOROOT,
};

//	Global enum for OVERWRITE/ALLOW-RENAME headers
//	Overwrite_rename is when overwrite header is absent or "f" and allow-reanme header is "t".
//	when overwrite header is explicitly "t", allow-rename is ignored. Combining these two,
//	very much dependent, headers saves us a tag in the DAVEX DIM.
//
enum
{
	OVERWRITE_UNKNOWN = 0,
	OVERWRITE_YES = 0x8,
	OVERWRITE_RENAME = 0x4
};


//	Inline functions to type cast FileTime structures to __int64 and back.
//
//	For safety, these cast using the UNALIGNED keyword to avoid any problems
//	on the Alpha if someone were to do this:
//		struct {
//			DWORD dwFoo;
//			FILETIME ft;
//		}
//	In this case, the FILETIME would be aligned on a 32-bit rather than a
//	64-bit boundary, which would be bad without UNALIGNED!
//
inline
__int64 & FileTimeCastToI64(FILETIME & ft)
{
	return *(reinterpret_cast<__int64 UNALIGNED *>(&ft));
}

inline
FILETIME & I64CastToFileTime(__int64 & i64)
{
	return *(reinterpret_cast<FILETIME UNALIGNED *>(&i64));
}

#endif // _EX_CALCOM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\buffer.h ===
/*
 *	B U F F E R . H
 *
 *	Data buffer processing
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_EX_BUFFER_H_
#define _EX_BUFFER_H_

//	Alignment macros ----------------------------------------------------------
//
#include <align.h>

//	Safe allocators -----------------------------------------------------------
//
#include <ex\exmem.h>

//	Stack buffers -------------------------------------------------------------
//
#include <ex\stackbuf.h>

//	StringSize usage ----------------------------------------------------------
//
//	CbStringSize is the size of the string without the NULL termination
//	CbStringSizeNull is the size of the string with the NULL termination
//	CchStringLength is the length of the string without the NULL termination
//	CchzStringLength is the length of the string with the NULL termination
//
template<class X>
inline int WINAPI CbStringSize(const X* const pszText)
{
	int cch;

	Assert (pszText);

	cch = (sizeof(X) == sizeof(WCHAR))
		  ? wcslen(reinterpret_cast<const WCHAR* const>(pszText))
		  : strlen(reinterpret_cast<const CHAR* const>(pszText));

	return cch * sizeof(X);
}

template<class X>
inline int WINAPI CbStringSizeNull(const X* const pszText)
{
	int cch;

	Assert (pszText);

	cch = (sizeof(X) == sizeof(WCHAR))
		  ? wcslen(reinterpret_cast<const WCHAR* const>(pszText))
		  : strlen(reinterpret_cast<const CHAR* const>(pszText));

	return (cch + 1) * sizeof(X);
}

template<class X>
inline int WINAPI CchStringLength(const X* const pszText)
{
	int cch;

	Assert (pszText);

	cch = (sizeof(X) == sizeof(WCHAR))
		  ? wcslen(reinterpret_cast<const WCHAR* const>(pszText))
		  : strlen(reinterpret_cast<const CHAR* const>(pszText));

	return cch;
}
template<class X>
inline int WINAPI CchzStringLength(const X* const pszText)
{
	int cch;

	Assert (pszText);

	cch = (sizeof(X) == sizeof(WCHAR))
		  ? wcslen(reinterpret_cast<const WCHAR* const>(pszText))
		  : strlen(reinterpret_cast<const CHAR* const>(pszText));

	return cch + 1;
}

//	StringBuffer vs ChainedStringBuffer usage ---------------------------------
//
//	When should you use which one?
//	StringBuffer characteristics:
//	o	Data stored in one contiguous memory block.
//	o	Memory may be realloc'd.
//	o	Only offsets (ib) to strings are returned.
//	ChainedStringBuffer characteristics:
//	o	Memory not contiguous.  Multiple chained buffers.
//	o	Memory is never realloc'd.
//	o	String pointers directly into chained buffers are returned.
//	Both have logarithmic allocation behavior (order log(n) alloc operations
//	will be done, where n is the max size of the data).  This behavior is
//	governed by the m_cbChunkSize starting size and increments.
//

//	StringBuffer template class -----------------------------------------------
//
//	A simple variable-size, demand paged buffer abstraction.
//
template<class T>
class StringBuffer
{
	T *			m_pData;
	UINT		m_cbAllocated;
	UINT		m_cbUsed;
	UINT		m_cbChunkSize;		// Count of bytes to alloc (dynamic).

	enum { CHUNKSIZE_START = 64 };	// Default starting chunk size (in bytes).

	//	Memory allocation mechanism -------------------------------------------
	//
	UINT Alloc( UINT ibLoc, UINT cbAppend )
	{
		//	Grow the data buffer if necessary
		//
		if ( ibLoc + cbAppend > m_cbAllocated )
		{
			T* pData;

			//	Alloc the buffer.
			//
			UINT cbSize = max( m_cbChunkSize, cbAppend );

			if (m_pData)
			{
				pData = static_cast<T*>
						(ExRealloc( m_pData, m_cbAllocated + cbSize ));
			}
			else
			{
				pData = static_cast<T*>
						(ExAlloc( m_cbAllocated + cbSize ));
			}

			//	When we are in the context of the server, our allocators
			//	can fail without throwing.  Bubble the error out.
			//
			if (NULL == pData)
				return static_cast<UINT>(-1);

			m_cbAllocated += cbSize;
			m_pData = pData;

			//	Increase the chunk size, to get "logarithmic allocation behavior"
			//
			m_cbChunkSize *= 2;
		}

		return cbAppend;
	}

	//	non-implemented operators
	//
	StringBuffer(const StringBuffer& );
	StringBuffer& operator=(const StringBuffer& );

public:

	StringBuffer( ULONG cbChunkSize = CHUNKSIZE_START ) :
		m_pData(NULL),
		m_cbAllocated(0),
		m_cbUsed(0),
		m_cbChunkSize(cbChunkSize)
	{
	}

	~StringBuffer()
	{
		ExFree( m_pData );
	}

	//	There is no reason to make it constant on relinquish
	//	we do not own the memory any more
	//
	T * relinquish()
	{
		T * tRet = m_pData;

		m_pData = NULL;
		m_cbUsed = 0;
		m_cbAllocated = 0;

		return tRet;
	}

	const T * PContents() const { return m_pData; }
	UINT CbSize() const			{ return m_cbUsed; }
	UINT CchSize() const		{ return m_cbUsed/sizeof(T); }
	VOID Reset()				{ m_cbUsed = 0; }

	//	Counted type appends --------------------------------------------------
	//
	UINT AppendAt( UINT ibLoc, UINT cbAppend, const T * pAppend)
	{
		UINT cb;
		//	Ensure there is enough memory to hold what is needed
		//
		cb = Alloc( ibLoc, cbAppend );

		//	When we are in the context of the server, our allocators
		//	can fail without throwing.  Bubble the error out.
		//
		if (cb != cbAppend)
			return cb;

		//	Append the data to the buffer
		//
		CopyMemory( reinterpret_cast<LPBYTE>(m_pData) + ibLoc,
					pAppend,
					cbAppend );

		m_cbUsed = ibLoc + cbAppend;
		return cbAppend;
	}

	UINT Append( UINT cbAppend, const T * pAppend )
	{
		return AppendAt( CbSize(), cbAppend, pAppend );
	}

	//	Uncounted appends -----------------------------------------------------
	//
	UINT AppendAt( UINT ibLoc, const T * const pszText )
	{
		return AppendAt( ibLoc, CbStringSize<T>(pszText), pszText );
	}

	UINT Append( const T * const pszText )
	{
		return AppendAt( CbSize(), CbStringSize<T>(pszText), pszText );
	}

	BOOL FAppend( const T * const pszText )
	{
		if (AppendAt( CbSize(), CbStringSize<T>(pszText), pszText ) ==
			static_cast<UINT>(-1))
		{
			return FALSE;
		}
		return TRUE;
	}

	BOOL FTerminate()
	{
		T ch = 0;
		if (AppendAt(CbSize(), sizeof(T), &ch) == static_cast<UINT>(-1))
			return FALSE;
		return TRUE;
	}
};


//	ChainedBuffer template class -----------------------------------------
//
//	A variable-size, demand paged, non-realloc-ing buffer pool abstraction.
//	When would you use this guy? When you need to allocate heap memory for
//	many small data items and would rather do it in sizeable chunks rather
//	than allocate each small data item individually. You need the data to
//	to stay because you are going to point to it (no reallocs are allowed
//	under your feet).
//
//	NOTE: Caller is required to allocate items to be properly aligned if
//	it the item being allocated is an element that requires a specific
//	alignment (ie. struct's).
//
template<class T>
class ChainedBuffer
{
	// CHAINBUF -- Hungarian hb
	//
	struct CHAINBUF
	{
		CHAINBUF * phbNext;
		UINT cbAllocated;
		UINT cbUsed;
		BYTE * pData;
	};

	CHAINBUF *	m_phbData;			// The data.
	CHAINBUF *	m_phbCurrent;		// The current buffer for appends.
	UINT		m_cbChunkSizeInit;	// Initial value of m_cbChunkSize
	UINT		m_cbChunkSize;		// Count of bytes to alloc (dynamic).

	//	Alignments
	//
	UINT		m_uAlign;

	//	Destruction function
	//
	void FreeChainBuf( CHAINBUF * phbBuf )
	{
		while (phbBuf)
		{
			CHAINBUF * phbNext = phbBuf->phbNext;
			ExFree(phbBuf);
			phbBuf = phbNext;
		}
	}

protected:

	enum { CHUNKSIZE_START = 64 };	// Default starting chunk size (in bytes).

public:

	ChainedBuffer( ULONG cbChunkSize = CHUNKSIZE_START,
				   UINT uAlign = ALIGN_NATURAL) :
		m_phbData(NULL),
		m_phbCurrent(NULL),
		m_cbChunkSizeInit(cbChunkSize),
		m_cbChunkSize(cbChunkSize),
		m_uAlign(uAlign)
	{
	}

	~ChainedBuffer() { FreeChainBuf( m_phbData ); }

	//	Alloc a fixed size buffer ---------------------------------------
	//
	T * Alloc( UINT cbAlloc )
	{
		BYTE * pbAdd;

		//	So that we don't do anything stupid....  Make sure we allocate
		//	stuff aligned for the template-parameterized type 'T'.
		//
		cbAlloc = AlignN(cbAlloc, m_uAlign);

		//	Add another data buffer if necessary.
		//
		//	It's necessary if we don't have a buffer, or
		//	if the current buffer doesn't have enough free space.
		//
		if ( ( !m_phbCurrent ) ||
			 ( m_phbCurrent->cbUsed + cbAlloc > m_phbCurrent->cbAllocated ) )
		{
			//	Alloc the new buffer.
			//
			UINT cbSize = max(m_cbChunkSize, cbAlloc);
			CHAINBUF * phbNew = static_cast<CHAINBUF *>
								(ExAlloc( cbSize + sizeof(CHAINBUF) ));

			//	When we are in the context of the server, our allocators
			//	can fail without throwing.  Bubble the error out.
			//
			if (NULL == phbNew)
				return NULL;

			//	Fill in the header fields.
			//
			phbNew->phbNext = NULL;
			phbNew->cbAllocated = cbSize;
			phbNew->cbUsed = 0;
			phbNew->pData = reinterpret_cast<BYTE *>(phbNew) + sizeof(CHAINBUF);

			//	Add the new buffer into the chain.
			//
			if ( !m_phbData )
			{
				Assert(!m_phbCurrent);
				m_phbData = phbNew;
			}
			else
			{
				Assert(m_phbCurrent);
				phbNew->phbNext = m_phbCurrent->phbNext;
				m_phbCurrent->phbNext = phbNew;
			}

			//	Use the new buffer (it is now the current buffer).
			//
			m_phbCurrent = phbNew;

			//	Increase the chunk size, to get "logarithmic allocation behavior".
			//
			m_cbChunkSize *= 2;
		}

		Assert(m_phbCurrent);
		Assert(m_phbCurrent->pData);

		//	Find the correct starting spot in the current buffer.
		//
		pbAdd = m_phbCurrent->pData + m_phbCurrent->cbUsed;

		//	Update our count of bytes actually used.
		//
		m_phbCurrent->cbUsed += cbAlloc;

		//	Return the alloced data's starting point to the caller.
		//
		return reinterpret_cast<T *>(pbAdd);
	}

	//	Clear all buffers -----------------------------------------------------
	//
	void Clear()
	{
		//
		//	Clear out data from, but do not free, the buffers
		//	in the chain.  This allows a ChainedStringBuffer to be
		//	reused without necessarily having to reallocate its
		//	consituent buffers.
		//
		for ( CHAINBUF * phb = m_phbData; phb; phb = phb->phbNext )
			phb->cbUsed = 0;

		//	Free any nodes after the first, they do not get reused
		//	as you might expect.
		//
		if ( m_phbCurrent )
		{
			FreeChainBuf( m_phbCurrent->phbNext );
			m_phbCurrent->phbNext = NULL;
		}

		//
		//	Reset the current buffer to the first one
		//
		m_phbCurrent = m_phbData;

		//
		//	Reset the chunk size to the initial chunk size
		//
		m_cbChunkSize = m_cbChunkSizeInit;
	}

	//	Get the total size of the buffer ---------------------------------------
	//
	DWORD	CbBufferSize() const
	{
		DWORD	cbTotal = 0;

		for ( CHAINBUF * phb = m_phbData; phb; phb = phb->phbNext )
			cbTotal += phb->cbUsed;

		return cbTotal;
	}
	//	Dump the whole buffer contents into a contiguous buffer------------------
	//
	DWORD Dump(T *tBuffer, DWORD cbSize) const
	{
		BYTE	*pbBuffer		= NULL;

		Assert(tBuffer);
        Assert(cbSize >= CbBufferSize());

		pbBuffer = reinterpret_cast<PBYTE>(tBuffer);

		//	walk thru the list and dump all the contents
		//
		for ( CHAINBUF * phb = m_phbData; phb; phb = phb->phbNext )
		{
			memcpy(pbBuffer, phb->pData, phb->cbUsed);
			pbBuffer += phb->cbUsed;
		}
		//	return the actual size
		//
		return static_cast<DWORD>( (pbBuffer) - (reinterpret_cast<PBYTE>(tBuffer)) );
	}
};

//	ChainedStringBuffer template class -----------------------------------------
//
//	A variable-size, demand paged, non-realloc-ing string buffer pool abstraction.
//	Why would you use this guy instead of StringBuffer (above)?
//	If you want the strings to STAY, and you don't care about them being
//	in a contiguous block of memory.
//	NOTE: We still keep the data in order, it's just not all in one block.
//
//	This template is only to be used for CHAR and WCHAR strings.
//	Use the ChainedBuffer template for other types.
//
template<class T>
class ChainedStringBuffer : public ChainedBuffer<T>
{
	//	non-implemented operators
	//
	ChainedStringBuffer(const ChainedStringBuffer& );
	ChainedStringBuffer& operator=(const ChainedStringBuffer& );

public:

	//	Declare constructor inline (for efficiency) but do not provide
	//	a definition here.  Definitions for the two template paramater
	//	types that we support (CHAR and WCHAR) are provided explicitly
	//	below.
	//
	inline ChainedStringBuffer( ULONG cbChunkSize = CHUNKSIZE_START );

	//	Counted append --------------------------------------------------
	//
	T * Append( UINT cbAppend, const T * pAppend )
	{
		T* pAdd;

		//	Reserve the space
		//
		pAdd = Alloc( cbAppend );

		//	When we are in the context of the server, our allocators
		//	can fail without throwing.  Bubble the error out.
		//
		if (NULL == pAdd)
			return NULL;

		//	Append the data to the current buffer.
		//
		CopyMemory( pAdd, pAppend, cbAppend );

		//	Return the data's starting point to the caller.
		//
		return pAdd;
	}

	//	Uncounted append ------------------------------------------------------
	//	NOTE: The append does NOT count the trailing NULL of the string!
	//
	T * Append( const T * const pszText )
	{
		return Append( CbStringSize<T>(pszText), pszText );
	}

	//	Uncounted append with trailing NULL -----------------------------------
	//
	T * AppendWithNull( const T * const pszText )
	{
		return Append( CbStringSizeNull<T>(pszText), pszText );
	}
};

//	Specialized ChainedStringBuffer constructor for CHAR ----------------------
//
//	Pass ALIGN_NONE to the ChainedBuffer constructor because CHAR strings
//	do not require alignment.
//
//	!!! DO NOT use ChainedStringBuffer<CHAR> for anything that must be aligned!
//
inline
ChainedStringBuffer<CHAR>::ChainedStringBuffer( ULONG cbChunkSize )
	: ChainedBuffer<CHAR>(cbChunkSize, ALIGN_NONE )
{
}

//	Specialized ChainedStringBuffer constructor for WCHAR ---------------------
//
//	Pass ALIGN_WORD to the ChainedBuffer constructor because WCHAR strings
//	require WORD alignment.
//
inline
ChainedStringBuffer<WCHAR>::ChainedStringBuffer( ULONG cbChunkSize )
	: ChainedBuffer<WCHAR>(cbChunkSize, ALIGN_WORD )
{
}

//	LinkedBuffer template class -----------------------------------------------
//
//	A variable-size, demand paged, non-realloc-ing buffer pool abstraction.
//	When would you use this guy? When you need to allocate heap memory for
//	many small data items and would rather do it in sizeable chunks rather
//	than allocate each small data item individually and the resulting pointer
//	you need to pass into the store needs to be "linked".
//
//	IMPORTANT:
//
//	Linked allocation mechanism is stolen from \store\src\_util\mdbmig.cxx
//	and needs to always match that mechanism.
//
PVOID ExAllocLinked(LPVOID pvLinked, UINT cb);
VOID ExFreeLinked(LPVOID* ppv);

template<class T>
class LinkedBuffer
{
	PVOID m_pvHead;
	PVOID PvAllocLinked(UINT cb)
	{
		PVOID pv = ExAllocLinked(m_pvHead, cb);

		if (NULL == m_pvHead)
			m_pvHead = pv;

		return pv;
	}

public:

	LinkedBuffer() : m_pvHead(NULL)
	{
	}

	~LinkedBuffer()
	{
		if (m_pvHead)
			ExFreeLinked(&m_pvHead);
	}

	//	Alloc a fixed size buffer ---------------------------------------
	//
	T * Alloc( UINT cbAlloc )
	{
		return reinterpret_cast<T*>(PvAllocLinked (cbAlloc));
	}

	PVOID PvTop() { Assert (m_pvHead); return m_pvHead; }
	PVOID relinquish()
	{
		PVOID pv = m_pvHead;
		m_pvHead = NULL;
		return pv;
	}
	void clear()
	{
		if (m_pvHead)
		{
			ExFreeLinked(&m_pvHead);
			m_pvHead = NULL;
		}
	}
	void takeover ( LinkedBuffer<T> & lnkbufOldOwner )
	{
		m_pvHead = lnkbufOldOwner.m_pvHead;
		lnkbufOldOwner.m_pvHead = NULL;
	}
};

#endif // _EX_BUFFER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\cnvt.h ===
/*
 *	C N V T . H
 *
 *	Data conversion routines
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_CNVT_H_
#define _CNVT_H_

#include <ex\sz.h>
#include <crc.h>
#include <limits.h>
#define INT64_MIN 0x8000000000000000

//	Error return value for CchFindChar()
//
#define INVALID_INDEX ((UINT)(-1))

//	Conversion functions ------------------------------------------------------
//
UINT __fastcall CchFindChar(WCHAR, LPCWSTR, UINT);
UINT __fastcall CchSkipWhitespace(LPCWSTR, UINT);
LONG __fastcall LNumberFromParam(LPCWSTR, UINT);

HRESULT __fastcall HrHTTPDateToFileTime(LPCWSTR, FILETIME *);
HRESULT	__fastcall GetFileTimeFromParam(LPCWSTR, UINT, SYSTEMTIME *);
HRESULT __fastcall GetFileDateFromParam(LPCWSTR, UINT, SYSTEMTIME *);

BOOL __fastcall FGetSystimeFromDateIso8601(LPCWSTR, SYSTEMTIME *);
BOOL __fastcall FGetDateIso8601FromSystime(SYSTEMTIME *, LPWSTR, UINT);
BOOL __fastcall FGetDateRfc1123FromSystime(SYSTEMTIME *, LPWSTR, UINT);

VOID EncodeBase64 (LPBYTE pbIn, UINT cbIn, WCHAR* pwszOut, UINT cchOut);
VOID EncodeBase64A (LPBYTE pbIn, UINT cbIn, LPBYTE pbOut, UINT cbOut, BOOL fTerminate = TRUE);
SCODE ScDecodeBase64 (WCHAR* pwszIn, UINT cchIn, LPBYTE pbOut, UINT* pcbOut);

//	------------------------------------------------------------------------
//	CchNeededEncodeBase64
//
//	Figure the size of the string buffer needed to encode binary data of the
//	given size into a Base64 string.
//	Base64 uses 4 chars out for each 3 bytes in, AND if there is ANY
//	"remainder", it needs another 4 chars to encode the remainder.
//	("+2" BEFORE "/3" ensures that we count any remainder as a whole
//	set of 3 bytes that need 4 chars to hold the encoding.)
//
//	NOTE: This function does NOT count space for the terminating NULL.
//	The caller must add one for the terminating NULL, if desired.
//
inline
UINT
CchNeededEncodeBase64 (UINT cb)
{
	return (((cb + 2) / 3) * 4);
}


//	------------------------------------------------------------------------
//	CbNeededDecodeBase64
//
//	Figure the number of bytes of space needed to decode a Base64 string
//	of length cch (NOT counting terminal NULL -- pure strlen cch here).
//	This is the easy direction -- the padding is already in the cch!
//
inline
UINT
CbNeededDecodeBase64 (UINT cch)
{
	return ((cch / 4) * 3);
}

//	------------------------------------------------------------------------
//	CopyToWideBase64
//
//	Copy skinny base64 encoded string into the wide base64 encoded string
//	of length equal to cb. Function assumes that there is a '\0' termination
//	straight at the end that is to be copied too
//
inline
VOID CopyToWideBase64(LPCSTR psz, LPWSTR pwsz, UINT cb)
{
	//	Include '\0' termination
	//
	cb++;

	//	Copy all the stuff to the wide string
	//
	while (cb--)
	{
		pwsz[cb] = psz[cb];
	}
}

//$REVIEW: The following three do not really does not belong to any common libraries 
//$REVIEW: that are shared by davex, exdav, exoledb and exprox. 
//$REVIEW: On the other hand, we definitely don't want add a new lib for this. so just
//$REVIEW: add it here. Feel free to move them to a better location if you find one
//
//	Routines to fetch and manipulate security IDs (SIDs)
//
SCODE
ScDupPsid (PSID psidSrc,
		   DWORD dwcbSID,
		   PSID * ppsidDst);

SCODE
ScGetTokenInfo (HANDLE hTokenUser,
				DWORD * pdwcbSIDUser,
				PSID * ppsidUser);

//	CRCSid:	A SID based key.
//
class CRCSid
{
public:

	DWORD	m_dwCRC;
	DWORD	m_dwLength;
	PSID	m_psid;

	CRCSid (PSID psid)
			: m_psid(psid)
	{
		UCHAR* puch;
		Assert (psid);

		//	"Right way" -- since MSDN says not to touch the SID directly.
		puch = GetSidSubAuthorityCount (psid);
		m_dwLength = GetSidLengthRequired (*puch);	// "cannot fail" -- MSDN
		Assert (m_dwLength);	// MSDN said this call "cannot fail".

		m_dwCRC = DwComputeCRC (0,
								psid,
								m_dwLength);
	}

	//	operators for use with the hash cache
	//
	int hash (const int rhs) const
	{
		return (m_dwCRC % rhs);
	}

	bool isequal (const CRCSid& rhs) const
	{
		return ((m_dwCRC == rhs.m_dwCRC) &&
				(m_dwLength == rhs.m_dwLength) &&
				!memcmp (m_psid, rhs.m_psid, m_dwLength));
	}
};

//$REVIEW: These functions are needed by _storext, exdav and davex. They have
//	moved quite a bit, going from calcprops.cpp to exprops.cpp and now to 
//	cnvt.cpp. cnvt.cpp seems to be a better destination for them than 
//	exprops.cpp. I bet these functions look awfully similar to some of 
//	the ones already in this file:-)
//
SCODE ScUnstringizeData (
	IN LPCSTR pchData,
	IN UINT cchData,
	IN OUT BYTE * pb,
	IN OUT UINT * pcb);

SCODE
ScStringizeData (IN const BYTE * pb,
				 IN const UINT cb,
				 OUT LPSTR psz,
				 IN OUT UINT * pcch);

SCODE
ScStringizeDataW (	IN const BYTE * pb,
					IN const UINT cb,
					OUT LPWSTR pwsz,
					IN OUT UINT * pcch);

inline
BOOL
FCharInHexRange (char ch)
{
	return ((ch >= '0' && ch <= '9') ||
			(ch >= 'A' && ch <= 'F') ||
			(ch >= 'a' && ch <= 'f'));
}

//	Our own version of WideCharToMultiByte(CP_UTF8, ...)
//
//	It returns similarly to the system call WideCharToMultiByte:
//
//	If the function succeeds, and cbMulti is nonzero, the return value is
//	the number of bytes written to the buffer pointed to by psz. 
//
//	If the function succeeds, and cbMulti is zero, the return value is
//	the required size, in bytes, for a buffer that can receive the translated
//	string. 
//
//	If the function fails, the return value is zero. To get extended error
//	information, call GetLastError. GetLastError may return one of the
//	following error codes:
//
//	ERROR_INSUFFICIENT_BUFFER
//	ERROR_INVALID_FLAGS
//	ERROR_INVALID_PARAMETER
//
//	See the WideCharToMultiByte MSDN pages to find out more about
//	this function and its use. The only difference is that INVALID_INDEX
//	should be used instead of -1.
//
UINT WideCharToUTF8(/* [in]  */ LPCWSTR	pwsz,
				    /* [in]  */ UINT	cchWide,
				    /* [out] */ LPSTR	psz,
				    /* [in]  */ UINT	cbMulti);

//$	REVIEW: negative values of _int64 seem to have problems in
//	the __i64toa() API.  Handle those cases ourselves by using the wrapper
//  function Int64ToPsz.
//
inline
VOID
Int64ToPsz (UNALIGNED __int64 * pI64, LPSTR pszBuf, UINT cbBuf)
{
	Assert(pI64);
	Assert(pszBuf);
	Assert(cbBuf >= 64);
	BOOL fNegative = (*pI64 < 0);

	//  Note:  this workaround works for all cases except the
	//  most negative _int64 value (because it can't be inverted).
	//  Luckily __i64toa works for this case...
	//
	if (INT64_MIN == *pI64) 
		fNegative = FALSE;

	if (fNegative)
	{
		//	Stuff a negative sign into the buffer and
		//	then fix the value.
		//
		pszBuf[0] = '-';
		*pI64 = 0 - *pI64;
	}
	
	Assert ((0 == fNegative) || (1 == fNegative));
	_i64toa (*pI64, pszBuf + fNegative, 10);
}

//$	REVIEW: negative values of _int64 seem to have problems in
//	the __i64tow() API.  Handle those cases ourselves by using the wrapper
//  function Int64ToPwsz.
//
inline
VOID
Int64ToPwsz (UNALIGNED __int64 * pI64, LPWSTR pwszBuf, UINT cbBuf)
{
	Assert(pI64);
	Assert(pwszBuf);
	Assert(cbBuf >= 64 * sizeof(WCHAR));
	
	BOOL fNegative = (*pI64 < 0);	

	//  Note:  this workaround works for all cases except the
	//  most negative _int64 value (because it can't be inverted).
	//  Luckily __i64tow works for this case...
	//
	if (INT64_MIN == *pI64) 
		fNegative = FALSE;

	if (fNegative)
	{
		//	Stuff a negative sign into the buffer and
		//	then fix the value.
		//
		pwszBuf[0] = L'-';
		*pI64 = 0 - *pI64;
	}
	
	Assert ((0 == fNegative) || (1 == fNegative));
	_i64tow (*pI64, pwszBuf + fNegative, 10);
}


#endif // _CNVT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\gencache.h ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	GENCACHE.H
//
//		Header for generic cache classes.
//
//	Copyright 1997-1998 Microsoft Corporation, All Rights Reserved
//

//	Documenting my dependencies
//	These must be included BEFORE this file is included.
//#include "caldbg.h"
//#include "autoptr.h"

#ifndef _EX_GENCACHE_H_
#define _EX_GENCACHE_H_

#pragma warning(disable:4200)	// zero-sized array

//	Exdav-safe allocators --------------------------------------------------
//
//	The classed declared here use the EXDAV-safe allocators (ExAlloc, ExFree)
//	for all allocations.
//	NOTE: These allocators can FAIL.  You must check for failure on
//	ExAlloc and ExRealloc!
//
#include <ex\exmem.h>
#include <align.h>

//	========================================================================
//
//	TEMPLATE CLASS CPoolAllocator
//
//	A generic type-specific pool allocator template.  Items in the pool
//	are allocated in chunks and handed out upon request.
//	Items are recycled on a free chain.
//	All items are the same size, so reuse is relatively easy.
//
//	NOTE: I have NOT optimized the heck out of this thing.  To really
//	optimize locality of mem usage, we'd want to always grow & shrink
//	"at the tail".  To that end, I always check the freechain first --
//	reuse an item before using a new one from the current buffer.
//	More optimization would require sorting the freechain & stuff.
//
template<class T>
class CPoolAllocator
{
	//	CHAINBUFHDR ----------------------------------------
	//	Header struct for chaining together pool buffers.
	//
	struct CHAINBUFHDR
	{
		CHAINBUFHDR * phbNext;
		int cItems;
		int cItemsUsed;
		// Remainder of buffer is set of items of type T.
		T rgtPool[0];
		// Just to quiet our noisy compiler.
		CHAINBUFHDR() {};
		~CHAINBUFHDR() {};
	};

	//	CHAINITEM ------------------------------------------
	//	Struct "applied over" free items to chain them together.
	//	The actual items MUST be large enough to accomodate this.
	//
	struct CHAINITEM
	{
		CHAINITEM * piNext;
	};

	//	Chain of buffers.
	CHAINBUFHDR * m_phbCurrent;
	//	Chain of free'd items to reuse.
	CHAINITEM * m_piFreeChain;
	//	Size of chunk to alloc.
	int m_ciChunkSize;

	//	Constant (enum) for our default starting chunk size (in items).
	//
	enum { CHUNKSIZE_START = 20 };

public:

	//	Constructor takes count of items for initial chunk size.
	//
	CPoolAllocator (int ciChunkSize = CHUNKSIZE_START) :
		m_phbCurrent(NULL),
		m_piFreeChain(NULL),
		m_ciChunkSize(ciChunkSize)
	{
		//	A CHAINITEM struct will be "applied over" free items to chain
		//	them together.
		//	The actual items MUST be large enough to accomodate this.
		//
		Assert (sizeof(T) >= sizeof(CHAINITEM));
	};
	~CPoolAllocator()
	{
		//	Walk the list of blocks we allocated and free them.
		//
		while (m_phbCurrent)
		{
			CHAINBUFHDR * phbTemp = m_phbCurrent->phbNext;
			ExFree (m_phbCurrent);
			m_phbCurrent = phbTemp;
		}
	}

	//	------------------------------------------------------------------------
	//	GetItem
	//	Return an item from the pool to our caller.
	//	We get the item from the free chain, or from the next block of items.
	//
	T * GetItem()
	{
		T * ptToReturn;

		if (m_piFreeChain)
		{
			//	The free chain is non-empty.  Return the first item here.
			//
			ptToReturn = reinterpret_cast<T *>(m_piFreeChain);
			m_piFreeChain = m_piFreeChain->piNext;
		}
		else
		{
			//	The free chain is empty.  We must grab a never-used item from
			//	the current block.
			//
			if (!m_phbCurrent ||
				(m_phbCurrent->cItemsUsed == m_phbCurrent->cItems))
			{
				//	There are no more items in the current block.
				//	Allocate a whole new block of items.
				//
				CHAINBUFHDR * phbNew = static_cast<CHAINBUFHDR *>(
					ExAlloc (sizeof(CHAINBUFHDR) +
							 (m_ciChunkSize * sizeof(T))));
				//	The allocators CAN FAIL.  Handle this case!
				if (!phbNew)
					return NULL;
				phbNew->cItems = m_ciChunkSize;
				phbNew->cItemsUsed = 0;
				phbNew->phbNext = m_phbCurrent;
				m_phbCurrent = phbNew;
			}

			//	Now we should have a block with an unused item for us to return.
			//
			Assert (m_phbCurrent &&
					(m_phbCurrent->cItemsUsed < m_phbCurrent->cItems));
			ptToReturn = & m_phbCurrent->rgtPool[ m_phbCurrent->cItemsUsed++ ];
		}
		Assert (ptToReturn);
		return ptToReturn;
	}

	//	------------------------------------------------------------------------
	//	FreeItem
	//	The caller is done with this item.  Add it to our free chain.
	//
	void FreeItem (T * pi)
	{
		//	Add the item to the free chain.
		//	To do this without allocating more memory, we use the item's
		//	storage to hold our next-pointer.
		//	The actual items MUST be large enough to accomodate this.
		//
		reinterpret_cast<CHAINITEM *>(pi)->piNext = m_piFreeChain;
		m_piFreeChain = reinterpret_cast<CHAINITEM *>(pi);
	}

};



//	========================================================================
//
//	TEMPLATE CLASS CCache
//
//	A generic hash cache template.  Items in the cache uniquely map keys of
//	type _K to values of type _Ty.  Keys and values are copied when
//	they are added to the cache; there is no "ownership".
//
//	The key (type _K) must provide methods hash and isequal.  These methods
//	will be used to hash and compare the keys.
//
//
//	Add()
//		Adds an item (key/value pair) to the cache.  Returns a reference
//		to the added item's value.
//
//	Set()
//		Sets an item's value, adding the item if it doesn't already exist.
//		Returns a reference to the added item's value.
//
//	Lookup()
//		Looks for an item with the specified key.  If the item exists,
//		returns a pointer to its value, otherwise returns NULL.
//
//	FFetch()
//		Boolean version of Lookup().
//
//	Remove()
//		Removes the item associated with a particular key.
//		Does nothing if there is no item with that key.
//
//	Clear()
//		Removes all items from the cache.
//
//	ForEach()
//		Applies an operation, specified by an operator object passed in
//		as a parameter, to all of the items in the cache.
//
//	ForEachMatch()
//		Applies an operation, specified by an operator object passed in
//		as a parameter, to each item in the cache that matches the provided key.
//
//	Additional functions proposed
//	Rehash - currently ITP only
//		Resize the table & re-add all items.
//	DumpCacheUsage() - NYI
//		Dump the bookkeeping data about the cache.
//
template<class _K, class _Ty>
class CCache
{
	//	---------------------------------------------------------------------
	//	Cache Entry structures
	//
	struct Entry
	{
		struct Entry * peNext;
		_K key;
		_Ty data;
#ifdef	DBG
		BOOL fValid;		// Is this entry valid?
#endif	// DBG

		//	CONSTRUCTORS
		Entry (const _K& k, const _Ty& d) :
				key(k),
				data(d)
		{
		};
		//
		// The following is to get around the fact that the store has
		//   defined a "new" macro which makes using the new operator to
		//   do in place initialization very difficult
		//
		void EntryInit (const _K& k, const _Ty& d) {
			key = k;
			data = d;
		};
	};

	struct TableEntry	//HashLine
	{
		BOOL fLineValid;			// Is this cache line valid?
		Entry * peChain;
#ifdef DBG
		int cEntries;				// Number of entries in this line in the cache.
		mutable BYTE cAccesses;		// Bookkeeping
#endif // DBG
	};

	//	---------------------------------------------------------------------
	//	The hash table data
	//
	int m_cSize;			// Size of the hash table.
	auto_heap_ptr<TableEntry> m_argTable;	// The hash table.
	int m_cItems;			// Current number of items in the cache.

	//	---------------------------------------------------------------------
	//	Pool allocator to alloc nodes
	//
	CPoolAllocator<Entry> m_poolalloc;

	//	---------------------------------------------------------------------
	//	Constant (enum) for our default initial count of lines in the cache.
	//	NOTE: Callers should really pick their own best size.
	//	This size is prime to try to force fewer collisions.
	//
	enum { CACHESIZE_START = 37 };

#ifdef	DBG
	//	---------------------------------------------------------------------
	//	Bookkeeping bits
	//
	int m_cCollisions;		//	Adds that hit the same chain
	mutable int m_cHits;	//	Lookup/Set hits
	mutable int m_cMisses;	//	Lookup/Set misses
#endif	// DBG


	//	---------------------------------------------------------------------
	//	Helper function to build the table
	//
	BOOL FBuildTable()
	{
		Assert (!m_argTable.get());

		//	Allocate space for the number of cache lines we need (m_cSize).
		//
		m_argTable = reinterpret_cast<TableEntry *>(ExAlloc (
			m_cSize * sizeof(TableEntry)));
		//	The allocators CAN FAIL.  Handle this case!
		if (!m_argTable.get())
			return FALSE;
		ZeroMemory (m_argTable.get(), m_cSize * sizeof(TableEntry));
		return TRUE;
	}

	//	---------------------------------------------------------------------
	//	CreateEntry
	//	Create a new entry to add to the cache.
	//
	Entry * CreateEntry(const _K& k, const _Ty& d)
	{
		Entry * peNew = m_poolalloc.GetItem();
		//	The allocators CAN FAIL.  Handle this case!
		if (!peNew)
			return NULL;
		ZeroMemory (peNew, sizeof(Entry));
//		peNew = new (peNew) Entry(k,d);
		peNew->EntryInit (k,d);
#ifdef	DBG
		peNew->fValid = TRUE;
#endif	// DBG
		return peNew;
	}

	void DeleteEntry(Entry * pe)
	{
		pe->~Entry();
#ifdef	DBG
		pe->fValid = FALSE;
#endif	// DBG
		m_poolalloc.FreeItem (pe);
	}

	//	NOT IMPLEMENTED
	//
	CCache (const CCache&);
	CCache& operator= (const CCache&);

public:
	//	=====================================================================
	//
	//	TEMPLATE CLASS IOp
	//
	//		Operator base class interface used in ForEach() operations
	//		on the cache.
	//		The operator can return FALSE to cancel iteration, or TRUE to
	//		continue walking the cache.
	//
	class IOp
	{
		//	NOT IMPLEMENTED
		//
		IOp& operator= (const IOp&);

	public:
		virtual BOOL operator() (const _K& key,
								 const _Ty& value) = 0;
	};

	//	=====================================================================
	//
	//	CREATORS
	//
	CCache (int cSize = CACHESIZE_START) :
			m_cSize(cSize),
			m_cItems(0)
	{
		Assert (m_cSize);	// table size of zero is invalid!
							// (and would cause div-by-zero errors later!)
#ifdef DBG
		m_cCollisions = 0;
		m_cHits = 0;
		m_cMisses = 0;
#endif // DBG
	};
	~CCache()
	{
		//	If we have a table (FInit was successfully called), clear it.
		//
		if (m_argTable.get())
			Clear();
		//	Auto-pointer will clean up the table.
	};

	BOOL FInit()
	{
		//	Set up the cache with the provided initial size.
		//	When running under the store (exdav.dll) THIS CAN FAIL!
		//
		return FBuildTable();
	}

	//	=====================================================================
	//
	//	ACCESSORS
	//

	//	--------------------------------------------------------------------
	//	CItems
	//	Returns the number of items in the cache.
	//
	int CItems() const
	{
		return m_cItems;
	}

	//	--------------------------------------------------------------------
	//	Lookup
	//	Find the first item in the cache that matches this key.
	//	key.hash is used to find the correct line of the cache.
	//	key.isequal is called on each item in the collision chain until a
	//	match is found.
	//
	_Ty * Lookup (const _K& key) const
	{
		//	Find the index of the correct cache line for this key.
		//
		int iHash = key.hash(m_cSize);

		Assert (iHash < m_cSize);
		Assert (m_argTable.get());
#ifdef	DBG
		TableEntry * pte = &m_argTable[iHash];
		pte->cAccesses++;
#endif	// DBG

		//	Do we have any entries in this cache line?
		//	If this cache line is not valid, we have no entries -- NOT found.
		//
		if (m_argTable[iHash].fLineValid)
		{
			Entry * pe = m_argTable[iHash].peChain;
			while (pe)
			{
				Assert (pe->fValid);

				if (key.isequal (pe->key))
				{
#ifdef	DBG
					m_cHits++;
#endif	// DBG
					return &pe->data;
				}
				pe = pe->peNext;
			}
		}

#ifdef	DBG
		m_cMisses++;
#endif	// DBG

		return NULL;
	}

	//	--------------------------------------------------------------------
	//	FFetch
	//	Boolean-returning wrapper for Lookup.
	//
	BOOL FFetch (const _K& key, _Ty * pValueRet) const
	{
		_Ty * pValueFound = Lookup (key);
		if (pValueFound)
		{
			*pValueRet = *pValueFound;
			return TRUE;
		}

		return FALSE;
	}

	//	--------------------------------------------------------------------
	//	ForEach
	//	Seek through the cache, calling the provided operator on each item.
	//	The operator can return FALSE to cancel iteration, or TRUE to continue
	//	walking the cache.
	//
	//	NOTE: This function is built to allow deletion of the item being
	//	visited (see the comment inside the while loop -- fetch a pointer
	//	to the next item BEFORE calling the visitor op), BUT other
	//	deletes and adds are not "supported" and will have undefined results.
	//	Two specific disaster scenarios:  delete of some other item could
	//	actually delete the item we pre-fetched, and we will crash on the
	//	next time around the loop.  add of any item during the op callback
	//	could end up adding the item either before or after our current loop
	//	position, and thus might get visited, or might not.
	//
	void ForEach (IOp& op) const
	{
		//	If we don't have any items, quit now!
		//
		if (!m_cItems)
			return;

		Assert (m_argTable.get());

		//	Loop through all items in the cache, calling the
		//	provided operator on each item.
		//
		for (int iHash = 0; iHash < m_cSize; iHash++)
		{
			//	Look for valid cache entries.
			//
			if (m_argTable[iHash].fLineValid)
			{
				Entry * pe = m_argTable[iHash].peChain;
				while (pe)
				{
					//	To support deleting inside the op,
					//	fetch the next item BEFORE calling the op.
					//
					Entry * peNext = pe->peNext;

					Assert (pe->fValid);

					//	Found a valid entry.  Call the operator.
					//	If the operator returns TRUE, keep looping.
					//	If he returns FALSE, quit the loop.
					//
					if (!op (pe->key, pe->data))
						return;

					pe = peNext;
				}
			}
		}
	}

	//	--------------------------------------------------------------------
	//	ForEachMatch
	//	Seek through the cache, calling the provided operator on each item
	//	that has a matching key.  This is meant to be used with a cache
	//	that may have duplicate items.
	//	The operator can return FALSE to cancel iteration, or TRUE to continue
	//	walking the cache.
	//
	void ForEachMatch (const _K& key, IOp& op) const
	{
		//	If we don't have any items, quit now!
		//
		if (!m_cItems)
			return;

		//	Find the index of the correct cache line for this key.
		//
		int iHash = key.hash(m_cSize);

		Assert (iHash < m_cSize);
		Assert (m_argTable.get());
#ifdef	DBG
		TableEntry * pte = &m_argTable[iHash];
		pte->cAccesses++;
#endif	// DBG

		//	Only process if this row of the cache is valid.
		//
		if (m_argTable[iHash].fLineValid)
		{
			//	Loop through all items in this row of the cache, calling the
			//	provided operator on each item.
			//
			Entry * pe = m_argTable[iHash].peChain;
			while (pe)
			{
				//	To support deleting inside the op,
				//	fetch the next item BEFORE calling the op.
				//
				Entry * peNext = pe->peNext;

				Assert (pe->fValid);

				if (key.isequal (pe->key))
				{
					//	Found a matching entry.  Call the operator.
					//	If the operator returns TRUE, keep looping.
					//	If he returns FALSE, quit the loop.
					//
					if (!op (pe->key, pe->data))
						return;
				}

				pe = peNext;
			}
		}
	}

	//	=====================================================================
	//
	//	MANIPULATORS
	//

	//	--------------------------------------------------------------------
	//	FSet
	//	Reset the value of an item in the cache, adding it if the item
	//	does not yet exist.
	//
	BOOL FSet (const _K& key, const _Ty& value)
	{
		//	Find the index of the correct cache line for this key.
		//
		int iHash = key.hash (m_cSize);

		Assert (iHash < m_cSize);
		Assert (m_argTable.get());
#ifdef	DBG
		TableEntry * pte = &m_argTable[iHash];
		pte->cAccesses++;
#endif	// DBG

		//	Look for valid cache entries.
		//
		if (m_argTable[iHash].fLineValid)
		{
			Entry * pe = m_argTable[iHash].peChain;
			while (pe)
			{
				Assert (pe->fValid);

				if (key.isequal (pe->key))
				{
#ifdef	DBG
					m_cHits++;
#endif	// DBG
					pe->data = value;
					return TRUE;
				}
				pe = pe->peNext;
			}
		}

#ifdef	DBG
		m_cMisses++;
#endif	// DBG

		//	The items does NOT exist in the cache.  Add it now.
		//
		return FAdd (key, value);
	}

	//	--------------------------------------------------------------------
	//	FAdd
	//	Add an item to the cache.
	//	WARNING: Duplicate keys will be blindly added here!  Use FSet()
	//	if you want to change the value for an existing item.  Use Lookup()
	//	to check if a matching item already exists.
	//$LATER: On DBG, scan the list for duplicate keys.
	//
	BOOL FAdd (const _K& key, const _Ty& value)
	{
		//	Create a new element to add to the chain.
		//	NOTE: This calls the copy constructors for the key & value!
		//
		Entry * peNew = CreateEntry (key, value);
		//	The allocators CAN FAIL.  Handle this case!
		if (!peNew)
			return FALSE;

		//	Find the index of the correct cache line for this key.
		//
		int iHash = key.hash (m_cSize);

		Assert (iHash < m_cSize);
		Assert (m_argTable.get());
#ifdef	DBG
		TableEntry * pte = &m_argTable[iHash];
		pte->cEntries++;
		if (m_argTable[iHash].peChain)
			m_cCollisions++;
		else
			pte->cAccesses = 0;
#endif	// DBG

		//	Link this new element into the chain.
		//
		peNew->peNext = m_argTable[iHash].peChain;
		m_argTable[iHash].peChain = peNew;

		m_argTable[iHash].fLineValid = TRUE;
		m_cItems++;

		return TRUE;
	}

	//	--------------------------------------------------------------------
	//	Remove
	//	Remove an item from the cache.
	//$REVIEW: Does this need to return a "found" boolean??
	//
	void Remove (const _K& key)
	{
		//	Find the index of the correct cache line for this key.
		//
		int iHash = key.hash (m_cSize);

		Assert (iHash < m_cSize);
		Assert (m_argTable.get());
#ifdef	DBG
		TableEntry * pte = &m_argTable[iHash];
		pte->cAccesses++;
#endif	// DBG

		//	If this cache line is not valid, we have no entries --
		//	nothing to remove.
		//
		if (m_argTable[iHash].fLineValid)
		{
			Entry * pe = m_argTable[iHash].peChain;
			Entry * peNext = pe->peNext;
			Assert (pe->fValid);

			//	Delete first item in chain.
			//
			if (key.isequal (pe->key))
			{
				//	Snip the item to delete (pe) out of the chain.
				m_argTable[iHash].peChain = peNext;
				if (!peNext)
				{
					//	We deleted the last item.  This line is empty.
					//
					m_argTable[iHash].fLineValid = FALSE;
				}

				//	Delete entry to destroy the copied data (value) object.
				DeleteEntry (pe);
				m_cItems--;
#ifdef	DBG
				pte->cEntries--;
#endif	// DBG
			}
			else
			{
				//	Lookahead compare & delete.
				//
				while (peNext)
				{
					Assert (peNext->fValid);

					if (key.isequal (peNext->key))
					{
						//	Snip peNext out of the chain.
						pe->peNext = peNext->peNext;

						//	Delete entry to destroy the copied data (value) object.
						DeleteEntry (peNext);
						m_cItems--;
#ifdef	DBG
						pte->cEntries--;
#endif	// DBG
						break;
					}
					//	Advance
					pe = peNext;
					peNext = pe->peNext;
				}
			}
		}
	}

	//	--------------------------------------------------------------------
	//	Clear
	//	Clear all items from the cache.
	//	NOTE: This does not destroy the table -- the cache is still usable
	//	after this call.
	//
	void Clear()
	{
		if (m_argTable.get())
		{
			//	Walk the cache, checking for valid lines.
			//
			for (int iHash = 0; iHash < m_cSize; iHash++)
			{
				//	If the line if valid, look for items to clear out.
				//
				if (m_argTable[iHash].fLineValid)
				{
					Entry * pe = m_argTable[iHash].peChain;
					//	The cache line was marked as valid.  There should be
					//	at least one item here.
					Assert (pe);

					//	Walk the chain of items in this cache line.
					//
					while (pe)
					{
						Entry * peTemp = pe->peNext;
						Assert (pe->fValid);
						//	Delete entry to destroy the copied data (value) object.
						DeleteEntry (pe);
						pe = peTemp;
					}
				}

				//	Clear out our cache line.
				//
				m_argTable[iHash].peChain = NULL;
				m_argTable[iHash].fLineValid = FALSE;

#ifdef	DBG
				//	Clear out the bookkeeping bits in the cache line.
				//
				m_argTable[iHash].cEntries = 0;
				m_argTable[iHash].cAccesses = 0;
#endif	// DBG
			}

			//	We have no more items.
			//
			m_cItems = 0;
		}
	}

#ifdef	ITP_USE_ONLY
	//	---------------------------------------------------------------------
	//	Rehash
	//	Re-allocates the cache's hash table and re-hashes all items.
	//	NOTE: If this call fails (due to memory failure), the old hash table
	//	is restored so that we don't lose any the items.
	//	**RA** This call has NOT been tested in production (shipping) code!
	//	**RA** It is provided here for ITP use only!!!
	//
	BOOL FRehash (int cNewSize)
	{
		Assert (m_argTable.get());

		//	Swap out the old table and build a new one.
		//
		auto_heap_ptr<TableEntry> pOldTable ( m_argTable.relinquish() );
		int cOldSize = m_cSize;

		Assert (pOldTable.get());
		m_cSize = cNewSize;

		if (!FBuildTable())
		{
			Assert (pOldTable.get());
			Assert (!m_argTable.get());

			//	Restore the old table.
			//
			m_cSize = cOldSize;
			m_argTable = pOldTable.relinquish();
			return FALSE;
		}

		//	If no items in the cache, we're done!
		//
		if (!m_cItems)
		{
			return TRUE;
		}

		//	Loop through all items in the cache (old table), placing them
		//	into the new table.
		//
		for ( int iHash = 0; iHash < cOldSize; iHash++ )
		{
			//	Look for valid cache entries.
			//
			if (pOldTable[iHash].fLineValid)
			{
				Entry * pe = pOldTable[iHash].peChain;
				while (pe)
				{
					//	Keep track of next item.
					Entry * peNext = pe->peNext;

					Assert (pe->fValid);

					//	Found a valid entry.  Place it in the new hash table.
					//
					int iHashNew = pe->key.hash (m_cSize);
					pe->peNext = m_argTable[iHashNew].peChain;
					m_argTable[iHashNew].peChain = pe;
					m_argTable[iHashNew].fLineValid = TRUE;
#ifdef	DBG
					m_argTable[iHashNew].cEntries++;
#endif	// DBG
					pe = peNext;
				}
			}
		}

		//	We're done re-filling the cache.
		//
		return TRUE;
	}
#endif	// ITP_USE_ONLY

};


//	========================================================================
//	COMMON KEY CLASSES
//	========================================================================

//	========================================================================
//	class DwordKey
//		Key class for any dword data that can be compared with ==.
//
class DwordKey
{
private:
	DWORD m_dw;

public:
	DwordKey (DWORD dw) : m_dw(dw) {}

	DWORD Dw() const
	{
		return m_dw;
	}

	int DwordKey::hash (const int rhs) const
	{
		return (m_dw % rhs);
	}

	bool DwordKey::isequal (const DwordKey& rhs) const
	{
		return (rhs.m_dw == m_dw);
	}
};

//	========================================================================
//	class PvoidKey
//		Key class for any pointer data that can be compared with ==.
//
class PvoidKey
{
private:
	PVOID m_pv;

public:
	PvoidKey (PVOID pv) : m_pv(pv) {}

	//	operators for use with the hash cache
	//
	int PvoidKey::hash (const int rhs) const
	{
		//	Since we are talking about ptrs, we want
		//	to shift the pointer such that the hash
		//	values don't tend to overlap due to alignment
		//	NOTE: This shouldn't matter if you choose your hash table size
		//	(rhs) well.... but it also doesn't hurt.
		//
		return (int)((reinterpret_cast<UINT_PTR>(m_pv) >> ALIGN_NATURAL) % rhs);
	}

	bool PvoidKey::isequal (const PvoidKey& rhs) const
	{
		//	Just check if the values are equal.
		//
		return (rhs.m_pv == m_pv);
	}
};


//	========================================================================
//
//	CLASS Int64Key
//
//		__int64-based key class for use with the CCache (hashcache).
//
class Int64Key
{
private:
	__int64 m_i64;

	//	NOT IMPLEMENTED
	//
	bool operator< (const Int64Key& rhs) const;

public:
	Int64Key (__int64 i64) :
			m_i64(i64)
	{
	};

	//	operators for use with the hash cache
	//
	int hash (const int rhs) const
	{
		//	Don't even bother with the high part of the int64.
		//	The mod operation would lose that part anyway....
		//
		return ( static_cast<UINT>(m_i64) % rhs );
	}

	BOOL isequal (const Int64Key& rhs) const
	{
		//	Just check if the ids are equal.
		//
		return ( m_i64 == rhs.m_i64 );
	}
};

//	========================================================================
//	CLASS GuidKey
//	Key class for per-MDB cache of prop-mapping tables.
//
class GuidKey
{
private:
	const GUID * m_pguid;

public:
	GuidKey (const GUID * pguid) :
			m_pguid(pguid)
	{
	}

	//	operators for use with the hash cache
	//
	int hash (const int rhs) const
	{
		return (m_pguid->Data1 % rhs);
	}

	bool isequal (const GuidKey& rhs) const
	{
		return (!!IsEqualGUID (*m_pguid, *rhs.m_pguid));
	}
};


//	========================================================================
//	CLASS StoredGuidKey
//	Key class for per-MDB cache of prop-mapping tables.
//
class StoredGuidKey
{
private:
	GUID m_guid;

public:
	StoredGuidKey (const GUID guid)
	{
		CopyMemory(&m_guid, &guid, sizeof(GUID));
	}

	//	operators for use with the hash cache
	//
	int hash (const int rhs) const
	{
		return (m_guid.Data1 % rhs);
	}

	bool isequal (const StoredGuidKey& rhs) const
	{
		return (!!IsEqualGUID (m_guid, rhs.m_guid));
	}
};




#endif // !_EX_GENCACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\oldhack.h ===
//  will be public in IIS 5.0
#define   HSE_REQ_EXECUTE_CHILD                    (HSE_REQ_END_RESERVED+13)
#define   HSE_REQ_GET_EXECUTE_FLAGS                (HSE_REQ_END_RESERVED+19)

# define HSE_EXEC_NO_ISA_WILDCARDS        0x00000010   // Ignore wildcards in
                                                       // ISAPI mapping when
                                                       // executing child
# define HSE_EXEC_CUSTOM_ERROR            0x00000020   // URL being sent is a
                                                       // custom error
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\hdriter.h ===
/*
 *	H D R I T E R . H
 *
 *	Comma-separated header iterator
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef _HDRITER_H_
#define _HDRITER_H_

//	Check if the given character is whitespace
//
template<class X>
inline BOOL WINAPI FIsWhiteSpace( const X ch )
{
	BOOL f;

	if (sizeof(X) == sizeof(WCHAR))
	{
		f = !!wcschr(gc_wszLWS, static_cast<const WCHAR>(ch));
	}
	else
	{
		f = !!strchr(gc_szLWS, static_cast<const CHAR>(ch));;
	}

	return f;
}

//	Comma-separated header iterator -------------------------------------------
//
template<class T>
class HDRITER_TEMPLATE
{
private:

	const T *			m_pszHdr;
	const T *			m_pch;
	StringBuffer<T>		m_buf;

	//  NOT IMPLEMENTED
	//
	HDRITER_TEMPLATE& operator=( const HDRITER_TEMPLATE& );
	HDRITER_TEMPLATE( const HDRITER_TEMPLATE& );

public:

	HDRITER_TEMPLATE (const T * psz=0) : m_pszHdr(psz), m_pch(psz) {}
	~HDRITER_TEMPLATE() {}

	//	Accessors -------------------------------------------------------------
	//
	void Restart()					{ m_pch = m_pszHdr; }
	void NewHeader(const T * psz)	{ m_pch = m_pszHdr = psz; }
	const T * PszRaw(VOID)	const	{ return m_pch; }

	const T * PszNext(VOID)
	{
		const T * psz;
		const T * pszEnd;

		//	If no header existed, then there is nothing to do
		//
		if (m_pch == NULL)
			return NULL;

		//	Eat all the white space
		//
		while (*m_pch && FIsWhiteSpace<T>(*m_pch))
			m_pch++;

		//	There is nothing left to process
		//
		if (*m_pch == 0)
			return NULL;

		//	Record the start of the current segment and zip
		//	along until you find the end of the new segment
		//
		psz = m_pch;
		while (*m_pch && (*m_pch != ','))
			m_pch++;

		//	Need to eat all the trailing white spaces
		//
		pszEnd = m_pch - 1;
		while ((pszEnd >= psz) && FIsWhiteSpace<T>(*pszEnd))
			pszEnd--;

		//	The difference between, the two pointers gives us
		//	the size of the current entry.
		//
		m_buf.AppendAt (0, static_cast<UINT>(pszEnd - psz + 1) * sizeof(T), psz);
		m_buf.FTerminate ();

		//	Skip the trailing comma, if any.
		//
		if (*m_pch == ',')
			m_pch++;

		//	Return the string
		//
		return m_buf.PContents();
	}
};

typedef HDRITER_TEMPLATE<CHAR>	HDRITER;
typedef HDRITER_TEMPLATE<CHAR>	HDRITER_A;
typedef HDRITER_TEMPLATE<WCHAR>	HDRITER_W;

#endif // _HDRITER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\idlethrd.h ===
/*=========================================================================*\

	Module:      idlethrd.h

	Copyright Microsoft Corporation 1997, All Rights Reserved.

	Author:      zyang

	Description: Idle thread implementation

\*=========================================================================*/

#ifndef _EX_IDLETHRD_H_
#define _EX_IDLETHRD_H_

#include <ex\refcnt.h>

//	Interface IIdleThreadCallBack
//
//		This is a pure virtual class. which is to be implemented by any caller
//	who wants to register a callback on the idle thread. It has two methods.
//
//		DwWait(): return the next time out value. this allows the client to
//	change the timeout value dynamically. This method is also called when the 
//	callback is register obtain the initial timeout value, in this case, zero 
//	means execute immediately.
//
//		FExecute(): called when the time out happens, client should return 
//					TRUE if client want to keep this registration
//					FALSE if the client wants to unregister
//
//	IMPORTANT:
//		As there could be huge numder of registration on the idle thread, client 
//	should not block the Execute(), otherwise, other registrations would be 
//	blocked.
//
class IIdleThreadCallBack : private CRefCountedObject,
							public IRefCounted
{
	ULONG	m_ulIndex;	//	This is to facilitate unregister	
						// 	should not be touched by the client							
						
	//	non-implemented
	//
	IIdleThreadCallBack( const IIdleThreadCallBack& );
	IIdleThreadCallBack& operator=( const IIdleThreadCallBack& );

protected:

	IIdleThreadCallBack() {};

public:
	//	Client should not touch these two methods
	//
	VOID 	SetIndex (ULONG ulIndex) {	m_ulIndex = ulIndex; }
	const ULONG	UlIndex  ()	{ return m_ulIndex; }

	//	Client should implement the following methods
	
	//	Return the next timeout, in milliseconds.
	//
	virtual DWORD	DwWait() = 0;

	//	Called when timed out
	//
	virtual BOOL	FExecute() = 0;

	// 	Tell the clients that the idle thread is being shutdown
	//
	virtual VOID	Shutdown() = 0;

	//	RefCounting -- forward all reconting requests to our refcounting
	//	implementation base class: CRefCountedObject
	//
	void AddRef() { CRefCountedObject::AddRef(); }
	void Release() { CRefCountedObject::Release(); }
};

//	Helper functions

//	FInitIdleThread
//
//	Initialize the idle thread object. It can be out only once,
//	Note this call only initialize the CIdleThread object, the 
//	idle thread is not started until the first registration
//
BOOL	FInitIdleThread();

//	FDeleteIdleThread
//	
//	Delete the idle thread object. again, it can be called only once.
//
//	Note this must be called before any other uninitialization work,
//	Because we don't own a ref to the callback object, all what we 
//	have is a pointer to the object. in the shutdown time, we must
//	clear all the callback registration before the callback object 
//	go away.
//
VOID	DeleteIdleThread();

//	FRegister
//
//	Register a callback
//
BOOL	FRegister (IIdleThreadCallBack * pCallBack);

//	Unregister
//
//	Unregister a callback
//
VOID	Unregister (IIdleThreadCallBack * pCallBack);

#endif // !_EX_IDLETHRD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\nmspc.h ===
/*
 *	N M S P C . H
 *
 *	XML namespace processing
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_EX_NMSPC_H_
#define _EX_NMSPC_H_

#include <ex\calcom.h>
#include <ex\autoptr.h>
#include <ex\gencache.h>
#include <ex\buffer.h>
#include <ex\sz.h>
#include <crc.h>

//	Debugging -----------------------------------------------------------------
//
DEFINE_TRACE(Nmspc);
#define NmspcTrace		DO_TRACE(Nmspc)

//	Namespaces ----------------------------------------------------------------
//
DEC_CONST WCHAR gc_wszXmlns[] = L"xmlns";

//	Namespace support functions -----------------------------------------------
//
inline ULONG CchGenerateAlias (LONG lAlias, LPWSTR pwszAlias)
{
	UINT i = 0;
	Assert (pwszAlias);
	do
	{
		//	We don't have to use 'A'-'Z', use the first 16 capital
		//	letters to facilitate our computing.
		//
		pwszAlias[i++] = static_cast<WCHAR>(L'a' + (lAlias & 0xF));
		lAlias >>= 4;
	}
	while (lAlias);

	//	Ensure termination
	//
	pwszAlias[i] = 0;

	//	Return the length
	//
	NmspcTrace ("Nmspc: generating '%ws' as alias\n", pwszAlias);
	return i;
}

DEC_CONST WCHAR wchHiddenNmspcSep = L'#';
inline BOOL FIsNmspcSeparator (WCHAR wch)
{
	return ((wch == L':') ||
			(wch == L'/') ||
			(wch == L'?') ||
			(wch == L';') ||
			(wch == wchHiddenNmspcSep));
}

inline UINT CchAliasFromSizedTag (LPCWSTR pwszTag, UINT cch)
{
	LPCWSTR pwsz;

	for (pwsz = pwszTag; (pwsz - pwszTag) < static_cast<LONG>(cch); pwsz++)
		if (*pwsz == L':')
			return static_cast<UINT>(pwsz - pwszTag);

	return 0;
}

inline UINT CchNmspcFromTag (UINT cchTag, LPCWSTR pwszTag, LPCWSTR* ppwszOut)
{
	LPCWSTR pwsz;

	Assert (ppwszOut);
	*ppwszOut = pwszTag;
	for (pwsz = pwszTag + cchTag - 1; pwsz >= pwszTag; pwsz--)
	{
		if (FIsNmspcSeparator (*pwsz))
		{
			//	Since the separator is a part of the namespace,
			//	adjust accourdingly..
			//
			//$	REVIEW: We are being forced down the path of allowing namespaces
			//	that are not properly terminated.  The way we do this, is if the
			//	namespace is not properly terminated, or ends in an '#', we will
			//	append an '#' character.
			//
			//	What this means is the namespace "urn:xml-data", when assembled
			//	into a fully qualified tag would become "urn:xml-data#dt".  Also,
			//	the namespace "urn:exch-data#" would become "urn:exch-data##dt".
			//
			//	What we are catching here is the breaking down of a fully qualified
			//	tag into it's namespace and tag components.
			//
			//	The length of the namespace will not include the trailing '#'
			//	character -- ever!
			//
			*ppwszOut = pwsz + 1;
			if (wchHiddenNmspcSep == *pwsz)
				--pwsz;
			//
			//$ REVIEW: end.

			break;
		}
	}
	return static_cast<UINT>(1 + pwsz - pwszTag);
}

//	class CNmspc --------------------------------------------------------------
//
class CNmspc
{
private:

	//	Ref' counting.
	//
	//	!!! Please note that this is NON-THREADSAFE !!!
	//
	//	CXNodes should be operated on a single thread at
	//	any given time.
	//
	LONG					m_cRef;

public:

	void AddRef()			{ m_cRef++; }
	void Release()			{ if (0 == --m_cRef) delete this; }

private:

	auto_heap_ptr<WCHAR>	m_pszHref;
	UINT					m_cchAlias;
	UINT					m_cchHref;

	auto_heap_ptr<WCHAR>	m_pszLongAlias;
	WCHAR					m_szAlias[20];
	LPWSTR					m_pszAlias;

	//	Used for the scoping of namespaces
	//
	auto_ref_ptr<CNmspc>	m_pnsScoped;
	auto_ref_ptr<CNmspc>	m_pnsSiblings;

	//	non-implemented
	//
	CNmspc(const CNmspc& p);
	CNmspc& operator=(const CNmspc& p);

public:

	CNmspc () :
			m_cRef(1), // com-style refcounting
			m_cchHref(0),
			m_cchAlias(0)
	{
		m_szAlias[0] = 0;
		m_pszAlias = m_szAlias;
	}

	SCODE ScSetHref (LPCWSTR pszHref, UINT cch)
	{
		Assert (m_pszHref.get() == NULL);

		//	Copy the namespace locally
		//
		UINT cb = CbSizeWsz(cch);

		//$	REVIEW: We are being forced down the path of allowing namespaces
		//	that are not properly terminated.  The way we do this, is if the
		//	namespace is not properly terminated, or ends in an '#', we will
		//	append an '#' character.
		//
		//	What this means is the namespace "urn:xml-data", when assembled
		//	into a fully qualified tag would become "urn:xml-data#dt".  Also,
		//	the namespace "urn:exch-data#" would become "urn:exch-data##dt".
		//
		//	What we catch here, is the handling for an unterminated namespace.
		//	If the namespace ends in a non-terminator or a '#' character, then
		//	we will want to append one.
		//
		//	It is important to note that the appended char is NOT included in
		//	the total character count of the href.
		//
		//  If we are dealing with the empty namespace, we will not append a #.
		//
		BOOL fUnterminated = FALSE;

		if (0 != cch)
		{
			Assert (pszHref);
			WCHAR wch = pszHref[cch - 1];
			if ((wchHiddenNmspcSep == wch) || !FIsNmspcSeparator(wch))
			{
				NmspcTrace ("Nmspc: WARNING: namespace does not have a separator\n"
							"  as the last character of the namespace.  DAV will\n"
							"  add a '#' to the namespace for internal processing.\n");

				fUnterminated = TRUE;

				//	Make sure there is space for the appended character
				//
				cb += sizeof(WCHAR);
			}
		}
		//
		//$	REVIEW: end;

		//	Allocate space and copy everything over
		//
		m_pszHref = static_cast<LPWSTR>(ExAlloc(cb));
		if (NULL == m_pszHref.get())
			return E_OUTOFMEMORY;

		//  Note:  CopyMemory does not dereference pszHref if cch equals 0.
		//
		CopyMemory (m_pszHref, pszHref, cch * sizeof(WCHAR));
		m_cchHref = cch;

		//	If it is unterminated, handle that here
		//
		if (fUnterminated)
		{
			NmspcTrace ("Nmspc: WARNING: '#' appended to mis-terminated namespace\n");
			m_pszHref[cch++] = wchHiddenNmspcSep;

			Assert (CchHref() == m_cchHref);
			Assert (PszHref() == m_pszHref.get());
			Assert (wchHiddenNmspcSep == m_pszHref[m_cchHref]);
		}

		//	Ensure termination
		//
		m_pszHref[cch] = 0;
		NmspcTrace ("Nmspc: href defined\n"
					"-- m_pszHref: %ws\n"
					"-- m_szAlias: %ws\n",
					m_pszHref,
					m_szAlias);

		return S_OK;
	}

	SCODE ScSetAlias (LPCWSTR pszAlias, UINT cchAlias)
	{
		//	Copy the alias locally
		//
		Assert (pszAlias);
		UINT cb = CbSizeWsz(cchAlias);
		if (cb <= sizeof(m_szAlias))
		{
			CopyMemory (m_szAlias, pszAlias, cchAlias * sizeof(WCHAR));
			m_pszAlias = m_szAlias;
		}
		else
		{
			m_pszLongAlias.realloc (cb);
			if (NULL == m_pszLongAlias.get())
				return E_OUTOFMEMORY;

			CopyMemory (m_pszLongAlias, pszAlias, cchAlias * sizeof(WCHAR));
			m_pszAlias = m_pszLongAlias.get();
		}
		m_pszAlias[cchAlias] = L'\0';
		m_cchAlias = cchAlias;
		NmspcTrace ("Nmspc: alias defined\n"
					"-- m_pszHref: %ws\n"
					"-- m_szAlias: %ws\n",
					m_pszHref,
					m_pszAlias);

		return S_OK;
	}

	UINT CchHref()		const { return m_cchHref; }
	UINT CchAlias()		const { return m_cchAlias; }
	LPCWSTR PszHref()	const { return m_pszHref; }
	LPCWSTR PszAlias()	const { return m_pszAlias; }

	//	Namespace Scoping -----------------------------------------------------
	//
	CNmspc* PnsScopedNamespace() const { return m_pnsScoped.get(); }
	void SetScopedNamespace (CNmspc* pns)
	{
		m_pnsScoped = pns;
	}

	CNmspc* PnsSibling() const { return m_pnsSiblings.get(); }
	void SetSibling (CNmspc* pns)
	{
		m_pnsSiblings = pns;
	}

};

//	class CNmspcCache ---------------------------------------------------------
//
class CNmspcCache
{
public:

	typedef CCache<CRCWszN, auto_ref_ptr<CNmspc> > NmspcCache;
	NmspcCache					m_cache;

protected:

	ChainedStringBuffer<WCHAR>	m_sb;

	//	Key generation
	//
	virtual CRCWszN IndexKey (auto_ref_ptr<CNmspc>& pns) = 0;

	//	non-implemented
	//
	CNmspcCache(const CNmspcCache& p);
	CNmspcCache& operator=(const CNmspcCache& p);

public:

	CNmspcCache()
	{
		INIT_TRACE(Nmspc);
	}

	SCODE ScInit() { return m_cache.FInit() ? S_OK : E_OUTOFMEMORY; }

	void CachePersisted (auto_ref_ptr<CNmspc>& pns)
	{
		auto_ref_ptr<CNmspc>* parp = NULL;
		CRCWszN key = IndexKey(pns);

		//	Take a quick peek to see if the index already
		//	exists in the cache.  If it does, then setup
		//	the scoping such that when the namespace falls
		//	out of scope, the original namespace will be
		//	restored.
		//
		if (NULL != (parp = m_cache.Lookup (key)))
		{
			NmspcTrace ("Nmspc: scoped redefinition of namespace:\n"
						"-- old: '%ws' as '%ws'\n"
						"-- new: '%ws' as '%ws'\n",
						(*parp)->PszHref(),
						(*parp)->PszAlias(),
						pns->PszHref(),
						pns->PszAlias());

			pns->SetScopedNamespace(parp->get());
		}

		//	Setup the index
		//
		NmspcTrace ("Nmspc: indexing namespace\n"
					"-- ns: '%ws' as '%ws'\n",
					pns->PszHref(),
					pns->PszAlias());

		(void) m_cache.FAdd (key, pns);
	}

	void RemovePersisted (auto_ref_ptr<CNmspc>& pns)
	{
		auto_ref_ptr<CNmspc> pnsScoped;

		//	Disconnect the index to this namespace
		//
		NmspcTrace ("Nmspc: namespace falling out of scope\n"
					"-- ns: '%ws' as '%ws'\n",
					pns->PszHref(),
					pns->PszAlias());

		m_cache.Remove (IndexKey(pns));

		//	If there was an index in existance before this
		//	namespace came into scope, reinstate it here.
		//
		pnsScoped = pns->PnsScopedNamespace();
		if (pnsScoped.get())
		{
			NmspcTrace ("Nmspc: restoring redefined namespace:\n"
						"-- restored: '%ws' as '%ws'\n"
						"-- from: '%ws' as '%ws'\n",
						pnsScoped->PszHref(),
						pnsScoped->PszAlias(),
						pns->PszHref(),
						pns->PszAlias());

			(void) m_cache.FAdd (IndexKey(pnsScoped), pnsScoped);
		}
	}
};

//	class CParseNmspcCache ----------------------------------------------------
//
class CParseNmspcCache : public CNmspcCache
{
	//	non-implemented
	//
	CParseNmspcCache(const CNmspcCache& p);
	CParseNmspcCache& operator=(const CNmspcCache& p);

	virtual CRCWszN IndexKey (auto_ref_ptr<CNmspc>& pns)
	{
		return CRCWszN (pns->PszAlias(), pns->CchAlias());
	}

	//	Namespace lookup ------------------------------------------------------
	//
	BOOL FNmspcFromAlias (LPCWSTR pszAlias, UINT cch, auto_ref_ptr<CNmspc>& pns)
	{
		//	In this scenario, the namespace should already exist.
		//	if it doesn't things will not go well.
		//
		auto_ref_ptr<CNmspc> * parp = NULL;
		parp = m_cache.Lookup (CRCWszN(pszAlias, cch));
		if (parp)
		{
			pns = *parp;
			return TRUE;
		}
		return FALSE;
	}

public:

	CParseNmspcCache()
	{
	}

	//	Token translations ----------------------------------------------------
	//
	SCODE TranslateToken (LPCWSTR* ppwszTok,
						  ULONG* pcchTok,
						  LPCWSTR* ppwszNmspc,
						  ULONG* pcchNmspc)
	{
		auto_ref_ptr<CNmspc> pns;
		SCODE sc = S_FALSE;

		Assert (pcchTok && (*pcchTok != 0));
		Assert (ppwszTok && *ppwszTok);

		Assert (pcchNmspc);
		Assert (ppwszNmspc);

		//	See if there is an namespace that matches the persisted
		//	alias.
		//
		if (FNmspcFromAlias (*ppwszTok, *pcchNmspc, pns))
		{
			//	Passback the namespace
			//
			*pcchNmspc = pns->CchHref();
			*ppwszNmspc = pns->PszHref();

			//$	REVIEW: We are being forced down the path of allowing namespaces
			//	that are not properly terminated.  The way we do this, is if the
			//	namespace is not properly terminated, or ends in an '#', we will
			//	append an '#' character.
			//
			//	What this means is the namespace "urn:xml-data", when assembled
			//	into a fully qualified tag would become "urn:xml-data#dt".  Also,
			//	the namespace "urn:exch-data#" would become "urn:exch-data##dt".
			//
			//	What we catch here, is the first part of reconstruction of a fully
			//	qualified namespace.  If the href we want to pass back is non-
			//	terminated or ends in a '#' character, then we want to append one.
			//	When we cached the namespace object, we did the appending there.
			//	So, the character already exists, the character count just doesn't
			//	include it (see CNmspc::SetHref() above).
			//
			//  If we are dealing with the empty namespace, we will not append a #.
			//
			if (0 != pns->CchHref())
			{
				WCHAR wch = pns->PszHref()[pns->CchHref() - 1];
				if ((wchHiddenNmspcSep == wch) || !FIsNmspcSeparator(wch))
				{
					NmspcTrace ("Nmspc: WARNING: namespace is not properly terminated\n"
								"  and DAV will add in a '#' for internal processing.\n");

					Assert (wchHiddenNmspcSep == pns->PszHref()[pns->CchHref()]);
					*pcchNmspc = *pcchNmspc + 1;
				}
			}
			//
			//$	REVIEW: end.

			//	Adjust the token to refer to the tagname -- ie. the
			//	text after the namespace alias and colon.  If the alias
			//	is zero-length, then this maps to the "default" namespace
			//	and no colon skipping is done.
			//
			if (0 != pns->CchAlias())
			{
				*pcchTok = *pcchTok - (pns->CchAlias() + 1);
				*ppwszTok = *ppwszTok + (pns->CchAlias() + 1);
			}

			//	Tell the caller there is a translation
			//
			sc = S_OK;
		}
		else
		{
			//	If the caller expected a namespace, but one did not
			//	exist, it is an error.  If they didn't expect one to
			//	to exist -- ie. *pcchNmspc was 0 -- then it is not an
			//	error.  Make sure the caller knows what the real
			//	situation is.
			//
			if (0 == *pcchNmspc)
				sc = S_OK;

			//	It looks like no alias was specified, so we can just
			//	return the name as persisted.
			//
			*ppwszNmspc = NULL;
			*pcchNmspc = 0;
		}
		return sc;
	}
};

//	class CEmitterNmspcCache --------------------------------------------------
//
class CEmitterNmspcCache : public CNmspcCache
{
	LONG m_lAlias;

	//	non-implemented
	//
	CEmitterNmspcCache(const CEmitterNmspcCache& p);
	CEmitterNmspcCache& operator=(const CEmitterNmspcCache& p);

protected:

	void AdjustAliasNumber(LONG lOffset) { m_lAlias += lOffset; }

	//	Key generation
	//
	virtual CRCWszN IndexKey (auto_ref_ptr<CNmspc>& pns)
	{
		return CRCWszN (pns->PszHref(), pns->CchHref());
	}

	SCODE ScNmspcFromHref (LPCWSTR pszHref, UINT cch, auto_ref_ptr<CNmspc>& pns)
	{
		//	Lookup to see if the namespace already exists
		//
		auto_ref_ptr<CNmspc>* parp = m_cache.Lookup (CRCWszN(pszHref, cch));

		//	If it doesn't exist, then create a new one and cache it
		//
		if (parp == NULL)
		{
			WCHAR wszAlias[10];
			ULONG cchAlias;
			SCODE sc;

			//	Generate an alias to apply to this namespace and then
			//	check to see if this alias has been already used.  If
			//	not, then go ahead an use it.
			//
			cchAlias = CchGenerateAlias (m_lAlias++, wszAlias);

			//	Create a new cache item
			//
			pns.take_ownership(new CNmspc());
			if (NULL == pns.get())
				return E_OUTOFMEMORY;

			//	Set the HREF
			//
			sc = pns->ScSetHref (pszHref, cch);
			if (FAILED (sc))
				return sc;

			//	Set the alias
			//
			sc = pns->ScSetAlias (wszAlias, cchAlias);
			if (FAILED (sc))
				return sc;

			//	It is important, that the key and the return value are taken
			//	from items in the cache, otherwise the lifetime of the data
			//	may not scope the usage.
			//
			CachePersisted (pns);
			return S_FALSE;
		}
		pns = *parp;
		return S_OK;
	}

public:

	CEmitterNmspcCache() :
			m_lAlias(0)
	{
	}
};

#endif	// _EX_NMSPC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\refcnt.h ===
/*=========================================================================*\

	Module:      _refcnt.h

	Copyright Microsoft Corporation 1997, All Rights Reserved.


		Stolen from Storext.h
		
	Description: Ref counted object defintion
	
\*=========================================================================*/

#ifndef _EX_REFCNT_H_
#define _EX_REFCNT_H_

/*==========================================================================*\

	IRefCounted

    Description:  Your basic reference counting interface.

	Note:
		In most cases you shouldn't need to include this class as a base
		class in your refcounted object.  Instead you should just derive
		derive your class directly from CRefCountedObject.  You would only
		use IRefCounted with objects that can be used used where the
		code cannot or does not make assumptions on how the object
		implements its refcounting.  E.g. classes that forward refcounting
		to parent classes or derive from two concrete refcounted base
		classes.

\*==========================================================================*/

class IRefCounted
{
	//	NOT IMPLEMENTED
	//
	IRefCounted& operator=(const IRefCounted&);

public:
	//	CREATORS
	//
	virtual ~IRefCounted() = 0 {}

	//	MANIPULATORS
	//
	virtual void AddRef() = 0;
	virtual void Release() = 0;
};


/*==========================================================================*\

	CRefCountedObject

    Description:  Provide simple reference counting for internal objects.
	NOTE: The ref-counting used here is NOT consistent with OLE/COM refcounting.
	This class was meant to be used with auto_ref_ptr.

\*==========================================================================*/

class CRefCountedObject
{

private:

	//	NOT IMPLEMENTED
	//
	//	Force an error in instances where a copy constructor
	//  was needed, but none was provided.
	//
	CRefCountedObject& operator=(const CRefCountedObject&);
    CRefCountedObject(const CRefCountedObject&);

protected:

	LONG	m_cRef;

public:

	CRefCountedObject() : m_cRef(0) {}
	virtual ~CRefCountedObject() = 0 {}

	void AddRef()
	{
		InterlockedIncrement(&m_cRef);
	}

	void Release()
	{
		if (0 == InterlockedDecrement(&m_cRef))
			delete this;
	}

};

#endif // !_EX_REFCNT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\refhandle.h ===
#ifndef _REFHANDLE_H_
#define _REFHANDLE_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	REFHANDLE.H
//
//	Copyright 1999 Microsoft Corporation, All Rights Reserved
//

#include <ex\refcnt.h>
#include <ex\autoptr.h>


//	========================================================================
//
//	CLASS IRefHandle
//
//	Implements a refcounted handle.  AddRef() and Release() replace the
//	much slower in-process DuplicateHandle() calls.
//
//	The reason for the interface is that handles may come from many sources
//	and it is not always clear what we should do once we are done with one
//	when the last ref goes away.  In the most common case (where we own the
//	raw handle) we just want to call CloseHandle().  But we don't always own
//	the raw handle.  When someone else owns the raw handle, we must use
//	their mechanisms to indicate when we are done using it.  CIFSHandle in
//	davex\exifs.cpp is one such instance.
//
class IRefHandle : public CRefCountedObject
{
	//	NOT IMPLEMENTED
	//
	IRefHandle( const IRefHandle& );
	IRefHandle& operator=( const IRefHandle& );

protected:
	//	CREATORS
	//	Only create this object through it's descendents!
	//
	IRefHandle()
	{
		//
		//	Start the ref count at 1.  The expectation is that we will
		//	typically use constructs like this
		//
		//		auto_ref_handle hf;
		//		hf.take_ownership(new CFooRefHandle());
		//
		//	or this
		//
		//		auto_ref_ptr<IRefHandle> pRefHandle;
		//		pRefHandle.take_ownership(new CFooRefHandle());
		//
		//	when creating these objects.
		//
		m_cRef = 1;
	}

public:
	//	CREATORS
	//
	virtual ~IRefHandle() = 0 {}

	//	ACCESSORS
	//
	virtual HANDLE Handle() const = 0;
};

//	========================================================================
//
//	CLASS CRefHandle
//
//	By far the most common form of a refcounted handle -- the one where we
//	own the raw HANDLE and must call CloseHandle() on it when we are done.
//
//	This is implemented as a simple refcounted auto_handle.
//
class CRefHandle : public IRefHandle
{
	//
	//	The handle
	//
	auto_handle<HANDLE> m_h;

	//	NOT IMPLEMENTED
	//
	CRefHandle( const CRefHandle& );
	CRefHandle& operator=( const CRefHandle& );

public:
	//	CREATORS
	//
	CRefHandle(auto_handle<HANDLE>& h)
	{
		//	Take ownership of the passed-in auto_handle
		//
		*m_h.load() = h.relinquish();
	}

	//	ACCESSORS
	//
	HANDLE Handle() const
	{
		return m_h;
	}
};

//	========================================================================
//
//	CLASS auto_ref_handle
//
//	Implements automatic refcounting on IRefHandle objects.  The idea is
//	that an auto_ref_handle can be used in most cases to replace a raw
//	HANDLE.  The main difference is that copying a raw HANDLE introduces
//	an issue of ownership, but copying an auto_ref_handle does not.
//	Typically, a raw handle is copied with an expensive DuplicateHandle()
//	call.  Copying an auto_ref_handle just does a cheap AddRef().
//
class auto_ref_handle
{
	auto_ref_ptr<IRefHandle> m_pRefHandle;

public:
	//	CREATORS
	//
	auto_ref_handle() {}

	auto_ref_handle(const auto_ref_handle& rhs)
	{
		m_pRefHandle = rhs.m_pRefHandle;
	}

	//	ACCESSORS
	//
	HANDLE get() const
	{
		return m_pRefHandle.get() ? m_pRefHandle->Handle() : NULL;
	}

	//	MANIPULATORS
	//
	auto_ref_handle& operator=(const auto_ref_handle& rhs)
	{
		if ( m_pRefHandle.get() != rhs.m_pRefHandle.get() )
			m_pRefHandle = rhs.m_pRefHandle;

		return *this;
	}

	VOID take_ownership(IRefHandle * pRefHandle)
	{
		Assert( !m_pRefHandle.get() );

		m_pRefHandle.take_ownership(pRefHandle);
	}

	//	------------------------------------------------------------------------
	//
	//	auto_ref_handle::FCreate()
	//
	//	This function serves to simplify the very specific -- but very common --
	//	case of having an auto_ref_handle take ownership of a raw HANDLE.
	//	Without this function, callers would essentially need to go through all
	//	of the same steps that we do here.  The number of different objects
	//	required to get to the final auto_ref_handle (a temporary auto_handle,
	//	a CRefHandle, and an auto_ref_ptr to hold it) and how to assemble them
	//	correctly would be confusing enough to be bug prone.  It is far better
	//	to keep things simple from the caller's perspective.
	//
	//	Returns:
	//		TRUE	if the auto_ref_handle successfully takes ownership of the
	//				specified valid handle.
	//		FALSE	if the specified handle is NULL or invalid or if there is
	//				some other failure in the function.  In the latter case
	//				the function also CLOSES THE RAW HANDLE.
	//
	//	!!! IMPORTANT !!!
	//	This function is designed to be called with the direct return value
	//	from any API that creates a raw HANDLE.  If this call fails
	//	(i.e. returns FALSE) then it will close the raw HANDLE passed in!
	//	The whole point of the auto_ref_handle class is to replace usage of
	//	the raw HANDLE.
	//
	BOOL FCreate(HANDLE h)
	{
		Assert( !m_pRefHandle.get() );

		//	Don't even bother with NULL or invalid handles.
		//
		if (NULL == h || INVALID_HANDLE_VALUE == h)
			return FALSE;

		//	Put the raw handle into an auto_handle so that we clean up properly
		//	(i.e. close the handle) if instantiating the CRefHandle below fails
		//	by throwing an exception (as it would with a throwing allocator).
		//
		auto_handle<HANDLE> hTemp(h);

		//	Preserve the last error from our caller.  Our caller could have passed
		//	in a raw HANDLE from a CreateFile() call and may need to check the last
		//	error even in the success case -- to determine whether the file already
		//	existed, for example.
		//
		DWORD dw = GetLastError();

		//	Create a new refcounted handle object to control the lifetime
		//	of the handle that we are taking ownership of.
		//
		//	Note: the reason we preserved the last error above is that the
		//	allocator clears the last error when we create the CRefHandle
		//	here if the allocation succeeds.
		//
		m_pRefHandle.take_ownership(new CRefHandle(hTemp));
		if (!m_pRefHandle.get())
		{
			//	Return a failure.  Note that we don't restore the last
			//	error here -- callers should expect the last error to
			//	be set to a value appropriate for the last call that
			//	failed which is us.
			//
			return FALSE;
		}

		//	Restore our caller's last error before returning.
		//
		SetLastError(dw);

		//	We now own the handle.
		//
		return TRUE;
	}

	VOID clear()
	{
		m_pRefHandle = NULL;
	}
};

#endif // !defined(_REFHANDLE_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\reg.h ===
#ifndef _REG_H_
#define _REG_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	REG.H
//
//	Registry manipulation
//
//	Copyright 1986-1998 Microsoft Corporation, All Rights Reserved
//

#include <caldbg.h>

//	========================================================================
//
//	CLASS CRegKey
//
class CRegKey
{
	//
	//	The raw HKEY
	//
	HKEY m_hkey;

	//	NOT IMPLEMENTED
	//
	CRegKey& operator=( const CRegKey& );
	CRegKey( const CRegKey& );

public:
	//	CREATORS
	//
	CRegKey() : m_hkey(NULL) {}

	~CRegKey()
	{
		if ( m_hkey )
			(VOID) RegCloseKey( m_hkey );
	}

	//	MANIPULATORS
	//
	DWORD DwCreate( HKEY    hkeyBase,
					LPCWSTR lpwszSubkeyPath )
	{
		Assert( !m_hkey );

		return RegCreateKeyW( hkeyBase,
							  lpwszSubkeyPath,
							  &m_hkey );
	}

	DWORD DwOpen( HKEY    hkeyBase,
				  LPCWSTR lpwszSubkeyPath,
				  REGSAM  regsam = KEY_READ )
	{
		Assert( !m_hkey );

		return RegOpenKeyExW( hkeyBase,
							  lpwszSubkeyPath,
							  0,
							  regsam,
							  &m_hkey );
	}

	DWORD DwOpen( const CRegKey& regkey,
				  LPCWSTR lpwszSubkeyPath,
				  REGSAM  regsam = KEY_READ )
	{
		return DwOpen( regkey.m_hkey, lpwszSubkeyPath, regsam );
	}

	DWORD DwOpenA( HKEY   hkeyBase,
				   LPCSTR pszSubkeyPath,
				   REGSAM regsam = KEY_READ )
	{
		Assert( !m_hkey );

		return RegOpenKeyExA( hkeyBase,
							  pszSubkeyPath,
							  0,
							  regsam,
							  &m_hkey );
	}

	DWORD DwOpenA( const CRegKey& regkey,
				   LPCSTR pszSubkeyPath,
				   REGSAM regsam = KEY_READ )
	{
		return DwOpenA( regkey.m_hkey, pszSubkeyPath, regsam );
	}

	//	ACCESSORS
	//
	DWORD DwSetValue( LPCWSTR      lpwszValueName,
					  DWORD        dwValueType,
					  const VOID * lpvData,
					  DWORD        cbData ) const
	{
		Assert( m_hkey );

		return RegSetValueExW( m_hkey,
							   lpwszValueName,
							   0,
							   dwValueType,
							   reinterpret_cast<const BYTE *>(lpvData),
							   cbData );
	}

	DWORD DwQueryValue( LPCWSTR lpwszValueName,
						VOID *  lpvData,
						DWORD * pcbData,
						DWORD * pdwType = NULL ) const
	{
		Assert( m_hkey );

		return RegQueryValueExW( m_hkey,
								 lpwszValueName,
								 NULL, // lpReserved (must be NULL)
								 pdwType,
								 reinterpret_cast<LPBYTE>(lpvData),
								 pcbData );
	}

	DWORD DwQueryValueA( LPCSTR  lpszValueName,
						 VOID *  lpvData,
						 DWORD * pcbData,
						 DWORD * pdwType = NULL ) const
	{
		Assert( m_hkey );

		return RegQueryValueExA( m_hkey,
								lpszValueName,
								NULL, // lpReserved (must be NULL)
								pdwType,
								reinterpret_cast<LPBYTE>(lpvData),
								pcbData );
	}

	DWORD DwEnumSubKeyA( DWORD   iSubKey,
						 LPCSTR  pszSubKey,
						 DWORD * pcchSubKey ) const
	{
		FILETIME ftUnused;

		Assert( m_hkey );

		return RegEnumKeyExA( m_hkey,
							  iSubKey,
							  const_cast<LPSTR>(pszSubKey),
							  pcchSubKey,
							  NULL, // Reserved
							  NULL,	// Class not required
							  NULL, // Class not required
							  &ftUnused );
	}

	DWORD DwEnumSubKey( DWORD   iSubKey,
						LPCWSTR pwszSubKey,
						DWORD * pcchSubKey ) const
	{
		FILETIME ftUnused;

		Assert( m_hkey );

		return RegEnumKeyExW( m_hkey,
							  iSubKey,
							  const_cast<LPWSTR>(pwszSubKey),
							  pcchSubKey,
							  NULL, // Reserved
							  NULL,	// Class not required
							  NULL, // Class not required
							  &ftUnused );
	}
};

#endif // !defined(_REG_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\rgiter.h ===
/*
 *	R G I T E R . H
 *
 *	Range iterator
 */

#ifndef	_EX_RGITER_H_
#define _EX_RGITER_H_

#pragma warning(disable:4200)	// zero-sized array

//	Ranges --------------------------------------------------------------------
//
enum {

	RANGE_TOTAL_UNKNOWN	= 0xFFFFFFFF,
	RANGE_NOT_PRESENT = 0xFFFFFFFF,
	RANGE_UNKNOWN = 0,
	RANGE_ROW,
	RANGE_URL,
	RANGE_FIND
};

//	Range Items ---------------------------------------------------------------
//
//	There are two different range item formats.
//
//		row/byte ranges = DWRGITEM;
//		url/find ranges = SZRGITEM;
//
typedef struct _dwrgitem
{
	DWORD dwFirst;	// first row/byte of a range
	DWORD dwLast;	// last row/byte of a range

} DWRGITEM;

typedef struct _szrgitem
{
	LONG	lcRows;	// count of rows to return
	DWORD	cb;		// length, in bytes of item including NULL and padding
	WCHAR	wsz[];	// item padded out to align as needed

} SZRGITEM;

typedef struct _rgitem
{
	DWORD uRT;		// range type
	SCODE sc;

	union {

		DWRGITEM dwrgi;	// item for byte and row ranges
		SZRGITEM szrgi;	// item for url and find ranges
	};

} RGITEM, *PRGITEM;

inline
DWORD CbRangeItem (const RGITEM * prgi)
{
	Assert (prgi);
	DWORD cb = sizeof(RGITEM);
	if ((RANGE_URL == prgi->uRT) || (RANGE_FIND == prgi->uRT))
		cb += prgi->szrgi.cb;

	return cb;
}

//	Range Classes -------------------------------------------------------------
//
//	There are two classes for dealing with ranges.  A class that constructs the
//	range item array (a range parser), and a class that iterates over a range
//	array.
//
//	It is important to note that the CRangeParser only is used to parse the HTTP
//	"Range" header.  This header does not support the syntax of url and/or find
//	ranges, so the parser only builds items of type "bytes" and/or "rows".
//
//	Since both of these share the same format (DWRGITEM), and it is a fixed size,
//	there are some simplifying assumptions that can be made without adding too
//	much complexity to the parser.
//
//	Both parser and iterator share a common base...
//
class CRangeBase
{
protected:

	//	Count of ranges parsed out.
	//
	DWORD m_cRGList;

	//	Index of the range that is currently being parsed and/or processed
	//
	DWORD m_iCur;
	RGITEM * m_prgi;

	//	An array of ranges of size m_cRCList.  As noted above, this array is
	//	built up from items that were parsed from the HTTP header, and can
	//	then be assumed to be a fixed size based on the count of ranges.  This
	//	is an important aspect of the CRangeParser.
	//
	auto_heap_ptr<BYTE> m_pbData;
	DWORD m_cbSize;

	//	Collapsing unknown ranges
	//
	void CollapseUnknown();

	//  NOT IMPLEMENTED
	//
	CRangeBase& operator=( const CRangeBase& );
	CRangeBase( const CRangeBase& );

public:

	~CRangeBase();
	CRangeBase()
		: m_cRGList(0),
		  m_cbSize(0),
		  m_iCur(0),
		  m_prgi(0)

	{
	}

	//	Range fixup.  There are some cases where ranges need to be fixed up
	//	to match the actual amount of bytes/rows available.  Note that this
	//	only impacts byte and/or row ranges.
	//
	SCODE ScFixupRanges (DWORD dwCount);

	//	Advances through the rangGet the next range.
	//
	const RGITEM * PrgiNextRange();

	//	Rewind to the first range.
	//
	void Rewind()
	{
		m_iCur = 0;
		m_prgi = NULL;
	}

	//	Check for more ranges
	//
	BOOL FMoreRanges () const { return m_iCur < m_cRGList; }

	//	Check if a range present or not
	//
	BOOL FRangePresent (DWORD dw) const { return RANGE_NOT_PRESENT != dw; }

	//	Gets the total number of ranges.
	//
	ULONG UlTotalRanges() const { return m_cRGList; }

	//	Return the range array, with count and size.
	//
	RGITEM * PrgRangeArray(
		/* [out] */ ULONG * pulCount,
		/* [out] */ ULONG * pulSize,
		/* [in]  */ BOOL fTakeOwnership)
	{
		Assert (pulCount);
		Assert (pulSize);

		RGITEM * prgi = reinterpret_cast<RGITEM*>
			(fTakeOwnership ? m_pbData.relinquish() : m_pbData.get());

		*pulCount = m_cRGList;
		*pulSize = m_cbSize;
		return prgi;
	}
};

class CRangeParser : public CRangeBase
{
private:

	//  NOT IMPLEMENTED
	//
	CRangeParser& operator=( const CRangeParser& );
	CRangeParser( const CRangeParser& );

public:

	CRangeParser() {}
	~CRangeParser();

	//	Takes a range header and builds an array of ranges. Calls
	//	ScParseRangeHdr() to perform syntax checking, then validates
	//	the ranges against the entity size.
	//
	SCODE ScParseByteRangeHdr (LPCWSTR pwszRgHeader, DWORD dwSize);

	//	Take a range header and builds an array of ranges. Performs
	//	syntax checking.
	//
	SCODE ScParseRangeHdr (LPCWSTR pwszRgHeader, LPCWSTR pwszRangeUnit);
};

class CRangeIter : public CRangeBase
{
private:

	//  NOT IMPLEMENTED
	//
	CRangeIter& operator=( const CRangeIter& );
	CRangeIter( const CRangeIter& );

public:

	CRangeIter() {}
	~CRangeIter();

	//	Initialize a range iteration object based off of an existing
	//	range data blob.  In this case, the blob is copied and not consumed
	//	by the call.
	//
	SCODE ScInit (ULONG	cRGList, const RGITEM * prgRGList, ULONG cbSize);

	//	Initialize a range	iteration object based off of an existing
	//	range data blob.  In this case, the blob is consumed by the new
	//	object.
	//
	SCODE ScInit (CRangeParser& crp)
	{
		RGITEM * prgi = crp.PrgRangeArray (&m_cRGList,
										   &m_cbSize,
										   TRUE /* fTakeOwnership */);

		m_pbData = reinterpret_cast<BYTE*>(prgi);

		//	Rewind all the state.
		//
		Rewind();

		return S_OK;
	}
};

//	Range Parsing -------------------------------------------------------------
//
SCODE
ScParseOneWideRange (
	/* [in]  */ LPCWSTR pwsz,
	/* [out] */ DWORD * pdwStart,
	/* [out] */ DWORD * pdwEnd);

//	Range support -------------------------------------------------------------
//
//	Helper function to tell whether a range is a special range (0,0xffffffff)
//	which is used to represent the rows(bytes)=-n range on a zero sized response
//	body.
//
inline
BOOL FSpecialRangeForZeroSizedBody (RGITEM * prgItem)
{
	Assert (prgItem);

	return ((RANGE_ROW == prgItem->uRT)
			&& (0 == prgItem->dwrgi.dwFirst)
			&& (RANGE_NOT_PRESENT == prgItem->dwrgi.dwLast));
}

//	Range emitting ------------------------------------------------------------
//
SCODE ScGenerateContentRange (
	/* [in]  */ LPCSTR pszRangeUnit,
	/* [in]  */ const RGITEM * prgRGList,
	/* [in]  */ ULONG cRanges,
	/* [in]  */ ULONG cbRanges,
	/* [in]  */ ULONG ulTotal,
	/* [out] */ LPSTR *ppszContentRange);

#endif // _EX_RGITER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\synchro.h ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	SYNCHRO.H
//
//		Header for DAV synchronization classes.
//
//	Copyright 1986-1998 Microsoft Corporation, All Rights Reserved
//

#ifndef _EX_SYNCHRO_H_
#define _EX_SYNCHRO_H_

#include <caldbg.h>		// for Assert/DebugTrace/etc

//	========================================================================
//
//	CLASS CCriticalSection
//
//	Implements a critical section around a Win32 CRITICAL_SECTION.
//
//	Adds safety by explicitly disallowing copying (copying a raw
//	CRITICAL_SECTION can cause very unpredictable and hard to debug
//	behavior -- trust me).
//
//	Automatically cleans up the CRITICAL_SECTION resource when done.
//
class CCriticalSection
{
	//	The critical section
	//
	CRITICAL_SECTION	m_cs;

	//  NOT IMPLEMENTED
	//
	CCriticalSection& operator=( const CCriticalSection& );
	CCriticalSection( const CCriticalSection& );

public:
	//	CREATORS
	//
	CCriticalSection()
	{
		InitializeCriticalSection(&m_cs);
#ifdef DBG
		m_cLockRefs				= 0;
		m_dwLockOwnerThreadId	= 0;
#endif
	}

	~CCriticalSection()
	{
		DeleteCriticalSection(&m_cs);
	}

	BOOL FTryEnter()
	{
		if ( TryEnterCriticalSection (&m_cs) ) {
#ifdef DBG
			Assert (
				m_dwLockOwnerThreadId == GetCurrentThreadId() ||
				( m_cLockRefs == 0 && m_dwLockOwnerThreadId == 0 )
				);

			m_dwLockOwnerThreadId = GetCurrentThreadId ();
		m_cLockRefs++;
#endif
			return TRUE;
		}
		else
			return FALSE;
	}

	void Enter()
	{
		EnterCriticalSection(&m_cs);
#ifdef DBG
		Assert (
			m_dwLockOwnerThreadId == GetCurrentThreadId() ||
			( m_cLockRefs == 0 && m_dwLockOwnerThreadId == 0 )
			);

		m_dwLockOwnerThreadId = GetCurrentThreadId ();
		m_cLockRefs++;
#endif
	}

	void Leave()
	{
#ifdef DBG
		Assert ( m_cLockRefs > 0 );
		Assert ( m_dwLockOwnerThreadId != 0 );

		m_cLockRefs--;

		if ( m_cLockRefs == 0 ) {
			m_dwLockOwnerThreadId = 0;
		}
#endif
		LeaveCriticalSection(&m_cs);
	}

	void AssertLocked ( ) const
	{
#ifdef DBG
		//	This routine allows us to verify our correctness even when
		//	running in the single-threaded case.
		//

		// If this assert fires, it means that nobody has the lock:
		AssertSz ( m_cLockRefs > 0, "Calling method without the lock." );

		// If this assert fires, it means that somebody else has the lock:
		AssertSz ( m_dwLockOwnerThreadId == GetCurrentThreadId(),
			"Calling method, but another thread owns the lock!" );

#endif
	}

private:
#ifdef DBG

	// # of Lock() calls - # of Unlock() calls. Used by AssertInLock()
	DWORD				m_cLockRefs;

	// Thread ID of the current lock owner (or 0 if unowned).
	DWORD				m_dwLockOwnerThreadId;

#endif
};


//	========================================================================
//
//	CLASS CSynchronizedBlock
//
//	Synchronizes (serializes) any block of code in which an instance of
//	this class is declared on the critical section with which it
//	is initialized.
//
//	To use, just declare one of these in the block you want synchronized:
//
//		...
//		{
//			CSynchronizedBlock	sb(critsec);
//
//			//
//			//	Do some stuff that must be synchronized
//			//
//			...
//
//			//
//			//	Do more synchronized stuff
//			//
//			...
//		}
//
//		//
//		//	Do stuff that doesn't have to be synchronized
//		//
//		...
//
//	and the block is automatically synchronized.  Why bother?  Because
//	you don't need to have any cleanup code; the critical section is
//	automatically released when execution leaves the block, even if via
//	an exception thrown from any of the synchronized stuff.
//
class CSynchronizedBlock
{
	//	The critical section
	//
	CCriticalSection&	m_cs;

	//  NOT IMPLEMENTED
	//
	CSynchronizedBlock& operator=( const CSynchronizedBlock& );
	CSynchronizedBlock( const CSynchronizedBlock& );

public:
	//	CREATORS
	//
	CSynchronizedBlock( CCriticalSection& cs ) :
		m_cs(cs)
	{
		m_cs.Enter();
	}

	~CSynchronizedBlock()
	{
		m_cs.Leave();
	}
};

#include <except.h>

//	========================================================================
//
//	CLASS CEvent
//
//	Implements an event around a Win32 event handle resource.
//
class CEvent
{
	//	NOT IMPLEMENTED
	//
	CEvent& operator=(const CEvent&);
	CEvent(const CEvent&);

protected:

	HANDLE m_hevt;

public:

	CEvent() : m_hevt(NULL) {}

	BOOL FInitialized() const
	{
		return m_hevt && m_hevt != INVALID_HANDLE_VALUE;
	}

	~CEvent()
	{
		if ( FInitialized() )
		{
			CloseHandle( m_hevt );
		}
	}

	BOOL FCreate( LPSECURITY_ATTRIBUTES	lpsa,
				  BOOL					fManualReset,
				  BOOL					fSignalled,
				  LPCWSTR				lpwszEventName,
				  BOOL					fDontMungeTheEventName = FALSE)
	{
		Assert( !FInitialized() );

		//	create event does not take backslashes. so replace
		//	them with ? which won't be part of URI at this point.
		//
		//$HACK
		//	ARGH!  Who put this slash-munging hack in here?  Modifying a
		//	const parameter and munging the name.  Most events are smart
		//	enough not to use backward slashes in their names since they
		//	aren't allowed by the underlying Win32 API, CreateEvent()....
		//
		//	At any rate, this is not good in the Terminal Server case which
		//	must prefix event names with either "Global\" or "Local\" (note
		//	the backslash!)
		//
		//	So the hack upon a hack here (fDontMungeTheEventName) is for
		//	callers who really can be trusted to know what they are doing.
		//	Unfortunately, short of grepping a lot of sources, there is
		//	no way of knowing who can and can't be trusted, so we have to
		//	assume the worst.
		//
		if (!fDontMungeTheEventName)
		{
			LPWSTR lpwszTemp = const_cast<LPWSTR>(lpwszEventName);

			if (lpwszTemp)
			{
				while( NULL != (lpwszTemp = wcschr (lpwszTemp, L'\\')) )
				{
					lpwszTemp[0] = L'?';
				}
			}
		}

		m_hevt = CreateEventW( lpsa,
							   fManualReset,
							   fSignalled,
							   lpwszEventName );

		//	According to MSDN, if the creation fails, CreateEvent returns NULL, not
		//	INVALID_HANDLE_VALUE.  We'll just do a quick DBG check to make sure we never
		//	see INVALID_HANDLE_VALUE here.
		//
		Assert(INVALID_HANDLE_VALUE != m_hevt);

		if ( !m_hevt )
			return FALSE;

		return TRUE;
	}

	void Set()
	{
		Assert( FInitialized() );

		SideAssert( SetEvent(m_hevt) );
	}

	void Reset()
	{
		Assert( FInitialized() );

		SideAssert( ResetEvent(m_hevt) );
	}

	void Wait()
	{
		Assert( FInitialized() );

		SideAssert( WaitForSingleObject( m_hevt, INFINITE ) == WAIT_OBJECT_0 );
	}

	void AlertableWait()
	{
		Assert( FInitialized() );

		DWORD dwResult;

		do
		{
			dwResult = WaitForSingleObjectEx( m_hevt, INFINITE, TRUE );
			Assert( dwResult != 0xFFFFFFFF );
		}
		while ( dwResult == WAIT_IO_COMPLETION );

		Assert( dwResult == WAIT_OBJECT_0 );
	}
};


//	========================================================================
//
//	CLASS CMRWLock
//
//	Implements a multi-reader, single writer-with-promote lock for
//	efficient, thread-safe access of a per-process resource.
//
class CMRWLock
{
	//
	//	The implementation uses a really clever trick where
	//	the high bit of the reader count is reserved for use
	//	as a one-bit flag that it set whenever there is a
	//	writer in the lock or waiting to enter it.
	//
	//	Combining the reader count and a writer flag into
	//	a single DWORD allows InterlockedXXX() calls to
	//	be used to manipulate the two pieces of information
	//	atomically as part of a spinlock which eliminates
	//	the need for an entering reader to pass through
	//	a critical section.
	//
	//	Entering a critical section, even for the short amount
	//	of time necessary to get a reader into the lock,
	//	drastically impacts the performance of heavily used
	//	process-wide locks.
	//

	//
	//	The write lock bit
	//
	enum { WRITE_LOCKED = 0x80000000 };

	//
	//	Critical section to allow only one writer at a time.
	//
	CCriticalSection m_csWriter;

	//
	//	ThreadID of the thread that owns the write lock.
	//	This value is 0 when no one owns the write lock.
	//
	DWORD m_dwWriteLockOwner;

	//
	//	Promoter recursion count used to allow a single thread
	//	which holds the promote/write lock to reenter the lock.
	//
	DWORD m_dwPromoterRecursion;

	//
	//	Event signalled when a writer leaves the lock to
	//	allow blocked readers to enter.
	//
	CEvent m_evtEnableReaders;

	//
	//	Event signalled when the last reader leaves the lock
	//	to allow a blocked writer to enter.
	//
	CEvent m_evtEnableWriter;

	//
	//	Count of readers plus a flag bit (WRITE_LOCKED)
	//	indicating whether a writer owns the lock or is
	//	waiting to enter it.
	//
	LONG m_lcReaders;

	BOOL FAcquireReadLock(BOOL fAllowCallToBlock);

	//	NOT IMPLEMENTED
	//
	CMRWLock& operator=(const CMRWLock&);
	CMRWLock(const CMRWLock&);

public:

	//	CREATORS
	//
	CMRWLock();
	BOOL FInitialize();
	~CMRWLock() {};

	//	MANIPULATORS
	//
	void EnterRead();
	BOOL FTryEnterRead();
	void LeaveRead();

	void EnterWrite();
	BOOL FTryEnterWrite();
	void LeaveWrite();

	void EnterPromote();
	BOOL FTryEnterPromote();
	void LeavePromote();
	void Promote();
};


//	========================================================================
//
//	CLASS CCrossThreadLock
//
//	Implements a simple mutual exclusion lock to guard access to objects.
//	This object can be locked and unlocked from different threads (difference
//	from critsec-style locks).
//
//	ONLY USE THIS LOCK IF YOU _REALLY_ _REALLY_ NEED CROSS-THREAD
//	LOCK/UNLOCK CAPABILITY.
//
//	Possible future plans for improvement:
//	o	This object currently sets NULL for lpSemaphoreAttributes.  This will
//		not allow the lock to be used cross-process or from a different
//		user security context.
//	o	This object always specifies an INFINITE timeout.  In the future, there
//		could be an optional parameter to FEnter that allows you to set
//		something other than INFINITE.
//
class
CCrossThreadLock
{
	HANDLE	m_hSemaphore;

	//	NOT IMPLEMENTED
	//
	CCrossThreadLock& operator=(const CCrossThreadLock&);
	CCrossThreadLock(const CCrossThreadLock&);

public:
	CCrossThreadLock() :
		m_hSemaphore(NULL)
	{ }

	~CCrossThreadLock()
	{
		if (NULL != m_hSemaphore)
			CloseHandle(m_hSemaphore);
	}

	BOOL FInitialize()
	{
		BOOL	fSuccess = FALSE;
		m_hSemaphore = CreateSemaphore(NULL,				//	lpSemaphoreAttributes
									   1,					//	lInitialCount
									   1,					//	lMaximumCount
									   NULL);				//	lpName

		//	According to MSDN, if the creation fails, CreateSemaphore returns NULL, not
		//	INVALID_HANDLE_VALUE.  We'll just do a quick DBG check to make sure we never
		//	see INVALID_HANDLE_VALUE here.
		//
		Assert(INVALID_HANDLE_VALUE != m_hSemaphore);

		if (NULL == m_hSemaphore)
			goto Exit;

		fSuccess = TRUE;

	Exit:
		return fSuccess;
	}

	BOOL FEnter(DWORD dwTimeOut = INFINITE)
	{
		Assert(NULL != m_hSemaphore);

		if (WAIT_OBJECT_0 == WaitForSingleObject(m_hSemaphore,
												 dwTimeOut))
			return TRUE;

		return FALSE;
	}

	VOID Leave()
	{
		Assert(NULL != m_hSemaphore);

		if (!ReleaseSemaphore(m_hSemaphore,
							  1,
							  NULL))
		{
			DebugTrace("CCrossThreadLock::Leave(): Failed to release semaphore, last error 0x%08lX.\n",
					   GetLastError());
			TrapSz("CCrossThreadLock::Leave(): Failed to release semaphore!\n");
		}
	}
};

//	========================================================================
//
//	CLASS CGate
//
//	Implements gating mechanism, that alows to close the EXECUTION PATH and
//	push out all the threads using it. Very usefull on shutdown scenarios.
//
//	Here is a sketch of the gate usage:
//
//	...
//
//	{
//		CGatedBlock	gb(gate);
//
//		if (gb.FIsGateOpen())
//		{
//			...
//				EXECUTION PATH that is to be gated
//			...
//		}
//		else
//		{
//			...
//				Do whatever has to be done if EXECUTION PATH
//				is not to be executed any more
//			...
//		}
//	}
//	...
//
class CGate
{
	//	Number of users in the zone framed by this gate
	//
	LONG	m_lcUsers;

	//	Flag indicating if the gate is open
	//
	BOOL	m_fClosed;

	//	NOT IMPLEMENTED
	//
	CGate& operator=(const CGate&);
	CGate(const CGate&);

public:

	//	The fact that all member variables of the class are
	//	0 on creation, allows to use it as a static variable
	//	without additional burden of explicit initialization
	//
	CGate() : m_lcUsers(0),
			  m_fClosed(FALSE) {};

	//	INITIALIZER
	//
	inline
	VOID Init()
	{
		m_lcUsers = 0;
		m_fClosed = FALSE;
	}

	//	MANIPULATORS
	//
	inline
	VOID Enter()
	{
		InterlockedIncrement(&m_lcUsers);
	}

	inline
	VOID Leave()
	{
		InterlockedDecrement(&m_lcUsers);
	}

	inline
	VOID Close()
	{
		//	Mark the gate as closed
		//
		m_fClosed = TRUE;

		//	Wait until all the threads that use execution
		//	path framed by this gate will leave the zone
		//	it is framing. As FIsOpen() call is allowed only
		//	inside the gated zone, we will know that after
		//	this call returns there is no thread thinking
		//	that the gate is still open
		//
		while (0 != m_lcUsers)
		{
			Sleep(200);
		}
	}

	//	ACCESSORS
	//
	inline
	BOOL FIsOpen()
	{
		//	We must be in the gated zone in order
		//	to be able to determine if the gate is
		//	open.
		//
		Assert(m_lcUsers > 0);
		return !m_fClosed;
	}
};


//	========================================================================
//
//	TEMPLATE CLASS SynchronizedReadBlock
//
template<class _Lock>
class SynchronizedReadBlock
{
	//	The read/write lock
	//
	_Lock& m_lock;

	//  NOT IMPLEMENTED
	//
	SynchronizedReadBlock& operator=( const SynchronizedReadBlock& );
	SynchronizedReadBlock( const SynchronizedReadBlock& );

public:

	SynchronizedReadBlock (_Lock& mrw)
		: m_lock(mrw)
	{
		m_lock.EnterRead();
	}

	~SynchronizedReadBlock()
	{
		m_lock.LeaveRead();
	}
};

typedef SynchronizedReadBlock<CMRWLock> CSynchronizedReadBlock;


//	========================================================================
//
//	TEMPLATE CLASS CSynchronizedWriteBlock
//
template<class _Lock>
class SynchronizedWriteBlock
{
	//	The read/write lock
	//
	_Lock& m_lock;

	//  NOT IMPLEMENTED
	//
	SynchronizedWriteBlock& operator=( const SynchronizedWriteBlock& );
	SynchronizedWriteBlock( const SynchronizedWriteBlock& );

public:

	SynchronizedWriteBlock (_Lock& mrw)
		: m_lock(mrw)
	{
		m_lock.EnterWrite();
	}

	~SynchronizedWriteBlock()
	{
		m_lock.LeaveWrite();
	}
};

typedef SynchronizedWriteBlock<CMRWLock> CSynchronizedWriteBlock;


//	========================================================================
//
//	TEMPLATE CLASS TryWriteBlock
//
//	Like SynchronizedWriteBlock except that the block must be
//	entered via the FTryEnter() method.  A return value of TRUE
//	from FTryEnter() indicates the lock is entered.
//
template<class _Lock>
class TryWriteBlock
{
	//	The read/write lock
	//
	_Lock& m_lock;

	//	TRUE if write lock entered
	//
	BOOL m_fLocked;

	//  NOT IMPLEMENTED
	//
	TryWriteBlock& operator=( const TryWriteBlock& );
	TryWriteBlock( const TryWriteBlock& );

public:

	TryWriteBlock (_Lock& mrw) :
		m_lock(mrw),
		m_fLocked(FALSE)
	{
	}

	BOOL FTryEnter()
	{
		return m_fLocked = m_lock.FTryEnterWrite();
	}

	~TryWriteBlock()
	{
		if ( m_fLocked )
			m_lock.LeaveWrite();
	}
};

typedef TryWriteBlock<CMRWLock> CTryWriteBlock;


//	========================================================================
//
//	TEMPLATE CLASS SynchronizedPromoteBlock
//
template<class _Lock>
class SynchronizedPromoteBlock
{
	//	The read/write lock
	//
	_Lock& m_lock;

	//  NOT IMPLEMENTED
	//
	SynchronizedPromoteBlock& operator=( const SynchronizedPromoteBlock& );
	SynchronizedPromoteBlock( const SynchronizedPromoteBlock& );

public:

	SynchronizedPromoteBlock (_Lock& mrw)
		: m_lock(mrw)
	{
		m_lock.EnterPromote();
	}

	~SynchronizedPromoteBlock()
	{
		m_lock.LeavePromote();
	}

	void Promote()
	{
		m_lock.Promote();
	}
};

typedef SynchronizedPromoteBlock<CMRWLock> CSynchronizedPromoteBlock;

//	========================================================================
//
//	TEMPLATE CLASS GatedBlock
//
template<class _Gate>
class GatedBlock
{
	//	The gate
	//
	_Gate& m_gate;

	//  NOT IMPLEMENTED
	//
	GatedBlock& operator=( const GatedBlock& );
	GatedBlock( const GatedBlock& );

public:

	GatedBlock (_Gate& gate)
		: m_gate(gate)
	{
		m_gate.Enter();
	}

	BOOL FGateIsOpen()
	{
		return m_gate.FIsOpen();
	}

	~GatedBlock()
	{
		m_gate.Leave();
	}
};

typedef GatedBlock<CGate> CGatedBlock;

//	========================================================================
//
//	InterlockedExchangeOr -  A multithread safe way to OR bits into a LONG
//
LONG InterlockedExchangeOr( LONG * plVariable, LONG lOrBits );

#endif // !_EX_SYNCHRO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\stackbuf.h ===
/*
 *	S T A C K B U F . H
 *
 *	Data buffer processing
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_EX_STACKBUF_H_
#define _EX_STACKBUF_H_
#include <caldbg.h>

//	Alignment macros ----------------------------------------------------------
//
#include <align.h>

//	Safe allocators -----------------------------------------------------------
//
#include <ex\exmem.h>

//	Class STACKBUF ------------------------------------------------------------
//
enum { STACKBUFFER_THRESHOLD = 64};
template <class T, UINT N = STACKBUFFER_THRESHOLD>
class CStackBuffer
{
private:

	BYTE	m_rgb[N];
	ULONG	m_fDynamic:1;
	ULONG	m_fValid:1;
	ULONG	m_cb:30;
	T*		m_pt;

	//	non-implemented operators
	//
	CStackBuffer(const CStackBuffer& );
	CStackBuffer& operator=(const CStackBuffer& );

	void release()
	{
		if (m_fDynamic && m_pt)
		{
			ExFree(m_pt);
			m_pt = NULL;
		}
	}

	T& idx(size_t iT) const
	{
		Assert(m_fValid && m_pt && ((UINT)iT < celems()));
		return m_pt[iT];
	}

	//	non-implemented operators
	//
	operator T*() const;
	T& operator*() const;
	T** operator&()	const;

	//	block random assignments
	//
	CStackBuffer& operator=(T* pt);
	CStackBuffer& operator=(void * p);

public:

	//	Manuplation -----------------------------------------------------------
	//
	//	Allocation mechanism, replaces _alloca()
	//
	T * resize (UINT cb)
	{
		//	Max size for a stack item
		//
		Assert (cb <= 0x3FFFFFFF);

		//	Lets go ahead an ask for a sizable chunk, regardless.
		//
		cb = max(cb, N);

		//	If the size of the item is greater than the current size,
		//	then we need to aquire space for the data,
		//
		if (m_cb < cb)
		{
			T* pt = NULL;

			//	If the item is already dynamically allocated, or if the
			//	size exceeds the threshold of the stackbuffer, allocate
			//	the memory.
			//
			if (m_fDynamic || (N < cb))
			{
				//	Allocate space using ExAlloc() and return that value,
				//	fDynamic means that the existing value is dynamically
				//	allocated.  Free the old before creating the new.
				//
				DebugTrace ("DAV: stackbuf going dynamic...\n");
				//
				//	The free/alloc should have better perf characteristics
				//	in the multi-heap land.
				//
				release();
				pt = static_cast<T*>(ExAlloc(cb));
				m_fDynamic = TRUE;
			}
			else
			{
				pt = reinterpret_cast<T*>(m_rgb);
			}

			m_pt = pt;
			m_cb = cb;
		}
		m_fValid = TRUE;
		return m_pt;
	}


	//	Constructor/Destructor ------------------------------------------------
	//
	~CStackBuffer() { release(); }
	explicit CStackBuffer(UINT uInitial = N)
		: m_fDynamic(FALSE),
		  m_fValid(FALSE),
		  m_pt(NULL),
		  m_cb(0)
	{
		resize(uInitial);
	}

	//	Invalidation ----------------------------------------------------------
	//
	void clear() { m_fValid = FALSE; }

	//	Size ------------------------------------------------------------------
	//
	size_t celems() const { return (m_cb / sizeof(T)); }
	size_t size() const { return m_cb; }

	//	Accessors -------------------------------------------------------------
	//
	T* get()		const { Assert(m_fValid && m_pt); return m_pt; }
	void* pvoid()	const { Assert(m_fValid && m_pt); return m_pt; }
	T* operator->() const { Assert(m_fValid && m_pt); return m_pt; }
	T& operator[] (INT iT) const { return idx((size_t)iT); }
	T& operator[] (UINT iT) const { return idx((size_t)iT); }
	T& operator[] (DWORD iT) const { return idx((size_t)iT); }
	T& operator[] (__int64 iT) const { return idx((size_t)iT); }
	T& operator[] (unsigned __int64 iT) const { return idx((size_t)iT); }
};

#endif // _EX_STACKBUF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\xml.h ===
/*
 *	X M L . H
 *
 *	XML Document processing
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_XML_H_
#define _XML_H_

#include <caldbg.h>
#include <ex\refcnt.h>

//	Debugging -----------------------------------------------------------------
//
DEFINE_TRACE(Xml);
#define XmlTrace		DO_TRACE(Xml)

//	Property name escaping/unescaping -----------------------------------------
//
VOID UnescapePropertyName (LPCWSTR wszEscaped, LPWSTR wszProp);
SCODE ScEscapePropertyName (LPCWSTR wszProp, UINT cch, LPWSTR pwszEscaped, UINT* pcch, BOOL fRestrictFirstCharacter);

//	Property construction helpers ---------------------------------------------
//
SCODE ScVariantTypeFromString (LPCWSTR pwszType, USHORT& vt);
SCODE ScVariantValueFromString (PROPVARIANT& var, LPCWSTR pwszValue);

enum
{
	//$REVIEW: Define an proper body part size. It's used in CXMLBodyPartMgr
	//$REVIEW: to control when a body part is to be added to the body part list.
	//$REVIEW: Acutally, because it is not predictable how big the next piece is.
	//$REVIEW: the max size of xml body part can be (CB_XMLBODYPART_SIZE * 2 - 1)
	//$REVIEW: It is also used in ScSetValue to break over-size value into
	//$REVIEW: smaller pieces.
	//
	//$REVIEW: Don't confuse this to the largest chunk size CB_WSABUFS_MAX (8174).
	//$REVIEW: CB_XMLBODYPART_SIZE is not meant to control chunks
	//
	CB_XMLBODYPART_SIZE	=	4 * 1024	//	4K
};

//	class IXMLBody ------------------------------------------------------------
//
//	This is the XML body building interface, it is to be inherited in either
//	IIS and/or store size, to allow XML emitting
//
class IXMLBody : private CRefCountedObject,
				 public IRefCounted
{
	//	NOT IMPLEMENTED
	//
	IXMLBody(const IXMLBody& p);
	IXMLBody& operator=( const IXMLBody& );

protected:

	IXMLBody()
	{
		AddRef(); // use com-style refcounting
	}

public:

	virtual SCODE ScAddTextBytes ( UINT cbText, LPCSTR lpszText ) = 0;
	virtual VOID Done() = 0;

	//	RefCounting -- forward all reconting requests to our refcounting
	//	implementation base class: CRefCountedObject
	//
	void AddRef() { CRefCountedObject::AddRef(); }
	void Release() { CRefCountedObject::Release(); }
};

#endif	// _XML_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\sz.h ===
//	========================================================================
//
//	sz.h
//
//	Constant string support
//
//	NOTE: Strings that need multi-language support should NOT go here!
//	They belong in the \cal\lang tree.
//
//	Copyright 1986-1999 Microsoft Corporation, All Rights Reserved
//

#ifndef _EX_SZ_H_
#define _EX_SZ_H_


//	Const string length -------------------------------------------------------
//
#define CchConstString(_s)	((sizeof(_s)/sizeof(_s[0])) - 1)
#define _wcsspnp(_cpc1, _cpc2) ((*((_cpc1)+wcsspn(_cpc1,_cpc2))) ? ((_cpc1)+wcsspn(_cpc1,_cpc2)) : NULL)


//	String constants ----------------------------------------------------------
//

//	Product tokens ------------------------------------------------------------
//
DEC_CONST CHAR gc_szOffice9UserAgent[]		= "Microsoft Data Access Internet Publishing Provider DAV";
DEC_CONST UINT gc_cchOffice9UserAgent		= CchConstString(gc_szOffice9UserAgent);
DEC_CONST CHAR gc_szRosebudNT5UserAgent[]	= "Microsoft Data Access Internet Publishing Provider DAV 1.1";
DEC_CONST UINT gc_cchRosebudNT5UserAgent	= CchConstString(gc_szRosebudNT5UserAgent);

//	Whitespace ----------------------------------------------------------------
//
DEC_CONST CHAR gc_szLWS[]					= " \r\n\t";
DEC_CONST WCHAR gc_wszLWS[]					= L" \r\n\t";
DEC_CONST CHAR gc_szWS[]					= " \t";
DEC_CONST WCHAR gc_wszWS[]					= L" \t";

//	Generic constants ---------------------------------------------------------
//
DEC_CONST WCHAR gc_wszDigits[] = L"0123456789";
DEC_CONST WCHAR gc_wchEquals   = L'=';
DEC_CONST WCHAR gc_wchComma	   = L',';
DEC_CONST WCHAR gc_wszByteRangeAlphabet[] = L"0123456789-, \t";
DEC_CONST WCHAR gc_wszSeparator[] = L" \t,";
DEC_CONST WCHAR gc_wchDash	= L'-';

//	HTTP-DAV headers ----------------------------------------------------------
//
DEC_CONST CHAR gc_szAccept_Charset[]		= "Accept-Charset";
DEC_CONST CHAR gc_szAccept_Encoding[]		= "Accept-Encoding";
DEC_CONST CHAR gc_szAccept_Language[]		= "Accept-Language";
DEC_CONST CHAR gc_szAccept_Ranges[]			= "Accept-Ranges";
DEC_CONST CHAR gc_szAccept[]				= "Accept";
DEC_CONST CHAR gc_szAge[]					= "Age";
DEC_CONST CHAR gc_szAllow[]					= "Allow";
DEC_CONST CHAR gc_szAtomic[]				= "Atomic";
DEC_CONST CHAR gc_szAuthorization[]			= "Authorization";
DEC_CONST CHAR gc_szChunked[]				= "chunked";
DEC_CONST WCHAR gc_wszChunked[]				= L"chunked";
DEC_CONST CHAR gc_szCollection_Member[]		= "Collection-Member";
DEC_CONST CHAR gc_szCompatibility[]			= "Compatibility";
DEC_CONST CHAR gc_szConnection[]			= "Connection";
DEC_CONST CHAR gc_szContent_Base[]			= "Content-Base";
DEC_CONST CHAR gc_szContent_Encoding[]		= "Content-Encoding";
DEC_CONST CHAR gc_szContent_Language[]		= "Content-Language";
DEC_CONST CHAR gc_szContent_Length[]		= "Content-Length";
DEC_CONST CHAR gc_szContent_Location[]		= "Content-Location";
DEC_CONST CHAR gc_szContent_MD5[]			= "Content-MD5";
DEC_CONST CHAR gc_szContent_Range[]			= "Content-Range";
DEC_CONST WCHAR gc_wszContent_Range[]		= L"Content-Range";
DEC_CONST INT gc_cchContent_Range			= CchConstString(gc_szContent_Range);
DEC_CONST CHAR gc_szContent_Type[]			= "Content-Type";
DEC_CONST WCHAR gc_wszContent_Type[]		= L"Content-Type";
DEC_CONST INT gc_cchContent_Type			= CchConstString(gc_szContent_Type);
DEC_CONST CHAR gc_szContent_Disposition[]	= "Content-Disposition";
DEC_CONST CHAR gc_szCookie[]				= "Cookie";
DEC_CONST CHAR gc_szDate[]					= "Date";
DEC_CONST CHAR gc_szDepth[]					= "Depth";
DEC_CONST CHAR gc_szDestination[]			= "Destination";
DEC_CONST CHAR gc_szDestroy[]				= "Destroy";
DEC_CONST CHAR gc_szExpires[]				= "Expires";
DEC_CONST CHAR gc_szETag[]					= "ETag";
DEC_CONST CHAR gc_szFrom[]					= "From";
DEC_CONST CHAR gc_szHost[]					= "Host";
DEC_CONST CHAR gc_szIf_Match[]				= "If-Match";
DEC_CONST CHAR gc_szIf_Modified_Since[]		= "If-Modified-Since";
DEC_CONST CHAR gc_szIf_None_Match[]			= "If-None-Match";
DEC_CONST CHAR gc_szIf_None_State_Match[]	= "If-None-State-Match";
DEC_CONST CHAR gc_szIf_Range[]				= "If-Range";
DEC_CONST CHAR gc_szIf_State_Match[]		= "If-State-Match";
DEC_CONST CHAR gc_szIf_Unmodified_Since[]	= "If-Unmodified-Since";
DEC_CONST CHAR gc_szLast_Modified[]			= "Last-Modified";
DEC_CONST CHAR gc_szLocation[]				= "Location";
DEC_CONST CHAR gc_szLockInfo[]				= "Lock-Info";
DEC_CONST CHAR gc_szLockToken[]				= "If";
DEC_CONST CHAR gc_szMS_Author_Via[]			= "MS-Author-Via";
DEC_CONST CHAR gc_szMS_Exchange_FlatURL[]	= "MS-Exchange-Permanent-URL";
DEC_CONST CHAR gc_szOverwrite[]				= "Overwrite";
DEC_CONST CHAR gc_szAllowRename[]			= "Allow-Rename";
DEC_CONST CHAR gc_szPublic[]				= "Public";
DEC_CONST CHAR gc_szRange[]					= "Range";
DEC_CONST CHAR gc_szReferer[]				= "Referer";
DEC_CONST CHAR gc_szRetry_After[]			= "Retry-After";
DEC_CONST CHAR gc_szServer[]				= "Server";
DEC_CONST CHAR gc_szSet_Cookie[]			= "Set-Cookie";
DEC_CONST CHAR gc_szTimeout[]				= "Timeout";
DEC_CONST CHAR gc_szTime_Out[]				= "Time-Out";
DEC_CONST CHAR gc_szTransfer_Encoding[]		= "Transfer-Encoding";
DEC_CONST CHAR gc_szTranslate[]				= "Translate";
DEC_CONST CHAR gc_szUpdate[]				= "Update";
DEC_CONST CHAR gc_szUser_Agent[]			= "User-Agent";
DEC_CONST CHAR gc_szVary[]					= "Vary";
DEC_CONST CHAR gc_szWarning[]				= "Warning";
DEC_CONST CHAR gc_szWWW_Authenticate[]		= "WWW-Authenticate";
DEC_CONST CHAR gc_szVersioning_Support[]	= "Versioning-Support";
DEC_CONST CHAR gc_szBrief[]					= "Brief";

//	ECB server variables ------------------------------------------------------
//
DEC_CONST CHAR gc_szHTTP_[]                 = "HTTP_";
DEC_CONST UINT gc_cchHTTP_					= CchConstString(gc_szHTTP_);
DEC_CONST CHAR gc_szServer_Protocol[]		= "SERVER_PROTOCOL";
DEC_CONST CHAR gc_szServer_Name[]			= "SERVER_NAME";
DEC_CONST CHAR gc_szServer_Port[]			= "SERVER_PORT";
DEC_CONST CHAR gc_szAuth_Type[]				= "AUTH_TYPE";
DEC_CONST CHAR gc_szHTTP_Version[]			= "HTTP_VERSION";
DEC_CONST CHAR gc_szAll_Raw[]				= "ALL_RAW";

//	ECB server variable values ------------------------------------------------
//
DEC_CONST CHAR gc_sz80[]					= "80";
DEC_CONST CHAR gc_sz443[]					= "443";
DEC_CONST CHAR gc_szBasic[]					= "Basic";

//	Verbs
//
DEC_CONST CHAR gc_szHEAD[]	= "HEAD";
DEC_CONST CHAR gc_szGET[]	= "GET";

//	Custom headers ------------------------------------------------------------
//
DEC_CONST CHAR gc_szX_MS_DEBUG_DAV[]		= "X-MS-Debug-DAV";
DEC_CONST CHAR gc_szX_MS_DEBUG_DAV_Signature[]	= "X-MS-Debug-DAV-Signature";

//	Depth values --------------------------------------------------------------
//
DEC_CONST CHAR gc_sz0[]					= "0";
DEC_CONST WCHAR gc_wsz0[]				= L"0";
DEC_CONST CHAR gc_sz1[]					= "1";
DEC_CONST WCHAR gc_wsz1[]				= L"1";
DEC_CONST CHAR gc_szInfinity[]			= "infinity";
DEC_CONST WCHAR gc_wszInfinity[]		= L"infinity";
DEC_CONST CHAR gc_sz1NoRoot[]			= "1,noroot";
DEC_CONST CHAR gc_szInfinityNoRoot[]	= "infinity,noroot";

//	Common header values ------------------------------------------------------
//
DEC_CONST CHAR gc_szClose[]					= "close";
DEC_CONST WCHAR gc_wszClose[]				= L"close";
DEC_CONST WCHAR gc_wszKeep_Alive[]			= L"Keep-Alive";
DEC_CONST CHAR gc_szNone[]					= "none";

DEC_CONST CHAR gc_szBytes[]					= "bytes";
DEC_CONST WCHAR gc_wszBytes[]				= L"bytes";
DEC_CONST INT gc_cchBytes					= CchConstString(gc_szBytes);
DEC_CONST WCHAR gc_wszRows[]				= L"rows";
DEC_CONST CHAR gc_szAnd[]					= "and";
DEC_CONST CHAR gc_szOr[]					= "or";
DEC_CONST WCHAR gc_wszNot[]					= L"not";
DEC_CONST WCHAR gc_wszInfinite[]			= L"Infinite";
DEC_CONST INT gc_cchInfinite				= CchConstString(gc_wszInfinite);
DEC_CONST WCHAR gc_wszSecondDash[]			= L"Second-";
DEC_CONST INT gc_cchSecondDash				= CchConstString(gc_wszSecondDash);

DEC_CONST CHAR gc_szMS_Author_Via_Dav[]		= "DAV";
DEC_CONST CHAR gc_szMS_Author_Via_Dav_Fp[]	= "MS-FP/4.0,DAV";

//	Lock Header values --------------------------------------------------------
//
DEC_CONST CHAR gc_szLockTimeoutFormat[]		= "Second-%d";
DEC_CONST INT gc_cchMaxLockTimeoutString	= CchConstString(gc_szLockTimeoutFormat) + 10;

//	Content-Type values -------------------------------------------------------
//
DEC_CONST CHAR gc_szText_XML[]				= "text/xml";
DEC_CONST WCHAR gc_wszText_XML[]			= L"text/xml";
DEC_CONST INT  gc_cchText_XML				= CchConstString(gc_szText_XML);
DEC_CONST CHAR gc_szApplication_XML[]	    = "application/xml";
DEC_CONST WCHAR gc_wszApplication_XML[]	    = L"application/xml";
DEC_CONST CHAR gc_szText_HTML[]				= "text/html";
DEC_CONST INT  gc_cchText_HTML				= CchConstString(gc_szText_HTML);
DEC_CONST CHAR gc_szAppl_Octet_Stream[]		= "application/octet-stream";
DEC_CONST WCHAR gc_wszAppl_Octet_Stream[]	= L"application/octet-stream";
DEC_CONST INT  gc_cchAppl_Octet_Stream		= CchConstString(gc_szAppl_Octet_Stream);
DEC_CONST CHAR gc_szAppl_X_WWW_Form[]		= "application/x-www-form-urlencoded";
DEC_CONST INT gc_cchAppl_X_WWW_Form			= CchConstString(gc_szAppl_X_WWW_Form);
DEC_CONST WCHAR gc_wszMultipart_Byterange[]	= L"multipart/byteranges";
DEC_CONST INT  gc_cchMultipart_Byterange	= CchConstString(gc_wszMultipart_Byterange);
DEC_CONST CHAR gc_szMultipart_FormData[]	= "multipart/form-data";
DEC_CONST INT  gc_cchMultipart_FormData		= CchConstString(gc_szMultipart_FormData);
DEC_CONST WCHAR gc_wszBoundary[]			= L"boundary";
DEC_CONST INT  gc_cchBoundary				= CchConstString(gc_wszBoundary);
DEC_CONST CHAR gc_szAppl_MIME[]				= "application/mime";
DEC_CONST INT  gc_cchAppl_MIME				= CchConstString(gc_szAppl_MIME);

//	Cache control -------------------------------------------------------------
//
DEC_CONST CHAR gc_szCache_Control[]			= "Cache-Control";
DEC_CONST CHAR gc_szCache_Control_Private[]	= "private";
DEC_CONST CHAR gc_szCache_Control_NoCache[] = "no-cache";
DEC_CONST CHAR gc_szCache_Control_MaxAge[]  = "max-age";
DEC_CONST ULONG gc_cchCache_Control_MaxAge	= CchConstString(gc_szCache_Control_MaxAge);
DEC_CONST CHAR gc_szCache_Control_MaxAgeZero[]  = "max-age=0";

//	Header emitters -----------------------------------------------------------
//
DEC_CONST CHAR gc_szCRLF[]					= "\r\n";
DEC_CONST WCHAR gc_wszCRLF[]				= L"\r\n";
DEC_CONST INT gc_cchCRLF					= CchConstString(gc_szCRLF);
DEC_CONST CHAR gc_szColonSp[]				= ": ";
DEC_CONST CHAR gc_szEmpty[]					= "";
DEC_CONST WCHAR gc_wszEmpty[]				= L"";

//	HTTP versions -------------------------------------------------------------
//
DEC_CONST CHAR gc_szHTTP[]					= "HTTP/";
DEC_CONST INT gc_cchHTTP					= CchConstString(gc_szHTTP);
DEC_CONST CHAR gc_szHTTP_0_9[]				= "HTTP/0.9";
DEC_CONST CHAR gc_szHTTP_1_0[]				= "HTTP/1.0";
DEC_CONST CHAR gc_szHTTP_1_1[]				= "HTTP/1.1";
DEC_CONST INT gc_cchHTTP_X_X				= CchConstString(gc_szHTTP_1_1);

DEC_CONST CHAR gc_szDavCompliance[]			= "DAV";

//	Default error -------------------------------------------------------------
//
DEC_CONST CHAR gc_szDefErr400StatusLine[]	= "400 Bad Request";
DEC_CONST CHAR gc_szDefErrStatusLine[]		= "500 Internal Server Failure";
DEC_CONST UINT gc_cchszDefErrStatusLine		= CchConstString(gc_szDefErrStatusLine);
DEC_CONST CHAR gc_szDefErrBody[] =
	"Content-Type: text/html\r\n"
	"Content-Length: 67\r\n"
	"\r\n"
	"<body><h1>"
	"HTTP/1.1 500 Internal Server Error(exception)"
	"</h1></body>";
DEC_CONST UINT gc_cchszDefErrBody			= CchConstString(gc_szDefErrBody);

//	Token error ---------------------------------------------------------------
//
DEC_CONST CHAR gc_szUsgErrBody[] =
	"Content-Type: text/html\r\n"
	"Content-Length: 69\r\n"
	"\r\n"
	"<body><h1>"
	"HTTP/1.1 500 Internal Server Error(USG support)"
	"</h1></body>";
DEC_CONST UINT gc_cchszUsgErrBody			= CchConstString(gc_szUsgErrBody);

//	INDEX response items ------------------------------------------------------
//
DEC_CONST WCHAR gc_wszAs[]					= L"as";
DEC_CONST WCHAR gc_wszCollectionResource[]	= L"DAV:collectionresource";
DEC_CONST WCHAR gc_wszContent_Encoding[]	= L"Content-Encoding";
DEC_CONST WCHAR gc_wszContent_Language[]	= L"Content-Language";
DEC_CONST WCHAR gc_wszContent_Length[]		= L"Content-Length";
DEC_CONST WCHAR gc_wszCreation_Date[]		= L"Creation-Date";
DEC_CONST WCHAR gc_wszDisplayName[]			= L"DisplayName";
DEC_CONST WCHAR gc_wszETag[]				= L"ETag";
DEC_CONST WCHAR gc_wszExternal[]			= L"External";
DEC_CONST WCHAR gc_wszHref[]				= L"href";
DEC_CONST WCHAR gc_wszIsCollection[]		= L"IsCollection";
DEC_CONST WCHAR gc_wszLast_Modified[]		= L"Last-Modified";
DEC_CONST WCHAR gc_wszMemberResource[]		= L"MemberResource";
DEC_CONST WCHAR gc_wszDav[]					= L"DAV:";
DEC_CONST WCHAR gc_wszProp[]				= L"DAV:prop";
DEC_CONST WCHAR gc_wszXML__Href[]			= L"DAV:href";
DEC_CONST WCHAR gc_wszXML__Namespace[]		= L"xml::namespace";

//	Partial response items ----------------------------------------------------
//
DEC_CONST WCHAR gc_wszErrorMessage[]		= L"DAV:responsedescription";
DEC_CONST WCHAR gc_wszStatus[]				= L"DAV:status";
DEC_CONST WCHAR gc_wszMultiResponse[]		= L"DAV:multistatus";
DEC_CONST WCHAR gc_wszResponse[]			= L"DAV:response";
DEC_CONST WCHAR gc_wszSearchResult[]		= L"DAV:searchresult";
DEC_CONST WCHAR gc_wszPropstat[] 			= L"DAV:propstat";
DEC_CONST WCHAR	gc_wszXML[]					= L"xml";
DEC_CONST WCHAR gc_wszContentRange[]		= L"DAV:contentrange";

//	Metadata items ------------------------------------------------------------
//
DEC_CONST WCHAR gc_wszCreate[]				= L"DAV:create";
DEC_CONST WCHAR gc_wszSet[]					= L"DAV:set";
DEC_CONST WCHAR gc_wszGetProps[]			= L"DAV:getprops";
DEC_CONST WCHAR gc_wszPropfind[]			= L"DAV:propfind";
DEC_CONST WCHAR gc_wszPropertyUpdate[]		= L"DAV:propertyupdate";
DEC_CONST WCHAR gc_wszRemove[]				= L"DAV:remove";
DEC_CONST WCHAR gc_wszAllprop[]				= L"DAV:allprop";
DEC_CONST WCHAR gc_wszFullFidelity[]		= L"http://schemas.microsoft.com/exchange/allprop";
DEC_CONST WCHAR gc_wszFullFidelityExclude[]	= L"http://schemas.microsoft.com/exchange/exclude";
DEC_CONST WCHAR gc_wszFullFidelityInclude[]	= L"http://schemas.microsoft.com/exchange/include";
DEC_CONST WCHAR gc_wszPropname[]			= L"DAV:propname";
DEC_CONST WCHAR gc_wszCollection[]			= L"DAV:collection";

//	Version history report items ----------------------------------------------
//
DEC_CONST WCHAR	gc_wszEnumReport[]			= L"DAV:enumreport";
DEC_CONST WCHAR gc_wszLimit[]				= L"DAV:limit";
DEC_CONST WCHAR	gc_wszReport[]				= L"DAV:report";
DEC_CONST WCHAR	gc_wszDavDefaultHistory[]	= L"DAV:defaulthistory";
DEC_CONST UINT	gc_cchDavDefaultHistory		= CchConstString (gc_wszDavDefaultHistory);
DEC_CONST WCHAR	gc_wszRevision[]			= L"DAV:revision";

//	Search items --------------------------------------------------------------
//
DEC_CONST CHAR gc_szDasl[]					= "DASL";
DEC_CONST CHAR gc_szSqlQuery[]				= "<DAV:sql>";

DEC_CONST WCHAR gc_wszSearchRequest[]		= L"DAV:searchrequest";
DEC_CONST WCHAR gc_wszResoucetype[]			= L"DAV:resourcetype";
DEC_CONST WCHAR gc_wszStructureddocument[]	= L"DAV:structureddocument";
DEC_CONST WCHAR gc_wszSimpleSearch[]		= L"DAV:simple-search";
DEC_CONST WCHAR gc_wszType[]				= L"DAV:type";
DEC_CONST WCHAR gc_wszQuery[]				= L"DAV:query";
DEC_CONST WCHAR gc_wszSql[]					= L"DAV:sql";
DEC_CONST WCHAR gc_wszSelect[]				= L"Select";
DEC_CONST WCHAR gc_wszFrom[]				= L"From";
DEC_CONST WCHAR	gc_wszWhere[] 				= L"Where";
DEC_CONST WCHAR gc_wszOrder[]				= L"Order";
DEC_CONST WCHAR gc_wszBy[]					= L"By";
DEC_CONST WCHAR gc_wszServerHints[]			= L"DAV:serverhints";
DEC_CONST WCHAR	gc_wszMaxResults[]			= L"DAV:maxresults";
DEC_CONST WCHAR	gc_wszScope[] 				= L"Scope";
DEC_CONST WCHAR gc_wszRange[]				= L"DAV:range";
DEC_CONST WCHAR gc_wszRangeType[]			= L"DAV:type";
DEC_CONST WCHAR gc_wszRangeRows[]			= L"DAV:rows";
DEC_CONST WCHAR gc_wszExpansion[]			= L"DAV:expansion";

DEC_CONST WCHAR gc_wszStatic[]				= L"static";
DEC_CONST WCHAR gc_wszDynamic[]				= L"dynamic";

//	Batch method items --------------------------------------------------------
//
DEC_CONST WCHAR gc_wszTarget[]				= L"DAV:target";
DEC_CONST WCHAR gc_wszDelete[]				= L"DAV:delete";
DEC_CONST WCHAR gc_wszCopy[]				= L"DAV:copy";
DEC_CONST WCHAR gc_wszMove[]				= L"DAV:move";
DEC_CONST WCHAR gc_wszDest[]				= L"DAV:dest";
DEC_CONST WCHAR gc_wszLocation[]			= L"DAV:location";

//	Property types ------------------------------------------------------------
//
DEC_CONST WCHAR gc_wszLexType[]				= L"urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/dt";
DEC_CONST INT   gc_cchLexType				= CchConstString (gc_wszLexType);
DEC_CONST WCHAR gc_wszLexTypeOfficial[]		= L"uuid:C2F41010-65B3-11d1-A29F-00AA00C14882#dt";
DEC_CONST WCHAR gc_wszDataTypes[]			= L"urn:schemas-microsoft-com:datatypes#dt";
DEC_CONST WCHAR gc_wszFlags[]				= L"urn:schemas:httpmail:flags";

DEC_CONST WCHAR gc_wszHrefAttribute[]		= L"urn:schemas:href";
DEC_CONST INT   gc_cchHrefAttribute			= CchConstString (gc_wszHrefAttribute);

DEC_CONST WCHAR gc_wszDavType_String[]		= L"string";
DEC_CONST WCHAR gc_wszDavType_Date_ISO8601[]= L"dateTime.tz";
DEC_CONST WCHAR gc_wszDavType_Date_Rfc1123[]= L"dateTime.rfc1123";
DEC_CONST WCHAR gc_wszDavType_Float[]		= L"float";
DEC_CONST WCHAR gc_wszDavType_Boolean[]		= L"boolean";
DEC_CONST WCHAR gc_wszDavType_Int[]			= L"int";
DEC_CONST WCHAR gc_wszDavType_Mvstring[]	= L"mv.string";
DEC_CONST WCHAR gc_wszDavType_Bin_Base64[]	= L"bin.base64";
DEC_CONST WCHAR gc_wszDavType_Bin_Hex[]		= L"bin.hex";
DEC_CONST WCHAR gc_wszDavType_I2[]			= L"i2";
DEC_CONST WCHAR gc_wszDavType_I8[]			= L"i8";
DEC_CONST WCHAR gc_wszDavType_R4[]			= L"r4";
DEC_CONST WCHAR gc_wszDavType_Fixed_14_4[]  = L"fixed.14.4";
DEC_CONST WCHAR gc_wszDavType_Uuid[]		= L"uuid";
DEC_CONST WCHAR gc_wszDavType_MV[]			= L"mv.";
DEC_CONST WCHAR gc_wszUri[]					= L"uri";

//	multivalue property	-------------------------------------------------------
//
DEC_CONST WCHAR gc_wszXml_V[]				= L"xml:v";

//	URI Construction ----------------------------------------------------------
//
DEC_CONST CHAR gc_szUrl_Prefix[]			= "http://";
DEC_CONST WCHAR gc_wszUrl_Prefix[]			= L"http://";
DEC_CONST INT gc_cchszUrl_Prefix			= CchConstString(gc_szUrl_Prefix);
DEC_CONST CHAR gc_szUrl_Prefix_Secure[]		= "https://";
DEC_CONST WCHAR gc_wszUrl_Prefix_Secure[]	= L"https://";
DEC_CONST INT gc_cchszUrl_Prefix_Secure		= CchConstString(gc_szUrl_Prefix_Secure);
DEC_CONST WCHAR	gc_wszFileScheme[]			= L"file://";
DEC_CONST INT gc_strlenFileScheme			= CchConstString(gc_wszFileScheme);

DEC_CONST WCHAR gc_wszUrl_Port_80[]			= L":80";
DEC_CONST INT gc_cchUrl_Port_80				= CchConstString(gc_wszUrl_Port_80);
DEC_CONST WCHAR gc_wszUrl_Port_443[]		= L":443";
DEC_CONST INT gc_cchUrl_Port_443			= CchConstString(gc_wszUrl_Port_443);

//	Special metaprops ---------------------------------------------------------
//
DEC_CONST WCHAR	gc_wszProp_ContentType[]	= L"ContentType";

//	Performance counters ------------------------------------------------------
//
DEC_CONST WCHAR	gc_wsz_Total[]				= L"_Total";

//	Metabase strings ----------------------------------------------------------
//
DEC_CONST WCHAR gc_wsz_Lm_MimeMap[]			= L"/lm/MimeMap";
DEC_CONST INT gc_cch_Lm_MimeMap				= CchConstString(gc_wsz_Lm_MimeMap);

DEC_CONST WCHAR gc_wsz_Lm_W3Svc[]			= L"/lm/w3svc";
DEC_CONST INT gc_cch_Lm_W3Svc				= CchConstString(gc_wsz_Lm_W3Svc);

DEC_CONST WCHAR gc_wsz_Root[]				= L"/root";
DEC_CONST INT gc_cch_Root					= CchConstString(gc_wsz_Root);
DEC_CONST WCHAR gc_wsz_Star[]				= L"*";

//	Lock strings --------------------------------------------------------------
//
DEC_CONST WCHAR gc_wszOpaquelocktokenPrefix[] = L"opaquelocktoken:";
DEC_CONST INT   gc_cchOpaquelocktokenPrefix  = CchConstString(gc_wszOpaquelocktokenPrefix);
DEC_CONST WCHAR gc_wszLockTypeRead[]         = L"DAV:read";
DEC_CONST CHAR  gc_szLockTokenHeader[]       = "Lock-Token";
DEC_CONST WCHAR gc_wszGuidFormat[]          = L"%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X";

//  Size in characters required for an ascii string which contains
//  a GUID in the swprintf'ed gc_wszGuidFormat
//
DEC_CONST INT   gc_cchMaxGuid                = 37;  // Not the size of format string: size of formatted guid

//	CRC'd strings -------------------------------------------------------------
//
//	IMPORTANT: if you feel the need to change any of these strings, then you
//	really need to re-crc it and update the value.  Failure to do so will cause
//	unpredicitible results and possible termination (of the app, not you).
//
//	The CRC's are maintained in the impls' meta sources

#define IanaItem(_sz)							\
	DEC_CONST WCHAR gc_wszProp_iana_##_sz[] =	\
		L"DAV:" L#_sz;							\

IanaItem(getcontentencoding);
IanaItem(getcontentlanguage);
IanaItem(getcontentlength);
IanaItem(getcontenttype);
IanaItem(creationdate);
IanaItem(displayname);
IanaItem(getetag);
IanaItem(filename);
IanaItem(getlastmodified);
IanaItem(externalmembers);
IanaItem(resourcetype);
IanaItem(ishidden);
IanaItem(iscollection);

enum { MAX_LOCKTOKEN_LENGTH = 256 };

#endif	// !_EX_SZ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\xprs.h ===
/*
 *	X P R S . H
 *
 *	XML push-model parsing
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_EX_XPRS_H_
#define _EX_XPRS_H_

#include <xmlparser.h>
#include <ex\autoptr.h>
#include <ex\nmspc.h>
#include <davsc.h>
#include <exo.h>

//	XML Namespace scopes ------------------------------------------------------
//
class CXmlnsScope
{
private:

	//	Ref' counting.
	//
	//	!!! Please note that this is NON-THREADSAFE !!!
	//
	//	CXNodes should be operated on a single thread at
	//	any given time.
	//
	LONG					m_cRef;

public:

	void AddRef()			{ m_cRef++; }
	void Release()			{ if (0 == --m_cRef) delete this; }

private:

	auto_ref_ptr<CNmspc>	m_pns;

	//	non-implemented
	//
	CXmlnsScope(const CXmlnsScope& p);
	CXmlnsScope& operator=(const CXmlnsScope& p);

public:

	~CXmlnsScope() {}
	CXmlnsScope()
			: m_cRef(1)
	{
	}

	VOID ScopeNamespace(CNmspc* pns)
	{
		//	Set the current top of the sibling chain as a sibling
		//	to this namespace.
		//
		pns->SetSibling (m_pns.get());

		//	Set this new namespace as the top of the sibling chain.
		//
		m_pns = pns;
	}

	VOID LeaveScope(CNmspcCache* pnsc)
	{
		auto_ref_ptr<CNmspc> pns;

		while (m_pns.get())
		{
			//	Unhook the namespace
			//
			pns = m_pns;
			m_pns = m_pns->PnsSibling();

			//	Remove it from the indexes
			//
			pnsc->RemovePersisted (pns);
		}
	}
};

//	class CXMLNodeFactory -----------------------------------------------------
//
class CNodeFactory :
	public EXO,
	public IXMLNodeFactory,
	public CParseNmspcCache
{
	StringBuffer<WCHAR> m_sbValue;

	//	State tracking
	//
	typedef enum {

		ST_NODOC,
		ST_PROLOGUE,
		ST_INDOC,
		ST_INATTR,
		ST_INATTRDATA,
		ST_XMLERROR

	} PARSE_STATE;
	PARSE_STATE m_state;
	HRESULT m_hrParserError;

	//	Unhandled nodes -------------------------------------------------------
	//
	UINT m_cUnhandled;

	VOID PushUnhandled()
	{
		++m_cUnhandled;
		XmlTrace ("Xml: incrementing unhandled node depth\n"
				  "  m_cUnhandled: %ld\n",
				  m_cUnhandled);
	}

	VOID PopUnhandled()
	{
		--m_cUnhandled;
		XmlTrace ("Xml: decrementing unhandled node depth\n"
				  "  m_cUnhandled: %ld\n",
				  m_cUnhandled);
	}

	//	non-implemented
	//
	CNodeFactory(const CNodeFactory& p);
	CNodeFactory& operator=(const CNodeFactory& p);

protected:

	//	FIsTag() --------------------------------------------------------------
	//
	//	FIsTag() can be used in XML parsing code as a shortcut to see if
	//	the str from a xml element matches a fully qualified tagname. An
	//	important distinction here, is that FIsTag() will allow for non-
	//	qualified short-names.  So, FIsTag() should never be used in any
	//	place where the tag is not scoped by the standard dav namespace.
	//
	//		ie. "DAV:foo" and "foo" will match.
	//
	inline BOOL FIsTag (LPCWSTR pwszTag, LPCWSTR pwszExpected)
	{
		Assert (wcslen(pwszExpected) > CchConstString(gc_wszDav));
		return (!_wcsicmp (pwszTag, pwszExpected) ||
				!_wcsicmp (pwszTag, pwszExpected + CchConstString(gc_wszDav)));
	}

public:

	virtual ~CNodeFactory() {}
	CNodeFactory()
			: m_state(ST_NODOC),
			  m_hrParserError(S_OK),
			  m_cUnhandled(0)
	{
		INIT_TRACE(Xml);
	}

	//	EXO support
	//
	EXO_INCLASS_DECL(CNodeFactory);

	//	INodeFactory ----------------------------------------------------------
	//
	virtual HRESULT STDMETHODCALLTYPE NotifyEvent(
		/* [in] */ IXMLNodeSource __RPC_FAR *pSource,
		/* [in] */ XML_NODEFACTORY_EVENT iEvt);

	virtual HRESULT STDMETHODCALLTYPE BeginChildren(
		/* [in] */ IXMLNodeSource __RPC_FAR *pSource,
		/* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo);

	virtual HRESULT STDMETHODCALLTYPE EndChildren(
		/* [in] */ IXMLNodeSource __RPC_FAR *pSource,
		/* [in] */ BOOL fEmpty,
		/* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo);

	virtual HRESULT STDMETHODCALLTYPE Error(
		/* [in] */ IXMLNodeSource __RPC_FAR *pSource,
		/* [in] */ HRESULT hrErrorCode,
		/* [in] */ USHORT cNumRecs,
		/* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo);

	virtual HRESULT STDMETHODCALLTYPE CreateNode(
		/* [in] */ IXMLNodeSource __RPC_FAR *pSource,
		/* [in] */ PVOID pNodeParent,
		/* [in] */ USHORT cNumRecs,
		/* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *pNodeInfo);

	//	CNodeFactory specific methods -----------------------------------------
	//
	virtual SCODE ScCompleteAttribute (void) = 0;

	virtual SCODE ScCompleteChildren (
		/* [in] */ BOOL fEmptyNode,
		/* [in] */ DWORD dwType,
		/* [in] */ const WCHAR __RPC_FAR *pwcText,
		/* [in] */ ULONG ulLen) = 0;

	virtual SCODE ScHandleNode (
		/* [in] */ DWORD dwType,
		/* [in] */ DWORD dwSubType,
		/* [in] */ BOOL fTerminal,
		/* [in] */ const WCHAR __RPC_FAR *pwcText,
		/* [in] */ ULONG ulLen,
		/* [in] */ ULONG ulNamespaceLen,
		/* [in] */ const WCHAR __RPC_FAR *pwcNamespace,
		/* [in] */ const ULONG ulNsPrefixLen) = 0;

	//	Most implementation do not need this method, lock requires it for
	//	proper processing of the owner node.
	//
	virtual SCODE ScCompleteCreateNode (
		/* [in] */ DWORD)
	{
		return S_OK;
	}

	//	Parser errors ---------------------------------------------------------
	//
	BOOL FParserError(SCODE sc) const
	{
		return (FAILED (m_hrParserError) ||
				((sc & 0xFFFFFF00) == XML_E_PARSEERRORBASE));
	}
};

//	ScInstatiateParser() ------------------------------------------------------
//
//	Raid X5:136451
//	The XML parser in the version of MSXML.DLL released with Windows 2000
//	doesn't fail properly when given a XML document shorter than a certain
//	length.  CB_XML_PARSER_MIN is the minimum length of an XML document, in
//	bytes, required to avoid this bug.  One must explicitly check that a
//	document is at least this long before feeding it to the XML parser.
//
enum { CB_XML_PARSER_MIN = 2 };
SCODE ScNewXMLParser (CNodeFactory* pnf, IStream * pstm, IXMLParser ** ppxprs);
SCODE ScParseXML (IXMLParser * pxprs, CNodeFactory * pnf);
SCODE ScParseXMLBuffer (CNodeFactory* pnf, LPCWSTR pwszXML);

//	Parsers -------------------------------------------------------------------
//
//	CPropContext --------------------------------------------------------------
//
//	The property context is used specifically in <DAV:prop> node processing.
//	The components of the property are constructed across multiple calls and
//	are implementation dependant.
//
class CPropContext
{
private:

	//	Ref' counting.
	//
	//	!!! Please note that this is NON-THREADSAFE !!!
	//
	//	CXNodes should be operated on a single thread at
	//	any given time.
	//
	LONG					m_cRef;

public:

	void AddRef()			{ m_cRef++; }
	void Release()			{ if (0 == --m_cRef) delete this; }

private:
	//	non-implemented operators
	//
	CPropContext( const CPropContext& );
	CPropContext& operator=( const CPropContext& );

public:

	virtual ~CPropContext() {}
	CPropContext()
			: m_cRef(1) // com-style refcounting
	{
	}

	virtual SCODE ScSetType(
		/* [in] */ LPCWSTR pwszType) = 0;

	virtual SCODE ScSetValue(
		/* [in] */ LPCWSTR pwszValue,
		/* [in] */ UINT cmvValues) = 0;

	virtual SCODE ScComplete(
		/* [in] */ BOOL fEmpty) = 0;

	virtual BOOL FMultiValued( void ) = 0;

	virtual SCODE ScSetFlags(DWORD dw)	{ return S_OK; }
};

//	CValueContext -------------------------------------------------------------
//
//	When a parser encounters a property, a context is needed such that
//	construction of the property value is possible.
//
class CValueContext
{
	//	non-implemented operators
	//
	CValueContext( const CValueContext& );
	CValueContext& operator=( const CValueContext& );

public:

	CValueContext() {}
	virtual ~CValueContext() {}

	//	When the parser finds an item that the client wants operated on,
	//	the item is added to the context via the following set context
	//	methods.  Each request is qualified by the resource on which the
	//	request is made.
	//
	virtual SCODE ScSetProp(
		/* [in] */ LPCWSTR pwszPath,
		/* [in] */ LPCWSTR pwszProp,
		/* [in] */ auto_ref_ptr<CPropContext>& pPropCtx) = 0;
};

#endif	// _EX_XPRS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_crc\calcrc.c ===
/*
 *	C A L C R C . C
 *
 *	CRC (Cyclic Redundancy Check) Calculation Utilities
 *
 *	Copyright 1993-1997 Microsoft Corporation. All Rights Reserved.
 */

//	We get this warning, C4115, in rpcasync.h
#pragma warning(disable:4115)	/* named type definition in parentheses */

#include <windows.h>
#include <crc.h>

//	DwComputeCRC --------------------------------------------------------------
//
//	The table which follows was computed using the following function:
//
//	#define CRC_POLYNOMIAL 0xEDB88320
//
//	DWORD ComputeCRCByte(BYTE b)
//	{
//		DWORD	dwCRC = b;
//		int	   i;
//
//		for (i = 8; --i >= 0; )
//			dwCRC = ((dwCRC & 1) ? ((dwCRC >> 1) ^ CRC_POLYNOMIAL)
//						: (dwCRC >> 1));
//
//		return dwCRC;
//	}
//
const DWORD g_rgdwCRC[] =
{
	0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,
	0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
	0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
	0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
	0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
	0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
	0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
	0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
	0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
	0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
	0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,
	0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
	0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,
	0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
	0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
	0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
	0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,
	0xA4D1C46D, 0xD3D6F4FB,	0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
	0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,	0x5005713C, 0x270241AA,
	0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
	0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
	0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
	0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,
	0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
	0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
	0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
	0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,
	0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
	0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,
	0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
	0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,
	0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
	0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,
	0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
	0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
	0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
	0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,
	0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
	0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,
	0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
	0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,
	0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
	0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
};

DWORD
DwComputeCRC(DWORD dwCRC, PVOID pv, UINT cb)
{
	BYTE * pb = (BYTE *)pv;
	DWORD dw;

	while (cb && ((DWORD_PTR)pb & 3))
	{
		dwCRC = CRC_COMPUTE(dwCRC, *pb++);
		cb--;
	}
	if (cb)
	{
		while (cb >= sizeof(DWORD))
		{
			dw = *((DWORD *)pb);
			pb += sizeof(DWORD); 
			dwCRC = CRC_COMPUTE(dwCRC, dw);
			dw >>= 8;
			dwCRC = CRC_COMPUTE(dwCRC, dw);
			dw >>= 8;
			dwCRC = CRC_COMPUTE(dwCRC, dw);
			dw >>= 8;
			dwCRC = CRC_COMPUTE(dwCRC, dw);
			cb -= sizeof(DWORD);
		}

		while (cb--)
			dwCRC = CRC_COMPUTE(dwCRC, *pb++);
	}
	return dwCRC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\xmldata.h ===
/*
 *	X M L D A T A . H
 *
 *	Sources Exchange messaging implementation of DAV-Base --
 *	XML-Data types.
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_EX_XMLDATA_H_
#define _EX_XMLDATA_H_

#include <mapidefs.h>

//#define INT64_MIN 0x8000000000000000

//	Data types ----------------------------------------------------------------
//
DEC_CONST WCHAR wszWebClientTime[]	= L"dateTime.wc.";

USHORT __fastcall
UsPtypeFromName (
	/* [in] */ LPCWSTR pwszAs,
	/* [in] */ UINT cchAs,
	/* [out] */ USHORT* pusCnvt);

enum {

	CNVT_DEFAULT = 0,
	CNVT_ISO8601,
	CNVT_RFC1123,
	CNVT_UUID,
	CNVT_BASE64,
	CNVT_BINHEX,
	CNVT_01,
	CNVT_CUSTOMDATE,
	CNVT_LIMITED,
};

//	Data conversions ----------------------------------------------------------
//
SCODE ScInBase64Literal (LPCWSTR, UINT, BOOL, SBinary*);
SCODE ScInBinhexLiteral (LPCWSTR, UINT, BOOL, SBinary*);
SCODE ScInIso8601Literal (LPCWSTR, UINT, BOOL, FILETIME*);
SCODE ScInRfc1123Literal (LPCWSTR, UINT, BOOL, FILETIME*);
SCODE ScInUuidLiteral (LPCWSTR, UINT, BOOL, GUID*);

#endif	// _EX_XMLDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\body.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	BODY.CPP
//
//		Common implementation classes from which request body and
//		response body are derived.
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include <_davprs.h>
#include <body.h>



//	========================================================================
//
//	CLASS IAcceptObserver
//

//	------------------------------------------------------------------------
//
//	IAcceptObserver::~IAcceptObserver()
//
//		Out of line virtual destructor necessary for proper deletion
//		of objects of derived classes via this class
//
IAcceptObserver::~IAcceptObserver() {}



//	========================================================================
//
//	CLASS IAsyncPersistObserver
//

//	------------------------------------------------------------------------
//
//	IAsyncPersistObserver::~IAsyncPersistObserver()
//
//		Out of line virtual destructor necessary for proper deletion
//		of objects of derived classes via this class
//
IAsyncPersistObserver::~IAsyncPersistObserver() {}



//	========================================================================
//
//	CLASS IAsyncIStreamObserver
//

//	------------------------------------------------------------------------
//
//	IAsyncIStreamObserver::~IAsyncIStreamObserver()
//
//		Out of line virtual destructor necessary for proper deletion
//		of objects of derived classes via this class
//
IAsyncIStreamObserver::~IAsyncIStreamObserver() {}


//	========================================================================
//
//	CLASS CIStreamAsyncStream
//
class CIStreamAsyncStream : public IAsyncStream
{
	//
	//	The OLE IStream
	//
	IStream& m_stm;

	//	NOT IMPLEMENTED
	//
	CIStreamAsyncStream( const CIStreamAsyncStream& );
	CIStreamAsyncStream& operator=( const CIStreamAsyncStream& );

public:
	//	CREATORS
	//
	CIStreamAsyncStream( IStream& stm ) : m_stm(stm) {}

	//	ACCESSORS
	//
	void AsyncWrite( const BYTE * pbBuf,
					 UINT         cbToWrite,
					 IAsyncWriteObserver& obsAsyncWrite );
};

//	------------------------------------------------------------------------
//
//	CIStreamAsyncStream::AsyncWrite()
//
void
CIStreamAsyncStream::AsyncWrite(
	const BYTE * pbBuf,
	UINT         cbToWrite,
	IAsyncWriteObserver& obsAsyncWrite )
{
	ULONG cbWritten;
	HRESULT hr;

	hr = m_stm.Write( pbBuf,
					  cbToWrite,
					  &cbWritten );

	obsAsyncWrite.WriteComplete( cbWritten, hr );
}


//	========================================================================
//
//	CLASS IBodyPartVisitor
//

//	------------------------------------------------------------------------
//
//	IBodyPartVisitor::~IBodyPartVisitor()
//
//		Out of line virtual destructor necessary for proper deletion
//		of objects of derived classes via this class
//
IBodyPartVisitor::~IBodyPartVisitor() {}



//	========================================================================
//
//	CLASS IBodyPart
//

//	------------------------------------------------------------------------
//
//	IBodyPart::~IBodyPart()
//
//		Out of line virtual destructor necessary for proper deletion
//		of objects of derived classes via this class
//
IBodyPart::~IBodyPart() {}


//	------------------------------------------------------------------------
//
//	CTextBodyPart::CTextBodyPart()
//
CTextBodyPart::CTextBodyPart( UINT cbText, LPCSTR lpszText )
{
	AddTextBytes( cbText, lpszText );
}

//	------------------------------------------------------------------------
//
//	CTextBodyPart::CTextBodyPart()
//
VOID
CTextBodyPart::AddTextBytes( UINT cbText, LPCSTR lpszText )
{
	m_bufText.Append( cbText, lpszText );
}

//	------------------------------------------------------------------------
//
//	CTextBodyPart::Rewind()
//
VOID
CTextBodyPart::Rewind()
{
	//
	//	Since a text body part is implemented as a randomly-
	//	accessible array there is nothing to "rewind".
	//
}

//	------------------------------------------------------------------------
//
//	CTextBodyPart::Accept()
//
VOID
CTextBodyPart::Accept( IBodyPartVisitor& v,
					   UINT64 ibPos64,
					   IAcceptObserver& obsAccept )
{
	Assert( ibPos64 < m_bufText.CbSize() );

	//
	//	Just visit all of the remaining text in the buffer.  The visitor
	//	may not process it all, but that will be reflected in the next
	//	call to this function.
	//		NOTE: To be compatable with IBodyPart the position is passed
	//	in as 64 bit value (this is necessary to support file body parts
	//	that are bigger than 4GB). However we do not want anyone to create
	//	text body parts that are bigger than 4GB. So assert that it is not
	//	the case here and truncate the passed in 64 bit value to 32 bits.
	//
	Assert(0 == (0xFFFFFFFF00000000 & ibPos64));

	v.VisitBytes(
		reinterpret_cast<const BYTE *>(m_bufText.PContents()) + static_cast<UINT>(ibPos64),
		m_bufText.CbSize() - static_cast<UINT>(ibPos64),
		obsAccept );
}


//	========================================================================
//
//	CLASS CFileBodyPart
//

//	------------------------------------------------------------------------
//
//	CFileBodyPart::CFileBodyPart()
//
CFileBodyPart::CFileBodyPart( const auto_ref_handle& hf,
							  UINT64 ibFile64,
							  UINT64 cbFile64 ) :
   m_hf(hf),
   m_ibFile64(ibFile64),
   m_cbFile64(cbFile64)
{

	//	We do not support byteranges on the files larger than 4GB. But due to the fact that byterange
	//	processing is all DWORD based in adition to the check for default file length value we do the
	//	check for default byterange value. If _HSE_TF_INFO will ever be fixed to take file size values
	//	larger than DWORD then we would be able to move our byterange processing to UINT64 base and
	//	the second check below would go away.
	//
	if ((0xFFFFFFFFFFFFFFFF == cbFile64) ||	//	If we got the default file length value indicating that we want data up to the end of the file
		(0x00000000FFFFFFFF == cbFile64))	//	If we got the default byterange value indicating that we want the data up to the end of the file
	{
		LARGE_INTEGER cbFileSize;

		if (!GetFileSizeEx(hf.get(), &cbFileSize))
		{
			DebugTrace( "CFileBodyPart::CFileBodyPart() - GetFileSizeEx() failed with last error (0x%08lX)\n", GetLastError() );
			throw CLastErrorException();
		}

		m_cbFile64 = cbFileSize.QuadPart;
	}
}

//	------------------------------------------------------------------------
//
//	CFileBodyPart::Rewind()
//
VOID
CFileBodyPart::Rewind()
{
	//
	//	Since the files in file body parts are opened overlapped,
	//	they do not have internal file pointers, hence they never
	//	need to be rewound.
	//
}

//	------------------------------------------------------------------------
//
//	CFileBodyPart::Accept()
//
VOID
CFileBodyPart::Accept( IBodyPartVisitor& v,
					   UINT64 ibPos64,
					   IAcceptObserver& obsAccept )
{
	if (ibPos64 < m_cbFile64)
	{
		//
		//	Just visit the remainder of the file.  The visitor
		//	may not process it all, but that will be reflected in the next
		//	call to this function.
		//
		v.VisitFile( m_hf,
					 m_ibFile64 + ibPos64,
					 m_cbFile64 - ibPos64,
					 obsAccept );
	}
	else
	{
		//
		//	We should always have something to accept unless we have a
		//	0-length file body part.  In that case, just tell the observer
		//	how much was visited: nothing.
		//
		obsAccept.AcceptComplete(0);
	}
}


//	========================================================================
//
//	CLASS CAsyncReadVisitor
//
//	A body part visitor that asynchronously reads body parts into
//	a fixed size, caller-supplied, buffer.
//
class CAsyncReadVisitor :
	public IBodyPartVisitor,
	private IAsyncReadObserver
{
	//
	//	Error information
	//
	HRESULT	m_hr;

	//
	//	User's buffer and its size
	//
	LPBYTE	m_pbBufUser;
	UINT	m_cbBufUser;

	//
	//	Accept observer passed to VisitStream().  This observer must
	//	be stashed in a member variable because reading from the stream
	//	is asynchronous and we need to be able to notify the observer
	//	when the read completes.
	//
	IAcceptObserver * m_pobsAccept;

	//
	//	IBodyPartVisitor
	//
	VOID VisitBytes( const BYTE * pbData,
					 UINT         cbToRead,
					 IAcceptObserver& obsAccept );

	VOID VisitFile( const auto_ref_handle& hf,
					UINT64   ibOffset64,
					UINT64   cbToRead64,
					IAcceptObserver& obsAccept );

	VOID VisitStream( IAsyncStream& stm,
					  UINT cbToRead,
					  IAcceptObserver& obsAccept );

	VOID VisitComplete();

	//
	//	IAsyncReadObserver for async streams visited via VisitStream()
	//
	VOID ReadComplete( UINT cbRead, HRESULT hr );

	//	NOT IMPLEMENTED
	//
	CAsyncReadVisitor( const CAsyncReadVisitor& );
	CAsyncReadVisitor& operator=( const CAsyncReadVisitor& );

public:
	//	CREATORS
	//
	CAsyncReadVisitor() :
			//	Always start with clean member variables
			m_hr(S_OK),
			m_pbBufUser(NULL),
			m_cbBufUser(0),
			m_pobsAccept(NULL)
	{
	}

	//	ACCESSORS
	//
	HRESULT Hresult() const { return m_hr; }

	//	MANIPULATORS
	//
	VOID
	Configure( LPBYTE pbBufUser,
			   UINT   cbBufUser )
	{
		m_pbBufUser = pbBufUser;
		m_cbBufUser = cbBufUser;
		//	Also reset our HRESULT
		m_hr = S_OK;
	}
};

//	------------------------------------------------------------------------
//
//	CAsyncReadVisitor::VisitBytes()
//
VOID
CAsyncReadVisitor::VisitBytes( const BYTE * pbData,
							   UINT         cbToRead,
							   IAcceptObserver& obsAccept )
{
	cbToRead = min(cbToRead, m_cbBufUser);

	memcpy(m_pbBufUser, pbData, cbToRead);

	obsAccept.AcceptComplete(cbToRead);
}

//	------------------------------------------------------------------------
//
//	CAsyncReadVisitor::VisitFile()
//
//	Not implemented because 1) request bodies cannot have file
//	body parts and 2) CAsyncReadVisitor is currently only used
//	with request bodies.  Should we ever need this for response
//	bodies we'll need to write the code at that point.
//
//	The old implementation used ReadFileEx() to read from the file
//	asynchronously.  In a nutshell, we couldn't use ReadFileEx()
//	because it relied on APC for calling back its completion routine.
//	APC in turn required the calling thread to enter an alertable
//	wait state.  Typically, we would only call VisitFile() from an
//	I/O completion port thread pool, and those threads are never
//	in an alertable wait state, thus the completion routine for
//	ReadFileEx() would never be called.
//
VOID
CAsyncReadVisitor::VisitFile( const auto_ref_handle&,
							  UINT64,
							  UINT64,
							  IAcceptObserver& obsAccept )
{
	TrapSz( "CAsyncReadVisitor::VisitFile() is not implemented!!" );

	//
	//	If, for whatever random reason, someone actually does call
	//	this function, at least do something predictable: fail gracefully.
	//
	m_hr = E_FAIL;
	obsAccept.AcceptComplete( 0 );
}

//	------------------------------------------------------------------------
//
//	CAsyncReadVisitor::VisitStream()
//
VOID
CAsyncReadVisitor::VisitStream( IAsyncStream& stmSrc,
								UINT cbToRead,
								IAcceptObserver& obsAccept )
{
	//
	//	Read into our user's buffer only as much of the stream as is
	//	immediately available -- i.e. the amount of data that can be
	//	read without pending the read operation.  Note that on input
	//	cbToRead is the amount of data remaining to be read from the
	//	stream -- it is not all necessarily immediately available.
	//
	//	X5 162502: This used to say min(stmSrc.CbReady(),...) here
	//	instead of min(cbToRead,...).  This was not a problem on IIS5
	//	because there was always at least some data immediately available
	//	when our ISAPI was called.  However, on the Local Store, it may
	//	be such that when we call the ISAPI, there is no data immediately
	//	available.  This turned out to be a problem because we would get
	//	here and cbToRead would be assigned to 0, which would end up
	//	making it look like we'd finished (end of stream), which would
	//	cause XML parse errors (0-byte XML bodies don't parse well!).
	//
	cbToRead = min(cbToRead, m_cbBufUser);

	//
	//	Save off the observer and start reading.  Even though this is
	//	an AsyncRead() call, we have limited the request to what can
	//	be read immediately, so our ReadComplete() should be called
	//	before the AsyncRead() call returns.  This is important because
	//	we are reading directly into the user's buffer.  The buffer
	//	is valid for the duration of this visit.
	//
	m_pobsAccept = &obsAccept;
	stmSrc.AsyncRead(m_pbBufUser, cbToRead, *this);
}

//	------------------------------------------------------------------------
//
//	CAsyncReadVisitor::ReadComplete()
//
//	Called when the AsyncRead() of the stream by VisitStream() completes.
//
VOID
CAsyncReadVisitor::ReadComplete( UINT cbRead, HRESULT hr )
{
	//
	//	Latch in any error returned.
	//
	m_hr = hr;

	//
	//	Notify our observer of the number of bytes read.
	//
	Assert(m_pobsAccept);
	m_pobsAccept->AcceptComplete(cbRead);
}

//	------------------------------------------------------------------------
//
//	CAsyncReadVisitor::VisitComplete()
//
VOID
CAsyncReadVisitor::VisitComplete()
{
	m_hr = S_FALSE;
}

//	========================================================================
//
//	CLASS CAsyncCopyToVisitor
//
//	A body part visitor that asynchronously copies body parts into
//	a destination async stream.
//
class CAsyncCopyToVisitor :
	public IBodyPartVisitor,
	private IAsyncWriteObserver,
	private IAsyncCopyToObserver
{
	//
	//	CAsyncCopyToVisitor forwards its refcounting calls to this
	//	parent object (settable via SetRCParent()).  We are a non-refcounted
	//	member of another object (e.g. CAsyncPersistor below) -- so our
	//	lifetime must be determined by the lifetime of our parent object.
	//
	IRefCounted * m_prcParent;

	//
	//	Error information
	//
	HRESULT m_hr;

	//
	//	The destination stream
	//
	IAsyncStream * m_pstmDst;

	//
	//	The count of bytes to copy and the count copied
	//
	ULONG m_cbToCopy;
	ULONG m_cbCopied;

	//
	//	The Accept() observer to notify when we're done
	//	visiting upon completion of an AsyncWrite()
	//	or AsyncCopyTo() on the destination stream.
	//
	IAcceptObserver * m_pobsAccept;

	//
	//	IBodyPartVisitor
	//
	VOID VisitBytes( const BYTE * pbData,
					 UINT cbToCopy,
					 IAcceptObserver& obsAccept );

	VOID VisitFile( const auto_ref_handle& hf,
					UINT64 ibOffset64,
					UINT64 cbToCopy64,
					IAcceptObserver& obsAccept );

	VOID VisitStream( IAsyncStream& stm,
					  UINT cbToCopy,
					  IAcceptObserver& obsAccept );

	VOID VisitComplete();

	//
	//	IAsyncWriteObserver
	//
	VOID WriteComplete( UINT cbWritten, HRESULT hr );

	//
	//	IAsyncCopyToObserver
	//
	VOID CopyToComplete( UINT cbCopied, HRESULT hr );

	//	NOT IMPLEMENTED
	//
	CAsyncCopyToVisitor( const CAsyncCopyToVisitor& );
	CAsyncCopyToVisitor& operator=( const CAsyncCopyToVisitor& );

public:
	//	CREATORS
	//
	CAsyncCopyToVisitor() :
			m_prcParent(NULL),
			m_hr(S_OK),
			m_pstmDst(NULL),
			m_cbToCopy(0),
			m_cbCopied(0)
	{
	}

	//	ACCESSORS
	//
	HRESULT Hresult() const { return m_hr; }
	UINT CbCopied() const { return m_cbCopied; }

	//	MANIPULATORS
	//
	VOID
	Configure( IAsyncStream& stmDst,
			   ULONG cbToCopy )
	{
		m_pstmDst  = &stmDst;
		m_cbToCopy = cbToCopy;
		m_cbCopied = 0;
		m_hr       = S_OK;
	}

	VOID
	SetRCParent(IRefCounted * prcParent)
	{
		Assert(prcParent);

		m_prcParent = prcParent;
	}

	//	Refcounting for IAsyncWriteObserver.  Since this is not a refcounted
	//	object we forward the refcouting to the object with which we
	//	were configured.
	//
	void AddRef()
	{
		Assert( m_prcParent );

		m_prcParent->AddRef();
	}

	void Release()
	{
		Assert( m_prcParent );

		m_prcParent->Release();
	}
};

//	------------------------------------------------------------------------
//
//	CAsyncCopyToVisitor::WriteComplete()
//
void
CAsyncCopyToVisitor::WriteComplete( UINT cbWritten, HRESULT hr )
{
	ActvTrace( "DAV: TID %3d: 0x%08lX: CAsyncCopyToVisitor::WriteComplete() called.  hr = 0x%08lX, cbWritten = %u\n", GetCurrentThreadId(), this, hr, cbWritten );

	m_cbCopied += cbWritten;
	m_hr = hr;

	m_pobsAccept->AcceptComplete( cbWritten );
}

//	------------------------------------------------------------------------
//
//	CAsyncCopyToVisitor::VisitBytes()
//
void
CAsyncCopyToVisitor::VisitBytes( const BYTE * pbData,
								 UINT cbToCopy,
								 IAcceptObserver& obsAccept )
{
	ActvTrace( "DAV: TID %3d: 0x%08lX: CAsyncCopyToVisitor::VisitBytes() called.  cbToCopy = %u\n", GetCurrentThreadId(), this, cbToCopy );

	//
	//	Remember the accept observer so that we can notify it when
	//	the AsyncWrite() below completes.
	//
	m_pobsAccept = &obsAccept;

	//
	//	Start writing
	//
	cbToCopy = min( cbToCopy, m_cbToCopy - m_cbCopied );
	m_pstmDst->AsyncWrite( pbData, cbToCopy, *this );
}

//	------------------------------------------------------------------------
//
//	CAsyncCopyToVisitor::VisitFile()
//
//	Not implemented because 1) request bodies cannot have file
//	body parts and 2) CAsyncCopyToVisitor is currently only used
//	with request bodies.  Should we ever need this for response
//	bodies we'll need to write the code at that point.
//
//	The old implementation used ReadFileEx() to read from the file
//	asynchronously.  In a nutshell, we couldn't use ReadFileEx()
//	because it relied on APC for calling back its completion routine.
//	APC in turn required the calling thread to enter an alertable
//	wait state.  Typically, we would only call VisitFile() from an
//	I/O completion port thread pool, and those threads are never
//	in an alertable wait state, thus the completion routine for
//	ReadFileEx() would never be called.
//
void
CAsyncCopyToVisitor::VisitFile( const auto_ref_handle&,
								UINT64,
								UINT64,
								IAcceptObserver& obsAccept )
{
	TrapSz( "CAsyncCopyToVisitor::VisitFile() is not implemented!!" );

	//
	//	If, for whatever random reason, someone actually does call
	//	this function, at least do something predictable: fail gracefully.
	//
	m_hr = E_FAIL;
	obsAccept.AcceptComplete( 0 );
}

//	------------------------------------------------------------------------
//
//	CAsyncCopyToVisitor::VisitStream()
//
void
CAsyncCopyToVisitor::VisitStream( IAsyncStream& stmSrc,
								  UINT cbToCopy,
								  IAcceptObserver& obsAccept )
{
	ActvTrace( "DAV: TID %3d: 0x%08lX: CAsyncCopyToVisitor::VisitStream() called.  cbToCopy = %u\n", GetCurrentThreadId(), this, cbToCopy );

	//
	//	Remember the accept observer so that we can notify it when
	//	the AsyncCopyTo() below completes.
	//
	m_pobsAccept = &obsAccept;

	//
	//	Start copying
	//
	cbToCopy = min( cbToCopy, m_cbToCopy - m_cbCopied );
	stmSrc.AsyncCopyTo( *m_pstmDst, cbToCopy, *this );
}

//	------------------------------------------------------------------------
//
//	CAsyncCopyToVisitor::CopyToComplete()
//
void
CAsyncCopyToVisitor::CopyToComplete( UINT cbCopied, HRESULT hr )
{
	m_cbCopied += cbCopied;
	m_hr = hr;

	ActvTrace( "DAV: TID %3d: 0x%08lX: CAsyncCopyToVisitor::CopyToComplete() hr = 0x%08lX, cbCopied = %u, m_cbCopied = %u\n", GetCurrentThreadId(), this, hr, cbCopied, m_cbCopied );

	m_pobsAccept->AcceptComplete( cbCopied );
}

//	------------------------------------------------------------------------
//
//	CAsyncCopyToVisitor::VisitComplete()
//
VOID
CAsyncCopyToVisitor::VisitComplete()
{
	m_hr = S_FALSE;
}


//	========================================================================
//
//	CLASS CBodyAsIStream
//
//	Provides once-only access to the entire body as an OLE COM IStream using
//	either IStream::Read() and IStream::CopyTo().
//
class CBodyAsIStream :
	public CStreamNonImpl,
	private IAcceptObserver
{
	//
	//	Iterator used to traverse the body
	//
	IBody::iterator * m_pitBody;

	//
	//	The three states of the read operation started by the most recent
	//	call to CBodyAsIStream::Read():
	//
	//		READ_ACTIVE
	//			The read is active.  It may or may not complete
	//			synchronously.  This is the initial state.
	//
	//		READ_PENDING
	//			The read is pending.  The read did not complete before
	//			we had to return to the caller.  CBodyAsIStream::Read()
	//			returns E_PENDING and the stream observer (below) is notified
	//			when the read completes.
	//
	//		READ_COMPLETE
	//			The read completed before we had to return to the
	//			caller.  CBodyAsIStream::Read() does not return E_PENDING
	//			and the stream observer (below) is not notified.
	//
	//	Note: m_lStatus is meaningless (and hence uninitialized/invalid) until
	//	CBodyAsIStream::Read() is called.
	//
	enum
	{
		READ_ACTIVE,
		READ_PENDING,
		READ_COMPLETE,

		READ_INVALID_STATUS = -1
	};

	LONG m_lStatus;

	//
	//	Status of last completed operation.
	//
	HRESULT m_hr;

	//
	//	Async visitor used for Read().
	//
	CAsyncReadVisitor m_arv;

	//
	//	Count of bytes read in the visit started by the most recent
	//	call to CBodyAsIStream::Read().
	//
	//	Note: m_cbRead is meaningless (and hence uninitialized) until
	//	CBodyAsIStream::Read() is called.
	//
	UINT m_cbRead;

	//
	//	Reference to the async I/O completion observer.  We notify this
	//	observer from CBodyAsIStream::AcceptComplete() when the async
	//	Accept() call we make in CBodyAsIStream::Read() completes for
	//	a read that we have pended.
	//
	IAsyncIStreamObserver& m_obsStream;

	//	IAcceptObserver callback used when accepting async read visitor
	//	to asynchronoulsy refill the buffer.
	//
	VOID AcceptComplete( UINT64 cbRead64 );

	//	NOT IMPLEMENTED
	//
	CBodyAsIStream( const CBodyAsIStream& );
	CBodyAsIStream& operator=( const CBodyAsIStream& );

public:
	CBodyAsIStream( IBody& body,
					IAsyncIStreamObserver& obs ) :
		m_pitBody(body.GetIter()),
		m_lStatus(READ_INVALID_STATUS),
		m_hr(S_OK),
		m_cbRead(0),
		m_obsStream(obs)
	{
	}

	//	COM IStream ACCESSORS/MANIPULATORS
	//
	virtual /* [local] */ HRESULT STDMETHODCALLTYPE Read(
		/* [length_is][size_is][out] */ void __RPC_FAR *,
		/* [in] */ ULONG,
		/* [out] */ ULONG __RPC_FAR *);

	//$WORKAROUND: MSXML is calling our Stat() method. (X5#89140)
	//	Our parent (CStreamNonImpl) has a TrapSz() there, so
	//	avoid it by implementing our own Stat() call here,
	//	that just returns E_NOTIMPL.
	//	MSXML doesn't care if this is not implemented, just so long
	//	as it doesn't crash/assert/dbgbreak.  If they get results
	//	back here, they do other security checking that we don't
	//	need or want!
	//
	virtual HRESULT STDMETHODCALLTYPE Stat(
		/* [out] */ STATSTG __RPC_FAR *,
		/* [in] */ DWORD)
	{
		return E_NOTIMPL;
	}
	//$WORKAROUND: end
};

//	------------------------------------------------------------------------
//
//	CBodyAsIStream::Read()
//
HRESULT STDMETHODCALLTYPE
CBodyAsIStream::Read( LPVOID  pv,
					  ULONG   cbToRead,
					  ULONG * pcbRead )
{
	HRESULT hr = S_OK;

	Assert( cbToRead > 0 );
	Assert( !IsBadWritePtr(pv, cbToRead) );
	Assert( !pcbRead || !IsBadWritePtr(pcbRead, sizeof(ULONG)) );

	BodyStreamTrace( "DAV: TID %3d: 0x%08lX: CBodyAsIStream::Read() called to read %lu bytes from stream\n", GetCurrentThreadId(), this, cbToRead );

	//
	//	If we are called on the Read() again while the previous read is pending
	//	return with the same indication - that operation is still pending.
	//	This is done to protect ourselves from the external callers like MSXML
	//	parser, that tries to read data from us, we return E_PENDING, and then
	//	they are turning around and calling into us again without waiting for
	//	the previous pending read to complete. Our code does handle only one
	//	outstanding async IO at a time. So the check below allows us to ignore
	//	the IOs that are attempted to start while previous one is pending. This
	//	works as long as the caller does expect to be called back only once for
	//	any amount of async IOs issued while the original IO is still pending.
	//	If the last condition is not met the only thing left to us would be to
	//	error out so we do not crash and for the callers to fix their behaviour
	//	so the code would work.
	//
	if (READ_PENDING == InterlockedCompareExchange(	&m_lStatus,
							READ_PENDING,
							READ_PENDING ))
	{
		return E_PENDING;
	}

	//
	//	As this is an STDMETHODCALLTYPE function, we need to wrap the whole thing
	//	in a try/catch block to keep exceptions due to memory allocation failures
	//	from propagating out.
	//
	//	Note: We don't expect anything in this try/catch block to throw a "hard"
	//	Win32 exception so we don't need a CWin32ExceptionHandler in the block.
	//
	try
	{
		//
		//	Check for errors from the previous (pended) read.
		//
		hr = m_arv.Hresult();
		if ( FAILED(hr) )
		{
			DebugTrace( "CBodyAsIStream::Read() - Error from previous async read 0x%08lX\n", hr );
			goto ret;
		}

		//
		//	Set up our visitor to read directly into the caller's buffer.
		//
		m_arv.Configure(static_cast<LPBYTE>(pv), cbToRead);

		//
		//	Clear out the count of bytes read from the previous run
		//
		m_cbRead = 0;

		//
		//	Set our status to actively reading.  When we call Accept(), this status will
		//	change in one of two possible ways:  If we finish accepting before our
		//	Accept() call returns then the status will be set to READ_COMPLETE and
		//	we will complete this Read() call synchronously.  If not then it will still
		//	be set to READ_ACTIVE at the point where we test and set it below to
		//	READ_PENDING.
		//
		m_lStatus = READ_ACTIVE;

		//
		//	Visit the body.
		//
		m_pitBody->Accept( m_arv, *this );

		//
		//	Check the visit status.  If the visit has not completed at this
		//	point then attempt to pend the read operation and return E_PENDING
		//	to our caller.  If we successfully pend the operation then our
		//	AcceptComplete() routine will notify our stream observer when the
		//	read completes.
		//
		if ( READ_ACTIVE == m_lStatus &&
			 READ_ACTIVE == InterlockedExchange( &m_lStatus, READ_PENDING ) )
		{
			BodyStreamTrace( "DAV: TID %3d: 0x%08lX: CBodyAsIStream::Read() Returning E_PENDING\n", GetCurrentThreadId(), this );
			hr = E_PENDING;
			goto ret;
		}

		//
		//	Check for errors from the current read.
		//
		hr = m_arv.Hresult();
		if ( FAILED(hr) )
		{
			DebugTrace( "CBodyAsIStream::Read() - Error from current read 0x%08lX\n", hr );
			goto ret;
		}

		//
		//	If we're at End Of Stream then return what we got.
		//
		if ( S_FALSE == hr )
		{
			//
			//	Don't return S_FALSE when we're also returning
			//	data.  The IStream spec is unclear on whether
			//	that is allowed.
			//
			if ( m_cbRead > 0 )
				hr = S_OK;
		}

		//
		//	Return the number of bytes read if the caller asked for
		//	that information.
		//
		if ( pcbRead )
			*pcbRead = m_cbRead;
	}
	catch ( CDAVException& e )
	{
		hr = e.Hresult();
		Assert( FAILED(hr) );
	}

ret:
	return hr;
}

//	------------------------------------------------------------------------
//
//	CBodyAsIStream::AcceptComplete()
//
//	Called when the Accept() call started in Read() to asynchronously
//	refill the buffer completes.
//
VOID
CBodyAsIStream::AcceptComplete( UINT64 cbRead64 )
{
	BodyStreamTrace( "DAV: TID %3d: 0x%08lX: CBodyAsIStream::AcceptComplete() cbRead64 = %lu\n", GetCurrentThreadId(), this, cbRead64 );

	//
	//	Update the count of bytes that our Accept() call successfully
	//	read into the user's buffer. We are accepting in piecies so the
	//	accepted amount should be really much less than 4GB.
	//
	Assert(0 == (0xFFFFFFFF00000000 & cbRead64));
	m_cbRead = static_cast<UINT>(cbRead64);

	//
	//	Set status to READ_COMPLETE.  If the read operation pended --
	//	i.e. the previous state was READ_PENDING, not READ_ACTIVE --
	//	then we must wake up the stream observer and tell it that
	//	we are done.
	//
	if ( READ_PENDING == InterlockedExchange( &m_lStatus, READ_COMPLETE ) )
		m_obsStream.AsyncIOComplete();
}


//	========================================================================
//
//	CLASS CAsyncPersistor
//
//	Implements an async driven object to persist a body to an IAsyncStream.
//
class CAsyncPersistor :
	public CMTRefCounted,
	public IRefCounted,
	private IAcceptObserver
{
	//
	//	Body iterator
	//
	IBody::iterator * m_pitBody;

	//
	//	Async driving mechanism
	//
	CAsyncDriver<CAsyncPersistor> m_driver;
	friend class CAsyncDriver<CAsyncPersistor>;

	//
	//	Caller-supplied observer to notify when we're done persisting.
	//
	auto_ref_ptr<IAsyncPersistObserver> m_pobsPersist;

	//
	//	CopyTo visitor used to persist the body
	//
	CAsyncCopyToVisitor m_actv;

	//
	//	CAsyncDriver callback
	//
	VOID Run();

	//
	//	IAcceptObserver callback used when accepting async copyto visitor
	//	to asynchronously persist the body to the destination stream.
	//
	VOID AcceptComplete( UINT64 cbCopied64 );

	//	NOT IMPLEMENTED
	//
	CAsyncPersistor( const CAsyncPersistor& );
	CAsyncPersistor& operator=( const CAsyncPersistor& );

public:
	//	CREATORS
	//
	CAsyncPersistor( IBody& body,
					 IAsyncStream& stm,
					 IAsyncPersistObserver& obs ) :
		m_pitBody(body.GetIter()),
		m_pobsPersist(&obs)
	{
		//
		//	Set the CopyTo() parameters here, once.  If we ever need
		//	to copy request bodies larger than ULONG_MAX bytes, we'll
		//	need to move this call down into Run().
		//
		m_actv.Configure(stm, ULONG_MAX);
	}

	//	MANIUPLATORS
	//
	VOID Start()
	{
		m_driver.Start(*this);
	}

	//	Refcounting -- forward all refcounting requests to our refcounting
	//	implementation base class: CMTRefCounted.
	//
	void AddRef() { CMTRefCounted::AddRef(); }
	void Release() { CMTRefCounted::Release(); }
};

//	------------------------------------------------------------------------
//
//	CAsyncPersistor::Run()
//
VOID
CAsyncPersistor::Run()
{
	PersistTrace( "DAV: TID %3d: 0x%08lX: CAsyncPersistor::Run() called\n", GetCurrentThreadId(), this );

	//
	//	AddRef() for Accept().  Use auto_ref_ptr for exception-safety.
	//
	auto_ref_ptr<CAsyncPersistor> pRef(this);

	m_actv.SetRCParent(this);
	m_pitBody->Accept(m_actv, *this);

	pRef.relinquish();
}

//	------------------------------------------------------------------------
//
//	CAsyncPersistor::AcceptComplete()
//
VOID
CAsyncPersistor::AcceptComplete( UINT64 cbCopied64 )
{
	//
	//	Take ownership of the reference added in Run().
	//
	auto_ref_ptr<CAsyncPersistor> pRef;
	pRef.take_ownership(this);

	//
	//	We're done when the status of the CopyTo visitor is
	//	S_FALSE (success) or an error.
	//
	HRESULT hr = m_actv.Hresult();

	PersistTrace( "DAV: TID %3d: 0x%08lX: CAsyncPersistor::AcceptComplete() hr = 0x%08lX\n, cbCopied64 = %ud\n", GetCurrentThreadId(), this, hr, cbCopied64 );

	if ( FAILED(hr) || S_FALSE == hr )
	{
		Assert( m_pobsPersist.get() );
		m_pobsPersist->PersistComplete(hr);
	}
	else
	{
		Start();
	}
}


//	========================================================================
//
//	CLASS IBody
//

//	------------------------------------------------------------------------
//
//	IBody::~IBody()
//
//		Out of line virtual destructor necessary for proper deletion
//		of objects of derived classes via this class
//
IBody::~IBody() {}

//	========================================================================
//
//	CLASS IBody::iterator
//

//	------------------------------------------------------------------------
//
//	IBody::iterator::~iterator()
//
//		Out of line virtual destructor necessary for proper deletion
//		of objects of derived classes via this class
//
IBody::iterator::~iterator() {}


//	========================================================================
//
//	CLASS CList
//
//	The body part list implementation uses the STL list template.
//	Body parts are stored in auto_ptrs so that they are automatically
//	destroyed as they are removed from the list or when the list itself is
//	destroyed.
//
//	This class does not by itself need to provide any sort of thread-safety.
//
typedef std::list<
			auto_ptr_obsolete<IBodyPart>,
			heap_allocator< auto_ptr_obsolete<IBodyPart> >
		> CList;

//	========================================================================
//
//	CLASS CBodyPartList
//
//	Encapsulates access to the list of body parts.  The reason for this
//	seemingly extra level of encapsulation is that it enables us to
//	change the list implementation easily without touching code which
//	uses the list.
//
//	!!! IMPORTANT !!!
//	When accessing/modifying the raw STL list through CBodyPartList,
//	we must acquire our critical section.  Threads may be iterating
//	over the list via our iterator, CBodyPartListIter, while we are modifying
//	the list and the STL list and its iterator are not thread-safe.
//	In other words, CBodyPartListIter and CBodyPartList share the same critsec.
//
class CBodyPartList
{
	//	The list
	//
	CList m_list;

	//	Critical section to serialize access to the above list
	//
	CCriticalSection m_csList;

	//	NOT IMPLEMENTED
	//
	CBodyPartList( const CBodyPartList& );
	CBodyPartList& operator=( const CBodyPartList& );

	friend class CBodyPartListIter;

public:
	//	CREATORS
	//
	CBodyPartList() {}

	//	ACCESSORS
	//
	const BOOL FIsEmpty() const
	{
		//
		//	Note: we don't currently acquire the critical section
		//	proctecting the raw list as we expect this function
		//	to not be called once we are accessing the list
		//	from multiple threads.
		//

		//
		//	Return whether there are any body parts in the list
		//
		return m_list.empty();
	}

	//	MANIPULATORS
	//
	VOID Clear()
	{
		//
		//	Note: we don't currently acquire the critical section
		//	proctecting the raw list as we expect this function
		//	to not be called once we are accessing the list
		//	from multiple threads.
		//

		//
		//	Remove all body parts from the list (at which point they
		//	should be automatically destroyed).
		//
		m_list.clear();
	}

	VOID PushPart( IBodyPart * pBodyPart )
	{
		CSynchronizedBlock sb(m_csList);

		//
		//	Our iterator (CBodyPartList iter, below) uses the STL
		//	list reverse_iterator to traverse the list from back to
		//	front, so we append body parts to the *front* of the list.
		//
		m_list.push_front( auto_ptr_obsolete<IBodyPart>(pBodyPart) );
	}
};

//	========================================================================
//
//	CLASS CBodyPartListIter
//
//	Implements an iterator for CBodyPartList
//
//	This implementation uses the reverse STL list iterator corresponding
//	to the usage of the STL list type in CBodyPartList.  STL iterators
//	have some syntactic sugar that we need to note here:
//
//		* (deref) of an iterator gives the thing pointed to
//		++ (increment) of an iterator goes to the "next" item
//		-- (decrement) of an iterator goes to the "previous" item
//
//	We use the reverse iterator because of the behavior we need at
//	the end of the list w.r.t. adding new items.  When an iterator
//	reaches the end of the list and items are later added there,
//	we want the iterator to refer to the first of the new items rather
//	than the new end-of-list.  The forward STL iterator has the
//	latter behavior.
//
//	!!! IMPORTANT !!!
//	When accessing/modifying the raw STL list through our iterator
//	we must acquire CBodyPartList's critical section.  Threads may
//	be modifying the list while we are iterating through it and
//	the STL list and its iterator are not thread-safe.  In other words,
//	CBodyPartListIter and CBodyPartList share the same critsec.
//
class CBodyPartListIter
{
	//	Pointer to the list to iterate on
	//
	CBodyPartList * m_pBodyPartList;

	//	The raw STL list iterator
	//
	CList::reverse_iterator m_itRaw;

	//	CBodyPartList ACCESSORS
	//
	CCriticalSection& CritsecList() const
	{
		Assert( m_pBodyPartList );
		return m_pBodyPartList->m_csList;
	}

	CList& RawList() const
	{
		Assert( m_pBodyPartList );
		return m_pBodyPartList->m_list;
	}

	//	NOT IMPLEMENTED
	//
	CBodyPartListIter( const CBodyPartListIter& );
	CBodyPartListIter& operator=( const CBodyPartListIter& );

public:
	//	CREATORS
	//
	CBodyPartListIter() :
		m_pBodyPartList(NULL)
	{
	}

	VOID Start( CBodyPartList& m_bodyPartList )
	{
		m_pBodyPartList = &m_bodyPartList;

		//
		//	Note: we don't currently acquire the critical section
		//	proctecting the raw list as we expect this function
		//	to not be called once we are accessing the list
		//	from multiple threads.
		//

		m_itRaw = RawList().rbegin();
	}

	//	ACCESSORS
	//
	BOOL FDone()
	{
		CSynchronizedBlock sb(CritsecList());

		return m_itRaw == RawList().rend();
	}

	IBodyPart * PItem()
	{
		CSynchronizedBlock sb(CritsecList());

		return *m_itRaw;
	}

	//	MANIPULATORS
	//

	//	------------------------------------------------------------------------
	//
	//	CBody::Prune()
	//
	//	Bumps the iterator to the next item in the list
	//
	VOID Next()
	{
		CSynchronizedBlock sb(CritsecList());

		//
		//	We had better not already be at the end...
		//
		Assert( m_itRaw != RawList().rend() );

		++m_itRaw;
	}

	//	------------------------------------------------------------------------
	//
	//	CBody::Prune()
	//
	//	Prunes the list at this iterator's current position.  Removes items
	//	from the current position to the end of the list.  Does not remove
	//	the current item.
	//
	VOID Prune()
	{
		CSynchronizedBlock sb(CritsecList());

		//
		//	Unfortunately the STL only allows us to erase between two
		//	forward iterators.  And there is no way to get a forward
		//	iterator directly from a reverse iterator.  So we must
		//	start a forward iterator at the end of the list and walk
		//	it backward the same distance that our reverse iterator
		//	is from its "beginning" of the list and then erase the
		//	items between the forward iterator and the end of the list.
		//
		CList::iterator itErase = RawList().end();

		for ( CList::reverse_iterator it = RawList().rbegin();
			  it != m_itRaw;
			  ++it )
		{
			--itErase;
		}

		if ( itErase != RawList().end() )
			RawList().erase( ++itErase, RawList().end() );
	}
};


//	========================================================================
//
//	CLASS CBody
//
class CBody : public IBody
{
	//	========================================================================
	//
	//	CLASS iterator
	//
	class iterator :
		public IBody::iterator,
		private IAcceptObserver
	{
		//
		//	Iterator to walk the body part list.
		//
		CBodyPartListIter m_itPart;

		//
		//	Pointer to the current body part referred to by the
		//	above iterator.
		//
		IBodyPart * m_pBodyPart;

		//
		//	Current position in the above part.
		//
		UINT64 m_ibPart64;

		//
		//	Observer to call when Accept() completes -- set on each
		//	Accept() call.
		//
		IAcceptObserver *  m_pobsAccept;

		//
		//	IAcceptObserver
		//
		VOID AcceptComplete( UINT64 cbAccepted64 );

		//	NOT IMPLEMENTED
		//
		iterator( const iterator& );
		iterator& operator=( const iterator& );

	public:
		iterator() {}

		VOID Start( CBodyPartList& bodyPartList )
		{
			m_itPart.Start(bodyPartList);
			m_pBodyPart = NULL;
		}

		VOID Accept( IBodyPartVisitor& v,
					 IAcceptObserver& obsAccept );

		VOID Prune();
	};

	//	Body part list and current position in that list
	//
	CBodyPartList m_bodyPartList;

	//	Our iterator
	//
	iterator m_it;

	//
	//	Inline helper to add a body part
	//
	void _AddBodyPart( IBodyPart * pBodyPart )
	{
		m_bodyPartList.PushPart(pBodyPart);
	}

	//	NOT IMPLEMENTED
	//
	CBody( const CBody& );
	CBody& operator=( const CBody& );

public:
	CBody() {}

	//	ACCESSORS
	//
	BOOL FIsEmpty() const;
	BOOL FIsAtEnd() const;
	UINT64 CbSize64() const;

	//	MANIPULATORS
	//
	void AddText( LPCSTR lpszText,
				  UINT   cbText );

	void AddFile( const auto_ref_handle& hf,
				  UINT64 ibFile,
				  UINT64 cbFile );

	void AddStream( IStream& stm );

	void AddStream( IStream& stm,
					UINT     ibOffset,
				    UINT     cbSize );

	void AddBodyPart( IBodyPart * pBodyPart );

	void AsyncPersist( IAsyncStream& stm,
					   IAsyncPersistObserver& obs );

	IStream * GetIStream( IAsyncIStreamObserver& obs )
	{
		return new CBodyAsIStream(*this, obs);
	}

	IBody::iterator * GetIter();

	VOID Clear();
};

//	------------------------------------------------------------------------
//
//	CBody::GetIter()
//
IBody::iterator *
CBody::GetIter()
{
	m_it.Start(m_bodyPartList);
	return &m_it;
}

//	------------------------------------------------------------------------
//
//	CBody::FIsEmpty()
//
BOOL
CBody::FIsEmpty() const
{
	return m_bodyPartList.FIsEmpty();
}

//	------------------------------------------------------------------------
//
//	CBody::CbSize64()
//
UINT64
CBody::CbSize64() const
{
	UINT64 cbSize64 = 0;

	//
	//	Sum the sizes of all the body parts
	//
	CBodyPartListIter it;

	for ( it.Start(const_cast<CBodyPartList&>(m_bodyPartList));
		  !it.FDone();
		  it.Next() )
	{
		cbSize64 += it.PItem()->CbSize64();
	}

	return cbSize64;
}

//	------------------------------------------------------------------------
//
//	CBody::AddText()
//
//		Adds static text to the body by creating a text body part with
//		its own copy of the text and adding that body part to the
//		body part list.
//
//		!!!
//		For best performance, implement your own text body part on top
//		of your text data source rather than copying it via this function
//		as doing so avoids making an extra copy of the data from the
//		data source in memory.
//
void
CBody::AddText( LPCSTR lpszText, UINT cbText )
{
	_AddBodyPart( new CTextBodyPart(cbText, lpszText) );
}

//	------------------------------------------------------------------------
//
//	CBody::AddFile()
//
void
CBody::AddFile( const auto_ref_handle& hf,
				UINT64 ibFile64,
				UINT64 cbFile64 )
{
	_AddBodyPart( new CFileBodyPart(hf, ibFile64, cbFile64) );
}

//	------------------------------------------------------------------------
//
//	CBody::AddStream()
//
void
CBody::AddStream( IStream& stm )
{
	TrapSz("Stream body parts no longer implemented");
}

//	------------------------------------------------------------------------
//
//	CBody::AddStream()
//
void
CBody::AddStream( IStream& stm,
					 UINT     ibOffset,
					 UINT     cbSize )
{
	TrapSz("Stream body parts no longer implemented");
}

//	------------------------------------------------------------------------
//
//	CBody::AddBodyPart()
//
void
CBody::AddBodyPart( IBodyPart * pBodyPart )
{
	_AddBodyPart( pBodyPart );
}

//	------------------------------------------------------------------------
//
//	CBody::Clear()
//
VOID
CBody::Clear()
{
	m_bodyPartList.Clear();
}

//	------------------------------------------------------------------------
//
//	CBody::iterator::Accept()
//
//	Accepts an asynchronous body part visitor (v) at the iterator's
//	current position.  The Accept() observer (obsAccept) is notified
//	when the visitor finishes.
//
//	Lifetimes of both the visitor and the observer are controled
//	outside the scope of this function; i.e. it is assumed that
//	the observer will still be valid when the visitor finishes.
//
VOID
CBody::iterator::Accept( IBodyPartVisitor& v,
						 IAcceptObserver& obsAccept )
{
	//
	//	If we've reached the end of the body, then we're done.
	//
	if ( m_itPart.FDone() )
	{
		v.VisitComplete();
		obsAccept.AcceptComplete(0);
		return;
	}

	//
	//	We're not at the end of the body.  If we are starting
	//	a new part then rewind the part and our current position.
	//
	if ( NULL == m_pBodyPart )
	{
		m_pBodyPart = m_itPart.PItem();
		m_pBodyPart->Rewind();
		m_ibPart64 = 0;
	}

	//
	//	Save off the observer so that we can call it back when
	//	the body part is done accepting the visitor.
	//
	m_pobsAccept = &obsAccept;

	//
	//	Accept the specified visitor starting from the current
	//	position in the current body part.
	//
	m_pBodyPart->Accept( v, m_ibPart64, *this );
}

//	------------------------------------------------------------------------
//
//	CBody::iterator::AcceptComplete()
//
//	IBodyPart::AcceptObserver method called by the body part when it is
//	done with the visitor we told it to accept in Accept() above.
//
VOID
CBody::iterator::AcceptComplete( UINT64 cbAccepted64 )
{
	Assert( m_pBodyPart );


	m_ibPart64 += cbAccepted64;

	//
	//	If we reach the end of the current body part then tell
	//	our iterator to go to the next part.  If we hit the end
	//	of the body, we will catch that condition in Accept() the
	//	next time we get called there.
	//
	if ( m_ibPart64 == m_pBodyPart->CbSize64() )
	{
		m_itPart.Next();

		//
		//	Null out the current body part so we will know to
		//	fetch the next one on the next call to Accept().
		//
		m_pBodyPart = NULL;
	}

	//
	//	Callback our observer
	//
	m_pobsAccept->AcceptComplete(cbAccepted64);
}

//	------------------------------------------------------------------------
//
//	CBody::iterator::Prune()
//
//	Deletes items from the body part list up to, but not including,
//	the part at the current list position.  This minimizes the
//	memory footprint for large one-pass async partwise operations
//	such as request persisting or response transmission.
//
VOID
CBody::iterator::Prune()
{
	m_itPart.Prune();
}

//	------------------------------------------------------------------------
//
//	CBody::AsyncPersist()
//
void
CBody::AsyncPersist( IAsyncStream& stm,
					 IAsyncPersistObserver& obs )
{
	PersistTrace( "DAV: TID %3d: 0x%08lX: CBody::AsyncPersist() called\n", GetCurrentThreadId(), this );

	auto_ref_ptr<CAsyncPersistor>
		pPersistor(new CAsyncPersistor(*this, stm, obs));

	pPersistor->Start();
}

//	------------------------------------------------------------------------
//
//	NewBody()
//
IBody * NewBody()
{
	return new CBody();
}

//	------------------------------------------------------------------------
//
//	CXMLBody::ScAddTextBytes
//
SCODE
CXMLBody::ScAddTextBytes ( UINT cbText, LPCSTR lpszText )
{
	Assert (lpszText);

	//	Create the text body part if necessary
	//
	if (!m_ptbp.get())
		m_ptbp = new CTextBodyPart(0, NULL);

	//	Add the piece to the body part
	//
	m_ptbp->AddTextBytes (cbText, lpszText);

	//	Add to body part list if this body part has reach a proper size
	//
	if (m_fChunked && (m_ptbp->CbSize64() > CB_XMLBODYPART_SIZE))
		SendCurrentChunk();

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\appmain.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	APPMAIN.CPP
//
//		DAV ISAPI DLL entrypoints, main routine, global instance management
//
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include <_davprs.h>

#include <xatom.h>		// XML atom cache

#include "instdata.h"
#include <langid.h>
#include "custerr.h"
#include "content.h"


//	THE one, global instance
//
CInst g_inst;



//	------------------------------------------------------------------------
//
//	CInst::PerProcessInit()
//
//		Zero it out.
//

void
CInst::PerProcessInit( HINSTANCE hinst )
{
	m_hinst = hinst;

#ifdef MINIMAL_ISAPI
	m_hfDummy = CreateFileW( L"c:\\temp\\test2.txt",		// filename
							 GENERIC_READ,					// dwAccess
							 FILE_SHARE_READ | FILE_SHARE_WRITE,
							 NULL,							// lpSecurityAttributes
							 OPEN_EXISTING,					// creation flags
							 FILE_ATTRIBUTE_NORMAL |
							 FILE_FLAG_SEQUENTIAL_SCAN |
							 FILE_FLAG_OVERLAPPED,			// attributes
							 NULL );						// tenplate
#endif // MINIMAL_ISAPI
}


//	------------------------------------------------------------------------
//
//	CInst::GetInstData()
//
//		Get the instance data for this ECB.
//		Handoff this call to our InstDataCache.
//

CInstData&
CInst::GetInstData( const IEcb& ecb )
{
	return CInstDataCache::GetInstData( ecb );
}



//	------------------------------------------------------------------------
//
//	CDAVExt::FInitializeDll()
//
//		Your standard DLL entrypoint.
//

BOOL
CDAVExt::FInitializeDll( HINSTANCE	hinst,
						 DWORD		dwReason )
{
	BOOL			fInitialized = TRUE;

	switch ( dwReason )
	{
		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:

			Assert(FALSE);
			break;

		case DLL_PROCESS_ATTACH:
		{

			//
			//	Do per process initialization (and implicit initialization of
			//	the first thread).  The try/catch block just allows us to
			//	clean up neatly if anything at all goes wrong.
			//
			try
			{
				g_inst.PerProcessInit( hinst );
			}
			catch ( CDAVException& )
			{
				DebugTrace( "CDAVExt::FInitializeDll() - Caught exception in per-process initialization\n" );
				fInitialized = FALSE;
			}

			break;
		}

		case DLL_PROCESS_DETACH:
		{

			break;
		}

		default:
		{
			TrapSz( "FInitializeDll called for unknown reason\n" );
			fInitialized = FALSE;
			break;
		}
	}

	return fInitialized;
}

//	------------------------------------------------------------------------
//
//	CDAVExt::FVersion()
//
BOOL
CDAVExt::FVersion ( HSE_VERSION_INFO * pver )
{
	BOOL fSuccess = FALSE;

	//
	//	Init .INI file tagged debug traces
	//
	InitDavprsTraces();

	//	Init ECB logging -- DBG only
	//
#ifdef DBG
	if ( DEBUG_TRACE_TEST(ECBLogging) )
		InitECBLogging();
#endif

	//	Instatiate the virtual root cache
	//	We must do that before we initialise the metabase as this cache will listen
	//	to the metabase notifications that are registered when metabase is created.
	//	So if CChildVRCache is not there we may notify the object that does not
	//	exist and crash while doing that.
	//
	CChildVRCache::CreateInstance();

	//	Init the metabase
	//
	if ( !FMDInitialize() )
		goto ret;

	//	Instatiate the instance cache
	//
	CInstDataCache::CreateInstance();

	//	Create the language ID cache
	//
	CLangIDCache::CreateInstance();

	if ( !CLangIDCache::FInitialize() )
		goto ret;

	//	Instantiate the global registry-based mime map
	//
	if ( !FInitRegMimeMap() )
		goto ret;

	fSuccess = TRUE;

ret:
	return fSuccess;
}

#ifndef MINIMAL_ISAPI
#else  // defined(MINIMAL_ISAPI)
static VOID WINAPI
IOCompleteNoOp( EXTENSION_CONTROL_BLOCK *		pecb,
				PVOID                           pvContext,
				DWORD							cbIO,
				DWORD							dwLastError )
{
	//
	//	Done with the session.  This must be done from inside
	//	of the async callback because INETINFO crashes in
	//	INFOCOMM.DLL if you try to put it immediately after
	//	the SSF::HSE_REQ_TRANSMIT_FILE and the client sends
	//	a huge pile of requests before waiting for a response.
	//
	pecb->ServerSupportFunction (pecb->ConnID,
								 HSE_REQ_DONE_WITH_SESSION |
								 (pvContext ? HSE_STATUS_SUCCESS_AND_KEEP_CONN : 0),
								 NULL,
								 NULL,
								 NULL);
}

void
CheckKeepAlive( LPEXTENSION_CONTROL_BLOCK pecb, DWORD * pdwKeepAlive )
{
	pecb->ServerSupportFunction (pecb->ConnID,
								 HSE_REQ_IS_KEEP_CONN,
								 pdwKeepAlive,
								 NULL,
								 NULL);
}

void
SendHeaders( LPEXTENSION_CONTROL_BLOCK pecb )
{
	HSE_SEND_HEADER_EX_INFO	hseSendHeaderExInfo;

	static CHAR rgchStatus[] = "200 OK";

	hseSendHeaderExInfo.pszStatus = rgchStatus;
	hseSendHeaderExInfo.cchStatus = sizeof(rgchStatus) - 1;

	hseSendHeaderExInfo.pszHeader = NULL;
	hseSendHeaderExInfo.cchHeader = 0;

	hseSendHeaderExInfo.fKeepConn = TRUE;

	pecb->ServerSupportFunction (pecb->ConnID,
								 HSE_REQ_SEND_RESPONSE_HEADER_EX,
								 &hseSendHeaderExInfo,
								 NULL,
								 NULL);
}

void
SendResponse( LPEXTENSION_CONTROL_BLOCK pecb, DWORD dwKeepAlive )
{
	HSE_TF_INFO	hseTFInfo;

	ZeroMemory(&hseTFInfo, sizeof(HSE_TF_INFO));

	//
	//	If we're going to close the connection anyway, might
	//	as well send the headers along with everything else now.
	//
	if ( !dwKeepAlive )
	{
		static CHAR rgchHeaders[] =
			"HTTP/1.1 200 OK\r\n"
			"Content-Type: text/plain\r\n"
			"Connection: close\r\n"
			"\r\n";

		hseTFInfo.pHead        = rgchHeaders;
		hseTFInfo.HeadLength   = sizeof(rgchHeaders) - 1;
	}

	hseTFInfo.pfnHseIO     = IOCompleteNoOp;
	hseTFInfo.pContext     = (PVOID)(dwKeepAlive);
	hseTFInfo.dwFlags      = HSE_IO_ASYNC |
							 (dwKeepAlive ? 0 : HSE_IO_DISCONNECT_AFTER_SEND);
	hseTFInfo.BytesToWrite = 0;
	hseTFInfo.hFile        = g_inst.m_hfDummy;

	pecb->ServerSupportFunction (pecb->ConnID,
								 HSE_REQ_TRANSMIT_FILE,
								 &hseTFInfo,
								 NULL,
								 NULL);
}

DWORD
CDAVExt::DwMain( LPEXTENSION_CONTROL_BLOCK pecb,
				 BOOL fUseRawUrlMappings /* = FALSE */ )
{
	DWORD dwKeepAlive;

	//
	//	Determine whether to keep the connection open
	//
	CheckKeepAlive( pecb, &dwKeepAlive );

	//
	//	If keep alive is set, we *MUST* send the headers using
	//	HSE_REQ_SEND_RESPONSE_HEADERS_EX (which is always synchronous)
	//	because it's the only way that allows us to tell IIS to
	//	keep the connection open.
	//
	if ( dwKeepAlive )
		SendHeaders( pecb );

	//
	//	Transmit the dummy file
	//
	SendResponse( pecb, dwKeepAlive );

	return HSE_STATUS_PENDING;
}
#endif // defined(MINIMAL_ISAPI)


//	------------------------------------------------------------------------
//
//	CDAVExt::FTerminate()
//
//		Terminates (deinitializes) the common portions of this DAV ISAPI
//
//	Returns:
//		TRUE	if the DAV ISAPI application can be unloaded now
//		FALSE	otherwise
//
BOOL
CDAVExt::FTerminate()
{
	//	Tear down the global registry-based mimemap
	//
	DeinitRegMimeMap();

	//	Tear down the XML Atom cache
	//
	CXAtomCache::DeinitIfUsed();

	//	Delete the language ID cache
	//
	CLangIDCache::DestroyInstance();

	//	Tear down the instance data cache
	//
	CInstDataCache::DestroyInstance();

	//
	//	Deinit the metabase
	//
	MDDeinitialize();

	//	Tear down the child vroot cache
	//	We must do that after metabase is uninitialized and metabase notifications
	//	are shut down, as this cache listens to the metabase notifications.
	//	So if CChildVRCache is not there we may notify the object that does not
	//	exist and crash while doing that.
	//
	CChildVRCache::DestroyInstance();

	//	Deinit ECB logging
	//
#ifdef DBG
	if ( DEBUG_TRACE_TEST(ECBLogging) )
		DeinitECBLogging();
#endif

	//	Due to the fact that COM threads may still be siting in the pur code
	//	even they are done modifying our data, and there is no way we can
	//	push them out (synchronization would need to happen outside of our
	//	dll-s) - we will sleep for 5 seconds, hoping tha they will leave us alone.
	//
	Sleep(5000);

	//
	//	We can always shut down (for now...)
	//
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\content.cpp ===
/*
 *	C O N T E N T . C P P
 *
 *	DAV content types
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davprs.h"
#include "content.h"
#include <ex\reg.h>


//	------------------------------------------------------------------------
//
//	CchExtMapping()
//
//	Returns the size in characters required for a single mapping for
//	writing to the metabase.
//
//	The format of a mapping is null-terminated, comma-delimited string
//	(e.g. ".ext,application/ext").
//
inline UINT
CchExtMapping( UINT cchExt,
			   UINT cchContentType )
{
	return (cchExt +
			1 + // ','
			cchContentType +
			1); // '\0'
}

//	------------------------------------------------------------------------
//
//	PwchFormatExtMapping()
//
//	Formats a single mapping for writing to the metabase.
//
//	The format of a mapping is null-terminated, comma-delimited string
//	(e.g. ".ext,application/ext").
//
//	This function returns a pointer to the character beyond the null terminator
//	in the formatted mapping.
//
inline WCHAR *
PwchFormatExtMapping( WCHAR * pwchBuf,
					  LPCWSTR pwszExt,
					  UINT cchExt,
					  LPCWSTR pwszContentType,
					  UINT cchContentType )
{
	Assert(!IsBadReadPtr(pwszExt, sizeof(WCHAR) * (cchExt+1)));
	Assert(!IsBadReadPtr(pwszContentType, sizeof(WCHAR) * (cchContentType+1)));
	Assert(!IsBadWritePtr(pwchBuf, sizeof(WCHAR) * CchExtMapping(cchExt, cchContentType)));

	//	Dump in the extension first ...
	//
	memcpy(pwchBuf,
		   pwszExt,
		   sizeof(WCHAR) * cchExt);

	pwchBuf += cchExt;

	//	... followed by a comma
	//
	*pwchBuf++ = L',';

	//	... followed by the content type
	//
	memcpy(pwchBuf,
		   pwszContentType,
		   sizeof(WCHAR) * cchContentType);

	pwchBuf += cchContentType;

	//	... and null-terminated.
	//
	*pwchBuf++ = '\0';

	return pwchBuf;
}

//	========================================================================
//
//	CLASS CContentTypeMap
//
class CContentTypeMap : public IContentTypeMap
{
	//	Cache of mappings from filename extensions to content types
	//	(e.g. ".txt" --> "text/plain")
	//
	typedef CCache<CRCWszi, LPCWSTR> CMappingsCache;

	CMappingsCache m_cache;

	//	Flag set if the mappings came from an inherited mime map.
	//
	BOOL m_fIsInherited;

	//	CREATORS
	//
	CContentTypeMap(BOOL fMappingsInherited) :
		m_fIsInherited(fMappingsInherited)
	{
	}

	BOOL CContentTypeMap::FInit( LPWSTR pwszContentTypeMappings );

	//	NOT IMPLEMENTED
	//
	CContentTypeMap(const CContentTypeMap&);
	CContentTypeMap& operator=(CContentTypeMap&);

public:
	//	CREATORS
	//
	static CContentTypeMap * New( LPWSTR pwszContentTypeMappings,
								  BOOL fMappingsInherited );

	//	ACCESSORS
	//
	LPCWSTR PwszContentType( LPCWSTR pwszExt ) const
	{
		LPCWSTR * ppwszContentType = m_cache.Lookup( CRCWszi(pwszExt) );

		//
		//	Return the content type (if there was one).
		//	Note that the returned pointer is good only
		//	for the lifetime of the IMDData object that
		//	scopes us since that is where the raw data lives.
		//
		return ppwszContentType ? *ppwszContentType : NULL;
	}

	BOOL FIsInherited() const { return m_fIsInherited; }
};

//	------------------------------------------------------------------------
//
//	CContentTypeMap::FInit()
//
BOOL
CContentTypeMap::FInit( LPWSTR pwszContentTypeMappings )
{
	Assert( pwszContentTypeMappings );

	//
	//	Initialize the cache of mappings
	//
	if ( !m_cache.FInit() )
		return FALSE;

	//
	//	The format of the data in the mappings is a sequence of
	//	null-terminated strings followed by an additional null.
	//	Each string is of the format ".ext,type/subtype".
	//

	//
	//	Parse out the extension and type/subtype for each
	//	item and add a corresponding mapping to the cache.
	//
	for ( LPWSTR pwszMapping = pwszContentTypeMappings; *pwszMapping; )
	{
		enum {
			ISZ_CT_EXT = 0,
			ISZ_CT_TYPE,
			CSZ_CT_FIELDS
		};

		LPWSTR rgpwsz[CSZ_CT_FIELDS];
		UINT cchMapping;

		//
		//	Digest the metadata
		//
		if ( !FParseMDData( pwszMapping,
							rgpwsz,
							CSZ_CT_FIELDS,
							&cchMapping ) )
		{
			DebugTrace( "CContentTypeMap::FInit() - Malformed metadata\n" );
			return FALSE;
		}

		Assert(rgpwsz[ISZ_CT_EXT]);

		//
		//	Verify that the first field is an extension or '*'
		//
		if ( L'.' != *rgpwsz[ISZ_CT_EXT] && wcscmp(rgpwsz[ISZ_CT_EXT], gc_wsz_Star) )
		{
			DebugTrace( "CContentTypeMap::FInit() - Bad extension\n" );
			return FALSE;
		}

		Assert(rgpwsz[ISZ_CT_TYPE]);

		//
		//	Whatever there is in the second field is expected to be the
		//	content type.  Note that we don't do any syntactic checking
		//	there.
		//		The only special case we handle there is if the content
		//	type is a blank string. As IIS 6.0 treats that kind as
		//	application/octet-stream we will achieve the same behaviour
		//	by simply ignoring such bad content type that will make us
		//	default to application/octet-stream too. So omit content types
		//	with blank values.
		//
		if (L'\0' != *rgpwsz[ISZ_CT_TYPE])
		{
			//	Add a mapping from the extension to the content type
			//
			if ( !m_cache.FSet(CRCWszi(rgpwsz[ISZ_CT_EXT]), rgpwsz[ISZ_CT_TYPE]) )
				return FALSE;
		}

		//
		//	Get the next mapping
		//
		pwszMapping += cchMapping;
	}

	return TRUE;
}

//	------------------------------------------------------------------------
//
//	CContentTypeMap::New()
//
CContentTypeMap *
CContentTypeMap::New( LPWSTR pwszContentTypeMappings,
					  BOOL fMappingsInherited )
{
	auto_ref_ptr<CContentTypeMap> pContentTypeMap;

	pContentTypeMap.take_ownership(new CContentTypeMap(fMappingsInherited));

	if ( pContentTypeMap->FInit(pwszContentTypeMappings) )
		return pContentTypeMap.relinquish();

	return NULL;
}

//	------------------------------------------------------------------------
//
//	NewContentTypeMap()
//
//	Creates a new content type map from a string of content type mappings.
//
IContentTypeMap *
NewContentTypeMap( LPWSTR pwszContentTypeMappings,
				   BOOL fMappingsInherited )
{
	return CContentTypeMap::New( pwszContentTypeMappings,
								 fMappingsInherited );
}

//	========================================================================
//
//	CLASS CRegMimeMap
//
//	Global registry-based mime map from file extension to content type.
//
class CRegMimeMap : public Singleton<CRegMimeMap>
{
	//
	//	Friend declarations required by Singleton template
	//
	friend class Singleton<CRegMimeMap>;

	//
	//	String buffer for cached strings
	//
	ChainedStringBuffer<WCHAR> m_sb;

	//	Cache of mappings from filename extensions to content types
	//	(e.g. ".txt" --> "text/plain")
	//
	CCache<CRCWszi, LPCWSTR> m_cache;

	//	A R/W lock that we will use when when reading from
	//	the cache or when adding cache misses This lock
	//	is used by PszContentType().
	//
	//	FInitialize() does not use this lock (only initializes it)
	//	because it is called during dll load and we don't need to
	//	protect ourselves during dll load
	//
	CMRWLock   m_rwl;

	//	CREATORS
	//
	CRegMimeMap() {}

	//	NOT IMPLEMENTED
	//
	CRegMimeMap(const CRegMimeMap&);
	CRegMimeMap& operator=(CRegMimeMap&);

public:
	//	CREATORS
	//
	using Singleton<CRegMimeMap>::CreateInstance;
	using Singleton<CRegMimeMap>::DestroyInstance;
	BOOL FInitialize();

	//	ACCESSORS
	//
	using Singleton<CRegMimeMap>::Instance;

	//	Given an extension, return the Content-Type
	//	from the registry.
	//$NOTE: This was a const function before but it
	//	cannot be a const function anymore because we
	//	can add to our caches on cache misses.
	//
	LPCWSTR PwszContentType( LPCWSTR pwszExt );
};

//	------------------------------------------------------------------------
//
//	CRegMimeMap::FInitialize()
//
//	Load up the registry mappings.  Any kind of failure (short of an
//	exception) is not considered fatal.  It just means that we will
//	rely on the superceding metabase mappings.
//
BOOL
CRegMimeMap::FInitialize()
{
	BOOL fRet = FALSE;
	CRegKey regkeyClassesRoot;
	DWORD dwResult;
	
	//
	//	Initialize the cache of mappings
	//
	if ( !m_cache.FInit() )
		goto ret;

	//	Init the R/W lock.
	//
	if (!m_rwl.FInitialize())
		goto ret;

	//
	//	Read in the mapping information from the registry
	//

	//  Get the base of the classes hierarchy in the registry
	//
	dwResult = regkeyClassesRoot.DwOpen( HKEY_CLASSES_ROOT, L"" );
	if ( dwResult != NO_ERROR )
		goto ret;

	// Iterate over all the entries looking for content-type associations
	//
	for ( DWORD iMapping = 0;; iMapping++ )
	{
		WCHAR wszSubKey[MAX_PATH];
		DWORD cchSubKey;
		DWORD dwDataType;
		CRegKey regkeySub;
		WCHAR wszContentType[MAX_PATH] = {0};
		DWORD cbContentType = MAX_PATH;

		//
		//	Locate the next subkey.  If there isn't one then we're done.
		//
		cchSubKey = CElems(wszSubKey);
		dwResult = regkeyClassesRoot.DwEnumSubKey( iMapping, wszSubKey, &cchSubKey );
		if ( dwResult != NO_ERROR )
		{
			//
			//  Ignore keys that are larger than MAX_PATH.  
			//  Note that keys larger than MAX_PATH shouldn't be allowed 
			//  but if we didn't check and then hit one initialization 
			//  would fail
			//
			if ( ERROR_MORE_DATA == dwResult )
				continue;

			fRet = (ERROR_NO_MORE_ITEMS == dwResult);
			goto ret;
		}

		//
		//	Open that subkey.
		//
		dwResult = regkeySub.DwOpen( regkeyClassesRoot, wszSubKey );
		if ( dwResult != NO_ERROR )
			continue;

		//
		//  Get the associated Media-Type (Content-Type)
		//
		dwResult = regkeySub.DwQueryValue( L"Content Type",
										   wszContentType,
										   &cbContentType,
										   &dwDataType );
		if ( dwResult != NO_ERROR || dwDataType != REG_SZ )
			continue;

		//
		//	Add a mapping for this extension/content type pair.
		//
		//	Note: FAdd() cannot fail here -- FAdd() only fails on
		//	allocator failures.  Our allocators throw.
		//
		(VOID) m_cache.FAdd (CRCWszi(m_sb.AppendWithNull(wszSubKey)),
							 m_sb.AppendWithNull(wszContentType));
	}
	
ret:
	return fRet;
}


LPCWSTR
CRegMimeMap::PwszContentType( LPCWSTR pwszExt )
{
	LPCWSTR pwszContentType = NULL;
	LPCWSTR * ppwszContentType = NULL;
	CRegKey regkeyClassesRoot;
	CRegKey regkeySub;
	DWORD dwResult;
	DWORD dwDataType;
	WCHAR prgwchContentType[MAX_PATH] = {0};
	DWORD cbContentType;

	//	Grab a reader lock and check the cache.
	//
	{
		CSynchronizedReadBlock srb(m_rwl);

		ppwszContentType = m_cache.Lookup( CRCWszi(pwszExt) );
	}

	//
	//	Return the content type (if there was one).
	//	Note that the returned pointer is good only
	//	for the lifetime of the cache (since we never
	//	modify the cache after class initialization)
	//	which, in turn, is only good for the lifetime
	//	of this object.  The external interface functions
	//	FGetContentTypeFromPath() and FGetContentTypeFromURI()
	//	both copy the returned content type into caller-supplied
	//	buffers.
	//
	if (ppwszContentType)
	{
		pwszContentType = *ppwszContentType;
		goto ret;
	}

	//	Otherwise, read in the mapping information from the registry
	//

	//  Get the base of the classes hierarchy in the registry
	//
	dwResult = regkeyClassesRoot.DwOpen( HKEY_CLASSES_ROOT, L"" );
	if ( dwResult != NO_ERROR )
		goto ret;


	//	Open that subkey of the extension we are looking for.
	//
	dwResult = regkeySub.DwOpen( regkeyClassesRoot, pwszExt );
	if ( dwResult != NO_ERROR )
		goto ret;

	//  Get the associated Media-Type (Content-Type)
	//
	cbContentType = sizeof(prgwchContentType);
	dwResult = regkeySub.DwQueryValue( L"Content Type",
									   prgwchContentType,
									   &cbContentType,
									   &dwDataType );
	if ( dwResult != NO_ERROR || dwDataType != REG_SZ )
		goto ret;

	//	Before adding the mapping for this extension/content type
	//	pair to the cache, take a writer lock and check the cache
	//	to see if someone has beaten us to it.
	//
	//	Grab a reader lock and check the cache.
	//
	{
		CSynchronizedWriteBlock swb(m_rwl);

		ppwszContentType = m_cache.Lookup( CRCWszi(pwszExt) );

		if (ppwszContentType)
		{
			pwszContentType = *ppwszContentType;
			goto ret;
		}

		pwszContentType = m_sb.AppendWithNull(prgwchContentType);

		Assert (pwszContentType);

		//	Note: FAdd() cannot fail here -- FAdd() only fails on
		//	allocator failures.  Our allocators throw.
		//
		(VOID) m_cache.FAdd (CRCWszi(m_sb.AppendWithNull(pwszExt)),
							 pwszContentType);
	}
ret:
	return pwszContentType;
}

//	------------------------------------------------------------------------
//
//	FInitRegMimeMap()
//
BOOL
FInitRegMimeMap()
{
	return CRegMimeMap::CreateInstance().FInitialize();
}

//	------------------------------------------------------------------------
//
//	DeinitRegMimeMap()
//
VOID
DeinitRegMimeMap()
{
	CRegMimeMap::DestroyInstance();
}


//	------------------------------------------------------------------------
//
//	HrGetContentTypeByExt()
//
//	Fetch the content type of a resource based on its path/URI extension.
//	This function searches the following three places, in order, for a mapping:
//
//	1) a caller-supplied content type map
//	2) the global (metabase) content type map
//	3) the global (registry) content type map
//
//	Parameters:
//
//		pContentTypeMapLocal	[IN]	If non-NULL, points to the content type
//										map to search first.
//
//		pwszExt					[IN]	Extension to search on
//		pwszBuf					[OUT]	Buffer in which to copy the mapped
//										content type
//		pcchBuf					[IN]	Size of buffer in characters including 0 termination
//								[OUT]	Size of mapped content type
//
//		pfIsGlobalMapping		[OUT]	(Optional) Pointer to flag which is set
//										if the mapping is from a global map.
//
//	Returns:
//
//	S_OK
//		if a mapping was found and copied into the caller-supplied buffer
//		The size of the mapped content type is returned in *pcchzBuf.
//
//	HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND)
//		if no mapping was found in any of the maps
//
//	HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY)
//		if a mapping was found, but the caller supplied buffer was too small.
//		The required size of the buffer is returned in *pcchzBuf.
//
HRESULT
HrGetContentTypeByExt( const IEcb& ecb,
					   const IContentTypeMap * pContentTypeMapLocal,
					   LPCWSTR pwszExt,
					   LPWSTR pwszBuf,
					   UINT * pcchBuf,
					   BOOL * pfIsGlobalMapping )
{
	Assert(!pfIsGlobalMapping || !IsBadWritePtr(pfIsGlobalMapping, sizeof(BOOL)));

	LPCWSTR pwszContentType = NULL;
	auto_ref_ptr<IMDData> pMDData;
	const IContentTypeMap * pContentTypeMapGlobal;

	//
	//	If a local map was specified then check it first for
	//	the extension based mapping.
	//
	if ( pContentTypeMapLocal )
		pwszContentType = pContentTypeMapLocal->PwszContentType(pwszExt);

	//
	//	If this doesn't yield a mapping then try the global mime map.
	//	Note: if we fail to get any metadata for the global mime map
	//	then use gc_szAppl_Octet_Stream rather than trying the registry.
	//	We'd rather use a "safe" default than a possibly intentionally
	//	overridden value from the registry.
	//
	if ( !pwszContentType )
	{
		if ( SUCCEEDED(HrMDGetData(ecb, gc_wsz_Lm_MimeMap, gc_wsz_Lm_MimeMap, pMDData.load())) )
		{
			pContentTypeMapGlobal = pMDData->GetContentTypeMap();

			if ( pContentTypeMapGlobal )
			{
				pwszContentType = pContentTypeMapGlobal->PwszContentType(pwszExt);
				if (pwszContentType && pfIsGlobalMapping)
					*pfIsGlobalMapping = TRUE;
			}
		}
		else
		{
			pwszContentType = gc_wszAppl_Octet_Stream;
		}
	}

	//
	//	Nothing in the global mime map either?
	//	Then try the registry as a last resort.
	//
	if ( !pwszContentType )
	{
		pwszContentType = CRegMimeMap::Instance().PwszContentType(pwszExt);
		if (pwszContentType && pfIsGlobalMapping)
			*pfIsGlobalMapping = TRUE;
	}

	//
	//	If there wasn't anything in the registry either then there is
	//	no mapping for this extension.
	//
	if ( !pwszContentType )
		return HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);

	//
	//	If we did find a mapping via one of the above methods
	//	then attempt to copy it into the caller-supplied buffer.
	//	If the buffer is not big enough, return an appropriate error.
	//	Note: FCopyStringToBuf() will fill in the required size
	//	if the buffer was not big enough.
	//
	return FCopyStringToBuf( pwszContentType,
							 pwszBuf,
							 pcchBuf ) ?

				S_OK : HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
}

//	------------------------------------------------------------------------
//
//	PszExt()
//
//	Returns any extension (i.e. characters including
//	and following a '.') appearing in the string pointed
//	to by pchPathBegin that appear at or before pchPathEnd.
//
//	Returns NULL if there is no extension.
//
inline LPCWSTR
PwszExt( LPCWSTR pwchPathBegin,
		 LPCWSTR pwchPathEnd )
{
	Assert(pwchPathEnd);

	//
	//	Scan backward from the designated end of the path looking
	//	for a '.' that begins an extension.  If we don't find one
	//	or we find a path separator ('/') then there is no extension.
	//
	while ( pwchPathEnd-- > pwchPathBegin )
	{
		if ( L'.' == *pwchPathEnd )
			return pwchPathEnd;

		if ( L'/'  == *pwchPathEnd )
			return NULL;
	}

	return NULL;
}

//	------------------------------------------------------------------------
//
//	FGetContentType()
//
//	Fetches the content type of the resource at the specified path/URI
//	and copies it into a caller-supplied buffer.
//
//	The copied content type comes from one of the following mappings:
//
//	1) Via an explicit mapping from the specified path/URI extension.
//	2) Via a ".*" (default) mapping
//	3) application/octet-stream
//
//	Parameters:
//
//		pContentTypeMapLocal	[IN]	If non-NULL, points to a content type
//										map for HrGetContentTypeByExt() to
//										search first for each of the first
//										two methods above.
//
//		pwszPath				[IN]	Path whose content type is desired.
//		pwszBuf					[OUT]	Buffer in which to copy the mapped
//										content type
//		pcchBuf					[IN]	Size of buffer in characters including 0 termination
//								[OUT]	Size of mapped content type
//
//		pfIsGlobalMapping		[OUT]	(Optional) Pointer to flag which is set
//										if the mapping is from a global map.
//
//	Returns:
//
//	TRUE
//		if the mapping was successfully copied into the caller-supplied buffer.
//		The size of the mapped content type is returned in *pcchzBuf.
//
//	FALSE
//		if the caller-supplied buffer was too small.
//		The required size of the buffer is returned in *pcchzBuf.
//
BOOL
FGetContentType( const IEcb& ecb,
				 const IContentTypeMap * pContentTypeMapLocal,
				 LPCWSTR pwszPath,
				 LPWSTR pwszBuf,
				 UINT * pcchBuf,
				 BOOL * pfIsGlobalMapping )
{
	HRESULT hr;

	CStackBuffer<WCHAR>	pwszCopy;
	BOOL fCopy = FALSE;
	UINT cchPath = static_cast<UINT>(wcslen(pwszPath));

	//	Scan backward to skip all '/' characters at the end.
	//
	while ( cchPath  && (L'/' == pwszPath[cchPath-1]) )
	{
		cchPath--;
		fCopy = TRUE;	// Fine to keep the assignment here, as clients usually
						// do not put multiple wacks at the end of the path.
	}

	if (fCopy)
	{
		//	Make the copy of the path without ending wacks.
		//
		if (!pwszCopy.resize(CbSizeWsz(cchPath)))
			return FALSE;

		memcpy( pwszCopy.get(), pwszPath, cchPath * sizeof(WCHAR) );
		pwszCopy[cchPath] = L'\0';

		//	Swap the pointers
		//
		pwszPath = pwszCopy.get();
	}

	//
	//	First check for an extension mapping in both the specified
	//	content type map and the global mime map.
	//
	//	The loop checks progressively longer extensions.  E.g. a path
	//	of "/foo/bar/baz.a.b.c" will be checked for ".c" then ".b.c"
	//	then ".a.b.c".  This is consistent with IIS' behavior.
	//
	for ( LPCWSTR pwszExt = PwszExt(pwszPath, pwszPath + cchPath);
		  pwszExt;
		  pwszExt = PwszExt(pwszPath, pwszExt) )
	{
		hr = HrGetContentTypeByExt( ecb,
									pContentTypeMapLocal,
									pwszExt,
									pwszBuf,
									pcchBuf,
									pfIsGlobalMapping );

		if ( HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) != hr )
		{
			Assert( S_OK == hr || HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY) == hr );
			return SUCCEEDED(hr);
		}
	}

	//
	//	There is no extension mapping so check both maps
	//	for a ".*" (default) mapping.  Note: don't set *pfIsGlobalMapping if
	//	the ".*" mapping is the only one that applies.  The ".*" mapping is
	//	a catch-all; it is ok for local mime maps to override it.
	//
	hr = HrGetContentTypeByExt( ecb,
								pContentTypeMapLocal,
								L".*",
								pwszBuf,
								pcchBuf,
								NULL );

	if ( HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) != hr )
	{
		Assert( S_OK == hr || HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY) == hr );
		return SUCCEEDED(hr);
	}

	//
	//	No ".*" mapping either so use the default default --
	//	application/octet-stream.
	//
	return FCopyStringToBuf( gc_wszAppl_Octet_Stream,
							 pwszBuf,
							 pcchBuf );
}

//	------------------------------------------------------------------------
//
//	FGetContentTypeFromPath()
//
//	Fetch the content type associated with the extension of the
//	specified file path.
//
BOOL FGetContentTypeFromPath( const IEcb& ecb,
							  LPCWSTR pwszPath,
							  LPWSTR pwszBuf,
							  UINT * pcchBuf )
{
	return FGetContentType( ecb,
							NULL, // No local map to check
							pwszPath,
							pwszBuf,
							pcchBuf,
							NULL ); // Don't care where the mapping comes from
}

//	------------------------------------------------------------------------
//
//	FGetContentTypeFromURI()
//
//	Retrieves the content type for the specified URI.
//
BOOL
FGetContentTypeFromURI( const IEcb& ecb,
						LPCWSTR pwszURI,
						LPWSTR  pwszBuf,
						UINT * pcchBuf,
						BOOL * pfIsGlobalMapping )
{
	auto_ref_ptr<IMDData> pMDData;

	//
	//	Fetch the metadata for this URI.  If it has a content type map
	//	then use it to look for a mapping.  If it does not have a content
	//	type map then check the global mime map.
	//
	//	Note: if we fail to get the metadata at all then default the
	//	content type to application/octet-stream.  Do not use the global
	//	mime map just because we cannot get the metadata.
	//
	if ( FAILED(HrMDGetData(ecb, pwszURI, pMDData.load())) )
	{
		DebugTrace( "FGetContentTypeFromURI() - HrMDGetData() failed to get metadata for %S.  Using application/octet-stream...\n", pwszURI );
		return FCopyStringToBuf( gc_wszAppl_Octet_Stream,
								 pwszBuf,
								 pcchBuf );
	}

	const IContentTypeMap * pContentTypeMap = pMDData->GetContentTypeMap();

	//
	//	If there is a content type map specific to this URI then
	//	try it first looking for a "*" (unconditional) mapping.
	//
	if ( pContentTypeMap )
	{
		LPCWSTR pwszContentType = pContentTypeMap->PwszContentType(gc_wsz_Star);
		if ( pwszContentType )
			return FCopyStringToBuf( pwszContentType,
									 pwszBuf,
									 pcchBuf );
	}

	//
	//	There was either no "*" mapping or no URI-specific map
	//	so check the global maps
	//
	return FGetContentType( ecb,
							pContentTypeMap,
							pwszURI,
							pwszBuf,
							pcchBuf,
							pfIsGlobalMapping );
}

//	------------------------------------------------------------------------
//
//	ScApplyStarExt()
//
//		Determines whether the mapping "*" --> pwszContentType should be used
//		instead of the mapping *ppwszExt --> pwszContentType based on the
//		following criteria:
//
//		Use the mapping "*" --> pwszContentType if:
//
//			o	*ppwszExt is already "*", OR
//			o	a mapping exists in pwszMappings for *ppwszExt whose content type
//				is not the same as pwszContentType, OR
//			o	a "*" mapping exists in pwszMappings.
//
//		Use *ppwszExt --> pwszContentType otherwise.
//
//	Returns:
//
//		The value returned in *ppwszExt indicates the mapping to be used.
//
SCODE
ScApplyStarExt( LPWSTR pwszMappings,
				LPCWSTR pwszContentType,
				LPCWSTR * ppwszExt )

{
	SCODE sc = S_OK;

	Assert(pwszMappings);
	Assert(!IsBadWritePtr(ppwszExt, sizeof(LPCWSTR)));
	Assert(*ppwszExt);
	Assert(pwszContentType);

	//
	//	Parse out the extension and type/subtype for each
	//	item and check for conflicts or "*" mappings.
	//
	for ( LPWSTR pwszMapping = pwszMappings;
		  L'*' != *(*ppwszExt) && *pwszMapping; )
	{
		enum {
			ISZ_CT_EXT = 0,
			ISZ_CT_TYPE,
			CSZ_CT_FIELDS
		};

		LPWSTR rgpwsz[CSZ_CT_FIELDS];

		//
		//	Digest the metadata for this mapping
		//
		{
			UINT cchMapping;

			if ( !FParseMDData( pwszMapping,
								rgpwsz,
								CSZ_CT_FIELDS,
								&cchMapping ) )
			{
				sc = E_FAIL;
				DebugTrace("ScApplyStarExt() - Malformed metadata 0x%08lX\n", sc);
				goto ret;
			}

			pwszMapping += cchMapping;
		}

		Assert(rgpwsz[ISZ_CT_EXT]);
		Assert(rgpwsz[ISZ_CT_TYPE]);

		//
		//	If this is a "*" mapping OR
		//	If the extension matches *ppszExt AND
		//		the content types conflict
		//
		//	then use a "*" mapping.
		//
		if ((L'*' == *rgpwsz[ISZ_CT_EXT]) ||
			(!_wcsicmp((*ppwszExt), rgpwsz[ISZ_CT_EXT]) &&
			 _wcsicmp(pwszContentType, rgpwsz[ISZ_CT_TYPE])))
		{
			*ppwszExt = gc_wsz_Star;
		}

		//
		//	!!!IMPORTANT!!!  FParseMDData() munges the mapping string.
		//	Specifically, it replaces the comma separator with a null.
		//	We always need to restore the comma so that the mappings
		//	string is not modified by this function!
		//
		*(rgpwsz[ISZ_CT_EXT] + wcslen(rgpwsz[ISZ_CT_EXT])) = L',';
	}

ret:

	return sc;
}

DEC_CONST WCHAR gc_wszIisWebFile[] = L"IisWebFile";

//	------------------------------------------------------------------------
//
//	ScAddMimeMap()
//
//		Adds the mapping pwszExt --> pwszContentType to the mime map at
//		the metabase path pwszMDPath relative to the currently open
//		metabase handle mdoh, creating a new mime map as required.
//
//		A new mime map is required when there is no existing mime map
//		(pwszMappings is NULL) or if a "*" mapping is being set.  In the
//		latter case, the "*" map overwrites whatever mapping is there.
//
SCODE
ScAddMimeMap( const CMDObjectHandle& mdoh,
			  LPCWSTR pwszMDPath,
			  LPWSTR  pwszMappings,
			  UINT	  cchMappings,
			  LPCWSTR pwszExt,
			  LPCWSTR pwszContentType )
{
	CStackBuffer<WCHAR> wszBuf;
	UINT cchContentType;
	UINT cchExt;
	WCHAR * pwch;

	Assert(pwszExt);
	Assert(pwszContentType);

	cchExt = static_cast<UINT>(wcslen(pwszExt));
	cchContentType = static_cast<UINT>(wcslen(pwszContentType));

	//	If content type we want to set is blank, then do not
	//	attempt to do that - IIS does not properly understand
	//	such kind of thing, and the item with such content
	//	type is to be treated as application/octet-stream
	//	which will be guaranteed by the absence of content
	//	type in the metabase.
	//
	if (L'\0' == *pwszContentType)
	{
		return S_OK;
	}

	if (pwszMappings && L'*' != *pwszExt)
	{
		//	IIS has an interesting concept of an empty mapping.  Instead
		//	of just a single null (indicating an empty list of mapping
		//	strings) it uses a double null which to us would actually mean
		//	a list of strings consisting solely of the empty string!
		//	Anyway, if we add a mapping after this "empty mapping" neither
		//	IIS nor HTTPEXT will ever see it because the mime map checking
		//	implementations in both code bases treat the extraneous null
		//	as the list terminator.
		//
		//		If we have an "empty" set of mappings then REPLACE
		//		it with a set consisting of just the new mapping.
		//
		if (2 == cchMappings && !*pwszMappings)
			--cchMappings;

		//	Start at the end of the current mappings.  Skip the extra
		//	null at the end.  We will add it back later.
		//
		Assert(cchMappings >= 1);
		Assert(L'\0' == pwszMappings[cchMappings-1]);
		pwch = pwszMappings + cchMappings - 1;
	}
	else
	{
		//	Allocate enough space including list terminating 0
		//
		if (!wszBuf.resize(CbSizeWsz(CchExtMapping(cchExt, cchContentType))))
			return E_OUTOFMEMORY;

		//	Since this is the only mapping, start from the beginning
		//
		pwszMappings = wszBuf.get();
		pwch = pwszMappings;
	}

	//	Append the new mapping to the end of the existing mappings (if any).
	//
	pwch = PwchFormatExtMapping(pwch,
								pwszExt,
								cchExt,
								pwszContentType,
								cchContentType);

	//	Terminate the new set of mappings
	//
	*pwch++ = L'\0';

	//	Write the mappings out to the metabase
	//
	METADATA_RECORD mdrec;

	//$	REVIEW: if the value for pwszMDPath is non-NULL, then this means that the key to
	//	which we are trying to right, does not exist at this point.  If it did, we would have
	//	opened it directly and set the data on the node directly.  In the case of it being
	//	non-NULL, that means that we must also set the MD_KEY_TYPE as well.
	//
	if (NULL != pwszMDPath)
	{
		mdrec.dwMDIdentifier = MD_KEY_TYPE;
		mdrec.dwMDAttributes = METADATA_NO_ATTRIBUTES;
		mdrec.dwMDUserType = IIS_MD_UT_FILE;
		mdrec.dwMDDataType = STRING_METADATA;
		mdrec.dwMDDataLen  = CbSizeWsz(CchConstString(gc_wszIisWebFile));
		mdrec.pbMDData = reinterpret_cast<LPBYTE>(const_cast<WCHAR*>(gc_wszIisWebFile));
		(void) mdoh.HrSetMetaData (pwszMDPath, &mdrec);
	}
	//
	//$	REVIEW: end.

	mdrec.dwMDIdentifier = MD_MIME_MAP;
	mdrec.dwMDAttributes = METADATA_INHERIT;
	mdrec.dwMDUserType = IIS_MD_UT_FILE;
	mdrec.dwMDDataType = MULTISZ_METADATA;
	mdrec.dwMDDataLen  = static_cast<DWORD>(pwch - pwszMappings) * sizeof(WCHAR);
	mdrec.pbMDData = reinterpret_cast<LPBYTE>(pwszMappings);

	return mdoh.HrSetMetaData(pwszMDPath, &mdrec);
}

//	------------------------------------------------------------------------
//
//	ScSetStarMimeMap()
//
SCODE
ScSetStarMimeMap( const IEcb& ecb,
				  LPCWSTR pwszURI,
				  LPCWSTR pwszContentType )
{
	SCODE sc = E_OUTOFMEMORY;

	//	Get the metabase path corresponding to pwszURI.
	//
	CStackBuffer<WCHAR,MAX_PATH> pwszMDPathURI;
	if (NULL == pwszMDPathURI.resize(CbMDPathW(ecb,pwszURI)))
		return sc;

	{
		MDPathFromURIW(ecb, pwszURI, pwszMDPathURI.get());
		CMDObjectHandle	mdoh(ecb);
		LPCWSTR pwszMDPathMimeMap;

		//	Open a metabase object at or above the path where we want to set
		//	the star mime map.
		//
		sc = HrMDOpenMetaObject( pwszMDPathURI.get(),
								 METADATA_PERMISSION_WRITE,
								 1000, // timeout in msec (1.0 sec)
								 &mdoh );
		if (SUCCEEDED(sc))
		{
			pwszMDPathMimeMap = NULL;
		}
		else
		{
			if (sc != HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND))
			{
				DebugTrace ("ScSetStarMimeMap() - HrMDOpenMetaObject(pszMDPathURI) "
							"failed 0x%08lX\n", sc);
				goto ret;
			}

			sc = HrMDOpenMetaObject( ecb.PwszMDPathVroot(),
									 METADATA_PERMISSION_WRITE,
									 1000,
									 &mdoh );
			if (FAILED(sc))
			{
				DebugTrace("ScSetStarMimeMap() - HrMDOpenMetaObject(ecb.PwszMDPathVroot()) "
						   "failed 0x%08lX\n", sc);
				goto ret;
			}

			Assert(!_wcsnicmp(pwszMDPathURI.get(),
							  ecb.PwszMDPathVroot(),
							  wcslen(ecb.PwszMDPathVroot())));

			pwszMDPathMimeMap = pwszMDPathURI.get() + wcslen(ecb.PwszMDPathVroot());
		}

		//	Add the "*" mime map
		//
		sc = ScAddMimeMap(mdoh,
						  pwszMDPathMimeMap,
						  NULL,			//	Overwrite existing mimemap (if any)
						  0,			//
						  gc_wsz_Star,	//	with "*" --> pszContentType
						  pwszContentType);
		if (FAILED(sc))
		{
			DebugTrace("ScSetStarMimeMap() - ScAddMimeMap() failed 0x%08lX\n", sc);
			goto ret;
		}
	}

ret:

	return sc;
}

//	------------------------------------------------------------------------
//
//	ScAddExtMimeMap() (aka the guts behind NT5:292139)
//
//		Use the following algorithm to set the content type (pwszContentType)
//		of the resource at pwszURI:
//
//			If a mime map exists somewhere at or above the metabase path for
//			pwszURI that has no mapping for the extension of pwszURI AND that
//			mapping does NOT have a "*" mapping, then add a mapping from
//			the extension of pwszURI to pwszContentType to that map.
//
//			If no such map exists then create one at the site root and
//			add the mapping there.
//
//			In all other cases, add the mapping "*" --> pwszContentType
//			at the level of pwszURI.
//
//		The idea behind this complicated little routine is to reduce the number
//		of "*" mappings that we create in the metabase to represent content types
//		of resources with extensions that are not found in any administrator-defined
//		mime map or global mime map.  This helps most in scenarios where a new
//		application is deployed which uses a heretofore unknown extension and
//		the install utility (or admin) neglects to register a content type mapping
//		for that application in any mime map.
//
//		Without this functionality, we could end up creating "*" mappings for
//		every resource created with an unknown extension.  With time that would
//		drag down the performance of the metabase significantly.
//
SCODE
ScAddExtMimeMap( const IEcb& ecb,
				 LPCWSTR pwszURI,
				 LPCWSTR pwszContentType )
{
	//	Metabase path corresponding to pwszURI.  We form a relative path,
	//	off of this path, where we set a "*" mapping if we need to do so.
	//
	CStackBuffer<WCHAR,MAX_PATH> pwszMDPathURI(CbMDPathW(ecb, pwszURI));
	if (!pwszMDPathURI.get())
		return E_OUTOFMEMORY;

	MDPathFromURIW(ecb, pwszURI, pwszMDPathURI.get());
	UINT cchPathURI = static_cast<UINT>(wcslen(pwszMDPathURI.get()));

	//	Metabase path to the non-inherited mime map closest to pwszURI.  When there
	//	is no such mime map, this is just the metabase path to the site root.
	//
	CStackBuffer<WCHAR,MAX_PATH> pwszMDPathMimeMap(CbSizeWsz(cchPathURI));
	if (!pwszMDPathMimeMap.get())
		return E_OUTOFMEMORY;

	memcpy(pwszMDPathMimeMap.get(),
		   pwszMDPathURI.get(),
		   CbSizeWsz(cchPathURI));
	UINT cchPathMimeMap = cchPathURI;
	LPWSTR pwszMDPathMM = pwszMDPathMimeMap.get();

	//	Buffer for the metabase path to the site root (e.g. "/LM/W3SVC/1/root").
	//
	WCHAR rgwchMDPathSiteRoot[MAX_PATH];
	SCODE sc = S_OK;

	//	Locate the non-inherited mime map "closest" to pszURI by probing successively
	//	shorter path prefixes until a non-inherited mime map is found or until we reach
	//	the site root, whichever happens first.
	//
	for ( ;; )
	{
		//	Fetch the (hopefully cached) metadata for the current metabase path.
		//
		//$OPT
		//	Note the use of /LM/W3SVC as the "open" path.  We use that path because
		//	it is guaranteed to exist (a requirement for this form of HrMDGetData())
		//	and because it is above the site root.  It is also easily computable
		//	(it's a constant!).  It does however lock a pretty huge portion of the
		//	metabase fetching the metadata.  If this turns out to not perform well
		//	(i.e. the call fails due to timeout under normal usage) then we should
		//	evaluate whether a "lower" path -- like the site root -- would be a
		//	more appropriate choice.
		//
		auto_ref_ptr<IMDData> pMDDataMimeMap;
		sc = HrMDGetData(ecb,
						 pwszMDPathMM,
						 gc_wsz_Lm_W3Svc,
						 pMDDataMimeMap.load());
		if (FAILED(sc))
		{
			DebugTrace("ScAddExtMimeMap() - HrMDGetData(pwszMDPathMimeMap) failed 0x%08lX\n", sc);
			goto ret;
		}

		//	Look for a mime map (inherited or not) in the metadata.  If we don't find
		//	one then we'll want to create one at the site root.
		//
		IContentTypeMap * pContentTypeMap;
		pContentTypeMap = pMDDataMimeMap->GetContentTypeMap();
		if (!pContentTypeMap)
		{
			ULONG cchPathSiteRoot = CElems(rgwchMDPathSiteRoot) - gc_cch_Root;

			//	We did not find any mime map (inherited or otherwise) so
			//	set up to create a mime map at the site root.
			//
			//	Get the instance root (e.g. "/LM/W3SVC/1")
			//
			if (!ecb.FGetServerVariable("INSTANCE_META_PATH",
										rgwchMDPathSiteRoot,
										&cchPathSiteRoot))
			{
				sc = HRESULT_FROM_WIN32(GetLastError());
				DebugTrace("ScAddExtMimeMap() - ecb.FGetServerVariable(INSTANCE_META_PATH) failed 0x%08lX\n", sc);
				goto ret;
			}

			//	Convert the size (in bytes) of the site root path to a length (in characters).
			//	Remember: cbPathSiteRoot includes the null terminator.
			//
			cchPathMimeMap = cchPathSiteRoot - 1;

			//	Tack on the "/root" part to get something like "/LM/W3SVC/1/root".
			//
			memcpy( rgwchMDPathSiteRoot + cchPathMimeMap,
					gc_wsz_Root,
					CbSizeWsz(gc_cch_Root)); // copy the null terminator too

			cchPathMimeMap += gc_cch_Root;
			pwszMDPathMM = rgwchMDPathSiteRoot;
			break;
		}
		else if (!pContentTypeMap->FIsInherited())
		{
			//	We found a non-inherited mime map at pwszMDPathMimeMap
			//	so we are done looking.
			//
			break;
		}

		//	We found a mime map, but it was an inherited mime map,
		//	so back up one path component and check there.  Eventually
		//	we will find the path where it was inherited from.
		//
		while ( L'/' != pwszMDPathMM[--cchPathMimeMap])
			Assert(cchPathMimeMap > 0);

		pwszMDPathMM[cchPathMimeMap] = L'\0';
	}

	//	At this point, pwszMDPathMimeMap is the location of an existing non-inherited
	//	mime map or the site root.  Now we want to lock down the metabase at this
	//	path (and everything below it) so that we can consistently check the actual
	//	current mime map contents (remember, we were looking at a cached view above!)
	//	and update them with the new mapping.
	//
	{
		CMDObjectHandle	mdoh(ecb);
		METADATA_RECORD mdrec;

		//	Figure out the file extension on the URI.  If it doesn't have one
		//	then we know right away that we are going to use a "*" mapping.
		//
		LPCWSTR pwszExt = PwszExt(pwszURI, pwszURI + wcslen(pwszURI));
		if (!pwszExt)
			pwszExt = gc_wsz_Star;

		//	Buffer size for the mime map metadata.  8K should be big enough
		//	for most mime maps -- the global mime map at lm/MimeMap is only ~4K.
		//
		enum { CCH_MAPPINGS_MAX = 2 * 1024 };

		//	Compute the size of the new mapping and do a quick check
		//	to handle any rogue user who tries to pull a fast one by creating
		//	a mapping that is ridiculously large.
		//
		UINT cchNewMapping = CchExtMapping(static_cast<UINT>(wcslen(pwszExt)),
				static_cast<UINT>(wcslen(pwszContentType)));

		if (cchNewMapping >= CCH_MAPPINGS_MAX )
		{
			sc = E_DAV_INVALID_HEADER;  //HSC_BAD_REQUEST
			goto ret;
		}

		//	Buffer for the mime map metadata.  8K should be big enough for most
		//	mime maps -- the global mime map at lm/MimeMap is only ~4K.
		//	And don't forget to leave room at the end for the new mapping!
		//
		CStackBuffer<BYTE,4096> rgbData;
		Assert (rgbData.size() == (CCH_MAPPINGS_MAX * sizeof(WCHAR)));
		DWORD cbData = (CCH_MAPPINGS_MAX - cchNewMapping) * sizeof(WCHAR);

		//	Open the metadata object at the path we found.  We know that the path
		//	that we want to open already exists -- if it is a path to some node
		//	with a non-inherited mime map then it is the path to the site root.
		//
		sc = HrMDOpenMetaObject( pwszMDPathMM,
								 METADATA_PERMISSION_WRITE |
								 METADATA_PERMISSION_READ,
								 1000, // timeout in msec (1.0 sec)
								 &mdoh );
		if (FAILED(sc))
		{
			DebugTrace("ScAddExtMimeMap() - HrMDOpenMetaObject() failed 0x%08lX\n", sc);
			goto ret;
		}

		//	Fetch the mime map.
		//
		mdrec.dwMDIdentifier = MD_MIME_MAP;
		mdrec.dwMDAttributes = METADATA_INHERIT;
		mdrec.dwMDUserType   = IIS_MD_UT_FILE;
		mdrec.dwMDDataType   = MULTISZ_METADATA;
		mdrec.dwMDDataLen    = cbData;
		mdrec.pbMDData       = rgbData.get();

		sc = mdoh.HrGetMetaData( NULL, // No relative path to the mime map.
									   // We opened a path directly there above.
								 &mdrec,
								 &cbData );

		if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == sc)
		{
			//	In the unlikely event that the static-size buffer above wasn't
			//	big enough, then try reading again into a one that is.
			//
			//	Again, leave enough room for the new mapping
			//
			mdrec.dwMDDataLen = cbData;
			mdrec.pbMDData = rgbData.resize(cbData + cchNewMapping * sizeof(WCHAR));
			sc = mdoh.HrGetMetaData( NULL, &mdrec, &cbData );
		}
		if (FAILED(sc))
		{
			if (MD_ERROR_DATA_NOT_FOUND != sc)
			{
				DebugTrace("ScAddExtMimeMap() - HrMDOpenMetaObject() failed 0x%08lX\n", sc);
				goto ret;
			}

			//	If we don't find a mapping, that's fine.  Most likely we are just
			//	at the site root.  There is also a slim chance that the admin could
			//	have deleted the mapping between the time we found it in the cache
			//	and the time that we locked the path in the metabase.
			//
			mdrec.pbMDData = NULL;
			sc = S_OK;
		}

		//	If we don't have a mime map then use a "*" mapping unless we are
		//	at the site root in which case we should CREATE a mime map with
		//	a single mapping for the URI extension.
		//
		if (!mdrec.pbMDData)
		{
			if (rgwchMDPathSiteRoot != pwszMDPathMM)
				pwszExt = gc_wsz_Star;
		}

		//	If we found a mime map and it is still not inherited then we have
		//	some more checking to do.  Yes, the mime map actually can be
		//	inherited at this point.  See below for why.
		//
		else if (!(mdrec.dwMDAttributes & METADATA_ISINHERITED))
		{
			//	Check whether we should apply a "*" mapping rather than
			//	the extension mapping that we ideally want.  The rules
			//	governing this decision are outlined in ScApplyStarExt().
			//
			sc = ScApplyStarExt(reinterpret_cast<LPWSTR>(mdrec.pbMDData),
								pwszContentType,
								&pwszExt);
			if (FAILED(sc))
			{
				DebugTrace("ScAddExtMimeMap() - ScApplyStarExt() failed 0x%08lX\n", sc);
				goto ret;
			}
		}

		//	We found a mime map, but for some oddball reason it now appears to be
		//	inherited!  This can happen if the admin manages to change things
		//	between the time we check the cache and when we open pszMDPathMimeMap
		//	for writing.  This should be a sufficiently rare case that falling back
		//	to a "*" mapping here isn't so bad.
		//
		else
		{
			Assert(mdrec.pbMDData);
			Assert(mdrec.dwMDAttributes & METADATA_ISINHERITED);
			pwszExt = gc_wsz_Star;
		}

		//	Ok, we're all set.  We have the extension ("*" or .somethingorother).
		//	We have the content type.  We have the existing mappings (if any).
		//	Add in the new mapping.
		//
		//	Note: if we are adding a "*" mapping, we always want to add it
		//	at the level of the URI.  But since the metabase handle we have
		//	open is at some level above the URI, the path we pass to ScAddMimeMap()
		//	below must be relative to the path used to open the handle.
		//	Easy enough.  That path is just what's left of the URI path
		//	beyond where we found (or would have created) the non-inherited
		//	mime map.
		//
		sc = ScAddMimeMap(mdoh,
						  (L'*' == *pwszExt) ?
							  pwszMDPathURI.get() + cchPathMimeMap :
							  NULL,
						  reinterpret_cast<LPWSTR>(mdrec.pbMDData),
						  mdrec.dwMDDataLen / sizeof(WCHAR),
						  pwszExt,
						  pwszContentType);
		if (FAILED(sc))
		{
			DebugTrace("ScAddExtMimeMap() - ScAddMimeMap(pszExt) failed 0x%08lX\n", sc);
			goto ret;
		}
	}

ret:

	return sc;
}

//	------------------------------------------------------------------------
//
//	ScSetContentType()
//
SCODE
ScSetContentType( const IEcb& ecb,
				  LPCWSTR pwszURI,
				  LPCWSTR pwszContentTypeWanted )
{
	BOOL fIsGlobalMapping = FALSE;
	CStackBuffer<WCHAR> pwszContentTypeCur;
	SCODE sc = S_OK;
	UINT cchContentTypeCur;

	//	Check what the content type would be if we didn't do anything.
	//	If it's what we want, then we're done.  No need to open the metabase
	//	for anything!
	//
	cchContentTypeCur = pwszContentTypeCur.celems();
	if ( !FGetContentTypeFromURI( ecb,
								  pwszURI,
								  pwszContentTypeCur.get(),
								  &cchContentTypeCur,
								  &fIsGlobalMapping ) )
	{
		if (!pwszContentTypeCur.resize(cchContentTypeCur * sizeof(WCHAR)))
		{
			sc = E_OUTOFMEMORY;
			goto ret;
		}
		if ( !FGetContentTypeFromURI( ecb,
									  pwszURI,
									  pwszContentTypeCur.get(),
									  &cchContentTypeCur,
									  &fIsGlobalMapping))
		{
			//
			//	If the size of the content type keeps changing on us
			//	then the server is too busy.  Give up.
			//
			sc = ERROR_PATH_BUSY;
			DebugTrace("ScSetContentType() - FGetContentTypeFromURI() failed 0x%08lX\n", sc);
			goto ret;
		}
	}

	//
	//	If the content type is already what we want then don't change a thing.
	//
	if ( !_wcsicmp( pwszContentTypeWanted, pwszContentTypeCur.get()))
	{
		sc = S_OK;
		goto ret;
	}

	//
	//	The current content type isn't what we want so we will have to set
	//	something in the metabase.  If the mapping for this extension came
	//	from one of the global maps, then always override the mapping by
	//	setting a "*" mapping at the URI level.  If the mapping was not
	//	a global one then what we do gets very complicated due to Raid NT5:292139....
	//
	if (fIsGlobalMapping)
	{
		sc = ScSetStarMimeMap(ecb,
							  pwszURI,
							  pwszContentTypeWanted);
		if (FAILED(sc))
		{
			DebugTrace("ScSetContentType() - ScAddExtMimeMap() failed 0x%08lX\n", sc);
			goto ret;
		}
	}
	else
	{
		sc = ScAddExtMimeMap(ecb,
							 pwszURI,
							 pwszContentTypeWanted);
		if (FAILED(sc))
		{
			DebugTrace("ScSetContentType() - ScAddExtMimeMap() failed 0x%08lX\n", sc);
			goto ret;
		}
	}

ret:

	return sc;
}

/*
 *	ScCanAcceptContent()
 *
 *	Purpose:
 *
 *		Check if the given content type is acceptable
 *
 *	Parameters:
 *
 *		pwszAccepts	[in]	the Accept header;
 *		pwszApp		[in]	the application part of the content type
 *		pwszType	[in]	the sub type of the content type
 *
 *	Returns:
 *
 *		S_OK	- if the request accepts the content type, no wildcard matching
 *		S_FALSE - if the request accepts the content type, wildcard matching
 *		E_DAV_RESPONSE_TYPE_UNACCEPTED - if the response type was unaccepted
 */
SCODE __fastcall
ScCanAcceptContent (LPCWSTR pwszAccepts, LPWSTR pwszApp, LPWSTR pwszType)
{
	SCODE sc = E_DAV_RESPONSE_TYPE_UNACCEPTED;
	HDRITER_W hit(pwszAccepts);
	LPWSTR pwsz;
	LPCWSTR pwszAppType;
	LPCWSTR pwszSubType;

	//	Rip through the entries in the header...
	//
	while (NULL != (pwszAppType = hit.PszNext()))
	{
		pwsz = const_cast<LPWSTR>(pwszAppType);

		//	Search for the end of the application type
		//	'/' is the sub type separator, and ';' starts the parameters
		//
		while (	*pwsz &&
				(L'/' != *pwsz) &&
				(L';' != *pwsz) )
			pwsz++;

		if (L'/' == *pwsz)
		{
			//	Make pwszAppType point to the application type ...
			//
			*pwsz++ = L'\0';

			//	... and pszSubType point to the subtype
			//
			pwszSubType = pwsz;
			while (*pwsz && (L';' != *pwsz))
				pwsz++;

			*pwsz = L'\0';
		}
		else
		{
			//	There's not sub type.
			//
			*pwsz = L'\0';

			// 	point pszSubType to a empty string, instead of setting it to NULL
			//
			pwszSubType = pwsz;
		}

		//	Here're the rules:
		//
		//	A application type * match any type (including */xxx)
		//	type/* match all subtypes of that app type
		//	type/subtype looks for exact match
		//
		if (!wcscmp (pwszAppType, gc_wsz_Star))
		{
			//	This is a wild-card match.  So, S_FALSE is used
			//	to distinguish this from an exact match.
			//
			sc = S_FALSE;
		}
		else if (!wcscmp (pwszAppType, pwszApp))
		{
			if (!wcscmp (pwszSubType, gc_wsz_Star))
			{
				//	Again, a wild-card matching will result in
				//	an S_FALSE return.
				//
				sc = S_FALSE;
			}
			else if (!wcscmp (pwszSubType, pwszType))
			{
				//	Exact matches return S_OK
				//
				sc = S_OK;
			}
		}

		//	If we had any sort of a match by this point, we are
		//	pretty much done.
		//
		if (!FAILED (sc))
			break;
	}

	return sc;
}

/*
 *	ScIsAcceptable()
 *
 *	Purpose:
 *
 *		Checks if a given content type is acceptable for a given request.
 *
 *	Parameters:
 *
 *		pmu			[in]  pointer to the IMethUtil object
 *		pwszContent	[in]  content type to ask about
 *
 *	Returns:
 *
 *		S_OK	- if the request accepts the content type and the header existed
 *		S_FALSE - if the request accepts the content type and the header did not
 *				  exist or was blank, or any wildcard matching occured
 *		E_DAV_RESPONSE_TYPE_UNACCEPTED - if the response type was unaccepted
 *		E_OUTOFMEMORY - if memory allocation failure occurs
 *		
 */
SCODE
ScIsAcceptable (IMethUtil * pmu, LPCWSTR pwszContent)
{
	SCODE sc = S_OK;
	LPCWSTR pwszAccept = NULL;
	CStackBuffer<WCHAR> pwsz;
	UINT cch;
	LPWSTR pwch;

	Assert( pmu );
	Assert( pwszContent );

	//	If the accept header is NULL or empty, then we will gladly
	//	accept any type of file. Do not apply URL conversion rules
	//	for this header.
	//
	pwszAccept = pmu->LpwszGetRequestHeader (gc_szAccept, FALSE);
	if (!pwszAccept || (0 == wcslen(pwszAccept)))
	{
		sc = S_FALSE;
		goto ret;
	}

	//	Make a local copy of the content-type seeing
	//	that we are going to munge while processing
	//
	cch = static_cast<UINT>(wcslen(pwszContent) + 1);
	if (!pwsz.resize(cch * sizeof(WCHAR)))
	{
		sc = E_OUTOFMEMORY;
		DebugTrace("ScIsAcceptable() - Failed to allocate memory 0x%08lX\n", sc);
		goto ret;
	}
	memcpy(pwsz.get(), pwszContent, cch * sizeof(WCHAR));

	//	Split the content type into its two components
	//
	for (pwch = pwsz.get(); *pwch && (L'/' != *pwch); pwch++)
		;

	//	If there was app/type pair, we want to skip
	//	the '/' character.  Otherwise, lets just see
	//	What we get.
	//
	if (*pwch != 0)
		*pwch++ = 0;

	//	At this point, rgch refers to the application
	//	portion of the the content type.  pch refers
	//	to the subtype.  Do the search!
	//
	sc = ScCanAcceptContent (pwszAccept, pwsz.get(), pwch);

ret:

	return sc;
}

/*
 *	ScIsContentType()
 *
 *	Purpose:
 *
 *		Check if the specified content type is provide by the client
 *		SCODE is returned as we need to differentiate unexpected
 *		content type and no content type case.
 *
 *	Parameters:
 *
 *		pmu				[in]	pointer to the IMethUtil object
 *		pszType			[in]	the content type expected
 *		pszTypeAnother	[in]	optional, another valid content type
 *
 *	Returns:
 *
 *		S_OK	- if the content type existed, and was one tat we expected
 *		E_DAV_MISSING_CONTENT_TYPE - if the request did not have the content
 *									 type header
 *		E_DAV_UNKNOWN_CONTENT - content type existed but did not match expectation
 *		E_OUTOFMEMORY - if memory allocation failure occurs
 */
SCODE
ScIsContentType (IMethUtil * pmu, LPCWSTR pwszType, LPCWSTR pwszTypeAnother)
{
	SCODE sc = S_OK;
	const WCHAR wchDelimitSet[] = { L';', L'\t', L' ', L'\0' };
	LPCWSTR pwszCntType = NULL;
	CStackBuffer<WCHAR> pwszTemp;
	UINT cchTemp;

	//	Make sure none is passing in null
	//
	Assert(pmu);
	Assert(pwszType);

	//	Get content type. Do not apply URL conversion rules to this header.
	//
	pwszCntType = pmu->LpwszGetRequestHeader (gc_szContent_Type, FALSE);

	//	Error out if the content type does not exist
	//
	if (!pwszCntType)
	{
		sc = E_DAV_MISSING_CONTENT_TYPE;
		DebugTrace("ScIsContentType() - Content type header is missing 0x%08lX\n", sc);
		goto ret;
	}

	//	Find out the single content type in the header
	//
	cchTemp = static_cast<UINT>(wcscspn(pwszCntType, wchDelimitSet));

	//	At least we will find zero terminator. And if that is zero terminator then
	//	the entire string is the content type. Otherwise we copy it and zero terminate.
	//
	if (L'\0' != pwszCntType[cchTemp])
	{
		if (!pwszTemp.resize(CbSizeWsz(cchTemp)))
		{
			sc = E_OUTOFMEMORY;
			DebugTrace("ScIsContentType() - Failed to allocate memory 0x%08lX\n", sc);
			goto ret;
		}

		memcpy(pwszTemp.get(), pwszCntType, cchTemp * sizeof(WCHAR));
		pwszTemp[cchTemp] = L'\0';
		pwszCntType = pwszTemp.get();
	}

	//	Now pwszCntType points to the string consisting just of null terminated content type.
	//	Check if it is requested content type.
	//
	if (!_wcsicmp(pwszCntType, pwszType))
		goto ret;

	if (pwszTypeAnother)
	{
		if (!_wcsicmp(pwszCntType, pwszTypeAnother))
			goto ret;
	}
	sc = E_DAV_UNKNOWN_CONTENT;

ret:

	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\inc\ex\xemit.h ===
/*
 *	X E M I T . H
 *
 *	XML emitting
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_EX_XEMIT_H_
#define _EX_XEMIT_H_

#include <ex\sz.h>
#include <ex\autoptr.h>
#include <ex\cnvt.h>
#include <ex\nmspc.h>
#include <ex\xmldata.h>
#include <ex\atomcache.h>

typedef UINT XNT;

//	Interface IPreloadNamespaces
//
//	This is a virtual class which is to be implemented by everyone
//	that emits XML.
//
class CXMLEmitter;
class IPreloadNamespaces
{
	//	NOT IMPLEMENTED
	//
	IPreloadNamespaces& operator=( const IPreloadNamespaces& );

public:
	//	CREATORS
	//
	virtual ~IPreloadNamespaces() = 0 {};

	//	MANIPULATORS
	//
	virtual SCODE ScLoadNamespaces(CXMLEmitter* pxe) = 0;
};

//	class CXMLEmitter ---------------------------------------------------------
//
class CXNode;
class CEmitterNode;
class CXMLEmitter : public CEmitterNmspcCache
{
private:

	//	Ref' counting.
	//
	//	!!! Please note that this is NON-THREADSAFE !!!
	//
	//	CXNodes should be operated on a single thread at
	//	any given time.
	//
	LONG						m_cRef;

public:

	void AddRef()	{ m_cRef++; }
	void Release()	{ if (0 == --m_cRef) delete this; }

private:
	//	Other important bits
	//

	//	Because CXNode::ScDone (which references IXMLBody * m_pxb) is called in CXNode
	//	dtor, so we must have m_pxb defined befor m_pxnRoot, so that it will be destroyed
	//	after CXNode is destroyed
	//
	auto_ref_ptr<IXMLBody>		m_pxb;
	
	auto_ref_ptr<CXNode>		m_pxnRoot;
	IPreloadNamespaces*			m_pNmspcLoader;
	NmspcCache					m_cacheLocal;

	class NmspcEmittingOp : public CNmspcCache::NmspcCache::IOp
	{
	private:

		auto_ref_ptr<CXMLEmitter> m_emitter;
		auto_ref_ptr<CXNode>	  m_pxnParent;

		//	NOT IMPLEMENTED
		//
		NmspcEmittingOp( const NmspcEmittingOp& );
		NmspcEmittingOp& operator=( const NmspcEmittingOp& );

	public:

		NmspcEmittingOp (CXMLEmitter * pemitter,
						 CXNode * pxnParent)
				:m_emitter (pemitter),
				 m_pxnParent (pxnParent)
		{
		}

		BOOL operator()( const CRCWszN&,
						 const auto_ref_ptr<CNmspc>& nmspc );
	};

	//	non-implemented
	//
	CXMLEmitter(const CXMLEmitter& p);
	CXMLEmitter& operator=(const CXMLEmitter& p);

public:

	~CXMLEmitter() 
	{
		// According to standard C++, There's no garantee on the order of member
		// being deleted. so delete explicitly.
		// 
		m_pxnRoot.clear();
		m_pxb.clear();
	}
	CXMLEmitter(IXMLBody * pxb, IPreloadNamespaces * pNmspcLoader = NULL)
			: m_cRef(1),
			  m_pxb(pxb),
			  m_pNmspcLoader(pNmspcLoader)
	{
		INIT_TRACE(Xml);
	}

	CXNode* PxnRoot() { return m_pxnRoot.get(); }

	//	Find the appropriate namespace for the given name
	//
	SCODE ScFindNmspc (LPCWSTR, UINT, auto_ref_ptr<CNmspc>&);

	//	Attach the namespace to a given node
	//
	inline SCODE ScAddNmspc(const auto_ref_ptr<CNmspc>&, CXNode *);

	SCODE ScAddAttribute (
		/* [in] */ CXNode * pxn,
		/* [in] */ LPCWSTR pwszTag,
		/* [in] */ UINT cchTag,
		/* [in] */ LPCWSTR pwszValue,
		/* [in] */ UINT cchValue);

	SCODE ScNewNode (
		/* [in] */ XNT xnt,
		/* [in] */ LPCWSTR pwszTag,
		/* [in] */ CXNode* pxnParent,
		/* [out] */ auto_ref_ptr<CXNode>& pxnOut);

	//	Create a root node for this document
	//	including prologue.
	//
	SCODE ScSetRoot (LPCWSTR);

	//	Create a root node with NO prologue, this node can be
	//	used to build XML piece.
	//
	//	This function should not be used directly in IIS side. it may
	//	be used directly in store side to build XML chunks
	//
	SCODE ScNewRootNode (LPCWSTR);
	SCODE ScPreloadNamespace (LPCWSTR pwszTag);
	SCODE ScPreloadLocalNamespace (CXNode * pxn, LPCWSTR pwszTag);
	VOID DoneWithLocalNamespace ()
	{
		//	Reuse the namespace alises
		//
		//$	NOTE: we can do this by simply deducting the the number of aliases
		//$	NOTE: in the local cache. because all local aliases are added
		//$	NOTE: after root level aliases is added. so this way do cleanup
		//$	NOTE: only those aliases taken the by the local cache.
		//$	NOTE: Note that this is based on the fact that at any time, we
		//$	NOTE: we have only one <response> node under contruction
		//
		AdjustAliasNumber (0 - m_cacheLocal.CItems());

		//	Cleanup all the entries in the local cache
		//
		m_cacheLocal.Clear();
	}

	VOID Done()
	{
		//	Close the root node
		//
		m_pxnRoot.clear();

		//	Emit the body part;
		//
		m_pxb->Done();
	}
};

//	class CXNode --------------------------------------------------------------
//
class CXNode
{
private:

	//	Ref' counting.
	//
	//	!!! Please note that this is NON-THREADSAFE !!!
	//
	//	CXNodes should be operated on a single thread at
	//	any given time.
	//
	LONG						m_cRef;

public:

	void AddRef()				{ m_cRef++; }
	void Release()				{ if (0 == --m_cRef) delete this; }

private:

	//	Node type
	//
	const XNT					m_xnt;

	//	The body part manager
	//
	IXMLBody *		            m_pxb;


	//	The namespace that applies to this node
	//
	auto_ref_ptr<CNmspc>		m_pns;

	//  The escaped property tag of the node.
	//
	auto_heap_ptr<WCHAR>		m_pwszTagEscaped;
	UINT						m_cchTagEscaped;
	
	//  Whether or not the propertyname has an empty namespace (no namespace).
	//
	BOOL						m_fHasEmptyNamespace;
	
	//	If an open node. i.e. <tag>, not <tag/>, Used for element node only
	//
	UINT						m_fNodeOpen;

	//	Whether this node is done emitting
	//
	BOOL						m_fDone;

	//	The CXMLEmitter from which we persist the pilot namespace
	//
	CXMLEmitter *				m_pmsr;

	//	Emitting --------------------------------------------------------------
	//
	SCODE ScAddUnicodeResponseBytes (UINT cch, LPCWSTR pwsz);
	SCODE ScAddEscapedValueBytes (UINT cch, LPCSTR psz);
	SCODE ScAddEscapedAttributeBytes (UINT cch, LPCSTR psz);
	SCODE ScWriteTagName ();

	//	non-implemented
	//
	CXNode(const CXNode& p);
	CXNode& operator=(const CXNode& p);

public:

	CXNode(XNT xnt, IXMLBody* pxb) :
			m_cRef(1),
			m_fDone(FALSE),
			m_pmsr(NULL),
			m_xnt(xnt),
			m_fNodeOpen(FALSE),
			m_cchTagEscaped(0),
			m_pxb(pxb),
			m_fHasEmptyNamespace(FALSE)
	{
	}

	~CXNode()
	{
		if (!m_fDone)
		{
			//	Close the node
			//
			//$REVIEW: ScDone() could only fail for E_OUTMEMORY. Yes, we cannot
			//$REVIEW: return the failure from dtor. but how much better can be done
			//$REVIEW: when run out of memory?
			//$REVIEW: This does help to relievate the dependence on client to
			//$REVIEW: call ScDone correctly. (Of course, they still need to declare
			//$REVIEW: the nodes in correct order
			//
			(void)ScDone();
		}
	}

	//	CXNode types ----------------------------------------------------------
	//
	typedef enum {

		XN_ELEMENT = 0,
		XN_ATTRIBUTE,
		XN_NAMESPACE
	};

	//	Construction ----------------------------------------------------------
	//
	//	Set the name of the node
	//
	SCODE ScSetTag (CXMLEmitter* pmsr, UINT cch, LPCWSTR pwszTag);

	//	Sets the value of a node.
	//
	//	IMPORTANT: setting the value of a node appends the value of the node
	//	to the child.
	//
	SCODE ScSetValue (LPCSTR pszValue, UINT cch);
	SCODE ScSetValue (LPCWSTR pwszValue, UINT cch);
	SCODE ScSetValue (LPCWSTR pwszValue)
	{
		return ScSetValue (pwszValue, static_cast<UINT>(wcslen(pwszValue)));
	}
	SCODE ScSetUTF8Value (LPCSTR pszValue, UINT cch);
	SCODE ScSetFormatedXML (LPCSTR pszValue, UINT cchValue);
	SCODE ScSetFormatedXML (LPCWSTR pwszValue, UINT cchValue);

	//	Adds an child to the this node
	//
	SCODE ScGetChildNode (XNT xntType, CXNode ** ppxnChild);
	SCODE ScDone();
};

//	class CEmitterNode --------------------------------------------------------
//
class CEmitterNode
{
	auto_ref_ptr<CXMLEmitter>		m_emitter;
	auto_ref_ptr<CXNode>			m_pxn;

	//	non-implemented
	//
	CEmitterNode(const CEmitterNode& p);
	CEmitterNode& operator=(const CEmitterNode& p);

public:

	CEmitterNode ()
	{
	}

	//	Pass back a reference to the Emitter
	//
	CXMLEmitter* PEmitter() const { return m_emitter.get(); }
	VOID SetEmitter (CXMLEmitter* pmsr) { m_emitter = pmsr; }

	//	Pass back a reference to the CXNode
	//
	CXNode*	Pxn() const { return m_pxn.get(); }
	VOID SetPxn (CXNode* pxn) { m_pxn = pxn; }

	//	New node construction -------------------------------------------------
	//
	SCODE ScConstructNode (CXMLEmitter& emitter,
						   CXNode * pxnParent,
						   LPCWSTR pwszTag,
						   LPCWSTR pwszValue = NULL,
						   LPCWSTR pwszType = NULL);

	//	Add a child node to this node.  This API is the heart of the emitter
	//	processing and all other AddXXX() methods are written in terms of
	//	this method.
	//
	SCODE ScAddNode (LPCWSTR pwszTag,
					 CEmitterNode& en,
					 LPCWSTR pwszValue = NULL,
					 LPCWSTR pwszType = NULL);

	//	Non-wide char nodes
	//
	SCODE ScAddMultiByteNode (LPCWSTR pwszTag,
							  CEmitterNode& en,
							  LPCSTR pszValue,
							  LPCWSTR pwszType = NULL);
	SCODE ScAddUTF8Node (LPCWSTR pwszTag,
						 CEmitterNode& en,
						 LPCSTR pszValue,
						 LPCWSTR pwszType = NULL);


	//	"date.iso8601"
	//
	SCODE ScAddDateNode (LPCWSTR pwszTag,
						 FILETIME * pft,
						 CEmitterNode& en);
	//	"int"
	//
	SCODE ScAddInt64Node (LPCWSTR pwszTag,
						  LARGE_INTEGER * pli,
						  CEmitterNode& en);
	//	"boolean"
	//
	SCODE ScAddBoolNode (LPCWSTR pwszTag,
						 BOOL f,
						 CEmitterNode& en);
	//	"bin.base64"
	//
	SCODE ScAddBase64Node (LPCWSTR pwszTag,
						   ULONG cb,
						   LPVOID pv,
						   CEmitterNode& en,
						   BOOL fSupressTypeAttr = FALSE,
						   //	For WebFolders, we need to emit zero length
						   //	binary properties as bin.hex instead of bin.base64.
						   //
						   BOOL fUseBinHexIfNoValue = FALSE);

	//	Multi-Status ----------------------------------------------------------
	//
	SCODE ScDone ()
	{
		SCODE sc = S_OK;
		if (m_pxn.get())
		{
			sc = m_pxn->ScDone();
			m_pxn.clear();
		}
		m_emitter.clear();
		return sc;
	}
};

//	String constants ----------------------------------------------------------
//
DEC_CONST CHAR gc_chAmp				= '&';
DEC_CONST CHAR gc_chBang			= '!';
DEC_CONST CHAR gc_chColon			= ':';
DEC_CONST CHAR gc_chDash			= '-';
DEC_CONST CHAR gc_chEquals			= '=';
DEC_CONST CHAR gc_chForwardSlash	= '/';
DEC_CONST CHAR gc_chBackSlash		= '\\';
DEC_CONST CHAR gc_chGreaterThan		= '>';
DEC_CONST CHAR gc_chLessThan		= '<';
DEC_CONST CHAR gc_chApos			= '\'';
DEC_CONST CHAR gc_chQuestionMark	= '?';
DEC_CONST CHAR gc_chQuote			= '"';
DEC_CONST CHAR gc_chSpace			= ' ';
DEC_CONST CHAR gc_szAmp[]			= "&amp;";
DEC_CONST CHAR gc_szGreaterThan[]	= "&gt;";
DEC_CONST CHAR gc_szLessThan[]		= "&lt;";
DEC_CONST CHAR gc_szApos[]			= "&apos;";
DEC_CONST CHAR gc_szQuote[]			= "&quot;";

DEC_CONST WCHAR gc_wszAmp[]			= L"&amp;";
DEC_CONST WCHAR gc_wszGreaterThan[]	= L"&gt;";
DEC_CONST WCHAR gc_wszLessThan[]	= L"&lt;";
DEC_CONST WCHAR gc_wszApos[]		= L"&apos;";
DEC_CONST WCHAR gc_wszQuote[]		= L"&quot;";

//	XML property emitting helpers ---------------------------------------------
//
SCODE __fastcall
ScEmitPropToXml (
	/* [in] */ CEmitterNode* penProp,
	/* [in] */ const BOOL fFilterValues,
	/* [in] */ const USHORT usPt,
	/* [in] */ const LPCWSTR wszTag,
	/* [in] */ const BYTE* pb);

SCODE __fastcall
ScEmitStringPropToXml (
	/* [in] */ CEmitterNode* penProp,
	/* [in] */ const BOOL fFilterValues,
	/* [in] */ const USHORT usPt,
	/* [in] */ const LPCWSTR wszTag,
	/* [in] */ const ULONG cpid,
	/* [in] */ const UINT cch,
	/* [in] */ const VOID* pv);

SCODE __fastcall
ScEmitBinaryPropToXml (
	/* [in] */ CEmitterNode* penProp,
	/* [in] */ const BOOL fFilterValues,
	/* [in] */ const USHORT usPt,
	/* [in] */ const LPCWSTR wszTag,
	/* [in] */ const UINT cb,
	/* [in] */ const BYTE* pb);

SCODE __fastcall
ScEmitMultiValuedAtomicToXml (
	/* [in] */ CEmitterNode* penProp,
	/* [in] */ const BOOL fFilterValues,
	/* [in] */ const USHORT usPt,
	/* [in] */ const UINT cbItem,
	/* [in] */ const LPCWSTR wszTag,
	/* [in] */ const ULONG cValues,
	/* [in] */ const BYTE* pb);

SCODE __fastcall
ScEmitMutliValuedStringToXml (
	/* [in] */ CEmitterNode* penProp,
	/* [in] */ const BOOL fFilterValues,
	/* [in] */ const USHORT usPt,
	/* [in] */ const LPCWSTR wszTag,
	/* [in] */ const ULONG cpid,
	/* [in] */ const UINT cchMax,
	/* [in] */ const LPVOID* pv);

SCODE __fastcall
ScEmitMutliValuedBinaryToXml (
	/* [in] */ CEmitterNode* penProp,
	/* [in] */ const BOOL fFilterValues,
	/* [in] */ const USHORT usPt,
	/* [in] */ const LPCWSTR wszTag,
	/* [in] */ const BYTE** ppb,
	/* [in] */ const DWORD* pcb,
	/* [in] */ const DWORD cbMax);

#endif	// _EX_XEMIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\content.h ===
#ifndef	_CONTENT_H_
#define _CONTENT_H_

/*
 *	C O N T E N T . H
 *
 *	DAV Content-Type mappings
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

class IContentTypeMap : public CMTRefCounted
{
	//	NOT IMPLEMENTED
	//
	IContentTypeMap(const IContentTypeMap&);
	IContentTypeMap& operator=(IContentTypeMap&);

protected:
	//	CREATORS
	//	Only create this object through it's descendents!
	//
	IContentTypeMap()
	{
		m_cRef = 1; //$HACK Until we have 1-based refcounting
	};

public:
	//	ACCESSORS
	//
	virtual LPCWSTR PwszContentType( LPCWSTR pwszURI ) const = 0;
	virtual BOOL FIsInherited() const = 0;
};

BOOL FInitRegMimeMap();
VOID DeinitRegMimeMap();

IContentTypeMap *
NewContentTypeMap( LPWSTR pwszContentTypeMappings,
				   BOOL fMappingsInherited );

#endif	// _CONTENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\custerr.h ===
#ifndef _CUSTERR_H_
#define _CUSTERR_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	CUSTERR.H
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

class ICustomErrorMap : public CMTRefCounted
{
	//	NOT IMPLEMENTED
	//
	ICustomErrorMap(const ICustomErrorMap&);
	ICustomErrorMap& operator=(ICustomErrorMap&);

protected:
	//	CREATORS
	//	Only create this object through it's descendents!
	//
	ICustomErrorMap()
	{
		m_cRef = 1; //$HACK Until we have 1-based refcounting
	};

public:
	virtual BOOL FDoResponse( IResponse& response, const IEcb&  ) const = 0;
};

ICustomErrorMap *
NewCustomErrorMap( LPWSTR pwszCustomErrorMappings );

class IEcb;
class IResponse;

BOOL
FSetCustomErrorResponse( const IEcb& ecb, IResponse& response );

#endif // _CUSTERR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\header.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	HEADER.CPP
//
//		HTTP header cache implementation.
//
//
//	Copyright 1997 Microsoft Corporation, All Rights Reserved
//

#include "_davprs.h"

#include <buffer.h>
#include "header.h"
#include <tchar.h>


//	========================================================================
//
//	CLASS CHeaderCache
//



//	------------------------------------------------------------------------
//
//	CHeaderCacheForResponse::DumpData()
//	CHeaderCacheForResponse::CEmit::operator()
//
//		Dump headers to a string buffer.
//
void CHeaderCacheForResponse::DumpData( StringBuffer<CHAR>& bufData ) const
{
	CEmit emit(bufData);

	//	Iterate over all cache items, emitting each to our buffer
	//	The cache controls the iteration here; we just provide
	//	the operation to apply to each iterated item.
	//
	m_cache.ForEach( emit );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\evtlog.h ===
#ifndef _EVTLOG_H_
#define _EVTLOG_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	EVTLOG.H
//
//		Header for event log cache class.
//		This cache is meant to serve as a map. indexes on the event key.
//		we really don't care the concrete value, but only it is NULL or not
//
//	Copyright 1997 Microsoft Corporation, All Rights Reserved
//

//	========================================================================
//
//	CLASS CEventLogCache
//
#include "gencache.h"
class CEventLogCache
{
	typedef CCache<CRCSzi, LPCSTR> CHdrCache;

	// String data storage area.
	//
	ChainedStringBuffer<char>	m_sb;

	// Cache of header values, keyed by CRC'd name
	//
	CHdrCache					m_cache;

	//	NOT IMPLEMENTED
	//
	CEventLogCache& operator=( const CEventLogCache& );
	CEventLogCache( const CEventLogCache& );

public:
	//	CREATORS
	//
	CEventLogCache()
	{
		//	If this fails, our allocators will throw for us.
		(void)m_cache.FInit();
	}

	//	ACCESSORS
	//
	BOOL FExist( LPCSTR lpszName );

	//	MANIPULATORS
	void AddKey (LPCSTR lpszName);
};

#endif // !_EVTLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\custerr.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	CUSTERR.CPP
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include "_davprs.h"
#include "custerr.h"
#include "content.h"


//	========================================================================
//
//	CLASS IError
//
//	Interface class for error response handler classes.  An error response
//	handler class implements one virtual method, DoResponse(), which
//	handles the error response.
//
class IError : public CMTRefCounted
{
	//	NOT IMPLEMENTED
	//
	IError& operator=(const IError&);
	IError( const IError& );

protected:
	IError() {}

public:
	//	CREATORS
	//
	virtual ~IError() = 0;

	//	ACCESSORS
	//
	virtual void DoResponse( IResponse& response , const IEcb& ecb ) const = 0;

};

//	------------------------------------------------------------------------
//
//	IError::~IError()
//
//		Out of line virtual destructor necessary for proper deletion
//		of objects of derived classes via this class
//
IError::~IError() {}

//	------------------------------------------------------------------------
//
//	BOOL AddResponseBodyFromFile( IResponse& response, LPCSTR lpszFilePath )
//
//	Utility function to add the file's contents to the response's body
//
static BOOL AddResponseBodyFromFile( IResponse& response, LPCWSTR pwszFilePath )
{
	BOOL fReturn = FALSE;
	auto_ref_handle	hf;

	//
	//	Add the file to the response body
	//
	if ( hf.FCreate(
			CreateFileW( pwszFilePath,
						 GENERIC_READ,
						 FILE_SHARE_READ | FILE_SHARE_WRITE,
						 NULL,
						 OPEN_EXISTING,
						 FILE_ATTRIBUTE_NORMAL |
						 FILE_FLAG_SEQUENTIAL_SCAN |
						 FILE_FLAG_OVERLAPPED,
						 NULL )) )
	{
		response.AddBodyFile(hf);

		//	Set the response content type to an appropriate value based
		//	on the file's extension.
		//
		UINT cchContentType = 60;
		CStackBuffer<WCHAR> pwszContentType(cchContentType * sizeof(WCHAR));
		if (!pwszContentType.get())
			return FALSE;

		if ( !FGetContentTypeFromPath( *response.GetEcb(),
									   pwszFilePath,
									   pwszContentType.get(),
									   &cchContentType))
		{
			if (!pwszContentType.resize(cchContentType * sizeof(WCHAR)))
				return FALSE;

			if ( !FGetContentTypeFromPath( *response.GetEcb(),
										   pwszFilePath,
										   pwszContentType.get(),
										   &cchContentType))
			{
				//
				//	If we can't get a reasonable value from the mime map
				//	then use a reasonable default: application/octet-stream
				//
				Assert (pwszContentType.celems() >
						CchConstString(gc_wszAppl_Octet_Stream));

				wcscpy (pwszContentType.get(), gc_wszAppl_Octet_Stream);
			}
		}
		response.SetHeader( gc_szContent_Type, pwszContentType.get() );
		fReturn = TRUE;
	}

	return fReturn;
}

//	========================================================================
//
//	CLASS CURLError
//
//	URL error response handler class.  Handles an error response by
//	forwarding to another URL.
//
class CURLError : public IError
{
	//
	//	The URL
	//
	LPCWSTR m_pwszURL;

	//	NOT IMPLEMENTED
	//
	CURLError& operator=(const CURLError&);
	CURLError(const CURLError&);

public:
	//	CREATORS
	//
	CURLError( LPCWSTR pwszURL ) : m_pwszURL(pwszURL) {}

	//	ACCESSORS
	//
	void DoResponse( IResponse& response, const IEcb& ecb ) const;
};

//	------------------------------------------------------------------------
//
//	CURLError::DoResponse()
//
//	Handle the error response by forwarding to the configured URL.
//
void
CURLError::DoResponse( IResponse& response, const IEcb& ecb ) const
{
	SCODE sc = S_OK;

	//	The first boolean flag is for keeping the query string
	//	and the second flag indicates that we are doing CustomError
	//	processing.
	//
	sc = response.ScForward( m_pwszURL, TRUE , TRUE );
	if (FAILED(sc))
	{
		//	The child execute failed - one reason is that the URL is a simple
		//	file URL. Try mapping the URL to file..
		//
		if ( HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) == sc )
		{
			HSE_UNICODE_URL_MAPEX_INFO mi;

			//	Obtain the file path and send the file in the body
			//
			sc = ecb.ScReqMapUrlToPathEx(m_pwszURL, &mi);
			if (FAILED(sc))
			{
				//	We ran into a case where the CE URL resource itself is not
				//	found. When we are ready to send response, this will mean
				//	an empty body. Appropriate body will be default generated there.
				//
				DebugTrace("CURLError::DoResponse() - IEcb::ScSSFReqMapUrlToPathEx() failed 0x%08lX\n", sc);
			}
			else
			{
				AddResponseBodyFromFile( response, mi.lpszPath );
			}
		}
	}

	return;
}

//	========================================================================
//
//	CLASS CFileError
//
//	File error response handler class.  Handles an error response by
//	adding a file containing response body content to the response body.
//
class CFileError : public IError
{
	//
	//	The filename
	//
	LPCWSTR m_pwszFileName;

	//	NOT IMPLEMENTED
	//
	CFileError& operator=(const CFileError&);
	CFileError(const CFileError&);

public:
	//	CREATORS
	//
	CFileError( LPCWSTR pwszFileName ) : m_pwszFileName(pwszFileName) {}


	//	ACCESSORS
	//
	void DoResponse( IResponse& response, const IEcb& ) const;
};

//	------------------------------------------------------------------------
//
//	CFileError::DoResponse()
//
//	Handle the error response by setting the response body content
//	to the contents of the configured file.
//
void
CFileError::DoResponse( IResponse& response, const IEcb& ) const
{
	AddResponseBodyFromFile( response, m_pwszFileName );
}


//	========================================================================
//	class CEKey
//		Key class for custom error keys that can be compared with ==.
//
#pragma warning(disable:4201) // Nameless struct/union
class CEKey
{
private:
	union
	{
		DWORD m_dw;
		struct
		{
			USHORT m_iStatusCode;
			USHORT m_iSubError;
		};
	};

public:
	CEKey (USHORT iStatusCode,
		   USHORT iSubError) :
		m_iStatusCode(iStatusCode),
		m_iSubError(iSubError)
	{
	}

	DWORD Dw() const
	{
		return m_dw;
	}

	int CEKey::hash (const int rhs) const
	{
		return (m_dw % rhs);
	}

	bool CEKey::isequal (const CEKey& rhs) const
	{
		return (rhs.m_dw == m_dw);
	}
};
#pragma warning(default:4201) // Nameless struct/union

//	========================================================================
//
//	CLASS CCustomErrorMap
//
//	Custom error list class.  Each instance of this class encapsulates a
//	set of custom error mappings.  Each mapping maps from a status code
//	and "suberror" (as defined by IIS) to an error response handling object.
//
//	The list is configured, via FInit(), from a set of null-terminated
//	string of the following form:
//
//		"<error>,<suberror|*>,<"FILE"|"URL">,<filename|URL>"
//
//	For example, the string "404,*,FILE,C:\WINNT\help\common\404b.htm" would
//	translate to a mapping from "404,*" to a CFileError(C:\WINNT\htlp\common\404b.htm)
//	object.
//
class CCustomErrorMap : public ICustomErrorMap
{
	//
	//	A cache of status-code-plus-sub-error strings to
	//	error object mappings
	//
	CCache<CEKey, auto_ref_ptr<IError> > m_cache;

	//	NOT IMPLEMENTED
	//
	CCustomErrorMap& operator=(const CCustomErrorMap&);
	CCustomErrorMap(const CCustomErrorMap&);

public:
	//	CREATORS
	//
	CCustomErrorMap()
	{
		//	If this fails, our allocators will throw for us.
		(void)m_cache.FInit();

		//
		//$COM refcounting
		//
		m_cRef = 1;
	}

	//	MANIPULATORS
	//
	BOOL FInit( LPWSTR pwszCustomErrorMappings );

	//	ACCESSORS
	//
	BOOL FDoResponse( IResponse& response, const IEcb& ecb ) const;
};

//	------------------------------------------------------------------------
//
//	CCustomErrorMap::FInit()
//
//	Initialize a custom error map from a sequence of comma-delimited mapping
//	strings.
//
//	Disable warnings about conversion from INT to USHORT losing data for
//	this function only.  The conversion is for the status code and suberror
//	which we Assert() are in the range of a USHORT.
//
BOOL
CCustomErrorMap::FInit( LPWSTR pwszCustomErrorMappings )
{
	Assert( pwszCustomErrorMappings != NULL );


	//
	//	Parse through the error list and build up the cache.
	//	(Code mostly copied from IIS' W3_METADATA::BuildCustomErrorTable())
	//
	//	Each mapping is a string of the form:
	//
	//		"<error>,<suberror|*>,<"FILE"|"URL">,<filename|URL>"
	//
	//	Note that if any of the mappings is invalid we fail the whole call.
	//	This is consistent with IIS' behavior.
	//
	for ( LPWSTR pwszMapping = pwszCustomErrorMappings; *pwszMapping; )
	{
		enum {
			ISZ_CE_STATCODE = 0,
			ISZ_CE_SUBERROR,
			ISZ_CE_TYPE,
			ISZ_CE_PATH,
			ISZ_CE_URL = ISZ_CE_PATH, // alias
			CSZ_CE_FIELDS
		};

		LPWSTR rgpwsz[CSZ_CE_FIELDS];
		INT iStatusCode;
		INT iSubError = 0;

		auto_ref_ptr<IError> pError;
		UINT cchMapping;

		Assert( !IsBadWritePtr(pwszMapping, wcslen(pwszMapping) * sizeof(WCHAR)) );

		//
		//	Digest the metadata
		//
		if ( !FParseMDData( pwszMapping,
							rgpwsz,
							CSZ_CE_FIELDS,
							&cchMapping ) )
			return FALSE;

		//
		//	Verify that the first field is a valid status code
		//
		iStatusCode = _wtoi(rgpwsz[ISZ_CE_STATCODE]);
		if ( iStatusCode < 400 || iStatusCode > 599 )
			return FALSE;

		//
		//	Verify that the second field is a valid suberror.  A valid
		//	suberror is either a "*" or an integer.  Note: IIS'
		//	BuildCustomErrorTable() only checks whether the first
		//	character is a '*' so we do the same here.
		//
		if ( *rgpwsz[ISZ_CE_SUBERROR] != L'*' )
		{
			iSubError = _wtoi(rgpwsz[ISZ_CE_SUBERROR]);
			if ( iSubError < 0 || iSubError > _UI16_MAX )
				return FALSE;
		}

		//
		//	Verify that the third field is a valid type and
		//	create the appropriate (file or URL) error object.
		//
		if ( !_wcsicmp(rgpwsz[ISZ_CE_TYPE], L"FILE") )
		{
			pError = new CFileError(rgpwsz[ISZ_CE_PATH]);
		}
		else if ( !_wcsicmp(rgpwsz[ISZ_CE_TYPE], L"URL") )
		{
			pError = new CURLError(rgpwsz[ISZ_CE_URL]);
		}
		else
		{
			return FALSE;
		}

		//
		//	Add the error object to the cache, keyed by the error/suberror.
		//
		(void)m_cache.FSet( CEKey(static_cast<USHORT>(iStatusCode),
								  static_cast<USHORT>(iSubError)),
							pError );

		//
		//	Get the next mapping
		//
		pwszMapping += cchMapping;
	}

	return TRUE;
}

//	------------------------------------------------------------------------
//
//	CCustomErrorMap::FDoResponse()
//
//	Look for a custom error response mapping for the particular response
//	error status and, if one exists, apply it to the response.
//
//	Returns TRUE if an error mapping exists, FALSE if not.
//
BOOL
CCustomErrorMap::FDoResponse( IResponse& response, const IEcb& ecb ) const
{
	auto_ref_ptr<IError> pError;

	Assert( response.DwStatusCode() <= _UI16_MAX );
	Assert( response.DwSubError() <= _UI16_MAX );

	//
	//	Lookup the error/suberror pair in the cache
	//
	if ( m_cache.FFetch( CEKey(static_cast<USHORT>(response.DwStatusCode()),
							   static_cast<USHORT>(response.DwSubError())),
						 &pError ) )
	{
		pError->DoResponse( response, ecb );
		return TRUE;
	}

	return FALSE;
}


//	========================================================================
//
//	FREE FUNCTIONS
//

//	------------------------------------------------------------------------
//
//	FSetCustomErrorResponse()
//
BOOL
FSetCustomErrorResponse( const IEcb& ecb,
						 IResponse& response )
{
	const ICustomErrorMap * pCustomErrorMap;

	pCustomErrorMap = ecb.MetaData().GetCustomErrorMap();
	return pCustomErrorMap && pCustomErrorMap->FDoResponse(response, ecb);
}

//	------------------------------------------------------------------------
//
//	NewCustomErrorMap()
//
ICustomErrorMap *
NewCustomErrorMap( LPWSTR pwszCustomErrorMappings )
{
	auto_ref_ptr<CCustomErrorMap> pCustomErrorMap;

	pCustomErrorMap.take_ownership(new CCustomErrorMap());

	if ( pCustomErrorMap->FInit(pwszCustomErrorMappings) )
		return pCustomErrorMap.relinquish();

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\davcom.cpp ===
/*
 *	D A V C O M . C P P
 *
 *	Common routines used by both DAVFS and DAVOWS.
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davprs.h"
#include <iiscnfg.h>
#include "instdata.h"
#include <mapicode.h>
#include <mimeole.h>
#include <dav.rh>
#include <ex\rgiter.h>

//	Map last error to HTTP response code --------------------------------------
//
/*
 *	HscFromLastError()
 *
 *	Purpose:
 *
 *		Maps the value returned from GetLastError() to
 *		an HTTP 1.1 response status code.
 *
 *	Parameters:
 *
 *		err			[in]  system error code
 *
 *	Returns:
 *
 *		Mapped system error code
 */
UINT
HscFromLastError (DWORD dwErr)
{
	UINT hsc = HSC_INTERNAL_SERVER_ERROR;

	switch (dwErr)
	{
		//	Successes ---------------------------------------------------------
		//
		case NO_ERROR:

			return HSC_OK;

		//	Parial Success
		//
		case ERROR_PARTIAL_COPY:

			hsc = HSC_MULTI_STATUS;
			break;

		//	Errors ------------------------------------------------------------
		//
		//	Not Implemented
		//
		case ERROR_NOT_SUPPORTED:
		case ERROR_INVALID_FUNCTION:

			hsc = HSC_NOT_IMPLEMENTED;
			break;

		//	Not Found
		//
		case ERROR_FILE_NOT_FOUND:
		case ERROR_PATH_NOT_FOUND:
		case ERROR_INVALID_NAME:

			hsc = HSC_NOT_FOUND;
			break;

		//	Unathorized Access
		//
		case ERROR_ACCESS_DENIED:

			hsc = HSC_UNAUTHORIZED;
			break;

		//	Forbidden access
		//
		case ERROR_DRIVE_LOCKED:
		case ERROR_INVALID_ACCESS:
		case ERROR_INVALID_PASSWORD:
		case ERROR_LOCK_VIOLATION:
		case ERROR_WRITE_PROTECT:

			hsc = HSC_FORBIDDEN;
			break;

		//	LOCKING -- this is the error when a resource is
		//	already locked.
		//
		case ERROR_SHARING_VIOLATION:

			hsc = HSC_LOCKED;
#ifdef	DBG
			{
				static LONG s_lAssert = -1;
				if (s_lAssert == -1)
				{
					LONG lAss = GetPrivateProfileIntA ("general",
						"Assert_423s",
						0,
						gc_szDbgIni);
					InterlockedCompareExchange (&s_lAssert, lAss, -1);
				}
				if (s_lAssert != 0)
					TrapSz ("GetLastError() maps to 423");
			}
#endif	// DBG
			break;

		//	Bad Requests
		//
		case ERROR_BAD_COMMAND:
		case ERROR_BAD_FORMAT:
		case ERROR_INVALID_DRIVE:
		case ERROR_INVALID_PARAMETER:
		case ERROR_NO_UNICODE_TRANSLATION:

			hsc = HSC_BAD_REQUEST;
			break;

		//	Errors generated when the client drops the connection
		//	on us or when we timeout waiting for the client to send
		//	us additional data.  These errors should map to a response
		//	status code of 400 Bad Request even though we can't actually
		//	send back the response.  IIS logs the response status code
		//	and we want to indicate that the error is the client's,
		//	not ours.  K2 logs a 400, so this is for compatibility.
		//
		case WSAECONNRESET:
		case ERROR_NETNAME_DELETED:
		case ERROR_SEM_TIMEOUT:

			hsc = HSC_BAD_REQUEST;
			break;

		//	Method Failure
		//
		case ERROR_DIR_NOT_EMPTY:

			hsc = HSC_METHOD_FAILURE;
			break;

		//	Conflict
		//
		case ERROR_FILE_EXISTS:
		case ERROR_ALREADY_EXISTS:

			hsc = HSC_CONFLICT;
			break;

		//	Unavailable Services (SMB access)
		//
		case ERROR_NETWORK_UNREACHABLE:
		case ERROR_UNEXP_NET_ERR:

			hsc = HSC_SERVICE_UNAVAILABLE;
			break;

		//	Returned by metabase when the server is too busy.
		//	Do NOT map this to HSC_SERVICE_UNAVAILABLE.  The
		//	"too busy" scenario has an IIS custom suberror
		//	which assumes a 500 (not 503) status code.
		//
		case ERROR_PATH_BUSY:

			hsc = HSC_INTERNAL_SERVER_ERROR;
			break;

		//	This error code (ERROR_OUTOFMEMORY) has been added for DAVEX.
		//	The exchange store returns this error when we try to retrieve
		//	the message body property. When we fetch properties on a
		//	message, the store does not return the message body property
		//	if the message body is greater than a certain length. The
		//	general idea is that we don't wan't huge message bodies
		//	returned along with the other properties. We'd much rather fetch
		//	the message body separately.
		//
		case ERROR_OUTOFMEMORY:

			hsc = HSC_INSUFFICIENT_SPACE;
			break;

		default:

			hsc = HSC_INTERNAL_SERVER_ERROR;
#ifdef	DBG
			{
				static LONG s_lAssert = -1;
				if (s_lAssert == -1)
				{
					LONG lAss = GetPrivateProfileIntA ("general",
						"Assert_500s",
						0,
						gc_szDbgIni);
					InterlockedCompareExchange (&s_lAssert, lAss, -1);
				}
				if (s_lAssert != 0)
					TrapSz ("GetLastError() maps to 500");
			}
#endif	// DBG
			break;
	}

	DebugTrace ("DAV: sys error (%ld) mapped to hsc (%ld)\n", dwErr, hsc);
	return hsc;
}

/*
 *	CSEFromHresult()
 *
 *	Purpose:
 *
 *		Maps an hresult to an IIS custom error suberror
 *
 *	Parameters:
 *
 *		hr			[in]  HRESULT error code
 *
 *	Returns:
 *
 *		Mapped suberror
 */
UINT
CSEFromHresult (HRESULT hr)
{
	UINT cse = CSE_NONE;

	switch (hr)
	{
		//	Read Access Forbidden
		//
		case E_DAV_NO_IIS_READ_ACCESS:

			Assert( HscFromHresult(hr) == HSC_FORBIDDEN );
			cse = CSE_403_READ;
			break;

		//	Write Access Forbidden
		//
		case E_DAV_NO_IIS_WRITE_ACCESS:

			Assert( HscFromHresult(hr) == HSC_FORBIDDEN );
			cse = CSE_403_WRITE;
			break;

		//	Execute Access Forbidden
		//
		case E_DAV_NO_IIS_EXECUTE_ACCESS:

			Assert( HscFromHresult(hr) == HSC_FORBIDDEN );
			cse = CSE_403_EXECUTE;
			break;

		//	Access denied due to ACL
		//
		case HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED):

			Assert( HscFromHresult(hr) == HSC_UNAUTHORIZED );
			cse = CSE_401_ACL;
			break;

		//	Server too busy
		//
		case HRESULT_FROM_WIN32(ERROR_PATH_BUSY):

			Assert( HscFromHresult(hr) == HSC_INTERNAL_SERVER_ERROR );
			cse = CSE_500_TOO_BUSY;
			break;
	}

	return cse;
}

/*
 *	HscFromHresult()
 *
 *	Purpose:
 *
 *		Maps an hresult to an HTTP 1.1 response status code.
 *
 *	Parameters:
 *
 *		hr			[in]  HRESULT error code
 *
 *	Returns:
 *
 *		Mapped error code
 */
UINT
HscFromHresult (HRESULT hr)
{
	UINT hsc = HSC_INTERNAL_SERVER_ERROR;

	//	If the facility of the hr is WIN32,
	//	parse out the error bits and send it to HscFromLastError.
	//
	if (FACILITY_WIN32 == HRESULT_FACILITY(hr))
		return HscFromLastError (HRESULT_CODE(hr));

	switch (hr)
	{
		//	Successes ---------------------------------------------------------
		//
		case S_OK:
		case S_FALSE:
		case W_DAV_SCRIPTMAP_MATCH_FOUND:

			return HSC_OK;

		//	No Content
		//
		case W_DAV_NO_CONTENT:

			hsc = HSC_NO_CONTENT;
			break;

		//	Created
		//
		case W_DAV_CREATED:

			hsc = HSC_CREATED;
			break;

		//	Partial content
		//
		case W_DAV_PARTIAL_CONTENT:

			hsc = HSC_PARTIAL_CONTENT;
			break;

		//	Multi-status
		//
		case W_DAV_PARTIAL_SUCCESS:

			hsc = HSC_MULTI_STATUS;
			break;

		//	Moved temporarily
		//
		case W_DAV_MOVED_TEMPORARILY:

			hsc = HSC_MOVED_TEMPORARILY;
			break;

		//	Errors ------------------------------------------------------------
		//
		//	Not modified
		//
		case E_DAV_ENTITY_NOT_MODIFIED:

			hsc = HSC_NOT_MODIFIED;
			break;

		//	Pre-condition failed
		//
		case E_DAV_IF_HEADER_FAILURE:
		case E_DAV_NOTALLOWED_WITHIN_TRANSACTION:
		case E_DAV_OVERWRITE_REQUIRED:
		case E_DAV_CANT_SATISFY_LOCK_REQUEST:
		case E_DAV_NOTIF_SUBID_ERROR:

			hsc = HSC_PRECONDITION_FAILED;
			break;

		//	Not Implemented
		//
		case E_NOTIMPL:
		case E_DAV_NO_PARTIAL_UPDATE:
		case STG_E_UNIMPLEMENTEDFUNCTION:
		case STG_E_INVALIDFUNCTION:
		case E_DAV_STORE_CHECK_FOLDER_NAME:
		case E_DAV_MKCOL_NOT_ALLOWED_ON_NULL_RESOURCE:
		case E_DAV_STORE_SEARCH_UNSUPPORTED:

			hsc = HSC_NOT_IMPLEMENTED;
			break;

		//	Not Found
		//
		case E_DAV_ALT_FILESTREAM:
		case E_DAV_SHORT_FILENAME:
		case MK_E_NOOBJECT:
		case STG_E_FILENOTFOUND:
		case STG_E_INVALIDNAME:
		case STG_E_PATHNOTFOUND:
		case E_DAV_HIDDEN_OBJECT:
		case E_DAV_STORE_BAD_PATH:
		case E_DAV_STORE_NOT_FOUND:

			hsc = HSC_NOT_FOUND;
			break;

		//	Unathorized Access
		//
		case E_DAV_ENTITY_TYPE_CONFLICT:
		case E_ACCESSDENIED:
		case STG_E_ACCESSDENIED:

			hsc = HSC_UNAUTHORIZED;
			break;

		case E_DAV_SMB_PROPERTY_ERROR:
		case E_DAV_NO_IIS_ACCESS_RIGHTS:
		case E_DAV_NO_IIS_READ_ACCESS:
		case E_DAV_NO_IIS_WRITE_ACCESS:
		case E_DAV_NO_IIS_EXECUTE_ACCESS:
		case E_DAV_NO_ACL_ACCESS:
		case E_DAV_PROTECTED_ENTITY:
		case E_DAV_CONFLICTING_PATHS:
		case E_DAV_FORBIDDEN:
		case STG_E_DISKISWRITEPROTECTED:
		case STG_E_LOCKVIOLATION:
		case E_DAV_STORE_MAIL_SUBMISSION:
		case E_DAV_STORE_REVISION_ID_FAILURE:
		case E_DAV_MAIL_SUBMISSION_FORBIDDEN:
		case E_DAV_MKCOL_REVISION_ID_FORBIDDEN:
		case E_ABORT:

			hsc = HSC_FORBIDDEN;
			break;

		case E_DAV_SEARCH_COULD_NOT_RESTRICT:
		case E_DAV_UNSUPPORTED_SQL:
		case MIME_E_NO_DATA:			//	empty 822 message, returned from IMail. It is nothing wrong with
										//	request that attempts to create empty message. Semantics are wrong.

			hsc = HSC_UNPROCESSABLE;
			break;

		//	LOCKING errors when a resource is already locked.
		//
		case E_DAV_LOCKED:
		case STG_E_SHAREVIOLATION:

			hsc = HSC_LOCKED;
#ifdef	DBG
			{
				static LONG s_lAssert = -1;
				if (s_lAssert == -1)
				{
					LONG lAss = GetPrivateProfileIntA ("general",
						"Assert_423s",
						0,
						gc_szDbgIni);
					InterlockedCompareExchange (&s_lAssert, lAss, -1);
				}
				if (s_lAssert != 0)
					TrapSz ("HRESULT maps to 423");
			}
#endif	// DBG
			break;

		//	Bad Requests
		//
		case E_DAV_EMPTY_FIND_REQUEST:
		case E_DAV_EMPTY_PATCH_REQUEST:
		case E_DAV_INCOMPLETE_SQL_STATEMENT:
		case E_DAV_INVALID_HEADER:
		case E_DAV_LOCK_NOT_FOUND:
		case E_DAV_MALFORMED_PATH:
		case E_DAV_METHOD_FAILURE_STAR_URL:
		case E_DAV_MISSING_CONTENT_TYPE:
		case E_DAV_NAMED_PROPERTY_ERROR:
		case E_DAV_NO_DESTINATION:
		case E_DAV_NO_QUERY:
		case E_DAV_PATCH_TYPE_MISMATCH:
		case E_DAV_READ_REQUEST_TIMEOUT:
		case E_DAV_SEARCH_SCOPE_ERROR:
		case E_DAV_UNEXPECTED_TYPE:
		case E_DAV_XML_PARSE_ERROR:
		case E_DAV_XML_BAD_DATA:
		case E_INVALIDARG:
		case MK_E_NOSTORAGE:
		case MK_E_SYNTAX:
		case STG_E_INVALIDPARAMETER:

			hsc = HSC_BAD_REQUEST;
			break;

		//	Length required
		//
		case E_DAV_MISSING_LENGTH:

			hsc = HSC_LENGTH_REQUIRED;
			break;

		//	Unknown content-types
		//
		case E_DAV_UNKNOWN_CONTENT:

			hsc = HSC_UNSUPPORTED_MEDIA_TYPE;
			break;

		//	Content errors
		//
		case E_DAV_BASE64_ENCODING_ERROR:
		case E_DAV_RESPONSE_TYPE_UNACCEPTED:

			hsc = HSC_NOT_ACCEPTABLE;
			break;

		//	Bad Gateway
		//
		case E_DAV_BAD_DESTINATION:
		case W_DAV_SPANS_VIRTUAL_ROOTS:
		case E_DAV_STAR_SCRIPTMAPING_MISMATCH:

			hsc = HSC_BAD_GATEWAY;
			break;

		//	Methods not allowed
		//
		case E_DAV_COLLECTION_EXISTS:
		case E_DAV_VOLUME_NOT_NTFS:
		case E_NOINTERFACE:
		case E_DAV_STORE_ALREADY_EXISTS:
		case E_DAV_MKCOL_OBJECT_ALREADY_EXISTS:

			hsc = HSC_METHOD_NOT_ALLOWED;
			break;

		//	Conflict
		//
		case E_DAV_NONEXISTING_PARENT:
		case STG_E_FILEALREADYEXISTS:
		case E_DAV_CONFLICT:
		case E_DAV_NATIVE_CONTENT_NOT_MAPI:

			hsc = HSC_CONFLICT;
			break;

		//	Unsatisfiable byte range requests
		//
		case E_DAV_RANGE_NOT_SATISFIABLE:

			hsc = HSC_RANGE_NOT_SATISFIABLE;
			break;

		//	424 Method Failure
		//
		case E_DAV_STORE_COMMIT_GOP:

			hsc = HSC_METHOD_FAILURE;
			break;

		case E_DAV_IPC_CONNECT_FAILED:
		case E_DAV_EXPROX_CONNECT_FAILED:
		case E_DAV_MDB_DOWN:
		case E_DAV_STORE_MDB_UNAVAILABLE:

			hsc = HSC_SERVICE_UNAVAILABLE;
			break;

		case E_DAV_RSRC_INSUFFICIENT_BUFFER:

			hsc = HSC_INSUFFICIENT_SPACE;
			break;

		default:
		case E_DAV_METHOD_FORWARDED:
		case E_DAV_GET_DB_HELPER_FAILURE:
		case E_DAV_NOTIF_POLL_FAILURE:

			hsc = HSC_INTERNAL_SERVER_ERROR;
#ifdef	DBG
			{
				static LONG s_lAssert = -1;
				if (s_lAssert == -1)
				{
					LONG lAss = GetPrivateProfileIntA ("general",
						"Assert_500s",
						0,
						gc_szDbgIni);
					InterlockedCompareExchange (&s_lAssert, lAss, -1);
				}
				if (s_lAssert != 0)
					TrapSz ("HRESULT maps to 500");
			}
#endif	// DBG
			break;
	}

	DebugTrace ("DAV: HRESULT error (0x%08x) mapped to hsc (%ld)\n", hr, hsc);
	return hsc;
}

BOOL
FWchFromHex (LPCWSTR pwsz, WCHAR * pwch)
{
	INT iwch;
	WCHAR wch;
	WCHAR wchX = 0;

	Assert (pwch);
	for (iwch = 0; iwch < 2; iwch++)
	{
		//	Shift whats there up a diget
		//
		wchX = (WCHAR)(wchX << 4);

		//	Parse the next char
		//
		wch = pwsz[iwch];

		//	Make sure we don't exceed the sequence.
		//
		if (!wch)
			return FALSE;

#pragma warning(disable:4244)
		if ((wch >= L'0') && (wch <= L'9'))
			wchX += (WCHAR)(wch - L'0');
		else if ((wch >= L'A') && (wch <= L'F'))
			wchX += (WCHAR)(wch - L'A' + 10);
		else if ((wch >= L'a') && (wch <= L'f'))
			wchX += (WCHAR)(wch - L'a' + 10);
		else
			return FALSE;	// bad sequence
#pragma warning(default:4244)
	}

	*pwch = wchX;
	return TRUE;
}

//	Byte Range Checking and Header Emission -----------------------------------------------------------
//
/*
 *	ScProcessByteRanges()
 *
 *	Purpose:
 *
 *		Helper function used to process byte ranges and emit the header
 *		information for GET responses.
 *
 *	Parameters:
 *
 *		pmu				[in]		pointer to the method util obj
 *		pwszPath		[in]		path of request entity
 *		dwSizeLow		[in]		size of get request entity (low byte)
 *		dwSizeHigh		[in]		size of get request entity (high byte)
 *		pByteRange		[out]		given a pointer to a RangeIter obj, the
 *									function fills in byte range information
 *									if the request contains a Range header
 *		pszEtagOverride	[in, opt.]	pointer to an Etag, overrides the Etag
 *										generated from the last modification
 *										time
 *		pftOverride		[in, opt.]	pointer to a FILETIME structure, overrides
 *										call to FGetLastModTime
 *
 *	Returns: SCODE
 *
 *		S_OK indicates success(ordinary response).
 *		W_DAV_PARTIAL_CONTENT (206) indicates success(byte range response).
 *		E_DAV_RANGE_NOT_SATISFIABLE (416) indicates all of requested
 *				byte ranges were beyond the size of the entity.
 */
SCODE
ScProcessByteRanges (IMethUtil * pmu,
					 LPCWSTR pwszPath,
					 DWORD dwSizeLow,
					 DWORD dwSizeHigh,
					 CRangeParser * pByteRange)
{
	FILETIME ft;
	WCHAR pwszEtag[CCH_ETAG];

	//	Check the validity of the inputs
	//
	Assert (pmu);
	Assert (pwszPath);
	Assert (pByteRange);

	SideAssert(FGetLastModTime (pmu, pwszPath, &ft));
	SideAssert(FETagFromFiletime (&ft, pwszEtag, pmu->GetEcb()));

	return ScProcessByteRangesFromEtagAndTime (pmu,
											   dwSizeLow,
											   dwSizeHigh,
											   pByteRange,
											   pwszEtag,
											   &ft);
}

SCODE
ScProcessByteRangesFromEtagAndTime (IMethUtil * pmu,
									DWORD dwSizeLow,
									DWORD dwSizeHigh,
									CRangeParser *pByteRange,
									LPCWSTR pwszEtag,
									FILETIME * pft)
{
	SCODE	sc = S_OK;
	LPCWSTR	pwszRangeHeader;
	WCHAR	rgwchBuf[128] = L"";

	//	Check the validity of the inputs
	//
	Assert (pmu);
	Assert (pByteRange);
	Assert (pwszEtag);
	Assert (pft);

	//	Check to see if we have a Range header and the If-Range condition( if
	//	there is one) is satisfied. Do not apply URL conversion rules while
	//	fetching the header.
	//
	pwszRangeHeader = pmu->LpwszGetRequestHeader (gc_szRange, FALSE);
	if ( pwszRangeHeader && !FAILED (ScCheckIfRangeHeaderFromEtag (pmu,
																   pft,
																   pwszEtag)) )
	{
		//  Limit the maximum size of range headers we will process
		//
		if ( MAX_PATH < wcslen(pwszRangeHeader) )
		{
			sc = E_DAV_RANGE_NOT_SATISFIABLE;
			goto ret;
		}

		//	We have no means of handling byte ranges for files larger than 4GB,
		//	due to limitations of _HSE_TF_INFO that takes DWORD values for sizes
		//	and offsets. So if we are geting byterange request on that large file
		//	just fail out - with some error that maps to 405 Method Not Allowed
		//
		if (dwSizeHigh)
		{
			sc = E_NOINTERFACE;
			goto ret;
		}

		//	OK, we have a byte range. Parse the byte ranges from the header.
		//	The function takes the size of the request entity to make
		//	sure the byte ranges are consistent with the entity size (no byte
		//	ranges beyond the size).
		//
		sc = pByteRange->ScParseByteRangeHdr(pwszRangeHeader, dwSizeLow);

		switch (sc)
		{
			case W_DAV_PARTIAL_CONTENT:

				//	We have a byte range (206 partial content). Send back
				//	this return code.
				//
				break;

			case E_DAV_RANGE_NOT_SATISFIABLE:

				//	We don't have any satisfiable ranges (all our ranges had a
				//	start byte greater than the size of the file or they
				//	requested a zero-sized range). Our behaviour here depends on
				//	the presence of the If-Range header.
				//	If we have an If-Range header, return the default response
				//	S_OK (the entire file). If we don't have one,
				//	we need to return a 416 (Requested Range Not Satisfiable).
				//		Would look like it is more performant to ask for the skinny
				//	version here, but at this moment wide header value is already
				//	cached so it makes no difference. And do not apply URL conversion
				//	rules to the header.
				//
				if (!pmu->LpwszGetRequestHeader(gc_szIf_Range, FALSE))
				{
					//	NO If-Range header found.
					//	Set the Content-Range header to say "bytes *"
					//	(meaning the whole file was sent).
					//
					wsprintfW(rgwchBuf, L"%ls */%d", gc_wszBytes, dwSizeLow);
					pmu->SetResponseHeader(gc_szContent_Range, rgwchBuf);

					//	Send back this return code (E_DAV_RANGE_NOT_SATISFIABLE).
					//
				}
				else
				{
					//	We DO have an If-Range header.
					//	Return 200 OK, and send the whole file.
					//
					sc = S_OK;
				}
				break;

			case E_INVALIDARG:

				//	If the parsing function returned S_FALSE we have a syntax
				//	error, so we ignore the Range header and send the entire
				//	file/stream.
				//	Reset our return code to S_OK.
				//
				sc = S_OK;
				break;

			default:

				//	Unrecognizable error. We should never see anything but
				//	the three values in the case statement. Assert (TrapSz),
				//	and return this sc.
				//
				break;
		}
	}

	//	Either we didn't have a Range header or the If-Range condition
	//	was false. Its an ordinary GET and we need to send the entire
	//	file. Our response (S_OK) is already set by default.
	//

ret:

	return sc;
}


//	Generating a boundary for multipartpart mime like responses------------------
//
/*
 *	GenerateBoundary()
 *
 *	Purpose:
 *
 *		Helper function used to generate a separator boundary for multipart
 *		mime like responses
 *
 *	Parameters:
 *
 *		rgwchBoundary	[out]		boundary for multipart responses
 *		cch				[in]		size of the rgwchBoundary parameter
 */
void
GenerateBoundary(LPWSTR rgwchBoundary, UINT cch)
{
	UINT cchMin;
	UINT iIter;

	//	Assert that we've been given a buffer of at least size 2 (a minimum
	//	null terminated boundary of one byte).
	//
	Assert (cch > 1);
	Assert (rgwchBoundary);

	//	The boundary size is the smaller of the size passed in to us or the default
	//
	cchMin = min(gc_ulDefaultBoundarySz, cch - 1);

	//	We are going to randomly use characters from the boundary alphabet.
	//	The rand() function is seeded by the current time
	//
	srand(GetTickCount());

	//	Now to generate the actual boundary
	//
	for (iIter = 0; iIter < cchMin; iIter++)
	{
		rgwchBoundary[iIter] = gc_wszBoundaryAlphabet[ rand() % gc_ulAlphabetSz ];
	}
	rgwchBoundary[cchMin] = L'\0';
}


//	Non-Async IO on Top of Overlapped Files -----------------------------------
//
BOOL
ReadFromOverlapped (HANDLE hf,
	LPVOID pvBuf,
	ULONG cbToRead,
	ULONG * pcbRead,
	OVERLAPPED * povl)
{
	Assert (povl);

	//	Start reading
	//
	if ( !ReadFile( hf, pvBuf, cbToRead, pcbRead, povl ) )
	{
		if ( GetLastError() == ERROR_IO_PENDING )
		{
			if ( !GetOverlappedResult( hf, povl, pcbRead, TRUE ) )
			{
				if ( GetLastError() != ERROR_HANDLE_EOF )
				{
					DebugTrace( "ReadFromOverlapped(): "
								"GetOverlappedResult() failed (%d)\n",
								GetLastError() );

					return FALSE;
				}
			}
		}
		else if ( GetLastError() != ERROR_HANDLE_EOF )
		{
			DebugTrace( "ReadFromOverlapped(): "
						"ReadFile() failed (%d)\n",
						GetLastError() );

			return FALSE;
		}
	}
	return TRUE;
}

BOOL
WriteToOverlapped (HANDLE hf,
	const void * pvBuf,
	ULONG cbToWrite,
	ULONG * pcbWritten,
	OVERLAPPED * povl)
{
	Assert (povl);

	//	Start writting
	//
	if ( !WriteFile( hf, pvBuf, cbToWrite, pcbWritten, povl ) )
	{
		if ( GetLastError() == ERROR_IO_PENDING )
		{
			if ( !GetOverlappedResult( hf, povl, pcbWritten, TRUE ) )
			{
				if ( GetLastError() != ERROR_HANDLE_EOF )
				{
					DebugTrace( "WriteToOverlapped(): "
								"GetOverlappedResult() failed (%d)\n",
								GetLastError() );

					return FALSE;
				}
			}
		}
		else if ( GetLastError() != ERROR_HANDLE_EOF )
		{
			DebugTrace( "WriteToOverlapped(): "
						"WriteFile() failed (%d)\n",
						GetLastError() );

			return FALSE;
		}
	}
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\davmb.cpp ===
/*
 *	D A V M B . C P P
 *
 *	DAV metabase
 *
 *	Copyright 1986-1998 Microsoft Corporation, All Rights Reserved
 */

#include <_davprs.h>
#include <content.h>	// IContentTypeMap
#include <custerr.h>	// ICustomErrorMap
#include <scrptmps.h>	// IScriptMap

//	========================================================================
//
//	CLASS CNotifSink
//
//	Metabase change notification advise sink.  Provides IMSAdminBaseSink
//	interface to the real metabase so that we can be informed of
//	all changes to it.
//
class CNotifSink : public EXO, public IMSAdminBaseSink
{
	//
	//	Shutdown notification event that we signal when we are
	//	done -- i.e. when we get destroyed.
	//
	CEvent& m_evtShutdown;

	HRESULT STDMETHODCALLTYPE SinkNotify(
		/* [in] */ DWORD dwMDNumElements,
		/* [size_is][in] */ MD_CHANGE_OBJECT_W __RPC_FAR pcoChangeList[  ]);

	HRESULT STDMETHODCALLTYPE ShutdownNotify()
	{
		MBTrace ("MB: CNotifSink: shutdown\n");
		return HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
	}

	//	NOT IMPLEMENTED
	//
	CNotifSink& operator=(const CNotifSink&);
	CNotifSink(const CNotifSink&);

public:
	EXO_INCLASS_DECL(CNotifSink);

	//	CREATORS
	//
	CNotifSink(CEvent& evtShutdown) :
		m_evtShutdown(evtShutdown)
	{
	}

	~CNotifSink()
	{
		//
		//	We cannot process any more notifications at this point.
		//	Signal our shutdown event.
		//
		m_evtShutdown.Set();
	}

	//	Wrapper for all the work that needs to be done on the notification
	//
	static VOID OnNotify( DWORD cCO,
						  MD_CHANGE_OBJECT_W rgCO[] );
};

BEGIN_INTERFACE_TABLE(CNotifSink)
	INTERFACE_MAP(CNotifSink, IMSAdminBaseSink)
END_INTERFACE_TABLE(CNotifSink);
EXO_GLOBAL_DATA_DECL(CNotifSink, EXO);

//	------------------------------------------------------------------------
//
//	HrAdviseSink()
//
HRESULT
HrAdviseSink( IMSAdminBase& msAdminBase,
			  IMSAdminBaseSink * pMSAdminBaseSink,
			  DWORD * pdwCookie )
{
	auto_ref_ptr<IConnectionPoint> pcp;
	auto_ref_ptr<IConnectionPointContainer> pcpc;
	SCODE sc = S_OK;

	Assert( !IsBadReadPtr(&msAdminBase, sizeof(IMSAdminBase)) );
	Assert( !IsBadWritePtr(pMSAdminBaseSink, sizeof(IMSAdminBaseSink)) );

	//	First see if a connection point container is supported
	//
	sc = msAdminBase.QueryInterface (IID_IConnectionPointContainer,
									 reinterpret_cast<LPVOID *>(pcpc.load()));
	if (FAILED (sc))
	{
		DebugTrace( "HrAdviseSink() - QI to IConnectionPointContainer() failed 0x%08lX\n", sc );
		goto ret;
	}

	//	Find the required connection point
	//
	sc = pcpc->FindConnectionPoint (IID_IMSAdminBaseSink, pcp.load());
	if (FAILED (sc))
	{
		DebugTrace( "HrAdviseSink() - FindConnectionPoint() failed 0x%08lX\n", sc );
		goto ret;
	}

	//	Advise on the sink
	//
	sc = pcp->Advise (pMSAdminBaseSink, pdwCookie);
	if (FAILED (sc))
	{
		DebugTrace( "HrAdviseSink() - Advise() failed 0x%08lX\n", sc );
		goto ret;
	}

ret:

	return sc;
}

//	------------------------------------------------------------------------
//
//	UnadviseSink()
//
VOID
UnadviseSink( IMSAdminBase& msAdminBase,
			  DWORD dwCookie )
{
	auto_ref_ptr<IConnectionPoint> pcp;
	auto_ref_ptr<IConnectionPointContainer> pcpc;
	SCODE sc = S_OK;

	Assert( !IsBadReadPtr(&msAdminBase, sizeof(IMSAdminBase)) );
	Assert( dwCookie );

	//	First see if a connection point container is supported
	//
	sc = msAdminBase.QueryInterface (IID_IConnectionPointContainer,
									 reinterpret_cast<LPVOID *>(pcpc.load()));
	if (FAILED (sc))
	{
		DebugTrace( "UnadviseSink() - QI to IConnectionPointContainer() failed 0x%08lX\n", sc );
		goto ret;
	}

	//	Find the required connection point
	//
	sc = pcpc->FindConnectionPoint (IID_IMSAdminBaseSink, pcp.load());
	if (FAILED (sc))
	{
		DebugTrace( "UnadviseSink() - FindConnectionPoint() failed 0x%08lX\n", sc );
		goto ret;
	}

	//	Unadvise
	//
	sc = pcp->Unadvise (dwCookie);
	if (FAILED (sc))
	{
		DebugTrace( "UnadviseSink() - Unadvise() failed 0x%08lX\n", sc );
		goto ret;
	}

ret:

	return;
}

//	========================================================================
//
//	CLASS CMDData
//
//	Encapsulates access to a resource's metadata.
//
class CMDData :
	public IMDData,
	public CMTRefCounted
{
	//
	//	Object metadata
	//
	auto_ref_ptr<IContentTypeMap> m_pContentTypeMap;
	auto_ref_ptr<ICustomErrorMap> m_pCustomErrorMap;
	auto_ref_ptr<IScriptMap> m_pScriptMap;

	//
	//	Buffer for the raw metadata and count of
	//	metadata records in that buffer.
	//
	auto_heap_ptr<BYTE> m_pbData;
	DWORD m_dwcMDRecords;

	//
	//	String metadata
	//
	LPCWSTR m_pwszDefaultDocList;
	LPCWSTR m_pwszVRUserName;
	LPCWSTR m_pwszVRPassword;
	LPCWSTR m_pwszExpires;
	LPCWSTR m_pwszBindings;
	LPCWSTR m_pwszVRPath;

	DWORD m_dwAccessPerms;
	DWORD m_dwDirBrowsing;
	BOOL  m_fFrontPage;
	DWORD m_cbIPRestriction;
	BYTE* m_pbIPRestriction;
	BOOL  m_fHasApp;
	DWORD m_dwAuthorization;
	DWORD m_dwIsIndexed;

	//
	//	Metabase path from which the data for this data set was loaded.
	//	Used in metabase notifications.  See CMetabase::OnNotify() below.
	//	The string pointed to is at the end of m_pbData.
	//
	LPCWSTR m_pwszMDPathDataSet;
	DWORD m_dwDataSet;

	//	NOT IMPLEMENTED
	//
	CMDData& operator=(const CMDData&);
	CMDData(const CMDData&);

public:
	//	CREATORS
	//
	CMDData(LPCWSTR pwszMDPathDataSet, DWORD dwDataSet);
	~CMDData();
	BOOL FInitialize( auto_heap_ptr<BYTE>& pbData, DWORD dwcRecords );

	//	Implementation of IRefCounted members
	//	Simply route them to our own CMTRefCounted members.
	//
	void AddRef()
	{ CMTRefCounted::AddRef(); }
	void Release()
	{ CMTRefCounted::Release(); }

	//	ACCESSORS
	//
	LPCWSTR PwszMDPathDataSet() const { return m_pwszMDPathDataSet; }
	DWORD DwDataSet() const { return m_dwDataSet; }
	IContentTypeMap * GetContentTypeMap() const { return m_pContentTypeMap.get(); }
	const ICustomErrorMap * GetCustomErrorMap() const { return m_pCustomErrorMap.get(); }
	const IScriptMap * GetScriptMap() const { return m_pScriptMap.get(); }

	LPCWSTR PwszDefaultDocList() const { return m_pwszDefaultDocList; }
	LPCWSTR PwszVRUserName() const { return m_pwszVRUserName; }
	LPCWSTR PwszVRPassword() const { return m_pwszVRPassword; }
	LPCWSTR PwszExpires() const { return m_pwszExpires; }
	LPCWSTR PwszBindings() const { return m_pwszBindings; }
	LPCWSTR PwszVRPath() const { return m_pwszVRPath; }

	DWORD DwDirBrowsing() const { return m_dwDirBrowsing; }
	DWORD DwAccessPerms() const { return m_dwAccessPerms; }
	BOOL FAuthorViaFrontPage() const { return m_fFrontPage; }
	BOOL FHasIPRestriction() const { return !!m_cbIPRestriction; }
	BOOL FSameIPRestriction( const IMDData* pIMDD ) const
	{
		const CMDData* prhs = static_cast<const CMDData*>( pIMDD );

		//$	REVIEW: theoretically, there is no need for
		//	a memcmp.  However, in the rare case where
		//	the sizes are the same and the pointers are
		//	different, we might still try this.
		//
		//	This way, if/when we go to not using the
		//	METADATA_REFERNCE flag when getting the
		//	data, there should be no difference.
		//
		if ( m_pbIPRestriction == prhs->m_pbIPRestriction )
		{
			Assert( m_cbIPRestriction == prhs->m_cbIPRestriction );
			return TRUE;
		}
		else if ( m_cbIPRestriction == prhs->m_cbIPRestriction )
		{
			if ( !memcmp (m_pbIPRestriction,
						  prhs->m_pbIPRestriction,
						  prhs->m_cbIPRestriction))
			{
				return TRUE;
			}
		}
		//
		//$	REVIEW: end.
		return FALSE;
	}
	BOOL FHasApp() const { return m_fHasApp; }
	DWORD DwAuthorization() const { return m_dwAuthorization; }
	BOOL FIsIndexed() const { return (0 != m_dwIsIndexed); }
	BOOL FSameStarScriptmapping( const IMDData* pIMDD ) const
	{
		return m_pScriptMap->FSameStarScriptmapping( pIMDD->GetScriptMap() );
	}
};


//	========================================================================
//
//	STRUCT SCullInfo
//
//	Structure used in culling cached metabase data once the cache reaches
//	a certain threshold size.
//
struct SCullInfo
{
	//
	//	Data set number of the entry to be considered for culling.
	//
	DWORD dwDataSet;

	//
	//	Number of hits to that entry.
	//
	DWORD dwcHits;

	//
	//	Comparison function used by qsort() to sort the array of
	//	SCullInfo structures in determining which ones to cull.
	//
	static int __cdecl Compare( const SCullInfo * pCullInfo1,
								const SCullInfo * pCullInfo2 );
};


//	========================================================================
//
//	CLASS CMetabase
//
//	Encapsulates access to the metabase through a cache.  The cache
//	provides O(hash) lookup and addition and keeps the cache from
//	growing without bound using a LFU (Least Frequently Used) culling
//	mechanism whenever the size of the cache exceeds a preset threshold.
//
class CMetabase : public Singleton<CMetabase>
{
	//
	//	Friend declarations required by Singleton template
	//
	friend class Singleton<CMetabase>;

	//
	//	The IMSAdminBase interface to the real metabase
	//
	auto_ref_ptr<IMSAdminBase> m_pMSAdminBase;

	//
	//	Cache of metadata objects keyed by data set number
	//	and a reader/writer lock to protect it.
	//
	typedef CCache<DwordKey, auto_ref_ptr<CMDData> > CDataSetCache;
	CDataSetCache m_cache;
	CMRWLock m_mrwCache;

	//
	//	Cookie for metabase advise sink registration and an event that is
	//	signalled when the sink associated with that registration has been
	//	shut down and is no longer processing any notifications.
	//
	DWORD m_dwSinkRegCookie;
	CEvent m_evtSinkShutdown;

	//	========================================================================
	//
	//	CLASS COpGatherCullInfo
	//
	//	Cache ForEach() operator class for gathering info needed in determining
	//	which entries to cull from the cache when the cache size reaches the
	//	culling threshold.
	//
	class COpGatherCullInfo : public CDataSetCache::IOp
	{
		//
		//	Array of cull info
		//
		SCullInfo * m_rgci;

		//
		//	Current item in the array above
		//
		int m_ici;

		//	NOT IMPLEMENTED
		//
		COpGatherCullInfo( const COpGatherCullInfo& );
		COpGatherCullInfo& operator=( const COpGatherCullInfo& );

	public:
		COpGatherCullInfo( SCullInfo * rgci ) :
			m_rgci(rgci),
			m_ici(0)
		{
			Assert( m_rgci );
		}

		BOOL operator()( const DwordKey& key,
						 const auto_ref_ptr<CMDData>& pMDData );
	};

	//
	//	Interlockable flag to prevent simultaneous culling by multiple threads.
	//
	LONG m_lfCulling;

	//	========================================================================
	//
	//	CLASS COpNotify
	//
	//	Cache ForEach() operator class for gathering info needed in determining
	//	which entries to blow from the cache when a notification comes in
	//	from the metabase that the metadata for a path changed.
	//
	class COpNotify : public CDataSetCache::IOp
	{
		//
		//	Array of data set IDs.  For entries with a value other than 0,
		//	the data set with that ID is flagged to be blown from the cache.
		//	The array is guaranteed to be as big as there are entries in
		//	the cache.
		//
		DWORD m_cCacheEntry;
		DWORD * m_rgdwDataSets;

		//
		//	Flag set to TRUE if there are any data sets flagged in m_rgdwDataSets.
		//
		BOOL m_fDataSetsFlagged;

		//
		//	Current item in the array above
		//
		UINT m_iCacheEntry;

		//
		//	Path being notified and its length in characters
		//	(set via the Configure() method below).
		//
		LPCWSTR m_pwszMDPathNotify;
		UINT    m_cchMDPathNotify;

		//	NOT IMPLEMENTED
		//
		COpNotify( const COpNotify& );
		COpNotify& operator=( const COpNotify& );

	public:
		//	CREATORS
		//
		COpNotify( DWORD cce, DWORD * rgdwDataSets ) :
			m_rgdwDataSets(rgdwDataSets),
			m_cCacheEntry(cce),
			m_iCacheEntry(0),
			m_fDataSetsFlagged(FALSE)
		{
		}

		//	ACCESSORS
		//
		BOOL FDataSetsFlagged() const { return m_fDataSetsFlagged; }

		//	MANIPULATORS
		//
		BOOL operator()( const DwordKey& key,
						 const auto_ref_ptr<CMDData>& pMDData );

		VOID Configure( LPCWSTR pwszMDPathNotify )
		{
			//	Reset our current entry index.
			//
			m_iCacheEntry = 0;

			m_pwszMDPathNotify = pwszMDPathNotify;
			m_cchMDPathNotify = static_cast<UINT>(wcslen(pwszMDPathNotify));
		}
	};

	//	========================================================================
	//
	//	CLASS COpMatchExactPath
	//
	//	ForEachMatch() operator that fetches the cache entry whose path matches
	//	a desired path.  Used when inheritance bits are important.
	//
	class COpMatchExactPath : public CDataSetCache::IOp
	{
		//	The path to match
		//
		LPCWSTR m_pwszMDPathToMatch;

		//	The data for the matched path
		//
		auto_ref_ptr<CMDData> m_pMDDataMatched;

		//	NOT IMPLEMENTED
		//
		COpMatchExactPath( const COpMatchExactPath& );
		COpMatchExactPath& operator=( const COpMatchExactPath& );

	public:
		//	CREATORS
		//
		COpMatchExactPath( LPCWSTR pwszMDPath ) :
			m_pwszMDPathToMatch(pwszMDPath)
		{
		}

		//	MANIPULATORS
		//
		VOID Invoke( CDataSetCache& cache,
					 DWORD dwDataSet,
					 auto_ref_ptr<CMDData> * ppMDData )
		{
			//	Do the ForEachMatch()
			//
			(VOID) cache.ForEachMatch( dwDataSet, *this );

			//	Returned the matched data (if any)
			//
			(*ppMDData).take_ownership(m_pMDDataMatched.relinquish());
		}

		BOOL operator()( const DwordKey&,
						 const auto_ref_ptr<CMDData>& pMDData )
		{
			//	If the data's data set number path matches the
			//	path we are looking for, then return this data set.
			//	If not then do nothing and keep looking.
			//
			//$OPT	Can we guarantee that all MD paths are one case?
			//
			if (_wcsicmp(pMDData->PwszMDPathDataSet(), m_pwszMDPathToMatch))
			{
				return TRUE;
			}
			else
			{
				m_pMDDataMatched = pMDData;
				return FALSE;
			}
		}
	};

	//	CREATORS
	//
	CMetabase() :
		m_lfCulling(FALSE),
		m_dwSinkRegCookie(0)
	{
	}
	~CMetabase();

	//	MANIPULATORS
	//
	VOID CullCacheEntries();

	HRESULT HrCacheData( const IEcb& ecb,
						 LPCWSTR pwszMDPathAccess,
						 LPCWSTR pwszMDPathOpen,
						 CMDData ** ppMDData );

	//	NOT IMPLEMENTED
	//
	CMetabase& operator=( const CMetabase& );
	CMetabase( const CMetabase& );

public:
	enum
	{
		//
		//	Number of entries allowed in cache before culling.
		//
		//$REVIEW	Not based on emperical data
		//
		C_MAX_CACHE_ENTRIES = 100,

		//
		//	Number of entries to cull from cache when culling.
		//
		//$REVIEW	Not based on emperical data
		//$REVIEW	Consider expressing culling as a factor (percentage)
		//$REVIEW	rather than an absolute number.
		//
		C_CULL_CACHE_ENTRIES = 20,

		//
		//	Size of the metadata for the average cache entry.
		//	This one is based on experential data.  9K is just
		//	enough to hold all of an object's inherited metadata.
		//
		CCH_AVG_CACHE_ENTRY = 9 * 1024
	};

	//	CREATORS
	//
	//	Instance creating/destroying routines provided
	//	by the Singleton template.
	//
	using Singleton<CMetabase>::CreateInstance;
	using Singleton<CMetabase>::DestroyInstance;
	using Singleton<CMetabase>::Instance;
	BOOL FInitialize();

	VOID OnNotify( DWORD dwcChangeObjects,
				   MD_CHANGE_OBJECT_W rgCO[] );

	HRESULT HrGetData( const IEcb& ecb,
					   LPCWSTR pwszMDPathAccess,
					   LPCWSTR pwszMDPathOpen,
					   IMDData ** ppMDData );

	DWORD DwChangeNumber( const IEcb * pecb);

	HRESULT HrOpenObject( LPCWSTR pwszMDPath,
						  DWORD dwAccess,
						  DWORD dwMsecTimeout,
						  CMDObjectHandle * pmdoh );

	HRESULT HrOpenLowestNodeObject( LPWSTR pwszMDPath,
									DWORD dwAccess,
									LPWSTR * ppwszMDPath,
									CMDObjectHandle * pmdoh );

	HRESULT HrIsAuthorViaFrontPageNeeded( const IEcb& ecb,
										  LPCWSTR pwszURI,
										  BOOL * pfFrontPageWeb );

};


//	========================================================================
//
//	CLASS CMDObjectHandle
//
//	Encapsulates access to a metabase object through an open handle,
//	ensuring that the handle is always propery closed.
//
//	------------------------------------------------------------------------
//
//	HrOpen()
//
HRESULT
CMDObjectHandle::HrOpen( IMSAdminBase * pMSAdminBase,
						 LPCWSTR pwszPath,
						 DWORD dwAccess,
						 DWORD dwMsecTimeout )
{
	HRESULT hr = S_OK;
	
	safe_revert sr(m_ecb.HitUser());

	Assert(pMSAdminBase);
	Assert (NULL == m_pMSAdminBase || pMSAdminBase == m_pMSAdminBase);

	//	METADATA_MASTER_ROOT_HANDLE must be set
	//
	Assert (METADATA_MASTER_ROOT_HANDLE == m_hMDObject);

	//	Save the pointer to the interface, so we could use
	//	it any time later in spite of the fact if opening
	//	of the key succeeded or not
	//
	m_pMSAdminBase = pMSAdminBase;
	hr = pMSAdminBase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
							   pwszPath,
							   dwAccess,
							   dwMsecTimeout,
							   &m_hMDObject);

	if (ERROR_SUCCESS != hr)
	{
		if (!FAILED(hr))
		{
			hr = HRESULT_FROM_WIN32(hr);
		}

		MBTrace("MB: CMDObjectHandle::HrOpen() - IMSAdminBase::OpenKey() failed 0x%08lX\n", hr );
	}
	else
	{
		m_pwszPath = pwszPath;
	}

	return hr;
}

//	------------------------------------------------------------------------
//
//	HrOpenLowestNode()
//
//	Purpose:
//
//		Opens the LOWEST possible metabase node along the given path.
//
//	Parameters:
//
//		pMSAdminBase [in]	IMSAdminBase interface pointer.
//
//		pwszPath	 [in]	A full metabase path.  This function opens
//							the lowest possible node along this path,
//							by working backward from the full path
//							up to the root of the metabase until a
//							path specifying an existing node is opened.
//
//		dwAccess	 [in]	Permissions with which we want to open the
//							node.
//
//		ppwszPath	 [out]	Points to the remainder of the initial path
//							relative to the opened node.  This value is
//							NULL if the initial path was openable.
//
HRESULT
CMDObjectHandle::HrOpenLowestNode( IMSAdminBase * pMSAdminBase,
								   LPWSTR pwszPath,
								   DWORD dwAccess,
								   LPWSTR * ppwszPath)
{
	HRESULT hr = E_FAIL;
	WCHAR * pwch;

	Assert (pMSAdminBase);
	Assert (pwszPath);
	Assert (L'/' == pwszPath[0]);
	Assert (ppwszPath);
	Assert (!IsBadWritePtr(ppwszPath, sizeof(LPWSTR)) );

	*ppwszPath = NULL;

	pwch = pwszPath + wcslen(pwszPath);
	while ( pwch > pwszPath )
	{
		//
		//	Split off the path from the root at the current position
		//
		*pwch = L'\0';

		//
		//	Attempt to open a node at the resulting root
		//
		hr = HrOpen(pMSAdminBase,
					pwszPath,
					dwAccess,
					METADATA_TIMEOUT);

		//
		//	If we successfully open the node or failed for any reason
		//	other than that the node wasn't there, we're done.
		//
		if ( SUCCEEDED(hr) ||
			 HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) != hr )
		{
			goto ret;
		}

		//
		//	If there was no node, then restore the slash separator
		//	that we previously nulled out and scan backward to the
		//	next possible split location.
		//
		if ( *ppwszPath )
		{
			*pwch = L'/';
		}

		pwch--;
		while (*pwch != L'/')
		{
			pwch--;
		}

		*ppwszPath = pwch + 1;
	}

ret:

	return hr;
}

//	------------------------------------------------------------------------
//
//	HrEnumKeys()
//
HRESULT
CMDObjectHandle::HrEnumKeys( LPCWSTR pwszPath,
							 LPWSTR pwszChild,
							 DWORD dwIndex ) const
{
	HRESULT hr = S_OK;

	safe_revert sr(m_ecb.HitUser());
	
	//
	//	METADATA_MASTER_ROOT_HANDLE is valid for this operation so no assert
	//

	Assert (m_pMSAdminBase);

	hr = m_pMSAdminBase->EnumKeys(m_hMDObject,
								  pwszPath,
								  pwszChild,
								  dwIndex);
	if (ERROR_SUCCESS != hr )
	{
		if (!FAILED(hr))
		{
			hr = HRESULT_FROM_WIN32(hr);
		}

		MBTrace("MB: CMDObjectHandle::HrEnumKeys() - IMSAdminBase::EnumKeys() failed 0x%08lX\n", hr );
	}

	return hr;
}

//	------------------------------------------------------------------------
//
//	HrGetDataPaths()
//
HRESULT
CMDObjectHandle::HrGetDataPaths( LPCWSTR pwszPath,
								 DWORD   dwPropID,
								 DWORD   dwDataType,
								 LPWSTR	 pwszDataPaths,
								 DWORD * pcchDataPaths ) const
{
	HRESULT hr = S_OK;

	safe_revert sr(m_ecb.HitUser());

	//
	//	METADATA_MASTER_ROOT_HANDLE is valid for this operation so no assert
	//

	Assert (pwszPath);
	Assert (!IsBadReadPtr(pcchDataPaths, sizeof(DWORD)));
	Assert (!IsBadWritePtr(pcchDataPaths, sizeof(DWORD)));
	Assert (!IsBadWritePtr(pwszDataPaths, *pcchDataPaths * sizeof(WCHAR)));

	Assert (m_pMSAdminBase);

	hr = m_pMSAdminBase->GetDataPaths(m_hMDObject,
									  pwszPath,
									  dwPropID,
									  dwDataType,
									  *pcchDataPaths,
									  pwszDataPaths,
									  pcchDataPaths);

	if (ERROR_SUCCESS != hr )
	{
		if (!FAILED(hr))
		{
			hr = HRESULT_FROM_WIN32(hr);
		}

		MBTrace("MB: CMDObjectHandle::HrGetDataPaths() - IMSAdminBase::GetDataPaths() failed 0x%08lX\n", hr );
	}

	return hr;
}

//	------------------------------------------------------------------------
//
//	HrGetMetaData()
//
HRESULT
CMDObjectHandle::HrGetMetaData( LPCWSTR pwszPath,
							    METADATA_RECORD * pmdrec,
							    DWORD * pcbBufRequired ) const
{
	HRESULT hr = S_OK;

	safe_revert sr(m_ecb.HitUser());

	//
	//	METADATA_MASTER_ROOT_HANDLE is valid for this operation so no assert
	//

	Assert (m_pMSAdminBase);

	hr = m_pMSAdminBase->GetData(m_hMDObject,
								 const_cast<LPWSTR>(pwszPath),
								 pmdrec,
								 pcbBufRequired);
	if (ERROR_SUCCESS != hr )
	{
		if (!FAILED(hr))
		{
			hr = HRESULT_FROM_WIN32(hr);
		}

		MBTrace("MB: CMDObjectHandle::HrGetMetaData() - IMSAdminBase::GetData() failed 0x%08lX\n", hr );
	}

	return hr;
}

//	------------------------------------------------------------------------
//
//	HrGetAllMetaData()
//
HRESULT
CMDObjectHandle::HrGetAllMetaData( LPCWSTR pwszPath,
								   DWORD dwAttributes,
								   DWORD dwUserType,
								   DWORD dwDataType,
								   DWORD * pdwcRecords,
								   DWORD * pdwDataSet,
								   DWORD cbBuf,
								   LPBYTE pbBuf,
								   DWORD * pcbBufRequired ) const
{
	HRESULT hr = S_OK;

	safe_revert sr(m_ecb.HitUser());

	//
	//	METADATA_MASTER_ROOT_HANDLE is valid for this operation so no assert
	//

	Assert (m_pMSAdminBase);

	hr = m_pMSAdminBase->GetAllData(m_hMDObject,
									pwszPath,
									dwAttributes,
									dwUserType,
									dwDataType,
									pdwcRecords,
									pdwDataSet,
									cbBuf,
									pbBuf,
									pcbBufRequired);
	if (ERROR_SUCCESS != hr )
	{
		if (!FAILED(hr))
		{
			hr = HRESULT_FROM_WIN32(hr);
		}

		MBTrace("MB: CMDObjectHandle::HrGetAllMetaData() - IMSAdminBase::GetAllData() failed 0x%08lX\n", hr );
	}

	return hr;
}

//	------------------------------------------------------------------------
//
//	HrSetMetaData()
//
HRESULT
CMDObjectHandle::HrSetMetaData( LPCWSTR pwszPath,
							    const METADATA_RECORD * pmdrec ) const
{
	HRESULT hr = S_OK;

	safe_revert sr(m_ecb.HitUser());

	Assert (pmdrec);

	//	METADATA_MASTER_ROOT_HANDLE not valid for this operation
	//
	Assert (METADATA_MASTER_ROOT_HANDLE != m_hMDObject);
	Assert (m_pMSAdminBase);

	hr = m_pMSAdminBase->SetData(m_hMDObject,
								 pwszPath,
								 const_cast<METADATA_RECORD *>(pmdrec));
	if (ERROR_SUCCESS != hr)
	{
		if (!FAILED(hr))
		{
			hr = HRESULT_FROM_WIN32(hr);
		}

		MBTrace("MB: CMDObjectHandle::HrSetMetaData() - IMSAdminBase::SetData() failed 0x%08lX\n", hr );
	}
	else
	{
		//	Notify the sinks registered on this IMSAdminBase
		//	will not get notified, so we need to do all the
		//	invalidation ourselves. The only sink currently
		//	being registered is CChildVRCache.
		//
		SCODE scT;
		MD_CHANGE_OBJECT_W mdChObjW;
		UINT cchBase = 0;
		UINT cchPath = 0;

		CStackBuffer<WCHAR,MAX_PATH> pwsz;
		UINT cch;

		if (m_pwszPath)
		{
			cchBase = static_cast<UINT>(wcslen(m_pwszPath));
		}
		if (pwszPath)
		{
			cchPath = static_cast<UINT>(wcslen(pwszPath));
		}

		//	Allocate enough space for constructed path:
		//		base, '/' separator,
		//		path, '/' termination, '\0' termination...
		//
		cch = cchBase + 1 + cchPath + 2;
		if (!pwsz.resize(cch * sizeof(WCHAR)))
			return E_OUTOFMEMORY;

		scT = ScBuildChangeObject(m_pwszPath,
								  cchBase,
								  pwszPath,
								  cchPath,
								  MD_CHANGE_TYPE_SET_DATA,
								  &pmdrec->dwMDIdentifier,
								  pwsz.get(),
								  &cch,
								  &mdChObjW);

		//	Function above returns S_FALSE when it is short in buffer,
		//	otherwise it always returns S_OK. The buffer we gave is
		//	sufficient, so assert that we succeeded
		//
		Assert( S_OK == scT );
		CNotifSink::OnNotify( 1, &mdChObjW );
		goto ret;
	}

ret:
	return hr;
}

//	------------------------------------------------------------------------
//
//	HrDeleteMetaData()
//
HRESULT
CMDObjectHandle::HrDeleteMetaData( LPCWSTR pwszPath,
								   DWORD dwPropID,
								   DWORD dwDataType ) const
{
	HRESULT hr = S_OK;

	safe_revert sr(m_ecb.HitUser());

	//	METADATA_MASTER_ROOT_HANDLE not valid for this operation
	//
	Assert (METADATA_MASTER_ROOT_HANDLE != m_hMDObject);
	Assert (m_pMSAdminBase);

	hr = m_pMSAdminBase->DeleteData(m_hMDObject,
									pwszPath,
									dwPropID,
									dwDataType);
	if (ERROR_SUCCESS != hr)
	{
		if (!FAILED(hr))
		{
			hr = HRESULT_FROM_WIN32(hr);
		}

		MBTrace("MB: CMDObjectHandle::HrDeleteMetaData() - IMSAdminBase::DeleteData() failed 0x%08lX\n", hr );
	}
	else
	{
		//	Notify the sinks registered on this IMSAdminBase
		//	will not get notified, so we need to do all the
		//	invalidation ourselves. The only sink currently
		//	being registered is CChildVRCache.
		//
		SCODE scT;
		MD_CHANGE_OBJECT_W mdChObjW;
		UINT cchBase = 0;
		UINT cchPath = 0;

		CStackBuffer<WCHAR,MAX_PATH> pwsz;
		UINT cch;

		if (m_pwszPath)
		{
			cchBase = static_cast<UINT>(wcslen(m_pwszPath));
		}
		if (pwszPath)
		{
			cchPath = static_cast<UINT>(wcslen(pwszPath));
		}

		//	Allocate enough space for constructed path:
		//		base, '/' separator,
		//		path, '/' termination, '\0' termination...
		//
		cch = cchBase + 1 + cchPath + 2;
		if (!pwsz.resize(cch * sizeof(WCHAR)))
			return E_OUTOFMEMORY;

		scT = ScBuildChangeObject(m_pwszPath,
								  cchBase,
								  pwszPath,
								  cchPath,
								  MD_CHANGE_TYPE_DELETE_DATA,
								  &dwPropID,
								  pwsz.get(),
								  &cch,
								  &mdChObjW);

		//	Function above returns S_FALSE when it is short in buffer,
		//	otherwise it always returns S_OK. The buffer we gave is
		//	sufficient, so assert that we succeeded
		//
		Assert( S_OK == scT );
		CNotifSink::OnNotify( 1, &mdChObjW );
		goto ret;
	}

ret:

	return hr;
}

//	------------------------------------------------------------------------
//
//	Close()
//
VOID
CMDObjectHandle::Close()
{
	if ( METADATA_MASTER_ROOT_HANDLE != m_hMDObject )
	{
		Assert (m_pMSAdminBase);

		m_pMSAdminBase->CloseKey( m_hMDObject );
		m_hMDObject = METADATA_MASTER_ROOT_HANDLE;
		m_pwszPath = NULL;
	}
}

//	------------------------------------------------------------------------
//
//	~CMDObjectHandle()
//
CMDObjectHandle::~CMDObjectHandle()
{
	Close();
}

//	------------------------------------------------------------------------
//
//	HrReadMetaData()
//
//	Reads in the raw metadata from the metabase.
//
HrReadMetaData( const IEcb& ecb,
				IMSAdminBase * pMSAdminBase,
				LPCWSTR pwszMDPathAccess,
				LPCWSTR pwszMDPathOpen,
				LPBYTE * ppbData,
				DWORD * pdwDataSet,
				DWORD * pdwcRecords,
				LPCWSTR * ppwszMDPathDataSet )
{
	CMDObjectHandle mdoh(ecb);
	HRESULT hr;

	Assert( ppwszMDPathDataSet );

	//
	//	We should never open the root node of the metabase.
	//	It's prohibitively expensive.
	//
	Assert( pwszMDPathOpen );

	//
	//	If the open path is not the path we are trying to access
	//	then the former must be a proper prefix of the latter.
	//
	Assert( pwszMDPathAccess == pwszMDPathOpen ||
			!_wcsnicmp(pwszMDPathOpen, pwszMDPathAccess, wcslen(pwszMDPathOpen)) );

	//
	//	Open the specified "open" path.  Note that we do not simply open
	//	the full path because it may not exist and we don't necessarily
	//	want to try opening successive "parent" paths as each attempt
	//	costs us a trip through a global critical section in the metabase.
	//
	hr = mdoh.HrOpen( pMSAdminBase,
					  pwszMDPathOpen,
					  METADATA_PERMISSION_READ,
					  200 ); // timeout in msec (0.2 sec)

	if ( FAILED(hr) )
	{
		DebugTrace( "HrReadMetaData() - Error opening vroot for read 0x%08lX\n", hr );
		return hr;
	}

	//
	//	Get all of the metadata.  We should go through this loop at most twice --
	//	if our inital guess is too small to hold all the data the first time
	//	through, we'll go through it again with a buffer of the adequate size.
	//
	//	Note that we reserve space at the end of the buffer for a copy of the
	//	access path including a slash at the end (to make subpath detection
	//	easier).
	//
	DWORD cbBuf = CMetabase::CCH_AVG_CACHE_ENTRY * sizeof(WCHAR);
	DWORD cchMDPathAccess = static_cast<DWORD>(wcslen(pwszMDPathAccess) + 1);
	auto_heap_ptr<BYTE> pbBuf(static_cast<LPBYTE>(ExAlloc(cbBuf + CbSizeWsz(cchMDPathAccess))));

	//
	//	Get all the metadata.  Include inherited data (METADATA_INHERIT).
	//	Return whether the data for a given path was inherited (METADATA_ISINHERITED).
	//	If the path does not exist, return the inherited data
	//	anyway (METADATA_PARTIAL_PATH).
	//
	hr = mdoh.HrGetAllMetaData( (pwszMDPathOpen == pwszMDPathAccess) ?
									NULL :
									pwszMDPathAccess + wcslen(pwszMDPathOpen),
								METADATA_INHERIT |
								METADATA_ISINHERITED |
								METADATA_PARTIAL_PATH,
								ALL_METADATA,
								ALL_METADATA,
								pdwcRecords,
								pdwDataSet,
								cbBuf,
								pbBuf.get(),
								&cbBuf );

	if ( FAILED(hr) )
	{
		if ( HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) != hr )
		{
			DebugTrace( "HrReadMetaData() - Error getting all metadata 0x%08lX\n", hr );
			return hr;
		}

		//
		//	We couldn't read all the metadata because our initial
		//	guess was too small so allocate a buffer that is as
		//	big as the metabase told us we needed and use that
		//	buffer the next time around.
		//
		pbBuf.realloc(cbBuf + CbSizeWsz(cchMDPathAccess));
		hr = mdoh.HrGetAllMetaData( (pwszMDPathOpen == pwszMDPathAccess) ?
										NULL :
										pwszMDPathAccess + wcslen(pwszMDPathOpen),
									METADATA_INHERIT |
									METADATA_PARTIAL_PATH,
									ALL_METADATA,
									ALL_METADATA,
									pdwcRecords,
									pdwDataSet,
									cbBuf,
									pbBuf.get(),
									&cbBuf );

		if ( FAILED(hr) )
		{
			DebugTrace( "HrReadMetaData() - Error getting all metadata 0x%08lX\n", hr );
			return hr;
		}
	}

	//
	//	Copy the access path (including the null terminator) to the end
	//	of the buffer.
	//
	Assert( L'\0' == pwszMDPathAccess[cchMDPathAccess - 1] );
	memcpy( pbBuf + cbBuf, pwszMDPathAccess, cchMDPathAccess * sizeof(WCHAR) );

	//
	//	Tack on a final slash and null terminate.
	//	Note: pwszMDPathAccess may or may not already have a terminating slash
	//	** depending on how this function was called **
	//	(specifically, deep MOVE/COPY/DELETEs will have slashes on
	//	sub-directory URLs)
	//
	LPWSTR pwszT = reinterpret_cast<LPWSTR>(pbBuf + cbBuf + (cchMDPathAccess - 2) * sizeof(WCHAR));
	if ( L'/' != pwszT[0] )
	{
		pwszT[1] = L'/';
		pwszT[2] = L'\0';
	}

	//
	//	Return the path
	//
	*ppwszMDPathDataSet = reinterpret_cast<LPWSTR>(pbBuf.get() + cbBuf);

	//
	//	And the data
	//
	*ppbData = pbBuf.relinquish();
	return S_OK;
}

//	========================================================================
//
//	CLASS CMDData
//

//	------------------------------------------------------------------------
//
//	CMDData::CMDData()
//
CMDData::CMDData( LPCWSTR pwszMDPathDataSet,
				  DWORD dwDataSet ) :
    m_pwszMDPathDataSet(pwszMDPathDataSet),
	m_dwDataSet(dwDataSet),
								// Defaults not handled by auto_xxx classes:
	m_pwszDefaultDocList(NULL), //   No default doc list
	m_pwszVRUserName(NULL),     //   No VRoot user name
	m_pwszVRPassword(NULL),     //   No VRoot password
	m_pwszExpires(NULL),        //   No expiration
	m_pwszBindings(NULL),		//   No custom bindings
	m_pwszVRPath(NULL),			//   No VRoot physical path
    m_dwAccessPerms(0),         //   Deny all access
	m_dwDirBrowsing(0),         //   No default dir browsing
	m_fFrontPage(FALSE),        //   No FrontPage authoring
	m_cbIPRestriction(0),		//    --
	m_pbIPRestriction(NULL),	//    --
    m_fHasApp(FALSE),           //   No registered app
    m_dwAuthorization(0),		//	 No specific authorization method
	m_dwIsIndexed(1)			//   Indexing is on by default
{
	Assert(pwszMDPathDataSet);
	Assert(dwDataSet != 0);
	m_cRef = 1;
}

//	------------------------------------------------------------------------
//
//	CMDData::~CMDData()
//
CMDData::~CMDData()
{
}

//	------------------------------------------------------------------------
//
//	CMDData::FInitialize()
//
//	Populates a metadata object from metadata obtained through an accessor.
//
BOOL
CMDData::FInitialize( auto_heap_ptr<BYTE>& pbData,
					  DWORD dwcMDRecords )
{
	Assert(!IsBadReadPtr(pbData.get(), dwcMDRecords * sizeof(METADATA_RECORD)));

	for ( DWORD iRec = 0; iRec < dwcMDRecords; iRec++ )
	{
		//
		//	Locate the metadata record and its data.  Note that the
		//	pbMDData field of METADATA_RECORD is actually an offset
		//	to the data -- not a pointer to it -- from the start of
		//	the buffer.
		//
		const METADATA_GETALL_RECORD& mdrec =
			reinterpret_cast<const METADATA_GETALL_RECORD *>(pbData.get())[iRec];

		LPVOID pvRecordData =
			pbData.get() + mdrec.dwMDDataOffset;

		//
		//	!!!IMPORTANT!!! The list of identifiers below must be kept up to date
		//	with the list in FHasCachedIDs().
		//
		switch ( mdrec.dwMDIdentifier )
		{
			case MD_IP_SEC:
			{
				Assert( mdrec.dwMDDataTag == NULL );
				if ( mdrec.dwMDDataType != BINARY_METADATA )
					return FALSE;

				m_cbIPRestriction = mdrec.dwMDDataLen;
				m_pbIPRestriction = static_cast<LPBYTE>(pvRecordData);
				break;
			}

			case MD_ACCESS_PERM:
			{
				Assert( mdrec.dwMDDataTag == NULL );
				if ( mdrec.dwMDDataType != DWORD_METADATA )
					return FALSE;

				m_dwAccessPerms = *static_cast<LPDWORD>(pvRecordData);
				break;
			}

			case MD_IS_CONTENT_INDEXED:
			{
				Assert( mdrec.dwMDDataTag == NULL );
				if ( mdrec.dwMDDataType != DWORD_METADATA )
					return FALSE;

				m_dwIsIndexed = *static_cast<LPDWORD>(pvRecordData);
				break;
			}

			case MD_FRONTPAGE_WEB:
			{
				Assert( mdrec.dwMDDataTag == NULL );
				if ( mdrec.dwMDDataType != DWORD_METADATA )
					return FALSE;

				//
				//	Set the frontpage flag if MD_FRONTPAGE_WEB is
				//	explicitly set on this metabase node and not
				//	inherited.
				//
				m_fFrontPage = *static_cast<LPDWORD>(pvRecordData) &&
							   !(mdrec.dwMDAttributes & METADATA_ISINHERITED);
				break;
			}

			case MD_DIRECTORY_BROWSING:
			{
				Assert( mdrec.dwMDDataTag == NULL );
				if ( mdrec.dwMDDataType != DWORD_METADATA )
					return FALSE;

				m_dwDirBrowsing = *static_cast<LPDWORD>(pvRecordData);
				break;
			}

			case MD_AUTHORIZATION:
			{
				Assert( mdrec.dwMDDataTag == NULL );
				if ( mdrec.dwMDDataType != DWORD_METADATA )
					return FALSE;

				m_dwAuthorization = *static_cast<LPDWORD>(pvRecordData);
				break;
			}

			case MD_DEFAULT_LOAD_FILE:
			{
				Assert( mdrec.dwMDDataTag == NULL );
				if ( mdrec.dwMDDataType != STRING_METADATA )
					return FALSE;

				m_pwszDefaultDocList = static_cast<LPWSTR>(pvRecordData);
				break;
			}

			case MD_CUSTOM_ERROR:
			{
				Assert( mdrec.dwMDDataTag == NULL );
				if ( mdrec.dwMDDataType != MULTISZ_METADATA )
					return FALSE;

				m_pCustomErrorMap.take_ownership(
					NewCustomErrorMap(static_cast<LPWSTR>(pvRecordData)));

				//
				//	Bail if we cannot create the map.
				//	This means the record data was malformed.
				//
				if ( !m_pCustomErrorMap.get() )
					return FALSE;

				break;
			}

			case MD_MIME_MAP:
			{
				Assert( mdrec.dwMDDataTag == NULL );
				if ( mdrec.dwMDDataType != MULTISZ_METADATA )
					return FALSE;

				m_pContentTypeMap.take_ownership(
					NewContentTypeMap(static_cast<LPWSTR>(pvRecordData),
									  !!(mdrec.dwMDAttributes & METADATA_ISINHERITED)));

				//
				//	Bail if we cannot create the map.
				//	This means the record data was malformed.
				//
				if ( !m_pContentTypeMap.get() )
					return FALSE;

				break;
			}

			case MD_SCRIPT_MAPS:
			{
				Assert( mdrec.dwMDDataTag == NULL );
				if ( mdrec.dwMDDataType != MULTISZ_METADATA )
					return FALSE;

				m_pScriptMap.take_ownership(
					NewScriptMap(static_cast<LPWSTR>(pvRecordData)));

				//
				//	Bail if we cannot create the map.
				//	This means the record data was malformed.
				//
				if ( !m_pScriptMap.get() )
					return FALSE;

				break;
			}

			case MD_APP_ISOLATED:
			{
				//
				//	If this property exists on this node at all
				//	(i.e. it is not inherited) then we want to
				//	know, regardless of its value.
				//
				if ( mdrec.dwMDAttributes & METADATA_ISINHERITED )
					m_fHasApp = TRUE;

				break;
			}

			case MD_VR_USERNAME:
			{
				if ( mdrec.dwMDDataType != STRING_METADATA )
					return FALSE;

				m_pwszVRUserName = static_cast<LPWSTR>(pvRecordData);
				break;
			}

			case MD_VR_PASSWORD:
			{
				if ( mdrec.dwMDDataType != STRING_METADATA )
					return FALSE;

				m_pwszVRPassword = static_cast<LPWSTR>(pvRecordData);
				break;
			}

			case MD_HTTP_EXPIRES:
			{
				Assert( mdrec.dwMDDataTag == NULL );
				if ( mdrec.dwMDDataType != STRING_METADATA )
					return FALSE;

				m_pwszExpires = static_cast<LPWSTR>(pvRecordData);
				break;
			}

			case MD_SERVER_BINDINGS:
			{
				Assert( mdrec.dwMDDataTag == NULL );
				if ( mdrec.dwMDDataType != MULTISZ_METADATA )
					return FALSE;

				m_pwszBindings = static_cast<LPWSTR>(pvRecordData);
				break;
			}

			case MD_VR_PATH:
			{
				Assert( mdrec.dwMDDataTag == NULL );
				if ( mdrec.dwMDDataType != STRING_METADATA )
					return FALSE;

				m_pwszVRPath = static_cast<LPWSTR>(pvRecordData);
				break;
			}

			//
			//$REVIEW	Do we need to worry about any of these?
			//
			case MD_VR_PASSTHROUGH:
			case MD_SSL_ACCESS_PERM:
			default:
			{
				break;
			}
		}
	}

	//
	//	If all goes well we take ownership of the data buffer passed in.
	//
	m_pbData = pbData.relinquish();
	m_dwcMDRecords = dwcMDRecords;
	return TRUE;
}

//	========================================================================
//
//	CLASS CMetabase
//

//	------------------------------------------------------------------------
//
//	CMetabase::~CMetabase()
//
CMetabase::~CMetabase()
{
	//
	//	If we ever advised a notification sink then unadvise it now.
	//
	if ( m_dwSinkRegCookie )
	{
		//
		//	Unadvise the sink
		//
		UnadviseSink(*m_pMSAdminBase.get(), m_dwSinkRegCookie);

		//
		//	Wait for the sink to shutdown
		//
		m_evtSinkShutdown.Wait();
	}
}

//	------------------------------------------------------------------------
//
//	CMetabase::FInitialize()
//
BOOL
CMetabase::FInitialize()
{
	HRESULT hr = S_OK;

	//	Init the cache
	//
	if ( !m_cache.FInit() )
	{
		hr = E_OUTOFMEMORY;
		goto ret;
	}

	//	Init its reader/writer lock
	//
	if ( !m_mrwCache.FInitialize() )
	{
		hr = E_OUTOFMEMORY;
		goto ret;
	}

	//	Create an instance of the com-base metabase interface.
	//	Again, we expect that somebody above us has already done
	//	this, so it should be fairly cheap as well.
	//
	//	Note that we do not init COM at any point.  IIS should
	//	have already done that for us.
	//
	hr = CoCreateInstance (CLSID_MSAdminBase,
						   NULL,
						   CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
						   IID_IMSAdminBase,
						   (LPVOID *)m_pMSAdminBase.load());
	if ( FAILED(hr) )
	{
		DebugTrace( "CMetabase::FInitialize() - CoCreateInstance(CLSID_MDCOM) failed 0x%08lX\n", hr );
		goto ret;
	}

	//	Register for metabase change notifications
	//
	{
		auto_ref_ptr<CNotifSink> pSinkNew;

		//	First, set up an empty security descriptor and attributes
		//	so that the event can be created with no security
		//	(i.e. accessible from any security context).
		//
		SECURITY_DESCRIPTOR* psdAllAccess = PsdCreateWorld();
		SECURITY_ATTRIBUTES saAllAccess;

		saAllAccess.nLength              = sizeof(saAllAccess);
		saAllAccess.lpSecurityDescriptor = psdAllAccess;
		saAllAccess.bInheritHandle       = FALSE;

		//
		//	Create the sink shutdown event
		//
		if ( !m_evtSinkShutdown.FCreate( &saAllAccess, // no security
										 TRUE, // manual access
										 FALSE, // initially non-signalled
										 NULL ))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			DebugTrace( "CMetabase::FInitialize() - m_evtSinkShutdown.FCreate() failed 0x%08lX\n", hr );
			goto ret;
		}

		//
		//	Create the sink
		//
		pSinkNew.take_ownership(new CNotifSink(m_evtSinkShutdown));

		//
		//	Advise the sink
		//
		hr = HrAdviseSink(*m_pMSAdminBase.get(),
						  pSinkNew.get(),
						  &m_dwSinkRegCookie);
		if ( FAILED(hr) )
		{
			DebugTrace( "CMetabase::FInitialize() - HrAdviseSink() failed 0x%08lX\n", hr );
			goto ret;
		}

		LocalFree(psdAllAccess);
	}

ret:
	return SUCCEEDED(hr);
}

//	------------------------------------------------------------------------
//
//	CMetabase::DwChangeNumber()
//

DWORD
CMetabase::DwChangeNumber(const IEcb * pecb)
{
	Assert(pecb);
	
	DWORD dw = 0;
	safe_revert sr(pecb->HitUser());

	Assert(m_pMSAdminBase.get());

	//  Note:  this function can fail.  We are not checking the return value
	//  because we need to generate an etag regardless of failure.  
	//
	(void) m_pMSAdminBase->GetSystemChangeNumber(&dw);
	return dw;
}


//	------------------------------------------------------------------------
//
//	CMetabase::COpGatherCullInfo::operator()
//
BOOL
CMetabase::COpGatherCullInfo::operator()( const DwordKey& key,
										  const auto_ref_ptr<CMDData>& pMDData )
{
	//
	//	Gather and reset the access count of the current metadata object
	//
	m_rgci[m_ici].dwDataSet = key.Dw();
	m_rgci[m_ici].dwcHits   = pMDData->LFUData().DwGatherAndResetHitCount();
	++m_ici;

	//
	//	ForEach() operators can cancel the iteration by returning FALSE.
	//	We always want to iterate over everything so return TRUE
	//
	return TRUE;
}

//	------------------------------------------------------------------------
//
//	SCullInfo::Compare()
//
//	Cull info comparison function used by qsort() to sort an array
//	of SCullInfo structures.
//
int __cdecl
SCullInfo::Compare( const SCullInfo * pCullInfo1,
					const SCullInfo * pCullInfo2 )
{
	return static_cast<int>(pCullInfo1->dwcHits - pCullInfo2->dwcHits);
}

//	------------------------------------------------------------------------
//
//	CMetabase::CullCacheEntries()
//
//	Called by HrCacheData() when the number of entries in the metabase
//	cache reaches a preset threshold.  This function removes those entries
//	that have been used least frequently since the last time the cache
//	was culled.
//
VOID
CMetabase::CullCacheEntries()
{
	CStackBuffer<SCullInfo,128> rgci;
	int cCacheEntries;

	//
	//	Gather cull info for all of the cache entries.  We need to do
	//	this in a read block so that the cache stays stable (i.e. does
	//	not have entries added or removed) while we are in the ForEach()
	//	operation.
	//
	{
		//
		//	Lock out writers -- anyone trying to add or remove cache entries
		//
		CSynchronizedReadBlock sb(m_mrwCache);

		//
		//	Now that the count of cache entries is stable (because
		//	we are in the read block) check once again that we
		//	are over the culling threshold.  If we are not (because
		//	enough entries were removed before we got the lock) then
		//	don't cull.
		//
		cCacheEntries = m_cache.CItems();
		if ( cCacheEntries < C_CULL_CACHE_ENTRIES )
			return;

		//
		//	We need to cull.  Run through the cache gathering the access
		//	frequency information for each entry.
		//
		if (!rgci.resize(cCacheEntries * sizeof(SCullInfo)))
			return;

		COpGatherCullInfo opGatherCullInfo(rgci.get());
		m_cache.ForEach( opGatherCullInfo );
	}

	//
	//	Now that we are out of the reader block, cache entries can be
	//	freely added and removed, so there's no guarantee that any of
	//	the cull info we just gathered is still accurate at this point.
	//	It's important to remember that culling is a hint-driven process.
	//	More strict methods would require holding locks longer, increasing
	//	the probability of contention.
	//
	//
	//	Sort the cull info by increasing number of cache entry hits.
	//
	qsort( rgci.get(),
		   cCacheEntries,
		   sizeof(SCullInfo),
		   reinterpret_cast<int (__cdecl *)(const void *, const void *)>(SCullInfo::Compare) );

	//	Run through the sorted cull info and cull entries from the cache
	//
	Assert( cCacheEntries >= C_CULL_CACHE_ENTRIES );
	{
		CSynchronizedWriteBlock sb(m_mrwCache);

		for ( int iCacheEntry = 0;
			  iCacheEntry < C_CULL_CACHE_ENTRIES;
			  iCacheEntry++ )
		{
			m_cache.Remove( DwordKey(rgci[iCacheEntry].dwDataSet) );
		}
	}
}

//	------------------------------------------------------------------------
//
//	CMetabase::HrCacheData()
//
//	Add a new cache entry for the metadata for the object at the given
//	access path.
//
HRESULT
CMetabase::HrCacheData( const IEcb& ecb,
					    LPCWSTR pwszMDPathAccess,
						LPCWSTR pwszMDPathOpen,
						CMDData ** ppMDData )
{
	auto_ref_ptr<CMDData> pMDDataRet;
	auto_heap_ptr<BYTE> pbData;
	LPCWSTR pwszMDPathDataSet;
	DWORD dwDataSet;
	DWORD dwcMDRecords;
	HRESULT hr = S_OK;

	//
	//	Read in the raw metadata from the metabase
	//
	hr = HrReadMetaData( ecb,
						 m_pMSAdminBase.get(),
						 pwszMDPathAccess,
						 pwszMDPathOpen,
						 &pbData,
						 &dwDataSet,
						 &dwcMDRecords,
						 &pwszMDPathDataSet );
	if ( FAILED(hr) )
	{
		DebugTrace( "CMetabase::HrCacheData() - HrReadMetaData() failed 0x%08lX\n", hr );
		goto ret;
	}

	//
	//	Digest it into a new metadata object
	//
	pMDDataRet.take_ownership(new CMDData(pwszMDPathDataSet, dwDataSet));
	if ( !pMDDataRet->FInitialize(pbData, dwcMDRecords) )
	{
		//
		//$REVIEW	We should probably log this in the event log since
		//$REVIEW	there is no other indication to the server admin
		//$REVIEW	what is wrong and this is something that an admin
		//$REVIEW	could fix.
		//
		hr = E_INVALIDARG;
		DebugTrace( "CMetabase::HrCacheData() - Metadata is malformed\n" );
		goto ret;
	}

	//
	//	Add the new data object to the cache.  Note: we don't care
	//	if we can't add to the cache.  We already have a metadata
	//	object that we can return to the caller.
	//
	{
		CSynchronizedWriteBlock sb(m_mrwCache);

		if ( !m_cache.Lookup( DwordKey(dwDataSet) ) )
			(void) m_cache.FAdd( DwordKey(dwDataSet), pMDDataRet );
	}

	//
	//	If the cache size has exceeded the expiration threshold then
	//	start culling entries until it goes below the minimum
	//	threshold.  The ICE ensures that only the first thread to
	//	see the threshold exceeded will do the culling.
	//
	if ( (m_cache.CItems() > C_MAX_CACHE_ENTRIES) &&
		 TRUE == InterlockedCompareExchange(&m_lfCulling, TRUE, FALSE) )
	{
		//
		//$REVIEW	Consider culling asynchronously.  I believe the current
		//$REVIEW	mechanism still allows us to hang onto a very large
		//$REVIEW	cache which is never reduced if we get hit with a
		//$REVIEW	burst of new entries simultaneously.
		//
		CullCacheEntries();

		m_lfCulling = FALSE;
	}

	Assert( pMDDataRet.get() );
	*ppMDData = pMDDataRet.relinquish();

ret:

	return hr;
}

//	------------------------------------------------------------------------
//
//	CMetabase::HrGetData()
//
//	Fetch data from the metabase cache.  See comment in \cal\src\inc\davmb.h
//	for the distinction between pszMDPathAccess and pszMDPathOpen.
//
HRESULT
CMetabase::HrGetData( const IEcb& ecb,
					  LPCWSTR pwszMDPathAccess,
					  LPCWSTR pwszMDPathOpen,
					  IMDData ** ppMDData )
{
	auto_ref_ptr<CMDData> pMDDataRet;
	DWORD dwDataSet;
	HRESULT hr;

	//	Fetch the data set number for this path directly from the metabase.
	//	Items in the metabase with the same data set number have the same data.
	//
	{
		safe_revert sr(ecb.HitUser());

		hr = m_pMSAdminBase->GetDataSetNumber(METADATA_MASTER_ROOT_HANDLE,
											  pwszMDPathAccess,
											  &dwDataSet);
		if ( FAILED(hr) )
		{
			MBTrace( "CMetabase::HrGetData() - GetDataSetNumber() failed 0x%08lX\n", hr );
			return hr;
		}

		MBTrace("MB: CMetabase::HrGetData() - TID %3d: Retrieved data set number 0x%08lX for path '%S'\n", GetCurrentThreadId(), dwDataSet, pwszMDPathAccess );
	}

	//
	//	If we don't care about the exact path then look for any entry
	//	in the cache with this data set number.  If we do care then
	//	look for an entry in the cache with this data set number AND
	//	a matching path.
	//
	//	Note: a pointer comparison here is sufficient.  Callers are expected
	//	to use the single path version of HrMDGetData() if they want
	//	an metadata for an exact path.  That version passes the same
	//	string for both pszMDPathAccess and pszMDPathOpen.
	//
	//	Why does anyone care about an exact path match?  Inheritance.
	//
	{
		CSynchronizedReadBlock sb(m_mrwCache);

		if (pwszMDPathAccess == pwszMDPathOpen)
		{
			MBTrace("MB: CMetabase::HrGetData() - TID %3d: Exact path match! Trying to get CMDData, dataset 0x%08lX\n", GetCurrentThreadId(), dwDataSet);

			COpMatchExactPath(pwszMDPathAccess).Invoke(m_cache, dwDataSet, &pMDDataRet);
		}
		else
		{
			MBTrace("MB: CMetabase::HrGetData() - TID %3d: Not exact path match! Trying to get CMDData, dataset 0x%08lX\n", GetCurrentThreadId(), dwDataSet);

			(void) m_cache.FFetch( dwDataSet, &pMDDataRet );
		}
	}

	if ( pMDDataRet.get() )
	{
		MBTrace("MB: CMetabase::HrGetData() - TID %3d: Retrieved cached CMDData, data set number 0x%08lX, path '%S'\n", GetCurrentThreadId(), dwDataSet, pwszMDPathAccess );

		pMDDataRet->LFUData().Touch();
	}
	else
	{

		MBTrace("MB: CMetabase::HrGetData() - TID %3d: No cached data CMDData, data set number 0x%08lX, path '%S'\n", GetCurrentThreadId(), dwDataSet, pwszMDPathAccess );

		//
		//	We didn't find an entry in the cache, so create one.
		//
		//	Note: nothing here prevents multiple threads from getting here
		//	simultaneously and attempting to cache duplicate entries.  That
		//	is done within HrCacheData().
		//
		hr = HrCacheData( ecb,
						  pwszMDPathAccess,
						  pwszMDPathOpen,
						  pMDDataRet.load() );
		if ( FAILED(hr) )
		{
			MBTrace( "MB: CMetabase::HrGetData() - HrCacheData() failed 0x%08lX\n", hr );
			return hr;
		}
	}

	//
	//	Return the data object
	//
	Assert( pMDDataRet.get() );
	*ppMDData = pMDDataRet.relinquish();
	return S_OK;
}

//	------------------------------------------------------------------------
//
//	CMetabase::HrOpenObject()
//
HRESULT
CMetabase::HrOpenObject( LPCWSTR pwszMDPath,
						 DWORD dwAccess,
						 DWORD dwMsecTimeout,
						 CMDObjectHandle * pmdoh )
{
	Assert(pwszMDPath);
	Assert(pmdoh);

	return pmdoh->HrOpen( m_pMSAdminBase.get(),
						  pwszMDPath,
						  dwAccess,
						  dwMsecTimeout );
}

//	------------------------------------------------------------------------
//
//	CMetabase::HrOpenLowestNodeObject()
//

HRESULT
CMetabase::HrOpenLowestNodeObject( LPWSTR pwszMDPath,
								   DWORD dwAccess,
								   LPWSTR * ppwszMDPath,
								   CMDObjectHandle * pmdoh )
{
	Assert(pwszMDPath);
	Assert(ppwszMDPath);
	Assert(pmdoh);

	return pmdoh->HrOpenLowestNode( m_pMSAdminBase.get(),
									pwszMDPath,
									dwAccess,
									ppwszMDPath );
}

//	------------------------------------------------------------------------
//
//	CMetabase::HrIsAuthorViaFrontPageNeeded()
//
//	Description: Function goes directly to the metabase and checks if
//				 the given path is configured as "FrontPageWeb". We need
//				 to do that via direct read from the metabase rather than
//				 going through dataset cache, as as that does not work very
//				 well due to the fact, that we are reading inherited
//				 metadata and get stuck with it.
//	Parameters:
//
//	ecb			   - interface to ecb object, that will be needed for
//					 fetching the impersonation token for that we will need
//					 to impersonate as as soon as read from metabase is finished
//	pwszMDPath	   - metabase path that we want to check out
//	pfFrontPageWeb - pointer to the booleanin which the result of operation is
//					 returned
//
HRESULT
CMetabase::HrIsAuthorViaFrontPageNeeded(const IEcb& ecb,
										LPCWSTR pwszMDPath,
										BOOL * pfFrontPageWeb)
{
	HRESULT hr = S_OK;

	CMDObjectHandle mdoh(ecb, m_pMSAdminBase.get());

	BOOL fFrontPageWeb = FALSE;
	DWORD cbData = sizeof(BOOL);

	METADATA_RECORD mdrec;

	Assert( pwszMDPath );
	Assert( pfFrontPageWeb );

	//	Assume that we do not have "FrontPageWeb" set to TRUE
	//
	*pfFrontPageWeb = FALSE;

	//	We want just explicitely set data, not inherited one
	//
	mdrec.dwMDIdentifier = MD_FRONTPAGE_WEB;
	mdrec.dwMDAttributes = METADATA_NO_ATTRIBUTES;
	mdrec.dwMDUserType   = IIS_MD_UT_SERVER;
	mdrec.dwMDDataType   = DWORD_METADATA;
	mdrec.dwMDDataLen    = cbData;
	mdrec.pbMDData       = reinterpret_cast<PBYTE>(&fFrontPageWeb);

	hr = mdoh.HrGetMetaData(pwszMDPath,
							&mdrec,
							&cbData);
	if (FAILED(hr))
	{
		MBTrace( "MB: CMetabase::HrIsAuthorViaFrontPageNeeded() - CMDObjectHandle::HrGetMetaData() failed 0x%08lX\n", hr );
		goto ret;
	}

	//	If we succeeded then we should have the value in our hands
	//
	*pfFrontPageWeb = fFrontPageWeb;

ret:

	return hr;
}

//	The way IID_IMSAdminBaseSinkW is defined in IADMW.H does
//	not work well with EXO.  So it needs to be redefined
//	here in such a way that it will work.
//
const IID IID_IMSAdminBaseSinkW = {

	0xa9e69612,
	0xb80d,
	0x11d0,
	{
		0xb9, 0xb9, 0x0, 0xa0,
		0xc9, 0x22, 0xe7, 0x50
	}
};

//	------------------------------------------------------------------------
//
//	FHasCachedIDs()
//
//	Returns TRUE if any one of the IDs rgdwDataIDs is one of the IDs that
//	we care about in CMDData::FInitialize().
//
//	!!!IMPORTANT!!! The list of IDs in this function *MUST* be kept up to
//	date with the cases in CMDData::FInitialize().
//
__inline BOOL
FHasCachedIDs( DWORD dwcDataIDs,
			   DWORD * rgdwDataIDs )
{
	for ( DWORD iID = 0; iID < dwcDataIDs; iID++ )
	{
		switch ( rgdwDataIDs[iID] )
		{
			case MD_IP_SEC:
			case MD_ACCESS_PERM:
			case MD_IS_CONTENT_INDEXED:
			case MD_FRONTPAGE_WEB:
			case MD_DIRECTORY_BROWSING:
			case MD_AUTHORIZATION:
			case MD_DEFAULT_LOAD_FILE:
			case MD_CUSTOM_ERROR:
			case MD_MIME_MAP:
			case MD_SCRIPT_MAPS:
			case MD_APP_ISOLATED:
			case MD_VR_USERNAME:
			case MD_VR_PASSWORD:
			case MD_HTTP_EXPIRES:
			case MD_SERVER_BINDINGS:
				return TRUE;
		}
	}

	return FALSE;
}

//	------------------------------------------------------------------------
//
//	CMetabase::COpNotify::operator()
//
BOOL
CMetabase::COpNotify::operator()( const DwordKey& key,
								  const auto_ref_ptr<CMDData>& pMDData )
{
	//
	//	If the path for this cache entry is a child of the path
	//	being notified, then set this entry's data set ID in the
	//	array of IDs to blow from the cache.
	//
	if ( !_wcsnicmp( m_pwszMDPathNotify,
					 pMDData->PwszMDPathDataSet(),
					 m_cchMDPathNotify ) )
	{
		Assert (m_iCacheEntry < m_cCacheEntry);
		m_rgdwDataSets[m_iCacheEntry] = pMDData->DwDataSet();
		m_fDataSetsFlagged = TRUE;
	}

	++m_iCacheEntry;

	//
	//	ForEach() operators can cancel the iteration by returning FALSE.
	//	We always want to iterate over everything so return TRUE
	//
	return TRUE;
}

//	------------------------------------------------------------------------
//
//	CMetabase::OnNotify()
//
VOID
CMetabase::OnNotify( DWORD cCO,
					 MD_CHANGE_OBJECT_W rgCO[] )
{
	INT cCacheEntries;
	CStackBuffer<DWORD> rgdwDataSets;
	BOOL fDataSetsFlagged;

	//
	//	Grab a read lock on the cache and go through it
	//	figuring out which items we want to blow away.
	//
	{
		CSynchronizedReadBlock sb(m_mrwCache);

		cCacheEntries = m_cache.CItems();
		if (!rgdwDataSets.resize(sizeof(DWORD) * cCacheEntries))
			return;

		memset(rgdwDataSets.get(), 0, sizeof(DWORD) * cCacheEntries);
		COpNotify opNotify(cCacheEntries, rgdwDataSets.get());
		for ( DWORD iCO = 0; iCO < cCO; iCO++ )
		{
			LPWSTR pwszMDPath = reinterpret_cast<LPWSTR>(rgCO[iCO].pszMDPath);

			//	Quick litmus test: ignore any change that is not
			//	related to anything that we would ever cache -- i.e.
			//	anything that is not one of the following:
			//
			//	- The global mimemap (LM/MimeMap)
			//	- Anything in the W3SVC tree (LM/W3SVC/...)
			//
			//	Also ignore MD_CHANGE_TYPE_ADD_OBJECT notifications --
			//	even in combination with other notifications.  We simply
			//	don't care when something is added because we always
			//	read from the metabase when we don't find an item in
			//	the cache.
			//
			//	Finally, ignore changes to any data that isn't interesting
			//	to us -- i.e. that we don't cache.
			//
			if ( (!_wcsnicmp(gc_wsz_Lm_MimeMap, pwszMDPath, gc_cch_Lm_MimeMap) ||
				  !_wcsnicmp(gc_wsz_Lm_W3Svc, pwszMDPath, gc_cch_Lm_W3Svc - 1)) &&

				 !(rgCO[iCO].dwMDChangeType & MD_CHANGE_TYPE_ADD_OBJECT) &&

				 FHasCachedIDs( rgCO[iCO].dwMDNumDataIDs,
								rgCO[iCO].pdwMDDataIDs ) )
			{
				//
				//	Flag each entry in the cache whose data set corresponds
				//	to a path that is a child of the one being notified.
				//
				MBTrace ("MB: cache: flagging '%S' as dirty\n", pwszMDPath);
				opNotify.Configure( pwszMDPath );

				m_cache.ForEach( opNotify );
			}
		}

		fDataSetsFlagged = opNotify.FDataSetsFlagged();
	}

	//
	//	If any data sets were flagged in our pass above then
	//	grab a write lock now and blow `em away.
	//
	//	Note: we don't care about any change to the cache between the
	//	time we sweep above and now.  If data sets are culled,
	//	and even re-added, between then and now, that's fine.
	//	The worst thing that this does is cause them to be
	//	faulted in again.  On the flip side, any new data sets
	//	brought into the cache after our pass above by definition
	//	has more recent data, so there is no possibility of
	//	missing any cached entries and ending up with stale data.
	//
	if ( fDataSetsFlagged )
	{
		CSynchronizedWriteBlock sb(m_mrwCache);

		for ( INT iCacheEntry = 0;
			  iCacheEntry < cCacheEntries;
			  iCacheEntry++ )
		{
			if ( rgdwDataSets[iCacheEntry] )
				m_cache.Remove( DwordKey(rgdwDataSets[iCacheEntry]) );
		}
	}
}

//	========================================================================
//
//	CLASS CNotifSink
//

//	------------------------------------------------------------------------
//
//	CNotifSink::SinkNotify()
//
//	Metabase change notification callback
//
HRESULT STDMETHODCALLTYPE
CNotifSink::SinkNotify(/* [in] */ DWORD dwMDNumElements,
					   /* [size_is][in] */ MD_CHANGE_OBJECT_W __RPC_FAR pcoChangeList[  ])
{
	OnNotify( dwMDNumElements,
			  pcoChangeList );

	return S_OK;
}

VOID
CNotifSink::OnNotify( DWORD cCO,
					  MD_CHANGE_OBJECT_W rgCO[] )
{
	//	Trace out the information with which we have been called
	//
#ifdef DBG

	MBTrace("MB: CNotifSink::OnNotify() - TID %3d: MD_CHANGE_OBJECT_W array length 0x%08lX\n", GetCurrentThreadId(), cCO );

	for ( DWORD idwElem = 0; idwElem < cCO; idwElem++ )
	{
		MBTrace("   Element %d:\n", idwElem );
		MBTrace("      pszMDPath '%S'\n", rgCO[idwElem].pszMDPath );
		MBTrace("      dwMDChangeType 0x%08lX\n", rgCO[idwElem].dwMDChangeType );
		MBTrace("      dwMDNumDataIDs 0x%08lX\n", rgCO[idwElem].dwMDNumDataIDs );
		for (DWORD idwID = 0; idwID < rgCO[idwElem].dwMDNumDataIDs; idwID++)
		{
			MBTrace("         pdwMDDataIDs[%d] is 0x%08lX\n", idwID, rgCO[idwElem].pdwMDDataIDs[idwID] );
		}
	}

#endif

	CMetabase::Instance().OnNotify( cCO,
									rgCO );

	CChildVRCache::Instance().OnNotify( cCO,
										rgCO );

}

//	========================================================================
//
//	FREE Functions
//

BOOL
FMDInitialize()
{
	//	Instantiate the CMetabase object and initialize it.
	//	Note that if initialization fails, we don't destroy
	//	the instance.  MDDeinitialize() must still be called.
	//
	return CMetabase::CreateInstance().FInitialize();
}

VOID
MDDeinitialize()
{
	CMetabase::DestroyInstance();
}

//	------------------------------------------------------------------------
//
//	In the future we might need Copy/Rename/Delete operations
//	on metabase objects.
//	For Copy following steps should apply:
//		a) Lock dst
//		b) Kick dst and children out of cache
//		c) Copy the raw metadata
//		d) Unlock dst
//		e) Send update notifications
//
//	For Rename:
//		a) Lock common parent of src and dst
//		b) Kick dst and children out of cache
//		c) Rename src to dst
//		d) Kick src and children out of cache
//		e) Unlock common parent of src and dst
//		f) Send update notifications
//	For Delete:
//		a) Lock path
//		b) Kick path and children out of cache
//		c) Unlock path
//		d) Send update notifications

//	------------------------------------------------------------------------
//
//	HrMDGetData()
//
//	Intended primarily for use by impls.  This call fetches the metadata
//	for the specified URI.  If the URI is the request URI then this
//	function uses the copy of the metadata cached on the ecb.  This saves
//	a cache lookup (and read lock) in the majority of cases.
//
HRESULT
HrMDGetData( const IEcb& ecb,
			 LPCWSTR pwszURI,
			 IMDData ** ppMDData )
{
	SCODE sc = S_OK;
	auto_heap_ptr<WCHAR> pwszMDPathURI;
	auto_heap_ptr<WCHAR> pwszMDPathOpenOnHeap;
	LPWSTR pwszMDPathOpen;

	//
	//	If the URI is the request URI then we already have the data cached.
	//
	//	Note that we only test for pointer equality here because
	//	typically callers will pass in THE request URI from
	//	the ECB rather than a copy of it.
	//
	if ( ecb.LpwszRequestUrl() == pwszURI )
	{
		*ppMDData = &ecb.MetaData();

		Assert (*ppMDData);
		(*ppMDData)->AddRef();

		goto ret;
	}

	//
	//	Map the URI to its equivalent metabase path, and make sure
	//	the URL is stripped before we call into the MDPath processing
	//
	Assert (pwszURI == PwszUrlStrippedOfPrefix (pwszURI));

	pwszMDPathURI = static_cast<LPWSTR>(ExAlloc(CbMDPathW(ecb, pwszURI)));
	if (NULL == pwszMDPathURI.get())
	{
		sc = E_OUTOFMEMORY;
		goto ret;
	}

	MDPathFromURIW(ecb, pwszURI, pwszMDPathURI);
	pwszMDPathOpen = const_cast<LPWSTR>(ecb.PwszMDPathVroot());

	//	If the URI requested is in NOT in the current request's vroot,
	//	start the metabase search from the virtual server root.
	//
	if (_wcsnicmp(pwszMDPathURI, pwszMDPathOpen, wcslen(pwszMDPathOpen)))
	{
		pwszMDPathOpenOnHeap = static_cast<LPWSTR>(ExAlloc(CbMDPathW(ecb, L"")));
		if (NULL == pwszMDPathOpenOnHeap.get())
		{
			sc = E_OUTOFMEMORY;
			goto ret;
		}

		pwszMDPathOpen = pwszMDPathOpenOnHeap.get();

		MDPathFromURIW(ecb, L"", pwszMDPathOpen);
	}

	//
	//	Fetch and return the metadata
	//
	sc = CMetabase::Instance().HrGetData( ecb,
										  pwszMDPathURI,
										  pwszMDPathOpen,
										  ppMDData );

ret:

	return sc;
}

//	------------------------------------------------------------------------
//
//	HrMDGetData()
//
//	Fetch metadata for the specified metabase path.
//
HRESULT
HrMDGetData( const IEcb& ecb,
			 LPCWSTR pwszMDPathAccess,
			 LPCWSTR pwszMDPathOpen,
			 IMDData ** ppMDData )
{
	return CMetabase::Instance().HrGetData( ecb,
											pwszMDPathAccess,
											pwszMDPathOpen,
											ppMDData );
}

//	------------------------------------------------------------------------
//
//	DwMDChangeNumber()
//
//	Get the metabase change number .
//
DWORD
DwMDChangeNumber(const IEcb * pecb)
{
	return CMetabase::Instance().DwChangeNumber(pecb);
}

//	------------------------------------------------------------------------
//
//	HrMDOpenMetaObject()
//
//	Open a metadata object, given a path
//
HRESULT
HrMDOpenMetaObject( LPCWSTR pwszMDPath,
					DWORD dwAccess,
					DWORD dwMsecTimeout,
					CMDObjectHandle * pmdoh )
{
	return CMetabase::Instance().HrOpenObject( pwszMDPath,
											   dwAccess,
											   dwMsecTimeout,
											   pmdoh );
}

HRESULT
HrMDOpenLowestNodeMetaObject( LPWSTR pwszMDPath,
							  DWORD dwAccess,
							  LPWSTR * ppwszMDPath,
							  CMDObjectHandle * pmdoh )
{
	return CMetabase::Instance().HrOpenLowestNodeObject( pwszMDPath,
														 dwAccess,
														 ppwszMDPath,
														 pmdoh );
}


HRESULT
HrMDIsAuthorViaFrontPageNeeded(const IEcb& ecb,
							   LPCWSTR pwszURI,
							   BOOL * pfFrontPageWeb)
{
	return CMetabase::Instance().HrIsAuthorViaFrontPageNeeded( ecb,
															   pwszURI,
															   pfFrontPageWeb );
}

//	class CMetaOp -------------------------------------------------------------
//
SCODE __fastcall
CMetaOp::ScEnumOp (LPWSTR pwszMetaPath, UINT cch)
{
	Assert (cch <= METADATA_MAX_NAME_LEN);

	DWORD dwIndex = 0;
	LPWSTR pwszKey;
	SCODE sc = S_OK;

	//	First and formost, call out on the key handed in
	//
	MBTrace ("MB: CMetaOp::ScEnumOp(): calling op() on '%S'\n", pwszMetaPath);
	sc = ScOp (pwszMetaPath, cch);
	if (FAILED (sc))
		goto ret;

	//	If the Op() returns S_FALSE, that means the operation
	//	knows enough that it does not have to be called for any
	//	more metabase paths.
	//
	if (S_FALSE == sc)
		goto ret;

	//	Then enumerate all the child nodes and recurse.  To do
	//	this, we are going use the fact that we have been passed
	//	a buffer big enough to handle CCH_BUFFER_SIZE chars.
	//
	Assert ((cch + 1 + METADATA_MAX_NAME_LEN) <= CCH_BUFFER_SIZE);
	pwszKey = pwszMetaPath + cch;
	*(pwszKey++) = L'/';
	*pwszKey = L'\0';

	while (TRUE)
	{
		//	Enum the next key in the set of child keys, and process it.
		//
		sc = m_mdoh.HrEnumKeys (pwszMetaPath, pwszKey, dwIndex);
		if (FAILED (sc))
		{
			sc = S_OK;
			break;
		}

		//	Recurse on the new path.
		//
		Assert (wcslen(pwszKey) <= METADATA_MAX_NAME_LEN);
		sc = ScEnumOp (pwszMetaPath, cch + 1 + static_cast<UINT>(wcslen(pwszKey)));
		if (FAILED (sc))
			goto ret;

		//	If the EnumOp() returns S_FALSE, that means the operation
		//	knows enough that it does not have to be called for any
		//	more metabase paths.
		//
		if (S_FALSE == sc)
			goto ret;

		//	Increment the index to make sure the traversing continues
		//
		dwIndex++;

		//	Truncate the metapath again
		//
		*pwszKey = 0;
	}

ret:
	return sc;
}

SCODE __fastcall
CMetaOp::ScMetaOp()
{
	auto_heap_ptr<WCHAR> prgwchMDPaths;
	SCODE sc = S_OK;

	//	Initialize the metabase
	//
	sc = HrMDOpenMetaObject( m_pwszMetaPath,
							 m_fWrite ? METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE : METADATA_PERMISSION_READ,
							 5000,
							 &m_mdoh );
	if (FAILED (sc))
	{
		//	If the path is not found, then it really is
		//	not a problem...
		//
		if (HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == sc)
		{
			MBTrace ("MB: CMetaOp::ScMetaOp(): '%S' does not exist\n", m_pwszMetaPath);
			return S_OK;
		}

		DebugTrace ("Dav: MCD: unable to initialize metabase\n");
		return sc;
	}

	//	Get the set of paths for which the metabase property
	//	is explicitly specified.
	//
	//	Since the size of the buffer needed to hold the paths
	//	is initially unknown, guess at a reasonable size.  If
	//	it's not large enough, then then we will fallback to
	//	iterating throught the tree.
	//
	//	Either way, for each directory where the value is set
	//	explicitly, the call to ScOp() will be called (and in
	//	the fallback scenario, sometimes it won't be set).
	//
	prgwchMDPaths = static_cast<LPWSTR>(g_heap.Alloc(CCH_BUFFER_SIZE * sizeof(WCHAR)));
	DWORD cchMDPaths = CCH_BUFFER_SIZE;

	sc = m_mdoh.HrGetDataPaths( L"",
								m_dwId,
								m_dwType,
								prgwchMDPaths,
								&cchMDPaths );
	if (FAILED(sc))
	{
		//	Ok, this is the fallback position...
		//
		MBTrace ("MB: CMetaOp::ScMetaOp(): falling back to enumeration for op()\n");
		//
		//	We want to enumerate all the possible metabase paths and call
		//	the sub-op for each.  In this scenario, the sub-op is must be
		//	able to handle the case where the value is not explicitly set.
		//
		//	We are first going to copy the metapath into our buffer from
		//	above and pass it in so that we can use it and not have to
		//	do any real allocations.
		//
		*prgwchMDPaths = 0;
		sc = ScEnumOp (prgwchMDPaths, 0);

		//	Error or failure - we are done with processing this
		//	request.
		//
		goto ret;
	}
	else
	{
		//	Woo hoo.  The number/size of the paths all fit within
		//	the initial buffer!
		//
		//	Go ahead and call the sub-op for each of these paths
		//
		LPCWSTR pwsz = prgwchMDPaths;
		while (*pwsz)
		{
			MBTrace ("MB: CMetaOp::ScMetaOp(): calling op() on '%S'\n", pwsz);

			//	Call the sub-op.  The sub-op is responsible for
			//	handling all possible errors, but can pass back
			//	any terminating errors.
			//
			UINT cch = static_cast<UINT>(wcslen (pwsz));
			sc = ScOp (pwsz, cch);
			if (FAILED (sc))
				goto ret;

			//	If the Op() returns S_FALSE, that means the operation
			//	knows enough that it does not have to be called for any
			//	more metabase paths.
			//
			if (S_FALSE == sc)
				goto ret;

			//	Move to the next metapath
			//
			pwsz += cch + 1;
		}

		//	All the explict paths have been processed. We are done
		//	with processing this request.
		//
		goto ret;
	}

ret:

	//	Close up the metabase regardless
	//
	m_mdoh.Close();
	return sc;
}

//	------------------------------------------------------------------------
//
//	FParseMDData()
//
//	Parses a comma-delimited metadata string into fields.  Any whitespace
//	around the delimiters is considered insignificant and removed.
//
//	Returns TRUE if the data parsed into the expected number of fields
//	and FALSE otherwise.
//
//	Pointers to the parsed are returned in rgpwszFields.  If a string
//	parses into fewer than the expected number of fields, NULLs are
//	returned for all of the fields beyond the last one parsed.
//
//	If a string parses into the expected number of fields then
//	the last field is always just the remainder of the string beyond
//	the second to last field, regardless whether the string could be
//	parsed into additional fields.  For example "  foo , bar ,  baz  "
//	parses into three fields as "foo", "bar" and "baz", but parses
//	into two fields as "foo" and "bar ,  baz"
//
//	The total number of characters in pwszData, including the null
//	terminator, is also returned in *pcchData.
//
//	Note: this function MODIFIES pwszData.
//
BOOL
FParseMDData( LPWSTR pwszData,
			  LPWSTR rgpwszFields[],
			  UINT cFields,
			  UINT * pcchData )
{
	Assert( pwszData );
	Assert( pcchData );
	Assert( cFields > 0 );
	Assert( !IsBadWritePtr(rgpwszFields, cFields * sizeof(LPWSTR)) );

	//	Clear our "out" parameter
	//
	memset(rgpwszFields, 0, sizeof(LPWSTR) * cFields);

	WCHAR * pwchDataEnd = NULL;
	LPWSTR pwszField = pwszData;
	BOOL fLastField = FALSE;

	UINT iField = 0;

	while (!fLastField)
	{
		WCHAR * pwch;

		//
		//	Strip leading WS
		//
		while ( *pwszField && L' ' == *pwszField )
			++pwszField;

		//
		//	Locate the delimiter following the field.
		//	For all fields but the last field the delimiter
		//	is a ','.  For the last field, the "delimiter"
		//	is the terminating null.
		//
		if ( cFields - 1 == iField )
		{
			pwch = pwszField + wcslen(pwszField);
			fLastField = TRUE;
		}
		else
		{
			pwch = wcschr(pwszField, L',');
			if ( NULL == pwch )
			{
				//
				//	If we don't find a comma after the field
				//	then it is the last field.
				//
				pwch = pwszField + wcslen(pwszField);
				fLastField = TRUE;
			}
		}

		//	At this point we should have found a comma
		//	or the null terimator after the field.
		//
		Assert( pwch );

		pwchDataEnd = pwch;

		//
		//	Eat trailing whitespace at the end of the
		//	field up to the delimiter we just found
		//	by backing up from the delimiter's position
		//	and null-terminating the field after the
		//	last non-whitespace character.
		//
		while ( pwch-- > pwszField && L' ' == *pwch )
			;

		*++pwch = '\0';

		//
		//	Fill in the pointer to this field
		//
		rgpwszFields[iField] = pwszField;

		//
		//	Proceed to the next field
		//
		pwszField = pwchDataEnd + 1;
		++iField;
	}

	Assert( pwchDataEnd > pwszData );

	*pcchData = static_cast<UINT>(pwchDataEnd - pwszData + 1);

	return iField == cFields;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\ecb.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	ECB.CPP
//
//	Implementation of CEcb methods and non-member functions
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include "_davprs.h"
#include "ecb.h"
#include "instdata.h"
#include "ecbimpl.h"

//	========================================================================
//
//	CLASS IEcb
//

//	------------------------------------------------------------------------
//
//	IEcb::~IEcb()
//
//		Out of line virtual destructor necessary for proper deletion
//		of objects of derived classes via this class.
//
IEcb::~IEcb()
{
}


#ifdef DBG	// ECB logging

const CHAR gc_szDbgECBLogging[] = "ECB Logging";

//	========================================================================
//
//	CLASS CEcbLog (DBG only)
//
class CEcbLog : private Singleton<CEcbLog>
{
	//
	//	Friend declarations required by Singleton template
	//
	friend class Singleton<CEcbLog>;

	//
	//	Critical section to serialize writes to
	//	the log file
	//
	CCriticalSection	m_cs;

	//
	//	Handle to the log file
	//
	auto_handle<HANDLE>	m_hfLog;

	//
	//	Monotonically increasing unique identifier
	//	for ECB logging;
	//
	LONG				m_lMethodID;

	//	CREATORS
	//
	//	Declared private to ensure that arbitrary instances
	//	of this class cannot be created.  The Singleton
	//	template (declared as a friend above) controls
	//	the sole instance of this class.
	//
	CEcbLog();

	//	NOT IMPLEMENTED
	//
	CEcbLog( const CEcbLog& );
	CEcbLog& operator=( const CEcbLog& );

public:
	//	STATICS
	//

	//
	//	Instance creating/destroying routines provided
	//	by the Singleton template.
	//
	using Singleton<CEcbLog>::CreateInstance;
	using Singleton<CEcbLog>::DestroyInstance;

	static void LogString( const EXTENSION_CONTROL_BLOCK * pecb,
						   LONG   lMethodID,
						   LPCSTR szLocation );

	static LONG LNextMethodID();
};


//	------------------------------------------------------------------------
//
//	CEcbLog::CEcbLog()
//
CEcbLog::CEcbLog() :
	m_lMethodID(0)
{
	CHAR rgch[MAX_PATH];

	//	Init our ECB log file.
	if (GetPrivateProfileString( gc_szDbgECBLogging,
								 gc_szDbgLogFile,
								 "",
								 rgch,
								 sizeof(rgch),
								 gc_szDbgIni ))
	{
		m_hfLog = CreateFile( rgch,
							  GENERIC_WRITE,
							  FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
							  NULL,
							  CREATE_ALWAYS,
							  FILE_ATTRIBUTE_NORMAL, // | FILE_FLAG_SEQUENTIAL_SCAN
							  NULL );
	}
	else
		m_hfLog = INVALID_HANDLE_VALUE;
}

//	------------------------------------------------------------------------
//
//	CEcbLog::LogString()
//
void
CEcbLog::LogString( const EXTENSION_CONTROL_BLOCK * pecb,
					LONG   lMethodID,
					LPCSTR szLocation )
{
	if ( INVALID_HANDLE_VALUE == Instance().m_hfLog )
		return;

	Assert( pecb );

	CHAR rgch[MAX_PATH];
	int cch;

	//	Dump a line to the log:
	//	Thread: <tid> pECB <ecb> MethodID: <id> <meth name> <szLocation>
	//
	cch = _snprintf( rgch, CElems(rgch), "Thread: %08x pECB: 0x%08p MethodID: 0x%08x %hs %hs %hs\n",
					 GetCurrentThreadId(),
					 pecb,
					 lMethodID,
					 gc_szSignature,
					 pecb->lpszMethod,
					 szLocation );

	//  If we hit the buffer length then we won't be NULL terminated
	//
	rgch[CElems(rgch)-1] = '\0';

	//  If the trace is bigger than the buffer then cch will be negative
	//  but the buffer will have been filled.
	//
	if ( 0 > cch )
		cch = CElems(rgch)-1;


	DWORD cbActual;
	CSynchronizedBlock sb(Instance().m_cs);

	WriteFile( Instance().m_hfLog,
			   rgch,
			   cch,
			   &cbActual,
			   NULL );
}

//	------------------------------------------------------------------------
//
//	CEcbLog::LNextMethodID()
//
LONG
CEcbLog::LNextMethodID()
{
	return InterlockedIncrement(&Instance().m_lMethodID);
}

void InitECBLogging()
{
	CEcbLog::CreateInstance();
}

void DeinitECBLogging()
{
	CEcbLog::DestroyInstance();
}

#endif // DBG ECB logging


//	========================================================================
//
//	CLASS IIISAsyncIOCompleteObserver
//

//	------------------------------------------------------------------------
//
//	IIISAsyncIOCompleteObserver::~IIISAsyncIOCompleteObserver()
//
//		Out of line virtual destructor necessary for proper deletion
//		of objects of derived classes via this class
//
IIISAsyncIOCompleteObserver::~IIISAsyncIOCompleteObserver() {}


//	========================================================================
//
//	CLASS CAsyncErrorResponseInterlock
//
class CAsyncErrorResponseInterlock
{
	enum
	{
		STATE_ENABLED,
		STATE_DISABLED,
		STATE_TRIGGERED
	};

	//	Interlock state
	//
	LONG m_lState;

	//	NOT IMPLEMENTED
	//
	CAsyncErrorResponseInterlock( const CAsyncErrorResponseInterlock& );
	CAsyncErrorResponseInterlock& operator=( const CAsyncErrorResponseInterlock& );

public:
	CAsyncErrorResponseInterlock() :
		m_lState(STATE_ENABLED)
	{
	}

	//	------------------------------------------------------------------------
	//
	//	CAsyncErrorResponseInterlock::FDisable()
	//
	//	Tries to disable the interlock.  Returns TRUE if successful; subsequent
	//	calls to FTrigger() will return FALSE.
	//
	BOOL FDisable()
	{
		//	Return TRUE if the lock is already disabled OR if the lock is
		//	still enabled and we succeeded in disabling it.  Return FALSE
		//	otherwise.
		//
		return STATE_DISABLED == m_lState ||
			   (STATE_ENABLED == m_lState &&
				STATE_ENABLED == InterlockedCompareExchange(
									&m_lState,
									STATE_DISABLED,
									STATE_ENABLED));
	}

	//	------------------------------------------------------------------------
	//
	//	CAsyncErrorResponseInterlock::FTrigger()
	//
	//	Tries to trigger the interlock.  Returns TRUE if successful; subsequent
	//	calls to FDisable() will return FALSE.
	//
	BOOL FTrigger()
	{
		//	We can only trigger the lock once.
		//
		Assert(STATE_TRIGGERED != m_lState);

		//	Return TRUE if the lock is still enabled and we succeed in
		//	triggering it.  Return FALSE otherwise.
		//
		return STATE_ENABLED == m_lState &&
			   STATE_ENABLED == InterlockedCompareExchange(
									&m_lState,
									STATE_TRIGGERED,
									STATE_ENABLED);
	}
};

//	========================================================================
//
//	CLASS CEcb
//
//		Implementation of the caching ECB
//
class CEcb : public CEcbBaseImpl<IEcb>
{
	//	Cached user impersonation token
	//
	mutable HANDLE m_hTokUser;

	//	Cached instance data -- owned by the instance cache,
	//	not us, so don't free it (not an auto-ptr!!).
	//
	mutable CInstData * m_pInstData;

	//	Cached HTTP version (e.g. "HTTP/1.1")
	//
	mutable CHAR			m_rgchVersion[10];

	//	Cached Connection: header
	//
	mutable auto_heap_ptr<WCHAR> m_pwszConnectionHeader;

	//	Cached metadata
	//
	auto_ref_ptr<IMDData> m_pMD;

	//	State in which we leave the connection
	//	when we're done.
	//
	mutable enum
	{
		UNKNOWN,	// Don't know yet
		CLOSE,		// Close it
		KEEP_ALIVE	// Keep it open

	} m_connState;

	//	Brief'ness
	//
	enum { BRIEF_UNKNOWN = -1, BRIEF_NO, BRIEF_YES };
	mutable LONG m_lBrief;

	//	Acceptable transfer coding method:
	//
	//	TC_UNKNOWN  - Acceptable transfer coding has not yet been determined.
	//	TC_CHUNKED  - Chunked transfer coding is acceptable.
	//	TC_IDENTITY - No transfer coding is acceptable.
	//
	mutable TRANSFER_CODINGS m_tcAccepted;

	//	Authentication State information:
	//		Bit		Means
	//		============================
	//		31		Queried against ECB
	//		30-4	Unused
	//		3		Kerberos
	//		2		NTLM
	//		1		Basic
	//		0		Authenticated

	mutable DWORD			m_rgbAuthState;

	//	Init flag set to TRUE once we've registered our
	//	I/O completion routine with IIS.
	//
	enum { NO_COMPLETION, IO_COMPLETION, CUSTERR_COMPLETION, EXECURL_COMPLETION };
	LONG m_lSetIISIOCompleteCallback;

	//	Flag stating whether a child ISAPI has been successfully executed.  If this is the
	//	case, we don't want to reset dwHttpStatusCode later or we will lose whatever
	//	status code they set.
	//
	BOOL m_fChildISAPIExecSuccess;

	//
	//	Interlock used to prevent a race condition between a thread
	//	sending a normal response and a thread sending an error in response
	//	to an async event such as an exception or epoxy shutdown.
	//
	CAsyncErrorResponseInterlock m_aeri;

	//	Status string for async custom error response.
	//	Format "nnn reason".
	//
	auto_heap_ptr<CHAR> m_pszStatus;

	//
	//	Refcount to track number of outstanding async I/O operations.
	//	There should never be more than one.
	//
	LONG m_cRefAsyncIO;

	//
	//	Pointer to the current async I/O completion observer
	//
	IIISAsyncIOCompleteObserver * m_pobsAsyncIOComplete;

#ifdef DBG
	LONG					m_lEcbLogMethodID;
#endif

	//	ECB tracing (not to be confused with ECB logging!)
	//
#ifdef DBG
	void TraceECB() const;
#else
	void TraceECB() const {}
#endif

	//
	//	Async I/O
	//
	SCODE ScSetIOCompleteCallback(LONG lCompletion);
	static VOID WINAPI IISIOComplete( const EXTENSION_CONTROL_BLOCK * pecbIIS,
									  CEcb *	pecb,
									  DWORD		dwcbIO,
									  DWORD		dwLastError );
	static VOID WINAPI CustomErrorIOCompletion( const EXTENSION_CONTROL_BLOCK * pecbIIS,
												CEcb *	pecb,
												DWORD   dwcbIO,
												DWORD   dwLastError );
	static VOID WINAPI ExecuteUrlIOCompletion( const EXTENSION_CONTROL_BLOCK * pecbIIS,
											   CEcb *	pecb,
											   DWORD    dwcbIO,
											   DWORD    dwLastError );

	//	NOT IMPLEMENTED
	//
	CEcb( const CEcb& );
	CEcb& operator=( const CEcb& );

	SCODE ScSyncExecuteChildWide60Before( LPCWSTR pwszUrl,
										  LPCSTR pszQueryString,
										  BOOL fCustomErrorUrl );

	SCODE ScAsyncExecUrlWide60After( LPCWSTR pwszUrl,
									 LPCSTR pszQueryString,
									 BOOL fCustomErrorUrl );


public:

	CEcb( EXTENSION_CONTROL_BLOCK& ecb );
	BOOL FInitialize( BOOL fUseRawUrlMappings );
	~CEcb();

	//	URL prefix
	//
	UINT CchUrlPortW( LPCWSTR * ppwszPort ) const;

	//	Instance data access
	//
	CInstData& InstData() const;

	//	Impersonation token access
	//
	HANDLE HitUser() const;

	//	ACCESSORS
	//
	LPCSTR LpszVersion() const;
	BOOL FKeepAlive() const;
	BOOL FCanChunkResponse() const;
	BOOL FAuthenticated() const;
	BOOL FProcessingCEUrl() const;

	BOOL FIIS60OrAfter() const
	{
		return (m_pecb->dwVersion >= IIS_VERSION_6_0);
	}

	BOOL FSyncTransmitHeaders( const HSE_SEND_HEADER_EX_INFO& shei );

	SCODE ScAsyncRead( BYTE * pbBuf,
					   UINT * pcbBuf,
					   IIISAsyncIOCompleteObserver& obs );

	SCODE ScAsyncWrite( BYTE * pbBuf,
						DWORD  dwcbBuf,
						IIISAsyncIOCompleteObserver& obs );

	SCODE ScAsyncTransmitFile( const HSE_TF_INFO& tfi,
							   IIISAsyncIOCompleteObserver& obs );

	SCODE ScAsyncCustomError60After( const HSE_CUSTOM_ERROR_INFO& cei,
									 LPSTR pszStatus );

	SCODE ScAsyncExecUrl60After( const HSE_EXEC_URL_INFO& eui );

	SCODE ScExecuteChild( LPCWSTR pwszURI, LPCSTR pszQueryString, BOOL fCustomErrorUrl )
	{
		//	IIS 6.0 or after has a different way of executing child
		//
		if (m_pecb->dwVersion >= IIS_VERSION_6_0)
		{
			return ScAsyncExecUrlWide60After (pwszURI, pszQueryString, fCustomErrorUrl);
		}
		else
		{
			return ScSyncExecuteChildWide60Before (pwszURI, pszQueryString, fCustomErrorUrl);
		}
	}

	SCODE ScSendRedirect( LPCSTR lpszURI );

	IMDData& MetaData() const
	{
		Assert( m_pMD.get() );
		return *m_pMD;
	}

	BOOL FBrief () const;

	LPCWSTR PwszMDPathVroot() const
	{
		Assert( m_pInstData );
		return m_pInstData->GetNameW();
	}

#ifdef DBG
	virtual void LogString( LPCSTR lpszLocation ) const
	{
		if ( DEBUG_TRACE_TEST(ECBLogging) )
			CEcbLog::LogString( m_pecb, m_lEcbLogMethodID, lpszLocation );
	}
#endif

	//	MANIPULATORS
	//
	VOID SendAsyncErrorResponse( DWORD dwStatusCode,
								 LPCSTR pszStatusDescription,
								 DWORD cchzStatusDescription,
								 LPCSTR pszBody,
								 DWORD cchzBody );

	DWORD HSEHandleException();

	//	Session handling
	//
	VOID DoneWithSession( BOOL fKeepAlive );

	//	To be used ONLY by request/response.
	//
	void SetStatusCode( UINT iStatusCode );
	void SetConnectionHeader( LPCWSTR pwszValue );
	void SetAcceptLanguageHeader( LPCSTR pszValue );
	void CloseConnection();
};


//	------------------------------------------------------------------------
//
//	CEcb Constructor/Destructor
//
CEcb::CEcb( EXTENSION_CONTROL_BLOCK& ecb ) :
   CEcbBaseImpl<IEcb>(ecb),
   m_hTokUser(NULL),
   m_pInstData(NULL),
   m_connState(UNKNOWN),
   m_tcAccepted(TC_UNKNOWN),
   m_rgbAuthState(0),
   m_cRefAsyncIO(0),
   m_lSetIISIOCompleteCallback(NO_COMPLETION),
   m_fChildISAPIExecSuccess(FALSE),
   m_lBrief(BRIEF_UNKNOWN)
{
#ifdef DBG
	if ( DEBUG_TRACE_TEST(ECBLogging) )
		m_lEcbLogMethodID = CEcbLog::LNextMethodID();
#endif

	//	Auto-pointers will be init'd by their own ctors.
	//

	//	Zero the first char of the m_rgchVersion.
	//
	*m_rgchVersion = '\0';

	//	Clear out the status code in the EXTENSION_CONTROL_BLOCK so that
	//	we will be able to tell whether we should try to send a 500
	//	Server Error response in the event of an exception.
	//
	SetStatusCode(0);

	//	Set up our instance data now.  We need it for the perf counters below.
	//
	m_pInstData = &g_inst.GetInstData( *this );

	//	And trace out the ECB info (If we're debug, if we're tracing....)
	//
	TraceECB();
}

//	------------------------------------------------------------------------
//
//	CEcb::FInitialize()
//
BOOL
CEcb::FInitialize( BOOL fUseRawUrlMappings )
{
	auto_heap_ptr<WCHAR>	pwszMDUrlOnHeap;

	//
	//	Fault in a few things like the vroot (LPSTR) and its length
	//	and the corresponding path information.
	//	The mapex info is already "faulted in" during the CEcb constructor.
	//	(ctor calls GetInstData, which calls CEcbBaseImpl<>::GetMapExInfo)
	//	However, fault in other pieces, like our translated request URI
	//	and our MD path.
	//

	//
	//	Cache the metabase paths for both the vroot and the request URI.
	//
	//	Note that the metabase path for the vroot is just the instance name.
	//
	//	Special case: If '*' is the request URI.
	//
	//	IMPORTANT: this is only valid for an OPTIONS request.  The handling
	//	of the validitiy of the request is handled later.  For now, lookup
	//	the data for the default site root.
	//
	//	IMPORTANT:
	//	LpszRequestUrl() will return FALSE in the case of a bad URL (in
	//	DAVEX, if the ScNormalizeUrl() call fails).  If that happens,
	//	set our status code to HSC_BAD_REQUEST and return FALSE from here.
	//	The calling code (NewEcb()) will handle this gracefully.
	//
	LPCWSTR pwszRequestUrl = LpwszRequestUrl();
	if (!pwszRequestUrl)
	{
		SetStatusCode(HSC_BAD_REQUEST);
		return FALSE;
	}

	LPCWSTR pwszMDUrl;
	if ( L'*'  == pwszRequestUrl[0] &&
		 L'\0' == pwszRequestUrl[1] )
	{
		pwszMDUrl = PwszMDPathVroot();
	}
	else
	{
		pwszMDUrlOnHeap = static_cast<LPWSTR>(ExAlloc(CbMDPathW(*this, pwszRequestUrl)));
		if (NULL == pwszMDUrlOnHeap.get())
			return FALSE;

		pwszMDUrl = pwszMDUrlOnHeap.get();
		MDPathFromURIW( *this, pwszRequestUrl, const_cast<LPWSTR>(pwszMDUrl) );
	}

	//
	//$REVIEW	It would be nice to propagate out the specific HRESULT
	//$REVIEW	so that we could send back an appropriate suberror,
	//$REVIEW	but sending a suberror could be difficult if we can't
	//$REVIEW	get to the metadata that contains the suberror mappings....
	//
	return SUCCEEDED(HrMDGetData( *this,
								  pwszMDUrl,
								  PwszMDPathVroot(),
								  m_pMD.load() ));
}

//	------------------------------------------------------------------------
//
//	CEcb::~CEcb()
//
CEcb::~CEcb()
{
	//
	//	If we've already given back the EXTENSION_CONTROL_BLOCK then
	//	we don't need to do anything else here.  Otherwise we should
	//	return it (call HSE_REQ_DONE_WITH_SESSION) with the appropriate
	//	keep-alive.
	//
	if ( m_pecb )
	{
		//
		//	At this point someone should have generated a response,
		//	even in the case of an exception (see HSEHandleException()).
		//
		Assert( m_pecb->dwHttpStatusCode != 0 );

		//
		//	Tell IIS that we're done for this request.
		//
		DoneWithSession( FKeepAlive() );
	}
}

//	========================================================================
//
//	PRIVATE CEcb methods
//

//	------------------------------------------------------------------------
//
//	CEcb::DoneWithSession()
//
//	Called whenever we are done with the raw EXTENSION_CONTROL_BLOCK.
//
VOID
CEcb::DoneWithSession( BOOL fKeepAlive )
{
	//
	//	We should only call DoneWithSession() once.  We null out m_pecb
	//	at the end, so we can assert that we are only called once by
	//	checking m_pecb here.
	//
	Assert( m_pecb );

	//
	//	We should never release the EXTENSION_CONTROL_BLOCK if there
	//	is async I/O outstanding.
	//
	Assert( 0 == m_cRefAsyncIO );

	//
	//	"Release" the raw EXTENSION_CONTROL_BLOCK inherited from IEcb.
	//
	static const DWORD sc_dwKeepConn = HSE_STATUS_SUCCESS_AND_KEEP_CONN;

	(VOID) m_pecb->ServerSupportFunction(
						m_pecb->ConnID,
						HSE_REQ_DONE_WITH_SESSION,
						fKeepAlive ? const_cast<DWORD *>(&sc_dwKeepConn) : NULL,
						NULL,
						NULL );

	//
	//	We can no longer use the EXTENSION_CONTROL_BLOCK so remove any
	//	temptation to do so by nulling out the pointer.
	//
	m_pecb = NULL;
}


//	------------------------------------------------------------------------
//
//	CEcb::SendAsyncErrorResponse()
//
VOID
CEcb::SendAsyncErrorResponse( DWORD dwStatusCode,
							  LPCSTR pszStatusDescription,
							  DWORD cchzStatusDescription,
							  LPCSTR pszBody,
							  DWORD cchzBody )
{
	//	Try to trigger the async error response mechanism.  If successful
	//	then we are responsible for sending the entire repsonse.  If not
	//	then we are already sending a response on some other thread, so
	//	don't confuse things by sending any thing here.
	//
	if (!m_aeri.FTrigger())
	{
		DebugTrace( "CEcb::SendAsyncErrorResponse() - Non-error response already in progress\n" );
		return;
	}

	HSE_SEND_HEADER_EX_INFO shei;
	CHAR rgchStatusDescription[256];

	//	Blow away any previously set status code in favor of
	//	the requested status code.  Even though there may have
	//	been an old status code set, it was never sent -- the
	//	fact that our interlock triggered proves that no other
	//	response has been sent.
	//
	SetStatusCode(dwStatusCode);

	//	If we don't have a status description then fetch the default
	//	for the given status code.
	//
	if ( !pszStatusDescription )
	{
		LpszLoadString( dwStatusCode,
						LcidAccepted(),
						rgchStatusDescription,
						sizeof(rgchStatusDescription) );

		pszStatusDescription = rgchStatusDescription;
	}

	shei.pszStatus = pszStatusDescription;
	shei.cchStatus = cchzStatusDescription;

	//	Don't send any body unless we are given one.
	//
	shei.pszHeader = pszBody;
	shei.cchHeader = cchzBody;

	//	Always close the connection on errors -- and we should
	//	only ever be called for serious server errors.
	//
	Assert(dwStatusCode >= 400);
	shei.fKeepConn = FALSE;

	//	Send the response.  We don't care at all about the return
	//	value because there's nothing we can do if the response
	//	cannot be sent.
	//
	(VOID) m_pecb->ServerSupportFunction(
				m_pecb->ConnID,
				HSE_REQ_SEND_RESPONSE_HEADER_EX,
				&shei,
				NULL,
				NULL );
}


//	------------------------------------------------------------------------
//
//	CEcb::HSEHandleException()
//
DWORD
CEcb::HSEHandleException()
{
	//
	//	!!! IMPORTANT !!!
	//
	//	This function is called after an exception has occurred.
	//	Don't do ANYTHING outside of a try/catch block or a secondary
	//	exception could take out the whole IIS process.
	//
	try
	{
		//
		//	Translate async Win32 exceptions into thrown C++ exceptions.
		//	This must be placed inside the try block!
		//
		CWin32ExceptionHandler win32ExceptionHandler;

		//
		//	Send a 500 Server Error response.  We use the async error
		//	response mechanism, because we may have been in the middle
		//	of sending some other response on another thread.
		//
		SendAsyncErrorResponse(500,
							   gc_szDefErrStatusLine,
							   gc_cchszDefErrStatusLine,
							   gc_szDefErrBody,
							   gc_cchszDefErrBody);
	}
	catch ( CDAVException& )
	{
		//
		//	We blew up trying to send a response.  Oh well.
		//
	}

	//
	//	Tell IIS that we are done with the EXTENSION_CONTROL_BLOCK that
	//	it gave us.  We must do this or IIS will not be able to shut down.
	//	We would normally do this from within our destructor, but since
	//	we are handling an exception, there is no guarantee that our
	//	destructor will ever be called -- that is, there may be outstanding
	//	refs that will never be released (i.e. we will leak).
	//
	DWORD dwHSEStatusRet;

	try
	{
		//
		//	Translate async Win32 exceptions into thrown C++ exceptions.
		//	This must be placed inside the try block!
		//
		CWin32ExceptionHandler win32ExceptionHandler;

		DoneWithSession( FALSE );

		//
		//	If this call succeeds, we MUST return HSE_STATUS_PENDING to
		//	let IIS know that we claimed a ref on the EXTENSION_CONTROL_BLOCK.
		//
		dwHSEStatusRet = HSE_STATUS_PENDING;
	}
	catch ( CDAVException& )
	{
		//
		//	We blew up trying to tell IIS that we were done with
		//	the EXTENSION_CONTROL_BLOCK.  There is absolutely nothing
		//	we can do at this point.  IIS will probably hang on shutdown.
		//
		dwHSEStatusRet = HSE_STATUS_ERROR;
	}

	return dwHSEStatusRet;
}

//	------------------------------------------------------------------------
//
//	CEcb::TraceECB()
//
//		Traces out the EXTENSION_CONTROL_BLOCK
//
#ifdef DBG
void
CEcb::TraceECB() const
{
	EcbTrace( "ECB Contents:\n" );
	EcbTrace( "\tcbSize             = %lu\n",    m_pecb->cbSize );
	EcbTrace( "\tdwVersion          = %lu\n",    m_pecb->dwVersion );
	EcbTrace( "\tlpszMethod         = \"%s\"\n", m_pecb->lpszMethod );
	EcbTrace( "\tlpszQueryString    = \"%s\"\n", m_pecb->lpszQueryString );
	EcbTrace( "\tlpszPathInfo       = \"%s\"\n", m_pecb->lpszPathInfo );
	EcbTrace( "\tlpszPathTranslated = \"%s\"\n", m_pecb->lpszPathTranslated );
	EcbTrace( "\tcbTotalBytes       = %lu\n",    m_pecb->cbTotalBytes );
	EcbTrace( "\tcbAvailable        = %lu\n",    m_pecb->cbAvailable );
	EcbTrace( "\tlpszContentType    = \"%s\"\n", m_pecb->lpszContentType );
	EcbTrace( "\n" );

	{
		char	rgch[256];
		DWORD	dwCbRgch;

		dwCbRgch = sizeof(rgch);
		(void) m_pecb->GetServerVariable( m_pecb->ConnID, "SCRIPT_NAME", rgch, &dwCbRgch );

		EcbTrace( "Script name = \"%s\"\n", rgch );

		dwCbRgch = sizeof(rgch);
		(void) m_pecb->GetServerVariable( m_pecb->ConnID, "SCRIPT_MAP", rgch, &dwCbRgch );

		EcbTrace( "Script map = \"%s\"\n", rgch );

		dwCbRgch = sizeof(rgch);
		(void) m_pecb->GetServerVariable( m_pecb->ConnID, "HTTP_REQUEST_URI", rgch, &dwCbRgch );

		EcbTrace( "Request URI = \"%s\"\n", rgch );

		dwCbRgch = sizeof(rgch);
		(void) m_pecb->ServerSupportFunction( m_pecb->ConnID, HSE_REQ_MAP_URL_TO_PATH, rgch, &dwCbRgch, NULL );

		EcbTrace( "Path from request URI = \"%s\"\n", rgch );
	}
}
#endif // defined(DBG)


//	========================================================================
//
//	PUBLIC CEcb methods
//

//	------------------------------------------------------------------------
//
//	CEcb::CchUrlPortW
//
//		Get the string with the port based on the fact if we are secure
//
UINT
CEcb::CchUrlPortW( LPCWSTR * ppwszPort ) const
{
	Assert (ppwszPort);

	//	If we are secure...
	//
	if (FSsl())
	{
		*ppwszPort = gc_wszUrl_Port_443;
		return gc_cchUrl_Port_443;
	}

	*ppwszPort = gc_wszUrl_Port_80;
	return gc_cchUrl_Port_80;
}

//	------------------------------------------------------------------------
//
//	CEcb::InstData
//
//		Fetch and cache our per-vroot instance data
//
CInstData&
CEcb::InstData() const
{
	Assert( m_pInstData );

	return *m_pInstData;
}

//	------------------------------------------------------------------------
//
//	CEcb::HitUser
//
//		Fetch and cache our impersonation token
//
HANDLE
CEcb::HitUser() const
{
	if ( m_hTokUser == NULL )
	{
		ULONG cb = sizeof(HANDLE);

		m_pecb->ServerSupportFunction( m_pecb->ConnID,
									   HSE_REQ_GET_IMPERSONATION_TOKEN,
									   &m_hTokUser,
									   &cb,
									   NULL );
	}

	return m_hTokUser;
}


//	------------------------------------------------------------------------
//
//	CEcb::LpszVersion()
//
LPCSTR
CEcb::LpszVersion() const
{
	if ( !*m_rgchVersion )
	{
		DWORD cbVersion = sizeof(m_rgchVersion);

		if ( !FGetServerVariable( gc_szHTTP_Version,
								  m_rgchVersion,
								  &cbVersion ) )
		{
			//
			//	If we are unable to get a value for HTTP_VERSION then
			//	the string is probably longer than the buffer we gave.
			//	Rather than deal with a potentially arbitrarily long
			//	string, default to HTTP/1.1.  This is consistent with
			//	observed IIS behavior (cf. NT5:247826).
			//
			memcpy( m_rgchVersion,
					gc_szHTTP_1_1,
					sizeof(gc_szHTTP_1_1) );
		}
		else if ( !*m_rgchVersion )
		{
			//
			//	No value for HTTP_VERSION means that nothing was
			//	specified on the request line, which means HTTP/0.9
			//
			memcpy( m_rgchVersion,
					gc_szHTTP_0_9,
					sizeof(gc_szHTTP_0_9) );
		}
	}

	return m_rgchVersion;
}

//	------------------------------------------------------------------------
//
//	CEcb::FKeepAlive()
//
//		Returns whether to keep alive the client connection after sending
//		the response.
//
//		The connection logic has changed over the various HTTP versions;
//		this function uses the logic appropriate to the HTTP version
//		of the request.
//
BOOL
CEcb::FKeepAlive() const
{
	//
	//	If we haven't already determined what we want, then begin
	//	the process of figuring it out...
	//
	if ( m_connState == UNKNOWN )
	{
		//
		//	If someone set a Connection: header then pay attention to it
		//
		if (m_pwszConnectionHeader.get())
		{
			//
			//	Set the connection state based on the current value of
			//	the request's Connection: header, and the HTTP version.
			//	NOTE: The request MUST forward us any updates to the
			//	Connection: header for this to work!
			//	NOTE: Comparing the HTTP version strings using C-runtime strcmp,
			//	because the version string is pure ASCII.
			//

			//
			//	HTTP/1.1
			//
			//	(Consider the HTTP/1.1 case FIRST to minimize the number
			//	of string compares in this most common case).
			//
			if ( !strcmp( LpszVersion(), gc_szHTTP_1_1 ) )
			{
http_1_1:
				//
				//	The default for HTTP/1.1 is to keep the connection alive
				//
				m_connState = KEEP_ALIVE;

				//
				//	But if the request's Connection: header says close,
				//	then close.
				//
				//	This compare should be case-insensitive.
				//
				//	Using CRT skinny-string func here 'cause this header is pure ASCII,
				//	AND because _stricmp (and his brother _strcmpi) doesn't cause us
				//	a context-switch!
				//
				if ( !_wcsicmp( m_pwszConnectionHeader.get(), gc_wszClose ) )
					m_connState = CLOSE;
			}

			//
			//	HTTP/1.0
			//
			else if ( !strcmp( LpszVersion(), gc_szHTTP_1_0 ) )
			{
				//
				//	For HTTP/1.0 requests, the default is to close the connection
				//	unless a "Connection: Keep-Alive" header exists.
				//
				m_connState = CLOSE;

				if ( !_wcsicmp( m_pwszConnectionHeader.get(), gc_wszKeep_Alive ) )
					m_connState = KEEP_ALIVE;
			}

			//
			//	HTTP/0.9
			//
			else if ( !strcmp( LpszVersion(), gc_szHTTP_0_9 ) )
			{
				//
				//	For HTTP/0.9, always close the connection.  There was no
				//	other option for HTTP/0.9.
				//
				m_connState = CLOSE;
			}

			//
			//	Other (future) HTTP versions
			//
			else
			{
				//
				//	We really are only guessing what to do here, but assuming
				//	that the HTTP spec doesn't change the Connection behavior
				//	again, we should behave like HTTP/1.1
				//
				goto http_1_1;
			}
		}

		//
		//	If no one set a Connection: header, than use whatever IIS
		//	tells us to use.
		//
		//	NOTE: Currently, this value can only be ADDED, never DELETED.
		//	If that fact changes, FIX this code!
		//
		else
		{
			BOOL fKeepAlive;

			if ( !m_pecb->ServerSupportFunction( m_pecb->ConnID,
												 HSE_REQ_IS_KEEP_CONN,
												 &fKeepAlive,
												 NULL,
												 NULL ))
			{
				DebugTrace( "CEcb::FKeepAlive--Failure (0x%08x) from SSF(IsKeepConn).\n",
							GetLastError() );

				//	No big deal?  If we're getting errors like this
				//	we probably want to close the connection anyway....
				//
				m_connState = CLOSE;
			}

			m_connState = fKeepAlive ? KEEP_ALIVE : CLOSE;
		}
	}

	//
	//	By now we must know what we want
	//
	Assert( m_connState == KEEP_ALIVE || m_connState == CLOSE );

	return m_connState == KEEP_ALIVE;
}

//	------------------------------------------------------------------------
//
//	CEcb::FCanChunkResponse()
//
//	Returns TRUE if the client will accept a chunked response.
//
BOOL
CEcb::FCanChunkResponse() const
{
	if ( TC_UNKNOWN == m_tcAccepted )
	{
		//
		//	According to the HTTP/1.1 draft, section 14.39 TE:
		//
		//		"A server tests whether a transfer-coding is acceptable,
		//		acording to a TE field, using these rules:
		//
		//		1.
		//			The "chunked" transfer-coding is always acceptable.
		//
		//		[...]"
		//
		//	and section 3.6 Transfer Codings, last paragraph:
		//
		//		"A server MUST NOT send transfer-codings to an HTTP/1.0
		//		client."
		//
		//	Therefore, deciding whether a client accepts a chunked
		//	transfer coding is simple:  If the request is an HTTP/1.1
		//	request, then it accepts chunked coding.  Otherwise it doesn't.
		//
		m_tcAccepted = strcmp( gc_szHTTP_1_1, LpszVersion() ) ?
						TC_IDENTITY :
						TC_CHUNKED;
	}

	Assert( m_tcAccepted != TC_UNKNOWN );

	return TC_CHUNKED == m_tcAccepted;
}

BOOL
CEcb::FBrief() const
{
	//	If we don't have a value yet...
	//
	if (BRIEF_UNKNOWN == m_lBrief)
	{
		CHAR rgchBrief[8] = {0};
		ULONG cbBrief = 8;

		//	Brief is expected when:
		//
		//		The "brief" header has a value of "t"
		//
		//	NOTE: The default is brief to false.
		//
		//	We addapt overwrite checking model here. Just first letter for true case.
		//
		//	NOTE also: the default value if there is no Brief: header
		//	is FALSE -- give the full response.
		//
		FGetServerVariable("HTTP_BRIEF", rgchBrief, &cbBrief);
		if ((rgchBrief[0] != 't') && (rgchBrief[0] != 'T'))
			m_lBrief = BRIEF_NO;
		else
			m_lBrief = BRIEF_YES;
	}
	return (BRIEF_YES == m_lBrief);
}


//	------------------------------------------------------------------------
//
//	CEcb::FAuthenticated()
//

const DWORD c_AuthStateQueried			= 0x80000000;
const DWORD c_AuthStateAuthenticated	= 0x00000001;
const DWORD c_AuthStateBasic			= 0x00000002;
const DWORD c_AuthStateNTLM				= 0x00000004;
const DWORD c_AuthStateKerberos			= 0x00000008;
const DWORD c_AuthStateUnknown			= 0x00000010;

const CHAR	c_szBasic[]					= "Basic";
const CHAR	c_szNTLM[]					= "NTLM";
const CHAR	c_szKerberos[]				= "Kerberos";

BOOL
CEcb::FAuthenticated() const
{
	if (!(m_rgbAuthState & c_AuthStateQueried))
	{
		CHAR	szAuthType[32];
		ULONG	cb = sizeof(szAuthType);

		Assert(m_rgbAuthState == 0);

		if (FGetServerVariable(gc_szAuth_Type, szAuthType, &cb))
		{
			// For now, lets just check the first character (it's cheaper).
			// If this proves problematic then we can do a full string
			// compair.  Also, SSL by itself is not to be considered a form
			// of domain authentication.  The only time that SSL does imply
			// and authenticated connection is when Cert Mapping is enabled
			// and I don't think this is an interesting scenario. (russsi)

			if (*szAuthType == 'B')
				m_rgbAuthState = (c_AuthStateAuthenticated | c_AuthStateBasic);
			else if (*szAuthType == 'N')
				m_rgbAuthState = (c_AuthStateAuthenticated | c_AuthStateNTLM);
			else if (*szAuthType == 'K')
				m_rgbAuthState = (c_AuthStateAuthenticated | c_AuthStateKerberos);
			else
				m_rgbAuthState = c_AuthStateUnknown; // it could be "SSL/PCT"
		}

		m_rgbAuthState |= c_AuthStateQueried;
	}

	return (m_rgbAuthState & c_AuthStateAuthenticated);
}

//	------------------------------------------------------------------------
//
//	CEcb::SetStatusCode()
//
//	Sets the HTTP status code that IIS uses in logging
//
void
CEcb::SetStatusCode( UINT iStatusCode )
{
	//	If we have executed a child ISAPI successfully, we don't want to overwrite the
	//	status code in the ECB.  This will end up causing IIS to log this status code
	//	rather than the one left in the ECB by the ISAPI.
	//
	if (!m_fChildISAPIExecSuccess)
		m_pecb->dwHttpStatusCode = iStatusCode;
}

//	MANIPULATORS
//	To be used ONLY by request/response.
//
//	NOTE: These member vars start out NULL.  Inside CEcb, we are using NULL
//	as a special value that means the data has NEVER been set, so if
//	we get an lpszValue of NULL (meaning to delete the header), store
//	an empty string instead, so that we know the data has been forcefully erased.
//
void CEcb::SetConnectionHeader( LPCWSTR pwszValue )
{
	auto_heap_ptr<WCHAR> pwszOld;
	pwszOld.take_ownership(m_pwszConnectionHeader.relinquish());

	//	If they want to delete the value, set an empty string.
	//
	if (!pwszValue)
		pwszValue = gc_wszEmpty;

	m_pwszConnectionHeader = WszDupWsz( pwszValue );
}

void CEcb::CloseConnection()
{
	m_connState = CLOSE;
}

void CEcb::SetAcceptLanguageHeader( LPCSTR pszValue )
{
	auto_heap_ptr<CHAR> pszOld;
	pszOld.take_ownership(m_pszAcceptLanguage.relinquish());

	//	If they want to delete the value, set an empty string.
	//
	if (!pszValue)
		pszValue = gc_szEmpty;

	m_pszAcceptLanguage = LpszAutoDupSz( pszValue );
}

SCODE CEcb::ScAsyncRead( BYTE * pbBuf,
						 UINT * pcbBuf,
						 IIISAsyncIOCompleteObserver& obs )
{
	SCODE sc = S_OK;

	EcbTrace( "DAV: TID %3d: 0x%08lX: CEcb::ScAsyncRead() called...\n", GetCurrentThreadId(), this );

	//
	//	If there is another async IO outstanding we do not want to start one more. IIS will fail
	//	us out, and we ourselves will not be able to handle the completion of initial async IO
	//	properly. So just kill the connection and return. This may happen when we attempt to
	//	send the response before the read is finished.
	//
	if (0 != InterlockedCompareExchange(&m_cRefAsyncIO,
										1,
										0))
	{
		//	The function bellow is not supported starting from IIS 6.0 but let us call it anyway
		//	just in case support becomes available - and we want to call it if the binary is
		//	running on IIS 5.0. It does not matter that much, as the bad side of not closing the
		//	connection may hang the client, or error out on subsequent request. That is ok as
		//	the path is supposed to be hit in abnormal/error conditions when clients for example
		//	send in invalid requests trying to cause denial of service or similar things.
		//		So on IIS 6.0 the connection will not be closed, we will just error out. We have
		//	not seen this path hit on IIS 6.0 anyway when runing denial of service scripts as it
		//	handles custom errors differently.
		//
		if (m_pecb->ServerSupportFunction(m_pecb->ConnID,
										  HSE_REQ_CLOSE_CONNECTION,
										  NULL,
										  NULL,
										  NULL))
		{
			EcbTrace( "CEcb::ScAsyncRead() - More than 1 async operation. Connection closed. Failing out with error 0x%08lX\n", E_ABORT );

			sc = E_ABORT;
			goto ret;
		}
		else
		{
			EcbTrace( "CEcb::ScAsyncRead() - More than 1 async operation. ServerSupportFunction(HSE_REQ_CLOSE_CONNECTION) "
					  "failed with last error 0x%08lX. Overriding with fatal error 0x%08lX\n", GetLastError(), E_FAIL );

			sc = E_FAIL;
			goto ret;
		}
	}

	//
	//	IIS allows only one async I/O operation at a time.  But for performance reasons it
	//	leaves it up to the ISAPI to heed the restriction.  For the same reasons, we push
	//	that responsibility off to the DAV impl.  A simple refcount tells us whether
	//	the impl has done so.
	//
	AssertSz( 1 == m_cRefAsyncIO,
			  "CEcb::ScAsyncRead() - m_cRefAsyncIO wrong on entry" );

	//
	//	We need to hold a ref on the process-wide instance data for the duration of the I/O
	//	so that if IIS tells us to shut down while the I/O is still pending we will keep
	//	the instance data alive until we're done with the I/O.
	//
	AddRefImplInst();

	//
	//	Set the async I/O completion observer
	//
	m_pobsAsyncIOComplete = &obs;

	//
	//	Set up the async I/O completion routine and start reading.
	//	Add a ref for the I/O completion thread.  Use auto_ref_ptr
	//	to make things exception-proof.
	//
	{
		auto_ref_ptr<CEcb> pRef(this);

		sc = ScSetIOCompleteCallback(IO_COMPLETION);
		if (SUCCEEDED(sc))
		{
			if (m_pecb->ServerSupportFunction( m_pecb->ConnID,
											   HSE_REQ_ASYNC_READ_CLIENT,
											   pbBuf,
											   reinterpret_cast<LPDWORD>(pcbBuf),
											   NULL ))
			{
				EcbTrace( "DAV: TID %3d: 0x%08lX: CEcb::ScAsyncRead() I/O pending...\n", GetCurrentThreadId(), this );
				pRef.relinquish();
			}
			else
			{
				EcbTrace( "CEcb::ScAsyncRead() - ServerSupportFunction(HSE_REQ_ASYNC_READ_CLIENT) failed with last error 0x%08lX\n", GetLastError() );
				sc = HRESULT_FROM_WIN32(GetLastError());
			}
		}
		else
		{
			EcbTrace( "CEcb::ScAsyncRead() - ScSetIOCompleteCallback() failed with error 0x%08lX\n", sc );
		}

		if (FAILED(sc))
		{
			LONG cRefAsyncIO;

			//
			//	Release the instance ref we added above.
			//
			ReleaseImplInst();

			//
			//	Decrement the async I/O refcount added above.
			//
			cRefAsyncIO = InterlockedDecrement(&m_cRefAsyncIO);
			AssertSz( 0 == cRefAsyncIO,
					  "CEcb::ScAsyncRead() - m_cRefAsyncIO wrong after failed async read" );

			goto ret;
		}
	}

ret:

	return sc;
}

BOOL CEcb::FSyncTransmitHeaders( const HSE_SEND_HEADER_EX_INFO& shei )
{
	//
	//	At this point someone should have generated a response.
	//
	Assert( m_pecb->dwHttpStatusCode != 0 );

	//
	//	Try to disable the async error response mechanism.  If we succeed, then we
	//	can send a response.  If we fail then we must not send a response -- the
	//	async error response mechanism already sent one.
	//
	if ( !m_aeri.FDisable() )
	{
		DebugTrace( "CEcb::FSyncTransmitHeaders() - Async error response already in progress\n" );

		//	Do not forget to set the error, as callers will be confused if the function
		//	returns FALSE, but GetLastError() will return S_OK.
		//
		SetLastError(static_cast<ULONG>(E_FAIL));
		return FALSE;
	}

	//
	//	Send the response
	//
	if ( !m_pecb->ServerSupportFunction( m_pecb->ConnID,
										 HSE_REQ_SEND_RESPONSE_HEADER_EX,
										 const_cast<HSE_SEND_HEADER_EX_INFO *>(&shei),
										 NULL,
										 NULL ) )
	{
		DebugTrace( "CEcb::FSyncTransmitHeaders() - SSF::HSE_REQ_SEND_RESPONSE_HEADER_EX failed (%d)\n", GetLastError() );
		return FALSE;
	}

	return TRUE;
}

SCODE CEcb::ScAsyncWrite( BYTE * pbBuf,
						  DWORD  dwcbBuf,
						  IIISAsyncIOCompleteObserver& obs )
{
	SCODE sc = S_OK;

	EcbTrace( "DAV: TID %3d: 0x%08lX: CEcb::ScAsyncWrite() called...\n", GetCurrentThreadId(), this );

	//
	//	At this point someone should have generated a response.
	//
	Assert( m_pecb->dwHttpStatusCode != 0 );

	//
	//	Try to disable the async error response mechanism.  If we succeed, then we
	//	can send a response.  If we fail then we must not send a response -- the
	//	async error response mechanism already sent one.
	//
	if ( !m_aeri.FDisable() )
	{
		EcbTrace( "CEcb::ScAsyncWrite() - Async error response already in progress. Failing out with 0x%08lX\n", E_FAIL );

		//	Do not forget to set the error, as callers will be confused if the function
		//	returns FALSE, but GetLastError() will return S_OK.
		//
		sc = E_FAIL;
		goto ret;
	}

	//
	//	If there is another async IO outstanding we do not want to start one more. IIS will fail
	//	us out, and we ourselves will not be able to handle the completion of initial async IO
	//	properly. So just kill the connection and return. This may happen when we attempt to
	//	send the response before the read is finished.
	//
	if (0 != InterlockedCompareExchange(&m_cRefAsyncIO,
										1,
										0))
	{
		//	The function bellow is not supported starting from IIS 6.0 but let us call it anyway
		//	just in case support becomes available - and we want to call it if the binary is
		//	running on IIS 5.0. It does not matter that much, as the bad side of not closing the
		//	connection may hang the client, or error out on subsequent request. That is ok as
		//	the path is supposed to be hit in abnormal/error conditions when clients for example
		//	send in invalid requests trying to cause denial of service or similar things.
		//		So on IIS 6.0 the connection will not be closed, we will just error out. We have
		//	not seen this path hit on IIS 6.0 anyway when runing denial of service scripts as it
		//	handles custom errors differently.
		//
		if (m_pecb->ServerSupportFunction(m_pecb->ConnID,
										  HSE_REQ_CLOSE_CONNECTION,
										  NULL,
										  NULL,
										  NULL))
		{
			EcbTrace( "CEcb::ScAsyncWrite() - More than 1 async operation. Connection closed. Failing out with error 0x%08lX\n", E_ABORT );

			sc = E_ABORT;
			goto ret;
		}
		else
		{
			EcbTrace( "CEcb::ScAsyncWrite() - More than 1 async operation. ServerSupportFunction(HSE_REQ_CLOSE_CONNECTION) "
					  "failed with last error 0x%08lX. Overriding with fatal error 0x%08lX\n", GetLastError(), E_FAIL );

			sc = E_FAIL;
			goto ret;
		}
	}

	//
	//	IIS allows only one async I/O operation at a time.  But for performance reasons it
	//	leaves it up to the ISAPI to heed the restriction.  For the same reasons, we push
	//	that responsibility off to the DAV impl.  A simple refcount tells us whether
	//	the impl has done so.
	//
	AssertSz( 1 == m_cRefAsyncIO,
			  "CEcb::ScAsyncWrite() - m_cRefAsyncIO wrong on entry" );

	//
	//	We need to hold a ref on the process-wide instance data for the duration of the I/O
	//	so that if IIS tells us to shut down while the I/O is still pending we will keep
	//	the instance data alive until we're done with the I/O.
	//
	AddRefImplInst();

	//
	//	Set the async I/O completion observer
	//
	m_pobsAsyncIOComplete = &obs;

	//
	//	Set up the async I/O completion routine and start writing.
	//	Add a ref for the I/O completion thread.  Use auto_ref_ptr
	//	to make things exception-proof.
	//
	{
		auto_ref_ptr<CEcb> pRef(this);

		sc = ScSetIOCompleteCallback(IO_COMPLETION);
		if (SUCCEEDED(sc))
		{
			if (m_pecb->WriteClient( m_pecb->ConnID, pbBuf, &dwcbBuf, HSE_IO_ASYNC ))
			{
				EcbTrace( "DAV: TID %3d: 0x%08lX: CEcb::ScAsyncWrite() I/O pending...\n", GetCurrentThreadId(), this );
				pRef.relinquish();
			}
			else
			{
				EcbTrace( "CEcb::ScAsyncWrite() - _EXTENSION_CONTROL_BLOCK::WriteClient() failed with last error 0x%08lX\n", GetLastError() );
				sc = HRESULT_FROM_WIN32(GetLastError());
			}
		}
		else
		{
			EcbTrace( "CEcb::ScAsyncWrite() - ScSetIOCompleteCallback() failed with error 0x%08lX\n", sc );
		}

		if (FAILED(sc))
		{
			LONG cRefAsyncIO;

			//
			//	Release the instance ref we added above.
			//
			ReleaseImplInst();

			//
			//	Decrement the async I/O refcount added above.
			//
			cRefAsyncIO = InterlockedDecrement(&m_cRefAsyncIO);
			AssertSz( 0 == cRefAsyncIO,
					  "CEcb::ScAsyncWrite() - m_cRefAsyncIO wrong after failed async write" );

			goto ret;
		}
	}

ret:

	return sc;
}

SCODE CEcb::ScAsyncTransmitFile( const HSE_TF_INFO& tfi,
								 IIISAsyncIOCompleteObserver& obs )
{
	SCODE sc = S_OK;

	EcbTrace( "DAV: TID %3d: 0x%08lX: CEcb::ScAsyncTransmitFile() called...\n", GetCurrentThreadId(), this );

	//
	//	At this point someone should have generated a response.
	//
	Assert( m_pecb->dwHttpStatusCode != 0 );

	//
	//	Try to disable the async error response mechanism.  If we succeed, then we
	//	can send a response.  If we fail then we must not send a response -- the
	//	async error response mechanism already sent one.
	//
	if ( !m_aeri.FDisable() )
	{
		EcbTrace( "CEcb::ScAsyncTransmitFile() - Async error response already in progress. Failing out with 0x%08lX\n", E_FAIL );

		//	Do not forget to set the error, as callers will be confused if the function
		//	returns FALSE, but GetLastError() will return S_OK.
		//
		sc = E_FAIL;
		goto ret;
	}

	//
	//	If there is another async IO outstanding we do not want to start one more. IIS will fail
	//	us out, and we ourselves will not be able to handle the completion of initial async IO
	//	properly. So just kill the connection and return. This may happen when we attempt to
	//	send the response before the read is finished.
	//
	if (0 != InterlockedCompareExchange(&m_cRefAsyncIO,
										1,
										0))
	{
		//	The function bellow is not supported starting from IIS 6.0 but let us call it anyway
		//	just in case support becomes available - and we want to call it if the binary is
		//	running on IIS 5.0. It does not matter that much, as the bad side of not closing the
		//	connection may hang the client, or error out on subsequent request. That is ok as
		//	the path is supposed to be hit in abnormal/error conditions when clients for example
		//	send in invalid requests trying to cause denial of service or similar things.
		//		So on IIS 6.0 the connection will not be closed, we will just error out. We have
		//	not seen this path hit on IIS 6.0 anyway when runing denial of service scripts as it
		//	handles custom errors differently.
		//
		if (m_pecb->ServerSupportFunction(m_pecb->ConnID,
										  HSE_REQ_CLOSE_CONNECTION,
										  NULL,
										  NULL,
										  NULL))
		{
			EcbTrace( "CEcb::ScAsyncTransmitFile() - More than 1 async operation. Connection closed. Failing out with error 0x%08lX\n", E_ABORT );

			sc = E_ABORT;
			goto ret;
		}
		else
		{
			EcbTrace( "CEcb::ScAsyncTransmitFile() - More than 1 async operation. ServerSupportFunction(HSE_REQ_CLOSE_CONNECTION) "
					  "failed with last error 0x%08lX. Overriding with fatal error 0x%08lX\n", GetLastError(), E_FAIL );

			sc = E_FAIL;
			goto ret;
		}
	}

	//
	//	IIS allows only one async I/O operation at a time.  But for performance reasons it
	//	leaves it up to the ISAPI to heed the restriction.  For the same reasons, we push
	//	that responsibility off to the DAV impl.  A simple refcount tells us whether
	//	the impl has done so.
	//
	AssertSz( 1 == m_cRefAsyncIO,
			  "CEcb::ScAsyncTransmitFile() - m_cRefAsyncIO wrong on entry" );

	//
	//	We need to hold a ref on the process-wide instance data for the duration of the I/O
	//	so that if IIS tells us to shut down while the I/O is still pending we will keep
	//	the instance data alive until we're done with the I/O.
	//
	AddRefImplInst();

	//
	//	Async I/O completion routine and context should have been passed
	//	in as parameters.  Callers should NOT use the corresponding members
	//	of the HSE_TF_INFO structure.  IIS has to call CEcb::IISIOComplete()
	//	so that it can release the critsec.
	//
	Assert( !tfi.pfnHseIO );
	Assert( !tfi.pContext );

	//
	//	Verify that the caller has set the async I/O flag
	//
	Assert( tfi.dwFlags & HSE_IO_ASYNC );

	//
	//	Set the async I/O completion observer
	//
	m_pobsAsyncIOComplete = &obs;

	//
	//	Set up the async I/O completion routine and start transmitting.
	//	Add a ref for the I/O completion thread.  Use auto_ref_ptr
	//	to make things exception-proof.
	//
	{
		auto_ref_ptr<CEcb> pRef(this);

		sc = ScSetIOCompleteCallback(IO_COMPLETION);
		if (SUCCEEDED(sc))
		{
			if (m_pecb->ServerSupportFunction( m_pecb->ConnID,
											   HSE_REQ_TRANSMIT_FILE,
											   const_cast<HSE_TF_INFO *>(&tfi),
											   NULL,
											   NULL ))
			{
				EcbTrace( "DAV: TID %3d: 0x%08lX: CEcb::ScAsyncTransmitFile() I/O pending...\n", GetCurrentThreadId(), this );
				pRef.relinquish();
			}
			else
			{
				EcbTrace( "CEcb::ScAsyncTransmitFile() - ServerSupportFunction(HSE_REQ_TRANSMIT_FILE) failed with last error 0x%08lX\n", GetLastError() );
				sc = HRESULT_FROM_WIN32(GetLastError());
			}
		}
		else
		{
			EcbTrace( "CEcb::ScAsyncTransmitFile() - ScSetIOCompleteCallback() failed with error 0x%08lX\n", sc );
		}

		if (FAILED(sc))
		{
			LONG cRefAsyncIO;

			//
			//	Release the instance ref we added above.
			//
			ReleaseImplInst();

			//
			//	Decrement the async I/O refcount added above.
			//
			cRefAsyncIO = InterlockedDecrement(&m_cRefAsyncIO);
			AssertSz( 0 == cRefAsyncIO,
					  "CEcb::ScAsyncTransmitFile() - m_cRefAsyncIO wrong after failed async transmit file" );

			goto ret;
		}
	}

ret:

	return sc;
}

//	Other functions that start async IO with IIS. These functions are for IIS 6.0 or later
//	only. We will not even use observers on them, as the completion esentially will serve
//	just to signal some cleanup on a single string, which does not make much sense to wrap
//	it up as the observer.
//
SCODE CEcb::ScAsyncCustomError60After( const HSE_CUSTOM_ERROR_INFO& cei,
									   LPSTR pszStatus )
{
	SCODE sc = S_OK;

	EcbTrace( "DAV: TID %3d: 0x%08lX: CEcb::ScAsyncCustomError60After() called...\n", GetCurrentThreadId(), this );

	//
	//	At this point someone should have generated a response.
	//
	Assert( m_pecb->dwHttpStatusCode != 0 );

	//
	//	Try to disable the async error response mechanism.  If we succeed, then we
	//	can send a response.  If we fail then we must not send a response -- the
	//	async error response mechanism already sent one.
	//
	if ( !m_aeri.FDisable() )
	{
		EcbTrace( "CEcb::ScAsyncCustomError60After() - Async error response already in progress. Failing out with 0x%08lX\n", E_FAIL );

		//	Do not forget to set the error, as callers will be confused if the function
		//	returns FALSE, but GetLastError() will return S_OK.
		//
		sc = E_FAIL;
		goto ret;
	}

	//
	//	If there is another async IO outstanding we do not want to start one more. IIS will fail
	//	us out, and we ourselves will not be able to handle the completion of initial async IO
	//	properly. So just kill the connection and return. This may happen when we attempt to
	//	send the response before the read is finished.
	//
	if (0 != InterlockedCompareExchange(&m_cRefAsyncIO,
										1,
										0))
	{
		//	The function bellow is not supported starting from IIS 6.0 but let us call it anyway
		//	just in case support becomes available - and we want to call it if the binary is
		//	running on IIS 5.0. It does not matter that much, as the bad side of not closing the
		//	connection may hang the client, or error out on subsequent request. That is ok as
		//	the path is supposed to be hit in abnormal/error conditions when clients for example
		//	send in invalid requests trying to cause denial of service or similar things.
		//		So on IIS 6.0 the connection will not be closed, we will just error out. We have
		//	not seen this path hit on IIS 6.0 anyway when runing denial of service scripts as it
		//	handles custom errors differently.
		//
		if (m_pecb->ServerSupportFunction(m_pecb->ConnID,
										  HSE_REQ_CLOSE_CONNECTION,
										  NULL,
										  NULL,
										  NULL))
		{
			EcbTrace( "CEcb::ScAsyncCustomError60After() - More than 1 async operation. Connection closed. Failing out with error 0x%08lX\n", E_ABORT );

			sc = E_ABORT;
			goto ret;
		}
		else
		{
			EcbTrace( "CEcb::ScAsyncCustomError60After() - More than 1 async operation. ServerSupportFunction(HSE_REQ_CLOSE_CONNECTION) "
					  "failed with last error 0x%08lX. Overriding with fatal error 0x%08lX\n", GetLastError(), E_FAIL );

			sc = E_FAIL;
			goto ret;
		}
	}

	//
	//	IIS allows only one async I/O operation at a time.  But for performance reasons it
	//	leaves it up to the ISAPI to heed the restriction.  For the same reasons, we push
	//	that responsibility off to the DAV impl.  A simple refcount tells us whether
	//	the impl has done so.
	//
	AssertSz( 1 == m_cRefAsyncIO,
			  "CEcb::ScAsyncCustomError60After() - m_cRefAsyncIO wrong on entry" );

	//
	//	We need to hold a ref on the process-wide instance data for the duration of the I/O
	//	so that if IIS tells us to shut down while the I/O is still pending we will keep
	//	the instance data alive until we're done with the I/O.
	//
	AddRefImplInst();

	//
	//	Verify that the caller has set the async I/O flag
	//
	Assert( TRUE == cei.fAsync );

	//
	//	Set up the async I/O completion routine and start transmitting.
	//	Add a ref for the I/O completion thread.  Use auto_ref_ptr
	//	to make things exception-proof.
	//
	{
		auto_ref_ptr<CEcb> pRef(this);

		sc = ScSetIOCompleteCallback(CUSTERR_COMPLETION);
		if (SUCCEEDED(sc))
		{
			if (m_pecb->ServerSupportFunction( m_pecb->ConnID,
											   HSE_REQ_SEND_CUSTOM_ERROR,
											   const_cast<HSE_CUSTOM_ERROR_INFO *>(&cei),
											   NULL,
											   NULL ))
			{
				EcbTrace( "DAV: TID %3d: 0x%08lX: CEcb::ScAsyncCustomError60After() I/O pending...\n", GetCurrentThreadId(), this );
				pRef.relinquish();
			}
			else
			{
				EcbTrace( "CEcb::ScAsyncCustomError60After() - ServerSupportFunction(HSE_REQ_SEND_CUSTOM_ERROR) failed with last error 0x%08lX\n", GetLastError() );
				sc = HRESULT_FROM_WIN32(GetLastError());
			}
		}
		else
		{
			EcbTrace( "CEcb::ScAsyncCustomError60After() - ScSetIOCompleteCallback() failed with error 0x%08lX\n", sc );
		}

		if (FAILED(sc))
		{
			LONG cRefAsyncIO;

			//
			//	Release the instance ref we added above.
			//
			ReleaseImplInst();

			//
			//	Decrement the async I/O refcount added above.
			//
			cRefAsyncIO = InterlockedDecrement(&m_cRefAsyncIO);
			AssertSz( 0 == cRefAsyncIO,
					  "CEcb::ScAsyncCustomError60After() - m_cRefAsyncIO wrong after failed async custom error" );

			goto ret;
		}
	}

	//	We need to take ownership of the status string that was passed in in the case of success
	//	From looking in the code in IIS it does not mater if we keep it alive until completion,
	//	as it is anyway realocated before going onto another thread. But just in case something
	//	changes and to be doing what IIS people asked us to do we will keep it alive. String has
	//	the format of "nnn reason".
	//
	m_pszStatus.take_ownership(pszStatus);

ret:

	return sc;
}

SCODE CEcb::ScAsyncExecUrl60After( const HSE_EXEC_URL_INFO& eui )
{
	SCODE sc = S_OK;

	EcbTrace( "DAV: TID %3d: 0x%08lX: CEcb::ScAsyncExecUrl60After() called...\n", GetCurrentThreadId(), this );

	//
	//	At this point someone should have generated a response.
	//
	Assert( m_pecb->dwHttpStatusCode != 0 );

	//
	//	Try to disable the async error response mechanism.  If we succeed, then we
	//	can send a response.  If we fail then we must not send a response -- the
	//	async error response mechanism already sent one.
	//
	if ( !m_aeri.FDisable() )
	{
		EcbTrace( "CEcb::ScAsyncExecUrl60After() - Async error response already in progress. Failing out with 0x%08lX\n", E_FAIL );

		sc = E_FAIL;
		goto ret;
	}

	//
	//	If there is another async IO outstanding we do not want to start one more. IIS will fail
	//	us out, and we ourselves will not be able to handle the completion of initial async IO
	//	properly. So just kill the connection and return. This may happen when we attempt to
	//	send the response before the read is finished.
	//
	if (0 != InterlockedCompareExchange(&m_cRefAsyncIO,
										1,
										0))
	{
		//	The function bellow is not supported starting from IIS 6.0 but let us call it anyway
		//	just in case support becomes available - and we want to call it if the binary is
		//	running on IIS 5.0. It does not matter that much, as the bad side of not closing the
		//	connection may hang the client, or error out on subsequent request. That is ok as
		//	the path is supposed to be hit in abnormal/error conditions when clients for example
		//	send in invalid requests trying to cause denial of service or similar things.
		//		So on IIS 6.0 the connection will not be closed, we will just error out. We have
		//	not seen this path hit on IIS 6.0 anyway when runing denial of service scripts as it
		//	handles custom errors differently.
		//
		if (m_pecb->ServerSupportFunction(m_pecb->ConnID,
										  HSE_REQ_CLOSE_CONNECTION,
										  NULL,
										  NULL,
										  NULL))
		{
			EcbTrace( "CEcb::ScAsyncExecUrl60After() - More than 1 async operation. Connection closed. Failing out with error 0x%08lX\n", E_ABORT );

			sc = E_ABORT;
			goto ret;
		}
		else
		{
			EcbTrace( "CEcb::ScAsyncExecUrl60After() - More than 1 async operation. ServerSupportFunction(HSE_REQ_CLOSE_CONNECTION) "
					  "failed with last error 0x%08lX. Overriding with fatal error 0x%08lX\n", GetLastError(), E_FAIL );

			sc = E_FAIL;
			goto ret;
		}
	}

	//
	//	IIS allows only one async I/O operation at a time.  But for performance reasons it
	//	leaves it up to the ISAPI to heed the restriction.  For the same reasons, we push
	//	that responsibility off to the DAV impl.  A simple refcount tells us whether
	//	the impl has done so.
	//
	AssertSz( 1 == m_cRefAsyncIO,
			  "CEcb::ScAsyncExecUrl60After() - m_cRefAsyncIO wrong on entry" );

	//
	//	We need to hold a ref on the process-wide instance data for the duration of the I/O
	//	so that if IIS tells us to shut down while the I/O is still pending we will keep
	//	the instance data alive until we're done with the I/O.
	//
	AddRefImplInst();

	//
	//	Set up the async I/O completion routine and start transmitting.
	//	Add a ref for the I/O completion thread.  Use auto_ref_ptr
	//	to make things exception-proof.
	//
	{
		auto_ref_ptr<CEcb> pRef(this);

		sc = ScSetIOCompleteCallback(EXECURL_COMPLETION);
		if (SUCCEEDED(sc))
		{
			if (m_pecb->ServerSupportFunction( m_pecb->ConnID,
											   HSE_REQ_EXEC_URL,
											   const_cast<HSE_EXEC_URL_INFO *>(&eui),
											   NULL,
											   NULL ))
			{
				EcbTrace( "DAV: TID %3d: 0x%08lX: CEcb::ScAsyncExecUrl60After() I/O pending...\n", GetCurrentThreadId(), this );
				pRef.relinquish();
			}
			else
			{
				EcbTrace( "CEcb::ScAsyncExecUrl60After() - ServerSupportFunction(HSE_REQ_EXEC_URL) failed with last error 0x%08lX\n", GetLastError() );
				sc = HRESULT_FROM_WIN32(GetLastError());
			}
		}
		else
		{
			EcbTrace( "CEcb::ScAsyncExecUrl60After() - ScSetIOCompleteCallback() failed with error 0x%08lX\n", sc );
		}

		if (FAILED(sc))
		{
			LONG cRefAsyncIO;

			//
			//	Release the instance ref we added above.
			//
			ReleaseImplInst();

			//
			//	Decrement the async I/O refcount added above.
			//
			cRefAsyncIO = InterlockedDecrement(&m_cRefAsyncIO);
			AssertSz( 0 == cRefAsyncIO,
					  "CEcb::ScAsyncExecUrl60After() - m_cRefAsyncIO wrong after failed async exec url" );

			goto ret;
		}
	}

ret:

	return sc;
}

SCODE CEcb::ScSetIOCompleteCallback( LONG lCompletion )
{
	SCODE sc = S_OK;

	//
	//	Do not reset the completion function if it is already set to the
	//	same one we want to set. There is no need to protect the member
	//	variable against multithreaded access as the callers of this
	//	function are already protecting against the overlap of 2 async
	//	IO-s and this function is the only one changing variable value
	//	and is always called within protected zone.
	//
	if ( lCompletion != m_lSetIISIOCompleteCallback )
	{
		//
		//	Figure out what completion function we need
		//
		PFN_HSE_IO_COMPLETION pfnCallback;

		if (IO_COMPLETION == lCompletion)
		{
			pfnCallback = reinterpret_cast<PFN_HSE_IO_COMPLETION>(IISIOComplete);
		}
		else if (CUSTERR_COMPLETION == lCompletion)
		{
			pfnCallback = reinterpret_cast<PFN_HSE_IO_COMPLETION>(CustomErrorIOCompletion);
		}
		else if (EXECURL_COMPLETION == lCompletion)
		{
			pfnCallback = reinterpret_cast<PFN_HSE_IO_COMPLETION>(ExecuteUrlIOCompletion);
		}
		else
		{
			EcbTrace( "CEcb::ScSetIOCompleteCallback() - attempting to set unknown completion function. Failing out with 0x%08lX\n", E_FAIL );

			sc = E_FAIL;
			goto ret;
		}

		//	Set the IIS I/O completion routine to the requested one. Some of those
		//	routines will simply handle the completion, others will forward to the
		//	right observer.
		//
		if (!m_pecb->ServerSupportFunction(m_pecb->ConnID,
										   HSE_REQ_IO_COMPLETION,
										   pfnCallback,
										   NULL,
										   reinterpret_cast<LPDWORD>(this)))
		{
			EcbTrace( "CEcb::ScSetIOCompleteCallback() - ServerSupportFunction(HSE_REQ_IO_COMPLETION) failed with last error 0x%08lX\n", GetLastError() );

			sc = HRESULT_FROM_WIN32(GetLastError());
			goto ret;
		}

		m_lSetIISIOCompleteCallback = lCompletion;
	}

ret:

	return sc;
}

VOID WINAPI
CEcb::IISIOComplete( const EXTENSION_CONTROL_BLOCK * pecbIIS,
					 CEcb * pecb,
					 DWORD dwcbIO,
					 DWORD dwLastError )
{
	BOOL fCaughtException = FALSE;

	//	PLEASE SEE *** EXTREMELY IMPORTANT NOTE *** near the bottom of this
	//	function for more information on the proper way to unwind (deinit())
	//	this auto_ref_ptr!
	//
	auto_ref_ptr<CEcb> pThis;

	//
	//	Don't let thrown C++ exceptions propagate out of this entrypoint.
	//
	try
	{
		//
		//	Translate async Win32 exceptions into thrown C++ exceptions.
		//	This must be placed inside the try block!
		//
		CWin32ExceptionHandler win32ExceptionHandler;
		LONG cRefAsyncIO;

		//
		//	Take ownership of the reference added
		//	on our behalf by the thread that started the async I/O.
		//
		pThis.take_ownership(pecb);

		EcbTrace( "DAV: TID %3d: 0x%08lX: CEcb::IISIOComplete() called\n", GetCurrentThreadId(), pecb );

		//
		//	A quick sanity check to make sure the context
		//	is really us...
		//
		Assert( !IsBadReadPtr( pecb, sizeof(CEcb) ) );
		Assert( pecb->m_pecb == pecbIIS );

		IIISAsyncIOCompleteObserver * pobsAsyncIOComplete = pThis->m_pobsAsyncIOComplete;

		//
		//	Decrement the async I/O refcount added by the routine that
		//	started the async I/O.  Do this before calling the I/O
		//	completion routine which can start new async I/O.
		//
		cRefAsyncIO = InterlockedDecrement(&pThis->m_cRefAsyncIO);
		AssertSz( 0 == cRefAsyncIO,
				  "CEcb::IISIOComplete() - m_cRefAsyncIO wrong after async I/O complete" );

		//	Tell the observer that the I/O is complete
		//
		pobsAsyncIOComplete->IISIOComplete( dwcbIO, dwLastError );
	}
	catch ( CDAVException& )
	{
		fCaughtException = TRUE;
	}

	//
	//	If we caught an exception then handle it as best we can
	//
	if ( fCaughtException )
	{
		//
		//	If we have a CEcb then use it to handle the exception.
		//	If we don't have one then there's nothing we can do --
		//	there is no way to return any status from this function.
		//
		if ( pThis.get() )
			(VOID) pThis->HSEHandleException();
	}

	//
	//	Release the instance ref added by the routine that started the async I/O.
	//	We must do this as the VERY LAST THING(tm) before returning control back
	//	to IIS because during shutdown, this could be the last reference to the
	//	instance data.
	//
	//	EXTREMELY IMPORTANT NOTE: If this is the last reference on the instance
	//	data, everything will get torn down (we're finished with everything, so
	//	we can clean up everything).  Specifically, our HEAPS will be DESTROYED
	//	here in this situation.  Hence, we need to clear out the auto_ref_ptr
	//	from above ********** BEFORE ********** we call ReleaseImplInst().
	//	Otherwise, we could end up trying to touch the reference count on the
	//	CEcb object pointed to by the auto_ref_ptr AFTER we have destroyed the
	//	heap it was allocated on.  This is A BAD THING(tm).
	//
	//	This bug was found in IIS stress on 18 June 1999, and was filed as NTRAID
	//	bug #358578.
	//

	//	Per "EXTREMELY IMPORTANT NOTE" above: CLEAR the auto_ref_ptr
	//	********** BEFORE ********** calling ReleaseImplInst().
	//
	pThis.clear();

	//	Now it is safe to call ReleaseImplInst().
	//
	ReleaseImplInst();
}

VOID WINAPI
CEcb::CustomErrorIOCompletion ( const EXTENSION_CONTROL_BLOCK * pecbIIS,
								CEcb * pecb,
								DWORD dwcbIO,
								DWORD dwLastError )
{
	auto_ref_ptr<CEcb> pThis;
	LONG cRefAsyncIO;

	//
	//	Take ownership of the reference added
	//	on our behalf by the thread that started the async I/O.
	//
	pThis.take_ownership(pecb);

	//
	//	Decrement the async I/O refcount added by the routine that
	//	started the async I/O.
	//
	cRefAsyncIO = InterlockedDecrement(&pThis->m_cRefAsyncIO);
	AssertSz( 0 == cRefAsyncIO,
			  "CEcb::CustomErrorIOCompletion() - m_cRefAsyncIO wrong after async I/O complete" );


	EcbTrace( "Custom Error finished with dwcbIO = %d, error = %d\n", dwcbIO, dwLastError);
	EcbTrace( "More info about the request:\n");
	EcbTrace( "\tcbSize             = %lu\n",    pecbIIS->cbSize );
	EcbTrace( "\tdwVersion          = %lu\n",    pecbIIS->dwVersion );
	EcbTrace( "\tlpszMethod         = \"%s\"\n", pecbIIS->lpszMethod );
	EcbTrace( "\tlpszQueryString    = \"%s\"\n", pecbIIS->lpszQueryString );
	EcbTrace( "\tlpszPathInfo       = \"%s\"\n", pecbIIS->lpszPathInfo );
	EcbTrace( "\tlpszPathTranslated = \"%s\"\n", pecbIIS->lpszPathTranslated );
	EcbTrace( "\tcbTotalBytes       = %lu\n",    pecbIIS->cbTotalBytes );
	EcbTrace( "\tcbAvailable        = %lu\n",    pecbIIS->cbAvailable );
	EcbTrace( "\tlpszContentType    = \"%s\"\n", pecbIIS->lpszContentType );
	EcbTrace( "\n" );

	//	We need to make sure that last release of memory is finished before we release
	//	ref on CImplInst (as when CImplInst goes away so does our heap and we do not
	//	want to do operations on memory if the heap itself is gone).
	//
	pThis.clear();
	ReleaseImplInst();
}

VOID WINAPI
CEcb::ExecuteUrlIOCompletion( const EXTENSION_CONTROL_BLOCK * pecbIIS,
							  CEcb * pecb,
							  DWORD dwcbIO,
							  DWORD dwLastError )
{
	auto_ref_ptr<CEcb> pThis;
	LONG cRefAsyncIO;

	//
	//	Take ownership of the reference added
	//	on our behalf by the thread that started the async I/O.
	//
	pThis.take_ownership(pecb);

	//
	//	Decrement the async I/O refcount added by the routine that
	//	started the async I/O.
	//
	cRefAsyncIO = InterlockedDecrement(&pThis->m_cRefAsyncIO);
	AssertSz( 0 == cRefAsyncIO,
			  "CEcb::CustomErrorIOCompletion() - m_cRefAsyncIO wrong after async I/O complete" );


	EcbTrace( "Exec_URL finished with dwcbIO = %d, error = %d\n", dwcbIO, dwLastError);
	EcbTrace( "More info about the request:\n");
	EcbTrace( "\tcbSize             = %lu\n",    pecbIIS->cbSize );
	EcbTrace( "\tdwVersion          = %lu\n",    pecbIIS->dwVersion );
	EcbTrace( "\tlpszMethod         = \"%s\"\n", pecbIIS->lpszMethod );
	EcbTrace( "\tlpszQueryString    = \"%s\"\n", pecbIIS->lpszQueryString );
	EcbTrace( "\tlpszPathInfo       = \"%s\"\n", pecbIIS->lpszPathInfo );
	EcbTrace( "\tlpszPathTranslated = \"%s\"\n", pecbIIS->lpszPathTranslated );
	EcbTrace( "\tcbTotalBytes       = %lu\n",    pecbIIS->cbTotalBytes );
	EcbTrace( "\tcbAvailable        = %lu\n",    pecbIIS->cbAvailable );
	EcbTrace( "\tlpszContentType    = \"%s\"\n", pecbIIS->lpszContentType );
	EcbTrace( "\n" );

	//	We need to make sure that last release of memory is finished before we release
	//	ref on CImplInst (as when CImplInst goes away so does our heap and we do not
	//	want to do operations on memory if the heap itself is gone).
	//
	pThis.clear();
	ReleaseImplInst();
}

//	This is how we execute a child in any IIS version before IIS 6.0
//
SCODE CEcb::ScSyncExecuteChildWide60Before( LPCWSTR pwszUrl,
											LPCSTR pszQueryString,
											BOOL fCustomErrorUrl )
{
	SCODE sc = S_OK;

	auto_heap_ptr<CHAR> pszUrlEscaped;
	CStackBuffer<CHAR, MAX_PATH> pszUrl;
	DWORD dwExecFlags;
	LPCSTR pszUrlToForward;
	LPCSTR pszVerb = NULL;
	UINT cch;
	UINT cb;
	UINT cbQueryString = 0;

	Assert( m_pecb );
	Assert( pwszUrl );

	cch = static_cast<UINT>(wcslen(pwszUrl));
	Assert(L'\0' == pwszUrl[cch]);
	cb = cch * 3;

	if (pszQueryString)
	{
		cbQueryString = static_cast<UINT>(strlen(pszQueryString));
	}

	//	Resize the buffer to the sufficient size, leave place for '\0' termination.
	//	We also add the length of the query string there, although it is not necessary
	//	at this step - but in many cases it will save us the allocation afterwards,
	//	as we already will have sufficient buffer even for escaped version of the string.
	//
	if (!pszUrl.resize(cb + cbQueryString + 1))
	{
		sc = E_OUTOFMEMORY;
		DebugTrace("CEcb::ScSyncExecuteChildWide60Before() - Error while allocating memory 0x%08lX\n", sc);
		goto ret;
	}

	//	Convert URL to skinny including '\0' termination.
	//
	cb = WideCharToMultiByte(CP_UTF8,
							 0,
							 pwszUrl,
							 cch + 1,
							 pszUrl.get(),
							 cb + 1,
							 0,
							 0);
	if (0 == cb)
	{
		sc = HRESULT_FROM_WIN32(GetLastError());
		DebugTrace("CEcb::ScSyncExecuteChildWide60Before() - WideCharToMultiByte() failed 0x%08lX\n", sc);
		goto ret;
	}

	//	Escape the URL
	//
	HttpUriEscape( pszUrl.get(), pszUrlEscaped );

	//	Handle the query string
	//
	if (cbQueryString)
	{
		//	Find out the length of new URL
		//
		cb = static_cast<UINT>(strlen(pszUrlEscaped.get()));

		//	Resize the buffer to the sufficient size, leave place for '\0' termination.
		//
		if (!pszUrl.resize(cb + cbQueryString + 1))
		{
			sc = E_OUTOFMEMORY;
			DebugTrace("CEcb::ScSyncExecuteChildWide60Before() - Error while allocating memory 0x%08lX\n", sc);
			goto ret;
		}

		//	Copy the escaped version of the URL
		//
		memcpy(pszUrl.get(), pszUrlEscaped.get(), cb);

		//	Copy the query string at the end together with it's '\0' termination.
		//
		memcpy(pszUrl.get() + cb, pszQueryString, cbQueryString + 1);

		//	Point to the constructed URL
		//
		pszUrlToForward = pszUrl.get();
	}
	else
	{
		//	In the case we do not have query string then the URL to forward to
		//	is the same as the escaped URL.
		//
		pszUrlToForward = pszUrlEscaped.get();
	}

	//	Depending on the fact if we are doing custom error or executing script
	//	determine the execution flags and the verb.
	//
	if ( fCustomErrorUrl )
	{
		//	We enable wildcard processing here, since we want
		//	to give one chance to all CE URLs.
		//	Calling into ourselves is fine here and we prevent
		//	recusrion using another scheme!
		//
		dwExecFlags = HSE_EXEC_CUSTOM_ERROR;
		if (!strcmp(LpszMethod(), gc_szHEAD))
		{
			//	If this is a HEAD request, tell whomever we
			//	forward this to to only pass back the status
			//	line and headers.
			//
			pszVerb = gc_szHEAD;
		}
		else
		{
			pszVerb = gc_szGET;
		}

		//	If we're doing a custom error then someone has
		//	already set the status code.
		//
		Assert( m_pecb->dwHttpStatusCode != 0 );
	}
	else
	{
		//	When we are executing scripts, we disable wild card
		//	execution to prevent recursion.
		//	Also the verb field is allowed to be NULL, it is optional and
		//	used only for custom error processing.
		//
		dwExecFlags = HSE_EXEC_NO_ISA_WILDCARDS;
		pszVerb = NULL;

		//	We need to set the status code here to 200 (like it
		//	was set when we were first called) just in case
		//	child ISAPIs depend on it.
		//
		SetStatusCode(200);
	}

	if (!m_pecb->ServerSupportFunction( m_pecb->ConnID,
										HSE_REQ_EXECUTE_CHILD,
										const_cast<LPSTR>(pszUrlToForward),
										reinterpret_cast<LPDWORD>(const_cast<LPSTR>(pszVerb)),
										&dwExecFlags ))
	{
		//	Reset the status code back to 0 if we failed to execute
		//	the child ISAPI because we will be handling the request
		//	ourselves later (probably by sending an error).
		//
		if (!fCustomErrorUrl)
		{
			SetStatusCode(0);
		}

		sc = HRESULT_FROM_WIN32(GetLastError());
		DebugTrace("CEcb::ScSyncExecuteChildWide60Before() - ServerSupportFunction(HSE_REQ_EXECUTE_CHILD) failed with error 0x%08lX\n", sc);
		goto ret;
	}

	//	Set the flag stating that we have successfully executed a child ISAPI.
	//
	m_fChildISAPIExecSuccess = TRUE;

ret:

	return sc;
}

SCODE CEcb::ScAsyncExecUrlWide60After( LPCWSTR pwszUrl,
									   LPCSTR pszQueryString,
									   BOOL fCustomErrorUrl )
{
	SCODE sc = S_OK;
	HSE_EXEC_URL_INFO execUrlInfo;

	auto_heap_ptr<CHAR> pszUrlEscaped;
	CStackBuffer<CHAR, MAX_PATH> pszUrl;
	UINT cch;
	UINT cb;
	UINT cbQueryString = 0;

	Assert( m_pecb );
	Assert( pwszUrl );
	Assert(!fCustomErrorUrl);	//	In IIS60 custom error is NOT done by execute URL


	cch = static_cast<UINT>(wcslen(pwszUrl));
	Assert(L'\0' == pwszUrl[cch]);
	cb = cch * 3;

	if (pszQueryString)
	{
		cbQueryString = static_cast<UINT>(strlen(pszQueryString));
	}

	//	Resize the buffer to the sufficient size, leave place for '\0' termination.
	//	We also add the length of the query string there, although it is not necessary
	//	at this step - but in many cases it will save us the allocation afterwards,
	//	as we already will have sufficient buffer even for escaped version of the string.
	//
	if (!pszUrl.resize(cb + cbQueryString + 1))
	{
		sc = E_OUTOFMEMORY;
		DebugTrace("CEcb::ScAsyncExecUrlWide60After() - Error while allocating memory 0x%08lX\n", sc);
		goto ret;
	}

	//	Convert to skinny including '\0' termination
	//
	cb = WideCharToMultiByte(CP_UTF8,
							 0,
							 pwszUrl,
							 cch + 1,
							 pszUrl.get(),
							 cb + 1,
							 0,
							 0);
	if (0 == cb)
	{
		sc = HRESULT_FROM_WIN32(GetLastError());
		DebugTrace("CEcb::ScAsyncExecUrlWide60After() - WideCharToMultiByte() failed 0x%08lX\n", sc);
		goto ret;
	}

	//	Escape the URL
	//
	HttpUriEscape( pszUrl.get(), pszUrlEscaped );

	//	Handle the query string
	//
	if (cbQueryString)
	{
		//	Find out the length of new URL
		//
		cb = static_cast<UINT>(strlen(pszUrlEscaped.get()));

		//	Resize the buffer to the sufficient size, leave place for '\0' termination.
		//
		if (!pszUrl.resize(cb + cbQueryString + 1))
		{
			sc = E_OUTOFMEMORY;
			DebugTrace("CEcb::ScAsyncExecUrlWide60After() - Error while allocating memory 0x%08lX\n", sc);
			goto ret;
		}

		//	Copy the escaped version of the URL
		//
		memcpy(pszUrl.get(), pszUrlEscaped.get(), cb);

		//	Copy the query string at the end together with it's '\0' termination.
		//
		memcpy(pszUrl.get() + cb, pszQueryString, cbQueryString + 1);

		//	Point to the constructed URL
		//
		execUrlInfo.pszUrl = pszUrl.get();
	}
	else
	{
		//	In the case we do not have query string then the URL to forward to
		//	is the same as the escaped URL.
		//
		execUrlInfo.pszUrl = pszUrlEscaped.get();
	}

	//	Initialize method name
	//
	execUrlInfo.pszMethod = NULL;

	//	Initialize child headers
	//
	execUrlInfo.pszChildHeaders = NULL;

	//	We don't need a new user context,
	//
	execUrlInfo.pUserInfo = NULL;

	//	We don't need a new entity either
	//
	execUrlInfo.pEntity = NULL;

	//	Pick up the execution flags
	//
	execUrlInfo.dwExecUrlFlags = HSE_EXEC_URL_DISABLE_CUSTOM_ERROR;

	//	We need to set the status code here to 200 (like it
	//	was set when we were first called) just in case
	//	child ISAPIs depend on it.
	//
	SetStatusCode(200);

	sc = ScAsyncExecUrl60After( execUrlInfo );
	if (FAILED(sc))
	{
		//	Reset the status code back to 0 if we failed to execute
		//	the child ISAPI because we will be handling the request
		//	ourselves later (probably by sending an error).
		//
		SetStatusCode(0);

		DebugTrace("CEcb::ScAsyncExecUrlWide60After() - CEcb::ScAsyncExecUrl60After() failed with error 0x%08lX\n", sc);
		goto ret;
	}

	//	Set the flag stating that we have successfully executed a child ISAPI.
	//
	m_fChildISAPIExecSuccess = TRUE;

ret:

	return sc;
}

SCODE CEcb::ScSendRedirect( LPCSTR pszURI )
{
	SCODE sc = S_OK;

	//
	//	We cannot assert that the dwHttpStatusCode status code in ECB is
	//	some particular value. On IIS 5.X it will be 0, IIS 6.0 has changed
	//	the behaviour and will shuffle 200 into it upon calling us. Also we
	//	have seen ourselves be called from IIS 6.0 when If-Modified-Since,
	//	Translate: t request is given which is the bug in IIS (WB 277208),
	//	as in that case IIS must be handling that. So untill we could assert
	//	for the response code to be 0 (IIS 5.X) or 200 (IIS 6.0) we will have
	//	to wait till IIS 6.0 is fixed up.
	//

	//
	//	Fill in the appropriate status code in the ECB
	//	(for IIS logging).
	//
	SetStatusCode(HSC_MOVED_TEMPORARILY);

	//
	//	Attempt to send a redirection response.  If successful then
	//	the response will be handled by IIS.  If unsuccessful
	//	then we will handle the response later.
	//
	Assert( pszURI );
	DWORD cbURI = static_cast<DWORD>(strlen( pszURI ) * sizeof(CHAR));

	if ( !m_pecb->ServerSupportFunction( m_pecb->ConnID,
										 HSE_REQ_SEND_URL_REDIRECT_RESP,
										 const_cast<LPSTR>(pszURI),
										 &cbURI,
										 NULL ) )
	{
		//
		//	Reset the status code back to 0 if we failed to send
		//	the redirect because we will be handling the request
		//	ourselves later (probably by sending an error).
		//
		SetStatusCode(0);

		sc = HRESULT_FROM_WIN32(GetLastError());
		DebugTrace( "CEcb::ScSendRedirect() - ServerSupportFunction(HSE_REQ_SEND_URL_REDIRECT_RESP) failed with error 0x%08lX\n", sc );
		goto ret;
	}

ret:

	return sc;
}

//	------------------------------------------------------------------------
//
//	CEcb::FProcessingCEUrl()
//
//	Find out if we are called with a CE URL.
//	Important to avoid recursive invocation while
//	doing custom error URLs.
//

BOOL
CEcb::FProcessingCEUrl( ) const
{
	//	Assume that we are not doing custom error processing.
	//	For IIS 6.0 and after it is always the right thing to assume,
	//	due to the changes in behaviour from IIS 5.x
	//
	BOOL fCustErr = FALSE;

	//	In the case of IIS 5.x we do the usual determinatin.
	//
	if (m_pecb->dwVersion < IIS_VERSION_6_0)
	{
		//	By default assume custom error processing.
		//	Why? Suppose somebody forgets to tell us that
		//	it is a custom error url. We dont want recursive
		//	calls in that case. So it is safer to assume that
		//	we are doing custom error processing. This is only
		//	used to determine if we want to invoke custom
		//	error URLs and hence has no other side effects.
		//
		DWORD	dwExecFlags = HSE_EXEC_CUSTOM_ERROR;

		if (!(m_pecb->ServerSupportFunction( m_pecb->ConnID,
										  HSE_REQ_GET_EXECUTE_FLAGS,
										  NULL,
										  NULL,
										  &dwExecFlags )))
		{
			DebugTrace("CEcb::FProcessingCEUrl Server supportFunction call failed.\n");
			DebugTrace("CEcb::FProcessingCEUrl Assuming custom error processing.\n");
		}

		fCustErr = !!(dwExecFlags & HSE_EXEC_CUSTOM_ERROR);
	}

	return fCustErr;
}



//	========================================================================
//
//	FREE FUNCTIONS
//

//	------------------------------------------------------------------------
//
//	NewEcb
//
IEcb * NewEcb( EXTENSION_CONTROL_BLOCK& ecbRaw,
			   BOOL fUseRawUrlMappings,
			   DWORD * pdwHSEStatusRet )
{
	Assert( !IsBadWritePtr(pdwHSEStatusRet, sizeof(DWORD)) );


	auto_ref_ptr<CEcb> pecb;

	pecb.take_ownership(new CEcb(ecbRaw));

	if ( pecb->FInitialize(fUseRawUrlMappings) )
		return pecb.relinquish();

	//
	//	If we couldn't init, there are two cases: If there is a status code
	//	set into the (raw) ECB, then the error was that LpszRequestUrl() returned
	//	NULL (bad URL).  In this case, we need to go ahead and send a response to
	//	the client that is appropriate (400 Bad Request) and then continue on
	//	the way we normally would.  Since the CEcb was already constructed, we can
	//	do everything just as we would for a normal request, calling
	//	DoneWithSession() and then returning HSE_STATUS_PENDING to IIS.
	//
	//	If there was NOT a status code in the (raw) ECB, we just treat it as an
	//	exception.  Think of this as functionally equal to throwing from a
	//	constructor.
	//
	if (ecbRaw.dwHttpStatusCode)
	{
		//
		//	The only path that can get here right now is if LpszRequestUrl()
		//	returns NULL during the CEcb FInitialize() call.  Assert that
		//	we had 400 (Bad Request) in the ECB.
		//
		Assert(HSC_BAD_REQUEST == ecbRaw.dwHttpStatusCode);

		//
		//	Send a 400 Bad Request response.  We use the async error
		//	response mechanism, but that technically doesn't matter since we
		//	are for sure are not in the middle of sending some other response on
		//	another thread (we've not even dispatched out to the actual methods
		//	(DAV*) yet).
		//
		Assert(pecb.get());
		pecb->SendAsyncErrorResponse(HSC_BAD_REQUEST,
									 gc_szDefErr400StatusLine,
									 CchConstString(gc_szDefErr400StatusLine),
									 NULL,
									 0);
		//
		//	Tell IIS that we are done with the EXTENSION_CONTROL_BLOCK that
		//	it gave us.  We must do this or IIS will not be able to shut down.
		//	If this call succeeds (doesn't except), we MUST return
		//	HSE_STATUS_PENDING to let IIS know that we claimed a ref on the
		//	EXTENSION_CONTROL_BLOCK.
		//
		pecb->DoneWithSession( FALSE );
		*pdwHSEStatusRet = HSE_STATUS_PENDING;
	}
	else
	{
		*pdwHSEStatusRet = pecb->HSEHandleException();
	}
	return NULL;
}

//	------------------------------------------------------------------------
//
//	CbMDPathW
//
ULONG CbMDPathW (const IEcb& ecb, LPCWSTR pwszURI)
{
	//	The number of bytes we returned could be more than the path needs
	//
	return static_cast<UINT>((wcslen(ecb.InstData().GetNameW()) + wcslen(pwszURI) + 1) * sizeof(WCHAR));
}

//	------------------------------------------------------------------------
//
//	MDPathFromURIW
//
VOID MDPathFromURIW (const IEcb& ecb, LPCWSTR pwszURI, LPWSTR pwszMDPath)
{
	LPCWSTR pwszVroot;

	//	If the URI is fully qualified, then somebody is not
	//	playing fair.  Gently nudge them.
	//
	Assert (pwszURI);
	Assert (pwszURI == PwszUrlStrippedOfPrefix (pwszURI));

	//	Copy the root name the instance -- MINUS the vroot
	//
	UINT cch = static_cast<UINT>(wcslen(ecb.InstData().GetNameW()));
	cch -= ecb.CchGetVirtualRootW(&pwszVroot);
	memcpy (pwszMDPath, ecb.InstData().GetNameW(), sizeof(WCHAR) * cch);

	// 	Copy the rest that is after the vroot path.
	//
	wcscpy (pwszMDPath + cch, pwszURI);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\emitting.cpp ===
/*
 *	E M I T T I N G . C P P
 *
 *	Common response bit emitters
 *
 *	Stolen from the IIS5 project 'iis5\svcs\iisrlt\string.cxx' and
 *	cleaned up to fit in with the DAV sources.
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davprs.h"
#include <dav.rh>

/*
 *	EmitLocation()
 *
 *	Purpose:
 *
 *		Helper function used to emit the location information
 *
 *	Parameters:
 *
 *		pszHeader	[in]  name of header to set
 *		pszURI		[in]  destination URI
 *		fCollection [in]  is resource a collection...
 *
 *	Note:
 *		This prefix the relative URI with the local server to get the
 *		absolute URI. this is OK as now all operations are within one
 *		vroot.
 *		Later, if we are able to COPY/MOVE across servers, then this
 *		function is not enough.
 */
void __fastcall
CMethUtil::EmitLocation (
	/* [in] */ LPCSTR pszHeader,
	/* [in] */ LPCWSTR pwszURI,
	/* [in] */ BOOL fCollection)
{
	auto_heap_ptr<CHAR> pszEscapedURI;
	BOOL fTrailing;
	CStackBuffer<WCHAR,MAX_PATH> pwsz;
	LPCWSTR pwszPrefix;
	LPCWSTR pwszServer;
	SCODE sc = S_OK;
	UINT cch;
	UINT cchURI;
	UINT cchServer;
	UINT cchPrefix;

	Assert (pszHeader);
	Assert (pwszURI);
	Assert (pwszURI == PwszUrlStrippedOfPrefix(pwszURI));

	//	Calc the length of the URI once and only once
	//
	cchURI = static_cast<UINT>(wcslen(pwszURI));

	//	See if it has a trailing slash
	//
	fTrailing = !!(L'/' == pwszURI[cchURI - 1]);

	//	See if it is fully qualified
	//
	cchPrefix = m_pecb->CchUrlPrefixW (&pwszPrefix);

	//	Get the server to use: passed in or from ECB
	//
	cchServer = m_pecb->CchGetServerNameW(&pwszServer);

	//	We know the size of the prefix, the size of the server
	//	and the size of the url.  All we need to make sure of is
	//	that there is space for a trailing slash and a terminator
	//
	cch = cchPrefix + cchServer + cchURI + 1 + 1;
	if (!pwsz.resize(cch * sizeof(WCHAR)))
		return;

	memcpy (pwsz.get(), pwszPrefix, cchPrefix * sizeof(WCHAR));
	memcpy (pwsz.get() + cchPrefix, pwszServer, cchServer * sizeof(WCHAR));
	memcpy (pwsz.get() + cchPrefix + cchServer, pwszURI, (cchURI + 1) * sizeof(WCHAR));
	cchURI += cchPrefix + cchServer;

	//	Ensure proper termination
	//
	if (fTrailing != !!fCollection)
	{
		if (fCollection)
		{
			pwsz[cchURI] = L'/';
			cchURI++;
			pwsz[cchURI] = L'\0';
		}
		else
		{
			cchURI--;
			pwsz[cchURI] = L'\0';
		}
	}
	pwszURI = pwsz.get();

	//	Make a wire url out of it.
	//
	sc = ScWireUrlFromWideLocalUrl (cchURI, pwszURI, pszEscapedURI);
	if (FAILED(sc))
	{
		//	If we can't make a wire URL for whatever reason
		//	we just won't emit a Location: header.  Oh well.
		//	It's the best we can do at this point.
		//
		return;
	}

	//	Add the appropriate header
	//
	m_presponse->SetHeader(pszHeader, pszEscapedURI.get(), FALSE);
}

/*
 *	EmitLastModified()
 *
 *	Purpose:
 *
 *		Helper function used to emit the last modified information
 *
 *	Parameters:
 *
 *		pft			[in]  last mod time
 */
void __fastcall
CMethUtil::EmitLastModified (
	/* [in] */ FILETIME * pft)
{
	SYSTEMTIME st;
	WCHAR rgwch[80];

	FileTimeToSystemTime (pft, &st);
	(VOID) FGetDateRfc1123FromSystime(&st, rgwch, CElems(rgwch));
	SetResponseHeader (gc_szLast_Modified, rgwch);
}


/*
 *	EmitCacheControlAndExpires()
 *
 *	Purpose:
 *
 *		Helper function used to emit the Cache-Control and Expires information
 *
 *	Parameters:
 *
 *		pszURI		[in]  string representing the URI for the entity to have
 *						  information generated for
 *
 *	Comments:  From the HTTP 1.1 specification, draft revision 5.
 *		13.4 Response Cachability
 *		... If there is neither a cache validator nor an explicit expiration time
 *		associated with a response, we do not expect it to be cached, but
 *		certain caches MAY violate this expectation (for example, when little
 *		or no network connectivity is available). A client can usually detect
 *		that such a response was taken from a cache by comparing the Date
 *		header to the current time.
 *			Note that some HTTP/1.0 caches are known to violate this
 *			expectation without providing any Warning.
 */
VOID __fastcall
CMethUtil::EmitCacheControlAndExpires(
	/* [in] */ LPCWSTR pwszURI)
{
	//$$BUGBUG: $$CAVEAT:  There is an inherent problem here.  We get the current
	//	system time, do some processing, and then eventually the response gets sent
	//	from IIS, at which time the Date header gets added.  However, in the case
	//	where the expiration time is 0, the Expires header should MATCH the Date
	//	header EXACTLY.  We cannot guarantee this.
	//

	static const __int64 sc_i64HundredNanoSecUnitsPerSec =
		1    *	//	second
		1000 *	//	milliseconds per second
		1000 *	//	microseconds per millisecond
		10;		//	100 nanosecond units per microsecond.

	SCODE sc;
	FILETIME ft;
	FILETIME ftExpire;
	SYSTEMTIME stExpire;
	__int64 i64ExpirationSeconds = 0;
	WCHAR rgwchExpireTime[80] = L"\0";
	WCHAR rgwchMetabaseExpireTime[80] = L"\0";
	UINT cchMetabaseExpireTime = CElems(rgwchMetabaseExpireTime);

	sc = ScGetExpirationTime(pwszURI,
							 rgwchMetabaseExpireTime,
							 &cchMetabaseExpireTime);

	if (FAILED(sc))
	{
		//	At this point, we cannot emit proper Cache-Control and Expires headers,
		//	so we do not emit them at all.  Please see the comment in this function's
		//	description above regarding non-emission of these headers.
		//
		DebugTrace("CMethUtil::EmitCacheControlAndExpires() - ScGetExpirationTime() error getting expiration time %08x\n", sc);

		//	With a buffer of 80 chars. long we should never have this problem.
		//	An HTTP date + 3 chars is as long as we should ever have to be.
		//
		Assert(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) != sc);
		return;
	}

	//	The metabase expiration string looks like:
	//	"S, HTTP DATE" --- Expires at a specific date/time.
	//	"D, 0xHEXNUM" --- Expires after a certain number of seconds.
	//	"" --- No expiration.
	//
	switch (rgwchMetabaseExpireTime[0])
	{
		default:
			Assert(L'\0' == rgwchMetabaseExpireTime[0]);
			return;

		case L'S':
		case L's':
			if (SUCCEEDED(HrHTTPDateToFileTime(&(rgwchMetabaseExpireTime[3]),
											   &ftExpire)))
			{
				//	Set our Expires header.
				//
				SetResponseHeader(gc_szExpires, &(rgwchMetabaseExpireTime[3]));

				GetSystemTimeAsFileTime(&ft);
				if (CompareFileTime(&ft, &ftExpire) >= 0)
				{
					//	If we already expired, we want cache-control to be no-cache.  This
					//	will do that.
					//
					i64ExpirationSeconds = 0;
				}
				else
				{
					i64ExpirationSeconds = ((FileTimeCastToI64(ftExpire) -
											 FileTimeCastToI64(ft)) /
											sc_i64HundredNanoSecUnitsPerSec);
				}
			}
			else
			{
				//	At this point, we cannot emit proper Cache-Control and Expires headers,
				//	so we do not emit them at all.  Please see the comment in this function's
				//	description above regarding non-emission of these headers.
				//
				DebugTrace("EmitCacheControlAndExpires: Failed to convert HTTP date to FILETIME.\n");
				return;
			}
			break;

		case L'D':
		case L'd':

			BOOL fRetTemp;

			//	Set our Expires header.
			//
			SetResponseHeader (gc_szExpires, rgwchExpireTime);

			i64ExpirationSeconds = wcstoul(&(rgwchMetabaseExpireTime[3]), NULL, 16);

			GetSystemTimeAsFileTime(&ft);
			FileTimeCastToI64(ft) = (FileTimeCastToI64(ft) +
									 (i64ExpirationSeconds * sc_i64HundredNanoSecUnitsPerSec));

			if (!FileTimeToSystemTime (&ft, &stExpire))
			{
				//	At this point, we cannot emit proper Cache-Control and Expires headers,
				//	so we do not emit them at all.  Please see the comment in this function's
				//	description above regarding non-emission of these headers.
				//
				DebugTrace("EmitCacheControlAndExpires: FAILED to convert file time "
						   "to system time for expiration time.\n");
				return;
			}

			fRetTemp = FGetDateRfc1123FromSystime (&stExpire,
				rgwchExpireTime,
				CElems(rgwchExpireTime));
			Assert(fRetTemp);

			break;
	}

	if (0 == i64ExpirationSeconds)
		SetResponseHeader(gc_szCache_Control, gc_szCache_Control_NoCache);
	else
		SetResponseHeader(gc_szCache_Control, gc_szCache_Control_Private);
}


/*
 *	ScEmitHeader()
 *
 *	Purpose:
 *
 *		Helper function used to emit the header information for
 *		GET/HEAD responses.
 *
 *	Parameters:
 *
 *		pszContent	[in]  string containing content type of resource
 *		pszURI		[optional, in] string containing the URI of the resource
 *		pftLastModification [optional, in] pointer to a FILETIME structure
 *										   representing the last modification
 *										   time for the resource
 *
 *	Returns:
 *
 *		SCODE.  S_OK (0) indicates success.
 */
SCODE __fastcall
CMethUtil::ScEmitHeader (
	/* [in] */ LPCWSTR pwszContent,
	/* [in] */ LPCWSTR pwszURI,
	/* [in] */ FILETIME * pftLastModification)
{
	SCODE sc = S_OK;

	//	In the case where we have a last modification time, we also need a URI.
	//	If we don't have a last modification time, it doesn't matter.  We don't
	//	use the URI anyway in this case.
	//
	Assert(!pftLastModification || pwszURI);

	//	See if the content is acceptable to the client, remembering
	//	that the content type is html for directories.  If we are
	//	in a strict environment and the content is not acceptable,
	//	then return that as an error code.
	//
	Assert (pwszContent);
	if (FAILED (ScIsAcceptable (this, pwszContent)))
	{
		DebugTrace ("Dav: client does not want this content type\n");
		sc = E_DAV_RESPONSE_TYPE_UNACCEPTED;
		goto ret;
	}

	//	Write the common header information, all the calls to
	//	SetResponseHeader() really cannot fail unless there is
	//	a memory error (which will throw!)
	//
	if (*pwszContent)
		SetResponseHeader (gc_szContent_Type, pwszContent);

	//	We support byte ranges for documents but not collections.  We also
	//	only emit Expires and Cache-Control headers for documents but not
	//	collections.
	//
	if (pftLastModification != NULL)
	{
		SetResponseHeader (gc_szAccept_Ranges, gc_szBytes);

		//	While we are processing documents, get the Etag too
		//
		EmitETag (pftLastModification);
		EmitLastModified (pftLastModification);
		EmitCacheControlAndExpires(pwszURI);
	}
	else
		SetResponseHeader (gc_szAccept_Ranges, gc_szNone);

ret:
	return sc;
}


//	Allow header processing ---------------------------------------------------
//
void
CMethUtil::SetAllowHeader (
	/* [in] */ RESOURCE_TYPE rt)
{
	//	We need to check if we have write permission on the directory.  If not, we should
	//	not allow PUT, DELETE, MKCOL, MOVE, or PROPPATCH.
	//
	BOOL fHaveWriteAccess = !(E_DAV_NO_IIS_WRITE_ACCESS ==
							  ScIISCheck(LpwszRequestUrl(),
										 MD_ACCESS_WRITE));

	//	The gc_szDavPublic header MUST list all the possible verbs,
	//	so that's the longest Allow: header we'll ever have.
	//	NOTE: sizeof includes the trailing NULL!
	//
	CStackBuffer<CHAR,MAX_PATH> psz(gc_cbszDavPublic);

	//	Setup the minimal set of methods
	//
	strcpy (psz.get(), gc_szHttpBase);

	//	If we have write access, then we can delete.
	//
	if (fHaveWriteAccess)
		strcat (psz.get(), gc_szHttpDelete);

	//	If the resource is not a directory, PUT will be available...
	//
	if ((rt != RT_COLLECTION) && fHaveWriteAccess)
		strcat (psz.get(), gc_szHttpPut);

	//	If a scriptmap could apply to this resource, then
	//	add in the post method
	//
	if (FInScriptMap (LpwszRequestUrl(), MD_ACCESS_EXECUTE))
		strcat (psz.get(), gc_szHttpPost);

	//	Add in the DAV basic methods
	//
	if (rt != RT_NULL)
	{
		strcat (psz.get(), gc_szDavCopy);
		if (fHaveWriteAccess) strcat (psz.get(), gc_szDavMove);
		strcat (psz.get(), gc_szDavPropfind);
		if (fHaveWriteAccess) strcat (psz.get(), gc_szDavProppatch);
		strcat (psz.get(), gc_szDavSearch);
		strcat (psz.get(), gc_szDavNotif);
		if (fHaveWriteAccess) strcat (psz.get(), gc_szDavBatchDelete);
		strcat (psz.get(), gc_szDavBatchCopy);
		if (fHaveWriteAccess)
		{
			strcat (psz.get(), gc_szDavBatchMove);
			strcat (psz.get(), gc_szDavBatchProppatch);
		}
		strcat (psz.get(), gc_szDavBatchPropfind);
	}

	//	If the resource is a directory, MKCOL will be available...
	//
	if ((rt != RT_DOCUMENT) && fHaveWriteAccess)
		strcat (psz.get(), gc_szDavMkCol);

	//	Locks should be available, it doesn't mean it will succeed...
	//
	strcat (psz.get(), gc_szDavLocks);

	//	Set the header
	//
	SetResponseHeader (gc_szAllow, psz.get());
}

//	Etags ---------------------------------------------------------------------
//
void __fastcall
CMethUtil::EmitETag (FILETIME * pft)
{
	WCHAR pwszEtag[100];

	if (FETagFromFiletime (pft, pwszEtag, GetEcb()))
		SetResponseHeader (gc_szETag, pwszEtag);
}

void __fastcall
CMethUtil::EmitETag (LPCWSTR pwszPath)
{
	FILETIME ft;

	//	Get and Emit the ETAG
	//
	if (FGetLastModTime (this, pwszPath, &ft))
		EmitETag (&ft);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\if.cpp ===
/*
 *	I F . C P P
 *
 *	If-xxx header processing and ETags for DAV resources
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davprs.h"

//$ REVIEW: This file was once the same as \exdav\davif.cpp.  
//$ REVIEW: These two files should really be merged.  They share a lot of 
//$ REVIEW: common functionality, but they have been evolving separately.
//$ REVIEW: We need to be very careful because different bug fixes have 
//$ REVIEW: been going into each of them.

//	ETag formation ------------------------------------------------------------
//
/*
 *	FETagFromFiletime()
 *
 *	Purpose:
 *
 *		Derives an ETag for a given resource or a given last modification
 *		time.
 *
 *	Parameters:
 *
 *		pft			[in]  last modification time
 *		pwszETag	[out] ETag buffer
 *      pecb		[in]  ecb so that we can access the metabase
 *
 *	Returns:
 *
 *		TRUE if ETag was created.
 */
BOOL
FETagFromFiletime (FILETIME * pft, LPWSTR pwszEtag, const IEcb * pecb)
{
	Assert (pwszEtag);
	Assert (pecb);
	
	swprintf (pwszEtag,
			 L"\"%x%x%x%x%x%x%x%x:%x\"",
			 (DWORD)(((PUCHAR)pft)[0]),
			 (DWORD)(((PUCHAR)pft)[1]),
			 (DWORD)(((PUCHAR)pft)[2]),
			 (DWORD)(((PUCHAR)pft)[3]),
			 (DWORD)(((PUCHAR)pft)[4]),
			 (DWORD)(((PUCHAR)pft)[5]),
			 (DWORD)(((PUCHAR)pft)[6]),
			 (DWORD)(((PUCHAR)pft)[7]),
			 DwMDChangeNumber(pecb));
	return TRUE;
}

//	If-xxx header processing --------------------------------------------------
//
SCODE
ScCheckEtagAgainstHeader (LPCWSTR pwszEtag, LPCWSTR pwszHeader)
{
	LPCWSTR pwsz;
	Assert (pwszHeader);

	//	Get the ETag we are going to compare against, and then
	//	look at what was passed it.  It should either be an ETAG
	//	or an '*'.  We fail if the value does not exist or the
	//	ETag does not match.
	//
	HDRITER_W hdri(pwszHeader);

	for (pwsz = hdri.PszNext(); pwsz; pwsz = hdri.PszNext())
	{
		//	Since we do not do week ETAG checking, if the
		//	ETAG starts with "W/" skip those bits
		//
		if (L'W' == *pwsz)
		{
			Assert (L'/' == pwsz[1]);
			pwsz += 2;
		}

		//	If we see stars, then we match
		//
		if (L'*' == *pwsz)
			return S_OK;
		else
		{
			//	For DAVFS, we don't do weak matching today
			//
			if (pwszEtag && !wcscmp (pwsz, pwszEtag))
				return S_OK;
		}
	}
	return E_DAV_IF_HEADER_FAILURE;
}

SCODE
ScCheckFileTimeAgainstHeader (FILETIME * pft, LPCWSTR pwszHeader)
{
	FILETIME ftHeader;
	FILETIME ftTmp;
	SYSTEMTIME st;

	Assert (pft);
	Assert (pwszHeader);

	//	The header passed in here should be an HTTP-date
	//	of the format "ddd, dd, mmm yyyy HH:mm:ss GMT".
	//	We can spit this into a SYSTEMTIME and then compare
	//	it against the filetime for the resource.
	//
	DebugTrace ("DAV: evaluating If-Unmodified-Since header\n");

	memset (&st, 0, sizeof(SYSTEMTIME));

	if (SUCCEEDED (HrHTTPDateToFileTime(pwszHeader, &ftHeader)))
	{
		FILETIME 	ftCur;
		
		//	The filetime retrieved from FGetLastModTime is acurate
		//	down to 100-nanosecond increments.  The converted date
		//	is acurate down to seconds.  Adjust for that.
		//
		FileTimeToSystemTime (pft, &st);
		st.wMilliseconds = 0;
		SystemTimeToFileTime (&st, &ftTmp);

		//	Get current time
		//
        GetSystemTimeAsFileTime(&ftCur);

		//	Compare the two filetimes
		//	Note that we also need to make sure the Modified-Since time is
		//	less than our current time
		//
		if ((CompareFileTime (&ftHeader, &ftTmp) >= 0) &&
			(CompareFileTime (&ftHeader, &ftCur) < 0))
			return S_OK;

		return E_DAV_IF_HEADER_FAILURE;
	}

	return S_FALSE;
}


SCODE
ScCheckIfHeaders(IMethUtil * pmu,
				 FILETIME * pft,
				 BOOL fGetMethod)
{
	Assert(pmu);
	WCHAR pwszEtag[CCH_ETAG];
	SideAssert(FETagFromFiletime (pft, pwszEtag, pmu->GetEcb()));
	
	return ScCheckIfHeadersFromEtag (pmu,
									 pft,
									 fGetMethod,
									 pwszEtag);
}

SCODE
ScCheckIfHeadersFromEtag (IMethUtil * pmu,
						  FILETIME* pft,
						  BOOL fGetMethod,
						  LPCWSTR pwszEtag)
{
	SCODE sc = S_OK;
	LPCWSTR pwsz;
	
	Assert (pmu);
	Assert (pft);
	Assert (pwszEtag);

	//	There're several bugs related with DAV not matching IIS behavior
	//	on these If-xxx header processing.
	//	So we now just copy their logic over
	
	//	Check the 'if-match' header
	//
	if ((pwsz = pmu->LpwszGetRequestHeader (gc_szIf_Match, FALSE)) != NULL)
	{
		DebugTrace ("DAV: evaluating 'if-match' header\n");
		sc = ScCheckEtagAgainstHeader (pwszEtag, pwsz);
		if (FAILED (sc))
			goto ret;
	}

    // Now see if we have an If-None-Match, and if so handle that.
    //
    BOOL fIsNoneMatchPassed = TRUE;
    BOOL fSkipIfModifiedSince = FALSE;
	
	if ((pwsz = pmu->LpwszGetRequestHeader (gc_szIf_None_Match, FALSE)) != NULL)
	{
		DebugTrace ("DAV: evaluating 'if-none-match' header\n");
		if (!FAILED (ScCheckEtagAgainstHeader (pwszEtag, pwsz)))
		{
			//	Etag match, so nonmatch test is NOT passed
			//
			fIsNoneMatchPassed = FALSE;
		}
		else
		{
			fSkipIfModifiedSince = TRUE;
		}
	}
	
	//	The "if-modified-since" really only applies to GET-type
	//	requests
	//
	if (!fSkipIfModifiedSince && fGetMethod)
	{
		if ((pwsz = pmu->LpwszGetRequestHeader (gc_szIf_Modified_Since, FALSE)) != NULL)
		{
			DebugTrace ("DAV: evaluating 'if-none-match' header\n");
			if (S_OK == ScCheckFileTimeAgainstHeader (pft, pwsz))
			{
				sc = fGetMethod
					 ? E_DAV_ENTITY_NOT_MODIFIED
					 : E_DAV_IF_HEADER_FAILURE;
				goto ret;
			}

			fIsNoneMatchPassed = TRUE;
		}
	}

	if (!fIsNoneMatchPassed)
	{
		sc = fGetMethod
			 ? E_DAV_ENTITY_NOT_MODIFIED
			 : E_DAV_IF_HEADER_FAILURE;
		goto ret;
	}

    // Made it through that, handle If-Unmodified-Since if we have that.
    //
	if ((pwsz = pmu->LpwszGetRequestHeader (gc_szIf_Unmodified_Since, FALSE)) != NULL)
	{
		DebugTrace ("DAV: evaluating 'if-unmodified-since' header\n");
		sc = ScCheckFileTimeAgainstHeader (pft, pwsz);
		if (FAILED (sc))
			goto ret;
	}

ret:

	if (sc == E_DAV_ENTITY_NOT_MODIFIED)
	{
		//	Let me quote from the HTTP/1.1 draft...
		//
		//	"The response MUST include the following header fields:
		//
		//	...
		//
		//	.  ETag and/or Content-Location, if the header would have been sent in
		//	a 200 response to the same request
		//
		//	..."
		//
		//	So what that means, is that we really just want to do is suppress the
		//	body of the response, set a 304 error code and do everything else as
		//	normal.  All of which is done by setting a hsc of 304.
		//
		DebugTrace ("Dav: suppressing body for 304 response\n");
		pmu->SetResponseCode (HSC_NOT_MODIFIED, NULL, 0);
		sc = S_OK;
	}

	return sc;
}

SCODE
ScCheckIfRangeHeader (IMethUtil * pmu, FILETIME * pft)
{
	Assert(pmu);
	WCHAR pwszEtag[CCH_ETAG];
	SideAssert(FETagFromFiletime (pft, pwszEtag, pmu->GetEcb()));

	return ScCheckIfRangeHeaderFromEtag (pmu, pft, pwszEtag);
}

SCODE
ScCheckIfRangeHeaderFromEtag (IMethUtil * pmu, FILETIME * pft, LPCWSTR pwszEtag)
{
	SCODE sc = S_OK;
	LPCWSTR pwsz;

	Assert (pmu);
	Assert (pft);
	Assert (pwszEtag);

	//	Check "If-Range". Do not apply URL conversion rules to this header
	//
	if ((pwsz = pmu->LpwszGetRequestHeader (gc_szIf_Range, FALSE)) != NULL)
	{
		DebugTrace ("DAV: evaluating 'if-range' header\n");

		//	The format of this header is either an ETAG or a
		//	date.  Process accordingly...
		//
		if ((L'"' == *pwsz) || (L'"' == *(pwsz + 2)))
		{
			if (L'W' == *pwsz)
			{
				Assert (L'/' == *(pwsz + 1));
				pwsz += 2;
			}
			sc = ScCheckEtagAgainstHeader (pwszEtag, pwsz);
			if (FAILED (sc))
				goto ret;
		}
		else
		{
			sc = ScCheckFileTimeAgainstHeader (pft, pwsz);
			goto ret;
		}
	}

ret:

	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\header.h ===
#ifndef _HEADER_H_
#define _HEADER_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	HEADER.H
//
//		Header for HTTP header cache class.
//		This cache is meant to hold pairs of strings, indexed by the first
//		string in the pair.  The indexing string will be treated
//		as case-insensitive (Content-Type and content-type are treated as
//		the same slot in the cache).
//
//	NOTE: Header names are NOT localized strings -- they are always 7-bit ASCII,
//		and should NEVER be treated as MBCS strings.
//		Later, this cache might make optimizations that depend on the indexing
//		string being 7-bit ASCII.
//
//	Copyright 1997 Microsoft Corporation, All Rights Reserved
//

//	========================================================================
//
//	CLASS CHeaderCache
//
#include "gencache.h"

template<class _T>
class CHeaderCache
{
	typedef CCache<CRCSzi, const _T *> CHdrCache;

	// String data storage area.
	//
	ChainedStringBuffer<_T>	m_sb;

protected:

	// Cache of header values, keyed by CRC'd name
	//
	CHdrCache					m_cache;

	//	NOT IMPLEMENTED
	//
	CHeaderCache& operator=( const CHeaderCache& );
	CHeaderCache( const CHeaderCache& );

public:
	//	CREATORS
	//
	CHeaderCache()
	{
		//	If this fails, our allocators will throw for us.
		(void)m_cache.FInit();
	}

	//	ACCESSORS
	//

	//	------------------------------------------------------------------------
	//
	//	CHeaderCache::LpszGetHeader()
	//
	//		Fetch a header from the cache.  Return the header value if found,
	//		NULL otherwise.
	//
	const _T * LpszGetHeader( LPCSTR pszName ) const
	{
		const _T ** ppszValue;

		Assert( pszName );

		ppszValue = m_cache.Lookup( CRCSzi(pszName) );
		if ( !ppszValue )
			return NULL;

		return *ppszValue;
	}

	//	MANIPULATORS
	//

	//	------------------------------------------------------------------------
	//
	//	CHeaderCache::ClearHeaders()
	//
	//		Clear all headers from the cache.
	//
	void ClearHeaders()
	{
		//	Clear all data from the map.
		//
		m_cache.Clear();

		//	Also clear out the string buffer.
		//
		m_sb.Clear();
	}
	
	//	------------------------------------------------------------------------
	//
	//	CHeaderCache::DeleteHeader()
	//
	//		Remove a header from the cache.
	//
	void DeleteHeader( LPCSTR pszName )
	{
		//
		//	Note: this just removes the cache item (i.e. the header
		//	name/value pair).  It DOES NOT free up the memory used by the
		//	header name/value strings which are stored in our string buffer.
		//	We would need a string buffer class which supports deletion
		//	(and a smarter string class) for that.
		//
		m_cache.Remove( CRCSzi(pszName) );
	}

	//	------------------------------------------------------------------------
	//
	//	CHeaderCache::SetHeader()
	//
	//		Set a header in the cache.
	//		If pszValue NULL, just set NULL as the header value.
	//		If pszValue is the empty string, just set the header string to the
	//		empty string.
	//		Return the string's cache placement (same as GetHeader) for convenience.
	//
	//	NOTE:
	//		fMultiple is an optional param that defaults to FALSE
	//
	const _T * SetHeader( LPCSTR pszName, const _T * pszValue, BOOL fMultiple = FALSE)
	{
		Assert( pszName );

		pszName = reinterpret_cast<LPCSTR>(m_sb.Append( static_cast<UINT>(strlen(pszName) + 1), reinterpret_cast<const _T *>(pszName) ));
		if ( pszValue )
		{
			if (sizeof(_T) == sizeof(WCHAR))
			{
				pszValue = m_sb.Append( static_cast<UINT>(CbSizeWsz(wcslen(reinterpret_cast<LPCWSTR>(pszValue)))), pszValue );
			}
			else
			{
				pszValue = m_sb.Append( static_cast<UINT>(strlen(reinterpret_cast<LPCSTR>(pszValue)) + 1), pszValue );
			}
		}

		if (fMultiple)
			(void)m_cache.FAdd( CRCSzi(pszName), pszValue );
		else
			(void)m_cache.FSet( CRCSzi(pszName), pszValue );

		return pszValue;
	}

};

class CHeaderCacheForResponse : public CHeaderCache<CHAR>
{
	//	========================================================================
	//
	//	CLASS CEmit
	//
	//	Functional class to emit a header name/value pair to a buffer
	//
	class CEmit : public CHdrCache::IOp
	{
		StringBuffer<CHAR>&	m_bufData;

		//	NOT IMPLEMENTED
		//
		CEmit& operator=( const CEmit& );

	public:
		CEmit( StringBuffer<CHAR>& bufData ) : m_bufData(bufData) {}

		virtual BOOL operator()( const CRCSzi& crcsziName,
								 const LPCSTR& pszValue )
		{
			//	Throw in the header name string.
			//
			m_bufData.Append( crcsziName.m_lpsz );

			//	Throw in a colon delimiter.
			//
			m_bufData.Append( gc_szColonSp );

			//	Throw in the header value string.
			//
			m_bufData.Append( pszValue );

			//	Terminate the header line (CRLF).
			//
			m_bufData.Append( gc_szCRLF );

			//	Tell the cache to keep iterating.
			//
			return TRUE;
		}
	};

	//	NOT IMPLEMENTED
	//
	CHeaderCacheForResponse& operator=( const CHeaderCacheForResponse& );
	CHeaderCacheForResponse( const CHeaderCacheForResponse& );

public:
	//	CREATORS
	//
	CHeaderCacheForResponse()
	{
	}

	void DumpData( StringBuffer<CHAR>& bufData ) const;
};

#endif // !_HEADER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\instdata.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	INSTDATA.CPP
//
//		HTTP instance data cache implementation.
//
//
//	Copyright 1997 Microsoft Corporation, All Rights Reserved
//

#include "_davprs.h"

#include <buffer.h>
#include "instdata.h"

//	========================================================================
//
//	class CInstData
//

//	------------------------------------------------------------------------
//
//	CInstData::CInstData()
//
//		Constructor.  Init all variables.  Make a copy of the name string
//		for us to keep.
//
//		NOTE: This object must be constructed while we are REVERTED.
//
CInstData::CInstData( LPCWSTR pwszName )
{
	//	Make copy of wide instance name
	//
	m_wszVRoot = WszDupWsz(pwszName);

	//	Parse out and store service instance, otherwise
	//	sometimes referred as the server ID.
	//
	m_lServerID = LInstFromVroot( m_wszVRoot );
	
	//	Create our objects.  Please read the notes about the
	//	relative costs and reasons behind creating these objects
	//	now rather than on demand.  Don't create anything here that
	//	can be created on demand unless at least one of the
	//	following is true:
	//
	//		1. The object is lightweight and cheap to create.
	//		   Example: an empty cache.
	//
	//		2. The object is used in the processing of a vast
	//		   majority of HTTP requests.
	//		   Example: any object used on every GET request.
	//
 
}

//	========================================================================
//
//	class CInstDataCache
//

//	------------------------------------------------------------------------
//
//	CInstDataCache::GetInstData()
//
//		Fetch a row from the cache.
//
CInstData& CInstDataCache::GetInstData( const IEcb& ecb )
{
	auto_ref_ptr<CInstData> pinst;
	CStackBuffer<WCHAR> pwszMetaPath;
	UINT cchMetaPath;
	CStackBuffer<WCHAR> pwszVRoot;
	UINT cchVRoot;
	LPCWSTR pwszRootName;
	UINT cchRootName;

	//	Build up a unique string from the vroot and instance:
	//	lm/w3svc/<site id>/root/<vroot name>
	//

	//	Get the virtual root from the ecb (/<vroot name>).
	//
	cchRootName = ecb.CchGetVirtualRootW( &pwszRootName );

	//	pwszRootName should still be NULL-terminated.  Check it, 'cause
	//	we're going to put the next string after there, and we don't want
	//	to get them mixed...
	//
	Assert( pwszRootName );
	Assert( L'\0' == pwszRootName[cchRootName] );

	//	Ask IIS for the metabase prefix (lm/w3svc/<site id>) for the
	//	virtual server (site) we're on...
	//
	cchMetaPath = pwszMetaPath.celems();
	if (!ecb.FGetServerVariable( "INSTANCE_META_PATH",
								 pwszMetaPath.get(),
								 reinterpret_cast<DWORD *>(&cchMetaPath) ))
	{
		if (ERROR_INSUFFICIENT_BUFFER != GetLastError())
		{
			DebugTrace( "CInstDataCache::GetInstData() - FGetServerVariable() failed"
						" to get INSTANCE_META_PATH\n" );
			throw CLastErrorException();
		}

		if (NULL == pwszMetaPath.resize(cchMetaPath * sizeof(WCHAR)))
		{
			SetLastError(E_OUTOFMEMORY);

			DebugTrace( "CInstDataCache::GetInstData() -  failed to allocate memory\n" );
			throw CLastErrorException();
		}

		if (!ecb.FGetServerVariable( "INSTANCE_META_PATH",
									 pwszMetaPath.get(),
									 reinterpret_cast<DWORD *>(&cchMetaPath) ))
		{
			DebugTrace( "CInstDataCache::GetInstData() - FGetServerVariable() failed"
						" to get INSTANCE_META_PATH\n" );
			throw CLastErrorException();
		}
	}

	//	The function returning server variable returns total number of characters
	//	written to the output buffer, so it will include '\0' termination. Let us make
	//	sure that the return is what is expected.
	//
	Assert(0 == cchMetaPath ||
		   L'\0' == pwszMetaPath[cchMetaPath - 1]);

	//	Adjust the cchMetaPath to reflect the actual character count
	//
	if (0 != cchMetaPath)
	{
		cchMetaPath--;
	}

	//	Check that the root name is either NULL (zero-length string)
	//	or has its own separator.
	//
	//	NOTE: This is conditional because IF we are installed at the ROOT
	//	(on w3svc/1 or w3svc/1/root) and you throw a method against
	//	a file that doesn't live under a registered K2 vroot
	//	(like /default.asp) -- we DO get called, but the mi.cchMatchingURL
	//	comes back as 0, so pwszRootName is a zero-len string.
	//	(In IIS terms, you are not really hitting a virtual root,
	//	so your vroot is "".)
	//	I'm making this assert CONDITIONAL until we figure out more about
	//	how we'll handle this particular install case.
	//$REVIEW: The installed-at-the-root case needs to be examined more
	//$REVIEW: becuase we DON'T always build the same instance string
	//$REVIEW: in that case -- we'll still get vroot strings when the URI
	//$REVIEW: hits a resource under a REGISTERED vroot, and so we'll
	//$REVIEW: build different strings for the different vroots, even though
	//$REVIEW: we are running from a single, global install of DAV.
	//$REVIEW: The name might need to be treated as a starting point for a lookup.
	//	NTBug #168188: On OPTIONS, "*" is a valid URI.  Need to handle this
	//	special case without asserting.
	//
	AssertSz( (L'*' == pwszRootName[0] && 1 == cchRootName) ||
			  (0 == cchRootName) ||
			  (L'/' == pwszRootName[0]),
			  "(Non-zero) VRoot name doesn't have expected slash delimiter.  Instance name string may be malformed!" );

	//	NTBug # 168188: Special case for OPTIONS * -- map us to the root
	//	instdata name of "/w3svc/#/root" (don't want an instdata named
	//	"/w3svc/#/root*" that noone else can ever use!).
	//
	cchVRoot = pwszVRoot.celems();
	if (cchVRoot < cchMetaPath + gc_cch_Root + cchRootName + 1)
	{
		cchVRoot = cchMetaPath + gc_cch_Root + cchRootName;
		if (NULL == pwszVRoot.resize(CbSizeWsz(cchVRoot)))
		{
			SetLastError(E_OUTOFMEMORY);

			DebugTrace( "CInstDataCache::GetInstData() -  failed to allocate memory\n" );
			throw CLastErrorException();
		}
	}

	//	Copy first 2 portions: 'lm/w3svc/<site id>' and '/root'
	//
	memcpy(pwszVRoot.get(), pwszMetaPath.get(), cchMetaPath * sizeof(WCHAR));
	memcpy(pwszVRoot.get() + cchMetaPath, gc_wsz_Root, gc_cch_Root * sizeof(WCHAR));

	//	Copy remaining 3-rd portion: '/<vroot name>' and terminate the string.
	//	NTBug # 168188: Special case for OPTIONS * -- map us to the root
	//	instdata name of "/w3svc/#/root" (don't want an instdata named
	//	"/w3svc/#/root*" that noone else can ever use!).
	//
	if (L'*' == pwszRootName[0] && 1 == cchRootName)
	{
		(pwszVRoot.get())[cchMetaPath + gc_cch_Root] = L'\0';
	}
	else
	{
		memcpy(pwszVRoot.get() + cchMetaPath + gc_cch_Root, pwszRootName, cchRootName * sizeof(WCHAR));
		(pwszVRoot.get())[cchMetaPath + gc_cch_Root + cchRootName] = L'\0';
	}

	//	Slam the string to lower-case so that all variations on the vroot
	//	name will match.  (IIS doesn't allow vroots with the same name --
	//	and "VRoot" and "vroot" count as the same!)
	//
	_wcslwr( pwszVRoot.get() );

	//	Demand load the instance data for this vroot
	//
	{
		CRCWsz crcwszVRoot( pwszVRoot.get() );

		while ( !Instance().m_cache.FFetch( crcwszVRoot, &pinst ) )
		{
			CInitGate ig( L"DAV/CInstDataCache::GetInstData/", pwszVRoot.get() );

			if ( ig.FInit() )
			{
				//	Setup instance data from the system security context,
				//	not the client's security context.
				//
				safe_revert sr(ecb.HitUser());

				pinst = new CInstData(pwszVRoot.get());

				//	Since we are going to use this crcsz as a key in a cache,
				//	need to make sure that it's built on a name string that
				//	WON'T EVER MOVE (go away, get realloc'd).  The stack-based one
				//	above just isn't good enough.  SO, build a new little CRC-dude
				//	on the UNMOVABLE name data in the inst object.
				//	(And check that this new crc matches the old one!)
				//
				CRCWsz crcwszAdd( pinst->GetNameW() );
				AssertSz( crcwszVRoot.isequal(crcwszAdd),
						  "Two CRC's from the same string don't match!" );

				Instance().m_cache.Add( crcwszAdd, pinst );

				//	Log the fact that we've got a new instance pluged in.
				//	Message DAVPRS_VROOT_ATTACH takes two parameters:
				//	the signature of the impl and the vroot.
				//
				//$	RAID:NT:283650: Logging each attach causes a large
				//	number of events to be registered.  We really should
				//	only Log one-time-startup/failure events.
				//
				#undef	LOG_STARTUP_EVENT
				#ifdef	LOG_STARTUP_EVENT
				{
					LPCWSTR	pwszStrings[2];

					pwszStrings[0] = gc_wszSignature;
					pwszStrings[1] = pwszVRoot.get();
					LogEventW(DAVPRS_VROOT_ATTACH,
							  EVENTLOG_INFORMATION_TYPE,
							  2,
							  pwszStrings,
							  0,
							  NULL );
				}
				#endif	// LOG_STARTUP_EVENT
				//
				//$	RAID:X5:283650: end.

				break;
			}
		}
	}

	return *pinst;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\langtocpid.cpp ===
//	========================================================================
//
//	Module:		   langtocpid.cpp
//
//	Copyright Microsoft Corporation 1997, All Rights Reserved.
//
//	Description:	Implements language to cpid mapping cache
//					defined in inc\langtocpid.cpp
//
//	========================================================================

#include "_davprs.h"
#include <langtocpid.h>

//	========================================================================
//
//	Singleton class CLangToCpidCache
//
//	The CLangToCpidCache singleton class which provides a cache for fast
//	retrieval of code pages based on values in the Accept-Language header.
//
//	========================================================================

//	CLangToCpidCache::FCreateInstance() ------------------------------------
//
//	Initialization of the singleton class
//
BOOL
CLangToCpidCache::FCreateInstance()
{
	BOOL fSuccess = FALSE;
	UINT uiCpid;	// Index into the static table mapping language strings and cpids

	//	Init ourselves
	//
	CreateInstance();

	//	Init our cache
	//
	if (!Instance().m_cacheAcceptLangToCPID.FInit())
		goto ret;

	//	Fill our cache with all the language strings from
	//	the static table defined in the header.
	//
	for (uiCpid = 0; uiCpid < gc_cAcceptLangToCPIDTable; uiCpid++)
	{
		CRCSzi szKey (gc_rgAcceptLangToCPIDTable[uiCpid].pszLang);

		//	Check that we don't have duplicate NAMES in our table
		//	by doing a Lookup before we actually add each prop -- debug only!
		//
		Assert (!Instance().m_cacheAcceptLangToCPID.Lookup (szKey));

		//	Add the lang string.  Report a failure if we can't add.
		//
		if (!Instance().m_cacheAcceptLangToCPID.FAdd (szKey,
													  gc_rgAcceptLangToCPIDTable[uiCpid].cpid))
			goto ret;
	}

	//	Completed successfully.
	//
	fSuccess = TRUE;

ret:

	return fSuccess;
}

//	CLangToCpidCache::FFindCpid() ------------------------------------------
//
//	Find the CPID from language string
//
BOOL
CLangToCpidCache::FFindCpid(IN LPCSTR pszLang, OUT UINT * puiCpid)
{
	return Instance().m_cacheAcceptLangToCPID.FFetch(CRCSzi(pszLang),
													 puiCpid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\instdata.h ===
#ifndef _INSTDATA_H_
#define _INSTDATA_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	INSTDATA.H
//
//		Header for Dav Instance cache class.
//		(This cache hold per-instance data.  An instance is an
//		installation of DAV with a particular VServer-VRoot combination.)
//		Items declared here are defined(implemented) in inst.cpp.
//
//	Copyright 1997 Microsoft Corporation, All Rights Reserved
//

//	========================================================================
//	Implementation note:
//	We need the classes CONTAINED in the inst to be completely defined here.
//	I decided to make these classes CONTAINED directly for speed purposes.
//	If we ever want to switch to holding an interface instead, replace
//	these definitions with the interface declaration, and have all the
//	actual classes use the interface.  The interface must provide for
//	creating and destroying the objects -- don't forget to change the
//	CInstData dtor to destroy all its objects!		--BeckyAn
//

// Caches
#include "gencache.h"
// Scrip map cache
#include "scrptmps.h"
// Singleton template
#include <singlton.h>
// Instance data object
#include <instobj.h>

//	========================================================================
//
//	CLASS CInstDataCache
//
//		The instance data cache.  Contains one "row" (CInstData) for each
//		"instance" (virtual server/virtual root combination).
//		Only one should ever be created in any DAV dll.
//
//		A virtual server (or site) is IIS's mechanism for hosting more than one
//		web site on a single machine -- www.msn.com and www.microsoft.com
//		running off of different directories on the same machine.
//		A virtual server is addressed by IIS as an instance number under
//		the w3svc service (w3svc/1/root, w3svc/2/root, etc)
//		A virtual root is IIS's mechanism for mapping virtual directories
//		under a particular vserver to different parts of the file system --
//		the URI /becky could map to d:\msn\web\users\b\becky.
//		DAV uses a virtual directory as the root of its document access --
//		all requests with URIs under our vroot are serviced by DAV.
//		DAV can also be installed under many different vroots at the same
//		time.  The instance data allows us to maintain seperate setting
//		and data for each vroot.
//
//		To get the data row for the current instance, use GetInstData(ECB).
//
class CInstDataCache : private Singleton<CInstDataCache>
{
	//
	//	Friend declarations required by Singleton template
	//
	friend class Singleton<CInstDataCache>;

	//	The instance data cache
	//
	CMTCache<CRCWsz, auto_ref_ptr<CInstData> > m_cache;

	//	NOT IMPLEMENTED
	//
	CInstDataCache& operator=( const CInstDataCache& );
	CInstDataCache( const CInstDataCache& );

	//	CONSTRUCTORS
	//
	//	Declared private to ensure that arbitrary instances
	//	of this class cannot be created.  The Singleton
	//	template (declared as a friend above) controls
	//	the sole instance of this class.
	//
	CInstDataCache() {}

public:
	//	STATICS
	//

	//
	//	Instance creating/destroying routines provided
	//	by the Singleton template.
	//
	using Singleton<CInstDataCache>::CreateInstance;
	using Singleton<CInstDataCache>::DestroyInstance;

	//
	//	Per-vroot instance data accessor
	//
	static CInstData& GetInstData( const IEcb& ecb );
};


#endif // _INSTDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\lockmeta.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	L O C K M E T A . C P P
//
//		HTTP 1.1/DAV 1.0 request handling via ISAPI
//
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include <_davprs.h>

#include <tchar.h>	//_strspnp

#include <gencache.h>
#include <sz.h>
#include <xemit.h>
#include <xlock.h>
#include <statetok.h>
#include <nonimpl.h>

//	LockDiscovery -------------------------------------------------------------
//
SCODE
ScAddInLockToken (CEmitterNode& en, LPCWSTR pwszLockToken)
{
	//	Outer nodes must be declared first
	//
	CEmitterNode enLToken;
	CEmitterNode enToken;

	SCODE sc = S_OK;
	WCHAR rgwsz[MAX_LOCKTOKEN_LENGTH];
	LPCWSTR pwsz;

	//	Make sure they give us a locktoken string.
	//
	Assert(pwszLockToken);

	//	AND remove the quote marks (currently <>)
	//
	if (L'<' == pwszLockToken[0])
		pwszLockToken++;

	pwsz = wcschr(pwszLockToken, L'>');
	if (pwsz)
	{
		UINT cch = static_cast<UINT>(pwsz - pwszLockToken);
		if (MAX_LOCKTOKEN_LENGTH - 1 < cch)
		{
			sc = E_FAIL;
			goto ret;
		}
		Assert(MAX_LOCKTOKEN_LENGTH > cch);
		memcpy(rgwsz, pwszLockToken, cch * sizeof(WCHAR));
		rgwsz[cch] = L'\0';
		pwszLockToken = rgwsz;
	}

	//	Create and add a locktoken node under activelock.
	//	(locktoken node contains a single href node.)
	//
	sc = en.ScAddNode (gc_wszLockToken, enLToken);
	if (FAILED (sc))
		goto ret;

	sc = enLToken.ScAddNode (gc_wszXML__Href, enToken, pwszLockToken);
	if (FAILED (sc))
		goto ret;

ret:

	return sc;
}

//	========================================================================
//
//	ScBuildLockDiscovery
//
//		Takes an emitter and an already-constructed lockdiscovery node,
//		and adds an activelock node under it.
//		May be called multiple times -- each call will add a new activelock
//		node under the lockdiscovery node in en.
//
SCODE
ScBuildLockDiscovery (CXMLEmitter& emitter,
	CEmitterNode& en,
	LPCWSTR pwszLockToken,
	LPCWSTR pwszLockType,
	LPCWSTR pwszLockScope,
	BOOL fRollback,
	BOOL fDepthInfinity,
	DWORD dwTimeout,
	LPCWSTR pwszOwnerComment,
	LPCWSTR pwszSubType)
{
	CEmitterNode enActive;
	SCODE sc = S_OK;
	WCHAR wsz[50];

	//	Zero is an invalid timeout.
	//
	Assert(dwTimeout);

	//	Add in the 'DAV:activelock' node
	//
	sc = en.ScAddNode (gc_wszLockActive, enActive);
	if (FAILED (sc))
		goto ret;

	//	Create a node for the locktype.
	//
	{
		CEmitterNode enLType;

		sc = enActive.ScAddNode (gc_wszLockType, enLType);
		if (FAILED (sc))
			goto ret;

		{
			CEmitterNode enType;
			sc = enLType.ScAddNode (pwszLockType, enType);
			if (FAILED (sc))
				goto ret;

			if (pwszSubType)
			{
				CEmitterNode enSubLType;
				sc = enType.ScAddNode (pwszSubType, enSubLType);
				if (FAILED (sc))
					goto ret;
			}
		}
	}

	//	Create a node for the lockscope
	//
	{
		CEmitterNode enLScope;

		sc = enActive.ScAddNode (gc_wszLockScope, enLScope);
		if (FAILED (sc))
			goto ret;

		{
			CEmitterNode enScope;

			sc = enLScope.ScAddNode (pwszLockScope, enScope);
			if (FAILED (sc))
				goto ret;
		}
	}

	//	Create a node for the owner. The comment is well contructed XML already
	//
	if (pwszOwnerComment)
	{
		sc = enActive.Pxn()->ScSetFormatedXML (pwszOwnerComment, static_cast<UINT>(wcslen(pwszOwnerComment)));
		if (FAILED (sc))
			goto ret;
	}

	//	If this is a rollback lock...
	//
	if (fRollback)
	{
		CEmitterNode enRollback;
		sc = enActive.ScAddNode (gc_wszLockRollback, enRollback);
		if (FAILED (sc))
			goto ret;
	}

	//	Add in the lock token
	//
	sc = ScAddInLockToken (enActive, pwszLockToken);
	if (FAILED (sc))
		goto ret;

	//	Add an appropriate depth node.
	//
	{
		CEmitterNode enDepth;

		if (fDepthInfinity)
		{
			sc = enActive.ScAddNode (gc_wszLockDepth, enDepth, gc_wszInfinity);
			if (FAILED (sc))
				goto ret;
		}
		else
		{
			sc = enActive.ScAddNode (gc_wszLockDepth, enDepth, gc_wsz0);
			if (FAILED (sc))
				goto ret;
		}
	}

	//	Finally, create and add a timeout node
	//
	{
		CEmitterNode enTimeout;
		wsprintfW (wsz, L"Second-%d", dwTimeout);

		sc = enActive.ScAddNode (gc_wszLockTimeout, enTimeout, wsz);
		if (FAILED (sc))
			goto ret;
	}

ret:

	return sc;
}

//	========================================================================
//
//	Lock utility functions
//
//$REVIEW: This should really be common impl code.  Move to _davcom later.
//

//	------------------------------------------------------------------------
//
//	FGetLockTimeout
//
//		Fetches and parses an incoming Time-Out header on the request.
//		Returns FALSE if an invalid option was encountered.
//		Returns TRUE with *pdwSeconds=gc_cSecondsDefaultLock
//		if NO Time-Out header was present.
//
BOOL
FGetLockTimeout (LPMETHUTIL pmu, DWORD * pdwSeconds, DWORD dwMaxOverride)
{
	LPCWSTR pwsz;
	DWORD  dwMax = gc_cSecondsMaxLock;

	Assert (pmu);
	Assert (pdwSeconds);

	*pdwSeconds = gc_cSecondsDefaultLock;

	//	If there is NO Time-Out header, leave our timeout set to the default,
	//	which was set at construction time.
	//	NOTE: It IS valid to have NO Time-Out header.  Just use the defaults.
	//
	pwsz = pmu->LpwszGetRequestHeader (gc_szTimeout, FALSE);
	if (!pwsz)
	{
		LockTrace ("Dav: No Timeout header found.\n");
		goto ret;
	}

	//	Skip any initial whitespace.
	//
	pwsz = _wcsspnp(pwsz, gc_wszLWS);
	if (!pwsz)
	{
		LockTrace ("Dav: No params found in LOCK Time-Out header.\n");
		return FALSE;
	}

	Assert(pwsz);

	//	Check for a new-style timeout header.
	//

	//	Load a header iterator -- there could be multiple values here.
	//
	{
		HDRITER_W hdr(pwsz);

		pwsz = hdr.PszNext();
		if (!pwsz)
		{
			//	No data found.  That's an error.
			//
			return FALSE;
		}

		if (dwMaxOverride)
			dwMax = dwMaxOverride;

		while (pwsz)
		{
			//	Loop until we find an acceptable time.
			//	(Ignore any header values we don't understand.)
			//	If no acceptable time is found, it's okay.
			//	dwSeconds stays zero, and return TRUE.
			//

			if (!_wcsnicmp (gc_wszSecondDash, pwsz, gc_cchSecondDash))
			{
				DWORD dwSeconds;

				pwsz += gc_cchSecondDash;
				if (!*pwsz)
					return FALSE;

				dwSeconds = _wtol(pwsz);

				if (dwSeconds > dwMax)
				{
					//	Remember that they asked for something huge.
					//
					*pdwSeconds = dwMax;
				}
				else
				{
					//	We found a request that we'll grant.
					//	Set it and stop looping.
					//
					*pdwSeconds = dwSeconds;
					break;
				}
			}
			else if (!_wcsnicmp (gc_wszInfinite, pwsz, gc_cchInfinite))
			{
				//	We don't yet handle infinite timeouts.
				//	Remember that they asked for something huge.
				//	Skip to the next token.
				//
				*pdwSeconds = dwMax;

			}

			//	else skip to next token
			//	(ignore unrecognized tokens).
			//
			pwsz = hdr.PszNext();

		} // elihw
	}

ret:

	//$HACK:ROSEBUD_OFFICE9_TIMEOUT_HACK
    //  For the bug where rosebud waits until the last second
    //  before issueing the refresh. Need to filter out this check with
    //  the user agent string. The hack is to increase the timeout
	//	by 30 seconds and return the actual timeout.
    //
	if (pmu->FIsOffice9Request())
	{
		*pdwSeconds += gc_dwSecondsHackTimeoutForRosebud;
	}
	//$HACK:END:ROSEBUD_OFFICE9_TIMEOUT_HACK

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\htmlmap.cpp ===
/*
 *	H T M L M A P . C P P
 *
 *	HTML .MAP file processing
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davprs.h"
#include <htmlmap.h>

//	.MAP file parsing ---------------------------------------------------------
//
//	This code has been stolen from IIS and rewritten to work within the
//	DAV/Caligula sources.  The original code can be found in the IIS slm
//	project at \\kernel\razzle3\slm\iis\svcs\w3\server\doget.cxx.
//
#define SQR(x)		((x) * (x))
#define MAXVERTS	160
#define X			0
#define Y			1

inline bool IsWhiteA (CHAR ch)
{
	return ((ch) == '\t' || (ch) == ' ' || (ch) == '\r');
}

inline CHAR * SkipNonWhite( CHAR * pch )
{
	while (*pch && !IsWhiteA(*pch))
		pch++;

	return pch;
}

inline CHAR * SkipWhite( CHAR * pch )
{
	while (IsWhiteA(*pch) || (*pch == ')') || (*pch == '('))
		pch++;

	return pch;
}

int GetNumber( CHAR ** ppch )
{
	CHAR * pch = *ppch;
	INT	   n;

	//	Make sure we don't get into the URL
	//
	while ( *pch &&
			!isdigit( *pch ) &&
			!isalpha( *pch ) &&
			*pch != '/'		 &&
			*pch != '\r'	 &&
			*pch != '\n' )
	{
		pch++;
	}

	if ( !isdigit( *pch ) )
		return -1;

	n = atoi( pch );

	while ( isdigit( *pch ))
		pch++;

	*ppch = pch;
	return n;
}

int pointinpoly(int point_x, int point_y, double pgon[MAXVERTS][2])
{
	int i, numverts, inside_flag, xflag0;
	int crossings;
	double *p, *stop;
	double tx, ty, y;

	for (i = 0; pgon[i][X] != -1 && i < MAXVERTS; i++)
		;

	numverts = i;
	crossings = 0;

	tx = (double) point_x;
	ty = (double) point_y;
	y = pgon[numverts - 1][Y];

	p = (double *) pgon + 1;

	if ((y >= ty) != (*p >= ty))
	{
		if ((xflag0 = (pgon[numverts - 1][X] >= tx)) == (*(double *) pgon >= tx))
		{
			if (xflag0)
				crossings++;
		}
		else
		{
			crossings += (pgon[numverts - 1][X] - (y - ty) *
			(*(double *) pgon - pgon[numverts - 1][X]) /
			(*p - y)) >= tx;
		}
	}

	stop = pgon[numverts];

	for (y = *p, p += 2; p < stop; y = *p, p += 2)
	{
		if (y >= ty)
		{
			while ((p < stop) && (*p >= ty))
				p += 2;

			if (p >= stop)
				break;

			if ((xflag0 = (*(p - 3) >= tx)) == (*(p - 1) >= tx))
			{
				if (xflag0)
					crossings++;
			}
			else
			{
				crossings += (*(p - 3) - (*(p - 2) - ty) *
					(*(p - 1) - *(p - 3)) / (*p - *(p - 2))) >= tx;
			}
		}
		else
		{
			while ((p < stop) && (*p < ty))
				p += 2;

			if (p >= stop)
				break;

			if ((xflag0 = (*(p - 3) >= tx)) == (*(p - 1) >= tx))
			{
				if (xflag0)
					crossings++;

			}
			else
			{
				crossings += (*(p - 3) - (*(p - 2) - ty) *
					(*(p - 1) - *(p - 3)) / (*p - *(p - 2))) >= tx;
			}
		}
	}

	inside_flag = crossings & 0x01;
	return (inside_flag);
}

BOOL
FSearchMapFile (LPCSTR pszMap,
	INT x,
	INT y,
	BOOL * pfRedirect,
	LPSTR pszRedirect,
	UINT cchBuf)
{
	BOOL fRet = FALSE;
	CHAR * pch;
	CHAR * pchDefault = NULL;
	CHAR * pchPoint = NULL;
	CHAR * pchStart;
	UINT cchUrl;
	UINT dis;
	UINT bdis = static_cast<UINT>(-1);
	BOOL fComment = FALSE;
	BOOL fIsNCSA = FALSE;
	LPSTR pURL;					// valid only if fIsNCSA is TRUE

	//	We should now be ready to parse the map.  Here is where the
	//	IIS code begins.
	//
	fRet = TRUE;

	//	Loop through the contents of the buffer and see what we've got
	//
	for (pch = const_cast<CHAR *>(pszMap); *pch; )
	{
		fIsNCSA = FALSE;

		//	note: _tolower doesn't check case (tolower does)
		//
		switch( ( *pch >= 'A' && *pch <= 'Z' ) ? _tolower( *pch ) : *pch )
		{
			case '#':

				fComment = TRUE;
				break;

			case '\r':
			case '\n':

				fComment = FALSE;
				break;

			//	Rectangle
			//
			case 'r':
			case 'o':

				//	In the IIS code, "oval" and "rect" are treated the
				//	same.  The code is commented with a BUGBUG comment.
				//
				if( !fComment &&
					( !_strnicmp( "rect", pch, 4)
					  // BUGBUG handles oval as a rect, as they are using
					  // the same specification format. Should do better.
					  || !_strnicmp( "oval", pch, 4 )) )
				{
					INT x1, y1, x2, y2;

					pch = SkipNonWhite( pch );
					pURL = pch;
					pch = SkipWhite( pch );

					if( !isdigit(*pch) && *pch!='(' )
					{
						fIsNCSA = TRUE;
						pch = SkipNonWhite( pch );
					}

					x1 = GetNumber( &pch );
					y1 = GetNumber( &pch );
					x2 = GetNumber( &pch );
					y2 = GetNumber( &pch );

					if ( x >= x1 && x < x2 &&
						 y >= y1 && y < y2	 )
					{
						if ( fIsNCSA )
							pch = pURL;
						goto Found;
					}

					//	Skip the URL
					//
					if( !fIsNCSA )
					{
						pch = SkipWhite( pch );
						pch = SkipNonWhite( pch );
					}
					continue;
				}
				break;

			//	Circle
			//
			case 'c':
				if ( !fComment &&
					 !_strnicmp( "circ", pch, 4 ))
				{
					INT xCenter, yCenter, xEdge, yEdge;
					INT r1, r2;

					pch = SkipNonWhite( pch );
					pURL = pch;
					pch = SkipWhite( pch );

					if ( !isdigit(*pch) && *pch!='(' )
					{
						fIsNCSA = TRUE;
						pch = SkipNonWhite( pch );
					}

					//	Get the center and edge of the circle
					//
					xCenter = GetNumber( &pch );
					yCenter = GetNumber( &pch );

					xEdge = GetNumber( &pch );
					yEdge = GetNumber( &pch );

					//	If there's a yEdge, then we have the NCSA format, otherwise
					//	we have the CERN format, which specifies a radius
					//
					if ( yEdge != -1 )
					{
						r1 = ((yCenter - yEdge) * (yCenter - yEdge)) +
							 ((xCenter - xEdge) * (xCenter - xEdge));

						r2 = ((yCenter - y) * (yCenter - y)) +
							 ((xCenter - x) * (xCenter - x));

						if ( r2 <= r1 )
						{
							if ( fIsNCSA )
								pch = pURL;
							goto Found;
						}
					}
					else
					{
						INT radius;

						//	CERN format, third param is the radius
						//
						radius = xEdge;

						if ( SQR( xCenter - x ) + SQR( yCenter - y ) <=
							 SQR( radius ))
						{
							if ( fIsNCSA )
								pch = pURL;
							goto Found;
						}
					}

					//	Skip the URL
					//
					if ( !fIsNCSA )
					{
						pch = SkipWhite( pch );
						pch = SkipNonWhite( pch );
					}
					continue;
				}
				break;

			//	Polygon
			//
			case 'p':
				if ( !fComment &&
					 !_strnicmp( "poly", pch, 4 ))
				{
					double pgon[MAXVERTS][2];
					DWORD  i = 0;
					BOOL fOverflow = FALSE;

					pch = SkipNonWhite( pch );
					pURL = pch;
					pch = SkipWhite( pch );

					if ( !isdigit(*pch) && *pch!='(' )
					{
						fIsNCSA = TRUE;
						pch = SkipNonWhite( pch );
					}

					//	Build the array of points
					//
					while ( *pch && *pch != '\r' && *pch != '\n' )
					{
						pgon[i][0] = GetNumber( &pch );

						//
						//	Did we hit the end of the line (and go past the URL)?
						//

						if ( pgon[i][0] != -1 )
						{
							pgon[i][1] = GetNumber( &pch );
						}
						else
						{
							break;
						}

						if ( i < MAXVERTS-1 )
						{
							i++;
						}
						else
						{
							fOverflow = TRUE;
						}
					}

					pgon[i][X] = -1;

					if ( !fOverflow && pointinpoly( x, y, pgon ))
					{
						if ( fIsNCSA )
							pch = pURL;
						goto Found;
					}

					//	Skip the URL
					//
					if ( !fIsNCSA )
					{
						pch = SkipWhite( pch );
						pch = SkipNonWhite( pch );
					}
					continue;
				}
				else if ( !fComment &&
						  !_strnicmp( "point", pch, 5 ))
				{
					INT x1,y1;

					pch = SkipNonWhite( pch );
					pURL = pch;
					pch = SkipWhite( pch );
					pch = SkipNonWhite( pch );

					x1 = GetNumber( &pch );
					y1 = GetNumber( &pch );

					x1 -= x;
					y1 -= y;
					dis = x1*x1 + y1*y1;
					if ( dis < bdis )
					{
						pchPoint = pURL;
						bdis = dis;
					}
				}
				break;

			//	Default URL
			//
			case 'd':
				if ( !fComment &&
					 !_strnicmp( "def", pch, 3 ) )
				{
					//
					//	Skip "default" (don't skip white space)
					//

					pch = SkipNonWhite( pch );

					pchDefault = pch;

					//
					//	Skip URL
					//

					pch = SkipWhite( pch );
					pch = SkipNonWhite( pch );
					continue;
				}
				break;
		}

		pch++;
		pch = SkipWhite( pch );
	}

	//	If we didn't find a mapping and a default was specified, use
	//	the default URL
	//
	if ( pchPoint )
	{
		pch = pchPoint;
		goto Found;
	}

	if ( pchDefault )
	{
		pch = pchDefault;
		goto Found;
	}

	DebugTrace ("Dav: no mapping found for (%d, %d)\n", x, y);
	goto Exit;

Found:

	//	pch should point to the white space immediately before the URL
	//
	pch = SkipWhite( pch );
	pchStart = pch;
	pch = SkipNonWhite( pch );

	//	Determine the length of the URL and copy it out
	//
	cchUrl = static_cast<UINT>(pch - pchStart);
	if ( cchUrl >= cchBuf )
		return FALSE;

	CopyMemory (pszRedirect, pchStart, cchUrl);
	*(pszRedirect + cchUrl) = 0;
	*pfRedirect = TRUE;

	DebugTrace ("Dav: mapping for (%d, %d) is %hs\n", x, y, pszRedirect);

Exit:
	return fRet;
}

BOOL
FIsMapProcessed (
	LPCSTR lpszQueryString,
	LPCSTR lpszUrlPrefix,
	LPCSTR lpszServerName,
	LPCSTR pszMap,
	BOOL * pfRedirect,
	LPSTR pszRedirect,
	UINT cchBuf)
{
	INT x = 0;
	INT y = 0;
	LPCSTR pch = lpszQueryString;

	//	Ensure the *pfRedirect is initialized
	//
	Assert( pfRedirect );
	*pfRedirect = FALSE;

	//	If there is no query string, I don't think we want to process
	//	the file as if it were a .map request.
	//
	if ( pch == NULL )
		return TRUE;

	//	Get the x and y cooridinates of the mouse click on the image
	//
	x = strtoul( pch, NULL, 10 );

	//	Move past x and any intervening delimiters
	//
	while ( isdigit( *pch ))
		pch++;
	while ( *pch && !isdigit( *pch ))
		pch++;
	y = strtoul( pch, NULL, 10 );

	//	Search the map file
	//
	if ( !FSearchMapFile( pszMap,
						  x,
						  y,
						  pfRedirect,
						  pszRedirect,
						  cchBuf))
	{
		DebugTrace ("Dav: FSearchMapFile() failed with %ld\n", GetLastError());
		return FALSE;
	}

	//	If no redirected URL was passed back, then we are done.
	//
	if ( !*pfRedirect )
	{
		//	Returning true does not indicate success, it really
		//	just means that there were no processing errors
		//
		goto ret;
	}

	//	If the found URL starts with a forward slash ("/foo/bar/doc.htm")
	//	and it doesn't contain a bookmark ('#') then the URL is local and
	//	we build a fully qualified URL to send back to the client. We assume
	//	it's a fully qualified URL ("http://foo/bar/doc.htm") and send the
	//	client a redirection notice to the mapped URL
	//
	if ( *pszRedirect == '/' )
	{
		CHAR rgch[MAX_PATH];
		UINT cch;
		UINT cchUri;

		if ( strlen(lpszUrlPrefix) + strlen(lpszServerName) >= MAX_PATH)
			return FALSE;

		//	Build up the full qualification to the url
		//
		strcpy (rgch, lpszUrlPrefix);
		strcat (rgch, lpszServerName);

		//	See how much we need to shif the URL by
		//
		cch = static_cast<UINT>(strlen (rgch));
		cchUri = static_cast<UINT>(strlen (pszRedirect));
		//	If they haven't passed us enough buffer to copy
		//	the redirect url, fail. Add one to the counts for the 
		//	terminating NULL character
		//
		if (cchBuf < (cchUri + cch + 1))
			return FALSE;
		
		MoveMemory (pszRedirect + cch, pszRedirect, cchUri + 1);
		CopyMemory (pszRedirect, rgch, cch);
	}

ret:
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\method.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	METHOD.CPP
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include "_davprs.h"

#include <statcode.h>
#include "ecb.h"
#include "instdata.h"


//	------------------------------------------------------------------------
//
//	DAVUnsupported()
//
//	Execute an unsupported method --> Return "501 Not Supported" to client
//
void
DAVUnsupported( LPMETHUTIL pmu )
{
	//	Get our access perms
	//
	SCODE sc = S_OK;
	//	Do ISAPI application and IIS access bits checking
	//
	sc = pmu->ScIISCheck (pmu->LpwszRequestUrl());
	if (FAILED(sc))
	{
		//	Either the request has been forwarded, or some bad error occurred.
		//	In either case, quit here and map the error!
		//
		goto ret;
	}

ret:
	pmu->SetResponseCode( FAILED(sc)
							  ? HscFromHresult(sc)
							  : HSC_NOT_IMPLEMENTED,
						  NULL,
						  0 );
}

//	========================================================================
//
//	STRUCT SMethod
//
//	Encapsulates DAV method execution information.
//
//	This is represented as a structure rather than a class since the method
//	objects are all const globals and MSVC won't initialize global objects
//	in a DLL to anything but 0-filled memory without an explicit call to
//	_CRT_INIT at process attach.  _CRT_INIT is too expensive to call just
//	to initialize globals with constant data values which are known
//	at compile time.
//
typedef struct SMethod
{
	//
	//	Verb ("GET", "PUT", etc.)
	//
	//
	LPCSTR						lpszVerb;
	LPCWSTR						pwszVerb;

	//
	//	Method ID
	//
	METHOD_ID					mid;

	//
	//	Implementation execution function
	//
	DAVMETHOD *					Execute;

} SMethod;

const SMethod g_rgMethods[] =
{
	//
	//	For best performance, entries in this array should be
	//	ordered by relative frequency.
	//
	//$OPT	Right now, they obviously are not.
	//
	{
		"OPTIONS",
		L"OPTIONS",
		MID_OPTIONS,
		DAVOptions
	},
	{
		"GET",
		L"GET",
		MID_GET,
		DAVGet
	},
	{
		"HEAD",
		L"HEAD",
		MID_HEAD,
		DAVHead
	},
	{
		"PUT",
		L"PUT",
		MID_PUT,
		DAVPut
	},
	{
		"POST",
		L"POST",
		MID_POST,
		DAVPost
	},
	{
		"MOVE",
		L"MOVE",
		MID_MOVE,
		DAVMove
	},
	{
		"COPY",
		L"COPY",
		MID_COPY,
		DAVCopy
	},
	{
		"DELETE",
		L"DELETE",
		MID_DELETE,
		DAVDelete
	},
	{
		"MKCOL",
		L"MKCOL",
		MID_MKCOL,
		DAVMkCol
	},
	{
		"PROPFIND",
		L"PROPFIND",
		MID_PROPFIND,
		DAVPropFind
	},
	{
		"PROPPATCH",
		L"PROPPATCH",
		MID_PROPPATCH,
		DAVPropPatch
	},
	{
		"SEARCH",
		L"SEARCH",
		MID_SEARCH,
		DAVSearch
	},
	{
		"LOCK",
		L"LOCK",
		MID_LOCK,
		DAVLock
	},
	{
		"UNLOCK",
		L"UNLOCK",
		MID_UNLOCK,
		DAVUnlock
	},
	{
		NULL,
		NULL,
		MID_UNKNOWN,
		DAVUnsupported
	}

};

METHOD_ID
MidMethod (LPCSTR pszMethod)
{
	const SMethod * pMethod;

	for ( pMethod = g_rgMethods; pMethod->lpszVerb != NULL; pMethod++ )
		if ( !strcmp( pszMethod, pMethod->lpszVerb ) )
			break;

	return pMethod->mid;
}

METHOD_ID
MidMethod (LPCWSTR pwszMethod)
{
	const SMethod * pMethod;

	for ( pMethod = g_rgMethods; pMethod->pwszVerb != NULL; pMethod++ )
		if ( !wcscmp( pwszMethod, pMethod->pwszVerb ) )
			break;

	return pMethod->mid;
}


//	Debug SID vs Name ---------------------------------------------------------
//
#ifdef	DBG
VOID
SpitUserNameAndSID (CHAR * rgch)
{
	enum { TOKENBUFFSIZE = (256*6) + sizeof(TOKEN_USER)};

	auto_handle<HANDLE> hTok;
	BYTE tokenbuff[TOKENBUFFSIZE];
	TOKEN_USER *ptu = reinterpret_cast<TOKEN_USER *>(tokenbuff);
	ULONG ulcbTok = sizeof(tokenbuff);

	*rgch = '\0';

	//	Open the process and the process token, and get out the
	//	security ID.
	//
	if (!OpenThreadToken (GetCurrentThread(),
						  TOKEN_QUERY,
						  TRUE,  //$ TRUE for Process security!
						  hTok.load()))
	{
		if (ERROR_NO_TOKEN != GetLastError())
		{
			DebugTrace( "OpenThreadToken() failed %d\n", GetLastError() );
			return;
		}

		if (!OpenProcessToken (GetCurrentProcess(),
							   TOKEN_QUERY,
							   hTok.load()))
		{
			DebugTrace( "OpenProcessToken() failed %d\n", GetLastError() );
			return;
		}
	}

	if (GetTokenInformation	(hTok,
							 TokenUser,
							 ptu,
							 ulcbTok,
							 &ulcbTok))
	{
		ULONG IdentifierAuthority;
		BYTE * pb = (BYTE*)&IdentifierAuthority;
		SID * psid = reinterpret_cast<SID *>(ptu->User.Sid);

		for (INT i = 0; i < sizeof(ULONG); i++)
		{
			*pb++ = psid->IdentifierAuthority.Value[5-i];
		}
		wsprintfA (rgch, "S-%d-%d",
				   psid->Revision,
				   IdentifierAuthority);

		for (i = 0; i < psid->SubAuthorityCount; i++)
		{
			//	The SubAuthority is a PDWORD which can be 64 bits
			//	at the most in the forseable future, 2^64 = 10^20,
			//	so we should use 23 (20 for the SubAuthority, a terminating
			//	NULL plus the "- ". If snprintf
			//	is not able to print the NULL, we will add it ourselves.
			//
			CHAR rgchT[23];
			_snprintf (rgchT, sizeof(rgchT), "-%d", psid->SubAuthority[i]);
			rgchT[CElems(rgchT) - 1] = '\0';
			lstrcatA (rgch, rgchT);
		}

		if (1 == psid->Revision)
		{
			if (0 == IdentifierAuthority)
				lstrcatA (rgch, " (Null)");
			if (1 == IdentifierAuthority)
				lstrcatA (rgch, " (World)");
			if (2 == IdentifierAuthority)
				lstrcatA (rgch, " (Local)");
			if (3 == IdentifierAuthority)
				lstrcatA (rgch, " (Creator)");
			if (4 == IdentifierAuthority)
				lstrcatA (rgch, " (Non-Unique)");
			if (5 == IdentifierAuthority)
				lstrcatA (rgch, " (NT)");
		}

		CHAR rgchAccount[MAX_PATH];
		CHAR rgchDomain[MAX_PATH];
		DWORD cbAccount = sizeof(rgchAccount) - 1;
		DWORD cbDomain = sizeof(rgchDomain) - 1;
		SID_NAME_USE snu;
		LookupAccountSidA (NULL,
						   psid,
						   rgchAccount,
						   &cbAccount,
						   rgchDomain,
						   &cbDomain,
						   &snu);
		lstrcatA (rgch, " ");
		lstrcatA (rgch, rgchDomain);
		lstrcatA (rgch, "\\");
		lstrcatA (rgch, rgchAccount);
		DavprsDbgHeadersTrace ("Dav: header: x-Dav-Debug-SID: %hs\n", rgch);
	}
}

VOID DebugAddSIDHeader( IMethUtil& mu )
{
	CHAR rgch[4096];

	if (!DEBUG_TRACE_TEST(DavprsDbgHeaders))
		return;

	SpitUserNameAndSID (rgch);
	mu.SetResponseHeader ("x-Dav-Debug-SID", rgch);
}

#else
#define DebugAddSIDHeader(_mu)
#endif	// DBG

// ----------------------------------------------------------------------------
//
//	CDAVExt::DwMain()
//
//	Invokes a DAV method.  This is THE function called by our IIS entrypoint
//	DwDavXXExtensionProc() to start processing a request.
//
//	If MINIMAL_ISAPI is defined, this function is implemented in another
//	file (.\appmain.cpp).  See the implementation there for what MINIMAL_ISAPI
//	does.
//
#ifndef MINIMAL_ISAPI
DWORD
CDAVExt::DwMain( LPEXTENSION_CONTROL_BLOCK pecbRaw,
				 BOOL fUseRawUrlMappings /* = FALSE */ )
{
#ifdef	DBG
	CHAR rgch[1024];
	DWORD cch;

	cch = sizeof(rgch);
	if (pecbRaw->GetServerVariable (pecbRaw->ConnID, "REQUEST_METHOD", rgch, &cch))
		EcbTrace ("CDAVExt::DwMain() called via method: %hs\n", rgch);

	cch = sizeof(rgch);
	if (pecbRaw->GetServerVariable (pecbRaw->ConnID, "ALL_RAW", rgch, &cch))
		EcbTrace ("CDAVExt::DwMain() called with RAW:\n%hs\n", rgch);

	cch = sizeof(rgch);
	if (pecbRaw->GetServerVariable (pecbRaw->ConnID, "ALL_HTTP", rgch, &cch))
		EcbTrace ("CDAVExt::DwMain() called with HTTP:\n%hs\n", rgch);
#endif	// DBG

	auto_ref_ptr<IEcb> pecb;
	DWORD dwHSEStatusRet = 0;
	BOOL fCaughtException = FALSE;
	HANDLE hitUser = INVALID_HANDLE_VALUE;

	try
	{
		//
		//	Don't let hardware exceptions (AVs, etc.)
		//	leave this try block
		//
		CWin32ExceptionHandler win32ExceptionHandler;

		pecb.take_ownership(NewEcb(*pecbRaw, fUseRawUrlMappings, &dwHSEStatusRet));

		//
		//	If for whatever reason we failed to create a CEcb then bail
		//	and return whatever status we were told to return.
		//
		//	Note: return HSE_STATUS_SUCCESS here, not HSE_STATUS_ERROR.
		//	We have sent back a 500 Server Error response to the client
		//	so we don't need to send back any kind of error to IIS.
		//
		if ( !pecb.get() )
		{
			//	All valid HSE status codes are non-zero (how convenient!)
			//	so we can make sure that we are returning a valid HSE
			//	status code here.
			//
			Assert( dwHSEStatusRet != 0 );
			return dwHSEStatusRet;
		}

		const SMethod * pMethod;

		//
		//	Lookup the method object for this verb
		//
		for ( pMethod = g_rgMethods; pMethod->lpszVerb != NULL; pMethod++ )
			if ( !strcmp( pecb->LpszMethod(), pMethod->lpszVerb ) )
				break;

		//
		//	Build request and response objects.
		//
		auto_ref_ptr<IRequest> prequest( NewRequest( *pecb ) );
		auto_ref_ptr<IResponse> presponse( NewResponse( *pecb ) );

		//
		//	If impersonation is required, do it here
		//
		hitUser = pecb->HitUser();
		if ((NULL == hitUser) || (INVALID_HANDLE_VALUE == hitUser))
		{
			//$	REVIEW: SECURITY: If HitUser() returns any
			//	value of NULL or INVALID_HANDLE_VALUE, then a call
			//	to augment the user's token to include USG
			//	group membership failed.  Since this token
			//	is not augmented with the additional group
			//	that may be included in any/all deny ACL's
			//	we want to fail this request immediately.
			//
			//	We treat the failure as a 500 level error.
			//
			pecb->SendAsyncErrorResponse (500,
										  gc_szDefErrStatusLine,
										  gc_cchszDefErrStatusLine,
										  gc_szUsgErrBody,
										  gc_cchszUsgErrBody);

			//
			//	Return HSE_STATUS_PENDING on success.  We will call
			//	HSE_REQ_DONE_WITH_SESSION when the CEcb is destroyed.
			//
			dwHSEStatusRet = HSE_STATUS_PENDING;
			//
			//$	REVIEW: SECURITY: end.
			
		}
		else
		{
			safe_impersonation si( hitUser );

			//	If we failed to impersonate, we should not process any
			//	portion of the the request.
			//
			if (!si.FImpersonated())
				throw CHresultException(E_FAIL);

			//	Let the implementation handle the request.
			//
			{
				auto_ref_ptr<CMethUtil> pmu( CMethUtil::NewMethUtil( *pecb,
					*prequest,
					*presponse,
					pMethod->mid ) );

				DebugAddSIDHeader( *pmu );

				//
				//	Execute the method
				//
				pMethod->Execute( pmu.get() );
			}

			//
			//	Call the method completion function on the response.
			//	This does all work necessary to finish handling the
			//	response as far as the method is concerned, including
			//	sending the response if it was not deferred by the impl.
			//
			presponse->FinishMethod();

			//
			//	Return HSE_STATUS_PENDING on success.  We will call
			//	HSE_REQ_DONE_WITH_SESSION when the CEcb is destroyed.
			//
			dwHSEStatusRet = HSE_STATUS_PENDING;
		}
	}
	catch ( CDAVException& )
	{
		fCaughtException = TRUE;
	}

	//
	//	If we caught an exception then handle it as best we can
	//
	if ( fCaughtException )
	{
		//
		//	If we have a CEcb then use it to handle the server error.
		//	If we don't have one (i.e. we threw an exception trying
		//	to allocate/build one) then return an error to IIS
		//	and let it handle it.
		//
		dwHSEStatusRet =
			pecb.get() ? pecb->HSEHandleException() :
						 HSE_STATUS_ERROR;
	}

	//
	//	All valid HSE status codes are non-zero (how convenient!)
	//	so we can make sure that we are returning a valid HSE
	//	status code here.
	//
	Assert( dwHSEStatusRet != 0 );

	return dwHSEStatusRet;
}
#endif // !defined(MINIMAL_ISAPI)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\methutil.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	METHUTIL.CPP
//
//		Implementation of external IMethUtil interface
//
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include "_davprs.h"
#include "instdata.h"

//	IIS MetaData header
#include <iiscnfg.h>


//	========================================================================
//
//	CLASS CMethUtil
//

//	------------------------------------------------------------------------
//
//	CMethUtil::FInScriptMap()
//
//	Utility to determine whether there is information in the scriptmaps
//	about a particular URI and whether it applies.
//
BOOL
CMethUtil::FInScriptMap (LPCWSTR pwszURI,
						 DWORD dwAccess,
						 BOOL * pfCGI,
						 SCODE * pscMatch) const
{
	SCODE	scMatch;

	//	Fetch the script map.
	//
	const IScriptMap * pScriptMap = m_pecb->MetaData().GetScriptMap();

	//	If we have a script map at all then check it for a match.
	//	Otherwise we have no match by definition.
	//
	if (pScriptMap)
	{
		scMatch = pScriptMap->ScMatched (LpwszMethod(),
										 MidMethod(),
										 pwszURI,
										 dwAccess,
										 pfCGI);

		if (S_OK != scMatch)
		{
			//	ScApplyChildISAPI need the SCODE value
			//
			if (pscMatch)
				*pscMatch = scMatch;
			return TRUE;
		}
	}

	return FALSE;
}

//	------------------------------------------------------------------------
//
//	CMethUtil::ScApplyChildISAPI()
//
//	During normal method processing to actually forward a method.
//
//	fCheckISAPIAccess flag tells us whether to do the "extra ACL check for ASP".
//	FALSE means don't check for READ & WRITE in the acl, TRUE means do the check.
//
//	fKeepQueryString is a special flag, TRUE by default.  This flag is only
//	used when actually forwarding the method.  It can be set to FALSE
//	when we are forwarding the request to a different URI
//	(like a default document in a folder).
//
//	Return codes
//		NOTE: These codes were carefully chosen so that the FAILED() macro
//		can be applied to the return code and tell us whether to
//		terminate our method processing.
//
//		This may seem counterintuitive, but this function FAILS if
//		any of the following happened:
//		o	An ISAPI was found to handle this method (and the method
//			was forwarded successfully.
//		o	The caller said Translate:F, but doesn't have correct Metabase access.
//		o	The caller said Translate:F, but doesn't have correct ACL access.
//
//		This method SUCCEEDS if:
//		o	The caller said Translate:F, and passed all access checks.
//		o	No matching ISAPI was found.
//
//	S_OK	There was NO ISAPI to apply
//	E_DAV_METHOD_FORWARDED
//			There was an ISAPI to apply, and the method WAS successfully
//			forwarded.  NOTE: This IS a FAILED return code!  We should STOP
//			method processing if we see this return code!
//
//
//$REVIEW: Right now, we check the Author bit (Metabase::MD_ACCESS_SOURCE)
//$REVIEW: if they say Translate:F, but NOT if there are no scriptmaps or
//$REVIEW: if our forwarding fails.  Is this right?


SCODE
CMethUtil::ScApplyChildISAPI(LPCWSTR pwszURI,
							 DWORD	dwAccess,
							 BOOL	fCheckISAPIAccess,
							 BOOL	fKeepQueryString) const
{
	BOOL fFoundMatch = FALSE;
	BOOL fCGI;
	SCODE sc = S_OK;
	UINT cchURI = 0;

	//	If there is a scriptmap then grab it and see if there is a match.
	//	(If there is, remember if this was a CGI script or no.)
	//
	fFoundMatch = FInScriptMap (pwszURI,
								dwAccess,
								&fCGI,
								&sc);

	ScriptMapTrace ("CMethUtil::ScApplyChildISAPI()"
					"-- matching scriptmap %s, sc=0x%08x\n",
					fFoundMatch ? "found" : "not found",
					sc);

	//	If we are just being called to check for matching scriptmaps,
	//	report our findings now.  Or if there were no scriptmaps that
	//	applied, then we are also good to go.
	//
	if (!fFoundMatch)
		goto ret;

	//	We do not call into the child ISAPI's if the "Translate" header
	//	is present and its value is "F"
	//
	if (!FTranslated())
	{
		//	Translate header indicates no translation is allowed.
		//

		//	Check our metabase access.  We must have the Author bit
		//	(MD_ACCESS_SOURCE) in order to process raw source bits
		//	if, and only if, a scriptmap did apply to the resource.
		//
		if (!(dwAccess & MD_ACCESS_SOURCE))
		{
			DebugTrace ("CMethUtil::ScApplyChildISAPI()"
						"-- Translate:F with NO metabase Authoring access.\n");

			sc = E_DAV_NO_IIS_ACCESS_RIGHTS;
			goto ret;
		}

		//	One more thing, tho....
		//
		//	IF they've asked for special access checking, AND we found a match,
		//	AND it's a script (NOT a CGI), then do the special access checking.
		//
		//	NOTE: This all comes from "the ASP access bug".  ASP overloaded
		//	the NTFS read-access-bit to also mean execute-access.
		//	That means that many agents will have read-access to ASP files.
		//	So how do we restrict access to fetch the raw ASP bits, when
		//	the read-bit means execute?  Well, we're gonna assume that
		//	an agent that is allowed to read the raw bits is also allowed to
		//	WRITE the raw bits.  If they have WRITE access to the ASP-file,
		//	then, and only then, let them fetch raw scriptfile bits.
		//
		if (fCheckISAPIAccess && !fCGI)
		{
			if (FAILED (ScChildISAPIAccessCheck (*m_pecb,
				m_pecb->LpwszPathTranslated(),
				GENERIC_READ | GENERIC_WRITE,
				NULL)))
			{
				//	They didn't have read AND WRITE access.
				//	Return FALSE, and tell the caller that the access check failed.
				//
				DebugTrace ("ScChildISAPIAccessCheck() fails the processing of this method!\n");
				sc = E_ACCESSDENIED;
				goto ret;
			}
		}
	}
	else
	{
		//	Translate header says TRUE. we need execute permission to forward
		//	the request
		//
		if ((dwAccess & (MD_ACCESS_EXECUTE | MD_ACCESS_SCRIPT)) == 0)
		{
			sc = E_DAV_NO_IIS_EXECUTE_ACCESS;
			goto ret;
		}

		ScriptMapTrace ("ScApplyChildISAPI -- Forwarding method\n");

		//	If the method is excluded, then we really do not want to
		//	touch the source, so "translate: t"/excluded is a no-access
		//
		if (sc == W_DAV_SCRIPTMAP_MATCH_EXCLUDED)
		{
			sc = E_DAV_NO_IIS_ACCESS_RIGHTS;
			goto ret;
		}

		Assert (sc == W_DAV_SCRIPTMAP_MATCH_FOUND);

		//  if we are going forwarding this to a child ISAPI, we need to check
		//  if the URI has a trailing slash or backslash.  if it does we will
		//  model httpext behavior and fail as file not found.  trailing
		//  backslashes and slashes are not handled well if forwarded...
		//
		Assert (pwszURI);
		cchURI = static_cast<UINT>(wcslen(pwszURI));
		if (1 < cchURI)
		{
			if (L'/' == pwszURI[cchURI-1] || L'\\' == pwszURI[cchURI-1])
			{
				sc = HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);
				goto ret;
			}
		}

		//	Try the forward.
		//
		//	BIG NOTE: If it fails, we're gonna check the GetLastError,
		//	and if that happens to be ERROR_INVALID_PARAMETER,
		//	we're gonna assume that there's not actually any applicable
		//	scriptmap, and process the method ourselves after all!
		//
		sc = m_presponse->ScForward(pwszURI,
									fKeepQueryString,
									FALSE);
		if (FAILED(sc))
		{
			//	The forward attempt failed because there is no applicable
			//	scriptmap.  Let's handle the method ourselves.
			//$REVIEW: This is going to have the same end result as
			//$REVIEW: Translate:F.  Should we check the "author" bit here???
			//
			if (HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) == sc)
			{
				//	We get to handle this method.
				//
				sc = S_OK;

				if (!(dwAccess & MD_ACCESS_SOURCE))
				{
					DebugTrace ("ScApplyChildISAPI"
								"-- Forward FAIL with NO metabase Authoring access.\n");
					sc = E_DAV_NO_IIS_ACCESS_RIGHTS;
					goto ret;
				}
			}

			goto ret;
		}

		//	We were forwarded...
		//
		sc = E_DAV_METHOD_FORWARDED;
	}

ret:

	return sc;
}

//	------------------------------------------------------------------------
//
//	DwDirectoryAccess()
//
//	Fetch access perms for the specified URI.
//
DWORD
DwDirectoryAccess(
	const IEcb &ecb,
	LPCWSTR pwszURI,
	DWORD dwAccIfNone)
{
	DWORD dwAcc = dwAccIfNone;
	auto_ref_ptr<IMDData> pMDData;

	if (SUCCEEDED(HrMDGetData(ecb, pwszURI, pMDData.load())))
		dwAcc = pMDData->DwAccessPerms();

	return dwAcc;
}

//	IIS Access ----------------------------------------------------------------
//
SCODE
CMethUtil::ScIISAccess (
	LPCWSTR pwszURI,
	DWORD dwAccessRequested,
	DWORD* pdwAccessOut) const
{
	DWORD dw;

	//	Make sure the url is stripped of any prefix
	//
	pwszURI = PwszUrlStrippedOfPrefix (pwszURI);

	//$	SECURITY:
	//
	//	Plug the ::$DATA security hole for NT5.
	//
	if (! FSucceededColonColonCheck(pwszURI))
		return HRESULT_FROM_WIN32(ERROR_INVALID_NAME);

	//	Get the access from the cache
	//
	dw = DwDirectoryAccess( *m_pecb,
							pwszURI,
							dwAccessRequested );

	//	If the caller actually needs the bits back, pass them
	//	back here
	//
	if (pdwAccessOut)
		*pdwAccessOut = dw;

	//	Check the access bits against the requested bits
	//
	if ((dw & dwAccessRequested) == dwAccessRequested)
		return S_OK;

	return E_DAV_NO_IIS_ACCESS_RIGHTS;
}

//	Common IIS checking
//		Apply child ISAPI if necessary, if not, verify if desired access
//	is granted
//
//	parameters
//		pszURI			the request URI
//		dwDesired		desired access, default is zero
//		fCheckISAPIAccess	Only used by GET/HEAD, default to FALSE.
//
SCODE
CMethUtil::ScIISCheck( LPCWSTR pwszURI,
					   DWORD dwDesired			/* = 0 */,
					   BOOL fCheckISAPIAccess 	/* = FALSE */) const
{
	SCODE	sc = S_OK;

	//$	SECURITY:
	//
	//	Plug the ::$DATA security hole for NT5.
	//
	if (! FSucceededColonColonCheck(pwszURI))
		return HRESULT_FROM_WIN32(ERROR_INVALID_NAME);

	//	Whoa, baby.  Do not let "*" urls get through this
	//	check unless the method is unknown or is an OPTIONS
	//	request.
	//
	if ((L'*' == pwszURI[0]) && ('\0' == pwszURI[1]))
	{
		if ((MID_UNKNOWN != m_mid) && (MID_OPTIONS != m_mid))
		{
			DebugTrace ("Dav: url: \"*\" not valid for '%ls'\n",
						m_pecb->LpwszMethod());

			return E_DAV_METHOD_FAILURE_STAR_URL;
		}
	}

	//	Get IIS access rights
	//
	DWORD dwAcc = DwDirectoryAccess (*m_pecb, pwszURI, 0);

	//	See if we need to hand things off to a child ISAPI.
	//
	sc = ScApplyChildISAPI (pwszURI,
							dwAcc,
							fCheckISAPIAccess,
							TRUE);
	if (FAILED(sc))
	{
		//	Either the request has been forwarded, or some bad error occurred.
		//	In either case, quit here and map the error!
		//
		goto ret;
	}

	//	Check to see if the desired access is granted
	//
	if (dwDesired != (dwAcc & dwDesired))
	{
		//	At least one of the desired access rights is not granted,
		//	so generate an appropriate error.  Note: if multiple rights
		//	were requested then multiple rights may not have been granted.
		//	The error is guaranteed to be appropriate to at least one
		//	of the rights not granted, but not necessariliy all of them.
		//
		switch (dwDesired & (MD_ACCESS_READ|MD_ACCESS_WRITE))
		{
			case MD_ACCESS_READ:
				sc = E_DAV_NO_IIS_READ_ACCESS;
				break;

			case MD_ACCESS_WRITE:
				sc = E_DAV_NO_IIS_WRITE_ACCESS;
				break;

			default:
				sc = E_DAV_NO_IIS_ACCESS_RIGHTS;
				break;
		}
		goto ret;
	}

ret:
	return sc;
}

//	Destination url access ------------------------------------------------
//
SCODE __fastcall
CMethUtil::ScGetDestination (LPCWSTR* ppwszUrl,
							 LPCWSTR* ppwszPath,
							 UINT* pcchPath,
							 CVRoot** ppcvr) const		//	Defaults to NULL
{
	SCODE sc = S_OK;

	LPCWSTR	pwszFullUrl = NULL;

	Assert (ppwszUrl);
	Assert (ppwszPath);
	Assert (pcchPath);

	*ppwszUrl = NULL;
	*ppwszPath = NULL;
	*pcchPath = 0;
	if (ppcvr)
		*ppcvr = NULL;

	//	If we haven't done this yet...
	//
	if (NULL == m_pwszDestinationUrl.get())
	{
		LPCWSTR pwszStripped;
		UINT cch;

		//	Get the header in unicode, apply URL conversion. I.e.
		//	value will be escaped and and translated into unicode
		//	taking into account the Accept-Language: header
		//
		pwszFullUrl = m_prequest->LpwszGetHeader(gc_szDestination, TRUE);

		//	If they asked for a destination, there better be one...
		//
		if (NULL == pwszFullUrl)
		{
			sc = E_DAV_NO_DESTINATION;
			DebugTrace ("CMethUtil::ScGetDestination() - required destination header not present\n");
			goto ret;
		}

		//	URL has been escaped at header retrieval step, the last step
		//	in order to get normalized URL is to canonicalize what we have
		//	at the current moment. So allocate enough space and fill it.
		//
		cch = static_cast<UINT>(wcslen(pwszFullUrl) + 1);
		m_pwszDestinationUrl = static_cast<LPWSTR>(g_heap.Alloc(cch * sizeof(WCHAR)));

		//	Canonicalize the absolute URL. It does not mater what value we
		//	pass in for cch here - it is just an output parameter.
		//
		sc = ScCanonicalizePrefixedURL (pwszFullUrl,
										m_pwszDestinationUrl.get(),
										&cch);
		if (S_OK != sc)
		{
			//	We've given ScCanonicalizeURL() sufficient space, we
			//	should never see S_FALSE here - size can only shrink.
			//
			Assert(S_FALSE != sc);
			DebugTrace ("CMethUtil::ScGetDestination() - ScCanonicalizeUrl() failed 0x%08lX\n", sc);
			goto ret;
		}

		//	Now translate the path, take a best guess and use MAX_PATH as
		//	the initial size of the path
		//
		cch = MAX_PATH;
		m_pwszDestinationPath = static_cast<LPWSTR>(g_heap.Alloc(cch * sizeof(WCHAR)));

		sc = ::ScStoragePathFromUrl (*m_pecb,
									 m_pwszDestinationUrl.get(),
									 m_pwszDestinationPath.get(),
									 &cch,
									 m_pcvrDestination.load());

		//	If there was not enough space -- ie. S_FALSE was returned --
		//	then reallocate and try again...
		//
		if (sc == S_FALSE)
		{
			m_pwszDestinationPath.realloc(cch * sizeof(WCHAR));

			sc = ::ScStoragePathFromUrl (*m_pecb,
										 m_pwszDestinationUrl.get(),
										 m_pwszDestinationPath.get(),
										 &cch,
										 m_pcvrDestination.load());

			//	We should not get S_FALSE again --
			//	we allocated as much space as was requested.
			//
			Assert (S_FALSE != sc);
		}
		if (FAILED(sc))
			goto ret;

		//	We always will get '\0' terminated string back, and cch will indicate
		//	the number of characters written (including '\0' termination). Thus it
		//	will always be greater than 0 at this point
		//
		Assert( cch > 0 );
		m_cchDestinationPath = cch - 1;

		//	We must remove all trailing slashes, in case the path is not empty string
		//
		if ( 0 != m_cchDestinationPath )
		{
			//	Since URL is normalized there may be not more than one trailing slash
			//
			if ((L'\\' == m_pwszDestinationPath[m_cchDestinationPath - 1]) ||
				(L'/'  == m_pwszDestinationPath[m_cchDestinationPath - 1]))
			{
				m_cchDestinationPath--;
				m_pwszDestinationPath[m_cchDestinationPath] = L'\0';
			}
		}
	}

	//	We will have S_OK or W_DAV_SPANS_VIRTUAL_ROOTS here.
	//	In any case it is success
	//
	Assert(SUCCEEDED(sc));

	//	Return the pointers. For the url, make sure that any
	//	prefix is stripped off.
	//
	//	Note that the ScStoragePathFromUrl() already has checked
	//	to see if the all important prefix matched, so we just need
	//	to strip
	//
	*ppwszUrl = PwszUrlStrippedOfPrefix (m_pwszDestinationUrl.get());

	//	Pass everything back to the caller
	//
	*ppwszPath = m_pwszDestinationPath.get();
	*pcchPath = m_cchDestinationPath;

	//	If they wanted the destination virtual root, hand that back
	//	as well.
	//
	if (ppcvr)
	{
		*ppcvr = m_pcvrDestination.get();
	}

ret:

	//	Do a cleanup if we failed. Subsequent calls to the
	//	function just may start returning partial data if
	//	we do not do that. That is undesirable.
	//
	if (FAILED (sc))
	{
		if (m_pwszDestinationUrl.get())
			m_pwszDestinationUrl.clear();

		if (m_pwszDestinationPath.get())
			m_pwszDestinationPath.clear();

		if (m_pcvrDestination.get())
			m_pcvrDestination.clear();

		m_cchDestinationPath = 0;

		//$	WINBUGS: 403726: If we don't pass back the full url, then
		//	an incorrect result gets generated and no copy is done.
		//
		*ppwszUrl = pwszFullUrl;
		//
		//$	WINBUGS: end.
	}

	return sc;
}

//	------------------------------------------------------------------------
//
//	CMethUtil::ScGetExpirationTime
//
//	Gets the expiration time string from the metabase corresponding to a
//	particular resource.  If pszURI is NULL and there is information in the
//	metabase for the particular resource, the function will return (in pcb) the number
//	of bytes necessary to pass in as pszBuf to get the requested expiration
//	string.
//
//			[in]	pszURI		The resource you want the expiration time string for
//			[in]	pszBuf,		The buffer we put the string into
//			[in out]pcb			On [in], the size of the buffer passed in,
//								On [out], if the buffer size passed in would be
//								insufficient or there was no buffer passed in.
//								Otherwise unchanged from [in].
//
//	Return values:
//		S_OK: If pszBuf was non-NULL, then the data was successfully retrieved and
//			  the length of the actual data was put in pcb.
//		HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER): The buffer passed in is not
//													   large enough to hold
//													   the requested data.
//		HRESULT_FROM_WIN32(ERROR_NO_DATA): No data for expiration time exists in the
//										   metabase for this resource.  Default value
//										   of 1 day expiration should be used in this
//										   case.
//
SCODE
CMethUtil::ScGetExpirationTime(IN		LPCWSTR	pwszURI,
							   IN		LPWSTR	pwszBuf,
							   IN OUT	UINT *	pcch)
{
	SCODE sc = S_OK;
	auto_ref_ptr<IMDData> pMDData;
	LPCWSTR pwszExpires = NULL;
	UINT cchExpires;

	//
	//	Fetch the metadata for this URI.  If it has a content type map
	//	then use it to look for a mapping.  If it does not have a content
	//	type map then check the global mime map.
	//
	//	Note: if we fail to get the metadata at all then default the
	//	content type to application/octet-stream.  Do not use the global
	//	mime map just because we cannot get the metadata.
	//
	if ( FAILED(HrMDGetData(pwszURI, pMDData.load())) ||
		 (NULL == (pwszExpires = pMDData->PwszExpires())) )
	{
		sc = HRESULT_FROM_WIN32(ERROR_NO_DATA);
		goto ret;
	}

	cchExpires = static_cast<UINT>(wcslen(pwszExpires) + 1);
	if (*pcch < cchExpires)
	{
		sc = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
		*pcch = cchExpires;
		goto ret;
	}
	else
	{
		memcpy(pwszBuf, pwszExpires, cchExpires * sizeof(WCHAR));
		*pcch = cchExpires;
	}

ret:

	return sc;
}

//	ScCheckMoveCopyDeleteAccess() ---------------------------------------------
//
SCODE
CMethUtil::ScCheckMoveCopyDeleteAccess (
	/* [in] */ LPCWSTR pwszUrl,
	/* [in] */ CVRoot* pcvrUrl,			//	OPTIONAL (may be NULL)
	/* [in] */ BOOL fDirectory,
	/* [in] */ BOOL fCheckScriptmaps,
	/* [in] */ DWORD dwAccess)
{
	Assert (pwszUrl);

	auto_ref_ptr<IMDData> pMDData;
	BOOL fCGI = FALSE;
	DWORD dwAccessActual = 0;
	SCODE sc = S_OK;

	//	Get the metadata object
	//
	//$	REVIEW: Ideally we could get this without it being cached
	//
	if (NULL == pcvrUrl)
	{
		sc = HrMDGetData (pwszUrl, pMDData.load());
		if (FAILED (sc))
			goto ret;
	}
	else
	{
		LPCWSTR pwszMbPathVRoot;
		CStackBuffer<WCHAR> pwszMbPathChild;
		UINT cchPrefix;
		UINT cchUrl = static_cast<UINT>(wcslen(pwszUrl));

		//	Map the URI to its equivalent metabase path, and make sure
		//	the URL is stripped before we call into the MDPath processing
		//
		Assert (pwszUrl == PwszUrlStrippedOfPrefix (pwszUrl));
		cchPrefix = pcvrUrl->CchPrefixOfMetabasePath (&pwszMbPathVRoot);
		if (!pwszMbPathChild.resize(CbSizeWsz(cchPrefix + cchUrl)))
			return E_OUTOFMEMORY;

		memcpy (pwszMbPathChild.get(), pwszMbPathVRoot, cchPrefix * sizeof(WCHAR));
		memcpy (pwszMbPathChild.get() + cchPrefix, pwszUrl, (cchUrl + 1) * sizeof(WCHAR));
		sc = HrMDGetData (pwszMbPathChild.get(), pwszMbPathVRoot, pMDData.load());
		if (FAILED (sc))
			goto ret;
	}
	//
	//$	REVIEW: end.

	//	Check metabase access to see if we have the minimal access
	//	required for this operation.
	//
	dwAccessActual = pMDData->DwAccessPerms();
	if ((dwAccessActual & dwAccess) != dwAccess)
	{
		sc = E_DAV_NO_IIS_ACCESS_RIGHTS;
		goto ret;
	}

	//$	SECURITY: check for IP restrictions placed on this resource
	//$	REVIEW: this may not be good enough, we may need to do more
	//	than this...
	//
	if (!m_pecb->MetaData().FSameIPRestriction(pMDData.get()))
	{
		sc = E_DAV_BAD_DESTINATION;
		goto ret;
	}
	//
	//$	REVIEW: end.

	//$	SECURITY: Check to see if authorization is different than the
	//	request url's authorization.
	//
	if (m_pecb->MetaData().DwAuthorization() != pMDData->DwAuthorization())
	{
		sc = E_DAV_BAD_DESTINATION;
		goto ret;
	}
	//
	//$	REVIEW: end.

	//	Check to see if we have 'star' scriptmap honors over this
	//	file.
	//
	if (!m_pecb->MetaData().FSameStarScriptmapping(pMDData.get()))
	{
		sc = E_DAV_STAR_SCRIPTMAPING_MISMATCH;
		goto ret;
	}

	//	Check to see if there is a scriptmap that applies.  If so, then
	//	we had better have MD_ACCESS_SOURCE rights to do a move or a copy.
	//
	if (fCheckScriptmaps && FInScriptMap(pwszUrl,
										 dwAccessActual,
										 &fCGI))
	{
		if (0 == (MD_ACCESS_SOURCE & dwAccessActual))
		{
			sc = E_DAV_NO_IIS_ACCESS_RIGHTS;
			goto ret;
		}
	}

ret:

	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\request.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	REQUEST.CPP
//
//		HTTP 1.1/DAV 1.0 request handling via ISAPI
//
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include <_davprs.h>

#include "ecb.h"
#include "body.h"
#include "header.h"


//	========================================================================
//
//	CLASS IRequest
//

//	------------------------------------------------------------------------
//
//	IRequest::~IRequest()
//
//		Out of line virtual destructor for request interface class
//		necessary for proper destruction of derived request classes
//		via a pointer to an IRequest
//
IRequest::~IRequest() {}



//	========================================================================
//
//	CLASS ISubPart
//
//	Interface class for the request body part (CEcbRequestBodyPart)
//	"sub parts".  CEcbRequestBodyPart has two "modes" of operation
//	through which execution flows:
//
//	1.	Accessing the first 48K of data which IIS caches in the ECB.
//	2.	Accessing remaining unread data from the ECB in the form of an
//		asynchronous read-once stream.
//
//	An ISubPart is a stripped-down IBodyPart (..\inc\body.h) -- it does
//	not provide any Rewind() semantics because there's nothing that
//	needs to (or can be) rewound.  It does, however, provide a function
//	to proceed from one mode to the next.
//
class CEcbRequestBodyPart;
class ISubPart
{
	//	NOT IMPLEMENTED
	//
	ISubPart& operator=( const ISubPart& );
	ISubPart( const ISubPart& );

protected:
	ISubPart() {}

public:
	//	CREATORS
	//
	virtual ~ISubPart() = 0;

	//	ACCESSORS
	//
	virtual ULONG CbSize() const = 0;
	virtual ISubPart * NextPart( CEcbRequestBodyPart& part ) const = 0;

	//	MANIPULATORS
	//
	virtual VOID Accept( IBodyPartVisitor& v,
						 UINT ibPos,
						 IAcceptObserver& obsAccept ) = 0;
};

//	------------------------------------------------------------------------
//
//	ISubPart::~ISubPart()
//
//		Out of line virtual destructor necessary for proper deletion
//		of objects of derived classes via this class
//
ISubPart::~ISubPart()
{
}


//	========================================================================
//
//	CLASS CEcbCache
//
//
//
class CEcbCache : public ISubPart
{
	//
	//	Our IEcb.  Note that this is a C++ reference and not
	//	a auto_ref_ptr.  This is simply an optimization since
	//	lifetime of CEcbCache is entirely scoped by the lifetime
	//	of the request body which in turn is scoped by the
	//	lifetime of the request which holds an auto_ref_ptr
	//	to the IEcb.
	//
	IEcb& m_ecb;

	//	NOT IMPLEMENTED
	//
	CEcbCache& operator=( const CEcbCache& );
	CEcbCache( const CEcbCache& );

public:
	//	CREATORS
	//
	CEcbCache( IEcb& ecb ) : m_ecb(ecb) {}

	//	ACCESSORS
	//
	ULONG CbSize() const { return m_ecb.CbAvailable(); }
	ISubPart * NextPart( CEcbRequestBodyPart& ecbRequestBodyPart ) const;

	//	MANIPULATORS
	//
	VOID Accept( IBodyPartVisitor& v,
				 UINT ibPos,
				 IAcceptObserver& obsAccept );
};


//	========================================================================
//
//	CLASS CEcbStream
//
//	Accesses remaining unread data from the ECB in the form of an
//	asynchronous read-once stream.
//
class CEcbStream :
	public ISubPart,
	private IAsyncStream,
	private IAsyncWriteObserver,
	private IIISAsyncIOCompleteObserver
{
	//
	//	Size of the static buffer that we read into.  This buffer
	//	improves performance by reducing the number of times we
	//	have to call into IIS to read data from the ECB when we
	//	are being called to read only a few bytes at a time.
	//
	enum
	{
		CB_BUF = 32 * 1024	//$??? Is 32K reasonable?
	};

	//
	//	Ref back to our request object.  This need not be a counted
	//	ref because its lifetime scopes ours AS LONG AS we add a ref
	//	when starting any async operation which could extend our
	//	lifetime -- i.e. an async read from the ECB.
	//
	IRequest& m_request;

	//
	//	Ref to the IEcb.  This need not be a counted ref because its
	//	lifetime, like ours, is scoped by the lifetime of the request
	//	object.
	//
	IEcb& m_ecb;

	//
	//	Last error HRESULT.  Used in state processing to determine
	//	when to quit because of an error
	//
	HRESULT m_hr;

	//
	//	Size of the ECB stream and the amount of data that has
	//	been consumed (read into the buffer below).
	//
	DWORD m_dwcbStreamSize;
	DWORD m_dwcbStreamConsumed;

	//
	//	The three states of the buffer:
	//
	//	IDLE
	//	Data is present in the buffer or the buffer is empty
	//	because we've reached the end of the stream.  The
	//	buffer is not being filled.
	//
	//	FILLING
	//	The buffer is in the process of being filled from the stream.
	//	Data may or may not already be present.  Nobody is waiting
	//	on the data.
	//
	//	FAULTING
	//	The buffer is in the process of being filled from the stream.
	//	There is no data present.  A caller pended and needs to be
	//	notified when data becomes available.
	//
	//	WRITE_ERROR
	//	This state is only enterable if the stream is in a CopyTo()
	//	operation.  See CEcbStream::WriteComplete() and
	//	CEcbStream::FillComplete() for the conditions under which
	//	the buffer is in this state.
	//
	enum
	{
		STATUS_IDLE,
		STATUS_FILLING,
		STATUS_FAULTING,
		STATUS_WRITE_ERROR
	};

	mutable LONG m_lBufStatus;

	//
	//	AsyncRead()/AsyncCopyTo() observer to notify as soon as the
	//	stream is ready after FAULTING in data.
	//
	union
	{
		IAsyncReadObserver *   m_pobsAsyncRead;
		IAsyncCopyToObserver * m_pobsAsyncCopyTo;
	};

	//
	//	Wakeup functions and function pointer used to get processing
	//	started again after an AsyncRead() or AsyncCopyTo() request
	//	returns because data has to be faulted into the buffer.
	//	All these functions do is notify their associated observer
	//	(m_pobsAsyncRead or m_pobsAsyncCopyTo).
	//
	VOID WakeupAsyncRead();
	VOID WakeupAsyncCopyTo();

	typedef VOID (CEcbStream::*PFNWAKEUP)();
	PFNWAKEUP m_pfnWakeup;

	//
	//	Hint as to the amount of data that we can expect to
	//	be returned from a single async read from the
	//	read-once ECB stream.  Used to help fully utilize
	//	the available space in the buffer.  The hint is the
	//	historical maximum over all of the previous reads.
	//
	UINT m_cbBufFillHint;

	//
	//	Indices into the buffer that implement the 'ring' property.
	//
	//	The Fill index (m_ibBufFill) is where data is read into the
	//	buffer from the async stream.
	//
	//	The Drain index (m_ibBufDrain) is where data is read from or
	//	copied out of the buffer.
	//
	//	The Wrap index (m_ibBufWrap) is used by the drainer to tell
	//	it where the data in the buffer ends.  This is needed because
	//	we may not have filled all the way to the end of the buffer.
	//	m_ibBufWrap has no meaning until m_ibBufDrain > m_ibBufFill,
	//	so we explicitly leave it unitialized at construction time.
	//
	//	The ring property of the buffer holds if and only if the
	//	following condition is met:
	//
	//	m_ibBufDrain <= m_ibBufFill
	//	Data exists in the half-open interval [m_ibBufDrain,m_ibBufFill).
	//
	//	m_ibBufDrain > m_ibBufFill
	//	Data exists in the half-open interval [m_ibBufDrain,m_ibBufWrap)
	//	and the half-open interval [0,m_ibBufFill).
	//
	UINT m_ibBufFill;
	mutable UINT m_ibBufDrain;
	mutable UINT m_ibBufWrap;

	//
	//	Static buffer for requests of less than CB_BUF bytes.
	//	Note that this variable is located at the END of the class
	//	definition to make debugging in CDB easier -- all of the
	//	other member variables are visible up front.
	//
	BYTE m_rgbBuf[CB_BUF];

	//
	//	Debugging variables for easy (yeah, right) detection
	//	of async buffering problems and interactions with
	//	external streams.
	//
#ifdef DBG
	UINT dbgm_cbBufDrained;
	UINT dbgm_cbBufAvail;
	UINT dbgm_cbToCopy;
	LONG dbgm_cRefAsyncWrite;
#endif

	//
	//	IAsyncWriteObserver
	//
	void AddRef();
	void Release();
	VOID WriteComplete( UINT cbWritten,
						HRESULT hr );

	//
	//	IAsyncStream
	//
	UINT CbReady() const;

	VOID AsyncRead( BYTE * pbBuf,
					UINT   cbBuf,
					IAsyncReadObserver& obsAsyncRead );

	VOID AsyncCopyTo( IAsyncStream& stmDst,
					  UINT          cbToCopy,
					  IAsyncCopyToObserver& obsAsyncCopyTo );

	//
	//	IIISAsyncIOCompleteObserver
	//
	VOID IISIOComplete( DWORD dwcbRead,
						DWORD dwLastError );

	//
	//	Buffer functions
	//
	VOID AsyncFillBuf();
	VOID FillComplete();

	HRESULT HrBufReady( UINT * pcbBufReady,
						const BYTE ** ppbBufReady ) const;

	UINT CbBufReady() const;
	const BYTE * PbBufReady() const;

	VOID DrainComplete( UINT cbDrained );

	//	NOT IMPLEMENTED
	//
	CEcbStream& operator=( const CEcbStream& );
	CEcbStream( const CEcbStream& );

public:
	//	CREATORS
	//
	CEcbStream( IEcb& ecb,
				IRequest& request ) :
		m_ecb(ecb),
		m_request(request),
		m_hr(S_OK),
		m_dwcbStreamSize(ecb.CbTotalBytes() - ecb.CbAvailable()),
		m_dwcbStreamConsumed(0),
		m_lBufStatus(STATUS_IDLE),
		m_cbBufFillHint(0),
		m_ibBufFill(0),
#ifdef DBG
		dbgm_cbBufDrained(0),
		dbgm_cbBufAvail(0),
		dbgm_cRefAsyncWrite(0),
#endif
		m_ibBufDrain(0),
		m_ibBufWrap(static_cast<UINT>(-1))
	{
	}

	//	ACCESSORS
	//
	ULONG CbSize() const
	{
		//
		//	Return the size of the stream.  Normally this is just
		//	the value we initialized above.  But for chunked requests
		//	this value changes as soon as we know the real
		//	size of the request.
		//
		return m_dwcbStreamSize;
	}

	ISubPart * NextPart( CEcbRequestBodyPart& part ) const
	{
		//
		//	The stated size of the CEcbRequestBodyPart should keep
		//	us from ever getting here.
		//
		TrapSz( "CEcbStream is the last sub-part. There is NO next part!" );
		return NULL;
	}

	//	MANIPULATORS
	//
	VOID Accept( IBodyPartVisitor& v,
				 UINT ibPos,
				 IAcceptObserver& obsAccept );
};


//	========================================================================
//
//	CLASS CEcbRequestBodyPart
//
class CEcbRequestBodyPart : public IBodyPart
{
	//
	//	Position in the entire body part at the time of the most recent
	//	call to Accept().  This value is used to compute the number of
	//	bytes accepted by the previous call so that the sub-parts can
	//	be properly positioned for the next call.
	//
	ULONG m_ibPosLast;

	//
	//	The sub-parts
	//
	//$NYI	If we ever need caching of data from the ECB stream again,
	//$NYI	it should be implemented as a third sub-part comprised of
	//$NYI	or derived from a CTextBodyPart.
	//
	CEcbCache  m_partEcbCache;
	CEcbStream m_partEcbStream;

	//
	//	Pointer to the current sub-part
	//
	ISubPart * m_pPart;

	//
	//	Position in the current sub-part
	//
	ULONG m_ibPart;

	//	NOT IMPLEMENTED
	//
	CEcbRequestBodyPart& operator=( const CEcbRequestBodyPart& );
	CEcbRequestBodyPart( const CEcbRequestBodyPart& );

public:
	CEcbRequestBodyPart( IEcb& ecb,
						 IRequest& request ) :
		m_partEcbCache(ecb),
		m_partEcbStream(ecb, request)
	{
		Rewind();
	}

	//	ACCESSORS
	//
	UINT64 CbSize64() const
	{
		//
		//	The size of the whole really is the sum of its parts.
		//	But -- and this is a big but -- the reported size of
		//	the stream may change, so we must not cache its value.
		//	The reason is that chunked requests may not have a
		//	Content-Length so the final size is not known until
		//	we have read the entire stream.
		//
		return m_partEcbCache.CbSize() + m_partEcbStream.CbSize();
	}

	//	MANIPULATORS
	//
	ISubPart& EcbCachePart() { return m_partEcbCache; }
	ISubPart& EcbStreamPart() { return m_partEcbStream; }

	VOID Rewind();

	VOID Accept( IBodyPartVisitor& v,
				 UINT64 ibPos64,
				 IAcceptObserver& obsAccept );
};

//	------------------------------------------------------------------------
//
//	CEcbRequestBodyPart::Rewind()
//
VOID
CEcbRequestBodyPart::Rewind()
{
	m_ibPosLast = 0;
	m_pPart = &m_partEcbCache;
	m_ibPart = 0;
}

//	------------------------------------------------------------------------
//
//	CEcbRequestBodyPart::Accept()
//
VOID
CEcbRequestBodyPart::Accept( IBodyPartVisitor& v,
							 UINT64 ibPos64,
							 IAcceptObserver& obsAccept )
{
	UINT ibPos;

	//		NOTE: To be compatable with IBodyPart the position is passed
	//	in as 64 bit value (this is necessary to support file body parts
	//	that are bigger than 4GB). However we do not want anyone to create
	//	text body parts that are bigger than 4GB. So assert that it is not
	//	the case here and truncate the passed in 64 bit value to 32 bits.
	//
	Assert(0 == (0xFFFFFFFF00000000 & ibPos64));
	ibPos = static_cast<UINT>(ibPos64);

	//
	//	Check our assumption that the position has increased since the
	//	last call by not more than what was left of the current sub-part.
	//
	Assert( ibPos >= m_ibPosLast );
	Assert( ibPos - m_ibPosLast <= m_pPart->CbSize() - m_ibPart );

	//
	//	Adjust the position of the current sub-part by the
	//	previously accepted amount.
	//
	m_ibPart += ibPos - m_ibPosLast;

	//
	//	Remember the current position so that we can do the above
	//	computations again the next time through.
	//
	m_ibPosLast = ibPos;

	//
	//	If we're at the end of the current sub-part, go on to the next one.
	//
	while ( m_ibPart == m_pPart->CbSize() )
	{
		m_pPart = m_pPart->NextPart(*this);
		m_ibPart = 0;
	}

	//
	//	Forward the accept call to the current sub-part
	//
	m_pPart->Accept( v, m_ibPart, obsAccept );
}


//	========================================================================
//
//	CLASS CEcbCache
//
//	Accessing the first 48K of data which IIS caches in the ECB.
//

//	------------------------------------------------------------------------
//
//	CEcbCache::Accept()
//
VOID
CEcbCache::Accept( IBodyPartVisitor& v,
				   UINT ibPos,
				   IAcceptObserver& obsAccept )
{
	//
	//	Limit the request to just the amount of data cached in the ECB.
	//
	v.VisitBytes( m_ecb.LpbData() + ibPos,
				  m_ecb.CbAvailable() - ibPos,
				  obsAccept );
}

//	------------------------------------------------------------------------
//
//	CEcbCache::NextPart()
//
ISubPart *
CEcbCache::NextPart( CEcbRequestBodyPart& ecbRequestBodyPart ) const
{
	return &ecbRequestBodyPart.EcbStreamPart();
}


//	========================================================================
//
//	CLASS CEcbStream
//

//	------------------------------------------------------------------------
//
//	CEcbStream::AddRef()
//
void
CEcbStream::AddRef()
{
	m_request.AddRef();
}

//	------------------------------------------------------------------------
//
//	CEcbStream::Accept()
//
void
CEcbStream::Release()
{
	m_request.Release();
}

//	------------------------------------------------------------------------
//
//	CEcbStream::Accept()
//
VOID
CEcbStream::Accept( IBodyPartVisitor& v,
					UINT ibPos,
					IAcceptObserver& obsAccept )
{
	EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::Accept() ibPos = %u\n", GetCurrentThreadId(), this, ibPos );

	v.VisitStream( *this,
				   m_dwcbStreamSize - ibPos,
				   obsAccept );
}

//	------------------------------------------------------------------------
//
//	CEcbStream::CbReady()
//
//	Returns the number of bytes that are instantly available to be read.
//
UINT
CEcbStream::CbReady() const
{
	return CbBufReady();
}

//	------------------------------------------------------------------------
//
//	CEcbStream::AsyncRead()
//
VOID
CEcbStream::AsyncRead( BYTE * pbBufCaller,
					   UINT   cbToRead,
					   IAsyncReadObserver& obsAsyncRead )
{
	//
	//	Don't assert that cbToRead > 0.  It is a valid request to read 0
	//	bytes from the stream.  The net effect of such a call is to just
	//	start/resume asynchronously filling the buffer.
	//
	//	Assert( cbToRead > 0 );
	//

	EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::AsyncRead() cbToRead = %u\n", GetCurrentThreadId(), this, cbToRead );

	//
	//	Stash away the observer and wakeup method so that if
	//	the call to HrBufReady() returns E_PENDING then then
	//	wakeup function will be called when the data becomes
	//	available.
	//
	m_pobsAsyncRead = &obsAsyncRead;
	m_pfnWakeup = WakeupAsyncRead;

	//
	//	Start/Continue asynchronously filling the buffer
	//
	AsyncFillBuf();

	//
	//	Check whether the buffer has data available to be read.  If so, then
	//	read it into the caller's buffer.  If not, then it will wake us up
	//	when data becomes available.
	//
	UINT cbBufReady;
	const BYTE * pbBufReady;

	HRESULT hr = HrBufReady( &cbBufReady, &pbBufReady );

	if ( FAILED(hr) )
	{
		//
		//	If HrBufReady() returns a "real" error, then report it.
		//
		if ( E_PENDING != hr )
			obsAsyncRead.ReadComplete(0, hr);

		//
		//	HrBufReady() returns E_PENDING if there is no data immediately
		//	available.  If it does then it will wake us up when data
		//	becomes available.
		//
		return;
	}

	//
	//	Limit what we read to the minimum of what's available in the
	//	buffer or what was asked for.  Keep in mind that cbBufReady or
	//	cbToRead may be 0.
	//
	cbToRead = min(cbToRead, cbBufReady);

	//
	//	Copy whatever is to be read from the I/O buffer into
	//	the caller's buffer.
	//
	if ( cbToRead )
	{
		EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::AsyncRead() %lu bytes to read\n", GetCurrentThreadId(), this, cbToRead );

		Assert( !IsBadWritePtr(pbBufCaller, cbToRead) );

		//
		//	Copy data from our buffer into the caller's
		//
		memcpy( pbBufCaller, pbBufReady, cbToRead );

		//
		//	Tell our buffer how much we've consumed so it can
		//	continue to fill and replace what we consumed.
		//
		DrainComplete( cbToRead );
	}

	//
	//	Tell our observer that we're done.
	//
	obsAsyncRead.ReadComplete(cbToRead, S_OK);
}

//	------------------------------------------------------------------------
//
//	CEcbStream::WakeupAsyncRead()
//
//	Called by FillComplete() when the buffer returns to IDLE after
//	FAULTING because an observer pended trying to access an empty buffer
//	while the buffer was FILLING.
//
VOID
CEcbStream::WakeupAsyncRead()
{
	EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::WakeupAsyncRead()\n", GetCurrentThreadId(), this );

	//
	//	Now that that the buffer is ready, tell the observer to try again.
	//
	m_pobsAsyncRead->ReadComplete(0, S_OK);
}

//	------------------------------------------------------------------------
//
//	CEcbStream::AsyncCopyTo
//
//	Called by FillComplete() when the buffer returns to IDLE after
//	FAULTING because an observer pended trying to access an empty buffer
//	while the buffer was FILLING.
//
VOID
CEcbStream::AsyncCopyTo( IAsyncStream& stmDst,
						 UINT          cbToCopy,
						 IAsyncCopyToObserver& obsAsyncCopyTo )
{
	Assert( cbToCopy > 0 );

	EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::AsyncCopyTo() cbToCopy = %u\n", GetCurrentThreadId(), this, cbToCopy );

	//
	//	Stash away the observer and wakeup method so that if
	//	the call to HrBufReady() returns E_PENDING then the
	//	wakeup function will be called when the data becomes
	//	available.
	//
	m_pobsAsyncCopyTo = &obsAsyncCopyTo;
	m_pfnWakeup = WakeupAsyncCopyTo;

	//
	//	Start/Continue asynchronously filling the buffer
	//
	AsyncFillBuf();

	//
	//	Check whether the buffer has data available to be read.  If so, then
	//	copy it to the caller's stream.  If not, then it will wake us up
	//	when data becomes available.
	//
	UINT cbBufReady;
	const BYTE * pbBufReady;

	HRESULT hr = HrBufReady( &cbBufReady, &pbBufReady );

	if ( FAILED(hr) )
	{
		//
		//	If HrBufReady() returns a "real" error, then report it.
		//
		if ( E_PENDING != hr )
			obsAsyncCopyTo.CopyToComplete(0, hr);

		//
		//	HrBufReady() returns E_PENDING if there is no data immediately
		//	available.  If it does then it will wake us up when data
		//	becomes available.
		//
		return;
	}

	//
	//	Limit what we copy to the minimum of what's available in the
	//	buffer or what was asked for.  Keep in mind cbBufReady may
	//	be 0.
	//
	cbToCopy = min(cbToCopy, cbBufReady);

	//
	//	Write whatever there is to write, if anything.  If there is
	//	nothing to write then notify the observer immediately that
	//	we're done -- i.e. do not ask the destination stream to
	//	write 0 bytes.
	//
	if ( cbToCopy )
	{
		EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::AsyncCopyTo() %lu bytes to copy\n", GetCurrentThreadId(), this, cbToCopy );

#ifdef DBG
		//
		//	In DBG builds, remember how much we're writing so that
		//	we can quickly catch streams that do something stupid
		//	like tell our WriteComplete() that it wrote more than
		//	we asked it to.
		//
		dbgm_cbToCopy = cbToCopy;
#endif

		//
		//	We should only ever be doing one AsyncWrite() at a time.
		//
		Assert( InterlockedIncrement(&dbgm_cRefAsyncWrite) == 1 );

		stmDst.AsyncWrite( pbBufReady, cbToCopy, *this );
	}
	else
	{
		obsAsyncCopyTo.CopyToComplete(0, S_OK);
	}
}

//	------------------------------------------------------------------------
//
//	CEcbStream::WakeupAsyncCopyTo()
//
VOID
CEcbStream::WakeupAsyncCopyTo()
{
	EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::WakeupAsyncCopyTo()\n", GetCurrentThreadId(), this );

	//
	//	Now that that the buffer is ready, tell the observer to try again.
	//
	m_pobsAsyncCopyTo->CopyToComplete(0, S_OK);
}

//	------------------------------------------------------------------------
//
//	CEcbStream::WriteComplete
//
VOID
CEcbStream::WriteComplete(
	UINT cbWritten,
	HRESULT hr )
{
	//
	//	Make sure the stream isn't telling us it wrote more than we asked for!
	//
	Assert( dbgm_cbToCopy >= cbWritten );

	EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::WriteComplete() %u "
					"bytes written (0x%08lX)\n", GetCurrentThreadId(),
					this, cbWritten, hr );

	//
	//	If no error has occurred, we want to call DrainComplete as soon as
	//	possible, as it will begin another AsyncFillBuf to fill in the part of
	//	the buffer that was drained.
	//
	//	However, in the case of error, we do not want to call DrainComplete
	//	before the error gets set into m_hr and the state of the stream gets
	//	set to STATUS_WRITE_ERROR.  We don't want to call AsyncFillBuf without
	//	the error latched in, or it will start another async. operation, which
	//	is not good since we've already errored!
	//
    if (SUCCEEDED(hr))
        DrainComplete( cbWritten );

	//
	//	We should only ever do one AsyncWrite() at a time.  Assert that.
	//
	Assert( InterlockedDecrement(&dbgm_cRefAsyncWrite) == 0 );

	//
	//	If the async write completed successfully just notify the CopyTo observer.
	//
	if ( SUCCEEDED(hr) )
	{
		m_pobsAsyncCopyTo->CopyToComplete( cbWritten, hr );
	}

	//
	//	Otherwise things get a little tricky....
	//
	else
	{
		//
		//	Normally we would just notify the CopyTo observer of the error.
		//	But if we are FILLING that could be a bad idea.  When we notify
		//	the observer it will most likely send back an error to the client
		//	via async I/O.  If we are still FILLING at that point then we would
		//	have multiple async I/Os outstanding which is a Bad Thing(tm) --
		//	ECB leaks making the web service impossible to shut down, etc.
		//
		//	So instead of notifying the observer unconditionally we latch
		//	in the error and transition to a WRITE_ERROR state.  If the
		//	previous state was FILLING then don't notify the observer.
		//	CEcbStream::FillComplete() will notify the observer when
		//	FILLING completes (i.e. when it is safe to do another async I/O).
		//	If the previous state was IDLE (and it must have been either IDLE
		//	or FILLING) then it is safe to notify the observer because
		//	the transition to WRITE_ERROR prevents any new filling operations
		//	from starting.
		//

		//
		//	Latch in the error now.  FillComplete() can potentially send
		//	the error response immediately after we change state below.
		//
		m_hr = hr;

		//
		//	Change state.  If the previous state was IDLE then it is safe
		//	to notify the observer from this thread.  No other thread can
		//	start FILLING once the state changes.
		//
		LONG lBufStatusPrev = InterlockedExchange( &m_lBufStatus, STATUS_WRITE_ERROR );

		//
		//	Now that we've latched in the errors, we can safely call
		//	DrainComplete.  AsyncFillBuf checks that the state of the
		//	stream is NOT STATUS_WRITE_ERROR before beginning an
		//	asynchronous read.
		//
        DrainComplete( cbWritten );

		if ( STATUS_IDLE == lBufStatusPrev )
		{
			EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::WriteComplete() - Error writing.  Notifying CopyTo observer.\n", GetCurrentThreadId(), this );

			m_pobsAsyncCopyTo->CopyToComplete( cbWritten, hr );
		}
		else
		{
			//
			//	The previous state was not IDLE, so it must have
			//	been FILLING.  In no other state could we have been
			//	writing.
			//
			Assert( STATUS_FILLING == lBufStatusPrev );

			EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::WriteComplete() - Error writing while filling.  FillComplete() will notify CopyTo observer\n", GetCurrentThreadId(), this );
		}
	}
}

//	------------------------------------------------------------------------
//
//	CEcbStream::DrainComplete()
//
//	Called by AsyncRead() and WriteComplete() when draining (consuming)
//	data from the buffer.  This function updates the drain position of
//	the buffer and allows the buffer to continue filling the space
//	just drained.
//
VOID
CEcbStream::DrainComplete( UINT cbDrained )
{
#ifdef DBG
	dbgm_cbBufDrained += cbDrained;

	UINT cbBufAvail = InterlockedExchangeAdd( reinterpret_cast<LONG *>(&dbgm_cbBufAvail),
											  -static_cast<LONG>(cbDrained) );
	EcbStreamTrace( "DAV: TID %3d: 0x%08lX: !!!CEcbStream::DrainComplete() %lu left to write (%u in buffer)\n", GetCurrentThreadId(), this, m_dwcbStreamSize - dbgm_cbBufDrained, cbBufAvail );

	Assert( dbgm_cbBufDrained <= m_dwcbStreamConsumed );
#endif

	//
	//	Update the drain position of the buffer.  Don't wrap here.
	//	We wrap only in CbBufReady().
	//
	m_ibBufDrain += cbDrained;

	//
	//	Resume/Continue filling the buffer
	//
	AsyncFillBuf();
}

//	------------------------------------------------------------------------
//
//	CEcbStream::CbBufReady()
//
UINT
CEcbStream::CbBufReady() const
{
	//
	//	Poll the filling position now so that it doesn't change
	//	between the time we do the comparison below and the time
	//	we use its value.
	//
	UINT ibBufFill = m_ibBufFill;

	//
	//	If the fill position is still ahead of the drain position
	//	then the amount of data available is simply the difference
	//	between the two.
	//
	if ( ibBufFill >= m_ibBufDrain )
	{
		return ibBufFill - m_ibBufDrain;
	}

	//
	//	If the fill position is behind the drain then the fillling
	//	side must have wrapped.  If the drain position has not yet
	//	reached the wrap position then the amount of data available
	//	is the difference between the two.
	//
	else if ( m_ibBufDrain < m_ibBufWrap )
	{
		Assert( ibBufFill < m_ibBufDrain );
		Assert( m_ibBufWrap != static_cast<UINT>(-1) );

		return m_ibBufWrap - m_ibBufDrain;
	}

	//
	//	Otherwise the fill position has wrapped and the drain
	//	position has reached the wrap position so wrap the
	//	drain position back to the beginning.  At that point
	//	the amount of data available will be the difference
	//	between the fill and the drain positions.
	//
	else
	{
		Assert( ibBufFill < m_ibBufDrain );
		Assert( m_ibBufDrain == m_ibBufWrap );
		Assert( m_ibBufWrap != static_cast<UINT>(-1) );

		m_ibBufWrap = static_cast<UINT>(-1);
		m_ibBufDrain = 0;

		return m_ibBufFill;
	}
}

//	------------------------------------------------------------------------
//
//	CEcbStream::PbBufReady()
//
const BYTE *
CEcbStream::PbBufReady() const
{
	return m_rgbBuf + m_ibBufDrain;
}

//	------------------------------------------------------------------------
//
//	CEcbStream::AsyncFillBuf()
//
//	Starts asynchronously filling the buffer.  The buffer may not (and
//	usually won't) fill up with just one call.  Called by:
//
//	AsyncRead()/AsyncCopyTo()
//		to start filling the buffer for the read/copy request.
//
//	DrainComplete()
//		to resume filling the buffer after draining some amount
//		from a previously full buffer.
//
//	IISIOComplete()
//		to continue filling the buffer after the initial call.
//
VOID
CEcbStream::AsyncFillBuf()
{
	//
	//	Don't do anything if the buffer is already FILLING (or FAULTING).
	//	We can have only one outstanding async I/O at once.  If the buffer
	//	is IDLE, then start filling.
	//
	if ( STATUS_IDLE != InterlockedCompareExchange(
							&m_lBufStatus,
							STATUS_FILLING,
							STATUS_IDLE ) )
		return;

	//
	//	Important!!!  The following checks CANNOT be moved outside
	//	the 'if' clause above without introducing the possibility
	//	of having multiple outstanding async I/O operations.
	//	So don't even consider that "optimization".
	//

	//
	//	First, check whether we are in an error state.  If we are
	//	then don't try to read any more data.  The stream is ready
	//	with whatever data (if any) is already there when it goes
	//	idle.
	//
	if ( FAILED(m_hr) )
	{
		EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::FReadyBuf() m_hr = 0x%08lX\n", GetCurrentThreadId(), this, m_hr );
		FillComplete();
		return;
	}

	//
	//	If we've read everything there is to read, then the buffer
	//	is ready (though it may be empty) once we return to idle.
	//	The only time we would not be idle in this case is if the
	//	thread completing the final read is in IISIOComplete() and
	//	has updated m_dwcbStreamConsumed, but has not yet returned
	//	the status to idle.
	//
	if ( m_dwcbStreamConsumed == m_dwcbStreamSize )
	{
		EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::FReadyBuf() End Of Stream\n", GetCurrentThreadId(), this );
		FillComplete();
		return;
	}

	//
	//	Poll the current drain position and use the polled value
	//	for all of the calculations below to keep them self-consistent.
	//	We would have serious problems if the drain position were to
	//	change (specifically, if it were to wrap) while we were in
	//	the middle of things.
	//
	UINT ibBufDrain = m_ibBufDrain;

	Assert( m_ibBufFill < CB_BUF );
	Assert( ibBufDrain <= CB_BUF );

	//
	//	If there's no space to fill, then we can't do anything more.
	//	The buffer is already full of data.  Note that the situation
	//	can change the instant after we do the comparison below.
	//	In particular, if another thread is draining the buffer at
	//	the same time, it is possible that there may be no data
	//	available by the time we return TRUE.  Callers which
	//	allow data to be drained asynchronously must be prepared
	//	to deal with this.
	//
	if ( (m_ibBufFill + 1) % CB_BUF == ibBufDrain % CB_BUF )
	{
		EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::FReadyBuf() buffer full\n", GetCurrentThreadId(), this );
		FillComplete();
		return;
	}

	//	Ideally, we could read up to as much data as is left in the stream.
	//
	UINT cbFill = m_dwcbStreamSize - m_dwcbStreamConsumed;

	//
	//	But that amount is limited by the amount of buffer available
	//	for filling.  If the current fill position in the buffer is
	//	ahead of (greater than) the drain position, that amount is
	//	the greater of the distance from the current fill position
	//	to the end of the buffer or the distance from the beginning
	//	of the buffer to the current drain position.  If the fill
	//	position is behind (less than) the drain position, the amount
	//	is simply the distance from the fill position to the drain
	//	position.
	//
	if ( m_ibBufFill == ibBufDrain )
	{
		//	Case 1.

		//
		//	The buffer is empty so wrap both the fill and drain
		//	positions back to the beginning of the buffer to get
		//	maximum usage of the buffer.  Note that it is safe for
		//	us (the filling code) to move m_ibBufDrain here because
		//	there can be nobody draining the buffer at this point -- it's empty!
		//
		//	Note that above comment is NOT correct (but leave it here to that it's
		//	easy to understand why the following code is necessary). We can't assume
		//	nobody is draing the buffer at the same time, because the draining
		//	side may be in the middle of checking buffer status, say it's calling
		//	CbBufReady() to check the number of bytes availble, if this happens
		//	right after we set m_ibBufFill to 0 and before set m_ibBufDrain to 0,
		//	then CbBufReady() will report the buffer as not empty and we end up
		//	reading garbage data or crash.
		//
		if (STATUS_FAULTING == m_lBufStatus)
		{
			//	Case 1.1

			//	This is what the original code looks like. this code is safe only
			//	when the status if in FAULING state, which means the draining side
			//	is in waiting state already.

			//  We have:
			//
			//  [_________________________________________________]
			//                                          ^
			//                                          m_ibBufFill == ibBufDrain
			//                                          (i.e. empty buffer)
			//
			//	After filling, we will have:
			//
			//  [DATADATADATADATADATADATADATADATADATADATADAT______]
			//   ^                                          ^
			//   ibBufDrain                                 m_ibBufFill
			//
			m_ibBufFill = 0;
			m_ibBufDrain = 0;
			cbFill = min(cbFill, CB_BUF - 1);
		}
		//	If the status is not FAULTING (which means the draining side is not in
		//	waiting state yet), one alternative is to wait for the status
		//	to turn to FAULTING, but that will drag the performance, because the whole
		//	design of this async draining/filling mechanism is to avoid any expensive
		//	synchronization.
		else
		{
			//	Though we can't move both pointers, we still want to fill as much
			//	as we can. so depends on whether the fill pointer in the lower half
			//	or higher half of the buffer, different approach is used.
			//
			if (m_ibBufFill < (CB_BUF - 1) / 2)
			{
				//	Case 1.2 - similar logic to case 3

				//  We have:
				//
				//  [_________________________________________________]
				//              ^
				//              m_ibBufFill == ibBufDrain
				//              (i.e. empty buffer)
				//
				//	After filling, we will have:
				//
				//  [___________DATADATADATADATADATADATADATADAT______]
				//				^                              ^
				//				ibBufDrain                     m_ibBufFill
				//
				cbFill = min(cbFill, CB_BUF - m_ibBufFill - !ibBufDrain);
			}
			else
			{
				//	Case 1.3 - similiar logic to case 4.

				//  We have:
				//
				//  [_________________________________________________]
				//									     ^
				//										 m_ibBufFill == ibBufDrain
				//										 (i.e. empty buffer)
				//
				//	After filling, we will have:
				//
				//  [DATADATADATADATADAT______________________________]
				//				        ^                ^
				//					    m_ibBufFill		 m_ibBufWrap == ibBufDrain

				//	Yes, we touch both m_ibBufWrap and m_ibBufFill. However, as
				//  in case 4, we are safe here, because, CbBufReady() get ibBufFill
				//	first, and then access m_ibBufWrap etc.
				//	Here we are setting	these two members in reverse order, so that,
				//	if CbBufReady()	doesn't see the new m_ibBufFill, then it simply
				//	returns 0 as usual, If it does see the new m_ibBufFill, the m_ibBufWrap
				//	is already set and thus CbBufReady will reset both m_ibBufWrap and
				//	m_ibBufDRain.
				//

				//	If this thread is here when CbBufReady is called, CbBufReady will
				//	return 0, which means buffer empty and will put draining side to wait

				//	Set the wrap position so that a draining thread will
				//	know when to wrap the drain position.
				//
				m_ibBufWrap = m_ibBufFill;

				//	If this thread is here when CbBufReady is called, Again, CbBufRead will
				//	return 0, which means buffer empty and will put draining side to wait

				//	Set the fill position back at the beginning of the buffer
				//
				m_ibBufFill = 0;

				//	If this thread is here when CbBufReady is called, CbBufReady will
				//	reset m_ibBufWrap to -1, and m_ibBufDrain to 0, which is exactly
				//	what we want.

				cbFill = min(cbFill, ibBufDrain - 1);
			}
		}

		Assert( cbFill > 0 );
		EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::FReadyBuf() m_ibBufFill == ibBufDrain (empty buffer).  New values: m_cbBufFillHint = %u, m_ibBufFill = %u, ibBufDrain = %u, m_ibBufWrap = %u\n", GetCurrentThreadId(), this, m_cbBufFillHint, m_ibBufFill, ibBufDrain, m_ibBufWrap );
	}
	else if ( m_ibBufFill < ibBufDrain )
	{
		//	Case 2

		//
		//  We have:
		//
		//  [DATADATA_______________DATADATADATADA***UNUSED***]
		//           ^              ^             ^
		//           m_ibBufFill    ibBufDrain    m_ibBufWrap
		//
		//	After filling, we will have:
		//
		//  [DATADATADATADATADATADA_DATADATADATADA***UNUSED***]
		//                         ^^             ^
		//                         |ibBufDrain    m_ibBufWrap
		//                         m_ibBufFill
		//
		cbFill = min(cbFill, ibBufDrain - m_ibBufFill - 1);

		Assert( cbFill > 0 );

		EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::FReadyBuf() m_ibBufFill < ibBufDrain.  New values: m_cbBufFillHint = %u, m_ibBufFill = %u, ibBufDrain = %u, m_ibBufWrap = %u\n", GetCurrentThreadId(), this, m_cbBufFillHint, m_ibBufFill, ibBufDrain, m_ibBufWrap );
	}
	else if ( ibBufDrain <= CB_BUF - m_ibBufFill ||
			  m_cbBufFillHint <= CB_BUF - m_ibBufFill )

	{
		//	Case 3

		Assert( m_ibBufFill > ibBufDrain );

		//
		//	If ibBufDrain is 0 then we can't fill all the way to
		//	the end of the buffer (since the end of the buffer is
		//	synonymous with the beginning).  To account for this
		//	we need to subtract 1 from cbFill if ibBufDrain is 0.
		//	We can do that without the ?: operator as long as the
		//	following holds true:
		//
		Assert( 0 == !ibBufDrain || 1 == !ibBufDrain );

		//
		//  We have:                                v------v m_cbBufFillHint
		//
		//  [________________DATADATADATADATADATADAT__________]
		//                   ^                      ^
		//                   ibBufDrain             m_ibBufFill
		//	-OR-
		//
		//  We have:                                v------------v m_cbBufFillHint
		//
		//  [DATADATADATADATADATADATADATADATADATADAT__________]
		//   ^                                      ^
		//   ibBufDrain                             m_ibBufFill
		//
		//
		//	After filling, we will have:
		//
		//  [________________DATADATADATADATADATADATADATADATAD]
		//   ^               ^                                ^
		//   m_ibBufFill     ibBufDrain                       m_ibBufWrap
		//
		//	-OR-
		//
		//  [DATADATADATADATADATADATADATADATADATADATADATADATA_]
		//   ^                                               ^
		//   ibBufDrain                                      m_ibBufFill
		//
		cbFill = min(cbFill, CB_BUF - m_ibBufFill - !ibBufDrain);

		Assert( cbFill > 0 );

		EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::FReadyBuf() m_ibBufFill > ibBufDrain (enough room at end of buffer).  New values: m_cbBufFillHint = %u, m_ibBufFill = %u, ibBufDrain = %u, m_ibBufWrap = %u\n", GetCurrentThreadId(), this, m_cbBufFillHint, m_ibBufFill, ibBufDrain, m_ibBufWrap );
	}
	else
	{
		//	Case 4

		Assert( m_ibBufFill > ibBufDrain );
		Assert( m_cbBufFillHint > CB_BUF - m_ibBufFill );
		Assert( ibBufDrain > CB_BUF - m_ibBufFill );

		//
		//  We have:                                v------------v m_cbBufFillHint
		//
		//  [________________DATADATADATADATADATADAT__________]
		//                   ^                      ^
		//                   ibBufDrain             m_ibBufFill
		//
		//
		//	After filling, we will have:
		//
		//  [DATADATADATADAT_DATADATADATADATADATADAT***UNUSED*]
		//                  ^^                      ^
		//                  |ibBufDrain             m_ibBufWrap
		//                  m_ibBufFill
		//

		//
		//	Set the wrap position so that a draining thread will
		//	know when to wrap the drain position.
		//
		m_ibBufWrap = m_ibBufFill;

		//
		//	Set the fill position back at the beginning of the buffer
		//
		m_ibBufFill = 0;

		//
		//	And fill up to the drain position - 1
		//
		Assert( ibBufDrain > 0 );
		cbFill = min(cbFill, ibBufDrain - 1);

		Assert( cbFill > 0 );

		EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::FReadyBuf() m_ibBufFill > ibBufDrain (not enough room at end of buffer).  New values: m_cbBufFillHint = %u, m_ibBufFill = %u, ibBufDrain = %u, m_ibBufWrap = %u\n", GetCurrentThreadId(), this, m_cbBufFillHint, m_ibBufFill, ibBufDrain, m_ibBufWrap );
	}

	//
	//	Start async I/O to read from the ECB.
	//
	{
		SCODE sc = S_OK;

		//
		//	Add a reference to our parent request to keep us alive
		//	for the duration of the async call.
		//
		//	Use auto_ref_ptr so that we release the ref if the
		//	async call throws an exception.
		//
		auto_ref_ptr<IRequest> pRef(&m_request);

		EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::FReadyBuf() reading %u bytes\n", GetCurrentThreadId(), this, cbFill );

		//	Assert that we are actually going to fill something and that
		//	we aren't going to fill past the end of our buffer.
		//
		Assert( m_ibBufFill + cbFill <= CB_BUF );

		sc = m_ecb.ScAsyncRead( m_rgbBuf + m_ibBufFill,
								&cbFill,
								*this );
		if (SUCCEEDED(sc))
		{
			pRef.relinquish();
		}
		else
		{
			DebugTrace( "CEcbStream::AsyncFillBuf() - IEcb::ScAsyncRead() failed with error 0x%08lX\n", sc );

			m_hr = sc;
			FillComplete();
		}
	}
}

//	------------------------------------------------------------------------
//
//	CEcbStream::FillComplete()
//
VOID
CEcbStream::FillComplete()
{
	//
	//	Poll the wakeup function pointer now before the ICE() below
	//	so that we don't lose the value if another thread immediately
	//	starts filling immediately after we transition to IDLE.
	//
	PFNWAKEUP pfnWakeup = m_pfnWakeup;

	//
	//	At this point we had better be FILLING or FAULTING because
	//	we are completing async I/O started from AsyncFillBuf().
	//
	//	We could actually be in WRITE_ERROR as well.  See below
	//	and CEcbStream::WriteComplete() for why.
	//
	Assert( STATUS_FILLING == m_lBufStatus ||
			STATUS_FAULTING == m_lBufStatus ||
			STATUS_WRITE_ERROR == m_lBufStatus );

	//
	//	Attempt to transition to IDLE from FILLING.  If successful then
	//	we're done.  Otherwise we are either FAULTING or in the WRITE_ERROR
	//	state.  Handle those below.
	//
	LONG lBufStatus = InterlockedCompareExchange(
							&m_lBufStatus,
							STATUS_IDLE,
							STATUS_FILLING );

	if ( STATUS_FAULTING == lBufStatus )
	{
		//
		//	We are FAULTING.  This means the writing side of things
		//	needs to be notified now that data is available.  So
		//	change state to IDLE (remember: ICE() didn't change state
		//	above -- it just told us what the state is) and call
		//	the registered wakeup function.
		//
		m_lBufStatus = STATUS_IDLE;
		Assert( pfnWakeup );
		(this->*pfnWakeup)();
	}
	else if ( STATUS_WRITE_ERROR == lBufStatus )
	{
		EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::FillComplete() - Error writing while filling.  Notifying CopyTo observer\n", GetCurrentThreadId(), this );

		//
		//	We are in the WRITE_ERROR state.  This state is entered
		//	by CEcbStream::WriteComplete() during an async CopyTo operation
		//	when a write fails.  This terminal state prevents new async fill
		//	operations from starting.  When WriteComplete() transitioned into
		//	this state, it also checked if we were FILLING at the time.
		//	If we were then WriteComplete() left the responsibility for notifying
		//	the CopyTo observer up to us.  See CEcbStream::WriteComplete()
		//	for the reason why.
		//
		Assert( m_pobsAsyncCopyTo );
		m_pobsAsyncCopyTo->CopyToComplete( 0, m_hr );

		//
		//	Note that once in the WRITE_ERROR state we DO NOT transition
		//	back to IDLE.  WRITE_ERROR is a terminal state.
		//
	}
}

//	------------------------------------------------------------------------
//
//	CEcbStream::IISIOComplete()
//
//	Our IIISAsyncIOCompleteObserver method called by CEcb::IISIOComplete()
//	when the async I/O to read from the read-once request body stream
//	completes.
//
VOID
CEcbStream::IISIOComplete( DWORD dwcbRead,
						   DWORD dwLastError )
{
	//
	//	Claim the reference to our parent request added in AsyncFillBuf()
	//
	auto_ref_ptr<IRequest> pRef;
	pRef.take_ownership(&m_request);

	//
	//	Update the m_dwcbStreamConsumed *before* m_ibBufFill so that
	//	we can safely assert at any time on any thread that we never
	//	drain more than has been consumed.
	//
	//	Chunked requests: If we successfully read 0 bytes then we have
	//	reached the end of the request and should report the real
	//	stream size.
	//
	if ( ERROR_SUCCESS == dwLastError )
	{
		if ( 0 == dwcbRead )
			m_dwcbStreamSize = m_dwcbStreamConsumed;
		else
			m_dwcbStreamConsumed += dwcbRead;
	}
	else
	{
		DebugTrace( "CEcbStream::IISIOComplete() - Error %d during async read\n", dwLastError );
		m_hr = HRESULT_FROM_WIN32(dwLastError);
	}

#ifdef DBG
	UINT cbBufAvail = InterlockedExchangeAdd( reinterpret_cast<LONG *>(&dbgm_cbBufAvail), dwcbRead ) + dwcbRead;
	EcbStreamTrace( "DAV: TID %3d: 0x%08lX: !!!CEcbStream::IISIOComplete() %lu left to read (%u in buffer)\n", GetCurrentThreadId(), this, m_dwcbStreamSize - m_dwcbStreamConsumed, cbBufAvail );
#endif

	//	Assert that we didn't just read past the end of our buffer.
	//
	Assert( m_ibBufFill + dwcbRead <= CB_BUF );

	//	Update the fill position.  If we've reached the end of the buffer
	//	then wrap back to the beginning.  We must do this here BEFORE
	//	calling FillComplete() -- the fill position must be valid (i.e.
	//	within the bounds of the buffer) before we start off another
	//	fill cycle.
	//
	m_ibBufFill += dwcbRead;
	if ( CB_BUF == m_ibBufFill )
	{
		m_ibBufWrap = CB_BUF;
		m_ibBufFill = 0;
	}

	//	If we read more than the last fill hint then we know we
	//	can try to read at least this much next time.
	//
	if ( dwcbRead > m_cbBufFillHint )
	{
		EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::IISIOComplete() setting m_cbBufFillHint = %lu\n", GetCurrentThreadId(), this, dwcbRead );
		m_cbBufFillHint = dwcbRead;
	}

	EcbStreamTrace( "DAV: TID %3d: 0x%08lX: CEcbStream::IISIOComplete() dwcbRead = %lu, m_ibBufFill = %lu, m_dwcbStreamConsumed = %lu, m_dwcbStreamSize = %lu, dwLastError = %lu\n", GetCurrentThreadId(), this, dwcbRead, m_ibBufFill, m_dwcbStreamConsumed, m_dwcbStreamSize, dwLastError );

	//
	//	Indicate that we're done filling.  This resets the state from FILLING
	//	(or FAULTING) to idle and wakes up the observer if it is blocked.
	//
	FillComplete();

	//
	//	Kick off the next read cycle.  AsyncFillBuf() checks for error and
	//	end-of-stream conditions, so we don't have to.
	//
	AsyncFillBuf();
}

//	------------------------------------------------------------------------
//
//	CEcbStream::HrBufReady()
//
//	Determines how much and the location of the next block of data that
//	is instantaneously accessible in the buffer.  Also determines whether
//	the stream is in an error state (e.g. due to a failure reading
//	from the stream while filling the buffer).
//
//	The matrix of return results is:
//
//	HRESULT		*pcbBufReady	*ppbBufReady	Meaning
//	----------------------------------------------------
//	S_OK		> 0				valid			Data available
//	S_OK		0				n/a				No data available (EOS)
//	E_PENDING	n/a				n/a				No data available (pending)
//	E_xxx		n/a				n/a				Error
//
HRESULT
CEcbStream::HrBufReady( UINT * pcbBufReady,
						const BYTE ** ppbBufReady ) const
{
	Assert( pcbBufReady );
	Assert( ppbBufReady );

	//
	//	If the buffer has data ready, then return the amount and
	//	its location.
	//
	*pcbBufReady = CbBufReady();
	if ( *pcbBufReady )
	{
		*ppbBufReady = PbBufReady();
		return S_OK;
	}

	//
	//	No data ready.  If the buffer is in an error state
	//	then return the fact.
	//
	if ( S_OK != m_hr )
		return m_hr;

	//
	//	No data ready and we haven't had an error.  If the buffer
	//	is FILLING then transition to FAULTING and tell it to
	//	notify the observer when data becomes ready.  Return
	//	E_PENDING to the caller to tell it that we will be
	//	notifying the observer later.
	//
	//	Note that the very instant before we try to transition to FAULTING,
	//	the buffer may go from FILLING back to IDLE.  If that
	//	happens, then data should be ready, so go `round the loop
	//	and check again.
	//
	Assert( STATUS_FAULTING != m_lBufStatus );

	if ( STATUS_FILLING == InterlockedCompareExchange(
								&m_lBufStatus,
								STATUS_FAULTING,
								STATUS_FILLING ) )
		return E_PENDING;

	//
	//	The buffer must have finished FILLING sometime between
	//	when we did the initial poll and now.  At this point
	//	there must be data ready.
	//
	*pcbBufReady = CbBufReady();
	*ppbBufReady = PbBufReady();
	return S_OK;
}


//	========================================================================
//
//	CLASS CRequest
//
//		Request class
//
class CRequest : public IRequest
{
	//	Extension control block passed in through the ISAPI interface
	//
	auto_ref_ptr<IEcb>		m_pecb;

	//	Header caches. We retrieve headers as skinny, as no other
	//	choice is available.
	//		But sometimes we need wide version to operate on, so in
	//	that case we will get the skinny version, convert it properly
	//	and store in the wide header cache.
	//
	mutable CHeaderCache<CHAR>	m_hcHeadersA;
	mutable CHeaderCache<WCHAR>	m_hcHeadersW;

	//	This flag tells us whether we have cleared the headers
	//	and thus whether we should check the ECB when we cannot
	//	find a header in the cache.  Since we cannot actually remove
	//	headers from from the ECB, we just remember not to check the
	//	ECB if the headers have ever been "cleared".
	//
	bool					m_fClearedHeaders;

	//	Request body
	//
	auto_ptr<IBody>			m_pBody;

	//  NOT IMPLEMENTED
	//
	CRequest& operator=( const CRequest& );
	CRequest( const CRequest& );

public:
	//	CREATORS
	//
	CRequest( IEcb& ecb );

	//	ACCESSORS
	//
	LPCSTR LpszGetHeader( LPCSTR pszName ) const;
	LPCWSTR LpwszGetHeader( LPCSTR pszName, BOOL fUrlConversion ) const;
	BOOL FExistsBody() const;
	IStream * GetBodyIStream( IAsyncIStreamObserver& obs ) const;
	VOID AsyncImplPersistBody( IAsyncStream& stm,
							   IAsyncPersistObserver& obs ) const;

	//	MANIPULATORS
	//
	VOID ClearBody();
	VOID AddBodyText( UINT cbText, LPCSTR pszText );
	VOID AddBodyStream( IStream& stm );
};

//	------------------------------------------------------------------------
//
//	CRequest::CRequest()
//
CRequest::CRequest( IEcb& ecb ) :
    m_pecb(&ecb),
	m_pBody(NewBody()),
	m_fClearedHeaders(false)
{
	//
	//	If the ECB contains a body, then create a body part for it.
	//
	if ( ecb.CbTotalBytes() > 0 )
		m_pBody->AddBodyPart( new CEcbRequestBodyPart(ecb, *this) );

	//	HACK: The ECB needs to keep track of two pieces of request info,
	//	the Accept-Language and Connection headers.
	//	"Prime" the ECB with the Accept-Language value (if one is specified).
	//	The Connection header is sneakier -- read about that in
	//	CEcb::FKeepAlive.  Don't set it here, but do push updates through
	//	from SetHeader.
	//
	LPCSTR pszValue = LpszGetHeader( gc_szAccept_Language );
	if (pszValue)
		m_pecb->SetAcceptLanguageHeader( pszValue );
}


//	------------------------------------------------------------------------
//
//	CRequest::LpszGetHeader()
//
//		Retrieves the value of the specified HTTP request header.  If the
//		request does not have the specified header, LpszGetHeader() returns
//		NULL.  The header name, pszName, is in the standard HTTP header
//		format (e.g. "Content-Type")
//
LPCSTR
CRequest::LpszGetHeader( LPCSTR pszName ) const
{
	Assert( pszName );

	LPCSTR pszValue;

	//	Check the cache.
	//
	pszValue = m_hcHeadersA.LpszGetHeader( pszName );

	//	If we don't find the header in the cache then check
	//	the ECB
	//
	if ( !pszValue )
	{
		UINT cbName = static_cast<UINT>(strlen(pszName));
		CStackBuffer<CHAR> pszVariable( gc_cchHTTP_ + cbName + 1 );
		CStackBuffer<CHAR> pszBuf;

		//	Headers retrieved via the ECB are named using the ECB's
		//	server variable format (e.g. "HTTP_CONTENT_TYPE"), so we must
		//	convert our header name from its HTTP format to its ECB
		//	server variable equivalent.
		//
		//	Start with the header, prepended with "HTTP_"
		//
		memcpy( pszVariable.get(), gc_szHTTP_, gc_cchHTTP_ );
		memcpy( pszVariable.get() + gc_cchHTTP_, pszName, cbName + 1 );

		//	Replace all occurrences of '-' with '_'
		//
		for ( CHAR * pch = pszVariable.get(); *pch; pch++ )
		{
			if ( *pch == '-' )
				*pch = '_';
		}

		//	And uppercasify the whole thing
		//
		_strupr( pszVariable.get() );

		//	Get the value of this server variable from the ECB and
		//	add it to the header cache using its real (HTTP) name
		//
		for ( DWORD cbValue = 256; cbValue > 0; )
		{
			if (NULL == pszBuf.resize(cbValue))
			{
				SetLastError(E_OUTOFMEMORY);
				DebugTrace("CRequest::LpszGetHeader() - Error while allocating memory 0x%08lX\n", E_OUTOFMEMORY);
				throw CLastErrorException();
			}

			if ( m_pecb->FGetServerVariable( pszVariable.get(),
											 pszBuf.get(),
											 &cbValue ))
			{
				pszValue = m_hcHeadersA.SetHeader( pszName, pszBuf.get() );
				break;
			}
		}
	}

	return pszValue;
}

//	------------------------------------------------------------------------
//
//	CRequest::LpwszGetHeader()
//
//		Provides and caches wide version of the header value
//
//	PARAMETERS:
//
//		pszName			- header name
//		fUrlConversion	- flag that if set to TRUE indicates that special
//						  conversion rules should be applied. I.e. the
//						  header contains URL-s, that need escaping and
//						  codepage lookup. If set to FALSE the header will
//						  simply be converted using UTF-8 codepage. E.g.
//						  we do expect only US-ASCII characters in that
//						  header (or any other subset of UTF-8).
//							Flag is ignored once wide version gets cached.
//
LPCWSTR
CRequest::LpwszGetHeader( LPCSTR pszName, BOOL fUrlConversion ) const
{
	Assert( pszName );

	//	Check the cache
	//
	LPCWSTR pwszValue = m_hcHeadersW.LpszGetHeader( pszName );

	//	If we don't find the header in the cache then out for
	//	the skinny version, convert it and cache.
	//
	if ( !pwszValue )
	{
		//	Check the skinny cache
		//
		LPCSTR pszValue = LpszGetHeader( pszName );
		if (pszValue)
		{
			SCODE sc;

			CStackBuffer<WCHAR> pwszBuf;
			UINT cbValue = static_cast<UINT>(strlen(pszValue));
			UINT cchValue = cbValue + 1;

			//	Make sure we have sufficient buffer for conversion
			//
			if (NULL == pwszBuf.resize(CbSizeWsz(cbValue)))
			{
				sc = E_OUTOFMEMORY;
				SetLastError(sc);
				DebugTrace("CRequest::LpwszGetHeader() - Error while allocating memory 0x%08lX\n", sc);
				throw CLastErrorException();
			}

			sc = ScConvertToWide(pszValue,
								 &cchValue,
								 pwszBuf.get(),
								 LpszGetHeader(gc_szAccept_Language),
								 fUrlConversion);
			if (S_OK != sc)
			{
				//	We gave sufficient buffer
				//
				Assert(S_FALSE != sc);
				SetLastError(sc);
				throw CLastErrorException();
			}

			pwszValue = m_hcHeadersW.SetHeader( pszName, pwszBuf.get() );
		}
	}

	return pwszValue;
}

//	------------------------------------------------------------------------
//
//	CRequest::FExistsBody()
//
BOOL
CRequest::FExistsBody() const
{
	return !m_pBody->FIsEmpty();
}

//	------------------------------------------------------------------------
//
//	CRequest::GetBodyIStream()
//
IStream *
CRequest::GetBodyIStream( IAsyncIStreamObserver& obs ) const
{
	//
	//	With the assumption above in mind, persist the request body.
	//
	return m_pBody->GetIStream( obs );
}

//	------------------------------------------------------------------------
//
//	CRequest::AsyncImplPersistBody()
//
VOID
CRequest::AsyncImplPersistBody( IAsyncStream& stm,
								IAsyncPersistObserver& obs ) const
{
	m_pBody->AsyncPersist( stm, obs );
}

//	------------------------------------------------------------------------
//
//	CRequest::ClearBody()
//
VOID
CRequest::ClearBody()
{
	m_pBody->Clear();
}

//	------------------------------------------------------------------------
//
//	CRequest::AddBodyText()
//
//		Adds the specified text to the end of the request body.
//
VOID
CRequest::AddBodyText( UINT cbText, LPCSTR pszText )
{
	m_pBody->AddText( pszText, cbText );
}


//	------------------------------------------------------------------------
//
//	CRequest::AddBodyStream()
//
//		Adds the specified stream to the end of the request body.
//
VOID
CRequest::AddBodyStream( IStream& stm )
{
	m_pBody->AddStream( stm );
}



//	========================================================================
//
//	FREE FUNCTIONS
//

//	------------------------------------------------------------------------
//
//	NewRequest
//
IRequest *
NewRequest( IEcb& ecb )
{
	return new CRequest(ecb);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\response.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	RESPONSE.CPP
//
//		HTTP 1.1/DAV 1.0 response handling via ISAPI
//
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include <_davprs.h>

#include <new.h>
#include "ecb.h"
#include "header.h"
#include "body.h"
#include "instdata.h"
#include "custerr.h"


enum
{
	//
	//	Protocol overhead for a chunk prefix, which is:
	//
	//	chunk-size - formatted as 1*HEX
	//	CRLF
	//
	CB_CHUNK_PREFIX = 2 * sizeof(ULONG) + 2,

	//
	//	Protocol overhead for a chunk suffix, which is:
	//
	//	CRLF - at the end of chunk-data
	//	0    - if this is the last chunk
	//	CRLF - again, if this is the last chunk
	//	CRLF - terminate the chunked-body (no trailers)
	//
	CB_CHUNK_SUFFIX = 7,

	//
	//	Maximum amount of data (in bytes) per packet.
	//	We SHOULD limit ourselves to a reasonable maximum amount
	//	to get good chunking performance.  At one time, we had to
	//	ourselves to 8K at most because the socket transport layer
	//	did not accept more than this amount for sending.
	//	WriteClient() and SSF::HSE_REQ_TRANSMIT_FILE failed when
	//	more than this amount is submitted.
	//
	//	However, as of 06/03/1999, bumping this amount to 64K seems
	//	to work just fine.
	//
	CB_PACKET_MAX = 64 * 1024, // 64K

	//
	//	So the amount of data that we can put in a chunk then is just
	//	the max packet size minus the chunked encoding protocol overhead
	//	minus one byte because packets containing headers must be
	//	null-terminated (IIS doesn't use the byte counts we pass in).
	//
	CB_WSABUFS_MAX = CB_PACKET_MAX - CB_CHUNK_PREFIX - CB_CHUNK_SUFFIX - 1
};

//
//	Utility to check if the HTTP response code is one of the
//	"real" error response codes. Inlined here so that we use
//	it consistantly. Particularly, this is used to check if
//	we want to do custom error processing.
//
static BOOL inline FErrorStatusCode ( int nCode )
{
	return ( ( nCode >= 400 ) && ( nCode <= 599 ) );
}

//	========================================================================
//
//	CLASS CWSABufs
//
class CWSABufs
{
	//
	//	Having a small number of buffers in a fixed size array means
	//	that we can delay, if not avoid altogether, dynamic allocation.
	//	The number of buffers is somewhat arbitrary, but should be large
	//	enough to handle the common cases.  For example, DAVOWS GET
	//	typically uses two buffers: one for the headers, one for the body.
	//	Another example: error responses can use up to eight buffers (one
	//	per text body part added via AddText() by
	//	CResponse::FinalizeContent()).
	//
	enum
	{
		C_WSABUFS_FIXED = 8
	};

	WSABUF m_rgWSABufsFixed[C_WSABUFS_FIXED];

	//
	//	Dynamically sized array of WSABUFs for when we need more buffers
	//	than we can hold in the fixed array.
	//
	auto_heap_ptr<WSABUF> m_pargWSABufs;

	//
	//	Pointer to which of the two WSABUF arrays above we use.
	//
	WSABUF * m_pWSABufs;

	//
	//	Count of WSABUFs allocated/used
	//
	UINT m_cWSABufsAllocated;
	UINT m_cWSABufsUsed;

	//
	//	Total size of the data in all WSABUFS used
	//
	UINT m_cbWSABufs;

	//	NOT IMPLEMENTED
	//
	CWSABufs( const CWSABufs& );
	CWSABufs& operator=( const CWSABufs& );

public:
	//	CREATORS
	//
	CWSABufs();

	//	MANIPULATORS
	//
	UINT CbAddItem( const BYTE * pbItem, UINT cbItem );

	VOID Clear()
	{
		m_cWSABufsUsed = 0;
		m_cbWSABufs = 0;
	}

	//	ACCESSORS
	//
	UINT CbSize() const
	{
		return m_cbWSABufs;
	}

	VOID DumpTo( LPBYTE lpbBuf,
				 UINT   ibFrom,
			     UINT   cbToDump ) const;
};

//	------------------------------------------------------------------------
//
//	CWSABufs::CWSABufs()
//
CWSABufs::CWSABufs() :
   m_pWSABufs(m_rgWSABufsFixed),
   m_cWSABufsAllocated(C_WSABUFS_FIXED),
   m_cWSABufsUsed(0),
   m_cbWSABufs(0)
{
}

//	------------------------------------------------------------------------
//
//	CWSABufs::CbAddItem()
//
UINT
CWSABufs::CbAddItem( const BYTE * pbItem, UINT cbItem )
{
	//
	//	We can only hold up to CB_WSABUFS_MAX bytes.  Any more than
	//	that would exceed the capacity of the socket transport layer's
	//	buffer at transmit time.
	//
	Assert( m_cbWSABufs <= CB_WSABUFS_MAX );

	//
	//	Limit what we add so that the total does not exceed CB_WSABUFS_MAX.
	//
	cbItem = min( cbItem, CB_WSABUFS_MAX - m_cbWSABufs );

	//
	//	Resize the WSABUF array if necessary.
	//
	if ( m_cWSABufsUsed == m_cWSABufsAllocated )
	{
		m_cWSABufsAllocated *= 2;

		if ( m_pWSABufs == m_rgWSABufsFixed )
		{
			m_pargWSABufs =
				reinterpret_cast<WSABUF *>(
					g_heap.Alloc( sizeof(WSABUF) *
								  m_cWSABufsAllocated ));

			CopyMemory( m_pargWSABufs,
						m_rgWSABufsFixed,
						sizeof(WSABUF) * m_cWSABufsUsed );
		}
		else
		{
			m_pargWSABufs.realloc( sizeof(WSABUF) * m_cWSABufsAllocated );
		}

		m_pWSABufs = m_pargWSABufs;
	}

	//
	//	Add the new data to the end of the array
	//
	m_pWSABufs[m_cWSABufsUsed].len = cbItem;
	m_pWSABufs[m_cWSABufsUsed].buf = const_cast<LPSTR>(
										reinterpret_cast<LPCSTR>(pbItem));
	++m_cWSABufsUsed;

	//
	//	Update the total byte count
	//
	m_cbWSABufs += cbItem;

	return cbItem;
}

//	------------------------------------------------------------------------
//
//	CWSABufs::DumpTo()
//
//	Dumps cbToDump bytes of data from the WSA buffers starting at ibFrom
//	into a block of contiguous memory starting at lpbBuf.
//
VOID
CWSABufs::DumpTo( LPBYTE lpbBuf,
				  UINT   ibFrom,
				  UINT   cbToDump ) const
{
	UINT iWSABuf;


	Assert( !IsBadWritePtr(lpbBuf, m_cbWSABufs + 1) );

	//
	//	Skip WSA buffers up to the first one from which we will copy.
	//
	for ( iWSABuf = 0;
		  iWSABuf < m_cWSABufsUsed && m_pWSABufs[iWSABuf].len <= ibFrom;
		  iWSABuf++ )
	{
		ibFrom -= m_pWSABufs[iWSABuf].len;
		++iWSABuf;
	}

	//
	//	Copy data from this and subsequent buffers up to the lesser
	//	of the number of bytes requested or the number of bytes
	//	remaining in the WSA buffers.
	//
	for ( ;
		  iWSABuf < m_cWSABufsUsed && cbToDump > 0;
		  iWSABuf++ )
	{
		UINT cbToCopy = min(m_pWSABufs[iWSABuf].len - ibFrom, cbToDump);

		memcpy( lpbBuf,
				m_pWSABufs[iWSABuf].buf + ibFrom,
				cbToCopy );

		cbToDump -= cbToCopy;
		lpbBuf   += cbToCopy;

		ibFrom = 0;
	}
}



//	========================================================================
//
//	CLASS CResponse
//
//		The response consists of a header and a body.
//
class CResponse : public IResponse
{
	//	Our reference to the ECB.  This must a refcounted reference because
	//	the lifetime of the response object is indefinite.
	//
	auto_ref_ptr<IEcb> m_pecb;

	//
	//	Response status (not to be confused with HTTP status below)
	//
	enum RESPONSE_STATUS
	{
		RS_UNSENT = 0,
		RS_DEFERRED,
		RS_FORWARDED,
		RS_REDIRECTED,
		RS_SENDING
	};

	RESPONSE_STATUS	m_rs;

	//
	//	The variable that will hold one of 2 values:
	//		0 - we never started the responce through
	//			the transmitter, it was never created
	//		1 - we already attempted to initiate the
	//			responce, so no new initiations should
	//			be allowed
	//
	LONG			m_lRespStarted;

	//
	//	HTTP status code (e.g. 501)
	//
	int				m_iStatusCode;

	//
	//	IIS-defined suberror used in custom error processing
	//	to generate the most specific response body possible
	//	for a given status code.
	//
	UINT			m_uiSubError;

	//
	//	Full status line (e.g. "HTTP/1.1 404 Resource Not Found")
	//	generated whenever the status code is set.
	//
	auto_heap_ptr<CHAR>	m_lpszStatusLine;

	//
	//	Body detail for error response body.
	//
	auto_heap_ptr<CHAR> m_lpszBodyDetail;

	//
	//	Response header cache
	//
	CHeaderCacheForResponse	m_hcHeaders;

	//	Response body
	//
	auto_ptr<IBody>	 m_pBody;
	BOOL			 m_fSupressBody;

	//
	//	The response transmitter.  Make this class a friend for
	//	easy access to private data (ecb, headers, body parts, etc.)
	//
	friend class CTransmitter;
	CTransmitter *	m_pTransmitter;

	//
	//	Private helpers
	//
	VOID FinalizeContent( BOOL fResponseComplete );
	VOID SetStatusLine(	int iStatusCode );

	//
	//	NOT IMPLEMENTED
	//
	CResponse( const CResponse& );
	CResponse& operator=( const CResponse& );

public:
	//	CREATORS
	//
	CResponse( IEcb& ecb );

	//	ACCESSORS
	//
	IEcb * GetEcb() const;
	BOOL FIsEmpty() const;
	BOOL FIsUnsent() const;

	DWORD DwStatusCode() const;
	DWORD DwSubError() const;
	LPCSTR LpszStatusDescription() const;
	LPCSTR LpszStatusCode() const;

	LPCSTR LpszGetHeader( LPCSTR pszName ) const;

	//	MANIPULATORS
	//
	VOID SetStatus( int    iStatusCode,
					LPCSTR lpszReserved,
					UINT   uiCustomSubError,
					LPCSTR lpszBodyDetail,
					UINT   uiBodyDetail );

	VOID ClearHeaders() { m_hcHeaders.ClearHeaders(); }
	VOID SetHeader( LPCSTR pszName, LPCSTR pszValue, BOOL fMultiple = FALSE );
	VOID SetHeader( LPCSTR pszName, LPCWSTR pwszValue, BOOL fMultiple = FALSE );

	VOID ClearBody() { m_pBody->Clear(); }
	VOID SupressBody() { m_fSupressBody = TRUE; }
	VOID AddBodyText( UINT cbText, LPCSTR pszText );
	VOID AddBodyText( UINT cchText, LPCWSTR pwszText );
	VOID AddBodyFile( const auto_ref_handle& hf,
					  UINT64 ibFile64,
					  UINT64 cbFile64 );
	VOID AddBodyStream( IStream& stm );
	VOID AddBodyStream( IStream& stm, UINT ibOffset, UINT cbSize );
	VOID AddBodyPart( IBodyPart * pBodyPart );

	//
	//	Various sending mechanisms
	//
	SCODE ScForward( LPCWSTR pwszURI,
					 BOOL   fKeepQueryString = TRUE,
					 BOOL   fCustomErrorUrl = FALSE);
	SCODE ScRedirect( LPCSTR pszURI );
	VOID Defer() { m_rs = RS_DEFERRED; }

	VOID SendPartial();
	VOID SendComplete();
	VOID SendStart( BOOL fComplete );
	VOID FinishMethod();

};

//	========================================================================
//
//	CLASS CTransmitter
//
class CTransmitter :
	public CMTRefCounted,
	private IBodyPartVisitor,
	private IAsyncCopyToObserver,
	private IAcceptObserver,
	private IAsyncStream,
	private IIISAsyncIOCompleteObserver
{
	//
	//	Back-reference to our response object.  This is an
	//	auto_ref because, once created, the transmitter owns
	//	the response.
	//
	auto_ref_ptr<CResponse> m_pResponse;

	//
	//	Transfer coding method
	//
	TRANSFER_CODINGS m_tc;

	//
	//	Error information
	//
	HRESULT	m_hr;

	//
	//	Iterator used to traverse the body
	//
	IBody::iterator * m_pitBody;

	//
	//	Async driving mechanism
	//
	CAsyncDriver<CTransmitter> m_driver;
	friend class CAsyncDriver<CTransmitter>;

	//
	//	Buffers for headers and text body parts
	//
	StringBuffer<CHAR>			m_bufHeaders;
	ChainedStringBuffer<CHAR>	m_bufBody;

	//
	//	Accept observer passed to VisitStream().  This observer must
	//	be stashed in a member variable because reading from the stream
	//	is asynchronous and we need to be able to notify the observer
	//	when the read completes.
	//
	IAcceptObserver * m_pobsAccept;

	//
	//	WSA buffers for text data
	//
	CWSABufs	m_wsabufsPrefix;
	CWSABufs	m_wsabufsSuffix;
	CWSABufs *	m_pwsabufs;

	//
	//	TransmitFile info for file data
	//
	auto_ref_handle m_hf;
	HSE_TF_INFO	m_tfi;

	//
	//	Fixed-size buffers to hold prefix and suffix text packets
	//	being transmitted until async I/O completes.
	//
	BYTE	m_rgbPrefix[CB_PACKET_MAX];
	BYTE	m_rgbSuffix[CB_PACKET_MAX];

	//
	//	Amount of header data left to accept
	//
	UINT	m_cbHeadersToAccept;

	//
	//	Amount of header data left to send.
	//
	UINT	m_cbHeadersToSend;

	//	------------------------------------------------------------------------
	//
	//	FSendingIISHeaders()
	//
	//	Returns TRUE if we want to have IIS format and send a status
	//	line along with any custom headers of its own.
	//
	BOOL FSendingIISHeaders() const
	{
		//
		//	If we have headers to send and we haven't sent any
		//	of them yet then we want to include custom IIS
		//	headers as well.
		//
		return m_cbHeadersToSend &&
			   (m_cbHeadersToSend == m_bufHeaders.CbSize());
	}

	//
	//	Flag which is TRUE when the impl has submitted the last
	//	part of the response for transmitting.  It can be FALSE
	//	only with chunked responses.
	//
	BOOL	m_fImplDone;

	//
	//	Transmitter status.  The transmitter status is always one
	//	of the following:
	//
	enum
	{
		//
		//	STATUS_IDLE
		//		The transmitter is idle.  That is, it is not executing
		//		any of the state functions below.
		//
		STATUS_IDLE,

		//
		//	STATUS_RUNNING_ACCEPT_PENDING
		//		The transmitter is running.  The impl has added new
		//		response data (via ImplStart()) to be accepted while
		//		the transmitter is working on existing data on another
		//		thread.
		//
		STATUS_RUNNING_ACCEPT_PENDING,

		//
		//	STATUS_RUNNING_ACCEPTING
		//		The transmitter is running and accepting existing
		//		response data.
		//
		STATUS_RUNNING_ACCEPTING,

		//
		//	STATUS_RUNNING_ACCEPT_DONE
		//		The transmitter is running and has finished accepting
		//		all existing response data.  If the transmitter is
		//		working on a chunked response then it will go idle
		//		from here until the impl indicates that it has added
		//		more data via ImplStart().
		//
		STATUS_RUNNING_ACCEPT_DONE
	};

	LONG	m_lStatus;

	//
	//	Function which returns TRUE if the entire response has
	//	been accepted, FALSE otherwise.
	//
	BOOL FAcceptedCompleteResponse() const
	{
		//
		//	We have accepted the last chunk of the response when
		//	the impl is done adding chunks to the response and we've
		//	accepted the last chunk added.
		//
		//	!!! IMPORTANT !!!
		//	The order of comparison here (m_lStatus then m_fImplDone)
		//	is important.  Checking the other way around could result
		//	in a false positive if another thread were in ImplStart()
		//	right after setting m_fImplDone to TRUE.
		//
		return (STATUS_RUNNING_ACCEPT_DONE == m_lStatus) && m_fImplDone;
	}

	//
	//	IAcceptObserver
	//
	VOID AcceptComplete( UINT64 );

	//
	//	Transmitter state functions.  When running, the transmitter is
	//	always executing one of the following state functions:
	//
	//	SAccept
	//		The accepting state.  When in this state the transmitter
	//		accepts resposne data in preparation for transmitting it.
	//		The impl can add data to the response body while the transmitter
	//		is accepting it -- the mechanism is thread-safe.  In fact the
	//		best performance is realized when the transmitter accepts and
	//		transmits data at the same rate that the impl adds it.
	//		When the transmitter accepts a sufficient amount data
	//		(determined by the amount and type of data accepted)
	//		it enters the transmitting state.
	//
	//	STransmit
	//		The transmitting state.  The transmitter is transmitting
	//		accepted response data via the selected method (m_pfnTransmitMethod).
	//		The impl can add data to the response body while the transmitter
	//		is in this state.  When transmission completes (the transmit methods
	//		are asynchronous) the transmitter enters the cleanup state.
	//
	//	SCleanup
	//		The cleanup state.  Cleans up transmitted data.  From here the
	//		transmitter enters the accepting state if there is more data to
	//		transmit or the idle state if there isn't and the impl hasn't
	//		finished adding data yet.
	//
	typedef VOID (CTransmitter::*PFNSTATE)();
	VOID SAccept();
	VOID STransmit();
	VOID SCleanup();
	PFNSTATE m_pfnState;

	//
	//	Transmit methods.  When the transmitter enters the transmit state,
	//	it will transmit accepted data via the selected transmit method.
	//
	typedef VOID (CTransmitter::*PFNTRANSMIT)();
	VOID TransmitNothing();
	VOID AsyncTransmitFile();
	VOID AsyncTransmitText();
	VOID SyncTransmitHeaders();
	PFNTRANSMIT m_pfnTransmitMethod;

	//
	//	CAsyncDriver
	//
	VOID Run();
	VOID Start()
	{
		TransmitTrace( "DAV: CTransmitter: TID %3d: 0x%08lX Start()\n", GetCurrentThreadId(), this );
		m_driver.Start(*this);
	}

	//
	//	IAsyncStream
	//
	VOID AsyncWrite( const BYTE * pbBuf,
					 UINT         cbToWrite,
					 IAsyncWriteObserver& obsAsyncWrite );

	//
	//	IAsyncCopyToObserver
	//
	VOID CopyToComplete( UINT cbCopied, HRESULT hr );

	//
	//	IIISAsyncIOCompleteObserver
	//
	VOID IISIOComplete( DWORD dwcbSent,
						DWORD dwLastError );

	//	NOT IMPLEMENTED
	//
	CTransmitter( const CTransmitter& );
	CTransmitter& operator=( const CTransmitter& );

public:
	//	CREATORS
	//
	CTransmitter( CResponse& response );
	~CTransmitter() { TransmitTrace( "DAV: CTransmitter: TID %3d: 0x%08lX Transmitter destroyed\n", GetCurrentThreadId(), this ); }

	//
	//	IBodyPartVisitor
	//
	VOID VisitBytes( const BYTE * pbData,
					 UINT         cbToSend,
					 IAcceptObserver& obsAccept );

	VOID VisitFile( const auto_ref_handle& hf,
					UINT64   ibOffset64,
					UINT64   cbToSend64,
					IAcceptObserver& obsAccept );

	VOID VisitStream( IAsyncStream& stm,
					  UINT cbToSend,
					  IAcceptObserver& obsAccept );

	VOID VisitComplete();

	VOID ImplStart( BOOL fResponseComplete );
};



//	========================================================================
//
//	CLASS IResponse
//

//	------------------------------------------------------------------------
//
//	IResponse::~IResponse()
//
IResponse::~IResponse()
{
}



//	========================================================================
//
//	CLASS CResponse
//

//	------------------------------------------------------------------------
//
//	CResponse::CResponse()
//
CResponse::CResponse( IEcb& ecb ) :
   m_pecb(&ecb),
   m_pBody(NewBody()),
   m_pTransmitter(NULL),
   m_rs(RS_UNSENT),
   m_iStatusCode(0),
   m_uiSubError(CSE_NONE),
   m_fSupressBody(FALSE),
   m_lRespStarted(0)
{
}

//	------------------------------------------------------------------------
//
//	CResponse::GetEcb()
//
//		Returns the pointer to the ECB. We are holding a ref on it
//	so make sure that returned pointer is used no longer than this
//	response object.
//
IEcb *
CResponse::GetEcb() const
{
	//
	//	Return the raw pointer
	//
	return m_pecb.get();
}

//	------------------------------------------------------------------------
//
//	CResponse::FIsEmpty()
//
//		Returns TRUE if the response is empty, FALSE otherwise.
//
BOOL
CResponse::FIsEmpty() const
{
	//
	//	The response is empty IFF no status code has been set
	//
	return m_iStatusCode == 0;
}


//	------------------------------------------------------------------------
//
//	CResponse::FIsUnsent()
//
//		Returns TRUE if the response is unsent (not deferred,
//		forwarded or redirected), FALSE otherwise.
//
BOOL
CResponse::FIsUnsent() const
{
	return m_rs == RS_UNSENT;
}


//	------------------------------------------------------------------------
//
//	CResponse::DwStatusCode()
//
DWORD
CResponse::DwStatusCode() const
{
	return m_iStatusCode;
}

//	------------------------------------------------------------------------
//
//	CResponse::DwSubError()
//
DWORD
CResponse::DwSubError() const
{
	return m_uiSubError;
}

//	------------------------------------------------------------------------
//
//	CResponse::LpszStatusDescription()
//
LPCSTR
CResponse::LpszStatusDescription() const
{
	//
	//	Getting just the status description is a little tricky since
	//	we only keep around the full status line (to avoid having to
	//	compute it more than once).  Given that the format of the
	//	status line is ALWAYS "HTTP-version Status-Code Description"
	//	we know that the status line always appears immediately after
	//	the HTTP version and status code.
	//
	return m_lpszStatusLine +
			strlen( m_pecb->LpszVersion() ) +	//	description
			1 +							//  " "
			3 +							//  3-digit status code (e.g. "404")
			1;							//  " "

	//
	//	Ok, so it's not that tricky...
	//
}

//	------------------------------------------------------------------------
//
//	CResponse::LpszStatusCode()
//
LPCSTR
CResponse::LpszStatusCode() const
{
	Assert( m_lpszStatusLine != NULL );

	return m_lpszStatusLine +
		   strlen(m_pecb->LpszVersion()) +
		   1; // (e.g. "HTTP/1.1 200 OK" -> "200 OK")
}

//	------------------------------------------------------------------------
//
//	CResponse::LpszGetHeader()
//
LPCSTR
CResponse::LpszGetHeader( LPCSTR pszName ) const
{
	return m_hcHeaders.LpszGetHeader( pszName );
}

//	------------------------------------------------------------------------
//
//	CResponse::SetStatus()
//
//		Sets the status line portion of the response, superceding any
//		previously set status line.
//
//	Parameters:
//		iStatusCode [in]
//			A standard HTTP/DAV response status code (e.g. 404)
//
//		lpszReserved [in]
//			Reserved.  Must be NULL.
//
//		uiCustomSubError [in]
//			Custom error Sub Error (CSE).  If the status code is in the
//			error range ([400,599]) and this value is anything except
//			CSE_NONE then this value specifies the suberror used to
//			generate a more specific custom error response body than
//			the default for a given status code.
//
//		lpszBodyDetail [in]
//			Optional string to use as detail in an error response body.
//			If NULL, use uiBodyDetail instead.  If that is also 0,
//			an error response body just consists of an HTML
//			version of the status line.
//
//		uiBodyDetail [in]
//			Optional resource id to use as detail in an error response body.
//			If 0, an error response body just consists of an HTML
//			version of the status line.
//
VOID
CResponse::SetStatus( int	 iStatusCode,
					  LPCSTR lpszReserved,
					  UINT   uiCustomSubError,
					  LPCSTR lpszBodyDetail,
					  UINT   uiBodyDetail )
{
	CHAR rgchStatusDescription[256];

	//	We must not change the response status once the response has
	//	started sending. Sometimes it's hard for client to keep track
	//	response has started sending. Now that the response object
	//	has the information, we can simply ignore the set status request
	//	when the response has started sending
	//
	//	was Assert( RS_SENDING != m_rs );
	//
	if (RS_SENDING == m_rs)
		return;

	//	If we are setting the same status code again,
	//	do nothing!
	//
	if ( m_iStatusCode == iStatusCode )
		return;

	//	Quick check -- the iStatusCode must be in the valid HSC range:
	//	100 - 599.
	//	Assert this here to catch any callers who forget to map their
	//	SCODEs/HRESULTs to HSCs first (HscFromHresult).
	//
	Assert (100 <= iStatusCode &&
			599 >= iStatusCode);

	//	When a 304 response is to be generated, the request becomes
	//	very much like a HEAD request in that the whole response is
	//	processed, but not transmitted.  The important part here is
	//	that you do not want to overwrite the 304 response with any
	//	other code other than error responses.
	//
	if ( m_iStatusCode == 304 ) // HSC_NOT_MODIFIED
	{
		//	304's should really be restricted to GET/HEAD
		//
		AssertSz ((!strcmp (m_pecb->LpszMethod(), "GET") ||
				   !strcmp (m_pecb->LpszMethod(), "HEAD") ||
				   !strcmp (m_pecb->LpszMethod(), "PROPFIND")),
				  "304 returned on non-GET/HEAD request");

		if ( iStatusCode < 300 )
			return;

		DebugTrace ("non-success response over-rides 304 response\n");
	}

	//
	//	Remember the status code for our own use ...
	//
	m_iStatusCode = iStatusCode;

	//
	//	... and stash it away in the ECB as well.
	//	IIS uses it for logging.
	//
	m_pecb->SetStatusCode( iStatusCode );

	//
	//	Remember the suberror for custom error processing
	//
	m_uiSubError = uiCustomSubError;

	//
	//	IF we are setting a NEW status code (we are),
	//	AND it's an error status code,
	//	clear out the body.
	//
	if ( FErrorStatusCode(m_iStatusCode) )
	{
		m_pBody->Clear();
	}

	SetStatusLine( iStatusCode );

	//
	//	Save the error body detail (if any).  We'll use it in
	//	CResponse::FinalizeContent() later to build the error response
	//	body if the final result is an error.
	//
	m_lpszBodyDetail.clear();

	//
	//	Figure out what to use for the body detail string:
	//
	//		Use the string if one is provided.  If no string
	//		is provided, use the resource ID.  If no resource ID,
	//		then don't bother setting any body detail!
	//
	if ( !lpszBodyDetail && uiBodyDetail )
	{
		//
		//	Load up the body detail string
		//
		LpszLoadString( uiBodyDetail,
						m_pecb->LcidAccepted(),
						rgchStatusDescription,
						sizeof(rgchStatusDescription) );

		lpszBodyDetail = rgchStatusDescription;
	}

	//	Save off the body detail string.
	//
	if ( lpszBodyDetail )
	{
		m_lpszBodyDetail = LpszAutoDupSz( lpszBodyDetail );
	}
}

//	------------------------------------------------------------------------
//
//	CResponse::SetHeader()
//
//		Sets the specified header to the specified value
//
//		If lpszValue is NULL, deletes the header
//
VOID
CResponse::SetHeader( LPCSTR pszName, LPCSTR pszValue, BOOL fMultiple )
{
	//	We must not modify any headers once the response has started sending.
	//	It is up to the impl to enforce this -- we just assert it here.
	//
	Assert( RS_SENDING != m_rs );

	if ( pszValue == NULL )
		m_hcHeaders.DeleteHeader( pszName );
	else
		m_hcHeaders.SetHeader( pszName, pszValue, fMultiple );
}

VOID
CResponse::SetHeader( LPCSTR pszName, LPCWSTR pwszValue, BOOL fMultiple )
{
	//	We must not modify any headers once the response has started sending.
	//	It is up to the impl to enforce this -- we just assert it here.
	//
	Assert( RS_SENDING != m_rs );

	if ( pwszValue == NULL )
		m_hcHeaders.DeleteHeader( pszName );
	else
	{
		UINT cchValue = static_cast<UINT>(wcslen(pwszValue));
		UINT cbValue = cchValue * 3;
		CStackBuffer<CHAR> pszValue(cbValue + 1);

		//	We have received wide string for the value. We need to convert it
		//	to skinny.
		//
		cbValue = WideCharToMultiByte(CP_ACP,
									  0,
									  pwszValue,
									  cchValue + 1,
									  pszValue.get(),
									  cbValue + 1,
									  NULL,
									  NULL);
		if (0 == cbValue)
		{
			DebugTrace ( "CResponse::SetHeader(). Error 0x%08lX from WideCharToMultiByte()\n", GetLastError() );
			throw CLastErrorException();
		}

		m_hcHeaders.SetHeader( pszName, pszValue.get(), fMultiple );
	}
}

//	------------------------------------------------------------------------
//
//	CResponse::AddBodyText()
//
//		Appends a string to the response body
//
VOID
CResponse::AddBodyText( UINT cbText, LPCSTR pszText )
{
	m_pBody->AddText( pszText, cbText );
}


VOID
CResponse::AddBodyText( UINT cchText, LPCWSTR pwszText )
{

	UINT cbText = cchText * 3;
	CStackBuffer<CHAR> pszText(cbText);
	LPCSTR pszTextToAdd;

	//	We have received wide string for the value. We need to convert it
	//	to skinny.
	//
	if (cbText)
	{
		cbText = WideCharToMultiByte(CP_ACP,
									 0,
									 pwszText,
									 cchText,
									 pszText.get(),
									 cbText,
									 NULL,
									 NULL);
		if (0 == cbText)
		{
			DebugTrace ( "CResponse::SetHeader(). Error 0x%08lX from WideCharToMultiByte()\n", GetLastError() );
			throw CLastErrorException();
		}

		pszTextToAdd = pszText.get();
	}
	else
	{
		//	Make sure that we do not pass NULL forward,
		//	but instead we use empty string, as the callee
		//	may not handle NULL.
		//
		pszTextToAdd = gc_szEmpty;
	}

	m_pBody->AddText( pszTextToAdd, cbText );
}
//	------------------------------------------------------------------------
//
//	CResponse::AddBodyFile()
//
//		Appends a file to the current response state
//
VOID
CResponse::AddBodyFile( const auto_ref_handle& hf,
						UINT64 ibFile64,
						UINT64 cbFile64 )
{
	m_pBody->AddFile( hf, ibFile64, cbFile64 );
}

//	------------------------------------------------------------------------
//
//	CResponse::AddBodyStream()
//
//		Appends a stream to the current response state
//
VOID
CResponse::AddBodyStream( IStream& stm )
{
	m_pBody->AddStream( stm );
}

//	------------------------------------------------------------------------
//
//	CResponse::AddBodyStream()
//
//		Appends a stream to the current response state
//
VOID
CResponse::AddBodyStream( IStream& stm, UINT ibOffset, UINT cbSize )
{
	m_pBody->AddStream( stm, ibOffset, cbSize );
}


//	------------------------------------------------------------------------
//
//	CResponse::AddBodyPart()
//
//		Appends a body part to the current response state
//
VOID CResponse::AddBodyPart( IBodyPart * pBodyPart )
{
	m_pBody->AddBodyPart( pBodyPart );
}

//	------------------------------------------------------------------------
//
//	CResponse::ScForward()
//
//		Instructs IIS to forward responsibility for handling the
//		current request to another ISAPI.
//
//	Returns:
//		S_OK - if forwarding succeeded, error otherwise		
//
SCODE
CResponse::ScForward( LPCWSTR pwszURI, BOOL fKeepQueryString, BOOL fCustomErrorUrl)
{
	CStackBuffer<CHAR, MAX_PATH> pszQS;
	LPCSTR	pszQueryString;
	SCODE sc = S_OK;

	//
	//	Verify that the response is still unsent.  A response can be
	//	either sent, forwarded, or redirected, but only one of the three
	//	and only once
	//
	AssertSz( m_rs == RS_UNSENT || m_rs == RS_DEFERRED,
			  "Response already sent, forwarded or redirected!" );

	Assert(pwszURI);

	//	Get the query string
	//
	pszQueryString = m_pecb->LpszQueryString();

	//	If there was custom error processing, construct query string for it ...
	//
	if (fCustomErrorUrl)
	{
		//	The query string for custom error to be forwarded is to be of the
		//	format ?nnn;originaluri, where nnn is the error code. Find out the
		//	length of the URL. Reallocate required space accounting for ?nnn;
		//	and '\0' termination.
		//
		UINT cb = 1 + 3 + 1 + static_cast<UINT>(strlen(m_pecb->LpszRequestUrl())) + 1;
		LPSTR psz = pszQS.resize(cb);
		if (NULL == psz)
		{
			DebugTrace( "CResponse::ScForward() - Error while allocating memory 0x%08lX\n", E_OUTOFMEMORY );
			sc = E_OUTOFMEMORY;
			goto ret;
		}

		_snprintf (psz, cb, "?%03d;%s",
				 max(min(m_iStatusCode, 999), 100),
				 m_pecb->LpszRequestUrl());
		Assert (0 == psz[cb - 1]);
				 
 		//	Just point the query string to the start.
		//	Note that if we are handling a custom error url we discard
		//	original query string
		//
		pszQueryString = pszQS.get();
	}
	//
	//	... otherwise if we have query string processing, construct the
	//	query string too...
	//
	else if (fKeepQueryString && pszQueryString && *pszQueryString)
	{
		//	The composed query string has to be of the format ?querystring
		//	and '\0' termination.
		//
		UINT cb = 1 + static_cast<UINT>(strlen(pszQueryString)) + 1;
		LPSTR psz = pszQS.resize(cb);
		if (NULL == psz)
		{
			DebugTrace( "CResponse::ScForward() - Error while allocating memory 0x%08lX\n", E_OUTOFMEMORY );
			sc = E_OUTOFMEMORY;
			goto ret;
		}

		_snprintf (psz, cb, "?%s", m_pecb->LpszRequestUrl());
		Assert (0 == psz[cb - 1]);
		
		//	Just point the query string to the start
		//
		pszQueryString = pszQS.get();
	}
	//
	//	... otherwise we do not need the query string
	//
	else
	{
		pszQueryString = NULL;
	}

	//	If the forward request URI is fully qualified, strip it to
	//	an absolute URI
	//
	if ( FAILED( ScStripAndCheckHttpPrefix( *m_pecb, &pwszURI )))
	{
		DebugTrace( "CResponse::ScForward() - ScStripAndCheckHttpPrefix() failed, "
					"forward request not local to this server.\n" );

		//	Why do we override error maping to 502 Bad Gateway with
		//	the error maping to 404 Not Found?
		//
		sc = HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND );
		goto ret;
	}

	//	Forward the request to the child ISAPI
	//
	sc = m_pecb->ScExecuteChild( pwszURI, pszQueryString, fCustomErrorUrl );
	if (FAILED(sc))
	{
		DebugTrace( "CResponse::ScForward() - IEcb::ScExecuteChild() "
					"failed to execute child ISAPI for %S (0x%08lX)\n",
					pwszURI,
					sc );
		goto ret;
	}

	m_rs = RS_FORWARDED;

ret:

	return sc;
}

//	------------------------------------------------------------------------
//
//	CResponse::ScRedirect()
//
//		Instructs IIS to send a redirect (300) response to the client.
//
//	Returns:
//		S_OK - if forwarding succeeded, error otherwise
//
SCODE
CResponse::ScRedirect( LPCSTR pszURI )
{
	SCODE sc = S_OK;

	//
	//	Verify that the response is still unsent.  A response can be
	//	either sent, forwarded, or redirected, but only one of the three
	//	and only once
	//
	AssertSz( m_rs == RS_UNSENT || m_rs == RS_DEFERRED,
			  "Response already sent, forwarded or redirected!" );

	//
	//	Tell IIS to send a redirect response
	//
	sc = m_pecb->ScSendRedirect( pszURI );
	if (FAILED(sc))
	{
		DebugTrace( "CResponse::FRedirect() - ServerSupportFunction() failed to redirect to %hs (0x%08lX)\n", pszURI, sc );
		goto ret;
	}

	m_rs = RS_REDIRECTED;

ret:

	return sc;
}

//	------------------------------------------------------------------------
//
//	CResponse::FinalizeContent()
//
//		Prepare the response for sending by filling in computed values for
//		headers (Content-Length, Connection, etc) and body (for error
//		responses).  After this function is called, the response should be
//		ready for transmission.
//
VOID
CResponse::FinalizeContent( BOOL fResponseComplete )
{
	BOOL	fDoingCustomError = m_pecb->FProcessingCEUrl();

	//	Special case:
	//	If we have a FAILING error code, DO NOT send back an ETag header.
	//
	//	This is somewhat of a hack because we should never have set an
	//	ETag on an error response in the first place.  However, several
	//	places in the code blindly stuff the ETag into the response headers
	//	before determining the final status code.  So rather than
	//	fix the code in each place (which is a pain) we filter out
	//	the ETag here.
	//
	//	300-level responses are considered to be errors by FSuccessHSC(),
	//	but the HTTP/1.1 spec says that an ETag must be emitted for
	//	a "304 Not Modified" response, so we treat that status code
	//	as a special case.
	//
	if (!FSuccessHSC(m_iStatusCode) && m_iStatusCode != 304)
		m_hcHeaders.DeleteHeader( gc_szETag );

	//	Handle error responses.  This may mean setting default or custom
	//	error body text, or executing an error-handling URL.  In the latter
	//	case, we want to get out immediately after fowarding.
	//
	if ( FErrorStatusCode(m_iStatusCode) )
	{
		if ( m_pBody->FIsEmpty() && !fDoingCustomError && !m_pecb->FBrief())
		{
			if (m_pecb->FIIS60OrAfter())
			{
				//	For IIS 6.0 or after, we use the new way to send custom error
				//
				HSE_CUSTOM_ERROR_INFO  custErr;
				UINT cbStatusLine;

				//	Perf Wadeh, we should hold on to the string till the IO completion
				//	routine returns
				//
				auto_heap_ptr<CHAR>	pszStatus;

				//	Make sure that status line starts with one of HTTP versions.
				//	
				Assert(!_strnicmp(m_lpszStatusLine.get(), gc_szHTTP, gc_cchHTTP));
				Assert(' ' == m_lpszStatusLine[gc_cchHTTP_X_X]);

				//	Allocate the space for status string that we pass onto the CEcb.
				//	We will treat the space occupied by ' ' as accounting for space
				//	we will need for '\0' in the mathematics below.
				//
				cbStatusLine = static_cast<UINT>(strlen(m_lpszStatusLine.get()));
				cbStatusLine -= gc_cchHTTP_X_X;

				pszStatus = static_cast<LPSTR>(g_heap.Alloc(cbStatusLine));
				if (NULL != pszStatus.get())
				{
					//	m_lpszStatusLine has format "HP/x.x nnn yyyy...", where
					//	nnn is the status code. IIS expects up to pass in format
					//	"nnn yyyy....", so we need to skip the version part.
					//	Note, all the version part are of same length, this makes
					//	the adjustment easier. We copy including '\0' termination.
					//
					memcpy(pszStatus.get(), m_lpszStatusLine.get() + gc_cchHTTP_X_X + 1, cbStatusLine);

					//	Populate custom error info
					//
					custErr.pszStatus = pszStatus.get();
					custErr.uHttpSubError = static_cast<USHORT>(m_uiSubError);
					custErr.fAsync = TRUE;

					//	Try to send the custom error. The ownership of the string
					//	will be taken by CEcb only in the case of success.
					//
					if (SUCCEEDED(m_pecb->ScAsyncCustomError60After( custErr,
																	 pszStatus.get() )))
					{
						//	Relinquish the ref, as if we succeeeded in the function
						//	above it has been taken ownership by CEcb.
						//
						pszStatus.relinquish();

						m_rs = RS_FORWARDED;
						return;
					}
				}

				//	Otherwise, fall through to send error
			}
			else
			{
				//	Try a custom error.  If a custom error exists, use it.
				//	Note that a custom error can refer to a URL in which
				//	case the request is forwarded to that URL to generate
				//	appropriate error content.  If there is no custom error,
				//	then use the body detail (if any) formatted as a short
				//	HTML document. Before we start we check if the ECB is
				//	already for a custom error request. This is to prevent
				//	us from recursively calling ourselves on some custom error
				//	url that does not exist.
				//
				if ( FSetCustomErrorResponse( *m_pecb, *this ) )
				{
					//
					//	If the custom error caused the response to be forwarded
					//	(i.e. the custom error was a URL) then we are done.
					//
					if ( m_rs == RS_FORWARDED)
						return;

					//
					//	Raid NT5:187545 & X5:70652
					//
					//	This is somewhat of a hack:  IIS won't send a
					//	Connection: close header for us if the following
					//	conditions are true:
					//
					//	1. The original request was keep-alive.
					//	2. We are sending an error response.
					//	3. We have a file response body.
					//	4. We intend to send the body.
					//
					//	Because we are in this code path, we know we are sending
					//	an error (condition 2).  If custom error processing added
					//	a body, we know that it must be a file body because the
					//	only custom error types are URL or file, and the URL case
					//	is handled above by fowarding the response.  So, if we have
					//	a body, then condition 3 is satisfied.  To check for
					//	condition 1, test the state of the connection before we
					//	close it (below).  Condition 4 is satisfied if and only
					//	if do not supress the body.  The body is supressed, for
					//	example, in a HEAD response.
					//
					//	If all of the conditions are satisfied, then add our own
					//	Connection: close header.
					//
					if ( m_pecb->FKeepAlive() &&
						 !m_pBody->FIsEmpty() &&
						 !m_fSupressBody )
					{
						SetHeader( gc_szConnection, gc_szClose );
					}
				}
			}
		}

		//	Check if the body is still empty and send some
		//	stuff.
		//
		if ( m_pBody->FIsEmpty() )
		{
			m_hcHeaders.SetHeader( gc_szContent_Type, gc_szText_HTML );

			m_pBody->AddText( "<body><h2>" );
			m_pBody->AddText( m_lpszStatusLine );
			m_pBody->AddText( "</h2>" );

			if ( m_lpszBodyDetail != NULL && *m_lpszBodyDetail )
			{
				m_pBody->AddText( "<br><h3>" );
				m_pBody->AddText( m_lpszBodyDetail );
				m_pBody->AddText( "</h3>" );
			}
			m_pBody->AddText( "</body>" );
		}

		//	error response: Always close the connection.
		//
		m_pecb->CloseConnection();
	}

	//	Set the status code from the original request
	//	if we are procesing the custom URL. We expect that
	//	the query string is of the format XXX;original url.
	//
	if ( fDoingCustomError )
	{
		LPCSTR	lpszQueryString = m_pecb->LpszQueryString();
		int		iOrgStatCode = 0;

		//	Normally we expect the query string to be present.
		//	However there is a possibility that ISAPIs can initiate
		//	this request and some ISAPI may misbehave.
		//	So we check if the query string is really there and
		//	silently fail.
		//
		if (lpszQueryString)
		{
			if ( 1 == sscanf(lpszQueryString, "%3d;", &iOrgStatCode) )
			{
				//	IIS behaved as per the promise.
				//	Set the response code in the ecb and hack our
				//	status line accordingly.
				//
				m_pecb->SetStatusCode( iOrgStatCode );
				SetStatusLine( iOrgStatCode );
			}
		}

		//	error response: Always close the connection.
		//
		m_pecb->CloseConnection();

		DebugTrace("CResponse::FinalizeContent Original Status code in CEURL request %d",
				   iOrgStatCode );
	}

	//
	//	If we can chunk the response and we don't have a complete
	//	response already then include a Transfer-Encoding: chunked
	//	header.
	//
	if ( m_pecb->FCanChunkResponse() && !fResponseComplete )
	{
		m_hcHeaders.SetHeader( gc_szTransfer_Encoding, gc_szChunked );
	}

	//
	//	Otherwise the response body is already complete (i.e. we
	//	can quickly calculate its content length) or the client
	//	won't let us do chunking so set the correct Content-Length header.
	//
	else
	{
		char rgchContentLength[24];

		//	WININET HACK
		//	A 304 *can* send back all the headers of the real resource,
		//	(and we're trying to be a good little HTTP server, so we do!)
		//	BUT if we send back a >0 content-length on a 304, WININET
		//	hangs trying to read the body (which isn't there!).
		//	So hack the content type in this one case.
		//
		if (m_iStatusCode != 304)
		{
			_ui64toa( m_pBody->CbSize64(), rgchContentLength, 10 );
		}
		else
			_ultoa( 0, rgchContentLength, 10 );

		m_hcHeaders.SetHeader( gc_szContent_Length, rgchContentLength );
	}

	//
	//	If the body is to be supressed, then nuke it
	//
	//	We nuke the body in two cases: if the body was suppressed
	//	or if the status code is a 304 not-modified.
	//
	if ( m_fSupressBody  || (m_iStatusCode == 304)) // HSC_NOT_MODIFIED
		m_pBody->Clear();

	//
	//	Nuke the status line and headers (EVEN DBG HEADERS!)
	//	for HTTP/0.9 responses.
	//
	if ( !strcmp( m_pecb->LpszVersion(), gc_szHTTP_0_9 ) )
	{
		//
		//	Clear the status line.
		//
		m_lpszStatusLine.clear();

		//
		//	Clear the headers.
		//
		m_hcHeaders.ClearHeaders();
	}
}


//	------------------------------------------------------------------------
//
//	CResponse::SetStatusLine()
//
//	Sets the status line according to the info given.
//
VOID
CResponse::SetStatusLine(int iStatusCode)
{
	CHAR rgchStatusDescription[256];

	//
	//	Load up the status string
	//
	//	(Conveniently, the status description resource ID
	//	for any given status code is just the status code itself!)
	//
	LpszLoadString( iStatusCode,
					m_pecb->LcidAccepted(),
					rgchStatusDescription,
					sizeof(rgchStatusDescription) );

	//
	//	Generate the status line by concatenating the HTTP
	//	version string, the status code (in decimal) and
	//	the status description.
	//
	{
		CHAR rgchStatusLine[256];
		UINT cchStatusLine;

		_snprintf(rgchStatusLine, 
			       sizeof(rgchStatusLine), 
			       "%s %03d %s",
			       m_pecb->LpszVersion(),
			       iStatusCode,
			       rgchStatusDescription);
		rgchStatusLine[CElems(rgchStatusLine) - 1] = 0;
		
		m_lpszStatusLine.clear();
		m_lpszStatusLine = LpszAutoDupSz( rgchStatusLine );
	}
}

//	------------------------------------------------------------------------
//
//	CResponse::SendStart()
//
//	Starts sending accumulated response data.  If fComplete is TRUE then
//	the accumulated data constitutes the entire response or remainder
//	thereof.
//
VOID
CResponse::SendStart( BOOL fComplete )
{
	switch ( m_rs )
	{
		case RS_UNSENT:
		{
			Assert( fComplete );

			if (0 == InterlockedCompareExchange(&m_lRespStarted,
												1,
												0))
			{
				FinalizeContent( fComplete );

				if ( m_rs == RS_UNSENT )
				{
					Assert( m_pTransmitter == NULL );
					m_pTransmitter = new CTransmitter(*this);
					m_pTransmitter->ImplStart( fComplete );

					//	This is the path where response is complete.
					//	The ref of transmitter will be be taken
					//	ownership inside ImplStart() so noone should
					//	attempt to access it after this point as it
					//	may be released.
					//
					m_pTransmitter = NULL;

					//	Change the state after the transmitter pointer
					//	is changed to NULL, so that any thread that comes
					//	into SendStart() in the RS_SENDING state could be
					//	checked and denied the service. (i.e. by the time
					//	we check state for RS_SENDING we know that pointer
					//	is NULL if it is ment to be nulled in here).
					//
					m_rs = RS_SENDING;
				}
			}

			break;
		}

		case RS_DEFERRED:
		{
			//
			//	If the client does not accept a chunked response then we
			//	cannot start sending until the response is complete because
			//	we need the entire response to be able to compute the
			//	content length
			//
			if ( fComplete || m_pecb->FCanChunkResponse() )
			{
				if (0 == InterlockedCompareExchange(&m_lRespStarted,
													1,
													0))
				{

					FinalizeContent( fComplete );
					if ( m_rs == RS_DEFERRED )
					{
						Assert( m_pTransmitter == NULL );

						m_pTransmitter = new CTransmitter(*this);
						m_pTransmitter->ImplStart( fComplete );

						//	This is the path where response is complete.
						//	The ref of transmitter will be be taken
						//	ownership inside ImplStart() so noone should
						//	attempt to access it after this point as it
						//	may be released.
						//
						if ( fComplete )
						{
							m_pTransmitter = NULL;
						}

						//	Change the state after the transmitter pointer
						//	is changed to NULL, so that any thread that comes
						//	into SendStart() in the RS_SENDING state could be
						//	checked and denied the service. (i.e. by the time
						//	we check state for RS_SENDING we know that pointer
						//	is NULL if it is ment to be nulled in here).
						//
						m_rs = RS_SENDING;

					}
				}
			}

			break;
		}

		//
		//	If we're forwarding to another ISAPI or we already sent back
		//	a redirection response, then don't do anything further.
		//
		case RS_FORWARDED:
		case RS_REDIRECTED:
		{
			break;
		}

		case RS_SENDING:
		{
			Assert( m_rs == RS_SENDING );
			Assert( m_pecb->FCanChunkResponse() );

			//	If someone came here when transmitter is not available
			//	(was not created or complete response was already sent
			//	and the pointer was NULL-ed above, then there is no work
			//	for us.
			//
			if (NULL != m_pTransmitter)
			{
				m_pTransmitter->ImplStart( fComplete );
			}

			break;
		}

		default:
		{
			TrapSz( "Unknown response transmitter state!" );
		}
	}
}

//	------------------------------------------------------------------------
//
//	CResponse::SendPartial()
//
//	Starts sending accumulated response data.  Callers may continue to add
//	response data after calling this function.
//
VOID
CResponse::SendPartial()
{
	SendStart( FALSE );
}

//	------------------------------------------------------------------------
//
//	CResponse::SendComplete)
//
//	Starts sending all of the accumulated response data.  Callers must not
//	add response data after calling this function.
//
VOID
CResponse::SendComplete()
{
	SendStart( TRUE );
}

//	------------------------------------------------------------------------
//
//	CResponse::FinishMethod()
//
VOID
CResponse::FinishMethod()
{
	//
	//	If no one else has taken responsibility for sending the
	//	response, then send the entire thing now.
	//
	if ( m_rs == RS_UNSENT )
		SendStart( TRUE );
}

//	------------------------------------------------------------------------
//
//	CTransmitter::CTransmitter()
//
//	A few things to note about this constructor:
//
//	The keep-alive value is cached to avoid having to get it off of the
//	IEcb for every packet transmitted.  Getting the value from the IEcb
//	can incur a SSF call.  Since the value can't change once we start
//	transmitting, it is safe to cache it.
//
//	The size of the text buffer is initialized to be twice as large as
//	the maximum amount of text data that can be sent in a single network
//	packet.  The reason for this is to eliminate reallocations when adding
//	to the buffer.  The buffer may potentially be used for prefix and
//	suffix text data, each being up to CB_WSABUFS_MAX in size.
//
//	Headers are dumped into the text buffer and a pointer to them is
//	then added to the WSABufs so that the headers count against the
//	total amount of text that can be accepted for the first packet.
//	If additional body text is later added to the WSABufs for that packet,
//	it may be transmitted along with the headers in the same packet.
//
CTransmitter::CTransmitter( CResponse& response ) :
    m_pResponse(&response),
	m_hr(S_OK),
	m_tc(TC_UNKNOWN),
	m_pitBody(response.m_pBody->GetIter()),
	m_bufBody(2 * CB_WSABUFS_MAX),
	m_cbHeadersToSend(0),
	m_cbHeadersToAccept(0),
	m_fImplDone(FALSE),
	m_pwsabufs(&m_wsabufsPrefix),
	m_lStatus(STATUS_IDLE),
	m_pfnTransmitMethod(TransmitNothing)
{
	ZeroMemory( &m_tfi, sizeof(HSE_TF_INFO) );

	//
	//	If we are sending a status line and headers (i.e. we don't
	//	have an HTTP/0.9 response) then set up to send them along
	//	with the custom IIS headers in the first packet.
	//
	if ( response.m_lpszStatusLine )
	{
		response.m_hcHeaders.DumpData( m_bufHeaders );
		m_bufHeaders.Append( 2, gc_szCRLF );	// Append extra CR/LF
		m_cbHeadersToAccept = m_bufHeaders.CbSize();
		m_cbHeadersToSend = m_cbHeadersToAccept;
		m_pfnTransmitMethod = SyncTransmitHeaders;
	}

	//
	//	Add the first transmitter ref on the impl's behalf.
	//	This ref is released when the impl says that it's
	//	done with the response in ImplStart().
	//
	//	Other refs may be added by the transmitter itself
	//	whenever it starts an async operation, so this
	//	ref may not be the last one released.
	//
	AddRef();

	TransmitTrace( "DAV: CTransmitter: TID %3d: 0x%08lX Transmitter created\n",
				   GetCurrentThreadId(),
				   this );
}

//	------------------------------------------------------------------------
//
//	CTransmitter::ImplStart()
//
VOID
CTransmitter::ImplStart( BOOL fResponseComplete )
{
	//	We must not be called with fResponseComplete equal to TRUE
	//	several times. We can finish doing the work only once.
	//	This would prevent us from taking out IIS process if the
	//	callers would make that mistake.
	//
	if (m_fImplDone)
	{
		TrapSz("CTransmitter::ImplStart got called twice! That is illegal! Please grab a DEV to look at it!");
		return;
	}

	//
	//	If we don't know it already, figure out the transfer coding
	//	to use in the response.
	//
	if ( TC_UNKNOWN == m_tc )
	{
		//
		//	If the response is not complete then we should not have
		//	a Content-Length header in the response.
		//
		Assert( fResponseComplete ||
				NULL == m_pResponse->LpszGetHeader( gc_szContent_Length ) );

		//
		//	Use chunked coding in the response only if the client
		//	will accept it and if we don't have a complete response
		//	(i.e. we do not have a Content-Length header).
		//
		m_tc = (!fResponseComplete && m_pResponse->m_pecb->FCanChunkResponse()) ?
					TC_CHUNKED :
					TC_IDENTITY;
	}

	Assert( m_tc != TC_UNKNOWN );

	//
	//	If the impl says it's done with the response then
	//	ensure we release its ref to the transmitter when
	//	we're done here.
	//
	auto_ref_ptr<CTransmitter> pRef;
	if ( fResponseComplete )
		pRef.take_ownership(this);

	//
	//	Note whether this is the last chunk of the response
	//	being added by the impl.
	//
	//	!!!IMPORTANT!!!
	//	Set m_fImplDone before changing the status below because the
	//	transmitter may already be running (if this is a chunked response)
	//	and may run to completion before we get a chance to do anything
	//	after the InterlockedExchange() below.
	//
	m_fImplDone = fResponseComplete;

	//
	//	Tell everyone that there is new data pending and ping the transmitter.
	//
	LONG lStatusPrev =
		InterlockedExchange( &m_lStatus, STATUS_RUNNING_ACCEPT_PENDING );

	//
	//	If the transmitter is idle then start it accepting.
	//
	if ( STATUS_IDLE == lStatusPrev )
	{
		m_pfnState = SAccept;
		Start();
	}
}

//	------------------------------------------------------------------------
//
//	CTransmitter::SAccept()
//
//	Accept data for transmitting.
//
VOID
CTransmitter::SAccept()
{
	TransmitTrace( "DAV: CTransmitter: TID %3d: 0x%08lX SAccept()\n", GetCurrentThreadId(), this );

	//
	//	At this point we are either about to accept newly pended response
	//	data or we are continuing to accept existing data.  Either way
	//	we are going to be accepting, so change the status to reflect that.
	//
	Assert( STATUS_RUNNING_ACCEPT_PENDING == m_lStatus ||
			STATUS_RUNNING_ACCEPTING == m_lStatus );

	m_lStatus = STATUS_RUNNING_ACCEPTING;

	//
	//	If we have headers left to accept then
	//	accept as much of them as possible.
	//
	if ( m_cbHeadersToAccept > 0 )
	{
		UINT cbAccepted = m_wsabufsPrefix.CbAddItem(
			reinterpret_cast<const BYTE *>(m_bufHeaders.PContents()) +
				(m_bufHeaders.CbSize() - m_cbHeadersToAccept),
			m_cbHeadersToAccept );

		m_cbHeadersToAccept -= cbAccepted;

		//
		//	If we could not accept all of the headers then send
		//	whatever we did accept now and we will accept more
		//	the next time around.
		//
		if ( m_cbHeadersToAccept > 0 )
		{
			//
			//	Presumably we did not accept all of the headers
			//	because we filled up the prefix WSABUF.
			//
			Assert( m_wsabufsPrefix.CbSize() == CB_WSABUFS_MAX );

			//
			//	Send the headers
			//
			m_pfnState = STransmit;
			Start();
			return;
		}
	}

	//
	//	Accept a body part.  CTransmitter::AcceptComplete() will be called
	//	repeatedly for body parts as they are accepted.
	//
	//	Add a transmitter ref before starting the next async operation.
	//	Use auto_ref_ptr to simplify resource recording and to
	//	prevent resource leaks if an exception is thrown.
	//	Ref is claimed by AcceptComplete() below.
	//
	{
		auto_ref_ptr<CTransmitter> pRef(this);

		m_pitBody->Accept( *this, *this );

		pRef.relinquish();
	}
}

//	------------------------------------------------------------------------
//
//	CTransmitter::VisitComplete()
//
//	IBodyPartVisitor callback called when we accept the last response body
//	part added so far.  Note that the impl may still be adding body parts
//	on another thread at this point.
//
VOID
CTransmitter::VisitComplete()
{
	TransmitTrace( "DAV: CTransmitter: TID %3d: 0x%08lX VisitComplete()\n", GetCurrentThreadId(), this );

	//
	//	Sanity check: the transmitter must be running (or we wouldn't
	//	be here) and we must be accepting data.  In fact we think we
	//	just finished or we wouldn't be here.  However ImplStart() may
	//	have pended new data between the time we were called and now.
	//
	Assert( STATUS_RUNNING_ACCEPT_PENDING == m_lStatus ||
			STATUS_RUNNING_ACCEPTING == m_lStatus );

	//
	//	If ImplStart() has not pended any new data yet then let
	//	everyone know that we are done accepting for now.
	//
	(VOID) InterlockedCompareExchange( &m_lStatus,
									   STATUS_RUNNING_ACCEPT_DONE,
									   STATUS_RUNNING_ACCEPTING );
}

//	------------------------------------------------------------------------
//
//	CTransmitter::AcceptComplete()
//
//	IAcceptObserver callback called when we are done accepting data from
//	a body part.  We don't care here how much data was accepted --
//	each VisitXXX() function takes care of limiting the amount of
//	accepted data by putting the transmitter into the transmit state
//	once the optimal amount of data for a transmittable packet is reached.
//	Here we only care about the case where we reach the end of the response
//	body before accepting an optimal amount of data.
//
VOID
CTransmitter::AcceptComplete( UINT64 )
{
	//
	//	Claim the transmitter ref added by AcceptBody()
	//
	auto_ref_ptr<CTransmitter> pRef;
	pRef.take_ownership(this);

	TransmitTrace( "DAV: CTransmitter: TID %3d: 0x%08lX AcceptComplete()\n", GetCurrentThreadId(), this );

	//
	//	If we have finished accepting the entire the response
	//	then transmit it.
	//
	if ( FAcceptedCompleteResponse() )
	{
		TransmitTrace( "DAV: CTransmitter: TID %3d: 0x%08lX AcceptComplete() - Last chunk accepted.\n", GetCurrentThreadId(), this );
		m_pfnState = STransmit;
		Start();
	}

	//
	//	If there is still data left to accept or ImplStart() has pended
	//	more data then continue accepting.
	//
	//	Otherwise there is nothing to accept so try to go idle.  ImplStart()
	//	may pend new data right as we try to go idle.  If that happens then
	//	just continue accepting as if the data had been pended before.
	//
	else if ( STATUS_RUNNING_ACCEPT_DONE != m_lStatus ||
			  STATUS_RUNNING_ACCEPT_PENDING ==
				  InterlockedCompareExchange( &m_lStatus,
											  STATUS_IDLE,
											  STATUS_RUNNING_ACCEPT_DONE ) )
	{
		Start();
	}
}

//	------------------------------------------------------------------------
//
//	CTransmitter::STransmit()
//
//	Transmit accepted data via the current transmit method.
//
VOID
CTransmitter::STransmit()
{
	(this->*m_pfnTransmitMethod)();
}

//	------------------------------------------------------------------------
//
//	CTransmitter::SCleanup()
//
//	Cleanup transmitted data.
//
VOID
CTransmitter::SCleanup()
{
	TransmitTrace( "DAV: CTransmitter: TID %3d: 0x%08lX SCleanup()\n", GetCurrentThreadId(), this );

	//
	//	Quick check: If we are done accepting/transmitting the response then
	//	don't bother doing any explicit cleanup here -- our destructor
	//	will take care of everything.
	//
	if ( FAcceptedCompleteResponse() )
	{
		TransmitTrace( "DAV: CTransmitter: TID %3d: 0x%08lX SCleanup() - Last chunk has been transmitted.\n", GetCurrentThreadId(), this );
		return;
	}

	//
	//	Clear any file part.
	//
	ZeroMemory( &m_tfi, sizeof(HSE_TF_INFO) );

	//
	//	Clear any buffered text parts.
	//
	m_bufBody.Clear();

	//
	//	Clear the WSABUFS and use the prefix buffers again.
	//
	m_wsabufsPrefix.Clear();
	m_wsabufsSuffix.Clear();
	m_pwsabufs = &m_wsabufsPrefix;

	//
	//	Destroy any body parts we just sent.
	//
	m_pitBody->Prune();

	//
	//	Reset the transmit method
	//
	m_pfnTransmitMethod = TransmitNothing;

	//
	//	At this point the transmitter must be running and in
	//	one of the three accepting states.
	//
	Assert( (STATUS_RUNNING_ACCEPT_PENDING == m_lStatus) ||
			(STATUS_RUNNING_ACCEPTING == m_lStatus) ||
			(STATUS_RUNNING_ACCEPT_DONE == m_lStatus) );

	//
	//	If there is still data left to accept or ImplStart() has pended
	//	more data then continue accepting.
	//
	//	Otherwise there is nothing to accept so try to go idle.  ImplStart()
	//	may pend new data right as we try to go idle.  If that happens then
	//	just continue accepting as if the data had been pended before.
	//
	if ( STATUS_RUNNING_ACCEPT_DONE != m_lStatus ||
		 STATUS_RUNNING_ACCEPT_PENDING ==
			 InterlockedCompareExchange( &m_lStatus,
										 STATUS_IDLE,
										 STATUS_RUNNING_ACCEPT_DONE ) )
	{
		m_pfnState = SAccept;
		Start();
	}
}

//	------------------------------------------------------------------------
//
//	CTransmitter::Run()
//
VOID
CTransmitter::Run()
{
	//
	//	Keep things running as long as we're still transmitting
	//
	if ( !FAILED(m_hr) )
	{
		//
		//	Assert: we aren't idle if we're executing state functions.
		//
		Assert( m_lStatus != STATUS_IDLE );

		(this->*m_pfnState)();
	}
}

//	------------------------------------------------------------------------
//
//	CTransmitter::IISIOComplete()
//
//	Response transmitter async I/O completion routine.
//
VOID
CTransmitter::IISIOComplete( DWORD dwcbSent,
							 DWORD dwLastError )
{
	TransmitTrace( "DAV: CTransmitter: TID %3d: 0x%08lX IISIOComplete() Sent %d bytes (last error = %d)\n", GetCurrentThreadId(), this, dwcbSent, dwLastError );

	//
	//	Take ownership of the transmitter reference added
	//	on our behalf by the thread that started the async I/O.
	//
	auto_ref_ptr<CTransmitter> pRef;
	pRef.take_ownership(this);

	//
	//	If we had headers left to send then theoretically we just
	//	finished sending some of them.  If so then subtract off
	//	what we just sent before continuing.
	//
	if ( m_cbHeadersToSend > 0 && dwLastError == ERROR_SUCCESS )
	{
		//	Note: dwcbSent does not in any way give use the amount of
		//	headers sent.  Use the size of the prefix buffer instead.
		//
		Assert( m_wsabufsPrefix.CbSize() <= m_cbHeadersToSend );

		m_cbHeadersToSend -= m_wsabufsPrefix.CbSize();
	}

	//
	//	Proceed with cleanup.
	//
	m_hr = HRESULT_FROM_WIN32(dwLastError);
	m_pfnState = SCleanup;
	Start();
}

//	------------------------------------------------------------------------
//
//	CTransmitter::TransmitNothing()
//
//	This transmit function is used as the initial default transmit function.
//	If no body data is accepted for transmission before the transmitter
//	is invoked (e.g. either because the body is empty, or because the
//	previous transmission transmitted the last of the body).
//
VOID
CTransmitter::TransmitNothing()
{
	TransmitTrace( "DAV: CTransmitter: TID %3d: 0x%08lX TransmitNothing()\n", GetCurrentThreadId(), this );

	//
	//	Nothing to transmit, just proceed to cleanup.
	//
	m_pfnState = SCleanup;
	Start();
}

//	------------------------------------------------------------------------
//
//	CTransmitter::SyncTransmitHeaders()
//
VOID
CTransmitter::SyncTransmitHeaders()
{
	TransmitTrace( "DAV: CTransmitter: TID %3d: 0x%08lX SyncTransmitHeaders()\n", GetCurrentThreadId(), this );

	HSE_SEND_HEADER_EX_INFO shei = { 0 };

	//
	//	This function should (obviously) only be used to send headers
	//	including IIS headers.
	//
	Assert( m_cbHeadersToSend > 0 );
	Assert( FSendingIISHeaders() );

	shei.cchHeader = m_wsabufsPrefix.CbSize();
	if ( shei.cchHeader > 0 )
	{
		Assert( shei.cchHeader + 1 <= sizeof(m_rgbPrefix) );

		//
		//	Dump the contents of the prefix WSABUF into our prefix buffer
		//
		m_wsabufsPrefix.DumpTo( m_rgbPrefix,
								0,
								shei.cchHeader );

		//
		//	Null-terminate the headers because IIS doesn't pay any attention
		//	to cchHeader....
		//
		m_rgbPrefix[shei.cchHeader] = '\0';
		shei.pszHeader = reinterpret_cast<LPSTR>(m_rgbPrefix);
	}

	shei.pszStatus = m_pResponse->LpszStatusCode();
	shei.cchStatus = static_cast<DWORD>(strlen(shei.pszStatus));
	shei.fKeepConn = m_pResponse->m_pecb->FKeepAlive();

	if ( m_pResponse->m_pecb->FSyncTransmitHeaders(shei) )
	{
		m_cbHeadersToSend -= shei.cchHeader;
	}
	else
	{
		DebugTrace( "CTransmitter::SyncTransmitHeaders() - SSF::HSE_REQ_SEND_RESPONSE_HEADER_EX failed (%d)\n", GetLastError() );
		m_hr = HRESULT_FROM_WIN32(GetLastError());
	}

	//
	//	Next thing to do is cleanup the headers we just transmitted.
	//
	m_pfnState = SCleanup;
	Start();
}

//	------------------------------------------------------------------------
//
//	PbEmitChunkPrefix()
//
//	Emit a chunked encoding prefix.
//
inline LPBYTE
PbEmitChunkPrefix( LPBYTE pbBuf,
				   UINT cbSize )
{
	//
	//	Emit the chunk size expressed in hex
	//
	_ultoa( cbSize,
			reinterpret_cast<LPSTR>(pbBuf),
			16 );

	pbBuf += strlen(reinterpret_cast<LPSTR>(pbBuf));

	//
	//	followed by a CRLF
	//
	*pbBuf++ = '\r';
	*pbBuf++ = '\n';

	return pbBuf;
}

//	------------------------------------------------------------------------
//
//	PbEmitChunkSuffix()
//
//	Emit a chunked encoding suffix.
//
inline LPBYTE
PbEmitChunkSuffix( LPBYTE pbBuf,
				   BOOL fLastChunk )
{
	//
	//	CRLF to end the current chunk
	//
	*pbBuf++ = '\r';
	*pbBuf++ = '\n';

	//
	//	If this is the last chunk
	//
	if ( fLastChunk )
	{
		//
		//	then add a 0-length chunk
		//
		*pbBuf++ = '0';
		*pbBuf++ = '\r';
		*pbBuf++ = '\n';

		//
		//	and there are no trailers,
		//	so just add the final CRLF
		//	to finish things off.
		//
		*pbBuf++ = '\r';
		*pbBuf++ = '\n';
	}

	return pbBuf;
}

//	------------------------------------------------------------------------
//
//	CTransmitter::AsyncTransmitFile()
//
VOID
CTransmitter::AsyncTransmitFile()
{
	TransmitTrace( "DAV: CTransmitter: TID %3d: 0x%08lX AsyncTransmitFile()\n", GetCurrentThreadId(), this );

	Assert( m_tfi.hFile != NULL );


	//
	//	Always async I/O
	//
	m_tfi.dwFlags = HSE_IO_ASYNC;

	//
	//	Start building up the prefix...
	//
	LPBYTE pbPrefix = m_rgbPrefix;

	//
	//	If we are sending headers then we dump those out
	//	first followed by the chunk prefix (if we are using
	//	Transfer-Encoding: chunked.
	//
	if ( m_cbHeadersToSend )
	{
		Assert( m_wsabufsPrefix.CbSize() > 0 );

		m_wsabufsPrefix.DumpTo( pbPrefix,
								0,
								m_wsabufsPrefix.CbSize() );

		pbPrefix += m_wsabufsPrefix.CbSize();

		if ( TC_CHUNKED == m_tc )
		{
			pbPrefix = PbEmitChunkPrefix( pbPrefix,
										  m_tfi.BytesToWrite +
										  m_wsabufsSuffix.CbSize() );
		}

		//
		//	Oh yeah, we need to do a little more work here when
		//	we are including IIS headers
		//
		if ( FSendingIISHeaders() )
		{
			//	First, tell IIS to include the headers and format
			//	the status code.
			//
			m_tfi.dwFlags |= HSE_IO_SEND_HEADERS;
			m_tfi.pszStatusCode = m_pResponse->LpszStatusCode();

			//
			//	Then null-terminate the headers in the prefix because
			//	IIS doesn't pay any attention to m_tfi.HeadLength in
			//	this case.
			//
			//	Note: we do NOT increment pbPrefix here because we are
			//	not including the NULL as part of the data.  It's just
			//	there to keep IIS from overrunning our buffer.  Yes,
			//	our buffer size accounts for this.  We assert it below.
			//
			*pbPrefix = '\0';
		}
	}

	//
	//	Otherwise, we are not sending headers so all of the data
	//	in the prefix WSABUF is body data, so emit the chunk prefix
	//	before dumping the body data.
	//
	else
	{
		if ( TC_CHUNKED == m_tc )
		{
			pbPrefix = PbEmitChunkPrefix( pbPrefix,
										  m_tfi.BytesToWrite +
										  m_wsabufsSuffix.CbSize() +
										  m_wsabufsPrefix.CbSize() );
		}

		if ( m_wsabufsPrefix.CbSize() )
		{
			m_wsabufsPrefix.DumpTo( pbPrefix,
									0,
									m_wsabufsPrefix.CbSize() );

			pbPrefix += m_wsabufsPrefix.CbSize();
		}
	}

	//
	//	It's sort of after the fact, but assert that we didn't
	//	overrun the buffer.  Remember, we might have stuffed a
	//	null in at *pbPrefix, so don't forget to include it.
	//
	Assert( pbPrefix - m_rgbPrefix + 1 <= sizeof(m_rgbPrefix) );

	//
	//	Finish up the prefix
	//
	m_tfi.HeadLength = (DWORD)(pbPrefix - m_rgbPrefix);
	m_tfi.pHead = m_rgbPrefix;

	//
	//	Now start building up the suffix...
	//
	LPBYTE pbSuffix = m_rgbSuffix;

	//
	//	If there is any data in the suffix WSABUF then add that first.
	//
	if ( m_wsabufsSuffix.CbSize() )
	{
		m_wsabufsSuffix.DumpTo( pbSuffix,
								0,
								m_wsabufsSuffix.CbSize() );

		pbSuffix += m_wsabufsSuffix.CbSize();
	}

	//
	//	If we are using Transfer-Encoding: chunked then append the
	//	protocol suffix.
	//
	if ( TC_CHUNKED == m_tc )
		pbSuffix = PbEmitChunkSuffix( pbSuffix, FAcceptedCompleteResponse() );

	//
	//	It's sort of after the fact, but assert that we didn't
	//	overrun the buffer.
	//
	Assert( pbSuffix - m_rgbSuffix <= sizeof(m_rgbSuffix) );

	//
	//	Finish up the suffix
	//
	m_tfi.TailLength = (DWORD)(pbSuffix - m_rgbSuffix);
	m_tfi.pTail = m_rgbSuffix;

	//
	//	If this will be the last packet sent AND we will be closing
	//	the connection, then also throw the HSE_IO_DISCONNECT_AFTER_SEND
	//	flag.  This VASTLY improves throughput by allowing IIS to close
	//	and reuse the socket as soon as the file is sent.
	//
	if ( FAcceptedCompleteResponse() &&
		 !m_pResponse->m_pecb->FKeepAlive() )
	{
		m_tfi.dwFlags |= HSE_IO_DISCONNECT_AFTER_SEND;
	}

	//
	//	Start async I/O to transmit the file.  Make sure the transmitter
	//	has an added ref if the async I/O starts successfully.  Use
	//	auto_ref to make things exception-proof.
	//
	{
		SCODE sc = S_OK;
		auto_ref_ptr<CTransmitter> pRef(this);

		TransmitTrace( "DAV: CTransmitter: TID %3d: 0x%08lX   prefix=%d, suffix=%d, content=%d\n", GetCurrentThreadId(), this, m_tfi.HeadLength, m_tfi.TailLength, m_tfi.BytesToWrite );

		sc = m_pResponse->m_pecb->ScAsyncTransmitFile( m_tfi, *this ); 
		if (FAILED(sc))
		{
			DebugTrace( "CTransmitter::AsyncTransmitFile() - IEcb::ScAsyncTransmitFile() failed with error 0x%08lX\n", sc );
			IISIOComplete( 0, sc );
		}

		pRef.relinquish();
	}
}

//	------------------------------------------------------------------------
//
//	CTransmitter::AsyncTransmitText()
//
//	Start transmitting the text-only response.
//
VOID
CTransmitter::AsyncTransmitText()
{
	LPBYTE pb = m_rgbPrefix;


	TransmitTrace( "DAV: CTransmitter: TID %3d: 0x%08lX AsyncTransmitText()\n", GetCurrentThreadId(), this );

	//
	//	If we are sending text then there must be data in m_wsabufsPrefix.
	//
	Assert( m_wsabufsPrefix.CbSize() > 0 );

	//
	//	Figure out the amount of headers we have in the prefix WSABUF.
	//	Given that all of the headers must be transmitted before any
	//	of the body, the amount of headers in the WSABUF is the lesser
	//	of the amount of headers left to send or the size of the WSABUF.
	//
	//	The size of the body chunk is whatever is left (if anything).
	//
	UINT cbHeaders = min(m_cbHeadersToSend, m_wsabufsPrefix.CbSize());
	UINT cbChunk = m_wsabufsPrefix.CbSize() - cbHeaders;

	//
	//	If we are sending any headers then dump those out first.
	//
	if ( cbHeaders )
	{
		m_wsabufsPrefix.DumpTo( pb,
								0,
								cbHeaders );

		pb += cbHeaders;
	}

	//
	//	Then, if we are using Transfer-Encoding: chunked, include
	//	the size of this chunk.
	//
	if ( TC_CHUNKED == m_tc )
		pb = PbEmitChunkPrefix( pb, cbChunk );

	//
	//	Next, dump out the data for this chunk
	//
	if ( cbChunk > 0 )
	{
		m_wsabufsPrefix.DumpTo( pb,
								cbHeaders,
								cbChunk );

		pb += cbChunk;
	}

	//
	//	Finally, dump out the chunk suffix if we're using
	//	chunked encoding.
	//
	if ( TC_CHUNKED == m_tc )
		pb = PbEmitChunkSuffix( pb, FAcceptedCompleteResponse() );

	//
	//	It's sort of after the fact, but assert that we didn't
	//	overrun the buffer.
	//
	Assert( pb - m_rgbPrefix <= sizeof(m_rgbPrefix) );

	//
	//	Start async I/O to transmit the text.  Make sure the transmitter
	//	has an added ref if the async I/O starts successfully.  Use
	//	auto_ref to make things exception-proof.
	//
	{
		SCODE sc = S_OK;
		auto_ref_ptr<CTransmitter> pRef(this);

		sc = m_pResponse->m_pecb->ScAsyncWrite( m_rgbPrefix,
												static_cast<DWORD>(pb - m_rgbPrefix),
												*this );
		if (FAILED(sc))
		{
			DebugTrace( "CTransmitter::AsyncTransmitText() - IEcb::ScAsyncWrite() failed to start transmitting with error 0x%08lX\n", sc );
			IISIOComplete( 0, sc );
		}

		pRef.relinquish();
	}
}

//	------------------------------------------------------------------------
//
//	CTransmitter::VisitBytes()
//
VOID
CTransmitter::VisitBytes( const BYTE * pbData,
						  UINT         cbToSend,
						  IAcceptObserver& obsAccept )
{
//	TransmitTrace( "DAV: CTransmitter: TID %3d: 0x%08lX VisitBytes()\n", GetCurrentThreadId(), this );

	UINT cbAccepted;

	//
	//$IIS	If we still have IIS headers to send, then we must send them now.
	//$IIS	One might wonder why we can't simply be clever and effecient
	//$IIS	and just add the bytes to send along with the headers.  The reason
	//$IIS	we cannot is because the IIS send headers call pays no attention
	//$IIS	to the stated size of the headers and sends only up to the first
	//$IIS	NULL.  Since binary body part data could contain several NULLs,
	//$IIS	the result would be that part of the body would be lost.
	//
	if ( FSendingIISHeaders() )
	{
		m_pfnState = STransmit;
		obsAccept.AcceptComplete( 0 );
		return;
	}

	//
	//	Accept as many bytes as we can.  Note that we may not
	//	accept everything because of the WSABUFS size limit.
	//	(See CWSABufs class definition for an explanation.)
	//
	cbAccepted = m_pwsabufs->CbAddItem( pbData, cbToSend );

	//
	//	If we accepted anything at all, then we'll want to use
	//	the text transmitter to send it later, unless we are
	//	already planning to use another transmitter (e.g. the
	//	file transmitter or header transmitter) for better
	//	performance.
	//
	if ( cbAccepted > 0 && m_pfnTransmitMethod == TransmitNothing )
		m_pfnTransmitMethod = AsyncTransmitText;

	//
	//	If we couldn't accept everything, then the WSABUFS are full
	//	so we have to transmit them before we can accept anything more.
	//
	if ( cbAccepted < cbToSend )
		m_pfnState = STransmit;

	//
	//	Finally, don't forget to tell our observer that we're done visiting.
	//
	obsAccept.AcceptComplete( cbAccepted );
}

//	------------------------------------------------------------------------
//
//	CTransmitter::VisitFile()
//
VOID
CTransmitter::VisitFile( const auto_ref_handle& hf,
						 UINT64   ibOffset64,
						 UINT64   cbToSend64,
						 IAcceptObserver& obsAccept )
{
	TransmitTrace( "DAV: CTransmitter: TID %3d: 0x%08lX VisitFile()\n", GetCurrentThreadId(), this );

	//
	//	We can only transmit one file at a time.  If we've already
	//	accepted a file for transmission then we cannot accept another
	//	one.  We must transmit now.
	//
	if ( m_tfi.hFile != NULL )
	{
		m_pfnState = STransmit;
		obsAccept.AcceptComplete( 0 );
		return;
	}

	//	If we need to send headers with this packet, then we can only
	//	send them along with the file
	//
	//	Accept as much of the file as we were told to.  The amount of
	//	file data we can transmit is unlimited.
	//
	m_hf = hf;
	m_tfi.hFile = m_hf.get();

	//	Our way of seting it up depends on the fact if the file is larger
	//	than 4GB. Also we have no way to do offsets that are above 4GB
	//	through _HSE_TF_INFO. We should not get them here though as
	//	byteranges are disabled for files above 4GB. And seting 0 for
	//	BytesToWrite is special value that is to be used to ask for the
	//	whole file.
	//
	Assert(0 == (0xFFFFFFFF00000000 & ibOffset64));
	m_tfi.Offset = static_cast<DWORD>(ibOffset64);
	if (0x00000000FFFFFFFF < cbToSend64)
	{
		m_tfi.BytesToWrite = 0;
	}
	else
	{	
		m_tfi.BytesToWrite = static_cast<DWORD>(cbToSend64);
	}

	//
	//	Subsequent text data (if any) will form the suffix to the file data,
	//	so cut over to the suffix WSABUFs.
	//
	m_pwsabufs = &m_wsabufsSuffix;

	//
	//	Use the file transmitter come send time.
	//
	m_pfnTransmitMethod = AsyncTransmitFile;

	obsAccept.AcceptComplete( cbToSend64 );
}

//	------------------------------------------------------------------------
//
//	CTransmitter::VisitStream()
//
VOID
CTransmitter::VisitStream( IAsyncStream& stmSrc,
						   UINT cbToSend,
						   IAcceptObserver& obsAccept )
{
	TransmitTrace( "DAV: CTransmitter: TID %3d: 0x%08lX VisitStream()\n", GetCurrentThreadId(), this );

	//
	//$IIS	If we still have IIS headers to send, then we must send them now.
	//$IIS	One might wonder why we can't simply be clever and effecient
	//$IIS	and just stream in bytes to send along with the headers.  The reason
	//$IIS	we cannot is because the IIS send headers call pays no attention
	//$IIS	to the stated size of the headers and sends only up to the first
	//$IIS	NULL.  Since binary body part data could contain several NULLs,
	//$IIS	the result would be that part of the body would be lost.
	//
	if ( FSendingIISHeaders() )
	{
		m_pfnState = STransmit;
		obsAccept.AcceptComplete( 0 );
		return;
	}

	m_pobsAccept = &obsAccept;

	cbToSend = min( cbToSend, CB_WSABUFS_MAX - m_pwsabufs->CbSize() );

	//
	//	Add a transmitter ref before starting the next async operation.
	//	Use auto_ref_ptr to simplify resource recording and to
	//	prevent resource leaks if an exception is thrown.
	//
	auto_ref_ptr<CTransmitter> pRef(this);

	stmSrc.AsyncCopyTo( *this, cbToSend, *this );

	pRef.relinquish();
}

//	------------------------------------------------------------------------
//
//	CTransmitter::CopyToComplete()
//
VOID
CTransmitter::CopyToComplete( UINT cbCopied, HRESULT hr )
{
	//
	//	Claim the transmitter ref added by VisitStream()
	//
	auto_ref_ptr<CTransmitter> pRef;
	pRef.take_ownership(this);

	m_hr = hr;
	m_pobsAccept->AcceptComplete( cbCopied );
}

//	------------------------------------------------------------------------
//
//	CTransmitter::AsyncWrite()
//
//	"Write" text to the transmitter by adding it to the transmit buffers.
//	Despite its name, this call executes synchronously (note the call
//	to WriteComplete() at the end) so it does NOT need an additional
//	transmitter reference.
//
VOID
CTransmitter::AsyncWrite(
	const BYTE * pbBuf,
	UINT         cbToWrite,
	IAsyncWriteObserver& obsAsyncWrite )
{
	UINT cbWritten;

	Assert( cbToWrite <= CB_WSABUFS_MAX - m_pwsabufs->CbSize() );

	cbWritten = m_pwsabufs->CbAddItem(
		reinterpret_cast<LPBYTE>(m_bufBody.Append( cbToWrite,
		reinterpret_cast<LPCSTR>(pbBuf) )),
		cbToWrite );

	//
	//	If we accepted anything at all, then we'll want to use
	//	the text transmitter to send it later, unless we are
	//	already planning to use another transmitter (e.g. the
	//	file transmitter or header transmitter) for better
	//	performance.
	//
	if ( cbWritten > 0 && m_pfnTransmitMethod == TransmitNothing )
		m_pfnTransmitMethod = AsyncTransmitText;

	if ( m_pwsabufs->CbSize() == CB_WSABUFS_MAX )
		m_pfnState = STransmit;

	obsAsyncWrite.WriteComplete( cbWritten, NOERROR );
}


//	========================================================================
//
//	FREE FUNCTIONS
//

//	------------------------------------------------------------------------
//
//	NewResponse
//
IResponse * NewResponse( IEcb& ecb )
{
	return new CResponse(ecb);
}

//
//	Disable stubborn level 4 warnings generated by expansion of inline STL
//	member functions.  Why do it way down here?  Because it appears to
//	silence these expanded functions without supressing warnings for any
//	code we've written above!
//
#pragma warning(disable:4146)	//	negative unsigned is still unsigned
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\scrptmps.cpp ===
/*
 *	S C R P T M P S . C P P
 *
 *	Scriptmaps cacheing
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davprs.h"
#include "scrptmps.h"
#include "instdata.h"

//	========================================================================
//	class CScriptMap
//
//	Contains the parsed set of scriptmaps for a single metabase entry.
//	Contains lookup functions to find scriptmaps that match certain
//	conditions.
//
class CScriptMap :
	public IScriptMap,
	public CMTRefCounted
{

	typedef struct _inclusions {

		DWORD	fdwInclusions;
		LPCWSTR	pwszMethods;

		BOOL FAllMethodsIncluded ()
		{
			//	When a script map has an empty inclusion verb list, it means all verbs included
			//	(NOT all verbs excluded).
			//
			Assert (pwszMethods);
			return L'\0' == pwszMethods[0];
		}

	} INCLUSIONS, * PINCLUSIONS;

	typedef CCache<CRCWszi, PINCLUSIONS> CInclusionsCache;

	//	INCLUSIONS data storage area.
	//
	ChainedBuffer<INCLUSIONS>	m_bInclusions;

	//	Cache of scriptmap entries
	//
	CInclusionsCache			m_cache;

	//	Pointer to first 'star' scriptmap in the list.
	//	This is the one that IIS will have called to process
	//	the request for this url.  This is used by the virtual
	//	root cache.
	//
	//	Note that we should ignore any 'star' scriptmaps when
	//	evaluating for matches.  The first 'star' gets a crack
	//	at it, and that's that.
	//
	LPCWSTR						m_pwszStarScriptmap;

	//	Private accessors
	//
	VOID AddMapping (LPCWSTR pwszMap, HDRITER_W* pit);
	BOOL FLoadScriptmaps (LPWSTR pwszScriptMaps);

	//	CLASS CIsMatch --------------------------------------------------------
	//
	//	Functional class to find if a given scriptmap applys to a URI
	//
	class CIsMatch : public CInclusionsCache::IOp
	{
		const CInclusionsCache& m_cache;
		const LPCWSTR m_pwszMethod;
		const METHOD_ID m_midMethod;
		BOOL m_fCGI;
		DWORD m_dwAccess;
		LPCWSTR m_pwszMatch;
		LPCWSTR m_pwszURI;
		SCODE m_sc;

		//	NOT IMPLEMENTED
		//
		CIsMatch& operator=(const CIsMatch&);

	public:

		CIsMatch(const CInclusionsCache& cache,
				 const LPCWSTR pwszMethod,
				 const METHOD_ID midMethod,
				 LPCWSTR pwszUri,
				 LPCWSTR pwszMatch,
				 DWORD dwAcc)

				: m_cache(cache),
				  m_pwszMethod(pwszMethod),
				  m_midMethod(midMethod),
				  m_fCGI(FALSE),
				  m_dwAccess(dwAcc),
				  m_pwszURI(pwszUri),
				  m_pwszMatch(pwszMatch),
				  m_sc(S_OK)
		{}

		SCODE ScMatched() const		{ return m_sc; }
		BOOL FMatchIsCGI() const	{ return m_fCGI; }

		virtual BOOL operator()(const CRCWszi& crcwszi, const PINCLUSIONS& pin);
	};

	//	NOT IMPLEMENTED
	//
	CScriptMap& operator=(const CScriptMap&);
	CScriptMap(const CScriptMap&);

	//	Helper function
	//
public:

	//	CREATORS
	//
	CScriptMap() : m_pwszStarScriptmap(NULL)
	{
		//	Use COM-style ref-counting.  Start with 1.
		//
		m_cRef = 1;
	}

	BOOL FInit (LPWSTR pwszScriptMaps);

	//	Implementation of IRefCounted members
	//	Simply route them to our own CMTRefCounted members.
	//
	void AddRef()
	{
		CMTRefCounted::AddRef();
	}
	void Release()
	{
		CMTRefCounted::Release();
	}

	//	ACCESSORS
	//
	SCODE ScMatched (LPCWSTR pwszMethod,
					 METHOD_ID midMethod,
					 LPCWSTR pwszMap,
					 DWORD dwAccess,
					 BOOL * pfCGI) const;

	//	Used by MOVE/COPY/DELETE to check for star scriptmapping
	//	overrides
	//
	BOOL FSameStarScriptmapping (const IScriptMap * pism) const
	{
		const CScriptMap* prhs = static_cast<const CScriptMap*>(pism);
		if (m_pwszStarScriptmap != prhs->m_pwszStarScriptmap)
		{
			if (m_pwszStarScriptmap && prhs->m_pwszStarScriptmap)
				if (0 == _wcsicmp (m_pwszStarScriptmap, prhs->m_pwszStarScriptmap))
					return TRUE;
		}
		else
			return TRUE;

		return FALSE;
	}
};

CScriptMap::FInit (LPWSTR pwszScriptMaps)
{
	//	Init the cache
	//
	if ( !m_cache.FInit() )
		return FALSE;

	//	Load the scriptmaps
	//
	return FLoadScriptmaps(pwszScriptMaps);
}

void
CScriptMap::AddMapping(LPCWSTR pwszMap, HDRITER_W * pitInclusions)
{
	LPCWSTR pwszInclusion;
	METHOD_ID mid;
	PINCLUSIONS pin = NULL;

	Assert (pwszMap);

	//	If there is a DLL, then we want to assemble an inclusions list
	//
	if (pitInclusions)
	{
		pin = m_bInclusions.Alloc (sizeof(INCLUSIONS));

		//	Record the start of the inclusion list
		//
		pin->pwszMethods = pitInclusions->PszRaw();
		pin->fdwInclusions = 0;

		//	Rip through the list and identify all the known
		//	inclusions
		//
		while ((pwszInclusion = pitInclusions->PszNext()) != NULL)
		{
			mid = MidMethod (pwszInclusion);
			if (mid != MID_UNKNOWN)
				pin->fdwInclusions |= (1 << mid);
		}
	}

	//	At this point, we can add the cache item...
	//
	ScriptMapTrace ("Dav: adding scriptmap for %S -- including %S\n",
					pwszMap,
					(pin && pin->pwszMethods) ? pin->pwszMethods : L"none");

	//	CRC the mapping and stuff it into the cache.
	//	Note that we are safe in using the actual parameter string
	//	here because the CScriptMap object's lifetime is the same
	//	as the lifetime of the metadata on which it operates.  See
	//	\cal\src\_davprs\davmb.cpp for details.
	//
	CRCWszi crcwszi(pwszMap);

	(void) m_cache.FSet (crcwszi, pin);
}

BOOL
CScriptMap::FLoadScriptmaps (LPWSTR pwszScriptMaps)
{
	HDRITER_W it(NULL);

	UINT cchDav = static_cast<UINT>(wcslen(gc_wszSignature));

	Assert (pwszScriptMaps);

	ScriptMapTrace ("Dav: loading scriptmap cache\n");

	//	Add in the default CGI/BGI mappings
	//
	AddMapping (L".EXE", NULL);
	AddMapping (L".CGI", NULL);
	AddMapping (L".COM", NULL);
	AddMapping (L".DLL", NULL);
	AddMapping (L".ISA", NULL);

	//
	//	Parse through the scriptmap list and build up the cache.
	//
	//	Each mapping is a string of the form:
	//
	//		"<ext>|<*>,<path>,<flags>[,<included verb>...]"
	//
	//	Note that if any of the mappings is invalid we fail the whole call.
	//	This is consistent with IIS' behavior.
	//
	UINT cchMapping = 0;
	for ( LPWSTR pwszMapping = pwszScriptMaps;
		  *pwszMapping;
		  pwszMapping += cchMapping )
	{
		enum {
			ISZ_SM_EXT = 0,
			ISZ_SM_PATH,
			ISZ_SM_FLAGS,
			ISZ_SM_INCLUSION_LIST,
			CSZ_SM_FIELDS
		};

		//	Figure out the length of the mapping
		//	including the null terminator
		//
		cchMapping = static_cast<UINT>(wcslen(pwszMapping) + 1);

		//	Special case: star (wildcard) scriptmaps.
		//
		//	These should mostly be ignored.  We will never
		//	forward to a star scriptmap.  If we find a star
		//	scriptmap, the only reason to keep track of it
		//	is so that we can compare it against another
		//	star scriptmap when checking the feasibility
		//	of a trans-vroot MOVE/COPY/DELETE.  And for this
		//	comparsion, we check for EXACT equality between
		//	the scriptmaps by checking the entire scriptmap
		//	string.
		//
		//	See the comments regarding m_pszStarScriptMap
		//	above for more detail.
		//
		if (L'*' == *pwszMapping)
		{
			if (NULL == m_pwszStarScriptmap)
				m_pwszStarScriptmap = pwszMapping;

			continue;
		}

		//	Digest the metadata.
		//
		LPWSTR rgpwsz[CSZ_SM_FIELDS];

		UINT cchUnused;
		if (!FParseMDData (pwszMapping,
						   rgpwsz,
						   CSZ_SM_FIELDS,
						   &cchUnused))
		{
			//	FParseMDData() will return FALSE if there is no verb
			//	exclusion list because it is an optional parameter.
			//	If all the other parameters exist though then it's
			//	really ok.
			//
			if (!(rgpwsz[ISZ_SM_EXT] &&
				  rgpwsz[ISZ_SM_PATH] &&
				  rgpwsz[ISZ_SM_FLAGS]))
			{
				DebugTrace ("CScriptMap::FLoadScriptMaps() - Malformed scriptmaps\n");
				continue;
			}
		}

		//	We belive that all the scriptmaps are
		//	extension based.  But other than that
		//	there is no validation.
		//
		Assert (*rgpwsz[ISZ_SM_EXT] == L'.');

		//	If the path refers to our DAV DLL then skip this mapping.
		//
		//	The way this works is:  If the length of the path is at least
		//	as long as the length of our DLL name AND the final component
		//	of that path is the name of our DLL then skip the mapping.
		//	Eg. "HTTPEXT.DLL" will match the first condition of the if,
		//	"c:\foo\bar\HTTPEXT.DLL" will match the second condition of the if.
		//
		static const UINT cchDll = CchConstString(L".DLL");
		UINT cchPath = static_cast<UINT>(wcslen(rgpwsz[ISZ_SM_PATH]));
		if (cchPath == cchDav + cchDll ||
			((cchPath > cchDav + cchDll) &&
			 *(rgpwsz[ISZ_SM_PATH] + cchPath - cchDll - cchDav - 1) == L'\\'))
		{
			//	Now we know the final piece of the path is the correct length.
			//	Check the data!  If it matches our dll name, skip this mapping.
			//
			if (!_wcsnicmp(rgpwsz[ISZ_SM_PATH] + cchPath - cchDll - cchDav,
						   gc_wszSignature,
						   cchDav) &&

				!_wcsicmp(rgpwsz[ISZ_SM_PATH] + cchPath - cchDll,
						  L".DLL"))
			{
				continue;
			}
		}

		//	Feed the optional inclusion list into a header iterator
		//	that AddMapping() will use to determine what verbs
		//	are included for this mapping.  If there is no inclusion
		//	list then use an empty iterator.
		//
		//	Adding a mapping with an empty iterator (vs. NULL)
		//	allows the scriptmap matching code to distinguish
		//	between a "real" scriptmap with an empty inclusion
		//	list and a default CGI-style scriptmap like those
		//	added at the beginning of this function.
		//
		it.NewHeader(rgpwsz[ISZ_SM_INCLUSION_LIST] ?
					 rgpwsz[ISZ_SM_INCLUSION_LIST] :
					 gc_wszEmpty);

		//	Add the extension-based mapping
		//
		AddMapping (rgpwsz[ISZ_SM_EXT], &it);
	}

	return TRUE;
}

SCODE
CScriptMap::ScMatched (
	LPCWSTR pwszMethod,
	METHOD_ID midMethod,
	LPCWSTR pwszURI,
	DWORD dwAccess,
	BOOL * pfCGI) const
{
	LPCWSTR pwsz;
	SCODE sc = S_OK;

	Assert(pwszURI);

	//
	//	Scan down the URI, looking for extensions.  When one is found
	//	zip through the list of mappings.  While this may not seem the
	//	most optimal, it really is.  If we simply scaned the URI for
	//	each mapping.  We would be scaning the URI multiple times.  In
	//	this model, we scan the URI once.
	//
	if ((pwsz = wcsrchr(pwszURI, L'.')) != NULL)
	{
		//	We have an extension so take a look
		//
		CIsMatch cim(m_cache, pwszMethod, midMethod, pwszURI, pwsz, dwAccess);

		m_cache.ForEach(cim);

		sc = cim.ScMatched();

		if (pfCGI && (sc != S_OK))
			*pfCGI = cim.FMatchIsCGI();
	}

	return sc;
}

//	CLASS CIsMatch ------------------------------------------------------------
//
//$REVIEW: Does this code work for DBCS/UTF-8 map names?  These are filenames....
//$REVIEW: This function does not currently check the METHOD EXCLUSION LIST.
//$REVIEW: This might cause us to report a match when actually there are NO matches.
//
BOOL
CScriptMap::CIsMatch::operator()(const CRCWszi& crcwszi, const PINCLUSIONS& pin)
{
	Assert (crcwszi.m_pwsz);

	//	Every scriptmap in the cache should be an extension-based mapping.
	//	Compare the extension vs. the part of the URI that we're looking at.
	//	If they match then we have a scriptmap.
	//
	Assert (L'.' == *crcwszi.m_pwsz);

	UINT cch = static_cast<UINT>(wcslen (crcwszi.m_pwsz));

	if (!_wcsnicmp (crcwszi.m_pwsz, m_pwszMatch, cch) &&
		((m_pwszMatch[cch] == '\0')
		 || !wcscmp (m_pwszMatch+cch, L"/")
		 || !wcscmp (m_pwszMatch+cch, L"\\")))
	{
		//	Looks like we have a match
		//
		ScriptMapTrace ("Dav: %S matched scriptmap %S\n", m_pwszURI, crcwszi.m_pwsz);

		//	However, we only allow execution of CGI type child
		//	ISAPI's if EXECUTE priviledge is enabled
		//
		if ((pin != NULL) || (m_dwAccess & MD_ACCESS_EXECUTE))
			m_sc = W_DAV_SCRIPTMAP_MATCH_FOUND;

		m_fCGI = !pin;
	}

	//	See if it is included
	//	Note that, if all methods are included, no need to do further checking
	//
	if ((m_sc != S_OK) && pin && !pin->FAllMethodsIncluded())
	{
		ScriptMapTrace ("Dav: checking '%S' against scriptmap inclusions: %S\n",
						m_pwszMethod,
						pin->pwszMethods);

		//	In the unknown method scenario, we just need
		//	to iterate the set of methods that are included
		//	and check it against the request method
		//
		if (m_midMethod == MID_UNKNOWN)
		{
			BOOL fIncluded = FALSE;
			HDRITER_W it(pin->pwszMethods);
			LPCWSTR pwsz;

			while ((pwsz = it.PszNext()) != NULL)
			{
				fIncluded = !wcscmp (pwsz, m_pwszMethod);
				if (fIncluded)
					break;
			}

			if (!fIncluded)
			{
				ScriptMapTrace ("Dav: unknown '%S' excluded from scriptmap\n",
								m_pwszMethod);

				m_sc = W_DAV_SCRIPTMAP_MATCH_EXCLUDED;
			}
		}
		//
		//	Otherwise, the inclusions flags have the MID'th bit
		//	set if it is excluded.
		//
		else if (!(pin->fdwInclusions & (1 << m_midMethod)))
		{
			ScriptMapTrace ("Dav: '%S' excluded from scriptmap\n",
						m_pwszMethod);

			m_sc = W_DAV_SCRIPTMAP_MATCH_EXCLUDED;
		}
	}

	return (m_sc == S_OK);
}

IScriptMap *
NewScriptMap( LPWSTR pwszScriptMaps )
{
	auto_ref_ptr<CScriptMap> pScriptMap;

	pScriptMap.take_ownership (new CScriptMap());

	if (pScriptMap->FInit(pwszScriptMaps))
		return pScriptMap.relinquish();

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\security.cpp ===
/*
 *	S E C U R I T Y . C P P
 *
 *	Url security checks.  While these would seem to only apply to HttpEXT,
 *	all impls. that care about ASP execution should really think about this.
 *
 *	Bits stolen from the IIS5 project 'iis5\infocom\cache2\filemisc.cxx' and
 *	cleaned up to fit in with the DAV sources.
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davprs.h"

//	This function takes a suspected NT/Win95 short filename and checks
//	if there's an equivalent long filename.
//
//		For example, c:\foobar\ABCDEF~1.ABC is the same as
//		c:\foobar\abcdefghijklmnop.abc.
//
//	If there is an equivalent, we need to FAIL this path, because our metabase
//	will NOT have the correct values listed under the short paths!
//	If there is no equivalent, this path can be allowed through, because it
//	might be a real storage entitiy (not an alias for a real storage entity).
//
//	NOTE: This function should be called unimpersonated - the FindFirstFile()
//	must be called in the system context since most systems have traverse
//	checking turned off - except for the UNC case where we must be impersonated
//	to get network access.
//
SCODE __fastcall
ScCheckIfShortFileName (
	/* [in] */ LPCWSTR pwszPath,
	/* [in] */ const HANDLE hitUser)
{
	WIN32_FIND_DATAW fd;
	LPCWSTR pwsz;
	BOOL fUNC = FALSE;

	//	Skip forward to find the first '~'
	//
	if (NULL == (pwsz = wcschr(pwszPath, L'~')))
		return S_OK;

	//$	REVIEW: this is not sufficient for DavEX, but it is unclear that
	//	this function applies there.  Certainly the FindFirstFile() call
	//	will fail at this time.
	//
    	fUNC = (*pwszPath == L'\\');
	Assert (!fUNC || (NULL != hitUser));

    	//	We actually need to loop in case multiple '~' appear in the filename
    	//
	do
    	{
		//	At this point, pwsz should be pointing to the '~'
		//
		Assert (L'~' == *pwsz);

		//	Is the next char a digit?
		//
		pwsz++;
	       if ((*pwsz >= L'0') && (*pwsz <= L'9'))
	   	{
			WCHAR wszTmp[MAX_PATH];
            		const WCHAR * pwchEndSeg;
            		const WCHAR * pwchBeginSeg;
            		HANDLE hFind;

            		//  Isolate the path up to the segment with the
            		//  '~' and do the FindFirstFile with that path
            		//
            		pwchEndSeg = wcschr (pwsz, L'\\');
            		if (!pwchEndSeg)
            		{
                		pwchEndSeg = pwsz + wcslen (pwsz);
            		}

            		//   If the string is beyond MAX_PATH then we fail it.
			//	urls this long don't need to have '~N' in them.
			//
			//	Also check that our buffer is big enough to handle anything
			//	that gets through this check.
			//
			//	NOTE: We are assuming that other code outside this function
			//	will catch paths that are larger than MAX_PATH and FAIL them.
			//
			//$	REVIEW: the MAX_PATH restriction is very important because
			//	the call to FindFirstFile() will fail if the path is larger
			//	than MAX_PATH.  Should we ever decide to support larger paths
			//	in HttpEXT, this code will have to change.
            		//
			Assert (MAX_PATH == CElems(wszTmp));
            		if ((pwchEndSeg - pwszPath) >= MAX_PATH)
				return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

			//	Make a copy of the string up to this point in the path
			//
			wcsncpy (wszTmp, pwszPath, pwchEndSeg - pwszPath);
			wszTmp[pwchEndSeg - pwszPath] = 0;

			//	If we are not accessing a unc, then we need to revert
			//	for our call to FindFirstFile() -- see comment above.
			//
			if (!fUNC)
			{
				safe_revert (const_cast<HANDLE>(hitUser));
				hFind = FindFirstFileW (wszTmp, &fd);
			}
			else
				hFind = FindFirstFileW (wszTmp, &fd);

            		if (hFind == INVALID_HANDLE_VALUE)
            		{
                		//  If the FindFirstFile() fails to find the file then
				//	the filename cannot be a short name.
                		//
				DWORD dw = GetLastError();
                		if ((ERROR_FILE_NOT_FOUND != dw) && (ERROR_PATH_NOT_FOUND != dw))
					return HRESULT_FROM_WIN32(dw);

				return S_OK;
            		}

			//	Make sure the find context gets closed.
			//
            		FindClose (hFind);

            		//  Isolate the last segment of the string which should be
            		//  the potential short name equivalency
            		//
			pwchBeginSeg = wcsrchr (wszTmp, '\\');
			Assert (pwchBeginSeg);
			pwchBeginSeg++;

            		//  If the last segment doesn't match the long name then
			//	this is the short name version (alias) of the path -- so
			//	fail this function.
			//
            		if (_wcsicmp (fd.cFileName, pwchBeginSeg))
			{
				DebugTrace ("Dav: Url: refers to shortname for file\n");
				Assert (!_wcsicmp (fd.cAlternateFileName, pwchBeginSeg));
				return E_DAV_SHORT_FILENAME;
			}
        	}
	       
    	} while (NULL != (pwsz = wcschr (pwsz, L'~')));
	
    	return S_OK;
}

SCODE __fastcall
ScCheckForAltFileStream (
	/* [in] */ LPCWSTR pwszPath)
{
    //	Avoid the infamous ::$DATA bug
	//
    if (wcsstr (pwszPath, L"::"))
		return E_DAV_ALT_FILESTREAM;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\sz.cpp ===
/*
 *	S Z . C P P
 *
 *	Multi-language string support
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */


//-----------------------------------------------------------------------------
//
//	NOTE: This file doesn't exist anymore.  All string go in \cal\src\inc\sz.h
//		  and are declared using DEC_CONST.  This is just a tombstone!  This
//		  file has been removed from the SOURCES list in the makefile.
//
//-----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\szsrc.cpp ===
/*
 *	S Z S R C . C P P
 *
 *	Multi-language string support
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davprs.h"
#include <langid.h>

/*
 *	FLookupWSz()
 *
 *	Purpose:
 *
 *		Looks up a string given a specific language ID.
 *
 *	Parameters:
 *
 *		rid			[in]  resource ID of string in localized table
 *		lcid		[in]  locale ID
 *		ppwsz		[out] pointer to reequested string
 */
BOOL
FLookupWSz (UINT rid, LCID lcid, LPWSTR pwsz, UINT cch)
{
	safe_lcid sl(lcid);

	//	Try the requested language identifier
	//
	if (!LoadStringW (g_inst.Hinst(), rid, pwsz, cch))
	{
		DebugTrace ("Dav: Failed to find requested language string\n");

		//	If that wasn't there, then try try stripping the sub-lang
		//
		SetThreadLocale (MAKELCID (MAKELANGID (PRIMARYLANGID (lcid),
											   SUBLANG_DEFAULT),
								   SORT_DEFAULT));

		if (!LoadStringW (g_inst.Hinst(), rid, pwsz, cch))
		{
			DebugTrace ("Dav: Failed to find next best language string\n");
			return FALSE;
		}
	}
	return TRUE;
}

/*
 *	FLoadLangSpecificString()
 *
 *	Purpose:
 *
 *		Loads a language specific string.  If lang is unavailable, try
 *		LANG_ENGLISH.
 *
 *	Parameters:
 *
 *		rid			[in]  string resource ID
 *		lcid		[in]  locale ID
 *		rgchBuf		[out] loaded string
 *		cbBuf		[in]  size of rgchBuf
 */
BOOL
FLoadLangSpecificString (UINT rid, LCID lcid, LPSTR psz, UINT cch)
{
	CStackBuffer<WCHAR,128> pwsz(cch * sizeof(WCHAR));

	//	Try the requested language
	//
	if (!FLookupWSz (rid, lcid, pwsz.get(), cch))
	{
		//	If we couldn't find the requested language, then
		//	try for the machine default.
		//
		lcid = MAKELCID (GetSystemDefaultLangID(), SORT_DEFAULT);
		if (!FLookupWSz (rid, lcid, pwsz.get(), cch))
		{
			//	And lastly try for english, cause we know that one
			//	is there.
			//
			lcid = MAKELCID (MAKELANGID (LANG_ENGLISH,
										 SUBLANG_ENGLISH_US),
							 SORT_DEFAULT);

			if (!FLookupWSz (rid, lcid, pwsz.get(), cch))
				return FALSE;
		}
	}

	return WideCharToMultiByte (CP_UTF8,
								0,
								pwsz.get(),
								-1,
								psz,
								cch,
								NULL,
								NULL);
}

BOOL
FLoadLangSpecificStringW (UINT rid, LCID lcid, LPWSTR pwsz, UINT cch)
{
	//	Try the requested language
	//
	if (!FLookupWSz (rid, lcid, pwsz, cch))
	{
		//	If we couldn't find the requested language, then
		//	go for US English
		//
		lcid = MAKELCID (MAKELANGID (LANG_ENGLISH,
									 SUBLANG_ENGLISH_US),
						 SORT_DEFAULT);

		if (!FLookupWSz (rid, lcid, pwsz, cch))
			return FALSE;
	}

	return TRUE;
}

//	========================================================================
//
//	CLASS CIDPair
//
//	Key class used with the caches in CResourceStringCache below.  Each key
//	is just a pair of IDs: the resource ID and the LCID.
//
class CIDPair
{
public:

	UINT m_uiResourceID;
	LCID m_lcid;

	CIDPair(UINT uiResourceID,
			LCID lcid) :
		m_uiResourceID(uiResourceID),
		m_lcid(lcid)
	{
	}

	//	operators for use with the hash cache
	//
	int hash( const int rhs ) const
	{
		//
		//	Ignore the LCID and hash only on resource ID.
		//	Typically the server will only deal with one language.
		//
		return m_uiResourceID % rhs;
	}

	bool isequal( const CIDPair& rhs ) const
	{
		return (m_lcid == rhs.m_lcid) &&
			   (m_uiResourceID == rhs.m_uiResourceID);
	}
};


//	========================================================================
//
//	CLASS CResourceStringCache
//
//	Cache of resource strings to minimize expensive LoadString() calls.
//
class CResourceStringCache : private Singleton<CResourceStringCache>
{
	//
	//	Friend declarations required by Singleton template
	//
	friend class Singleton<CResourceStringCache>;

	//
	//	Caches for ANSI and Unicode strings, keyed by LCID/ResourceID pair.
	//	These must be multithread-safe caches as accesses and additions
	//	can occur simultaneously from multiple threads.
	//
	CMTCache<CIDPair, LPSTR>  m_cacheA;
	CMTCache<CIDPair, LPWSTR> m_cacheW;

	//
	//	Buffers in which the strings in the caches are stored.
	//
	ChainedStringBuffer<CHAR>  m_sbA;
	ChainedStringBuffer<WCHAR> m_sbW;

	//	NOT IMPLEMENTED
	//
	CResourceStringCache& operator=(const CResourceStringCache&);
	CResourceStringCache(const CResourceStringCache&);

public:
	//	STATICS
	//
	using Singleton<CResourceStringCache>::CreateInstance;
	using Singleton<CResourceStringCache>::DestroyInstance;
	using Singleton<CResourceStringCache>::Instance;

	//	CREATORS
	//
	CResourceStringCache() {}
	BOOL FInitialize() { return TRUE; } //$NYI Planning for when CMTCache initialization can fail...

	//	MANIPULATORS
	//
	BOOL FFetchStringA( UINT  uiResourceID,
						LCID  lcid,
						LPSTR lpszBuf,
						INT   cchBuf );

	BOOL FFetchStringW( UINT   uiResourceID,
						LCID   lcid,
						LPWSTR lpwszBuf,
						INT    cchBuf );
};

/*
 *	CResourceStringCache::FFetchStringA()
 *
 *	Purpose:
 *
 *		Fetches an ANSI string from the cache, faulting the string into
 *		the cache on first access.
 */
BOOL
CResourceStringCache::FFetchStringA(
	UINT  uiResourceID,
	LCID  lcid,
	LPSTR lpszBuf,
	INT   cchBuf )

{
	CIDPair ids( uiResourceID, lcid );
	LPSTR lpszCached = NULL;

	Assert( lpszBuf );

	//
	//	Lookup the string in the cache.  If it isn't there, then fault it in.
	//
	while ( !m_cacheA.FFetch( ids, &lpszCached ) )
	{
		//
		//	Use an init gate.  If there are multiple threads all trying
		//	to fault in the same string, this will block all but the first
		//	one through until we're done.  Use the full LCID/Resource ID
		//	pair when naming the init gate to minimize possible contention
		//	on the gate to just those threads that are trying to fault
		//	in this particular string.
		//
		WCHAR rgwchIDs[(sizeof(LCID) + sizeof(UINT)) * 2 + 1];

		swprintf( rgwchIDs, L"%x%lx", lcid, uiResourceID );

		CInitGate ig( L"DAV/CResourceStringCache::FFetchStringA/", rgwchIDs );

		if ( ig.FInit() )
		{
			//
			//	We be the thread to fault in the string.  Load up the string
			//	and cache it.  Since we load the string into the caller-supplied
			//	buffer directly, we can return as soon as we're done adding
			//	to the cache.  No need for another lookup.
			//
			if ( FLoadLangSpecificString( uiResourceID, lcid, lpszBuf, cchBuf ) )
			{
				m_cacheA.Add( ids, m_sbA.AppendWithNull(lpszBuf) );
				return TRUE;
			}
			else
			{
				return FALSE;
			}
		}
	}

	Assert( lpszCached );

	//
	//	Copy up to cchBuf characters from the cached string into
	//	the provided buffer.  If the cached string is longer than
	//	the buffer, then the copied string is truncated
	//
	strncpy( lpszBuf, lpszCached, cchBuf );

	//
	//	Make sure the copied string is null-terminated, which
	//	it may not have been if it was truncated above.
	//
	lpszBuf[cchBuf-1] = '\0';

	return TRUE;
}

/*
 *	CResourceStringCache::FFetchStringW()
 *
 *	Purpose:
 *
 *
 *		Fetches a UNICODE string from the cache, faulting the string into
 *		the cache on first access.
 */
BOOL
CResourceStringCache::FFetchStringW(
	UINT   uiResourceID,
	LCID   lcid,
	LPWSTR lpwszBuf,
	INT    cchBuf )
{
	CIDPair ids( uiResourceID, lcid );
	LPWSTR lpwszCached = NULL;

	Assert( lpwszBuf );

	//
	//	Lookup the string in the cache.  If it isn't there, then fault it in.
	//
	while ( !m_cacheW.FFetch( ids, &lpwszCached ) )
	{
		//
		//	Use an init gate.  If there are multiple threads all trying
		//	to fault in the same string, this will block all but the first
		//	one through until we're done.  Use the full LCID/Resource ID
		//	pair when naming the init gate to minimize possible contention
		//	on the gate to just those threads that are trying to fault
		//	in this particular string.
		//
		WCHAR rgwchIDs[(sizeof(LCID) + sizeof(UINT)) * 2 + 1];

		swprintf( rgwchIDs, L"%x%lx", lcid, uiResourceID );

		CInitGate ig( L"DAV/CResourceStringCache::FFetchStringW/", rgwchIDs );

		if ( ig.FInit() )
		{
			//
			//	We be the thread to fault in the string.  Load up the string
			//	and cache it.  Since we load the string into the caller-supplied
			//	buffer directly, we can return as soon as we're done adding
			//	to the cache.  No need for another lookup.
			//
			if ( FLoadLangSpecificStringW( uiResourceID, lcid, lpwszBuf, cchBuf ) )
			{
				m_cacheW.Add( ids, m_sbW.AppendWithNull(lpwszBuf) );
				return TRUE;
			}
			else
			{
				return FALSE;
			}
		}
	}

	Assert( lpwszCached );

	//
	//	Copy up to cchBuf characters from the cached string into
	//	the provided buffer.  If the cached string is longer than
	//	the buffer, then the copied string is truncated
	//
	wcsncpy( lpwszBuf, lpwszCached, cchBuf );

	//
	//	Make sure the copied string is null-terminated, which
	//	it may not have been if it was truncated above.
	//
	lpwszBuf[cchBuf-1] = L'\0';

	return TRUE;
}

/*
 *	FInitResourceStringCache()
 *
 *	Purpose:
 *
 *		Initializes the resource string pool.
 */
BOOL
FInitResourceStringCache()
{
	return CResourceStringCache::CreateInstance().FInitialize();
}

/*
 *	DeinitResourceStringCache()
 *
 *	Purpose:
 *
 *		Deinitializes the resource string pool.
 */
VOID
DeinitResourceStringCache()
{
	CResourceStringCache::DestroyInstance();
}

/*
 *	LpszLoadString()
 *
 *	Purpose:
 *
 *		Loads a string based on localization.
 */
LPSTR
LpszLoadString (UINT uiResourceID,
	ULONG lcid,
	LPSTR lpszBuf,
	INT cchBuf)
{
	if (!CResourceStringCache::Instance().FFetchStringA(uiResourceID, lcid, lpszBuf, cchBuf))
	{
		DebugTrace ("LpszLoadString() - Could not load string for resource ID %u (%d)\n",
					uiResourceID,
					GetLastError());
		throw CDAVException();
	}
	return lpszBuf;
}

/*
 *	LpwszLoadString()
 *
 *	Purpose:
 *
 *		Loads a string based on localization.
 */
LPWSTR
LpwszLoadString (UINT uiResourceID,
	ULONG lcid,
	LPWSTR lpwszBuf,
	INT cchBuf)
{
	if (!CResourceStringCache::Instance().FFetchStringW(uiResourceID, lcid, lpwszBuf, cchBuf))
	{
		DebugTrace ("LpszLoadString() - Could not load string for resource ID %u (%d)\n",
					uiResourceID,
					GetLastError());
		throw CDAVException();
	}
	return lpwszBuf;
}

/*
 *	LInstFromVroot()
 *
 *	Purpose:
 *
 *		Compute the server ID from the vroot (format of the vroot
 *		is "/lm/w3svc/<ID>/root/vroot/...").  The computation should
 *		be robust -- if for whatever reason the server ID can't
 *		be determined from the vroot, leave it with a value of 0.
 *
 */
LONG LInstFromVroot( LPCWSTR pwszServerId )
{
	LONG	lServerId = 0;
	CStackBuffer<WCHAR> pwszInstance;

	Assert(pwszServerId);

	//	Make sure the vroot begins with "/lm/w3svc"
	//
	if ( wcsstr( pwszServerId, gc_wsz_Lm_W3Svc) == pwszServerId )
	{
		//
		//	If it does, then skip past that part and try to
		//	locate the '/' which should follow it.  If there
		//	isn't one, that's fine; we'll just be unable to
		//	convert whatever is there to a number and we'll
		//	end up with a server id of 0, which as we said
		//	above is just fine.
		//
		pwszServerId += gc_cch_Lm_W3Svc;
		if (L'/' == *pwszServerId)
		{
			pwszServerId++;
		}

		//
		//	At this point, pwszServerId should look like
		//	"1/root/vroot/..."  Locate the first '/' (should
		//	be immediately following the number) and null
		//	it out.  Again, if for some oddball reason
		//	we don't find a '/', then we'll just try to
		//	convert whatever is there and end up with
		//	a server ID of 0.
		//
		WCHAR * pwch = wcschr( pwszServerId, L'/' );
		if ( pwch )
		{
			//	Reallocate the string with server ID on the stack
			//	so that we do not mess up the one passed in
			//
			UINT cchInstance = static_cast<UINT>(pwch - pwszServerId);
			pwszInstance.resize(CbSizeWsz(cchInstance));

			//	Copy the string and terminate it
			//
			memcpy(pwszInstance.get(), pwszServerId, cchInstance * sizeof(WCHAR));
			pwszInstance[cchInstance] = L'\0';

			//	Swap the pointer
			//
			pwszServerId = pwszInstance.get();
		}

		//
		//	If we nulled out the '/', our pwszServerId
		//	should now just be a number formatted as
		//	decimal integer string.  Attempt to convert
		//	it to its corresponding binary value to get
		//	the ServerId.  Conveniently, atoi returns 0
		//	if it can't convert the string, which is
		//	exactly what we would want.
		//
		lServerId = _wtoi(pwszServerId);
	}

	return lServerId;
}

/*
 *	LpszAutoDupSz()
 *
 *	Purpose:
 *
 *		Duplicates a string
 */
LPSTR
LpszAutoDupSz (LPCSTR psz)
{
	Assert(psz);
	LPSTR pszDup;
	UINT cb = static_cast<UINT>((strlen(psz) + 1) * sizeof(CHAR));

	pszDup = static_cast<LPSTR>(g_heap.Alloc (cb));
	if (pszDup)
		CopyMemory (pszDup, psz, cb);

	return pszDup;
}
LPWSTR WszDupWsz (LPCWSTR psz)
{
	Assert(psz);
	LPWSTR pszDup;
	UINT cb = static_cast<UINT>((wcslen(psz) + 1) * sizeof(WCHAR));

	pszDup = static_cast<LPWSTR>(g_heap.Alloc (cb));
	if (pszDup)
		CopyMemory (pszDup, psz, cb);

	return pszDup;
}

//	Language to LANGID mapping ------------------------------------------------
//

/*
 *	FLookupLCID()
 *
 *	Purpose:
 *
 *		Looks up a locale identifier given a particular language.
 *
 *	Parameters:
 *
 *		psz			[in]  pointer to the language name
 *		plcid		[out] locale identifier
 *
 *	Returns:
 *
 *		TRUE if a locale identifier for the language is found.  Its
 *		value is returned in plcid.
 */
BOOL
FLookupLCID (LPCSTR psz, ULONG * plcid)
{
	//	Find it in the cache
	//
	*plcid = CLangIDCache::LcidFind (psz);
	return (0 != *plcid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\_davprs.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	_DAVPRS.H
//
//		DAV parser precompiled header
//
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include <_davprs.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\traces.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	TRACES.CPP
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include <_davprs.h>

#include <exo.h>

void InitDavprsTraces()
{
	INIT_TRACE(Actv);
	INIT_TRACE(BodyStream);
	INIT_TRACE(Content);
	INIT_TRACE(Ecb);
	INIT_TRACE(ECBLogging);
	INIT_TRACE(EcbStream);
	INIT_TRACE(Event);
	INIT_TRACE(Lock);
	INIT_TRACE(Method);
	INIT_TRACE(Persist);
	INIT_TRACE(Request);
	INIT_TRACE(Response);
	INIT_TRACE(ScriptMap);
	INIT_TRACE(Transmit);
	INIT_TRACE(Url);
	INIT_TRACE(DavprsDbgHeaders);
	INIT_TRACE(Metabase);

	//	Also init the EXO trace flag.
#ifdef	DBG
	g_fExoDebugTraceOn = GetPrivateProfileInt(gc_szDbgTraces, "ExoDebugTraceOn",
											  FALSE, gc_szDbgIni);
#else	// DBG
#endif	// DBG, else
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\_davprs.h ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	_DAVPRS.H
//
//		DAV parser precompiled header
//
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

//	Disable unnecessary (i.e. harmless) warnings
//
#pragma warning(disable:4100)	//	unref formal parameter (caused by STL templates)
#pragma warning(disable:4127)	//  conditional expression is constant
#pragma warning(disable:4201)	//	nameless struct/union
#pragma warning(disable:4514)	//	unreferenced inline function
#pragma warning(disable:4710)	//	(inline) function not expanded

//	Standard C/C++ headers
//
#include <malloc.h>	// For _alloca declaration ONLY!
#include <limits.h>

//	Windows headers
//
//$HACK!
//
//	Define _WINSOCKAPI_ to keep windows.h from including winsock.h,
//	whose declarations would be redefined in winsock2.h,
//	which is included by iisextp.h,
//	which we include below!
//
#define _WINSOCKAPI_
#include <windows.h>

//	IIS headers
//
#include <httpext.h>

//	Use pragmas to disable the specific level 4 warnings
//	that appear when we use the STL.  One would hope our version of the
//	STL compiles clean at level 4, but alas it doesn't....
#pragma warning(disable:4663)	//	C language, template<> syntax
#pragma warning(disable:4244)	//	return conversion, data loss
#pragma warning(disable:4786)	//	symbol truncated in debug info (turn this one off forever)

// Put STL includes here
#include <list>

// Turn warnings back on
#pragma warning(default:4663)	//	C language, template<> syntax
#pragma warning(default:4244)	//	return conversion, data loss

//	Global DAV subsystem headers
//
#include <autoptr.h>
#include <singlton.h>
#include <align.h>
#include <mem.h>
#include <util.h>
#include <except.h>
#include <caldbg.h>
#include <calrc.h>
#include <davimpl.h>
#include <davmb.h>
#include <nonimpl.h>
#include <ex\cnvt.h>
#include <crc.h>
#include <eventlog.h>
#include <statcode.h>
#include <sz.h>
#include <etag.h>
#include <synchro.h>
#include <profile.h>
#include "traces.h"


//	------------------------------------------------------------------------
//
//	CLASS CInst
//
//		THE one, global instance declataion.  Encapsulates both per process
//		and per thread instance information.
//
class CInstData;
class CInst
{
	HINSTANCE	m_hinst;

public:
#ifdef MINIMAL_ISAPI
	HANDLE				m_hfDummy;
#endif

	//	ACCESSORS
	//
	HINSTANCE Hinst() const { return m_hinst; }

	//	MANIPULATORS
	//
	void PerProcessInit( HINSTANCE hinst );

	CInstData& GetInstData( const IEcb& ecb );
};

extern CInst g_inst;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\traces.h ===
#ifndef _TRACES_H_
#define _TRACES_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	TRACES.H
//
//	.INI file tagged traces
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

DEFINE_TRACE(Actv);
DEFINE_TRACE(BodyStream);
DEFINE_TRACE(Content);
DEFINE_TRACE(Ecb);
DEFINE_TRACE(ECBLogging);
DEFINE_TRACE(EcbStream);
DEFINE_TRACE(Event);
DEFINE_TRACE(Lock);
DEFINE_TRACE(Method);
DEFINE_TRACE(Persist);
DEFINE_TRACE(Request);
DEFINE_TRACE(Response);
DEFINE_TRACE(ScriptMap);
DEFINE_TRACE(Transmit);
DEFINE_TRACE(Url);
DEFINE_TRACE(DavprsDbgHeaders);
DEFINE_TRACE(Metabase);

#define ActvTrace				DO_TRACE(Actv)
#define BodyStreamTrace			DO_TRACE(BodyStream)
#define ContentTrace			DO_TRACE(Content)
#define EcbStreamTrace			DO_TRACE(EcbStream)
#define EcbTrace				DO_TRACE(Ecb)
#define EventTrace				DO_TRACE(Event)
#define LockTrace				DO_TRACE(Lock)
#define MethodTrace				DO_TRACE(Method)
#define PersistTrace			DO_TRACE(Persist)
#define RequestTrace			DO_TRACE(Request)
#define ResponseTrace			DO_TRACE(Response)
#define ScriptMapTrace			DO_TRACE(ScriptMap)
#define TransmitTrace			DO_TRACE(Transmit)
#define UrlTrace				DO_TRACE(Url)
#define DavprsDbgHeadersTrace	DO_TRACE(DavprsDbgHeaders)
#define MBTrace					DO_TRACE(Metabase)

void InitDavprsTraces();

#endif // !defined(_TRACES_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_dbg\caldbg.c ===
/*
 *	C A L D B G . C
 *
 *	Debugging Utilities
 *
 *	Copyright 1993-1997 Microsoft Corporation. All Rights Reserved.
 */

#pragma warning(disable:4206)	/* empty source file */

#ifdef	DBG

#pragma warning(disable:4001)	/* single line comments */
#pragma warning(disable:4001)	/* single line comments */
#pragma warning(disable:4050)	/* different code attributes */
#pragma warning(disable:4100)	/* unreferenced formal parameter */
#pragma warning(disable:4115)	/* named type definition in parentheses */
#pragma warning(disable:4115)	/* named type definition in parentheses */
#pragma warning(disable:4127)	/* conditional expression is constant */
#pragma warning(disable:4201)	/* nameless struct/union */
#pragma warning(disable:4206)	/* translation unit is empty */
#pragma warning(disable:4209)	/* benign typedef redefinition */
#pragma warning(disable:4214)	/* bit field types other than int */
#pragma warning(disable:4514)	/* unreferenced inline function */

#include <windows.h>
#include <objerror.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <time.h>

#include <lmcons.h>
#include <lmalert.h>

#include <caldbg.h>

//	Global debugging indicators -----------------------------------------------
//

//	Values for Assert flags
#define ASSERTFLAG_UNINITIALIZED	0xffffffff
#define ASSERTFLAG_DEFAULT			0x00000000
#define ASSERTFLAG_IF_DEBUGGING		0x00000001
#define ASSERTFLAG_POPUP			0x00000002
#define ASSERTFLAG_KD_SAFE			0x00000004

//	Values for TraceError() settings (these are NOT flags!)
#define TRACEERROR_UNINITIALIZED	0xffffffff
#define TRACEERROR_NONE				0x00000000
#define TRACEERROR_FAILED_SCODE		0x00000001
#define TRACEERROR_NATURAL			0x00000002
#define TRACEERROR_FAILING_EC		0x00000003
#define TRACEERROR_ALWAYS			0x00000004

//	Trace buffer size and popup buffer size
#define TRACE_BUF_SIZE	4096
#define POP_BUF_SIZE	512

static BOOL g_fTraceEnabled			= -1;
static BOOL g_fUseEventLog			= -1;
static BOOL g_fAssertLeaks			= -1;
static DWORD g_dwAssertFlags		= ASSERTFLAG_UNINITIALIZED;
static DWORD g_dwDefaultAssertFlags	= ASSERTFLAG_DEFAULT;
static DWORD g_dwErrorTraceLevel	= TRACEERROR_UNINITIALIZED;


//	Debug strings -------------------------------------------------------------
//
const CHAR gc_szDbgEventLog[]			= "EventLog";
const CHAR gc_szDbgGeneral[]				= "General";
const CHAR gc_szDbgLogFile[]				= "LogFile";
const CHAR gc_szDbgTraces[]				= "Traces";
const CHAR gc_szDbgUseVirtual[]			= "UseVirtual";

const CHAR gc_szDbgDebugTrace[]			= "DebugTrace";
const CHAR gc_szDbgErrorTrace[]			= "Error";
const CHAR gc_szDbgPopupAsserts[]		= "PopupAsserts";
const CHAR gc_szDebugAssert[]			= "Debug Assert";
const CHAR gc_cchDebugAssert			= sizeof(gc_szDebugAssert) - sizeof(CHAR);

//	Debugging routines --------------------------------------------------------
//
typedef	BOOL  (WINAPI *REPORTEVENT)(HANDLE, WORD, WORD, DWORD, PSID, WORD, DWORD, LPCTSTR *, LPVOID);
typedef HANDLE (WINAPI *REGISTEREVENTSOURCEA)(LPCTSTR, LPCTSTR);
typedef NET_API_STATUS (WINAPI *NAREFN)(TCHAR *, ADMIN_OTHER_INFO *, ULONG, TCHAR *);

#define MAX_LINE		256

//	LogIt() -------------------------------------------------------------------
//

VOID
LogIt (LPSTR plpcText, BOOL	fUseAlert)
{
	LPSTR llpcStr[2];
	static HANDLE hEventSource = NULL;
	static REPORTEVENT pfnReportEvent = NULL;
	static REGISTEREVENTSOURCEA pfnRegisterEventSourceA = NULL;

	if (pfnRegisterEventSourceA == NULL)
	{
		//	This handle is not important as the lib will be
		//	freed on exit (and it's debug only)
		//
		HINSTANCE lhLib;

		lhLib = LoadLibraryA("advapi32.dll");
		if (!lhLib)
			return;

		pfnRegisterEventSourceA = (REGISTEREVENTSOURCEA) GetProcAddress(lhLib, "RegisterEventSourceA");
		pfnReportEvent = (REPORTEVENT) GetProcAddress(lhLib, "ReportEventA");
		if (!pfnRegisterEventSourceA || !pfnReportEvent)
			return;
	}

	if (!hEventSource)
		hEventSource = pfnRegisterEventSourceA(NULL, "Caligula Debug");

	llpcStr[0] = "Caligula Debug Log";
	llpcStr[1] = plpcText;

	pfnReportEvent(hEventSource,	/* handle of event source */
		EVENTLOG_ERROR_TYPE,		/* event type			  */
		0,							/* event category		  */
		0,							/* event ID				  */
		NULL,						/* current user's SID	  */
		2,							/* strings in lpszStrings */
		0,							/* no bytes of raw data	  */
		llpcStr,					/* array of error strings */
		NULL);						/* no raw data			  */

	//	The code for raising an alert was taken from code in the
	//	admin tree.  It needs to be UNICODE
	//
	if (fUseAlert)
	{
		BYTE rgb[sizeof(ADMIN_OTHER_INFO) + (sizeof(WCHAR) * MAX_LINE)];
		ADMIN_OTHER_INFO * poi = (ADMIN_OTHER_INFO *) rgb;
		WCHAR *	pch = (WCHAR *)(rgb + sizeof(ADMIN_OTHER_INFO));	/*lint -esym(550,nas) */
		NET_API_STATUS nas;
		WCHAR wsz[MAX_LINE * 3 + 1];
		INT cb, cch;
		static NAREFN fnNetAlertRaiseEx = NULL;

		//	Load the alert library, and as before, unloading is taken
		//	care of when the DLL goes away.
		//
		if (!fnNetAlertRaiseEx)
		{
			HINSTANCE lhLib;

			lhLib = LoadLibrary("NETAPI32.DLL");
			if (!lhLib)
				return;

			fnNetAlertRaiseEx = (NAREFN)GetProcAddress(lhLib, "NetAlertRaiseEx");
			if (!fnNetAlertRaiseEx)
				return;
		}

		poi->alrtad_errcode = (DWORD) -1;
		poi->alrtad_numstrings = 1;

		cb = (INT)(strlen(plpcText));
		if (MAX_LINE * 3 < cb)
			cb = MAX_LINE * 3;
		
		cch = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, plpcText, cb + 1, wsz, MAX_LINE * 3 + 1);
		if (cch)
		{
			cch--;
			if (MAX_LINE <= cch)
				cch  = MAX_LINE - 1;

			memcpy(pch, wsz, cch * sizeof(WCHAR));
			pch[cch] = L'\0';
			nas = fnNetAlertRaiseEx ((TCHAR *)L"ADMIN",
									 poi,
									 sizeof(ADMIN_OTHER_INFO) + (cch + 1) * sizeof(WCHAR),
									 (TCHAR *)L"Caligula Assert");


		}
		
	}
}

//	DebugOutputNoCRLFFn() -----------------------------------------------------
//
void DebugOutputNoCRLFFn(char *psz)
{
	if (g_fTraceEnabled == -1)
	{
		g_fTraceEnabled = GetPrivateProfileIntA (gc_szDbgGeneral,
			gc_szDbgDebugTrace,
			FALSE,
			gc_szDbgIni);

		g_fUseEventLog = GetPrivateProfileIntA (gc_szDbgGeneral,
												gc_szDbgEventLog,
												FALSE,
												gc_szDbgIni);
	}
	if (!g_fTraceEnabled)
		return;

	if (g_fUseEventLog)
		LogIt (psz, FALSE);

	OutputDebugStringA(psz);
}


//	DebugOutputFn() -----------------------------------------------------------
//
void DebugOutputFn(char *psz)
{
	static CHAR szCRLF[] = "\r\n";

	DebugOutputNoCRLFFn(psz);

	//Temporarily disabled until we yank out all the "\n"s from the calling code.
	//OutputDebugStringA(szCRLF);
}


//	DebugTrapFn() -------------------------------------------------------------
//
typedef struct _MBCONTEXT
{
	char *		sz1;
	char *		sz2;
	UINT		rgf;
	int			iResult;

} MBCONTEXT;

DWORD WINAPI
MessageBoxFnThreadMain(MBCONTEXT *pmbc)
{
	if (g_fUseEventLog)
	{
		LogIt (pmbc->sz1, TRUE);
		pmbc->iResult = IDIGNORE;
	}
	else
	{
		pmbc->iResult = MessageBoxA (NULL,
									 pmbc->sz1,
									 pmbc->sz2,
									 pmbc->rgf | MB_SETFOREGROUND);
	}
	return (0);
}

INT
MessageBoxFn(char *sz1, char *sz2, UINT rgf)
{
	HANDLE hThread;
	DWORD dwThreadId;
	MBCONTEXT mbc;

	// To preserve last error over tracing calls
	DWORD dwErr = GetLastError();

	mbc.sz1 = sz1;
	mbc.sz2 = sz2;
	mbc.rgf = rgf;
	mbc.iResult = IDRETRY;

	hThread = CreateThread (NULL,
							0,
							(PTHREAD_START_ROUTINE)MessageBoxFnThreadMain,
							&mbc,
							0,
							&dwThreadId);
	if (hThread != NULL)
	{
		WaitForSingleObject (hThread, INFINITE);
		CloseHandle (hThread);
	}

	SetLastError(dwErr);

	return mbc.iResult;
}

//	------------------------------------------------------------------------
//	DebugTrapFn
//
//	Main Assert/DebugTrap handling routine.
//
//	Meanings of the g_dwAssertFlags:
//
//#define ASSERTFLAG_IF_DEBUGGING	0x00000001
//#define ASSERTFLAG_POPUP			0x00000002
//#define ASSERTFLAG_KD_SAFE		0x00000004
//
//	0 -- (default if no inifile or unrecognized value in inifile)
//		Default behavior -- DebugBreak() and then dump our strings.
//		NOTE: HTTPEXT needs this to remain their default because
//		of the way that IIS runs their stress testing.  DO NOT CHANGE THIS!
//	ASSERTFLAG_IF_DEBUGGING
//		-- use MessageBox asserts only if no debugger attached.
//		Why not use MessageBox everywhere?
//		Because MessageBox lets all the other threads keep going,
//		so we lose some amount of the state of the assert.
//		If this flag is NOT set, or a debugger is NOT connected,
//		we obey the other flags.
//	ASSERTFLAG_POPUP
//		-- use MessageBox asserts.  Our MessageBox has three buttons:
//		Abort,Retry,Ignore do "*(0)=1",DebugBreak,go
//	ASSERTFLAG_KD_SAFE	
//		-- use HardCrash instead of DebugBreak
//		Use hard-av if debugger is attached.
//		(Option for devs with CDB and no KD attached, or for anyone
//		who wants to do ALL their debugging in KD! ;-)
//		Why not just DebugBreak() if a debugger is attached?
//		Because DebugBreak() will catch in the kernel debugger first --
//		so if I have a both kd and cdb hooked up, DebugBreak() will 
//		hit in the kd, even though this is user-mode code.
//
//	Alternate code for IsDebuggerPresent()
//		peb = NtCurrentPeb();
//		if (peb->BeingDebugged) ...
//
INT EXPORTDBG __cdecl
DebugTrapFn (int fFatal, char *pszFile, int iLine, char *pszFormat, ...)
{
	char	sz[POP_BUF_SIZE];
	int cb = POP_BUF_SIZE; 
	const char * pszT;
	int cbT;
	int cbWritten;
	va_list	vl;
	int		id;
	static BOOL s_fBuiltDebugStrings = FALSE;
	static char s_rgchMessageBoxTitle[MAX_PATH];

	// To preserve last error over tracing calls
	DWORD dwErr = GetLastError();

	if (ASSERTFLAG_UNINITIALIZED == g_dwAssertFlags)
	{
		//	Check the ini file.
		//	Pass in our default flags -- if there's no inifile, we'll
		//	get back our default.
		//
		g_dwAssertFlags = GetPrivateProfileIntA (gc_szDbgGeneral,
												 gc_szDbgPopupAsserts,
												 g_dwDefaultAssertFlags,
												 gc_szDbgIni);
	}

	//	Check our static flag to see if we've already built the
	//	title string for our Asserts/DebugTraces.
	//
	if (!s_fBuiltDebugStrings)
	{
		char * pch;
		int cbDebugStrings = MAX_PATH;

		if (gc_cchDbgIni < cbDebugStrings)
		{
			//	Copy including termination 
			//
			memcpy(s_rgchMessageBoxTitle, gc_szDbgIni, gc_cchDbgIni + 1);
			cbDebugStrings -= gc_cchDbgIni;
		}
		else
		{
			//	Copy as much as we can and terminate
			//
			memcpy(s_rgchMessageBoxTitle, gc_szDbgIni, cbDebugStrings - 1);
			s_rgchMessageBoxTitle[MAX_PATH - 1] = '\0';
			cbDebugStrings = 1;
		}
		
		pch = strchr (s_rgchMessageBoxTitle, '.');
		if (pch)
		{
			cbDebugStrings = MAX_PATH - (INT)(pch - s_rgchMessageBoxTitle) - 1;
			*pch = ' ';
		}

		if (gc_cchDebugAssert < cbDebugStrings)
		{
			//	Copy including termination
			//
			memcpy(s_rgchMessageBoxTitle + MAX_PATH - cbDebugStrings, gc_szDebugAssert, gc_cchDebugAssert + 1);
		}
		else
		{
			memcpy(s_rgchMessageBoxTitle + MAX_PATH - cbDebugStrings, gc_szDebugAssert, cbDebugStrings);
			s_rgchMessageBoxTitle[MAX_PATH - 1] = '\0';
		}
		
		s_fBuiltDebugStrings = TRUE;
	}

	//	Build the assert strings and dump the first line
	//
	pszT = "++++ ";
	cbT = sizeof("++++ ") - sizeof(char);
	if (cbT < cb)
	{		
		memcpy(sz, pszT, cbT + 1);
		cb -= cbT;

		cbT = (int)(strlen(s_rgchMessageBoxTitle));
		if (cbT < cb)
		{
			memcpy(sz + POP_BUF_SIZE - cb, s_rgchMessageBoxTitle, cbT + 1);
			cb -= cbT;

			pszT = " (";
			cbT = sizeof(" (") - sizeof(char);
			if (cbT < cb)
			{
				char szDateTime[POP_BUF_SIZE];
				
				memcpy(sz + POP_BUF_SIZE - cb, pszT, cbT + 1);
				cb -= cbT;

				//	POP_BUF_SIZE should always be sufficient for the date
				//
				_strdate	(szDateTime);
				cbT = (int)(strlen(szDateTime));
				if (cbT < cb)
				{
					memcpy(sz + POP_BUF_SIZE - cb, szDateTime, cbT + 1);
					cb -= cbT;

					pszT = " ";
					cbT = sizeof(" ") - sizeof(char);
					if (cbT < cb)
					{
						memcpy(sz + POP_BUF_SIZE - cb, pszT, cbT + 1);
						cb -= cbT;

						//	POP_BUF_SIZE should always be sufficient for the date
						//
						_strtime	(szDateTime);
						cbT = (int)(strlen(szDateTime));
						if (cbT < cb)
						{
							memcpy(sz + POP_BUF_SIZE - cb, szDateTime, cbT + 1);
							cb -= cbT;

							pszT = ")\n";
							cbT = sizeof(")\n") - sizeof(char);
							if (cbT < cb)
							{
								memcpy(sz + POP_BUF_SIZE - cb, pszT, cbT + 1);
							}
						}
					}
				}
			}
		}
	}
	
	DebugOutputFn(sz);

	// Reset the buffer and fill it once more
	//
	cb = POP_BUF_SIZE;

	va_start(vl, pszFormat);
	cbWritten = _vsnprintf(sz, POP_BUF_SIZE, pszFormat, vl);
	va_end(vl);

	if ((-1 == cbWritten) || (POP_BUF_SIZE == cbWritten))
	{
		sz[POP_BUF_SIZE - 1] = '\0';
	}
	else	
	{
		cb -= cbWritten;
		
		cbWritten =  _snprintf(sz + POP_BUF_SIZE - cb, cb, "\n[File %s, Line %d]\n\n", pszFile, iLine);
		if ((-1 == cbWritten) || (cb == cbWritten))
		{
			sz[POP_BUF_SIZE - 1] = '\0';
		}	
	}

	//	Check our assert flags
	//

	//	See if MessageBoxes are desired....
	//
	//	If the "msg-box-if-no-debugger" flag is set,
	//	and there is no debugger -- give 'em message boxes!
	//	If they specifically requested message boxes, give 'em message boxes.
	//
	if (((ASSERTFLAG_IF_DEBUGGING & g_dwAssertFlags) && !IsDebuggerPresent()) ||
		(ASSERTFLAG_POPUP & g_dwAssertFlags))
	{
		//	Use MessageBox asserts
		//
		UINT uiFlags = MB_ABORTRETRYIGNORE;

		if (fFatal)
			uiFlags |= MB_DEFBUTTON1;
		else
			uiFlags |= MB_DEFBUTTON3;

		DebugOutputFn(sz);

		//	Always act as if we are a service (why not?)
		//
		uiFlags |= MB_ICONSTOP | MB_TASKMODAL | MB_SERVICE_NOTIFICATION;
		id = MessageBoxFn (sz, s_rgchMessageBoxTitle, uiFlags);
		if (id == IDABORT)
		{
			*((LPBYTE)NULL) = 0;
		}
		else if (id == IDRETRY)
			DebugBreak();
	}
	else if (ASSERTFLAG_KD_SAFE & g_dwAssertFlags)
	{
		//	Hard-av and then dump our string.
		//
		*((LPBYTE)NULL) = 0;
		DebugOutputFn(sz);
	}
	else
	{
		//	Do the default behavior:
		//	DebugBreak() and then dump our string.
		//
		DebugBreak();
		DebugOutputFn(sz);
	}

	SetLastError(dwErr);

	return 0;
}

//	DebugTraceFn() ------------------------------------------------------------
//
INT EXPORTDBG __cdecl
DebugTraceFn(char *pszFormat, ...)
{	
	char sz[TRACE_BUF_SIZE];
	int cb;
	va_list	vl;

	// To preserve last error over tracing calls
	DWORD dwErr = GetLastError();

	if (*pszFormat == '~')
	{
		pszFormat += 1;
	}

	va_start(vl, pszFormat);
	cb = _vsnprintf(sz, TRACE_BUF_SIZE, pszFormat, vl);
	va_end(vl);

	if ((-1 == cb) || (TRACE_BUF_SIZE == cb))
	{
		sz[TRACE_BUF_SIZE - 1] = '\0';
	}

	DebugOutputFn(sz);

	SetLastError(dwErr);

	return(0);
}

INT EXPORTDBG __cdecl
DebugTraceNoCRLFFn(char *pszFormat, ...)
{	
	char sz[TRACE_BUF_SIZE];
	int cb;
	va_list	vl;

	// To preserve last error over tracing calls
	DWORD dwErr = GetLastError();

	va_start(vl, pszFormat);
	cb = _vsnprintf(sz, TRACE_BUF_SIZE, pszFormat, vl);
	va_end(vl);

	if ((-1 == cb) || (TRACE_BUF_SIZE == cb))
	{
		sz[TRACE_BUF_SIZE - 1] = '\0';
	}

	DebugOutputNoCRLFFn(sz);

	SetLastError(dwErr);

	return(0);
}

INT EXPORTDBG __cdecl
DebugTraceCRLFFn(char *pszFormat, ...)
{	
	char sz[TRACE_BUF_SIZE];
	int cb;
	va_list	vl;

	// To preserve last error over tracing calls
	DWORD dwErr = GetLastError();

	va_start(vl, pszFormat);
	cb = _vsnprintf(sz, TRACE_BUF_SIZE, pszFormat, vl);
	va_end(vl);

	if ((-1 == cb) || (TRACE_BUF_SIZE == cb))
	{
		sz[TRACE_BUF_SIZE - 1] = '\0';
	}


	DebugOutputNoCRLFFn(sz);

	DebugOutputNoCRLFFn("\r\n");

	SetLastError(dwErr);

	return(0);
}


//	TraceErrorFn() ------------------------------------------------------------
//
INT EXPORTDBG __cdecl
TraceErrorFn (DWORD error, char *pszFunction,
				   char *pszFile, int iLine,
				   BOOL fEcTypeError)	// defaults to FALSE
{
	BOOL fTraceIt = FALSE;
	
	if (TRACEERROR_UNINITIALIZED == g_dwErrorTraceLevel)
	{
		g_dwErrorTraceLevel = GetPrivateProfileIntA (gc_szDbgGeneral,
			gc_szDbgErrorTrace,
			FALSE,
			gc_szDbgIni);
	}
	if (TRACEERROR_NONE == g_dwErrorTraceLevel)
		return 0;

	//	Logic for trace error levels:
	//	Error tracing, like all our tracing, is OFF by default.
	//	TRACEERROR_NONE			-- don't trace errors
	//	TRACEERROR_FAILED_SCODE -- trace only if FAILED(error)
	//	TRACEERROR_NATURAL		-- if fEcTypeError, use if (error)
	//							-- if !fEcTypeError, use if (FAILED(error))
	//	TRACEERROR_FAILING_EC	-- trace only if (error)
	//	TRACEERROR_ALWAYS		-- always trace
	//
	switch (g_dwErrorTraceLevel)
	{
	case TRACEERROR_FAILED_SCODE:
		if (FAILED(error))
			fTraceIt = TRUE;
		break;
	case TRACEERROR_FAILING_EC:
		if (0 != error)
			fTraceIt = TRUE;
		break;

	case TRACEERROR_ALWAYS:
		fTraceIt = TRUE;
		break;

	case TRACEERROR_NATURAL:
		if (fEcTypeError)
			fTraceIt = (0 != error);
		else
			fTraceIt = (FAILED(error));
		break;
	default:
		break;
	}

	if (fTraceIt)
	{
		char pszFormat[] = "%hs Error Trace: 0x%08x from function %hs (%hs line %d)\r\n";

		DebugTraceNoCRLFFn (pszFormat, gc_szDbgIni,
							error, pszFunction, pszFile, iLine);
	}

	return 0;
}

#else

#if defined(_AMD64_)

//
// ****** temporary ******
//

int
DebugTrapFn (
    int fFatal,
    char *pszFile,
    int iLine,
    char *pszFormat,
    ...
    )
{
    return 0;
}

int
DebugTraceFn (
    char *pszFormat,
    ...
    )

{
    return 0;
}

int
DebugTraceCRLFFn (
    char *pszFormat,
    ...
    )

{
    return 0;
}

int
DebugTraceNoCRLFFn (
    char *pszFormat,
    ...
    )

{
    return 0;
}

#endif

#endif	//	DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_evntlog\evntlog.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	EVNTLOG.CPP
//
//	Event logging
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include "_evntlog.h"  // Precompiled header

//	_EVNTLOG headers
//
#include <eventlog.h>	// Event logging interface
#include <ex\reg.h>		// Registry access

static DWORD DwCreateAppLogSubkey( LPCWSTR lpwszDllPath, DWORD dwCategories = 0 );
static DWORD DwDeleteAppLogSubkey();
static const WCHAR gsc_wszAppLogRegKey[] =
	L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\";

//	------------------------------------------------------------------------
//
//	DWCreateAppLogSubkey()
//
DWORD
DwCreateAppLogSubkey( LPCWSTR lpwszDllPath, DWORD dwCategories )
{
	CRegKey regkey;
	DWORD dwResult = ERROR_SUCCESS;

	//
	//	Create a key for this source under the application log
	//
	{
		WCHAR lpwszKey[256];

		swprintf( lpwszKey, L"%ls%ls", gsc_wszAppLogRegKey, gc_wszSignature );
		dwResult = regkey.DwCreate( HKEY_LOCAL_MACHINE, lpwszKey );
		if ( ERROR_SUCCESS != dwResult )
		{
			DebugTrace( "DwCreateAppLogSubkey() - Error creating application log registry key (%d)\n", dwResult );
			goto ret;
		}
	}

	//
	//	Set EventMessageFile to the full DLL path
	//
	dwResult = regkey.DwSetValue( L"EventMessageFile",
								  REG_EXPAND_SZ,
								  reinterpret_cast<const BYTE *>(lpwszDllPath),
								  static_cast<DWORD>(sizeof(WCHAR) * (wcslen(lpwszDllPath) + 1)) );

	if ( ERROR_SUCCESS != dwResult )
	{
		DebugTrace( "DwCreateAppLogSubkey() - Error setting EventMessageFile value (%d)\n", dwResult );
		goto ret;
	}

	//
	//	Set TypesSupported -- Error, warning and information only
	//
	{
		DWORD dwTypesSupported = EVENTLOG_ERROR_TYPE |
								 EVENTLOG_WARNING_TYPE |
								 EVENTLOG_INFORMATION_TYPE;

		dwResult = regkey.DwSetValue( L"TypesSupported",
									  REG_DWORD,
									  reinterpret_cast<LPBYTE>(&dwTypesSupported),
									  sizeof(DWORD) );

		if ( ERROR_SUCCESS != dwResult )
		{
			DebugTrace( "DwCreateAppLogSubkey() - Error setting TypesSupported value (%d)\n", dwResult );
			goto ret;
		}
	}

	if (dwCategories)
	{
		//
		//	Set CategoryMessageFile to the full DLL path
		//
		dwResult = regkey.DwSetValue( L"CategoryMessageFile",
									  REG_EXPAND_SZ,
									  reinterpret_cast<const BYTE *>(lpwszDllPath),
									  static_cast<DWORD>(sizeof(WCHAR) * (wcslen(lpwszDllPath) + 1)) );

		if ( ERROR_SUCCESS != dwResult )
		{
			DebugTrace( "DwCreateAppLogSubkey() - Error setting CategoryMessageFile value (%d)\n", dwResult );
			goto ret;
		}

		//
		//	Set CategoryCount (to the specified one)
		//
		{
			dwResult = regkey.DwSetValue( L"CategoryCount",
										  REG_DWORD,
										  reinterpret_cast<LPBYTE>(&dwCategories),
										  sizeof(DWORD) );

			if ( ERROR_SUCCESS != dwResult )
			{
				DebugTrace( "DwCreateAppLogSubkey() - Error setting CategoryCount value (%d)\n", dwResult );
				goto ret;
			}
		}
	}

ret:
	return dwResult;
}

//	------------------------------------------------------------------------
//
//	DwDeleteAppLogSubkey()
//
DWORD
DwDeleteAppLogSubkey()
{
	WCHAR lpwszKey[256];

	swprintf( lpwszKey, L"%ls%ls", gsc_wszAppLogRegKey, gc_wszSignature );
	DWORD dwResult = RegDeleteKeyW( HKEY_LOCAL_MACHINE, lpwszKey );
	if ( dwResult != ERROR_SUCCESS )
		DebugTrace( "FDeleteAppLogSubkey() - RegDeleteKeyW() failed (%d)\n", dwResult );

	return dwResult;
}



//	========================================================================
//
//	PUBLIC INTERFACE
//

//	------------------------------------------------------------------------
//
//	LogEvent()
//
VOID
LogEvent( DWORD    dwEventID,
		  WORD     wEventType,
		  WORD     wcDataStrings,
		  LPCSTR * plpszDataStrings,
		  DWORD    dwcbRawData,
		  LPVOID   lpvRawData,
		  WORD	   wEventCategory )
{
	HANDLE hEventLog = RegisterEventSourceW( NULL, gc_wszSignature );

	if ( NULL != hEventLog )
	{
		if ( !ReportEventA( hEventLog,
							wEventType,
							wEventCategory, // Category
							dwEventID,
							NULL, // Optional security ID
							wcDataStrings,
							dwcbRawData,
							plpszDataStrings,
							lpvRawData ) )
		{
			DebugTrace( "LogEvent() - ReportEventA() failed (%d)\n", GetLastError() );
		}

		if ( !DeregisterEventSource( hEventLog ) )
		{
			DebugTrace( "LogEvent() - DeregisterEventSource() failed (%d)\n", GetLastError() );
		}
	}
	else
	{
		DebugTrace( "LogEvent() - RegisterEventSource() failed (%d)\n", GetLastError() );
	}
}

//	------------------------------------------------------------------------
//
//	LogEventW()
//
VOID
LogEventW( DWORD     dwEventID,
		   WORD      wEventType,
		   WORD      wcDataStrings,
		   LPCWSTR * plpwszDataStrings,
		   DWORD     dwcbRawData,
		   LPVOID    lpvRawData,
		   WORD		 wEventCategory )
{
	HANDLE hEventLog = RegisterEventSourceW( NULL, gc_wszSignature );

	if ( NULL != hEventLog )
	{
		if ( !ReportEventW( hEventLog,
							wEventType,
							wEventCategory, // Category
							dwEventID,
							NULL, // Optional security ID
							wcDataStrings,
							dwcbRawData,
							plpwszDataStrings,
							lpvRawData ) )
		{
			DebugTrace( "LogEventW() - ReportEventW() failed (%d)\n", GetLastError() );
		}

		if ( !DeregisterEventSource( hEventLog ) )
		{
			DebugTrace( "LogEventW() - DeregisterEventSource() failed (%d)\n", GetLastError() );
		}
	}
	else
	{
		DebugTrace( "LogEventW() - RegisterEventSource() failed (%d)\n", GetLastError() );
	}
}

//	------------------------------------------------------------------------
//
//	EventLogDllRegisterServer()
//
STDAPI EventLogDllRegisterServer( LPCWSTR lpwszDllPath, DWORD dwCategories )
{
	return HRESULT_FROM_WIN32(DwCreateAppLogSubkey(lpwszDllPath, dwCategories));
}

//	------------------------------------------------------------------------
//
//	EventLogDllUnregisterServer()
//
STDAPI EventLogDllUnregisterServer()
{
	return HRESULT_FROM_WIN32(DwDeleteAppLogSubkey());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_davprs\url.cpp ===
/*
 *	U R L . C P P
 *
 *	Url normalization/canonicalization
 *
 *	Stolen from the IIS5 project 'iis5\svcs\iisrlt\string.cxx' and
 *	cleaned up to fit in with the DAV sources.
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davprs.h"
#include "xemit.h"

//	URI Escaping --------------------------------------------------------------
//
//	gc_mpbchCharToHalfByte - map a ASCII-encoded char representing a single hex
//	digit to a half-byte value.  Used to convert hex represented strings into a
//	binary representation.
//
//	Reference values:
//
//		'0' = 49, 0x31;
//		'A' = 65, 0x41;
//		'a' = 97, 0x61;
//
DEC_CONST BYTE gc_mpbchCharToHalfByte[] =
{
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,	0x8,0x9,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0xa,0xb,0xc,0xd,0xe,0xf,0x0,	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,	// Caps here.
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0xa,0xb,0xc,0xd,0xe,0xf,0x0,	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,	// Lowercase here.
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
};

//	Switches a wide char to a half-byte hex value.  The incoming char
//	MUST be in the "ASCII-encoded hex digit" range: 0-9, A-F, a-f.
//
inline BYTE
BCharToHalfByte(WCHAR wch)
{
    AssertSz (!(wch & 0xFF00), "BCharToHalfByte: char upper bits non-zero");
    AssertSz (iswxdigit(wch), "BCharToHalfByte: Char out of hex digit range.");

    return gc_mpbchCharToHalfByte[wch];
};

//	gc_mpwchhbHalfByteToChar - map a half-byte (low nibble) value to the
//	correspoding ASCII-encoded wide char.  Used to convert a single byte
//	into a hex string representation.
//
const WCHAR gc_mpwchhbHalfByteToChar[] =
{
    L'0', L'1', L'2', L'3',
    L'4', L'5', L'6', L'7',
    L'8', L'9', L'A', L'B',
    L'C', L'D', L'E', L'F',
};

//	Switches a half-byte to an ACSII-encoded wide char.
//	NOTE: The caller must mask out the "other half" of the byte!
//
inline WCHAR WchHalfByteToWideChar(BYTE b)
{
    AssertSz (!(b & 0xF0), "WchHalfByteToWideChar: byte upper bits non-zero.");

    return gc_mpwchhbHalfByteToChar[b];
};

//	gc_mpchhbHalfByteToChar - map a half-byte (low nibble) value to the
//	correspoding ASCII-encoded wide char.  Used to convert a single byte
//	into a hex string representation.
//
const CHAR gc_mpchhbHalfByteToChar[] =
{
    '0', '1', '2', '3',
    '4', '5', '6', '7',
    '8', '9', 'A', 'B',
    'C', 'D', 'E', 'F',
};

//	Switches a half-byte to an ACSII-encoded wide char.
//	NOTE: The caller must mask out the "other half" of the byte!
//
inline CHAR ChHalfByteToWideChar(BYTE b)
{
    AssertSz (!(b & 0xF0), "ChHalfByteToWideChar: byte upper bits non-zero.");

	return gc_mpchhbHalfByteToChar[b];
};


//	Note on HttpUriEscape and HttpUriUnescape
//
//	These functions do the HTTP URL escaping and Unescaping equivalent to
//	the one done by IIS. DAVEX URLs are escaped and unescaped thru a different
//	sets of routines in _urlesc subsystem. The rule is whenever we sent out
//	an Exchange HTTP wire URL, you should go thru the function in the
//	_urlesc. Right now old UrlEscape and UrlUnescape routines are routed
//	through those. However there exist cases where we need to do the
//	IIS style escape and unescape. One scenario is when we forward the
//	URLs to ISAPIs, where we use the HttpUriUnescape and HttpUriEscape functions.
//	File system DAV also uses HttpUriEscape and HttpUriUnescape.
//
//	HttpUriEscape()
//
//	This function is immigrated from iis5\svcs\w3\server\dirlist.cpp's
//	We should do the same URL escaping as IIS does.
//
//	Replaces all "bad" characters with their ASCII hex equivalent
//
VOID __fastcall HttpUriEscape (
	/* [in] */ LPCSTR pszSrc,
	/* [out] */ auto_heap_ptr<CHAR>& pszDst)
{
	enum { URL_BUF_INCREMENT = 16 };

	//	It is important that we operate on unsigned character, as otherwise
	//	checks below simply do not work correctly. E.g. UTF-8 characters will
	//	not get escaped, etc.
	//
    UCHAR uch;

	UINT cbDst;
	UINT cbSrc;
	UINT ibDst;
	UINT ibSrc;

	//	Set cbSrc to account for the string length of
	//	the url including the NULL
	//
	Assert(pszSrc);
    cbSrc = static_cast<UINT>(strlen (pszSrc) + 1);

	//	Allocate enough space for the expanded url -- and
	//	lets be a bit optimistic
	//
	cbDst = max (cbSrc + URL_BUF_INCREMENT, MAX_PATH);
    pszDst = static_cast<LPSTR>(g_heap.Alloc(cbDst));

	for (ibSrc = 0, ibDst = 0; ibSrc < cbSrc; ibSrc++)
    {
    	uch = pszSrc[ibSrc];

		//	Make sure we always have space to expand this character.
		//	Since we have allocated extra space to begin with, we should
		//	never have the scenario where we do a realloc just for the
		//	last char.
		//
		if (ibDst + 2 >= cbDst)		// enough space for three more chars
		{
			//	Destiniation buffer is not large enough, reallocate
			//	to get more space.
			//
			cbDst += URL_BUF_INCREMENT;
			pszDst.realloc (cbDst);
		}

        //  Escape characters that are in the non-printable range
        //  but ignore CR and LF.
		//
		//	The inclusive ranges escaped are...
		//
		//	0x01 - 0x20		/* First non-printable range */
		//	0x80 - 0xBF		/* Trailing bytes of UTF8 sequence */
		//	0xC0 - 0xDF		/* Leading byte of UTF8 two byte sequence */
		//	0xE0 - 0xEF		/* Leading byte of UTF8 three byte sequence */
        //
        if ((((uch >= 0x01) && (uch <= 0x20)) /* First non-printable range */ ||
			 ((uch >= 0x80) && (uch <= 0xEF))	/* UTF8 sequence bytes */ ||
			 (uch == '%') ||
			 (uch == '?') ||
			 (uch == '+') ||
			 (uch == '&') ||
			 (uch == '#')) &&
			!(uch == '\n' || uch == '\r'))
        {
            //  Insert the escape character
            //
            pszDst[ibDst + 0] = '%';

            //  Convert the low then the high character to hex
            //
            BYTE bDigit = static_cast<BYTE>(uch % 16);
            pszDst[ibDst + 2] = ChHalfByteToWideChar (bDigit);
            bDigit = static_cast<BYTE>((uch/16) % 16);
            pszDst[ibDst + 1] = ChHalfByteToWideChar (bDigit);

			//	Adjust for the two extra characters for this sequence
			//
            ibDst += 3;
        }
        else
		{
            pszDst[ibDst] = uch;
			ibDst += 1;
		}
    }

	UrlTrace ("Url: UriEscape(): escaped url: %hs\n", pszDst.get());
	return;
}

//	HttpUriUnescape()
//
//	This function is immigrated from iis5\svcs\w3\server\dirlist.cpp's
//	We should do the same URL unescaping as IIS does.
//
//	Replaces all escaped characters with their byte equivalent
//
//
VOID __fastcall HttpUriUnescape (
	/* [in] */ const LPCSTR pszUrl,
	/* [out] */ LPSTR pszUnescaped)
{
	LPCSTR	pch;
	LPSTR	pchNew;

	Assert (pszUrl);
	Assert (pszUnescaped);

	pch = pszUrl;
	pchNew = pszUnescaped;

	while (*pch)
	{
		//	If this is a valid byte-stuffed character, unpack it.  For us
		//	to really unpack it, we need the sequence to be valid.
		//
		//	NOTE: we stole this code from IIS at one point, so we are
		//	pretty sure this is consistant with their behavior.
		//
		if  (('%' == pch[0]) &&
			 ('\0' != pch[1]) &&
			 ('\0' != pch[2]) &&
			 isxdigit(pch[1]) &&
			 isxdigit(pch[2]))
		{

#pragma warning(disable:4244)

			//	IMPORTANT: when we do this processing, there is no specific
			//	machine/byte ordering assumed.  The HEX digit is represented
			//	as a %xx, and the first char is multiplied by sixteen and
			//	then second char is added in.
			//
			UrlTrace ("HttpUriEscape () - unescaping: %hc%hc%hc\n", pch[0], pch[1], pch[2]);
			*pchNew = (BCharToHalfByte(pch[1]) * 16) + BCharToHalfByte(pch[2]);
			pch += 3;

#pragma warning(default:4244)

		}
		else
		{
		     *pchNew = *pch++;
		}

		//	If a NULL character was byte-stuffed, then that is the end of
		//	the url and we can stop processing now. Otherwise, path modifications
		//	could be used to bypass a NULL.
		//
		if ('\0' == *pchNew)
		{
			break;
		}

		pchNew++;
	}

    //	Close the new URI
    //
    *pchNew = '\0';

	UrlTrace ("HttpUriEscape() - resulting destination: \"%hs\"\n", pszUnescaped);
}

//	Prefix stripping ----------------------------------------------------------
//
SCODE __fastcall
ScStripAndCheckHttpPrefix (
	/* [in] */ const IEcb& ecb,
	/* [in/out] */ LPCWSTR * ppwszRequest)
{
	SCODE sc = S_OK;

	Assert (ppwszRequest);
	Assert (*ppwszRequest);
	LPCWSTR pwszRequest = *ppwszRequest;

	//	See if the servername matches
	//
	LPCWSTR pwsz;
	UINT cch;

	//	If the forward request URI is fully qualified, strip it to
	//	an absolute URI
	//
	cch = ecb.CchUrlPrefixW (&pwsz);
	if (!_wcsnicmp (pwsz, pwszRequest, cch))
	{
		pwszRequest += cch;
		cch = ecb.CchGetServerNameW (&pwsz);
		if (_wcsnicmp (pwsz, pwszRequest, cch))
		{
			sc = E_DAV_BAD_DESTINATION;
			DebugTrace ("ScStripAndCheckHttpPrefix(): server does not match 0x%08lX\n", sc);
			goto ret;
		}

		//	If the server name matched, make sure that if the
		//	next thing is a port number that it is ":80".
		//
		pwszRequest += cch;
		if (*pwszRequest == L':')
		{
			cch = ecb.CchUrlPortW (&pwsz);
			if (_wcsnicmp (pwsz, pwszRequest, cch))
			{
				sc = E_DAV_BAD_DESTINATION;
				DebugTrace ("ScStripAndCheckHttpPrefix(): port does not match 0x%08lX\n", sc);
				goto ret;
			}
			pwszRequest += cch;
		}
	}

	*ppwszRequest = pwszRequest;

ret:

	return sc;
}

LPCWSTR __fastcall
PwszUrlStrippedOfPrefix (
	/* [in] */ LPCWSTR pwszUrl)
{
	Assert (pwszUrl);

	//	Skip past the "http://" of the url
	//
	if (L'/' != *pwszUrl)
	{
		//	If the first slash occurance is a double slash, then
		//	move past the end of it.
		//
		LPWSTR pwszSlash = wcschr (pwszUrl, L'/');
		while (pwszSlash && (L'/' == pwszSlash[1]))
		{
			//	Skip past the host/server name
			//
			pwszSlash += 2;
			while (NULL != (pwszSlash = wcschr (pwszSlash, L'/')))
			{
				UrlTrace ("Url: PwszUrlStrippedOfPrefix(): normalizing: "
						  "skipping %d chars of '%S'\n",
						  pwszSlash - pwszUrl,
						  pwszUrl);

				pwszUrl = pwszSlash;
				break;
			}
			break;
		}
	}

	return pwszUrl;
}

//	Storage path to UTF8 url translation --------------------------------------
//
SCODE __fastcall
ScUTF8UrlFromStoragePath (
	/* [in]     */ const IEcbBase &	ecb,
	/* [in]     */ LPCWSTR			pwszPath,
	/* [out]    */ LPSTR			pszUrl,
	/* [in/out] */ UINT			  *	pcbUrl,
	/* [in]		*/ LPCWSTR			pwszServer)
{
	CStackBuffer<WCHAR,MAX_PATH> pwszUrl;
	SCODE sc = S_OK;
	UINT cbUrl;
	UINT cchUrl;

	//	Assume one skinny character will be represented by one wide character,
	//	Note that callers are indicating available space including 0 termination.
	//
	cchUrl = *pcbUrl;
	if (!pwszUrl.resize(cchUrl * sizeof(WCHAR)))
		return E_OUTOFMEMORY;

	sc = ScUrlFromStoragePath (ecb,
							   pwszPath,
							   pwszUrl.get(),
							   &cchUrl,
							   pwszServer);
	if (S_FALSE == sc)
	{
		if (!pwszUrl.resize(cchUrl * sizeof(WCHAR)))
			return E_OUTOFMEMORY;

		sc = ScUrlFromStoragePath (ecb,
								   pwszPath,
								   pwszUrl.get(),
								   &cchUrl,
								   pwszServer);
	}
	if (S_OK != sc)
	{
		//	There is no reason to fail because for being short of buffer - we gave as
		//	much as we were asked for
		//
		Assert(S_FALSE != sc);
		DebugTrace( "ScUrlFromStoragePath() - ScUrlFromStoragePath() failed 0x%08lX\n", sc );
		goto ret;
	}

	//	Find out the length of buffer needed for the UTF-8
	//	version of the URL. Functions above return the length
	//	including '\0' termination, so number of charasters
	//	to convert will always be more than zero.
	//
	Assert(0 < cchUrl);
	cbUrl = WideCharToMultiByte(CP_UTF8,
								0,
								pwszUrl.get(),
								cchUrl,
								NULL,
								0,
								NULL,
								NULL);
	if (0 == cbUrl)
	{
		sc = HRESULT_FROM_WIN32(GetLastError());
		DebugTrace( "ScUTF8UrlFromStoragePath() - WideCharToMultiByte() failed 0x%08lX\n", sc );
		goto ret;
	}

	if (*pcbUrl < cbUrl)
	{
		sc = S_FALSE;
		*pcbUrl = cbUrl;
		goto ret;
	}
	else
	{
		//	Convert the URL to skinny including 0 termination
		//
		cbUrl = WideCharToMultiByte( CP_UTF8,
									 0,
									 pwszUrl.get(),
									 cchUrl,
									 pszUrl,
									 cbUrl,
									 NULL,
									 NULL);
		if (0 == cbUrl)
		{
			sc = HRESULT_FROM_WIN32(GetLastError());
			DebugTrace( "ScUrlFromStoragePath() - WideCharToMultiByte() failed 0x%08lX\n", sc );
			goto ret;
		}

		*pcbUrl = cbUrl;
	}

ret:

	if (FAILED(sc))
	{
		//	Zero out the return in the case of failure
		//
		*pcbUrl = 0;
	}
	return sc;
}

//	Redirect url construction -------------------------------------------------
//
SCODE __fastcall
ScConstructRedirectUrl (
	/* [in] */ const IEcb& ecb,
	/* [in] */ BOOL fNeedSlash,
	/* [out] */ LPSTR * ppszUrl,
	/* [in] */ LPCWSTR pwszServer )
{
	SCODE sc;

	auto_heap_ptr<CHAR> pszEscapedUrl;	//	We will need to escape the url we construct, so we will store it there

	CStackBuffer<CHAR,MAX_PATH> pszLocation;
	LPCSTR	pszQueryString;
	UINT	cchQueryString;
	LPCWSTR	pwsz;
	UINT	cch;

	//	This request needs to be redirected.  Allocate
	//	enough space for the URI and an extra trailing
	//	slash and a null terminator.
	//
	pwsz = ecb.LpwszPathTranslated();
	pszQueryString = ecb.LpszQueryString();
	cchQueryString = static_cast<UINT>(strlen(pszQueryString));

	//	Make a best guess. We allow for additional trailing '/'
	//	here (thus we show one character less than we actually
	//	have to the functions bellow).
	//
	cch = pszLocation.celems() - 1;
	sc = ::ScUTF8UrlFromStoragePath (ecb,
									 pwsz,
									 pszLocation.get(),
									 &cch,
									 pwszServer);
	if (S_FALSE == sc)
	{
		//	Try again. Also do not forget that we may
		//	add trailing '/' later, thus allow space for
		//	it too.
		//
		if (!pszLocation.resize(cch + 1))
			return E_OUTOFMEMORY;

		sc = ::ScUTF8UrlFromStoragePath (ecb,
										 pwsz,
										 pszLocation.get(),
										 &cch,
										 pwszServer);
	}
	if (S_OK != sc)
	{
		//	We gave sufficient space, we must not be asked for more
		//
		Assert(S_FALSE != sc);
		DebugTrace("ScConstructRedirectUrl() - ScUTF8UrlFromStoragePath() failed with error 0x%08lX\n", sc);
		goto ret;
	}

	//	The translation above results in a URI that does not
	//	have a trailing slash.  So if one is required, do that
	//	here.
	//
	//	The value of cch at this point includes the
	//	null-termination character.  So we need to look
	//	back two characters instead of one.
	//
	//$	DBCS: Since we are always spitting back UTF8, I don't think
	//	forward-slash characters are likely to be an issue here.  So
	//	there should be no need for a DBCS lead byte check to determine
	//	if a slash is required.
	//
	Assert (0 == pszLocation[cch - 1]);
	if (fNeedSlash && ('/' != pszLocation[cch - 2]))
	{
		pszLocation[cch - 1] = '/';
		pszLocation[cch] = '\0';
	}
	//
	//$ DBCS: end.

	//	Escape the URL
	//
	HttpUriEscape (pszLocation.get(), pszEscapedUrl);

	//	Copy the query string if we have got one
	//
	if (cchQueryString)
	{
		cch = static_cast<UINT>(strlen(pszEscapedUrl.get()));
		pszEscapedUrl.realloc(cch + cchQueryString + 2);	//	One for the '?' and one for zero termination.

		pszEscapedUrl[cch] = '?';
		memcpy(pszEscapedUrl.get() + cch + 1, pszQueryString, cchQueryString);
		pszEscapedUrl[cch + 1 + cchQueryString] = '\0';
	}
	*ppszUrl = pszEscapedUrl.relinquish();

ret:

	return sc;
}

//	Virtual roots -------------------------------------------------------------
//
/*
 *	FIsVRoot()
 *
 *	Purpose:
 *
 *		Returns TRUE iif the specified URI is the VRoot
 *
 *	Parameters:
 *
 *		pmu			[in]  method utility function
 *		pszURI		[in]  URI to check
 */
BOOL __fastcall
CMethUtil::FIsVRoot (LPCWSTR pwszURI)
{
	LPCWSTR pwsz;
	LPCWSTR pwszUnused;

	Assert(pwszURI);
	UINT cch = static_cast<UINT>(wcslen (pwszURI));

	//	The virtual root as determined by CchGetVirtualRoot(),
	//	will truncate the trailing slash, if any.
	//
	pwsz = pwszURI + (cch ? cch - 1 : 0);
	if (L'/' == *pwsz)
	{
		cch -= 1;
	}

	return (cch == CchGetVirtualRootW(&pwszUnused));
}

//	Path conflicts ------------------------------------------------------------
//
BOOL __fastcall
FSizedPathConflict (
	/* [in] */ LPCWSTR pwszSrc,
	/* [in] */ UINT cchSrc,
	/* [in] */ LPCWSTR pwszDst,
	/* [in] */ UINT cchDst)
{
	//	For which ever path is shorter, see if it is
	//	a proper subdir of the longer.
	//
	if ((0 == cchSrc) || (0 == cchDst))
	{
		DebugTrace ("Dav: Url: FSizedPathConflict(): zero length path is "
					"always in conflict!\n");
		return TRUE;
	}
	if (cchDst < cchSrc)
	{
		//	When the destination is shorter, if the paths
		//	match up to the full length of the destination
		//	and the last character or the one immediately
		//	following the destination is a backslash, then
		//	the paths are conflicting.
		//
		if (!_wcsnicmp (pwszSrc, pwszDst, cchDst))
		{
			if ((L'\\' == *(pwszDst + cchDst - 1)) ||
				(L'\\' == *(pwszSrc + cchDst)) ||
				//$$DAVEX BUG: We could get here in a case where we have:
				//	pwszSrc  = \\.\ExchangeIfs\Private Folders/this/is/my/path
				//	pwszDest = \\.\ExchangeIfs\Private Folders
				//	The two comparisons above balk on this.  Add the two
				//	comparisons below to handle this case properly.
				(L'/'  == *(pwszDst + cchDst - 1)) ||
				(L'/'  == *(pwszSrc + cchDst)))
			{
				DebugTrace ("Dav: Url: FSizedPathConflict(): destination is "
							"parent to source\n");
				return TRUE;
			}
		}
	}
	else if (cchSrc < cchDst)
	{
		//	When the source is shorter, if the paths
		//	match up to the full length of the source
		//	and the last character or the one immediately
		//	following the source is a backslash, then
		//	the paths are conflicting.
		//
		if (!_wcsnicmp (pwszSrc, pwszDst, cchSrc))
		{
			if ((L'\\' == *(pwszSrc + cchSrc - 1)) ||
				(L'\\' == *(pwszDst + cchSrc)) ||
				//$$DAVEX BUG: We could get here in a case where we have:
				//	pwszSrc  = \\.\ExchangeIfs\Private Folders/this/is/my/path
				//	pwszDest = \\.\ExchangeIfs\Private Folders
				//	The two comparisons above balk on this.  Add the two
				//	comparisons below to handle this case properly.
				(L'/'  == *(pwszSrc + cchSrc - 1)) ||
				(L'/' == *(pwszDst + cchSrc)))
			{
				DebugTrace ("Dav: Url: FSizedPathConflict(): source is parent "
							"to destination\n");
				return TRUE;
			}
		}
	}
	else
	{
		//	If the paths are the same length, and are infact
		//	equal, why do anything?
		//
		if (!_wcsicmp (pwszSrc, pwszDst))
		{
			DebugTrace ("Dav: Url: FSizedPathConflict(): source and "
						"destination refer to same\n");
			return TRUE;
		}
	}
	return FALSE;
}

BOOL __fastcall
FPathConflict (
	/* [in] */ LPCWSTR pwszSrc,
	/* [in] */ LPCWSTR pwszDst)
{
	Assert (pwszSrc);
	Assert (pwszDst);

	UINT cchSrc = static_cast<UINT>(wcslen (pwszSrc));
	UINT cchDst = static_cast<UINT>(wcslen (pwszDst));

	return FSizedPathConflict (pwszSrc, cchSrc, pwszDst, cchDst);
}

BOOL __fastcall
FIsImmediateParentUrl (LPCWSTR pwszParent, LPCWSTR pwszChild)
{
	LPCWSTR pwsz;

	Assert(pwszChild);
	UINT cchChild = static_cast<UINT>(wcslen (pwszChild));
	UINT cchMatch;

	//	Skip back from the end of the child until the last
	//	path segment has been reached
	//
	pwsz = pwszChild + cchChild - 1;

	//	Child may terminate in a slash, trim it if need be
	//
	if (*pwsz == L'/')
	{
		--pwsz;
	}

	//	Ok, now we can try and isolate the last segment
	//
	for (; pwsz > pwszChild; --pwsz)
	{
		if (*pwsz == L'/')
		{
			break;
		}
	}

	//	See if the parent and child match up to this point
	//
	cchMatch = static_cast<UINT>(pwsz - pwszChild);
	if (!_wcsnicmp (pwszParent, pwszChild, cchMatch))
	{
		//	Make sure that the parent doesn't trail off onto another
		//	branch of the tree, and yes these asserts are DBCS correct.
		//
		Assert ((*(pwszParent + cchMatch) == L'\0') ||
				((*(pwszParent + cchMatch) == L'/') &&
				 (*(pwszParent + cchMatch + 1) == L'\0')));

		return TRUE;
	}

	return FALSE;
}

SCODE
ScAddTitledHref (CEmitterNode& enParent,
				 IMethUtil * pmu,
				 LPCWSTR pwszTag,
				 LPCWSTR pwszPath,
				 BOOL fCollection,
				 CVRoot* pcvrTranslate)
{
	auto_heap_ptr<CHAR> pszUriEscaped;
	CEmitterNode en;
	SCODE sc = S_OK;

	//	Just see if we have the path and tag to process
	//
	Assert(pwszTag);
	Assert(pwszPath);

	sc = ScWireUrlFromStoragePath (pmu,
								   pwszPath,
								   fCollection,
								   pcvrTranslate,
								   pszUriEscaped);
	if (FAILED (sc))
		goto ret;

	sc = enParent.ScAddUTF8Node (pwszTag, en, pszUriEscaped.get());
	if (FAILED (sc))
		goto ret;

ret:

	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_dbg\vmem.c ===
/*
 *	V M E M . C
 *
 *	Virtual Memory Utilities
 *
 *	Copyright 1993-1997 Microsoft Corporation. All Rights Reserved.
 */

#pragma warning(disable:4206)	/* empty source file */

#if defined(DBG) && defined(_X86_)

#pragma warning(disable:4001)	/* single line comments */
#pragma warning(disable:4001)	/* single line comments */
#pragma warning(disable:4050)	/* different code attributes */
#pragma warning(disable:4100)	/* unreferenced formal parameter */
#pragma warning(disable:4115)	/* named type definition in parentheses */
#pragma warning(disable:4115)	/* named type definition in parentheses */
#pragma warning(disable:4127)	/* conditional expression is constant */
#pragma warning(disable:4201)	/* nameless struct/union */
#pragma warning(disable:4206)	/* translation unit is empty */
#pragma warning(disable:4209)	/* benign typedef redefinition */
#pragma warning(disable:4214)	/* bit field types other than int */
#pragma warning(disable:4514)	/* unreferenced inline function */

#include <windows.h>
#include <caldbg.h>

#define PAGE_SIZE		4096
#define PvToVMBase(pv)	((void *)((ULONG)pv & 0xFFFF0000))

static BOOL VMValidatePvEx(VOID *pv, ULONG cbCluster)
{
	VOID *	pvBase;
	BYTE *	pb;

	pvBase = PvToVMBase(pv);
	pb = (BYTE *)pvBase + sizeof(ULONG);
	while (pb < (BYTE *)pv)
	{
		if (*pb++ != 0xAD)
		{
			TrapSz("VMValidatePvEx: Block leader overwrite");
			return(FALSE);
		}
	}

	if (cbCluster != 1)
	{
		ULONG cb = *((ULONG *)pvBase);
		ULONG cbPad = 0;

		if (cb % cbCluster)
			cbPad = (cbCluster - (cb % cbCluster));

		if (cbPad)
		{
			BYTE *pbMac;

			pb = (BYTE *)pv + cb;
			pbMac = pb + cbPad;

			while (pb < pbMac)
			{
				if (*pb++ != 0xBC)
				{
					TrapSz("VMValidatePvEx: Block trailer overwrite");
					return(FALSE);
				}
			}
		}
	}

	return(TRUE);
}

VOID * EXPORTDBG __cdecl VMAlloc(ULONG cb)
{
	return VMAllocEx(cb, 1);
}

VOID * EXPORTDBG __cdecl VMAllocEx(ULONG cb, ULONG cbCluster)
{
	ULONG	cbAlloc;
	VOID *	pvR;
	VOID *	pvC;
	ULONG 	cbPad	= 0;

	// a cluster size of 0 means don't use the virtual allocator.

	AssertSz(cbCluster != 0, "Cluster size is zero.");

	if (cb > 0x100000)
		return(0);

	if (cb % cbCluster)				/*lint !e414*/
		cbPad = (cbCluster - (cb % cbCluster));

	cbAlloc	= sizeof(ULONG) + cb + cbPad + PAGE_SIZE - 1;
	cbAlloc -= cbAlloc % PAGE_SIZE;
	cbAlloc	+= PAGE_SIZE;

	pvR = VirtualAlloc(0, cbAlloc, MEM_RESERVE, PAGE_NOACCESS);

	if (pvR == 0)
		return(0);

	pvC = VirtualAlloc(pvR, cbAlloc - PAGE_SIZE, MEM_COMMIT, PAGE_READWRITE);

	if (pvC != pvR)
	{
		VirtualFree(pvR, 0, MEM_RELEASE);	/*lint !e534*/
		return(0);
	}

	*(ULONG *)pvC = cb;

	memset((BYTE *)pvC + sizeof(ULONG), 0xAD,
		(UINT) cbAlloc - cb - cbPad - sizeof(ULONG) - PAGE_SIZE);

	if (cbPad)
		memset((BYTE *)pvC + cbAlloc - PAGE_SIZE - cbPad, 0xBC,
			(UINT) cbPad);

	return((BYTE *)pvC + (cbAlloc - cb - cbPad - PAGE_SIZE));
}

VOID EXPORTDBG __cdecl VMFree(VOID *pv)
{
	VMFreeEx(pv, 1);
}

VOID EXPORTDBG __cdecl VMFreeEx(VOID *pv, ULONG cbCluster)
{	/*lint -save -e534*/
	VMValidatePvEx(pv, cbCluster);	/*lint -restore*/

	if (!VirtualFree(PvToVMBase(pv), 0, MEM_RELEASE))
	{
		TrapSz("VMFreeEx: VirtualFree failed");
		GetLastError();
	}
}

VOID * EXPORTDBG __cdecl VMRealloc(VOID *pv, ULONG cb)
{
	return VMReallocEx(pv, cb, 1);
}

VOID * EXPORTDBG __cdecl VMReallocEx(VOID *pv, ULONG cb, ULONG cbCluster)
{
	VOID *	pvNew = 0;
	ULONG	cbCopy;
	/*lint -save -e534*/
	VMValidatePvEx(pv, cbCluster); /*lint -restore*/

	cbCopy = *(ULONG *)PvToVMBase(pv);
	if (cbCopy > cb)
		cbCopy = cb;

	pvNew = VMAllocEx(cb, cbCluster);

	if (pvNew)
	{
		memcpy(pvNew, pv, cbCopy);
		VMFreeEx(pv, cbCluster);
	}

	return(pvNew);
}

ULONG EXPORTDBG __cdecl VMGetSize(VOID *pv)
{
	return VMGetSizeEx(pv, 1);
}

/*lint -save -e715*/
ULONG EXPORTDBG __cdecl VMGetSizeEx(VOID *pv, ULONG cbCluster)
{
	return (*(ULONG *)PvToVMBase(pv));
} /*lint -restore*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_evntlog\_evntlog.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	_EVNTLOG.H
//
//		EVNTLOG precompiled header
//
//
//	Copyright 1986-1998 Microsoft Corporation, All Rights Reserved
//

#include "_evntlog.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_except\_except.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	_EXCEPT.H
//
//		EXCEPT precompiled header
//
//
//	Copyright 1986-1998 Microsoft Corporation, All Rights Reserved
//

#include "_except.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_evntlog\_evntlog.h ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	_EVNTLOG.H
//
//		EVNTLOG precompiled header
//
//
//	Copyright 1986-1998 Microsoft Corporation, All Rights Reserved
//

#ifndef __EVNTLOG_H_
#define __EVNTLOG_H_

//	Disable unnecessary (i.e. harmless) warnings
//
#pragma warning(disable:4100)	//	unref formal parameter (caused by STL templates)
#pragma warning(disable:4127)	//  conditional expression is constant */
#pragma warning(disable:4201)	//	nameless struct/union
#pragma warning(disable:4514)	//	unreferenced inline function
#pragma warning(disable:4710)	//	(inline) function not expanded

//$	RAID: 574486: This changes the behaviors for HRESULT_FROM_WIN32 such 
//	that if the param is a function call, the value is not evaluated multiple times.
//
#define INLINE_HRESULT_FROM_WIN32
//
//$	RAID: 574486: end.

//	Windows headers
//
#include <windows.h>

//	CRT headers
//
#include <malloc.h>	// For _alloca()
#include <wchar.h>	// For swprintf()

#endif // !defined(__EVNTLOG_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_except\_except.h ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	_EXCEPT.H
//
//		EXCEPT precompiled header
//
//
//	Copyright 1986-1998 Microsoft Corporation, All Rights Reserved
//

#ifndef __EXCEPT_H_
#define __EXCEPT_H_

//	Disable unnecessary (i.e. harmless) warnings
//
#pragma warning(disable:4100)	//	unref formal parameter (caused by STL templates)
#pragma warning(disable:4127)	//  conditional expression is constant */
#pragma warning(disable:4201)	//	nameless struct/union
#pragma warning(disable:4514)	//	unreferenced inline function
#pragma warning(disable:4710)	//	(inline) function not expanded

//	Windows headers
//
#include <windows.h>

//	_EXCEPT headers
//
#include <except.h> // Exception throwing/handling interfaces

#endif // !defined(__EXCEPT_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_except\except.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	EXCEPT.CPP
//
//		Exception classes used by this implementation
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include <_except.h>


//	========================================================================
//
//	CLASS CWin32ExceptionHandler
//

//	------------------------------------------------------------------------
//
//	CWin32ExceptionHandler::CWin32ExceptionHandler()
//
//	Exception handler constructor.  Just installs our exception handler,
//	saving off the old one for restoration by the destructor.
//
CWin32ExceptionHandler::CWin32ExceptionHandler()
{
	m_pfnOldHandler = _set_se_translator( HandleWin32Exception );
}

//	------------------------------------------------------------------------
//
//	CWin32ExceptionHandler::~CWin32ExceptionHandler()
//
//	Exception handler destructor.  Just restores the exception handler
//	we saved off in the constructor.
//
CWin32ExceptionHandler::~CWin32ExceptionHandler()
{
	_set_se_translator( m_pfnOldHandler );
}

//	------------------------------------------------------------------------
//
//	CWin32ExceptionHandler::HandleWin32Exception()
//
//	Our Win32 exception handler.  Just stuffs the Win32 exception
//	information into a C++ exception object and throws it so we
//	can catch it with a regular C++ exception handler.
//
void __cdecl
CWin32ExceptionHandler::HandleWin32Exception( unsigned int code, _EXCEPTION_POINTERS * pep )
{
	throw CWin32Exception( code, *pep );
}


//	========================================================================
//
//	CLASS CDAVException
//

//	------------------------------------------------------------------------
//
//	CDAVException::CDAVException()
//
CDAVException::CDAVException( const char * s ) :
   exception(s)
{
#ifdef DBG
	//
	//	When we're attached to a debugger, stop here so that
	//	the soul who is debugging can actually see where the
	//	exception is being thrown from before it is thrown.
	//
	if ( GetPrivateProfileInt( "General", "TrapOnThrow", FALSE, gc_szDbgIni ) )
		TrapSz( "Throwing DAV exception.  Retry now to catch it." );
#endif
}

#ifdef DBG
//	------------------------------------------------------------------------
//
//	CDAVException::DbgTrace()
//
void
CDAVException::DbgTrace() const
{
	DebugTrace( "%s\n", what() );
}
#endif

//	------------------------------------------------------------------------
//
//	CDAVException::Hresult()
//
HRESULT
CDAVException::Hresult() const
{
	return E_FAIL;
}

//	------------------------------------------------------------------------
//
//	CDAVException::DwLastError()
//
DWORD
CDAVException::DwLastError() const
{
	return ERROR_NOT_ENOUGH_MEMORY;	//$ Is there a better default?
}


//	========================================================================
//
//	CLASS CHresultException
//

//	------------------------------------------------------------------------
//
//	CHresultException::Hresult()
//
HRESULT
CHresultException::Hresult() const
{
	return m_hr;
}


//	========================================================================
//
//	CLASS CLastErrorException
//

//	------------------------------------------------------------------------
//
//	CLastErrorException::DwLastError()
//
DWORD
CLastErrorException::DwLastError() const
{
	return m_dwLastError;
}


//	========================================================================
//
//	CLASS CWin32Exception
//

#ifdef DBG
//	------------------------------------------------------------------------
//
//	CWin32Exception::DbgTrace()
//
void
CWin32Exception::DbgTrace() const
{
	DebugTrace( "Win32 exception 0x%08lX at address 0x%08lX\n", m_code, m_ep.ExceptionRecord->ExceptionAddress );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_exo\nonimpl.cpp ===
/*
 *	N O N I M P L . C P P
 *
 *	Base classes for COM interfaces with no functionality except IUnknown.
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#pragma warning(disable:4201)	/* nameless struct/union */
#pragma warning(disable:4514)	/* unreferenced inline function */

#include <windows.h>
#include <windowsx.h>
#include <ole2.h>

#include <nonimpl.h>

//	CStreamNonImpl class ------------------------------------------------------
//
BEGIN_INTERFACE_TABLE(CStreamNonImpl)
	INTERFACE_MAP(CStreamNonImpl, IStream)
END_INTERFACE_TABLE(CStreamNonImpl);

EXO_GLOBAL_DATA_DECL(CStreamNonImpl, EXO);

//	CPersistStreamInitNonImpl class -----------------------------------------------
//
BEGIN_INTERFACE_TABLE(CPersistStreamInitNonImpl)
	INTERFACE_MAP(CPersistStreamInitNonImpl, IPersistStreamInit)
END_INTERFACE_TABLE(CPersistStreamInitNonImpl);
	
EXO_GLOBAL_DATA_DECL(CPersistStreamInitNonImpl, EXO);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_locks\_locks.cpp ===
/*
 *	_ L O C K S . C P P
 *
 *	Pre-compiled header for _locks
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include <_locks.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_idlethd\idlethrd.cpp ===
/*=========================================================================*\

	Module:      idlethrd.cpp

	Copyright Microsoft Corporation 1998, All Rights Reserved.

	Author:      zyang

	Description: Idle thread implementation

\*=========================================================================*/

#include <windows.h>
#include <limits.h>
#include <caldbg.h>
#include <ex\exmem.h>
#include <ex\autoptr.h>
#include <ex\idlethrd.h>

#pragma warning(disable:4127)	// 	conditional expression is constant
#pragma warning(disable:4244)	//	possible loss of data

class CIdleThread;

//	Globals
//
CIdleThread * g_pIdleThread = NULL;

//	Debugging -----------------------------------------------------------------
//
DEFINE_TRACE(IdleThrd);
#define IdleThrdTrace		DO_TRACE(IdleThrd)

enum
{
	EVENT_SHUTDOWN = WAIT_OBJECT_0,
	EVENT_REGISTER = WAIT_OBJECT_0 + 1
};

//	class CIdleThread
//
//		This is the idle thread implementation. it accept clients callback
//	registration, and call back to the client when timeout.
//
//		Instead of periodically wake up the thread, we maitain the minimal
//	time to wait, so that we wake only when it is necessary.
//
//		As there could be a huge number of the registrations, so we maintain
//	a heap ordered by their next timeout value. so that we don't have to
//	iterate through all the registrations each time.
//
//		When the callback is registered, DwWait will be called to get
//	initial timeout. Client can return zero thus cause the Execute be called
//	immediately.
//
class CIdleThread
{
private:

	struct REGISTRATION
	{
		__int64 	m_i64Wakeup;			// Time to wake up
		auto_ref_ptr<IIdleThreadCallBack> m_pCallBack;	// Call back object
	};

	struct IDLETHREADTASKITEM
	{
		BOOL		m_fRegister;			// TRUE - register,
											// FALSE - unregister
		auto_ref_ptr<IIdleThreadCallBack> m_pCallBack;	// Call back object
	};

	// Default starting chunk size (in number of registrations)
	//
	enum {
#ifdef DBG
	CHUNKCOUNT_START = 2	//	must be 2 or greater, as our first reg starts at index 1
#else
	CHUNKCOUNT_START = 8192 / sizeof (REGISTRATION)
#endif
	};

	HANDLE		m_hIdleThread;
	HANDLE 		m_hevShutDown;		// signaled to inform the idle
									// thread to shutdown
	HANDLE 		m_hevRegister;		// signaled when new registration
									// comes.

	CRITICAL_SECTION 	m_csRegister;	//	Used to serialize registration operations

	ULONG		m_cSize;			//	Length of the current priority queue
	ULONG		m_cAllocated;		//	Size of the physical array allocated

	REGISTRATION * m_pData;			//	The registration priority queue.
									//	prioritized on the wake up time.
	LONG		m_lSleep;			//	Time to sleep before wakeup.
									//	Negative or 0 means wakeup immediately.
									//	To sleep forever, use LONG_MAX instead
									//	of INFINITE because INFINITE (as a LONG)
									//	is a *negative* number (i.e. it would be
									//	interpreted as wake up immediately).

	IDLETHREADTASKITEM * m_pTask;	//	Array of reg/unregs to be processed
	ULONG		m_cTask;			//	number of reg/unregs to be processed
	ULONG		m_cTaskAllocated;	//	size of the array

	BOOL	FStartIdleThread();

	static DWORD __stdcall DwIdleThreadProc(PVOID pvThreadData);

	inline VOID	HeapAdd ();
	inline VOID	HeapDelete (ULONG ulIndex);

	//$HACK
	//	In order to avoid calling SetIndex on the deleted object
	//	in Exchange, we pass in a flag to indicate whether this
	//	Exchange() call is to delete a node, if so, then we should
	//	not call SetIndex on the node that is at the end of the queue
	//	(which is to be deleted)
	//$HACK
	inline VOID	Exchange (ULONG ulIndex1, ULONG ulIndex2, BOOL fDelete = FALSE);
	inline VOID	Heapify (ULONG ulIndex);

	VOID 	EnterReg() { EnterCriticalSection (&m_csRegister); }
	VOID 	LeaveReg() { LeaveCriticalSection (&m_csRegister); }

	//	non-implemented
	//
	CIdleThread( const CIdleThread& );
	CIdleThread& operator=( const CIdleThread& );

public:
	CIdleThread () :
		m_cSize (0),
		m_cAllocated (0),
		m_lSleep (LONG_MAX),
		m_pData (NULL),
		m_pTask (NULL),
		m_cTaskAllocated (0),
		m_cTask (0),
		m_hIdleThread (NULL),
		m_hevShutDown (NULL),
		m_hevRegister (NULL)
	{
		INIT_TRACE (IdleThrd);
		InitializeCriticalSection (&m_csRegister);
	}

	~CIdleThread();

	BOOL FAddNewTask (IIdleThreadCallBack * pCallBack, BOOL fRegister);
};

//	CIdleThread::DwIdleThreadProc
//		This is idle thread implementation.
//
DWORD __stdcall CIdleThread::DwIdleThreadProc(PVOID pvThreadData)
{
	//	Get the CIdlThread object
	//
	CIdleThread * pit =  reinterpret_cast<CIdleThread *>(
		pvThreadData );
	HANDLE rgh[2];
	FILETIME ftNow;
	DWORD	dw;

	//	This thread wait for two events:
	//		shutdown event, and
	//		register event.
	//
	rgh[0] = pit->m_hevShutDown;
	rgh[1] = pit->m_hevRegister;

	//	This thread maintains a mininum timeout it could wait.
	//	and would wake up when it tiemouts

	do
	{
		DWORD dwRet;

		dwRet = WaitForMultipleObjects(2, 		//	two events
									   rgh,  	//	event handles
									   FALSE,	//	return if any event signaled
									   pit->m_lSleep);// 	timeout in milliseconds.

		//	If our shutdown event handle was signalled, suicide.
		//	(OR if the event object is gonzo....)
		//
		switch (dwRet)
		{
			case WAIT_TIMEOUT:

				//$REVIEW
				//	How accurate do we use the time? is a snapshot like this enough?
				//	or we may need to this inside the loop
				//
				GetSystemTimeAsFileTime( &ftNow );

				//	Now that Unregister is supported, we need to check the size of
				//	the heap before we call back, as it's possible the call back
				//	has been unregistered.
				//
				while (pit->m_cSize &&
					   (pit->m_pData[1].m_i64Wakeup <= *(__int64 *)(&ftNow)))
				{
					//	Call back to client
					//	Unregister if client required
					//
					Assert (pit->m_pData[1].m_pCallBack->UlIndex() == 1);
					if (!pit->m_pData[1].m_pCallBack->FExecute())
					{
						pit->m_pData[1].m_pCallBack.clear();

						//$HACK
						//	In order to avoid calling SetIndex on the deleted object
						//	in Exchange, we pass in a flag to indicate whether this
						//	Exchange() call is to delete a node, if so, then we should
						//	not call SetIndex on the node that is at the end of the queue
						//	(which is to be deleted)
						//$HACK
						pit->Exchange (1, pit->m_cSize, TRUE);
						pit->m_cSize--;
						if (!pit->m_cSize)
							break;
					}
					else
					{
						//	Get the next wakeup time
						//	1 millisecond = 10,000 of 100-nanoseconds
						//
						pit->m_pData[1].m_i64Wakeup = *(__int64 *)(&ftNow) +
								static_cast<__int64>(pit->m_pData[1].m_pCallBack->DwWait()) * 10000;
					}

					//	Get the next value
					//
					pit->Heapify(1);
				}

				//	Compute how long to wait before the next timeout
				//
				if (!pit->m_cSize)
					pit->m_lSleep = LONG_MAX;
				else
				{
					pit->m_lSleep = (pit->m_pData[1].m_i64Wakeup - *(__int64 *)(&ftNow)) / 10000;
					if (pit->m_lSleep < 0)
					{
						IdleThrdTrace ("Dav: Idle: zero or negative sleep: idle too active?");
						pit->m_lSleep = 0;
					}
				}

				IdleThrdTrace ("Dav: Idle: next idle action in:\n"
							   "- milliseconds: %ld\n"
							   "- seconds: %ld\n",
							   pit->m_lSleep,
							   pit->m_lSleep / 1000);
				break;

			case EVENT_REGISTER:
			{
				ULONG	ul;
				ULONG	ulNew;

				//	Register the callback and obtain the initial timeout setting

				//$REVIEW
				//	How accurate do we use the time? is a snapshot like this enough?
				//	or we may need to this inside the loop
				//
				GetSystemTimeAsFileTime( &ftNow );

				//	Make sure no one would add a new reg when we process the
				//	new regs
				//
				pit->EnterReg();

				//	It's possbile we've processed all the new regs in the
				//	last time we were signaled
				//
				if (pit->m_cTask)
				{
					//	Expand the queue to the maximum possible required length
					//
					if (pit->m_cSize + pit->m_cTask >= pit->m_cAllocated)
					{
						REGISTRATION * pData = NULL;
						ULONG	cNewSize = 0;

						if (!pit->m_pData)
						{
							//	Initial size of the priority queue
							//$Note: we need at least one more slot for exchange
							//
							cNewSize = max(pit->m_cTask + 1, CHUNKCOUNT_START);

							pData = static_cast<REGISTRATION *>(ExAlloc (
								cNewSize * sizeof (REGISTRATION)));

						}
						else
						{
							//	Double the size, to get "logarithmic allocation behavior"
							//
							cNewSize  = (pit->m_cSize + pit->m_cTask) * 2;

							//	Realloc the array
							//	If the realloc fails, the original remain unchanged
							//
							pData = static_cast<REGISTRATION *>(ExRealloc (pit->m_pData,
								cNewSize * sizeof(REGISTRATION)));
						}

						//	It's possible that allocation failed
						//
						if (!pData)
						{
							//$REVIEW: Anything else can we do other than a debugtrace ?
							//
							IdleThrdTrace ("Cannot allocate more space\n");
							pit->LeaveReg();
							break;
						}

						//	Initialize
						//
						ZeroMemory (pData + pit->m_cSize + 1,
									sizeof(REGISTRATION) * (cNewSize - pit->m_cSize - 1));

						//	Update information
						//
						pit->m_pData = pData;
						pit->m_cAllocated = cNewSize;

						IdleThrdTrace ("priority queue size = %d\n", pit->m_cAllocated);
					}

					for (ul=0; ul < pit->m_cTask; ul++)
					{
						if (pit->m_pTask[ul].m_fRegister)
						{
							//	New position of the reg
							//
							ulNew = pit->m_cSize + 1;

							IdleThrdTrace ("Dav: Idle: add new reg %x\n", pit->m_pTask[ul].m_pCallBack.get());

							dw = pit->m_pTask[ul].m_pCallBack->DwWait();
							pit->m_pData[ulNew].m_pCallBack.take_ownership (pit->m_pTask[ul].m_pCallBack.relinquish());

							//	dw is give in milliseconds, FILETIME unit is 100-nanoseconds.
							//
							pit->m_pData[ulNew].m_i64Wakeup = *(__int64 *)(&ftNow) +
										static_cast<__int64>(dw) * 10000;

							//	Update the index
							//
							pit->m_pData[ulNew].m_pCallBack->SetIndex(ulNew);

							// Add to the heap, m_cSize is updated inside
							//
							pit->HeapAdd();
						}
						else
						{
							Assert (pit->m_pTask[ul].m_pCallBack->UlIndex() <= pit->m_cSize);

							IdleThrdTrace ("Dav: Idle: delete reg %x\n", pit->m_pTask[ul].m_pCallBack.get());

							//	Delete from the priority queue, m_cSize is updated inside
							//	it also release our ref on the deleted object
							//
							pit->HeapDelete (pit->m_pTask[ul].m_pCallBack->UlIndex());

							pit->m_pTask[ul].m_pCallBack.clear();
						}
					}

					//	Now that all task item are processed, reset
					//
					pit->m_cTask = 0;
					
				}

				//	Done with the task array
				//
				pit->LeaveReg();

				//	Compute the mininum time to wait
				//
				if (pit->m_cSize)
				{
					pit->m_lSleep = (pit->m_pData[1].m_i64Wakeup -
								*(__int64 *)(&ftNow)) / 10000;
					if (pit->m_lSleep < 0)
					{
						IdleThrdTrace ("Dav: Idle: zero or negative sleep: "
									   "idle too active?");
						pit->m_lSleep = 0;
					}
				}
				else
					pit->m_lSleep = LONG_MAX;

				break;
			}

			default:
				//	Either shutdown event is signaled or other failure
				//
#ifdef DBG
				if (dwRet != EVENT_SHUTDOWN)
				{
					IdleThrdTrace ("Dav: Idle: thread quit because of failure\n");
					if (WAIT_FAILED == dwRet)
					{
						IdleThrdTrace ("Dav: Idle: last error = %d\n", GetLastError());
					}
				}
#endif
				for (UINT i = 1; i <= pit->m_cSize; i++)
				{
					//	Tell clients that the idle thread is being shutdown
					//
					Assert (pit->m_pData[i].m_pCallBack->UlIndex() == i);
					pit->m_pData[i].m_pCallBack->Shutdown ();
					pit->m_pData[i].m_pCallBack.clear();
				}

				IdleThrdTrace ("Dav: Idle: thread is stopping\n");

				//	Shutdown this thread
				//
				return 0;
		}

	} while (TRUE);
}

CIdleThread::~CIdleThread()
{
	if (m_hevShutDown && INVALID_HANDLE_VALUE != m_hevShutDown)
	{
		//	Signal the idle thread to shutdown
		//
		SetEvent(m_hevShutDown);

		//	Wait for the idle thread to shutdown
		//
		WaitForSingleObject(m_hIdleThread, INFINITE);
	}

	CloseHandle (m_hevShutDown);
	CloseHandle (m_hevRegister);

	//$REVIEW
	//	Do I need to close the thread handle?
	//$REVIEW
	//	Yes,
	//
	CloseHandle (m_hIdleThread);

	DeleteCriticalSection (&m_csRegister);

	//	Free our array of items.
	ExFree (m_pData);
	ExFree (m_pTask);

	IdleThrdTrace ("DAV: Idle: CIdleThread destroyed\n");
}

//
//	CIdleThread::FStartIdleThead
//
//		Helper method to start the idle thread and create the events
//
BOOL
CIdleThread::FStartIdleThread()
{
	BOOL	fRet = FALSE;
	DWORD	dwThreadId;

	m_hevShutDown = CreateEvent(	NULL, 	// handle cannot be inherited
									FALSE, 	// auto reset
									FALSE,  // nosignaled
									NULL);	// no name
	if (!m_hevShutDown)
	{
		IdleThrdTrace( "Failed to create event: error: %d", GetLastError() );
		TrapSz( "Failed to create idle thread event" );
		goto ret;
	}

	m_hevRegister = CreateEvent(	NULL, 	// handle cannot be inherited
									FALSE, 	// auto reset
									FALSE,  // nosignaled
									NULL);	// no name
	if (!m_hevRegister)
	{
		IdleThrdTrace( "Failed to create register event: error: %d", GetLastError() );
		TrapSz( "Failed to create register event" );
		goto ret;
	}

	m_hIdleThread = CreateThread( NULL,
								   0,
								   DwIdleThreadProc,
								   this,
								   0,	//	Start immediately -- no need to resume...
								   &dwThreadId );
	if (!m_hIdleThread)
	{
		IdleThrdTrace( "Failed to create thread: error: %d", GetLastError() );
		TrapSz( "Failed to create Notif Cache Timer thread" );
		goto ret;
	}

	fRet = TRUE;

ret:
	if (!fRet)
	{
		if (m_hevShutDown)
		{
			if (m_hevRegister && (INVALID_HANDLE_VALUE != m_hevRegister))
			{
				CloseHandle (m_hevRegister);
				m_hevRegister = NULL;
			}

			CloseHandle (m_hevShutDown);
			m_hevShutDown = NULL;
		}
	}
	return fRet;
}

//
//	CIdleThread::HeapAdd
//
//		Add the the next node into the priority queue
//
inline
VOID
CIdleThread::HeapAdd ()
{
	ULONG	 ulCur = m_cSize + 1;
	ULONG	ulParent;

	Assert (m_pData);

	//	We go bottom up, compare the node with the parent node,
	//	exchange the two nodes if the child win. it stops when
	//	the parent win.
	//
	while ( ulCur != 1)
	{
		ulParent = ulCur >> 1;
		if (m_pData[ulParent].m_i64Wakeup <= m_pData[ulCur].m_i64Wakeup)
			break;

		Exchange (ulCur, ulParent);

		ulCur = ulParent;
	}

	m_cSize++;
}

//
//	CIdleThread::HeapDelete
//
//		Delete an arbitary node from the priority queue
//
inline
VOID
CIdleThread::HeapDelete (ULONG ulIndex)
{
	Assert (ulIndex <= m_cSize);

	//	Exchange the node to the end of the queue first
	//	then heapify to maintain the heap property
	//
	//$HACK
	//	In order to avoid calling SetIndex on the deleted object
	//	in Exchange, we pass in a flag to indicate whether this
	//	Exchange() call is to delete a node, if so, then we should
	//	not call SetIndex on the node that is at the end of the queue
	//	(which is to be deleted)
	//$HACK
	Exchange (ulIndex, m_cSize, TRUE);
	m_cSize--;
	Heapify (ulIndex);
	
	//	Must Release our ref. m_cSize+1 is the one just deleted
	//
	m_pData[m_cSize+1].m_pCallBack.clear();
}

//
//	CIdleThread::Exchange
//
//		Exchange two nodes
//
//$HACK
//	In order to avoid calling SetIndex on the deleted object
//	in Exchange, we pass in a flag to indicate whether this
//	Exchange() call is to delete a node, if so, then we should
//	not call SetIndex on the node that is at the end of the queue
//	(which is to be deleted)
//$HACK
inline
VOID
CIdleThread::Exchange (ULONG ulIndex1, ULONG ulIndex2, BOOL fDelete)
{
	Assert ((ulIndex1 != 0) && (ulIndex1 <= m_cAllocated) &&
			(ulIndex2 != 0) && (ulIndex2 <= m_cAllocated));

	if (ulIndex1 != ulIndex2)
	{
		//	Use the 0th node as the temp node
		//
		CopyMemory (m_pData, m_pData + ulIndex1, sizeof(REGISTRATION));
		CopyMemory (m_pData + ulIndex1, m_pData + ulIndex2, sizeof(REGISTRATION));
		CopyMemory (m_pData + ulIndex2, m_pData, sizeof(REGISTRATION));

		//	Remember the index to facilitate unregister
		//	Note the index is set if only the node is not deleted
		//
		if (!((ulIndex1 == m_cSize) && fDelete))
			m_pData[ulIndex1].m_pCallBack->SetIndex (ulIndex1);

		if (!((ulIndex2 == m_cSize) && fDelete))
			m_pData[ulIndex2].m_pCallBack->SetIndex (ulIndex2);
	}
}

//
//	CIdleThread::Heapify
//
//		Maintain the heap property
//
inline
VOID
CIdleThread::Heapify (ULONG ulIndex)
{
	ULONG ulLeft;
	ULONG ulRight;
	ULONG ulWin;

	Assert (m_pData);

	while (ulIndex <= m_cSize)
	{
		//	Find out the winner (i.e. the one with earlier wakeup time)
		//	between the parent and left node.
		//
		ulLeft = ulIndex * 2;
		if (ulLeft > m_cSize)
			break;
		if (m_pData[ulIndex].m_i64Wakeup > m_pData[ulLeft].m_i64Wakeup)
			ulWin = ulLeft;
		else
			ulWin = ulIndex;

		//	Compare with the right node, and find out the final winner
		//
		ulRight = ulLeft + 1;
		if (ulRight <= m_cSize)
		{
			if (m_pData[ulWin].m_i64Wakeup > m_pData[ulRight].m_i64Wakeup)
				ulWin = ulRight;
		}

		//	If the parent node is already the winner, then we are done,
		//
		if (ulIndex == ulWin)
			break;

		//	Otherwise, exchange the parent node and winner node,
		//
		Exchange (ulWin, ulIndex);
		
		ulIndex = ulWin;
	}
}

//
//	CIdleThread::FAddNewTask
//
//		Called by client to register or unregister a callback object
//
BOOL
CIdleThread::FAddNewTask (IIdleThreadCallBack * pCallBack, BOOL fRegister)
{
	BOOL	fRet = TRUE;

	//	Caller must garantee a valid callback object
	//
	Assert (pCallBack);

	EnterReg();

	Assert (!m_cTaskAllocated || (m_cTask <= m_cTaskAllocated));

	//	Allocate more space if necessary
	//
	if (m_cTask == m_cTaskAllocated)
	{
		IDLETHREADTASKITEM * pTask = NULL;
		ULONG	cNewSize = 0;

		if (!m_pTask)
		{
			Assert (m_cTask == 0);

			//	Initial size of the priority queue
			//	Starting at 8, we don't expect this queue will grow too big
			//
			cNewSize = 8;

			//	Start idle thread when add the first registration
			//
			if (!FStartIdleThread ())
			{
				fRet = FALSE;
				goto ret;
			}

			pTask = static_cast<IDLETHREADTASKITEM *>(ExAlloc (
				cNewSize * sizeof (IDLETHREADTASKITEM)));
		}
		else
		{
			//	Double the size, to get "logarithmic allocation behavior"
			//
			cNewSize  = m_cTaskAllocated * 2;

			//	Realloc the array
			//	If the realloc fails, the original remain unchanged
			//
			pTask = static_cast<IDLETHREADTASKITEM *>(ExRealloc (m_pTask,
					cNewSize * sizeof(IDLETHREADTASKITEM)));
		}

		//	It's possible that allocation failed
		//
		if (!pTask)
		{
			fRet = FALSE;
			goto ret;
		}

		//	Must initialize, otherwise, we may start with uninitialize auto_ref_ptr
		//
		ZeroMemory (pTask + m_cTask, sizeof(IDLETHREADTASKITEM) * (cNewSize - m_cTask));

		//	Update information
		//
		m_pTask = pTask;
		m_cTaskAllocated = cNewSize;

		IdleThrdTrace ("Taskitem queue size = %d\n", m_cTaskAllocated);
	}

	//	Remember the new registration
	//
	m_pTask[m_cTask].m_pCallBack = pCallBack;
	m_pTask[m_cTask].m_fRegister = fRegister;
	m_cTask++;

	IdleThrdTrace ("New reg %x added at %d\n", pCallBack, m_cTask-1);

ret:
	LeaveReg();

	//	Inform the idle thread that new registration arrived
	//
	if (fRet)
		SetEvent (m_hevRegister);

	return fRet;
}

//	FInitIdleThread
//
//	Initialize the idle thread object. It can be out only once,
//	Note this call only initialize the CIdleThread object, the
//	idle thread is not started until the first registration
//
BOOL	FInitIdleThread()
{
	Assert (!g_pIdleThread);

	g_pIdleThread = new CIdleThread();

	return (g_pIdleThread != NULL);
}

//	FDeleteIdleThread
//
//	Delete the idle thread object. again, it can be called only once.
//
//	Note this must be called before any other uninitialization work,
//	Because we don't own a ref to the callback object, all what we
//	have is a pointer to the object. in the shutdown time, we must
//	clear all the callback registration before the callback object
//	go away.
//
VOID	DeleteIdleThread()
{
	if (g_pIdleThread)
		delete g_pIdleThread;
}

//	FRegister
//
//	Register a callback
//
BOOL	FRegister (IIdleThreadCallBack * pCallBack)
{
	Assert (g_pIdleThread);

	return g_pIdleThread->FAddNewTask (pCallBack, TRUE);
}

VOID 	Unregister (IIdleThreadCallBack * pCallBack)
{
	Assert (g_pIdleThread);
 	g_pIdleThread->FAddNewTask (pCallBack, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_langid\langid.cpp ===
//	========================================================================
//
//	LANGID.CPP
//
//	DAV language id cache
//	Maps between MIME language identifiers and Win32 LCIDs.
//
//	Copyright 1997-1998 Microsoft Corporation, All Rights Reserved
//
//	========================================================================

//	Disable unnecessary (i.e. harmless) warnings
//
#pragma warning(disable:4127)	//  conditional expression is constant
#pragma warning(disable:4710)	//	(inline) function not expanded

//	Standard C/C++ headers
//
#include <malloc.h>	// For _alloca declaration ONLY!

//	Windows headers
//
#include <windows.h>

//	CAL headers
//
#include <caldbg.h>
#include <calrc.h>
#include <crc.h>
#include <ex\autoptr.h>
#include <ex\buffer.h>

#include <langid.h>

static LONG
LHexFromSz (LPCSTR psz)
{
	LONG lVal = 0;

	Assert (psz);
	Assert (*psz);

	do
	{
		lVal = lVal << 4;

		if (('0' <= *psz) && ('9' >= *psz))
			lVal += *psz - '0';
		else if (('A' <= *psz) && ('F' >= *psz))
			lVal += *psz - L'A' + 10;
		else if (('a' <= *psz) && ('f' >= *psz))
			lVal += *psz - 'a' + 10;
		else
			return 0;

	} while (*++psz);

	return lVal;
}

//	LcidFind() - lookup language ID from the locale.
//
LONG
CLangIDCache::LcidFind (LPCSTR pszLangID)
{
	LONG * plid;
	plid = Instance().m_cache.Lookup (CRCSzi(pszLangID));
	return plid ? *plid : 0;
}

BOOL FNullTerminated (LPCSTR psz, DWORD cch)
{
	for (DWORD ich = 0; ich < cch; ich++)
		if (0 == psz[ich])
			break;

	return (ich < cch);
}

//	FFillCacheData() for filling the cache with data
//
BOOL
CLangIDCache::FFillCacheData()
{
	BOOL fSuccess = FALSE;
	HKEY hkey = 0;
	CStackBuffer<CHAR,256> rgchKey;
	CStackBuffer<CHAR,256> rgchValue;
	LONG lRet;
	DWORD dwIndex = 0;

	//	Querying registry for buffer sizes
	//
	DWORD cchMaxKeyLen;			// longest value name length (in characters without zero termination)
	DWORD cbMaxKeyLen;			// longest value name length (in bytes, including zero termination)
	DWORD cbMaxValueLen;		// longest value data length (in bytes, including zero termination)

	//	Load all thet lang ID's that come from the registry
	//
	lRet = RegOpenKeyExA (HKEY_CLASSES_ROOT,
						  "MIME\\DATABASE\\RFC1766",
						  0,
						  KEY_READ,
						  &hkey);
	if (ERROR_SUCCESS != lRet)
	{
		DebugTrace("LANGID: Failed to get MIME\\DATABASE\\RFC1766 registry key handle, error code 0x%08X.\n", lRet);
		goto ret;
	}

	//	Query for the length of the longest value name and for the length of the longest data piece under the key we have got.
	//	That will give us enough information about what size buffers we need for querying.
	//
	lRet = RegQueryInfoKeyA(hkey,
							NULL,
							NULL,
							NULL,
							NULL,
							NULL,
							NULL,
							NULL,
							&cchMaxKeyLen,			//	Value names come back in number of characters
							&cbMaxValueLen,			//	Data length comes back in number of bytes
							NULL,
							NULL);
	if (ERROR_SUCCESS != lRet)
	{
		DebugTrace("LANGID: Failed to get registry key MIME\\DATABASE\\RFC1766 max data length buffer sizes, error code 0x%08X.\n", lRet);
		goto ret;
	}

	//	Calculate maximum number of bytes needed for the value name
	//
	cbMaxKeyLen = (cchMaxKeyLen + 1) * sizeof(CHAR);

	//	Allocate the query buffers on the stack
	//
	if ((NULL == rgchKey.resize(cbMaxKeyLen)) ||
		(NULL == rgchValue.resize(cbMaxValueLen)))
		goto ret;

	do
	{
		DWORD cbKey		= cbMaxKeyLen;
		DWORD cbValue	= cbMaxValueLen;
		DWORD dwType;
		LPSTR pch;
		LONG lLangId;

		lRet = RegEnumValueA(hkey,
							 dwIndex++,
							 rgchKey.get(),
							 &cbKey,
							 NULL,
							 &dwType,
							 reinterpret_cast<LPBYTE>(rgchValue.get()),
							 &cbValue);
		if (ERROR_NO_MORE_ITEMS == lRet)
			break;

		//	Encountering unknown error code is a failure
		//
		if (ERROR_SUCCESS != lRet)
		{
			DebugTrace("LANGID: Failed to query registry key MIME\\DATABASE\\RFC1766 data with error code 0x%08X.\n", lRet);
			goto ret;
		}

		//	Skip unacceptable types.
		//
		if (REG_SZ != dwType)
			continue;

		//	Skip non-NULL terminated strings
		if (!FNullTerminated (rgchValue.get(), cbValue))
			continue;

		//	Find the semi-colon that separates the ID from the name
		//	and terminate the ID.
		//
		pch = strchr (rgchValue.get(), ';');
		if (pch != NULL)
			*pch++ = '\0';

		//	Persist the name and add the key to the cache
		//
#ifdef	DBG
		if (NULL != Instance().m_cache.Lookup (CRCSzi(rgchValue.get())))
			DebugTrace ("Dav: language identifier repeated (%hs)\n", rgchValue.get());
#endif	// DBG

		//	If making the copy of the string failed... Well we can live with it.
		//
		pch = Instance().m_sb.Append (
			static_cast<UINT>((strlen (rgchValue.get()) + 1) * sizeof(CHAR)),
			rgchValue.get());
		if (!pch)
			continue;	//	Skip addition to the cache if allocation failed so we do not crash in CRCSzi(pch).

		//	If we did not succeeded adding to the cache... Well we can live with it too.
		//
		lLangId = LHexFromSz(rgchKey.get());
		if (0 != lLangId)
		{
			(void)Instance().m_cache.FSet (CRCSzi(pch), lLangId);
		}

	} while (TRUE);

	//	Set in one ISO language code which W2K forgot in RTM bits (2195)
	//
	(void)Instance().m_cache.FSet ("fr-mc", MAKELANGID (LANG_FRENCH,SUBLANG_FRENCH_MONACO));

	//	Set in some additional ISO language codes supported by Navigator,
	//	but not present in the Windows registry.
	//
	(void)Instance().m_cache.FSet ("fr-fr", MAKELANGID (LANG_FRENCH,SUBLANG_FRENCH));
	(void)Instance().m_cache.FSet ("de-de", MAKELANGID (LANG_GERMAN,SUBLANG_GERMAN));
	(void)Instance().m_cache.FSet ("es-es", MAKELANGID (LANG_SPANISH,SUBLANG_SPANISH));

	//	Set in some of the known three-char language identifiers.
	//	We can live without them if addition to the cache failed.
	//
	(void)Instance().m_cache.FSet ("eng", MAKELANGID (LANG_ENGLISH,SUBLANG_ENGLISH_US));
	(void)Instance().m_cache.FSet ("fra", MAKELANGID (LANG_FRENCH,SUBLANG_FRENCH));
	(void)Instance().m_cache.FSet ("fre", MAKELANGID (LANG_FRENCH,SUBLANG_FRENCH));
	(void)Instance().m_cache.FSet ("deu", MAKELANGID (LANG_GERMAN,SUBLANG_GERMAN));
	(void)Instance().m_cache.FSet ("ger", MAKELANGID (LANG_GERMAN,SUBLANG_GERMAN));
	(void)Instance().m_cache.FSet ("esl", MAKELANGID (LANG_SPANISH,SUBLANG_SPANISH_MODERN));
	(void)Instance().m_cache.FSet ("spa", MAKELANGID (LANG_SPANISH,SUBLANG_SPANISH_MODERN));

	fSuccess = TRUE;

ret:

	if (hkey)
	{
		RegCloseKey (hkey);
	}

	return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_locks\_locks.h ===
/*
 *	_ L O C K S . H
 *
 *	Pre-compiled header for _locks
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#pragma warning(disable:4001)	/* single line comments */
#pragma warning(disable:4050)	/* different code attributes */
#pragma warning(disable:4100)	/* unreferenced formal parameter */
#pragma warning(disable:4115)	/* named type definition in parentheses */
#pragma warning(disable:4127)	/* conditional expression is constant */
#pragma warning(disable:4200)	/* zero-sized array in struct/union */
#pragma warning(disable:4201)	/* nameless struct/union */
#pragma warning(disable:4206)	/* translation unit is empty */
#pragma warning(disable:4209)	/* benign typedef redefinition */
#pragma warning(disable:4214)	/* bit field types other than int */
#pragma warning(disable:4514)	/* unreferenced inline function */
#pragma warning(disable:4710)	/* (inline) function not expanded */

//	Windows headers
//
#include <windows.h>

#pragma warning(disable:4201)	/* nameless struct/union */

#include <malloc.h>
#include <caldbg.h>
#include <calrc.h>

#include <align.h>
#include <ex\calcom.h>
#include <ex\buffer.h>
#include <ex\cnvt.h>

#include <davsc.h>

#include <statetok.h>
#include <sz.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_exo\exo.cpp ===
/*
 *  e x o . c p p
 *
 *  Purpose:
 *      Base Exchange COM Object
 *
 *      Any Exchange object that implements one or more COM interfaces
 *      should 'derive' from EXObject using the macros below.
 *
 *	Originator:
 *		JohnKal
 *  Owner:
 *      BeckyAn
 *
 *  Copyright (C) Microsoft Corp 1993-1997. All rights reserved.
 */

#pragma warning(disable:4201)	/* nameless struct/union */
#pragma warning(disable:4514)	/* unreferenced inline function */

#include <windows.h>
#include <windowsx.h>
#include <ole2.h>

#include <caldbg.h>
#include "exo.h"


#ifndef NCHAR
#define NCHAR CHAR
#endif // !NCHAR


// Debugging traces.
// Change the function name in the define to match your system's debug calls.
#ifdef DBG
BOOL g_fExoDebugTraceOn = -1;
#define ExoDebugTrace		(!g_fExoDebugTraceOn)?0:DebugTrace
#else // !DBG
#define ExoDebugTrace		1?0:DebugTrace
#endif // DBG, else


// Forward function declarations ////////////////////////////////////////

#ifdef DBG

// EXO supporting debug structures.
#define IID_PAIR(_iid)  { (IID *) & IID_ ## _iid, #_iid }

const struct
{
    IID *   piid;
    LPSTR   szIidName;
} c_rgiidpair[] =
{
    IID_PAIR(IUnknown),

    IID_PAIR(IDataObject),
//  IID_PAIR(IMAPITable),
    IID_PAIR(IOleObject),
    IID_PAIR(IOleInPlaceObject),
    IID_PAIR(IPersist),
//  IID_PAIR(IPersistMessage),
    IID_PAIR(IPersistStorage),
    IID_PAIR(IStorage),
    IID_PAIR(IStream),
    IID_PAIR(IViewObject),
    IID_PAIR(IViewObject2),
//  IID_PAIR(IMAPIForm),
//  IID_PAIR(IMAPIFormAdviseSink),
//  IID_PAIR(IMAPISession),
    IID_PAIR(IMoniker),
    IID_PAIR(IROTData),


    { 0, 0 }        // end of table marker.
};


// EXO supporting debug function.
// Gets a name for a given IID.
LPCSTR NszFromIid(REFIID riid)
{
    int i = 0;
    static NCHAR    rgnch[80];           //$ REVIEW: not thread safe.

    while (c_rgiidpair[i].piid)
    {
        if (*c_rgiidpair[i].piid == riid)
            return c_rgiidpair[i].szIidName;
        ++i;
    }
    wsprintfA(rgnch, "{%08lx-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x}",
             riid.Data1, riid.Data2, riid.Data3,
             riid.Data4[0],riid.Data4[1],riid.Data4[2],riid.Data4[3],
             riid.Data4[4],riid.Data4[5],riid.Data4[6],riid.Data4[7]);
    return rgnch;
}
#endif  // DBG



// EXO base class: implementation ////////////////////////////////////////

// EXO's own interface mapping table & class info definitions.
BEGIN_INTERFACE_TABLE(EXO)
END_INTERFACE_TABLE(EXO);

DECLARE_EXOCLSINFO(EXO) =
	EXOCLSINFO_CONTENT_EX( EXO, NULL, exotypNonserver, &CLSID_NULL, NULL );


EXO::EXO() :
    m_cRef(1)
{
}

EXO::~EXO()
{                           // must have this or linker whines.
}

/*
 *  EXO::InternalQueryInterface
 *
 *  Purpose:
 *      Given an interface ID, check to see if the object implements the interface.
 *      If the interface is supported, return a pointer to it.
 *      Otherwise, return E_NOINTERFACE.
 *      This function scans the object's classinfo chain, starting at the lowest
 *		level, looking for the requested IID. The lowest classinfo struct is
 *		obtained by calling a virtual function.
 *
 *  Arguments:
 *      riid    in  IID of the requested interface.
 *      ppvOut  out Returned interface pointer.
 *
 *  Returns:
 *      S_OK or E_NOINTERFACE.
 *
 *  Notes:
 *      This needs to be virtual for several reasons:
 *          1) so classes derived from EXO can aggregate other objects and still have EXO routines
 *             access the interfaces of the aggregated object,
 *          2) so that EXOA_UNK members can call it
 *      All QI work should be routed here using EXO[A]_INCLASS_DECL().
 *		(The only exception is if you are an aggregator -- you have a kid --
 *		and then you should still CALL this function to search throught your own interfaces.)
 *  Notes:
 *      Note that pexoclsinfo is looked up using the virtual call to GetEXOClassInfo instead of using the object's m_pexoclsinfo.  This is so
 *      that a derived object's IIDINFO table need only contain interfaces new to that object instead of
 *      all the interfaces of the derived object and all the interfaces of it's parent.
 *      A class's InternalQueryInterface() method general calls this method explicitly passing
 *      the classes EXOCLSINFO (*not* m_pexoclsinfo) and if that fails calls it's parent's
 *      InternalQueryInterface().
 */
HRESULT EXO::InternalQueryInterface(REFIID riid, LPVOID * ppvOut)
{
    UINT ciidinfo;
    const EXOCLSINFO * pexoclsinfo;
	const IIDINFO * piidinfo;
#ifdef DBG
#ifdef UNICODE
    UsesMakeANSI;
    LPCSTR szClassName = MakeANSI(GetEXOClassInfo()->szClassName);
#else   // !UNICODE
    LPCSTR szClassName = GetEXOClassInfo()->szClassName;
#endif  // !UNICODE
    ExoDebugTrace("%s::QueryInterface(%08lx): being asked for %s\n", szClassName, this, NszFromIid(riid));
#endif  // DBG

	Assert(ppvOut);
    *ppvOut = NULL;

	// Get the lowest (leaf) classinfo for this object.
	pexoclsinfo = GetEXOClassInfo();

	// Search up the classinfo chain.  EXO's parent classinfo pointer is NULL,
	// and will terminate this loop.
	while (pexoclsinfo)
	{
		// Get the interface mapping table from the classinfo struct.
		ciidinfo = pexoclsinfo->ciidinfo;
		piidinfo = pexoclsinfo->rgiidinfo;

		// Search through this interface mapping table.
		for ( ; ciidinfo--; ++piidinfo)
		{
			// If the iid is found.
			if (*piidinfo->iid == riid)
			{
				// Apply the offset for this iid.
				IUnknown * const punk = EXOApplyDbCast(IUnknown, this,
													   piidinfo->cbDown, piidinfo->cbUp);

#ifdef DBG
				// Uses a debug-only variable.
				ExoDebugTrace("%s::QueryInterface(%08lx): cRef: %d -> %d\n", szClassName, this, m_cRef, m_cRef+1);
#endif // DBG

				// Need to AddRef the resulting object.  This ref is for the caller.
				*ppvOut = punk;
				punk->AddRef();

				return S_OK;
			}
		}

		// Fetch the next classinfo struct up the chain.
		pexoclsinfo = pexoclsinfo->pexoclsinfoParent;
	}

    // No support for the requested inteface.

#ifdef DBG
	// Uses a debug-only variable.
    ExoDebugTrace("%s::QueryInterface(%08lx): E_NOINTERFACE\n", szClassName, this);
#endif  // DBG

    return E_NOINTERFACE;
}

/*
 *  EXO::InternalAddRef
 *
 *  Purpose:
 *      Increments the reference count on the object.
 *
 *  Arguments:
 *      None.
 *
 *  Returns:
 *      The new reference count.
 */
ULONG EXO::InternalAddRef()
{
#ifdef DBG
#ifdef UNICODE
	UsesMakeANSI;
	ExoDebugTrace("%s::AddRef(%08lx): cRef: %ld->%ld\n", MakeANSI(GetEXOClassInfo()->szClassName), this, m_cRef, m_cRef+1);
#else // !UNICODE
	ExoDebugTrace("%s::AddRef(%08lx): cRef: %ld->%ld\n", GetEXOClassInfo()->szClassName, this, m_cRef, m_cRef+1);
#endif // !UNICODE
#endif // DBG

	//	NOTE: On Win95 or NT3.51, this won't return the exact m_cRef....
	//	(People shouldn't depend on the value returned from AddRef anyway!!!)
	//
	return InterlockedIncrement(&m_cRef);
}



/*
 *  EXO::InternalRelease
 *
 *  Purpose:
 *      Decrements the reference count on the object. If the reference
 *      count reaches zero, we destroy the object.
 *
 *  Arguments:
 *      None.
 *
 *  Returns:
 *      The new reference count, 0 if the object is destroyed.
 */
ULONG EXO::InternalRelease()
{
    ULONG cRef;

#ifdef DBG
#ifdef UNICODE
    UsesMakeANSI;
    ExoDebugTrace("%s::Release(%08lx): cRef: %ld->%ld\n", MakeANSI(GetEXOClassInfo()->szClassName), this, m_cRef, m_cRef-1);
#else   // !UNICODE
    ExoDebugTrace("%s::Release(%08lx): cRef: %ld->%ld\n", GetEXOClassInfo()->szClassName, this, m_cRef, m_cRef-1);
#endif  // !UNICODE
#endif  // DBG

    AssertSz(m_cRef > 0, "cRef is already 0!");

    cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
    {
        delete this;
        return 0;
    }

    return cRef;
}

// Implementation of EXOA::EXOA_UNK methods //////////////////

/*
 *  EXOA::EXOA_UNK::QueryInterface
 *
 *  Purpose:
 *      Given an interface ID 'riid', first calls out through a virtual
 *      function EXOA::AggregatorQueryInterface() to allow an aggregated
 *      aggregator to QI any of his children for the interface pointer.
 *      If that doesn't result in an interface, we then perform the
 *      EXO::QueryInterface() scan on the derived object itself.
 *
 *  Arguments:
 *      riid    in  IID of the requested interface.
 *      ppvOut  out Returned interface pointer.
 *
 *  Returns:
 *      S_OK or E_NOINTERFACE.
 */

STDMETHODIMP EXOA::EXOA_UNK::QueryInterface(REFIID riid, LPVOID * ppvOut)
{
    // We need to preserve object identity when IUnknown is requested.
    if (IID_IUnknown == riid)
    {
        *ppvOut = this;
        AddRef();
        return S_OK;
    }
    return m_pexoa->InternalQueryInterface(riid, ppvOut);
}

/*
 *  EXOA::EXOA_UNK::AddRef
 *
 *  Purpose:
 *      Increases the reference count on the object, by deferring
 *      to EXO::AddRef(). Note that we're _not_ calling EXOA::Addref()
 *      as that would release the refcount of the aggregate, not this
 *      object.
 *
 *  Arguments:
 *      None.
 *
 *  Returns:
 *      The new reference count.
 */

STDMETHODIMP_(ULONG) EXOA::EXOA_UNK::AddRef()
{
    return m_pexoa->InternalAddRef();
}

/*
 *  EXOA::EXOA_UNK::Release
 *
 *  Purpose:
 *      Decreases the reference count on the object, by deferring
 *      to EXO::Release(). Note that we're _not_ calling EXOA::Release()
 *      as that would release the refcount of the aggregate, not this
 *      object.
 *
 *  Arguments:
 *      None.
 *
 *  Returns:
 *      The new reference count.
 */

STDMETHODIMP_(ULONG) EXOA::EXOA_UNK::Release()
{
    return m_pexoa->InternalRelease();
}


// Implementation of EXOA methods ////////////////////////////////////////

EXOA::EXOA(IUnknown * punkOuter)
{
    m_exoa_unk.m_pexoa = this;
    m_punkOuter = (punkOuter) ? punkOuter : &m_exoa_unk;
}

EXOA::~EXOA()
{                           // must have this or linker whines.
}

// end of exo.cpp ////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_locks\statetok.cpp ===
/*
 *	S T A T E T O K. C P P
 *
 *	Sources implementation of DAV-Lock common definitions.
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_locks.h"

//	This is the character that will be part of the opaquelocktoken
//	for transaction tokens.
//
DEC_CONST WCHAR gc_wszTransactionOpaquePathPrefix[] = L"XN";
DEC_CONST UINT gc_cchTransactionOpaquePathPrefix = CchConstString(gc_wszTransactionOpaquePathPrefix);

/*
 *	This file contains the definitions used for parsing state token
 *	relared headers.
 *
 *
 *	If = "If" ":" ( 1*No-tag-list | 1*Tagged-list)
 *	No-tag-list = List
 *	Tagged-list = Resource 1*List
 *	Resource = Coded-url
 *	List = "(" 1*(["Not"](State-token | "[" entity-tag "]")) ")"
 *	State-token = Coded-url
 *	Coded-url = "<" URI ">"
 *
 *$BIG NOTE
  *	If headers are used for two things - once to check preconditions
 *	of the operation and once to find out the lock contexts to be
 *	used for the operation. The second part differs in store and fs
 *	implementations - since in fs we look for the lock only if the
 *	operation fails because of lock conflict. In our store implementation we have
 *	lock contexts added to the login before we start the operation.
 *	But if-header asks us to use only certain tokens with certain resources.
 *	We fall short here in the store implementation.
 *
 *	Precondition checking should behave exactly the same in the two impls.
 *
 *	Notes on the match operator:
 *	We use the caller defined match operator to determine whether the
 *	resource (resource path) statisfies the condition. For non-tagged
 *	production this condition is applied for (each of) the original
 *	operand resources for the verb. We pass the recursive flag to
 *	check for all sub-resources or not. In the case of tagged production,
 *	it is little more complex - first for each tagged path the parser
 *	determines whether it comes under the scope of the operation or
 *	not. If it does come under the scope we call the operator to apply
 *	the condition check. Here we do not want the match to be applied to
 *	the child resources and the recursive flag is set to FALSE;
 *
 */


/*
 -	CIfHeadParser
 -
 *	This is used for syntax parse of the If: header as opposed to the
 *	tokenization done by the IFITER.
 *
 *
 */

class CIfHeadParser
{
private:

	//	The header string
	//
	LPCWSTR	 m_pwszHeader;

	//	BOOL flag indicating if it is a tagged production or not
	//
	BOOL	 m_fTagged;

	//	Bool flag to indicate child resource processing.
	//	The flag is set differently for tag and non-tag
	//	productions. However the meaning of the flag is
	//	consistent - it is used to tell the matchop if
	//	we want it to look the children of the given
	//	resource.
	//
	BOOL	m_fRecursive;

    SCODE   ScValidateTagged(LPCWSTR pwszPath);
    SCODE   ScValidateNonTagged(LPCWSTR rgpwszPaths[], DWORD cPaths, SCODE * pSC);

	//	Takes an array of pointers to paths and an array of bool-flags.
	//	Requires the size of the arrays (should be same).
	//
	SCODE	ScValidateList(IN LPCWSTR *ppwszPathList, IN DWORD crPaths, OUT BOOL *pfMatch);

	SCODE	ScMatch(LPCWSTR pwszPath);

	//	Very private member shared by our methods
	//	to keep track of current parse head.
	//
	LPCWSTR	m_pwszParseHead;

	//	String parser
	//
	IFITER	m_iter;

	//	Match operator given to us.
	//
	CStateMatchOp	*m_popMatch;

	//	NOT IMPLEMENTED
	//
	CIfHeadParser( const CIfHeadParser& );
	CIfHeadParser& operator=( const CIfHeadParser& );

public:

	//	Useful consts
	//
	enum
	{
		TAG_HEAD  =	L'<',
		TAG_TAIL  = L'>',
		ETAG_HEAD = L'[',
		ETAG_TAIL = L']',
		LIST_HEAD = L'(',
		LIST_TAIL =	L')'
	};

	CIfHeadParser (LPCWSTR pwszHeader, CStateMatchOp *popMatch) :
			m_pwszHeader(pwszHeader),
			m_iter(pwszHeader),
			m_popMatch(popMatch)
	{
		Assert(pwszHeader);

		m_pwszParseHead = const_cast<LPWSTR>(pwszHeader);

		while (*m_pwszParseHead && iswspace(*m_pwszParseHead))
			m_pwszParseHead++;

		//	Checks if the header is a tagged or non-tagged production.
		//	If we find a "Coded-URI" (a URIs inside angle brackets, <uri>)
		//	before the first list (before the first "(" char)
		//	then we have a tagged production.
		//
		m_fTagged = (TAG_HEAD == *m_pwszParseHead);
	}

	~CIfHeadParser()
	{
	}

	//	Apply the if header production to the paths.
	//	Path2 is optional. fRecursive says if the validation
	//	is to be done to all children of the given path(s).
	//	We may need to change the interface to support a list
	//	of paths so that we can use it in Batch methods as well.
	//
	SCODE ScValidateIf(LPCWSTR rgpwszPaths[], DWORD cPaths, BOOL fRecursive = FALSE, SCODE * pSC = NULL);
};



//	--------------------------------------------------------------------------------
//	----------------------------- Free Helper Functions ----------------------------
//	--------------------------------------------------------------------------------

/*
 -	PwszSkipCodes
 -
 *
 *	skip white spaces and the delimiters in a tagged string part
 *	of an if-header. We expect the codes to be <> or [].
 *
 *	*pdwLen must be zero or actual length of the input string.
 *	when the call returns it will have the length of the token san
 *	LWS and tags.
 *
 */
LPCWSTR
PwszSkipCodes(IN LPCWSTR pwszTagged, IN OUT DWORD *pcchLen)
{
	LPCWSTR	pwszTokHead = pwszTagged;
	DWORD	cchTokLen;

	Assert(pcchLen);

	//	find the actual length, if not specified
	//
	if (! *pcchLen)
		*pcchLen = static_cast<DWORD>(wcslen(pwszTokHead));

	cchTokLen = *pcchLen;

	//	Calculate relevant token length skipping LWS in the
	//	head and tail.
	//
	//	Skip any LWS near the head
	//
	while((*pwszTokHead) && (iswspace(*pwszTokHead)) && (cchTokLen > 0))
	{
		cchTokLen--;
		pwszTokHead++;
	}

	//	Skip any LWS near the tail
	//
	while((cchTokLen  > 0) && iswspace(pwszTokHead[cchTokLen-1]))
	{
		cchTokLen--;
	}

	//	At least two characters are expected now
	//
	if (cchTokLen < 2)
	{
		*pcchLen = 0;
		DebugTrace("PszSkipCodes: Invalid token.\n");
		return NULL;
	}
	//	skip delimiters if they are present.
	//
	if (((*pwszTokHead == CIfHeadParser::TAG_HEAD) && (pwszTokHead[cchTokLen-1] == CIfHeadParser::TAG_TAIL)) ||
		((*pwszTokHead == CIfHeadParser::ETAG_HEAD) && (pwszTokHead[cchTokLen-1] == CIfHeadParser::ETAG_TAIL)))
	{
		pwszTokHead++;
		cchTokLen -= 2;
	}

	//	LWS are legal within the tags as well.
	//	Skip any LWS near the head
	//
	while((*pwszTokHead) && (iswspace(*pwszTokHead)) && (cchTokLen > 0))
	{
		pwszTokHead++;
		cchTokLen--;
	}

	//	Skip any LWS near the tail
	//
	while(iswspace(pwszTokHead[cchTokLen-1]) && (cchTokLen  > 0))
	{
		cchTokLen--;
	}

	if (cchTokLen > 0)
	{
		*pcchLen = cchTokLen;
		return pwszTokHead;
	}
	else
	{
		*pcchLen = 0;
		DebugTrace("PszSkipCodes Invalid token length.\n");
		return NULL;
	}
}

//	--------------------------------------------------------------------------------
//	----------------------------- CIfHeadParser Impl -------------------------------
//	--------------------------------------------------------------------------------


/*
 -	CIfHeadParser::ScValidateTagged
 -
 *
 *	Apply the tagged production.
 *
 *
 *	Simply put we do this:
 *
 *		for each list within the list of list
 *			we apply the list production
 *
 *	we expect the parse string to be 1 * List as the resource is
 *	already consumed by the caller.
 *
 */

//$REVIEW: How is this function any different from ScValidateNonTagged(pwsz, NULL)???
SCODE
CIfHeadParser::ScValidateTagged(LPCWSTR	pwszPath)
{
	SCODE	sc = E_DAV_IF_HEADER_FAILURE;
	LPCWSTR	rpwszPath[1];
	BOOL	rfMatch[1];
	BOOL	fMatchAny = FALSE;

	Assert(m_fTagged);

	rpwszPath[0] = pwszPath;
	rfMatch[0] = FALSE;

	//	Apply one list which is
	//	LIST_HEAD 1 * ( [ not ] (statetoken | e-tag ) ) LIST_TAIL
	//
	while ( SUCCEEDED(sc = ScValidateList(rpwszPath, 1, rfMatch)) )
	{
		if (TRUE == rfMatch[0])
			fMatchAny = TRUE;
	}

	//	Status cannot be succesfull there as that is condition
	//	to exit the loop above
	//
	Assert(S_OK != sc);

	//	Now if the status is special failing error
	//	and we found the match then we need to return S_OK.
	//	Otherwise we will go down and return whatever
	//	error we are given.
	//
	if ((E_DAV_IF_HEADER_FAILURE == sc) && fMatchAny)
	{
		sc = S_OK;
	}

	return sc;
}

/*
 -	CIfHeadParser::ScValidateNonTagged
 -
 *
 *	Apply the non-tagged if header production.
 *
 *
 *	Simply put we do this:
 *
 *		for each list in the header
 *			we apply the list production
 *
 *	we expect the parse string to be 1 * List as the resource is
 *	already consumed by the caller.
 *
 *	Unlike the tagged production, a non tagged production is
 *	applied to all the resources in the scope of the operation.
 *	This is really complex and we shifted the complexity to
 *	the ApplyList function below which supports two resources.
 *
 *	If we succesfully finish the list, both the resources must
 *	have atleast one successful (TRUE) list production for the
 *	whole operation to succeed.
 *
 *  If pSC is NULL we'll return success or failure based on whether
 *  or not the if header passes or fails.
 *
 *  If pSC is not NULL, it points to an array of SCODEs that
 *  indicate whether or not the if header passed for each resource
 *  in the list.  Note that in this case we will return S_OK
 *  as the return value even if one of the resources fails.  We'll
 *  only send back a failure if there was some other unexpected
 *  error
 *
 */

SCODE
CIfHeadParser::ScValidateNonTagged(LPCWSTR rgpwszPaths[], DWORD cPaths, SCODE * pSC)
{
	CStackBuffer<BOOL> rgfMatches;		//	Flags indicating overall evaluation status for each path
	CStackBuffer<BOOL> rgfNextListMatch;//	Flags used to return the results of validating next list
    SCODE   sc = S_OK;
    DWORD   iPath = 0;

	Assert(! m_fTagged);
    Assert(rgpwszPaths);
    Assert(cPaths);

	if ((NULL == rgfMatches.resize(sizeof(BOOL) * cPaths)) ||
		(NULL == rgfNextListMatch.resize(sizeof(BOOL) * cPaths)))
	{
		sc = E_OUTOFMEMORY;
		goto ret;
	}

    //  Init the match flag list: to default FALSE
    //
    for ( iPath = 0; iPath < cPaths; iPath++ )
    {
        rgfMatches[iPath] = FALSE;
        if (pSC)
        {
        	pSC[iPath] = E_DAV_IF_HEADER_FAILURE;
        }

    }
	//	Apply one list which is
	//	LIST_HEAD 1 * ( [ not ] (statetoken | e-tag ) ) LIST_TAIL
	//
	while ( SUCCEEDED(sc = ScValidateList(rgpwszPaths, cPaths, rgfNextListMatch.get())) )
	{
        //  For all the paths that evaluated to TRUE in this list,
        //  update the result flag.
        //
        for ( iPath = 0; iPath < cPaths; iPath++ )
        {
			//	The result is interesting only for those whose current state is FALSE
			//	because each of the lists of ids are OR'd together to decide whether
			//  or not they passed.
			//
			if ( (FALSE == rgfMatches[iPath]) && (TRUE == rgfNextListMatch[iPath]) )
			{
				//  Note: you may be thinking why I don't break
				//  here. With depth locks, same list/lock can
				//  satisfy multiple resources.
				//
				rgfMatches[iPath] = TRUE;
				if (pSC)
				{
					//  If we are asked for a resource by resource record
					//  of matching resource, mark that we found a success
					//  for the current resource.
					//
					pSC[iPath] = S_OK;
				}
			}
        }
		//$NOTE
		//	Two levels of optimization on this evaluation may look feasible:
		//	1) Stop evaluating when we find all the paths are validated
		//	2) Do not validate a path if the path is already validated against a list
		//	Both these optimizations will work for pre-condition evaluation, however
		//	we use the state tokens to add lock content to the logon: so we still need
		//	to parse the entire list to obtain all the applicable lock tokens..
		//	3) Another possibility is to do only the lock-token matching in the above
		//	scenario. There is no point in the etag/restag comparison if the path is
		//	already validated: but lock token check is still required as we need to
		//	collect all the lock tokens. This would require sharing the current global
		//	results with the basic match function. I think I would do this some time later.
		//$NOTE
		//
	}

	//	Check if that is any of special errors and reset the error code to S_OK
	//	if that is the case. Otherwise fail out straight of.
	//
	if ((S_OK != sc) && (E_DAV_IF_HEADER_FAILURE != sc))
	{
		goto ret;
	}
	else
	{
		sc = S_OK;
	}

	//  if we were asked for a resource by resource account of matching resources
	//  we have succeeded the request.  Otherwise, if any resource failed, the
	//  if header failed.
	//
	if (pSC)
	{
		sc = S_OK;
		goto ret;
	}

	for ( iPath = 0; iPath < cPaths; iPath++ )
	{
		if (FALSE == rgfMatches[iPath])
		{
			sc = E_DAV_IF_HEADER_FAILURE;
			break;
		}
	}

ret:
    return sc;
}


/*
 -	CIfHeadParser::ScValidateList
 -
 *
 *	Apply the list production on the  resources.
 *	For non tagged resources we need to apply the
 *	list to all operand resources. We iterate the
 *	header once and achieve this.
 *
 *	Return: FALSE on malformed input otherwise TRUE.
 *
 *	we parse the list and apply the match operation on
 *	all the resources. In order for a TRUE match result all
 *	the list elements must succesfully "apply" to the
 *	resource. If atleast one element did not apply
 *	with a truth result, we stop applying elements to
 *	that resource.
 *
 *	We return on end of list or malformed list.
 *
 */

SCODE
CIfHeadParser::ScValidateList(IN LPCWSTR *ppwszPathList, IN DWORD crPaths, OUT BOOL *pfMatch)
{
	SCODE sc = S_OK;
	DWORD iIndex;

	//	Do some input verification.
	//	size of the list must be at least one.
	//
	Assert(crPaths>0);
	Assert(ppwszPathList[0]);
	Assert(pfMatch);

#ifdef DBG
	{
		for (iIndex=0; iIndex<crPaths; iIndex++)
		{
			Assert(ppwszPathList[iIndex]);
		}
	}
#endif

	//	From now on, we are driven by the input.
	//	Look for the token and decide what to do.
	//
	m_pwszParseHead = m_iter.PszNextToken(TOKEN_START_LIST);

	//	Not a list: it is important that we fail
	//	here specifically to handle syntaxt errors
	//	in the list.
	//
	if (NULL == m_pwszParseHead)
	{
		sc = E_DAV_IF_HEADER_FAILURE;
		goto ret;
	}

	//	Initialize the match flag list.
	//	we start by assuming TRUE, since we
	//	know that there is atleast one token in the list.
	//
	for (iIndex=0; iIndex<crPaths; iIndex++)
	{
		pfMatch[iIndex] = TRUE;
	}

	//	Apply one match element at a time - which is
	//	( [ not ] ( statetoken | e-tag ) )
	//
	while (NULL != m_pwszParseHead)
	{
		BOOL	fEtag = (ETAG_HEAD == *m_pwszParseHead);

		//	set the current token of the operator
		//
		if (! m_popMatch->FSetToken(m_pwszParseHead, fEtag))
		{
			DebugTrace("CIfHeadParser::ScValidateList Invalid token\n");

			//	return immediately
			//
			sc = E_DAV_IF_HEADER_FAILURE;
			goto ret;
		}

		//	Now we obtained one complete match condition-
		//	for all the paths check if the condition is good.
		//	we need to do this only if all previous matchs
		//	succeeded for the given path.
		//	i.e if a match failed, the list is anyway going to fail
		//	for the particular path.
		//
		for (iIndex=0; iIndex<crPaths; iIndex++)
		{
			if (TRUE == pfMatch[iIndex])
			{
				//	Change the match flag only if the condition
				//	failed. This is because the expression within a
				//	list is ANDed together. If one fails, the whole
				//	list fails.
				//
				sc = ScMatch(ppwszPathList[iIndex]);
				if (FAILED(sc))
				{
					if (E_DAV_IF_HEADER_FAILURE == sc)
					{
						pfMatch[iIndex] = FALSE;
					}
					else
					{
						goto ret;
					}
				}
			}
		}

		m_pwszParseHead = m_iter.PszNextToken(TOKEN_SAME_LIST);
	}

	//	List is a syntactically correct one.
	//
	sc = S_OK;

ret:

	return sc;
}

/*
 -	CIfHeadParser::ScValidateIf
 -
 *
 *	Apply the if production.
 *
 *  If pSC is NULL we'll return success or failure based on whether
 *  or not the if header passes or fails.
 *
 *  If pSC is not NULL, it points to an array of SCODEs that
 *  indicate whether or not the if header passed for each resource
 *  in the list.  Note that in this case we will return S_OK
 *  as the return value even if one of the resources fails.  We'll
 *  only send back a failure if there was some other unexpected
 *  error
 */

SCODE
CIfHeadParser::ScValidateIf(	LPCWSTR rgpwszPaths[],
								DWORD cPaths,
								BOOL fRecursive /* = FALSE */,
								SCODE * pSC /* = NULL */)
{
	SCODE sc = S_OK;

	//	If it is a tagged production, we do not
	//	apply the match to the children - the
	//	match op is for the tagged resource only. If non
	//	tagged, the method is to be applied
	//	depending on the method's depth flag.
	//
	if (m_fTagged)
		m_fRecursive = FALSE;
	else
		m_fRecursive = fRecursive;

	//	if tagged
	//		while ok
	//			find the tagged uri
	//			see if the uri is within scope of the operands
	//			if within scope apply tagged production
	//	if non tagged
	//		apply nontagged production on the two input uris
	//	we are done
	//
	if (m_fTagged)
	{
		BOOL	fDone = FALSE;
        DWORD   iPath = 0;

        //  Initialize the results array if required ...
        //
        if (pSC)
        {
            for (iPath = 0; iPath < cPaths; iPath++)
                pSC[iPath] = S_OK;
        }
		while(! fDone)
		{
			LPCWSTR		pwszUri;
			LPCWSTR		pwszPath;
			DWORD		dwLen;

			//	find the URI in the header
			//
			m_pwszParseHead = m_iter.PszNextToken(TOKEN_NEW_URI);

			if (NULL == m_pwszParseHead)
			{
				sc = S_OK;
				goto ret;
			}

			//	got the tagged uri - skip the tags in both
			//	sides and get a clean uri.
			//
			dwLen = 0;
			pwszUri = PwszSkipCodes(m_pwszParseHead, &dwLen);

            if ( (pwszUri == NULL) || (dwLen<1) )
            {
			    sc = E_DAV_IF_HEADER_FAILURE;
			    goto ret;
            }

			//	convert the uri to the resource path
			//
			sc = m_popMatch->ScGetResourcePath(pwszUri, &pwszPath);
			if (FAILED(sc))
			{
				//  error code will be E_OUTOFMEMORY
				//  if we get here
				//
				goto ret;
			}

			//	Check if the tagged URI is within scope of
			//	the method and apply the state match operation
			//	only if it does.
			//
            for (iPath = 0; iPath < cPaths; iPath++)
			{

				//	check path validity - depending on the operation depth.
				//	If the operation is not deep, the paths must match
				//	exactly.
				//
				if (FIsChildPath(rgpwszPaths[iPath], pwszPath, fRecursive))
				{
					sc = ScValidateTagged(pwszPath);

					//  If the caller wants a list of the scodes resource
					//  by resource, set it into the array.  Otherwise
					//  we can stop verifying the resource because we've
					//  already found a resource that fails the if statement.
					//	Note that we return the failure in the scode array
					//	only for pre-condition failures, other errors like
					//	memory errors (or even redirect errors) fail the
					//	whole request immediately.
					//
					if ((E_DAV_IF_HEADER_FAILURE == sc) && (pSC))
						pSC[iPath] = sc;
					else if (FAILED(sc))
						goto ret;

                    //  This path is done
                    //
                    break;
				}
			}
		}
	}
	else
	{
		sc = ScValidateNonTagged(rgpwszPaths, cPaths, pSC);
		goto ret;
	}

	sc = E_DAV_IF_HEADER_FAILURE;

ret:

	return sc;
}

/*
 -	CIfHeadParser::ScMatch
 -
 *	Call the appropriate operator and return the value of the
 *	expression.
 *
 *
 */

SCODE
CIfHeadParser::ScMatch(LPCWSTR pwszPath)
{
	SCODE	sc = S_OK;
	BOOL	fNot = m_iter.FCurrentNot();

	Assert(m_popMatch);

	//	determine the type of the token and call the
	//	appropriate handler
	//
	switch(m_popMatch->GetTokenType())
	{
		case CStateToken::TOKEN_LOCK:
			sc = m_popMatch->ScMatchLockToken(pwszPath, m_fRecursive);
			break;

		case CStateToken::TOKEN_RESTAG:
			sc = m_popMatch->ScMatchResTag(pwszPath);
			break;

		case CStateToken::TOKEN_ETAG:
			sc = m_popMatch->ScMatchETag(pwszPath, m_fRecursive);
			break;

		case CStateToken::TOKEN_TRANS:
			sc = m_popMatch->ScMatchTransactionToken(pwszPath);
			break;

		default:
			DebugTrace("CStateMatchOp::Unsupported token type\n");
			sc = E_DAV_IF_HEADER_FAILURE;
			goto ret;
	}

	//	Unless we applied the match operators above we
	//	should not even reach here.
	//
	if (fNot)
	{
		if (E_DAV_IF_HEADER_FAILURE == sc)
		{
			sc = S_OK;
		}
		else if (S_OK == sc)
		{
			sc = E_DAV_IF_HEADER_FAILURE;
		}
	}

ret:

	return sc;
}

//	--------------------------------------------------------------------------------
//	----------------------------- CStateMatchOp Impl -------------------------------
//	--------------------------------------------------------------------------------

/*
 -	CStateMatchOp::ScParseIf
 -
 *
 *
 */
SCODE
CStateMatchOp::ScParseIf(LPCWSTR  pwszIfHeader,
						LPCWSTR rgpwszPaths[],
                        DWORD   cPaths,
						BOOL    fRecur,
						SCODE *	pSC)
{
	SCODE			sc = S_OK;
	CIfHeadParser	ifParser(pwszIfHeader, this);

	sc = ifParser.ScValidateIf(rgpwszPaths, cPaths, fRecur, pSC);

    return sc;
}

//	--------------------------------------------------------------------------------
//	----------------------------- CStateToken Impl -------------------------------
//	--------------------------------------------------------------------------------

/*
 -	CStateToken::FSetToken
 -
 *	We expect pszToken to be an e-tag enclosed within [ ] or
 *	a state token enclosed within < >.
 *
 */
BOOL
CStateToken::FSetToken(LPCWSTR pwszToken, BOOL fEtag, DWORD dwLen)
{
	LPCWSTR	pwszTokHead = pwszToken;

	m_tType = TOKEN_NONE;

	//	update the length and skip the tags
	//
	pwszTokHead = PwszSkipCodes(pwszToken, &dwLen);

    if ( (NULL == pwszTokHead) || (dwLen < 1) )
    {
        return FALSE;
    }

	//	add one for the null char.
	//
	dwLen++;

	//	allocate buffer for the token.
	//	we try to optimize allocations by using a heuristic
	//	size value. Most of our tokens are of form
	//	prefix-guid-smallstring
	//
	if ((NULL == m_pwszToken) || (dwLen > m_cchBuf))
	{
		if (NULL != m_pwszToken)
			ExFree(m_pwszToken);

		if (dwLen > NORMAL_STATE_TOKEN_SIZE)
		{
			m_pwszToken = reinterpret_cast<LPWSTR>(ExAlloc(dwLen * sizeof(WCHAR)));
			m_cchBuf   = dwLen;
		}
		else
		{
			m_pwszToken = reinterpret_cast<LPWSTR>(ExAlloc(NORMAL_STATE_TOKEN_SIZE * sizeof(WCHAR)));
			m_cchBuf   = NORMAL_STATE_TOKEN_SIZE;
		}
	}
	if (NULL == m_pwszToken)
	{
		m_cchBuf = 0;
		return FALSE;
	}

	//	Remember that dwLen contains size of the buffer (including
	//	Null char).
	//	Make our copy of the string
	//
	wcsncpy(m_pwszToken, pwszTokHead, (dwLen - 1));

	//	add the null character to terminate the string.
	//
	m_pwszToken[dwLen-1] = L'\0';

	if (fEtag)
	{
		Assert(CIfHeadParser::ETAG_HEAD == *pwszToken);
		m_tType = CStateToken::TOKEN_ETAG;
		return TRUE;
	}
	//	parse the token to find our the token type.
	//
	else if (0 == _wcsnicmp(pwszTokHead,
							gc_wszOpaquelocktokenPrefix,
							gc_cchOpaquelocktokenPrefix) )
	{
		//	Since token is a client input, let us be careful
		//	with it. Make sure that the size is minimum expected,
		//	which is opaquelocktoken:guid:<at least one char extension>.
		//	Lock tokens, unfortunately, can be either transaction
		//	or plain lock tokens. To find out if it is transaction
		//	token, we will have to parse the token and reach the
		//	extension part. For performance reasons I am going to
		//	skip parsing and jump directly to the place where I
		//	can get the information. This is not bad as we any way
		//	correctly parse the token when we are looking for its
		//	contents.
		//
		//	gc_cchOpaquelocktokenPrefix includes the :, gc_cchMaxGuid
		//	includes the null char (cch?). Hence the expression below.
		//
		if ( dwLen > (gc_cchOpaquelocktokenPrefix + gc_cchMaxGuid) )
		{
			if (0 == _wcsnicmp(&pwszTokHead[gc_cchOpaquelocktokenPrefix + gc_cchMaxGuid],
							gc_wszTransactionOpaquePathPrefix,
							gc_cchTransactionOpaquePathPrefix) )
			{
				m_tType = TOKEN_TRANS;
				return TRUE;
			}
			else
			{
				m_tType = TOKEN_LOCK;
				return TRUE;
			}
		}
		else
		{
			DebugTrace("CStateMatchOp::lock state token too small %ls\n", pwszTokHead);
			return FALSE;
		}
	}
	//	Our restag-type URIs all start with 'r'.
	//	(And no other URIs that start with 'r' are valid statetokens.)
	//
	else if (L'r' == *pwszTokHead)
	{
		m_tType = TOKEN_RESTAG;
		return TRUE;
	}
	else
	{
		DebugTrace("CStateMatchOp::Unsupported/unrecognized state token %ls\n",
				  pwszTokHead);
		return FALSE;
	}
}

/*
 -	CStateToken::FGetLockTokenInfo
 -
 *	Parse the state token as if it is a lock token. Note that this
 *	works for transaction tokens as well.
 *
 */
BOOL
CStateToken::FGetLockTokenInfo(unsigned __int64 *pi64SeqNum, LPWSTR	pwszGuid)
{
	LPWSTR	pwszToken = m_pwszToken;

	Assert(pwszGuid);

	if ((TOKEN_LOCK != m_tType) && (TOKEN_TRANS != m_tType))
	{
		return FALSE;
	}

	//	We assume that the token is validated when we reach here.
    //  skip any LWS and the opaquetoken part.
    //
    while((*pwszToken) && iswspace(*pwszToken))
        pwszToken++;

	//	we check for opaque token when we set the token - so
	//	just skip the portion
	//
	pwszToken += gc_cchOpaquelocktokenPrefix;

	//	no check for validity of buf size. duh factor.
	//
	wcsncpy(pwszGuid, pwszToken, gc_cchMaxGuid - 1);

	//	terminate the guid string.
	//
	pwszGuid[gc_cchMaxGuid - 1] = L'\0';

	pwszToken = wcschr(pwszToken, L':');

	if (NULL == pwszToken)
	{
		DebugTrace("CStateToken::FGetLockTokenInfo invalid lock token.\n");
		return FALSE;
	}
	Assert(L':' == *pwszToken);

	//	skip the ":"
	//
	pwszToken++;

	//	Transaction tokens will have a T at the head of the extension
	//	part of the token.
	//
	if (TOKEN_TRANS == m_tType)
	{
		Assert(gc_wszTransactionOpaquePathPrefix[0] == *pwszToken);
		pwszToken += gc_cchTransactionOpaquePathPrefix;
	}

	//	the lock-id string follows
	//
	*pi64SeqNum = _wtoi64(pwszToken);

	//$TODO:
	//	Is there a way to validate if atoi failed?
	//
	return TRUE;
}

/*
 -	CStateToken::FIsEqual
 -
 *	Nifty equality operator
 *
 *
 */
BOOL
CStateToken::FIsEqual(CStateToken *pstokRhs)
{
	if (pstokRhs->GetTokenType() != m_tType)
		return FALSE;

	LPCWSTR	pwszLhs = m_pwszToken;
	LPCWSTR	pwszRhs = pstokRhs->WszGetToken();

	if (!pwszLhs || !pwszRhs)
		return FALSE;

	return (0 == _wcsicmp(pwszLhs, pwszRhs));
}

/*
 -	IFITER::PszNextToken
 -
 *
 *
 */
//	------------------------------------------------------------------------
//	IFITER::PszNextToken
//
//	Fetch the next token.
//	Can be restricted to the next token in this list (AND-ed set inside a
//	particular set of parens), the next token in a new list (new set of parens),
//	or the next token in the whole header-line.
//
LPCWSTR
IFITER::PszNextToken (FETCH_TOKEN_TYPE type)
{
	LPCWSTR pwsz;
	LPCWSTR pwszEnd;
	WCHAR wchEnd = L'\0';

	//	If no header existed, then there is nothing to do
	//
	if (NULL == m_pwch)
		return NULL;

	//	Quick state-check.
	//	If the current node is a "Not", then we MUST be in a list.
	//	(Not is a qualifier on a token inside a list.  Can't have a Not
	//	outside of a list.)
	//	Logically, m_fCurrentNot _implies_ m_state is STATE_LIST.
	//
	Assert (!m_fCurrentNot || STATE_LIST == m_state);

	//	Clear our "Not" bit before starting our fetch of the next token.
	//	If the token we return has a "Not" qualifier, set the flag correctly below.
	//
	m_fCurrentNot = FALSE;


	//	Eat all the white space
	//
	while (*m_pwch && iswspace(*m_pwch))
		m_pwch++;

	//	Quit if there is nothing left to process
	//
	if (L'\0' == *m_pwch)
		return NULL;

	//	If the last state was a LIST, we need to check for the close
	//	of the list, and set our state back to NONE.
	//
	if (STATE_LIST == m_state)
	{
		//	If the next char is a close paren, that's the end of this list.
		if (L')' == *m_pwch)
		{
			m_pwch++;
			m_state = STATE_NONE;

			//	Eat all the white space
			//
			while (*m_pwch && iswspace(*m_pwch))
				m_pwch++;

			//	Quit if there is nothing left to process
			//
			if (L'\0' == *m_pwch)
				return NULL;

			//	Update our state if we were asked for "any list item".
			//	(Now we should find a list start.)
			//
			if (TOKEN_ANY_LIST == type)
				type = TOKEN_START_LIST;
		}
	}

	//	If the caller asked for any list item, and we didn't change that
	//	request because of our state above, change it here to specifically
	//	search for the next item in the same list.
	//
	if (TOKEN_ANY_LIST == type)
		type = TOKEN_SAME_LIST;

	//
	//	Process the request.
	//

	switch (type)
	{
		//	This case is really dumb.  I thought I might use
		//	it for "counting" tokens.  If it's not being used, remove it!
		//
		case TOKEN_NONE:
		{
			//	If they're asking for a raw count (type == TOKEN_NONE),
			//	give it to 'em.....
			//	NOTE: This code is a little sloppy.  It will count names
			//	as state tokens.
			//
			m_pwch = wcschr (m_pwch, L'<');
			if (!m_pwch)
			{
				return NULL;
			}
			wchEnd = L'>';

			//	Go copy the data.
			//
			break;
		}

		case TOKEN_NEW_URI:
		{
			//	Grab a name, skipping all lists.
			//	If there are no names left, give NULL.

			//	Three places we could be -- NONE, NAME, LIST.
			//
			while (m_pwch && *m_pwch)
			{
				//	If we're at a uri-delimiter now, AND
				//	we're in the NONE state, just go fetch the token below...
				//
				if (L'<' == *m_pwch &&
					STATE_NONE == m_state)
				{
					break;
				}

#ifdef	DBG
				//	Debug-only check of our state.
				if (L'(' == *m_pwch)
				{
					Assert(STATE_NONE == m_state ||
						   STATE_NAME == m_state);
				}
				else if (L'<' == *m_pwch)
				{
					Assert(STATE_LIST == m_state);
				}
#endif	// DBG

				//	Zip to the end of the current list.
				//
				m_pwch = wcschr (m_pwch + 1, L')');
				if (!m_pwch)
				{
					return NULL;
				}
				m_pwch++;	// Skip past the closing paren.

				//	Eat all the white space
				//
				while (*m_pwch && iswspace(*m_pwch))
					m_pwch++;

				//	Quit if there is nothing left to process
				//
				if (L'\0' == *m_pwch)
					return NULL;

				m_state = STATE_NONE;
			}

			//	Fallthrough to the next segment to check the token
			//	and fetch our uri.
		}

		case TOKEN_URI:
		{
			//	Grab a name, iff the next item is a name.
			//	Otherwise, give NULL.

			//	Quit if the next item is not a name.
			//
			if (L'<' != *m_pwch)
				return NULL;

			//	Quit if we aren't in the correct state to look for a name.
			//	(This could happen if we already have a name, or if we are
			//	already INSIDE a list....)
			//
			if (STATE_NONE != m_state)
				return NULL;

			//	Set our state and fallthru to fetch the data.
			//
			m_state = STATE_NAME;
			wchEnd = L'>';

			//	Go copy the data.
			//
			break;
		}

		case TOKEN_NEW_LIST:
		{
			//	Fast-forward to the next new list and fetch the first item.
			//	If we're still inside a list, must skip the rest of this list.
			//	If there are no more new lists for this URI, return NULL.

			if (STATE_LIST == m_state)
			{
				//	We're inside a list.  Get out by seeking to the next
				//	list-end-char (right paren).
				//
				m_pwch = wcschr (m_pwch, L')');
				if (!m_pwch)
					return NULL;

				m_state = STATE_NONE;
				m_pwch++;	// Skip past the closing paren.

				//	Eat all the white space
				//
				while (*m_pwch && iswspace(*m_pwch))
					m_pwch++;

				//	Quit if there is nothing left to process
				//
				if (L'\0' == *m_pwch)
					return NULL;
			}

			Assert(m_pwch);
			Assert(*m_pwch);

			//	And fallthrough here to the TOKEN_START_LIST case.
			//	It will verify & skip past the list start char
			//	and fetch out the next token.
			//
		}
		case TOKEN_START_LIST:
		{
			//	Grab a list item, iff the next item is a NEW list item.
			//	Otherwise, return NULL.

			//	Quit if the next item is not a list.
			//
			if (L'(' != *m_pwch)
				return NULL;

			//	Quit if we aren't in the correct state to look for a name.
			//	(This could happen if we are already INSIDE a list....)
			//
			if (STATE_LIST == m_state)
				return NULL;

			//	Fetch the token.
			//
			m_state = STATE_LIST;
			m_pwch++;	// Skip the open paren.

			//	Eat all the white space
			//
			while (*m_pwch && iswspace(*m_pwch))
				m_pwch++;

			//	Quit if there is nothing left to process
			//
			if (L'\0' == *m_pwch)
				return NULL;

			//	Fallthrough to the TOKEN_SAME_LIST processing
			//	to actually fetch the token.
			//
		}

		case TOKEN_SAME_LIST:
		{
			//	Grab the next list item.
			//	If the next item is not a list item, return NULL.

			//	Quit if we aren't in the correct state to look for a name.
			//	(This could happen if we are NOT inside a list....)
			//
			if (STATE_LIST != m_state)
				return NULL;

			//	Check for the magic "Not" qualifier.
			//
			if (!_wcsnicmp (gc_wszNot, m_pwch, 3))
			{
				//	Remember the data and skip these chars.
				//
				m_fCurrentNot = TRUE;
				m_pwch += 3;

				//	Eat all the white space
				//
				while (*m_pwch && iswspace(*m_pwch))
					m_pwch++;

				//	Quit if there is nothing left to process
				//
				if (L'\0' == *m_pwch)
					return NULL;
			}

			//	Quit if the next item is not a token.
			//
			if (L'<' != *m_pwch &&
				L'[' != *m_pwch)
			{
				return NULL;
			}

			//	Fetch the token.
			//
			//	Next token must start with either < for statetokens, or [ for etags.
			//
			if (L'<' == *m_pwch)
			{
				wchEnd = L'>';
			}
			else if (L'[' == *m_pwch)
			{
				wchEnd = L']';
			}
			else
			{
				DebugTrace("HrCheckIfHeaders -- Found list start, but no tokens!\n");
				return NULL;
			}

			//	Go copy the data.
			//
			break;
		}

		default:
		{
			DebugTrace("HrCheckIfHeaders -- Unrecognized request: 0x%0x", type);
			return NULL;
		}
	}
	//	We should have set these items above.  They are needed to
	//	snip off the current token string (below).
	//
	Assert (m_pwch);
	Assert (*m_pwch);
	Assert (wchEnd);

	//	Quick state-check.
	//	If the current node is a "Not", then we MUST be in a list.
	//	(Not is a qualifier on a token inside a list.  Can't have a Not
	//	outside of a list.)
	//	Logically, m_fCurrentNot _implies_ m_state is STATE_LIST.
	//
	Assert (!m_fCurrentNot || STATE_LIST == m_state);


	//	Find the end of this data item.
	//
	//	Keep a pointer to the start, and seek for the end.
	//$REVIEW: Do we need to be super-careful here?
	//$REVIEW: This strchr *could* jump past stuff, but only in MALFORMED data.
	//
	pwsz = m_pwch;
	m_pwch = wcschr (pwsz + 1, wchEnd);
	if (!m_pwch)
	{
		//	No end-of-token-char found for this token!
		//
		DebugTrace("HrCheckIfHeader -- No end char (%lc) found for token %ls",
				   wchEnd, pwsz);
		return NULL;
	}
	//	Save off the end pointer, then advance past the end char.
	//	(m_pch now points to the start for the NEXT token.)
	//
	pwszEnd = m_pwch++;

	//	Copy the data.
	//

	//	The two pointers better be set before we try to copy the data.
	Assert (pwsz);
	Assert (pwszEnd);

	//	The difference between, the two pointers gives us
	//	the size of the current entry.
	//
	m_buf.AppendAt (0, static_cast<UINT>(pwszEnd - pwsz + 1) * sizeof(WCHAR), pwsz);
	m_buf.Append (sizeof(WCHAR), L"");	// NULL-terminate it!

	//	Return the string
	//
	return m_buf.PContents();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_rgiter\rgiter.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	RGITER.CPP
//
//		HTTP Range Iterator implementation.
//
//
//	Copyright 1997 Microsoft Corporation, All Rights Reserved
//

//	Windows headers
//
//$HACK!
//
//	Define _WINSOCKAPI_ to keep windows.h from including winsock.h,
//	whose declarations would be redefined in winsock2.h,
//	which is included by iisextp.h,
//	which we include in davimpl.h!
//
#define _WINSOCKAPI_
#include <windows.h>

#pragma warning(disable:4201)	// nameless struct/union
#pragma warning(disable: 4284)	// operator-> to a non UDT

#include <tchar.h>
#include <stdio.h>
#include <string.h>

#include <caldbg.h>
#include <sz.h>
#include <davsc.h>
#include <ex\autoptr.h>
#include <ex\rgiter.h>

//	Class CRangeBase ----------------------------------------------------------
//
CRangeBase::~CRangeBase()
{
}

VOID
CRangeBase::CollapseUnknown()
{
	BYTE * pb;
	const RGITEM * prgi;
	DWORD cbrgi;
	DWORD dwOffset;
	DWORD irg;

	//	Rip through the list, collapsing as we go.
	//
	for (irg = 0, dwOffset = 0, pb = m_pbData.get();
		 irg < m_cRGList;
		 )
	{
		//	Find the current RGITEM structure
		//
		prgi = reinterpret_cast<RGITEM *>(pb + dwOffset);
		cbrgi = CbRangeItem(prgi);

		if (RANGE_UNKNOWN == prgi->uRT)
		{
			//	Slurp the remaining ranges down
			//
			memcpy (pb + dwOffset,					/* current rgitem */
					pb + dwOffset + cbrgi,			/* next rgitem    */
					m_cbSize - dwOffset - cbrgi);	/* size remaining */

			//	Adjust our stored values
			//
			m_cbSize -= cbrgi;
			m_cRGList -= 1;
		}
		else
		{
			dwOffset += cbrgi;
			irg += 1;
		}
	}
}

//	Fixup a range array against a given size
//
SCODE
CRangeBase::ScFixupRanges (DWORD dwSize)
{
	SCODE sc = W_DAV_PARTIAL_CONTENT;
	DWORD cUnknown = 0;

	//	The way this works is that we iterate through all the ranges and then
	//	fixup any of the items that need fixing up.  We remember the current
	//	position, and the current range -- this allows us to restore later as
	//	needed.
	//
	//	Store off the current item.
	//
	DWORD iCur = m_iCur;
	RGITEM * prgi = m_prgi;

	//	Rewind and iterate through....
	//
	for (Rewind(); PrgiNextRange(); )
	{
		//	Again, we only fixup RANGE_ROW items.
		//
		if (RANGE_ROW == m_prgi->uRT)
		{
			m_prgi->sc = S_OK;

			//	If we have a zero count of byte/rows, we need to handle it
			//	in a special way.
			//
			if (dwSize == 0)
			{
				//	Only range of format "-n" could be zero sized.
				//
				if (!FRangePresent (m_prgi->dwrgi.dwFirst))
				{
					Assert (FRangePresent(m_prgi->dwrgi.dwLast));

					//	Note, we don't have a way to represent NULL range.
					//	However, we do need to have range...
					//
					m_prgi->dwrgi.dwFirst = 0;
					m_prgi->dwrgi.dwLast = static_cast<DWORD>(RANGE_NOT_PRESENT);
				}
			}
			else
			{
				//	If we don't have a last count...
				//
				if (!FRangePresent (m_prgi->dwrgi.dwLast))
				{
					//	We must have checked the syntax already
					//
					Assert (FRangePresent(m_prgi->dwrgi.dwFirst));

					//	We have first byte to send, calculate last byte from size
					//	We need to send from first byte to end.
					//
					m_prgi->dwrgi.dwFirst = m_prgi->dwrgi.dwFirst;
					m_prgi->dwrgi.dwLast = dwSize - 1;
				}
				//
				//	... or a last count without a first count...
				//
				else if (!FRangePresent(m_prgi->dwrgi.dwFirst))
				{
					Assert (FRangePresent(m_prgi->dwrgi.dwLast));

					//	We have the last count dwLast, which means we need
					//	to send the last dwLast bytes. Calculate the first
					//	count from the size. If they specify a size greater
					//	then the size of entity, then use the size of the
					//	entire entity
					//
					DWORD dwLast = min(m_prgi->dwrgi.dwLast, dwSize);
					m_prgi->dwrgi.dwFirst = dwSize - dwLast;
					m_prgi->dwrgi.dwLast = dwSize - 1;
				}
				//
				//	... or both counts are present...
				//
				else
				{
					//	If they specify a last count that is beyond the actual
					//	count.
					//
					m_prgi->dwrgi.dwLast = min(m_prgi->dwrgi.dwLast, dwSize - 1);
				}

				//	Now perform one additional validity check.  If the start
				//	falls after the end, the range is not statisfiable.
				//
				if (m_prgi->dwrgi.dwLast < m_prgi->dwrgi.dwFirst)
				{
					//	In this case, we want to collapse this item out of the
					//	list so that we can handle the ranges properly in the
					//	IIS-side of range header handling.
					//
					//	Remember that we have this handling to do, and deal
					//	with it at a later time.
					//
					m_prgi->uRT = RANGE_UNKNOWN;
					m_prgi->sc = E_DAV_RANGE_NOT_SATISFIABLE;
					cUnknown += 1;
				}
			}
		}
	}

	//	If we did not find any valid ranges
	//
	if (cUnknown == m_cRGList)
	{
		//	None of the ranges were satisfiable for the entity size.
		//
		sc = E_DAV_RANGE_NOT_SATISFIABLE;
	}

	//	Now is the time when we want to collapse out any unknown ranges
	//	out of the list.
	//
	if (0 != cUnknown)
	{
		//	This is important handling for the case of byte-ranges where
		//	there is only one resulting range that is applicable.
		//
		CollapseUnknown();
	}

	//	Restore the current position and return
	//
	m_iCur = iCur;
	m_prgi = prgi;
	return sc;
}

const RGITEM *
CRangeBase::PrgiNextRange()
{
	const RGITEM * prgi = NULL;

	if (FMoreRanges())
	{
		UINT cb = 0;
		BYTE * pb = NULL;

		//	If the main pointer is NULL, then we know that we have not
		//	setup for any ranges yet.
		//
		if (NULL == m_prgi)
		{
			pb = reinterpret_cast<BYTE*>(m_pbData.get());
		}
		else
		{
			//	Otherwise, we need to adjust our position based
			//	on the size of the current item
			//
			//	Find the size of the item
			//
			cb = CbRangeItem (m_prgi);
			pb = reinterpret_cast<BYTE*>(m_prgi);
		}

		//	Scoot forward
		//
		m_prgi = reinterpret_cast<RGITEM*>(pb + cb);
		m_iCur += 1;

		//	Ensure the boundry
		//
		Assert (reinterpret_cast<BYTE*>(m_prgi) <= (m_pbData.get() + m_cbSize));
		prgi = m_prgi;
	}
	return prgi;
}

//	Class CRangeParser --------------------------------------------------------
//
CRangeParser::~CRangeParser()
{
}

//	Takes a range header and builds an array of ranges. Performs syntax
//	checking.
//
//	S_OK is returned if no syntax error, otherwise, S_FALSE is returned
//
SCODE
CRangeParser::ScParseRangeHdr (LPCWSTR pwszRgHeader, LPCWSTR pwszRangeUnit)
{
	LPCWSTR pwsz, pwszEnd;
	SCODE sc = S_OK;
	BOOL bFirst = FALSE, bLast = FALSE;
	DWORD dwFirst = 0, dwLast = 0;
	DWORD cRanges = 0;

	Assert (pwszRgHeader);
	pwsz = pwszRgHeader;

	//	The first word has to be the range unit, either gc_wszBytes
	//	or gc_wszRows
	//
	Assert (!_wcsnicmp (pwszRangeUnit, gc_wszBytes, wcslen(gc_wszBytes)) ||
			!_wcsnicmp (pwszRangeUnit, gc_wszRows, wcslen(gc_wszRows)));
	if (_wcsnicmp(pwsz, pwszRangeUnit, wcslen(pwszRangeUnit)))
	{
		//	OK, the header did not start with range unit
		//
		sc = E_INVALIDARG;
		goto ret;
	}

	//	Move past the range unit
	//
	pwsz = pwsz + wcslen(pwszRangeUnit);

	//	Skip any whitespace
	//
	pwsz = _wcsspnp (pwsz, gc_wszWS);
	if (!pwsz)
	{
		//	OK, the header does not have any ranges
		//
		sc = E_INVALIDARG;
		goto ret;
	}

	//	We need an = immediately after the range unit
	//
	if (gc_wchEquals != *pwsz++)
	{
		//	OK, improper format
		//
		sc = E_INVALIDARG;
		goto ret;
	}

	//	Count the number of comma separated ranges we have
	//	While this algorithm results in m_cRGList being equal to one more
	//	than the number of commas, that is exactly what we want. The number
	//	of ranges is always less than or equal to one more than the number of
	//	commas.
	//
	while (pwsz)
	{
		//	Find a comma
		//
		pwsz = wcschr(pwsz, gc_wchComma);

		//	If we have a comma, move past it
		//
		if (pwsz)
			pwsz++;

		//	Increment the count
		//
		cRanges += 1;
	}

	//	Parse the header to find the byte ranges
	//
	//	Seek past the byte unit
	//
	pwsz = wcschr(pwszRgHeader, gc_wchEquals);

	//	We already checked for an =, so assert
	//
	Assert (pwsz);
	pwsz++;

	//	Any characters in our byte range except the characters 0..9,-,comma
	//	and whitespace are illegal. We check to see if we have any illegal characters
	//	using the function _wcsspnp(string1, string2) which finds the first character
	//	in string1 that does not belong to the set of characters in string2
	//
	pwszEnd = _wcsspnp(pwsz, gc_wszByteRangeAlphabet);
	if (pwszEnd)
	{
		//	We found an illegal character
		//
		sc = E_INVALIDARG;
		goto ret;
	}

	//	Skip any whitespace and separators
	//
	pwsz = _wcsspnp (pwsz, gc_wszSeparator);
	if (!pwsz)
	{
		//	OK, the header does not have any ranges
		//
		sc = E_INVALIDARG;
		goto ret;
	}

	//	Create the required storage
	//
	m_cRGList = 0;
	m_cbSize = cRanges * sizeof(RGITEM);
	m_pbData = static_cast<BYTE*>(ExAlloc(m_cbSize));
	m_prgi = reinterpret_cast<RGITEM*>(m_pbData.get());

	//	Make sure the allocation succeeds
	//
	if (NULL == m_prgi)
	{
		sc = E_OUTOFMEMORY;
		goto ret;
	}

	//	Iterate through the byte ranges
	//
	while (*pwsz != NULL)
	{
		pwszEnd = _wcsspnp (pwsz, gc_wszDigits);

		//	Do we have a first byte?
		//
		if (!pwszEnd)
		{
			//	This is illegal. We cannot just have a first byte and
			//	nothing after it
			//
			sc = E_INVALIDARG;
			goto ret;
		}
		else if (pwsz != pwszEnd)
		{
			dwFirst = _wtoi(pwsz);
			bFirst = TRUE;

			//	Seek past the end of the first byte
			//
			pwsz = pwszEnd;
		}

		//	Now we should find the -
		//
		if (*pwsz != gc_wchDash)
		{
			sc = E_INVALIDARG;
			goto ret;
		}
		pwsz++;

		//	If we aren't at the end of the string, look for the last byte
		//
		if (*pwsz != NULL)
		{
			pwszEnd = _wcsspnp(pwsz, gc_wszDigits);

			//	Do we have a last byte?
			//
			if (pwsz != pwszEnd)
			{
				dwLast = _wtoi(pwsz);
				bLast = TRUE;
			}

			//	Update psz to the end of the current range
			//
			if (!pwszEnd)
			{
				//	We must be at the end of the header. Update psz
				//
				pwsz = pwsz + wcslen(pwsz);
			}
			else
			{
				pwsz = pwszEnd;
			}
		}

		//	It's a syntax error if we don't have both first and last range
		//	or the last is less than the first
		//
		if ((!bFirst && !bLast) ||
			(bFirst && bLast && (dwLast < dwFirst)))
		{
			sc = E_INVALIDARG;
			goto ret;
		}

		//	We are done parsing the byte/row range, now save it.
		//
		Assert (m_cRGList < cRanges);
		m_prgi[m_cRGList].uRT = RANGE_ROW;
		m_prgi[m_cRGList].sc = S_OK;
		m_prgi[m_cRGList].dwrgi.dwFirst = bFirst ? dwFirst : RANGE_NOT_PRESENT;
		m_prgi[m_cRGList].dwrgi.dwLast = bLast ? dwLast : RANGE_NOT_PRESENT;
		m_cRGList += 1;

		//	Update variables
		//
		bFirst = bLast = FALSE;
		dwFirst = dwLast = 0;

		//	Skip any whitespace
		//
		pwsz = _wcsspnp (pwsz, gc_wszWS);
		if (!pwsz)
		{
			//	OK, we don't have anything beyond whitespace, we are at the end
			//
			goto ret;
		}
		else if (*pwsz != gc_wchComma)
		{
			//	The first non-whitespace character has to be a separator(comma)
			//
			sc = E_INVALIDARG;
			goto ret;
		}

		//	Now that we found the first comma, skip any number of subsequent
		//	commas and whitespace
		//
		pwsz = _wcsspnp (pwsz, gc_wszSeparator);
		if (!pwsz)
		{
			//	OK, we don't have anything beyond separator, we are at the end
			//
			goto ret;
		}
	}

ret:

	if (FAILED (sc))
	{
		//	Free up our storage
		//
		m_cbSize = 0;
		m_cRGList = 0;
		m_pbData.clear();
		Rewind();
	}
	return sc;
}

//	Don't use FAILED() macros on this return code!  You'll miss the details!
//
//	Takes a range header and builds an array of ranges. Performs syntax
//	checking and validation of the ranges against the entity size.
//	Returns an SCODE, but be careful!  These SCODEs are meant to be
//	mapped to HSCs at a higher level.
//
//		E_INVALIDARG means syntax error
//
//		E_DAV_RANGE_NOT_SATISFIABLE if none of the ranges were valid
//				for the entity size passed in.
//
//		W_DAV_PARTIAL_CONTENT if there was at least one valid range.
//
//	This function does NOT normally return S_OK.  Only one of the above!
//
SCODE
CRangeParser::ScParseByteRangeHdr (LPCWSTR pwszRgHeader, DWORD dwSize)
{
	SCODE sc = S_OK;

	Assert(pwszRgHeader);

	//	Parses the ranges header and builds an array of the ranges
	//
	sc = ScParseRangeHdr (pwszRgHeader, gc_wszBytes);
	if (FAILED (sc))
		goto ret;

	//	Fixup the ranges as needed
	//
	sc = ScFixupRanges (dwSize);
	Assert ((sc == W_DAV_PARTIAL_CONTENT) ||
			(sc == E_DAV_RANGE_NOT_SATISFIABLE));

ret:
	return sc;
}

//	Class CRangeIter ----------------------------------------------------------
//
CRangeIter::~CRangeIter()
{
}

SCODE
CRangeIter::ScInit (ULONG cRGList, const RGITEM * prgRGList, ULONG cbSize)
{
	SCODE sc = S_OK;

	//	The object must not have been initialized before
	//
	Assert (!m_pbData.get() && (0 == m_cRGList));

	//	Make sure we are given good bits...
	//
	Assert (cRGList);
	Assert (prgRGList);
	Assert (cbSize);

	//	Duplicate the RGITEM array
	//
	m_pbData = static_cast<BYTE*>(ExAlloc(cbSize));
	if (!m_pbData.get())
	{
		sc = E_OUTOFMEMORY;
		goto ret;
	}
	CopyMemory (m_pbData.get(), prgRGList, cbSize);

	//	Remember the count and size
	//
	m_cRGList = cRGList;
	m_cbSize = cbSize;

	//	Rewind to the beginning of the ranges
	//
	Rewind();

ret:
	return sc;
}

//	Range Parsing -------------------------------------------------------------
//
SCODE
ScParseOneWideRange (LPCWSTR pwsz, DWORD * pdwStart, DWORD * pdwEnd)
{
	BOOL fEnd = FALSE;
	BOOL fStart = FALSE;
	DWORD dwEnd = static_cast<DWORD>(RANGE_NOT_PRESENT);
	DWORD dwStart = static_cast<DWORD>(RANGE_NOT_PRESENT);
	LPCWSTR	pwszEnd;
	SCODE sc = S_OK;

	//	A quick note about the format here...
	//
	//		row_range= digit* '-' digit*
	//		digit= [0-9]
	//
	//	So, the first thing we need to check is if there is a leading set of
	//	digits to indicate a starting point.
	//
	pwszEnd = _wcsspnp (pwsz, gc_wszDigits);

	//	If the return value is NULL, or points to a NULL, then we have an
	//	invalid range.  It is not valid to simply have a set of digits
	//
	if ((NULL == pwszEnd) || (0 == *pwszEnd))
	{
		sc = E_INVALIDARG;
		goto ret;
	}
	//
	//	Else if the current position and the end refer to the same
	//	character, then there is no starting range.
	//
	else if (pwsz != pwszEnd)
	{
		dwStart = wcstoul (pwsz, NULL, 10 /* always base 10 */);
		pwsz = pwszEnd;
		fStart = TRUE;
	}

	//	Regardless, at this point we should have a single '-' character
	//
	if (L'-' != *pwsz++)
	{
		sc = E_INVALIDARG;
		goto ret;
	}

	//	Any remaining characters should be the end of the range
	//
	if (0 != *pwsz)
	{
		pwszEnd = _wcsspnp (pwsz, gc_wszDigits);

		//	Here we expect that the return value is not the same as
		//	the initial pointer
		//
		if ((NULL != pwszEnd) && (0 != pwszEnd))
		{
			sc = E_INVALIDARG;
			goto ret;
		}

		dwEnd = wcstoul (pwsz, NULL, 10 /* always base 10 */);
		fEnd = TRUE;
	}

	//	Can't have both end-points as non-existant ranges
	//
	if ((!fStart && !fEnd) ||
		(fStart && fEnd && (dwEnd < dwStart)))
	{
		sc = E_INVALIDARG;
		goto ret;
	}

ret:
	*pdwStart = dwStart;
	*pdwEnd = dwEnd;
	return sc;
}

//	ScGenerateContentRange() --------------------------------------------------
//
enum { BUFFER_INITIAL_SIZE = 512 };

//	ScGenerateContentRange
//
//	Helper function to build the content-range header
//
//	If ulTotal is RGITER_TOTAL_UNKNOWN ((ULONG)-1), then we give back "total=*".
//	This is needed for REPL, because our store api doesn't tell us how many possible
//	rows there are up front.
//
SCODE ScGenerateContentRange (
	/* [in]  */ LPCSTR pszRangeUnit,
	/* [in]  */ const RGITEM * prgRGList,
	/* [in]  */ ULONG cRanges,
	/* [in]  */ ULONG cbRanges,
	/* [in]  */ ULONG ulTotal,
	/* [out] */ LPSTR *ppszContentRange)
{
	auto_heap_ptr<CHAR>	pszCR;
	BOOL fMultipleRanges = FALSE;
	CRangeIter cri;
	SCODE sc = E_INVALIDARG;
	ULONG cb = 0;
	ULONG cbSize = BUFFER_INITIAL_SIZE;

	//	We must have something to emit
	//
	Assert (ppszContentRange);
	Assert (cRanges);

	sc = cri.ScInit (cRanges, prgRGList, cbRanges);
	if (FAILED (sc))
		goto ret;

	//	Allocate the space for the header
	//
	pszCR = static_cast<LPSTR>(ExAlloc (cbSize));
	if (!pszCR.get())
	{
		sc = E_OUTOFMEMORY;
		goto ret;
	}

	//	Setup the leading range units, etc...
	//
	strcpy (pszCR.get() + cb, pszRangeUnit);
	cb += static_cast<ULONG>(strlen(pszRangeUnit));

	//	Stuff in a leading space
	//
	pszCR.get()[cb++] = ' ';

	//	Now iterate through the ranges to add in
	//	each range.
	//
	while (NULL != (prgRGList = cri.PrgiNextRange()))
	{
		//	If the range is unknown, then it is a range
		//	that was not processed on the store side.
		//
		if (RANGE_UNKNOWN == prgRGList->uRT)
			continue;

		//	First off, make sure there is plenty of room
		//
		if (cb > cbSize - 50)
		{
			//	Realloc the buffer
			//
			cbSize = cbSize + BUFFER_INITIAL_SIZE;
			pszCR.realloc (cbSize);

			//	It's possible that the allocation fails
			//
			if (!pszCR.get())
				goto ret;
		}

		//	Now that we know we have space...
		//	If this is a subsequent range to the initial
		//	one, add in a comma.
		//
		if (fMultipleRanges)
		{
			//	Stuff in a comma and a space
			//
			pszCR.get()[cb++] = ',';
			pszCR.get()[cb++] = ' ';
		}

		if (RANGE_ROW == prgRGList->uRT)
		{
			//	50 is a safe numder of bytes to hold the last range and
			//	"total = <size>"
			//
			//	Append the next range
			//
			cb += sprintf (pszCR.get() + cb,
						   "%u-%u",
						   prgRGList->dwrgi.dwFirst,
						   prgRGList->dwrgi.dwLast);
		}
		else
		{
			//	For all non-row ranges, we really don't know the ordinals
			//	of the rows up front.  We only find that info out when the
			//	rows are actually queried.  This happens long after the
			//	content-range header is constructed, so we stuff in a place
			//	holder for these ranges.
			//
			pszCR.get()[cb++] = '*';
		}
		fMultipleRanges = TRUE;
	}

	//	Now it's time to append the "total=<size>"
	//	Handle the special case of RGITER_TOTAL_UNKNOWN -- give "total=*".
	//
	if (RANGE_TOTAL_UNKNOWN == ulTotal)
	{
		const char rgTotalStar[] = "; total=*";
		memcpy (pszCR.get() + cb, rgTotalStar, CElems(rgTotalStar));
	}
	else
	{
		sprintf(pszCR.get() + cb, "; total=%u", ulTotal);
	}

	//	Pass the buffer back
	//
	*ppszContentRange = pszCR.relinquish();
	sc = S_OK;

ret:
	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_synchro\_synchro.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	_SYNCHRO.H
//
//		SYNCHRO precompiled header
//
//
//	Copyright 1986-1998 Microsoft Corporation, All Rights Reserved
//

#include "_synchro.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_synchro\synchro.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	SYNCHRO.CPP
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//
#include "_synchro.h"
#include <ex\synchro.h>

//	========================================================================
//
//	CLASS CMRWLock
//
//	EnterRead()/LeaveRead() respectively lets a reader enter or leave
//	the lock.  If there is a writer or promotable reader in the lock,
//	entry is delayed until the writer/promotable reader leaves.
//
//	EnterWrite()/LeaveWrite() respectively lets a single writer enter
//	or leave the lock.  If there are any readers in the lock, entry
//	is delayed until they leave.  If there is another writer or a
//	promotable reader in the lock, entry is delayed until it leaves.
//
//	EnterPromote()/LeavePromote() respectively lets a single promotable
//	reader enter or leave the lock.  If there is a writer or another
//	promotable reader in the lock, entry is delayed until the
//	writer/promotable reader leaves.  Otherwise entry is immediate,
//	even if there are other (non-promotable) readers in the lock.
//	Promote() promotes the promotable reader to a writer.  If there
//	are readers in the lock, promotion is delayed until they leave.
//
//	Once a writer or promotable reader has entered the lock, it may
//	reenter the lock as a reader, writer or promotable reader without
//	delay.  A reader cannot reenter the lock as a writer or promotable.
//

//	------------------------------------------------------------------------
//
//	CMRWLock::CMRWLock()
//
CMRWLock::CMRWLock() :
   m_lcReaders(0),
   m_dwWriteLockOwner(0),
   m_dwPromoterRecursion(0)
{
}

//	------------------------------------------------------------------------
//
//	CMRWLock::FInitialize()
//
BOOL
CMRWLock::FInitialize()
{
	return m_evtEnableReaders.FCreate( NULL,	// default security
									   TRUE,	// manual-reset
									   FALSE,	// initially non-signalled
									   NULL )   // unnamed

		&& m_evtEnableWriter.FCreate(  NULL,	// default security
									   FALSE,	// auto-reset
									   FALSE,	// initially non-signalled
									   NULL );  // unnamed
}

//	------------------------------------------------------------------------
//
//	CMRWLock::EnterRead()
//
void
CMRWLock::EnterRead()
{
	(void) FAcquireReadLock(TRUE); // fBlock
}

//	------------------------------------------------------------------------
//
//	CMRWLock::FTryEnterRead()
//
BOOL
CMRWLock::FTryEnterRead()
{
	return FAcquireReadLock(FALSE); // fBlock
}

//	------------------------------------------------------------------------
//
//	CMRWLock::FAcquireReadLock()
//
BOOL
CMRWLock::FAcquireReadLock(BOOL fAllowCallToBlock)
{
	//
	//	Loop around trying to enter the lock until successful
	//
	for ( ;; )
	{
		//
		//	Poll the reader count/write lock
		//
		LONG lcReaders = m_lcReaders;

		//
		//	If the write lock is held ...
		//
		if ( lcReaders & WRITE_LOCKED )
		{
			//
			//	... check whether the writer is on this thread.
			//	If it is, then let this thread reenter the
			//	lock as a reader.  Do not update the reader
			//	count in this case.
			//
			if ( m_dwWriteLockOwner == GetCurrentThreadId() )
				break;

			//
			//	If the writer is not on this thread, then wait
			//	until the writer leaves, then re-poll the
			//	reader count/write lock and try again.
			//
			//	We only block if the caller allows us to block.  If this is
			//	a FTryEnterRead call, we return FALSE right away.
			//
			if ( fAllowCallToBlock )
			{
				m_evtEnableReaders.Wait();
			}
			else
			{
				return FALSE;
			}
		}

		//
		//	Otherwise, the write lock was not held, so
		//	try to enter the lock as a reader.  This only
		//	succeeds when no readers or writers enter or leave
		//	the lock between the time the reader count/
		//	write lock is polled above and now.  If what is in
		//	the lock has changed, the whole operation is retried
		//	until the lock state doesn't change.
		//
		else
		{
			if ( lcReaders == /*reinterpret_cast<LONG>*/(
								InterlockedCompareExchange(
									(&m_lcReaders),
									(lcReaders + 1),
									(lcReaders)))  )
#ifdef NEVER
									reinterpret_cast<PVOID *>(&m_lcReaders),
									reinterpret_cast<PVOID>(lcReaders + 1),
									reinterpret_cast<PVOID>(lcReaders)))  )
#endif // NEVER
			{
				break;
			}
		}
	}

	//	If we made it to this point, we have acquired the read lock.
	//
	return TRUE;
}

//	------------------------------------------------------------------------
//
//	CMRWLock::LeaveRead()
//
void
CMRWLock::LeaveRead()
{
	//
	//	If the thread on which the reader is leaving also owns
	//	the write lock, then the reader leaving has no effect,
	//	as did entering.
	//
	if ( m_dwWriteLockOwner == GetCurrentThreadId() )
		return;

	//
	//	Otherwise, atomically decrement the reader count and
	//	check if a writer is waiting to enter the lock.
	//	If the reader count goes to 0 and a writer is waiting
	//	to enter the lock, then notify the writer that
	//	it is safe to enter.
	//
	if ( WRITE_LOCKED == InterlockedDecrement(&m_lcReaders) )
		m_evtEnableWriter.Set();
}

//	------------------------------------------------------------------------
//
//	CMRWLock::EnterWrite()
//
void
CMRWLock::EnterWrite()
{
	//
	//	A writer is just a promotable reader that promotes immediately
	//
	EnterPromote();
	Promote();
}

//	------------------------------------------------------------------------
//
//	CMRWLock::FTryEnterWrite()
//
BOOL
CMRWLock::FTryEnterWrite()
{
	BOOL fSuccess;

	//
	//	Try to enter the lock as a promotable reader.
	//	Promote to a writer immediately if successful
	//	and return the status of the operation.
	//
	fSuccess = FTryEnterPromote();

	if ( fSuccess )
		Promote();

	return fSuccess;
}

//	------------------------------------------------------------------------
//
//	CMRWLock::LeaveWrite()
//
void
CMRWLock::LeaveWrite()
{
	LeavePromote();
}

//	------------------------------------------------------------------------
//
//	CMRWLock::EnterPromote()
//
void
CMRWLock::EnterPromote()
{
	//
	//	Grab the writer critical section to ensure that no other thread
	//	is already in the lock as a writer or promotable reader.
	//
	m_csWriter.Enter();

	//
	//	Bump the promoter recursion count
	//
	++m_dwPromoterRecursion;
}

//	------------------------------------------------------------------------
//
//	CMRWLock::FTryEnterPromote()
//
BOOL
CMRWLock::FTryEnterPromote()
{
	BOOL fSuccess;

	//
	//	Try to enter the writer critical section.
	//	Bump the recursion count if successful and
	//	return the status of the operation.
	//
	fSuccess = m_csWriter.FTryEnter();

	if ( fSuccess )
		++m_dwPromoterRecursion;

	return fSuccess;
}

//	------------------------------------------------------------------------
//
//	CMRWLock::Promote()
//
void
CMRWLock::Promote()
{
	//
	//	If the promotable reader has already been promoted
	//	then don't promote it again
	//
	if ( GetCurrentThreadId() == m_dwWriteLockOwner )
		return;

	//
	//	Assert that no other writer owns the lock.
	//
	Assert( 0 == m_dwWriteLockOwner );
	Assert( !(m_lcReaders & WRITE_LOCKED) );

	//
	//	Claim the lock
	//
	m_dwWriteLockOwner = GetCurrentThreadId();

	//
	//	Stop readers from entering the lock
	//
	m_evtEnableReaders.Reset();

	//
	//	If there are any readers in the lock
	//	then wait for them to leave.  The InterlockedExchangeOr()
	//	is used to ensure that the test is atomic.
	//
	if ( InterlockedExchangeOr( &m_lcReaders, WRITE_LOCKED ) )
		m_evtEnableWriter.Wait();

	//
	//	Assert that the (promoted) writer is now the only thing in the lock
	//
	Assert( WRITE_LOCKED == m_lcReaders );
}

//	------------------------------------------------------------------------
//
//	CMRWLock::LeavePromote()
//
void
CMRWLock::LeavePromote()
{
	//
	//	No one should attempt to leave a promote block
	//	that they never entered.
	//
	Assert( m_dwPromoterRecursion > 0 );

	//
	//	If the promotable reader promoted to a writer
	//	then start allowing readers back into the lock
	//	once the promoter recursion count reaches 0
	//
	if ( --m_dwPromoterRecursion == 0 &&
		 GetCurrentThreadId() == m_dwWriteLockOwner )
	{
		//
		//	Clear the write flag to allow new readers
		//	to start entering the lock.
		//
		m_lcReaders = 0;

		//
		//	Unblock any threads with readers that are
		//	already waiting to enter the lock.
		//
		m_evtEnableReaders.Set();

		//
		//	Release ownership of the write lock
		//
		m_dwWriteLockOwner = 0;
	}

	//
	//	Release the writer's/promoter's critical section reference.
	//	When this the last such reference is released, a new
	//	promoter/writer may enter the lock.
	//
	m_csWriter.Leave();
}

//	========================================================================
//
//	FREE FUNCTIONS
//

//	------------------------------------------------------------------------
//
//	InterlockedExchangeOr()
//
//	This function performs an atomic logical OR of a value to a variable.
//	The function prevents more than one thread from using the same
//	variable simultaneously.  (Well, actually, it spins until it
//	gets a consistent result, but who's counting...)
//
//	Returns the value of the variable before the logical OR was performed
//
LONG InterlockedExchangeOr( LONG * plVariable, LONG lOrBits )
{
	//	The rather cryptic way this works is:
	//
	//	Get the instantaneous value of the variable.  Stuff it into a
	//	local variable so that it cannot be changed by another thread.
	//	Then try to replace the variable with this value OR'd together
	//	with the OR bits.  But only replace if the variable's value
	//	is still the same as the local variable.  If it isn't, then
	//	another thread must have changed the value between the two
	//	operations, so keep trying until they both succeed as if
	//	they had executed as one.  Once the operation succeeds in
	//	changing the value atomically, return  the previous value.
	//
	for ( ;; )
	{
		LONG lValue = *plVariable;

		if ( lValue == /*reinterpret_cast<LONG>*/(
							InterlockedCompareExchange(
								(plVariable),
								(lValue | lOrBits),
								(lValue))) )
#ifdef NEVER
								reinterpret_cast<PVOID *>(plVariable),
								reinterpret_cast<PVOID>(lValue | lOrBits),
								reinterpret_cast<PVOID>(lValue))) )
#endif // NEVER
			return lValue;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_synchro\_synchro.h ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	_SYNCHRO.H
//
//		SYNCHRO precompiled header
//
//
//	Copyright 1986-1998 Microsoft Corporation, All Rights Reserved
//

#ifndef __SYNCHRO_H_
#define __SYNCHRO_H_

//	Disable unnecessary (i.e. harmless) warnings
//
#pragma warning(disable:4100)	//	unref formal parameter (caused by STL templates)
#pragma warning(disable:4127)	//  conditional expression is constant */
#pragma warning(disable:4201)	//	nameless struct/union
#pragma warning(disable:4514)	//	unreferenced inline function
#pragma warning(disable:4710)	//	(inline) function not expanded

//	Windows headers
//
#include <windows.h>

#endif // !defined(__SYNCHRO_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_thrdpl\thrdpool.cpp ===
/*
 *	T H R D P O O L . C P P
 *
 *	DAV Thread pool implementation
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#pragma warning(disable:4001)	/* single line comments */
#pragma warning(disable:4050)	/* different code attributes */
#pragma warning(disable:4100)	/* unreferenced formal parameter */
#pragma warning(disable:4115)	/* named type definition in parentheses */
#pragma warning(disable:4127)	/* conditional expression is constant */
#pragma warning(disable:4200)	/* zero-sized array in struct/union */
#pragma warning(disable:4201)	/* nameless struct/union */
#pragma warning(disable:4206)	/* translation unit is empty */
#pragma warning(disable:4209)	/* benign typedef redefinition */
#pragma warning(disable:4214)	/* bit field types other than int */
#pragma warning(disable:4514)	/* unreferenced inline function */
#pragma warning(disable:4710)	/* unexpanded virtual function */

#include <windows.h>
#include <thrdpool.h>
#include <except.h>
#include <caldbg.h>
#include <profile.h>
#include <ex\idlethrd.h>

//	CDavWorkerThread ----------------------------------------------------------
//
class CDavWorkerThread
{
private:

	//	Owning thread pool
	//
	CPoolManager&	m_cpm;

	//	Handle to completion port
	//
	HANDLE			m_hCompletionPort;

	//	Handle to worker thread
	//
	HANDLE			m_hThread;

	//	Shutdown event
	//
	HANDLE			m_hShutdownEvent;

	//	Block on GetQueuedCompletionStatus for work items
	//
	VOID GetWorkCompletion(VOID);

	//	Thread function
	//
	static DWORD __stdcall ThreadDispatcher(PVOID pvWorkerThread);

	//	NOT IMPLEMENTED
	//
	CDavWorkerThread(const CDavWorkerThread& p);
	CDavWorkerThread& operator=(const CDavWorkerThread& p);

public:

	explicit CDavWorkerThread (CPoolManager& cpm, HANDLE h);
	virtual ~CDavWorkerThread();

	//	Expose shutdown event
	//
	HANDLE QueryShutdownEvent() { return m_hShutdownEvent; }
	BOOL ShutdownThread() { return SetEvent (m_hShutdownEvent); }

	//	Expose the thread handle
	//
	HANDLE QueryThread() { return m_hThread; }
};

//	CDavWorkerThread ----------------------------------------------------------
//
CDavWorkerThread::CDavWorkerThread (CPoolManager& cpm, HANDLE h)
	: m_cpm(cpm),
	  m_hCompletionPort(h),
	  m_hThread(0),
	  m_hShutdownEvent(0)
{
	DWORD dwThreadId;

	//	Create shutdown event
	//
	m_hShutdownEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
	if (m_hShutdownEvent == NULL)
	{
		DebugTrace ("Dav: WorkerThread: failed to create shutdown event: %ld", GetLastError());
		return;
	}

	//	Create worker thread
	//
	m_hThread = CreateThread (NULL,
							  0,
							  ThreadDispatcher,
							  this,
							  CREATE_SUSPENDED,
							  &dwThreadId);
	if (m_hThread == NULL)
	{
		DebugTrace ("Dav: WorkerThread: failed to create thread: %ld", GetLastError());
		return;
	}
	ResumeThread (m_hThread);

	return;
}

CDavWorkerThread::~CDavWorkerThread()
{
	CloseHandle (m_hThread);
	CloseHandle (m_hShutdownEvent);
}

DWORD __stdcall
CDavWorkerThread::ThreadDispatcher (PVOID pvWorkerThread)
{
	//	Get pointer to this CWorkerThread object
	//
	CDavWorkerThread * pwt = reinterpret_cast<CDavWorkerThread *>(pvWorkerThread);

	//
	//	Run the thread until we're done -- i.e. until GetWorkCompletion() returns
	//	normally.  Note that I say 'normally' here.  If an exception is thrown
	//	anywhere below GetWorkCompletion(), catch it, deal with it, and continue
	//	execution.  Don't let the thread die off.
	//
	for ( ;; )
	{
		try
		{
			//
			//	Install our Win32 exception handler for the lifetime of the thread
			//
			CWin32ExceptionHandler win32ExceptionHandler;

			//	If GetWorkCompletion() ever returns normally
			//	we're done.
			//
			pwt->GetWorkCompletion();
			return 0;
		}
		catch ( CDAVException& )
		{
		}
	}
}

VOID
CDavWorkerThread::GetWorkCompletion (void)
{
	Assert (m_hThread);
	Assert (m_hCompletionPort);

	do
	{
		CDavWorkContext * pwc = NULL;
		DWORD dwBytesTransferred;
		LPOVERLAPPED po;
		DWORD dwLastError = ERROR_SUCCESS;

		//	Wait for work items to be queued.  Note that since we are using
		//	the lpOverlapped structure, a return value of 0 from
		//	GetQueuedCompletionStatus() does not mean the function failed.
		//	It means the async I/O whose status is being returned failed.
		//	We need to make the error information available to the context
		//	so that it can do the appropriate thing.
		//
		//	From the MSDN documentation:
		//
		//	"If *lpOverlapped is not NULL and the function dequeues a completion
		//	 packet for a failed I/O operation from the completion port,
		//	 the return value is zero. The function stores information in the
		//	 variables pointed to by lpNumberOfBytesTransferred, lpCompletionKey,
		//	 and lpOverlapped. To get extended error information, call GetLastError."
		//
		if ( !GetQueuedCompletionStatus (m_hCompletionPort,
										 &dwBytesTransferred,
										 reinterpret_cast<PULONG_PTR>(&pwc),
										 &po,
										 INFINITE) )
		{
			dwLastError = GetLastError();
			// Do NOT break; See above comment.
		}

		//	Check for termination packet
		//
		if (!pwc)
		{
			DebugTrace ("Dav: WorkerThread: received termination packet\n");
			break;
		}

		//	Check for termination signal.
		//
		if (WAIT_TIMEOUT != WaitForSingleObject (m_hShutdownEvent, 0))
		{
			DebugTrace ("Dav: WorkerThread: shutdown has been signaled\n");
			break;
		}

		// Record the completion status data.
		//
		pwc->SetCompletionStatusData(dwBytesTransferred, dwLastError, po);

		//	Execute the work context.
		//
//		DebugTrace ("Dav: WorkerThread: calling DwDoWork()\n"); // NOISY debug trace! -- should be tagged
		pwc->DwDoWork();

	} while (TRUE);

	return;
}

//	CPoolManager --------------------------------------------------------------
//
BOOL
CPoolManager::FInitPool (DWORD dwConcurrency)
{
	INT i;

	//	Create the completion port
	//
	m_hCompletionPort = CreateIoCompletionPort (INVALID_HANDLE_VALUE,
												NULL,
												0,
												dwConcurrency);
	if (!m_hCompletionPort.get())
	{
		DebugTrace ("Dav: thrdpool: failed to create completion port:"
					"GetLastError is %d",
					GetLastError());
		return FALSE;
	}

	//	Create the workers
	//
	for (i = 0; i < CTHRD_WORKER; i++)
		m_rgpdwthrd[i] = new CDavWorkerThread (*this, m_hCompletionPort.get());

	return TRUE;
}

BOOL
CPoolManager::PostWork (CDavWorkContext * pWorkContext)
{
	Assert (Instance().m_hCompletionPort.get());

	//	Post the work request
	//
	if (!PostQueuedCompletionStatus (Instance().m_hCompletionPort.get(),
									 0,
									 (ULONG_PTR)pWorkContext,
									 0))
	{
		DebugTrace ("Dav: PostQCompletionStatus() failed: %d", GetLastError());
		return FALSE ;
	}

	return TRUE;
}

VOID
CPoolManager::TerminateWorkers()
{
	INT i;
	INT cWorkersRunning;
	HANDLE rgh[CTHRD_WORKER];

	//	Kill all workers that are running
	//
	for (cWorkersRunning = 0, i = 0; i < CTHRD_WORKER; i++)
	{
		if ( m_rgpdwthrd[i] )
		{
			PostWork (NULL);
			rgh[cWorkersRunning++] = m_rgpdwthrd[i]->QueryThread();
		}
	}

	//	Wait for all the threads to terminate
	//
	WaitForMultipleObjects (cWorkersRunning, rgh, TRUE, INFINITE);

	//	Delete the worker objects, and close the handles
	//
	for (i = 0; i < CTHRD_WORKER; i++)
	{
		delete m_rgpdwthrd[i];
		m_rgpdwthrd[i] = 0;
	}
}

CPoolManager::~CPoolManager()
{
	TerminateWorkers();

#ifdef	DBG
	for (INT i = 0; i < CTHRD_WORKER; i++)
		Assert (m_rgpdwthrd[i] == NULL);
#endif	// DBG
}

//	CDavWorkContext -----------------------------------------------------------
//

//	CDavWorkContext::~CDavWorkContext()
//
//		Out of line virtual destructor necessary for proper deletion
//		of objects of derived classes via this class.
//
CDavWorkContext::~CDavWorkContext()
{
}

//	CIdleWorkItem -------------------------------------------------------------
//
class CIdleWorkItem : 	public IIdleThreadCallBack
{
	//
	//	Work context to post
	//
	CDavWorkContext * m_pWorkContext;

	//
	//	Time (in milliseconds) `til when the context should be posted
	//
	DWORD m_dwMsecDelay;

	//	NOT IMPLEMENTED
	//
	CIdleWorkItem(const CIdleWorkItem& );
	CIdleWorkItem& operator=(const CIdleWorkItem& );

public:
	//	CREATORS
	//
	CIdleWorkItem( CDavWorkContext * pWorkContext,
				   DWORD dwMsecDelay ) :
		m_pWorkContext(pWorkContext),
		m_dwMsecDelay(dwMsecDelay)
	{
	}

	~CIdleWorkItem() {}

	//	ACCESSORS
	//
	DWORD DwWait()
	{
		return m_dwMsecDelay;
	}

	//	MANIPULATORS
	//
	BOOL FExecute()
	{
		//
		//	Return FALSE to remove idle work item, TRUE to keep it.
		//	We want to remove the item if we successfully posted it
		//	to the work queue.  We want to keep it otherwise (and
		//	presumably attempt to repost it later...)
		//
		return !CPoolManager::PostWork( m_pWorkContext );
	}

	VOID Shutdown()
	{
		//
		//	We have no idea what the work context may be waiting for.
		//	It could be something that would hang shutdown if it
		//	doesn't get another chance to run.  So just run it.
		//
		(void) FExecute();
	}
};

BOOL
CPoolManager::PostDelayedWork (CDavWorkContext * pWorkContext,
							   DWORD dwMsecDelay)
{
	//
	//$OPT	If the delay is very short and the queue length of
	//$OPT	the worker threads is "long enough" such that the
	//$OPT	probability that it will be at least dwMsecDelay
	//$OPT	milliseconds before the work context is executed,
	//$OPT	consider putting the work context directly on the
	//$OPT	worker queues.
	//
	auto_ref_ptr<CIdleWorkItem> pIdleWorkItem(new CIdleWorkItem(pWorkContext, dwMsecDelay));

	return pIdleWorkItem.get() && ::FRegister( pIdleWorkItem.get() );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_vroot\cvroot.cpp ===
/*
 *	C V R O O T . C P P
 *
 *	Cached vroot information
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include <_vroot.h>

DEC_CONST WCHAR gc_wszPort80[]	= L":80";
DEC_CONST UINT gc_cchPort80		= CchConstString(gc_wszPort80);
DEC_CONST WCHAR gc_wszPort443[]	= L":443";
DEC_CONST UINT gc_cchPort443	= CchConstString(gc_wszPort443);


//	CVRoot --------------------------------------------------------------------
//
CVRoot::CVRoot(
	/* [in] */ LPCWSTR pwszMetaUrl,
	/* [in] */ UINT cchMetaUrlPrefix,
	/* [in] */ UINT cchServerDefault,
	/* [in] */ LPCWSTR pwszServerDefault,
	/* [in] */ IMDData* pMDData ) :
	m_pMDData(pMDData),
	m_pwszMbPath(m_sb.AppendWithNull(pwszMetaUrl)),
	m_pwszServer(pwszServerDefault), // Static from CChildVRCache
	m_cchServer(cchServerDefault),
	m_pwszPort(gc_wszPort80),
	m_cchPort(gc_cchPort80),
	m_fSecure(FALSE),
	m_fDefaultPort(TRUE)
{
	LPCWSTR pwsz;
	LPCWSTR pwszPort;

	//	Find the vroot in the metabase path
	//
	Assert (cchMetaUrlPrefix <= static_cast<UINT>(wcslen(m_pwszMbPath)));
	m_pwszVRoot = m_pwszMbPath + cchMetaUrlPrefix;
	m_cchVRoot = static_cast<UINT>(wcslen(m_pwszVRoot));

	//	Make a wide copy of the physical path
	//
	Assert (pMDData->PwszVRPath());
	pwsz =  pMDData->PwszVRPath();
	m_cchVRPath = static_cast<UINT>(wcslen(pwsz));
	m_pwszVRPath = static_cast<LPWSTR>(g_heap.Alloc(CbSizeWsz(m_cchVRPath)));
	memcpy(m_pwszVRPath, pwsz, CbSizeWsz(m_cchVRPath));

	//	Process the server information out of the server bindings
	//
	if (NULL != (pwsz = pMDData->PwszBindings()))
	{
		Assert (pwsz);
		pwszPort = wcschr (pwsz, L':');

		//	If there was no leading server name, then get the default
		//	server name for the machine
		//
		if (pwsz != pwszPort)
		{
			//	A specific name was specified, so use that instead of
			//	the default
			//
			m_cchServer = static_cast<UINT>(pwszPort - pwsz);
			m_pwszServer = pwsz;
		}

		//	For the port, trim off the trailing ":xxx"
		//
		if (NULL != (pwsz = wcschr (pwszPort + 1, L':')))
		{
			m_cchPort = static_cast<UINT>(pwsz - pwszPort);
			m_pwszPort = pwszPort;

			if ((gc_cchPort80 != m_cchPort) ||
				wcsncmp (m_pwszPort,
						 gc_wszPort80,
						 gc_cchPort80))
			{
				m_fDefaultPort = FALSE;
			}

			if ((gc_cchPort443 == m_cchPort) &&
				!wcsncmp (m_pwszPort,
						  gc_wszPort443,
						  gc_cchPort443))
			{
				m_fSecure = TRUE;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_vroot\_vroot.cpp ===
/*
 *	_ V R O O T . C P P
 *
 *	vroot lookup precompiled header
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_vroot.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_vroot\_vroot.h ===
/*
 *	_ V R O O T . H
 *
 *	vroot lookup precompiled header
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#pragma warning(disable:4001)	/* single line comments */
#pragma warning(disable:4050)	/* different code attributes */
#pragma warning(disable:4100)	/* unreferenced formal parameter */
#pragma warning(disable:4115)	/* named type definition in parentheses */
#pragma warning(disable:4127)	/* conditional expression is constant */
#pragma warning(disable:4201)	/* nameless struct/union */
#pragma warning(disable:4206)	/* translation unit is empty */
#pragma warning(disable:4209)	/* benign typedef redefinition */
#pragma warning(disable:4214)	/* bit field types other than int */
#pragma warning(disable:4514)	/* unreferenced inline function */
#pragma warning(disable:4710)

//$HACK!
//
//	Define _WINSOCKAPI_ to keep windows.h from including winsock.h,
//	whose declarations would be redefined in winsock2.h,
//	which is included by iisextp.h,
//	which we include in davimpl.h!
//
#define _WINSOCKAPI_
#include <windows.h>
#include <ocidl.h>
#include <lm.h>


#include <caldbg.h>
#include <calrc.h>
#include <calpc.h>
#include <except.h>
#include <autoptr.h>
#include <buffer.h>
#include <gencache.h>
#include <sz.h>
#include <davimpl.h>
#include <davmb.h>
#include <vrenum.h>
#include <sz.h>

#define CElems(_rg)		(sizeof(_rg)/sizeof(_rg[0]))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_vroot\vrenum.cpp ===
/*
 *	V R E N U M . C P P
 *
 *	Virtual root enumeration
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_vroot.h"

LPCWSTR __fastcall
PwszStripMetaPrefix (LPCWSTR pwszUrl)
{
	//	All metabase virtual roots are identified by the
	//	metabase path, minus a given prefix.
	//
	//	These paths uniformly look like:
	//
	//		'/lm/w3svc/' <site number> '/root'
	//
	//	Since the <site number> is an unnamed integer, the trick to
	//	skipping this stuff is to search for '/root' in the string
	//	and then bump ahead 5 characters.
	//
	Assert (pwszUrl);
	if (NULL == (pwszUrl = wcsstr(pwszUrl, L"/root")))
		return NULL;

	return pwszUrl + 5;
}

//	CVRootCache ---------------------------------------------------------------
//
VOID
CChildVRCache::OnNotify (DWORD dwElements, MD_CHANGE_OBJECT_W pcoList[])
{
	//	Go through the list of changes and see if any scriptmap/vrpath/bindings
	//	changes have been made to the metabase.  If any have changed, then we
	//	want to invalidate the cache.
	//
	for (UINT ice = 0; ice < dwElements; ice++)
	{
		for (UINT ico = 0; ico < pcoList[ice].dwMDNumDataIDs; ico++)
		{
			//	Only invalidate if the stuff that we use to compute our
			//	values changes changes.
			//
			if ((pcoList[ice].pdwMDDataIDs[ico] == MD_SERVER_BINDINGS) ||
				(pcoList[ice].pdwMDDataIDs[ico] == MD_VR_PATH))
			{
				DebugTrace ("Dav: CVRoot: invalidating cache\n");
				Invalidate();
				return;
			}
		}
	}
}

VOID
CChildVRCache::RefreshOp(const IEcb& ecb)
{
	//	Out with the old...
	//
	m_cache.Clear();
	m_sb.Clear();

	//	... and in with the new!
	//
	(void) ScCacheVroots(ecb);
}

//	Cache construction --------------------------------------------------------
//
//	class CVirtualRootMetaOp --------------------------------------------------
//
class CVirtualRootMetaOp : public CMetaOp
{
	enum { DONT_INHERIT = 0 };

	CVRCache& m_cache;

	ChainedStringBuffer<WCHAR>& m_sb;
	LPCWSTR m_pwszServerDefault;
	UINT m_cchServerDefault;

	//	non-implemented
	//
	CVirtualRootMetaOp& operator=( const CVirtualRootMetaOp& );
	CVirtualRootMetaOp( const CVirtualRootMetaOp& );

	//	Subclass' operation to perform for each node where
	//	a value is explicitly set.
	//
	virtual SCODE __fastcall ScOp(LPCWSTR pwszMbPath, UINT cch);

public:

	virtual ~CVirtualRootMetaOp() {}
	CVirtualRootMetaOp (const IEcb * pecb,
						LPCWSTR pwszPath,
						UINT cchServerDefault,
						LPCWSTR pwszServerDefault,
						ChainedStringBuffer<WCHAR>& sb,
						CVRCache& cache)
			: CMetaOp (pecb, pwszPath, MD_VR_PATH, STRING_METADATA, FALSE),
			  m_pwszServerDefault(pwszServerDefault),
			  m_cchServerDefault(cchServerDefault),
			  m_cache(cache),
			  m_sb(sb)
	{
	}
};

DEC_CONST WCHAR gc_wszLmW3svc[]	= L"/lm/w3svc";
DEC_CONST UINT gc_cchLmW3svc	= CchConstString(gc_wszLmW3svc);

SCODE __fastcall
CVirtualRootMetaOp::ScOp(LPCWSTR pwszMbPath, UINT cch)
{
	CStackBuffer<WCHAR,MAX_PATH> wszBuf;
	LPWSTR pwsz;
	LPCWSTR pwszUrl;
	SCODE sc = S_OK;
	auto_ref_ptr<CVRoot> pvr;
	auto_ref_ptr<IMDData> pMDData;

	Assert (MD_VR_PATH == m_dwId);
	Assert (STRING_METADATA == m_dwType);

	//	If the url ends in a trailing slash, snip it...
	//
	if (cch && (L'/' == pwszMbPath[cch - 1]))
		cch -= 1;

	//	Construct the full metabase path
	//
	if (NULL == wszBuf.resize(CbSizeWsz(gc_cchLmW3svc + cch)))
		return E_OUTOFMEMORY;

	memcpy (wszBuf.get(), gc_wszLmW3svc, gc_cchLmW3svc * sizeof(WCHAR));
	memcpy (wszBuf.get() + gc_cchLmW3svc, pwszMbPath, cch * sizeof(WCHAR));
	wszBuf[gc_cchLmW3svc + cch] = L'\0';

	//	Make a copy of the meta path for use as the cache
	//	key and for use by the CVRoot object.
	//
	_wcslwr (wszBuf.get());
	pwsz = m_sb.Append (CbSizeWsz(gc_cchLmW3svc + cch), wszBuf.get());

	//	Create a CVRoot object and cache it.  First get the metadata
	//	associated with this path and then construct the CVRoot out
	//	of that.
	//
	sc = HrMDGetData (*m_pecb, pwsz, pwsz, pMDData.load());
	if (FAILED (sc))
		goto ret;

	if (NULL != (pwszUrl = PwszStripMetaPrefix (pwsz)))
	{
		//$ RAID:304272:  There is a stress app/case where roots
		//	are being created that have no vrpath.
		//
		if (NULL != pMDData->PwszVRPath())
		{
			//	Construct the virtual root object
			//
			pvr = new CVRoot (pwsz,
							  static_cast<UINT>(pwszUrl - pwsz),
							  m_cchServerDefault,
							  m_pwszServerDefault,
							  pMDData.get());

			DebugTrace ("Dav: CVRoot: caching vroot\n"
						" MetaPath: %S\n"
						" VrPath: %S\n"
						" Bindings: %S\n",
						pwsz,
						pMDData->PwszVRPath(),
						pMDData->PwszBindings());

			m_cache.FSet (CRCWsz(pwsz), pvr);
		}
		//
		//$	RAID:304272: end
	}

ret:

	return sc;
}

SCODE
CChildVRCache::ScCacheVroots (const IEcb& ecb)
{
	SCODE sc = S_OK;

	CVirtualRootMetaOp vrmo(&ecb,
							gc_wszLmW3svc,
							m_cchServerDefault,
							m_wszServerDefault,
							m_sb,
							m_cache);

	//	Gather all the virtual root information
	//
	sc = vrmo.ScMetaOp();
	if (FAILED (sc))
		goto ret;

ret:

	return sc;
}

//	CFindChildren -------------------------------------------------------------
//
BOOL
CChildVRCache::CFindChildren::operator()(
	/* [in] */ const CRCWsz& crcwsz,
	/* [in] */ const auto_ref_ptr<CVRoot>& arpRoot)
{
	//	If the root we are checking is a proper ancestor to the
	//	vroot we are checking, then we will want to push it onto
	//	the stack.
	//
	if (!_wcsnicmp (crcwsz.m_pwsz, m_pwsz, m_cch))
	{
		LPCWSTR pwsz = crcwsz.m_pwsz;

		//	There are two interesting cases here.
		//
		//	- The child vroot has a physical path that has
		//	  diverged from the parent's.
		//
		//	- The child vroot has a physical path that aligns
		//	  perfectly with the parent.
		//
		//	ie. "/fs" has a VrPath of "f:\fs" and "/fs/bvt" has
		//	a VrPath of "f:\fs\bvt"
		//
		//	In this latter case, needs to be handled by the
		//	piece of code that is doing the traversing.  In
		//	most cases, this done by seeing if we traverse
		//	down into a vroot, etc.
		//
		Assert (L'\0' == m_pwsz[m_cch]);
		if ((L'/' == pwsz[m_cch]) || (L'/' == pwsz[m_cch - 1]))
		{
			//	Push it on the stack
			//
			m_vrl.push_back (CSortableStrings(m_sb.AppendWithNull(pwsz)));
		}
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_xml\chartype.h ===
/*
 * CharType.h 1.0 6/15/98
 * 
 * Character type constants and functions
 *
 *		Copied from nt\private\inet\xml\core\util\chartype.hxx 
 *		This is the logic used by XML parser. we use it for XML emitting
 *		so that we can make sure we emit XML friendly chars.
 *
 *  Copyright (C) 1998,1999 Microsoft Corporation. All rights reserved. * 
 */
 
#ifndef _CORE_UTIL_CHARTYPE_H_
#define _CORE_UTIL_CHARTYPE_H_


//==============================================================================

static const short TABLE_SIZE = 128;

enum
{
    FWHITESPACE    = 1,
    FDIGIT         = 2,
    FLETTER        = 4,
    FMISCNAME      = 8,
    FSTARTNAME     = 16,
    FCHARDATA      = 32
};

extern int g_anCharType[TABLE_SIZE];

inline bool isLetter(WCHAR ch)
{
    return (ch >= 0x41) && IsCharAlphaW(ch);
        // isBaseChar(ch) || isIdeographic(ch);
}

inline bool isAlphaNumeric(WCHAR ch)
{
    return (ch >= 0x30 && ch <= 0x39) || ((ch >= 0x41) && IsCharAlphaW(ch));
        // isBaseChar(ch) || isIdeographic(ch);
}

inline bool isDigit(WCHAR ch)
{
    return (ch >= 0x30 && ch <= 0x39);
}

inline bool isHexDigit(WCHAR ch)
{
    return (ch >= 0x30 && ch <= 0x39) || (ch >= 'a' && ch <= 'f') || (ch >= 'A' && ch <= 'F');
}

inline bool isCombiningChar(WCHAR ch)
{
    return false;
}

inline bool isExtender(WCHAR ch)
{
    return (ch == 0xb7);
}

inline int isNameChar(WCHAR ch)
{
    return  (ch < TABLE_SIZE ? (g_anCharType[ch] & (FLETTER | FDIGIT | FMISCNAME | FSTARTNAME)) :
              ( isAlphaNumeric(ch) || 
                ch == '-' ||  
                ch == '_' ||
                ch == '.' ||
                ch == ':' ||
                isCombiningChar(ch) ||
                isExtender(ch)));
}

inline int isStartNameChar(WCHAR ch)
{
    return  (ch < TABLE_SIZE) ? (g_anCharType[ch] & (FLETTER | FSTARTNAME))
        : (isLetter(ch) || (ch == '_' || ch == ':'));
        
}

inline int isCharData(WCHAR ch)
{
    // it is in the valid range if it is greater than or equal to
    // 0x20, or it is white space.
    return (ch < TABLE_SIZE) ?  (g_anCharType[ch] & FCHARDATA)
        : ((ch < 0xD800 && ch >= 0x20) ||   // Section 2.2 of spec.
            (ch >= 0xE000 && ch < 0xfffe));
}

#endif _CORE_UTIL_CHARTYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_xml\chartype.cpp ===
/*
 * CharType.cxx 1.0 6/15/98
 * 
 * Character type constants and functions
 *
 *		Copied from nt\private\inet\xml\core\util\chartype.cxx 
 *		This is the logic used by XML parser. we use it for XML emitting
 *		so that we can make sure we emit XML friendly chars.
 *
 *  Copyright (C) 1998,1999 Microsoft Corporation. All rights reserved. * 
 */

#include "_xml.h"

int g_anCharType[TABLE_SIZE] = { 
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0 | FWHITESPACE | FCHARDATA,
    0 | FWHITESPACE | FCHARDATA,
    0,
    0,
    0 | FWHITESPACE | FCHARDATA,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0 | FWHITESPACE | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FMISCNAME | FCHARDATA,
    0 | FMISCNAME | FCHARDATA,
    0 | FCHARDATA,
    0 | FDIGIT | FCHARDATA,
    0 | FDIGIT | FCHARDATA,
    0 | FDIGIT | FCHARDATA,
    0 | FDIGIT | FCHARDATA,
    0 | FDIGIT | FCHARDATA,
    0 | FDIGIT | FCHARDATA,
    0 | FDIGIT | FCHARDATA,
    0 | FDIGIT | FCHARDATA,
    0 | FDIGIT | FCHARDATA,
    0 | FDIGIT | FCHARDATA,
    0 | FSTARTNAME | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FMISCNAME | FSTARTNAME | FCHARDATA,
    0 | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_xml\var.cpp ===
/*
 *	V A R . C P P
 *
 *	XML document processing
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_xml.h"

//	ScVariantTypeFromString()
//
//	Returns the variant type associated with a dav datatype string
//
SCODE
ScVariantTypeFromString (LPCWSTR pwszType, USHORT& vt)
{
	SCODE sc = S_OK;

	//	NULL, "string" and "uri"
	//
	if (!pwszType ||
		!_wcsicmp (pwszType, gc_wszDavType_String) ||
		!_wcsicmp (pwszType, gc_wszUri))
	{
		vt = VT_LPWSTR;
	}
	//	integer
	//
	else if (!_wcsicmp (pwszType, gc_wszDavType_Int))
	{
		vt = VT_I4;
	}
	//	boolean.tf
	//
	else if (!_wcsicmp (pwszType, gc_wszDavType_Boolean))
	{
		vt = VT_BOOL;
	}
	//	float (Floating/Reals)
	//
	else if (!_wcsicmp (pwszType, gc_wszDavType_Float))
	{
		vt = VT_R8;
	}
	//	date.iso8601
	//
	else if (!_wcsicmp (pwszType, gc_wszDavType_Date_ISO8601))
	{
		vt = VT_FILETIME;
	}
	else
	{
		DebugTrace ("ScVariantTypeFromString(): unknown type");
		vt = VT_LPWSTR;
		sc = S_OK;
	}

	return sc;
}

//	ScVariantValueFromString() ------------------------------------------------
//
//	Sets the value of a PROPVARIANT
//
SCODE
ScVariantValueFromString (PROPVARIANT& var, LPCWSTR pwszValue)
{
	SCODE sc = S_OK;

	LPWSTR pwsz;
	SYSTEMTIME st;

	switch (var.vt)
	{
		case VT_LPWSTR:

			if (pwszValue)
			{
				pwsz = static_cast<LPWSTR>(CoTaskMemAlloc(CbSizeWsz(wcslen(pwszValue))));
				if (NULL == pwsz)
				{
					DebugTrace ("ScVariantValueFromString() - CoTaskMemAlloc() failed to allocate %d bytes\n", CbSizeWsz(wcslen(pwszValue)));

					sc = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
					goto ret;
				}

				wcscpy (pwsz, pwszValue);
				var.pwszVal = pwsz;
			}
			else
				var.pwszVal = NULL;

			break;

		case VT_I4:

			Assert (pwszValue);
			var.lVal = _wtoi (pwszValue);
			break;

		case VT_BOOL:

#pragma warning(disable:4310)	//	wtypes.h is broken

			Assert (pwszValue);
			if (!_wcsnicmp (pwszValue, gc_wsz1, 1))
				var.boolVal = VARIANT_TRUE;
			else if (!_wcsnicmp (pwszValue, gc_wsz0, 1))
				var.boolVal = VARIANT_FALSE;
			else
			{
				sc = E_INVALIDARG;
				goto ret;
			}
			break;

#pragma warning(default:4310)	//	wtypes.h is broken

		case VT_R8:

			Assert (pwszValue);
			var.dblVal = wcstod (pwszValue, NULL);
			break;

		case VT_FILETIME:

			Assert (pwszValue);
			memset (&var.filetime, 0, sizeof(FILETIME));
			if (!FGetSystimeFromDateIso8601 (pwszValue, &st))
			{
				sc = E_INVALIDARG;
				goto ret;
			}
			SystemTimeToFileTime (&st, &var.filetime);
			break;

		default:

			Assert (pwszValue);
			TrapSz ("ScVariantValueFromString() unknown type");

			sc = E_INVALIDARG;
			goto ret;
	}

ret:

	return sc;
}

//	ScEmitFromVariant() ------------------------------------------------
//
SCODE
ScEmitFromVariant (CXMLEmitter& emitter,
	CEmitterNode& enParent,
	LPCWSTR pwszTag,
	PROPVARIANT& var)
{
	CEmitterNode en;
	CStackBuffer<CHAR,110> szBuf;
	CStackBuffer<WCHAR,128> wszBuf;
	LPCWSTR	pwszType = NULL;
	LPWSTR pwszValue = NULL;
	SCODE sc = S_OK;
	SYSTEMTIME 	st;
	UINT cch;
	UINT i;
	VARIANT* pvarTrue = reinterpret_cast<VARIANT*>(&var);

	switch (var.vt)
	{
		case VT_NULL:
		case VT_EMPTY:

			break;

		case VT_BSTR:

			pwszValue = static_cast<LPWSTR>(var.bstrVal);
			break;

		case VT_LPWSTR:

			pwszValue = var.pwszVal;
			break;

		case VT_LPSTR:

			if (!var.pszVal)
				break;

			cch = static_cast<UINT>(strlen (var.pszVal));
			pwszValue = wszBuf.resize(CbSizeWsz(cch));
			if (NULL == pwszValue)
			{
				sc = E_OUTOFMEMORY;
				goto ret;
			}

			//  We know that the numbers are in ASCII codepage and we know
			//	that the buffer size is big enough.
			//
			cch = MultiByteToWideChar (CP_ACP,
									   MB_ERR_INVALID_CHARS,
									   var.pszVal,
									   cch + 1,
									   pwszValue,
									   wszBuf.celems());
			if (0 == cch)
			{
				sc = HRESULT_FROM_WIN32(GetLastError());
				Assert(FAILED(sc));
				goto ret;
			}
			break;

		case VT_I1:

			pwszType = gc_wszDavType_Int;
			_itow (pvarTrue->cVal, wszBuf.get(), 10);
			pwszValue = wszBuf.get();
			break;

		case VT_UI1:

			pwszType = gc_wszDavType_Int;
			_ultow (var.bVal, wszBuf.get(), 10);
			pwszValue = wszBuf.get();
			break;

		case VT_I2:

			pwszType = gc_wszDavType_Int;
			_itow (var.iVal, wszBuf.get(), 10);
			pwszValue = wszBuf.get();
			break;

		case VT_UI2:

			pwszType = gc_wszDavType_Int;
			_ultow (var.uiVal, wszBuf.get(), 10);
			pwszValue = wszBuf.get();
			break;

		case VT_I4:

			pwszType = gc_wszDavType_Int;
			_ltow (var.lVal, wszBuf.get(), 10);
			pwszValue = wszBuf.get();
			break;

		case VT_UI4:

			pwszType = gc_wszDavType_Int;
			_ultow (var.ulVal, wszBuf.get(), 10);
			pwszValue = wszBuf.get();
			break;

		case VT_I8:

			pwszType = gc_wszDavType_Int;

			//$ REVIEW: negative values of _int64 seem to have problems in
			//	the __i64tow() API.  Handle those cases ourselves by using the wrapper
			//  function Int64ToPwsz.
			//
			Int64ToPwsz (&var.hVal.QuadPart, wszBuf.get(), wszBuf.size());
			//
			//$ REVIEW: end

			pwszValue = wszBuf.get();
			break;

		case VT_UI8:

			pwszType = gc_wszDavType_Int;
			_ui64tow (var.uhVal.QuadPart, wszBuf.get(), 10);
			pwszValue = wszBuf.get();
			break;

		case VT_INT:

			pwszType = gc_wszDavType_Int;
			_itow (pvarTrue->intVal, wszBuf.get(), 10);
			pwszValue = wszBuf.get();
			break;

		case VT_UINT:

			pwszType = gc_wszDavType_Int;
			_ultow (pvarTrue->uintVal, wszBuf.get(), 10);
			pwszValue = wszBuf.get();
			break;

		case VT_BOOL:

			pwszType = gc_wszDavType_Boolean;
			_itow (!(VARIANT_FALSE == var.boolVal), wszBuf.get(), 10);
			pwszValue = wszBuf.get();
			break;

		case VT_R4:
			//	_gcvt could add 8 extra chars then the number of digits asked
			//	for example -3.1415e+019, '-','.' "e+019", plus the terminating
			//	NULL doesn't count in digits asked. so we have to reserve
			//	enough space in the provided buffer. using 11 to make sure
			//	we are absolutely safe.
			//
			_gcvt (var.fltVal, szBuf.celems() - 11, szBuf.get());

			cch = static_cast<UINT>(strlen(szBuf.get()));
			pwszValue = wszBuf.resize(CbSizeWsz(cch));
			if (NULL == pwszValue)
			{
				sc = E_OUTOFMEMORY;
				goto ret;
			}

			//  We know that the numbers are in ASCII codepage and we know
			//	that the buffer size is big enough.
			//
			cch = MultiByteToWideChar(CP_ACP,
									  MB_ERR_INVALID_CHARS,
									  szBuf.get(),
									  cch + 1,
									  wszBuf.get(),
									  wszBuf.celems());
			if (0 == cch)
			{
				sc = HRESULT_FROM_WIN32(GetLastError());
				Assert(FAILED(sc));
				goto ret;
			}

			pwszType = gc_wszDavType_R4;
			break;

		case VT_R8:
			//	_gcvt could add 8 extra chars then the number of digits asked
			//	for example -3.1415e+019, '-','.' "e+019", plus the terminating
			//	NULL doesn't count in digits asked. so we have to reserve
			//	enough space in the provided buffer. using 11 to make sure
			//	we are absolutely safe.
			//
			_gcvt (var.dblVal, szBuf.celems() - 11, szBuf.get());

			cch = static_cast<UINT>(strlen(szBuf.get()));
			pwszValue = wszBuf.resize(CbSizeWsz(cch));
			if (NULL == pwszValue)
			{
				sc = E_OUTOFMEMORY;
				goto ret;
			}

			//  We know that the numbers are in ASCII codepage and we know
			//	that the buffer size is big enough.
			//
			cch = MultiByteToWideChar(CP_ACP,
									  MB_ERR_INVALID_CHARS,
									  szBuf.get(),
									  cch + 1,
									  wszBuf.get(),
									  wszBuf.celems());
			if (0 == cch)
			{
				sc = HRESULT_FROM_WIN32(GetLastError());
				Assert(FAILED(sc));
				goto ret;
			}

			pwszType = gc_wszDavType_Float;
			break;

		case VT_FILETIME:

			if (!FileTimeToSystemTime (&var.filetime, &st))
			{
				//	In case the filetime is invalid, default to zero
				//
				FILETIME ftDefault = {0};
				FileTimeToSystemTime (&ftDefault, &st);
			}
			if (!FGetDateIso8601FromSystime(&st, wszBuf.get(), wszBuf.celems()))
				return E_INVALIDARG;

			pwszType = gc_wszDavType_Date_ISO8601;
			pwszValue = wszBuf.get();
			break;

		case VT_VECTOR | VT_LPWSTR:
		{
			//	Create the emitter node;
			//
			sc = en.ScConstructNode (emitter,
									 enParent.Pxn(),
									 pwszTag,
									 NULL,
									 gc_wszDavType_Mvstring);
			if (FAILED (sc))
				goto ret;

			//	Add the values
			//
			for (i = 0; i < var.calpwstr.cElems; i++)
			{
				CEmitterNode enSub;
				sc = en.ScAddNode (gc_wszXml_V,
								   enSub,
								   var.calpwstr.pElems[i]);
				if (FAILED (sc))
					goto ret;
			}

			//	In this case we have built up the node ourselves.  We do not
			//	want to fall into recreating the node.
			//
			return S_OK;
		}

		case VT_CY:
		case VT_DATE:
		case VT_DISPATCH:
		case VT_ERROR:
		case VT_VARIANT:
		case VT_UNKNOWN:
		case VT_DECIMAL:
		case VT_RECORD:
		case VT_BLOB:
		case VT_STREAM:
		case VT_STORAGE:
		case VT_STREAMED_OBJECT:
		case VT_STORED_OBJECT:
		case VT_BLOB_OBJECT:
		case VT_CF:
		case VT_CLSID:
		default:

			TrapSz ("ScEmitterNodeFromVariant() unknown type");
			return E_UNEXPECTED;
			break;
	}

	//	Create the emitter node
	//
	sc = en.ScConstructNode (emitter,
							 enParent.Pxn(),
							 pwszTag,
							 pwszValue,
							 pwszType);
	if (FAILED (sc))
		goto ret;

ret:
	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_xml\xfind.cpp ===
/*
 *	X F I N D . C P P
 *
 *	XML push model parsing for PROPFIND requests
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_xml.h"

//	class CNFFind -------------------------------------------------------------
//
SCODE
CNFFind::ScCompleteAttribute (void)
{
	if (m_state == ST_ENUMLIMIT)
		m_state = ST_INENUMREPORT;
	return S_OK;
}

SCODE
CNFFind::ScCompleteChildren (
	/* [in] */ BOOL fEmptyNode,
	/* [in] */ DWORD dwType,
	/* [in] */ const WCHAR __RPC_FAR *pwcText,
	/* [in] */ ULONG ulLen)
{
	switch (m_state)
	{
		case ST_PROPFIND:

			m_state = ST_NODOC;
			break;

		case ST_PROPS:
		case ST_ALLPROP:
		case ST_ALLNAMES:
		case ST_ENUMREPORT:

			m_state = ST_PROPFIND;
			break;

		case ST_INPROP:

			m_state = ST_PROPS;
			break;

		case ST_INENUMREPORT:

			m_state = ST_ENUMREPORT;
			break;

		case ST_ALLPROPFULL:

			m_state = ST_ALLPROP;
			break;

		case ST_ALLNAMESFULL:

			m_state = ST_ALLNAMES;
			break;

		case ST_ALLPROP_EXCLUDE:

			m_state = ST_ALLPROPFULL;
			break;

		case ST_ALLPROP_EXCLUDE_INPROP:

			m_state = ST_ALLPROP_EXCLUDE;
			break;

		case ST_ALLPROP_INCLUDE:

			m_state = ST_ALLPROPFULL;
			break;

		case ST_ALLPROP_INCLUDE_INPROP:

			m_state = ST_ALLPROP_INCLUDE;
			break;

	}
	return S_OK;
}

SCODE
CNFFind::ScHandleNode (
	/* [in] */ DWORD dwType,
	/* [in] */ DWORD dwSubType,
	/* [in] */ BOOL fTerminal,
	/* [in] */ const WCHAR __RPC_FAR *pwcText,
	/* [in] */ ULONG ulLen,
	/* [in] */ ULONG ulNamespaceLen,
	/* [in] */ const WCHAR __RPC_FAR *pwcNamespace,
	/* [in] */ const ULONG ulNsPrefixLen)
{
	LPCWSTR pwszTag;
	CStackBuffer<WCHAR> wsz;
	SCODE sc = S_FALSE;
	UINT cch;

	//	In the case of a PROPFIND, all the nodes that we are
	//	interested are XML_ELEMENT nodes.  Anything else can
	//	(and should) be safely ignored.
	//
	//	Returning S_FALSE signifies that we are not handling
	//	the node (and therefore its children).
	//
	if (dwType == XML_ELEMENT)
	{
		cch = ulNamespaceLen + ulLen;
		pwszTag = wsz.resize(CbSizeWsz(cch));
		if (NULL == pwszTag)
		{
			sc = E_OUTOFMEMORY;
			goto ret;
		}
		wcsncpy (wsz.get(), pwcNamespace, ulNamespaceLen);
		wcsncpy (wsz.get() + ulNamespaceLen, pwcText, ulLen);
		*(wsz.get() + cch) = 0;

		switch (m_state)
		{
			case ST_NODOC:

				//	If this is the topmost node in a propfind request,
				//	transition to the next state.  Since there is no
				//	parent node to provide scoping, FIsTag() cannot be
				//	used here!
				//
				if (!wcscmp (pwszTag, gc_wszPropfind))
				{
					m_state = ST_PROPFIND;
					sc = S_OK;
				}
				break;

			case ST_PROPFIND:

				//	Look for our well know node types
				//
				if (FIsTag (pwszTag, gc_wszAllprop))
				{
					//	Tell the context we are interested in all
					//	properties of the given resources
					//
					sc = m_cfc.ScGetAllProps (NULL);
					if (FAILED (sc))
						goto ret;

					m_state = ST_ALLPROP;
				}
				else if (FIsTag (pwszTag, gc_wszPropname))
				{
					//	Tell the context we are interested in all
					//	property names available in the given resources
					//
					sc = m_cfc.ScGetAllNames (NULL);
					if (FAILED (sc))
						goto ret;

					m_state = ST_ALLNAMES;
				}
				else if (FIsTag (pwszTag, gc_wszProp))
				{
					m_state = ST_PROPS;
					sc = S_OK;
				}
				else if (FIsTag (pwszTag, gc_wszEnumReport))
				{
					sc = m_cfc.ScEnumReport ();
					if (FAILED(sc))
						goto ret;

					m_state = ST_ENUMREPORT;
				}
				break;

			case ST_PROPS:

				//	Add the specific property to the set of properties
				//	we are interested in.
				//
				sc = m_cfc.ScAddProp (NULL, pwszTag, CFindContext::FIND_PROPLIST_INCLUDE);
				if (FAILED (sc))
					goto ret;

				m_state = ST_INPROP;
				break;

			case ST_ENUMREPORT:

				//	Add the report to the report list
				//
				sc = m_cfc.ScSetReportName (cch, pwszTag);
				if (FAILED(sc))
					goto ret;

				if (S_OK == sc)
					m_state = ST_INENUMREPORT;
				break;

			case ST_ALLPROP:
			case ST_ALLNAMES:

				//	Look for full fidelity node
				//
				if (FIsTag (pwszTag, gc_wszFullFidelity))
				{
					//	Tell the context we are interested in all
					//	properties with full fidelity of the given
					//	resources
					//
					sc = m_cfc.ScGetFullFidelityProps ();
					if (FAILED (sc))
						goto ret;

					if (ST_ALLPROP == m_state)
					{
						m_state = ST_ALLPROPFULL;
					}
					else
					{
						m_state = ST_ALLNAMESFULL;
					}
				}

			case ST_ALLPROPFULL:

				//	for the all-props full-fidelity case, there could be
				//	two lists of props: one exclude list and one include
				//	list. Exclude list specifies the props the client is
				//	not interested in and hence need to be removed from
				//	the response. Similarly include list specifies the
				//	extra properties the client is interested in.
				//
				if (FIsTag (pwszTag, gc_wszFullFidelityExclude))
				{
					m_state = ST_ALLPROP_EXCLUDE;
					sc = S_OK;
				}
				else if (FIsTag (pwszTag, gc_wszFullFidelityInclude))
				{
					m_state = ST_ALLPROP_INCLUDE;
					sc = S_OK;
				}
				break;


			case ST_ALLPROP_EXCLUDE:

				sc = m_cfc.ScAddProp (NULL,
									  pwszTag,
									  CFindContext::FIND_PROPLIST_EXCLUDE);
				if (FAILED (sc))
					goto ret;

				m_state = ST_ALLPROP_EXCLUDE_INPROP;
				break;

			case ST_ALLPROP_INCLUDE:

				sc = m_cfc.ScAddProp (NULL,
									  pwszTag,
									  CFindContext::FIND_PROPLIST_INCLUDE);
				if (FAILED (sc))
					goto ret;

				m_state = ST_ALLPROP_INCLUDE_INPROP;
				break;

		}
	}
	else if (dwType == XML_ATTRIBUTE)
	{
		if ((m_state == ST_INENUMREPORT) && (XML_NS != dwSubType))
		{
			cch = ulNamespaceLen + ulLen;
			pwszTag = wsz.resize(CbSizeWsz(cch));
			if (NULL == pwszTag)
			{
				sc = E_OUTOFMEMORY;
				goto ret;
			}
			wcsncpy (wsz.get(), pwcNamespace, ulNamespaceLen);
			wcsncpy (wsz.get() + ulNamespaceLen, pwcText, ulLen);
			*(wsz.get() + cch) = 0;

			//	If this is a limit attribute, make the
			//	appropriate transition
			//
			if (!_wcsnicmp (pwszTag, gc_wszLimit, cch))
			{
				m_state = ST_ENUMLIMIT;
				sc = S_OK;
			}
		}
	}
	else if (dwType == XML_PCDATA)
	{
		if (m_state == ST_ENUMLIMIT)
			sc = m_cfc.ScSetReportLimit (ulLen, pwcText);
	}

ret:
	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_xml\xlock.cpp ===
/*
 *	X L O C K . C P P
 *
 *	XML push model parsing for LOCK requests
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_xml.h"

#include <xlock.h>
#include <statetok.h>

//	Here are our LOCK XML elements
//
const WCHAR gc_wszLockActive[]				= L"DAV:activelock";
const WCHAR gc_wszLockDepth[]				= L"DAV:depth";
const WCHAR gc_wszLockDiscovery[]			= L"DAV:lockdiscovery";
const WCHAR gc_wszLockEntry[]				= L"DAV:lockentry";
const WCHAR gc_wszLockInfo[]				= L"DAV:lockinfo";
const WCHAR gc_wszLockOwner[]				= L"DAV:owner";
const WCHAR gc_wszLockScope[]				= L"DAV:lockscope";
const WCHAR gc_wszLockScopeExclusive[]		= L"DAV:exclusive";
const WCHAR gc_wszLockScopeShared[]			= L"DAV:shared";
const WCHAR gc_wszLockSupportedlock[]		= L"DAV:supportedlock";
const WCHAR gc_wszLockTimeout[]				= L"DAV:timeout";
const WCHAR gc_wszLockToken[]				= L"DAV:locktoken";
const WCHAR gc_wszLockType[]				= L"DAV:locktype";
const WCHAR gc_wszLockTypeWrite[]			= L"DAV:write";
const WCHAR	gc_wszLockTypeCheckout[]		= L"DAV:checkout";
const WCHAR gc_wszLockTypeTransaction[]		= L"DAV:transaction";
const WCHAR gc_wszLockTypeTransactionGOP[]	= L"DAV:groupoperation";
const WCHAR	gc_wszLockScopeLocal[]			= L"DAV:local";

//	And one item from the rollback draft.
//
const WCHAR gc_wszLockRollback[]		= L"http://www.iana.org/experimental/msrollback/rollback";

//	UNLOCK xml elememts
//
const WCHAR	gc_wszUnlockInfo[]			= L"DAV:unlockinfo";
const WCHAR gc_wszCancelCheckout[]		= L"DAV:cancelcheckout";
const WCHAR	gc_wszComment[]				= L"DAV:comment";
const WCHAR	gc_wszTransactionInfo[]		= L"DAV:transactioninfo";
const WCHAR	gc_wszTransactionStatus[]	= L"DAV:transactionstatus";
const WCHAR	gc_wszCommit[]				= L"DAV:commit";
const WCHAR	gc_wszAbort[]				= L"DAV:abort";

//	class CNFLock -------------------------------------------------------------
//
SCODE
CNFLock::ScCompleteAttribute (void)
{
	//	When we have gotten here, we have started processing
	//	owner node attributes and all cached namespaces have
	//	been added.
	//
	if (m_state == ST_OWNER)
		return m_xo.ScCompleteChildren ( FALSE, XML_ATTRIBUTE, L"", 0 );

	return S_OK;
}

SCODE
CNFLock::ScCompleteChildren (
	/* [in] */ BOOL fEmptyNode,
	/* [in] */ DWORD dwType,
	/* [in] */ const WCHAR __RPC_FAR *pwcText,
	/* [in] */ ULONG ulLen)
{
	SCODE sc = S_OK;

	//	Handle owner processing first....
	//
	if (ST_OWNER == m_state)
	{
		sc = m_xo.ScCompleteChildren (fEmptyNode,
									  dwType,
									  pwcText,
									  ulLen);
		if (FAILED (sc))
			goto ret;
	}

	//	Handle the rest...
	//
	switch (dwType)
	{
		case XML_ELEMENT:

			switch (m_state)
			{
				case ST_LOCKINFO:

					m_state = ST_NODOC;
					break;

				case ST_OWNER:

					if (0 == m_xo.LDepth())
					{
						//	Complete the owner comment buffer
						//
						m_state = ST_LOCKINFO;
						m_sbOwner.Append (sizeof(WCHAR), L"\0");
						XmlTrace ("Xml: Lock: owner XML body:\n%ws\n",
								  m_sbOwner.PContents());
					}
					break;

				case ST_TYPE:

					m_state = ST_LOCKINFO;
					break;

				case ST_INTYPE:

					m_state = ST_TYPE;
					break;

				case ST_INTYPE_TRANS:

					m_state = ST_INTYPE;
					break;

				case ST_SCOPE:

					m_state = ST_LOCKINFO;
					break;

				case ST_INSCOPE:

					m_state = ST_SCOPE;
					break;

				case ST_ROLLBACK:

					m_state = ST_LOCKINFO;
					break;
			}
	}

ret:
	return sc;
}

SCODE
CNFLock::ScHandleNode (
	/* [in] */ DWORD dwType,
	/* [in] */ DWORD dwSubType,
	/* [in] */ BOOL fTerminal,
	/* [in] */ const WCHAR __RPC_FAR *pwcText,
	/* [in] */ ULONG ulLen,
	/* [in] */ ULONG ulNamespaceLen,
	/* [in] */ const WCHAR __RPC_FAR *pwcNamespace,
	/* [in] */ const ULONG ulNsPrefixLen)
{
	CStackBuffer<WCHAR> wsz;
	LPCWSTR pwszTag = NULL;
	SCODE sc = S_FALSE;
	UINT cch;

	switch (dwType)
	{
		case XML_ELEMENT:

			//	Construct the full name of the node
			//
			cch = ulNamespaceLen + ulLen;
			pwszTag = wsz.resize(CbSizeWsz(cch));
			if (NULL == pwszTag)
			{
				sc = E_OUTOFMEMORY;
				break;
			}
			wcsncpy (wsz.get(), pwcNamespace, ulNamespaceLen);
			wcsncpy (wsz.get() + ulNamespaceLen, pwcText, ulLen);
			*(wsz.get() + cch) = 0;

			switch (m_state)
			{
				case ST_NODOC:

					//	If this is the topmost node in a propfind request,
					//	transition to the next state.  Since there is no parent
					//	node to provide scoping, FIsTag() cannot be used here!
					//
					if (!wcscmp (pwszTag, gc_wszLockInfo))
					{
						m_state = ST_LOCKINFO;
						sc = S_OK;
					}
					break;

				case ST_LOCKINFO:

					//	Look for our well know node types
					//
					if (FIsTag (pwszTag, gc_wszLockOwner))
					{
						CEmitNmspc cen(m_xo);

						//	Make the state transition and start recording
						//
						m_sbOwner.Reset();
						m_state = ST_OWNER;
						sc = m_xo.ScHandleNode (dwType,
												dwSubType,
												fTerminal,
												pwcText,
												ulLen,
												ulNamespaceLen,
												pwcNamespace,
											    ulNsPrefixLen);

						//	Spit out the namespaces.
						//
						//	Note that this will spit out any namespaces
						//	decl'd in the DAV:owner node itself.  So we
						//	do not really want to emit these out to the
						//	owners comments until ScCompleteAttribute()
						//	is called.
						//
						Assert (!m_xo.FAddNamespaceDecl());
						m_cache.ForEach(cen);
						sc = S_OK;
					}
					else if (FIsTag (pwszTag, gc_wszLockRollback))
					{
						m_dwRollback = DAV_LOCKTYPE_ROLLBACK;
						m_state = ST_ROLLBACK;
						sc = S_OK;
					}
					else if (FIsTag (pwszTag, gc_wszLockType))
					{
						m_state = ST_TYPE;
						sc = S_OK;
					}
					else if (FIsTag (pwszTag, gc_wszLockScope))
					{
						m_state = ST_SCOPE;
						sc = S_OK;
					}
					break;

				case ST_TYPE:

					if (FIsTag (pwszTag, gc_wszLockTypeWrite))
					{
						XmlTrace ("Xml: Lock: request is for a WRITE lock\n");
						m_dwLockType |= GENERIC_WRITE;
						m_state = ST_INTYPE;
						sc = S_OK;
					}
					else if (FIsTag (pwszTag, gc_wszLockTypeCheckout))
					{
						XmlTrace ("Xml: Lock: request is for a CHECKOUT lock\n");
						m_dwLockType |= DAV_LOCKTYPE_CHECKOUT;
						m_state = ST_INTYPE;
						sc = S_OK;
					}
					else if (FIsTag (pwszTag, gc_wszLockTypeTransaction))
					{
						XmlTrace ("Xml: Lock: request is for a TRANSACTION lock\n");
						m_state = ST_INTYPE_TRANS;
						sc = S_OK;
					}
#ifdef	DBG
					if (!_wcsicmp (pwszTag, L"read"))
					{
						XmlTrace ("Xml: Lock: request is for a READ lock\n");
						m_dwLockType |= GENERIC_READ;
						m_state = ST_INTYPE;
						sc = S_OK;
					}
#endif	// DBG
					break;

				case ST_SCOPE:

					if (FIsTag (pwszTag, gc_wszLockScopeExclusive))
					{
						XmlTrace ("Xml: Lock: request is for an EXCLUSE lock\n");
						m_dwScope = DAV_EXCLUSIVE_LOCK;
						m_state = ST_INSCOPE;
						sc = S_OK;
					}
					else if (FIsTag (pwszTag, gc_wszLockScopeShared))
					{
						XmlTrace ("Xml: Lock: request is for a SHARED lock\n");
						m_dwScope = DAV_SHARED_LOCK;
						m_state = ST_INSCOPE;
						sc = S_OK;
					}
					else if (FIsTag (pwszTag, gc_wszLockScopeLocal))
					{
						XmlTrace ("Xml: Lock: request is for a LOCAL scope lock\n");
						m_dwScope = DAV_LOCKSCOPE_LOCAL;
						m_state = ST_INSCOPE;
						sc = S_OK;
					}
					break;
				case ST_OWNER:

					sc = m_xo.ScHandleNode (dwType,
											dwSubType,
											fTerminal,
											pwcText,
											ulLen,
											ulNamespaceLen,
											pwcNamespace,
										    ulNsPrefixLen);
					break;

				case ST_INTYPE_TRANS:

					if (FIsTag (pwszTag, gc_wszLockTypeTransactionGOP))
					{
						XmlTrace ("Xml: Lock: request is for a TRANSACTION GOP lock\n");
						m_dwLockType |= DAV_LOCKTYPE_TRANSACTION_GOP;
						m_state = ST_INTYPE_TRANS;
						sc = S_OK;
					}
			}
			break;

		default:

			//	If we are processing the owner, continue
			//	to do so...
			//
			if (ST_OWNER == m_state)
			{
				sc = m_xo.ScHandleNode (dwType,
										dwSubType,
										fTerminal,
										pwcText,
										ulLen,
										ulNamespaceLen,
										pwcNamespace,
									    ulNsPrefixLen);
			}
			break;
	}

	return sc;
}

SCODE
CNFLock::ScCompleteCreateNode (
	/* [in] */ DWORD dwType)
{
	if (ST_OWNER == m_state)
		m_xo.CompleteCreateNode (dwType);

	return S_OK;
}

//	class CNFUnlock -------------------------------------------------------------
//
SCODE
CNFUnlock::ScCompleteAttribute (void)
{
	return S_OK;
}

SCODE
CNFUnlock::ScCompleteChildren (
	/* [in] */ BOOL fEmptyNode,
	/* [in] */ DWORD dwType,
	/* [in] */ const WCHAR __RPC_FAR *pwcText,
	/* [in] */ ULONG ulLen)
{
	//	Handle the rest...
	//
	switch (m_state)
	{
		case ST_UNLOCKINFO:

			m_state = ST_NODOC;
			break;

		case ST_COMMENT:
		case ST_CANCELCHECKOUT:

			m_state = ST_UNLOCKINFO;
			break;
	}

	return S_OK;
}

SCODE
CNFUnlock::ScHandleNode (
	/* [in] */ DWORD dwType,
	/* [in] */ DWORD dwSubType,
	/* [in] */ BOOL fTerminal,
	/* [in] */ const WCHAR __RPC_FAR *pwcText,
	/* [in] */ ULONG ulLen,
	/* [in] */ ULONG ulNamespaceLen,
	/* [in] */ const WCHAR __RPC_FAR *pwcNamespace,
	/* [in] */ const ULONG ulNsPrefixLen)
{
	CStackBuffer<WCHAR> wsz;
	LPCWSTR pwszTag = NULL;
	SCODE sc = S_FALSE;
	UINT cch;

	switch (dwType)
	{
		case XML_ELEMENT:

			//	Construct the full name of the node
			//
			cch = ulNamespaceLen + ulLen;
			pwszTag = wsz.resize(CbSizeWsz(cch));
			if (NULL == pwszTag)
			{
				sc = E_OUTOFMEMORY;
				break;
			}
			wcsncpy (wsz.get(), pwcNamespace, ulNamespaceLen);
			wcsncpy (wsz.get() + ulNamespaceLen, pwcText, ulLen);
			*(wsz.get() + cch) = 0;

			switch (m_state)
			{
				case ST_NODOC:

					//	If this is the topmost node in a propfind request,
					//	transition to the next state.  Since there is no parent
					//	node to provide scoping, FIsTag() cannot be used here!
					//
					if (!wcscmp (pwszTag, gc_wszUnlockInfo))
					{
						m_state = ST_UNLOCKINFO;
						sc = S_OK;
					}
					else if (FIsTag (pwszTag, gc_wszTransactionInfo))
					{
						m_state = ST_TRANSACTIONINFO;
						sc = S_OK;
					}
					break;

				case ST_UNLOCKINFO:

					//	Look for our well know node types
					//
					if (FIsTag (pwszTag, gc_wszComment))
					{
						m_state = ST_COMMENT;
						sc = S_OK;
					}
					else if (FIsTag (pwszTag, gc_wszCancelCheckout))
					{
						m_fCancelCheckout = TRUE;
						m_state = ST_CANCELCHECKOUT;
						sc = S_OK;
					}
					break;
				case ST_TRANSACTIONINFO:
					//	Look for our well know node types
					//
					if (FIsTag (pwszTag, gc_wszTransactionStatus))
					{
						m_state = ST_TRANSACTIONSTATUS;
						sc = S_OK;
					}
					break;
				case ST_TRANSACTIONSTATUS:
					//	Look for our well know node types
					//
					if (FIsTag (pwszTag, gc_wszCommit))
					{
						m_fCommitTransaction = TRUE;
						m_state = ST_TRANSACTIONSTATUS_COMMIT;
						sc = S_OK;
					}
					else if (FIsTag (pwszTag, gc_wszAbort))
					{
						m_fAbortTransaction = TRUE;
						m_state = ST_TRANSACTIONSTATUS_ABORT;
						sc = S_OK;
					}
					break;
			}
			break;

		case XML_PCDATA:

			//	get unlock comment
			//
			if (m_state == ST_COMMENT)
			{
				//	Keep the comment
				//	It's a syntax error to have more than one comment
				//
				if (!m_wszComment.get())
				{
					m_wszComment = reinterpret_cast<LPWSTR>(ExAlloc((ulLen + 1) * sizeof(WCHAR)));
					Assert (m_wszComment.get());

					wcsncpy (m_wszComment.get(), pwcText, ulLen);
					m_wszComment[ulLen] = L'\0';

					sc = S_OK;
				}
				//	else it's an error
				else
					sc = E_DAV_XML_PARSE_ERROR;
			}
			break;
	}

	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_xml\xout.cpp ===
/*
 *	X O U T . C P P
 *
 *	XML push model printing
 *
 *	This code was stolen from the XML guys and adapted for our use
 *	in owner comment processing.
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_xml.h"

//	CXMLOut -------------------------------------------------------------------
//
VOID
CXMLOut::CloseElementDecl(
	/* [in] */ BOOL fEmptyNode)
{
	//	If we get a call to EndAttributesOut, and the
	//	node is empty, we want to close things up here.
	//
	if (fEmptyNode)
	{
		m_sb.Append (L"/>");
	}
	//
	//	Otherwise, we can end the attributes as if a new node is
	//	to follow.
	//
	else
		m_sb.Append (L">");

	//	Remember that they have been ended!
	//
	m_fElementNeedsClosing = FALSE;

	//	Note, we should start to emit the namespaces after the first element
	//	node is closed. The namespaces for the first node is emitter from
	//	the namespace cache
	//
	m_fAddNamespaceDecl = TRUE;
}

VOID
CXMLOut::EndAttributesOut (
	/* [in] */ DWORD dwType)
{
	//	Make sure we setup to close the element
	//
	if (XML_ELEMENT == dwType)
	{
		Assert (FALSE == m_fElementNeedsClosing);
		m_fElementNeedsClosing = TRUE;
	}
}

VOID
CXMLOut::EndChildrenOut (
	/* [in] */ BOOL fEmptyNode,
	/* [in] */ DWORD dwType,
	/* [in] */ const WCHAR __RPC_FAR *pwcText,
	/* [in] */ ULONG ulLen)
{
	//	If there is an element awaiting a close...
	//
	if (m_fElementNeedsClosing)
	{
		//	... close it
		//
		CloseElementDecl (fEmptyNode);
	}

	switch (dwType)
	{
		case XML_ELEMENT:

			if (!fEmptyNode)
			{
				m_sb.Append (L"</");
				m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
				m_sb.Append (L">");
			}
			break;

		case XML_ATTRIBUTE:

			m_sb.Append (L"\"");
			break;

		case XML_XMLDECL:
		case XML_PI:

			m_sb.Append (L" ");
			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			m_sb.Append (L"?>");
			break;

		case XML_DOCTYPE:
		case XML_ENTITYDECL:
		case XML_PENTITYDECL:
		case XML_ELEMENTDECL:
		case XML_ATTLISTDECL:
		case XML_NOTATION:

			m_sb.Append (L">");
			break;

		case XML_GROUP:

			m_sb.Append (L")");
			break;

		case XML_INCLUDESECT:

			m_sb.Append (L"]]>");
			break;
	}
}

void
CXMLOut::CreateNodeAttrOut (
	/* [in] */ const WCHAR __RPC_FAR *pwszAttr,
	/* [in] */ const WCHAR __RPC_FAR *pwcText,
	/* [in] */ ULONG ulLen)
{
	m_sb.Append (pwszAttr);
	m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
	m_sb.Append (L"\"");
}

VOID
CXMLOut::CreateNodeOut(
	/* [in] */ DWORD dwType,
	/* [in] */ BOOL fTerminal,
	/* [in] */ const WCHAR __RPC_FAR *pwcText,
	/* [in] */ ULONG ulLen)
{
	//	If there is an element awaiting a close...
	//
	if (m_fElementNeedsClosing)
	{
		//	... close it
		//
		CloseElementDecl (FALSE);
	}

	switch (dwType)
	{
		case XML_ELEMENT:

			m_sb.Append (L"<");
			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			break;

		case XML_ATTRIBUTE:

			m_sb.Append (L" ");
			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			m_sb.Append (L"=\"");
			break;

		case XML_XMLDECL:
		case XML_PI:

			m_sb.Append (L"<?");
			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			break;

		case XML_DOCTYPE:

			m_sb.Append (L"<!DOCTYPE ");
			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			break;

		case XML_ENTITYDECL:

			m_sb.Append (L"<!ENTITY ");
			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			break;

		case XML_PENTITYDECL:

			m_sb.Append (L"<!ENTITY % ");
			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			break;

		case XML_ELEMENTDECL:

			m_sb.Append (L"<!ELEMENT ");
			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			break;

		case XML_ATTLISTDECL:

			m_sb.Append (L"<!ATTLIST ");
			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			break;

		case XML_NOTATION:

			m_sb.Append (L"<!NOTATION ");
			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			break;

		case XML_GROUP:

			m_sb.Append (L" (");
			break;

		case XML_INCLUDESECT:

			m_sb.Append (L"<![");
			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			m_sb.Append (L"[");
			break;

		case XML_IGNORESECT:

			m_sb.Append (L"<![IGNORE[");
			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			m_sb.Append (L"]]>");
			break;

		case XML_CDATA:

			m_sb.Append (L"<![CDATA[");
			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			m_sb.Append (L"]]>");
			break;

		case XML_COMMENT:

			m_sb.Append (L"<!--");
			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			m_sb.Append (L"-->");
			break;

		case XML_ENTITYREF:

			m_sb.Append (L"&");
			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			m_sb.Append (L";");
			break;

		case XML_PEREF:

			m_sb.Append (L"%");
			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			m_sb.Append (L";");
			break;

		case XML_SYSTEM:

			CreateNodeAttrOut (L" SYSTEM \"", pwcText, ulLen);
			break;

		case XML_PUBLIC:

			CreateNodeAttrOut (L" PUBLIC \"", pwcText, ulLen);
			break;

		case XML_NAME:

			m_sb.Append (L" ");
			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			break;

		case XML_STRING:

			CreateNodeAttrOut (L" \"", pwcText, ulLen);
			break;

		case XML_VERSION:

			CreateNodeAttrOut (L" version=\"", pwcText, ulLen);
			break;

		case XML_ENCODING:

			CreateNodeAttrOut (L" encoding=\"", pwcText, ulLen);
			break;

		case XML_NDATA:

			m_sb.Append (L" NDATA");
			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			break;

		case XML_PCDATA:

			//	IMPORTANT: we will get multiple calls to this for each
			//	entity element, some of which need to be escaped.  Handle
			//	that here.
			//
			//	The elements that need escaping are:
			//
			//		'&'	goes to "&amp;"
			//		'>' goes to "&gt;"
			//		'<' goes to	"&lt;"
			//		''' goes to	"&qpos;"
			//		'"' goes to "&quot;"
			//
			//	Note that in the case of attributes, only two need escaping --
			//	the latter two quote marks.  The first three are for node values.
			//	However, we are going to make some simple assumptions that should
			//	be reasonable.  If we only get a single character that matches on
			//	of the escape sequences, then escape it.
			//
			if (1 == ulLen)
			{
				switch (*pwcText)
				{
					case L'&':

						pwcText = gc_wszAmp;
						ulLen = CchConstString (gc_wszAmp);
						Assert (5 == ulLen);
						break;

					case L'>':

						pwcText = gc_wszGreaterThan;
						ulLen = CchConstString (gc_wszGreaterThan);
						Assert (4 == ulLen);
						break;

					case L'<':

						pwcText = gc_wszLessThan;
						ulLen = CchConstString (gc_wszLessThan);
						Assert (4 == ulLen);
						break;

					case L'\'':

						pwcText = gc_wszApos;
						ulLen = CchConstString (gc_wszApos);
						Assert (6 == ulLen);
						break;

					case L'"':

						pwcText = gc_wszQuote;
						ulLen = CchConstString (gc_wszQuote);
						Assert (6 == ulLen);
						break;

					default:

						//	There is no mapping required.
						//
						break;
				}
			}
			Assert (fTerminal);
			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			break;

		case XML_EMPTY:
		case XML_ANY:
		case XML_MIXED:
		case XML_ATTDEF:
		case XML_AT_CDATA:
		case XML_AT_ID:
		case XML_AT_IDREF:
		case XML_AT_IDREFS:
		case XML_AT_ENTITY:
		case XML_AT_ENTITIES:
		case XML_AT_NMTOKEN:
		case XML_AT_NMTOKENS:
		case XML_AT_NOTATION:
		case XML_AT_REQUIRED:
		case XML_AT_IMPLIED:
		case XML_AT_FIXED:

			m_sb.Append (L" ");
			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			break;

		case XML_DTDSUBSET:

			//	Do nothing -- since we've already printed the DTD subset.
			//	and EndDTDSubset will print the ']' character.
			//
			break;

		default:

			m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
			break;
	}
}

//	Owner processing ----------------------------------------------------------
//
SCODE
CXMLOut::ScCompleteChildren (
	/* [in] */ BOOL fEmptyNode,
	/* [in] */ DWORD dwType,
	/* [in] */ const WCHAR __RPC_FAR *pwcText,
	/* [in] */ ULONG ulLen)
{
	//	Close the current owner comment item
	//
	EndChildrenOut (fEmptyNode, dwType, pwcText, ulLen);

	//	Decrement the depth of the owner tree
	//
	--m_lDepth;
	XmlTrace ("Xml: Lock: Owner: decrementing depth to: %ld\n", m_lDepth);
	return S_OK;
}

SCODE
CXMLOut::ScHandleNode (
	/* [in] */ DWORD dwType,
	/* [in] */ DWORD dwSubType,
	/* [in] */ BOOL fTerminal,
	/* [in] */ const WCHAR __RPC_FAR *pwcText,
	/* [in] */ ULONG ulLen,
	/* [in] */ ULONG ulNamespaceLen,
	/* [in] */ const WCHAR __RPC_FAR *pwcNamespace,
	/* [in] */ const ULONG ulNsPrefixLen)
{
	switch (dwType)
	{
		case XML_ATTRIBUTE:

			//	If this is a namespace decl, then there is different
			//	name reconstruction that needs to happen...
			//
			if (XML_NS == dwSubType)
			{
				//	... but before we do that ...
				//
				//	There are some namespaces that should not be added
				//	to the owners comments at this time (the get added
				//	by the namespace cache emitting mechanism.  If the
				//	namespaces are to be blocked, handle this now.
				//
				//	Note that by returning S_FALSE, we will not get
				//	called for the PCDATA nodes that also apply to this
				//	namespace.
				//
				if (!m_fAddNamespaceDecl)
					return S_FALSE;

				Assert ((CchConstString(gc_wszXmlns) == ulLen)
					&& (!wcsncmp(pwcText, gc_wszXmlns, CchConstString(gc_wszXmlns))));
				
				break;
			}

			//	Otherwise, fall through to the regular processing
			//

		case XML_ELEMENT:
		{
			//	OK, we are going to be real sneaky here.  The
			//	original, aliased tag is available here without
			//	having to back-lookup.  The pwcText pointer has
			//	simply been scooted forward in the text to skip
			//	over the the alias and ':'.  So, we can use the
			//	ulNsPrefixLen to scoot back and not have to do
			//	any sort of back lookup.
			//
			if (0 != ulNsPrefixLen)
			{
				//	The prefix len does not take into account the
				//	colon separator, so we have to here!
				//
				pwcText -= ulNsPrefixLen + 1;
				ulLen += ulNsPrefixLen + 1;
			}

			break;
		}
	}

	//	Acknowledge the change in owner processing
	//	depth...
	//
	if (!fTerminal)
	{
		++m_lDepth;
		XmlTrace ("CXmlOut: incrementing depth to: %ld\n", m_lDepth);
	}

	//	Build up the owner comment where appropriate
	//
	CreateNodeOut (dwType, fTerminal, pwcText, ulLen);
	return S_OK;
}

BOOL
CEmitNmspc::operator()(const CRCWszN&, const auto_ref_ptr<CNmspc>& pns)
{
	Assert (pns.get());

	//	Allocate enough space for the namespace attribute --
	//	which includes the prefix, an optional colon and an
	//	alias.
	//
	CStackBuffer<WCHAR> pwsz;
	UINT cch = pns->CchAlias() + CchConstString(gc_wszXmlns) + 1;
	if (NULL == pwsz.resize(CbSizeWsz(cch)))
		return FALSE;

	//	Copy over the prefix
	//
	wcsncpy (pwsz.get(), gc_wszXmlns, CchConstString(gc_wszXmlns));
	if (pns->CchAlias())
	{
		//	Copy over the colon and alias
		//
		pwsz[CchConstString(gc_wszXmlns)] = L':';
		wcsncpy(pwsz.get() + CchConstString(gc_wszXmlns) + 1,
				pns->PszAlias(),
				pns->CchAlias());

		//	Terminate it
		//
		pwsz[cch] = 0;
	}
	else
	{
		//	Terminate it
		//
		pwsz[CchConstString(gc_wszXmlns)] = 0;
		cch = CchConstString(gc_wszXmlns);
	}

	//	Output the namespace element.
	//
	m_xo.CreateNodeOut (XML_ATTRIBUTE, FALSE, pwsz.get(), cch);

	//	There may be some escaping that needs to happen for a namespace.
	//
	LPCWSTR pwszHref = pns->PszHref();
	LPCWSTR pwszStart = pns->PszHref();
	UINT cchHref = pns->CchHref();
	for (; pwszHref < pns->PszHref() + cchHref; pwszHref++)
	{
		if ((L'\'' == *pwszHref) ||
			(L'"' == *pwszHref) ||
		    (L'&' == *pwszHref))
		{
			//	Emit the stuff leading up to the escaped character
			//
			m_xo.CreateNodeOut (XML_PCDATA, TRUE, pwszStart, static_cast<UINT>(pwszHref - pwszStart));

			//	Escape the single character and the underlying code
			//	will do the proper escaping!
			//
			m_xo.CreateNodeOut (XML_PCDATA, TRUE, pwszHref, 1);

			//	Mark our starting point at the next character
			//
			pwszStart = pwszHref + 1;
		}
	}

	//	Finish off the namespace
	//
	m_xo.CreateNodeOut (XML_PCDATA, TRUE, pwszStart, static_cast<UINT>(pwszHref - pwszStart));
	m_xo.EndChildrenOut (FALSE, XML_ATTRIBUTE, pwsz.get(), cch);
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_xml\xmlparser_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0158 */
/* at Tue Sep 22 19:11:47 1998
 */
/* Compiler settings for xmlparser.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID LIBID_XMLPSR = {0xd242361c,0x51a0,0x11d2,{0x9c,0xaf,0x00,0x60,0xb0,0xec,0x3d,0x39}};


const IID IID_IXMLNodeSource = {0xd242361d,0x51a0,0x11d2,{0x9c,0xaf,0x00,0x60,0xb0,0xec,0x3d,0x39}};


const IID IID_IXMLParser = {0xd242361e,0x51a0,0x11d2,{0x9c,0xaf,0x00,0x60,0xb0,0xec,0x3d,0x39}};


const IID IID_IXMLNodeFactory = {0xd242361f,0x51a0,0x11d2,{0x9c,0xaf,0x00,0x60,0xb0,0xec,0x3d,0x39}};


const CLSID CLSID_XMLParser = {0xd2423620,0x51a0,0x11d2,{0x9c,0xaf,0x00,0x60,0xb0,0xec,0x3d,0x39}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_xml\xemit.cpp ===
/*
 *	X E M I T . C P P
 *
 *	XML emitter processing
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_xml.h"
#include <szsrc.h>

//	class CXNode - Emitting ---------------------------------------------------
//
//	Our own version of WideCharToMultiByte(CP_UTF8, ...)
//
//	UTF-8 multi-byte encoding.  See Appendix A.2 of the Unicode book for
//	more info.
//
//		Unicode value    1st byte    2nd byte    3rd byte
//		000000000xxxxxxx 0xxxxxxx
//		00000yyyyyxxxxxx 110yyyyy    10xxxxxx
//		zzzzyyyyyyxxxxxx 1110zzzz    10yyyyyy    10xxxxxx
//
inline
VOID WideCharToUTF8Chars (WCHAR wch, BYTE * pb, UINT * pib)
{
	Assert (pb);
	Assert (pib);

	UINT	ib = *pib;

	//	single-byte: 0xxxxxxx
	//
	if (wch < 0x80)
	{
		pb[ib] = static_cast<BYTE>(wch);
	}
	//
	//	two-byte: 110xxxxx 10xxxxxx
	//
	else if (wch < 0x800)
	{
		//	Because we alloc'd two extra-bytes,
		//	we know there is room at the tail of
		//	the buffer for the overflow...
		//
		pb[ib++] = static_cast<BYTE>((wch >> 6) | 0xC0);
		pb[ib] = static_cast<BYTE>((wch & 0x3F) | 0x80);
	}
	//
	//	three-byte: 1110xxxx 10xxxxxx 10xxxxxx
	//
	else
	{
		//	Because we alloc'd two extra-bytes,
		//	we know there is room at the tail of
		//	the buffer for the overflow...
		//
		pb[ib++] = static_cast<BYTE>((wch >> 12) | 0xE0);
		pb[ib++] = static_cast<BYTE>(((wch >> 6) & 0x3F) | 0x80);
		pb[ib] = static_cast<BYTE>((wch & 0x3F) | 0x80);
	}

	*pib = ib;
}

//	CXMLEmitter helper functions ----------------------------------------------
//
SCODE
ScGetPropNode (
	/* [in] */ CEmitterNode& enItem,
	/* [in] */ ULONG hsc,
	/* [out] */ CEmitterNode& enPropStat,
	/* [out] */ CEmitterNode& enProp)
{
	SCODE	sc = S_OK;

	//	<DAV:propstat> node
	//
	sc = enItem.ScAddNode (gc_wszPropstat, enPropStat);
	if (FAILED(sc))
		goto ret;

	//	<DAV:status> node
	//
	sc = ScAddStatus (&enPropStat, hsc);
	if (FAILED(sc))
		goto ret;

	//	<DAV:prop> node
	//
	sc = enPropStat.ScAddNode (gc_wszProp, enProp);
	if (FAILED(sc))
		goto ret;

ret:
	return sc;
}

//	CXNode helper functions ---------------------------------------------------
//
SCODE
ScSetEscapedValue (CXNode* pxn, LPCWSTR pcwsz, UINT cch, BOOL fHandleStoragePathEscaping)
{
	SCODE	sc = S_OK;
	CStackBuffer<WCHAR>	lpwsz;

	//	Argh!  We need to have a buffer to fill that is
	//	at least 3 bytes long for the odd occurrence of a
	//	single unicode char with significant bits above
	//	0x7f.
	//
	UINT cb = min (cch + 2, CB_XMLBODYPART_SIZE);

	//	Make sure there is always room to terminate and allocate
	//  an extra byte.
	//  NOTE:  cb is not an actual count of bytes
	//  because of this.  it does not include the NULL termination.
	//
	//	We really can handle zero bytes being sloughed into
	//	the buffer.
	//
	UINT ib;
	UINT iwch;
	CStackBuffer<BYTE> pb;
	if (NULL == pb.resize (cb+1))
		return E_OUTOFMEMORY;

	if (fHandleStoragePathEscaping)
	{
		// $REVIEW: this might cause a stack overflow for exceptionally
		// large values of cch!  but this branch should only be executed
		// on the case for urls, so perhaps it's not possible...
		//
		if (NULL == lpwsz.resize((cch + 1) * sizeof(WCHAR)))
			return E_OUTOFMEMORY;

		CopyMemory(lpwsz.get(), pcwsz, (cch * sizeof(WCHAR)));
		lpwsz[cch] = L'\0';

		cch = static_cast<UINT>(wcslen(lpwsz.get()));
		pcwsz = lpwsz.get();
	}

	for (iwch = 0; iwch < cch; )
	{
		auto_heap_ptr<CHAR>  pszEscaped;

		//  While there are more characters to convert
		//  and we have enough buffer space left for one UTF8 character
		//  (max of 3 bytes).  the NULL termination is not included in
		//  cb, so it is already accounted for.
		//

		for (ib = 0;
			 (ib < cb - 2) && (iwch < cch);
			 ib++, iwch++)
		{
			WideCharToUTF8Chars (pcwsz[iwch], pb.get(), &ib);
		}

		//	Terminate
		//
		pb[ib] = 0;

		//	Escape the bytes
		//
		HttpUriEscape (reinterpret_cast<LPSTR>(pb.get()), pszEscaped);
		sc = pxn->ScSetUTF8Value (pszEscaped, static_cast<UINT>(strlen(pszEscaped)));
		if (FAILED(sc))
			goto ret;
	}

ret:
	return sc;
}

SCODE
ScEmitRawStoragePathValue (CXNode* pxn, LPCWSTR pcwsz, UINT cch)
{
    return pxn->ScSetValue (pcwsz, cch);
}

//	CEmitterNode helper functions ---------------------------------------------
//
VOID __fastcall
FormatStatus (ULONG hsc, LPSTR sz, UINT cb)
{
	UINT cch = CchConstString(gc_szHTTP_1_1);

	//	Construct a status line from the HSC
	//
	memcpy (sz, gc_szHTTP_1_1, cch);

	//	Add in a space
	//
	*(sz + cch++) = ' ';

	//	Add in the HSC
	//
	_itoa (hsc, sz + cch, 10);
	Assert (cch + 3 == strlen (sz));
	cch += 3;

	//	Add in a space
	//
	*(sz + cch++) = ' ';

	//	Add the description text
	//	Note, status line is not localized
	//
	//$REVIEW: Now that status line is not localized, do we still need to go through
	//$REVIEW: CResourceStringCache ?
	//
	LpszLoadString (hsc, MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), sz + cch, cb - cch);
}

SCODE __fastcall
ScAddStatus (CEmitterNode* pen, ULONG hsc)
{
	CHAR sz[MAX_PATH];
	CEmitterNode enStatus;

	FormatStatus (hsc, sz, sizeof(sz));
	return pen->ScAddMultiByteNode (gc_wszStatus, enStatus, sz);
}

SCODE __fastcall
ScAddError (CEmitterNode* pen, LPCWSTR pwszErrMsg)
{
	CEmitterNode en;
	return pen->ScAddNode (gc_wszErrorMessage, en, gc_wszErrorMessage);
}

//	class CStatusCache ------------------------------------------------------
//
BOOL
CStatusCache::EmitStatusNodeOp::operator()(
	const CHsc& key, const auto_ref_ptr<CPropNameArray>& pna )
{
	SCODE sc = S_OK;
	UINT iProp;
	CEmitterNode enPropStat;
	CEmitterNode enProp;

	sc = ScGetPropNode (m_enParent,
						key.m_hsc,
						enPropStat,
						enProp);
	//	Add prop names
	//
	for (iProp = 0; iProp < pna->CProps(); iProp++)
	{
		CEmitterNode en;

		//	Add one prop
		//
		sc = enProp.ScAddNode (pna->PwszProp(iProp), en);
		if (FAILED(sc))
			goto ret;
	}

ret:
	return sc == S_OK;
}

SCODE
CStatusCache::ScAddErrorStatus (ULONG hsc, LPCWSTR pwszProp)
{
	SCODE	sc = E_OUTOFMEMORY;
	auto_ref_ptr<CPropNameArray>	pna;
	auto_ref_ptr<CPropNameArray> *	ppna = NULL;

	//	Lookup in the cache for the array for the specific hsc
	//
	ppna = m_cache.Lookup (hsc);

	//	Add a new propname array if not exist
	//
	if (!ppna)
	{
		//	Create new propname array object
		//
		pna.take_ownership (new CPropNameArray());
		if (!pna.get())
			goto ret;

		//	Add it to the cache
		//
		if (!m_cache.FAdd (hsc, pna))
			goto ret;
	}
	else
		pna = *ppna;

	//	Persist the prop name string
	//
	pwszProp = m_csbPropNames.AppendWithNull (pwszProp);
	if (!pwszProp)
		goto ret;

	//	Add it to prop name array
	//
	sc = pna->ScAddPropName (pwszProp);
	if (FAILED(sc))
		goto ret;

ret:
	return sc;
}

SCODE
CStatusCache::ScEmitErrorStatus (CEmitterNode& enParent)
{
	EmitStatusNodeOp op (enParent);

	//$REVIEW: Currently, ForEach does not return an error code
	//$REVIEW: even when it stops in the middle. we may want to
	//$REVIEW: have it return at least a boolean to allow caller
	//$REVIEW: to tell whether to continue
	//
	m_cache.ForEach(op);

	return S_OK;
}


//	Property name escaping ----------------------------------------------------
//
DEC_CONST char gc_szEscape[] = "_xnnnn";

__inline WCHAR
WchFromEscape (const LPCWSTR wsz)
{
	WCHAR wch = 0;

	if ((L'x' == *(wsz + 1)) || (L'X' == *(wsz + 1)))
	{
		//	Convert the hex value into a wchar
		//
		LPWSTR wszEnd;
		wch = static_cast<WCHAR>(wcstoul(wsz + 2, &wszEnd, 16 /* hexidecimal */));

		//	If the length of the sequence is not correct,
		//	or the terminating character was not an underscore,
		//	then we there was no escape sequence.
		//
		if (((wszEnd - wsz) != CchConstString(gc_szEscape)) || (L'_' != *wszEnd))
			wch = 0;
	}
	return wch;
}

__inline BOOL
FIsXmlAllowedChar (WCHAR wch, BOOL fFirstChar)
{
	if (fFirstChar)
		return isStartNameChar (wch);
	else
		return isNameChar (wch);
}

SCODE
ScEscapePropertyName (LPCWSTR wszProp, UINT cchProp, LPWSTR wszEscaped, UINT* pcch, BOOL fRestrictFirstCharacter)
{
	Assert (wszProp);
	Assert (wszEscaped);
	Assert (pcch);

	LPCWSTR wszStart = wszProp;
	SCODE sc = S_OK;
	UINT cch = 0;
	UINT cchLeft = cchProp;

	//  The first character of an xml prop tag has different rules
	//  regarding what is allowable (only characters and underscores
	//  are allowed).
	//
	BOOL fFirstCharOfTag = TRUE;

	//  However, if the caller doesn't want us to impose the additional
	//  restrictions on the first character, treat the first character
	//  as no different from any other.
	//
	if (!fRestrictFirstCharacter) fFirstCharOfTag = FALSE;

	while (wszProp < (wszStart + cchProp))
	{
		//	If this is a supported character in a XML tag name,
		//	copy it over now...
		//
		if (FIsXmlAllowedChar(*wszProp, fFirstCharOfTag))
		{
			//	If there is room, copy it over.
			//
			if (cch < *pcch)
				*wszEscaped = *wszProp;
		}
		//
		//	... or if the chararacter is an underscore that does not
		//	look like it preceeds an escape sequence, copy it over
		//	now...
		//
		else if ((L'_' == *wszProp) &&
				((cchLeft <= CchConstString(gc_szEscape)) ||
					(0 == WchFromEscape(wszProp))))
		{
			//	If there is room, copy it over.
			//
			if (cch < *pcch)
				*wszEscaped = *wszProp;
		}
		//
		//	... and everything else gets escaped.
		//
		else
		{
			//	Adjust the byte count as if there were room for all
			//	but one of the characters in the escape sequence.
			//
			cch += CchConstString(gc_szEscape);

			//	If there is room, insert the escape
			//	sequence.
			//
			if (cch < *pcch)
			{
				wsprintfW (wszEscaped, L"_x%04x_", *wszProp);
				wszEscaped += CchConstString(gc_szEscape);
			}
		}

		//	Account for the last character copied over
		//
		wszEscaped += 1;
		wszProp += 1;
		cch += 1;
		cchLeft--;
		fFirstCharOfTag = FALSE;
	}

	//	If there was not room to escape the whole thing, then
	//	pass back S_FALSE.
	//
	if (cch > *pcch)
		sc = S_FALSE;

	//	Tell the caller how long the result is, and return
	//
	*pcch = cch;
	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_xml\xsearch.cpp ===
/*
 *	X S E A R C H . C P P
 *
 *	XML push model parsing for MS-SEARCH requests
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_xml.h"
#include <align.h>

//	class CNFSearch -------------------------------------------------------------
//
SCODE
CNFSearch::ScCompleteAttribute (void)
{
	SCODE sc = S_OK;

	switch (m_state)
	{
		case ST_RANGE_TYPE:

			//	Find the range type.
			//
			m_state = ST_RANGE;
			if (0 == wcsncmp (m_sb.PContents(), L"row", m_sb.CchSize()))
				m_uRT = RANGE_ROW;
			else if (0 == wcsncmp (m_sb.PContents(), L"url", m_sb.CchSize()))
				m_uRT = RANGE_URL;
			else if (0 == wcsncmp (m_sb.PContents(), L"find", m_sb.CchSize()))
				m_uRT = RANGE_FIND;
			else
				m_uRT = RANGE_UNKNOWN;

			m_sb.Reset();
			break;

		case ST_RANGE_ROWS:

			//	Find the number of rows to retrieve
			//
			m_state = ST_RANGE;
			m_sb.Append (sizeof(WCHAR), L"");
			m_lcRows = wcstol (m_sb.PContents(), NULL, 10 /* base 10 only */);
			m_sb.Reset();
			break;

	}
	return sc;
}

SCODE
CNFSearch::ScCompleteChildren (
	/* [in] */ BOOL fEmptyNode,
	/* [in] */ DWORD dwType,
	/* [in] */ const WCHAR __RPC_FAR *pwcText,
	/* [in] */ ULONG ulLen)
{
	SCODE sc = S_OK;

	switch (m_state)
	{
		case ST_SEARCH:

			Assert (dwType == XML_ELEMENT);
			m_state = ST_NODOC;
			break;

		//	Exiting the base repl node
		//
		case ST_REPL:

			Assert (dwType == XML_ELEMENT);
			m_state = ST_SEARCH;
			break;

		case ST_QUERY:

			Assert (dwType == XML_ELEMENT);
			m_state = ST_SEARCH;

			//	Set the search text into the context
			//
			m_sb.Append (sizeof(WCHAR), L"");
			sc = m_csc.ScSetSQL (this, m_sb.PContents());
			if (FAILED (sc))
				goto ret;

			break;

		case ST_QUERYENTITY:

			m_state = ST_QUERY;
			break;

		case ST_REPLCOLLBLOB:

			Assert (dwType == XML_ELEMENT);
			m_state = ST_REPL;

			//	Set the collblob text into the context
			//
			m_sb.Append (sizeof(WCHAR), L"");
			sc = m_csc.ScSetCollBlob (m_sb.PContents());
			if (FAILED (sc))
				goto ret;

			break;

		case ST_REPLRESTAGLIST:

			Assert (dwType == XML_ELEMENT);
			m_state = ST_REPL;
			break;

		case ST_REPLRESTAGADD:

			Assert (dwType == XML_ELEMENT);
			m_state = ST_REPLRESTAGLIST;

			//	Set the restag text into the context
			//
			m_sb.Append (sizeof(WCHAR), L"");
			sc = m_csc.ScSetResTagAdds (m_sb.PContents());
			if (FAILED (sc))
				goto ret;

			break;

		case ST_RANGE:

			Assert (XML_ELEMENT == dwType);
			m_state = ST_SEARCH;

			//	Add the range to the list
			//
			m_sb.Append (sizeof(WCHAR), L"");
			sc = m_csc.ScAddRange (m_uRT, m_sb.PContents(), m_lcRows);
			if (FAILED (sc))
				goto ret;

			//	Clear all range elements
			//
			m_uRT = RANGE_UNKNOWN;
			m_lcRows = 0;
			break;

		case ST_GROUP_EXPANSION:

			Assert (XML_ELEMENT == dwType);
			m_state = ST_SEARCH;

			//	Add the expansion level to the context
			//
			m_sb.Append (sizeof(WCHAR), L"");
			sc = m_csc.ScSetExpansion (wcstol(m_sb.PContents(), NULL, 10));
			if (FAILED (sc))
				goto ret;

			break;
	}

ret:
	return sc;
}

SCODE
CNFSearch::ScHandleNode (
	/* [in] */ DWORD dwType,
	/* [in] */ DWORD dwSubType,
	/* [in] */ BOOL fTerminal,
	/* [in] */ const WCHAR __RPC_FAR *pwcText,
	/* [in] */ ULONG ulLen,
	/* [in] */ ULONG ulNamespaceLen,
	/* [in] */ const WCHAR __RPC_FAR *pwcNamespace,
	/* [in] */ const ULONG ulNsPrefixLen)
{
	CStackBuffer<WCHAR> wsz;
	LPCWSTR pwszTag;
	SCODE sc = S_FALSE;
	UINT cch;

	switch (dwType)
	{
		case XML_ELEMENT:

			//	Construct the full name of the node
			//
			cch = ulNamespaceLen + ulLen;
			pwszTag = wsz.resize(CbSizeWsz(cch));
			if (NULL == pwszTag)
			{
				sc = E_OUTOFMEMORY;
				goto ret;
			}
			wcsncpy (wsz.get(), pwcNamespace, ulNamespaceLen);
			wcsncpy (wsz.get() + ulNamespaceLen, pwcText, ulLen);
			*(wsz.get() + cch) = 0;

			switch (m_state)
			{
				case ST_NODOC:

					//	If this is the topmost node in a propSearch request,
					//	transition to the next state.  Since there is no parent
					//	node to provide scoping, FIsTag() cannot be used here!
					//
					if (!wcscmp (pwszTag, gc_wszSearchRequest))
					{
						m_state = ST_SEARCH;
						sc = S_OK;
					}
					break;

				case ST_SEARCH:

					//	Look for our well know node types
					//
					if (FIsTag (pwszTag, gc_wszSql))
					{
						m_state = ST_QUERY;
						m_sb.Reset();
						sc = S_OK;
					}
					//	Check for our top-level repl node.
					//	All repl items should appear inside this node.
					//	Tell our caller this is a REPL request, and
					//	switch our state to ST_REPL.
					//
					else if (FIsTag (pwszTag, gc_wszReplNode))
					{
						m_state = ST_REPL;
						sc = m_csc.ScSetReplRequest (TRUE);
						if (FAILED (sc))
							goto ret;
					}
					else if (FIsTag (pwszTag, gc_wszRange))
					{
						m_state = ST_RANGE;
						m_sb.Reset();
						sc = S_OK;
					}
					else if (FIsTag (pwszTag, gc_wszExpansion))
					{
						m_state = ST_GROUP_EXPANSION;
						m_sb.Reset();
						sc = S_OK;
					}
					break;

				case ST_REPL:

					//	Handle the nodes under the top-level repl node.
					//
					if (FIsTag (pwszTag, gc_wszReplCollBlob))
					{
						m_sb.Reset();
						m_state = ST_REPLCOLLBLOB;
						sc = S_OK;
					}
					else if (FIsTag (pwszTag, gc_wszReplResTagList))
					{
						m_sb.Reset();
						m_state = ST_REPLRESTAGLIST;
						sc = S_OK;
					}
					break;

				case ST_REPLRESTAGLIST:

					//	Handle the restag nodes under the restaglist node.
					//
					if (FIsTag (pwszTag, gc_wszReplResTagItem))
					{
						m_sb.Reset();
						m_state = ST_REPLRESTAGADD;
						sc = S_OK;
					}
					break;
			}
			break;

		case XML_ATTRIBUTE:

			if (ST_RANGE == m_state)
			{
				//	Construct the full name of the node
				//
				cch = ulNamespaceLen + ulLen;
				pwszTag = wsz.resize(CbSizeWsz(cch));
				if (NULL == pwszTag)
				{
					sc = E_OUTOFMEMORY;
					goto ret;
				}
				wcsncpy (wsz.get(), pwcNamespace, ulNamespaceLen);
				wcsncpy (wsz.get() + ulNamespaceLen, pwcText, ulLen);
				*(wsz.get() + cch) = 0;

				//	There are two attributes node for the DAV:range
				//	node.  DAV:type, and DAV:rows.
				//
				if (FIsTag (pwszTag, gc_wszRangeType))
				{
					m_state = ST_RANGE_TYPE;
					sc = S_OK;
				}
				else if (FIsTag (pwszTag, gc_wszRangeRows))
				{
					m_state = ST_RANGE_ROWS;
					sc = S_OK;
				}
				break;
			}
			break;

		case XML_PCDATA:

			//	If this is SQL query data, or repl collblob data,
			//	repl resourcetag data, or any of the range items,
			//	then remember it in our buffer.
			//
			if ((m_state == ST_QUERY)
				|| (m_state == ST_REPLCOLLBLOB)
				|| (m_state == ST_REPLRESTAGADD)
				|| (m_state == ST_RANGE_TYPE)
				|| (m_state == ST_RANGE_ROWS)
				|| (m_state == ST_RANGE)
				|| (m_state == ST_GROUP_EXPANSION))
			{
				//	Append the current bits to the buffer
				//
				m_sb.Append (ulLen * sizeof(WCHAR), pwcText);
				sc = S_OK;
			}
			break;
	}

ret:
	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_xml\_xml.h ===
/*
 *	_ X M L . H
 *
 *	XML document processing
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#pragma warning(disable:4100)	//	unref formal parameter
#pragma warning(disable:4710)	//	unexpanded c++ methods


//	Define _WINSOCKAPI_ to keep windows.h from including winsock.h,
//	whose declarations would be redefined in winsock2.h,
//	which is included by iisextp.h,
//	which we include below!
//
#define _WINSOCKAPI_
#include <windows.h>

#include <oledberr.h>

#include <ex\xml.h>
#include <ex\xprs.h>
#include <ex\calcom.h>

#include <xemit.h>
#include <xmeta.h>
#include <xsearch.h>

#include "chartype.h"

//	Helper Macros -------------------------------------------------------------
//
#define CElems(_rg)			(sizeof(_rg)/sizeof(_rg[0]))
#define CbSizeWsz(_cch)		(((_cch) + 1) * sizeof(WCHAR))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_xml\_xml.cpp ===
/*
 *	_ X M L . C P P
 *
 *	XML document processing
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_xml.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_xmllib\atomcache.cpp ===
/*
 *	A T O M C A C H E . C P P
 *
 *	atom cache
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_xmllib.h"

//	CXAtomCache::GetCachedAtom ------------------------------------------------
//
SCODE
CXAtomCache::ScGetCachedAtom (CRCWszN& key, LPCWSTR* pwszAtom)
{
	LPCWSTR wszCommitted;
	LPCWSTR* pwsz;
	SCODE sc = S_OK;

	//	First look to see if it is already there.
	//
	{
		CSynchronizedReadBlock srb(m_lock);
		pwsz = m_cache.Lookup (key);
	}

	//	If it wasn't there, do our best to add it
	//
	if (NULL == pwsz)
	{
		CSynchronizedWriteBlock swb(m_lock);

		//	There is a small window where it could
		//	have shown up, so do a second quick peek
		//
		pwsz = m_cache.Lookup (key);
		if (NULL == pwsz)
		{
			//	Commit the string to perm. storage
			//
			wszCommitted = m_csb.Append(key.m_cch*sizeof(WCHAR), key.m_pwsz);
			if (NULL == wszCommitted)
			{
				sc = E_OUTOFMEMORY;
				goto ret;
			}

			//	Add the atom to the cache, but before it
			//	gets added, swap out the key's string pointer
			//	to the committed version.
			//
			key.m_pwsz = wszCommitted;
			m_cache.FAdd (key, wszCommitted);

			//	Setup for the return
			//
			pwsz = &wszCommitted;
		}
	}

	Assert (pwsz);
	Assert (pwszAtom);
	*pwszAtom = *pwsz;

ret:
	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_xml\xpatch.cpp ===
/*
 *	X P A T C H . C P P
 *
 *	XML push model parsing for PROPPATCH requests
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_xml.h"

//	class CNFPatch -------------------------------------------------------------
//
SCODE
CNFPatch::ScCompleteAttribute (void)
{
	SCODE sc = S_OK;

	//	Recording mode is only allowed when we are inside a property.  There
	//	no support implemented for recording mode for multivalued properties.
	//
	Assert((ST_INPROP == m_state || ST_LEXTYPE == m_state) || VE_NOECHO == m_vestate);

	//	If we are value echoing, this is the point at which we much
	//	complete outputting the attribute (i.e. add the quotation mark
	//	after the value)
	//
	if (m_vestate == VE_INPROGRESS)
	{
		sc = m_xo.ScCompleteChildren ( FALSE, XML_ATTRIBUTE, L"", 0 );
		if (FAILED(sc))
			goto ret;

		//	Complete the current lextype
		//
		if (m_state == ST_LEXTYPE)
			m_state = ST_INPROP;
	}

	//	Normal processing -- values not being echoed
	//
	else if (m_state == ST_LEXTYPE)
	{
		//	Complete the current lextype
		//
		//	Note that m_ppctx is non-NULL if and only if
		//	ST_SET and the property to set is not a reserved
		//	property.
		//	(That means m_ppctx is NULL on ST_REMOVE, or if the impl
		//	didn't add a pctx, say because it's a reserved prop
		//	and they know the set of this prop will fail anyway....)
		//
		if ((m_sType == ST_SET) && m_ppctx.get())
		{
			m_sbValue.Append (sizeof(WCHAR), L"");
			sc = m_ppctx->ScSetType (m_sbValue.PContents());
			if (FAILED (sc))
				goto ret;
			m_sbValue.Reset();
		}

		m_state = ST_INPROP;
	}

	//	Flags processing
	//
	else if (m_state == ST_FLAGS)
	{
		//	Complete the current set of flags
		//
		//	Note that m_ppctx is non-NULL if and only if
		//	ST_SET and the property to set is not a reserved
		//	property.
		//
		//	That means m_ppctx is NULL on ST_REMOVE, or if the impl
		//	didn't add a pctx, say because it's a reserved prop
		//	and they know the set of this prop will fail anyway....
		//
		if ((m_sType == ST_SET) && m_ppctx.get())
		{
			m_sbValue.Append (sizeof(WCHAR), L"");
			sc = m_ppctx->ScSetFlags (wcstol (m_sbValue.PContents(), NULL, 0));
			if (FAILED (sc))
				goto ret;
			m_sbValue.Reset();
		}

		m_state = ST_INPROP;
	}

	else if (m_state == ST_SEARCHREQUEST)
	{
		sc = m_xo.ScCompleteChildren ( FALSE, XML_ATTRIBUTE, L"", 0 );
		if (FAILED(sc))
			goto ret;
	}

ret:
	return sc;
}

SCODE
CNFPatch::ScCompleteCreateNode (
	/* [in] */ DWORD dwType)
{
	//	Recording mode is only allowed when we are inside a property.  There
	//	no support implemented for recording mode for multivalued properties.
	//
	Assert((ST_INPROP == m_state || ST_LEXTYPE == m_state) || VE_NOECHO == m_vestate);

	if (ST_SEARCHREQUEST == m_state || VE_INPROGRESS == m_vestate)
		m_xo.CompleteCreateNode (dwType);

	return S_OK;
}

SCODE
CNFPatch::ScCompleteChildren (
	/* [in] */ BOOL fEmptyNode,
	/* [in] */ DWORD dwType,
	/* [in] */ const WCHAR __RPC_FAR *pwcText,
	/* [in] */ ULONG ulLen)
{
	SCODE sc = S_OK;
	static const WCHAR wch = 0;

	//	Recording mode is only allowed when we are inside a property.  There
	//	no support implemented for recording mode for multivalued properties.
	//
	Assert((ST_INPROP == m_state || ST_LEXTYPE == m_state) || VE_NOECHO == m_vestate);

	switch (m_state)
	{
		case ST_UPDATE:

			Assert (dwType == XML_ELEMENT);
			m_state = ST_NODOC;
			break;

		case ST_SET:
		case ST_DELETE:

			Assert (dwType == XML_ELEMENT);
			m_state = ST_UPDATE;
			break;

		case ST_PROPS:

			Assert (dwType == XML_ELEMENT);
			m_state = m_sType;
			break;

		case ST_SEARCHREQUEST:

			//	Do searchreqeust processing
			//
			Assert (dwType == XML_ELEMENT);
			sc = m_xo.ScCompleteChildren (fEmptyNode,
										  dwType,
										  pwcText,
										  ulLen);
			if (FAILED (sc))
				goto ret;

			//	26/NOV/99: MAXB
			//	REVIEW: if there are attributes will count really go to zero?
			//
			if (0 != m_xo.LDepth())
				break;

			// else fall through

		case ST_INPROP:

			//	Complete the current property
			//
			//	Note that m_ppctx is non-NULL if and only if
			//	ST_SET and the property to set is not a reserved
			//	property.
			//
			if (m_vestate != VE_NOECHO)
			{
				Assert (dwType == XML_ELEMENT);
				sc = m_xo.ScCompleteChildren (fEmptyNode,
										  dwType,
										  pwcText,
										  ulLen);
				if (FAILED (sc))
					goto ret;

				if (0 != m_xo.LDepth())
					break;
				m_vestate = VE_NOECHO;
			}

			Assert (dwType == XML_ELEMENT);
			if ((m_sType == ST_SET) && m_ppctx.get())
			{
				m_sbValue.Append (sizeof(wch), &wch);
				sc = m_ppctx->ScSetValue (!fEmptyNode
										  ? m_sbValue.PContents()
										  : NULL,
										  m_cmvValues);
				if (FAILED (sc))
					goto ret;

				sc = m_ppctx->ScComplete (fEmptyNode);
				if (FAILED (sc))
					goto ret;

				m_cmvValues = 0;
				m_sbValue.Reset();
				m_ppctx.clear();
			}
			m_state = ST_PROPS;
			break;

		//	When dealing with multivalued properties, we need this extra
		//	state such that each value gets added to the context via a single
		//	call to ScSetValue() with multiple values layed end-to-end.
		//
		case ST_INMVPROP:

			Assert (dwType == XML_ELEMENT);
			if ((m_sType == ST_SET) && m_ppctx.get())
			{
				//	Terminate the current value.
				//
				m_sbValue.Append (sizeof(wch), &wch);
			}
			m_state = ST_INPROP;
			break;

		//  We are finishing a <DAV:resourcetype> tag, reset state to ST_PROPS
		//
		case ST_RESOURCETYPE:
			m_state = ST_PROPS;
			break;

		//  We are inside a <DAV:resourcetype> tag, reset state to ST_RESOURCETYPE
		//
		case ST_STRUCTUREDDOCUMENT:
			m_state = ST_RESOURCETYPE;
			break;
	}

ret:
	return sc;
}

SCODE
CNFPatch::ScHandleNode (
	/* [in] */ DWORD dwType,
	/* [in] */ DWORD dwSubType,
	/* [in] */ BOOL fTerminal,
	/* [in] */ const WCHAR __RPC_FAR *pwcText,
	/* [in] */ ULONG ulLen,
	/* [in] */ ULONG ulNamespaceLen,
	/* [in] */ const WCHAR __RPC_FAR *pwcNamespace,
	/* [in] */ const ULONG ulNsPrefixLen)
{
	CStackBuffer<WCHAR> wsz;
	LPCWSTR pwszTag;
	SCODE sc = S_FALSE;
	UINT cch;

	//	Recording mode is only allowed when we are inside a property.  There
	//	no support implemented for recording mode for multivalued properties.
	//
	Assert((ST_INPROP == m_state || ST_LEXTYPE == m_state) || VE_NOECHO == m_vestate);

	//	Forward to searchreqeust node handling
	//
	if (ST_SEARCHREQUEST == m_state)
	{
		sc = m_xo.ScHandleNode (dwType,
								dwSubType,
								fTerminal,
								pwcText,
								ulLen,
								ulNamespaceLen,
								pwcNamespace,
								ulNsPrefixLen);
		goto ret;
	}

	//	If we are performing value echoing, do it now
	//	NOTE: that unlike ST_SEARCHREQUEST we *also*
	//	do other processing.
	//
	if (m_vestate == VE_INPROGRESS)
	{
		sc = m_xo.ScHandleNode (dwType,
								dwSubType,
								fTerminal,
								pwcText,
								ulLen,
								ulNamespaceLen,
								pwcNamespace,
								ulNsPrefixLen);
		if (FAILED(sc))
			goto ret;
	}

	//	Normal handling performed whether we are echoing
	//	values or not
	//
	switch (dwType)
	{
		case XML_ELEMENT:

			//	Handle any state changes based on element
			//	names
			//
			sc = ScHandleElementNode (dwType,
									  dwSubType,
									  fTerminal,
									  pwcText,
									  ulLen,
									  ulNamespaceLen,
									  pwcNamespace,
									  ulNsPrefixLen);
			if (FAILED (sc))
				goto ret;

			break;

		case XML_ATTRIBUTE:

			if ((m_state == ST_INPROP) && (XML_NS != dwSubType))
			{
				cch = ulNamespaceLen + ulLen;
				pwszTag = wsz.resize(CbSizeWsz(cch));
				if (NULL == pwszTag)
				{
					sc = E_OUTOFMEMORY;
					goto ret;
				}
				wcsncpy (wsz.get(), pwcNamespace, ulNamespaceLen);
				wcsncpy (wsz.get() + ulNamespaceLen, pwcText, ulLen);
				*(wsz.get() + cch) = 0;

				//	If this is a lextype attribute, make the
				//	appropriate transition
				//
				if (!_wcsnicmp (pwszTag, gc_wszLexType, cch) ||
					!wcsncmp (pwszTag, gc_wszDataTypes, cch) ||
					!wcsncmp (pwszTag, gc_wszLexTypeOfficial, cch))
				{
					m_state = ST_LEXTYPE;
					sc = S_OK;
				}
				else if (!wcsncmp (pwszTag, gc_wszFlags, cch))
				{
					m_state = ST_FLAGS;
					sc = S_OK;
				}
			}
			break;

		case XML_PCDATA:
		case XML_WHITESPACE:

			if (m_vestate != VE_INPROGRESS)
			{
				switch (m_state)
				{
					case ST_INPROP:

						//	If we are in the transition from outside, value to
						//	inside value -- and visa versa -- we do not want to
						//	add anything to the current buffer.
						//	Note that m_ppcxt may be NULL if we've encountered a
						//	reserved property in the request.
						//
						if ((XML_WHITESPACE == dwType) &&
							(!m_ppctx.get() || m_ppctx->FMultiValued()))
							break;

						// !!! FALL THROUGH !!! */

					case ST_INMVPROP:

						//	Note that m_ppctx is non-NULL if and only if
						//	ST_SET and the property to set is not a reserved
						//	property.  If these are not set, then ignore the
						//	value.
						//
						if ((m_sType != ST_SET) || !m_ppctx.get())
							break;

						/* !!! FALL THROUGH !!! */

					case ST_LEXTYPE:
					case ST_FLAGS:

						Assert (fTerminal);

						//	Build up the value for later use...
						//
						m_sbValue.Append (ulLen * sizeof(WCHAR), pwcText);
						sc = S_OK;
				}
			}
	}

ret:
	return sc;
}

SCODE
CNFPatch::ScHandleElementNode (
	/* [in] */ DWORD dwType,
	/* [in] */ DWORD dwSubType,
	/* [in] */ BOOL fTerminal,
	/* [in] */ const WCHAR __RPC_FAR *pwcText,
	/* [in] */ ULONG ulLen,
	/* [in] */ ULONG ulNamespaceLen,
	/* [in] */ const WCHAR __RPC_FAR *pwcNamespace,
	/* [in] */ const ULONG ulNsPrefixLen)
{
	CStackBuffer<WCHAR> wsz;
	LPCWSTR pwszTag;
	SCODE sc = S_FALSE;
	UINT cch;

	//	Recording mode is only allowed when we are inside a property.  There
	//	no support implemented for recording mode for multivalued properties.
	//
	Assert((ST_INPROP == m_state || ST_LEXTYPE == m_state) || VE_NOECHO == m_vestate);

	//	Construct the full name of the node
	//
	cch = ulNamespaceLen + ulLen;
	pwszTag = wsz.resize(CbSizeWsz(cch));
	if (NULL == pwszTag)
	{
		sc = E_OUTOFMEMORY;
		goto ret;
	}
	wcsncpy (wsz.get(), pwcNamespace, ulNamespaceLen);
	wcsncpy (wsz.get() + ulNamespaceLen, pwcText, ulLen);
	*(wsz.get() + cch) = 0;

	switch (m_state)
	{
		case ST_NODOC:

			//	If this is the topmost node in a propfind request,
			//	transition to the next state.  Since there is no parent
			//	node to provide scoping, FIsTag() cannot be used here!
			//
			if (!wcscmp (pwszTag, gc_wszPropertyUpdate))
			{
				m_state = ST_UPDATE;
				sc = S_OK;
			}
			break;

		case ST_UPDATE:

			//	Look for our well know node types
			//
			if (FIsTag (pwszTag, gc_wszSet))
			{
				m_state = m_sType = ST_SET;
				sc = S_OK;
			}
			else if (FIsTag (pwszTag, gc_wszRemove))
			{
				m_state = m_sType = ST_DELETE;
				sc = S_OK;
			}
			break;

		case ST_SET:
		case ST_DELETE:

			//	Look for our well know node types
			//
			if (FIsTag (pwszTag, gc_wszProp))
			{
				m_state = ST_PROPS;
				sc = S_OK;
			}
			break;

		case ST_PROPS:

			//	Process the property as requested...
			//
			if (dwType == XML_ELEMENT)
			{
				m_state = ST_INPROP;
				if (m_sType == ST_SET)
				{
					//	Get a property context from the patch context
					//	that we can fill out and complete...
					//
					Assert (0 == m_cmvValues);
					Assert (NULL == m_ppctx.get());

					//  If it's resourcetype request, change the state
					//  and don't set props
					//
					if (FIsTag (pwszTag, gc_wszResoucetype))
					{
						m_state = ST_RESOURCETYPE;
						sc = S_OK;
					}
					else
					{
						sc = m_cpc.ScSetProp (NULL, pwszTag, m_ppctx);
						if (FAILED (sc))
							goto ret;

						//	Special handling for search requests, recording
						//	begins immediately
						//
						if (FIsTag (pwszTag, gc_wszSearchRequest))
						{
							CEmitNmspc cen(m_xo);

							//	Make the state transition and start recording
							//
							m_state = ST_SEARCHREQUEST;
							sc = m_xo.ScHandleNode (dwType,
								dwSubType,
								fTerminal,
								pwcText,
								ulLen,
								ulNamespaceLen,
								pwcNamespace,
								ulNsPrefixLen);

							//	Spit out the namespaces.
							//
							//	Note that this will spit out any namespaces
							//	decl'd in the DAV:owner node itself.  So we
							//	do not really want to emit these out to the
							//	owners comments until ScCompleteAttribute()
							//	is called.
							//
							Assert (!m_xo.FAddNamespaceDecl());
							m_cache.ForEach(cen);
							sc = S_OK;
						}
						//	Special handling for case when we are PROPPATCH-ing
						//	XML valued properties.  In this case we don't begin
						//	recording yet because we don't want the property
						//	node just the XML value inside
						//
						else if (FValueIsXML (pwszTag))
							m_vestate = VE_NEEDNS;
					}
				}
				else
				{
					//	Queue the property for deletion with
					//	the patch context
					//
					Assert (m_sType == ST_DELETE);
					sc = m_cpc.ScDeleteProp (NULL, pwszTag);
					if (FAILED (sc))
						goto ret;
				}
			}
			break;

		case ST_INPROP:

			//	Normal case -- value echoing is off.  The work here is to
			//	deal with multivalued properties.  In this case we need an extra
			//	state such that each value gets added to the context via a single
			//	call to ScSetValue() with multiple values layed end-to-end.
			//
			//		NOTE: support for handling multivalued properties has not been
			//		added for echoing mode.  If you add an XML valued multivalued
			//		property you need to do	some work in the echo mode cases below
			//
			if (m_vestate == VE_NOECHO)
			{
				//	m_ppctx is NULL when we have attempted to set a reserved
				//  (read only) property.  when this happens, we need to continue
				//  parsing the request, but we don't actually set the properties.
				//  thus, we need to set the correct state as if this was a valid
				//  request.
				//
				if (NULL == m_ppctx.get())
				{
					m_state = ST_INMVPROP;
					sc = S_OK;
				}
				else if (m_ppctx->FMultiValued() && FIsTag (pwszTag, gc_wszXml_V))
				{
					m_state = ST_INMVPROP;
					m_cmvValues += 1;
					sc = S_OK;
				}
			}

			//	We are echoing values or about to start echoing values
			//
			else
			{
				//	If this is the first element seen that is part of an XML-valued
				//	property that we are PROPPATCH-ing, then we need to spit out
				//	the cached namespaces they are available to the EXOLEDB side
				//
				if (m_vestate == VE_NEEDNS)
				{
					CEmitNmspc cen(m_xo);

					//	Make the state transition and start recording
					//
					m_vestate = VE_INPROGRESS;
					sc = m_xo.ScHandleNode (dwType,
											dwSubType,
											fTerminal,
											pwcText,
											ulLen,
											ulNamespaceLen,
											pwcNamespace,
											ulNsPrefixLen);

					//	Spit out the namespaces.
					//
					//	Note that this will spit out any namespaces
					//	decl'd in the DAV:owner node itself.  So we
					//	do not really want to emit these out to the
					//	owners comments until ScCompleteAttribute()
					//	is called.
					//
					Assert (!m_xo.FAddNamespaceDecl());
					m_cache.ForEach(cen);

				}

				//	Indicate that additional namespace declarations
				//	should be echoed as we see them
				//
				m_xo.CompleteAttribute();

				sc = S_OK;
			}
			break;
		//  We see a <DAV:resourcetype> tag.  It should be in a MKCOL body.
		//
		case ST_RESOURCETYPE:
			//  If resourcetype is not structured doc, just ignore
			//
			if (FIsTag (pwszTag, gc_wszStructureddocument))
			{
				m_cpc.SetCreateStructureddocument();
				m_state = ST_STRUCTUREDDOCUMENT;
				sc = S_OK;
			}
			break;
	}

ret:
	return sc;
}

// Tags that have XML values that need to be shipped across epoxy
//
const WCHAR * gc_rgwszXMLValueTags[] =
{
	L"http://schemas.microsoft.com/exchange/security/admindescriptor",
	L"http://schemas.microsoft.com/exchange/security/descriptor",
	L"http://schemas.microsoft.com/exchange/security/creator",
	L"http://schemas.microsoft.com/exchange/security/lastmodifier",
	L"http://schemas.microsoft.com/exchange/security/sender",
	L"http://schemas.microsoft.com/exchange/security/sentrepresenting",
	L"http://schemas.microsoft.com/exchange/security/originalsender",
	L"http://schemas.microsoft.com/exchange/security/originalsentrepresenting",
	L"http://schemas.microsoft.com/exchange/security/readreceiptfrom",
	L"http://schemas.microsoft.com/exchange/security/reportfrom",
	L"http://schemas.microsoft.com/exchange/security/originator",
	L"http://schemas.microsoft.com/exchange/security/reportdestination",
	L"http://schemas.microsoft.com/exchange/security/originalauthor",
	L"http://schemas.microsoft.com/exchange/security/receivedby",
	L"http://schemas.microsoft.com/exchange/security/receivedrepresenting",
};


//This function tests to see if a property has an XML value that must be
//shipped from DAVEX to EXOLEDB
//
BOOL
CNFPatch::FValueIsXML( const WCHAR *pwcTag )
{
	BOOL	f = FALSE;

	ULONG	iwsz;

	for (iwsz = 0; iwsz < sizeof(gc_rgwszXMLValueTags)/sizeof(WCHAR *); iwsz ++)
	{
		if (wcscmp (pwcTag, gc_rgwszXMLValueTags[iwsz]) == 0)
		{
			f = TRUE;
			break;
		}
	}
	return f;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_xmllib\xnode.cpp ===
/*
 *	X N O D E . C P P
 *
 *	XML emitter processing
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_xmllib.h"
#include <string.h>
#include <stdio.h>

//	class CXNode - Emitting ---------------------------------------------------
//
//	Our own version of WideCharToMultiByte(CP_UTF8, ...)
//
//	UTF-8 multi-byte encoding.  See Appendix A.2 of the Unicode book for
//	more info.
//
//		Unicode value    1st byte    2nd byte    3rd byte
//		000000000xxxxxxx 0xxxxxxx
//		00000yyyyyxxxxxx 110yyyyy    10xxxxxx
//		zzzzyyyyyyxxxxxx 1110zzzz    10yyyyyy    10xxxxxx
//
inline
VOID WideCharToUTF8Chars (WCHAR wch, BYTE * pb, UINT * pib)
{
	Assert (pb);
	Assert (pib);

	UINT	ib = *pib;

	//	single-byte: 0xxxxxxx
	//
	if (wch < 0x80)
	{
		pb[ib] = static_cast<BYTE>(wch);
	}
	//
	//	two-byte: 110xxxxx 10xxxxxx
	//
	else if (wch < 0x800)
	{
		//	Because we alloc'd two extra-bytes,
		//	we know there is room at the tail of
		//	the buffer for the overflow...
		//
		pb[ib++] = static_cast<BYTE>((wch >> 6) | 0xC0);
		pb[ib] = static_cast<BYTE>((wch & 0x3F) | 0x80);
	}
	//
	//	three-byte: 1110xxxx 10xxxxxx 10xxxxxx
	//
	else
	{
		//	Because we alloc'd two extra-bytes,
		//	we know there is room at the tail of
		//	the buffer for the overflow...
		//
		pb[ib++] = static_cast<BYTE>((wch >> 12) | 0xE0);
		pb[ib++] = static_cast<BYTE>(((wch >> 6) & 0x3F) | 0x80);
		pb[ib] = static_cast<BYTE>((wch & 0x3F) | 0x80);
	}

	*pib = ib;
}

SCODE
CXNode::ScAddUnicodeResponseBytes (
	/* [in] */ UINT cch,
	/* [in] */ LPCWSTR pcwsz)
{
	SCODE sc = S_OK;

	//	Argh!  We need to have a buffer to fill that is
	//	at least 3 bytes long for the odd occurrence of a
	//	single unicode char with significant bits above
	//	0x7f.
	//
	UINT cb = min (cch + 2, CB_XMLBODYPART_SIZE);

	//	We really can handle zero bytes being sloughed into
	//	the buffer.
	//
	UINT ib;
	UINT iwch;
	CStackBuffer<BYTE,512> pb;

	if (NULL == pb.resize(cb))
	{
		sc = E_OUTOFMEMORY;
		goto ret;
	}

	for (iwch = 0; iwch < cch; )
	{
		for (ib = 0;
			 (ib < cb-2) && (iwch < cch);
			 ib++, iwch++)
		{
			WideCharToUTF8Chars (pcwsz[iwch], pb.get(), &ib);
		}

		//	Add the bytes
		//
		Assert (ib <= cb);
		sc = m_pxb->ScAddTextBytes (ib, reinterpret_cast<LPSTR>(pb.get()));
		if (FAILED(sc))
			goto ret;
	}

ret:
	return sc;
}

SCODE
CXNode::ScAddEscapedValueBytes (UINT cch, LPCSTR psz)
{
	SCODE sc = S_OK;
	const CHAR* pch;
	const CHAR* pchLast;

	for (pchLast = pch = psz; pch < psz + cch; pch++)
	{
		//	Character Range
		//	[2] Char ::=  #x9
		//				| #xA
		//				| #xD
		//				| [#x20-#xD7FF]
		//				| [#xE000-#xFFFD]
		//				| [#x10000-#x10FFFF]
		//
		//	/* any Unicode character, excluding the surrogate blocks, FFFE, and FFFF. */
		//
		//	Valid characters also escaped in values:
		//
		//		&	-- escaped as &amp;
		//		<	-- excaped as &lt;
		//		>	-- excaped as &gt;
		//
		if ('&' == *pch)
		{
			//	Add the bytes up to this position
			//
			sc = m_pxb->ScAddTextBytes (static_cast<UINT>(pch - pchLast), pchLast);
			if (FAILED(sc))
				goto ret;

			//	Add the escape sequence
			//
			sc = m_pxb->ScAddTextBytes (CchConstString(gc_szAmp), gc_szAmp);
			if (FAILED(sc))
				goto ret;

			//	Update pchLast to account for what has been emitted
			//
			pchLast = pch + 1;
		}
		else if ('<' == *pch)
		{
			//	Add the bytes up to this position
			//
			sc = m_pxb->ScAddTextBytes (static_cast<UINT>(pch - pchLast), pchLast);
			if (FAILED(sc))
				goto ret;

			//	Add the escape sequence
			//
			sc = m_pxb->ScAddTextBytes (CchConstString(gc_szLessThan), gc_szLessThan);
			if (FAILED(sc))
				goto ret;

			//	Update pchLast to account for what has been emitted
			//
			pchLast = pch + 1;
		}
		else if ('>' == *pch)
		{
			//	Add the bytes up to this position
			//
			sc = m_pxb->ScAddTextBytes (static_cast<UINT>(pch - pchLast), pchLast);
			if (FAILED(sc))
				goto ret;

			//	Add the escape sequence
			//
			sc = m_pxb->ScAddTextBytes (CchConstString(gc_szGreaterThan), gc_szGreaterThan);
			if (FAILED(sc))
				goto ret;

			//	Update pchLast to account for what has been emitted
			//
			pchLast = pch + 1;
		}
		else if (	(0x9 > static_cast<BYTE>(*pch))
				 || (0xB == *pch)
				 || (0xC == *pch)
				 || ((0x20 > *pch) && (0xD < *pch)))
		{
			char rgch[10];

			//	Add the bytes up to this position
			//
			sc = m_pxb->ScAddTextBytes (static_cast<UINT>(pch - pchLast), pchLast);
			if (FAILED(sc))
				goto ret;

			//	Add the escape sequence...
			//
			sprintf (rgch, "&#x%02X;", *pch);
			Assert (strlen(rgch) == CchConstString("&#x00;"));
			sc = m_pxb->ScAddTextBytes (CchConstString("&#x00;"), rgch);
			if (FAILED(sc))
				goto ret;

			pchLast = pch + 1;
		}
		else if (pch - pchLast + 1 >= CB_XMLBODYPART_SIZE)
		{
			//	Break up if the bodyparts gets too big
			//
			sc = m_pxb->ScAddTextBytes (static_cast<UINT>(pch - pchLast + 1), pchLast);
			if (FAILED(sc))
				goto ret;

			pchLast = pch + 1;
		}
	}

	//	Add any remaining bytes
	//
	sc = m_pxb->ScAddTextBytes (static_cast<UINT>(pch - pchLast), pchLast);
	if (FAILED(sc))
		goto ret;

ret:
	return sc;
}

SCODE
CXNode::ScAddEscapedAttributeBytes (UINT cch, LPCSTR psz)
{
	SCODE sc = S_OK;
	const CHAR* pch;
	const CHAR* pchLast;

	for (pchLast = pch = psz; pch < psz + cch; pch++)
	{
		//	Characters escaped in values:
		//
		//		&	-- escaped as &amp;
		//		"	-- excaped as &quot;
		//
		if ('&' == *pch)
		{
			//	Add the bytes up to this position
			//
			sc = m_pxb->ScAddTextBytes (static_cast<UINT>(pch - pchLast), pchLast);
			if (FAILED(sc))
				goto ret;

			//	Add the escape sequence
			//
			sc = m_pxb->ScAddTextBytes (CchConstString(gc_szAmp), gc_szAmp);
			if (FAILED(sc))
				goto ret;

			//	Update pchLast to account for what has been emitted
			//
			pchLast = pch + 1;
		}
		else if ('"' == *pch)
		{
			//	Add the bytes up to this position
			//
			sc = m_pxb->ScAddTextBytes (static_cast<UINT>(pch - pchLast), pchLast);
			if (FAILED(sc))
				goto ret;

			//	Add the escape sequence
			//
			sc = m_pxb->ScAddTextBytes (CchConstString(gc_szQuote), gc_szQuote);
			if (FAILED(sc))
				goto ret;

			//	Update pchLast to account for what has been emitted
			//
			pchLast = pch + 1;
		}
		else if ((0x9 > static_cast<BYTE>(*pch))
				 || (0xB == *pch)
				 || (0xC == *pch)
				 || ((0x20 > *pch) && (0xD < *pch)))
		{
			char rgch[10];

			//	Add the bytes up to this position
			//
			sc = m_pxb->ScAddTextBytes (static_cast<UINT>(pch - pchLast), pchLast);
			if (FAILED(sc))
				goto ret;

			//	Add the escape sequence...
			//
			sprintf (rgch, "&#x%02X;", *pch);
			Assert (strlen(rgch) == CchConstString("&#x00;"));
			sc = m_pxb->ScAddTextBytes (CchConstString("&#x00;"), rgch);
			if (FAILED(sc))
				goto ret;

			pchLast = pch + 1;
		}
	}

	//	Add any remaining bytes
	//
	sc = m_pxb->ScAddTextBytes (static_cast<UINT>(pch - pchLast), pchLast);
	if (FAILED(sc))
		goto ret;

ret:
	return sc;
}

//	class CXNode - Construction -----------------------------------------------
//
SCODE
CXNode::ScWriteTagName ()
{
	SCODE sc = S_OK;

	//	If there is a namespace associated with this node,
	//	when writing out the tag name, add the alias and a
	//	separator to the data stream.
	//
	if (m_pns.get() && m_pns->CchAlias())
	{
		//	Add the alias
		//
		sc = ScAddUnicodeResponseBytes (m_pns->CchAlias(), m_pns->PszAlias());
		if (FAILED(sc))
			goto ret;

		//	Add in the separator
		//
		sc = m_pxb->ScAddTextBytes(1, &gc_chColon);
		if (FAILED(sc))
			goto ret;
	}

	//	Write the tag
	//
	Assert (m_pwszTagEscaped.get());
	sc = ScAddUnicodeResponseBytes (m_cchTagEscaped, m_pwszTagEscaped.get());
	if (FAILED(sc))
		goto ret;

ret:
	return sc;
}

SCODE
CXNode::ScSetTag (CXMLEmitter* pmsr, UINT cchTag, LPCWSTR pwszTag)
{
	LPCWSTR pwszName = pwszTag;
	SCODE sc = S_OK;
	BOOL fAddNmspc = FALSE;
	UINT cch = 0;
	UINT cchName = 0;
	UINT cchTagEscaped = 64;
	auto_heap_ptr<WCHAR> pwszTagEscaped;

	//	Namespace nodes do not have a namespace associated with them,
	//	so don't even bother looking...
	//
	switch (m_xnt)
	{
		case XN_ELEMENT:
		case XN_ATTRIBUTE:

			//	See if a namespace applies to this tag
			//
			cch = CchNmspcFromTag (cchTag, pwszTag, &pwszName);
			if (0 == cch)
			{
				m_fHasEmptyNamespace = TRUE;
			}
			else
			{
				//	Find the namespace to use
				//
				sc = pmsr->ScFindNmspc (pwszTag, cch, m_pns);
				if (FAILED (sc))
					goto ret;

				//	If a new namespace is added in the local namespace
				//	cache, make sure we emit it in the node
				//
				//$NOTE: this is how we handle pilot namespace, this is
				//$NOTE: is NOT the normal way of handling namespaces. All
				//$NOTE: common namespaces should be preloaded.
				//$NOTE:
				//
				fAddNmspc = (sc == S_FALSE);

				//	We should have preloaded all namespaces. The pilot
				//	namespace is handled here to avoid emitting invalid
				//	xml. But we should look into the reason why the pilot
				//	namespace comes up. so assert here.
				//
				//	Note that this assert should be removed if we decide
				//	we want to leave uncommon namesapces not preloaded and
				//	expect them to be treated as pilot namespaces.
				//
				AssertSz(!fAddNmspc, "Pilot namespace found, safe to ingore,"
									 "but please raid against HTTP-DAV");
			}

			break;

		case XN_NAMESPACE:
			break;
	}

	//	Record the new tag and\or its length
	//
	//	NOTE: the item that goes into the tag cache is the name
	//	of the property with the namespace stripped off.  This is
	//	important to know when doing searches in the tag cache.
	//
	cchName = static_cast<UINT>(pwszTag + cchTag - pwszName);
	if (0 == cchName )
	{
		//	We really need to have a tag that has a value.  Empty
		//	tags produce invalid XML.
		//
		sc = E_DAV_INVALID_PROPERTY_NAME;
		goto ret;
	}
	sc = CXAtomCache::ScCacheAtom (&pwszName, cchName);
	if (FAILED (sc))
		goto ret;

	//	ScSetTag shouldn't have been called for this node.
	//
	Assert (!m_pwszTagEscaped.get());

	//	Allocate buffer for the property tag.
	//
	pwszTagEscaped = static_cast<WCHAR*>(ExAlloc(CbSizeWsz(cchTagEscaped)));
	if (!pwszTagEscaped.get())
	{
		sc = E_OUTOFMEMORY;
		goto ret;
	}

	//	Escape the tag name as required.
	//
	//  If we have an empty namespace, we need to impose additional
	//  restrictions on the first character of the property name because
	//  it will be the first character of the xml node, and the first
	//  character of an xml node can only be a letter or an underscore
	//  (numbers, etc. are not allowed).
	//
	//  Note:  This will disallow an xml node <123> because it is invalid
	//  xml, but it will ALLOW the xml node <a:123> even though this is
	//  also invalid.  This is by design because most xml parsers will handle
	//  this appropriately, and it makes more sense to clients.
	//
	sc = ScEscapePropertyName (pwszName, cchName, pwszTagEscaped.get(), &cchTagEscaped, m_fHasEmptyNamespace);
	if (S_FALSE == sc)
	{
		pwszTagEscaped.clear();
		pwszTagEscaped = static_cast<WCHAR*>(ExAlloc(CbSizeWsz(cchTagEscaped)));
		if (!pwszTagEscaped.get())
		{
			sc = E_OUTOFMEMORY;
			goto ret;
		}

		sc = ScEscapePropertyName (pwszName, cchName, pwszTagEscaped.get(), &cchTagEscaped, m_fHasEmptyNamespace);
		Assert (S_OK == sc);
	}

	m_pwszTagEscaped = pwszTagEscaped.relinquish();
	m_cchTagEscaped = cchTagEscaped;

	//	Start a new node if XN_ELEMENT
	//
	if (m_xnt == XN_ELEMENT)
	{
		sc = m_pxb->ScAddTextBytes (1, "<");
		if (FAILED(sc))
			goto ret;
	}

	sc = ScWriteTagName();
	if (FAILED(sc))
		goto ret;

	if (fAddNmspc)
	{
		//	Add the namespace attribute in the node if necessary
		//
		sc = pmsr->ScAddNmspc (m_pns, this);
		if (FAILED(sc))
			goto ret;

		//	Save the emitter which can be used later to remove the temporary nmspc
		//
		m_pmsr = pmsr;
	}

ret:
	return sc;
}

SCODE
CXNode::ScDone ()
{
	SCODE sc = S_OK;

	//	This method should never be called twice
	//
	Assert (!m_fDone);
	switch (m_xnt)
	{
		case XN_ELEMENT:

			if (!m_pwszTagEscaped.get())
			{
				//$	RAID: 85824: When an invalid property name is unpacked,
				//	ScSetTag will fail with E_DAV_INVALID_PROPERTY_NAME.
				//
				//	Usuallly, the client will fail when it sees any error
				//	from CXNode methods, but in this case it may choose to
				//	continue and ignore this node completely.
				//
				//	For us, it's safe to not to emit anything when no tag name
				//	is available.
				//
				break;
				//
				//$RAID: 85824
			}

			if (m_fNodeOpen)
			{
				//	Node is open, so emit a complete closing node
				//	</tag>
				//
				sc = m_pxb->ScAddTextBytes (2, "</");
				if (FAILED(sc))
					goto ret;

				//	Add tag
				//
				sc = ScWriteTagName();
				if (FAILED(sc))
					goto ret;

				//	closing
				//
				sc = m_pxb->ScAddTextBytes (1, ">");
				if (FAILED(sc))
					goto ret;
			}
			else
			{
				//	Close directly
				//
				sc = m_pxb->ScAddTextBytes (2, "/>");
				if (FAILED(sc))
					goto ret;
			}

			break;

		case XN_NAMESPACE:

			//	Namespace nodes, should not have a namespace associated with
			//	them.
			//
			Assert (NULL == m_pns.get());
			//
			//	  Otherwise treat it at an attribute -- and fall through

		case XN_ATTRIBUTE:

			Assert (m_pwszTagEscaped.get());
			break;
	}

	//	Remove the pilot namespace from global cache
	//
	if (m_pmsr)
		m_pmsr->RemovePersisted(m_pns);

	m_fDone = TRUE;

ret:
	return sc;
}

SCODE
CXNode::ScSetFormatedXML (LPCSTR pszValue, UINT cch)
{
	SCODE	sc = S_OK;

	Assert (m_xnt == XN_ELEMENT);

	if (!m_fNodeOpen)
	{
		// We must have written the tag name
		//
		Assert (m_pwszTagEscaped.get());

		// Now that we are adding value to the element node
		// We should write the node open
		//
		sc = m_pxb->ScAddTextBytes (1, ">");
		if (FAILED(sc))
			goto ret;

		m_fNodeOpen = TRUE;
	}

	//	Add the value directly
	//
	sc = m_pxb->ScAddTextBytes (cch, pszValue);
	if (FAILED(sc))
		goto ret;

ret:
	return sc;
}

SCODE
CXNode::ScSetFormatedXML (LPCWSTR pwszValue, UINT cch)
{
	SCODE	sc = S_OK;

	Assert (m_xnt == XN_ELEMENT);

	if (!m_fNodeOpen)
	{
		// We must have written the tag name
		//
		Assert (m_pwszTagEscaped.get());

		// Now that we are adding value to the element node
		// We should write the node open
		//
		sc = m_pxb->ScAddTextBytes (1, ">");
		if (FAILED(sc))
			goto ret;

		m_fNodeOpen = TRUE;
	}

	//	Add the value directly
	//
	sc = ScAddUnicodeResponseBytes (cch, pwszValue);
	if (FAILED(sc))
		goto ret;

ret:
	return sc;
}


SCODE
CXNode::ScSetUTF8Value (LPCSTR pszValue, UINT cch)
{
	SCODE sc = S_OK;

	switch (m_xnt)
	{
		case XN_ELEMENT:

			if (!m_fNodeOpen)
			{
				// We must have written the tag name
				//
				Assert (m_pwszTagEscaped.get());

				// Now that we are adding value to the element node
				// We should write the node open
				//
				sc = m_pxb->ScAddTextBytes (1, ">");
				if (FAILED(sc))
					goto ret;

				m_fNodeOpen = TRUE;
			}

			// Write the value
			//
			sc =  ScAddEscapedValueBytes (cch, pszValue);
			if (FAILED(sc))
				goto ret;

			break;

		case XN_NAMESPACE:
		case XN_ATTRIBUTE:

			//	Write the value directly
			//
			sc =  ScAddEscapedAttributeBytes (cch, pszValue);
			if (FAILED(sc))
				goto ret;
			break;
	}

ret:
	return sc;
}

SCODE
CXNode::ScSetValue (LPCSTR pszValue, UINT cch)
{
	//	Ok, against all better judgement, we need to take this
	//	multi-byte string and convert it to unicode before doing
	//	any UTF8 processing on it.
	//
	//	Translations from multibyte to unicode, can never grow in
	//	character counts, so we are relatively safe allocating this
	//	on the stack.
	//
	UINT cchUnicode;
	CStackBuffer<WCHAR,512> pwsz;
	if (NULL == pwsz.resize(CbSizeWsz(cch)))
		return E_OUTOFMEMORY;

	cchUnicode = MultiByteToWideChar (GetACP(),
									  0,
									  pszValue,
									  cch,
									  pwsz.get(),
									  cch + 1);

	//	Terminate the string
	//
	Assert ((0 == cchUnicode) || (0 != *(pwsz.get() + cchUnicode - 1)));
	*(pwsz.get() + cchUnicode) = 0;

	//	Set the value
	//
	return ScSetValue (pwsz.get(), cchUnicode);
}

SCODE
CXNode::ScSetValue (LPCWSTR pcwsz, UINT cch)
{
	SCODE sc = S_OK;

	//	Argh!  We need to have a buffer to fill that is
	//	at least 3 bytes long for the odd occurrence of a
	//	single unicode char with significant bits above
	//	0x7f.
	//	Note that when the value
	UINT cb = min (cch + 2, CB_XMLBODYPART_SIZE);

	//	We really can handle zero bytes being sloughed into
	//	the buffer.
	//
	UINT ib;
	UINT iwch;
	CStackBuffer<BYTE,512> pb;

	if (NULL == pb.resize(cb))
	{
		sc = E_OUTOFMEMORY;
		goto ret;
	}

	for (iwch = 0; iwch < cch; )
	{
		for (ib = 0; (ib < cb-2) && (iwch < cch); ib++, iwch++)
			WideCharToUTF8Chars (pcwsz[iwch], pb.get(), &ib);

		//	Add the bytes
		//
		Assert (ib <= cb);
		sc = ScSetUTF8Value (reinterpret_cast<LPSTR>(pb.get()), ib);
		if (FAILED(sc))
			goto ret;
	}

ret:
	return sc;
}

SCODE
CXNode::ScGetChildNode (XNT xntType, CXNode **ppxnChild)
{
	SCODE sc = S_OK;
	auto_ref_ptr<CXNode> pxn;

	Assert (ppxnChild);
	if (XN_ELEMENT == xntType)
	{
		//	Now that new element child node is added, then this node is done open.
		//	i.e close by ">", instead of "/>"
		//
		if (!m_fNodeOpen)
		{
			sc = m_pxb->ScAddTextBytes (1, ">");
			if (FAILED(sc))
				goto ret;

			//	Then this node is an open node
			//
			m_fNodeOpen = TRUE;
		}
	}
	else
	{
		Assert ((XN_ATTRIBUTE == xntType) || (XN_NAMESPACE == xntType));
	}

	//	Create the child node
	//
	pxn.take_ownership (new CXNode(xntType, m_pxb));
	if (!pxn.get())
	{
		sc = E_OUTOFMEMORY;
		goto ret;
	}

	//	Pass back
	//
	*ppxnChild = pxn.relinquish();

ret:
	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_xmllib\_xmllib.cpp ===
/*
 *	_ X M L L I B . C P P
 *
 *	Precompiled header
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_xmllib.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_xmllib\xprs.cpp ===
/*
 *	X P R S . C P P
 *
 *	XML push model parsing
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_xmllib.h"

#define IID_INodeFactory	__uuidof(INodeFactory)
#define IID_IXMLParser		__uuidof(IXMLParser)

//	Debugging: Node types -----------------------------------------------------
//
DEC_CONST WCHAR gc_wszUnknown[] = L"UNKNOWN";

#define WszNodeType(_t)		{_t,L#_t}
typedef struct _NodeTypeMap {

	DWORD		dwType;
	LPCWSTR		wszType;

} NTM;

#ifdef	DBG
const NTM gc_mpnt[] = {

#pragma warning(disable:4245)	//	signed/unsigned conversion

	WszNodeType(XML_ELEMENT),
	WszNodeType(XML_ATTRIBUTE),
	WszNodeType(XML_PI),
	WszNodeType(XML_XMLDECL),
	WszNodeType(XML_DOCTYPE),
	WszNodeType(XML_DTDATTRIBUTE),
	WszNodeType(XML_ENTITYDECL),
	WszNodeType(XML_ELEMENTDECL),
	WszNodeType(XML_ATTLISTDECL),
	WszNodeType(XML_NOTATION),
	WszNodeType(XML_GROUP),
	WszNodeType(XML_INCLUDESECT),
	WszNodeType(XML_PCDATA),
	WszNodeType(XML_CDATA),
	WszNodeType(XML_IGNORESECT),
	WszNodeType(XML_COMMENT),
	WszNodeType(XML_ENTITYREF),
	WszNodeType(XML_WHITESPACE),
	WszNodeType(XML_NAME),
	WszNodeType(XML_NMTOKEN),
	WszNodeType(XML_STRING),
	WszNodeType(XML_PEREF),
	WszNodeType(XML_MODEL),
	WszNodeType(XML_ATTDEF),
	WszNodeType(XML_ATTTYPE),
	WszNodeType(XML_ATTPRESENCE),
	WszNodeType(XML_DTDSUBSET),
	WszNodeType(XML_LASTNODETYPE)

#pragma warning(default:4245)	//	signed/unsigned conversion

};
#endif	// DBG

inline LPCWSTR
PwszNodeType (DWORD dwType)
{
#ifdef	DBG

	for (UINT i = 0; i < CElems(gc_mpnt); i++)
		if (gc_mpnt[i].dwType == dwType)
			return gc_mpnt[i].wszType;

#endif	// DBG

	return gc_wszUnknown;
}

//	Debugging: Sub-node Types -------------------------------------------------
//
#ifdef	DBG
const NTM gc_mpsnt[] = {

#pragma warning(disable:4245)	//	signed/unsigned conversion

	WszNodeType(0),
	WszNodeType(XML_VERSION),
	WszNodeType(XML_ENCODING),
	WszNodeType(XML_STANDALONE),
	WszNodeType(XML_NS),
	WszNodeType(XML_XMLSPACE),
	WszNodeType(XML_XMLLANG),
	WszNodeType(XML_SYSTEM),
	WszNodeType(XML_PUBLIC),
	WszNodeType(XML_NDATA),
	WszNodeType(XML_AT_CDATA),
	WszNodeType(XML_AT_ID),
	WszNodeType(XML_AT_IDREF),
	WszNodeType(XML_AT_IDREFS),
	WszNodeType(XML_AT_ENTITY),
	WszNodeType(XML_AT_ENTITIES),
	WszNodeType(XML_AT_NMTOKEN),
	WszNodeType(XML_AT_NMTOKENS),
	WszNodeType(XML_AT_NOTATION),
	WszNodeType(XML_AT_REQUIRED),
	WszNodeType(XML_AT_IMPLIED),
	WszNodeType(XML_AT_FIXED),
	WszNodeType(XML_PENTITYDECL),
	WszNodeType(XML_EMPTY),
	WszNodeType(XML_ANY),
	WszNodeType(XML_MIXED),
	WszNodeType(XML_SEQUENCE),
	WszNodeType(XML_CHOICE),
	WszNodeType(XML_STAR),
	WszNodeType(XML_PLUS),
	WszNodeType(XML_QUESTIONMARK),
	WszNodeType(XML_LASTSUBNODETYPE)

#pragma warning(default:4245)	//	signed/unsigned conversion

};
#endif	// DBG

inline LPCWSTR
PwszSubnodeType (DWORD dwType)
{
#ifdef	DBG

	for (UINT i = 0; i < CElems(gc_mpsnt); i++)
		if (gc_mpsnt[i].dwType == dwType)
			return gc_mpsnt[i].wszType;

#endif	// DBG

	return gc_wszUnknown;
}

//	Debugging: Events ---------------------------------------------------------
//
#ifdef	DBG
const NTM gc_mpevt[] = {

#pragma warning(disable:4245)	//	signed/unsigned conversion

	WszNodeType(XMLNF_STARTDOCUMENT),
	WszNodeType(XMLNF_STARTDTD),
	WszNodeType(XMLNF_ENDDTD),
	WszNodeType(XMLNF_STARTDTDSUBSET),
	WszNodeType(XMLNF_ENDDTDSUBSET),
	WszNodeType(XMLNF_ENDPROLOG),
	WszNodeType(XMLNF_STARTENTITY),
	WszNodeType(XMLNF_ENDENTITY),
	WszNodeType(XMLNF_ENDDOCUMENT),
	WszNodeType(XMLNF_DATAAVAILABLE)

#pragma warning(default:4245)	//	signed/unsigned conversion

};
#endif	// DBG

inline LPCWSTR
PwszEvent (DWORD dwType)
{
#ifdef	DBG

	for (UINT i = 0; i < CElems(gc_mpevt); i++)
		if (gc_mpevt[i].dwType == dwType)
			return gc_mpevt[i].wszType;

#endif	// DBG

	return gc_wszUnknown;
}

//	Error codes ---------------------------------------------------------------
//
#ifdef	DBG
const NTM gc_mpec[] = {

#pragma warning(disable:4245)	//	signed/unsigned conversion

	WszNodeType(XML_E_ENDOFINPUT),
	WszNodeType(XML_E_UNCLOSEDPI),
	WszNodeType(XML_E_MISSINGEQUALS),
	WszNodeType(XML_E_UNCLOSEDSTARTTAG),
	WszNodeType(XML_E_UNCLOSEDENDTAG),
	WszNodeType(XML_E_UNCLOSEDSTRING),
	WszNodeType(XML_E_MISSINGQUOTE),
	WszNodeType(XML_E_COMMENTSYNTAX),
	WszNodeType(XML_E_UNCLOSEDCOMMENT),
	WszNodeType(XML_E_BADSTARTNAMECHAR),
	WszNodeType(XML_E_BADNAMECHAR),
	WszNodeType(XML_E_UNCLOSEDDECL),
	WszNodeType(XML_E_BADCHARINSTRING),
	WszNodeType(XML_E_XMLDECLSYNTAX),
	WszNodeType(XML_E_BADCHARDATA),
	WszNodeType(XML_E_UNCLOSEDMARKUPDECL),
	WszNodeType(XML_E_UNCLOSEDCDATA),
	WszNodeType(XML_E_MISSINGWHITESPACE),
	WszNodeType(XML_E_BADDECLNAME),
	WszNodeType(XML_E_BADEXTERNALID),
	WszNodeType(XML_E_EXPECTINGTAGEND),
	WszNodeType(XML_E_BADCHARINDTD),
	WszNodeType(XML_E_BADELEMENTINDTD),
	WszNodeType(XML_E_BADCHARINDECL),
	WszNodeType(XML_E_MISSINGSEMICOLON),
	WszNodeType(XML_E_BADCHARINENTREF),
	WszNodeType(XML_E_UNBALANCEDPAREN),
	WszNodeType(XML_E_EXPECTINGOPENBRACKET),
	WszNodeType(XML_E_BADENDCONDSECT),
	WszNodeType(XML_E_RESERVEDNAMESPACE),
	WszNodeType(XML_E_INTERNALERROR),
	WszNodeType(XML_E_EXPECTING_VERSION),
	WszNodeType(XML_E_EXPECTING_ENCODING),
	WszNodeType(XML_E_EXPECTING_NAME),
	WszNodeType(XML_E_UNEXPECTED_WHITESPACE),
	WszNodeType(XML_E_UNEXPECTED_ATTRIBUTE),
	WszNodeType(XML_E_SUSPENDED),
	WszNodeType(XML_E_STOPPED),
	WszNodeType(XML_E_UNEXPECTEDENDTAG),
	WszNodeType(XML_E_ENDTAGMISMATCH),
	WszNodeType(XML_E_UNCLOSEDTAG),
	WszNodeType(XML_E_DUPLICATEATTRIBUTE),
	WszNodeType(XML_E_MULTIPLEROOTS),
	WszNodeType(XML_E_INVALIDATROOTLEVEL),
	WszNodeType(XML_E_BADXMLDECL),
	WszNodeType(XML_E_INVALIDENCODING),
	WszNodeType(XML_E_INVALIDSWITCH),
	WszNodeType(XML_E_MISSINGROOT),
	WszNodeType(XML_E_INCOMPLETE_ENCODING),
	WszNodeType(XML_E_EXPECTING_NDATA),
	WszNodeType(XML_E_INVALID_MODEL),
	WszNodeType(XML_E_BADCHARINMIXEDMODEL),
	WszNodeType(XML_E_MISSING_STAR),
	WszNodeType(XML_E_BADCHARINMODEL),
	WszNodeType(XML_E_MISSING_PAREN),
	WszNodeType(XML_E_INVALID_TYPE),
	WszNodeType(XML_E_INVALIDXMLSPACE),
	WszNodeType(XML_E_MULTI_ATTR_VALUE),
	WszNodeType(XML_E_INVALID_PRESENCE),
	WszNodeType(XML_E_BADCHARINENUMERATION),
	WszNodeType(XML_E_UNEXPECTEDEOF),
	WszNodeType(XML_E_BADPEREFINSUBSET),
	WszNodeType(XML_E_BADXMLCASE),
	WszNodeType(XML_E_CONDSECTINSUBSET),
	WszNodeType(XML_E_CDATAINVALID),
	WszNodeType(XML_E_INVALID_STANDALONE),
	WszNodeType(XML_E_PE_NESTING),
	WszNodeType(XML_E_UNEXPECTED_STANDALONE),
	WszNodeType(XML_E_DOCTYPE_IN_DTD),
	WszNodeType(XML_E_INVALID_CDATACLOSINGTAG),
	WszNodeType(XML_E_PIDECLSYNTAX),
	WszNodeType(XML_E_EXPECTINGCLOSEQUOTE),
	WszNodeType(XML_E_DTDELEMENT_OUTSIDE_DTD),
	WszNodeType(XML_E_DUPLICATEDOCTYPE),
	WszNodeType(XML_E_MISSING_ENTITY),
	WszNodeType(XML_E_ENTITYREF_INNAME),
	WszNodeType(XML_E_DOCTYPE_OUTSIDE_PROLOG),
	WszNodeType(XML_E_INVALID_VERSION),
	WszNodeType(XML_E_MULTIPLE_COLONS),
	WszNodeType(XML_E_INVALID_DECIMAL),
	WszNodeType(XML_E_INVALID_HEXIDECIMAL),
	WszNodeType(XML_E_INVALID_UNICODE),
	WszNodeType(XML_E_RESOURCE),
	WszNodeType(XML_E_LASTERROR)

#pragma warning(default:4245)	//	signed/unsigned conversion

};
#endif	// DBG

inline LPCWSTR
PwszErrorCode (SCODE sc)
{
#ifdef	DBG

	for (UINT i = 0; i < CElems(gc_mpec); i++)
		if (gc_mpec[i].dwType == static_cast<DWORD>(sc))
			return gc_mpec[i].wszType;

#endif	// DBG

	return gc_wszUnknown;
}

void __fastcall
XmlTraceNodeInfo (const XML_NODE_INFO * pNodeInfo)
{
#ifdef	DBG

	CStackBuffer<WCHAR,MAX_PATH> pwsz(CbSizeWsz(pNodeInfo->ulLen));
	if (NULL != pwsz.get())
    {
        wcsncpy(pwsz.get(), pNodeInfo->pwcText, pNodeInfo->ulLen);
        pwsz[pNodeInfo->ulLen] = 0;
    }
    else
	{
		XmlTrace ("XML: WARNING: not enough memory to trace\n");
		return;
	}

    //	_XML_NODE_INFO
    //
    //	typedef struct  _XML_NODE_INFO	{
    //
    //		DWORD dwType;
    //		DWORD dwSubType;
    //		BOOL fTerminal;
    //		WCHAR __RPC_FAR *pwcText;
    //		ULONG ulLen;
    //		ULONG ulNsPrefixLen;
    //		PVOID pNode;
    //		PVOID pReserved;
    //
    //	} XML_NODE_INFO;
	//
    XmlTrace ("- pNodeInfo:\n"
              "--  dwSize: %ld bytes\n"
              "--  dwType: %ws (0x%08X)\n"
              "--  dwSubType: %ws (0x%08X)\n"
              "--  fTerminal: %ld\n"
              "--  pwcText: '%ws'\n"
              "--  ulLen: %ld (0x%08X)\n"
              "--  ulNsPrefixLen: %ld (0x%08X)\n"
              "--  pNode: 0x%08X\n"
              "--  pReserved: 0x%08X\n",
              pNodeInfo->dwSize,
              PwszNodeType(pNodeInfo->dwType), pNodeInfo->dwType,
              PwszSubnodeType(pNodeInfo->dwSubType), pNodeInfo->dwSubType,
              static_cast<DWORD>(pNodeInfo->fTerminal),
              pwsz.get(),
              pNodeInfo->ulLen, pNodeInfo->ulLen,
              pNodeInfo->ulNsPrefixLen, pNodeInfo->ulNsPrefixLen,
              pNodeInfo->pNode,
              pNodeInfo->pReserved);

#endif	// DBG
}

void __fastcall
XmlTraceCountedNodeInfo (const USHORT cNumRecs, XML_NODE_INFO **apNodeInfo)
{
#ifdef	DBG

	for (USHORT iNi = 0; iNi < cNumRecs; iNi++)
		XmlTraceNodeInfo (*apNodeInfo++);

#endif	// DBG
}

//	EXO class statics ---------------------------------------------------------
//
BEGIN_INTERFACE_TABLE(CNodeFactory)
	INTERFACE_MAP(CNodeFactory, IXMLNodeFactory)
END_INTERFACE_TABLE(CNodeFactory);
EXO_GLOBAL_DATA_DECL(CNodeFactory, EXO);

//	class CNodeFactory --------------------------------------------------------
//
HRESULT STDMETHODCALLTYPE CNodeFactory::NotifyEvent(
	/* [in] */ IXMLNodeSource __RPC_FAR*,
	/* [in] */ XML_NODEFACTORY_EVENT iEvt)
{
	XmlTrace ("Xml: INodeFactory::NotifyEvent() called\n");
	XmlTrace ("- iEvt: %ws (0x%08X)\n", PwszEvent(iEvt), iEvt);

	switch (iEvt)
	{
		case XMLNF_STARTDOCUMENT:

			//	Take note that we have started processing a document
			//
			m_state = ST_PROLOGUE;
			break;

		case XMLNF_ENDPROLOG:

			//	Take note that we have completed prologue processing
			//	and are now processing the document body.
			//
			Assert (m_state == ST_PROLOGUE);
			m_state = ST_INDOC;
			break;

		case XMLNF_ENDDOCUMENT:

			//	The state should be an error or document state
			//
			m_state = ST_NODOC;
			break;

		case XMLNF_DATAAVAILABLE:

			//	More data got pushed to the XMLParser.  There is no
			//	specific action for us, but we shouldn't fail this
			//	either.
			//
			break;

		case XMLNF_STARTDTD:
		case XMLNF_ENDDTD:
		case XMLNF_STARTDTDSUBSET:
		case XMLNF_ENDDTDSUBSET:
		case XMLNF_STARTENTITY:
		case XMLNF_ENDENTITY:
		default:

			//	Unhandled notications
			//
			return E_DAV_XML_PARSE_ERROR;
	}

	return S_OK;
}

HRESULT STDMETHODCALLTYPE CNodeFactory::BeginChildren(
	/* [in] */ IXMLNodeSource __RPC_FAR*,
	/* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo)
{
	XmlTrace ("Xml: INodeFactory::BeginChildren() called\n");
	XmlTraceNodeInfo (pNodeInfo);

	//	There should be no required action in our parsing
	//	mechanism here.
	//
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CNodeFactory::EndChildren(
	/* [in] */ IXMLNodeSource __RPC_FAR*,
	/* [in] */ BOOL fEmpty,
	/* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo)
{
	XmlTrace ("Xml: INodeFactory::EndChildren() called\n");
	XmlTrace ("- fEmtpy: %ld\n", static_cast<DWORD>(fEmpty));
	XmlTraceNodeInfo (pNodeInfo);

	SCODE sc = S_OK;

	if (ST_INDOC == m_state)
	{
		//	If the node was being handled by a subclass, then
		//	pass the ::EndChildren along to the subclass.
		//
		if (m_cUnhandled == 0)
		{
			sc = ScCompleteChildren (fEmpty,
									 pNodeInfo->dwType,
									 pNodeInfo->pwcText,
									 pNodeInfo->ulLen);
			if (FAILED (sc))
				goto ret;
		}
		else
		{
			//	Otherwise pop the unhandled count
			//
			PopUnhandled();
		}

	}

ret:

	//	If there was a scope context, leave the scope.
	//
	if (pNodeInfo->pNode)
	{
		//	A ref added when we handed the object to the
		//	XMLParser.  Reclaim that ref and release the
		//	object.
		//
		auto_ref_ptr<CXmlnsScope> pscope;
		pscope.take_ownership(reinterpret_cast<CXmlnsScope*>(pNodeInfo->pNode));
		pscope->LeaveScope(this);
		pNodeInfo->pNode = NULL;
	}

	return sc;
}

HRESULT STDMETHODCALLTYPE CNodeFactory::Error(
	/* [in] */ IXMLNodeSource __RPC_FAR*,
	/* [in] */ HRESULT hrErrorCode,
	/* [in] */ USHORT cNumRecs,
	/* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo)
{
	XmlTrace ("Xml: INodeFactory::Error() called\n");
	XmlTrace ("- hrErrorCode: %ws (0x%08X)\n"
			  "- cNumRecs: %hd\n",
			  PwszErrorCode(hrErrorCode), hrErrorCode,
			  cNumRecs);

	//	Argh...
	//
	//	MSXML currently has a bug where if the error occurs whilst
	//	processing the root -- ie. a non-xml document, then ::Error()
	//	is called with a cNumRecs of 1 and a null apNodeInfo.  Oops.
	//
	if (NULL == apNodeInfo)
		return S_OK;

	//	Argh...
	//
	//	There was an error in the XML somewhere.  I don't know if
	//	this is info that would ever help the client.
	//
	XmlTraceCountedNodeInfo (cNumRecs, apNodeInfo);
	m_hrParserError = hrErrorCode;
	m_state = ST_XMLERROR;

	for (; cNumRecs--; apNodeInfo++)
	{
		//	If there was a scope context, leave the scope.
		//
		if ((*apNodeInfo)->pNode)
		{
			//	A ref added when we handed the object to the
			//	XMLParser.  Reclaim that ref and release the
			//	object.
			//
			auto_ref_ptr<CXmlnsScope> pscope;
			pscope.take_ownership(reinterpret_cast<CXmlnsScope*>((*apNodeInfo)->pNode));
			pscope->LeaveScope(this);
			(*apNodeInfo)->pNode = NULL;
		}
	}
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CNodeFactory::CreateNode(
	/* [in] */ IXMLNodeSource __RPC_FAR*,
	/* [in] */ PVOID pNodeParent,
	/* [in] */ USHORT cNumRecs,
	/* [in] */ XML_NODE_INFO __RPC_FAR **apNodeInfo)
{
	XmlTrace ("Xml: INodeFactory::CreateNode() called\n");
	XmlTrace ("- pNodeParent: 0x%08X\n"
			  "- cNumRecs: %hd\n",
			  pNodeParent,
			  cNumRecs);
	XmlTraceCountedNodeInfo (cNumRecs, apNodeInfo);

	auto_ref_ptr<CNmspc> pnsLocal;
	auto_ref_ptr<CXmlnsScope> pxmlnss;
	LPCWSTR pwcNamespaceAttributeDefault = NULL;
	LPCWSTR pwcNamespace = NULL;
	SCODE sc = S_OK;
	ULONG ulNsPrefiLenAttributeDefault = 0;
	USHORT iNi;

	//	We really do not care much about anything in the
	//	prologue.
	//
	if (ST_INDOC != m_state)
		goto ret;

	//	The processing for ::CreateNode() really is a two pass
	//	mechanism for all the nodes being created.  First, the
	//	list of nodes are scanned for namespaces and they are
	//	added to the cache.  This is required because namespace
	//	definitions for this node's scope can apear anywhere in
	//	the list of attributes.
	//
	//	Once all the namespaces have been processed, the subclass
	//	is called for each node -- with the expanded names for
	//	both XML_ELEMENTS and XML_ATTRIBUTES
	//
	for (iNi = 0; iNi < cNumRecs; iNi++)
	{
		if (XML_NS == apNodeInfo[iNi]->dwSubType)
		{
			//	This should always be the case.  The enumeration
			//	that defines the subtypes picks up where the node
			//	types left off.
			//
			Assert (XML_ATTRIBUTE == apNodeInfo[iNi]->dwType);
			//
			//	However, handle this case -- just in case...
			//
			if (XML_ATTRIBUTE != apNodeInfo[iNi]->dwType)
				continue;

			//	Since we are about to create some namespaces that
			//	are scoped by this node, create a scoping object
			//	and set it into the node info.
			//
			//	When we hand this back to those wacky XML guys, we
			//	need to keep our reference so the object lives beyond
			//	the current instance.  It gets cleaned up in response
			//	to ::Error() or ::EndChildren() calls.
			//
			if (NULL == pxmlnss.get())
			{
				pxmlnss.take_ownership(new CXmlnsScope);
				if (NULL == pxmlnss.get())
				{
					sc = E_OUTOFMEMORY;
					goto ret;
				}
			}

			//	Ok, we have a namespace, and need to construct and
			//	cache it.
			//
			//	If this is a default namespace -- ie. one that does
			//	not have an alias associated with its use -- then
			//	the length of the namespace prefix should be zero.
			//
			auto_ref_ptr<CNmspc> pns;
			pns.take_ownership(new CNmspc());
			if (NULL == pns.get())
			{
				sc = E_OUTOFMEMORY;
				goto ret;
			}
			if (0 == apNodeInfo[iNi]->ulNsPrefixLen)
			{
				//	Set the empty alias
				//
				Assert (CchConstString(gc_wszXmlns) == apNodeInfo[iNi]->ulLen);
				Assert (!wcsncmp (apNodeInfo[iNi]->pwcText, gc_wszXmlns, CchConstString(gc_wszXmlns)));
				sc = pns->ScSetAlias (apNodeInfo[iNi]->pwcText, 0);
				if (FAILED (sc))
					goto ret;
			}
			else
			{
				UINT cch = apNodeInfo[iNi]->ulLen - apNodeInfo[iNi]->ulNsPrefixLen - 1;
				LPCWSTR pwsz = apNodeInfo[iNi]->pwcText + apNodeInfo[iNi]->ulLen - cch;

				//	The alias for this namespace is the text following
				//	the single colon in the namespace decl.
				//
				Assert (CchConstString(gc_wszXmlns) < apNodeInfo[iNi]->ulLen);
				Assert (!wcsncmp (apNodeInfo[iNi]->pwcText, gc_wszXmlns, CchConstString(gc_wszXmlns)));
				Assert (L':' == *(apNodeInfo[iNi]->pwcText + CchConstString(gc_wszXmlns)));
				sc = pns->ScSetAlias (pwsz, cch);
				if (FAILED (sc))
					goto ret;
			}

			//	Now assemble the href.  The href is defined by the next N
			//	consecutive nodes of type XML_PCDATA.
			//
			while (++iNi < cNumRecs)
			{
				if (XML_PCDATA != apNodeInfo[iNi]->dwType)
					break;

				if (-1 == m_sbValue.Append(apNodeInfo[iNi]->ulLen * sizeof(WCHAR),
										   apNodeInfo[iNi]->pwcText))
				{
					sc = E_OUTOFMEMORY;
					goto ret;
				}
			}

			//	At this point, we have hit the end of this current namespace
			//	declaration and can set the href into the namespace.
			//
			sc = pns->ScSetHref (m_sbValue.PContents(), m_sbValue.CchSize());
			if (FAILED (sc))
				goto ret;

			m_sbValue.Reset();

			//	The namespace has been completed, so we should cache it
			//	at this point; and clear the namespace in construction.
			//
			Assert (pns.get());
			Assert (pns->PszHref() && pns->PszAlias());
			CachePersisted (pns);

			//	Make sure the scoping for this namespace is handled.
			//
			Assert (pxmlnss.get());
			pxmlnss->ScopeNamespace (pns.get());

			//	Ok, if we simply move on to the next node, then we will skip the
			//	node that brought us out of the namespace processing.
			//
			iNi--;
		}
	}

	//	Now that we have all the namespaces taken care of, call the subclass
	//	for each of the nodes.
	//
	for (iNi = 0; iNi < cNumRecs; iNi++)
	{
		LPCWSTR pwcText = apNodeInfo[iNi]->pwcText;
		ULONG ulLen = apNodeInfo[iNi]->ulLen;
		ULONG ulNsPrefixLen = apNodeInfo[iNi]->ulNsPrefixLen;

		switch (apNodeInfo[iNi]->dwType)
		{
			case XML_ATTRIBUTE:
			case XML_ELEMENT:

				//	For both XML_ELEMENTs and XML_ATTRIBUTEs, we want to
				//	do the namespace translation and hand the subclass the
				//	fully qualified name!  The only exception to this would
				//	be for the special node and element subtypes.
				//
				if (0 == apNodeInfo[iNi]->dwSubType)
				{
					//	For attributes, if there was no translation, then we
					//	want to use this node's namespace for defaulting the
					//	attribute namespaces.
					//
					if ((XML_ATTRIBUTE == apNodeInfo[iNi]->dwType) &&
						(0 == apNodeInfo[iNi]->ulNsPrefixLen))
					{
						pwcNamespace = pwcNamespaceAttributeDefault;
						ulNsPrefixLen = ulNsPrefiLenAttributeDefault;
					}
					else
					{
						//	Otherwise try and translate...
						//
						sc = TranslateToken (&pwcText,
											 &ulLen,
											 &pwcNamespace,
											 &ulNsPrefixLen);
					}

					//	For elements, if there was no translation and there
					//	is a current default namespace declaired for this xml
					//	this document, this is invalid xml.
					//
					Assert (!FAILED (sc));
					if (S_FALSE == sc)
					{
						XmlTrace ("Xml: element has no valid namespace\n");
						sc = E_DAV_XML_PARSE_ERROR;
						goto ret;
					}

					//	Check for an empty property name.  An empty property name
					//  is invalid.  ulLen is the size of the property name with
					//  the prefix stripped.  ***
					//
					if (0 == ulLen)
					{
						XmlTrace("Xml:  property has noname\n");
						sc = E_DAV_XML_PARSE_ERROR;
						goto ret;
					}
				}

				//	Handle empty tags here -- ie. all namespace!
				//
				if (0 == apNodeInfo[iNi]->ulLen)
				{
					XmlTrace ("Xml: element has no valid tag\n");
					sc = E_DAV_XML_PARSE_ERROR;
				}

				//	If this is the first node in the list, then set the defaults
				//
				if (0 == iNi)
				{
					pwcNamespaceAttributeDefault = pwcNamespace;
					ulNsPrefiLenAttributeDefault = ulNsPrefixLen;
				}

				/* !!! FALL THROUGH !!! */

			case XML_PI:
			case XML_XMLDECL:
			case XML_DOCTYPE:
			case XML_DTDATTRIBUTE:
			case XML_ENTITYDECL:
			case XML_ELEMENTDECL:
			case XML_ATTLISTDECL:
			case XML_NOTATION:
			case XML_GROUP:
			case XML_INCLUDESECT:
			case XML_PCDATA:
			case XML_CDATA:
			case XML_IGNORESECT:
			case XML_COMMENT:
			case XML_ENTITYREF:
			case XML_WHITESPACE:
			case XML_NAME:
			case XML_NMTOKEN:
			case XML_STRING:
			case XML_PEREF:
			case XML_MODEL:
			case XML_ATTDEF:
			case XML_ATTTYPE:
			case XML_ATTPRESENCE:
			case XML_DTDSUBSET:
			default:
			{
				//	If we are currently in a state where the subclass has chosen
				//	not to handle a node (and subsequently its children), then we
				//	do not want to even bother the subclass.
				//
				//$	REVIEW:
				//
				//	We do not cut this off earlier such that we can process and
				//	know the namespaces of the unhandled nodes.  Otherwise we cannot
				//	do any XML validation of the unhandled nodes.
				//
				if (0 == m_cUnhandled)
				{
					//	Call the subclass
					//	Note that we don't need to call subclass if the it's a XML_NS node,
					//	because we've handled all the namespaces.
					//
					Assert (pwcNamespace ||
							(0 == apNodeInfo[iNi]->ulNsPrefixLen) ||
						    (apNodeInfo[iNi]->dwSubType == XML_NS));

					//	If we see a sub type of XML_NS, this must be a XML_ATTRIBUTE
					//
					Assert ((apNodeInfo[iNi]->dwSubType != XML_NS) ||
							(apNodeInfo[iNi]->dwType == XML_ATTRIBUTE));

					sc = ScHandleNode (apNodeInfo[iNi]->dwType,
									   apNodeInfo[iNi]->dwSubType,
									   apNodeInfo[iNi]->fTerminal,
									   pwcText,
									   ulLen,
									   ulNsPrefixLen,
									   pwcNamespace,
									 